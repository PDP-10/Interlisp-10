
                  TTYIN  a display typein editor

Filed on: <lispusers>ttyin.press
Last edited: June 18, 1982 by Bill van Melle

TTYIN is an Interlisp function to read input from the terminal.  It
features altmode completion, spelling correction, help facility,
and fancy editing, and can also serve as a glorified free text
input function.  This document is divided into two major sections:
how to use TTYIN from the user's point of view, and from the
programmer's.

TTYIN exists in implementations for Interlisp-10 and Interlisp-D.
The two are substantially compatible, but the capabilities of the
two systems differ (Interlisp-D has a more powerful display and
allows greater access to the system primitives needed to control it
effectively; it also has a mouse, greatly reducing the need for
keyboard-oriented editing commands).  Descriptions of both are
included in this document for completeness, but Interlisp-D users
may find large sections irrelevant.

Entering input with TTYIN

There are two major ways of using TTYIN: as your LISPXREADFN, i.e.,
the function LISPX executive uses to obtain input, and as a general
function for a program to gather text input.  Mostly the same rules
apply to both; places where it makes a difference are mentioned
below.

The following characters may be used to edit your input,
independent of what kind of terminal you are on.  The more TTYIN
knows about your terminal, of course, the nicer some of these will
behave.  Some functions are performed by one of several characters;
any character that you happen to have assigned as an interrupt
character will, of  couse, not be read by TTYIN.  There is a
(somewhat inelegant) way of changing which characters perform which
functions, described under TTYINREADMACROS later on.

    ^A, BS, DELETE  deletes a character.  At the start of the
       second or subsequent lines of your input, deletes the last
       character of the previous line.

    ^W  deletes a word''.  Generally this means back to the
       last space or parenthesis.

    ^Q (^U for Tops20 users)  deletes the current line, or if the
       current line is blank, deletes the previous line.

    ^R  refreshes the current line.  Two in a row refreshes the
       whole buffer (when doing multi-line input).

    ESCAPE  tries to complete the current word from the spelling
       list provided to TTYIN, if any.  In the case of ambiguity,
       completes as far as is uniquely determined, or rings the
       bell.  For LISPX input, the spelling list may be USERWORDS
       (see discussion of TTYINCOMPLETEFLG).  [Interlisp-10 only:]
        If no spelling list was provided, but the word begins with
       a <'', tries directory name completion (or filename
       completion if there is already a matching >'' in the
       current word).

    ?  if typed in the middle of a word will supply alternative
       completions from splst (if any).  ?ACTIVATEFLG must be true
       to enable this feature.

    ^F  [Sumex, Tops20 only] invokes GTJFN for filename
       completion on the current word''.

    ^Y  escapes to a Lisp userexec, from which you may return by
       the command OK.  However, when in READ mode and the buffer
       is non-empty, ^Y is treated as Lisp's unquote macro
       instead, so you have to use edit-^Y (below) to invoke the
       userexec.

    <middle-blank> in Interlisp-D, LF in Interlisp-10  retrieves
       characters from the previous non-empty buffer when it is
       able to; e.g., when typed at the beginning of the line this
       command restores the previous line you typed at TTYIN; when
       typed in the middle of a line fills in the remaining text
       from the old line; when typed following ^Q or ^W restores
       what those commands erased.

    ;   if typed as the first character of the line means the
       line is a comment; it is ignored, and TTYIN loops back for
       more input.

    ^X  goes to the end of your input (or end of expression if
       there is an excess right parenthesis) and returns if
       parentheses are balanced, beeps if not.  Currently
       implemented  in Interlisp-D only.

During most kinds of input, TTYIN is in autofill'' mode: if a
space is typed near the right margin, a <cr> is simulated to start
a new line.  In fact, on cursor-addressable displays, lines are
always broken, if possible, so that no word straddles the end of
the line.  The pseudo-<cr>'' ending the line is still read as a
space, however; i.e., the program keeps track of whether a line
ends in a <cr> or is merely broken at some convenient pointyou
won't get <cr>'s in your strings unless you explicitly type them.


Mouse commands [Interlisp-D only]

The mouse buttons are interpreted as follows during TTYIN input:


 LEFTmoves caret to where the cursor is pointing.  As you hold
    down LEFT, caret moves around with the cursor; after you let
    up, any typein will be inserted at the new position.
 MIDDLElike LEFT, but moves only to word boundaries.
 RIGHTdeletes text from the caret to the cursor, either forward
    or backward.  While you hold down RIGHT, the text to be
    deleted is complemented; when you let up, the text actually
    goes away.  If you let up outside the scope of the text,
    nothing is killed (this is how to cancel'' the command).
    This is roughly the same as CTRL-RIGHT with no initial
    selection (below).  

If you hold down CTRL and/or SHIFT while pressing the mouse
buttons, you instead get secondary selection, move selection or
delete selection, roughly as in the Laurel editor.  You make a
selection by bugging LEFT (to select a character) or MIDDLE (to
select a word), and optionally extend the selection either left or
right using RIGHT.  While you are doing this, the caret does not
move, but your selected text is highlighted in a manner indicating
what is about to happen.  When you have made your selection (all
mouse buttons up now), lift up on CTRL and/or SHIFT and the action
you have selected will occur, which is:
    SHIFTinsert the selected text as typein at the caret.  The
       text is highlighted with a broken underline during
       selection.
    CTRLdelete the selected text.  The text is complemented
       during selection.
    CTRL-SHIFTcombines the above: delete the selected text and
       insert it at the caret.  This is how you move text about.

You can cancel a selection in progress by pressing LEFT or MIDDLE
as if to select, and moving outside the range of the text.

The most recent text deleted by mouse command can be inserted at
the caret by typing <middle-blank> (the same key that retrieves the
previous buffer when issued at the end of a line).


Display editing commands

On edit-key terminals (Datamedia):  In Interlisp-10, TTYIN reads
from the terminal in binary mode, allowing many more editing
commands via the edit key, in the style of TVEDIT commands.  Note
that due to Tenex's unfortunate way of handling typeahead, it is
not possible to type ahead edit commands before TTYIN has started
(i.e., before its prompt appears), because the edit bit will be
thrown away. Also, since Escape has numerous other meanings in Lisp
and even in TTYIN (for completion), Escape is not used as a
substitute for the edit key.

On edit-keyless display terminals (Heath, Interlisp-D display):  If
you want to type any of these commands, you need to prefix them
with the edit prefix'' character.  Set the variable
EDITPREFIXCHAR to the character code of the desired prefix char.
In Interlisp-D, this is already set to be <top-blank>.  Type the
edit prefix twice to give an edit-Escape'' command.  Some users
of the TENEX TVEDIT program like to make Escape (33Q) be the edit
prefix, but this makes it somewhat awkward to ever use escape
completion.  Interlisp-D users will probably have little use for
most of these commands, as cursor positioning can often be done
more conveniently, and certainly more obviously, with the mouse.
In the Wind'' version of Interlisp-D (not yet released), just
perform (TTYINMETA T), and you can then use <bottom-blank> as a
meta (edit) key.

On edit-keyless hardcopy terminals:  You probably want to ignore
this section, since you won't be able to see what's going on when
you issure edit commands; there is no attempt made to echo anything
reasonable.

In the descriptions below, current word'' means the word the
cursor is under, or if under a space, the previous word.  Currently
parentheses are treated as spaces, which is usually what you want,
but can occasionally cause confusion in the word deletion commands.
 The notation [char] means edit-char, if you have an edit key, or
<editprefixchar> char if you don't; $ = escape.  Most commands can
be preceded by numbers or escape (infinity), only the first of
which requires the edit key (or the edit prefix).  Some commands
also accept negative arguments, but some only look at the magnitude
of the arg.  Most of these commands are taken from the display
editors TVEDIT and/or E, and are confined to work within one line
of text unless otherwise noted. 
 Cursor movement
 [delete], [bs], [<] back up one (or n) characters.
 [space], [>] move forward one (or n) characters.
 [^] moves up one (or n) lines.
 [lf] moves down one (or n) lines.
 [(] move back one (or n) words.
 [)] move ahead one (or n) words.
 [tab] moves to end of line; with an argument moves to nth end of
    line; [$tab] goes to end of buffer.
 [^L] moves to start of line (or nth previous, or start of
    buffer).
 [{] and [}] go to start and end of buffer, respectively (like
    [$^L] and [$tab]).
 [[] (i.e. edit-left-bracket) Moves to beginning of the current
    list, where cursor is currently under an element of that list
    or its closing paren.  (See also the auto-parenthesis-matching
    feature below under Flags''.)
 []] Moves to end of current list.
 [Sx] skips ahead to next (or nth) occurrence of character x, or
    rings the bell.
 [Bx] is a backward search, i.e., short for [S] or [nS].
 Buffer modification
 [Zx] Zaps characters from cursor to next (or nth) occurrence of
    x.  There is no unzap command yet.
 [A] (or [R] for E hackers) repeat the last S, B or Z command,
    regardless of any intervening input (note this differs from
    Tvedit's A command).
 [K] kills the character under the cursor, or n chars starting at
    the cursor.
 [I] begin inserting.  Exit insert with any edit command.
    Characters you type will be inserted, rather than overwriting
    the existing text.  If EMACSFLG is true (default in
    Interlisp-D), you are always in insert mode, and this command
    is a noop.
    Inserting <cr> behaves slightly different from in tvedit; the
    sequence [I<cr>] behaves as in TVEDIT  it inserts a blank
    line ahead of the cursor; <cr> typed any other time while in
    insert mode actually inserts a <cr>, behaving somewhat like
    TVEDIT's [B].  [$I] is the same as [I<cr>].
 [cr] when the buffer is empty is the same as <lf>, i.e. restores
    buffer's previous contents.  Otherwise is just like a <cr>
    (except that it also terminates an insert).  Thus, [<cr><cr>]
    will repeat the previous input (as will <lf><cr> without the
    edit key).
 [O] does Open line'', inserting a crlf after the cursor, i.e.,
    it breaks the line but leaves the cursor where it is.
 [T] transposes the characters before and after the cursor.  When
    typed at the end of a line, transposes the previous two
    characters.  Refuses to handle funny cases, such as tabs.
 [G] grabs the contents of the previous line from the cursor
    position onward.  [nG] grabs the nth previous line.
 [L] lowercases current word, or n words on line.  [$L] lowercases
    the rest of the line, or if given at the end of line
    lowercases the entire line.
 [U] uppercases analogously.
 [C] capitalize.  If you give it an argument, only the first word
    is capitalized; the rest are just lowercased.
 [^Q] deletes the current line.  [$^Q] deletes from the current
    cursor position to the end of the buffer.  No other arguments
    are handled.  This is all slightly inconsistent; suggestions
    for better interpretations are welcome.
 [^W] deletes the current word, or the previous word if sitting on
    a space.
 [D<del>] and [D<cr>] are [^W] and [^Q] for approximate
    compatibility with TVEDIT.
 [J] Justify'' this line, defined as breaking it if it is too
    long, or moving words up from the next line if too short.
    Will not join to an empty line, or one starting with a tab
    (both of which are interpreted as paragraph breaks).  Any new
    line breaks it introduces are considered spaces, not carriage
    returns.  [nJ] justifies n lines.  Linelength is defined as
    TTYJUSTLENGTH, ignoring any prompt characters at the margin.
    If TTYJUSTLENGTH is negative, it is interpreted as relative to
    the right margin.  TTYJUSTLENGTH is initially 8 in
    Interlisp-D, 72 in Interlisp-10.
 [$F] Finishes'' the input, regardless of where the cursor is.
    Specifically, it goes to the end of the input and enters a
    <cr>, ^Z or ]'', depending on whether normal, REPEAT or READ
    input is happening.  Note that a ]'' won't necessarily end a
    READ, but it seems likely to in most cases where you would be
    inclined to use this command, and makes for more predictable
    behavior.
 Miscellaneous
 [P] Prettyprint buffer  clears buffer and reprints it using
    prettyprint.  If there are not enough right parentheses, it
    will supply more; if there are too many, any excess remains
    unprettyprinted at the end of the buffer.  May refuse to do
    anything if there is an unclosed string or other error trying
    to read the buffer.  Not implemented yet in Interlisp-10.
 [N] Refresh line  same as ^R.  [$N] refreshes the whole buffer;
    [nN] refreshes n lines.  Cursor movement in TTYIN depends on
    TTYIN being the only source of output to the screen; if you do
    a ^T, or a system message appears, or line noise occurs, you
    may need to refresh the line for best results.  In
    Interlisp-10, if for some reason your terminal falls out of
    binary mode (e.g. can happen when returning to a Lisp running
    in a lower fork), Edit-<anything> is unreadable, so you'd have
    to type ^R instead.
 [^Y] gets userexec.  Thus, this is like regular ^Y, except when
    doing a READ (when ^Y is a read macro and hence does not
    invoke this function).
 [$^Y] gets a userexec, but first unreads the contents of the
    buffer from the cursor onward.  Thus if you typed at TTYIN
    something destined for the Lisp executive, you can do [^L$^Y]
    and give it to Lisp.
 [_] adds current word to spelling list USERWORDS.  With zero arg,
    removes word.  See TTYINCOMPLETEFLG discussion below.

Note to Datamedia, Heath users:  In addition to simple cursor
movement commands and insert/delete, TTYIN uses the display's
cursor-addressing capability to optimize cursor movements longer
than a few characters, e.g. [tab] to go to the end of the line.  In
order to be able to address the cursor, TTYIN has to know where it
is to begin with.  Lisp keeps track of the current print position
within the line, but does not keep track of the line on the screen
(in fact, it knows precious little about displays, much like
Tenex).  Thus, TTYIN establishes where it is by forcing the cursor
to appear on the last line of the screen.  Ordinarily this is the
case anyway (except possibly on startup), but if the cursor happens
to be only halfway down the screen at the time, there is a possibly
unsettling leap of the cursor when TTYIN starts. 

Further comments on using TTYIN for Lisp input

When TTYIN is loaded, or a sysout containing TTYIN is started up,
the function (SETREADFN) is called.  If the terminal is a display,
it sets LISPXREADFN to be TTYINREAD; if the terminal is
non-display, SETREADFN will set the variable back to READ.
(SETREADFN 'READ) will also set it back to READ.

There are two principal differences between TTYINREAD and Lisp
READ: (1) parenthesis balancing.  The input does not activate on an
exactly balancing right paren/bracket unless the input started with
a paren/bracket, e.g., USE (FOO) FOR (FIE)'' will all be on one
line, terminated by <cr>; and (2) read macros.  In Interlisp-10,
TTYIN does not use a read table (TTYIN behaves as though using the
default initial Lisp terminal input readtable), so read macros and
redefinition of syntax characters are not supported; however,  '
'' (QUOTE) and ^Y'' (EVAL) are built in, and a simple
implementation of ? and ?= is supplied.  Also, the TTYINREADMACROS
facility described below can supply some of the functionality of
immediate read macros in the editor.  In Interlisp-D, read macros
are (mostly) supported.  Immediate read macros take effect only if
typed at the end of the input (it's not clear what their semantics
should be elsewhere).

Useful macros

There are two useful edit macros that allow you to use TTYIN as a
character editor: (1) ED loads the current expression into the
ttyin buffer to be edited (this is good for editing comments and
strings).  Input is terminated in the usual way (by typing a
balancing right parenthesis at the end of the input, typing <cr> at
the end of an already balanced expression, or ^X anywhere inside
the balanced expression). ^E or clearing the buffer aborts ED.  (2)
EE is like ED but prettyprints the expression into the buffer, and
uses its own window.  The variable TTYINEDITPROMPT controls what
prompt, if any, EE uses; see prompt argument description in next
section (the initial setting is no prompt).  EE is not yet
implemented in Interlisp-10.

The macro BUF loads the current expression into the buffer,
preceded by E, to be used as input however desired; as a trivial
example, to evaluate the current expression, BUF followed by a <cr>
to activate the buffer will perform roughly what the edit macro
EVAL does.  Of course, you can edit the E to something else to make
it an edit command.

BUF is also defined at the Evalqt level as a LISPXHISTORYMACRO that
loads the buffer with the VALUEOF the indicated event, to be edited
as desired.

TV is a Lispxmacro like EV [EDITV] that performs an ED on the value
of the variable.

And finally, if the event is considered short'' enough, the
Programmer's Assistant command FIX will load the buffer with the
event's input, rather than calling the editor.  If you really
wanted the Interlisp editor for your fix, you could either say FIX
event - TTY:, or type ^U (or whatever on tops20) once you got
TTYIN's version to force you into the editor.


Programming with TTYIN

(TTYIN prompt splst help options file tabstops unreadbuf rdtbl)

TTYIN prints prompt, then waits for input.  The value returned in
the normal case is a list of all atoms on the line, with comma and
parens returned as individual atoms; options may be used to get a
different kind of value back.

 Prompt is an atom or string (anything else is stringified first).
    If NIL, the value of DEFAULTPROMPT, initially ** '', will be
    used. If T, no prompt will be given.  prompt may also be a
    dotted pair (prompt1 . prompt2), giving the prompt for the
    first and subsequent (or overflow) lines, each prompt being a
    string/atom or NIL to denote absence of prompt.  Note that
    rebinding DEFAULTPROMPT gives a convenient way to affect all
    the ordinary'' prompts in some program module.

 Splst is a spelling list, i.e., a list of atoms or dotted pairs
    (synonym . root). If supplied, it is used to check and correct
    user responses, and to provide completion if the user types
    Escape.  If splst is one of the Lisp system spelling lists
    (e.g., USERWORDS or SPELLINGS3), words that are
    escape-completed get moved to the front, just as if a FIXSPELL
    had found them.  Autocompletion is also performed when user
    types a break character (cr, space, paren, etc), unless one of
    the nofixspell'' options below is selected; i.e., if the
    word just typed would uniquely complete by Escape, TTYIN
    behaves as though Escape had been typed.

 Help, if non-NIL, determines what happens when the user types ?
    or HELP. If help = T, program prints back splst in suitable
    form.  If help is any other atom, or a string containing no
    spaces, it performs  (DISPLAYHELP help).  Anything else is
    printed as is.  If help is NIL, ? and HELP are treated as any
    other atoms the user types. [DISPLAYHELP is a user-supplied
    function, initially a noop; systems with a suitable HASH
    package, for example, have defined it to display a piece of
    text from a hashfile associated with the key help.] 

 Options is an atom or list of atoms chosen from among the
    following:

    NOFIXSPELLuses splst for help and Escape completion, but does
       not attempt any FIXSPELLing.  Mainly useful if splst is
       incomplete and the caller wants to handle corrections in a
       more flexible way than a straight FIXSPELL.

    MUSTAPPROVEdoes spelling correction, but requires
       confirmation.

    CRCOMPLETErequires confirmation on spelling correction, but
       also does autocompletion on <cr> (i.e. if what user has
       typed so far uniquely identifies a member of splst,
       completes it).  This allows you to have the benefits of
       autocompletion and still allow new words to be typed.

    DIRECTORY(only if splst=NIL) interprets Escape to mean
       directory name completion [Interlisp-10 only].

    USERlike DIRECTORY, but does username completion.  This is
       identical to DIRECTORY under Tenex [Interlisp-10 only].

    FILE(only if splst=NIL) interprets Escape to mean filename
       completion, i.e. does a GTJFN [Sumex and Tops20 only].

    FIXif response is not on, or does not correct to, splst,
       interacts with user until an acceptable response is
       entered.  A blank line (returning NIL) is always accepted.
       Note that if you are willing to accept responses that are
       not on splst, you probably should specify one of the
       options NOXFISPELL, MUSTAPPROVE or CRCOMPLETE, lest the
       user's new response get fixspelled away without her
       approval.

    STRINGline is read as a string, rather than list of atoms.
       Good for free text.

    NORAISEdoes not convert lower case letters to upper case.

    NOVALUEfor use principally with file arg (below).  Does not
       compute a value, but returns T if user typed anything, NIL
       if just a blank line.

    REPEATfor multi-line input.  Repeatedly prompts until user
       types ^Z (as in Tenex sndmsg).  Returns one long list; with
       STRING option returns a single string of everything typed,
       with carriage returns (EOL) included in the string.

    TEXTimplies REPEAT NORAISE NOVALUE.  Additionally, input may
       be terminated with ^V, in which case the global flag
       CTRLVFLG will be set true (it is set to NIL on any other
       termination). This flag may be utilized in any way the
       caller desires.

    COMMANDonly the first word on the line is treated as
       belonging to splst, the remainder of the line being
       arbitrary text; i.e., command format''.  If other options
       are supplied, COMMAND still applies to the first word
       typed.  Basically, it always returns (cmd . rest-of-input),
       where rest-of-input is whatever the other options dictate
       for the remainder.  E.g. COMMAND NOVALUE returns (cmd) or
       (cmd . T), depending on whether there was further input;
       COMMAND STRING returns (command . rest of input'').  When
       used with REPEAT, COMMAND is only in effect for the first
       line typed; furthermore, if the first line consists solely
       of a command, the REPEAT is ignored, i.e., the entire input
       is taken to be just the command.

    READparens, brackets, and quotes are treated a la READ,
       rather than being returned as individual atoms.  Control
       characters may be input via the ^Vx notation.  Input is
       terminated roughly along the lines of Lisp READ
       conventions:  a balancing or over-balancing right
       paren/bracket will activate the input, or <cr> when no
       parenthesis remains unbalanced.  READ overrides all other
       options (except NORAISE).

    LISPXREADlike READ, but implies that TTYIN should behave even
       more like a Lisp READ, i.e., do NORAISE, not be
       errorset-protected, etc.

    NOPROMPTthe prompt argument is treated as usual, except that
       TTYIN assumes that the prompt for the first line has
       already been printed by the caller; the prompt for the
       first line is thus used only when redisplaying the line.
       Interlisp-D only.

 Fileif specified, user's input is copied to this file, i.e.,
    TTYIN can be used as a simple text-to-file routine if NOVALUE
    is used.  If file is a list, copies to all files in the list.
    Prompt is not included on the file.

 Tabstopsspecial addition for tabular input.  Is list of tabstops
    (numbers).  When user types a tab, TTYIN automatically spaces
    over to the next tabstop (thus the first tabstop is actually
    the second column'' of input).  Also treats specially the
    characters * and "  they echo normally, and then
    automatically tab over.

 Unreadbufallows caller to preload'' the TTYIN buffer with a
    line of input.  Unreadbuf is a list, the elements of which are
    unread into the buffer (i.e., the outer parentheses are
    stripped off'') to be edited further as desired; a simple <cr>
    (or ^Z for REPEAT input) will thus cause the buffer's contents
    to be returned unchanged.  If doing READ input, the prin2
    pnames'' of the input list are used, i.e., quotes and %'s will
    appear as needed; otherwise the buffer will look as though
    Unreadbuf had been PRIN1'ed.  Unreadbuf is treated somewhat
    like Lisp's READBUF, so that if it contains a pseudo-cr (the
    value of HISTSTR0), the input line terminates there.

    Input can also be unread from a file, using the histstr1
    format: Unreadbuf = (<value of HISTSTR1> (file start . end)),
    where start and end are file byte pointers.  This makes TTYIN
    a miniature text file editor.

 Rdtbl[Interlisp-D only] the read table to use for READing the
    input when one of the READ options is given.  A lot of
    character interpretations are hardwired into TTYIN, so
    currently the only effect this has is in the actual READ, and
    in deciding whether a character typed at the end of the input
    is an immediate read macro, for purposes of termination.

If the global variable TYPEAHEADFLG is T, or option LISPXREAD is
given, TTYIN permits type-ahead; otherwise it clears the buffer
before prompting the user.

                        More hairy details

EE Interface

The following may be useful as a way of outsiders to call TTYIN as
an editor.  These functions are currently only in Interlisp-D.

(TTYINEDIT exprs window unpretty)

    This is the body of EE.  Switches the tty to window, clears
    it, prettyprints exprs, a list of expressions, into it, and
    leaves you in TTYIN to edit it as Lisp input.  Returns a new
    list of expressions.  If TTYINAUTOCLOSEFLG is true, closes the
    window on exit.  If window is NIL, uses the value of
    TTYINEDITWINDOW, creating it if it does not yet exist.  If
    unpretty is non-NIL, does not prettyprint.

(SET.TTYINEDIT.WINDOW window)

    Called under a RESETLST.  Switches the tty to window
    (defaulted as above) and clears it.  The window's position is
    left so that TTYIN will be happy with it if you now call TTYIN
    yourself.  Specifically, this means positioning an integral
    number of lines from the bottom of the window, the way the
    top-level tty window normally is.

(TTYIN.SCRATCHFILE)

    Returns, possibly creating, the scratchfile that TTYIN uses
    for prettyprinting its input.  The file pointer is set to
    zero.  Since TTYIN does use this file, beware of multiple
    simultaneous use of the file.

Read Macros

When doing READ input in Interlisp-10, no Lisp-style read macros
are available (but the ' and ^Y macros are built in).  Principally
because of the usefulness of the editor read macros (set by Lisp's
SETTERMCHARS), and the desire for a way of changing the meanings of
the display editing commands, the following exists as a hack:

 TTYINREADMACROS  this is a set of shorthand inputs useable
    during READ input.  It is an alist of entries (charcode .
    synonym).  If the user types the indicated char (edit bit is
    denoted by the 200Q bit in charcode), TTYIN behaves as though
    the synonym character had been typed.  Special cases: 0  the
    character is ignored; 200Q  pure Edit bit; means to read
    another char and turn on its edit bit; 400Q  macro quote:
    read another char and use its original meaning. E.g. if you
    have macros ((33Q . 200Q) (30Q . 33Q)), then Escape (33Q) will
    behave as an edit prefix, and ^X (30Q) will behave like
    Escape.  Note: currently, synonyms for edit commands are not
    well-supported, working only when the command is typed with no
    argument. 

    Slightly more powerful macros also can be supplied; they are
    recognized when a character is typed on an empty line, i.e.,
    as the first thing after the prompt.  In this case, the
    TTYINREADMACROS entry is of the form (charcode T . response)
    or (charcode condition . response), where condition is a List
    that evaluates true.  If response'' is a list, it is EVALed;
    otherwise it is left unevaluated.  The result of this
    evaluation (or response itself) is treated as follows:

    NIL  the macro is ignored and the character reads normally,
       i.e., as though TTYINREADMACROS had never existed.

    An integer  a character code, treated as above.  Special
       case: 1 is treated like 0, but says that the display may
       have been altered in the  evaluation of the macro, so TTYIN
       should reset itself appropriately.

    Anything else   this TTYIN input is terminated (with a crlf)
       and returns the value of response'' (turned into a list
       if necessary).  This is the principal use of this facility
        the macro character thus stands for the (possibly
       computed) reponse, terminated if necessary with a crlf.
       The original character is not echoed.

Interrupt characters, of course, cannot be read macros, as TTYIN
never sees them, but any other characters, even non-control chars,
are allowed.  The ability to return NIL allows you to have
conditional macros that only apply in specified situations (e.g.,
the macro might check the prompt (LISPXID) or other contextual
variables).  To use this specifically to do immediate editor read
macros, do the following for each edit command and character you
want to invoke it with:

  (ADDTOVAR TTYINREADMACROS (character-code 'CHARMACRO? editcom)))

For example, (ADDTOVAR TTYINREADMACROS (12Q CHARMACRO? NXP)) to
make linefeed do the NXP command.  Note that this will only
activate linefeed at the beginning of a line, not anywhere in the
line.  There will probably be a user function to do this in the
next release.

Note that putting (12Q T . NXP) on TTYINREADMACROS would also have
the effect of returning NXP'' from the READ call so that the
editor would do an NXP; however, TTYIN would also return NXP
outside the editor (probably resulting in a u.b.a. error, or
convincing dwim to enter the editor), and also the clearing of the
output buffer (performed by CHARMACRO?) would not happen.

Assorted flags

These flags control aspects of TTYIN's behavior.  Some have already
been mentioned.  Their initial values are all NIL.  In Interlisp-D,
the flags are all initially T.

 TYPEAHEADFLG  if true, TTYIN always permits typeahead; otherwise
    it clears the buffer for any but LISPXREAD input.

 ?ACTIVATEFLG  if true, enables the feature whereby ? lists
    alternative completions from the current spelling list.

 EMACSFLG  affects display editing.  When true, TTYIN tries to
    behave a little more like EMACS (in very simple ways) than
    TVEDIT. Specifically, it has the following effects currently:
    (1) all non-edit characters self-insert (i.e. behave as if
    you're always in Insert mode); (2) [D] is the EMACS delete to
    end of word command.

 SHOWPARENFLG  if true, then whenever you are typing Lisp input
    and type a right parenthesis/bracket, TTYIN will briefly move
    the cursor to the matching parenthesis/bracket, assuming it is
    still on the screen.  The cursor stays there for about 1
    second, or until you type another character (i.e., if you type
    fast you'll never notice it).  This feature was inspired by a
    similar EMACS feature, and turned out to be pretty easy to
    implement.

 TTYINBSFLG  causes TTYIN to always physically backspace, even if
    you're running on a non-display (not a DM or Heath), rather
    than print \deletedtext\ (this assumes your hardcopy terminal
    or glass tty is capable of backspacing).  If TTYINBSFLG is LF,
    then in addition to backspacing, TTYIN x's out the deleted
    characters as it backs up, and when you stop deleting, it
    outputs a linefeed to drop to a new, clean line before
    resuming.  To save paper, this linefeed operation is not done
    when only a single character is deleted, on the grounds that
    you can probably figure out what you typed anyway.

 TTYINRESPONSES  an alist of special responses that will be
    handled by routines designated by the programmer.  See
    Special Responses'', below.

 TTYINERRORSETFLG  [Interlisp-D only] if true, non-LISPXREAD
    inputs are errorset-protected (^E traps back to the prompt),
    otherwise errors propagate upwards.  Initially NIL.

 TTYINMAILFLG  [Tenex only] when true, performs mail checking,
    etc. before most inputs (except EVALQT inputs, where it is
    assumed this has already been done, or inputs indented by more
    than a few spaces).  MAILWATCH package must be loaded for
    this.

TTYINCOMPLETEFLG  if true, enables Escape completion from
USERWORDS during READ inputs.  Details below.

USERWORDS, as described in the dwim chapter, contains words you
mentioned recently: functions you have defined or edited, variables
you have set or evaluated at the evalqt level, etc.  This happens
to be a very convenient list for context-free escape completion; if
you have recently edited a function, chances are good you may want
to edit it again (typing EF xx$'') or type a call to it.  If
there is no completion for the current word from USERWORDS, the
escape echoes as $'', i.e. nothing special happens; if there is
more than one possible completion, you get beeped.  If typed when
not inside a word, Escape completes to the value of LASTWORD, i.e.,
the last thing you typed that the p.a. noticed'' (setting
TTYINCOMPLETEFLG to 0 disables this latter feature), except that
Escape at the beginning of the line is left alone (it is a p.a.
command; see 22.19 of manual).

If you really wanted to enter an escape, you can, of course, just
quote it with a ^V, like you can other control chars.

You may explicitly add words to USERWORDS yourself that wouldn't
get there otherwise.  To make this convenient online the edit
command [_] means add the current atom to USERWORDS'' (you might
think of the command as pointing out this atom'')  e.g. you
might be entering a function definition and want to point to''
one or more of its arguments or prog variables.  Giving an argument
of zero to this command will instead remove the indicated atom from
USERWORDS.

Note that this feature loses some of its value if the spelling list
is too long, for then the completion takes too long computationally
and, more important, there are too many alternative completions for
you to get by with typing a few characters followed by escape.
Lisp's maintenance of the spelling list USERWORDS keeps the
temporary'' section (which is where everything goes initially
unless you say otherwise) limited to #USERWORDS atoms, initially
100.  Words fall off the end if they haven't been used (they are
used'' if FIXSPELL corrects to one, or you use <escape> to
complete one). 

Special Responses

There is a facility for handling special responses'' during any
non-READ TTYIN input.  This action is independent of the particular
call to TTYIN, and exists to allow you to effectively advise''
TTYIN to intercept certain commands.  After the command is
processed, control returns to the original TTYIN call.  The
facility is implemented via the list TTYINRESPONSES.

TTYINRESPONSES is a list of elements, each of the form

	(commands response-form [LINE | STRING])

where commands is a single atom or list of commands to be
recognized; response-form is EVALed (if a list), or APPLYed (if
atom) to the command and the rest of the line.  Variables COMMAND
and LINE refer to the command the user typed and the rest of the
line.  LINE option means pass rest of line as a list; STRING means
pass it as a string; if neither is specified, the command is only
valid if there is nothing else on the line.  If the response form
returns IGNORE, it is not treated as a special response (i.e. the
input is returned normally as the result of TTYIN).

In MYCIN, the COMMENT command is handled this way; any time the
user types COMMENT as the first word of input, TTYIN passes the
rest of the line to a mycin-defined function which prompts for the
text of the comment (recursively using TTYIN with the TEXT option).
 When control returns, TTYIN goes back and prompts for the original
input again.  The TTYINRESPONSES entry for this is (COMMENT (GRIPE
LINE) LIST); GRIPE is a MYCIN function of one argument (the
one-line comment, or NIL for extended comments).

Suggested use: global commands or options can be added to the
toplevel value of TTYINRESPONSES.  For more specialized commands,
rebind TTYINRESPONSES to (APPEND '(your entries) TTYINRESPONSES)
inside any module where you want to do this sort of special
processing.

Special responses are not checked for during READ-style input.


                           Display Types
                   [not relevant in Interlisp-D]

TTYIN determines the type of display by calling DISPLAYTERMP[],
which is initially defined to test the value of the GTTYP jsys.  It
returns either NIL (for printing terminals) or a small number
giving TTYIN's internal code for the terminal type.  The types
TTYIN currently knows about:

    0 = glass tty (capable of deleting chars by backspacing, but
	 little else);
    1 = Datamedia;
    2 = Heath.

Only the Datamedia has full editing power.  DISPLAYTERMP has built
into it the correct terminal types for Sumex and Stanford campus
20's: DM = 11 on tenex, 5 on tops20; Heath = 18 on Tenex, 25 on
tops20.  You can override those values by setting the variable
DISPLAYTYPES to be an alist associating the GTTYP value with one of
these internal codes. E.g., Sumex displays correspond to
DISPLAYTYPES = ((11 . 1) (18 . 2)) [although this is actually
compiled into DISPLAYTERMP for speed]. Any display terminal other
than DM and Heath can probably safely be assigned to 0'' for
glass tty.

To add new terminal types, you have to choose a number for it, add
new code to TTYIN for it and recompile.  The TTYIN code specifies
what the capabilities of the terminal are, and how to do the
primitive operations: up, down, left, right, address cursor, erase
screen, erase to end of line, insert character, etc.

For terminals lacking an Edit key (currently only dm's have it),
set the variable EDITPREFIXCHAR to the ascii code of an Edit
prefix'' (i.e. anything typed preceded by the prefix is
considered to have the edit bit on).  If your EDITPREFIXCHAR is 33Q
(Escape), you can type a real Escape by typing 3 of them (2 won't
do, since that means Edit-Escape'', a legitimate argument to
another command).  You could also define an Escape synonym with
TTYINREADMACROS if you wanted (but currently it doesn't work in
filename completion).  Setting EDITPREFIXCHAR for a terminal that
is not equipped to handle the full range of editing functions (only
the Heath and Datamedia are currently so equipped) is not
guaranteed to work, i.e. the display will not always be up to date;
but if you can keep track of what you're doing, together with an
occasional ^R to help out, go right ahead. 
