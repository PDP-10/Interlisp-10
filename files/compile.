(FILECREATED " 1-OCT-74 16:39:49" COMPILE.;6 47726  

     changes to:  BCOMPL BCOMPL3 BRECOMPILE GETCFILE COMPILEFNS

     previous date: "16-SEP-74 04:44:56" COMPILE.;5)


  (LISPXPRINT (QUOTE COMPILECOMS)
	      T T)
  [RPAQQ COMPILECOMS
	 ((FNS * COMPILEFNS)
	  [VARS (DWIMIFYCOMPFLG)
		(NOLINKFNS (QUOTE (HELP ERRORX ERRORSET EVALV FAULTEVAL 
					INTERRUPT SEARCHPDL MAPDL BREAK1 EDITE 
					EDITL)))
		(LINKFNS)
		(RETFNS)
		(BLKAPPLYFNS)
		(DONTCOMPILEFNS)
		(SPECVARS (QUOTE (HELPCLOCK LISPXHIST)))
		(BLKLIBRARY)
		(BLKLIBRARYFNS (QUOTE (MEMB ASSOC EQUAL LAST LENGTH NTH GETP 
					    NLEFT NCONC1 LISPXWATCH)))
		(LOCALFREEVARS)
		[COMPILEHEADER (COND (SPAGHETTIFLG (QUOTE "compiled on "))
				     (T (QUOTE "COMPILED ON "]
		(COMPILE.EXT (QUOTE COM))
		(COMPSETLST (QUOTE (ST F STF S Y YES N NO 1 2 NIL T TTY TTY:]
	  (PROP BLKLIBRARYDEF * BLKLIBRARYFNS)
	  (PROP MACRO XNLSETQ UNDONLSETQ RESETVAR RESETFORM RESETLST RESETSAVE 
		* FRPLNODE)
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
		    (ADDVARS (NLAMA BLOCK:)
			     (NLAML BCOMPL3A]
  (RPAQQ COMPILEFNS
	 (BCOMPL BCOMPL1 BCOMPL1A BCOMPL2 BCOMPL3 BLOCK: BRECOMPILE BRECOMPILE1 
		 BRECOMPILE2 BRECOMPILE3 BLOCKCOMPILE BLOCKCOMPILE1 COMPSET 
		 COMPSETREAD COMPSETY COMPSETF RCOMP3 TCOMPL RECOMPILE RECOMP? 
		 COMPILE COMPILE1 FILECHECK COMPEM GETCFILE))
(DEFINEQ

(BCOMPL
  [LAMBDA (FILES CFILE NOBLOCKSFLG)

          (* BCOMPL is like TCOMPL, except that it reads in all of 
          FILES before starting any compilations, so that a BLOCK can 
          contain functions in several FILES.
          BLOCKS are set up using a DECLARE statement of the form 
          (DECLARE (BLOCK: BLKNAME BLKFN1 BLKFN2 ...
          (VAR1 VALUE) (VAR2 VALUE) ...) 
          (BLOCK: BLKNAME ...) ...) -
          where BLKFN1 ... are the functions in the BLOCK, and VAR1 
          ... are values for ENTRIES, RETFNS, SPECVARS, etc. A 
          variable setting of the form (VAR . list) sets variable to 
          UNION of the list with the variable's top level value.
          A variable setting of the form 
          (VAR . ATOM) simply sets the variable to that atom, e.g. 
          (NOLINKFLG . T))


    (COND
      ((AND SPAGHETTIFLG (NULL NOBLOCKSFLG))
	(PRIN1 (QUOTE "using TCOMPL instead
")
	       T)
	(TCOMPL FILES))
      (T (RESETLST (PROG ((LAMS LAMS)
			  DEFS CHANGES OTHERS BLOCKS BLKFNS TEM RESETEXP)
		         (RESETSAVE NLAML NLAML)
		         (RESETSAVE NLAMA NLAMA)
		         (RESETSAVE DWIMIFYCOMPFLG DWIMIFYCOMPFLG)
		         [COND
			   ((ATOM FILES)
			     (SETQ FILES (LIST FILES]
		         (SETQ FILES (MAPCAR FILES (FUNCTION FILECHECK)))
                                                (* Checks that all FILES are 
                                                there, and if not, attempts 
                                                spelling correction.)
		         (AND (NULL NOBLOCKSFLG)
			      (COMPSET NIL (QUOTE F)
				       FILES))

          (* NOBLOCKSFLG is T on calls from TCOMPL.
          In this case, the first COMPSET has already been performed.)


		         (COMPSET (OR CFILE
				      (PACK (LIST (SETQ TEM
						    (NAMEFIELD (CAR FILES)))
						  (QUOTE %.)
						  COMPILE.EXT)))
				  NIL FILES)
		         (RESETSAVE NIL (SETQ RESETEXP (LIST (QUOTE BCOMPL3)
							     NIL NIL FILES)))

          (* BCOMPL3 will close and if necessary delete all the 
          appropriate files when bcompl finishes, or control-d or 
          control-e occurs. distinguishes two cases by smashing first 
          argument to T at end of bcompl if it completes.)


		         (SETQ NOFIXVARSLST0
			   (NCONC (MAPCONC FILES (FUNCTION BCOMPL1))
				  NOFIXVARSLST))
		         (SETQ NOFIXFNSLST0
			   (NCONC [MAPCAR DEFS (FUNCTION (LAMBDA (X)
					      (RCOMP3 (CAR X)
						      (CADR X]
				  NOFIXFNSLST))

          (* The BCOMPL1 reads in FILES. It returns a list of 
          variables set in the files. The RCOMP3 adds function to 
          NLAMA, LAMS, etc., and returns a list of functions.
          NOFIXLST0 is reset in case there is any dwimifying to be 
          done.)


		         [AND (NULL DWIMIFYCOMPFLG)
			      (SETQ DWIMIFYCOMPFLG (EQ (GETP TEM (QUOTE 
								   FILETYPE))
						       (QUOTE CLISP]
                                                (* The FILETYPE may have been 
                                                set during the course of 
                                                BCOMPL1.)
		         (AND (NULL NOBLOCKSFLG)
			      (PROG NIL         (* compile blocks MAPC not used 
                                                because BCOMPL2 checks BLOCKS.)
				LP  (COND
				      ((NULL BLOCKS)
					(RETURN)))
				    (BCOMPL2 (CAR BLOCKS))
				    (SETQ BLOCKS (CDR BLOCKS))
				    (GO LP)))
		     LP  

          (* COMPILE other functions. done this way instead of MAPC to 
          release the defs as soon aspossible.)


		         (COND
			   (DEFS (AND (NOT (FMEMB (CAAR DEFS)
						  DONTCOMPILEFNS))
				      (COMPILE1 (CAAR DEFS)
						(CADAR DEFS)))
				 (SETQ DEFS (CDR DEFS))
				 (GO LP)))
		         (COND
			   (LCFIL [MAPC OTHERS (FUNCTION (LAMBDA (X)
                                                (* Dump variables.)
					    (PRINT X LCFIL FILERDTBL]
				  (PRINT NIL LCFIL FILERDTBL)))
		         (RPLACA (CDR RESETEXP)
				 T)
		         (RETURN LCFIL])

(BCOMPL1
  [LAMBDA (X)

          (* X is either the name of a file, or a list of non-defineq 
          expression on a file. In the first case, BCOMPL1 reads the 
          expressions on the file, printing the dates, gathering 
          definitions on DEFS (a free varible), evaluating DECLARE:'s, 
          and gathering expressions to be printed on the file on 
          OTHERS (a free variable). Value is a list of VARS set in the 
          file.)


    (AND (ATOM X)
	 (INFILE X))
    (PROG (TEM VARS)
      LP  (COND
	    ((NULL X)
	      (RETURN VARS))
	    ((LISTP X)
	      (SETQ TEM (CAR X))
	      (SETQ X (CDR X)))
	    ((OR (NULL (SETQ TEM (READ X FILERDTBL)))
		 (EQ TEM (QUOTE STOP)))
	      (CLOSEF X)
	      (RETURN VARS)))
          (BCOMPL1A TEM (QUOTE DEFAULT))
          (GO LP])

(BCOMPL1A
  [LAMBDA (X COMPCOPYFLG COMPEVALFLG)
    (PROG (TEM)
          (SELECTQ
	    (CAR X)
	    (FILECREATED (AND LCFIL (PRINT X LCFIL FILERDTBL))
			 (SETQ CHANGES
			   (NCONC (LDIFF (SETQ TEM (CDR (MEMB (QUOTE to:)
							      X)))
					 (MEMB (QUOTE previous)
					       TEM))
				  CHANGES)))
	    (DEFINEQ (SETQ DEFS (NCONC DEFS (CDR X))))
	    (DECLARE 

          (* DECLARE is an anachronism. The expressions are evaluate 
          and not copied to compiled file.
          Same as (DECLARE: DOEVAL@COMPILE DONTCOPY))


		     (MAPC (CDR X)
			   (FUNCTION EVAL)))
	    [DECLARE:                           (* supercedes DECLARE, DEFLIST 
                                                with third argument, and PROGN 
                                                with funny atom.)

          (* Note thatDECLARE: itself isnt copied to compiled file.
          nor is it evaluated at compile time.)


	      (RESETVAR DFNFLG DFNFLG
		(PROG ((COMPEVALFLG COMPEVALFLG)
		       (COMPCOPYFLG COMPCOPYFLG))
		      (MAPC (CDR X)
			    (FUNCTION (LAMBDA (X)
				(COND
				  ((LISTP X)
				    (BCOMPL1A X COMPCOPYFLG COMPEVALFLG))
				  (T (SELECTQ X
					      (DONTCOPY (SETQ COMPCOPYFLG NIL))
					      ((DOCOPY COPY)
						(SETQ COMPCOPYFLG T))
					      (DONTEVAL@COMPILE (SETQ 
								COMPEVALFLG NIL)
								)
					      ((DOEVAL@COMPILE EVAL@COMPILE)
						(SETQ COMPEVALFLG T))
					      ((DONTEVAL@LOAD DOEVAL@LOAD 
							      EVAL@LOAD)
						NIL)
					      (COMPILERVARS 

          (* From ADDVARS NLAMA and NLAML in prettydef.
          The resetting of dfnflg will suppress the 
          (NLAMA RESET) message.)


							    (SETQ DFNFLG T))
					      (HELP]
	    [DEFLIST                            (* DEFLIST and PROGN are now 
                                                superceded by DECLARE:)

          (* Normally DEFLIST's are copied to the compiled file but 
          not evaluated. This is the standard case for the PROP 
          option.)


		     (SELECTQ (CADR (CADDDR X))
			      ((COMPROP EVALUATE&COPY)
				(SETQ COMPEVALFLG (SETQ COMPCOPYFLG T)))
			      ((COMPROP* JUSTEVALUATE)
				(SETQ COMPEVALFLG T))
			      (AND (EQ COMPCOPYFLG (QUOTE DEFAULT))
				   (SETQ COMPCOPYFLG T]
	    [PROGN (AND (EQ (CAADR X)
			    (QUOTE QUOTE))
			(SELECTQ (CADADR X)
				 (EVALUATE&COPY (SETQ COMPEVALFLG (SETQ 
						    COMPCOPYFLG T)))
				 (JUSTEVALUATE (SETQ COMPEVALFLG T))
				 (AND (EQ COMPCOPYFLG (QUOTE DEFAULT))
				      (SETQ COMPCOPYFLG T]
	    ((SETQ SETQQ RPAQ RPAQQ)
	      (SETQ VARS (CONS (CADR X)
			       VARS))
	      (AND (EQ COMPCOPYFLG (QUOTE DEFAULT))
		   (SETQ COMPCOPYFLG T)))
	    (AND (EQ COMPCOPYFLG (QUOTE DEFAULT))
		 (SETQ COMPCOPYFLG T)))
          (COND
	    ((EQ COMPCOPYFLG T)
	      (SETQ OTHERS (NCONC1 OTHERS X))   (* OTHERS is a list of 
                                                expressions to be written out 
                                                later.)
	      ))
          (COND
	    ((EQ COMPEVALFLG T)
	      (EVAL X)))
          (RETURN])

(BCOMPL2
  [LAMBDA (BLOCK FILEMAPLST)                    (* Thisfunction processes a 
                                                single block.)
                                                (* FILEMAPLST is given when 
                                                recompiling.)
    (PROG ((RETFNS RETFNS)
	   (SPECVARS SPECVARS)
	   (GLOBALVARS GLOBALVARS)
	   (BLKLIBRARY BLKLIBRARY)
	   (NOLINKFNS NOLINKFNS)
	   (LINKFNS LINKFNS)
	   (DONTCOMPILEFNS DONTCOMPILEFNS)
	   (BLKNAME (CAR BLOCK))
	   BLKAPPLYFNS ENTRIES LOCALFREEVARS X TEM LST)
          (GO LP1)
      LP  

          (* Loop through BLOCK making assignments for non-atomic 
          expressions and gathering on LST the definitions for the 
          atoms.)


          [COND
	    ((LISTP (SETQ X (CAR BLOCK)))       (* A declaration)
	      [SETQ TEM (COND
		  ((EQ (CADR X)
		       (QUOTE *))
		    (EVAL (CADDR X)))
		  (T (CDR X]
	      [SET (CAR X)
		   (COND
		     ((NLISTP (CDR X))
		       TEM)
		     (T (APPEND TEM (EVAL (CAR X]
	      (SELECTQ (CAR X)
		       ((SPECVARS GLOBALVARS LOCALFREEVARS)
                                                (* Notices these variables.)
			 (SETQ NOFIXVARSLST0 (UNION TEM NOFIXVARSLST0)))
		       NIL)
	      (GO LP1))
	    ((AND FILEMAPLST (NULL BLKNAME)
		  (NOT (RECOMP? X FNS)))

          (* Function is not goin to be compiled, so no point in 
          looking up its definition. Note that BRECOMPILE never calls 
          BCOMPL2 on a block (other than one with a NIL name) unless 
          the entire block is going to have to be recompiled.)


	      (SETQ TEM (LIST X)))
	    (FILEMAPLST (SETQ TEM (BRECOMPILE3 X FILEMAPLST)))
	    ((SETQ TEM (FASSOC X DEFS))
	      (AND [NOTANY (CDR BLOCKS)
			   (FUNCTION (LAMBDA (X)
			       (FMEMB (CAR TEM)
				      (CDR X]
		   (SETQ DEFS (DREMOVE TEM DEFS)))

          (* This is done primarily to release the space for 
          recompilation as soon as possible.)


	      )
	    (T (COMPEM X (QUOTE "not compilable."]
          (SETQ LST (NCONC1 LST TEM))
          (SETQ BLKFNS (CONS X BLKFNS))

          (* A list of those functions contained in blocks.
          All others will be compiled separately.)


      LP1 (COND
	    ((SETQ BLOCK (CDR BLOCK))
	      (GO LP))
	    ((AND (NULL LST)
		  BLKNAME)

          (* BLOCK consists of single function: BLKNAME, e.g. 
          (FOO) or (FOO (SPECVARS --) (globavlars --)) have to go back 
          through loop to look up definition on defs.)


	      (SETQ BLOCK (LIST BLKNAME))
	      (GO LP)))
          (COND
	    ((NULL BLKNAME)

          (* By using NIL for BLOCK name, user indicates this is a 
          non-block compilation. However, he can set LINKFLG to T, 
          thereby causing all calls to be linked, even though he is 
          not compiling a BLOCK. He can also set NOLINKFNS and 
          GLOBALVARS.)


	      (PROG NIL
		L1  (COND
		      ((NULL LST)
			(RETURN))
		      ((OR (NULL FILEMAPLST)
			   (AND (CADAR LST)
				(RECOMP? (CAAR LST)
					 FNS)))
			(COMPILE1 (CAAR LST)
				  (CADAR LST)))
		      (T (BRECOMPILE1 (CAAR LST)
				      T)))
		    (SETQ LST (CDR LST))
		    (GO L1)))
	    (T                                  (* BLOCKCOMPILE1 will also make 
                                                some checks on ENTRIES.)
	       (BLOCKCOMPILE1 BLKNAME (PROG1 LST (SETQ LST))
			      ENTRIES)))
          (RETURN])

(BCOMPL3
  [NLAMBDA (FLG CFILE FILES)

          (* Cleans up after brecompile and bcompl have finished 
          operating, FLG=T means successful finish, NIL means 
          control-d or error)


    (COND
      ((AND LCFIL (NEQ LCFIL T)
	    (NEQ LCFIL (QUOTE NIL:))
	    (OPENP LCFIL (QUOTE OUTPUT)))
	(CLOSEF LCFIL)
	(AND (NULL FLG)
	     (DELFILE LCFIL)))
      (T (SETQ LCFIL NIL)))
    (COND
      ((AND CFILE (NEQ CFILE T)
	    (NEQ CFILE NIL)
	    (OPENP CFILE (QUOTE INPUT)))
	(CLOSEF CFILE)))
    [MAPC FILES (FUNCTION (LAMBDA (FILE)
	      (AND (OPENP FILE)
		   (CLOSEF FILE))
	      (COND
		(FLG                            (* Finished successfully.)
		     (/RPLACA (QUOTE NOTCOMPILEDFILES)
			      (REMOVE (NAMEFIELD FILE T)
				      NOTCOMPILEDFILES))
                                                (* Removes FILES from 
                                                NOTCOMPILEDFILES.)
		     ]
    (AND FLG (NEQ (POSITION T)
		  0)
	 (TERPRI T])

(BLOCK:
  [NLAMBDA X                                    (* Used in DECLARE expressions 
                                                to set up blocks.
                                                See comment in BCOMPL.)
    (SETQ BLOCKS (NCONC1 BLOCKS X])

(BRECOMPILE
  [LAMBDA (FILES CFILE FNS NOBLOCKSFLG)

          (* FNS is a list of functions to be recompiled.
          The object is to make a file that looks exactly like that 
          produced by BCOMPL (PFILE) except to greatly reduce the work 
          by copying from CFILE the compiled definitions those 
          functions not being recompiled.
          BRECOMPILE is driven by PFILE, and the algorithm is whenever 
          a DEFINEQ is encountered, process all OF the functions in 
          the DEFINEQ as follows: COMPILE the definition OF the 
          function IF it is on the list FNS, or IF FNS is T and the 
          function is currently defined as an EXPR.
          Otherwise copy its compiled definition from CFILE.
          Note that functions with compiled definitions in CFILE that 
          do not appear in PFILE are NOT copied.
          This corresponds to the case where functions have been 
          deleted from PFILE.)


    (COND
      [(AND SPAGHETTIFLG (NULL NOBLOCKSFLG))
	(PRIN1 (QUOTE "using RECOMPILE instead
")
	       T)
	(MAPCAR (COND
		  ((ATOM FILES)
		    (LIST FILES))
		  (T FILES))
		(FUNCTION (LAMBDA (FL)
		    (BRECOMPILE FL NIL FNS T]
      (T
	(RESETLST
	  (PROG ((LAMS LAMS)
		 CHANGES OTHERS FILEMAPLST FNLST BLKFNS BLOCKS FILE TEM ADRLST 
		 RESETEXP)
	        (RESETSAVE NLAMA NLAMA)
	        (RESETSAVE NLAML NLAML)
	        (RESETSAVE DWIMIFYCOMPFLG DWIMIFYCOMPFLG)
	        [COND
		  ((ATOM FILES)
		    (SETQ FILES (LIST FILES]
	        (COND
		  ((AND (NULL CFILE)
			(NULL FNS))

          (* BRECOMPILE (FILE) is equivalent to RECOMPILE 
          (PFILE CFILE T T) Thus, you can LOAD a file in using LOAD 
          (FILE PROP) edit selected functions causing them to be 
          unsaved, PRETTYDEF the file, and then simply perform 
          RECOMPILE (FILE) (* Note the CFILE=NIL is interpreted as 
          meaning PFILE.COM even when FNS supplied.))



          (* Another possibility is with COREFLG=NIL and FNS=T, in 
          which case the list of the functions changed on the file 
          will be used.)


		    (SETQ FNS T)))
	        (SETQ FILES (MAPCAR FILES (FUNCTION FILECHECK)))
	        (SETQ FILE (NAMEFIELD (CAR FILES)))
	        (SETQ TEM (PACK (LIST FILE (QUOTE %.)
				      COMPILE.EXT)))
	        (COND
		  ((EQ FNS (QUOTE ALL))

          (* Dont need CFILE since are going to compile everything.
          This feature is useful when your compiled file is clobbered, 
          but you have alredy loaded in the symbolic file.)


		    )
		  ([NULL (CAR (ERSETQ (GETCFILE FILES (OR CFILE TEM)
						(COND
						  (NOBLOCKSFLG (QUOTE TCOMPL))
						  (T (QUOTE BCOMPL]
		    (RETURN NIL))
		  (T (SETQ CFILE (INPUT))       (* Gets full name.)
		     ))
	        (COMPSET NIL (QUOTE ST)
			 FILES)
	        (COMPSET TEM NIL FILES)
	        (RESETSAVE NIL (SETQ RESETEXP (LIST (QUOTE BCOMPL3)
						    NIL CFILE FILES)))

          (* BCOMPL3 will close and if necessary delete all the 
          appropriate files when brecompile finishes, or control-d or 
          control-e occurs. distinguishes two cases by smashing first 
          argument to T at end of brecompile if it completes.
          Note that this call differs from the call for bcompl in that 
          cfile is also specified. this corresponds to the fact that 
          recompile has an extra file open.)


	        [SETQ FILEMAPLST
		  (MAPCAR
		    FILES
		    (FUNCTION (LAMBDA (FL)
			(PROG (FNLST (VARLST T)
				     DONELST)
			      (INFILE FL)
			      (SFPTR FL 0)
			      (AND (NULL BUILDMAPFLG)
				   (RESETSAVE BUILDMAPFLG T))
			      (RETURN (CONS (CONS FL
						  (SCANFILE0
						    (GETFILEMAP FL
								(NAMEFIELD
								  FL T))
						    T))
					    (DREVERSE DONELST)))

          (* SCANFILE0 scans the file, building a map if one not 
          already there. Value is the map.
          In addition, sets DONELST to a lit of all non-defineq 
          expressions.)


			  ]
	        [SETQ FNLST
		  (MAPCONC FILEMAPLST
			   (FUNCTION (LAMBDA (X)
			       (MAPCONC (CDDAR X)
					(FUNCTION (LAMBDA (X)
					    (MAPCAR (CDDR X)
						    (FUNCTION CAR]

          (* FILEMAPLST is a list of information about each file.
          CAR of each entry on FILEMAPLST is the filemap.
          The first entry on the filemap is the file name, and the 
          second would be NIL. We start mapping down CDDR of the 
          filemap, (CDDAR X), and each element therein corresponds to 
          a single DEFINEQ. CDDR is a list of 
          (FN ADR1 . ADR2), so the inner MAPCAR gathers up the names 
          of the functions. The reason for not asking LOADFNS to do 
          this is in most cases the map will already have been built, 
          so LOADFNS wont even go inside of the defineq.)


	        (SETQ NOFIXFNSLST0 (APPEND FNLST NOFIXFNSLST))
	        (SETQ NOFIXVARSLST0 (NCONC [MAPCONC FILEMAPLST
						    (FUNCTION (LAMBDA (X)
							(BCOMPL1 (CDR X]
					   NOFIXVARSLST))

          (* BCOMPL1 returns a list of VARS set in the files.
          NOFIXFNLST0 and NOFIXVARlst0 are reset in case there is any 
          dwimifying to be done BCOMPL1 ALSO set s free variable 
          OTHERS to list of expressions to be printed on compiled file 
          when all is done.)


	        [MAPC FNLST (FUNCTION (LAMBDA (X)
			  (RCOMP3 X (VIRGINFN X]
	        [AND (NULL DWIMIFYCOMPFLG)
		     (SETQ DWIMIFYCOMPFLG (EQ (GETP FILE (QUOTE FILETYPE))
					      (QUOTE CLISP]
	        (AND (NEQ FNS (QUOTE ALL))
		     (INPUT CFILE))
	        [AND (NULL NOBLOCKSFLG)
		     (MAPC BLOCKS (FUNCTION (LAMBDA (BLOCK)
			       (COND
				 ((NULL (CAR BLOCK))
				   (BCOMPL2 BLOCK FILEMAPLST))
				 ([SOME BLOCK (FUNCTION (LAMBDA (X)
					    (AND (ATOM X)
						 (RECOMP? X FNS]

          (* If any function in the BLOCK is to be recompiled, the 
          whole BLOCK must be recompiled.)


				   (BCOMPL2 BLOCK FILEMAPLST))
				 (T (BRECOMPILE1 BLOCK]

          (* NOBLOCKSFLG is T for calls from RECOMPILE.
          In this case, even if there were any blocks, ignore them.)

                                                (* Now COMPILE rest of 
                                                functions.)
	        [MAPC FNLST (FUNCTION (LAMBDA (X)
			  (COND
			    ((OR (FMEMB X BLKFNS)
				 (FMEMB X DONTCOMPILEFNS)))
			    [(RECOMP? X FNS)
			      (COMPILE1 X (CADR (BRECOMPILE3 X FILEMAPLST]
			    (T (BRECOMPILE1 X T]
                                                (* Now we can close the symbolic
                                                files.)
	        (MAPC FILES (FUNCTION CLOSEF))
                                                (* Now Dump variables and close 
                                                file.)
	        [MAPC OTHERS (FUNCTION (LAMBDA (X)
			  (PRINT X LCFIL FILERDTBL]
	        (PRINT NIL LCFIL FILERDTBL)
	        (RPLACA (CDR RESETEXP)
			T)                      (* so call to bcompl3a will know
                                                was successful finish.)
	        (RETURN LCFIL])

(BRECOMPILE1
  [LAMBDA (FN/BLOCK NOBLOCKSFLG)                (* Looks for FN/BLOCK and its 
                                                subfunctions on CFILE, skipping 
                                                till found.)
    (PROG ([NAME (COND
		   (NOBLOCKSFLG FN/BLOCK)
		   (T (CAR FN/BLOCK]
	   X ADR (ADRLST0 ADRLST))
      LP  (SETQ ADR (SFPTR CFILE))
          (COND
	    [(NULL (ATOM (SETQ X (READ CFILE FILERDTBL]
	    [(OR (EQ X NAME)
		 (BRECOMPILE2 X NAME))
	      (PRIN2 X T T)
	      (PRIN1 (QUOTE ", ")
		     T)
	      (OUTPUT LCFIL)
	      (LCSKIP X T)
	      (COND
		((EQ X NAME)
		  [COND
		    ((NULL NOBLOCKSFLG)
		      (SETQ BLKFNS (CONS X BLKFNS))
		      (MAPC (CDR FN/BLOCK)
			    (FUNCTION (LAMBDA (X)
				(COND
				  ((ATOM X)
				    (SETQ BLKFNS (CONS X BLKFNS)))
				  ((EQ (CAR X)
				       (QUOTE ENTRIES))
				    (MAPC (CDR X)
					  (FUNCTION (LAMBDA (X)
					      (COND
						((EQ X NAME))
						((NEQ (READ CFILE FILERDTBL)
						      X)
						  (COMPEM X (QUOTE "not found.")
							  ))
						(T (PRIN2 X T T)
						   (PRIN1 (QUOTE ", ")
							  T)
						   (LCSKIP X T]
		  (RETURN]
	    ([AND (EQ ADRLST0 ADRLST)
		  (SOME ADRLST (FUNCTION (LAMBDA (Y)

          (* NAME is not the next function on the file.
          Before skipping this function, see if NAME has been 
          encountered earlier by scanning ADRLST.
          This saves skipping all the way down to the end of the file 
          in the case that NAME is simply out of order.
          Only do this the first time, i.e. once you hve determined 
          that NAME is not on ADRLST, and skipped X, then no reason to 
          recheck ADRLST.)


			    (COND
			      ((OR (EQ (CAR Y)
				       NAME)
				   (BRECOMPILE2 (CAR Y)
						NAME))
                                                (* NAME was previously 
                                                encountered and skipped over, 
                                                e.g. out of order.)
				(SFPTR CFILE (CDR Y))
				(BRECOMPILE1 FN/BLOCK NOBLOCKSFLG)
				(SFPTR CFILE ADR)
                                                (* Reset filepointer back to 
                                                where it was.)
				T]
	      (RETURN))
	    [(OR (NULL X)
		 (EQ X (QUOTE STOP)))
	      (COND
		((EXPRP (SETQ X (VIRGINFN NAME T)))
		  (COMPILE1 NAME X)
		  (SFPTR CFILE ADR)             (* So next read wont hit end of 
                                                file.)
		  (RETURN))
		(T (COMPEM NAME (QUOTE "not found."]
	    (T (SETQ ADRLST (NCONC1 ADRLST (CONS X ADR)))
	       (LCSKIP X)))
          (GO LP])

(BRECOMPILE2
  [LAMBDA (X FN)                                (* T if X is a sub-functionof 
                                                FN.)
    (AND (STRPOS FN X)
	 (PROG [(NX (ADD1 (NCHARS X)))
		(N (ADD1 (NCHARS FN]
	   LP  (OR (STRPOS (QUOTE "A0ZZZ")
			   X N (QUOTE Z)
			   T)
		   (RETURN))                    (* Anchored match starting at 
                                                position N, z a wild card.)
	       (SETQ N (IPLUS N 5))
	       (COND
		 ((EQ N NX)
		   (RETURN T)))
	       (GO LP])

(BRECOMPILE3
  [LAMBDA (FN FILEMAPLST)                       (* returns definition of FN, 
                                                either from in core, or from the
                                                file.)
    (PROG (TEM FILE)
          (COND
	    ((EXPRP (SETQ TEM (VIRGINFN FN T)))
	      (RETURN (LIST FN TEM))            (* Value is of the form 
                                                (FN DEF))
	      )
	    ([SOME FILEMAPLST (FUNCTION (LAMBDA (X)
		       (SETQ FILE (CAAR X))
		       (SOME (CDDAR X)
			     (FUNCTION (LAMBDA (Y)
				 (SETQ TEM (FASSOC FN (CDDR Y]
	      (SFPTR FILE (CADR TEM))
	      (SETQ TEM (READ FILE FILERDTBL))
	      (COND
		((NEQ FN (CAR TEM))
		  (ERROR (QUOTE "filemap does not agree with contents of")
			 FILE T)))
	      (RETURN TEM))
	    (T 

          (* The only way I can see this happening is if a function is 
          included in a block declaration that is not in one of the 
          files, since the list of functios used to drive brecompile 
          is precisely all of the functions on the file.)


	       (COMPEM FN (QUOTE "not compileable."])

(BLOCKCOMPILE
  [LAMBDA (BLKNAME BLKFNS ENTRIES FLG)
    (RESETVAR NLAMA NLAMA
      (RESETVAR NLAML NLAML
	(PROG ((LAMS LAMS))                     (* Corresponds to COMPILE.)
	      [COND
		[(LISTP BLKNAME)
		  (COND
		    ((AND (NULL BLKFNS)
			  (NULL ENTRIES))       (* A common mistake, user calls 
                                                BLOCKCOMPILE as he would 
                                                COMPILE.)
		      (SETQ BLKFNS BLKNAME)
		      (SETQ BLKNAME (CAR BLKNAME)))
		    (T (ERROR (QUOTE "block name not atomic")
			      BLKNAME T]
		((NULL BLKFNS)
		  (SETQ BLKFNS (LIST BLKNAME]
	      (COMPSET)
	      (RETURN (PROG1 (BLOCKCOMPILE1 BLKNAME BLKFNS ENTRIES)
			     (COND
			       ((AND (NULL FLG)
				     LCFIL)
				 (PRINT NIL LCFIL FILERDTBL)
				 (CLOSEF LCFIL])

(BLOCKCOMPILE1
  [LAMBDA (BLKNAME BLKFNS ENTRIES)
    (PROG (BLOCKLIST NEWDEF FN DEF CALLTAGS TEM (TAGNUM -1))
          (COND
	    ((AND (EQ BLKNAME (CAR ENTRIES))
		  (NULL (CDR ENTRIES))
		  (NULL BLKAPPLYFNS))

          (* MKENTRIES treats the case of ENTRIES=NIL specially by not 
          setting up a separate BLOCK.)


	      (SETQ ENTRIES NIL)))
          [COND
	    ((AND (NULL ENTRIES)
		  BLKAPPLYFNS)                  (* ABOVE CAPER ONLY WORKS IF NO 
                                                BLKAPPLYFNS)
	      (SETQ ENTRIES (LIST BLKNAME]
          [COND
	    ([SETQ TEM (SOME (APPEND BLKAPPLYFNS (OR ENTRIES (LIST BLKNAME)))
			     (FUNCTION (LAMBDA (X)
				 (AND (NOT (MEMB X BLKFNS))
				      (NOT (ASSOC X BLKFNS]
	      (COMPEM (CAR TEM)
		      (QUOTE "not on blkfns.")))
	    ((MEMB BLKNAME ENTRIES)
	      (COMPEM
		(CONCAT BLKNAME
			(QUOTE " can't be both an entry and the block name
"))
		(COND
		  ((CDR ENTRIES)
		    (QUOTE "since there is more than one entry."))
		  (T (QUOTE "when there are also BLKAPPLYFNS."]
          (AND (NEQ (POSITION T)
		    0)
	       (TERPRI T))
          [SETQ CALLTAGS (MAPCAR
	      BLKFNS
	      (FUNCTION (LAMBDA (X)
		  [COND
		    [(LISTP X)

          (* BLKFNS can be a list of either function names, or 
          (names definitions))


		      (SETQ DEF (CADR X))
		      (SETQ X (CAR X))
		      (COND
			([OR DWIMIFYCOMPFLG (EQ (CAR (SETQ TEM (CADDR DEF)))
						(QUOTE CLISP:))
			     (AND (EQ (CAR TEM)
				      (QUOTE *))
				  (EQ (CADR TEM)
				      (QUOTE DECLARATIONS:]
			  (PRINT (LIST (QUOTE dwimifying)
				       X)
				 T T)
			  (DWIMIFY0 DEF X]
		    ([NOT (EXPRP (SETQ DEF (VIRGINFN X T]
		      (COMPEM X (QUOTE "not compileable."]
		  (SETQ BLOCKLIST (CONS X BLOCKLIST))
		  (LIST X (SETQ TAGNUM (SUB1 TAGNUM))
			DEF]

          (* CALLTAGS will be a list of triples 
          (FN LAPTAG DEF) which is used for internal entry points.
          CALLTAGS can be added to from library or from internally 
          genereated functions e/g functional arguments.)


          (SETQ BLKFNS NIL)
          (SETQ TEM (BLOCKCOMPILE2 BLKNAME CALLTAGS ENTRIES))
          (COND
	    (STRF                               (* Store and redefine)
		  (AND (NOT (FMEMB BLKNAME LINKEDFNS))
		       (SETQ LINKEDFNS (CONS BLKNAME LINKEDFNS)))
		  [MAPC CALLTAGS (FUNCTION (LAMBDA (X)
			    (AND (EXPRP (CAR X))
				 (SAVEDEF (CAR X))
				 (/PUTD (CAR X]

          (* All of the entries would now be compiled.
          the other function should have their definitions be removed 
          from definition cell, so that subsequent recompile will do 
          the right thing.)


		  ))
          (RETURN (OR TEM BLKNAME])

(COMPSET
  [LAMBDA (FILE FLG FILES)

          (* If FILE is not NIL, COMPSET doesn't ask any questions but 
          simply initializes the output FILE, LCFIL.
          If FLG is T (AND FILE IS NIL) COMPSET doesn't ask for an 
          output FILE, but does set up LAPFLG, STRF, SVFLG, and 
          LSTFIL. -
          -
          BCOMPL and BRECOMPILE both call COMPSET twice, once with 
          FILE NIL and FLG T, and once with FILE set to their output 
          FILE. -
          COMPILE calls COMPSET only once, with both arguments NIL.)


    (PROG (OLDO CLFLG RDBUF SYBUF)
          (SETQ OLDO (OUTPUT T))
          (COND
	    (FILE (GO NT)))
          (PRIN1 (QUOTE "listing? ")
		 T)
          [SELECTQ [SETQ FILE (COMPSETREAD T (OR FLG (QUOTE ST]
		   (S [COND
			(LAPFLG (PRIN1 (QUOTE "file: ")
				       T)
				(SETQ LSTFIL (COMPSETF (COMPSETREAD]
		      (GO NOCHANGE))
		   ((ST STF)
		     (SETQ LAPFLG NIL)
		     (SETQ STRF T)
		     (SETQ SVFLG (EQ FILE (QUOTE ST)))
		     (GO NOCHANGE))
		   (F (SETQ LAPFLG NIL)
		      (SETQ STRF NIL)
		      (SETQ SVFLG NIL)
		      (GO NOCHANGE))
		   (COND
		     ((SETQ LAPFLG (COMPSETY FILE))
		       (SELECTQ FILE
				((Y YES 1 2)
				  (PRIN1 (QUOTE "file: ")
					 T)
				  (SETQ FILE (COMPSETREAD)))
				NIL)
		       (SETQ LSTFIL (COMPSETF FILE]
          (PRIN1 (QUOTE "redefine? ")
		 T)
          [COND
	    ((SETQ STRF (COMPSETY (COMPSETREAD)))
	      (PRIN1 (QUOTE "save exprs? ")
		     T)
	      (SETQ SVFLG (COMPSETY (COMPSETREAD]
      NOCHANGE
          [COND
	    ([AND LAPFLG (NEQ LSTFIL (QUOTE T))
		  (NOT (OPENP LSTFIL (QUOTE OUTPUT]
	      (OUTFILE LSTFIL)
	      (SETQ LSTFIL (OUTPUT T]
          (COND
	    [(NULL FLG)
	      (PRIN1 (QUOTE "output file: ")
		     T)
	      (SETQ FILE (COMPSETREAD NIL (QUOTE N]
	    (T (SETQ FILE NIL)))
      NT  (COND
	    ([AND (SETQ LCFIL (COMPSETF FILE))
		  (NEQ LCFIL T)
		  (NULL (OPENP LCFIL (QUOTE OUTPUT]
	      (OUTFILE LCFIL)
	      (SETQ LCFIL (OUTPUT))
	      (PRINT (LIST (QUOTE FILECREATED)
			   (DATE)
			   (CONS COMPILEHEADER FILES))
		     NIL FILERDTBL)))
          (OUTPUT OLDO)
          [COND
	    (SYS (SETQ SYSFNS (UNION SYSNOTFNS SYSFNS]
          [COND
	    (CLFLG                              (* Set in COMPSETREAD.)
		   (SETQ READBUF RDBUF)

          (* All done in SYSBUF so that LINBUF not printed out in 
          middle of compilation.)


		   (BKBUFS (CONS NIL SYBUF]
          (RETURN (QUOTE DONE])

(COMPSETREAD
  [LAMBDA (FLG DEFAULT)
    (PROG (X (N (AND DWIMFLG DWIMWAIT))
	     TEM)
          [COND
	    ((NULL DWIMFLG)
	      (SETQ FLG NIL)
	      (GO READ))
	    (FLG (DOBE)
		 (SETQ FLG (LISPXREADP T]       (* FLG=T means special treatment
                                                for type-aheads. 
                                                (only done once))
      TOP (COND
	    ((OR FLG (NULL DEFAULT))

          (* Don't go into wait loop if something has already been 
          typed or if there is no DEFAULT.)


	      (GO READ)))
      WAITLP
          (DISMISS 500)
          (COND
	    ((LISPXREADP T)
	      (GO READ))
	    ([NOT (ZEROP (SETQ N (SUB1 N]
	      (GO WAITLP)))
          (PRIN1 (QUOTE ...)
		 T)
          (PRINT (SETQ X DEFAULT)
		 T T)
          (SETQ REREADFLG NIL)

          (* I.e. Same as though user typed it.
          If READBUF is not NIL, wouldn't DEFAULT.
          Therefore, READBUF was NIL to begin with or it 
          (AND REREADFLG) have already been saved.
          However, want to set REREADFLG here instead of after 
          CLEARBUF below because of case where READBUF is 
          (now) NIL but REREADFLG is not NIL from previous read.
          Since It would have been set to NIL if user had typed an 
          answer to the question, it should be set to NIL when he 
          defaults the answer.)


          (GO LP1)
      READ[SETQ X (COND
	      ((NULL LISPXHISTORY)
		(READ T T))
	      (T (LISPXREAD T T]
      LP1 (COND
	    ((OR (NULL FLG)
		 (FMEMB X COMPSETLST))          (* Acceptable as type-aheads.)
	      (GO OUT)))
          (COND
	    ((NULL REREADFLG)                   (* If problem due to bad group, 
                                                not type-ahead don't repeat 
                                                question.)
	      (PRIN1 BELLS T)
	      (PRINT (QUOTE listing?)
		     T)
	      (DOBE)))
          (LINBUF)
          (SYSBUF)

          (* Want to clear out LINUF and SYSBUF to prevent CLBUFS from 
          misakenly returning left over typeahead from a previous 
          CLEARBUF.)


          (SETQ TEM (CLBUFS))
          [COND
	    (REREADFLG (SETQ RDBUF REREADFLG))
	    (T (SETQ SYBUF (COND
		   ((NULL TEM)
		     (CONCAT X (QUOTE "
")))
		   ((NULL (CAR TEM))
		     (CONCAT X (QUOTE "
")
			     (CDR TEM)))
		   ((NULL (CDR TEM))
		     (CONCAT X (CAR TEM)))
		   (T (CONCAT X (CAR TEM)
			      (CDR TEM]
          (SETQ CLFLG T)
          (SETQ FLG NIL)
          (GO TOP)
      OUT (RETURN (COND
		    ((NULL LISPXHISTORY)
		      X)
		    (REREADFLG (PRINT X T T))
		    (RDBUF (ATTACH X RDBUF)
			   (SETQ RDBUF (CDR RDBUF))
			   X)
		    (T (NCONC (CAAAR LISPXHISTORY)
			      (LIST HISTSTR0 X))
		       X])

(COMPSETY
  [LAMBDA (A)
    (SELECTQ A
	     ((Y YES)
	       T)
	     ((N NO)
	       NIL)
	     A])

(COMPSETF
  [LAMBDA (A)
    (SELECTQ A
	     ((TTY T TELETYPE TTY:)
	       T)
	     ((NOTHING N)
	       NIL)
	     A])

(RCOMP3
  [LAMBDA (FN DEF)
    (PROG (TYPE TEM1 TEM2)
          (SELECTQ (SETQ TYPE (ARGTYPE DEF))
		   (NIL)
		   [1 (COND
			((NOT (MEMB FN NLAML))
			  (/RPLACA (QUOTE NLAML)
				   (CONS FN NLAML))
			  (SETQQ TEM1 NLAML)
			  (GO ERROR))
			((MEMB FN (CAR (SETQQ TEM1 NLAMA)))
			  (GO ERROR1]
		   [3 (COND
			((NOT (MEMB FN NLAMA))
			  (/RPLACA (QUOTE NLAMA)
				   (CONS FN NLAMA))
			  (SETQQ TEM1 NLAMA)
			  (GO ERROR))
			((MEMB FN (CAR (SETQQ TEM1 NLAML)))
			  (GO ERROR1]
		   [(0 2)
		     (COND
		       ([OR (MEMB FN (CAR (SETQQ TEM1 NLAMA)))
			    (MEMB FN (CAR (SETQQ TEM1 NLAML]
			 (GO ERROR1))
		       ((NEQ (ARGTYPE FN)
			     TYPE)

          (* Situation can occur when TCOMPLING a file which contains 
          a LAMBDA definition for a function, but for which the incore 
          definition is an NLAMBDA.)


			 (SETQ LAMS (CONS FN LAMS]
		   (HELP))
          (RETURN FN)
      ERROR1
          (/RPLACA TEM1 (REMOVE FN (CAR TEM1)))
          (SETQ TEM2 " was incorrectly on ")
      ERROR
          (PRIN1 (QUOTE "***note: ")
		 T)
          (PRIN2 FN T T)
          (PRIN1 (OR TEM2 (QUOTE " was not on "))
		 T)
          (PRINT TEM1 T)
          (RETURN FN])

(TCOMPL
  [LAMBDA (FILES)
    (COMPSET NIL (QUOTE F))
    (MAPCAR (COND
	      ((ATOM FILES)
		(LIST FILES))
	      (T FILES))
	    (FUNCTION (LAMBDA (FILE)
		(OR (CAR (ERSETQ (BCOMPL FILE NIL T)))
		    (CONS FILE (QUOTE (not compiled])

(RECOMPILE
  [LAMBDA (PFILE CFILE FNS)
    (BRECOMPILE PFILE CFILE FNS T])

(RECOMP?
  [LAMBDA (X FNS)
    (SELECTQ FNS
	     (ALL T)
	     (CHANGES (FMEMB X CHANGES))
	     ((T EXPRS)
	       (EXPRP (OR (GETP X (QUOTE ADVISED))
			  (GETP X (QUOTE BROKEN))
			  X)))
	     (COND
	       ((NLISTP FNS)
		 (EQ X FNS))
	       (T (FMEMB X FNS])

(COMPILE
  [LAMBDA (X FLG)
    (RESETVAR NLAMA NLAMA (RESETVAR NLAML NLAML
	(PROG ((LAMS LAMS))
	      (COMPSET)
	      [SETQ X (MAPCAR (COND
				((ATOM X)
				  (LIST X))
				(T X))
			      (FUNCTION (LAMBDA (FN)
				  (COMPILE1 FN (VIRGINFN FN T]
	      (COND
		((AND (NULL FLG)
		      LCFIL)
		  (PRINT NIL LCFIL FILERDTBL)
		  (CLOSEF LCFIL)))
	      (RETURN X])

(COMPILE1
  [LAMBDA (FN DEF)
    (PROG (TEM)
          [COND
	    ([OR DWIMIFYCOMPFLG (EQ (CAR (SETQ TEM (CADDR DEF)))
				    (QUOTE CLISP:))
		 (AND (EQ (CAR TEM)
			  (QUOTE *))
		      (EQ (CADR TEM)
			  (QUOTE DECLARATIONS:]
	      (PRINT (LIST (QUOTE dwimifying)
			   FN)
		     T T)
	      (RESETVAR FILEPKGFLG NIL (DWIMIFY0 DEF FN]
          (AND (NEQ (POSITION T)
		    0)
	       (TERPRI T))
          (RETURN (COMPILE2 FN DEF])

(FILECHECK
  [LAMBDA (FILE)

          (* Used by BCOMPL, BRECOMPILE, RCOMPILE1 
          (TCOMPL AND RCOMPILE) and TCOMPL.
          Tries to open FILE, if unsuccessful, corrects spelling on 
          FILE. Value is (corrected) FILE.
          In all cases, if cannot open FILE or correct spelling, gives 
          an error.)


    (PROG (Y)
          (RETURN (COND
		    ((OR (NULL FILE)
			 (EQ FILE T))
		      FILE)
		    ((SETQ Y (INFILEP FILE))
		      Y)
		    ((AND DWIMFLG (EQ (NAMEFIELD FILE T)
				      FILE)
			  (SETQ Y (MISSPELLED? FILE 70 FILELST T))
			  (SETQ Y (INFILEP Y)))

          (* No spelling correction if version number specified, or a 
          directory field is used.)


		      Y)
		    (T (INFILE FILE)

          (* Causes the appropriate error.
          The CLOSEF is in case INFILE has error corection to find the 
          corect name for FILE.)


		       (CLOSEF (INPUT])

(COMPEM
  [LAMBDA (X Y)

          (* Y is NIL when called from COMP.
          Just prints X and goes on. Otherwise generates non-helpable 
          error.)


    (COND
      ((NULL Y)
	(PRIN1 (QUOTE "

*****")
	       T)
	(PRINT X T T))
      (T (PRIN1 (QUOTE "*****")
		T)
	 (ERROR X Y T])

(GETCFILE
  [LAMBDA (FILES CFILE FN)
    (PROG (X)
          [COND
	    ([NLSETQ (RESETVAR HELPFLAG NIL (SETQ X (INFILE CFILE]

          (* The reason it is done this way instead of with an INFILEP 
          is that the user may have specified corrective action when 
          INFILE fails via ERRORFNS, e.g. check anther directory, 
          spelling correct, etc.)


	      (RETURN X))
	    ((NULL DWIMFLG)                     (* Let the error happen.)
	      (RETURN (INFILE CFILE]
          (TERPRI T)
          (DWIMESS CFILE T)
          (PRIN1 (QUOTE " not found, shall I ")
		 T)
          (PRIN2 FN T T)
          (SPACES 1 T)
          (PRIN2 (COND
		   ((AND (LISTP FILES)
			 (NULL (CDR FILES)))
		     (CAR FILES))
		   (T FILES))
		 T T)
          (COND
	    ((EQ (DWIMREADC DWIMWAIT (QUOTE Y)
			    (QUOTE " instead ?  "))
		 (QUOTE Y))
	      (APPLY* FN FILES)
	      (RETURN)))
          (DWIMESS (QUOTE "Shall I just forget about compiling ")
		   T)
          (PRIN2 FILES T T)
          (COND
	    ((EQ (DWIMREADC DWIMWAIT (QUOTE Y)
			    (QUOTE " ?  "))
		 (QUOTE Y))
	      [COND
		((OR (EQ (CAR READBUF)
			 (QUOTE ST))
		     (EQ (CAR READBUF)
			 (QUOTE F)))            (* E.g. From CLEANUP.)
		  (SETQ READBUF (CDR READBUF]
	      (APPLY* (QUOTE BCOMPL3)
		      NIL NIL FILES)
	      (RETURN NIL)))
          (PRIN1 (QUOTE "Then what shall I use for CFILE ?  ")
		 T)
          (RETURN (GETCFILE FILES (READ T T)
			    FN])
)
  (RPAQ DWIMIFYCOMPFLG)
  (RPAQQ NOLINKFNS (HELP ERRORX ERRORSET EVALV FAULTEVAL INTERRUPT SEARCHPDL 
			 MAPDL BREAK1 EDITE EDITL))
  (RPAQ LINKFNS)
  (RPAQ RETFNS)
  (RPAQ BLKAPPLYFNS)
  (RPAQ DONTCOMPILEFNS)
  (RPAQQ SPECVARS (HELPCLOCK LISPXHIST))
  (RPAQ BLKLIBRARY)
  (RPAQQ BLKLIBRARYFNS (MEMB ASSOC EQUAL LAST LENGTH NTH GETP NLEFT NCONC1 
			     LISPXWATCH))
  (RPAQ LOCALFREEVARS)
  [RPAQ COMPILEHEADER (COND (SPAGHETTIFLG (QUOTE "compiled on "))
			    (T (QUOTE "COMPILED ON "]
  (RPAQQ COMPILE.EXT COM)
  (RPAQQ COMPSETLST
	 (ST F STF S Y YES N NO 1 2 NIL T TTY TTY:))
(DEFLIST(QUOTE(
  [MEMB (LAMBDA (X Y)
		(PROG NIL LP (RETURN (COND ((NLISTP Y)
					    NIL)
					   ((EQ X (CAR Y))
					    Y)
					   (T (SETQ Y (CDR Y))
					      (GO LP]
  [ASSOC (LAMBDA (XSAS YSAS)
		 (PROG NIL LP [COND ((NLISTP YSAS)
				     (RETURN))
				    ((EQ (CAAR YSAS)
					 XSAS)
				     (RETURN (CAR YSAS]
		       (SETQ YSAS (CDR YSAS))
		       (GO LP]
  [EQUAL (LAMBDA (X Y)
		 (COND ((EQ X Y))
		       [(NLISTP X)
			(COND ((NUMBERP X)
			       (EQP X Y))
			      ((STRINGP X)
			       (STREQUAL X Y]
		       ((NLISTP Y)
			NIL)
		       ((EQUAL (CAR X)
			       (CAR Y))
			(EQUAL (CDR X)
			       (CDR Y]
  [LAST (LAMBDA (X)
		(PROG (XX)
		      L
		      (COND ((NLISTP X)
			     (RETURN XX)))
		      (SETQ XX X)
		      (SETQ X (CDR X))
		      (GO L]
  [LENGTH (LAMBDA (X)
		  (PROG NIL (LAPPUSH0)
			LP
			[COND ((NLISTP X)
			       (RETURN (LAPPOP]
			(SETQ X (CDR X))
			(LAPADD1)
			(GO LP]
  [NTH (LAMBDA (X N)
	       (COND ((IGREATERP 1 N)
		      (CONS NIL X))
		     (T (PROG NIL LP (COND ((NOT (IGREATERP N 1))
					    (RETURN X))
					   ((NLISTP X)
					    (RETURN NIL)))
			      (SETQ X (CDR X))
			      (SETQ N (SUB1 N))
			      (GO LP]
  [GETP (LAMBDA (ATM PROP)
		(AND (LITATOM ATM)
		     (PROG ((Z (CDR ATM)))
			   LOOP
			   [COND ((NLISTP Z)
				  (RETURN NIL))
				 ((EQ (CAR Z)
				      PROP)
				  (RETURN (CADR Z]
			   (SETQ Z (CDDR Z))
			   (GO LOOP]
  [NLEFT (LAMBDA (L N TAIL)
		 (PROG ((X L))
		       LP
		       (COND ((ZEROP N)
			      (GO LP1))
			     ((OR (EQ X TAIL)
				  (NLISTP X))
			      (RETURN NIL)))
		       (SETQ X (CDR X))
		       (SUB1VAR N)
		       (GO LP)
		       LP1
		       (COND ((OR (EQ X TAIL)
				  (NLISTP X))
			      (RETURN L)))
		       (SETQ X (CDR X))
		       (SETQ L (CDR L))
		       (GO LP1]
  [NCONC1 (LAMBDA (LST X)
		  (NCONC LST (FRPLACD (CONS X LST]
  [LISPXWATCH (LAMBDA (STAT N)
		      (AND (ARRAYP STAT)
			   (VAG (CLOSER (LOC STAT)
					(IPLUS (OPENR (LOC STAT))
					       (OR N 1]
))(QUOTE BLKLIBRARYDEF))
(DEFLIST(QUOTE(
  (XNLSETQ ((X FLG FN)
	    (.ERRSETQ. X FLG FN)))
  [UNDONLSETQ ((UNDOFORM UNDOFN)
	       (PROG ((LISPXHIST LISPXHIST)
		      UNDOSIDE0 UNDOSIDE UNDOTEM)
		     [COND ([LISTP (SETQ UNDOSIDE (GET LISPXHIST (QUOTE SIDE]
			    (SETQ UNDOSIDE0 (CONS (CAR UNDOSIDE)
						  (CDR UNDOSIDE)))
			    (FRPLACA UNDOSIDE -1))
			   (T (SETQ LISPXHIST (PUTL LISPXHIST (QUOTE SIDE)
						    (SETQ UNDOSIDE
							  (LIST -1]
		     (SETQ UNDOTEM (XNLSETQ UNDOFORM NIL UNDOFN))
		     [COND ((NULL UNDOTEM)
			    (FRPLACD (NLEFT UNDOSIDE 1 (CDR UNDOSIDE0)))
			    [MAPC (CDR UNDOSIDE)
				  (FUNCTION (LAMBDA
					      (X LISPXHIST)
					      [COND ((LISTP (CAR X))
						     (/RPLNODE (CAR X)
							       (CADR X)
							       (CDDR X)))
						    (T (APPLY (CAR X)
							      (CDR X]
					      (LISPXWATCH UNDOSTATS]
			    (FRPLACD UNDOSIDE (CDR UNDOSIDE0]
		     (FRPLACA UNDOSIDE (OR (CAR UNDOSIDE0)
					   0))
		     (RETURN UNDOTEM]
  [RESETVAR ((VAR VAL FORM)
	     (PROG (MACROX MACROY)
		   (SETQ MACROX (SETQ RESETVARSLST
				      (CONS (CONS (QUOTE VAR)
						  (CAR (QUOTE VAR)))
					    RESETVARSLST)))
		   (SETQ MACROY (XNLSETQ (PROGN (FRPLACA (QUOTE VAR)
							 VAL)
						FORM)
					 INTERNAL))
		   (FRPLACA (QUOTE VAR)
			    (CDAR MACROX))
		   (SETQ RESETVARSLST (CDR MACROX))
		   [COND (MACROY (RETURN (CAR MACROY]
		   (ERROR!]
  [RESETFORM
    (OPENX (SUBPAIR (QUOTE (X FORM FORM1 FN))
		    (LIST (CAR OPENX)
			  (CADR OPENX)
			  (AND (CADDR OPENX)
			       (LIST (QUOTE PROGN)
				     (CADDR OPENX)))
			  (CAAR OPENX))
		    (QUOTE (PROG ((MACROX (SETQ
					    RESETVARSLST
					    (CONS (LIST (LIST (QUOTE FN)
							      X))
						  RESETVARSLST)))
				  (MACROY (XNLSETQ FORM INTERNAL)))
				 (SETQ RESETVARSLST (CDR MACROX))
				 (APPLY (QUOTE FN)
					(CDAAR MACROX))
				 [COND (MACROY (RETURN (CAR MACROY]
				 FORM1
				 (ERROR!]
  [RESETLST (X (SUBPAIR (QUOTE FORMS)
			(CONS (QUOTE PROGN)
			      X)
			(QUOTE (PROG ((RESETVARSLST0 RESETVARSLST)
				      RESETY RESETZ)
				     (SETQ RESETVARSLST0 RESETVARSLST)
				     (SETQ RESETY (XNLSETQ FORMS INTERNAL))
				     (RESETRESTORE RESETVARSLST0)
				     [COND (RESETY (RETURN (CAR RESETY]
				     (ERROR!]
  [RESETSAVE
    (X (LIST (QUOTE SETQ)
	     (QUOTE RESETVARSLST)
	     (LIST (QUOTE CONS)
		   [COND [(AND (ATOM (CAR X))
			       (CAR X))
			  (SUBPAIR (QUOTE (VAR VAL))
				   X
				   (QUOTE (PROG1 (CONS (QUOTE VAR)
						       VAR)
						 (FRPLACA (QUOTE VAR)
							  VAL]
			 (T (LIST (QUOTE LIST)
				  (COND ((CDR X)
					 (LIST (QUOTE PROG1)
					       (CADR X)
					       (CAR X)))
					(T (LIST (QUOTE LIST)
						 (LIST (QUOTE QUOTE)
						       (CAAR X))
						 (CAR X]
		   (QUOTE RESETVARSLST]
  (* (X (QUOTE INSTRUCTIONS)))
  (FRPLNODE ((X A D)
	     (FRPLACD (FRPLACA X A)
		      D)))
))(QUOTE MACRO))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA BLOCK:)
  (ADDTOVAR NLAML BCOMPL3A)
]
  (LISPXPRINT (QUOTE COMPILECOMS)
	      T T)
  [RPAQQ COMPILECOMS
	 ((FNS * COMPILEFNS)
	  [VARS (DWIMIFYCOMPFLG)
		(NOLINKFNS (QUOTE (HELP ERRORX ERRORSET EVALV FAULTEVAL 
					INTERRUPT SEARCHPDL MAPDL BREAK1 EDITE 
					EDITL)))
		(LINKFNS)
		(RETFNS)
		(BLKAPPLYFNS)
		(DONTCOMPILEFNS)
		(SPECVARS (QUOTE (HELPCLOCK LISPXHIST)))
		(BLKLIBRARY)
		(BLKLIBRARYFNS (QUOTE (MEMB ASSOC EQUAL LAST LENGTH NTH GETP 
					    NLEFT NCONC1 LISPXWATCH)))
		(LOCALFREEVARS)
		[COMPILEHEADER (COND (SPAGHETTIFLG (QUOTE "compiled on "))
				     (T (QUOTE "COMPILED ON "]
		(COMPILE.EXT (QUOTE COM))
		(COMPSETLST (QUOTE (ST F STF S Y YES N NO 1 2 NIL T TTY TTY:]
	  (PROP BLKLIBRARYDEF * BLKLIBRARYFNS)
	  (PROP MACRO XNLSETQ UNDONLSETQ RESETVAR RESETFORM RESETLST RESETSAVE 
		* FRPLNODE)
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
		    (ADDVARS (NLAMA BLOCK:)
			     (NLAML BCOMPL3]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA BLOCK:)
  (ADDTOVAR NLAML BCOMPL3)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (1385 40839 (BCOMPL 1397 . 5539) (BCOMPL1 5543 . 6375) (BCOMPL1A
6379 . 9538) (BCOMPL2 9542 . 13063) (BCOMPL3 13067 . 14072) (BLOCK: 14076
. 14341) (BRECOMPILE 14345 . 21615) (BRECOMPILE1 21619 . 24330) (BRECOMPILE2
24334 . 24869) (BRECOMPILE3 24873 . 26035) (BLOCKCOMPILE 26039 . 26872) (
BLOCKCOMPILE1 26876 . 29678) (COMPSET 29682 . 32236) (COMPSETREAD 32240 .
35099) (COMPSETY 35103 . 35211) (COMPSETF 35215 . 35342) (RCOMP3 35346 . 36591)
(TCOMPL 36595 . 36841) (RECOMPILE 36845 . 36921) (RECOMP? 36925 . 37203) (
COMPILE 37207 . 37591) (COMPILE1 37595 . 38052) (FILECHECK 38056 . 39009)
(COMPEM 39013 . 39323) (GETCFILE 39327 . 40836)))))
STOP
