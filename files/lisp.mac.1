;<NEWLISP>LISP.MAC;55    18-OCT-74 04:35:51    EDIT BY LEWIS
; SPLICE MACRO RETURINGING ATOM AT FIRST READ IS LIKE NIL
;<NEWLISP>LISP.MAC;54    17-OCT-74 19:58:55    EDIT BY LEWIS
; fix cr followed by non-lf problem.
;<NEWLISP>LISP.MAC;53    17-OCT-74 01:01:31    EDIT BY LEWIS
; FIX MORE BETWEEN CONTROL/RAISE AND READMACROS
;<NEWLISP>LISP.MAC;52    16-OCT-74 21:08:42    EDIT BY LEWIS
; DONT HAVE FILE OUTPUT SEARCH GO TO IFSCG
;<LEWIS>LISP.MAC;1    15-OCT-74 22:33:31    EDIT BY LEWIS
; make ccodep return t for swapped fns
;<NEWLISP>LISP.MAC;49    15-OCT-74 19:44:03    EDIT BY LEWIS
; FIX IFSCH TO SAVE AND RESTORE READTABLE IN AC2
;<NEWLISP>LISP.MAC;48    11-OCT-74 23:23:37    EDIT BY LEWIS
; FIX INTERACTIONS BETWEEN CONTROL/RAISE AND READMACROS
;<NEWLISP>LISP.MAC;47    11-OCT-74 12:52:08    EDIT BY LEWIS
; FIX INTER.RAISE PROBLEM WITH CONTRL=T, AND CONTROL(T) ALWAYS RET.NIL
;<NEWLISP>LISP.MAC;46    10-OCT-74 12:11:49    EDIT BY LEWIS
; MAKE ^V ALSO WORK WITH LOWER CASE LETTERS
; TAKE OUT 0/1 FROM CONTROL AND MAKE SYSOUT CLEAR, NOT CLOSE FILE TABLE
;<LEWIS>LISP.MAC;8     9-OCT-74 16:43:34    EDIT BY LEWIS
; FIX BKLINBUF CHAR COUNT BUG
;<LEWIS>LISP.MAC;7     9-OCT-74 14:12:14    EDIT BY LEWIS
; PUT RAISE ON TERM.TBL, MAKE MODE T BE 0, DEFINE T AS "INTERNAL RAISE"
;<NEWLISP>LISP.MAC;42     8-OCT-74 14:29:20    EDIT BY LEWIS
; FIX PEEKC WAKEUP PROBLEM
;<LEWIS>LISP.MAC;4     6-OCT-74 13:42:37    EDIT BY LEWIS
; MAKE CONTROL TAKE TERM.TABLE AND ADD ECHOMODE
;<LEWIS>LISP.MAC;1     6-OCT-74 11:08:09    EDIT BY LEWIS
; PUT NO-EOL-CHECK FLAG INTO READP
;<LEWIS>LISP.MAC;12     5-OCT-74 02:40:26    EDIT BY LEWIS
; DOUBLED ADDR. SPACE FOR SUBR ENTRIES FOR 20000 TO 40000
;<LEWIS>LISP.MAC;7     4-OCT-74 10:57:22    EDIT BY LEWIS
; ADDED EXTRA MESSAGES TO ^A
;<LEWIS>LISP.MAC;15     1-OCT-74 05:19:50    EDIT BY LEWIS
; SEPERATE EDIT AND CTL.CH.ECHO FROM READTABLES INTO TERMINAL TABLES
;<LEWIS>LISP.MAC;5    24-SEP-74 20:14:46    EDIT BY LEWIS
;<LEWIS>LISP.MAC;4    23-SEP-74 20:26:29    EDIT BY LEWIS
; MAKE SETBRK GIVE ERROR IF 1ST ARG NOT LIST
;<LEWIS>LISP.MAC;1    23-SEP-74 19:23:28    EDIT BY LEWIS
; FIX ^E SWAPPING BUG IN CHEKBR AND BAD FLTPT. OUTPUT FORMAT BUG.
;<LEWIS>LISP.MAC;4    19-SEP-74 20:40:53    EDIT BY LEWIS
; FIX NCHARS, CHCON, UNPACK, NTHCHAR (AND IPRE2) TO TAKE A READTABLE ARG
;<NEWLISP>LISP.MAC;33    19-SEP-74 09:51:35    EDIT BY LEWIS
; FIX INFIX MACROS
;<NEWLISP>LISP.MAC;32    16-SEP-74 07:07:41    EDIT BY LEWIS
; READTABLE FNS USE ORIG INSTEAD OF RESET TO REF. PRISTINE TABLE.
;<LEWIS>LISP.MAC;3    16-SEP-74 04:23:26    EDIT BY LEWIS
; ADD RESETREADTABLE AND COPYREADTABLE, CHANGE SOME OTHER RDTBL FNS
;<NEWLISP>LISP.MAC;30    14-SEP-74 05:14:01    EDIT BY LEWIS
; INSTALL READTABLES AS OPTIONAL ARGS TO I/O FNS, REMOVE USER READ.
;<HARTLEY>LISP.MAC;2     1-SEP-74 01:47:56    EDIT BY HARTLEY
; ADDED COREVAL FOR POPTAB
;<HARTLEY>LISP.MAC;1    29-AUG-74 02:08:28    EDIT BY HARTLEY
; FIX ERROR! CLEARING STKFLG
;<HARTLEY>LISP.MAC;1    27-AUG-74 20:42:40    EDIT BY HARTLEY
; CLEAN-UP ERRDSP
;<LEWIS>LISP.MAC;4    12-AUG-74 23:49:14    EDIT BY LEWIS
; FIX RETF1 SO AC1 IS RESTORED ON ERROR
;<NEWLISP>LISP.MAC;27     5-AUG-74 02:51:01    EDIT BY LEWIS
;<NEWLISP>LISP.MAC;21     4-AUG-74 15:25:38    EDIT BY LEWIS
; PUT NAME AND #ARGS ON STK WHEN COMPILED CODE CALLS U.D.F.
; CHANGED FORMAT OF SWAPPER ERROR MESSAGES
; RESURECTED STKCALL
;<NEWLISP>LISP.MAC;17    17-JUL-74 21:56:43    EDIT BY LEWIS
; RESTORE SWAPPING BUFFER ON PDL OVERFLOW
;<LEWIS>LISP.MAC;4    13-JUL-74 01:25:19    EDIT BY LEWIS
;<LEWIS>LISP.MAC;2    13-JUL-74 00:23:40    EDIT BY LEWIS
; MORE ENABLE/DISABLE
;<NEWLISP>LISP.MAC;15     9-JUL-74 19:52:30    EDIT BY LEWIS
; ADDED COREVALS FOR FAST FN-OPENR/CLOSER FNS
;<NEWLISP>LISP.MAC;14     9-JUL-74 01:14:59    EDIT BY LEWIS
; ADDED FN-OPENR/CLOSER FNS
;<NEWLISP>LISP.MAC;13     3-JUL-74 19:35:07    EDIT BY LEWIS
; FIXED ENABLECHAR AND DISABLECHAR
;<LEWIS>LISP.MAC;1    13-JUN-74 06:43:51    EDIT BY LEWIS
; FIXED BUG IN RSTRING DUE TO READTABLES
;<LEWIS>LISP.MAC;1    10-JUN-74 10:53:18    EDIT BY LEWIS
; FIXED BUG IN UNBUFFERED READ
;<LEWIS>LISP.MAC;1     9-JUN-74 00:35:39    EDIT BY LEWIS
; FIXED READP FOR READING STRINGS
;<LEWIS>LISP.MAC;4     8-JUN-74 05:27:34    EDIT BY LEWIS
; FIXED BACKTRACE FOR WARREN
;<LEWIS>LISP.MAC;1     7-JUN-74 20:51:15    EDIT BY LEWIS
; FIXED STKNTH FOR WARREN
;<LEWIS>LISP.MAC;2     6-JUN-74 04:15:50    EDIT BY LEWIS
; FIXED BUG IN GNC AND ADDED READING FROM STRINGS
;<LEWIS>LISP.MAC;8     5-JUN-74 04:23:23    EDIT BY LEWIS
; FIXED SQBRK AND ADDED USER INTERRUPT CHARACTERS
;<NEWLISP>LISP.MAC;3     3-JUN-74 19:53:20    EDIT BY LEWIS
; FIX ESCAPE ALWAYS RETURNING NIL PROBLEM
;<GOODWIN>LISP.MAC;20    24-MAY-74 07:57:04    EDIT BY GOODWIN
;Fixed FTRP1 to relocate right to find freevar vector.
;<GOODWIN>FIE.;100018     3-MAY-74 04:03:36	EDIT BY GOODWIN
; - INSTALLING SWAPPER, FLUSH E+S DISPLAY SWITCHED CODE. JWG
;<FLIP>LISP.MAC;82    23-APR-74 15:17:47	EDIT BY LEWIS
;<FLIP>LISP.MAC;81     7-APR-74 00:45:13	EDIT BY LEWIS
;INSERTED ALICE'S CHANGES FOR PRXFLG
;<FLIP>LISP.MAC;80    31-MAR-74 14:25:15	EDIT BY LEWIS
;<FLIP>LISP.MAC;2    18-MAR-74 21:04:05	EDIT BY LEWIS
;<FLIP>LISP.MAC;1    19-FEB-74 00:25:30	EDIT BY LEWIS
;<FLIP>LISP.MAC;5    18-FEB-74 01:53:47	EDIT BY LEWIS
;<FLIP>LISP.MAC;3    17-FEB-74 19:46:52	EDIT BY LEWIS
;<FLIP>LISP.MAC;3    17-FEB-74 03:40:14	EDIT BY LEWIS
;<FLIP>LISP.MAC;3    11-FEB-74 18:02:52	EDIT BY LEWIS
;<HARTLEY>LISP.MAC;24     6-FEB-74 19:19:16	EDIT BY HARTLEY
;<HARTLEY>LISP.MAC;21     6-FEB-74 02:16:23	EDIT BY HARTLEY
;<FLIP>LISP.MAC;3     5-FEB-74 08:51:52	EDIT BY LEWIS
;<LEWIS>LISP.MAC;1     5-FEB-74 07:08:47	EDIT BY LEWIS
;<FLIP>LISP.MAC;2     3-FEB-74 09:40:53	EDIT BY LEWIS
;<HARTLEY>LISP.MAC;16     1-FEB-74 21:02:51	EDIT BY HARTLEY
;<HARTLEY>LISP.MAC;8    31-JAN-74 03:16:13	EDIT BY HARTLEY
;<FLIP>LISP.MAC;8    30-JAN-74 02:07:36	EDIT BY LEWIS

TITLE LISP


;SYSTEM SWITCH, 0 FOR TENEX, 1 FOR 10/50

IFNDEF TEN50,<TEN50==0>

IFN TEN50,<
	EXTERN CIO,FINIT,INFIL,OUTFIL,RFNM,CLOSEF
	EXTERN JOBSYM,JOBSA,JOBREL,JOBDDT,JOBREN,JOBOPC,JOBFF
>
	IF1,<PURGE CDR>

IFE TEN50,<SYSDAT=777	;DATE OF CREATION - FOR SYSIN CHECK
	SEARCH	STENEX		;USE TENEX JSYS'S
>
;PARAMETERS

NPM==1000		;MAX NUMBER OF PAGES IN SYSTEM
NPS==1000		;PAGE SIZE
LPS==11		;LOG OF PAGE SIZE
MPS==NPS-1	;PAGE MASK

;INITIAL ALLOCATIONS (NUMBER OF PAGES)

NLW==4		;LIST WORDS
NAT==6		;ATOMS
NHT==20		;ATOM HAST TABLE - MUST BE POWER OF 2
NFN==1		;FLOATING NUMBERS
NNM==1		;INTEGER NUMBERS

NPN==4		;PNAME STRINGS
NST==1		;REGULAR STRINGS
NSP==1		;STRING POINTERS
NAR==3		;ARRAYS
NHDL==1		;HANDLES

;INITIAL SIZES

NCP==7000		;CONTROL STACK
NPP==7000		;PARAMETER STACK
NNP==1000		;NUMBER STACK
NIP==24		;INTERRUPT LEVEL STACK

NFILES==20

NFRKS==4		;NUMBER OF FORKS FOR SHADOW SPACE
MFRKS==3		;MASK FOR ABOVE

;AC ASSIGNMENTS

CP=17		;CONTROL STACK
PP=16		;PARAMETER STACK
NP=15		;NUMBER STACK
BR=14		;BASE REGISTER FOR SELF-RELOCATING (SWAPPED) CODE.
FF=13		;BLOCK COMPILER FREE VAR PTR

TP=12		;FOR UUO DECODE
TF=11		;TEMP FLAGS
FX=10		;FILE INDEX
F=0		;FLAGS

;MISC

EOL=37		;END OF LINE CHARACTER
ESC=45		;% - ESCAPE CHAR, I.E. ONE SHOT QUOTE

NCHRS=1000	;SIZE OF CHARACTER PSEUDO-SPACE
ACHAR==400			;ADDRESS OF FIRST CHAR

MSN==6000	;SIZE OF SMALL NUMBER PSEUDO-SPACE
ASZ=MSN/2+NCHRS	;SMALL NUMBER ZERO

MINWPP==20	;CONS - MIN FREE WORDS FOR PAGE TO RECEIVE NEW LIST
NATMC==143		;MAX NUMBER OR CHARS IN ATOM

;FLAGS - RIGHT HALF ARE TEMPORARY

NEGFLG==1	;ATOM CONSTRUCTER - MINUS SIGN SEEN
LETFLG==2	; - LETTER SEEN
QFLG==4		; - Q WAS LAST CHAR
DIGFLG==10	; - DIGIT SEEN
FLTFLG==20	; - FLOATING INDICATION
RQTFLG==40	;DOUBLEQUOTED ATOM
LREAD==100	;RATOM - LISP READ
RATFLG==200	;- IN RATOM OR RSTRING
CHFLG==400	; - CHARACTER PACKED
RMFLG==1000	;READ BLIP ON STACK
ESCFLG==2000	;ESCAPE FLAG - LINE BUFFER
GCHDQF==4000	;WITHIN DOUBLE-QUOTE, LINE BUFFER
RDMFLG==10000	; - IN A READMACRO
ERQFLG==20000	;KEYBOARD ERROR REQUEST PENDING
REEFLG==40000	;INTERRUPT SERVICE (REENTER) IN PROGRESS
INTFLG==100000	;KEYBOARD INTERRUPT REQUEST
SEPFLG==200000	;SEPARATOR PRECEEDED ATOM
GCFLG==400000	;DOING GC

; - LEFT HALF ARE PERMANENT

PNEGF==1		;PRINT NEG NUMBER WITH SIGN
LBFFLG==2		;NO LINEBUFFERING
RASFLG==4		;INTERNAL INPUT RAISE FLAG
GCF==10		;TEMP FLAG FOR GC
GCMF==20		;GC MOVE FLAG-ANY PAGES MOVING
GCCF==40		;GC COMPACT FLAG-ANY TYPE COMPACTING
GCPF==100		;GC CHANGE POINTER FLAG-GEN TYPE COMPACTING
			;...OR PAGES SHUFFLING
STKFLG==200		;STACK HAS SKIP BLIP
CNSFLG==400		;FRECNT=FREBRK
NEGPLF==1000		;NEGATIVE PRINTLEVEL FLAG
PRPFLG==2000		;JUST PRINTED RIGHT PAREN
NCRFLG==4000		;NO EOL ON CLOSING PAREN IN READ
BKFLG==10000		;PUTTING STRING IN LINE BUFFER
NACFLG==20000		;DISALLOW NON-ATOMIC CAR
EVLFLG==40000		;...BUT PERMIT BELOW FIRST LEVEL
HDLFLG==100000		;FOR GC - HANDLE CHASE IN PROGRESS
PDQFLG==200000		;PRINT ESCAPES IN ATOMS AND STRINGS
PRXFLG==400000			;USE RADIX FOR NUMBERS

;MACROS AND DEFS

	OPDEF CALL [PUSHJ CP,0]
	OPDEF RET [POPJ CP,0]

;CAR AND CDR
;A IS DESTINATION ACCUMULATOR
;Y IS SOURCE, AC OR STORAGE

	DEFINE CARA (A,Y)
<	BB=0
	IFG Y,<
	IFL Y-20,<
	BB=-1
	HRRZ A,0(Y)>>

	IFE BB,<
	HRRZ A,@Y>>

	DEFINE CDRA (A,Y)
<	BB=0
	IFG Y,<
	IFL Y-20,<
	BB=-1
	HLRZ A,0(Y)>>

	IFE BB,<
	HLRZ A,@Y>>

;TYPE QUOTED STRING

	DEFINE TYPEQ (A)
<	TMSG [SIXBIT @A/@]>

;UNSTEP BYTE POINTER

DEFINE UBP (A)
<	BB==0
	IFG A,<
	IFL A-20,<
	BB=-1
	ADD A,[7B5]
	SKIPG A
	ADD A,[35B5-1]>>

	IFE BB,<
	EXCH 1,A
	UBP 1
	EXCH 1,A>>

;STRING POINTER TO BYTE POINTER CONVERSION

	DEFINE SBPC (C,B)
<	MOVE C,0(B)
	IFE B-C,<PUSH CP,C>
	TLZ C,777770
	IDIVI C,5
	HLL C,CBTAB-1(C+1)
	IFE B-C,<POP CP,C+1>
	IFN B-C,<MOVE C+1,0(B)>
	LSH C+1,-^D21>

;UNBOXED STRING POINTER CONVERSION

	DEFINE USBPC (C,B)
<	MOVE C,B
	IFE B-C,<PUSH CP,C>
	TLZ C,777770
	IDIVI C,5
	HLL C,CBTAB-1(C+1)
	IFE B-C,<POP CP,C+1>
	IFN B-C,<MOVE C+1,B>
	LSH C+1,-^D21>

;DEFINE STORAGE WORD OR BLOCK

	DEFINE U (A,B)
<	A=BEGTMP+ZZ
	IFB <B>,<ZZ=ZZ+1>
	IFNB <B>,<ZZ=ZZ+B>>

ZZ=0
IFN TEN50,<
BEGTMP=2400	;FOLLOWING FILEIO. THIS IS FOR 10-50 GOODWIN!!
	HISEG
>
IFE TEN50,<
BEGTMP==25000	;THIS IS FOR TENEX, GOODWIN YOU TURKEY.>
;THE SUPERFLUOUS COMMENTARY ABOVE SERVES TO PREVENT ME FROM
;MYOPICALLY CHANGING THE FIRST BEGTMP= I CAN FIND IN THE TEXT EDITOR
;WHEN IT COMES TIME TO INCREASE IT AGAIN AND THEREBY LOSING. JWG.
;SOMEDAY WE'LL LEARN TO AVOID CUT-AND-TRY METHODS.

;LOAD TYPE NUMBER INTO AC
;A-DESTINATION AC, C-SOURCE AC IF SUPPLIED

	DEFINE LDT (A,C)
<	IFNB <C>,<
	HRRZ A,C>
	LSH A,-LPS
	HRRZ A,TYPTAB(A)
	ANDI A,77>

;SKIP TYPE EQUAL, NOT EQUAL
;A-SOURCE AC, B-TYPE

	DEFINE STE (A,B)
<	HRRZM A,UUARG1
	PSTE B'T>

	DEFINE STN (A,B)
<	HRRZM A,UUARG1
	PSTN B'T>

;FUNCTION CALL FROM HAND CODE

	DEFINE LCALL (FN,NA)
<	MOVEI 1,NA
	MOVE 2,FN
	PUSHJ CP,EFNCAL
>
;ERROR CALL
;LOC IS LOCATION TO CONTINUE
;N IS ERROR NUMBER
;ERROR1 SUPPLIES VALUE IN AC1

	DEFINE ERROR1 (N,LOC)
<	PERR <N&17>,LOC+<N&60>B24>

;ERROR0 SUPPLIES NO VALUE

	DEFINE ERROR0 (N,LOC)
<	PERR0 <N&17>,LOC+<N&60>B24>

;TERMINAL INTERRUPT STUFF

IFN TEN50,<
	DEFINE SETICH
<	MOVEI 1,20000
	TTCALL 6,1		;READ LINE STATUS
	HRLI 1,400020		;TELMOD (400000) + TELISP (20) BITS
	TTCALL 7,1		;SET LINE STATUS
>
	DEFINE CLRICH
<	MOVEI 1,20000
	TTCALL 7,1
>
;VARIOUS SYSTEM OPS

	OPDEF TIME [CALLI 1,23]	;READ CLOCK IN MS
	OPDEF CLRTIB [TTCALL 11,0]	;CLEAR TTY IN BUF
	OPDEF CLRTOB [TTCALL 12,0]	;CLEAR OUTPUT BUFFER
	OPDEF SKIBNE [TTCALL 13,0]	;SKIPE IN IN BUF NOT EMPTY
	OPDEF BOUT [PUSHJ CP,CIO]	;BYTE OUT
	OPDEF BIN [PUSHJ CP,CIO]	;BYTE IN
	OPDEF CORE [CALLI 2,11]		;SET CORE LIMIT
	OPDEF HALTF [CALLI 12]

	DEFINE GETJRT
<	MOVEI 1,0		;INDICATE CURRENT JOB
	CALLI 1,27		;GET JOB RUN TIME
>
>	;CLOSES IFN TEN50

IFE TEN50,<

JOBSA==120
	DEFINE SETICH
<	CALL SETINT
>

	DEFINE CLRICH
<	MOVE 7,CTCTP		;DEASSIGN TERMINAL INTERRUPT CODES
	HLRZ 1,0(7)
	TRNN 1,400000		;MAKE SURE IT'S REALLY THERE
	DTI
	AOBJN 7,.-3
>
	DEFINE GETJRT
<	MOVEI 1,-5		;INDICATE WHOLE JOB
	RUNTM			;GET JOB RUN TIME
>
;NOT IMPLEMENTED YET

	DEFINE CLRTIB
<	MOVEI 1,100
	CFIBF>

	DEFINE CLRTOB
<	MOVEI 1,101
	CFOBF>

	DEFINE SKIBNE
<	MOVEI 1,100
	SIBE
	SKIPA>
>

;UUO DEFINITIONS

	OPDEF TMSG [1B8]
	OPDEF TCH [2B8]
	OPDEF PERR [3B8]
	OPDEF PSTE [4B8]
	OPDEF PSTN [5B8]
	OPDEF HCCAL [6B8]
	HCCALV==6
	OPDEF EXCAL [7B8]
	OPDEF PERR0 [10B8]
	OPDEF PSTE1 [11B8]
	OPDEF PSTN1 [12B8]
	OPDEF PBIND [13B8]
	OPDEF PBINDN [14B8]
	OPDEF PSTB [15B8]
	OPDEF PSTNB [16B8]
	OPDEF PIBOX [17B8]
	OPDEF PIUNBX [20B8]
	OPDEF PSETN [21B8]
	OPDEF CCALL [22B8]
	OPDEF LNCALL [23B8]
	OPDEF LNCAL2 [24B8]
	OPDEF CKUDT [25B8]
	OPDEF PSTEI [26B8]
	OPDEF PSTNI [27B8]
	OPDEF SBCAL [30B8]
	OPDEF ACCALL [31B8]

;GLOBAL STORAGE

U TYPTAB,NPM		;TABLE OF DATA TYPES AND STATUS

U ARRAYT		;TYPE NUMBERS
U BLOCKT
U CCODET
U HANDLT
U LISTT
U ATOMT
U FLOATT
U FIXT
U SMALLT
U STPTT
U CHART
U PNAMT
U STRNGT
U BTABT

U IBOXCN		;INTEGER BOX COUNT
U FBOXCN		;FLOATING BOX COUNT

U ENDCOR		;END OF ASSIGNED CORE

U NEWCNS		;CONS - LOWEST PAGE WITH SOME FREE WORDS
U LSTCNS		; - LAST CONS
U CNSCNT		; - CONS COUNT
U FREBRK		; - BREAK WHEN FREBRK=FRECNT
U CMINWP		;CONTAINS MINWPP FOR CONS
U OFRECT

U ATOMHT		;ADDRESS OF ATOM HASH TABLE
U MAXATL		;MAX NUMBER OF CHARS IN ATOM (USER SET)
U LINSIZ		;MAX NUMBER OF CHARS PER OUTPUT LINE
U URADIX		;CURRENT OUTPUT RADIX
U ESCONF		;ESCAPE CHAR FLAG - 0=OFF -1=ON
U RMONF		;READMACRO FLAG - 0=OFF -1=ON
;ATOMS

U KNIL
U KT
U KNOB
U KLAM
U KNLA
U KPER
U KFNARG
U KINPUT
U KOUTPUT
U KORIG
U KSYSHS
U KEVAL
U KLPT

U KPRINT		;FUNCTIONS CALLED INTERNALLY
U KREADX
U KAPPLY
U KAPP.
U KEVLQT
U KFAULT
U KFALTA
U KERRX
U KESGAG
U KINT
U KSTVAL
U CURRDT		;READTABLES
U SYSRDT
U CURRT2
U SYSRT2
U PRVIRT
U PRVORT
U BSTAB
U PBTAB
U TTYTBL		;CURRENT TERMINAL TABLE
U KPRXFL		;RADIX FLG FOR INTERNAL PRINT
U HLDMSG		;USER HEARLD MESSAGE
U GCMES2
U GCMESF		;MAYBE USERS GC MESSAGE
NKCELL==GCMESF+1-KNIL		;NUMBER OF K-ATOM CELLS


U FILEA,NFILES+1	;LAST CHAR READ,,FILE NAME ATOM
U FILEN,NFILES		;STATUS FLAGS,,FILE NUMBER
U FCHAR,NFILES+1	;FILE DATA- FLAGS,,ONE CHARACTER BUFFER
U CHPOS,NFILES		; - PAGE POSN,,LINE POSN
; THE NFILES+1 IS TO LEAVE ROOM FOR STRING INPUT

U FRX			;CURRENT READ AND PRINT FILE INDEX
U FPX

U LOGTOD		;LOGIN TIME-OF-DAY
U LOGRT			;LOGIN RUN-TIME
U GCRT			;GARBAGE COLLECTOR RUNTIME

U FNCALL		;XCT 1(2) OR CALL XBREAK

U FR			;STANDARD READ AND PRINT FILES
U FP

U ICP			;INITIAL STACK VALUES
U ICPC		;CONTROL STACK CONSTANT
U IPP
U IPPC		;PARAMETER STACK CONSTANT
U INP
U INPC

U BGNCOR			;BEGINNING OF DATA SPACE

;ABSOLUTE ASSEMBLY OF PAGE 0. BOOTSTRAP TO GET IN THE BOOTSTRAP TO
;GET IN REST OF WORLD, & SOME DATA NEEDED BY SECOND BOOTSTRAP SUCH AS
;SYSDAT, BUFFER FOR FORKHANDLES.
	LOC	140
BBOOT:
	SKIPA
;NEXT WRD IS USED BY BOOTSTRAP TO FIND RETURN CODE FROM SYSIN
	JRST	SYSINR
	HRLZI	1,400000	;THIS FORK PAGE 0 (RIGHT HERE)
	RMAP			;IS JFN FOR SELF
	HLRZ	6,1		;SAVE IT
MBOOT:	HRLZI	1,100001	;ENTER HERE FROM SYSDN1 AFTER MAKESYS
	HRROI	2,BOOTNM
	GTJFN
	 JRST	BLOSE
	HRLI	1,400000
	GET
	HRRZI	1,(6)		;RETRIEVE JFN FOR SELF
	JRST	777000		;GOTO BOOTSTRAP
BLOSE:	HRROI	1,BLOSM
	PSOUT
	HALTF

;THESE MUST BE ON PAGE 0 TOO SO DIDN'T MAKE THEM LITERALS.
BLOSM:	ASCIZ	/CANNOT FIND <LISP>BOOT.SAV/
BOOTNM:	ASCIZ	/<LISP>BOOT.SAV;0/

	LOC	1000-^D48
MYJFNS:	0
MYFRKS:	BLOCK 20
DADDYN:	BLOCK ^D30
DATEWD:	0		;REALLY CALLED SYSDAT.
	RELOC



;TABLE OF COREVALS FOR COMPILER
;IF THESE MOVE VARIABLE COREVALA IN COMPILER MUST BE CHANGED

COREV:	EXP NP
	EXP CP
	EXP PP
	EXP FF
	EXP BR
	EXP ENTERF
	EXP FNCALL
	EXP BHC
	EXP UUARG1
	EXP UUARG2
	EXP UUARG3
	EXP KT		;11
	EXP KNIL
	EXP ARRAYT
	EXP BLOCKT
	EXP CCODET
	EXP BTABT
	EXP LISTT
	EXP ATOMT
	EXP FLOATT
	EXP FIXT
	EXP SMALLT
	EXP STPTT
	EXP CHART
	EXP PNAMT
	EXP STRNGT
	EXP CONS		;30
	EXP IUNBOX
	EXP MKN
	EXP FUNBOX
	EXP MKFN
	EXP GUNBOX
	EXP GBOX
	EXP FXFLT
	EXP FLTFX
	EXP ASZ
	EXP TYPTAB
	EXP CLIST
	EXP EVCC
	EXP UPATM
	EXP IPRE
	EXP IPRE2
	EXP FILEN
	EXP IFSET
	EXP OFSET
	EXP FX
	EXP FIN
	EXP FOUT
	EXP IOFNMP
	EXP HCRET
	EXP ERRSET
	EXP ICPC
	EXP SETINT
	EXP CTCTP
	EXP IPPC
	EXP INPC
	EXP MKSP
	EXP UNP1
	EXP MKSTR1
	EXP MKSTRS
	EXP FILEA
	EXP FCHAR
	EXP CNSCNT
	EXP CTRLU
	EXP SETMOD
	EXP REBIND
	EXP UNBIND
	EXP EFNCAL
	EXP RETCAL
	EXP BLKENT
	EXP BLKAPP
	EXP BLKAP.
	EXP HCCALQ
	EXP EXCALQ
	EXP CCALC
	EXP FMEMB
	EXP PPLOOK
	EXP STKARC
	EXP STKNTC
	EXP LINBF3
	EXP IOFN
	EXP GETHSH
	EXP PUTHSH
	EXP GCRT
	EXP IBOXCN
	EXP FBOXCN
	EXP ENTERB
	EXP SBLKNT
	EXP SBCALQ
	EXP ORGRDT
	EXP SWAPIN
	EXP HANDLT
	EXP FFNOPR
	EXP FFNOPA
	EXP FFNOPD
	EXP FFNCLR
	EXP FFNCLA
	EXP FFNCLD
	EXP POPTAB
	BLOCK 4		;FOR EXPANSION

;UUO ROUTINE

POPDSP:	PUSHJ CP,POPCL		;C(41)

POPCL:	HLRZ TP,40
	LSH TP,-^D9
	JRST @POPTAB(TP)

;ARGS TO UUO'S

U UUARG1
U UUARG2
U UUARG3

UUACP:	POINT 4,40,12		;BYTE POINTER TO UUO AC FIELD

;UUO DISPATCH TABLE

POPTAB:	EXP UUUOQ,TMSGQ,TCHQ,ERRQ,STEQ,STNQ,HCCALQ,EXCALQ
	EXP ERR0Q,STE1Q,STN1Q,BINDQ,BINDNQ,STBQ,STNBQ
	EXP IBOXQ,IUBQ,SETNQ,FNCALQ,LCALQ,LCALQ2,CKTUSE
	EXP STEI,STNI,SBCALQ,FNACAL

	REPEAT 6,<EXP UUUOQ>

UUUOQ:	HRROI 1,[ASCIZ /ILLEGAL UUO/]
	PSOUT
	HALTF	;DON'T GO TO TRAP - IT CLOBBERS 40 AND 41!


;TABLE OF FULL WORD CONSTANTS

	XX=-30
	REPEAT 30,<EXP XX*1000001
		XX=XX+1>
BHC:	REPEAT 140,<EXP XX*1000001
		XX=XX+1>

;TABLE OF MIXED HALF WORD CONSTANTS USED BY COMPILED CODE


;TABLE OF 7 BIT BYTE POINTERS

	POINT 7,0,-1
CBTAB:	POINT 7,0,6
	POINT 7,0,13
	POINT 7,0,20
	POINT 7,0,27
	POINT 7,0,34
;UUO-CALLED ROUTINES

;MESSAGE TYPER

TMSGQ:	PUSH CP,1
	HRRZ 1,40		;ADDRESS OF STRING
	PUSH CP,2
	MOVEI 2,1
	HRLI 1,440600
	MOVEM 1,UUARG1		;BYTE POINTER TO STRING
TMSG1:	ILDB 1,UUARG1
	ADDI 1,40		;CONVERT TO ASCII
	CAIN 1,"$"		;$ BECOMES EOL
	JRST TMSG3
	CAIN 1,"/"		;SLASH TERMINATES
	JRST TMSG2
TMSG4:	CALL TCO
	JRST TMSG1

TMSG3:	MOVEI 1,EOL
	JRST TMSG4

TMSG2:	POP CP,2
	POP CP,1
	RET

;I/O TO CONTROL TELETYPE

TCO:	PUSH CP,FX
	MOVEI FX,1
	CALL FOUT
	POP CP,FX
	RET

TCI:	PUSH CP,FX
	MOVEI FX,0
	CALL FIN1		;DON'T INVOKE LINE EDITOR
	POP CP,FX
	RET

EOLM:	SIXBIT '$/'

;SKIP ON TYPE EQUAL TO C(E) OF UUO

STE1Q:	HRRZM 1,UUARG1
STEQ:	EXCH 1,UUARG1		;GET POINTER TO TEST
	LSH 1,-LPS		;GET PAGE ADDRESS
	HRRZ 1,TYPTAB(1)	;GET TYPE NUMBER
	ANDI 1,77
	CAMN 1,@40
	AOS 0(CP)		;EQUAL - SKIP RETURN
	EXCH 1,UUARG1		;RESTORE 1, LEAVE TYPE NUMBER IN UUARG1
	RET

;SKIP TYPE NOT EQUAL

STN1Q:	HRRZM 1,UUARG1
STNQ:	EXCH 1,UUARG1
	LSH 1,-LPS
	HRRZ 1,TYPTAB(1)
	ANDI 1,77
	CAME 1,@40
	AOS 0(CP)
	EXCH 1,UUARG1
	RET

;SKIP IF TYPE BETWEEN C(E) OF  UUO AND SMALLT
;USED FOR ATOM NUMBERP AND FIXP

STBQ:	MOVEM 1,UUARG1
	LDT 1
	CAMGE 1,@40
	JRST .+3
	CAMG 1,SMALLT
	AOS 0(CP)
	EXCH 1,UUARG1
	RET

;SKIP IF TYPE NOT BETWEEN C(E) OF UUO AND SMALLT

STNBQ:	MOVEM 1,UUARG1
	LDT 1
	CAML 1,@40
	CAMLE 1,SMALLT
	AOS 0(CP)
	EXCH 1,UUARG1
	RET

;ERROR IF TYPE NOT EQUAL TO RH(C(E))
;USED BY COMPILED CODE BEFORE SETING A USER DATA TYPE FIELD

CKTUSE:	MOVEM	1,UUARG1		;SAVE POINTER
	LDT	1
	HRRZ	2,@40
	CAIN	1,-ASZ(2)			;IS TYPE CORRECT?
	JRST	CKUOK			;YES- RETURN
	PUSH	NP,40			;NO, SAVE LOC. 40
	MOVE	1,UUARG1		;GET ARG.
	PUSH	CP,FF
	ERROR1	40,.+1			;GENERATE AN ERROR
	POP	CP,FF
	POP	NP,40			;RESTORE LOC. 40
	JRST	CKTUSE			;TRY AGAIN

;SKIP IF TYPE OF 1 EQUALS RH(C(E)) OF UUO

STEI:	MOVEM	1,UUARG1
	LDT	1
	HRRZ	2,@40
	CAIN	1,-ASZ(2)
	AOS	0(CP)
	MOVE	1,UUARG1
	RET

;SKIP IF NOT EQUAL

STNI:	MOVEM	1,UUARG1
	LDT	1
	HRRZ	2,@40
	CAIE	1,-ASZ(2)
	AOS	0(CP)
CKUOK:	MOVE	1,UUARG1
	RET

;BIND ARGS - EFF. ADDR OF UUO IS ADDRESS OF ARG NAMES
;XWD -#ARGS,-#ARGS


BINDQ:	MOVE 2,40
	MOVE 1,@0(CP)
	ADDI 1,1(PP)
	HLL 1,@0(CP)
	HRRZ 3,0(2)
	HRLM 3,0(1)
	ADDI 2,1
	AOBJN 1,.-3
BINDQR:	AOS 0(CP)
	RET

;BIND ARGS TO NIL

BINDNQ:	MOVE 2,40
	MOVE 1,@0(CP)
	HRRZ 3,KNIL
	HRL 3,0(2)
	PUSH PP,3
	ADDI 2,1
	AOBJN 1,.-3
	JRST BINDQR

;BOX EFF ADR FROM COMPILED CODE

IBOXQ:	HRRZ 1,@40
	CAIGE 1,MSN/2
	CAMG 1,[-MSN/2]
	JRST IBOX1
	ADDI 1,ASZ
	RET

IBOX1:	PUSH CP,FF
	CALL MKN1
	POP CP,FF
	RET

;UNBOX EFF ADR FROM COMPILED CODE

IUBQ:	HRRZ 1,@40
IUBQ1:	LDT 2,1
	CAMN 2,SMALLT
	JRST IUBQS
	CAME 2,FIXT
	JRST IUBQ2
	MOVE 1,0(1)
	RET

IUBQS:	SUBI 1,ASZ
	RET

IUBQ2:	CAME 2,FLOATT
	JRST IUBQE
	MOVE 1,0(1)
	JRST FLTFX

IUBQE:	PUSH CP,FF
	ERROR1 12,.+1
	POP CP,FF
	JRST IUBQ1

;SETN FROM COMPIILED CODE, E OF UUO IS VAR LOC
;AC1 NUMBER, 2 TYPE, 3 SP

SETNQ:	HRRZ 4,@40		;OLD VALUE(PTR)
	LDT 5,4
	CAME 5,FIXT
	CAMN 5,FLOATT
	JRST SETN1
	CALL GBOX		;BOX NEW
	HRRM 1,@40		;STORE NEW VAL(PTR)
	RET

SETN1:	MOVEM 1,0(4)		;STORE NEW VAL IN OLD BOX
	MOVEI 1,0(4)		;RET PTR
	RET

;ERROR ROUTINES

;ERROR UUO

ERR0Q:	MOVEI 1,0
ERRQ:	MOVEM 1,ERRVAL		;MESSAGE VALUE
	LDB 1,UUACP		;LOW ORDER 4 BITS OF ERROR NUMBER
	MOVEM 1,ERRNM
	LDB 1,[POINT 2,40,20]	;HIGH ORDER 2 BITS
	LSH 1,4
	IORM 1,ERRNM
	HRRZ 1,40		;CONTINUE LOCATION
	TRZ 1,300000		;FLUSH NUMBER BITS
	MOVEM 1,0(CP)		;REPLACES UUO RETURN ON STACK
	TRNE	F,RMFLG		;READ BLIP?
	PUSH	PP,[READ,,0]	;YES - MAKE SURE READMACROS ARE OFF
	LCALL KERRX,0		;CALL ERRORX
	HLRZ	2,(PP)		;READ BLIP?
	CAIN	2,READ
	SUB	PP,BHC+1	;YES - DELETE IT.
	RET

;SIMPLE ERRORX IF NO EXPR LOADED

ERRX:	MOVEI 1,ERRSET
	CALL PPLOOK		;ERRORSET IN FORCE?
	JRST ERRX1		;NO
	PUSH CP,1		;SAVE ERRORSET POSITION
	HRRZ 2,@KESGAG		;TEST ESGAG
	CAMN 2,KT
	JRST ERRX3		;T => PRINT MESSAGE AND BACKTRACE
	HRRZ 1,-2(1)		;ERRORSET (2ND ARG) FLAG
	CAMN 1,KNIL
	JRST ERRX4		;NO MESSAGE
ERRX3:	CALL ERRORN
	CALL ERRORM		;PRINT MESSAGES
	HRRZ 2,@KESGAG
	CAMN 2,KT
	CALL BACKTR		;T => DO BACKTRACE
ERRX4:	POP CP,1
	CALL UNBLIP		;CLEAR STACKS BACK TO ERRORSET
	JRST FALSE		;RETURN (FROM ERRORSET) NIL

ERRX1:	SKIPE ERRDSP		;ALREADY IN BACKTRACE?
	JRST ERRX5		;YES - DONT DO IT AGAIN
	CALL ERRORN
	CALL ERRORM
ERRX2:	CALL BACKTR
	JRST RESET
ERRX5:	SETZM ERRDSP
	JRST RESET


U ERRDSP

;GET ERROR NUMBER AND MESSAGE OF LAST ERROR

ERRORN:	MOVE 1,ERRVAL		;MESSAGE
	MOVE 2,KNIL
	JUMPE 1,ERRN1		;NO MESSAGE
	CALL CONS
	MOVEI 2,0(1)
ERRN1:	MOVE 1,ERRNM		;NUMBER
	ADDI 1,ASZ		;BOX IT
	JRST CONS

U ERRVAL
U ERRNM

;PRINT ERROR DIAGNOSTIC AND MESSAGE

ERRORM:	PUSH PP,1
	CARA 1,1		;ERROR NUMBER
	CALL IUNBOX
	TMSG EOLM
	TMSG @ERRMT(1)		;DIAGNOSTIC
	TMSG EOLM
	POP PP,1
	CDRA 1,1
	CAMN 1,KNIL		;MESSAGE?
	RET			;NO
	CARA 1,1
	JRST PRINTX

;SET ERROR NUMBER

SERRN:	MOVEM 2,ERRVAL
	CALL IUNBOX
	MOVEM 1,ERRNM
	JRST FALSE
;ERRORSET

ERRSET:	MOVSI 2,ERRSET		;PUT BLIP ON STACK
	HRRI 2,0(CP)
	PUSH PP,2
	CALL EVAL
	MOVE 2,KNIL		;RETURN LIST OF VALUE
	JRST CONS

;ERROR!  DOES QUICK RETURN TO ERRORSET

ERRORF:	MOVEI 1,ERRSET
	CALL PPLOOK		;FIND LAST ERRORSET
	JRST SRESET		;WASNT ONE
	CALL UNBLIP
	JRST FALSE

ERROR:	ERROR1 21,R		;USER INITIATED ERROR

;BACKTRACE

UBAKTR:	CAMN 1,KNIL		;USER BACKTRACE
	MOVEI 1,0(CP)		;FROM CURRENT POS IF ARG1 IS NIL
	CALL STKGP
	 JRST STKERR
	MOVEI 7,0(1)
	HRRZ 1,-1(PP)
	HRRZ 6,ICP		;TO TOP IF ARG 2 IS NIL
	CAMN 1,KNIL
	JRST UBT1
	CALL STKGP
	 JRST STKERR
	MOVEI 6,0(1)
UBT1:	HRRZ 3,0(PP)
	JRST BT

BACKTR:	MOVEI 1,0(CP)		;WHOLE STACK
	HRRZ 2,ICP
	MOVEI 3,ASZ+1		;PRINT VARS, NO FORMS, NO SUBR ARGS
	MOVEI 7,0(1)		;STARTING POINT
	MOVEI 6,0(2)		;ENDING POINT
BT:	SETOM ERRDSP		;SET SPECIAL ERROR DISPATCH
	CAMN 3,KNIL
	MOVEI 3,ASZ+1		;STANDARD IS VARS, NO FORMS NO SUBR ARGS
	MOVEI TF,-ASZ(3)	;SETUP TEMP FLAGS
	TRNN TF,10
	TYPEQ <$UNTRACE:$>
	MOVE 2,KT
	CALL OFSET
	MOVEI 2,1(7)
BT10:	CAILE 2,0(CP)
	JRST BT9
	HRRZ 1,0(2)
	CAIE 1,PPR		;LOOK AHEAD FOR FN CALL
	AOJA 2,BT10
	HRRZ 3,-1(2)		;P-STACK POINTER
	JRST BT2
BT9:	MOVEI 3,0(PP)
BT2:	CAIGE 7,0(6)		;MORE?
	JRST BTVR		;NO
	HRRZ 1,0(7)
	CAIE 1,PPR		;FLAG?
	SOJA 7,BT2		;NO, KEEP SEARCHING
	HRRZ 5,-1(7)		;YES, GET P-STACK POINTER
	HRLI 5,4		;INDEXED BY 4
	HLRZ 4,-2(7)		;NUMBER ARGS ACTUALLY ON STACK
	CAIL 4,200
	JRST BT2		;INSANE # ARGS, GO ON
	TRZ F,NEGFLG
BTV1:	CAIG 3,@5
	JRST BTV3		;NO MORE PROG VARIABLES
	HLRZ 1,0(3)
	CAIN 1,EVBLIP		;FORM?
	JRST BTV4		;YES
	TRNN TF,1		;PRINT VARS?
	JRST BTV2		;NO
	STE 1,ATOM
	JRST BTV2
	TRON F,NEGFLG
	TCH EOL			;BLANK LINE BEFORE FIRST VAR
	TYPEQ <   >
	CALL BT1X
	TCH " "
BTV5:	HRRZ 1,0(3)
	CALL BTPX
BTV2:	SOJA 3,BTV1

BTV4:	TRNN TF,2		;PRINT FORMS?
	JRST BTV2		;NO
	TRON F,NEGFLG
	TCH EOL			;BLANK LINE BEFORE FIRST FORM
	TYPEQ <   *FORM* >
	JRST BTV5

BTV3:	MOVEI 3,0(5)		;SAVE CURRENT TOP OF ARGS
	TRZ F,NEGFLG
	TRNN TF,1		;PRINT VARS (ARGS)?
	JRST BT3		;NO
BT1:	JUMPLE 4,BT3		;NO MORE ARGS TO PRINT
	HLRZ 1,@5		;GET THIS ARG NAME
	JUMPE 1,BT5		;NO NAME
	STE 1,ATOM
	JRST BT5		;STRANGE NAME
	TRON F,NEGFLG
	TCH EOL			;BLANK LINE BEFORE FIRST ARG
	TYPEQ <   >		;INDENT FOR ARG NAME
	CALL BT1X
BT6:	TCH " "
	HRRZ 1,@5		;VALUE
	CALL BTPX
BT1A:	SOJA 4,BT1		;COUNT ARGS

BT5:	TRNN TF,4		;PRINT SUBR ARGS?
	JRST BT1A		;NO
	HRRZ 1,@5
	CAMN 1,KNIL		;IS ARG NOT NIL,
	TRNE F,NEGFLG		;OR ONE OR MORE ALREADY PRINTED?
	JRST .+2		;YES
	JRST BT1A		;NO, DONT PRINT THIS ARG
	TRON F,NEGFLG
	TCH EOL			;BLANK LINE BEFORE FIRST ARG
	TYPEQ <   >		;INDENT
	TYPEQ <ARG>		;USE ARG# FOR UN-NAMED ARGS
	TCH "0"(4)
	JRST BT6

BT3:	TRNE	TF,10		;PRINT FN NAME?
	JRST	BT8		;NO
	HLRZ 1,0(7)		;FN NAME
	STE 1,ATOM
	JRST BT7
	CALL BTPX
BT8:	SUBI 7,2
BT4:	SOJA 7,BT2

BT7:	TYPEQ <***$>
	JRST BT8

BTPX:	CALL SAV27		;SAVE AC'S 2-7
	CALL PRINTX
BT1Y:	CALL RES27
	RET

BT1X:	CALL SAV27
	MOVE 2,KT
	MOVE 3,KT
	CALL PRIN2
	JRST BT1Y

BTVR:	SETZM ERRDSP		;CLEAR SPECIAL ERROR DISPATCH
	JRST TRUE		;RETURNS T IF NORMAL, NIL IF INTERRUPTED

IFN TEN50,<
;PROCESS REENTER - MEANS REQUEST FOR INTERRUPT CONTROL

RSTRT:	TROE F,REEFLG		;REMEMBER INTERRUPT IN PROGRESS
	JRST RSTR3		;ALREADY IN ONE
	MOVEM CP,RSTCP		;SAVE MAIN LEVEL STACK POINTER
	MOVE CP,IIP		;USE LOCAL STACK
	PUSH CP,1
	PUSH CP,JOBOPC		;SAVE RESTART LOC
RSTR4:	CALL TCI	;GET BREAK CHARACTER
	ANDI 1,177
	CAIN 1,10	;^H  HELP
	JRST RST1H
	CAIN 1,20	;^P  SET PRINTLEVEL
	JRST RST1P
	CAIN 1,6	;^F  SET MINFS
	JRST RST1F
	CAIN 1,24	;^T PRINT RUNTIME
	JRST RST1T
	CAIN 1,5	;^E  INITITATE ERROR
	JRST RST1E
	CAIN 1,32	;^Z  RETURN TO TOP
	JRST RST1Z
	JRST RSTC

RSTR3:	MOVE CP,IIP		;RESTORE CP
	ADD CP,BHC+2
	JRST RSTR4

RSTC:	SETICH			;SET INTERRUPT CHARACTERS
	POP CP,JOBOPC		;RETURN TO INTERRUPTED POINT
	POP CP,1
	MOVE CP,RSTCP		;RESTORE MAIN STACK
	TRZ F,REEFLG
	JRSTF @JOBOPC
>

;INTERRUPT ROUTINES

	DEFINE EINT
<	IFE TEN50,<
	JSYS EINTR		;ENTER INTERRUPTED STATE
>>
	DEFINE EINT1
<	IFE TEN50,<
	JSYS EINTR1
>>

IFE TEN50,<
EINTR:	XWD EINTRX,.+1
	MOVEM CP,RSTCP		;SAVE MAIN STACK
	MOVE CP,IIP		;SETUP LOCAL STACK
EINTRA:	PUSH CP,RSTCP
	PUSH CP,1
	JRST @EINTRX

EINTR1:	XWD EINTRX,.+1
	MOVEM CP,RSTCP
	MOVE CP,IIP1
	JRST EINTRA

;RETURN FROM INTERRUPT

RSTC:	POP CP,1
	POP CP,CP		;RESTORE STACK, AC'S
	DEBRK			;DISMISS INTERRUPT

TRAP:	EINT1
	TYPEQ <$TRAP AT LOCATION >
	HRRZ 1,LPC1
	PUSH CP,2
	PUSH CP,3
	CALL PNO8
	POP CP,3
	POP CP,2
	MOVEI 1,DDTC
	MOVEM 1,LPC1
	JRST RSTC

WTRP:	EINT1
	PUSH CP,2
	MOVEI 1,400000
	GTRPW
	PUSH CP,1		;SAVE TRAP WORRD
	PUSH CP,2		;AND WRITE DATA
	MOVEI 1,0(1)
	CAMN 1,FTRAP		;IS IT FREE VAR TRAP?
	JRST FTRP
	LSH 1,-LPS		;PAGE CAUSING TRAP
	CAMN 1,PPTRP
	JRST WTRP1		;MAGIC PP OVERFLOW PAGE
	HRLI 1,400000
	RPACS
	TLNE 2,(1B6)		;INDIRECT PTR?
	JRST WTRP3
	MOVSI 2,130400		;NO
	SPACS			;CHANGE ACCESS
WTRP5:	MOVEI 2,PVTBIT
	IORM 2,TYPTAB(1)
WTRP2:	POP CP,2
	POP CP,1
	TLNN 1,12		;WRITE REQUIRED?
	MOVEM 2,0(1)		;DO THE OFFFENDING  WRITE
	POP CP,2
	JRST RSTC

WTRP1:	SUB CP,BHC+3
	JRST PDLTR1

WTRP3:	PUSH CP,1		;FORK,,PG 1,ACCESS 2
	RMAP
	TLNN 1,400000
	JRST WTRP4		;NOT A FORK
	HRRM 1,0(CP)		;SAVE PAGE #
	HLRZ 2,1
	HLRZ 1,0(CP)		;GET FORK HANDLE USEABLE IN CURRENT
	CALL TGFRKH
	JRST WTRP4		;PUNT
	HRLM 1,0(CP)
	MOVE 1,0(CP)
	RPACS			;GET IMM AND INDIR ACCESS
	TLNE 2,(1B6)		;INDIR?
	JRST WTRP3+1		;YES - GO TIL ISNT
WTRP4:	POP CP,1
	MOVSI 2,130400
	SPACS
	TLNN 1,377777
	JRST WTRP5
	CALL FRKHN		;TRANS FORM FORK HANDLE TO NUMBER
	MOVEI 2,FPVTBT
	CALL SFRKB		;SET PVT BIT
	JRST WTRP2

;The following is a temporary GFRKH routine. There are several
;problems. GFRKH is not yet implemented at PARC and other places still
;running Tenex 1.31. It is in 1.32 and versions of 1.31 which are
;close to 1.32, e.g. those at BBN as of this writing, May '74.
;Secondly, thou shalt not do GFRKH's like this without corresponding
;RFRKH's. Otherwise, eventually something like CFORK will refuse
;to work merely for want of a name (400000 - 400030) for its output.
;Finally it is not clear that any case ever arises in which indirect
;page pointer chains go more than one level deep, or that if such cases
;do arise, one wants to chase clear to the bottom. However, that is
;the only approach that guarantees continuation. Even this code would
;lose if the page were ultimately found in a file opened for reading
;only.
;The fix here is to avoid calling GFRKH on the first iteration of the
;loop when it is a NOP anyway ("Give me a fork handle useable in fork
;400000 for the fork which is known as X to another fork I know about,
;namely, myself.). If it ever goes deeper than that, we call GFRKH
;and the hell with it.

TGFRKH:	CAIE 1,400000
	 JRST TGFRK1
	HRRZI 1,(2)
	AOS 0(CP)
	RET
TGFRK1:	GFRKH
	 RET
	AOS 0(CP)
	RET


;FORK HANDLE,, PG IN 1
;GET FORK#,, PAGE IN 1, 0 IF BAD

FRKHN:	PUSH CP,3
	MOVE 2,[XWD -NFRKS,FRKHT]
	MOVSS 1
FRKHN1:	HLRZ 3,0(2)
	CAIN 3,0(1)
	JRST FRKHN2
	AOBJN 2,FRKHN1
	HLRZ 1,1
FRKHN3:	POP CP,3
	RET

FRKHN2:	MOVSS 1
	HRLI 1,-FRKHT(2)
	JRST FRKHN3

U FRKHT,NFRKS
U EINTRX,1
U LPC1,1		;INTERRUPT LEVEL PC'S
U LPC2,1
U LPC3,1

;TENEX PSI LEVEL AND CHANNEL TABLES

LEVTAB:	XWD 0,LPC1
	XWD 0,LPC2
	XWD 0,LPC3

CHNTAB:	XWD 2,RSTU1			;USER INTERRUPT
	XWD 2,RST1P		;^P
	XWD 2,RST1F		;^S
	XWD 2,RST1R		;RUBOUT
	XWD 2,RST1E		;^E
	XWD 2,RST1Z		;^D
	XWD 0,0			;OVERFLOW
	XWD 0,0			;FLOATING OVERFLOW
	XWD 0,0			;UNUSED
	XWD 1,PDLTRP		;PDL OVF
	XWD 0,0			;EOF
	XWD 0,0			;DATA ERR
	XWD 0,0			;FILE (UNASSIGNED)
	XWD 0,0			;FILE (UNASSIGNED)
	XWD 0,0			;TOD
	XWD 1,TRAP		;INSTRUCTION
	XWD 1,WTRP		;MEM READ
	XWD 1,WTRP		;MEM WRITE
	XWD 1,TRAP		;MEM XCT
	XWD 0,0			;FORK
	XWD 0,0			;MACHINE SIZE
	XWD 2,RST1E		;^C - NORMALLY NOT ACCTIVATED
	XWD 0,0			;UNUSED
	XWD 0,0			;UNUSED
	XWD 2,RSTU2		;USER INTERRUPT
	XWD 2,RSTU3		;DITTO
	XWD 2,RSTU4		;DITTO
	XWD 2,RSTU5		;DITTO
	XWD 2,RST1O		;^O - 28.
	XWD 2,RST1H		;^H
	XWD 2,RST1B		;^B
	XWD 2,RST1U		;^U - WARREN'S EDIT INTERRUPT
	XWD 2,RSTU6		;USER INTERRUPT
	XWD 2,RSTU7		;DITTO
	XWD 2,RSTU8		;DITTO
	XWD 2,RSTU9		;DITTO

;TABLE TO INIT TERM INTERRUPTS

	DEFINE STC (T,C)
<	XWD "T"-100,C>

OCTCT:	STC H,35
	STC P,1
	STC S,2
	XWD 34,3		;RUBOUT
	STC E,4
	STC D,5
	STC O,34
	STC B,36+400000		;HARD INTERRUPT
	STC U,37
	XWD 400000,0		;USER INTERRUPTS
	XWD 400000,30
	XWD 400000,31
	XWD 400000,32
	XWD 400000,33
	XWD 400000,40
	XWD 400000,41
	XWD 400000,42
	XWD 400000,43
U CTCT,^D18
UCTCT=CTCT+9			;BEGINNING OF USER PORTION OF TABLE
CTCTP:	XWD -^D18,CTCT
UCTCTP:	XWD -9,UCTCT		;FOR JUST LOOKING AT THE USER CHARS.
CTCTC:	STC C,25


FTRP:	PUSH PP,3
	HRRZ 2,RSTCP		;LOOK FOR LAST FUNCTION CALL
	HRRZ 3,0(2)
	CAIE 3,PPR
FTRP1:	SOJA 2,.-2		;HAS TO BE ONE
	HRRZ 3,-1(2)		;THE RESET PP
	CAIL 3,0(FF)		;SHOULD BE LESS  FREE PTR
	JRST FTRP1		;WRONG ONE - KEEP LOOKING
	HLRZ 3,0(2)		;FN NAME
	HRRZ 3,1(3)		;FN DEF
	LDT 1,3			;GET TYPE OF DEFINITION
	CAMN 1,CCODET
	 JRST .+4
	CAME 1,HANDLT		;HANDLES, CCODE ARE OK.
	 JRST TRAP
	HRRZI	3,2(BR)		;RELOCATE IF HANDLE.
	HLRE 1,FF
	MOVN 1,1		;# FREE VARS
	ADD 1,@LPC1		;THE OFFENDING INSTR...-N(FF)
	ADD 1,4(3)		;ADDR OF LOCAL FREE NAMES
	CAIN	3,2(BR)		;IF SWAPPED CODE,
	 ADDI	1,(BR)		;RELOCATE.
	HLRZ 3,2(3)		;# NORMAL FREE VARS
	SUBI 1,1(3)
	HRRZ 1,0(1)		;NAME OF DESIRED VAR
	HRRZ 2,-1(2)		;THE RESET PP
	CALL PPLOK2		;GET VAL
	 JFCL			;NOT ON STACK - OK
	MOVE 2,@LPC1
	TLZ 2,20		;FLUSH IBIT
	HRRZM 1,@2		;NOTE THAT HERE IT IS NECESSARY
	AOS TRPCNT		;THAT STACK AND TEMS BE WRITABLE
	POP PP,3
	JRST WTRP2

PDLTRP:	EINT1
	TRNE F,GCFLG
	JRST PDLTR2		;IN GC - BAD
PDLTR1:	MOVEI 1,PPOVF
	MOVEM 1,LPC1
	JRST RSTC

PDLTR2:	MOVEI 1,RESETE
	MOVEM 1,@GCCP		;SET TO RESET WHEN GC DONE
	MOVE 1,ICP		;MOVE CP UP TO ICP+1
	ADDI 1,1
	HRL 1,GCCP		;FROM CP AT GC ENTRY
	PUSH CP,2
	MOVE 2,-2(CP)
	SUB 2,GCCP
	ADDI 2,0(1)
	BLT 1,0(2)
	HRLI 2,@ICPC
	MOVEM 2,-2(CP)
	POP CP,2
	JRST RSTC
>		;END OF IFE TEN50

RST1P:	EINT
	CALL RSTRN		;GET NUMBER
	PUSH CP,2
	MOVE 2,RSTSUM
	CAIN 1,"."
	JRST RST2P		;SET FOR THIS PRINT
	CAIE 1,"!"
	JRST RST3P		;ABORT
	MOVEM 2,PPLVL		;SET PERMANENT LEVEL
RST2P:	MOVEM 2,TPLVL
RST3P:	POP CP,2
	JRST RSTC

RSTRN:	SETZM RSTSUM
	PUSH CP,2
	PUSH CP,3
	PUSH CP,4
	PUSH CP,FX
	MOVEI FX,0
IFN TEN50,<	CALL CLRBUF>
IFE TEN50,<		PUSH CP,SYSBFP
	PUSH CP,[0]
	MOVEI 1,RSTRS
	CALL CLRBSS		;SAVE CURRENT TTY IN BUFFER
	CLRTOB
>
	MOVEI 1,""		;TYPE BELL
	CALL TCO
	MOVE 1,FILEN(FX)
IFE TEN50,<		DOBE			;WAIT TILL REALLY OUTPU
>
RST1P1:	CALL TCI
	CAIG 1,"9"
	CAIGE 1,"0"
	JRST RST1P2
	SUBI 1,"0"
	EXCH 1,RSTSUM
	IMULI 1,^D10
	ADDM 1,RSTSUM
	JRST RST1P1

RST1P2:
IFE TEN50,<		POP CP,4
	MOVE 3,SYSBFP
	MOVEM 1,0(CP)
	CALL BKSYS2		;RESTORE INPUT BUFFER
	POP CP,1
>
	POP CP,FX
	POP CP,4
	POP CP,3
	POP CP,2
	RET

RSTRS:	IDPB 1,-3(CP)
	AOS -2(CP)
	RET

U RSTSUM
U IPD,NIP
IIP:	IOWD NIP,IPD
U IPD1,NIP
IIP1:	IOWD NIP,IPD1


;CONTROL-F - SET MINLW

RST1F:	EINT
	CALL RSTRN
	CAIE 1,"."
	JRST RSTC
	MOVEI 1,MINLW
	TRNN F,GCFLG		;DOING GC?
	JRST RST1F1		;NO - SET MINFS LIST
	MOVE 1,GCTYP		;YES - DO FOR TYPE COLLECTING
	HRRZ 1,TYPBLK(1)
	ADDI 1,TMIN
RST1F1:	EXCH 1,RSTSUM
	MOVEM 1,@RSTSUM
	MOVEM 1,XMINARR		;IF ARRAYS MAKE MINFS PERMANENT
	JRST RSTC

;RUBOUT - CLEAR TTY INPUT BUFFER

RST1R:	EINT
	CLRTIB
	MOVEI 1,""
	CALL TCO
	JRST RSTC

;CONTROL - O CLEAR TTY OUTPUT BUFFER

RST1O:	EINT
	CLRTOB
	MOVEI 1,EOL
	CALL TCO
	JRST RSTC

;CONTROL - E   CALL ERROR!

RST1E:	EINT
	CLRTOB
	MOVEI 1,EOL
	CALL TCO
	CALL SCLRBF
	MOVEI 1,ERRORF
	JRST RSTE1


;CONTROL - U  SET CTRLU FOR USER INPERROGATION

RST1U:	EINT
	SETOM CTRLU
	JRST RSTC

U CTRLU


;CONTROL-H - INTERRUPT AT FN CALL

RST1H:	EINT
	MOVEI	1,1		;INTERRUPT ARG
URST1:	MOVEM 1,UINTCH
	MOVE 1,RSTBK
	MOVEM 1,FNCALL		;SET TO INTERRUPT AT NEXT FN CALL
	TRO F,INTFLG
	CLRTOB
	CALL SCLRBF		;CLEAR BUFFER AND SAVE
	MOVEI 1,""		;RING BELL
	CALL TCO
	JRST RSTC

;CONTROL-B - INITIATE ERROR

RST1B:	EINT
	TRO F,ERQFLG		;REGULAR ERROR, SET FLAG
	MOVEI 1,XBREAK		; DO IMMEDIATELY
RSTE1:	TRNE F,GCFLG		;DOING GC NOW?
	JRST RSTE3		;YES, REMEMBER REQUEST
	PUSH CP,1		;SAVE DISPATCH ADDRESS
	SKIPE INCTLA		;WERE WE IN ^A MODE?
	CALL FIXCTA		;YES.
	POP CP,LPC2		;PUT ROUTINE ADDRESS IN INTERRUPT PC
	JRST RSTC		;AND GO DEBREAK
RSTE3:	MOVEM 1,GINTD		;SAVE ADDRESS FOR END OF GC
	JRST RSTC



;CONTROL-D

RST1Z:	EINT
	CLRTOB
	MOVEI 1,EOL
	CALL TCO
	CALL SCLRBF
	JRST RRSET
SRESET:
IFE TEN50,<	CALL CLRBFS		;CLEAR INPUT BUFFER AND SAVE IT
>
	JRST RESET

RRSET:	MOVEI 1,RESET		;RESTART ADDRESS
	JRST RSTE1

RSTBK:	CALL HBREAK		;CALL TO INITIATE INTERRUPT

RSTFC:	XCT 1(2)		;NORMAL FUNCTION CALL INSTRUCTION

U GINTD

;SAFE CLEAR BUFFER

SCLRBF:	PUSH CP,2
	PUSH CP,FX
IFE TEN50,<	CALL CLRBFS>
IFN TEN50,<	CALL CLRBUF>
	POP CP,FX
	POP CP,2
	RET

	; INTERRUPT HANDLERS FOR USER INTERRUPT CHARS

DEFINE DUIC(X) <IRPC X,<
RSTU'X:	EINT
	MOVEI 1,X-1
	JRST RSTUN>
>
	DUIC	(<123456789>)

RSTUN:	MOVE	1,UCTCT(1)	;GET CHAR ENTRY
	TLNE	1,400000	;IS CHAR REALLY ON?
	JRST	RSTC		;NO - STRAY INTERRUPT - IGNORE IT
	TRNE	1,400000	;YES - IS IT A HARD OR SOFT INTERRUPT?
	JRST	UHARD		;HARD
	HLRZ	1,1		;SOFT - CONVERT TO LETTER
	ADDI	1,100
	JRST	URST1		;SIMILAR TO ^H

UHARD:	HLRZ	1,1		;HARD - CONVERT TO NUMBER
	ADDI	1,ASZ		;NEED TO BOX, NOT NEEDED FOR SOFT BREAKS
	MOVEM	1,UHINCH
	MOVEI	1,UBREAK
	JRST	RSTE1
U UINTCH
U UHINCH

;PERFORM CONTROL ACTION AT TIME OF FUNCTION CALL

HBREAK:	HRRZS -2(CP)		;CLEAR JUNK FROM HALF DON FN CALL
	HRLM 2,0(CP)
XBREAK:	MOVEM 1,FNCALL		;RESET FNCALL TO NORMAL
	MOVE 1,RSTFC
	EXCH 1,FNCALL
BREAKE:	TRZE F,ERQFLG		;TEST VARIOUS REQUEST FLAGS
BREAK:	ERROR0 22,R
	TRZE F,INTFLG
	JRST INTR1
	TLZE F,CNSFLG
	JRST CNSCI

	SOS 0(CP)
	POPJ CP,		;GO RE-EXECUTE CALLING INSTRUCTION

U RSTCP

UBREAK:	MOVE	1,RSTFC		;HARD USER INTERRUPT
	MOVEM	1,FNCALL
	MOVE	1,UHINCH
	ERROR1 53,R

CNSCI:	PUSH NP,[3]		;INTERRUPT TYPE NUMBER
	JRST INTRC

INTR1:	PUSH NP,UINTCH
INTRC:	PUSH CP,PP		;SAVE P-STACK
	PUSH PP,2		;NAME OF FUNCTION ABOUT TO BE CALLED
	MOVEI 6,-1(PP)
	CALL LSTAR2		;MAKE LIST OF ARGS ON STACK
	PUSH PP,1		;SECOND IS ARG LIST
	POP NP,1
	CALL MKN
	PUSH PP,1		;THIRD IS INT TYPE
	LCALL KINT,3
	JRST PPR1

;CLEAR TTY I/O

CLRTIO:	CLRTOB			;CLEAR OUTPUT BUFFER
	JRST CLRBUF		;CLEAR INPUT BUFFER AND RESET EDIT LINE

;ERROR MESSAGES TABLE

;REMOTE MACRO

	DEFINE REMOTE (TX)
<	HERE1 <TX>>

	DEFINE HERE1 (NEW,OLD,%G)
<	DEFINE %G
<	NEW>
	DEFINE REMOTE (TX)
<	HERE1 <TX>,<OLD
%G
>>>
	DEFINE HERE
<	DEFINE HERE1 (XX,YY)
<	YY>
	REMOTE>

;ERROR MESSAGES

	DEFINE EM (MSG,%T)
<	Z %T
	REMOTE <%T:	SIXBIT @MSG/@
>>

ERRMT:	EM <NONXMEM>
	EM <UNDEFINED FUNCTION>
	EM <P-STACK OVERFLOW>
	EM <ILLEGAL RETURN>
	EM <ILLEGAL ARG - PUTD>		;4
	EM <ARG NOT ATOM - SET>
	EM <ATTEMPT TO SET NIL>
	EM <ATTEMPT TO RPLAC NIL>
	EM <UNDEFINED OR ILLEGAL GO>	;10
	EM <FILE WON'T OPEN>
	EM <NON-NUMERIC ARG>
	EM <ATOM TOO LONG>
	EM <ATOM HASH TABLE FULL>	;14
	EM <FILE NOT OPEN>
	EM <ARG NOT ATOM>
	EM <TOO MANY FILES OPEN>
	EM <END OF FILE>		;20
	EM <ERROR>
	EM <BREAK>
	EM <ILLEGAL STACK ARG>
	EM <FAULT IN EVAL>		;24
	EM <ARRAYS FULL>
	EM <DIRECTORY FULL>
	EM <FILE NOT FOUND>
	EM <FILE INCOMPATIBLE - SYSIN>	;30
	EM <UNUSUAL CDR ARG LIST>
	EM <HASH TABLE FULL>
	EM <ILLEGAL ARG >
	EM <ARG NOT ARRAY>		;34
	EM <ILLEGAL OR IMPOSSIBLE BLOCK>
	EM <DISPLAY SERVICE ROUTINES NOT LOADED>	;OBSOLETE
	EM <LISTS FULL>
	EM <ATTEMPT TO CHANGE ITEM OF INCORRECT TYPE>	;40
	EM <ILLEGAL DATA TYPE NUMBER>
	EM <DATA TYPES FULL>
	EM <ILLEGAL ARGS - DEFTYPE>
	EM <ILLEGAL ARG - DEFEVAL>	;44
	EM <READ-MACRO CONTEXT ERROR>
	EM <ILLEGAL READTABLE>
	EM <ILLEGAL ARG - SWPARRAY>
	EM <SWAPBLOCK TOO BIG FOR BUFFER>	;50
	EM <ILLEGAL ARG - SETSBSIZE>
	EM <ILLEGAL ARG - SWPPOS>
	EM <USER BREAK>
	EM <TOO MANY USER INTERRUPT CHARACTERS>	;54
	EM <ILLEGAL TERMINAL TABLE>	;55
	HERE

;MAIN EXECUTIVE LOOP (EVALQUOTE)

RESETE:	MOVE F,TFLGS
	SETOM SYSCHK
	MOVE CP,ICP
	SETICH
IFE TEN50,<
	CALL SETTRP
>
	JRST RESET1
RESET:	MOVE CP,ICP		;SET STACKS TO INITIAL VALUES
	CALL CLRBUF
RESET1:	MOVE PP,IPP
	MOVE NP,INP
	TRZ F,-1		;CLEAR TEMP FLAGS
	TLZ F,STKFLG+CNSFLG
IFE TEN50,<
	CIS			;CLEAR INTERRUPT SYSTEM
	CALL SETMOD
>
	MOVE 1,RSTFC
	MOVEM 1,FNCALL
	TMSG EOLM
EVQ2:	SETZM ERRDSP
	SETZB BR,LSTSWF
	LCALL KEVLQT
	JRST EVQ2

EVALQT:	MOVEI 1,"_"		;READY CHARACTER
	CALL TCO
EVQ1:	LCALL KREADX,0		;READ FUNCTION
	CAMN 1,KNIL		;IGNORE NIL (UNMATCHED RT. PAREN)
	JRST EVQ1
	PUSH PP,1
	LCALL KREADX,0		;READ ARG LIST
	PUSH PP,1
	LCALL KAPPLY,2		;EVALUATE
	PUSH PP,1
	LCALL KPRINT,1		;PRINT VALUE
	RET

U TFLGS

;FUNCTION CALL UUO FOR CALLS FROM COMPILED CODE


FNACAL:	PUSH PP,1		;"PUSH AC1 FIRST" ENTRY
FNCALQ:	LDB 1,NARGP		;REGULAR ENTRY
	HRRZ 2,@40		;FN NAME
EFNCAL:	PUSH CP,1		;ENTRY WITH # ARGS IN 1,NAME IN 2
	SUBM PP,0(CP)		;SET RESET PP TO UNCOVER ARGS
	HRLM NP,0(CP)
	XCT FNCALL
PPR:	HLRZ NP,0(CP)
	HRLI NP,@INPC
	POP CP,PP
	HRLI PP,@IPPC		;RESET CORRECT COUNT
	RET
HCRET:	XWD 0,PPR

NARGP:	POINT 4,40,12

;ENTRY SEQUENCE FOR HAND CODED FUNCTIONS

HCCALQ:	HRLM 2,0(CP)
	HLRZ 2,40
	TRNE 2,100
	JRST HCSET3
HCSET2:	CAIG 1,3		;NUMBER ARGS GIVEN
	JRST HCSET1(1)		;OK OR TOO FEW
	SUB PP,BHC-3(1)		;TOO MANY FLUSH EXTRA
HCSET4:	MOVEI 1,3
	HRLM 1,-2(CP)		;NUMBER ARGS STACKED
	HRRZ 1,-2(PP)		;ARGS TO 1-3
	HRRZ 2,-1(PP)
	HRRZ 3,0(PP)
	JRST @40

HCSET1:	PUSH PP,KNIL
	PUSH PP,KNIL
	PUSH PP,KNIL
	JRST HCSET4

HCSET3:	HRLM 1,-2(CP)
	TRNE 2,40		;TEST EVAL/NO-EVAL
	HRRZ 1,0(PP)		;NO - EVAL, GET ARF LIST
	JRST @40


;LINKED FUNCTION CALL UUO

;LNCALL #ARGS,P
;P:	HCCALBITS,,DEF
;P+1:	NAME,,HCCALQ OR EXCALQ OR CCALC


LCALQ:	LDB 1,NARGP
LCALQ2:	PUSH CP,1		;ENTRY FOR MORE THAN 16 ARGS
	SUBM PP,0(CP)
	HRLM NP,0(CP)
	PUSH CP,HCRET
	MOVE 2,@40
	EXCH 2,40
	HRRZ 3,1(2)
	HLRZ 2,1(2)		;GIVE ENTERF & BROS. ACTUAL ATOM NAME.
	JRST 0(3)

CCALC:	JRST @40

;ENTRY SEQUENCE FOR EXPR'S

EXCALQ:	HRLM 2,0(CP)		;SAVE FN NAME
	HRRZ 3,40
	CAMN 3,KNIL
	JRST EXILL
	CARA 5,3
	CAME 5,KLAM
	CAMN 5,KNLA
	JRST EXCLM
EXILL:	HRLM	1,-2(CP)	;ELSE BACKTRACE SCREWS UP
	PUSH PP,2
	MOVEI 6,-1(PP)
	CALL LSTAR2
	PUSH PP,1
	LCALL KFALTA,2
	RET
EXCLM:	HRRZ PP,-1(CP)		;SET PP TO FIRST ARG GIVEN-1
	HRLI PP,@IPPC		;FIX LEFT
	CDRA 3,3
	CARA 4,3		;VARIABLE LIST
	CAMN 4,KNIL
	JRST EXCLM3
	STN 4,LIST		;LIST OR NIL?
	JRST EXCLM2		;YES
	CAME 5,KNLA		;NO, LAMBDA OR NLAMBDA?
	JRST EXCLM4
	HRL 4,1(PP)		;NLAMBDA- BIND TO ARG
	CAIGE 1,1
	HRL 4,KNIL		;OR NIL IF NO ARG GIVEN
	JRST EXCLM5
EXCLM4:	ADD PP,BHC(1)		;LAMBDA- BIND TO NUMBER OF ARGS
	PUSHJ CP,MKN
	HRLI 4,0(1)
EXCLM5:	MOVSM 4,1(PP)
	AOBJN PP,EXCLM3		;ALWAYS JUMPS

EXCLM2:	CAMN 4,KNIL		;FINISHED BINDINGS?
	JRST EXCLM3		;YES
	JUMPG 1,.+3		;NO, STILL SOME ARGS?
	MOVE 5,KNIL		;NO, USE NIL
	MOVEM 5,1(PP)
	CARA 5,4		;GET NEXT VARIABLE NAME
	HRLM 5,1(PP)		;TO LEFT HALF OF ARG POSITION
	CDRA 4,4
	SUBI 1,1
	AOBJN PP,EXCLM2
PPOVF:	HLRE 1,PP
	ADDI 1,400
	JUMPL 1,.+3
	SUBI PP,0(1)
	HRLI PP,@IPPC
	HLRE 1,NP
	ADDI 1,50
	JUMPL 1,.+2
	SUB NP,BHC(1)
	HLRE 1,CP
	ADDI 1,200
	JUMPL 1,.+3
	SUBI CP,0(1)
	HRLI CP,@ICPC
	JSYS	BRREST		;FIX THE STACK AND BUFFER
	ERROR0 2,RESET

EXCLM3:	MOVEI 1,0(PP)
	SUB 1,-1(CP)		;COMPUTE # ARGS STACKED
	HRLM 1,-2(CP)
	CDRA 1,3		;FORM TO BE EVAL'D
	JRST PROGN		;GO EVAL FORMS

;ENTRY SEQUENCE FOR SWAPPED FUNCTIONS
;BEGIN BY REARRANGING THE CP FRAME TO BE 5-WD SWAPPED FRAME:
;	LSTSWF,,REAL RETURN
;	C(BR) SWAPPED		;SWAPPED SO GC SEES HANDLE
;	NARGS,,CHEKBR		;NARGS FILLED IN BY ENTERB.
;	NP,,PP
;	FNAME,,PPR		;FNAME FILLED IN BY ENTERB.

SBCALQ:	PUSH CP,-1(CP)		;MOVE NP,,PP TO FOURTH WORD
	MOVSM BR,-2(CP)		;SAVE PREVIOUS VALUE OF BR
	HRRZI BR,(CP)
	EXCH BR,LSTSWF
	HRLM BR,-3(CP)
	PUSH CP,HCRET		;PUSH 'PPR
	HRRI BR,CHEKBR		;CHANGE 3RD WD FROM PPR TO CHEKBR
	HRRM BR,-2(CP)
	HRL BR,40		;POINTER TO HANDLE IN LH OF BR.
	CALL SWAPIN
	JRST 2(BR)		;BR PTS TO HEADER, NOT 1ST INSTRUC.


;CONTROL RETURNS HERE WHEN SWAPBLOCKS RETURN (BUT AFTER
;PPR STUFF DOES ITS THING). RESTORE BR AND PREVIOUS BLOCK TO BUFFER.

CHEKBR:	MOVS BR,0(CP)		;HANDLE TO PREV. SB INTO LH OF BR
	HLRZ 2,-1(CP)
	HRRZM 2,LSTSWF
	SUB	CP,BHC+1	;Why doesn't the PDP-10 have a POPSW?
	JRST	RESWAP		;Restore it to buffer and return.

;COMPILED FUNCTION ENTRY ROUTINE
;AC'S:	1 - # ARGS GIVEN (FROM CALLING FN)
;	2 - FN NAME
;	JSP 7,ENTERF
;	XWD # ARGS EXP'D, FN TYPE
;	XWD # FREE, VAR NAMES ADR

ENTERF:	HRLM 2,0(CP)		;FN NAME
	HRRZ 2,0(7)		;FN TYP
	CAIN 2,2
	JRST ENT7		;LAMBDA ATOM
	HLRZ 4,0(7)		;# ARGS EXPECTED
	HRLM 4,-2(CP)		;# ARGS EXPECTED => TOP RETURN WORD
	SUBM 1,4		;DIFFERENCE OF # GIVEN AND # EXPECTED
	JUMPE 4,ENT2		;EQUAL
	JUMPG 4,ENT1		;TOO MANY GIVEN
	PUSH PP,KNIL		;TOO FEW GIVEN, USE NIL
	AOJL 4,.-1
ENT2:	HLRZ 4,0(7)		;# ARGS EXPECTED
	HRRZ 5,1(7)		;ADR OF VECTOR OF VAR NAMES
ENT8:	JUMPE 4,ENT4		;ENTER HERE FROM ENTERB
	SUB PP,BHC(4)		;SETUP TO STORE VARIABLE NAMES
ENT3:	MOVE 1,0(5)		;GET VARIABLE NAME
	HRLM 1,1(PP)		;PUT IN LH OF WORD ON STACK
	AOBJP PP,PPOVF
	ADDI 5,1
	SOJG 4,ENT3
ENT4:	HLRZ 6,1(7)		;# FREE VARS
	JUMPE 6,ENT6		;CHECK FOR ANY FREE VARS TO SETUP
	PUSH CP,PP
ENT5:	MOVE 1,0(5)		;NAME OF FREE VAR
	MOVE 2,0(CP)		;PP OF LAST ARG THIS FN
	CALL PPLOK2		;SEARCH STACK
	JFCL 0			;NOT ON STACK (DOESN'T MATTER)
	PUSH PP,1		;PUT LOCATION OF VALUE ON STACK
	ADDI 5,1
	SOJG 6,ENT5
	SUB CP,BHC+1
ENT6:	JRST 2(7)		;GO EXECUTE FUNCTION

ENT1:	SUB PP,BHC(4)		;FLUSH EXTRA ARGS
	JRST ENT2


ENT7:	MOVEI 4,ASZ(1)
	PUSH PP,4		;# ARG GIVEN TO STACK
	MOVEI 4,1(1)
	HRLM 4,-2(CP)		;ARGS STACKED IS GIVEN + 1
	JRST ENT2

;ENTERB, ANALOGOUS TO ENTERF BUT FOR SWAPPED BLOCKS.
;THE ONLY THING THAT HAS TO BE DONE DIFFERENTLY FOR SWAPPED CODE
;IS THAT THE VAR NAMES ADDR MUST BE RELOCATED, I.E. BR ADDED IN.
;DUPLICATE ENTERF UP TO THAT POINT, ADD IN BR, JRST INTO ENTERF CODE.
ENTERB:	HRLM 2,0(CP)
	HRRZ 2,0(7)
	CAIN 2,2
	JRST ENTB7
	HLRZ 4,0(7)
	HRLM 4,-2(CP)
	SUBI 4,0(1)
	JUMPE 4,ENTB2
	JUMPL 4,ENTB1
	PUSH PP,KNIL
	SOJG 4,.-1
ENTB2:	HLRZ 4,0(7)
	HRRZ 5,1(7)
	ADDI 5,(BR)			;HERE'S THE EXTRA ADDI
	JRST ENT8			;GO REJOIN ENTERF

ENTB1:	ADD PP,BHC(4)
	JRST ENTB2

ENTB7:	MOVEI 4,ASZ(1)
	PUSH PP,4
	MOVEI 4,1(1)
	HRLM 4,-2(CP)
	JRST ENTB2
;EVALUATED CAR OF FORM, USED FROM COMPILED CODE

APPLY.:	SUBI 1,1		;1 HAS # ARGS TO APPLY*
EVCC:	MOVE 3,PP		;ENTRY HERE WITH # ARGS TO FN
	SUB 3,BHC+1(1)
	PUSH CP,3		;SAVE RESET PP
	PUSH NP,1		;SAVE # ARGS
	MOVEI 3,0(PP)
	SUBI 3,0(1)
	HRRZ 2,0(3)		;FN
	PUSH PP,2		;SAVE FN
	LDT 4,2
	CAMN 4,LISTT
	JRST APPLS
	CAME 4,ATOMT
	JRST APPBAD		;ILLEGAL FN
	MOVEI 1,0(2)
	CALL ARGTYP		;GET ARGTYP
	JRST APPBAD		;BAD DEF
APPL1:	CAIN 1,3		;N-LAMBDA AND NO-SPREAD?
	JRST APPNS		;YES
APPS:	POP NP,1		;SPREAD
	POP PP,2
	JRST EVAF6		;GO TO CALL THE FN

APPNS:	POP NP,1		;NO-SPREAD
	MOVEI 6,-1(PP)
	CALL LSTAR2		;LIST ARGS
	MOVE 2,0(PP)		;GET FN
	MOVEM 1,0(PP)		;STACK ARG LIST
	MOVEI 1,1
	JRST EVAF6		;CALL FN

APPLS:	CARA 4,2
	CAME 4,KLAM
	CAMN 4,KNLA
	JRST APPLM
	CAMN 4,KFNARG
	JRST APPFNA
APPBAD:	POP NP,1
	MOVEI 6,-1(PP)
	CALL LSTAR2
	PUSH PP,1
	LCALL KFALTA,2
	JRST PPR1

APPLM:	HLL 4,EVALUU		;FN IS LAMBDA
	HLLM 4,0(3)		;HOKEY UP CALLING INSTR
	MOVEI 3,-1(3)
	MOVEM 3,0(PP)
	MOVEI 3,0(2)
	CALL ARGT2
	JRST APPBAD		;SHOULDNT HAPPEN
	JRST APPL1

APPFNA:	POP PP,1		;APPLY* OF FUNARG
	POP NP,TNP		;BLIP USES NUMBER STACK
	CALL FNABLP		;BLIP THE STACK
	PUSH PP,2
	MOVE 1,TNP
	JUMPLE 1,APPFN1
	MOVEI 3,-1(PP)
	SUBI 3,0(1)
	HRLI 3,1(PP)
	MOVSS 3
	MOVEI 4,0(PP)
	HRLI 4,1
	ADD PP,BHC(1)
	BLT 3,@4
APPFN1:	ADDI 1,1
	CALL APPLY.
	JRST EVNF2
U TNP


;CONSTRUCT LIST OF ARGS

LIST:
LSTARG:	MOVEI 6,0(PP)
LSTAR2:	JUMPLE 1,FALSE		;ENTRY WITH PTR TO LAST ARG IN 6
	MOVEI 7,0(1)		;COUNT
	SUBI 6,0(7)
	HRLI 6,7
	SKIPA 2,KNIL		;START WITH NIL
LSTAR1:	MOVEI 2,0(1)		;LIST SO FAR
	HRRZ 1,@6		;NEXT ELEMENT
	CALL CONS
	SOJG 7,LSTAR1
	RET

;LIST FROM COMPILED CODE - TAKES ARGS OFF STACK

CLIST:	JUMPLE 1,FALSE
	MOVEI 7,0(1)
	SKIPA 2,KNIL
CLIST1:	MOVEI 2,0(1)
	POP PP,1
	CALL CONS
	SOJG 7,CLIST1
	RET

;STUFF FOR BLOCK COMPILER

;REBIND FREE VARS
; CALLED JSP 7,REBIND
;	F,,P		F REL.LOC. FREE VAR - P LOC NEW BINDING

REBIND:	MOVS 2,0(7)
	HLRZ 1,2
	TRNE 2,777000
	JRST REB1
	MOVN 2,2
	ADDI 2,0(FF)
	ADDI 1,0(PP)
	MOVEI 1,0(1)
	EXCH 1,0(2)
	PUSH CP,1
	AOJA 7,REBIND

REB1:	PUSH CP,7		;LEAVE RETURN ON STACK FOR UNBIND
	JRST @7

;UNBIND CALLED JSP 7,UNBIND

UNBIND:	POP CP,3		;ADDR TABLE END LEFT BY REBIND
UNBN1:	MOVS 2,-1(3)
	TRNE 2,777000
	JRST 0(7)
	MOVN 2,2
	ADDI 2,0(FF)
	POP CP,0(2)
	SOJA 3,UNBN1		;NOTE THAT AC1 PRESERVED
;TO CALL FUNCTION FROM BLOCK WITH POSSIBLE RETFROM TO IT
;CALLED MOVEI 1,#ARGS
;	MOVE 2,'NAM
;	HRLI 2,FNADDR
;	PUSHJ CP,RETCAL
;**** DID WE FORGET ABOUT AC FF???

RETCAL:	HLRE 3,FF		;SAVE FREE VAR BLOCK
	JUMPE 3,RETC1
	MOVEI 4,0(FF)
	ADDI 4,1(3)		;FIRST IN BLOCK
	MOVEI 5,1(CP)
	HRLI 5,0(4)
	MOVN 3,3
	ADD CP,BHC(3)
	BLT 5,0(CP)
RETC1:	PUSH CP,FF
	PUSH CP,[XWD 0,RETC2]
	HRLM 1,0(CP)
	PUSH CP,1
	SUBM PP,0(CP)
	HRLM NP,0(CP)
	PUSH CP,HCRET
	HRLM 2,0(CP)
	HLRZ 2,2
	JRST 0(2)

RETC2:	POP CP,FF		;RESTORE
	HLRE 3,FF		; - #FREE
	JUMPE 3,R
	MOVEI 4,0(FF)
	ADDI 4,1(3)
	MOVN 3,3
	SUB CP,BHC(3)
	HRLI 4,1(CP)
	BLT 4,0(FF)
	RET

;STUFF FOR BLOCK COMPILER
;BLKENT AT BEGINNING OF BLOCK TO SET UP ARGS AND CALL
;THE RIGHT SUBFN
;CALLED JSP 7,BLKENT
;	#FREE,,ADDR NAMES	FREE VARS THAT ARENT LOOKED UP
;	-#ENTRIES,,ADDR NAMES
;	LOCS OF SUBFNS FOLLOW

SBLKNT:	SKIPA 4,BR		;RELOCATION VALUE GOES IN AC4
BLKENT:	SETZ 4,			;NON-SWAPPED CODE; RELOCATION=0.
	HLRZ 6,0(7)
	JRST .+2
	PUSH PP,IFTRAP		;SET TO TRAP ON REF
	SOJGE 6,.-1
	MOVEI FF,0(PP)		;SET FF TO LAST FREE VAR
	HLRZ 2,-2(CP)		;NUMBER OF ARGS
	HLRZ 6,-2(7)		;# FREE INITIALIZED
	HLRZ 5,0(7)		;# FREE NOT INITIALIZED
	MOVN 6,6
	SUBI 6,0(5)
	HRLI FF,0(6)		;FF HAS - # FREE FOR RETCAL
	SUBI 6,-1(2)	
	HRLI 6,PP
	MOVE 3,1(7)
	ADDI 3,(4)		;RELOCATE.
	TLNN 3,-1		;NO ENTRIES?
	JRST BLKENS		;YES - JUST DO ARGS
	SUBI 2,1
	JRST BLKEN1
	HRRZ 5,@6		;MOVE ARGS DOWN PAST FREE
	PUSH PP,5
BLKEN1:	SOJG 2,.-2
	HRRZ 1,@6		;THE NAME
	HRLI 2,4		;RELOCATE BY INDEXING OFF AC2.
BLKEN2:	ADDI 7,1
	HRRZ 5,0(3)
	HRR 2,1(7)
	CAIN 1,0(5)
	JRST @2			;C(2) = ADDR(4) SO IT'S RELOCATED.
	AOBJN 3,BLKEN2
	RET			;SHOULD BE ERROR

	HRRZ 5,@6
	PUSH PP,5
BLKENS:	SOJGE 2,.-2
	JRST 2(7)

;BLKAPPLY		MOVEI 2,**BLKENT		ENTRY VECTOR
;			PUSHJ CP,BLKAPP

BLKAPP:	CAIE 2,7(BR)		;CALLED FROM SELF-RELOCATING CODE?
	 TRZA 5,-1		;NO, SO "RELOCATE" BY 0.
	HRRZI 5,(BR)		;YES, RELOCATE BY C(BR) 
	HRRZ 3,-1(PP)		;GET FN NAME
	MOVE 6,0(2)
	ADDI 6,(5)		;RELOCATE

;NOTE ON THE CAIN AT BLKAPP: THE VALUE 7 DEPENDS ON THE FACT THAT
;THE ENTRY VECTOR (**BLKENT) IS ALWAYS THE 7TH WORD OF A
;BLOCK, WHETHER SWAPPED OR NOT, AND IF SWAPPED, THE ABOVE CALLING
;SEQUENCE IS ACTUALLY
;	MOVEI 2,**BLKENT(BR)
;	PUSHJ CP,BLKAPP
;THIS IS A CROCK BUT IT'S FASTER THAN DOING A RANGE CHECK
;ON THE RIGHT HALF OF 0(CP) USING CBRANG AND CBRANG+1, WHICH
;IS THE SUPERCLEAN WAY. JWG.
BLKAP1:	CAMN 3,0(6)
	JRST BLKAPG
	ADDI 2,1
	AOBJN 6,BLKAP1
	POP PP,2		;NOT IN BLOCK, DO APPLY
	POP PP,1
	PUSH CP,FF
	CALL APPLY
BLKAP5:	POP CP,FF
	RET

BLKAPG:	HRRZ 4,1(2)		;ADDR OF SUBFN
	ADDI 4,(5)		;RELOCATE
	HLRZ 3,-1(4)		;# ARGS NEEDED
	POP PP,1
	SUB PP,BHC+1
	JRST BLKAP4
BLKAP3:	STE 1,LIST		;SPREAD ARGS
	JRST BLKAP2
	HRRZ 2,0(1)
	PUSH PP,2
	HLRZ 1,0(1)
BLKAP4:	SOJGE 3,BLKAP3
	JRST 0(4)		;GO TO SUBFN

BLKAP2:	PUSH PP,KNIL		;NOT ENUF ARGS GIVEN, USE NIL
	SOJGE 3,.-1
	JRST 0(4)


;BLKAPPLY* CALLED	MOVEI 1,#ARGS(INCL FN NAME)
;			MOVEI 2,**BLKENT
;			PUSHJ CP,BLKAP*

BLKAP.:	CAIE 2,7(BR)		;DITTO BLKAPP, FOR BLKAPPLY*
	 TRZA 5,-1
	HRRZI 5,(BR)
	MOVEI 3,0(PP)
	SUBI 3,-1(1)
	HRRZ 3,0(3)		;THE FN
	MOVE 6,0(2)
	ADDI 6,(5)
BLKA.1:	CAMN 3,0(6)
	JRST BLK.G
	ADDI 2,1
	AOBJN 6,BLKA.1
	MOVE 2,KAPP.
	PUSH CP,FF
	CALL EFNCAL
	JRST BLKAP5
BLK.G:	HRRZ 4,1(2)
	ADDI 4,(5)
	HLRZ 3,-1(4)
	SUBI 1,1(3)
	JUMPL 1,BLKA.2
	SUB PP,BHC(1)		;TOO MANY
BLKA.3:	PUSHJ CP,0(4)		;CALL SUBFN
	SUB PP,BHC+1		;FLUSH FN NAME
	RET

BLKA.2:	PUSH PP,KNIL
	AOJL 1,.-1
	JRST BLKA.3

;ARG(VAR N) GET NTH COMPONENT OF NON-SPREAD VAR

ARGN:	CALL ARGNP
	HRRZ 1,0(1)
	RET

;SETARG(VAR N VALUE)

SETARG:	CALL ARGNP
	PUSH PP,1
	HRRZ 1,-1(PP)
	CALL EVAL
	POP PP,2
	HRRM 1,0(2)
	RET

ARGNP:	CALL PPLOOK
	 JRST ARGNER		;NOT ON STACK - ERROR
	PUSH PP,1		;SAVE PSTACK POS. OF VAR
	HRRZ 1,-2(PP)
	CALL EVAL
	CALL IUNBOX
	POP PP,3
	HRRZ 2,0(3)		;# ARGS BOUND TO VAR
	CAILE 1,-ASZ(2)
	JRST ARGNER
	SUBI 1,1-ASZ(2)
	ADDI 1,0(3)
	RET

ARGNER:	HRRZ 1,-2(PP)
	ERROR1 33,RESET


;EVAL

EVBLIP==100
APBLIP==10

EVAL:	CAME 1,KNIL		;FAST CHECK FOR NIL AND NOBIND
	CAMN 1,KNOB
	RET			;EVALS TO SELF
	LDT 2,1			;GET TYPE OF THIS POINTER
	CAMN 2,LISTT		;LIST?
	JRST EVAF		;YES
	CAMN 2,ATOMT		;ATOM?
	JRST	EVAT		;YES
	SKIPG 2,EVATAB(2)	;IS THERE A USER EVAL. FN FOR THIS TYPE?
	RET			;NO - ITEM EVALS TO ITSELF
	TLZE	2,1		;YES - EVAL. FN A LIST?
	JRST	EVAA.		;YES - USE APPLY* TO EVAL THE ITEM
	PUSH PP,1		;YES - CALL THE ROUTINE
	MOVEI 1,1		;LCALL 2,1
	JRST EFNCAL		;
EVAA.:	PUSH	PP,2		;USE APPLY* TO EVAL THE ITEM
	PUSH	PP,1		;THE ITEM
	MOVEI	1,1
	JRST	EVCC
EVAT:	CALL PPLOOK		;LOOKUP ATOM ON STACK
	JRST EVAA1		;NOT ON STACK
	HRRZ 1,0(1)		;GET VALUE FROM STACK
	RET

EVAA1:	CARA 2,1		;GET VALUE CELL
	CAME 2,KNOB		;BOUND?
	JRST R2			;YES, RETURN VALUE
EVFAU:	PUSH PP,1		;NO, CALL FAULTEVAL
	LCALL KFAULT,1
	RET

;FAULTEVAL IF NOT USER SUPPLIED

FAULTX:	ERROR1 24,R

;APPLY AND EVAL OF NON-ATOMIC FORM

APPLY:	EXCH 1,2
	PUSH CP,PP
	PUSH PP,[XWD APBLIP,0]	;SUPRESS EVALUATION OF ARGS
	HRRM 2,0(PP)
	JRST APPLY1

APPLY2:	PUSH CP,PP		;FROM FUNARG
	PUSH PP,2
	MOVEI 2,0(2)
	JRST APPLY1

EVAF:	PUSH CP,PP
	PUSH PP,[XWD EVBLIP,0]	;SAYS DOING EVAL & HAVE WHOLE FORM
	HRRM 1,0(PP)		;SAVE FORM FOR W.T.
	CARA 2,1		;NON-ATOMIC FORM, GET CAR
	CDRA 1,1
APPLY1:	TLZ F,EVLFLG
	PUSH PP,1		;ARG-LIST
	PUSH PP,2		;FN
EVNC5:	LDT 3,2			;GET TYPE OF CAR
	CAMN 3,LISTT		;LIST?
	JRST EVNAC		;YES, EVAL OF NON-ATOMIC CAR OF FORM
	CAME 3,ATOMT		;ATOM?
	JRST UDF		;NO, ILLEGAL
	MOVEI 1,0(2)
	HRRZ 3,1(2)
	CAMN 3,KNIL
	JRST EVNC4		;NO DEF, TRY VALUE
	CALL ARGTYP		;ARGS ARE EVAL/NOEVAL, SPREAD/NOSPREAD
	JRST UDF		;DEF EXISTS BUT IS BAD
	POP PP,2
	HRLI 2,0(1)		;KEEP ARGTYPE BITS WITH FN NAME
	POP PP,1
	HLRZ 3,0(PP)		;EVAL-APPLY FLAG
EVNC2:	TLNE 2,1		;IS THIS NO-EVAL AND NO-SPREAD?
	TLNN 2,2
	JRST EVAF3		;NO, GO MAP ARG LIST
	PUSH PP,1		;YES, USE CDR OF FORM AS ARG
	MOVEI 1,1
	JRST EVAF6

EVAF3:	TRNE 3,APBLIP		;IS THIS AN APPLY?
	TLO 2,1			;YES, DON'T EVAL ARGS
	PUSH CP,PP
EVAF1:	STE 1,LIST		;ANY LIST LEFT?
	JRST EVAF2		;NO
	PUSH PP,1		;YES, SAVE IT
	PUSH PP,2		;AND FN NAME
	CARA 1,1		;GET NEXT ARG
	TLNN 2,1		;EVAL IT?
	CALL EVAL		;YES
	POP PP,2
	EXCH 1,0(PP)		;PUT ARG ON STACK
	CDRA 1,1		;GET REST OF LIST
	JRST EVAF1

EVAF2:	CAME 1,KNIL
	ERROR1 31,R		;CDR NOT LIST OR NIL - ERROR???
	POP CP,1		;COMPUTE NUMBER OF ARGS STACKED
	MOVNI 1,0(1)
	ADDI 1,0(PP)
EVAF6:	PUSHJ CP,EFNCAL		;CALL FN
PPR1:	POP CP,PP		;FLUSH ARGS
	RET

;NON-ATOMIC CAR OF FORM

EVNAC:	MOVEI 3,0(2)
	CALL ARGT2		;IS LAMBDA/NLAMBDA?
	JRST EVNC1		;NO
	POP PP,2		;YES, GET EXPRESSION
	HLL 2,EVALUU		;CONSTRUCT EXCAL INSTRUCTION
	MOVSI 1,0(1)		;CONSTRUCT POINTER TO INSTRUCTION-1
	HRRI 1,-1(PP)		;... WITH ARGTYP BITS IN LH
	EXCH 1,2
	EXCH 1,0(PP)		;RECOVER ORIGINAL ARG LIST
	HLRZ 3,-1(PP)		;EVAL/APPLY FLAG
	JRST EVNC2		;CONTINUE WITH EVAL

EVNC1:	MOVE 1,0(PP)		;GET CAR OF FORM
	CARA 2,1		;IS CAR FUNARG?
	CAMN 2,KFNARG
	JRST EVNFA
	TLNE F,EVLFLG
	JRST .+3
	TLNE F,NACFLG		;WARRENS EXPERIMENT********
	JRST UDF
	CALL EVAL		;EVAL IT TO GET FN NAME
	JRST EVNC6		;CONTINUE WITH EVAL

;UNDEFINED ATOMIC CAR OF FORM

EVNC4:	TLNE F,NACFLG
	JRST UDF
	MOVE 1,0(PP)		;ATOM
	CALL PPLOOK		;LOOK ON STACK
	JFCL 0			;OR VALUE CELL
	HRRZ 1,0(1)
EVNC6:	CAMN 1,0(PP)
	JRST UDF		;VALUE IS SELF - ERROR
	CAME 1,KNIL
	CAMN 1,KNOB
	JRST UDF		;NIL OR NOBIND IS ERROR
EVNC3:	MOVEM 1,0(PP)		;OTHERWISE, TRY AGAIN
	MOVEI 2,0(1)
	TLO F,EVLFLG
	JRST EVNC5

UDF:	POP CP,PP
	MOVE 1,1(PP)
	TLZE 1,EVBLIP
	JRST EVFAU		;GO TO FAULTEVAL
	TLZN 1,APBLIP
	JRST UDF1
	HRRZS 1(PP)
	ADD PP,BHC+2
UDF3:	LCALL KFALTA,2
	RET

UDF1:	HRRZ 2,2(PP)	;FUNARG IN EVAL - DONT HAVE FORM
	CALL CONS
	JRST EVFAU

;FUNARG

FNABLP:	CDRA 1,1
	CDRA 2,1
	CARA 2,2
	STE 2,ARRAY
	ERROR1 33,RESET		;SECOND ARG NOT ARRAY
	HRRZ 3,0(2)
	ADDI 3,-1(2)
	HRLI 3,SKBLIP		;PUT SKIP BLIP TO END OF ARRAY
	PUSH PP,3
	HRRI 3,-1(PP)
	MOVEM 3,2(2)		;AND BACK TO STACK IN BEG ARRAY
	PUSH NP,F
	TLO F,STKFLG
	CARA 2,1		;FUNCTION
	POPJ CP,
EVNFA:	CALL FNABLP
	MOVE 1,-2(PP)		;ARGS
	HLL 2,-3(PP)
	TLZ 2,EVBLIP
	CALL APPLY2
EVNF2:	POP NP,2
	TLNN 2,STKFLG		;RESTORE STKFLG
	TLZ F,STKFLG
	JRST PPR1


NONAC:	CAME 1,KNIL		;WARRENS EXPERIMENT*********
	TLOA F,NACFLG
	TLZ F,NACFLG
	MOVEM F,TFLGS
	RET

;ROUTINE TO SEARCH PARAMETER STACK FOR VARIABLE BINDING
;CALLED WITH ATOM IN 1
;SKIPS AND RETURNS POINTER TO STACK  IN 1 IF FOUND
;DOES NOT SKIP, RETURNS ATOM IN 1 IF NOT FOUND
;PPLOOK LOOKS BACKWARD FROM CURRENT VALUE OF PP
;PPLOK2 LOOKS BACKWARD FROM VALUE OF PP IN AC2

PPLOOK:	MOVE 2,PP		;USE CURRENT PP
PPLOK2:	HRRZ 3,IPP		;BEGINNING OF STACK
	SUBI 2,0(3)		;NUMBER OF WORDS NOW IN USE
	MOVEI 2,0(2)		;ZERO LEFT HALF
	JUMPLE 2,PPLK2		;EMPTY?
	HRLI 3,2		;NO, MAKE 3 CONTAIN APP(2)
	TLNE F,STKFLG		;STACK BLIPPED?
	JRST PPLK5		;YES GO DO HARDER SEARCH
PPLK1:	HLRZ 4,@3		;GET VARIABLE NAME
	CAIN 4,0(1)		;MATCH?
	JRST PPLK3		;YES
	SOJG 2,PPLK1		;NO, COUNT WORDS
PPLK2:	RET			;NOT FOUND, RETURN NO-SKIP, ATOM IN AC1

PPLK3:	AOS 0(CP)		;FOUND, RETURN SKIP
	MOVEI 1,@3		;WITH STACK ADDRESS IN 1
	RET

PPLK5:	HLRZ 4,@3
	CAIN 4,SKBLIP
	JRST PPLK4
	CAIN 4,0(1)
	JRST PPLK3
	SOJG 2,PPLK5
	RET

PPLK4:	HRRZ 2,@3
	JRST PPLOK2

;PUSH LIST FUNCTIONS

STKPOS:	CAMN 1,KNIL
	JRST STKP3		;MEANS SELF IF NIL
	CAMN 2,KNIL
	MOVEI 2,ASZ+1		;MEANS 1 IF NIL
	MOVEI 1,0(2)
	CALL IUNBOX
	MOVS 2,-2(PP)		;REQUESTED FN NAME
	MOVE 6,0(PP)		;GET 3RD ARG
	CAMN 6,KNIL
RETF3:	MOVEI 6,-3(CP)		;USE CURRENT POSITION
	HRRZ 5,ICP		;TOP OF CP
	HRLI 5,6		;INDEXED BY 6
	SUBI 6,0(5)		;NUMBER OF WORDS ON STACK
	HRRI 2,PPR		;FLAG
	CAMN 2,@5
	JRST STKP1		;FOUND
STKP2:	SOJG 6,.-2		;COUNT WORDS
	JRST FALSE		;FAILS

STKP1:	SOJG 1,STKP2		;COUNT OCCURRANCES
	MOVEI 1,@5		;DONE, COMPUTE ADDRESS
	RET

STKP3:	MOVEI 1,-3(CP)		;APPROX ADDRESS OF LAST FN
	CALL STKCHK		;MAKE IT EXACT
	JRST FALSE		;NO EARLIER FNS
	RET

STKSCN:	MOVEI 1,0(2)
	CAMN 1,KNIL
	MOVEI 1,0(CP)
	HRRZ 2,IPP
	CAILE 1,0(2)		;P -STACK PTR?
	CAILE 1,NPP(2)
	JRST STKSC1
	MOVEI 2,0(1)
	JRST STKSC2
STKSC1:	CALL STKGP
	JRST STKERR
	HLRZ 2,-2(1)	;NUMBER STACKED
	ADD 2,-1(1)		;PLUS PP AT ENTRY
STKSC2:	HRRZ 1,-2(PP)
	CALL PPLOK2
	JFCL 0			;NOT FOUND, ATOM RETURNED IN 1
	RET


;STACK CLEARING FUNCTIONS

RETFRM:	JSP 7,UNSTK		;CLEAR BACK TO POS
	MOVE 1,-1(PP)		;VALUE TO BE RETURNED
	JRST PPR

STKCAL:	JSP 7,UNSTK
	HLRZ 1,-1(CP)		;NUMBER ARGS STACKED
	HRRZ 2,-1(PP)		;FN TO BE CALLED
	JUMPE 1,.+4		;ZERO ARGS?
	HRR 3,0(PP)		;NO- SEE IF WE WANT TO SUB. 1
	CAME 3,KNIL
	SUBI 1,1		;YES
	POP CP,PP		;RESTORE PP
	JUMPE 1,.+5		;ZERO ARGS?
	MOVEI	 3,(1)		;NO - MUST ZERO NAMES AND COVER STACK
	ADDI PP,1
	HRRZS (PP)
	SOJN 3,.-2
	HRLI PP,@IPPC		;RESTORE PP
	JRST EFNCAL		;CALL FN AND RET

RETEVL:	JSP 7,UNSTK
			;THE FOLLOWING IS A KLUDGE FOR W.T. SO THAT
			;CLISP TRANSFORMATIONS WILL WORK CORRECTLY.
			;A BIT IS SET IN THE NEAREST PROG WHICH
			;SAYS THAT IF, WHILE GO IS SEARCHING FOR A
			;LABLE, THAT THE PROG NEED NOT PHYSICALLY
			;CONTAIN THE PREVIOUS PROG WHICH WAS SEARCHED.
	MOVE	2,0(CP)		;FIND THE PROG BLIP
	MOVEI	1,PROG
	CALL	PPLOK2
	 JRST	RETEV2		;NO PROG'S ON THE STACK
	MOVEI	2,1		;SET THE GO BIT
	HRLM	2,-1(1)	
RETEV2:			;END OF KLUDGE
	HRRZ 1,-1(PP)		;FORM TO BE EVAL'D
	POP CP,PP
	HRLI PP,@IPPC		;RESTORE PP
	JRST EVAL		;ENTER EVAL QUIETLY

UNSTK:	CALL STKGP		;NORMALIZE POINTER
STKERR:	ERROR1 23,RESET		;NO PLACE TO GO
	MOVEI CP,-1(1)
	HRLI CP,@ICPC		;COMPUTE AND SET PROPER COUNT
	JSYS BRREST
	JRST 0(7)

SKBLIP==40

STKEVL:	CAILE 1,0(PP)
	JRST STKEV1
	MOVEI 2,0(1)
	HRRZ 3,IPP
	CAILE 1,0(3)		;PP PTR
	JRST STKEV2		;YES - USE IT
STKEV1:	CALL STKGP		;NORMALIZE POINTER
	JRST STKERR
	HLRZ 2,-2(1)		;# ARGS STACKED
	ADD 2,-1(1)		;+ PP AT ENTRY
STKEV2:	HRLI 2,SKBLIP
	TLO F,STKFLG
	HRRZ 1,-1(PP)		;GET FORM TO BE EVALED
	PUSH PP,2		;PUT SKIP BLIP ON STACK
	CALL EVAL		;EVAL FORM
	SUB PP,BHC+1		;UNBLIP
	TLZ F,STKFLG
	RET


STKARC:	HRRZ 2,-1(PP)		;FROM COMPILED CODE
STKARG:	MOVEI 1,0(2)
	CALL STKGP
	JRST STKERR
	PUSH PP,1
	HRRZ 1,-3(PP)		;NUMBER OF ARG AT THIS POSITION
	CALL IUNBOX
	POP PP,7
	ADD 1,-1(7)
	MOVEI 1,0(1)		;CLEAR LEFT
	RET

STKNRG:	CALL STKGP
	JRST STKERR
	HLRZ 1,-2(1)
	JRST MKN

STKNAM:	CALL STKCHK
	JRST STKERR
	HLRZ 1,0(1)
	RET

;CHECK FOR VALID CP POINTER AND NORMALIZE TO FLAG WORD

STKGP:	STN 1,ATOM
	JRST RETF1		;ATOM -  - DO STKPOS
STKCHK:	CAILE 1,0(CP)
	RET			;MUST BE LESS THAN CURRENT CP
	HRRZ 3,ICP		;TOP
STKCH1:	HRRZ 2,0(1)
	CAIN 2,PPR		;FLAG?
	JRST RSKP		;YES, RETURN SKIP
	CAILE 1,0(3)		;NO, STILL ON STACK?
	SOJA 1,STKCH1		;YES, KEEP GOING
	RET			;RETURN NO SKIP

RETF1:	MOVSI 2,0(1)
	MOVEI 1,1
	CALL RETF3
	CAME 1,KNIL
	JRST RSKP
	HLRZ	1,2		;RESTORE FOR ERROR
	RET			;DIDN'T FIND IT

STKNTC:	HRRZ 1,-2(PP)		;FROM COMPILED CODE
STKNTH:	CALL IUNBOX
	MOVE 7,1
	HRRZ 1,-1(PP)		;POSITION
	CAMN 1,KNIL
	JRST STKN1		;NIL, GO FIGURE OUT WHAT TO USE
	CALL STKGP
	JRST STKERR
	JUMPGE 7,STKN2		;POSITIVE, SEARCH FORWARD
	JRST STKN6		;OTHERWISE BACKWARD

STKN1:	HRRZ 1,ICP		;USE TOP
	JUMPGE 7,STKN2		;IF N POS
	MOVEI 1,0(CP)		;OTHERWISE, CURRENT
STKN6:	HRRZ 3,ICP		;GET TOP FOR COMPARE
STKN4:	SUBI 1,3		;BACKUP ONE FN CALL
STKN5:	CAIG 1,0(3)		;STILL ON STACK
	JRST FALSE		;NO
	HRRZ 2,0(1)
	CAIE 2,PPR		;FN CALL BLOCK?
	SOJA 1,STKN5		;NO, BACKUP ONE
	AOJL 7,STKN4		;YES, NTH ONE?
	RET			;YES, DONE

STKN2:	JUMPE 7,R		;MAYBE SHOULD GO TO STKCH1?
	ADDI 1,3		;FORWARD ONE FN CALL
STKN3:	CAILE 1,0(CP)		;OFF END OF STACK?
	JRST FALSE		;YES
	HRRZ 2,0(1)
	CAIE 2,PPR		;FN CALL BLOCK?
	AOJA 1,STKN3		;NO, BACKUP ONE
	SOJG 7,STKN2		;YES, NTH?
	RET			;YES

;ROUTINE TO DETERMINE TYPE OF ARGS FOR FUNCTION CALL
;CALLED WITH ATOM NAME IN AC1
;IF ATOM DOES NOT HAVE A LEGAL DEFINITION, RETURNS NO-SKIP
;OTHERWISE, RETURNS SKIP WITH BITS IN AC1, 34 AND 35
;  35=1 => NO-EVAL
;  34=1 => NO-SPREAD

ARGTYP:	MOVE 2,1(1)		;GET DEFINITION
	HLRZ 3,2		;GET CALLING INSTRUCTION
	LSH 3,-^D9		;RIGHT JUSTIFIED
	CAIN 3,HCCALV		;IS IT HCCAL?
	JRST ARGT1		;YES, FN IS SUBR
	MOVEI 3,0(2)		;NO, GET DEFINITION POINTER
ARGTYB:	CAMN 3,KNIL		;DEFINED?
	RET			;NO, RETURN NO-SKIP
	LDT 4,3			;GET TYPE OF DEFINITION
	CAMN 4,LISTT		;S-EXPRESSION?
	JRST ARGT2		;YES
	CAMN 4,CCODET		;COMPILED CODE?
	JRST ARGT3		;YES
	CAMN 4,HANDLT
	 JRST ARGT1
	RET			;ANYTHING ELSE IS ILLEGAL

ARGT1:	LSHC 1,^D13		;SWAPPED OR SUBR, GET BITS FROM AC FIELD
ARGT3A:	ANDI 1,3
RSKP:	AOS 0(CP)		;RETURN SKIPPING
	RET

ARGT2:	MOVEI 1,0		;FN IS S-EXPRESSION
	CARA 2,3
	CAMN 2,KLAM		;LAMBDA?
	JRST ARGT2A		;YES
	CAME 2,KNLA		;NO, NLAMBDA?
	RET			;NO, ILLEGAL
	TRO 1,1			;YES, MEANS NO-EVAL
ARGT2A:	CDRA 3,3		;GET VARIABLES
	CARA 3,3
	CAMN 3,KNIL
	JRST RSKP
	STE 3,LIST		;LIST?
	TRO 1,2			;NO, ATOM (ASSUMED) MEANS NO SPREAD
	JRST RSKP		;RETURN AND SKIP

ARGT3:	HRRZ 1,1(3)		;FN IS COMPILED, GET TYPE FROM 2ND WD
	JRST ARGT3A

ARGTY:	STE 1,ATOM
	JRST ARGTYA
	CALL ARGTYP		;USER FUNCTION ARGTYPE
	JRST FALSE
	JRST MKN

ARGTYA:	CALL SUBRP		;ARG NOT ATOM - ASSUME DEF
	HRRZ 3,-2(PP)
	CAME 1,KNIL
	JRST ARGTYC
	LDT 2,3
	CAMN 2,HANDLT
	 JRST ARGTYH
	CALL ARGTYB
	JRST FALSE
	JRST MKN

ARGTYC:	CARA 1,3
	RET

ARGTYH:	PUSH PP,BR		;GET THE DAMN THING INTO MEMORY
	HRLI BR,(3)		;AND GET ARGTYPE BITS A LA
	CALL SWAPIN		;TWO PAGES BELOW AT PUTD5
	HRRZ 1,3(BR)		;HERE ARE THE BITS
	POP PP,BR
	CALL	RESWAP
	JRST MKN

;GETD AND PUTD

GETD:	STE 1,ATOM		;ATOM?
	JRST FALSE		;NO - RET NIL
	MOVE 2,1(1)		;GET DEF CELL
	HLRZ 3,2		;GET CALLING INSTRUCTION
	LSH 3,-^D9
	CAIN 3,HCCALV		;SUBR?
	JRST GETD1		;YES
	MOVEI 1,0(2)		;NO, RETURN POINTER
	RET

GETD1:	LDB 1,[POINT 4,2,12]	;GET EXTRA BITS
	ADDI 1,ASZ		;MAKE SMALL NUMBER
	MOVEI 2,0(2)		;CODE ADDRESS
	JRST CONS		;RETURN CONS OF TYPE INFO AND LOC

PUTD:	STE 1,ATOM
	ERROR1 4,R
	CAMN 2,KNIL
	JRST PUTD2
	LDT 3,2			;GET TYPE OF DEF
	CAMN 3,ATOMT		;ATOM?
	JRST PUTDX		;YES, UNDEFINED
	CAMN 3,HANDLT
	 JRST PUTD5
	CAME 3,CCODET		;COMPILED CODE?
	JRST PUTD1		;NO
	HRLI 2,<PUSHJ CP,>B53	;YES, INSERT CALLING INSTRUCTION
PUTD3:	MOVEM 2,1(1)		;STORE IN FN CELL
PUTD4:	MOVEI 1,0(2)		;RETURN DEF
	RET

PUTD1:	CAME 3,LISTT		;LIST?
	JRST PUTDX		;NO, UNDEFINED
	CARA 3,2		;YES
	CAIG 3,ASZ+3
	CAIGE 3,ASZ		;SUBR?
	JRST PUTD2		;NO, EXPR
	SUBI 3,ASZ		;YES, GET ARG BITS
	LSH 3,5
	IORI 3,<HCCALV>B26	;INSERT CALLING INSTRUCTION
	HRLM 3,1(1)
	CDRA 3,2		;GET CODE LOC
	CAMGE 3,ENDCOR		;CHECK FOR NON-DATA LOC
	CAMG 3,BGNCOR
	JRST .+2
	JRST PUTD2		;DATA, TREAT AS EXPR
	HRRM 3,1(1)
	JRST PUTD4

PUTD2:	HLL 2,EVALUU		;USE EXCAL INSTRUCTION
	JRST PUTD3

PUTD5:	HRLI 2,<SBCAL 0,0>B53
	PUSH PP,BR		;SAVE BR OF CURRENT GUY IF ANY
	HRLZI BR,(2)		;LH(BR)=HANDLE FOR SWAPIN
	CALL SWAPIN
	HRRZ 3,3(BR)		;RH OF 1ST WD AFTER JSP TO ENTERF
	DPB 3,[POINT 4,2,12]	;HAS THE BLOODY FNTYP BITS FOR SBCAL
	POP PP,BR
	CALL	RESWAP		;Get prev guy back, fix stack.
	JRST PUTD3


PUTDX:	MOVEI 1,0(2)		;ERRONEOUS DEFINITION
	ERROR1 4,R

;PREDICATES FOR FUNCTION TYPE, WORK GIVEN FN NAME OR DEF

CCODEP:	LDT 2,1
	CAME 2,ATOMT		;ATOM?
	JRST CCDP1		;NO ASSUME GIVEN DEF
	HRRZ 1,1(1)		;YES , GET DEF
	LDT 2,1
CCDP1:	CAMN 2,CCODET
	JRST TRUE
	JRST SCODP1

SUBRP:	LDT 2,1
	CAME 2,ATOMT
	JRST SUBRP1
	HLRZ 1,1(1)
	LSH 1,-^D9
	CAIN 1,HCCALV		;HAND-CODE CALL?
	JRST TRUE
	JRST FALSE

SUBRP1:	CAME 2,LISTT		;IS GETD A LIST?
	JRST FALSE		;NO- FALSE
	CARA 2,1
	CAIG 2,ASZ+3		;CAR BET. 0 AND 3 ?
	CAIGE 2,ASZ
	JRST FALSE		;NO - FALSE
	CDRA 1,1
	CAMGE 1,ENDCOR		;CDR NON-DATA ?
	CAMGE 1,BGNCOR
	JRST TRUE		;YES - IS SUBR
	JRST FALSE

EXPRP:	LDT 2,1
	CAME 2,ATOMT
	JRST EXPRP1
	MOVE 1,1(1)
	XOR 1,EVALUU
	TLNN 1,-1
	CAMN 1,KNIL
	JRST FALSE		;NOT EXPR, OR IS NIL
	JRST TRUE
EXPRP1:	CAME 2,LISTT		;LIST?
	JRST FALSE		;NO-FALSE
	CALL SUBRP1
	CAME 1,KNIL
	JRST FALSE
	JRST TRUE

SCODEP:	LDT 2,1
	CAME 2,ATOMT
	 JRST SCODP1
	HRRZ 1,1(1)
	LDT 2,1
SCODP1:	CAMN 2,HANDLT
	 JRST TRUE
	JRST FALSE


;BASIC PREDICATES

ATOM:	LDT 2,1
	CAML 2,ATOMT		;ATOM IS REALLY ATOM OR NUMBER
	CAMLE 2,SMALLT
	JRST FALSE
	JRST TRUE

LITATM:	STE 1,ATOM
	JRST FALSE
	JRST TRUE

EQ:	CAIE 1,0(2)		;LIKE COMPILED EQ
	JRST FALSE
	JRST TRUE

NULL:	CAME 1,KNIL		;ALSO NOT
	JRST FALSE
	JRST TRUE

NUMBRP:	LDT 2,1
	CAML 2,FLOATT		;FIXED, FLOATING, OR SMALL
	CAMLE 2,SMALLT
	JRST FALSE
	RET

LISTP:	STE 1,LIST
	JRST FALSE
	RET

FLOATP:	STE 1,FLOAT
	JRST FALSE
	RET

MINUSP:	CALL GUNBOX
	JUMPL 1,TRUE
	JRST FALSE

STRNGP:	STE 1,STPT
	JRST FALSE
	RET

HANDLP:	STE 1,HANDLT
	JRST FALSE
	RET

AND:	MOVE 2,KT
AND1:	CAMN 1,KNIL		;MORE CLAUSES?
	JRST R2			;NO, RETURN LAST VALUE
	PUSH PP,1
	CARA 1,1		;NEXT CLAUSE
	CALL EVAL
	MOVEI 2,0(1)
	POP PP,1
	CAMN 2,KNIL		;NIL?
	JRST FALSE		;YES, FAIL => RETURN NIL
	CDRA 1,1		;NO, CONTINUE
	JRST AND1

OR:
OR1:	CAMN 1,KNIL		;MORE CLAUSES
	RET			;NO, FAIL
	PUSH PP,1
	CARA 1,1		;NEXT CLAUSE
	CALL EVAL
	MOVEI 2,0(1)
	POP PP,1
	CAME 2,KNIL		;NIL?
	JRST R2			;NO, RETURN IT
	CDRA 1,1		;YES, CONTINUE
	JRST OR1
EQP:	CAIN 1,0(2)		;EQ WHICH WORKS FOR NUMBERS TOO
	JRST TRUE
	MOVEI 6,0(2)
	CALL GUBS
	EXCH 1,6		;SAVE UNBOXED NUMBER
	MOVEI 7,0(2)		;AND ITS TYPE
	CALL GUBS		;UNBOX SECOND ARG
	CAIN 2,0(7)		;BOTH SAME TYPE?
	JRST EQPCV		;YES- COMPARE VALUES
	CAME 7,FLOATT		;NO- IS ONE ARG FLOATING?
	JRST EQP1		;CHECK OTHER ARG
EQP2:	CALL FXFLT		;CONVERT FIXED TO FLOATING
	JUMPN 2,FALSE		;IF SOMETHING LOST IN CONVERSION, FALSE
EQPCV:	CAME 6,1
	JRST FALSE
	JRST TRUE

EQP1:	CAME 2,FLOATT
	JRST EQPCV		;NEITHER ARG IS FLOATING
	EXCH 1,6		;GET FIXED ARG TO 1
	JRST EQP2

GUBS:	LDT 2,1
	CAMN 2,SMALLT
	JRST IUBS
	CAME 2,FLOATT
	CAMN 2,FIXT
	JRST IUB2		;FIXED OR FLOAT, GET VALUE
	SUB CP,BHC+1		;NOT NUMBER, FLUSH EXTRA RETURN
	JRST FALSE		;AND RETURN FALSE

;BASIC SUBR'S

SET:	HRRM 2,0(PP)
	JRST SET1

SETQ:	CDRA 1,1		;GET EXPR
	CARA 1,1
	CALL EVAL
	EXCH 1,0(PP)
	CARA 1,1		;GET NAME
SET1:	STE 1,ATOM		;ATOM?
	ERROR1 5,R		;NO, ERROR
	CAMN 1,KNIL		;NAME IS NIL?
	JRST SETERR		;YES, ILLEGAL TO SET NIL
	CALL PPLOOK		;FIND LOCATION
	JFCL 0			;VALUE CELL
	HRRZ 2,0(PP)		;NEW VALUE
	HRRM 2,0(1)
R2:	MOVEI 1,0(2)
	RET

SETERR:	HRRZ 1,0(PP)
	ERROR1 6,R


;CONTROL SUBR'S

DDTC:	HALTF
OFFINT:	CLRICH
	RET

LOGOUT:	CALL OFFINT
	HALTF
LOGRE:	SETICH
	JRST FALSE

CONSCF:	CAME 1,KNIL
	JRST CONSCN
	MOVE 1,CNSCNT
	JRST MKN


CONSCN:	CALL IUNBOX
	MOVEM 1,CNSCNT
	HRRZ 1,-2(PP)
	RET

;BOXCOUNT(TYPE NEWCOUNT)

BOXCNT:	CAME	2,KNIL		;JUST GET CURRENT COUNT?
	JRST	BOXCN1		;NO
	HRRZ	2,-2(PP)	;YES - GET TYPE
	MOVE	1,IBOXCN	;GET PROPER COUNTER
	CAME	2,KNIL
	MOVE	1,FBOXCN
	CAIGE	1,MSN/2		;DON'T COUNT THE BOXING OPERATION
	CAMG	1,[-MSN/2]
	SOS	IBOXCN
	JRST	MKN

BOXCN1:	MOVEI	1,0(2)		;GET THE NEW COUNT
	CALL	IUNBOX
	HRRZ	2,-2(PP)	;GET TYPE
	MOVEI	3,IBOXCN	;GET THE PROPER COUNTER
	CAME	2,KNIL
	MOVEI	3,FBOXCN
	MOVEM	1,0(3)
	HRRZ	1,-1(PP)	;RETURN THE NEW COUNT
	RET

;RECLAIM AND MINFS

RECLM:	CAMN 1,KNIL
	SKIPA 1,LISTT
	CALL IUNBOX
	ANDI 1,MTYPN		;ARG IS TYPE
	SKIPN TYPBLK(1)
	JRST FALSE		;NO SUCH TYPE
	PUSH NP,1
	PUSH CP,[RECLM1]
	CAMN 1,ARRAYT
	JRST ARRGC
	CAMN 1,STRNGT
	JRST STRGC
	JRST GC1

RECLM1:	POP NP,1
	HRRZ 1,TYPBLK(1)
	MOVE 1,TNFR(1)
	JRST MKN

MINFS:	MOVEI 1,0(2)
	CAMN 1,KNIL		;SECOND ARG NIL MEANS LIST
	SKIPA 1,LISTT
	CALL IUNBOX		;ELSE TYPE NUMBER
	ANDI 1,MTYPN
	HRRZ 2,TYPBLK(1)
	JUMPE 2,FALSE
	PUSH NP,2
	HRRZ 1,-2(PP)
	CAMN 1,KNIL
	SKIPA 1,TMIN(2)
	CALL IUNBOX
	POP NP,2
	EXCH 1,TMIN(2)
	JRST MKN


;OPENR/CLOSER

OPENR:	CALL IUNBOX
	MOVE 1,0(1)
	JRST MKN

CLOSER:	CALL IUNBOX		;ADDRESS
	PUSH NP,1
	HRRZ 1,-1(PP)
	CALL GUNBOX		;CONTENTS
	POP NP,7
	MOVEM 1,0(7)
	HRRZ 1,-1(PP)
	RET

;MAP INDEF NUMBER OF ARGS
;COUNT OF ARGS SUPPLIED IN AC1
;INSTRUCTION TO EXECUTE TO PROCESS EACH ARG FOLLOWS CALL

MPARG:	MOVN 7,1
	JUMPGE 7,RSKP		;NO ARGS
	HRLI 7,-1(7)
	ADDI 7,1(PP)
PLUS1:	PUSH NP,7
	HRRZ 1,0(7)		;GET ARG
	XCT @0(CP)		;CALL EXECUTION FUNCTION
	POP NP,7
	AOBJN 7,PLUS1
	JRST RSKP

;NTYP - GET TYPE OF ARG

NTYP:	LDT 1,1
	JRST MKN

;NCONC

NCONC:	MOVE 5,KNIL
	CALL MPARG
	 CALL NCONC3
	MOVE 1,5
	RET

NCONC3:	STE 5,LIST
	JRST NCONC1
	SKIPA
NCONC2:	MOVEI 4,0(3)
	CDRA 3,4
	STN 3,LIST
	JRST NCONC2
	HRLM 1,0(4)
	RET

NCONC1:	MOVEI 5,0(1)
	MOVEI 4,0(1)
	RET

;FMEMB

FMEMB:	HRRZ 3,0(2)
	CAMN 3,1
	JRST FMEMBE
	HLRZ 2,0(2)
	CAME 2,KNIL
	JRST FMEMB
FMEMBE:	MOVEI 1,0(2)
	RET

;MAKE HANDLE

MKHDL1:	PUSH NP,1
	MOVE 1,HANDLT
	CALL GC1
	POP NP,1
MKHDL:	SKIPN 2,FREHDL
	JRST MKHDL1		;NO SPACE
	EXCH 1,0(2)
	EXCH 1,FREHDL
	RET

UMKHDL:	CALL IUNBOX
	JRST MKHDL

;INTEGER ARITHMETIC FUNCTIONS


MINUS:	CALL GUNBOX
	MOVN 1,1
	JRST GBOX

;IPLUS

IPLUS:	PUSH NP,[0]		;INITIAL SUM
	CALL MPARG		;MAP ALL ARGS
	CALL PLUS2		;WITH PLUS2
ITMS1:	POP NP,1		;ACCUMULATED VALUE
	JRST MKN

PLUS2:	CALL IUNBOX
	ADDM 1,-1(NP)
	RET

ITIMES:	PUSH NP,[1]		;INITIAL PRODUCT
	CALL MPARG
	CALL ITMS2
	JRST ITMS1

ITMS2:	CALL IUNBOX
	IMULM 1,-1(NP)
	RET

LOGOR:	PUSH NP,[0]
	CALL MPARG
	 CALL LOGOR1
	JRST ITMS1

LOGOR1:	CALL IUNBOX
	IORM 1,-1(NP)
	RET

LOGAND:	PUSH NP,[-1]
	CALL MPARG
	 CALL LOGAN1
	JRST ITMS1

LOGAN1:	CALL IUNBOX
	ANDM 1,-1(NP)
	RET

LOGXOR:	PUSH NP,[0]
	CALL MPARG
	 CALL LOGXR1
	JRST ITMS1

LOGXR1:	CALL IUNBOX
	XORM 1,-1(NP)
	RET

LSHFT:	CALL I2UBOX		;LOGICAL SHIFT
	LSH 1,0(2)
	JRST MKN

ASHFT:	CALL I2UBOX		;ARITHMETIC SHIFT
	ASH 1,0(2)
	JRST MKN


;GENERAL PLUS

PLUS:	CALL HIGHT
	 JRST IPLUS
FPLUS:	PUSH NP,[0]		;FLOATING PLUS
	CALL MPARG
	 CALL FPLUS2
FPLUS1:	POP NP,1
	JRST MKFN

FPLUS2:	CALL FUNBOX
	FADM 1,-1(NP)
	RET

;UNBOX NUMBER TO FLOATING

FUNBOX:	CALL GUNBOX			;UNBOX NUMBER
	CAMN 2,FLOATT		;FLOATING?
	RET			;YES- RETURN
FXFLT:	IDIVI 1,400		;FIXED TO FLOAT CONVERSION
	FSC 1,243
	FSC 2,233
	FADL 1,2		;LEAVE LOST PART IF  ANY IN 2
	RET

;FIND MOST COMPLICATED TYPE IN ARG LIST, SKIP IF FLOATING

HIGHT:	PUSH CP,1		;SAVE NUMBER OF ARGS
	HRRZ 5,SMALLT
	CALL MPARG
	 CALL HGH1
	CAMN 5,FLOATT
	AOS -1(CP)
	POP CP,1
	RET

HGH1:	LDT 2,1
	CAIGE 2,0(5)
	MOVEI 5,0(2)		;LOW TYPE NUMS ARE MOST COMPLEX
	RET

;GENERAL TIMES

TIMES:	CALL HIGHT
	 JRST ITIMES
				;FLOATING TIMES
FTIMES:	MOVSI 5,201400		;1.0
	PUSH NP,5
	CALL MPARG
	 CALL FTIME2
	JRST FPLUS1

FTIME2:	CALL FUNBOX
	FMPRM 1,-1(NP)
	RET

;UNBOX NUMBERS IN 1 AND 2 TO HIGHEST TYPE, RESULTS IN 1 AND 2
;SKIP IF FLOATING

G2UBOX:	LDT 4,2
	LDT 3,1
	CAME 4,FLOATT
	CAMN 3,FLOATT
	JRST U2B1		;AT LEAST ONE IS FLOATING
I2UBOX:	PUSH PP,2		;UNBOX 1 AND 2 TO INTEGER
	CALL IUNBOX
	PUSH NP,1
	POP PP,1
	CALL IUNBOX
U2B2:	MOVE 2,1
	POP NP,1
	RET

U2B1:	AOS 0(CP)
F2UBOX:	PUSH PP,2		;UNBOX 1 AND 2 TO FLOATING
	CALL FUNBOX
	PUSH NP,1
	POP PP,1
	CALL FUNBOX
	JRST U2B2

;CONVERT NUMBER IN 1 TYPE IN 2, TO TYPE IN 3

CNVNUM:	CAMN 3,SMALLT
	MOVE 3,FIXT
	CAMN 2,SMALLT
	MOVE 2,FIXT
	CAIN 3,0(2)
	RET
	CAME 3,FLOATT
	JRST FLTFX
	JRST FXFLT		;FIXED TO FLOAT

;GREATERP- GENERAL

GRTRP:	CALL G2UBOX
	 JFCL 0
GRTR1:	CAMG 1,2
	JRST FALSE
	JRST TRUE

;GREATERP- INTEGER

IGRTRP:	CALL I2UBOX
	JRST GRTR1

;GREATERP - FLOATING

FGTP:	CALL F2UBOX
	JRST GRTR1

;QUOTIENT- GENERAL

QTENT:	CALL G2UBOX
	JRST IQT1
	JRST FQT1

;REMAINDER- GENERAL

RMNDR:	CALL G2UBOX
	JRST IRMND1
	JRST FRMND1

;INTEGER QUOTIENT

IQTENT:	CALL I2UBOX
IQT1:	IDIV 1,2
	JRST MKN

;INTEGER REMAINDER

IRMNDR:	CALL I2UBOX
IRMND1:	IDIV 1,2
	MOVE 1,2
	JRST MKN

;FLOATING QUOTIENT

FQTENT:	CALL F2UBOX
FQT1:	FDV 1,2
	JRST MKFN
;FLOATING REMAINDER

FRMNDR:	CALL F2UBOX
FRMND1:	MOVE 3,2
	MOVEI 2,0
	FDVL 1,3
	MOVE 1,2
	FSC 1,0			;NORMALIZE
	JRST MKFN

;PROGN (EVAL LIST OF FORMS)

PROGN:	MOVE 2,1
PROGN1:	CAMN 2,KNIL		;END OF LIST?
	RET			;YES
	CARA 1,2		;NO, GET NEXT FORM
	PUSH PP,2		;SAVE REMAINDER OF LIST
	CALL EVAL
	POP PP,2
	CDRA 2,2		;GET REST OF LIST
	JRST PROGN1

;VERY BASIC SUBR'S

CAR:	CARA 1,1
	RET

CDR:	CDRA 1,1
	RET

RPLACA:	CAMN 1,KNIL
	JRST RPLNIL
	HRRM 2,0(1)
	RET

RPLACD:	CAMN 1,KNIL
	JRST RPLNIL
	HRLM 2,0(1)
	RET

RPLNIL:	CAMN 2,KNIL		;RPLAC(A-D) NIL NOT PERMITTED
	RET			;EXCEPT WITH NIL
	MOVEI 1,0(2)
	ERROR1 7,R

;PROG1 (EVAL A LIST OF FORMS AND RETURN THE FIRST ONE)

PROG1:	CAMN 1,KNIL		;EMPTY LIST?
	RET			;YES
	MOVEI	2,0(1)		;NO, GET FIRST FORM
	CARA	1,2
	CDRA	2,2
	PUSH	PP,2		;SAVE REST OF LIST
	CALL	EVAL		;EVAL FIRST FORM
	EXCH	1,(PP)		;GET REST OF LIST AND SAVE FIRST RESULT
	CALL	PROGN		;EVAL REST OF LIST
	POP	PP,1		;RETURN THE FIRST ITEM
	RET

;COND

COND:
COND2:	CAMN 1,KNIL		;END OF CLAUSES?
	RET			;YES, RETURN NIL
	PUSH PP,1		;SAVE LIST
	CARA 1,1		;GET PREDICATE
	CARA 1,1
	CALL EVAL
	POP PP,2
	CAMN 1,KNIL		;TEST
	JRST COND1		;FAILS, GET NEXT CLAUSE
	CARA 2,2		;GET REMAINDER OF CLAUSE
	CDRA 2,2
	JRST PROGN1		;GO EVAL CONSEQUENCES

COND1:	CDRA 1,2		;GET NEXT CLAUSE
	JRST COND2

;PROG, GO, RETURN

PROG:	PUSH CP,PP		;SAVE P-STACK POSITION
	PUSH PP,1		;SAVE PROG
	CARA 1,1		;GET VARIABLE LIST
PRO1:	CAMN 1,KNIL		;ANY VARIABLES LEFT?
	JRST PRO11
	CARA 3,1		;GET A VARIABLE
	STE 3,LIST		;LIST?
	JRST PRO14		;NO- DO SIMPLE CASE
	CARA 4,3		;YES - CAR IS NAME
	PUSH PP,4		;SAVE NAME
	PUSH PP,1		;SAVE CURRENT VARIABLE LIST
	CDRA 3,3		;GET VALUE
	CARA 1,3
	CALL EVAL		;EVAL IT
	EXCH 1,0(PP)		;SAVE VALUE AND GET BACK VAR LIST
PRO15:	CDRA 1,1
	JRST PRO1

PRO14:	PUSH PP,3		;SAVE NAME
	HRRZ 3,KNIL		;VALUE IS NIL
	PUSH PP,3		;SAVE VALUE
	JRST PRO15		;AND GO ON

PRO11:	HRRZI 5,0(PP)		;REMEMBER CURRENT PP FOR ENDCHECK
	MOVE PP,0(CP)		;RESTORE PP
	MOVE 2,1(PP)		;GET PROG BACK
	MOVEI 4,1(PP)		;SET UP COUNT
PRO12:	CAIN 4,0(5)		;DONE?
	JRST PRO2
	HRLZ 3,1(4)		;NAME TO LEFT
	HRR 3,2(4)		;VALUE TO RIGHT
	PUSH PP,3		;SAVE NAME AND VALUE
	ADDI 4,2
	JRST PRO12

PRO2:	PUSH PP,2		;SAVE WHOLE PROG
	MOVSI 3,PROG		;PUT BLIP ON P-STACK
	HRRI 3,0(CP)		;WITH CURRENT C-STACK POSITION
	PUSH PP,3		;FOR USE BY GO AND RETURN
PRO3:	CDRA 2,2
	CAMN 2,KNIL		;STATEMENTS LEFT?
	JRST PPR1		;NO, RETURN
	PUSH PP,2		;SAVE CURRENT STATE OF PROG
	SETZ	1,
	HRLM	1,-2(PP)	;CLEAR THE GO BIT
	CARA 1,2		;GET STATEMENT
	STE 1,ATOM		;LABEL?
	CALL EVAL		;NO, EVAL IT
	POP PP,2		;RECOVER PROG
	JRST PRO3


GO:	CARA 1,1		;GET GO LABEL
	MOVEI 2,0(PP)
	CALL PROGR		;CLEAR STACKS BACK TO LAST PROG
GOX:	ERROR1 10,RESET
	MOVE 1,PROT1		;SAVED LABEL
	HRRZ 2,-1(PP)		;WHOLE PROG
GO1:	CDRA 2,2
	CAMN 2,KNIL		;ANY STATEMENTS LEFT?
	JRST GO3		;NO, UNDEFINED LABEL
	CARA 3,2
	CAIN 3,0(1)		;IS THIS DESIRED LABEL?
	JRST PRO3		;YES, CONTINUE WITH PROG
	JRST GO1		;NO, CONTINUE SEARCH

GO3:	PUSH CP,[GOX]
	MOVEI 2,-1(PP)		;IS THER AN OUTER PROG?
	MOVEI 1,PROG
	CALL PPLOK2
	 JRST PROGER		;NO PROG
	PUSH CP,1
	MOVE 2,-1(1)		;GET OUTER PROG
	HRRZ 1,-1(PP)		;INNER PROG
	TLNN 2,1	;SKIP IF NON-NESTED PROG ALLOWED(SEE RETEVAL)
	CALL MM			;CHECK THAT REALLY NESTED
	CAMN 1,KNIL
	 JRST PROGE1		;NOPE
	POP CP,1
	JRST GO2


RETURN:	MOVEI 2,0(PP)
	CALL PROGR		;CLEAR STACKS
	ERROR1 3,RESET
	MOVE 1,PROT1		;VALUE TO BE RETURNED
	JRST PPR1		;RESTORE P-STACK AND RETURN



;ROUTINE TO CLEAR STACKS BACK TO LAST PROG

PROGR:	MOVEM 1,PROT1		;SAVE AC1
	MOVEI 1,PROG		;NAME LEFT ON STACK BY PROG
	CALL PPLOK2		;SEARCH P-STACK
	JRST PROGER		;NOT IN PROG
GO2:	AOS 0(CP)
UNBLIP:	MOVEI PP,0(1)		;SET PP TO LOC OF FLAG WORD
	HRLI PP,@IPPC		;RESTORE CORRECT COUNT TO LH
	POP CP,2		;LOCAL RETURN
	HRRZ CP,0(PP)		;CP CORRESPONDING TO FLAG POSITION
	HRLI CP,@ICPC		;COUNT
	JSYS BRREST		;Restore swapping buffer.
	JRST (2)

PROGE1:	POP CP,1
PROGER:	HRRZ 1,PROT1
	RET

U PROT1				;LOCAL TEMP FOR VALUE OR LABEL

MM:	CAIN 1,0(2)
	POPJ CP,
	STE 2,LIST
	JRST FALSE
	PUSH PP,2
	HRLM 1,0(PP)
	CARA 2,2
	CALL MM
	POP PP,2
	CAME 1,KNIL
	RET
	HLRZ 1,2
	CDRA 2,2
	JRST MM

;CONS

CONS:	PUSH PP,1
	HRLM 2,0(PP)		;CONSTRUCT WORD
	MOVEI 1,0(2)		;TRY CDR
CONS2:	CALL CONST
	HRRZ 1,0(PP)		;TRY CAR
	CALL CONST
	MOVE 1,LSTCNS		;TRY LAST CONS
	CALL CONST
	MOVE 1,NEWCNS		;BEGIN AT NEWCNS, SEARCH FOR PAGE WITH
	MOVE 4,CMINWP		;.G. MINWPP WORDS OF STORAGE
CONS1:	CALL CONSN		;TEST, NO RETURN IF OK
	ADDI 1,NPS		;TRY NEXT PAGE
	MOVEM 1,NEWCNS
	CAMGE 1,ENDCOR		;IF STILL WITHIN RANGE
	JRST CONS1
	MOVE 2,FRECNT
	MOVEM 2,OFRECT
	CALL CONSGC		;NO PAGES TO TRY, MUST GC
	MOVE 2,FRECNT
	CAMG 2,OFRECT
	JRST CONSX
	HLRZ 1,0(PP)		;START OVER
	JRST CONS2

CONSX:	MOVEI 2,2
	MOVEM 2,CMINWP
	ERROR0 37,RESET

;TEST FOR POSSIBLE CONS ON PAGE

CONST:	MOVEI 4,0		;MIN NUMBER OF WORDS
CONSN:	MOVEI 2,0(1)		;GET TYPE OF PAGE
	LSH 2,-LPS
	ADD 2,FCP		;CONSTRUCT POINTER TO FREE COUNT
	HRRZ 3,0(2)		;TYPE
	ANDI 3,77
	CAME 3,LISTT		;LIST?
	RET			;NO
	LDB 3,2			;GET FREE COUNT
	CAIG 3,0(4)		;GREATER THAN MIN?
	RET			;NO
	SUBI 3,1		;DECREMENT COUNT
	DPB 3,2			;REPLACE IN TABLE
	ILDB 3,2		;GET FREE LIST
	TRZ 1,MPS		;CONSTRUCT NEW POINTER
	IORI 1,0(3)
	MOVE 3,0(1)		;NEXT WORD IN FREE LIST
	DPB 3,2			;UPDATE FREE LIST POINTER
	POP PP,0(1)		;STORE CONSTRUCTED WORD
	MOVEM 1,LSTCNS		;SAVE LAST CONS
	AOS CNSCNT		;CONS COUNTER
	SOS 2,FRECNT		;REDUCE TOTAL FREE COUNT
	CAMN 2,FREBRK		;TEST AGAINST BREAK VALUE
	JRST CNSC1		;SET BREAK FLAG
CNSC2:	POP CP,2		;FLUSH EXTRA RETURN
	RET

CNSC1:	TLO F,CNSFLG
	MOVE 2,RSTBK		;SETUP TO BREAK AT NEXT FN CALL
	MOVEM 2,FNCALL
	JRST CNSC2

FCP:	POINT 9,TYPTAB,8


;SET FREBRK

GCTRP:	CAMN 1,KNIL
	JRST GCTR1		;ARG NIL - RET FREE COUNT
	CALL IUNBOX
	EXCH 1,FREBRK
	JRST MKN

GCTR1:	MOVE 1,FRECNT
	JRST MKN

;SET FLAG FOR GC MESSAGES

GCGAG:	MOVE	2,KNIL
	LDT	3,1
	CAME	3,LISTT		;IS THE ARG A LIST?
	JRST	GCGAG1		;YES
	CDRA	2,1		;NO - SPLIT INTO 2 ARGS
	CARA	1,1
GCGAG1:	CAMN	1,KNIL
	SETZ	1,
	EXCH	1,GCMESF
	SKIPN	1
	MOVE	1,KNIL
	CAMN	2,KNIL
	SETZ	2,
	EXCH	2,GCMES2
	JUMPN	2,CONS		;HAVE A SECOND PART - CONS RESULT
	RET

; SET FLAG FOR HERALD

HERALD:	CAMN	1,KNIL
	SETZ	1,
	EXCH	1,HLDMSG
	JUMPE	1,FALSE
	RET

;MAP ON ALL ATOMS

MPATMS:	HRRZ 3,ATOMHT
	HRRZ 4,@3		;LENGTH-1
	HRLI 3,4		;ATOMHT(4)
MAPA2:	MOVE 1,@3
	TLNN 1,777776
	JRST MAPA1
	MOVEI 1,-2(1)
	MOVE 2,KNIL
	PUSH NP,3
	PUSH NP,4
	CALL CONS
	MOVEI 2,0(1)
	HRRZ 1,-2(PP)
	CALL APPLY
	POP NP,4
	POP NP,3
MAPA1:	SOJG 4,MAPA2
	JRST FALSE


;MAKE INTEGER NUMBER

MKN:	CAIGE 1,MSN/2		;TEST FOR SMALL NUMBER
	CAMG 1,[-MSN/2]
	JRST MKN1
	ADDI 1,ASZ		;SMALL NUMBER 0
	RET

MKN1:	SKIPN 2,FREENM		;TEST FREE LIST
	JRST MKN2		;EMPTY
	EXCH 1,0(2)		;NOT EMPTY, STORE NUMBER AND GET
	EXCH 1,FREENM		;UPDATE FREE LIST
	AOS	IBOXCN		;UPDATE INTEGER BOX COUNT
	RET

MKN2:	PUSH NP,1		;SAVE NUMBER
	CALL INTGC		;INITIATE GARBAGE COLLECTION
	POP NP,1
	JRST MKN1		;TRY AGAIN

;UNBOX NUMBER TO INTEGER

IUNBOX:	CALL GUNBOX		;UNBOX NUMBER
	CAME 2,FLOATT		;FLOATING?
	RET			;NO- RETURN
FLTFX:	MULI 1,400		;CONVERT FLOAT TO FIXED
	TSC 1,1
	EXCH 1,2
	JUMPL 1,FLTFX1
	ASH 1,-243(2)
	RET
FLTFX1:	MOVN 1,1
	ASH 1,-243(2)
	MOVN 1,1
	RET


TRUE:	MOVE 1,KT		;RETURN T
R:	RET

FALSE:	MOVE 1,KNIL		;RETURN NIL
	RET
;GENERAL UNBOX- GET VALUE IN 1, TYPE IN 2

GUBEE:	POP CP,FF		;AFTER ERROR
GUNBOX:	LDT 2,1			;GET TYPE TO 2
	CAMN 2,SMALLT		;SMALL?
	JRST IUBS
	CAML 2,FLOATT		;FLOATING OR FIXED?
	CAMLE 2,FIXT
	JRST GUBE		;NO - ERROR
IUB2:	MOVE 1,0(1)		;YES- GET VALUE
	RET

IUBS:	SUBI 1,ASZ		;SMALL NUMBER ZERO
	RET

GUBE:	PUSH CP,FF		;PRESERVE FF FOR COMPILED CODE
	ERROR1 12,GUBEE

;GENERAL BOX- GIVEN VALUE IN 1, TYPE IN 2, DO APPROPRIATE BOX

GBOX:	CAME 2,FLOATT
	JRST MKN		;INTEGER
MKFN:	SKIPN 2,FREEFL		;MAKE FLOATING NUMBER
	JRST MKF1		;NO SPACE
	EXCH 1,0(2)	;STORE NUMBER
	EXCH 1,FREEFL		;GET POINTER, UPDATE FREE
	AOS	FBOXCN		;UPDATE FLOATING BOX COUNT
	RET

MKF1:	PUSH NP,1
	MOVE 1,FLOATT
	CALL GC1
	POP NP,1
	JRST MKFN

;ALLOCATE AN ELEMENT OF A USER DATA TYPE
;TYPE NUMBER IN AC

NALLOC:	CAIL	1,MSYST+1+ASZ	;CHECK DATA TYPE NUMBER
	CAIL	1,MTYPN+ASZ
	ERROR1	41,NALLOC
	MOVEI	4,-ASZ(1)		;SAVE TYPE NUMBER
	ANDI	4,77
	SKIPN	2,TYPBLK(4)	;GET TYPE ENTRY
	ERROR1	41,NALLOC
	SKIPN	1,TFRE(2)	;FREE LIST EMPTY?
	JRST	GCUSER		;YES
	HRRZ	3,(1)		;GET ADDR OF NEXT POINT
	MOVEM	3,TFRE(2)	;AND STORE IT
	HLRZ	2,TSIZ(2)	;CLEAR THE ITEM!
	SETZM	0(1)		;CLEAR FIRST WORD
	CAIN	2,1		;ONLY 1 WORD?
	JRST	NALOC1		;YES
	HRLI	3,0(1)		;SET UP BLT WORD
	HRRI	3,1(1)
	ADDI	2,-1(1)		;STOPPING ADDRESS
	BLT	3,0(2)		;CLEAR THE REST OF THE ITEM
NALOC1:	RET

GCUSER:	MOVEI	1,0(4)
	CALL	GC1		;RECLAIM
	JRST	NALLOC+1

;DEFINE A USER DATA TYPE
;NWRDS IN 1
;NPTRS IN 2

DEFTYP:	CALL	IUNBOX		;UNBOX ARGS
	PUSH	NP,1
	HRRZ	1,-1(PP)
	CALL	IUNBOX
	MOVE	2,1
	POP	NP,3
	SETZM	1,DEFNUM
	MOVSI	1,377777
	MOVEM	1,DEFDIF
	SKIPLE	3		;NPTRS GR 0?
	SKIPGE	2		;YES, NWORDS NEGATIVE?
	ERROR0	43,DEFTYP	;YES
	LSH	3,1
	CAILE	2,0(3)		;WILL PTRS FIT IN NWRDS?
	ERROR0	43,DEFTYP	;NO
	LSH	3,-1
	MOVE	1,[XWD MSYST-MTYPN+1,MSYST+1]
DEFTP3:	SKIPN	4,TYPBLK(1)	;EMPTY?
	JRST	DEFTP2		;YES - USE IT!
	HLRZ	5,TYPSIZ(1)	;GET STATUS AND NUM OF PTRS.
	CAIN	5,1		;STILL IN USE?
	JRST	DEFTP4		;YES
	HRRZ	5,TYPSIZ(1)
	CAIE	2,0(5)		;STILL EQUIVALENT?
	JRST	DEFTP4		;NO
	HLRZ	5,TSIZ(4)	;GET NUMBER OF WORDS
	CAILE	3,0(5)		;FIT AS A SUBSET?
	JRST	DEFTP4		;NO
	CAML	3,DEFDIF	;BETTER FIT THAN BEFORE
	JRST	DEFTP4		;NO
	MOVEM	3,DEFDIF	;YES
	HRRZM	1,DEFNUM
DEFTP4:	AOBJN	1,DEFTP3	;TRY AGAIN
	SKIPN	1,DEFNUM	;NONE FREE - ANY RECLAIMED?
	ERROR0	42,NALLOC1	;NO - ERROR OUT
	HRRZ	2,TYPSIZ(1)	;SET STATUS FLAG
	HRLI	2,1
	MOVEM	2,TYPSIZ(1)
	JRST	MKN
DEFTP2:	MOVEI	1,0(1)
	PUSH	NP,1		;SAVE TYPE NUMBER
	HRLM	3,TUSER		;SO GC KNOWS SIZE
	HRLI	2,1		;SET STATUS
	MOVEM	2,TYPSIZ(1)	;SAVE SIZE INFO.
	MOVEI	2,(1)		;SET UP TO CALL GCTBS
	MOVEI	10,TUSER
	IMULI	1,NTWN
	MOVEI	7,USEBLK-<<MSYST+1>*NTWN>(1)
	MOVEM	7,TYPBLK(2)
	PUSHJ	GP,GCTBS	;SET THE TYPE TABLES
	POP	NP,1		;RETYRN TYPE NUMBER
	JRST	MKN

U DEFNUM
U DEFDIF


;GENERAL USER CONS

USRCNS:	SKIPN	1
	JRST	.+5		;NO ARGS
	MOVEI	6,0(1)		;SAVE NUMBER OF ARGS
	MOVEI	5,1(PP)
	SUBI	5,0(1)		;POINT TO ARGS
	HRRZ	1,(5)		;GET TYPE NUMBER
	CALL	NALLOC		;GET AN ITEM
	MOVE	10,[HRLM 3,(2)]	;SET UP STORING OPERATION
	HRRZ	2,(5)
	HRRZ	7,TYPSIZ-ASZ(2)	;GET NUMBER OF POINTERS
	MOVEI	2,0(1)
USRC1:	JUMPE	7,NALOC1	;EXIT IF ALL PTRS FILLED
	ADDI	5,1		;BUMP ARG PTR
	SUBI	6,1		;DEC NUMBER OF ARGS LEFT
	JUMPLE	6,USRC2		;RAN OUT OF ARGS?
	HRRZ	3,(5)		;NO
	JRST	.+2
USRC2:	MOVE	3,KNIL		;YES - USE NIL
	XCT	10		;STORE THE DATA
	TLC	10,44000	;FLIP BETWEEN HRLM AND HRRM
	TLNN	10,40000	;BACK TO HRLM?
	AOJ	2,		;YES - BUMP DATA PTR
	SOJA	7,USRC1		;DEC. NUMBER OF PTRS AND LOOP


;GET NUMBER OF POINTERS

GTNPTR:	CAIL	1,MSYST+1+ASZ	;CHECK DATA TYPE NUMBER
	CAIL	1,MTYPN+ASZ
	ERROR1	41,GTNPTR
	CALL	IUNBOX
	HRRZ	1,TYPSIZ(1)
	JRST	MKN


;GET NUMBER OF WORDS

GTNWRD:	CAIL	1,MSYST+1+ASZ	;CHECK DATA TYPE NUMBER
	CAIL	1,MTYPN+ASZ
	ERROR1	41,GTNWRD
	CALL	IUNBOX
	HRRZ	1,TYPBLK(1)
	HLRZ	1,TSIZ(1)
	JRST	MKN

;SET TYPE STATUS
;NIL = RETURN CURRENT STATUS
;0 = FREE TYPE
;1 = IN USE
;2 = A DEALOCATED TYPE

TYPSTS:	CAIL	1,MSYST+1+ASZ	;CHECK DATA TYPE NUMBER
	CAIL	1,MTYPN+ASZ
	ERROR1	41,TYPSTS
	CAMN	2,KNIL
	JRST	TYSTS1
	HRRZ	1,-1(PP)
	CALL	IUNBOX
	HRRZ	2,-2(PP)
	MOVE	3,TYPSIZ-ASZ(2)
	HRLM	1,TYPSIZ-ASZ(2)
	HLR	1,3
	JRST	MKN
TYSTS1:	HLRZ	1,TYPSIZ-ASZ(1)
	JRST	MKN

;DEFEVAL - DEFINE THE EVALUATION FUNCTION FOR A GIVEN DATA TYPE
;ARG1 = THE NUMBER OF THE DATA TYPE (CANNOT BE LIST, ATOM, OR NUMBER)
;ARG2 = T OR EVAL => ITEM EVALS TO ITSELF (THE INITIAL SETTING)
;     = NIL => DO NOT RESET THE EVALUATION FUNCTION
;     = A FUNC. NAME => ARG2 WILL BE CALLED WHEN THIS TYPE IS EVAL'ED
;RETURNS: NIL IF THE TYPE NUMBER IS ILLEGAL
;         THE PREVIOUS EVALUATION FUNCTION OR
;         T IF THE TYPE CURRENTLY EVALS TO ITSELF.

DEFEVA:	CALL	IUNBOX		;UNBOX THE TYPE NUMBER
	SKIPL	1		;VALID TYPE?
	CAIL	1,MTYPN
	JRST	DFEVA4		;NO
	SKIPGE	3,EVATAB(1)	;YES - CAN USER EVAL THIS TYPE?
	JRST	DFEVA4		;NO
	SKIPN	3		;YES - WAS EVALING TO SELF?
	MOVE	3,KT		;YES - RETURN T
	MOVE	2,-1(PP)	;NO - GET NEW EVAL FN.
	CAMN	2,KNIL		;CHANGING THE EVAL. FN?
	JRST	DFEVA2		;NO
	LDT	4,2		;YES - GET FN ARG TYPE
	CAMN	4,LISTT		;FN A LIST?
	JRST	[TLO 2,1	;YES - SET THE "EXPR" BIT
		 JRST DFEVA2-1]
	CAME	4,ATOMT		;NO - FN AN ATOM?
	JRST	DFEVA3		;NO - BAD ARG
	CAME	2,KT		;YES - FN=T OR EVAL?
	CAMN	2,KEVAL
	SETZ	2,		;YES - SET TO ZERO
	MOVEM	2,EVATAB(1)	;NO - SAVE THE NEW FN.
DFEVA2:	MOVEI	1,0(3)		;RETURN PREV. EVAL. FN.
	RET
DFEVA3:	SKIPA	1,2
DFEVA4:	MOVE	1,-2(PP)
	ERROR1	44,R

;ALLOCATE SPACE FOR ARRAY - ARG IS NUMBER OF WORDS

ALLOCA:	CALL IUNBOX
ALLOC1:	TLNN 1,-1
	CAIG 1,1
	JRST ALLOCE		;INSANE LENGTH
	MOVEI 2,0(1)
	ADD 1,FREEAR
	CAMG 1,ENDAR
	JRST ALLOC2
	MOVEI 1,0(2)		;WON'T FIT, MUST GC
	PUSHJ GP,ARRGC
	MOVEI 1,0(2)
	ADD 1,FREEAR
	CAMLE 1,ENDAR
	ERROR0 25,RESET		;STILL WONT FIT,GIVE UP
ALLOC2:	EXCH 1,FREEAR
	HRRZM 2,0(1)		;SET LENGTH
	SETZM 1(1)		;SET GC PTR AND PTR PTR TO 0
	MOVEI 3,0(1)		;CHECK FOR FIRST ARRAY THIS PAGE
	LSH 3,-LPS
	HRRZ 2,BTT(3)
	CAIN 2,0
	HRRM 1,BTT(3)		;YES, ENTER IN BTT
	RET

ALLOCE:	CALL MKN
	ERROR1 33,RESET

;ELT(ARRAY POSITION)

ELT:	SETOM 0(PP)
	SKIPA
ELTD:	SETZM 0(PP)
	STE 1,ARRAY
	ERROR1 34,RESET
	MOVEI 3,0(1)
	CALL FBA
	CAIE 1,0(3)
	ERROR1 34,RESET		;MUST BE ARRAY BEG.
	MOVE 1,-1(PP)		;POSITION
	CALL IUNBOX
	HRRZ 4,-2(PP)		;ARRAY POINTER
	HRRZ 3,1(4)
	MOVEI 2,0(1)
	ADDI 4,1(1)
	MOVE 1,0(4)
	CAILE 3,1(2)
	JRST MKN
	HRRZ 2,0(PP)
	TRNN 2,1
	HLRZ 1,1
	MOVEI 1,0(1)
	RET

;ARRAY(LENGTH,#UNBOXED,INIT)

ARRAY:	CALL IUNBOX
	ADDI 1,2
	CALL ALLOC1		;GET LENGTH+2 WORDS
	EXCH 1,-1(PP)
	CAMN 1,KNIL
	TRZN 1,-1		;NIL MEANS 0
	CALL IUNBOX
	ADDI 1,2
	MOVE 2,-1(PP)		;ARRAY POINTER
	HRRM 1,1(2)		;SET RELATIVE LOC. OF POINTERS
	CAML 1,0(2)
	JRST R2			;NO POINTERS TO INITIALIZE
	ADDI 1,1(2)
	HRLI 1,-1(1)
	HRRZ 3,0(PP)		;INIT VAL FOR POINTERS
	HRLI 3,0(3)
	MOVEM 3,-1(1)
	MOVEI 3,0(2)
	ADD 3,0(2)
	CAIE 3,0(1)		;EXACTLY ONE POINTER?
	BLT 1,-1(3)
	JRST R2

;PREDICATE

ARRAYP:	LDT 2,1
	CAME 2,ARRAYT
	JRST FALSE
	RET


;RELOCATE COMPILED CODE
;1 ADDRESS OF CODE, 2 INCREMENT

REL:	MOVE 1,2		;USER ENTRY
	CALL IUNBOX
	MOVE 2,1
	MOVE 1,-2(PP)

RELI:	HLRZ 3,0(1)		;INTERNAL ENTRY
	ADDI 3,0(1)		;ADDR OF RELOC BITS
	HRRZ 4,1(1)
	ADDI 1,0(4)
	MOVNI 4,-2(4)		;-LEN+2
	HRLI 1,4		;BEG+LEN(4)
REL3:	MOVEI 5,44		;36. BITS PER WORD
	MOVE 6,0(3)		;THE BITS
REL1:	JUMPE 6,REL4		;NO MORE RELOCATIONS THIS WORD
	TLNE 6,400000
	ADDM 2,@1		;RELOCATE
REL2:	LSH 6,1
REL5:	AOJGE 4,R
	SOJG 5,REL1
	AOJA 3,REL3

REL4:	ADDI 4,-1(5)
	MOVEI 5,0
	JRST REL5

;GET BLOCK OF UNMOVABLE STORAGE
;1 - NUMBER OF PAGES

GETBLK:	CALL IUNBOX
	PUSH NP,1
	JUMPLE 1,GETBE		;ERROR
	MOVEI 5,0(1)
	CALL MTPGS		;LOOK FOR EMPTY PAGES
	 JRST GETBE		;CANT FIND
	MOVEI 1,0(4)
	MOVN 2,0(NP)
	MOVEM 4,0(NP)
	HRLI 1,0(2)
	MOVE 3,BLOCKT
	CALL CLRPG
	MOVEM 3,TYPTAB(1)
	AOBJN 1,.-2
	POP NP,1
	LSH 1,LPS
	RET			;RETURN ADDRESS OF FIRST PAGE

GETBE:	HRRZ 1,-2(PP)
	ERROR1 35,RESET

;RELEASE A BLOCK 1 - ADDR OF BEGINNING, 2- NUMBER PAGES

RELBLK:	MOVEI 1,0(2)
	CALL IUNBOX
	JUMPLE 1,RELBE
	HRRZ 2,-2(PP)
	LSH 2,-LPS
	MOVNI 3,0(1)
	HRLI 2,0(3)
	PUSH NP,2
RELB1:	HRRZ 1,TYPTAB(2)		;CHECK THAT PGS REALLY BLOCK
	ANDI 1,77
	CAME 1,BLOCKT
	JRST GETBE		;NOT BLOCK - ERROR
	AOBJN 2,RELB1
	POP NP,2
	SETZM TYPTAB(2)
	AOBJN 2,.-1
	HRRZ 1,-2(PP)
	RET

RELBE:	HRRZ 1,-1(PP)
	ERROR1 35,RESET

;GET HASH - 1 PTR, 2 ARRAY

GETHSH:	STN 2,LIST		;SECOND ARG LIST
	CARA 2,2		;CAR IS THE ARRAY
	CAMN 2,KNIL
	HRRZ 2,@KSYSHSH		;NIL MEANS SYSTEM ARRAY
	EXCH 1,2
	CALL HSHLK
	 JRST FALSE
	RET

;PUT HASH - 1 PTR, 2 VALUE , 3 ARRAY

PUTHSH:	STN 3,LIST
	CARA 3,3
	CAMN 3,KNIL
	HRRZ 3,@KSYSHSH
	EXCH 1,3
	EXCH 2,3
	JUMPE 1,PUTH1
	STE 1,ARRAY
	ERROR1 34,RESET
PUTH1:	CAME 3,KNIL		;VALUE NIL MEANS REMOVE
	JRST HSHENT
REMHSH:	PUSH PP,1		;SAVE ARRAY USING
	CALL HSHLK
	JRST REMH1		;WASNT THERE
	MOVSI 1,1
	MOVEM 1,0(4)		;MARK DELETED
	ADDM 1,@0(PP)		;DECREASE (NEG) COUNT
REMH1:	SUB PP,BHC+1
	JRST FALSE

;CLEAR HASH ARRAY

CLRHSH:	STN 1,LIST
	CARA 1,1
	CAMN 1,KNIL
	HRRZ 1,@KSYSHSH
	JUMPN 1,.+2
	CALL HSHLKS
	STE 1,ARRAY
	ERROR1 34,RESET
	HRROS 2,0(1)		;CLEAR COUNT, GET LENGTH
	MOVEI 2,0(2)
	CAIL 2,3
	SETZM 2(1)
	CAIG 2,3
	JRST CLRHA			;NOTHING TO CLEAR
	HRLZI 3,2(1)
	HRRI 3,3(1)
	ADDI 2,-1(1)
	BLT 3,0(2)
CLRHA:	HRRZ 1,-2(PP)
	RET


;HASH LOOKUP AND ENTER - 1 ARRAY, 2 PTR TO TAG, 3 VALUE

HSHLK:	SETOM HENTO		;-1 FOR LOOKUP
	JRST HSHLK1

HSHENT:	SETZM HENTO		;POS. FOR STORING
HSHLK1:	PUSH PP,1		;ARRAY
	PUSH PP,3		;VALUE
	JUMPN 1,.+2
	CALL HSHLKS
HSHLK2:	MOVEI 7,0(2)		;SCRAMBLE PTR
	IMUL 7,HASHC		;SAVE 7 FOR REHASH
	MOVE 3,7
	HRRZ 6,0(1)		;ARRAY LENGTH
	IDIVI 3,-2(6)		;REL. ADDR TO PROBE IN 4
	MOVEI 3,775(6)		;DIVIDE INTO BUCKETS APPROX PAGE SIZE
	LSH 3,-LPS		;# BUCKETS
	MOVEI 5,-2(6)
	IDIVM 5,3		;3 HAS BUCKET SIZE
	MOVEI 5,0(4)
	IDIVI 5,0(3)
	ADDI 4,2(1)		;MAKE ADDR ABSOLUTE
	SUBM 4,6		;6 HAS BUCKET ORG
	MOVEI 5,0(3)		;5 COUNTS PROBES
HSH1:	HLRZ 1,0(4)
	CAIG 1,1
	JRST HSHLKE		;EMPTY SLOT
	CAIE 1,0(2)		;USED -  RIGHT ONE?
	JRST HSHAGN		; NO - TRY AGAIN
	SKIPGE 1,HENTO		;YES - STORING?
	JRST HSHRV		;NO - RETURN VALUE
	SKIPN 1			;YES - ANY SAAVED ADDR
	JRST HSH2		;NO - JUST STORE NEW VALUE
	HRLI 1,1		;YES : RECLAIM THIS ONE
	HLLZM 1,0(4)		; AND USE EARLIER ONE
	MOVEI 4,0(1)
HSH2:	MOVSI 2,0(2)
	HRR 2,0(PP)
	MOVEM 2,0(4)		;STORE PAIR
	MOVEI 1,0(2)
HSH3:	SUB PP,BHC+2
	RET

HSHRV:	HRRZ 1,0(4)
	AOS 0(CP)		;RETURN SKIPPING
	JRST HSH3

HSHLKS:	PUSH PP,2		;FIRST REF TO SYSTEM TABLE
	MOVEI 1,NPS
	CALL ALLOC1		;MAKE IT EXIST
	MOVEI 2,2
	MOVEM 2,1(1)
	HRRM 1,@KSYSHSH
	POP PP,2
	MOVEM 1,-1(PP)
	RET


HSHLKE:	JUMPE 1,HSHLKU		;UNUSED
	SKIPN HENTO		;RECLAIMED - STORING?
	HRRZM 4,HENTO		;YES - SAVE FIRST RECLAIMED SLOT SEEN
HSHAGN:	JUMPL 5,HSHHRD		;TRY HARDER
	SOJLE 5,HSHQ		;DONE NORMAL WAY?
	MUL 7,HASHC		;NO - REHASH
	ASHC 7,^D20
	MOVE 10,7
	IDIVI 10,0(3)
	MOVEI 4,0(11)
	ADDI 4,0(6)
	JRST HSH1

HSHLKU:	SKIPGE 1,HENTO		;EMPTY - STORING?
	JRST HSH3		;NO - RETURN BAD
	SKIPE 1
	MOVEI 4,0(1)
	MOVSI 1,-1		;COUNT NEW ENTRY
	ADDM 1,@-1(PP)
	JRST HSH2

HSHHRD:	AOBJP 5,HSH3		;LIN. SEARCH DONE TOO - RET BAD
HSH5:	MOVEI 4,0(5)
	JRST HSH1

HSHQ:	TRNN F,GCFLG
	SKIPGE HENTO
	JRST HSH4		;IN GC OR SEARCHING - TRY HARDER
HSHFUL:	HRRZ 3,-1(PP)		;ELSE ASSUME FULL
	HRRZ 4,@KSYSHS
	CAIE 3,0(4)		;SYSTEM TABLE?
	JRST HSHBAD
	PUSH PP,2
	HRRZ 1,0(3)		;LENGGGTH
	LSH 1,-1
	ADD 1,0(3)		;1.5 TIMES LENGTH
	MOVEI 1,0(1)
	CALL ALLOC1
	MOVEI 2,2
	MOVEM 2,1(1)
	MOVEI 2,0(1)
	EXCH 1,-2(PP)
	CALL UREHSH
	HRRZM 1,@KSYSHS
	POP PP,2
	JRST HSHLK2

HSH4:	MOVN 5,@-1(PP)		;SET UP FOR LINEAR SEARCH
	HRLI 5,2(5)
	HRR 5,-1(PP)
	ADDI 5,2
	JRST HSH5

HSHBAD:	HRRZ 1,-2(PP)
	ERROR1 32,.+1
	HRRM 1,-2(PP)		;RESET ORIG. ARG
	CARA 1,1		;ASSUME LIST ELSE DONT GET HERE
	HRRM 1,-1(PP)
	HRRZ 2,-4(PP)
	STE 1,ARRAY
	ERROR1 34,RESET
	JRST HSHLK2

;USER REHASH - 1 OLD ARRAY, 2 NEW ARRAY

UREHSH:	STN 1,LIST
	CARA 1,1
	STN 2,LIST
	CARA 2,2
	MOVEI 3,0(2)
	MOVEI 4,0(1)
	CALL REHSHS
	RET

REHSHS:	PUSH PP,3		;REHASH SUBROUTINE - 3 NEW ARRAY, 4 OLD
	HRRZS 0(3)		;CLEAR COUNT IN NEW
	MOVEI 2,3(3)
	HRLI 2,2(3)		;CLEAR NEW ARRAY
	SETZM 2(3)
	HRRZ 1,0(3)
	ADDI 1,-1(3)
	BLT 2,0(1)
	HRRZ 3,0(4)
	MOVNI 3,0(3)
	HRLI 4,0(3)
	ADD 4,BHC+2
REHS2:	HLRZ 2,0(4)
	CAIG 2,1		;USED?
	JRST REHS1
	HRRZ 3,0(4)		;YES - REHASH IT
	HRRZ 1,0(PP)
	PUSH PP,4
	CALL HSHENT
	POP PP,4
REHS1:	AOBJN 4,REHS2
	POP PP,1		;RETURRN NEW ARRAY
	RET


;EVALA (FORM , ALIST)

EVALA:	PUSH CP,PP		;SAVE PSTACK POSITION
EVALA1:	STE 2,LIST
	JRST EVALA2
	CARA 3,2
	STE 3,LIST
	JRST EVALAE
	MOVS 3,0(3)		;NAME,VALUE
	PUSH PP,3
	CDRA 2,2
	JRST EVALA1

EVALA2:	HRRZ 4,0(CP)		;REVERSE STACKED BINDINGS
	HRRZI 5,0(PP)
EVALA3:	ADDI 4,1
	CAIL 4,0(5)
	JRST EVALA4
	MOVE 2,0(4)
	EXCH 2,0(5)
	MOVEM 2,0(4)
	SOJA 5,EVALA3

EVALA4:	CALL EVAL		;EVAL FORM
	POP CP,PP		;FLUSH BINDINGS
	RET

EVALAE:	MOVEI 1,0(3)
	ERROR1 33,RESET

;MAKE A STRING OUT OF ANYTHING

MKSTR:	CALL STRTY		;GET TYPE
	CAMN 2,STPTT
	RET			;ALREADY IS STRING
MKSTR3:	CAMN 2,PNAMT
	JRST MKSTRP
	CALL MKSTRS		;SET UP TO STORE
	CALL IPSTR		;INTERNAL PRINT STRING
	JRST MKSP		;BOX STRING POINTER

MKSTRP:	HLLZ 2,0(1)		;PNAME-MAKE STRING POINTER TO IT
	TLZ 2,3777
	LSH 2,-^D8		;GET LENGTH
	IMULI 1,5		;ADDR X 5
	ADDI 1,1		;+ 1 CHAR
	IOR 1,2			;LENGTH
	JRST MKSP		;BOX

;STORE 1 CHARACTER OF STRING

MKSTR1:	SOSGE NFRECH
	JRST MKSTR2		;STRING STORAGE FULL
	IDPB 1,FREEST
	MOVSI 1,10
	ADDM 1,UNP1		;INCR LENGTH
	RET

MKSTR2:	HRLM 1,0(CP)		;SAVE CHAR
	MOVE 1,UNP1
	CALL STRGC		;GARBAGE COLLECT
	MOVEM 1,UNP1		;RETURNS UPDATED STRING POINTER
	HLRZ 1,0(CP)
	JRST MKSTR1

;SET UP TO STORE STRING

MKSTRS:	LDB 4,[POINT 6,FREEST,5]	;CONVERT BYTE PONTER TO STRPTR
	MOVEI 3,^D29
	SUB 3,4
	IDIVI 3,7		;CHAR NO. LAST CHAR. PREV. STRING
	HRRZ 4,FREEST
	IMULI 4,5
	ADDI 4,1(3)
	MOVEM 4,UNP1		;STRING POINTER
	RET


;STORE A STRING POINTER

MKSP:	SKIPN 2,FREESP
	JRST MKSP1
	EXCH 1,0(2)
	EXCH 1,FREESP		;UPDATE FREE
	RET

MKSP1:	CALL STPTGC
	JRST MKSP

;MAKE ATOM OUT OF STRING OR PRINT REP. OF ANYTHING

MKATOM:	CALL PACS
	CALL MKSTR		;MAKE STRING
	SBPC 3,1
	JUMPLE 4,MKATM		;NULL STRING
	ILDB 1,3
	CALL PAC
	SOJG 4,.-2
	JRST MKATM


;SUBSTRING (X N M)
;MAKE X A STRING IF IT ISNT ALREADY
;AND RETURN STRING OF CHARS N THRU M OF X
;IF M NIL ASSUME END OF X
;NIL IF X TOO SHORT

SUBSTR:	CALL STRTY		;GET TYPE
	CAME 2,STPTT		;STRING?
	JRST SUBST1
	MOVE 1,0(1)		;YES - MAKE NEW STRING PTR BOX
	CALL MKSP
	JRST .+2
SUBST1:	CALL MKSTR3		;OTHER TYPES, MAKE STRING
	HRRM 1,-2(PP)		;SAVE NEW STRING POINTER
	HRRZ 1,-1(PP)		;N
	CALL IUNBOX
	HRRZ 6,-2(PP)
	MOVE 6,0(6)
	LSH 6,-^D21		;ORIG LEN
	SKIPG 7,1		;N NEGATIVE?
	ADDI 7,1(6)		;YES - N_N+LEN+1
	JUMPLE 7,FALSE
	SUBI 7,1
	PUSH NP,6
	PUSH NP,7
	HRRZ 1,0(PP)		;M
	CAMN 1,KNIL
	SKIPA 1,6		;M NIL , USE LENGTH
	CALL IUNBOX
	POP NP,7
	POP NP,6
	JUMPG 1,.+2		;M NEGATIVE?
	ADDI 1,1(6)		;YES - M_M+LEN+1
	CAILE 1,0(6)
	JRST FALSE		;M GREATER LENGTH
	SUB 1,7		;M-N+1=NEW LENGTH
	JUMPLE 1,FALSE		;TOO SHORT
	HRRZ 2,-2(PP)
	DPB 1,SUBBP		;PUT IN LENGTH
SUBST2:	HRRZ 1,-2(PP)
	ADDM 7,0(1)		;ADD N-1 TO POS.
	RET

SUBBP:	POINT 14,0(2),14


;GET NEXT CHARACTER (X)
;MAKE X A STRING IF IT ISNT
;RETURNS NEXT CHARACTER OF STRING AND INCREMENTS STRING POINTER
;RETURNS NIL IF STRING IS EMPTY

GNC:	CALL MKSTR
	MOVE 4,0(1)
	USBPC 2,4
	ADD 4,[-7777777]	;LENGTH-1 AND CHAR. POS. + 1
	SOJL 3,FALSE		;RAN OFF END
	MOVEM 4,0(1)
	ILDB 1,2
MK1ATM:	CALL PACS		;RETURN ATOM
	CALL PAC		;*****MAKE 1 CHAR ATOMS SOON
	JRST MKATM

;GET LAST CHARACTER AND DECREMENT STRING POINTER

GLC:	CALL MKSTR
	MOVE 4,0(1)
	LSH 4,-^D21		;ORIG LENGTH
	JUMPLE 4,FALSE		;STRING EMPTY
	ADD 4,0(1)		;ADD LENGTH TO POINTER
	SUBI 4,1
	MOVE 3,[-10000000]
	ADDM 3,0(1)		;SUBTR. 1 FROM ORIG. LENGTH
	USBPC 2,4
	ILDB 1,2
	JRST MK1ATM

;CONCAT(X Y... Z)
;CONCATENATE (COPIES OF) ANY NUMBER OF STRINGS
;ARGS TRANSFORMED TO STRINGS IF ARENT ALREADY

CONCAT:	MOVNI 7,0(1)
	CALL MKSTRS		;SET UP TO STORE STRING
	JUMPE 7,CONCA1		;NO ARGS - RET NULL STRING
	MOVEI 6,1(PP)
	HRLI 6,7
	HRRZ 1,@6
	CALL CONC1		;STORE AT END OF STRING STORAGE
	AOJL 7,.-2
	JRST MKSP

CONCA1:	MOVE 1,UNP1
	JRST MKSP

CONC1:	CALL STRTY		;GET TYPE
	CAMN 2,STPTT
	JRST COPST1		;STRING - COPY IT
	CAMN 2,PNAMT
	JRST COPPN1		;PNAME - COPY
IPSTR:	CAMN 2,CHART		;ENTRY FROM MKSTR
	JRST CONCC
	MOVEI 2,MKSTR1		;OTHER TYPES USE INTERNAL PRINT
	CALL IPRE
CONC2:	MOVE 1,UNP1		;GET POINTER
	RET

CONCC:	SUBI 1,ACHAR		;CHAR - UNBOX
	CALL MKSTR1		;STORE IT
	JRST CONC2

COPSTR:	CALL MKSTRS		;SETUP
COPST1:	SBPC 2,1		;CONVERT TO BYTE PTR
COPST3:	JUMPLE 3,COPST4		;LENGTH 0 OR NEG. ?
	PUSH CP,2		;BYTE PTR TO STACK SO GC WILL UPDATE IT
COPST2:	ILDB 1,0(CP)		;COPY STRING
	CALL MKSTR1
	SOJG 3,COPST2
	POP CP,2
COPST4:	MOVE 1,UNP1		;RETURN UNBOXED STRING POINTER
	RET

COPPNM:	CALL MKSTRS		;PNAME - SETUP
COPPN1:	HRLI 1,440700		;MAKE BYTE POINTER
	ILDB 3,1		;GET LENGTH
	MOVE 2,1
	JRST COPST3		;AND COPY

STRTY:	LDT 2,1		;GET TYPE
	CAME 2,ATOMT		;ATOM?
	RET 			;NO - OK
	HLRZ 1,2(1)		;ATOM - GET TYPE OF PNAME
	JRST STRTY

;RPLSTR(STR1 N STR2)
;REPLACE STRING 1 BEGINNING AT CHARACTER N BY STRING 2
;CONVERTS ARGS TO STRINGS
;RETURNS STRING 1, WILL BE DIFFERENT IF WASNT STRING
;ERROR IF STRING 2 TOO LONG.... STRING1 MAY BE SMASHED

RPLSTR:	CALL STRTY		;GET TYPE
	CAMN 2,STPTT
	JRST RPLSTS
	CALL MKSTRS		;NOT STRING - SET UP TO MAKE ONE
	CAMN 2,PNAMT
	JRST RPLSTP
	CALL IPSTR		;INTERNAL PRINT
RPLST3:	CALL MKSP		;BOX STRING POINTER
	HRRM 1,-2(PP)		;SAVE NEW STRING POINTER
RPLST2:	HRRZ 1,0(PP)
	HRRZM 1,RPLARG
	HRRZ 1,-1(PP)		;N
	CAMN 1,KNIL
	SKIPA 1,[1]		;NIL MEANS 1
	CALL IUNBOX
	JUMPG 1,RPLST5
	HRRZ 2,-2(PP)		;N NEGATIVE
	MOVE 2,0(2)		;... GET LENGTH
	LSH 2,-^D21		;... OF STRING1
	ADDI 1,1(2)		;...AND ADD TO N+1
	JUMPLE 1,RPLERR
RPLST5:	SUBI 1,1
	IMUL 1,[-7777777]
	MOVE 2,-2(PP)
	ADD 1,0(2)		;PTR TO SUBSTR(STRING1 N)
	JUMPL 1,RPLERR		;STRING1 LESS N LONG
	USBPC 4,1
	HRRZ 1,0(PP)
	CALL STRTY
	CAMN 2,STPTT
	JRST RPLS1
	CAMN 2,PNAMT
	JRST RPLP1
	CAMN 2,CHART
	JRST RPLC1
	MOVEM 4,UNP1		;BYTE POINTER
	MOVEM 5,UNP2		;LENGTH REMAINING
	MOVEI 2,RPLST1
	CALL IPRE
RPLST4:	HRRZ 1,-2(PP)
	RET

RPLST1:	SOSGE UNP2		;SUBR CALLED FROM IPRE
	JRST RPLERR
	IDPB 1,UNP1
	RET

RPLSTS:	MOVE 2,0(1)		;FIRST ARG IS STRING
	TLZ 2,777770
	IDIVI 2,5		;CHECK LOC OF CHARACTERS
	LDT 2,2
	CAME 2,PNAMT
	JRST RPLST2
	CALL COPSTR		;IN PNAME SPACE - COPY
	MOVE 2,-2(PP)
	MOVEM 1,0(2)		;SMASH NEW POINTER INTO OLD SLOT
	JRST RPLST2

RPLSTP:	CALL COPPN1		;PNAME - COPY
	JRST RPLST3

RPLS1:	SBPC 2,1
RPLS3:	CAMLE 3,5
	JRST RPLERR
	JUMPE 3,RPLST4
RPLS2:	ILDB 1,2
	IDPB 1,4
	SOJG 3,RPLS2
	JRST RPLST4

RPLP1:	HRLI 1,440700		;SECONG ARG PNAME
	ILDB 3,1		;GET LENGTH
	MOVE 2,1
	JRST RPLS3

RPLC1:	JUMPE 5,RPLERR
	SUBI 1,ACHAR
	IDPB 1,4
	JRST RPLST4

RPLERR:	HRRZ 1,RPLARG
	ERROR1 33,RESET

U RPLARG





;I-O RELATED FUNCTIONS

RADIKS:	CAMN 1,KNIL
	JRST RDKS1
	CALL IUNBOX
	EXCH 1,URADIX
	TLZN F,PNEGF		;TEST CURRENT FLAG
	MOVN 1,1		;0 - RET NEG VAL
	MOVE 2,URADIX
	CAIL 2,0
	TLO F,PNEGF		;NEW VAL POS, SET FLAG 1
	MOVMM 2,URADIX
	MOVEM F,TFLGS
	JRST MKN

RDKS1:	MOVE 1,URADIX
	TLNN F,PNEGF
	MOVN 1,1
	JRST MKN

OPENP:	CAMN 1,KNIL
	JRST OPNLST
	CALL OPENP1		;SEARCH FOR INPUT OR OUTPUT FILE
	JRST FALSE		;FAILS
	RET

OPENP1:	CAMN 2,KNIL
	JRST FSCH		;ANY OPEN FILE
	CAMN 2,KOUTPUT
	JRST OPENP2
	CAMN 2,KINPUT
	CALL IFSCH
	JRST IOFSCH		;OPEN  FOR INPUT AND OUTPUT
	JRST RSKP

OPENP2:	MOVEI 2,0(1)
	CALL OFSCH		;LOOK FOR OUTPUT FILE
	JRST OPNP3		;NOT FOUND
	MOVEI 1,0(2)
	JRST RSKP
OPNP3:	MOVEI 1,0(2)		;TRY I/O
	JRST IOFSCH



;HACK JSYS FN - (JSYS JSYS# AC1 AC2 AC3 DESIRED-AC)
;IS LAMBDA NO SPREAD - SHOULD BE FIVE ARGS

UJSYS:	SUBI 1,5
	JUMPL 1,UJSYS2(1)	;TOO FEW ARGS
	SUB PP,BHC(1)
UJSYS1:	HRRZ 1,0(PP)		;DESIREED AC
	CAMN 1,KNIL
	SKIPA 1,[1]
	CALL IUNBOX
	PUSH NP,1
	HRRZ 1,-4(PP)
	CALL IUNBOX
	PUSH NP,1
	HRRZ 1,-2(PP)
	CAMN 1,KNIL
	SKIPA 1,[0]
	CALL IUNBOX
	PUSH NP,1
	HRRZ 1,-1(PP)
	CAMN 1,KNIL
	SKIPA 1,[0]
	CALL IUNBOX
	PUSH NP,1
	HRRZ 1,-3(PP)
	CAMN 1,KNIL
	SKIPA 1,[0]
	CALL IUNBOX
	POP NP,3
	POP NP,2
	POP NP,5
	JSYS 0(5)
	 JFCL
	 JFCL
	POP NP,4
	MOVE 1,0(4)
	JRST MKN

	PUSH PP,KNIL
	PUSH PP,KNIL
	PUSH PP,KNIL
	PUSH PP,KNIL
	PUSH PP,KNIL
UJSYS2:	JRST UJSYS1

NCHARS:	CAME 2,KNIL
	JRST NCHR4
	LDT 2,1			;GET ARG TYPE
	CAME 2,ATOMT		;ATOM?
	JRST NCHR1		;NOT ATOM
	HLRZ 1,2(1)
NCHR3:	CALL UPATM		;CONSTRUCT COUNT, POINTER
	MOVEI 1,0(4)		;RETURN COUNT
	JRST MKN

NCHR1:	CAMN 2,STPTT		;STRING?
	JRST NCHR3		;YES -EASY
	MOVEI 4,IPRE
NCHR5:	SETZM UNP1
	MOVEI 2,NCHR2		;SET UP INTERNAL PRINT
	CALL (4)
	MOVE 1,UNP1
	JRST MKN

NCHR4:	MOVEI 4,IPRE2
	JRST NCHR5

NCHR2:	AOS UNP1
	RET


POSITN:	MOVE 3,FP
	CAMN 1,KNIL		;NIL ARG?
	JRST POSN1		;YES, USE STND OUTPUT FILE
	CALL FSCH
	JRST ILLIF		;NO SUCH FILE
	TRNN 3,-1		;TTY IN?
	MOVEI 3,1		;YES, USE TTY OUT
POSN1:	HRRZ 1,-1(PP)
	CAMN 1,KNIL
	JRST POSN2
	PUSH NP,3
	CALL IUNBOX		;SECOND ARG GIVEN MEANS SET
	POP NP,3
	HRRM 1,CHPOS(3)
	HRRZ 1,-1(PP)
	RET

POSN2:	HRRZ 1,CHPOS(3)		;POSITION ON LINE
	JRST MKN

TERPRI:	MOVEI 2,0(1)
	CALL OFSET
	MOVEI 1,EOL		;PRINT EOL
	CALL PREC
	JRST FALSE

;PACK AND UNPACK

PACK:	CALL PACS		;INITIALIZE ATOM PACKER
PACK1:	CAMN 1,KNIL		;END OF LIST?
	JRST MKATM		;YES, CONSTRUCT ATOM AND RETURN
	PUSH PP,1		;NO, SAVE LIST
	CARA 1,1		;GET NEXT ELEMENT
	MOVEI 2,PAC
	CALL IPRE		;INTERNAL PRINT
	POP PP,1
	CDRA 1,1
	JRST PACK1

PACKC:	CALL PACS
PACKC1:	CAMN 1,KNIL
	JRST MKATM
	PUSH PP,1
	CARA 1,1
	CALL IUNBOX
	CALL PAC
	POP PP,1
	CDRA 1,1
	JRST PACKC1

UNPACK:	SETZM UNP1		;INITIALIZE LIST
	MOVEI 4,IPRE
	CAME 2,KNIL		;SECOND ARG NIL?
	MOVEI 4,IPRE2		;NO - USE INTERNAL PRIN2
	MOVEI 2,UNP		;INTERNAL SUBR FOR CHARS
	CALL (4)		;INTERNAL PRINT
UNP6:	SKIPG UNP1
	JRST FALSE		;NO CHARACTERS
	MOVE 1,UNP2
	RET

UNP:	CALL SAV27		;SAVE AC'S 2-7
	CALL PACS		;INITIALIZE ATOM PACKER
	CALL PAC		;PACK CHARACTER
	PUSH PP,UNP2
	CALL MKATM
	POP PP,UNP2
UNP5:	PUSH PP,UNP1		;GET LAST ON STACK IN CASE GC
	MOVE 2,UNP2
	CALL CONS
	HLRZ 2,0(1)
	MOVEM 2,UNP2		;SAVE LIST SO FAR
	MOVE 2,KNIL
	HRLM 2,0(1)		;RPLACD (NEW) LAST WITH NIL
	POP PP,2		;GET BACK OLD LAST
	JUMPE 2,UNP3		;NO LIST SO FAR
	HRLM 1,0(2)		;RPLACD LAST WITH NEW ELEMENT
UNP4:	MOVEM 1,UNP1		;BECOMES NEW LAST
	CALL RES27		;RESTORE AC'S 2-7
	RET

UNP3:	MOVEM 1,UNP2		;IS FIRST (WHOLE) OF LIST
	JRST UNP4

U UNP1
U UNP2

CHCON:	SETZM UNP1		;INITIALIZE LIST
	MOVEI 4,IPRE
	CAME 2,KNIL		;SECOND ARG NIL?
	MOVEI 4,IPRE2		;NO- USE INTERNAL PRIN2
	MOVEI 2,CHCN
	CALL (4)
	JRST UNP6

CHCN:	CALL SAV27		;INTERNAL SUBR FOR CHARS- CHCON
	ADDI 1,ASZ		;BOX
	JRST UNP5

CHCON1:	MOVEM CP,UNP2
	MOVEI 2,CHCN1
	CALL IPRE
	JRST FALSE

CHCN1:	ADDI 1,ASZ
	MOVE CP,UNP2
	RET

NTHCHR:	SUBI 1,4		;BECAUSE OF THE RDTBL ARG, NTHCHAR IS
	JUMPL 1,NTHC5(1)	;... IS NOW A *SUBR, IT WILL BE A
	SUB PP,BHC(1)		;... AGAIN IN SPAG.
NTHC6:	HRRZ 3,-1(PP)		;... FOR SIMPLICITY, THE STACK IS
	HRRZ 2,-2(PP)		;... ADJUSTED TO 4 ARGS AND 1-3 ARE
	HRRZ 1,-3(PP)		;... PRE-LOADED
	CAME 3,KNIL
	JRST NTHCH2
	LDT 3,1
	CAMN 3,STPTT
	JRST NTHC3
	CAME 3,ATOMT
	JRST NTHCHN
	HLRZ 1,2(1)
	HRRM 1,-3(PP)
NTHC3:	MOVEI 1,0(2)
	CALL IUNBOX
	MOVE 7,1
	HRRZ 1,-3(PP)
	CALL UPATM
	SKIPGE 7
	ADDI 7,1(4)
	JUMPLE 7,FALSE
	CAILE 7,0(4)
	JRST FALSE
	SUBI 7,1
	IDIVI 7,5
	ADDI 3,0(7)
	IBP 3
	SOJGE 10,.-1
NTHC1:	LDB 1,3
NTHC2:	CALL PACS
	CALL PAC
	JRST MKATM

NTHCH2:	MOVEI 3,IPRE2
	SKIPA
NTHCHN:	MOVEI 3,IPRE
	MOVEM 3,NTHCP
	MOVEI 1,0(2)
	CALL IUNBOX
	JUMPG 1,NTHC4
	PUSH NP,1
	HRRZ 1,-3(PP)
	SETZM UNP1		;NTHCHAR WITH NON-STRING OR ATOM
	MOVEI 2,NCHR2		;...AND NEG. COUNT
	HRRZ 3,0(PP)		;...AND READTABLE
	CALL @NTHCP		;...IS SLOW, BUT SERVES ONE RIGHT
	POP NP,1
	ADD 1,UNP1
	ADDI 1,1
	JUMPLE 1,FALSE
NTHC4:	MOVEM 1,UNP1
	MOVEM CP,UNP2
	HRRZ 1,-3(PP)		;GET ARG BACK
	MOVEI 2,NTHCC		;ROUTINE FOR INTERNAL PRINT
	HRRZ 3,0(PP)		;READTABLE ARG
	CALL @NTHCP		;INTERNAL PRINT
	JRST FALSE		;TOO FEW CHARACTERS

	PUSH PP,KNIL
	PUSH PP,KNIL
	PUSH PP,KNIL
	PUSH PP,KNIL
NTHC5:	JRST NTHC6

NTHCC:	SOSLE UNP1
	RET
	MOVE CP,UNP2		;RESTORE CP
	JRST NTHC2		;AND MAKE ATOM


CHRCT:	CALL IUNBOX		;CHARACTER, UNBOX NUMBER
	JRST NTHC2		;AND MAKE ATOM
U NTHCP

;DATE AND TIME FNS

IFN TEN50,<
DATE:	CALL PACS
	MOVEI 2,^D10		;SETUP SUBROUTINES
	MOVEM 2,APTR		;RADIX
	MOVEI 2,PAC		;CHARACTER SINK
	MOVEM 2,PREX
	CALLI 1,14		;DATE
	IDIVI 1,^D31*^D12
	PUSH CP,1		;SAVE YEAR
	MOVEI 1,0(2)
	IDIVI 1,^D31
	PUSH CP,2		;SAVE DAY
	ADDI 1,1
	CALL DATE1		;MONTH
	TCH "/"
	POP CP,1
	ADDI 1,1
	CALL DATE1		;DAY
	TCH "/"
	POP CP,1
	ADDI 1,^D64
	CALL DATE1		;YEAR
	TCH " "
	CALLI 1,23		;DAYTIME IN MILLISECONDS
	IDIVI 1,^D1000		;CONVERT TO SECONDS
	IDIVI 1,^D3600
	PUSH CP,2		;SAVE SECONDS THIS HOUR
	CALL DATE1		;HOUR
	POP CP,1
	IDIVI 1,^D60
	PUSH CP,2		;SAVE REMAINING SECONDS
	CALL DATE1		;MINUTES
	TCH ":"
	POP CP,1
	CALL DATE1		;SECONDS
	JRST MKATM

DATE1:	CAIGE 1,^D10		;ALWAYS PRINT TWO DIGITS
	TCH "0"			;LEADING ZERO
	JRST APT1
>


;SET FILE POINTER
IFE TEN50,<

SPTR:	CAMN 1,KNIL
	JRST SFPT5
	CALL FSCH
	ERROR1 15,RESET		;FILE NOT OPEN
	MOVEI FX,0(3)
	SKIPA
SFPT5:	MOVE FX,FR		;USE STANDARD INPUT FILE
	MOVEM FX,FRX
	HRRZ 1,FILEN(FX)
	RFPTR		;GET PRESENT FILE PTR
	JRST SFPT3
	HRRZ 3,FCHAR(FX)
	JUMPE 3,SFPT1
	SUBI 2,1
	CAIN 3,EOL
	SUBI 2,1
SFPT1:	PUSH NP,2
	HRRZ 1,-1(PP)
	CAMN 1,KNIL
	JRST SFPT2		;JUST RETURN PRESENT PTR
	CALL IUNBOX
	MOVE FX,FRX
	HLLZS CHPOS(FX)
	HLLZS FCHAR(FX)
	MOVE 2,1
	HRRZ 1,FILEN(FX)
	SFPTR
	JRST SFPT4
SFPT2:	POP NP,1
	JRST MKN

SFPT3:	HRRZ 1,-2(PP)
	ERROR1 33,RESET

SFPT4:	HRRZ 1,-1(PP)
	ERROR1 33,RESET
>

IFE TEN50,<
DATE:	CAMN 1,KNIL
	SKIPA 1,[0]
	CALL IUNBOX
	MOVE 3,1		;FLGS FOR WHICH DATE
	SETO 2,			;STANDARD FORMAT
	MOVE 1,IOFNMP
	ODTIM			;DATE AND TIME TO STRING
	PUSH NP,1
	CALL MKSTRS
	MOVE 10,IOFNMP
DATE1:	ILDB 1,10
	CALL MKSTR1
	CAME 10,0(NP)
	JRST DATE1
	POP NP,2
	MOVE 1,UNP1
	JRST MKSP
>

CLOCK:	CAMN 1,KNIL
	JRST CLK0
	CALL IUNBOX
	CAIG 1,3
	CAIGE 1,0
	JRST FALSE
	JRST .+1(1)
	JRST CLK0
	JRST CLK1
	JRST CLK2
	JRST CLK3

CLK0:	TIME			;TIME IN MS
	JRST MKN

CLK1:	MOVE 1,LOGTOD		;TIME OF STARTUP OF LISP
	JRST MKN

CLK2:	GETJRT			;RUNTIME THIS JOB
	SUB 1,LOGRT		;LESS GC AND STARTUP
	SUB 1,GCRT
	JRST MKN

CLK3:	MOVE 1,GCRT		;GC TIME
	JRST MKN


CLRBUF:	IFN TEN50,<
UCLRBF:	CLRTIB			;CLEAR TTY IN BUF
>
	IFE TEN50,<MOVEI FX,0
	JRST CLRBF1
UCLRBF:	CALL IFSET
	HRRZ 2,-1(PP)
	CAME 2,KNIL
	JUMPE FX,CLRBFS		;SECOND ARG NOT NIL AND FILE TTY
CLRBF1:	HRRZ 1,FILEN(FX)
	CFIBF
	JUMPN FX,FALSE
>
CLRBF3:	CALL CLRTTY
	JRST FALSE

IFE TEN50,<
CLRBFS:	MOVEI FX,0		;SAVE STUFF IN TTY BUFFERS
	HRRZ 1,FILEN(FX)
	SKIPG LNBFC
	SIBE
	JRST .+3
	HRRZ 1,FCHAR(FX)
	JUMPE 1,CLRBF3		;NOTHING TO SAVE - DONT CHANGE VALUES
	MOVE 1,SYSBFP
	MOVEM 1,CSYSBP
	MOVEI 1,CLRBFC
	CALL CLRBSS
	MOVE 1,SLNBFP
	MOVEM 1,CSLNBP
	HRRZ 1,FCHAR(FX)
	SKIPE 1
CLRBF6:	IDPB 1,CSLNBP
	SOSGE LNBFC
	JRST CLRBF3
	ILDB 1,LNBFP
	JRST CLRBF6

CLRBFC:	IDPB 1,CSYSBP
	RET
CLRBSS:	MOVEM 1,CLRBFI		;ROUTINE TO CALL FOR EACH CHAR
	HRRZ 1,FILEN(FX)
	RFMOD
	MOVEM 2,OLDMOD
	TRZ 2,6000		;SET TO NO ECHO
	TRO 2,1B23		;AND WAKEUP ON EVERUTHING
	SFMOD
	HRRZ 1,FILEN(FX)
	SIBE
	JRST CLRBF2
CLRBFO:	MOVE 2,OLDMOD
	SFMOD
	RET

CLRBF2:	MOVEM 2,CLRBFN
CLRBF4:	HRRZ 1,FILEN(FX)
	SOSGE CLRBFN
	JRST CLRBFO
	BIN
	MOVEI 1,0(2)
	CALL @ CLRBFI
	JRST CLRBF4

U CLRBFN
U CLRBFI
U OLDMOD

SYSBFP:	POINT 7,SYSBF,-1
U CSYSBP
U SYSBF,15		;BUFFER FOR SAVED SYSTEM BUFFER
SLNBFP:	POINT 7,SLNBF,-1
U CSLNBP

;MAKE STRING OUT OF SAVED SYSTEM AND LINE BUFFERS

LINBUF:	MOVE 6,CSLNBP
	MOVE 7,SLNBFP
	CAMN 1,KNIL
	JRST LINBF1		;ARG NIL MEANS CLEAR SAVED BUFFER
LINBF3:	CAMN 6,7
	JRST FALSE
	CALL MKSTRS
LINBF2:	ILDB 1,7
	CALL MKSTR1
	CAME 6,7
	JRST LINBF2
	MOVE 1,UNP1
	JRST MKSP

LINBF1:	MOVEM 7,CSLNBP
	RET

SYSBUF:	MOVE 6,CSYSBP
	MOVE 7,SYSBFP
	CAME 1,KNIL
	JRST LINBF3
	MOVEM 7,CSYSBP
	RET

;PUT STRINGS INTO VARIOUS TTY BUFFERS

BKSYSB:	CALL BKSET
BKSYS2:	JUMPLE 4,FALSE
	MOVEI FX,0
	HRRZ 1,FILEN(FX)
BKSYS1:	ILDB 2,3
	STI
	SOJG 4,BKSYS1
	HRRZ 1,-2(PP)		;OK - RET STRING
	RET
>		;END OF IFE TEN50

BKLNBF:	CALL BKSET
	JUMPLE 4,FALSE
	SKIPLE LNBFC
	JRST FALSE		;CANT DO IF BUFFER NOT EMPTY
	MOVEM 3,BKLNP
	MOVEM 4,BKLNC
	CALL GCHIB
	HRRZ 1,-2(PP)
	RET

BKCHAR:	SOSGE BKLNC		;GET CHAR FROM BACKED STRING FOR LNBF
	JRST .+3
	ILDB 1,BKLNP
	JRST RSKP
	TLZ F,BKFLG		;FINISH WITH CHARS FROM TTY
	RET			;RETURN NO SKIP

BKSET:	CALL STRTY
	CAMN 2,STPTT
	JRST BKSET1
	CAME 2,PNAMT
	JRST BKSET2
	MOVEI 3,0(1)
	HRLI 3,440700
	ILDB 4,3
	RET

BKSET1:	SBPC 3,1
	RET

BKSET2:	MOVNI 4,1
	RET
U BKLNP
U BKLNC




ESCP:	SETO 2,		;ARG T TURNS ON ESCAPE CHAR FOR READ
	CAMN 1,KNIL
	SETZ 2,		;ARG NIL TURN OFF
	EXCH 2,ESCONF
	JUMPE 2,FALSE		;WAS OFF - RET NIL
	JRST TRUE

RDMACS:	MOVEI	2,0
	CAME	1,KNIL
	SETO	2,
	EXCH	2,RMONF
	JUMPE	2,FALSE
	JRST	TRUE

LINLTH:	CAMN 1,KNIL
	SKIPA 1,LINSIZ
	CALL IUNBOX
	EXCH 1,LINSIZ
	JRST MKN

TRAPCT:	CAMN 1,KNIL
	SKIPA 1,TRPCNT
	CALL IUNBOX
	EXCH 1,TRPCNT
	JRST MKN

U TRPCNT

SETPLV:	CAMN 1,KNIL
	JRST SETPL1		;ARG NIL, RETURN CURRENT VAL
	CALL IUNBOX
	EXCH 1,PPLVL
	TLZE F,NEGPLF		;CHECK OLD FLAG
	MOVN 1,1		;SET - RETURN NEG VALUE
	MOVE 2,PPLVL
	JUMPGE 2,.+3
	TLO F,NEGPLF
	MOVMM 2,PPLVL
	MOVEM F,TFLGS
	JRST MKN

SETPL1:	MOVE 1,PPLVL
	TLNE F,NEGPLF
	MOVN 1,1
	JRST MKN

READP:	CALL IFSET
	JUMPN FX,READP1		;TTY?
	SKIPLE LNBFC
	JRST TRUE
READP1:	HRRZ 1,FCHAR(FX)
	CAMN 2,KNIL		;FLG=T TO IGNORE EOL CHECK
	CAIE 1,EOL		;IGNORE EOL IN CHAR BUFFER
	JUMPN 1,TRUE
	IFN TEN50,<SKIBNE		;SKIP IF TTY IN BUF NOT EMPTY
>
	IFE TEN50,<
	CAIN	FX,NFILES	;STRING?
	JRST	READP2		;YES
	HRRZ 1,FILEN(FX)	;NO - IT'S A REAL FILE
	SIBE
	SKIPA
>
	JRST FALSE
	JRST TRUE
READP2:	HRRZ	1,FILEA(FX)	;GET THE STRING
	MOVE	1,(1)		;GET THE STRING POINTER
	TLNE	1,777770	;TEST THE COUNT - ZERO?
	JRST	TRUE		;NO
	JRST	FALSE		;YES


;SET INTERRUPT CHARACTERS

IFE TEN50,<
SETINC:	CALL IUNBOX		;WHICH TABLE ENTRY
	CAIL 1,UCTCT-CTCT
	ERROR1 33,SETINC
	PUSH NP,1
	PIUNBX -1(PP)		;NEW CHAR CODE
	MOVE 2,1
	CALL OFFINT		;SHUT OFF INTERRUPT CHARS
	CALL	DISAB1
	POP NP,3
	HLRZ 1,CTCT(3)		;GET OLD CHAR
	HRLM 2,CTCT(3)
	PUSH NP,1
	CALL SETINT		;TURN INTERUPT CHARS BACK ON
	POP NP,1
	TRNN	1,400000	;WAS IT REALLY THERE?
	JRST MKN		;YES
	JRST FALSE		;NO

;DISABLE INTERRUPT CHARACTER

DISABL:	CALL	IUNBOX
	MOVEI	2,(1)
	CALL	OFFINT		;SHUT OFF INTERRUPT CHARS
	CALL	DISAB1
	PUSH	PP,1
	CALL	SETINT		;TURN INTERRUPT CHAR BACK ON
	POP	PP,1
	RET

DISAB1:	MOVE	4,CTCTP
	HLRZ	3,(4)
	TRZ	3,400000	;CLEAR ENABLED/DISABLED BIT
	CAIN	3,0(2)		;IS THIS THE CHARACTER?
	JRST	.+3		;YES
	AOBJN	4,.-4		;NO - TRY AGAIN
	JRST	FALSE		;NOT FOUND - RETURN NIL
	TROE	3,400000	;GOT IT, DISABLE IT
	JRST	FALSE		;ALREADY OFF
	SETO	3,
	HRLM	3,(4)
	HRRZI	1,ASZ(4)
	SUB	1,CTCTP
	TLZ	1,-1
	CAML	4,UCTCTP	;IS IT A USER SLOT?
	HRRZ	1,KT		;YES
	RET


; ENABLE INTERRUPT CHARS

ENABLE:	SETZM	FREICH
	CAIG	1,ASZ+^D30	;LEGAL CHAR?
	CAIGE	1,ASZ
	ERROR1	33,ENABLE	;NO
	MOVEI	2,-ASZ(1)
	CALL	OFFINT		;TURN OFF INTERRUPT CHARS
	CALL	DISAB1		;DISABLE IT
	PUSH	PP,1
	HRRZ	3,-2(PP)	;2ND ARG
	CAIN	3,ASZ
	JRST	ENABL4
	MOVE	4,UCTCTP
ENABL2:	HLRZ	1,0(4)		;GET ENTRY
	TRNN	1,400000	;EMPTY SLOT?
	AOBJN	4,ENABL2	;NO - TRY AGAIN
	SKIPL	4		;GOT A FREE SLOT?
	ERROR0	54,R		;NO
	MOVE	1,(4)		;YES - NOW ENABLE THE CHAR
	HRL	1,2
	TRZ	1,400000
	CAME	3,KNIL		;IS IT A HARD INTERRUPT
	TRO	1,400000
	MOVEM	1,(4)
ENABL3:	CALL	SETINT		;TURN INTERRUPT CHARS BACK ON
	POP	PP,1
	RET
ENABL4:	CAME	1,KNIL		;IS IT ENABLED?
	HRLM	2,(4)		;YES
	JRST	ENABL3

U FREICH
>

;GET/SET BRK/SEPR/PRT

SETBRK:	MOVEI	6,SBBITS
	JRST	SETBSS

SETSEP:	MOVEI	6,SSBITS
	JRST	SETBSS

SETBR1:	MOVE	4,[Z ORGRDT+2+RDNUBW(1)]
	CAME	5,SYSRT2	;ARE WE RESETTING SYSTEM TABLE?
	MOVE 4,SYSRT2		;NO, RESET FROM SYSTEM RATHER THAN ORIG.
	MOVEI	1,177
SETBR2:	MOVE	2,@4
	MOVE	3,@5
	TDNN	2,1(6)		;IS BIT SET IN ORIGINAL?
	JRST	.+4		;NO
	TDNN 3,1(6)		;YES - IS BIT ALREADY SET?
	HLL 3,0(6)		;NO - MAKE IT A BREAKCHAR OR A SEPRCHAR
	JRST .+3		;YES - DO NOTHING
	TDNE 3,1(6)		;IS BIT ALREADY SET (IT'S NOT IN ORIG)
	HRLI 3,0		;YES, MAKE IT A REGULAR LETTER
	MOVEM	3,@5
	SOJGE	1,SETBR2
	JRST	FALSE

SETBSS:	MOVEI	5,(1)
	MOVEI 1,(3)
	CALL GETRDT
	EXCH 1,5
	ADD 5,[Z 2+RDNUBW(1)]
	CAMN 1,KT
	JRST SETBR1
	CAMN 1,KNIL
	JRST STBS1A
	LDT	7,1
	CAME	7,LISTT		;IS FIRST ARG A LIST?
	ERROR1 33,R
STBS1A:	MOVEI	7,0(2)
	CAMN	7,KNIL
	JRST	SETBS7
SETBS3:	CAMN 1,KNIL		;MORE CHARS?
	JRST	STBS10
	PUSH PP,1
	CARA 1,1		;NEXT CHAR
	LDT 2,1
	CAMN 2,SMALLT		;NUMBER?
	JRST SETBS1		;YES, IS CHARACTER CODE
	CAMN 2,STPTT
	JRST SETBS6
	CAME 2,ATOMT
	JRST ARGNA
	HLRZ 1,2(1)
SETBS6:	CALL UPATM
	ILDB 1,3
SETBS2:	MOVE	2,@5
	CAMN	7,KNIL		;SET?
	JRST	SETBS9		;YES
	CAIE	7,ASZ		;NO - CLEAR IT?
	JRST	SETBS8		;NO - ADD
	SETZM	@5		;YES - MAKE IT A REGULAR LETTER
	JRST SETBS5
SETBS8:	TDNE 2,1(6)		;ADD - IS BIT ALREADY SET?
	JRST SETBS5		;YES - DO NOTHING
	MOVE 2,0(6)		;NO - SET TO BREAKCHAR OR SEPRHAR
	HLLM 2,@5
SETBS5:	POP PP,1
	CDRA 1,1		;REST OF LIST
	JRST SETBS3

SETBS1:	MOVEI 1,-ASZ(1)
	JRST SETBS2

SETBS7:	SETZM	TMPBLK
	SETZM	TMPBLK+1
	SETZM	TMPBLK+2
	SETZM	TMPBLK+3
	JRST	SETBS3

SETBS9:	IDIVI	1,40
	MOVNI	2,(2)
	MOVSI	4,400000
	ROT	4,(2)
	IORM	4,TMPBLK(1)
	JRST	SETBS5

STBS10:	CAME	7,KNIL		;SET?
	JRST	FALSE		;NO
	MOVEI	1,177		;YES
STBS11:	MOVEI	3,(1)
	IDIVI	3,40
	MOVNI	4,(4)
	MOVSI	2,400000
	ROT	2,(4)
	MOVE	3,TMPBLK(3)
	TDNE	3,2
	JRST	STBS12
	MOVE	2,@5
	TDNN	2,1(6)
	JRST	STBS13
	SETZ 2,
	JRST	STBS14

STBS12:	MOVE	2,@5
	TDNN	2,1(6)
	SKIPA 2,0(6)
STBS14:	CAME	2,@5		;SO A PAGE WON'T GET UNSHARED
	HLLM	2,@5
STBS13:	SOJGE	1,STBS11
	JRST	FALSE

SBBITS:	XWD	BRKBIT+PRTBIT,0
	XWD	BRKBIT,0

SSBITS:	XWD	SEPBIT+PRTBIT,0
	XWD	SEPBIT,0

SPBITS:	XWD	PRTBIT,0
	XWD	PRTBIT,0

U TMPBLK,4

GETBRK:	MOVSI	6,BRKBIT
	JRST	GETBSS

GETSEP:	MOVSI	6,SEPBIT
GETBSS:	MOVEI 2,(1)		;SELECT WHICH READTABLE
	CALL IRTSET
	MOVEI	1,177		;CONSTRUCT LIST OF CHARACTER CODES
	PUSH	PP,KNIL		;INIT LIST
GETBS2:	MOVE	3,@BSTAB	;GET A CHARACTER ENTRY
	TDNN	3,6		;IS THE BIT SET?
	JRST	GETBS1		;NO
	MOVEI	2,0(1)		;YES, CONS ITS CODE ONTO LIST
	CALL SAV27
	MOVEI 1,ASZ(2)		;MAKE CHAR INTO (SMALL) NUMBER
	MOVE 2,0(PP)		;LIST
	CALL CONS
	MOVEM 1,0(PP)
	CALL RES27		;RESTORE AC'S 2-7
	MOVEI	1,0(2)
GETBS1:	SOJGE	1,GETBS2
	POP PP,1
	RET

; READTABLE CONSTANTS AND FLAGS

BRKBIT==200
SEPBIT==100
PRTBIT==40
STRBIT==20
ESCBIT==10

RDTMSK==350
JPBITS==7

RDNUBW==0		;NUMBER OF UNBOXED WORDS IN A READTABLE
RTSIZE==200+RDNUBW	;SIZE OF A READTABLE ARRAY

JMPFLD:	POINT 3,@BSTAB,17

; THE ORIGINAL SYSTEM READTABLE

ORGRDT:
BLOCK 2			;DUMMY HEADER
REPEAT 9,<0>		;NULL-^H
SEPBIT+PRTBIT,,0	;TAB
SEPBIT+PRTBIT,,0	;LF
0			;^K
SEPBIT+PRTBIT,,0	;^L
SEPBIT+PRTBIT,,0	;CR
REPEAT 21,<0>	;^N-RS
SEPBIT+PRTBIT,,0;	EOL
SEPBIT+PRTBIT,,0	;SPACE
0			;!
BRKBIT+STRBIT+PRTBIT,,0;"
0			;#
0			;$
ESCBIT+PRTBIT,,0	;%
0			;&
0			;'
BRKBIT+PRTBIT+3,,0	;(
BRKBIT+PRTBIT+4,,0	;)
REPEAT <"Z"-"*"+1>,<0>;* - Z
BRKBIT+PRTBIT+2,,0	;[
0			;\
BRKBIT+PRTBIT+1,,0	;]
REPEAT <200-"^">,<0>	;^ - RUBOUT


;TERMINALTABLE CONSTANTS

TTYSIZ==^D16		;SIZE OF TERMINAL TABLE
CTLA==2
CTLQ==3
CTLR==4
CTLV==5
CTLEOL==6
CCOCW1==7
CCOCW2==10
CTQMSG==11
CAMSG1==12		;FIRST ^A MESSAGE
CAMSG2==13		;NTH ^A MESSAGE
CAMSGP==14		;POST ^A MESSAGE
CAMSGE==15		;EMPTY BUFFER ^A MESSAGE
ECHFLG==16		;NO ECHO DELETED ^A FLAG
LBFLGW==17		;NO LINE BUFFERING FLAG WORD
ECHMDW==20		;ECHO MODE WORD
RASMOD==21		;RAISE MODE WORD

;ORIGINAL SYSTEM TERMINAL TABLE
;
ORGTTY:
BLOCK 2
"A"-100		;CHAR DELETE
"Q"-100		;LINE DELETE
"R"-100		;RETYPE
"V"-100		;CONTROL V
37		;EOL
BYTE (2) 0,0,1,1,1,1,1,2,1,3,2,1,1,2,1,1,1,0
BYTE (2) 0,1,1,1,1,1,1,1,1,3,1,1,1,2
ASCIZ/##
/			;^Q MESSAGE
ASCIZ/\/		;^A MESSAGES
0
ASCIZ/\/
ASCIZ/##
/
0			;NO ECHO DELETE ^A FLAG
0			;NO LINE BUFFERING FLAG
1			;ECHO MODE
-1			;RAISE MODE, = IS 0, < IS NIL, > IS T

; SETREADTABLE(RDTBL,TBLFLG)

SETRDT:	CALL GETRDT
	CAMN 2,KNIL		;SETTING CURRENT TABLE?
	 JRST .+3		;YES
	MOVEI 3,SYSRDT		;NO
	CAIA
	MOVEI 3,CURRDT
	EXCH	1,(3)		;SET READTABLE
	MOVEI	2,CURRT2	;SET PRT TO CHAR. DATA
	CAIE	3,CURRDT
	MOVEI	2,SYSRT2
	MOVE	3,(3)
	ADD	3,[Z 2+RDNUBW(1)]
	MOVEM	3,(2)
	RET

; GETREADTABLE(RDTBL)
GETRDT:	CAME 1,KNIL		;IS SOURCE THECURRENT TABLE
	 JRST .+3		;NO
	MOVE 1,CURRDT		;YES
	RET
	CAME 1,KT		;IS SOURCE THE SYSTEM TABLE?
	 JRST .+3		;NO
	MOVE 1,SYSRDT		;YES
	RET
	CALL CKRDTS		;IS IT A READTABLE?
	ERROR1	46,R		;NO
	RET

; COPYREADTABLE(RDTBL)
CPYRDT:	CAMN 1,KORIG
	JRST .+3
	CALL GETRDT
	CAIA
	MOVEI 1,ORGRDT
	PUSH	PP,1
	CALL	RTALOC
	POP	PP,2
	JRST RTCPY

RTALOC:	MOVEI	1,ASZ+RTSIZE	;ALLOCATE A READTABLE
	PUSH	PP,[ASZ+RDNUBW]
	PUSH	PP,[0]
	CALL	ARRAY
	SUB	PP,BHC+2
	RET

RTCPY:	PUSH	PP,1		;COPY A READTABLE
	HRL	1,2		;BUILD BLT DATA
	ADD	1,BHC+2
	MOVEI	4,RTSIZE-1(1)
	BLT	1,(4)		;COPY
	POP	PP,1
	CAIE 2,ORGRDT
	RET
	MOVE	3,KNIL		;FILL OUT FNS WITH NIL
	MOVEI 2,(1)
	ADD	2,[-200,,RDNUBW+2]
	HRRM	3,(2)
	AOBJN	2,.-1
	RET

; RESETREADTABLE(RDTBL,reset/RDTBL)
RSTRDT:	CALL GETRDT
	EXCH 1,2
	CAMN 1,KORIG
	JRST .+3
	CALL GETRDT
	CAIA
	MOVEI 1,ORGRDT
	EXCH 1,2
	CALL RTCPY
	RET

; READTABLEP(RDTBL)
RDTBLP:	CALL	CKRDTS		;USER ENTRY FOR READTABLEP
	JRST	FALSE
	RET

CKRDTS:	LDT	4,1		;SKIP RETURN IF A READTABLE
	CAME	4,ARRAYT		;ARRAY?
	RET			;NO
	HRRZ	4,(1)		;YES - RIGHT LENGTH?
	CAIE	4,RTSIZE+2
	RET			;NO
	HRRZ	4,1(1)		;YES - CORRECT NUMBER OF UNBOXED WORDS?
	CAIN	4,RDNUBW+2
	AOS	(CP)		;YES
	RET			;NO

; SET INPUT READTABLE FROM AC 2, ACS 1 AND 4 ARE CHANGED
IRTSET:	MOVE 1,CURRT2
	CAMN 2,KNIL		;CURRENT TABLE?
	 JRST IRTST1		;YES
	MOVE 1,SYSRT2		;NO
	CAMN 2,KT		;SYSTEM TABLE?
	 JRST IRTST1		;YES
	MOVEI 1,(2)		;NO
	CAMN 1,PRVIRT		;SAME TABLE AS LAST TIME?
	 JRST IRTST1-1		;YES
	CALL CKRDTS		;IS IT A READTABLE?
	ERROR1 46,R		;NO
	MOVEM 1,PRVIRT		;YES, SAVE FOR NEXT TIME
	ADD 1,[Z RDNUBW+2(1)]	;CONVERT TO INTERNAL USABLE FORM
IRTST1:	MOVEM 1,BSTAB		;STORE IT
	RET

; SET OUTPUT READTABLE FROM AC 3, ONLY AC 2 IS CHANGED

ORTSET:	MOVE 2,CURRT2
	CAMN 3,KNIL		;CURRENT TABLE?
	 JRST ORTST1		;YES
	MOVE 2,SYSRT2		;NO
	CAMN 3,KT		;SYSTEM TABLE?
	 JRST ORTST1		;YES
	CAMN 3,PRVORT		;SAME TABLE AS LAST TIME?
	 JRST ORTST2		;YES
	PUSH	PP,1		;NO
	PUSH PP,4
	MOVEI 1,(3)
	CALL CKRDTS		;IS IT A READTABLE?
	ERROR1 46,R		;NO
	MOVEM 1,PRVORT
	ADD 1,[Z RDNUBW+2(1)]	;YES, CONVERT TO INTERNAL USABLE FORM
	MOVE 2,1
	POP PP,4
	POP	PP,1
ORTST1:	MOVEM 2,PBTAB		;STORE IT
	RET
ORTST2:	ADD 3,[Z RDNUBW+2(1)]
	MOVEM 3,PBTAB
	RET


;TERMINALTABLE(TABLE)
TRMTBL:	CAME 1,KNIL		;IS IT NIL?
	JRST	.+3		;NO
GTTY2:	HRRZ 1,TTYTBL		;YES - RETURN CURRENT TABLE
	RET
	CALL CKTRMT		;NO - MAKE SURE IT IS VALID
	ERROR1 55,TRMTBL
	EXCH 1,TTYTBL		;SET NEW TABLE
TTCP2:	PUSH	PP,1
	CALL SETMOD		;RESET MODES
	POP PP,1		;RETURN OLD VALUE
	RET

CKTRMT:	LDT 4,1		;SKIP RETURN IF A TERMINAL TABLE
	CAME 4,ARRAYT	;ARRAY?
	RET		;NO
	HRRZ 4,(1)		;RIGHT LENGTH?
	CAIE 4,TTYSIZ+2
	RET			;NO
	HRRZ 4,1(1)		;YES - ARE THEY ALL UNBOXED?
	CAIN 4,TTYSIZ+2
	AOS (CP)		;YES
	RET			;NO

; COPYTERMTABLE(TABLE)
CPYTT:	CAMN 1,KORIG
	JRST	.+3
	CALL GETTY
	CAIA
	MOVEI 1,ORGTTY
	PUSH	PP,1
	CALL TTALOC
	POP PP,2
	JRST TTCPY

; GETTERMTABLE(TABLE)
GETTY:	CAMN 1,KNIL
	JRST GTTY2
	CALL CKTRMT
	ERROR1 55,TRMTBL
	RET

; RETSETERMTABLE(TABLE,orig/TABLE)
RSTTBL:	CALL GETTY
	EXCH 1,2
	CAMN 1,KORIG
	JRST .+3
	CALL GETTY
	CAIA
	MOVEI 1,ORGTTY
	EXCH 1,2
	JRST TTCPY

TTALOC:	MOVEI 1,ASZ+TTYSIZ	;ALLOCATE A TERMINAL TABLE
	PUSH PP,1
	PUSH PP,[0]
	CALL ARRAY
	SUB PP,BHC+2
	RET

TTCPY:	PUSH PP,1		;COPY A TERM TABLE
	HRL 1,2
	ADD 1,BHC+2
	MOVEI 4,TTYSIZ-1(1)
	BLT 1,(4)
	POP PP,1
	CAMN 1,TTYTBL
	JRST TTCP2
	RET

;TERMTABLEP(TABLE)
TTTBLP:	CALL CKTRMT
	JRST FALSE
	RET

;READ

READX:	MOVE 1,KT		;EVALQUOTE READ
	HRRZ 2,KT
	HRRZ 3,KNIL
READ:	TLZ F,NCRFLG
	CAME 3,KNIL
	TLO F,NCRFLG
	CALL IFSET
	CALL	IRTSET
	TRNE	F,RMFLG		;READ BLIP?
	JRST	RD9		;YES
XREAD:	MOVSI 1,-1		;TOP LEVEL FLAG
	JRST XRD1

RD9:	TRZ	F,RMFLG+RDMFLG	;CLEAR FLAGS
	MOVEI	1,READ		;LOOK FOR READ BLIP
	CALL	PPLOOK
	JRST	XREAD		;NOT FOUND
	HRRZ	1,(1)		;GET VALUE OF BLIP
	SKIPE	1		;BLIP VALUE 0?
	TRO	F,RDMFLG	;NO - SET FLAGS
	TRO	F,RMFLG
	JRST	XREAD

;READ TO RIGHT BRACKET

X2READ:	CALL X1READ		;READ TO TERMINATOR
XRR:	HRRZ 2,FCHAR(FX)	;CHECK TERMINATOR
	ADD	2,BSTAB
	HLRZ	2,(2)
	ANDI	2,JPBITS
	CAIN 2,1		;WAS RIGHT BRACKET?
	HLLZS FCHAR(FX)		;YES, CLEAR
	RET

;READ TO TERMINATOR

X1READ:	MOVEI 1,0
XRD1:	PUSH PP,1		;FLAG,,DOTTED PAIR POINTER
	PUSH PP,BHC		;WHOLE LIST,,LAST OF LIST
	PUSH CP,XRR1
RD1:	CALL RDA		;READ ATOM OR BREAK CHAR
	JRST RD5		;NOT BREAK CHAR
	LDB	3,JMPFLD	;JUMP ON BREAK CHAR. TYPE
	JRST	@RDJTAB(3)
RDJTAB:	RDS			;SELF-DELIMITING CHAR.
	RDRB			;]
	RDLB			;[
	RDL			;(
	RDR			;)
	RDMAC			;ELEMENT READ MACRO
	RDMAC			;SPLICE READ MACRO
	RDMAC			;INFIX READ MACRO

RDMAC:	SKIPN	RMONF
	JRST	RDBQ2		;NO-READMACROS, JUST A NUMBER
	PUSH	NP,3		;SAVE STATE OF READ
	PUSH	NP,FX
	PUSH	NP,F
	PUSH	PP,BSTAB	;SAVE CURRENT READTABLE
	PUSH	PP,[READ,,1]	;PUT READ BLIP ON STACK
	TRO	F,RMFLG		;SET BLIP FLAG
	TRZ	F,RDMFLG	;TURN OFF READMACRO FLAG
	HRLM	1,FILEA(FX)
	HRRZ	1,@BSTAB
	PUSH	PP,1
	HRRZ	1,FILEA(FX)
	PUSH	PP,1		;THE FILE NAME IS 1ST ARG
	HRRZ	1,BSTAB		;READTABLE IS 2ND ARG
	SUBI	1,RDNUBW+2
	PUSH	PP,1
	MOVEI	1,3
	CAIE	3,7		;IS IT AN INFIX MACRO?
	JRST	RDMAC2		;NO
	HLRZ	1,-5(PP)	;YES - BUILD A TCONC LIST
	SKIPN	1
	MOVE	1,KNIL
	HRRZ	2,-5(PP)
	SKIPN	2
	MOVE	2,KNIL
	CALL	CONS
	PUSH	PP,1
	MOVEI	1,4
RDMAC2:	MOVE	2,KAPP.
	CALL	EFNCAL		;CALL THE USER'S FUNCTION
	HLLZ 2,F		;GET LBFFLG AND RASFLG BIGS
	TLZ 2,-1-LBFFLG-RASFLG
	POP NP,F		;GET OLD FLAG BITS
	TLZ F,LBFFLG+RASFLG	;PUT IN CURRENT LINBUF AND RASFLG
	IOR F,2
	POP	NP,FX
	POP	NP,3
	SUB	PP,BHC+1	;REMOVE READ BLIP
	POP	PP,BSTAB	;RESTORE READTABLE
	JRST	@RDJMP-5(3)

RDJMP:	RDL2			;ELEMENT READMACRO
	RDSMAC			;SPLICE READMACRO
	RDINFX			;INFIX READMACRO


;SPLICE MACRO
RDSMAC:	HRRZ	2,0(PP)		;LCONC RESULT INTO LIST
	JUMPE	2,RDSM2		;WAS NONE
	HRLM	1,0(2)		;SMASH IN RESULT
RDSM3:	CDRA	1,2		;GET TAIL
	CAMN	1,KNIL		;NULL>
	JRST	RDSM4		;YES
	LDT	3,1		;NO - IS IT A LIST
	CAME	3,LISTT
	JRST	RDSM5		;NO
	MOVEI	2,0(1)		;YES - STEP TO NEXT WORD
	JRST	RDSM3

RDSM4:	HRRM	2,0(PP)		;SAVE THE LAST
	JRST	RD1		;AND CONTINUE READING

RDSM2:	LDT	3,1		;NOTHING BUILT YET - RESULT A LIST?
	CAME	3,LISTT
	JRST	RD1		;NO
	HRLM	1,0(PP)		;YES - SET UP WHOLE LIST
	MOVEI	2,0(1)
	JRST	RDSM3		;AND GO FIND THE TAIL

RDSM5:	HRRM	2,-1(PP)	;MAKE IT LOOK LIKE IT WAS READ
	MOVE	2,KNIL
	CALL	CONS
	HRRM	1,0(PP)		;THIS IS THE NEW TAIL
	MOVEI	2,0(1)
	MOVE	1,KPER
	CALL	CONS
	HRRZ	2,-1(PP)
	HRLM	1,(2)		;ATTACH IT INTO TAIL
	JRST	RD1		;AND CONTINUE READING

;INFIX MACRO
RDINFX:	SETZM	0(PP)
	LDT	2,1		;IS RESULT A LIST?
	CAME	2,LISTT
	JRST	RD1		;NO - EMPTY TCONC PAIR, IGNORE
	CDRA	2,1		;YES - THIS BECOMES NEW LIST
	SETZM	0(PP)
	CAMN	2,KNIL		;RESULT A NIL LIST?
	JRST	RD1		;YES
	HRRM	2,0(PP)
	CARA	2,1
	HRLM	2,0(PP)
	JRST	RD1

RDBQ2:	HRLM 1,FILEA(FX)	;SAVE LAST CHAR
	CALL PAC		;SELF-DELIMITING CHARACTER
	CALL MKATM		;CONVERT TO ATOM
RD2:	SKIPGE -1(PP)		;TOP LEVEL?
	RET			;YES, RETURN SINGLE S-EXP
RD7:	MOVE 2,KNIL		;NO, NCONC TO ACCUMULATED LIST
	CALL CONS
	HRRZ 2,0(PP)		;LAST OF LIST
	JUMPE 2,RD4		;WAS NONE
	HRLM 1,0(2)		;RPLACD LAST WITH NEW
	HRRM 1,0(PP)		;UPDATE LAST
	JRST RD1

RD4:	HRRZM 1,0(PP)		;SETUP WHOLE AND LAST
	HRLM 1,0(PP)
	JRST RD1

XRR1:	XWD 0,.+1
	SUB PP,BHC+2		;FLUSH TEMPS
	RET

;[

RDLB:	CALL X2READ
	JRST RD2

;(

RDL:	CALL X1READ
RDL2:	SKIPL	-1(PP)		;TOP LEVEL?
	JRST RD7		;NO, GO ADD TO LIST
	TRNN	F,RDMFLG	;YES - IN A READMACRO?
	JRST XRR		;NO, RETURN
	RET			;YES - JUST RETURN THE VALUE

;]

RDRB:	SKIPL -1(PP)		;TOP LEVEL?
	HRRM 1,FCHAR(FX)	;NO, SETUP TO REPROCESS SAME CHAR

;)

RDR:	HRLM 1,FILEA(FX)	;SAVE LAST CHAR
	SKIPGE	-1(PP)		;TOP LEVEL?
	TRNN	F,RDMFLG	;YES - IN A READMACRO?
	JRST	RDR2		;NO
	HRRM	1,FCHAR(FX)	;YES - BACKUP CHAR INCASE USER HAS
				;... A NLSETQ. WE WILL THEN WANT TO
				;... BE ABLE TO GET IT AT A HIGHER LEVEL
	ERROR0	45,R		;ERROR, TRIED TO READ ) OR ]
RDR2:	HRRZ 2,-1(PP)		;PERIOD ENCOUNTERED BEFORE?
	JUMPN 2,RDP1		;YES
RDP2:	HLRZ 1,0(PP)		;NO, GET WHOLE LIST
	JUMPG 1,.+2		;WAS NULL?
	MOVE 1,KNIL		;YES, RETURN NIL
	RET

RDS:	MOVE	3,@BSTAB
	TLNN	3,STRBIT	;IS IT A "?
	JRST	RDBQ2		;NO - SELF DELIMITING CHAR.
	CALL RDSTR
	JRST RD2

;ATOM

RD5:	CAMN 1,KPER		;WAS PERIOD?
	TRNE F,RQTFLG		;AND NOT QUOTED?
	JRST RD2		;NO, ORDINARY ATOM
	HRRZ 2,0(PP)		;YES, SAVE CURRENT LAST
	HRRM 2,-1(PP)
	JRST RD2

;FINISH DOTTED PAIR

RDP1:	CDRA 3,2		;IS CDDR OF PREVIOUS LAST
	CDRA 3,3		;EQ TO CURRENT LAST?
	HRRZ 1,0(PP)
	CAIE 1,0(3)
	JRST RDP2		;NO, TREAT DOT AS ORDINARY ATOM
	CARA 1,1		;YES, PUT SECOND HALF IN PROPER PLACE
	HRLM 1,0(2)
	JRST RDP2

;READ STRING

RSTRNG:	CALL IFSET
	CALL IRTSET
	TRZ F,LREAD		;USER ENTRY, QUITS ON BRK. OR SEP.
	TROA F,RATFLG
RDSTR:	TRO F,LREAD
	CALL MKSTRS		;SET UP TO STORE
RDSTR2:	CALL GCHIN
	MOVE	2,@BSTAB
	SKIPE	ESCONF		;ESCAPES ON
	TLNN	2,ESCBIT	;AND IS THIS AN ESCAPE?
	JRST RDSTR3
	TRO F,RQTFLG
	CALL GCHIN
	JRST RDSTR1

RDSTR3:	TRNN F,LREAD
	JRST RDSTR7
	TLNE	2,STRBIT	;DOUBLE-QUOTE?
	JRST RDSTS2
RDSTR1:	CALL MKSTR1		;STORE CHAR
	JRST RDSTR2

RDSTR4:
RDSTR7:	TLNE	2,BRKBIT	;CHECK FOR BRK OR SEPR
	JRST	RDSTS1
	TLNE	2,SEPBIT
	JRST	RDSTS
	JRST RDSTR1

RDSTS:	TRO F,SEPFLG
RDSTS1:	HRRM 1,FCHAR(FX)
	LDB 1,FREEST
RDSTS2:	HRLM 1,FILEA(FX)
	MOVE 1,UNP1
	JRST MKSP

;RATOM - USED BY READ AND AS FUNCTION

RATOM:	CALL IFSET		;USER ENTRY
	CALL IRTSET
	TRZ F,LREAD
	TROA F,RATFLG
RDA:	TRO F,LREAD		;LISP READ ENTRY
RAT:	CALL PACS		;INITIALIZE ATOM PACK
RAT1:	CALL GCHIN
	MOVE	2,@BSTAB
	SKIPE	ESCONF
	TLNN	2,ESCBIT
	JRST RAT3		;ESCAPE OFF OR NOT ESCAPE
	TRO F,RQTFLG		
	CALL GCHIN
	JRST RAT4

RAT3:	TLNE	2,BRKBIT
	JRST	RATB
	TLNE	2,SEPBIT
	JRST	RATS
RAT4:	CALL PAC
	TRO F,CHFLG
	JRST RAT1

RATB:	TRNE F,CHFLG
	JRST RAT2
	TRNE F,LREAD
	JRST RSKP		;SKIP ON BREAK FOR LISP READ
RAT7:	HRLM 1,FILEA(FX)
RAT6:	CALL PAC
	JRST MKATM

RAT2:	HRRM 1,FCHAR(FX)
	LDB 1,CBUFP
	HRLM 1,FILEA(FX)
	JRST MKATM

RATS:	TRNE F,CHFLG
	JRST RAT2
	TRO F,SEPFLG		;FOR WT, SEPARATOR PRECEEDS ATOM
	JRST RAT1

READC:	CALL IFSET		;USER READC, NO SECOND ARG
	CALL PACS
	TRZ F,LREAD+RATFLG
	CALL GCHIN
	JRST RAT7
;CONTROL - MISCELLANEOUS MODES FOR TTY INPUT

CONTRL:	EXCH 1,2
	CALL GETTY	;GET TERM TABLE
	EXCH 1,2
	SETZ 3,
	SETO 4,
	CAMN 1,KNIL
	JRST CNTRLN
	CAME 1,KT
	RET
	EXCH 4,LBFLGW(2)	;TURN OFF LINE BUFFER
	SKIPN 4
	HRRZ 1,KNIL
	JRST CNTRL2
CNTRLN:	EXCH 3,LBFLGW(2)	;SET TO LINE BUFFER
	SKIPE 3
	HRRZ 1,KT
CNTRL2:	CAME 2,TTYTBL		;CURRENT TABLE?
	JRST CNTRL1		;NO
	PUSH PP,1
	CALL SETMOD		;SETS MODE ACCORDING TO LBFFLG
	POP PP,1
CNTRL1:	RET
;ECHOMODE - SETS THE ECHO OF TTY INPUT
ECHMOD:	EXCH 1,2
	CALL GETTY
	EXCH 1,2
	MOVE 3,ECHMDW(2)
	CAME 1,KNIL
	JRST ECHMD1
	SETZM ECHMDW(2)
	SKIPE 3
	MOVE 1,KT
	JRST CNTRL2
ECHMD1:	SETOM ECHMDW(2)
	SKIPN 3
	MOVE 1,KNIL
	JRST CNTRL2


;MISCELLANEOUS TESTS OF LAST ATOM READ

RATEST:	CAMN 1,KNIL
	JRST RATT1
	CAMN 1,KT
	JRST RATT2		;T- CHECK FOR SEPARATOR
	CAIN 1,ASZ+1		;1- CHECK FOR DOUBLE QUOTE
	TRNN F,RQTFLG
	JRST FALSE
	JRST TRUE

RATT1:	TRNE F,CHFLG
	JRST FALSE
	JRST TRUE		;LAST ATOM WAS BREAK CHAR

RATT2:	TRNN F,SEPFLG
	JRST FALSE
	JRST TRUE		;LAST ATOM PRECEEDED BY SEPARATOR

RAISE:	EXCH 1,2		;GET TERM TABLE
	CALL GETTY
	HRREI 3,-1		;DECODE ARG
	CAMN 2,KNIL
	JRST .+4
	CAMN 2,KT
	ADDI 3,1
	ADDI 3,1
	EXCH 3,RASMOD(1)		;SET MODE AND GET PREV.
	MOVE 2,KNIL		;CONVERT VAL TO RETURNABLE FORM
	JUMPL 3,.+4
	SKIPE 3
	SKIPA 2,KT
	MOVEI 2,ASZ
	PUSH PP,2
	CAMN 1,TTYTBL		;CHANGING CURRENT TABLE?
	CALL SETMOD		;YES
	POP PP,1
	RET


;PEEK AT NEXT CHARACTER

PEEKC:	CALL IFSET
	CALL PACS
	HRRZ 1,FCHAR(FX)		;ANY SAVED CHAR?
	JUMPN 1,RAT6		;YES - USE IT
IFE TEN50,<
	JUMPE FX,PEEKCT		;HANDLE TTY SPECIAL
>
	TRZ F,LREAD+RATFLG
PEEKC3:	CALL GCHIN		;NO - GET A CHAR
	HRRM 1,FCHAR(FX)	;SAVE IT
	JRST RAT6		;AND RETURN IT

IFE TEN50,<
PEEKCT:	SKIPG LNBFC		;ANYTHING IN LINEBUFFER
	JRST PEEKC2
	MOVE 2,LNBFP		;YES - GET IT
	ILDB 1,2
	JRST PEEKC5

PEEKC2:	HRRZ 1,-1(PP)
	CAME 1,KNIL
	JRST PEEKC4
	MOVEI 1,100		;WAKE UP ON EVERYTHING
	RFMOD
	MOVEM 2,OLDMOD
	TRO 2,10000
	SFMOD
	MOVE 2,CHPOS(FX)
	CALL FIN1		;GET CHAR FROM SYSTEM
	MOVEM 2,CHPOS(FX)	;UNDO CHAR ACCOUNTING
	MOVEI 4,0(1)
	MOVEI 1,100		;RESTORE WAKEUP
	MOVE 2,OLDMOD
	SFMOD
	HRRZ 1,FILEN(FX)
	BKJFN			;BACK UP
	ERROR0 20,RESET		;??? WHAT DOES BAD RETURN MEAN
	MOVEI 1,0(4)
PEEKC5:	TLNN F,RASFLG		;RAISE MODE?
	JRST RAT6		;NO
	CAIL 1,"a"		;IS IT A LOWER CASE LETTER
	CAILE 1,"z"
	JRST RAT6		;NO
	TRZ 1,40		;YES - MAKE UPPER CASE
	JRST RAT6

PEEKC4:	TRO F,LREAD
	JRST PEEKC3
>

LASTC:	CALL IFSET
	CALL PACS
	HLRZ 1,FILEA(FX)
	JRST RAT6



;GET CHARACTER FROM CURRENT INPUT FILE

GCHIN:	HRRZ 1,FCHAR(FX)	;ANY SAVED CHAR?
	JUMPE 1,@RDAX		;NO, GO GET INPUT
	HLLZS FCHAR(FX)
	RET

GCHIT:	SOSGE LNBFC		;TELETYPE - CHARS LEFT IN BUFFER?
	CALL GCHIA		;NO, GO FILL IT
GCHI1:	ILDB 1,LNBFP		;YES, GET NEXT ONE
	TLNN F,RASFLG		;INTERNAL RAISE?
	RET			;NO
	CAIL 1,"a"		;YES - LOWER CASE LETTER?
	CAILE 1,"z"
	RET			;NO
	TRZ 1,40		;YES, MAKE UPPER CASE
	RET

;FILL TTY LINE BUFFER, PERFORMING EDITING

GCHIB:	TRO F,LREAD
	TLOA F,BKFLG		;ENTRY TO FILL FROM STRING
GCHIA:	TLZ F,BKFLG		;NORMAL ENTRY
GCHI2:	SETZM LNBFC		;COUNT
	TRNE F,LREAD+RATFLG		;LISP READ OR RATOM ?
	JRST GCHI7		;YES
	TLNN F,LBFFLG
	JRST GCHI7
	AOS 0(CP)		;SO WE WILL DO INTERNAL RAISE
	JRST FIN1		;UN LINE BUFFERED READC, GET CHAR
GCHI7:	PUSH CP,PARENC
	PUSH CP,BRKCT
	PUSH CP,F		;SAVE VALUES FOR POSSIBLE LINE DELETE
	MOVE 7,[POINT 7,LNBF,-1]	;INITIAL POINTER
	MOVEM 7,LNBFP
	JRST GCHI4

FIXCTA:	MOVEI	1,100		;TURN OFF ^A MODE
	MOVE 2,INCTLA		;BY RESETING TTY MODE
	SFMOD
	SETZM INCTLA
	RET

GCHI5:	AOS LNBFC		;COUNT CHARACTER JUST ADDED
GCHI4:	TLNE F,BKFLG
	JRST GCHIB1
	CALL FIN1		;GET NEXT CHAR FROM TTY
GCHIB2:	IDPB 1,7		;PUT INTO BUFFER
	HRRZ 2,TTYTBL		;SEE IF A SPECIAL FORMAT CHARACTER
	CAMN 1,CTLQ(2)
	JRST GCHQ		;^Q
	CAMN 1,CTLR(2)
	JRST GCHR		;^R
	CAMN 1,CTLA(2)
	JRST GCHA		;^A
	SKIPN INCTLA		;IN A ^A LOOP?
	JRST GCHIB7		;NO
	PUSH	PP,1		;YES
	HRRZ 1,TTYTBL
	HRROI 1,CAMSGP(1)	;PRINT THE POST MESSAGE
	CALL GCHMSG
	CALL FIXCTA		;LEAVE ^A MODE
	POP PP,1
	HRRZ 2,TTYTBL
	SKIPE ECHMDW(2)		;ECHOING INPUT?
	CALL TCO		;YES - ECHO THE CHAR
	HRRZ 2,TTYTBL
	SETZM INCTLA		;NO LONGER IN ^A MODE
GCHIB7:	CAMN 1,CTLV(2)
	JRST GCHV		;^V
	CAMN 1,CTLEOL(2)
	JRST GCHE		;EOL

GCHI3A:	CAMN 7,[POINT 7,LNBF+LLNBF-1,34]
	JRST GCHE		;FULL , ACT LIKE EOL
	JRST GCHLC		;NOT SPECIAL, CHECK LISP FORMATTERS

GCHIB1:	CALL BKCHAR		;GET CHAR FROM STRING
	JRST GCHE		;NO MORE - QUIT
	IDPB 1,7
	JRST GCHLC		;ASSUME CANT GET SPECIAL CHARS HERE

GCHE:	SUB CP,BHC+3
	RET

GCHQ:	SKIPE INCTLA
	CALL FIXCTA
	HRRZ 2,TTYTBL
	HRROI 1,CTQMSG(2)
GCHA1A:	CALL	GCHMSG
	POP CP,F
	POP CP,BRKCT		;RESTORE VALUES TO BEG OF LINE
	POP CP,PARENC
	JRST GCHI2

GCHA:	HRRZ 2,TTYTBL
	SOSGE LNBFC		;CHARACTERS TO DELETE?
	JRST GCHA1		;NO
	SKIPN INCTLA		;1ST ^A?
	JRST GCHA2		;YES
	HRROI 1,CAMSG2(2)	;NO - USE OTHER MESSAGE
GCHA3:	CALL	GCHMSG
	IBP 7			;BACKUP POINTER 2
	IBP 7
	IBP 7
	SOS 3,7			;LEAVING NEW VALUE IN AC3 ALSO
	ILDB 1,3		;CHARACTER TO BE DELETED
	SKIPN ECHFLG(2)		;ECHOING DELETED CHAR
	SKIPN ECHMDW(2)		;... AND TYPEIN?
	CAIA			;NO
	CALL TCO		;TYPE IT OUT
	JRST GCHDC		;CHECK FOR LISP FORMATTERS

GCHA2:	MOVEI 1,100		;ENTER ^A MODE
	RFMOD
	MOVEM 2,INCTLA	
	TRZ 2,6000		;TURN OFF ECHO
	TRO 2,170000		;WAKE UP ON EVERYTHING
	SFMOD
	HRRZ 2,TTYTBL
	HRROI 1,CAMSG1(2)	;FIRST ^A MESSAGE
	JRST GCHA3

GCHA1:	HRROI 1,CAMSGE(2)	;PRINT EMPTY BUFFER MESSAGE
	JRST GCHA1A

GCHR:	SKIPE INCTLA		;CLEAR ^A MODE
	CALL FIXCTA
	TMSG EOLM		;RETYPE LINE, EOL FIRST
	ADD 7,[7B5]		;BACKUP POINTER 1 TO FLUSH R
	MOVE 6,LNBFP		;INITIAL POINTER
	MOVE 5,LNBFC		;CURRENT COUNT
GCHR1:	JUMPE 5,GCHI4		;DONE
	ILDB 1,6
	CALL TCO
	SOJA 5,GCHR1

GCHV:	CALL CTRLV		;GET CHAR UNDER THE ^V
	DPB 1,7			;STORE ON TOP OF CTRLV
	JRST GCHI5

CLRTTY:	SETZM LNBFC
	SETZM PARENC
	SETZM BRKCT
	HLLZS FCHAR		;CLEAR SINGLE CHARACTER BUFFER
	TRZ F,GCHDQF
	RET
GCHMSG:	PUSH	CP,2		;FAST OUTPUT TO TTY
	PSOUT
	MOVEI	1,101			;NOW GET THE LINE POSITION
	RFPOS				;WILL BE CORRECT EVEN IF THINGS
	HRRZM	2,CHPOS+1		;... LIKE ^H ARE BACKSPACING
	POP	CP,2
	RET

U PARENC
U BRKCT

U LNBFP
U LNBFC
LLNBF==40
U LNBF,LLNBF
U SLNBF,LLNBF		;BUFFER FOR SAVED LINE BUFFER
U INCTLA		;IN ^A MODE FLAG

U RDAX

;SPECIAL LINE EDITING FOR LISP FORMAT CHARACTERS

GCHLC:	TRNN F,LREAD+RATFLG
	JRST GCHI5		;NOT LISP READ OR RATOM
	MOVE	2,@BSTAB
	SKIPN	ESCONF
	JRST	.+3
	TLNE	2,ESCBIT
	JRST GCHESC
	TRNN F,LREAD
	JRST GCHL1
	TLNE	2,STRBIT	;DOUBLE QUOTE?
	JRST GCHDQ
	TRNE F,GCHDQF		;INSIDE DOUBLEQUOTE NOW?
	JRST GCHI5		;YES
	LDB	2,JMPFLD
	JRST	@GCHJMP(2)
GCHJMP:	GCHL3
	GCHRBK			;]
	GCHLBK			;[
	GCHLPR			;(
	GCHRPR			;)
	GCHL3
	GCHL3
	GCHL3

GCHL3:	TLNN F,LBFFLG		;LINE-BUFFERRED?
	JRST GCHI5		;YES - GO ON
	SKIPN BRKCT		; NO - CHECK BRACKET AND PAREN COUNTS
	SKIPE PARENC
	JRST GCHI5		;INSIDE LIST - GO ON
	JRST GCHL2		;GO CHECK FOR BREAK AND SEPR

GCHLPR:	SKIPN	BRKCT
	AOS PARENC
	JRST GCHI5

GCHRBK:	SOSLE 1,BRKCT
	JRST GCHI5
	JUMPL 1,GCHACR		;UNMATCHED RIGHT BRACKET
	SKIPLE PARENC
	JRST	GCHI5
GCHRPR:	SKIPN	BRKCT
	SOSLE PARENC		;COUNT DOWN PARENS
	JRST GCHI5
GCHACR:	SETZM PARENC		;TERMINATOR
	SETZM BRKCT
	TLNN F,NCRFLG
	TMSG EOLM
	JRST GCHE

GCHLBK:	AOS BRKCT
	JRST GCHI5

GCHDQ:	TRCE F,GCHDQF
	JRST GCHL3		;CLOSING QUOTE, CHECK IF WANT TO QUIT
	JRST GCHI5
GCHESC:	AOS LNBFC		;ESCAPE COMING ON, QUOTE ONE CHAR
	TLNE F,BKFLG
	CALL BKCHAR		;GET CHAR FROM STRING -IF EMPTY,READ
	CALL FIN1
	HRRZ 2,TTYTBL
	CAMN 1,CTLV(2)		;CONTROL-V?
	CALL CTRLV
GCHES1:	IDPB 1,7
	JRST GCHI5

GCHL1:	TLNN F,LBFFLG		;HERE IF RATOM
	JRST GCHI5		;LIN BUFFERRED, GO TO EOL
GCHL2:	MOVE	2,@BSTAB	;NOT LINE BUFFERED, BRK OR SEPR?
	TLNE	2,BRKBIT+SEPBIT
	JRST	GCHE		;YES, QUIT
	JRST GCHI5		;YES

CTRLV:	TLNE F,BKFLG		;READING FROM STRING?
	RET			;YES-PASS ^V THRU
	CALL FIN1		;GET ANOTHER CHAR
	CAIG 1,"z"
	CAIN 1,100
	RET			;IGNORE @
	CAIL 1,"a"
	TRZ 1,40		;UPPER SHIFT
	CAIGE 1,133
	ANDI 1,77		;TRANSFORM A-Z TO ^A-^Z
	RET			;ALL ELSE UNCHANGED

;ACCOUNT FOR DELETED CHARACTER

GCHDC:	SKIPLE 3,LNBFC		;ANYTHING IN BUFFER?
	SKIPN	ESCONF
	JRST GCHDC1
	TRZ F,ESCFLG
GCHDC3:	UBP 2			;BACK UP POINTER
	LDB 5,2			;...LOOK FOR ODD OR EVEN ESC
	EXCH	1,5
	MOVE	1,@BSTAB
	EXCH	1,5
	TLNN	5,ESCBIT
	JRST	GCHDC2
	TRC F,ESCFLG
	SOJG 3,GCHDC3
GCHDC2:	TRZN F,ESCFLG
	JRST GCHDC1
	IBP 7			;CHAR IS UNDER ESC. DELETE ESC. ALSO
	JRST GCHA
GCHDC1:	TRNN F,LREAD
	JRST GCHI4
	MOVE	2,@BSTAB
	TLNE	2,STRBIT
	TRC F,GCHDQF
	TRNE F,GCHDQF
	JRST GCHI4		;WITHIN DOUBLEQUOTE
	LDB	2,JMPFLD
	XCT	GCHDC4(2)
GCHDC4:	JRST	GCHI4
	AOS	BRKCT		;]
	SOS	BRKCT		;[
	JRST	GCHDC5		;(
	JRST	GCHDC6		;)
	JRST	GCHI4
	JRST	GCHI4
	JRST	GCHI4

GCHDC5:	SKIPN	BRKCT		;NO COUNTING INSIDE BRACKETS
	SOS	PARENC
	JRST	GCHI4

GCHDC6:	SKIPN	BRKCT
	AOS	PARENC
	JRST	GCHI4

;INITIALIZE ATOM PACKER

PACS:	PUSH CP,1
	SETZM POCT
	SETZM PDEC
	TRZ F,NEGFLG+LETFLG+QFLG+DIGFLG+FLTFLG+CHFLG+RQTFLG+SEPFLG
PACS2:	MOVN 1,MAXATL
	MOVEM 1,NICHRS
	ADDI 1,4
	IDIVI 1,5
	ADD 1,ENDPN
	CAML 1,FREEPN
	JRST PACS1
	MOVE 1,PNAMT		;NOT ENUF SPACE FOR BIGGEST ATOM
	PUSHJ GP,GC1		;RECLAIM
	MOVE 1,PNAMT
	HRRZ 1,TYPBLK(1)
	HRRZ 1,TNFR(1)
	IMULI 1,5
	CAIL 1,NATMC		;ENUF NOW?
	MOVEI 1,NATMC		;YES - RESET MAXATL TO ORIG. VALUE
	MOVEM 1,MAXATL		;NO - MAKE MAXATL SHORTER
	CAIL 1,NATMC
	JRST PACS2
	JRST RESET		; AND GO TO TOP
PACS1:	MOVE 1,FREEPN
	HRLI 1,350700
	MOVEM 1,CBUFP
	MOVEM 1,SCBUFP
	POP CP,1
	RET

U POCT				;ACCUMULATES OCTAL NUMBER
U PDEC				;ACCUMULATES DECIMAL NUMBER
U CBUFP				;CURRENT POINTER TO PACKED STRING
U SCBUFP			;INITIAL POINTER TO PACKED STRING
U NICHRS			;COUNT OF CHARACTERS IN ATOM

;ACCUMULATE CHARACTER FOR ATOM

PAC:	IDPB 1,CBUFP
	TRNE F,LETFLG+QFLG
	JRST PACL
	CAIN 1,"E"
	TRNN F,DIGFLG
	CAIN 1,"."
	JRST PACFI
	CAIN 1,"-"
	JRST PACM
	CAIN 1,"+"
	JRST PACP
	CAIN 1,"Q"
	JRST PACQ
	CAIL 1,"0"
	CAILE 1,"9"
	JRST PACL
	TRO F,DIGFLG
	SUBI 1,"0"
	MOVE 2,POCT
	LSH 2,3
	IORI 2,0(1)
	MOVEM 2,POCT
	MOVE 2,PDEC
	LSH 2,2
	ADDB 2,PDEC		;TIMES 5
	ADDM 2,PDEC		;TIMES 10
	ADDM 1,PDEC
	JRST PACOUT

PACQ:	TRNE F,FLTFLG
	JRST PACL
	TROA F,QFLG
PACFI:	TRO F,FLTFLG
	JRST PACOUT

PACM:	TRO F,NEGFLG
PACP:	TRNN F,FLTFLG
	TRNN F,DIGFLG
	JRST PACOUT
PACL:	TRO F,LETFLG
PACOUT:	AOSL NICHRS
	ERROR0 13,RESET		;ATOM TOO LONG
	RET

;MAKE ATOM

MKATM:	TRNN F,LETFLG
	TRNN F,DIGFLG
	JRST MKAC		;>0 LETTERS OR 0 DIGITS => LITERAL ATOM
	TRNE F,FLTFLG		;FLOATING NUMBER?
	JRST MKFLT		;YES
	MOVE 1,PDEC
	TRNE F,QFLG		;OCTAL NUMBER
	MOVE 1,POCT		;YES
	TRNE F,NEGFLG		;MINUS SIGN?
	MOVN 1,1		;YES, NEGATE
	JRST MKN

MKAC:	MOVE 1,MAXATL
	ADDB 1,NICHRS
	CAIE 1,1		;ONE-CHARACTER ATOM?
	JRST MKAL		;NO
	JRST MKAL		;NO ONE-CHAR ATOMS YET


;TRANSFORM CHARACTER STRING INTO FLOATING NUMBER

MKFLT:	IFE TEN50,<SETZ 1,
	IDPB 1,CBUFP
	MOVE 1,SCBUFP
	FLIN
	JRST MKAC
	CAME 1,CBUFP
	JRST MKAC		;DIDNT USE ALL CHARS
	MOVE 1,2
	JRST MKFN
>
	IFN TEN50,<MOVE 3,SCBUFP
	SETZ 4,
	CALL MKFI		;GET INTEGER PART
	TRNE F,NEGFLG
	MOVN 1,1
	MOVE 5,2		;SAVE TERMINATING CHARACTER
	CALL FXFLT		;FLOAT INTEGER
	MOVE 4,1
	CAIE 5,"."		;IS THERE A FRACTION?
	JRST MKFE		;NO- GO DO EXPONENT
	MOVE 5,FT01		;0.1
	TRNE F,NEGFLG
	MOVNS 5
MKFL1:	CAMN 3,CBUFP
	JRST MKFLX
	ILDB 2,3
	CAIN 2,"E"
	JRST MKFE
	CAIG 2,"9"
	CAIGE 2,"0"
	JRST MKAC		;REALLY ISNT FLOATING NUM, ATOM
	SUBI 2,"0"
	MOVSI 2,211000(2)	;FLOAT THE DIGIT
	FMPR 2,5
	FADR 4,2
	FMPR 5,FT01		;0.1
	JRST MKFL1

MKFE:	CALL MKFI	;GET EXPONENT
	MOVEI 5,FT
	TRNE F,NEGFLG
	MOVEI 5,FT0
MKFE1:	SUBI 5,1
	TRNE 1,1
	FMPR 4,0(5)
	LSH 1,-1
	JUMPN 1,MKFE1
MKFLX:	MOVE 1,4
	JRST MKFN		;BOX IT

MKFI:	TRZ F,NEGFLG		;GET INTEGER WITH OPTIONAL SIGN
	SETZ 1,
	ILDB 2,3
	CAIN 2,"-"
	TROA F,NEGFLG
	CAIN 2,"+"
	JRST MKFI2
MKFI1:	CAIG 2,"9"
	CAIGE 2,"0"
	RET			;QUIT ON NON NUMBER
	SUBI 2,"0"
	IMULI 1,12
	ADDI 1,0(2)
MKFI2:	CAMN 3,CBUFP
	RET			;QUIT ON END BUFFER
	ILDB 2,3
	JRST MKFI1
>

;CONSTRUCT LITERAL ATOM

MKAL:	DPB 1,SCBUFP		;STORE CHAR COUNT AT BEG OF STRING
	HRRZ 1,SCBUFP		;PNAME ADDRESS
	MOVE 2,ATOMHT		;HASH TABLE ADDRESS
	CALL HENTER		;LOOKUP NAME IN ATOM HASH TABLE
	JRST MKAL1		;ALREADY PRESENT
	MOVEI 7,0(1)		;NEW ENTRY, H.T. ADDRESS IN 1
MKALG1:	MOVE 1,FREEAT		;ATOM FREE LIST
	JUMPE 1,MKALGC		;NO ATOMS LEFT
	MOVE 1,0(1)		;GET NEXT ENTRY IN LIST
	EXCH 1,FREEAT		;UPDATE FREE LIST POINTER
	MOVE 2,KNOB		;SETUP TOP LEVEL CELLS
	HRL 2,KNIL		;NOBIND=>CAR, NIL=>CDR
	MOVEM 2,0(1)
	MOVE 2,KNIL
	HLL 2,EVALUU		;FN CELL GETS EVAL UUO AND NIL
	MOVEM 2,1(1)
	HRLZ 2,SCBUFP		;PNAME POINTER
	MOVEM 2,2(1)
	AOS 2,CBUFP		;UPDATE PNAME POINTER
	HRRZM 2,FREEPN
	MOVEI 2,2(1)		;POINTER TO PNAME CELL
	HRRM 2,0(7)		;=>HASH TABLE
	RET

MKAL1:	HRRZ 1,0(1)		;GET POINTER TO ATOM
	MOVEI 1,-2(1)		;MAKE IT POINT TO VALUE, NOT PNAM CELL
	RET

MKALGC:	CALL ATOMGC		;COLLECT ATOMS
	JRST MKALG1

EVALUU:	EXCAL 0

;GENERAL PURPOSE HASH SYMBOL TABLE ROUTINE
;PNAME OR STRING POINTER IN 1
;HASH TABLE ADDRESS IN 2
;FIRST WORD OF HASH TABLE IS XWD NO. ENTRIES,SIZE-1

;LOOKUP. SKIP IF SYMBOL NOT PRESENT, BUT DO NOT ENTER IT

HLOOK:	SETOM HENTO		;LOOKUP/ENTER FLAG
	JRST HLOOK1

;ENTER. IF SYMBOL NOT PRESENT, ENTER IT AND SKIP.
;OTHERWISE (FOR LOOKUP AND ENTER) RETURN ADDRESS OF HASH TABLE
;ENTRY IN 1

HENTER:	SETZM HENTO		;LOOKUP/ENTER FLAG AND RECLAIMED CELL
HLOOK1:	PUSH CP,2		;TABLE ADDRESS
	STE 1,PNAM		;PNAME OR STRING POINTER?
	JRST HENT1		;STRING
	MOVEI 6,0(1)		;PNAME, CONVERT TO BYTE POINTER
	HRLI 6,440700
	ILDB 7,6		;LENGTH
HENT1A:	PUSH CP,6
	PUSH CP,7
	MOVEI 5,0		;COMPUTE HASH IN 5
HENT2:	ILDB 1,6
	ADDI 5,0(1)
	IMUL 5,HASHC
	SOJG 7,HENT2		;COUNT CHARS
	TRNN 5,777776		;TEST FOR RESERVED NUMBER
	ADDI 5,555550
	MOVS 3,5		;3 USED FOR RE-HASHING
	HRRZ 2,@-2(CP)		;HASH TABLE SIZE-1
	ANDI 2,0(3)		;MASK OFF HIGH BITS OF HASH
	ANDI 2,-NPS		;MASK OFF LOW BITS OF HASH
	PUSH CP,2		;LEAVING ADDRESS OF PAGE TO BE PROBED
	MOVEI 1,NPS*2		;PROBE COUNT
	MOVEM 1,HENTC
	JRST HENT4

HENT1:	SBPC 6,1		;STRING POINTER TO BYTE POINTER CONV.
	JRST HENT1A

HENT3:	SOSG HENTC		;COUNT NUMBER OF PROBES
	JRST HASERR		;TOO MANY - TABLE FULL
	MUL 3,HASHC		;REHASH FOR ANOTHER PROBE
	ROTC 3,^D20
HENT4:	MOVEI 2,0(3)		;COMPUTE PROBE ADDRESS WITHIN PAGE
	ANDI 2,MPS		;PREVIOUSLY COMPUTED
	ADD 2,0(CP)
	JUMPE 2,HENT3		;FIRST ENTRY KNOWN TO BE IN USE
	ADD 2,-3(CP)		;ADD TABLE ADDRESS
	HLRZ 1,0(2)		;EXTRA HASH BITS
	CAIG 1,1		;UNUSED ENTRY IF 1 OR 0
	JRST HENT5
	CAIE 1,0(5)
	JRST HENT3		;EXTRA BITS NOT EQUAL
	HRRZ 4,0(2)		;PNAME POINTER CELL ADDRESS
	HLRZ 4,0(4)		;PNAME OR STRING POINTER
	STE 4,PNAM
	JRST HENT8		;STRING
	HRLI 4,440700
	ILDB 7,4		;COUNT
HENT8A:	CAME 7,-1(CP)
	JRST HENT3		;CHAR COUNTS NOT EQUAL
	HRLM 2,0(CP)		;SAVE CURRENT ENTRY ADDRESS
	MOVE 6,-2(CP)		;POINTER TO PROTOTYPE STRING
HENT8B:	ILDB 2,6
	ILDB 1,4
	CAIE 1,0(2)
	JRST HENT3		;AFTER ALL THAT, THE STRINGS ARE DIFFERENT
	SOJG 7,HENT8B		;COUNT CHARS
	HLRZ 1,0(CP)		;STRINGS EQUAL, GET ENTRY ADDRESS
HENTR:	SUB CP,BHC+4		;FLUSH TEMPS
	RET

HENT8:	SBPC 6,4		;STRING TO BYTE POINTER
	MOVE 4,6
	JRST HENT8A

HENT5:	JUMPE 1,HENT6		;JUMP IF EMPTY ENTRY
	SKIPN HENTO		;IS RECLAIMED ENTRY
	MOVEM 2,HENTO		;REMEMBER IT IF FIRST ONE
	JRST HENT3

HENT6:	SKIPGE 1,HENTO		;SEARCH FAILED. CHECK FLAG
	JRST HENT7		;WAS LOOKUP, DONT MAKE NEW ENTRY
	JUMPE 1,.+2		;MAKE NEW ENTRY. USE RECLAIMED?
	MOVEI 2,0(1)		;YES
	HRLZM 5,0(2)		;STORE EXTRA HASH BITS
	MOVSI 1,1		;INCREMENT COUNT OF ENTRIES IN TABLE
	ADDM 1,@-3(CP)
	MOVEI 1,0(2)		;RETURN ADDRESS OF ENTRY
HENT7:	AOS -4(CP)		;SKIP RETURN
	JRST HENTR

U HENTO				;ADDRESS OF RECLAIMED CELL AND L/E FLAG
U HENTC				;PROBE COUNT

HASHC:	XWD 240501,202405	;HASH CONSTANT

HASERR:	ERROR0 14,RESET		;HASH TABLE FULL

;PRINT, ETC.

PRINTX:	MOVE 2,KT		;PRINT TO TTY
	HRRZ 3,KT
PRINT:	CALL PRIN2
	TCH EOL
	RET

PRIN1:	TLZ F,PDQFLG		;DISABLE ESCAPE
	TLO F,PRXFLG		;ENABLE RADIX
	CALL OFSET
	JRST IPRE1

PRIN2:	JRST PRINN

IPRE:	TLZ F,PDQFLG+PRXFLG		;DISABLE ESCAPE AND RADIX
	HRRZ 3,@KPRXFL		;IF PRXFLG=T - ENABLE RADIX
	CAME 3,KNIL
	TLO F,PRXFLG
	JRST IPRE3

IPRE2:	TLO F,PDQFLG+PRXFLG	;INTERNAL PRINT, PRIN2 FORMAT
	MOVEM 2,PREX		;INTERNAL SUBR
	MOVNI FX,1		;DENOTES NO FILE
	JRST IPRE4

IPRE3:	MOVEM 2,PREX		;INTERNAL SUBR
	MOVNI FX,1		;DENOTES NO FILE
	JRST IPRE1

PRINN:	TLO F,PDQFLG+PRXFLG
PRLST:	PUSH PP,3		;SAVE READTABLE
	CALL OFSET
	POP PP,3		;RESTORE READTABLE
IPRE4:	CALL ORTSET
IPRE1:	MOVE 2,PPLVL
	MOVEM 2,TPLVL
	SETZM PLVL
	TLZ F,PRPFLG
PRE:	PUSH PP,1
	STE 1,LIST
	JRST PRE5
	HRLM 1,0(PP)
	CAIE FX,1		;OUTPUT TTY?
	JRST PRE6		;NO, DONT CHECK PRINTLEVEL
	MOVE 1,TPLVL
	CAMG 1,PLVL
	JRST PRE4
	TLNE F,NEGPLF
	TLZN F,PRPFLG
	JRST PRE6
	TCH EOL
PRE6:	TCH "("
	AOS PLVL
PRE1:	HLRZ 1,0(PP)
	STE 1,LIST
	JRST PRE2
	CDRA 2,1
	CARA 1,1
	HRLM 2,0(PP)
	CALL PRE
	HLRZ 1,0(PP)
	CAMN 1,KNIL
	JRST PRE3
	CALL SPACE1
	CAIE FX,1		;OUTPUT TTY?
	JRST PRE1		;NO, DONT CHECK PRINTLEVEL
	MOVE 1,TPLVL
	CAML 1,PLVL
	JRST PRE1
	TCH "-"
	TCH "-"
PRE3:	TLO F,PRPFLG
	TCH ")"
	SOS PLVL
PREE:	POP PP,1
	HRRZ 1,1
	RET

PRE2:	TCH "."
	CALL SPACE1
	CALL PRATM
	JRST PRE3

PRE4:	TCH "&"
	JRST PREE

PRE5:	TLZ F,PRPFLG
	CALL PRATM
	JRST PREE

TCHQ:	PUSH CP,1		;TYPE ONE QUOTED CHARACTER UUO
	HRRZ 1,40
	CALL PREC
	POP CP,1
	RET

U PPLVL				;PERMANENT PRINT LEVEL
U TPLVL				;TEMPORARY (THIS PRINT) PRINT LEVEL
U PLVL				;RUNNING PRINT LEVEL

SPACE1:	PUSH CP,1
	JUMPL FX,SPA2		;REAL FILE?
	HRRZ 1,CHPOS(FX)
	ADDI 1,10		;WITHIN 10 OF MARGIN?
	CAMLE 1,LINSIZ
	TCH EOL			;YES, CR
	CAMG 1,LINSIZ
SPA2:	TCH " "			;NO, SPACE
	POP CP,1
	RET

SPACES:	CALL OFSET
	CALL IUNBOX
	MOVE FX,FPX
	HRRZ 2,CHPOS(FX)
	ADD 2,1
	CAMLE 2,LINSIZ		;WILL PASS MARGIN?
	JRST SPA1		;YES
	JUMPLE 1,FALSE		;NO, OUTPUT AND COUNT SPACES
	TCH " "
	SOJG 1,.-1
	JRST FALSE

SPA1:	TCH EOL
	JRST FALSE

;PRINT NON-LIST DATA

PRATM:	LDT 2,1
	CAMN 2,ARRAYT
	JRST PRARR		;ARRAY PRINT
	CAMN 2,ATOMT
	JRST PRAT		;ATOM
	CAMN 2,FLOATT
	JRST PRFLT		;FLOATING POINT NUMBER
	CAME 2,SMALLT
	CAMN 2,FIXT
	JRST PRNUM		;INTEGER
	CAME 2,PNAMT
	CAMN 2,STPTT
	JRST PRSTR		;STRING
	CAMN 2,CHART
	JRST PRCHA		;CHARACTER
PRABAD:	MOVEI 4,"#"
	MOVEI 3,1
	MOVEI 2,10
	JRST APTX

PRNUM:	CALL IUNBOX
	MOVEI 4,0		;SETUP FOR APT
	MOVEI 3,0
	MOVE 2,URADIX
	TLNN F,PRXFLG
	MOVEI 2,12		;RADIX DISABLED FOR IPRE
	JUMPGE 1,PRA2
	TLNN F,PNEGF		;SKIP ON PRINT SIGN FOR MINUS
	JRST PRA2
	MOVN 1,1
	ADDI 3,1		;AN EXTRA CHAR
	MOVEI 4,"-"		;PREFIX CHAR IS -
PRA2:	CAIN 2,10
	TLNN F,PDQFLG
	JRST APTX
	JUMPL 1,.+3
	CAMGE 1,2
	JRST APTX
	CALL APTX
	ADDI 3,1

	TCH "Q"		;Q AFTER OCTAL NUM IF PRIN2 AND NUM>7
	RET

;PRINT ATOM

PRAT:	CAMN 1,KPER		;PERIOD?
	JRST PRAPER		;YES, PRINT WITH DOUBLEQUOTES MAYBE
PRAP2:	HLRZ 1,2(1)		;GET PNAME POINTER
PRAST:	CALL UPATM		;SETUP BYTE AND COUNT
	JUMPE 4,R		;NO CHARS?
	JUMPL FX,PRA8		;REAL FILE?
	HRRZ 1,CHPOS(FX)	;POSITION ON LINE
	ADDI 1,0(4)
	CAMLE 1,LINSIZ		;WILL EXCEED RIGHT MARGIN?
	TCH EOL			;YES, CR
PRA8:
PRA5:	ILDB 1,3
	TLNN F,PDQFLG		;IF ESCAPE DISABLED,
	JRST PRA6		;DO NOT CHECK FOR SPECIAL CHAR
	MOVEI 5,0(1)
	MOVE	1,@PBTAB
	TLNE	1,PRTBIT
	TCH ESC			;SO PRINT ESCAPE
PRA7:	MOVEI 1,0(5)
PRA6:	CALL PREC
	SOJG 4,PRA5		;COUNT CHARACTERS
	RET

PRAPER:	TLNN F,PDQFLG		;PRINTING ESCAPE?
	JRST PRAP2		;NO
	TCH ESC
	TCH "."
	RET

UPATM:	STE 1,PNAM
	JRST PRAT1
	MOVEI 3,0(1)
	HRLI 3,440700		;MAKE INTO BYTE POINTER
	ILDB 4,3		;GET CHAR COUNT
	JRST PRAT2
PRAT1:	SBPC 3,1		;STRING TO BYTE POINTER CONVERSION
PRAT2:	MOVEM 3,UPATP
	MOVEM 4,UPATC
	RET

UPA:	SOSGE UPATC		;COUNT CHARS
	RET
	ILDB 1,UPATP
	JRST RSKP

U UPATP
U UPATC

;FLOATING POINT OUTPUT

A==3
B==4
C==5
W1==6
W2==7

PRFLT:
IFE TEN50,<	MOVE 2,0(1)
	MOVE 1,IOFNMP
	MOVE 3,FLTFMC
	FLOUT
	RET			;BAD RETURN
	PUSH NP,1
	MOVE 5,IOFNMP
FP1:	ILDB 1,5
	CALL PREC
	CAME 5,0(NP)
	JRST FP1
	POP NP,2
	RET

U FLTFMC

; FLOATING FORMAT

FLTFMF:	CAMN 1,KNIL
	JRST FLTFM1
	CAMN 1,KT
	SKIPA 1,[XWD 4000,0]
	CALL IUNBOX
	EXCH 1,FLTFMC
	JRST MKN
FLTFM1:	MOVE 1,FLTFMC
	JRST MKN
>
IFN TEN50,<	MOVE 1,0(1)
	MOVE A,1
	JUMPG A,TFLOT1
	JUMPE A,FP1A
	MOVNS A
	TCH "-"
	TLZE A,400000
	JRST FP1A
TFLOT1:	MOVEI 2,^D10
	TLNN A,400
	JRST APT		;IF UNNORMALIZED, TYPE AS DEC INTEGER??

FP1:	MOVEI B,0
	CAMGE A,FT01
	JRST FP4
	CAML A,FT8
	AOJA B,FP4

FP1A:	MOVEI C,0
FP3:	MULI A,400
	ASHC B,-243(A)
	SETZM TEM1		;INIT 8 DIGIT COUNTER
	SKIPE A,B		;DONT TYPE A LEADING 0
	PUSHJ CP,FP7		;PRINT INTEGER PART OF 8 DIGITS
	TCH "."
	MOVNI A,10
	ADD A,TEM1
	MOVE W1,C
FP3A:	MOVE 1,W1
	MULI 1,12
	MOVE W1,2
	PUSHJ CP,FP7B
	SKIPE ,W1
	AOJL A,FP3A
	POPJ CP,

FP4:	MOVNI C,6
	MOVEI W2,0
FP4A:	ASH W2,1
	XCT FPCP(B)
	JRST FP4B
	FMPR A,@FPCP+1(B)
	IORI W2,1
FP4B:	AOJN C,FP4A
	PUSH CP,W2	;SAVE EXPONENT
	PUSH CP,B		;SAVE SIGN
	PUSHJ CP,FP3		;PRINT FFF.FFF PART OF NUMBER
	TCH "E"
	POP CP,1
	JUMPG 1,.+2
	TCH "-"
	POP CP,A		;GET EXPONENT BACK

FP7:	IDIVI A,12		;DECIMAL OUTPUT SUBROUTINE
	AOS TEM1
	HRLM B,0(CP)
	JUMPE A,FP7A1
	PUSHJ CP,FP7
FP7A1:	HLRZ 1,0(CP)
FP7B:	ADDI 1,260
	JRST @PREX		;TYPE CHAR

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0=FT01+1

FPCP:	CAMLE A,FT0(C)
	CAMGE A,FT(C)
	Z FT0(C)

U TEM1
>
;PRINT STRING

PRSTR:	CALL UPATM
	JUMPL FX,PRSTR4		;REAL FILE?
	HRRZ 1,CHPOS(FX)
	ADDI 1,0(4)
	CAMLE 1,LINSIZ		;EXCEED MARGIN?
	TCH EOL			;YES - PRINT C.R.
PRSTR4:	TLNE F,PDQFLG
	TCH 42			;PRINT DOUBLE QUOTE
	JUMPLE 4,PRSTR1		;ANY CHARS?
PRSTR2:	ILDB 1,3
PRSTR5:	TLNN F,PDQFLG		;PRINTING ESCAPES?
	JRST PRSTR3		;NO
	CAIE 1,ESC		;CHAR IS " OR ESC ?
	CAIN 1,42
	TCH ESC			;YES - PRINT ESCAPE
PRSTR3:	CALL PREC
	SOJG 4,PRSTR2
PRSTR1:	TLNE F,PDQFLG
	TCH 42
	RET

PRCHA:	CAIGE 1,ACHAR
	JRST PRABAD
	TLNE F,PDQFLG
	TCH 42
	SUBI 1,ACHAR
	SETZ 4,
	JRST PRSTR5

;PRINT ROUTINES NOT YET IMPLEMENTED


PRARR:	JRST PRABAD		;ARRAY


;SYSOUT AND SYSIN
SYSOUT:	SETZM	ZORGJQ
	CALL	IOFN
	MOVSI	1,400001
	GTJFN
	 JRST	[HRRZ	2,-2(PP)
		 JRST	OPNER3]
	HRRZM	1,SYSJFN
	MOVE	2,[XWD 440000,102000]	;36BIT, WRITE, THAWED.
	OPENF
	 JRST	[HRRZ 1,SYSJFN
		 RLJFN
		  JFCL
		 HRRZ 2,-2(PP)
		 JRST OPNER3]		;CANNOT OPEN FILE ERROR
	MOVE	1,[XWD	10,GCAC2]	;SAVE AC'S 10-17
	BLT	1,GCAC2+7		;FOR RETURN FROM SYSIN.
SYSOUE:	MOVEM	F,TFLGS
	HRRZ	1,SYSJFN
	MOVE	2,[POINT 36,[XWD 1000,1	;WORD 0 (SEE JSYS MANUAL
			     0 ;SECT. 7 P 2. WORD1 DONE LATER.
			     XWD 1,140]] ;ENTRY VEC TO BOOT.
	MOVNI	3,3	;COUNT
	SOUT
	SKIPN	ZORGJQ
	SKIPA	2,[SIXBIT /SYSOUT/]
	MOVE	2,[SIXBIT /MAKSYS/]
	BOUT
	MOVE	2,SYSDAT	;SYSDAT TO W4 OF FILE FOR SYSIN CHECK
	BOUT
	MOVE	2,[POINT 36,DADDYN]
	MOVNI	3,^D31	;30 FOR DADDYNAME +1 FOR 1STFPN
	SOUT

;Later we will emit main fork page 0 (which contains the bootstrap
;to unscramble all that comes later) and then go back and write the map
;word for GET to use over the zero at file word 1 above.
	SKIPN	ZORGJQ
	SKIPA	3,[SYSBIT+PVTBIT]
	SETZ	3,
	CALL	SYSMAP		;WRITE OUT MAP WORDS FOR THE WORLD.
	HRRZ	1,SYSJFN
	RFPTR
	 JSYS	JSYSER
	LSH	2,-LPS		;SKIP TO PAGE BOUND
	ADD	2,[XWD 520000,1] ;PROT. FOR PMAP=520;+1 TO NXT PG.
	HRRZI	3,1		;NOW REPLACE 0 AT W1 WITH REGULAR GET
	ROUT
	HRRZI	2,(2)
	HRRZI	3,^D35		;1STFPN WORD GIVES 1ST FILE PAGE NUM
	ROUT			;DONE IN PAGE MODE.
	HRRZI	6,(2)		;SAVE PBOUND
	HRLI	1,400000		;KEEP JFN BUT CLOSE TO MAKE SURE FILE
	CLOSF
	 JSYS	JSYSER			;REALLY THERE FOR UPCOMING INPUT GTJFN
	MOVE	1,IOFNMP
	HRRZ	2,SYSJFN
	SETZ	3,
	JFNS
	MOVE	2,IOFNMP	;NAME (JFNS OUTPUT) FOR GETTING INPUT JFN
	HRLZI	1,100001	;OLD FILE NOW.
	GTJFN
	 JSYS	JSYSER
	HRLM	1,SYSJFN	;LH=READ JFN; RH=WRITE JFN NOW
	MOVE	2,[XWD 440000,202000] ;36 BIT READ THAWED
	OPENF
	 JSYS	JSYSER
	HRRZI	2,^D36		;SKIP TO 1ST MAPWORD
	SFPTR
	 JSYS	JSYSER
	HRRZ	1,SYSJFN
	MOVE	2,[XWD 440000,102000] ;AS BEFORE
	OPENF
	 JSYS	JSYSER
	HRRZI	2,(6)
	LSH	2,LPS
	SFPTR			;READY TO WRITE PAGES AT END.
	 JSYS	JSYSER


SYSPLP:	HLRZ	1,SYSJFN
	BIN			;READ 1 MAP WORD.
	JUMPE	2,SYSDON
	HRRZ	1,SYSJFN	;OUTPUT JFN AGAIN

	TRNE	2,7000		;0 HERE SEZ MAIN FORK
	 JRST	SYSHPG
	HLRZ	3,2
	LSH	3,LPS
	MOVNS	3
	LSH	2,LPS
	HRLI	2,444400
	SOUT
	JRST	SYSPLP

SYSHPG:	HLRZ	6,2		;PAGE CNT
	HRRZI	5,(2)
	ANDI	5,777		;FORK PAGE NUM
	LSH	2,-LPS
	ANDI	2,7		;FORK NUMBER,+1
	SOSGE	2
	 0
	HRL	5,SWFRKS(2)	;FORK HANDLE
HPGLP:	MOVE	1,5
	MOVE	2,[XWD 400000,777]
	HRLZI	3,100000
	PMAP
	HRRZ	1,SYSJFN
	MOVNI	3,1000
	MOVE	2,[POINT 36,777000]
	SOUT
	AOS	5
	SOJG	6,HPGLP
	JRST	SYSPLP


SYSDON:	SKIPE	ZORGJQ
	 JRST	SYSDN1
	HRRZ	1,SYSJFN
	CALL	FILNM
	PUSH	PP,1
	HLRZ	1,SYSJFN
	CLOSF	;CLOSE READING JFN FIRST SO THAT EOF RESET RIGHT
	 JFCL
	HRRZ	1,SYSJFN
	CLOSF
	 JFCL
	POP	PP,1
	RET


SYSDN1:	HLRZ	1,SYSJFN
	CLOSF	;CLOSE  JFN FOR READING & RELEASE
	 JFCL
	HRRZ	1,SYSJFN
	HRLI	1,400000
	CLOSF		;CLOSE WRITING ONE, DON'T RELEASE. IT'S CLOSED
	 JFCL		;SECOND TO GET EOF RESET TO END.
	HRRZ	6,SYSJFN	;PARAM FOR MBOOT.
	JRST	MBOOT

;"Return" from MAKESYS or SYSOUT when it's run.
SYSINR:	HRRZI	1,400000
	MOVE	2,[XWD 2,EVEC]
	SEVEC
	HRRZ	1,MYJFNS
	JUMPE	1,MKSYSA		;MAKESYS
	MOVE	1,[XWD MYFRKS+1,SWFRKS]	;CROCK: 1ST FORK IN MYFRKS
			;ACTUALLY MAINFORK (400000)

	HRRZI	2,SWFRKS-1
	BLT	1,NSWFRKS(2)
	MOVE	1,[XWD GCAC2,10]
	BLT	1,17
	MOVE	F,TFLGS
	SETZM FR		;SET CURRENT FILES TO TTY
	MOVEI 1,1
	MOVEM 1,FP
	MOVSI 3,-NFILES+2	;CLEAR FILE TABLE
	SETZM FILEA+2(3)
	AOBJN 3,.-1
	TIME
	MOVEM	1,LOGTOD
	GETJRT
	MOVEM	1,LOGRT
	SETZM	GCRT
	CALL	SETTRP		;MAGIC PP OVERFLOW PAGE-INIT PROTECTION
	CALL	RESTCB		;Restore swapping buffer.
;	JSYS	BRREST		;I have taken this out N times now.
				;I keep putting it back, but it is
				;unnecessary & wrong, given RESTCB.
	CALL	SETINT
	CALL	SETMOD
	HLRZ	1,MYJFNS
	CALL	FILNM
	PUSH	PP,1
	HRRZ	1,MYJFNS
	JUMPN	1,.+2
	 SKIPA	1,KNIL
	CALL	FILNM
	POP	PP,2
	JRST	CONS

SYSMAP:	SETZB	1,ZPAGE		;ITERATE THRU PP 0 TO ENDCOR ON ZPAGE
	SETZM	LPAGE		;COUNT # PP IN A ROW TO BE SAVED

SYMP1:	SKIPN	2,TYPTAB(1)
	 JRST	SYMPDN
	ANDI	2,77(3)	;BITS_0 IF MAKSYS SO SAVES ALL
	TRNE	2,SYSBIT+PVTBIT	;SAVE IF SYSBIT=0 OR PVTBIT=1
	TRZE	2,PVTBIT	;BOTH BITS NOW CLEAR FOR CAMN
	CAMN	2,BTABT		;NEVER SAVE BITTABLE PAGES
	 JRST	SYMPNX
	CAMN	1,PPTRP		;DON'T SAVE PDLOV TRAP PAGE
	 JRST	SYMPNX
	SKIPN	CBSIZE		;IF THERE'S A SWAPPING BUFFER,
	 JRST	SYMP2
	CAMG	1,CBRANG+1	;DON'T SAVE SWAPPING BUFFER
	CAMGE	1,CBRANG
	 SKIPA	2,CBTHED	;OR CORE BUFFER TABLE PAGE
	 JRST	SYMPNX
	CAIN	1,(2)
	 JRST	SYMPNX
SYMP2:	HRLI	1,400000
	RPACS
	TLNE	2,10000		;PAGE MUST EXIST TOO
	 AOSA	LPAGE		;COUNT 1 GOOD PAGE TO EMIT.
SYMPNX:	CALL	SMEMIT		;EMIT 'EM WHEN FIND 1ST BAD 1
	AOS	1,ZPAGE		;READY TO CHECK NEXT PAGE
	JRST	SYMP1

SMEMIT:	SKIPN	1,LPAGE		;COUNT PP THIS BLOCK
	 RET			;NONE
	HRRZ	2,ZPAGE
	SUBI	2,(1)		;RH=1ST PAGE IN GROUP
	HRLI	2,(1)		;LH=COUNT
	HRRZ	1,SYSJFN
	BOUT
	SETZM	LPAGE
	RET

SYMPDN:	CALL	SMEMIT		;MAKE SURE BLOCK CLOSED OUT
	AOS	1,ZPAGE		;COUNT TO NEXT IN CASE REALLY
	HRRZI	2,(1)		;NOT DONE
	LSH	2,LPS
	CAMG	2,ENDCOR
	 JRST	SYMP1

;NOW FOR SHADOW

	SETZM	LPAGE
	SETZB	1,ZPAGE
SMSHLP:	CALL	GFRKB
	CAIN	2,FSYSBT		;SAVE IF PVTBIT 1 OR SYSBIT 0
	 JUMPN	3,SMSHNX		;OR IF A MAKESYS
	HLRZ	2,1
	LSH	1,-LPS
	ANDI	1,777
	HRL	1,SWFRKS(2)
	SKIPN	SWFRKS(2)		;NOTHING HAS EVER BEEN SWAPPED
	 JRST	SMSHNX			;I ASSUME. IF SO WON'T LOOK FAR.
	RPACS
	MOVE	1,ZPAGE
	TLNE	2,10000
	 AOSA	LPAGE
SMSHNX:	 CALL	SHEMIT
	HRRZI	1,1000
	ADDB	1,ZPAGE
	CAMLE	1,HISHAD
	 JRST	SMSHDN
	TRNN	1,777000		;IF NEXT PAGE 1ST IN ITS FORK
	 CALL	SHEMIT			;FORCE,
	JRST	SMSHLP

SHEMIT:	SKIPN	2,LPAGE
	 RET
	SETZM	LPAGE
	LSH	1,-LPS
	ANDI	1,777
	SUBI	1,(2)
	HRLI	1,(2)		;1 = COUNT,FORKPAGE
	MOVE	2,ZPAGE
	SUBI	2,1000		;ONLY MATTERS IF FORKBOUND FORCED EMIT.
	LSH	2,-LPS
	ANDI	2,17000		;GOT THE FORK BITS, BUT MUST OFFSET
	ADDI	2,1000		;BY 1 FOR SYSOUT TO DISTINGUISH MAINFRK
	IOR	2,1
	HRRZ	1,SYSJFN
	BOUT
	MOVE	1,ZPAGE
	RET

SMSHDN:	CALL	SHEMIT
	HRRZ	1,SYSJFN
	SETZ	2,
	BOUT			;TERMINAL 0
	RET


SYSIN:	CALL	IOFN
	MOVSI	1,(1B2+1B17)
	GTJFN
	 JRST	[HRRZ	2,-2(PP)
		 JRST	OPNER3]
	HRRZI	6,(1)
	HRLZI	1,100001
	HRROI	2,[ASCIZ /<LISP>BOOT.SAV/]
	GTJFN
	 JRST	[HRROI	1,[ASCIZ /NO BOOTSTRAP/]
		 PSOUT
		 JRST	FALSE]
	HRLI	1,400000
	GET
	HRRZI	1,(6)
	JRST	777000

U	SYSFIL
U	SYSJFN
U	ZPAGE
U	LPAGE
U	ZORGJQ		;FLAG DURING SYSOUT/MAKESYS SEZ WHICH
			;IS HAPPENING


MYJFN:	HLRZ	1,MYJFNS
	JUMPE	1,.+2
	AOS	(CP)
	RET

;SETUP FOR INPUT FUNCTION

IFSET:	MOVEI FX,FIN		;CHARACTER INPUT ROUTINE
	MOVEM FX,RDAX		;INPUT DISPATCH
	CAMN 1,KNIL		;STANDARD FILE?
	JRST IFS3		;YES
	LDT	5,1
	CAMN	5,STPTT		;IS IT A STRING?
	JRST	IFS6		;YES
	CALL IFSCH		;SEARCH TABLE FOR INPUT FILE
	JRST ILLIF		;FAILS
IFS5:	MOVEI FX,0(3)
IFS2:	MOVEM FX,FRX
	RET

IFS6:	MOVEI	FX,STRIN	;STRING INPUT ROUTINE
	MOVEM	FX,RDAX		;INPUT DISPATCH
	MOVEI	FX,NFILES	;FILE NUMBER FOR STRING INPUT
	HRRZ	5,FILEA(FX)
	CAIN	1,(5)		;SAME STRING AS BEFORE?
	JRST	.+3
	SETZM	FCHAR(FX)	;NO - CLEAR THE BACKUP CHARACTER
	SETZM	FILEA(FX)
	HRRM	1,FILEA(FX)
	JRST	IFS2

IFS3:	MOVE FX,FR		;USE STANDARD INDEX
	JRST IFS2

;SEARCH OPEN FILE TABLE FOR NAME OF INPUT FILE

IOFSCH:	MOVEI 5,600000		;SEARCH FOR I/O FILE
	SKIPA
IFSCH:	MOVEI 5,400000		;SEARCH FOR INPUT  FILE
	PUSH PP,2		;READ AND FRIENDS WILL HAVE READTBL HERE
	PUSH PP,1
IFSC3:	MOVSI 3,-NFILES
IFSC1:	HLRZ 4,FCHAR(3)
	ANDI 4,0(5)
	CAIE 4,0(5)		;RIGHT TYPE?
	JRST IFSC2		;NO, IGNORE
	HRRZ 4,FILEA(3)		;GET NAME
	CAIN 4,0(1)
	JRST IFSCG		;FOUND, RETURN SKIPPING
IFSC2:	AOBJN 3,IFSC1
IFE TEN50,<
	TLON 5,1
	CALL IFREC		;TRY AGAIN WITH RECOGNIZED NAME
	JRST IFSCB		;ILLEGAL NAME OR NO JFNS AVAIL
	JRST IFSC3
>
IFSCB:	POP PP,1		;NOT FOUND RETURN NO-SKIP, ORIG ARG
	POP PP,2		;RESTORE READTABLE
	RET

IFSCG:	SUB PP,BHC+1		;FOUND - RETURN FULL NAME
	POP PP,2		;RETORE READTABLE
	JRST RSKP		;AND SKIP

;SETUP FOR OUTPUT FUNCTION

OFSET:	MOVEI FX,FOUT		;CHARACTER OUTPUT ROUTINE
	MOVEM FX,PREX		;OUTPUT DISPATCH
	CAMN 2,KNIL		;STANDARD FILE?
	JRST OFS3		;YES
	CALL OFSCH		;SEARCH TABLE FOR NAME
	JRST OFS4		;NOT FOUND
OFS5:	MOVEI FX,0(3)		;INDEX
OFS2:	MOVEM FX,FPX
	RET

OFS4:	PUSH PP,1		;TRY I/O FILE
	MOVEI 1,0(2)
	CALL IOFSCH
	JRST ILLIF		;NO FOUND - GIVE UP
	MOVEI 2,0(1)
	POP PP,1
	JRST OFS5

OFS3:	MOVE FX,FP		;USE STANDARD FILE
	JRST OFS2

;SEARCH OPEN FILE TABLE FOR NAME OF OUTPUT FILE

OFSCH:	TRZ 5,1		;SEARCH FOR OUPUT  FILE
	PUSH PP,2
OFSC3:	MOVSI 3,-NFILES
OFSC1:	HLRZ 4,FCHAR(3)
	ANDI 4,200000
	CAIE 4,200000
	JRST OFSC2
	HRRZ 4,FILEA(3)		;GET NAME
	CAIN 4,0(2)
	JRST OFSCG		;FOUND, RETURN SKIPPING
OFSC2:	AOBJN 3,OFSC1
IFE TEN50,<
	TRON 5,1
	CALL OFREC		;NOT FOUND - TRY FULL NAME
	JRST OFSCB		;ILLEGAL NAME OR NOT FOUND
	JRST OFSC3
>
OFSCG:	SUB PP,BHC+1		;FOUND, RETURN SKIP WITH FULL NAME
	JRST RSKP
OFSCB:	POP PP,2		;NOT FOUND - RETURN ORIG. NAME
	RET

ILLOF:	MOVEI 1,0(2)
ILLIF:	ERROR1 15,RESET

FSCH:	MOVSI 3,-NFILES		;SEARCH FOR INPUT OR OUTPUT FILE
FSC1:	HRRZ 4,FILEA(3)
	CAIN 4,0(1)
	JRST RSKP
	AOBJN 3,FSC1
	CALL IFSCH
	SKIPA
	JRST RSKP
	MOVEI 2,0(1)
	CALL OFSCH
	RET
	MOVEI 1,0(2)
	JRST RSKP

;GIVEN JFN IN 1, GET FULL NAME OF FILE

IFE TEN50,<
FILNM:	MOVEI 2,0(1)		;JFN
	MOVE 1,IOFNMP
	MOVSI 3,(2B2+2B5+1B8+1B11+1B14)
	HRRI 3,1
	JFNS			;GET STRING
	CALL PACS		;SETUP TO MAKE ATOM
	MOVE 3,1
	MOVE 4,IOFNMP
FILNM1:	CAMN 3,4
	JRST MKATM		;MAKE ATOM
	ILDB 1,4
	CALL PAC
	JRST FILNM1

;GET FULL NAME OF INPUT FILE

IFREC:	CALL IOFN
	MOVSI 1,(1B2+1B17)	;OLD FILE - SHORT FORM
IFREC1:	GTJFN
	JRST FALSE		;BAD NAME OR NO JFNS
	PUSH PP,1		;SAVE JFN
	PUSH NP,5
	CALL FILNM		;GET FILE NAME
	POP NP,5
	EXCH 1,0(PP)
	RLJFN			;RELEASE JFN
	JFCL
	POP PP,1		;NAME
	JRST RSKP

;GGET FULL NAME OF OUTPUT FILE

OFREC:	PUSH PP,1
	MOVEI 1,0(2)
	CAMN 1,KLPT		;LPT IS A CROCK
	JRST OFREC3
	CALL IOFN
	MOVSI 1,(1B0+1B17)		;FOR WRITING - SHORT FORM
	CALL IFREC1
	SKIPA
OFREC3:	AOS 0(CP)
	MOVEI 2,0(1)
	POP PP,1
	RET
>
;GET FOLL NAME OF FILE FOR INPUT


INFILP:	IFE TEN50,<
	CALL IFREC
	JRST FALSE
	RET
>
IFN TEN50,<
	CALL IFSCH
	JRST FALSE
	RET
>

;GET FULL NAME OF FILE FOR OUTPUT

OUFILP:	MOVEI 2,0(1)
IFE TEN50,<	CALL OFREC
>
IFN TEN50,<	CALL OFSCH
>
	JRST FALSE
	MOVEI 1,0(2)
	RET

;OPEN FILE FOR INPUT

INFILE:	CALL IFSCH		;FILE ALREADY OPEN?
	CAMN 1,KNIL		;OR NO NAME GIVEN?
	JRST SETINF		;THEN SET STANDARD FILE ONLY
	PUSH PP,1		;SAVE NAME
	CALL IOFN		;SETUP NAME STRING FROM ATOM
	MOVEI 4,0		;USE MODE 0
	CALL INFIL		;OPEN FILE
IFN TEN50,<	JRST OPNER2	;ERROR RETURN>
	CALL IOGB		;ASSIGN SLOT IN FILE TABLE
	MOVSI 1,400000
	MOVEM 1,FCHAR(2)		;INPUT FILE HAS BIT 0=1
	MOVEI FX,0(2)
	JRST INPUT2
IFN TEN50,<
OPNER2:	POP PP,1
	ERROR1 11,RESET
>

;SET STANDARD INPUT FILE

SETINF:	MOVE FX,FR
	CAMN 1,KNIL		;IF NO NAME GIVEN,
	JRST INPUT1		;RETURN NAME OF CURRENT STANDARD FILE
	CALL IFSET		;LOOKUP NAME
INPUT2:	EXCH FX,FR		;STANDARD FILE INDEX
INPUT1:	HRRZ 1,FILEA(FX)	;GET FILE NAME
	RET

;OPEN FILE FOR OUTPUT

OUFILE:	MOVEI 2,0(1)
	CALL OFSCH		;FILE ALREADY OPEN?
	CAMN 1,KNIL		;OR NO NAME GIVEN?
	JRST SETOUF		;THEN SET STANDARD FILE ONLY
	PUSH PP,1
	CALL IOFN		;SETUP NAMD STRING FROM ATOM
	MOVEI 4,0		;MODE 0
	CALL OUTFIL		;OPEN FILE
IFN TEN50,<	JRST OPNER2>
	CALL IOGB		;ASSIGN SLOT IN FILE TABLE
	MOVSI 1,200000		;SET BIT 1 IN FCHAR FOR OUTPUT FILE
	MOVEM 1,FCHAR(2)
	MOVEI FX,0(2)
	JRST OUTPU2

;SET STANDARD OUTPUT FILE

SETOUF:	MOVE FX,FP
	CAMN 1,KNIL		;IF NO NAME GIVEN
	JRST OUTPU1		;RETURN NAME OF CURRENT STANDARD FILE
	MOVEI 2,0(1)
	CALL OFSET		;LOOKUP NAME
OUTPU2:	EXCH FX,FP		;STANDARD FILE INDEX
OUTPU1:	HRRZ 1,FILEA(FX)	;GET NAME
	RET

;CLOSE FILE

CLOSLF:	CAMN 1,KNIL
	JRST CLOS2		;NO NAME GIVEN, TRY STANDARD FILE
	CALL FSCH		;INPUT OR OUTPUT FILE?
	JRST ILLIF		;NO, ERROR
CLOS3:	HRRZ 1,FILEA(3)
	PUSH PP,1		;SAVE NAME FOR VALUE
	MOVEI 2,0(3)		;CHECK FOR ONE OF TWO STANDARD FILES
	CAMN 2,FR		;INPUT?
	SETZM FR		;YES, RESET TO TTY
	MOVEI 1,1
	CAMN 2,FP		;OUTPUT?
	MOVEM 1,FP		;YES, RESET TO TTY
	CAIG 2,1
	JRST CLOS4		;DON'T CLOSE TTY
	SETZM FILEA(2)
	HRRZ 1,FILEN(2)		;FILE NUMBER
	CALL CLOSEF		;SYSTEM CLOSE FILE
CLOS4:	POP PP,1		;RETURN NAME OF FILE CLOSED
	RET

CLOS2:	SKIPE 3,FR		;STND INPUT FILE NOT TTY?
	JRST CLOS3		;YES, CLOSE IT
	MOVE 3,FP
	CAIE 3,1		;STND OUTPUT FILE NOT TTY?
	JRST CLOS3		;YES, CLOSE IT
	JRST FALSE		;NO FILE TO CLOSE

CLSALL:	MOVSI 3,-NFILES		;CLOSE ALL FILES
	SKIPE FILEA(3)
	CALL CLOS3
	AOBJN 3,.-2
	JRST FALSE

UCLSAL:	CALL OPNLST		;USER CLOSEALL
	PUSH PP,1
	CALL CLSALL
	POP PP,1
	RET

OPNLST:	HRRZ 1,KNIL
	MOVSI 5,-NFILES+2
OPNLS2:	SKIPN 2,FILEA+2(5)
	JRST OPNLS1
	EXCH 1,2
	CALL CONS
OPNLS1:	AOBJN 5,OPNLS2
	RET

;OPEN FILE FOR INPUT AND OUTPUT

IFE TEN50,<
IOFILE:	CALL IOFSCH
	JRST IOFIL1		;ALREADY THERE
	MOVEI FX,0(3)
	JRST INPUT1
IOFIL1:	PUSH PP,1
	CALL IOFN
	MOVEI 4,0
	CALL IOFIL
	CALL IOGB
	MOVSI 1,600000
	MOVEM 1,FCHAR(2)
	MOVEI FX,0(2)
	JRST INPUT1

;OPEN FILE - BITS GIVEN

OPENF:	PUSH PP,1
	MOVEI 1,0(2)
	CALL IUNBOX		;BITS
	PUSH NP,1
	HRRZ 1,0(PP)
	STE 1,ATOM		;FILE NAME?
	JRST OPEN1		;NO ASSUME JFN
	CALL IOFN
	MOVSI 1,(1B2+1B17)	;OLD FILE
	MOVE 3,0(NP)
	TRNN 3,220000		;READ OR APPEND?
	MOVSI 1,(1B0+1B17)	;NO - GET FOR WRITING
	GTJFN
	JRST OPNER1		;BAD NAME OR NO JFNS
	SKIPA
OPEN1:	CALL IUNBOX
	MOVE 2,0(NP)
	MOVEI 4,0(1)
	OPENF
	 JRST OPNB		;WONT OPEN
	CALL IOGB
	POP NP,1
	TRNE 1,020000		;IF APPEND
	TRO 1,100000		;... SET WRITE
	LSH 1,1
	ANDI 1,600000
	HRLZM 1,FCHAR(2)	;SAVE READ&WRITE BITS
	HRRZ 1,FILEA(2)		;FULL NAME
	RET


;GET JFN OF OPEN FILE

OPNJFN:	CALL OPENP
	CAMN 1,KNIL
	JRST OPNJX
	HRRZ 1,FILEN(3)
	JRST MKN

OPNJX:	HRRZ 1,-2(PP)
	JRST ILLIF
>	;END OF IFE TEN50

;I-O LOCAL SUBR'S

;SETUP FILE NAME STRING FROM ATOM

IFN TEN50,<
IOFN:	STE 1,ATOM		;ATOM?
ARGNA:	ERROR1 16,RESET		;NO, ERROR
	HLRZ 1,2(1)		;GET PNAME
	CALL UPATM		;SETUP BYTE POINTER AND COUNT
	MOVEI 1,IOFNC
	CALL RFNM		;NAME PARSING ROUTINE
	JUMPN 1,.+2		;DEVICE SUPPLIED?
	MOVE 1,[SIXBIT /DSK/]	;NO, USE DISC
	RET

IOFNC:	CALL UPA		;CALL FROM RFNM
	MOVEI 1,EOL		;USE EOL FOR TERMINATOR
	RET
>

;ASSIGN SLOT IN OPEN FILE TABLE - JFN IN 1, NAME ON PP

IOGB:	MOVSI 2,-NFILES
	SKIPN FILEA(2)		;AVAILABLE ENTRY?
	JRST IOGB1		;YES
	AOBJN 2,.-2		;NO
	ERROR0 17,RESET		;TOO MANY FILES OPEN

IOGB1:IFN TEN50,<	POP PP,FILEA(2)		;STORE NAME IN TABLE
>
	MOVEM 1,FILEN(2)	;FILE NUMBER
	SETZM CHPOS(2)		;CLEAR STATE WORDS
IFE TEN50,<	EXCH 2,0(PP)
	CAMN 2,KLPT		;YEECH - LPT CROCK
	SKIPA 1,2
	CALL FILNM		;GET FULL FILE NAME
	POP PP,2
	MOVEM 1,FILEA(2)
>
	RET

IFE TEN50,<
IOFN:	STN 1,ATOM
	JRST ARGNA+1
	STE 1,STRNG
ARGNA:	ERROR1 16,RESET
	HLRZ 1,2(1)
	CALL UPATM
	MOVE 7,IOFNMP
IOFN1:	CALL UPA		;SETUP STRING FOR GTJFN FROM ATOM
	JRST IOFN2		;ATOM FINISHED
	IDPB 1,7
	JRST IOFN1

IOFN2:	SETZ 1,
	IDPB 1,7		;NULL MARKS END OF STRING
	MOVE 2,IOFNMP
	RET

IOFNMP:	POINT 7,IOFNM,-1

U IOFNM,20

IOFIL:	MOVEI 3,1B19+1B20	;READ AND WRITE BITS
	SKIPA
INFIL:	MOVEI 3,1B19		;READ BIT FOR OPENF
	MOVSI 1,(1B2+1B17)	;OLD FILE BIT+SHORT FORM BIT
OPNFIL:	GTJFN
	JRST OPNER1		;ERROR
	HRRZS 4,1		;CLEAR LH
	MOVEI 2,0(3)		;GET OPENF FLAGS
	HRLI 2,(7B5)		;ASCII CHARACTER SIZE
	OPENF
	JRST OPNB
	RET

OPNB:	CAIN 1,OPNX1		;ALREADY OPEN?
	JRST OPNER2		;YES
	MOVEI 1,0(4)		;NO - RELEASE JFN
	RLJFN
	JFCL
OPNER2:	POP PP,1
	ERROR1 11,RESET

OPNER1:	POP PP,2
OPNER3:	EXCH 1,2
	CAIE 2,GJFX23
	ERROR1 27,RESET
	ERROR1 26,RESET		;DIRECTORY FULL

OUTFIL:	MOVSI 1,(1B0+1B17)	;FOR WRITING BIT+SHORT FORM BIT
	MOVEI 3,1B20
	JRST OPNFIL

CLOSEF:	CLOSF
	JFCL
	RET

>

;NUMBER PRINTERS

PNO8:	MOVEI 2,10	;OCTAL TO TTY
	JRST PNO10+1

PNO10:	MOVEI 2,^D10	;DECIMAL TO TTY
	MOVEI FX,0
	MOVEI 3,TCO
	MOVEM 3,PREX

APT:	MOVEI 3,0		;CHAR COUNT
	MOVEI 4,0		;PREFIX
APTX:	MOVEM 2,APTR	;ANY RADIX OUT VIA PREC
APT1:	LSHC 1,-^D35
	LSH 2,-1
	DIV 1,APTR
	HRLM 2,0(CP)
	ADDI 3,1
	JUMPE 1,APT4
	PUSHJ CP,APT1
APT2:	HLRZ 1,0(CP)
	ADDI 1,60

PREC:	JRST @PREX		;TCO, FOUT OR INTERNAL SUBR
APT4:	JUMPL FX,APT5		;REAL FILE
	HRRZ 1,CHPOS(FX)
	ADDI 1,0(3)
	CAMLE 1,LINSIZ
	TCH EOL
APT5:	JUMPE 4,APT2
	TCH 0(4)
	JRST APT2

CHACCT:	CAIGE 1,40		;COUNT CHARS AND LINES
	JRST PRECC
PREC1:	AOS CHPOS(FX)
	RET

PRECC:	CAIE 1,EOL
	CAIN 1,15
	JRST PRECR
	AOS CHPOS(FX)
	JRST PREC1

PRECR:	HLLOS CHPOS(FX)
	JRST PREC1

;OUTPUT CHARACTER TO FILE

FOUT:	CALL CHACCT		;ACCOUNT CHARACTER
	PUSH CP,2
	HRRZ 2,FILEN(FX)	;FILE NUMBER
IFN TEN50,<
	CAIN 2,1		;TTY?
	JRST FOUTT		;YES
	BOUT
FOUTT1:
>
IFE TEN50,<
	EXCH 1,2
	CAIN 2,EOL
	JRST FOUT1
	BOUT
FOUT2:	EXCH 1,2>
	POP CP,2
	RET

;INPUT CHARACTER FROM FILE

FIN:	JUMPE FX,GCHIT		;TTY (LINE BUFFERED) INPUT
FIN1:	PUSH CP,2
IFN TEN50,<
	HRRZ 2,FILEN(FX)	;FILE NUMBER
	JUMPE 2,FINT		;HANDLE TTY SPECIAL
	BIN
	MOVEM 2,FILEN(FX)	;STORE FLAGS
	POP CP,2
	SKIPL FILEN(FX)	;SPECIAL FILE STATUS (EOF) ?
	JRST CHACCT
	MOVEI 3,0(FX)		;YES,
	CALL CLOS3		;CLOSE FILE
	ERROR1 20,RESET		;AND ERROR

FINT:	TTCALL 0,1
	CAIE 1,15
	JRST FINT1
	TTCALL 0,1
	MOVEI 1,EOL
FINT1:	POP CP,2
	MOVEI FX,1		;NO, ACCOUNT CHARS AS FOR OUTPUT
	CALL CHACCT
	MOVE FX,FRX
	RET

FOUTT:	CAIN 1,EOL
	JRST FOUTE
	TTCALL 1,1
	JRST FOUTT1

FOUTE:	MOVEI 1,15
	TTCALL 1,1
	MOVEI 1,12
	TTCALL 1,1
	MOVEI 1,EOL
	JRST FOUTT1
>	;END OF IFN TEN50

IFE TEN50,<
	HRRZ 1,FILEN(FX)	;GET JFN
FIN3:	BIN
	JUMPE 2,FIN2		;PROBABLY EOF
	CAIE 2,15		;CR?
	JRST FIN4		;NO
	BIN			;FLUSH FOLLOWING LF
	CAIE	2,12		;MAKE SURE IT IS A LF
	JRST FIN5		;NOT LF, BACKUP ONE
	MOVEI 2,EOL		;USE EOL
FIN4:	MOVE 1,2
	POP CP,2
	JUMPN FX,CHACCT		;GO ACCOUNT CHARACTER
	MOVEI FX,1		;IF TTY IN,
	CALL CHACCT		;ACCOUNT AS FOR TTY OUT
	MOVE FX,FRX
	RET
FIN5:	BKJFN			;CR WITH NO LF, BACKUP ONE CHAR
	 JFCL			;(HOW CAN IT FAIL?)
	MOVEI 2,15		;RETURN C.R.
	JRST FIN4

FOUT1:	MOVEI 2,15		;CONVERT TO CR,LF
	BOUT
	MOVEI 2,12
	BOUT
	MOVEI 2,EOL
	JRST FOUT2

FIN2:	GTSTS
	TLNN 2,1B26		;EOF?
	JRST FIN3
	MOVEI 3,0(FX)		;YES
	CALL CLOS3		;CLOSE FILE
	ERROR1 20,RESET
>

;RED A CHAR FROM A STRING
; THE STRING POINTER IS KEPT IN BOXED FORM ONLY SO THAT
; WE ARE OK IF A GC OCCURS AND THE STRING MOVES
STRIN:	HRRZ	7,FILEA(FX)	;GET THE STRING
	MOVE	3,(7)
	USBPC	1,3
	SOJL	2,STREOF	;EMPY STRING
	ADD	3,[-7777777]	;LENGTH-1 & CHAR POS + 1
	MOVEM	3,0(7)		;RESTORE STRING POINTER
	ILDB	1,1		;GET THE CHAR OUT
	RET
STREOF:	ERROR0	20,RESET	;GIVE AN END OF FILE ERROR

U PREX
U APTR

;INITIAL OBLIST
	;NM IS ATOM NAME, F IS LOC OF FUNCTION CODE IF ANY,
	;L IS LOC OF CELL TO RECEIVE ATOM IF ANY
	;T IS FN TYPE

	DEFINE ATM (NM,F,L,T)
<	SIXBIT /NM /
	IFB <T>,<XWD F,L>
	IFNB <T>,<XWD T*40000+F,L>
	NIATOM==NIATOM+1>

NIATOM==0

FOO:
LOC ENDTMP
IATOMS=ENDTMP
	ATM <NIL>,,KNIL
	ATM <NOBIND>,,KNOB
	ATM <T>,,KT
	ATM <.>,,KPER
	ATM <LAMBDA>,,KLAM
	ATM <NLAMBDA>,,KNLA
	ATM <FUNARG>,,KFNARG
	ATM <LPT:>,,KLPT
	ATM <READX>,READX,KREADX
	ATM <PRINTX>,PRINTX,KPRINT
	ATM <APPLYX>,APPLY,KAPPLY
	ATM <APPLY*>,APPLY.,KAPP.,2
	ATM <EVALQT>,EVALQT,KEVLQT
	ATM <INTERRUPT>,APPLY,KINT
	ATM <FAULTEVAL>,FAULTX,KFAULT,3
	ATM <FAULTAPPLY>,FAULTX,KFALTA,3
	ATM <FNCLOSER>,FNCLSR
	ATM <FNCLOSERA>,FNCLSA
	ATM <FNCLOSERD>,FNCLSD
	ATM <FNOPENR>,FNOPNR
	ATM <FNOPENRA>,FNOPNA
	ATM <FNOPENRD>,FNOPND
	ATM <ECHOMODE>,ECHMOD
	ATM <ERRORX>,ERRX,KERRX
	ATM <ESGAG>,,KESGAG
	ATM <SYSHASHARRAY>,,KSYSHS
	ATM <PRXFLG>,,KPRXFL

	ATM <ALLOCATE>,ALLOCA
	ATM <AND>,AND,,3
	ATM <APPLY>,APPLY
	ATM <ARG>,ARGN,,1
	ATM <ARGTYPE>,ARGTY
	ATM <ARRAY>,ARRAY
	ATM <ARRAYBEG>,UFBA
	ATM <ARRAYP>,ARRAYP
	ATM <ASSED>,ASSED
	ATM <ATOM>,ATOM
	ATM <BACKTRACE>,UBAKTR
	ATM <BKLINBUF>,BKLNBF
IFE TEN50,<	ATM <BKSYSBUF>,BKSYSB
>
	ATM <BOXCOUNT>,BOXCNT
	ATM <SWPPOS>,SWPPOS
	ATM <CAR>,CAR
	ATM <CCODEP>,CCODEP
	ATM <CDR>,CDR
	ATM <CHARACTER>,CHRCT
	ATM <CHCON>,CHCON
	ATM <CHCON1>,CHCON1
	ATM <CLEARBUF>,UCLRBF
	ATM <CLRHASH>,CLRHSH
	ATM <CLOCK>,CLOCK
	ATM <CLOSEALL>,UCLSAL
	ATM <CLOSEF>,CLOSLF
	ATM <CLOSER>,CLOSER
	ATM <CONCAT>,CONCAT,,2
	ATM <COND>,COND,,3
	ATM <CONS>,CONS
	ATM <CONSCOUNT>,CONSCF
	ATM <CONTROL>,CONTRL
	ATM <COPYREADTABLE>,CPYRDT
	ATM <COPYTERMTABLE>,CPYTT
IFE TEN50,<
	ATM <CTRLC>,CTRLC
>
	ATM <DATE>,DATE
	ATM <DDT>,DDTC
	ATM <DEFEVAL>,DEFEVA
	ATM <DEFTYPE>,DEFTYP
	ATM <DISABLECHAR>,DISABL
	ATM <ELT>,ELT
	ATM <ELTD>,ELTD
	ATM <ENABLECHAR>,ENABLE
	ATM <EQ>,EQ
	ATM <EQP>,EQP
	ATM <ERROR>,ERROR
	ATM <ERRORM>,ERRORM
	ATM <ERRORN>,ERRORN
	ATM <ERRORSET>,ERRSET
	ATM <ERRORX1>,ERRX
	ATM <ERROR!>,ERRORF
	ATM <ESCAPE>,ESCP
	ATM <EVAL>,EVAL,KEVAL
	ATM <EVALA>,EVALA
	ATM <EXPRP>,EXPRP
	ATM <FGTP>,FGTP
	ATM <FLOATP>,FLOATP
IFE TEN50,<	ATM <FLTFMT>,FLTFMF
>
	ATM <FPLUS>,FPLUS,,2
	ATM <FQUOTIENT>,FQTENT
	ATM <FREMAINDER>,FRMNDR
	ATM <FTIMES>,FTIMES,,2
	ATM <FUNCTION>,CAR,,3
	ATM <GCGAG>,GCGAG
	ATM <GCTRP>,GCTRP
	ATM <GETD>,GETD
	ATM <GETBLK>,GETBLK
	ATM <GETBRK>,GETBRK
	ATM <GETHASH>,GETHSH
	ATM <GETNPTRS>,GTNPTR
	ATM <GETNWRDS>,GTNWRD
	ATM <GETSEPR>,GETSEP
	ATM <GETREADTABLE>,GETRDT
	ATM <GETTERMTABLE>,GETTY
	ATM <GLC>,GLC
	ATM <GNC>,GNC
	ATM <GO>,GO,,3
	ATM <GREATERP>,GRTRP
	ATM <HERALD>,HERALD
	ATM <HANDLEP>,HANDLP
	ATM <IGREATERP>,IGRTRP
	ATM <INFILE>,INFILE
	ATM <INFILEP>,INFILP
	ATM <INPUT>,SETINF,KINPUT
IFE TEN50,<
	ATM <IOFILE>,IOFILE
>
	ATM <IPLUS>,IPLUS,,2
	ATM <IQUOTIENT>,IQTENT
	ATM <IREMAINDER>,IRMNDR
	ATM <ITIMES>,ITIMES,,2
	ATM <JSYS>,UJSYS,,2
	ATM <LASTC>,LASTC
IFE TEN50,<
	ATM <LINBUF>,LINBUF
>
	ATM <LINELENGTH>,LINLTH
	ATM <LIST>,LIST,,2
	ATM <LISTP>,LISTP
	ATM <LITATOM>,LITATM
	ATM <LLSH>,LSHFT
	ATM <LOC>,MKN
	ATM <LOGAND>,LOGAND,,2
	ATM <LOGOR>,LOGOR,,2
	ATM <LOGOUT>,LOGOUT
	ATM <LOGXOR>,LOGXOR,,2
	ATM <LSH>,ASHFT
IFE TEN50,<
	ATM <MAKESYS>,MKSYS
>
	ATM <MAPATOMS>,MPATMS
	ATM <MINFS>,MINFS
	ATM <MINUS>,MINUS
	ATM <MINUSP>,MINUSP
	ATM <MKATOM>,MKATOM
	ATM <MKHANDLE>,UMKHDL
	ATM <MKSTRING>,MKSTR
	ATM <NALLOC>,NALLOC
	ATM <NCHARS>,NCHARS
	ATM <NCONC>,NCONC,,2
	ATM <NONAC>,NONAC
	ATM <NOT>,NULL
	ATM <NTHCHAR>,NTHCHR,,2
	ATM <NTYP>,NTYP
	ATM <NULL>,NULL
	ATM <NUMBERP>,NUMBRP
IFE TEN50,<
	ATM <OPENF>,OPENF
>
	ATM <OPENP>,OPENP
	ATM <OPENR>,OPENR
IFE TEN50,<
	ATM <OPNJFN>,OPNJFN
>
	ATM <OR>,OR,,3
	ATM <ORIG>,,KORIG
	ATM <OUTFILE>,OUFILE
	ATM <OUTFILEP>,OUFILP
	ATM <OUTPUT>,SETOUF,KOUTPU
	ATM <PACK>,PACK
	ATM <PACKC>,PACKC
	ATM <PEEKC>,PEEKC
	ATM <PLUS>,PLUS,,2
	ATM <POSITION>,POSITN
	ATM <PRIN1>,PRIN1
	ATM <PRIN2>,PRIN2
	ATM <PRINT>,PRINT
	ATM <PRINTLEVEL>,SETPLV
	ATM <PROG>,PROG,,3
	ATM <PROG1>,PROG1,,3
	ATM <PROG2>,PROGN,,3
	ATM <PROGN>,PROGN,,3
	ATM <PUTD>,PUTD
	ATM <PUTHASH>,PUTHSH
	ATM <QUOTE>,R,,1
	ATM <QUOTIENT>,QTENT
	ATM <RADIX>,RADIKS
IFE TEN50,<
	ATM <RAISE>,RAISE
>
	ATM <RATEST>,RATEST
	ATM <RATOM>,RATOM
	ATM <READ>,READ
	ATM <READC>,READC
	ATM <READMACROS>,RDMACS
	ATM <READP>,READP
	ATM <READTABLEP>,RDTBLP
	ATM <RECLAIM>,RECLM
	ATM <REHASH>,UREHSH
	ATM <RELBLK>,RELBLK
	ATM <RELOC>,REL
	ATM <REMAINDER>,RMNDR
	ATM <RESET>,RESET
	ATM <RESETREADTABLE>,RSTRDT
	ATM <RESETTERMTABLE>,RSTTBL
	ATM <RETEVAL>,RETEVL
	ATM <RETFROM>,RETFRM
	ATM <RETURN>,RETURN
	ATM <RPLACA>,RPLACA
	ATM <RPLACD>,RPLACD
	ATM <RPLSTRING>,RPLSTR
	ATM <RSTRING>,RSTRNG
	ATM <SCODEP>,SCODEP
	ATM <SET>,SET
	ATM <SETARG>,SETARG,,1
	ATM <SETBRK>,SETBRK
	ATM <SETERRORN>,SERRN
IFE TEN50,<
	ATM <SETINC>,SETINC
>
	ATM <SETREADTABLE>,SETRDT
	ATM <SETTERMTABLE>,TRMTBL
	ATM <SETSBSIZE>,SSBSIZ
	ATM <SETSEPR>,SETSEP
	ATM <SETQ>,SETQ,,3
IFE TEN50,<
	ATM <SFPTR>,SPTR
>
	ATM <SPACES>,SPACES
	ATM <STKARG>,STKARG
	ATM <STKCALL>,STKCAL
	ATM <STKEVAL>,STKEVL
	ATM <STKNAME>,STKNAM
	ATM <STKNARGS>,STKNRG
	ATM <STKNTH>,STKNTH
	ATM <STKPOS1>,STKPOS
	ATM <STKSCAN>,STKSCN
	ATM <STRINGP>,STRNGP
	ATM <SUBRP>,SUBRP
	ATM <SUBSTRING>,SUBSTR
IFE TEN50,<
	ATM <SWPARRAY>,SWPARY
	ATM <SYSBUF>,SYSBUF
	ATM <SYSIN>,SYSIN
	ATM <SYSOUT>,SYSOUT
>
	ATM <TERMTABLEP>,TTTBLP
	ATM <TERPRI>,TERPRI
	ATM <TIMES>,TIMES,,2
	ATM <TRAPCOUNT>,TRAPCT
	ATM <TYPESTATUS>,TYPSTS
	ATM <UNPACK>,UNPACK
	ATM <USED>,INUSE
	ATM <USERCONS>,USRCNS,,2
	ATM <VAG>,GUNBOX
RELOC FOO
;ONE-SHOT INIT, .START  OR  LISP0$G  FROM DDT AFTER LOADING

LISP0:	IFN TEN50,<
	MOVE 2,JOBFF
	ADDI 2,MPS
	TRZ 2,MPS
	MOVEM 2,BGNCOR		;USE FROM HERE UP FOR LISP DATA PAGES
	HRLM 2,JOBSA
	MOVEM 2,JOBFF
	MOVE 1,[JRST LISP1]
	MOVEM 1,EVEC
	MOVEI 1,EVEC		;ENTRY VECTOR
	HRRM 1,JOBSA
	HALTF
>
IFE TEN50,<
	MOVEI 2,ENDTMP		;LAST VARIABLE
	ADDI 2,MPS		;BUMP TO NEXT PAGE
	TRZ 2,MPS
	MOVEM 2,BGNCOR		;USE ABOVE FOR LISP DATA
	JRST LISP1

LISP00:	HRRZI 1,COREV	;IF COREV=140 YOU OMITTED "/1000O" TO LOADER
	CAIN 1,1000	;BEFORE LOADING LISP.REL IF IT'S 1000, THEN
	JRST .+4	;SUPPOSEDLY OK. OTHER VALUES VERY ODD INDEED.
	HRROI	1,[ASCIZ /COREV NOT RIGHT -- SEE LISP00 IN LISP.MAC/]
	PSOUT
	HALTF
	HRRZI	1,DATEWD
	CAIN	1,SYSDAT
	 JRST	.+4
	HRROI	1,[ASCIZ /DATEWD NEQ SYSDAT - SEE LISP00/]
	PSOUT
	HALTF
	HRRZI 1,BEGTMP
	CAILE 1,GCIE
	 JRST .+4
	HRROI 1,[ASCIZ /TIME TO RAISE BEGTMP AGAIN!!/]
	PSOUT
	HALTF
	MOVE 1,LISP0C
	MOVEM 1,EVEC+1
	HRRI 1,LISP0
	MOVEM 1,EVEC
	MOVEI 1,400000
	MOVE 2,[XWD 2,EVEC]		;DO ONCE BEFORE SAVE
	SEVEC
	HALTF

>
U EVEC,2		;ENTRY VECTOR


LISP2:	MOVE CP,ICP	;START AFTER INIT DONE
	MOVE PP,IPP		;INCASE PRIN1 IS CALLED BELOW
	SKIPE	SYSRDT		;HAVE A READTABLE?
	JRST	LSP2C		;YES
	MOVE 1,KORIG		;NO - RESET THE READTABLES
	CALL CPYRDT
	MOVEM 1,PRVIRT
	MOVEM 1,PRVORT
	MOVE 2,KT
	CALL SETRDT
	MOVE 1,KORIG
	CALL CPYRDT
	MOVE 2,KNIL
	CALL SETRDT
LSP2C:	SKIPE TTYTBL		;HAVE A TERMINAL TABLE?
	JRST .+4		;YES
	MOVE 1,KORIG		;NO - RESET THE TERMINA TABLE
	CALL CPYTT
	CALL TRMTBL
	HRRZ 3,TTYTBL
	MOVEI 1,100
	RFMOD
	TRNE 2,1B31		;IS RAISE MODE ON?
	SETZM RASMOD(3)		;YES, SET RAISE MODE TO 0.
	SKIPN	1,HLDMSG	;USER HERALD?
	JRST	LSP2B		;NO - PRINT NOTHING
	MOVE	2,KT		;YES - SET UP TO PRINT ON TTY
	CAMN	1,KT		;IS HERALD = T?
	JRST	LSP2A		;YES - PRINT STANDARD MESSAGE
	CALL	PRIN1		;NO - PRINT THE MESSAGE
	JRST	LSP2B
LSP2A:	TMSG LISPM1
LSP2B:	TIME
	MOVEM 1,LOGTOD
	GETJRT
	MOVEM 1,LOGRT
	SETZM GCRT
IFE TEN50,<
	CALL MYJFN
	 JRST LISP2S		;NOT MAKESYS
	CALL FILNM
	MOVE 1,IOFNM
	MOVE 2,IOFNM+1
	LSH 1,-1
	CAME 1,["<HACK"]
	JRST LISP2A
	LSH 2,-^D22
	CAIN 2,"S>"
	JRST RESETE
LISP2S:
	MOVE 1,[SIXBIT /LISP/]
	SETNM
>
LISP0C:	JRST RESETE

LISP2A:	CAME 1,["<SUBS"]
IFE TEN50,<
	JRST LISP2S
	LSH 2,-^D22
	CAIN 2,"YS"
	JRST RESETE
	JRST LISP2S
>

;INITIAL ENTRY - INITIALIZATION

LISP1:	SETZM TYPTAB		;ZERO TEMP STORAGE PAGE
	MOVE 1,[XWD TYPTAB,TYPTAB+1]
	BLT 1,BGNCOR-1
	MOVE 1,BGNCOR		;ASSIGN FIRST DATA PAGES TO STACKS
	MOVEI CP,-1(1)
	HRLI CP,-NCP
	MOVEM CP,ICP		;SAVE INITIAL VALUE
	MOVEI PP,NCP-1(1)
	HRLI PP,-NPP
	MOVEM PP,IPP
	MOVEI NP,NCP+NPP+NPS-1(1)
	HRLI NP,-NNP
	MOVEM NP,INP
	ADDI 1,NCP+NPP+NNP+NPS
	MOVEM 1,ENDCOR
	MOVEI 1,0(NP)
IFE TEN50,<
	SETZM 0(1)		;MAKE PAGE EXIST
	SUBI 1,105
	MOVEM 1,FTRAP		;MAGIC FREE VAR TRAP LOC
	HRLI 1,20
	MOVEM 1,IFTRAP		;INDIRECT VERSION OF ABOVE
	MOVEI 1,0(1)
>
	LSH 1,-LPS
	MOVEM 1,PPTRP		;READ ONLY PAGE TO CATCH PP OVF
				;..IN TEN50 JUST USED BY GC
	JSP 7,SETSPC
	MOVSI F,1		;FLAGS
	MOVE 1,POPDSP		;SETUP UUO DISPATCH
	MOVEM 1,41
	MOVEI 1,LISP2
	HRRM 1,EVEC		;RESET ENTRY VECTOR
IFE TEN50,<
	MOVE 1,SYSBFP
	MOVEM 1,CSYSBP
	MOVE 1,SLNBFP
	MOVEM 1,CSLNBP
>
	MOVE CP,IIP

IFN TEN50,<
	CALL FINIT		;INIT FILE PACKAGE
	MOVE 1,[SIXBIT /TTY/]	;OPEN TTY FILES
	MOVEI 4,0
	CALL INFIL
	JRST 4,.
	MOVEM 1,FILEN
	MOVE 1,[SIXBIT /TTY/]
	MOVEI 4,0
	CALL OUTFIL
	JRST 4,.
	MOVEM 1,FILEN+1
	MOVEI 1,RSTRT		;ADDRESS FOR INTERRUPT CHARACTER RESTART
	HRRM 1,JOBREN
>
IFE TEN50,<
	MOVEI 1,100		;SETUP PRIMARY FILES
	MOVEM 1,FILEN
	CALL SETMOD		;SET TTY MODES
	MOVEI 1,101
	MOVEM 1,FILEN+1
>
	MOVSI 1,200000
	MOVEM 1,FCHAR+1
	MOVSI 1,400000
	MOVEM 1,FCHAR

;INIT STORAGE

	MOVSI 2,-NTYPES		;SETUP SYSTEM-DEFINED TYPE NUMBERS
	MOVS 1,TYPTI(2)
	HLRZM 1,0(1)
	AOBJN 2,.-2
	MOVE 2,[XWD -NTIE,TYPTE];SET UP EVATAB
	MOVE 1,(2)
	SETOM EVATAB(1)
	AOBJN 2,.-2
	MOVSI 5,-IST1N		;SETUP PRE-DEFINED PAGES
	MOVEI 4,0
IS1:	MOVEI 3,0
	HLRZ 2,IST1(5)		;SIZE OF PRE-DEFINED SPACE
	HRRZ 1,IST1(5)		;LOC OF TYPE NUMBER FOR SPACE
	MOVE 1,0(1)		;GET TYPE NUMBER
	HRRM 1,TYPTAB(4)	;STORE TYPE NUMBER IN TABLE
	ADDI 4,1		;COUNT INDEX OF TYPE TABLE
	ADDI 3,NPS		;COUNT WORDS IN SPACE
	CAIGE 3,0(2)		;DONE SUFFICIENT WORDS?
	JRST .-4		;NO
	AOBJN 5,IS1		;DO NEXT SPACE
	MOVE 1,BLOCKT		;SET TYPE FOR REMAINING LOW CODE AND STACKS
	MOVE 3,ENDCOR
	LSH 3,-LPS
	MOVEM 1,TYPTAB(4)
	ADDI 4,1
	CAIGE 4,0(3)
	JRST .-3


;INIT ATOM HASH TABLE

ISHT:	MOVE 1,ENDCOR
	MOVEM 1,ATOMHT
	MOVEI 7,NHT		;NUMBER OF PAGES IN HT
	MOVE 6,BLOCKT
	CALL ISTYP		;SET TYPE NUMBERS
	MOVEI 2,NHT*NPS-1	;SIZE OF TABLE
	MOVEM 2,@ATOMHT

;INIT LIST PAGES ETC.

	CALL GCI

;INITIALIZE PARAMETERS

	DEFINE INITI (A,B)
<	MOVEI 1,B
	MOVEM 1,A>

	RADIX 10
	SETZM FR		;STANDARD INPUT AND OUTPUT FILES
	SETZM BSTAB
	INITI FP,1
	SETOM	RMONF
	SETOM	ESCONF
	INITI MAXATL,NATMC
	INITI LINSIZ,70
	INITI URADIX,10
	INITI PPLVL,10000
	RADIX 8

IFE TEN50,<
	MOVSI 1,4000
	MOVEM 1,FLTFMC
>
	SETZM CTRLU
	MOVE	1,CTCTP		;SET STANDARD INTERRUPT CHARS
	MOVE	2,OCTCT-CTCT(1)
	MOVEM	2,(1)
	AOBJN	1,.-2

;INITIALIZE ATOMS

ATSET:	MOVEI 6,IATOMS
	MOVEI 1,NIATOM
	PUSH CP,1
ATSET2:	CALL PACS
	HRLI 6,440600
ATSET3:	ILDB 1,6
	JUMPE 1,ATSET1		;STRING TERMINATED WITH 0
	ADDI 1,40		;CONVERT TO ASCII
	CALL PAC
	JRST ATSET3

ATSET1:	PUSH CP,6
	CALL MKATM
	POP CP,6
	MOVE 2,1(6)		;XWD F,L
	TRNE 2,-1
	MOVEM 1,0(2)		;CELL TO CONTAIN ATOM
	TLNN 2,-1		;FUNCTION?
	JRST ATSET4		;NO
	LDB 3,[POINT 4,2,3]	;ARG TYPE BITS
	LSH 3,5			;SHIFT TO AC FIELD
	IORI 3,<HCCALV>B26	;SUBR CALLING INSTRUCTION
	HRLM 3,1(1)
	TLZ 2,740000		;TURN OFF BITS IN SUBR ADR
	HLRM 2,1(1)		;STORE ADDRESS OF CODE
ATSET4:	ADDI 6,2
	SOSLE 0(CP)
	JRST ATSET2
	POP CP,1		;FLUSH COUNT
	MOVE 1,KNIL		;FINISH SETUP OF EARLY ATOMS
	HRRM 1,0(1)
	HRLM 1,0(1)
	HRRM 1,1(1)		;CAR, CDR, AND FN OF NIL
	HRRM 1,@KPRXFL
	MOVE 1,KNOB
	HRRM 1,0(1)		;CAR OF NOBIND

	MOVE 1,KT
	HRRM 1,0(1)		;VALUE OF T
	HRRM 1,FILEA		;FILL IN CONTROL FILE NAMES
	HRRM 1,FILEA+1
	HRRZM 1,GCMESF
	HRRZM	1,HLDMSG
	HLLZS @KSYSHS
	SETOM FREBRK
	CALL CLRBUF
	MOVEM F,TFLGS
	JRST LISP2


LISPM1:	SIXBIT '$INTERLISP-16  10-10-74 .../'

;GET C(7) PAGES AND SET TYPE TO C(6)

ISTYP:	CALL GETPG
	JRST 4,.		;NO CORE
	LSH 1,-LPS
	MOVEM 6,TYPTAB(1)
	SOJG 7,ISTYP
	RET

;SETUP STACK CONSTANTS FROM INITIAL POINTERS

SETSPC:	HLRZ 1,IPP		;COUNT (NEG)
	SUB 1,IPP		;GIVES -(BGN+SIZ)
	HRLI 1,PP		;USED AS INDEX
	MOVEM 1,IPPC
	HLRZ 1,ICP		;SAME FOR CP
	SUB 1,ICP
	HRLI 1,CP
	MOVEM 1,ICPC
	HLRZ 1,INP		;AND NP
	SUB 1,INP
	HRLI 1,NP
	MOVEM 1,INPC
	JRST 0(7)

IFE TEN50,<
SETMOD:	SETZM INCTLA		;MAKE SURE ^A IS OFF
	HRRZ 3,TTYTBL
	MOVEI 1,100
	RFMOD
	TRZ 2,77B23+3B25+17B29
	IORI 2,16B23+2B25+5B31	;SET WAKEUP,ECHO,RAISE,AND ASCII
	TLZ F,LBFFLG+RASFLG
	SKIPN LBFLGW(3)		;LINE BUFFERING?
	JRST .+3		;YES
	TLO F,LBFFLG		;NO - SET FLAGS WORD
	TRO 2,10000		;NO - WAKEUP ON ALPHABETIC ALSO
	SKIPN ECHMDW(3)		;ECHO INPUT?
	TRZ 2,2B25		;NO
	SKIPLE 4,RASMOD(3)	;INTERNAL RAISE?
	TLO F,RASFLG		;YES
	SKIPE 4			;RAISE AT 10X LEVEL?
	TRZ 2,1B31		;NO
	SFMOD
	MOVEI 1,-1		;SET THE ACTUAL TTY
	STPAR
	MOVEI 1,100
	MOVE 2,CCOCW1(3)
	MOVE 3,CCOCW2(3)
	SFCOC
	RET

SETINT:	MOVEI 1,400000		;THIS FORK
	EIR
	MOVE 2,[XWD LEVTAB,CHNTAB]
	SIR			;INIT PSI SYSTEM
	MOVE 2,AICC
	AIC			;ACTIVATE CHANNELS
	MOVE 7,CTCTP
	MOVE 1,0(7)		;CHARACTER AND CHANNEL
	TRZ	1,400000	;CLEAR "HARD" BIT
	TLNN	1,400000	;IS CHAR REALLY THERE?
	ATI			;YES - ACTIVATE TERMINAL INTERRUPT
	AOBJN 7,.-4
	RET

CTRLC:	MOVSI 1,400000
	MOVSI 3,400000
	EPCAP			;ENABLE ABILITY TO
	MOVE 1,CTCTC		;ACTIVATE CONTROL C
	ATI
	JRST FALSE

AICC:	XWD 770407,447777

SETTRP:	MOVE 1,PPTRP
	HRLI 1,400000
	RMAP
	TLNN 2,10000		;PAGE EXISTS?
	JRST STRP1
	JUMPL 1,STRP1
	MOVE 2,PPTRP
	HRLI 2,400000
	MOVSI 3,20000		;XCT ACCESS
	PMAP
	RET

STRP1:	SETZM @FTRAP		;MAKE TO EXIST
	JRST SETTRP
>		;END OF IFE TEN50

U PPTRP
U FTRAP
U IFTRAP

;GET NEW PAGE AND INCREASE ENDCOR

GETPG:	MOVEI 1,NPS
	ADD 1,ENDCOR
	MOVEI 2,-1(1)		;LAST WORD ON PAGE BEING ASSIGNED
	IFN TEN50,<
	CAMG 2,JOBREL		;CORE ALREADY ASSIGNED?
	JRST GETPG1		;YES
	CORE			;NO, REQUEST MORE FROM SYSTEM
	RET			;REFUSED, RETURN NO SKIP
GETPG1:	HRRM 1,JOBFF		;FOR CROCK SAVE COMMAND
	HRLM 1,JOBSA		;DITTO
>
	CAML 1,[777000]
	RET			;DONT ASSIGN LAST PAGES
	EXCH 1,ENDCOR
	MOVSI 2,0(1)
	HRRI 2,1(1)
	SETZM 0(1)
	BLT 2,NPS-1(1)		;ZERO PAGE JUST ASSIGNED
	JRST RSKP		;RETURN GOOD

SAV27:	EXCH 7,0(CP)		;SAVE AC'S 2-7
	PUSH CP,2
	PUSH CP,3
	PUSH CP,4
	PUSH CP,5
	PUSH CP,6
	JRST 0(7)

RES27:	POP CP,7		;RESTORE AC'S 2-7
	POP CP,6
	POP CP,5
	POP CP,4
	POP CP,3
	POP CP,2
	EXCH 7,0(CP)
	POPJ CP,

;INITIALIZATION TABLES

;SYSTEM-DEFINED TYPE NUMBERS

	DEFINE TYP (A,B)
<	NTYPES==NTYPES+1
	XWD A,B>

NTYPES=0

TYPTI:	TYP ARRAYT,1
	TYP BLOCKT,2
	TYP HANDLT,4
	TYP CCODET,1
	TYP BTABT,6
TYPTE:	TYP LISTT,10
	TYP ATOMT,14
	TYP FLOATT,20
	TYP FIXT,22
	TYP SMALLT,24
NTIE==.-TYPTE
	TYP STPTT,30
	TYP CHART,32
	TYP PNAMT,34
	TYP STRNGT,36

IST1:	XWD NCHRS,CHART
	XWD MSN,SMALLT
IST1N==.-IST1


