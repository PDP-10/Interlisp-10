(FILECREATED "16-SEP-74 03:36:07" WTFIX.;6 85525  

     changes to:  WTFIXFNS

     previous date: "12-SEP-74 18:07:37" WTFIX.;5)


  (LISPXPRINT (QUOTE WTFIXCOMS)
	      T T)
  [RPAQQ WTFIXCOMS ((FNS * WTFIXFNS)
	  (VARS (LAMBDASPLST (QUOTE [LAMBDA NLAMBDA]))
		FIXT
		(DWIMUSERFN)
		OKREEVALST
		(NOFIXFNSLST)
		(NOFIXFNSLST0)
		(NOFIXVARSLST)
		(NOFIXVARSLST0)
		(NOSPELLFLG))
	  (DECLARE: DOEVAL@COMPILE DONTCOPY (PROP BLKLIBRARYDEF /RPLNODE))
	  (PROP FILEDEF * FILEDEFLST)
	  (PROP FILEGROUP WTFIX)
	  (PROP CLISPTYPE ')
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
		    (ADDVARS (NLAMA CLISP% )
			     (NLAML]
  (RPAQQ WTFIXFNS
	 (WTFIX WTFIX0 WTFIX1 FIXLISPX/ RETDWIM RETDWIM0 RETDWIM1 RETDWIM2 
		RETDWIM3 RETEDIT FIX89TYPEIN FIXLAMBDA FIXAPPLY FIXAPPLY1 
		FIXATOM FIXATOM1 FIXCONTINUE FIXCONTINUE1 FIXATOM2 FINDATOM 
		CLISPATOM GETVARS FIX89 FIXPRINTIN FIX89A FIX89B SPLIT89 FIXT 
		CLISPFUNCTION? CLISPNOTVARP CLISPELL DWIMIFY3 HELPFIX HELPFIX1 
		HELPFIX2 FINDFN GENSYM? DWIMUNSAVEDEF WTFIXLOADEF CLISP%  
		CHECKTRAN))
(DEFINEQ

(WTFIX
  [LAMBDA (FAULTX FAULTARGS FAULTAPPLYFLG)
    (PROG (FAULTPOS FAULTFN EXPR VARS TAIL PARENT SUBPARENT FORMSFLG 
		    ONLYSPELLFLG DWIMIFYFLG)
          (RETURN (WTFIX1])

(WTFIX0
  [LAMBDA (FAULTX TAIL PARENT SUBPARENT ONLYSPELLFLG)

          (* Internal entry from dwimify1 and dwimify2.
          EXPR, FAULTFN, VARS, TAIL, and FORMSFLG already correctly 
          bound.)


    (PROG (FAULTARGS FAULTAPPLYFLG (FAULTPOS (COND
					       ((NULL (AND DWIMIFYFLG 
							   DWIMIFYING))
                                                (* Originally started out 
                                                evaluting, so there is a higher 
                                                faultpos.)
						 FAULTPOS)))
		     (DWIMIFYFLG T))
          (RETURN (WTFIX1])

(WTFIX1
  [LAMBDA NIL

          (* There are two machine dependent functions in WTFIX, i.e. 
          those containing VAG's or LOC's.
          FIXATOM1 and FIXAPPLY1. Both are disabled in spaghetti 
          system (and are awaiting special functions from alice), and 
          therefore wont cause alto lisp any problem.)



          (* Replaces FAULT1 when DWIM is on.
          on u.b.a.'s FAULTX is the atom.
          On u.d.f.'s involving forms, FAULTX is the form.
          On u.d.f.'s from APPLY, faultx is the name of the function, 
          FAULTARGS the arguments, and FAULTAPPLYFLG is T.
          Also is called directly to process a form from DWIMIFY.
          In this case, EXPR, VARS, ..., NOSPELLFLG0 are supplied, and 
          FINDFN is not called.)


    (AND
      DWIMFLG
      (XNLSETQ
	(PROG (TYPE-IN? BREAKFLG FAULTXX FAULTEM2 LST FAULTEM1 NEWTAIL 
			CLISPERTYPE HISTENTRY FIXCLK CLISPCHANGES SIDES
			(NOSPELLFLG0 NOSPELLFLG))
	      [COND
		(DWIMIFYFLG 

          (* Call from WTFIX0. Note that while this call from DWIMIFY1 
          or DWIMIFY2, the user may or may not have been DWIMIFYING, 
          e.g. when IF's are encountered in evaluation, DWIMIFY1 and 
          DWIMIFY2 are used. The variable DWIMIFYING is T if the call 
          to DWIMIFY! or DWIMIFY2 is from an explicit call to DWIMIFY 
          (or DWIMIFYFNS))


			    (SETQ TYPE-IN? (EQ FAULTFN (QUOTE TYPE-IN)))

          (* DWIMIFY is called on typein for processing FOR's and 
          IF's. In this case, want to treat user approval the same as 
          for type-in.)


			    )
		(T (SETQ FIXCLK (CLOCK 2))

          (* If EXPR is given, i.e. if DWIMIFYFLG is gong to be T, the 
          clkock is being measured at some higher caal to WTFIX or 
          DWIMIIY.)


		   [SETQ FAULTPOS (STKPOS (COND
					    (FAULTAPPLYFLG (QUOTE FAULTAPPLY))
					    (T (QUOTE FAULTEVAL]
		   (SETQ FAULTFN (FINDFN (FSTKNTH -1 FAULTPOS)
					 T))

          (* The value of FINDFN is the name of the 
          (interpreted) function in which the error occurred.
          FINDFN also sets the free variable EXPR to the definition of 
          that function. If the error occurred under a call to EVAL, 
          the value of FINDFN is EVAL, and EXPR is set to the 
          expression being evaluated, i.e. the argument to EVAL.
          If the error occurred under an APPLY, the value of FINDFN is 
          the first argument to APPLY, and EXPR is set to the second 
          argument to APPLY, i.e. the list of arguments.
          In this case, FAULTX will usually be EQ to the value 
          returned by FINDFN, and FAULTARGS EQ to EXPR.
          However, WTFIX may also be called from FAULTAPPLY, and 
          FINDFN not find an APPLY, as occurs on undefined functions 
          called from compiled code. For this reason, FIXAPPLY always 
          uses FAULTX and FAULTARGS, not FAULTFN and EXPR.)


		   (SETQ VARS (AND (SETQ FAULTEM1 (OR BREAKFLG (LISTP EXPR)))
				   (GETVARS FAULTEM1]
	      [AND (NULL TYPE-IN?)
		   (SETQ SIDES (CDR (GET LISPXHIST (QUOTE SIDE]
	      (AND TYPE-IN? (NULL DWIMIFYFLG)
		   [COND
		     (FAULTAPPLYFLG (EQ FAULTX (CAAAAR LISPXHISTORY)))
		     (T (OR (EQ FAULTX (CAAAAR LISPXHISTORY))
			    (EQUAL FAULTX (CAAAR LISPXHISTORY]
		   (SETQ HISTENTRY (CAAR LISPXHISTORY)))
	      [COND
		([LITATOM (SETQ FAULTXX (COND
			      (FAULTAPPLYFLG FAULTX)
			      ((ATOM FAULTX)
				FAULTX)
			      (T (CAR FAULTX]
		  (SETQ LST (DUNPACK FAULTXX CHCONLST]
	      (COND
		((AND (NULL FAULTAPPLYFLG)
		      (LITATOM FAULTX))
		  (FIXATOM))
		(FAULTAPPLYFLG (FIXAPPLY))
		([AND TYPE-IN? (EQ FAULTXX (CAAR HISTENTRY))
		      (SETQ FAULTEM1 (FMEMB 8 LST))
		      (NULL (AND CLISPFLG (STRPOSL CLISPCHARRAY FAULTXX]

          (* This distinguishes between (CONS8ADD1 3) which is handled 
          by a call to FIX89 from CLISPATOM, and FOO8A B C "]", which 
          is handled by FIX89TYPEIN, since it requires changing an 
          EVAL to an APPLY.)


		  (FIX89TYPEIN FAULTEM1 LST))
		((AND CLISPFLG LST (LITATOM (SETQ FAULTEM1 (CADR FAULTX)))
		      (OR (GETP FAULTEM1 (QUOTE CLISPTYPE))
			  (FMEMB (SETQ FAULTEM1 (NTHCHAR FAULTEM1 1))
				 CLISPCHARS))
		      (NOT (GETP FAULTEM1 (QUOTE UNARYOP)))
		      (CLISPNOTVARP (CADR FAULTX)))

          (* So that things like (SUM + X) will work, i.e. not be 
          interpreted as iterative statement.)


		  (GO NX0))
		((NULL LST)
		  (GO NX2)))

          (* Both FIXAPPLY and FIXATOM exit via RETDWIM so there is no 
          need for a return here in WTFIX.)


	  TOP [SELECTQ
		(CAR FAULTX)
		(T (SETQ FAULTX (FIXT)))
		[F/L
		  (/RPLNODE
		    FAULTX
		    (QUOTE FUNCTION)
		    (LIST (CONS (QUOTE LAMBDA)
				(COND
				  ((AND (CDDR FAULTX)
					(LISTP (CADR FAULTX))
					(NOT (CLISPFUNCTION? (CADR FAULTX)
							     (QUOTE OKVAR)))
					(EVERY (CADR FAULTX)
					       (FUNCTION ATOM)))
				    (CDR FAULTX))
				  (T (CONS (LIST (QUOTE X))
					   (CDR FAULTX]
		(CLISP:(ERSETQ (CLISPDEC0 FAULTX FAULTFN))
		  (SETQ FAULTX T))
		(SELECTQ [CAR (SETQ FAULTEM1 (GETP (CAR FAULTX)
						   (QUOTE CLISPWORD]
			 (FORWORD (SETQ FAULTX (CLISPFOR FAULTX)))
			 (IFWORD (SETQ FAULTX (CLISPIF FAULTX))
				 (SETQ HISTENTRY NIL))
			 (RECORDWORD (SELECTQ (CAR FAULTX)
					      [(fetch replace FETCH REPLACE)
						(AND DWIMIFYFLG (SETQ 
						       CLISPCHANGE T)
						     (SETQ ATTEMPTFLG T))
						(COND
						  ((NULL (SETQ FAULTEM1
							   (CLISPRECORD FAULTX))
							 )
						    (SETQ CLISPERTYPE
						      (LIST (QUOTE FIELDNAME)
							    FAULTX))
						    (RETDWIM]
					      (RECCOMPOSE0 FAULTX)))
			 (MATCHWORD             (* CAR of FAULTX either MATCH or
                                                match.)
				    (CLISPTRAN FAULTX (MAKEMATCH FAULTX)))
			 (NIL (GO NX0))
			 (PREFIXFN [SETQ FAULTEM1
				     (APPEND (COND
					       [(AND (NULL (CDDR FAULTX))
						     (LISTP (CADR FAULTX]
					       (T (CDR FAULTX]
				   (COND
				     ((NULL CLISPFLG)
				       (SETQ RESETVARSLST
					 (CONS (QUOTE (CLISPFLG))
					       RESETVARSLST))
				       (SETQ CLISPFLG T)
				       (DWIMIFY1 FAULTEM1)
				       (SETQ CLISPFLG NIL))
				     (T (DWIMIFY1 FAULTEM1)))
				   (CLISPELL FAULTX)
				   (CLISPTRAN FAULTX FAULTEM1))
			 (SETQ FAULTX (APPLY* (CAR FAULTEM1)
					      FAULTX]
	      (AND DWIMIFYFLG (SETQ CLISPCHANGE T))
	      (GO OUT)
	  NX0 (COND
		[(SETQ FAULTEM1 (FGETD (CAR FAULTX)))
		  (COND
		    ([NULL (PROG (TYPE-IN? (FAULTFN (CAR FAULTX)))
			         (COND
				   ((FIXLAMBDA FAULTEM1)

          (* This is the case where (FOO --) is being evaluated, and 
          the definition of FOO is bad.)


				     (AND FILEPKGFLG (NEWFILE? FAULTFN))
				     T]
		      (SETQ NOSPELLFLG0 T)
		      (GO NX3)                  (* So DWIMUSERFN can be called.)
		      ]
		((GETP (CAR FAULTX)
		       (QUOTE EXPR))
		  (DWIMUNSAVEDEF (CAR FAULTX))
		  (SETQ FAULTFN NIL)            (* So that RETDWIM won't do a 
                                                NEWFILE?)
		  )
		((SETQ FAULTEM1 (GETP (CAR FAULTX)
				      (QUOTE FILEDEF)))
		  (COND
		    ((WTFIXLOADEF FAULTEM1)
		      (GO OUT)))
		  (RETDWIM))
		(T (GO NX1)))
	      (GO OUT)
	  NX1 (COND
		((AND (CLISPNOTVARP (CAR FAULTX))
		      (SETQ FAULTEM1 (CLISPATOM LST FAULTX FAULTX)))
                                                (* E.g. (FOO_ATOM) OR 
                                                (FOO_ form))
		  (SETQ FAULTX FAULTEM1)
		  (GO OUT)))
	  NX2 (COND
		([AND CLISPFLG (SETQ FAULTEM1 (CADR FAULTX))
		      (LITATOM FAULTEM1)
		      (OR (GETP FAULTEM1 (QUOTE CLISPTYPE))
			  (FMEMB (CAR (SETQ FAULTEM1 (DUNPACK FAULTEM1 SKORLST3)
					))
				 CLISPCHARS))
		      [PROG (CLISPERTYPE)
			    (RETURN (SETQ FAULTEM1 (CLISPATOM FAULTEM1
							      (CDR FAULTX)
							      FAULTX T]
		      (COND
			[(OR (NEQ FAULTXX (CAR FAULTX))
			     (AND CLISPARRAY (GETHASH FAULTX CLISPARRAY]
			(DWIMIFYFLG (SETQ LST (DUNPACK FAULTXX CHCONLST))
                                                (* LST may have been clobbered)
				    (SETQ CLISPCHANGE NIL]

          (* E.g. (FOO _atom) or (FOO _ form). The NEQ check is 
          necessary to handle situations like 
          (FOOO N-1) where an CLISP transformation is performed, but 
          it does not correct CAR of the form.
          (In this case, we must continue to the spelling correction 
          part below, and set CLISPCHANGE to NIL so that DWIMIFY1 will 
          not be confused.) Note that if FOO also happens to be the 
          name of a function, then WTFIX will not be called and the 
          CLISP transformation not be performed until the arguments of 
          FOO are evaluated and cause a u.b.a.
          error. Then DWIM will have to back up as described in 
          FIXATOM and FIXATOM1. CLISPERTYPE is rebound because we do 
          not want this call to CLISPATOM to generate any diagnostics, 
          since if it is coming from DWIMIFY2 the error will be noted 
          when (CDR FAULTX) is processed, e.g. in 
          (A + B C), want error to occur when tail is 
          (+ B C))


		  (SETQ FAULTX FAULTEM1)
		  (GO OUT))
		((AND (NULL NOSPELLFLG0)
		      DWIMIFYFLG
		      (LISTP (CADR FAULTX))
		      (FIXLAMBDA FAULTX))

          (* The DWIMIFYFLG check is because in normal course of 
          events, it never makes sense for LAMBDA to appear as CAR of 
          a FORM. However, DWIMIFY1 is called on open LAMBDA 
          expressions.)


		  (GO OUT))
		((AND (NULL NOSPELLFLG0)
		      (LISTP (CAR FAULTX))
		      (LISTP (CADAR FAULTX))
		      (FIXLAMBDA (CAR FAULTX)))

          (* This corresponds to the case where LAMBDA is misspelled 
          in an open LAMBDA expression. Note that an open lambda 
          expression only makes sense when there is a non-atomic 
          argument list, so dont both spelling correcting if this is 
          notthe case.)


		  (GO OUT)))
	  NX3 (COND
		[[AND HISTENTRY TYPE-IN? (OR (FMEMB (CAR FAULTX)
						    EDITCOMSL)
					     (NUMBERP (CAR FAULTX]
		  (RETEDIT (COND
			     ((EVQ LISPXLINE)   (* User typed more than two 
                                                inputs, so each one is a 
                                                command.)
			       FAULTX)
			     (T (LIST FAULTX]
		((AND DWIMUSERFN (SETQ FAULTEM1 (DWIMUSERFN)))
		  (RETDWIM FAULTPOS FAULTEM1))
		(NOSPELLFLG0 (GO FAIL))
		[[AND LST (SETQ FAULTXX (OR (FIXSPELL (CAR FAULTX)
						      70 SPELLINGS2 NIL FAULTX 
						      NIL NIL LST)
					    (AND DWIMIFYFLG NOFIXFNSLST0
						 (FIXSPELL (CAR FAULTX)
							   70 NOFIXFNSLST0 NIL 
							   FAULTX NIL NIL LST]

          (* The extra argument to FIXSPELL indicates that SPLITS re 
          tolerated, e.g. (BREAKFOO))


		  (COND
		    ((EQ (CAAR HISTENTRY)
			 (CAR FAULTX))
		      (/RPLNODE HISTENTRY FAULTX (CDR HISTENTRY))

          (* Normally, RETDWIM patches the histroy entry to corresond 
          to a list input, even if it was typed in as a line.
          In the special case of a pselling correction, we leave the 
          entry as a line.)


		      ))
		  (SETQ HISTENTRY NIL)
		  (COND
		    ((NOT (FGETD FAULTXX))

          (* E.g. USER misspells FOR, IF, F/L etc. These are all 
          contained on SPELLINGS2.)


		      (GO TOP]
		([AND CLISPFLG (NULL CLISPCHANGES)
		      (NULL CLISPERTYPE)
		      (SETQ FAULTEM1 (CADR FAULTX))
		      (CDDR FAULTX)
		      (LITATOM FAULTEM1)
		      (SETQ FAULTEM1 (FIXSPELL
			  FAULTEM1 70 CLISPINFIXES NIL
			  (OR (AND DWIMIFYFLG (EQ CLISPCONTEXT (QUOTE INFIX)))
			      (CDR FAULTX))
			  NIL NIL (DUNPACK FAULTEM1 SKORLST3)))
		      (COND
			((AND DWIMIFYFLG (EQ CLISPCONTEXT (QUOTE INFIX)))
			  (RETEVAL (RETDWIM0 (QUOTE CLISPATOM1))
				   (QUOTE (PROGN (SETQ CLISPRESPELL T)
						 NIL))
				   T)

          (* Returns from the corresonding ERRORSET with a value of 
          NIL, i.e. looks like an error occurred at that point.)


			  )
			(T (PROG (CLISPERTYPE)
			         (RETURN (SETQ FAULTEM1 (CLISPATOM
					     FAULTEM1
					     (CDR FAULTX)
					     FAULTX T]
		  (SETQ FAULTX FAULTEM1))
		(T (GO FAIL)))
	  OUT (RETDWIM FAULTPOS FAULTX)
	  FAIL(RETDWIM))
	NIL WTFIX])

(FIXLISPX/
  [LAMBDA (X FN)
    (COND
      ((NULL TYPE-IN?)
        X)
      (T (LISPX/ X FN VARS])

(RETDWIM
  [LAMBDA (POS X APPLYFLG ARGS)
    (PROG (TEM)
          (LISPXWATCH FIXCALLS)
          [COND
	    ((AND DWIMIFYFLG DWIMIFYING)
	      (LISPXWATCH DWIMIFYFIXES))
	    (T (LISPXWATCH ERRORCALLS)
	       (COND
		 (TYPE-IN? (LISPXWATCH TYPEINFIXES))
		 (T (LISPXWATCH PROGFIXES]
          (COND
	    (FIXCLK (LISPXWATCH FIXTIME (SETQ TEM (IDIFFERENCE (CLOCK 2)
							       FIXCLK)))
		    (AND HELPCLOCK (SETQ HELPCLOCK (IPLUS HELPCLOCK TEM)))
                                                (* So time spent in DWIM will 
                                                not count towards a break.)
		    ))
      TOP [COND
	    [(OR POS X)                         (* Successful correction.)
	      (AND (EQ (CAR SIDES)
		       (QUOTE CLISP% ))
		   [NCONC1 (CADR SIDES)
			   (CDR (GET LISPXHIST (QUOTE SIDE]
		   (LISPXPUT (QUOTE LISPXPRINT*)
			     (LIST SIDES)
			     T LISPXHIST))

          (* Some messages were printed, and the undo informaton 
          marked. This completes the process enabling user to undo 
          just the effects associated with the dwim change 
          corresponding to the message printed between 
          (CADR of this mark) and the place where the mark appears.
          The use of CLISP%  makes the mark invisible to the editor, 
          and also does not i nterefere with printing the event.)


	      (COND
		((AND DWIMIFYFLG DWIMIFYING)
		  (SETQ DWIMIFY0CHANGE T)
		  (LISPXWATCH SUCCFIXES2))
		(T (LISPXWATCH SUCCFIXES1)
		   (AND (NULL TYPE-IN?)
			FILEPKGFLG
			(EXPRP FAULTFN)
			(OR (GET LISPXHIST (QUOTE *LISPXPRINT*))
			    (NULL CLISPIFYPRETTYFLG))
			(PROG [(L (CDR (GET LISPXHIST (QUOTE SIDE]
			  LP  (COND
				((OR (NULL L)
				     (EQ L SIDES))
				  (RETURN NIL))
				((NEQ (CAAR L)
				      (QUOTE /PUTHASH))
				  (RETURN T)))
			      (SETQ L (CDR L))
			      (GO LP))
			(NEWFILE? FAULTFN))

          (* The reason for the OR is that if there are no messages 
          printed, then the only changes were well-defined clisp 
          transformations, and therefore if clispifyprettyflg is not 
          NIL, there is no point in re-clispifying and 
          reprettyprinting the function.)


		   ))
	      (COND
		(DWIMIFYFLG (SETQ DWIMIFYCHANGE T)
			    (RETFROM (RETDWIM0 (QUOTE WTFIX))
				     X T))
		((AND (ATOM FAULTX)
		      NEWTAIL)

          (* The interpreter has already made up its mind about how to 
          handle the first operand of the CLISP expression, e.g. it 
          has already been evaluated as an argument, or else is about 
          to be called as a function. Therefore continuing the 
          computation requires some fiddling around.
          FIXATOM1 takes over and does the RETEVAL.)


		  (FIXATOM1)))
	      (COND
		((NULL APPLYFLG)
		  [COND
		    (HISTENTRY (/RPLNODE HISTENTRY (LIST X)
					 (CDR HISTENTRY))
			       (AND (ATOM X)
				    (SETQ LASTWORD X]
		  (RETEVAL POS (FIXLISPX/ X)
			   T))
		(T (AND HISTENTRY (/RPLNODE HISTENTRY (LIST X ARGS)
					    (CDR HISTENTRY)))
		   (RETEVAL POS (LIST (QUOTE APPLY)
				      (LIST (QUOTE QUOTE)
					    (FIXLISPX/ X))
				      (LIST (QUOTE QUOTE)
					    (FIXLISPX/ ARGS X))
				      (QUOTE (QUOTE INTERNAL)))
			    T]
	    ((AND CLISPFLG DWIMIFYFLG FORMSFLG (NULL NOSPELLFLG)
		  (EQ FAULTX (CAR TAIL))
		  (EQ TAIL PARENT)
		  (STRPOSL CLISPCHARRAY (CAR TAIL))
		  (DWIMIFY2A TAIL LST))

          (* In the event that a parenthesis was left out, and 
          (CAR TAIL) is really the name of a function 
          (or misspelled function), spelling correction would nothave 
          been attempted earlier in DWIMIFY2 until seeing if this was 
          ok CLISP, so try it now. E.g. (IF A THEN FOOX-1), where FOO 
          is name of a function, or (IF A THEN R/PLNODE X). Note that 
          CLISPCHANGES might be NIL in the case that the clisp 
          transformationdidn't go throuh, e.g. missing operand.)


	      (/RPLNODE TAIL (CONS (CAR TAIL)
				   (CDR TAIL)))
	      (SETQ X (DWIMIFY1? (CAR TAIL)))
	      (SETQ POS FAULTPOS)
	      (GO TOP))
	    (CLISPCHANGES (COND
			    ((NULL (RETDWIM1 (CDDR CLISPCHANGES)))
			      (RELSTK FAULTPOS)
			      (ERROR!)))
			  (SETQ X (CAR CLISPCHANGES))
			  [MAPC (CADR CLISPCHANGES)
				(FUNCTION (LAMBDA (X)
				    (COND
				      ((LISTP (CAR X))
					(/RPLNODE (CAR X)
						  (CADR X)
						  (CDDR X)))
				      (T (APPLY (CAR X)
						(CDR X]
			  (AND DWIMIFYFLG (SETQ CLISPCHANGE T))
			  (SETQ POS FAULTPOS)
			  (GO TOP))
	    (CLISPERTYPE 

          (* Error messages are postponed till this point because what 
          looks like a bad clisp expression may be interpreted 
          correctly in a different way -
          e.g. _PENP will correct to openp.)


			 (AND DWIMIFYFLG (SETQ ATTEMPTFLG T)
			      (SETQ CLISPCHANGE T))

          (* ATTEMPTFLG to inform DWIMMFY not to add FAUTX to 
          NOFIXLST. CLISPCHANGE is to prevent analysing cdr of the 
          form in the case the error occurred in CAR of the form.)


			 (AND (OR DWIMIFYFLG (NULL TYPE-IN?))
			      (CLISPERROR CLISPERTYPE]
          (COND
	    (DWIMIFYFLG (ERROR!))
	    (T (RELSTK FAULTPOS)
	       (RETFROM (RETDWIM0 (QUOTE WTFIX))
			[AND (NULL TYPE-IN?)
			     (CONS FAULTFN (COND
				     ((ATOM FAULTX)
				       (RETDWIM2 PARENT TAIL))
				     (T (RETDWIM2 FAULTX NIL 2]
			T)

          (* The vaue retunred by WTFIX is used on the call to 
          OLDFAULT1 for printing out a message.)


	       ])

(RETDWIM0
  [LAMBDA (FN)
    (PROG (POS TEM)
      LP  (SETQ TEM (NEWSTKPOS (QUOTE ERRORSET)
			       -1 POS))
          (RELSTK POS)
          (SETQ POS TEM)
          (COND
	    ((OR (NULL POS)
		 (EQ (NEWFSTKARG 3 POS)
		     FN))
	      (RETURN POS)))
          (SETQ POS (FSTKNTH -1 POS POS))
          (GO LP])

(RETDWIM1
  [LAMBDA (L)

          (* Called when about to make a CLISP transformation for 
          which one of the atmic operands are not bound.)


    (PROG ((TAIL (CAR L))
           (CURRTAIL (CADR L))
           MESS TEM CLISPCHANGES)

          (* CLISPCHANGES rebound so that FIXSPELL1 will only ask for 
          approval if dwim mode indicates.)


          [SETQ TEM
            (COND
              ((EQ (CDR TAIL)
                   CURRTAIL)
                (RETDWIM2 (CAR TAIL)))
              (T (APPLY (QUOTE CONCAT)
                        (MAPCON (LDIFF TAIL CURRTAIL)
                                (FUNCTION (LAMBDA (X)
                                    (COND
                                      [(LISTP (CAR X))
                                        (LIST (RETDWIM2 (CAR X]
                                      ((OR (FMEMB (NTHCHAR (CAR X)
                                                           -1)
                                                  CLISPCHARS)
                                           (FMEMB (CADR X)
                                                  CLISPCHARS))
                                        (LIST (CAR X)))
                                      (T (LIST (CAR X)
                                               (QUOTE " "]
          (COND
            ((FIXSPELL1 TEM (COND
                          (LCASEFLG (QUOTE " as clisp"))
                          (T 

          (* The reason for the check is that the user may want to key 
          on this message for an UNDO : operation, and if he is on a 
          33 and it is printed as a lowercase string 
          (even though he sees it in uppercase) he wont be able to fnd 
          it.)


                             (QUOTE " AS CLISP")))
                        [COND
                          [[OR TREATASCLISPFLG (AND (EQ (CADDR L)
                                                        (QUOTE PROBABLY))
                                                    (OR (AND DWIMIFYFLG 
                                                             DWIMIFYING)
                                                        (NULL TYPE-IN?]

          (* The idea here is that it does not make sense to 
          automatcaaly go ahead and perform a transformation to typein 
          that is then going to produce an error, e.g. user type 
          FOO_FIE where FIE is unbound. Therefore we will always ask 
          him for type-in? Note that he may say YES even though it 
          will produce an error, so that he can then say  ' or -> 
          something. -
          In functons, if the operation involves more than one CLISP 
          operator (or an assignment where the variable is one of the 
          bound varables.) we will just tell him.)


                            (SETQQ TEM NEEDNOTAPPROVE)
                            (COND
                              (LCASEFLG (QUOTE " treated"))
                              (T (QUOTE " TREATED"]
                          (T (SETQQ TEM MUSTAPPROVE)
                             (COND
                               (LCASEFLG (QUOTE " treat"))
                               (T (QUOTE " TREAT"]
                        T TEM)
              (SETQ NOFIXVARSLST0 (CADDDR L))

          (* Since user has approved CLISP, it is ok to set 
          NOFIXVARSLST0 to include any variabes detected during 
          analysis of CLISP expression, e.g. if expression were A*B A 
          and B can now be added NOFIXVARSLST0)


              (RETURN T)))
          (RETURN (COND
                    (DWIMIFYFLG (SETQ NEXTAIL (NLEFT (CAR L)
                                                     1 CURRTAIL))
                                                (* Tells DWIMIFY where to 
                                                continue.)
                                (COND
                                  ((LISTP (CAR NEXTAIL))
                                    (SETQ NEXTAIL (NLEFT (CAR L)
                                                         2 CURRTAIL))

          (* E.G. In A* (FOO --), this will enable 
          (FOO --) to be processed. If the expression immediately 
          before CURRTAIL is an atom, we have no way of knowing if it 
          contains a CLISP operator or not, e.g. is it A + B, or A+B.
          If we were to back up NEXTAIL so that DWIMIFYING continued 
          as of this atom, it might cause a loop.)


                                    ))
                                NIL])

(RETDWIM2
  [LAMBDA (X TAIL N M)

          (* N is a printlevel affecting TAILS, M one affecting 
          elementens. Value is a copy of X as though printed with 
          these levels.)


    (AND (NULL N)
         (SETQ N 3))
    (AND (NULL M)
         (SETQ M 1))
    (RETDWIM3 X N TAIL M])

(RETDWIM3
  [LAMBDA (X TAIL N1 M1)
    (COND
      ((NLISTP X)
	X)
      ((ILESSP M1 0)
	(QUOTE &))
      (T (CONS (RETDWIM3 (CAR X)
			 NIL N (SUB1 M1))
	       (COND
		 [TAIL (COND
			 ((EQ X TAIL)           (* Only begin counting down when
                                                you reach TAIL.)
			   (RETDWIM3 (CDR X)
				     NIL
				     (SUB1 N1)
				     M1))
			 (T (RETDWIM3 (CDR X)
				      TAIL N1 M1]
		 ((IGREATERP N1 0)
		   (RETDWIM3 (CDR X)
			     TAIL
			     (SUB1 N1)
			     M1))
		 ((CDR X)
		   (QUOTE (--])

(RETEDIT
  [LAMBDA (X)
    (LISPXWATCH FIXCALLS)
    (LISPXWATCH TYPEINFIXES)
    (LISPXWATCH SUCCFIXES1)
    (LISPXWATCH FIXTIME (IDIFFERENCE (CLOCK 2)
				     FIXCLK))
    (RETEVAL FAULTPOS (CONS (QUOTE EDITF)
			    (CONS NIL (CONS (QUOTE START)
					    X)))
	     T])

(FIX89TYPEIN
  [LAMBDA (X CLST APPLYFLG)
    (PROG (TEM)
          (PRIN1 (QUOTE =)
		 T)
          (COND
	    [(EQ X CLST)                        (* THE 8 is the first 
                                                character.)
	      (PRINT (SETQ TEM (PACK (CDR X)))
		     T T)
	      (RETDWIM FAULTPOS (CONS TEM (COND
					((NULL APPLYFLG)
                                                (* E.g. 8FOO X Y)
					  (CDR FAULTX))
					(FAULTARGS 
                                                (* E.G. 8FOO (A B))
						   (LIST FAULTARGS]
	    (T [SETQ FAULTARGS (COND
		   ((AND APPLYFLG FAULTARGS)    (* E.g. "FOO8)" or "FOO8A)" or 
                                                "FOO8A B]")
		     (LIST FAULTARGS))
		   (T                           (* E.g. "FOO8A B C]" 
                                                (or "FOO8 A B]"))
		      (CDR FAULTX]
	       (RETDWIM FAULTPOS (PRINT (SETQ TEM (PACK (LDIFF CLST X)))
					T T)
			T
			(COND
			  ((NULL (CDR X))
			    FAULTARGS)
			  (T (CONS (PACK (CDR X))
				   FAULTARGS])

(FIXLAMBDA
  [LAMBDA (DEF FLG)

          (* LAMBDASPLST is initialized to 
          (LAMBDA NLAMBDA). HOwever users can add to it for 'function' 
          handled by DWIMMUSERFN. QLISP uses this feature.)


    (AND (LITATOM (CAR DEF))
	 (CDDR DEF)
	 (NOT (FMEMB (CAR DEF)
		     LAMBDASPLST))
	 (FIXSPELL (CAR DEF)
		   70 LAMBDASPLST NIL DEF NIL NIL T])

(FIXAPPLY
  [LAMBDA NIL
    (PROG (X TEM)
          (COND
	    ((AND (LITATOM FAULTX)
		  (SETQ X (FGETD FAULTX)))
	      (COND
		([NULL (PROG (TYPE-IN?)
			     (RETURN (FIXLAMBDA X]
		  (GO NX)))
	      (AND FILEPKGFLG (NEWFILE? FAULTX))
	      (SETQ X FAULTX)
	      (GO OUT))
	    ((GETP FAULTX (QUOTE EXPR))
	      (DWIMUNSAVEDEF FAULTX)
	      (SETQ X FAULTX)
	      (SETQ FAULTFN NIL)                (* So that RETDWIM won't do a 
                                                NEWFILE?)
	      (GO OUT))
	    ((SETQ TEM (GETP FAULTX (QUOTE FILEDEF)))
	      (COND
		((WTFIXLOADEF TEM)
		  (SETQ X FAULTX)
		  (GO OUT1)))
	      (RETDWIM))
	    ((AND TYPE-IN? CLISPFLG (STRPOSL CLISPCHARRAY FAULTX)
		  (SETQ X (CLISPATOM LST (SETQ TEM (LIST FAULTX FAULTARGS))
				     TEM T)))

          (* E.g. FOO_ form. FOO _form is caught by a special check in 
          LISPX and treated as (FOO _form))


	      (RETDWIM FAULTPOS X))
	    ((AND TYPE-IN? (EQ FAULTXX (CAAR HISTENTRY))
		  (SETQ TEM (FMEMB 8 LST)))
	      (FIX89TYPEIN TEM LST T))
	    ((AND (LISTP FAULTX)
		  (FIXLAMBDA FAULTX))

          (* LAMBDA or NLAMBDA misspelled in LAMBDA expression being 
          applied, e.g. a functional argument.)


	      (SETQ X FAULTX)
	      (GO OUT)))
      NX  (COND
	    ((AND TYPE-IN? HISTENTRY (OR (NUMBERP FAULTX)
					 (FMEMB FAULTX EDITCOMSA)
					 (FMEMB FAULTX EDITCOMSL)))
	      (RETEDIT (LIST FAULTX FAULTARGS)))
	    ((AND DWIMUSERFN (SETQ TEM (DWIMUSERFN)))
	      (RETDWIM FAULTPOS TEM))
	    ([NULL (SETQ X
		     (OR (FIXSPELL FAULTX 70 SPELLINGS1 NIL NIL NIL NIL LST)
			 (FIXSPELL FAULTX 70 SPELLINGS2 NIL NIL NIL NIL LST]
	      (RETDWIM)))
      OUT (FIXAPPLY1 FAULTPOS FAULTX X)
      OUT1(RETDWIM FAULTPOS X T FAULTARGS])

(FIXAPPLY1
  [LAMBDA (POS OLD NEW *FORM*BLIP)

          (* Analagous to FINDATOM. Finds the XTAIL for which the 
          u.d.f. OLD is CAR, and replaces it with NEW.
          Also changes places where OLD appears on the stack to NEW.
          Sets PARENT to be the element containing OLD, and returns 
          with the TAIL.)


    (PROG (XTAIL (POS0 (FSTKNTH -1 POS)))
          (AND (NULL SPAGHETTIFLG)
	       (PROG (POS1 POS2)

          (* changes any bindings whose value is OLD, the undefined 
          function. Thus if the error occurs from inside of a mapping 
          function, you won't get N calls to WTFIX.
          Also necessary for changing the argument to apply, e.g. user 
          types FOOO NIL which is corrected to FOO.
          In this case, want argument to APPLY from LISPXBLOCK to be 
          FOO, not FOOO. Alice has to supply a function for doing this 
          in spaghetti system.)


		     (SETQ POS1 (FSTKARG 0 POS))
		     (SETQ POS2 (FSTKARG 0 (FSTKNTH -1 POS)))
		 LP  

          (* This loop changes any bindings whose value is OLD, the 
          undefined function. Thus if the error occurs from inside of 
          a mapping function, you won't get N calls to WTFIX.
          Also necessary for changing the argument to apply, e.g. user 
          types FOOO NIL which is corrected to FOO.
          In this case, want argument to APPLY from LISPXBLOCK to be 
          FOO, not FOOO.)


		     (COND
		       ((EQ POS1 POS2)
			 (GO NX))
		       ((EQ (CAR POS1) OLD)
			 (FRPLACA POS1 NEW)))
		     [SETQ POS1 (VAG (SUB1 (LOC POS1]
		     (GO LP)))
      NX  

          (* Attempts to find the occurrence of the u.d.f.
          in the user's program, e.g. if 
          (MAPC X (FUNCTION PRINNT)) caused the error, this will 
          change (FUNCTION PRINNT) to (FUNCTION PRINT))


          (COND
	    ((EQ (CAAAAR LISPXHISTORY) OLD)
	      (GO OUT)))
          [SETQ POS0 (COND
	      (TYPE-IN? EXPR)
	      (T (OR *FORM*BLIP (BLIPEVAL (QUOTE EVAL)
					  POS0]

          (* POS0 is used because want to find the form from which the 
          function before FAULTAPPLY, e.g. MAPC, was called.)


          (COND
	    ([SOME (CDR POS0)
		   (FUNCTION (LAMBDA (X)
		       (AND (EQ (CAR X)
				(QUOTE FUNCTION))
			    (EQ (CADR X) OLD)
			    (SETQ XTAIL (CDR X]
	      (SETQ PARENT POS0))
	    ((AND (LISTP EXPR)
		  (SETQ XTAIL (FMEMB OLD EXPR)))

          (* Second case corresponds to where MAPC 
          ((A B C) PRINNT) is typed in.)


	      )
	    (T (RETURN NIL)))
          (/RPLNODE XTAIL NEW (CDR XTAIL))
      OUT (RELSTK POS0)
          (RETURN XTAIL])

(FIXATOM
  [LAMBDA NIL
    (PROG (X Y TAIL0)
          (COND
	    ((NULL TAIL)
	      (SETQ TAIL (FINDATOM FAULTX (SETQ X (FSTKNTH -1 FAULTPOS))
				   (BLIPEVAL (QUOTE EVAL)
					     X)))
	      (RELSTK X)))
          (SETQ TAIL0 (AND (NEQ ONLYSPELLFLG (QUOTE NORUNONS))
			   TAIL))

          (* ONLYSPELLFLG is NORUNONS for calls from CLISPATOM2A, i.e. 
          when DWIMIYING one of the operands to an infix operator.
          IN this case it never makes sense to do a runon spelling 
          correction, e.g. FOOX*A shouldnt correct to 
          (ITIMES FOO X A), althouh it may correct to FOO X*A.)


          (COND
	    ((SETQ X (CLISPATOM LST TAIL PARENT))
	      (GO OUT))
	    ([AND (CDR TAIL)
		  (ATOM (SETQ Y (CADR TAIL)))
		  (EQ (NTHCHAR Y 1)
		      (QUOTE _))
		  (PROG (CLISPERTYPE)
		        (RETURN (SETQ X (CLISPATOM (DUNPACK Y SKORLST3)
						   (CDR TAIL)
						   PARENT T]

          (* E.G. (LIST FOO _ 3) where FOO is unbound at the time.
          See comment in WTFIX.)


	      (GO OUT))
	    [(AND (EQ (CAR LST)
		      7)
		  (GETP (QUOTE ')
			(QUOTE CLISPTYPE))
		  (FIXSPELL1 FAULTX (PACK (CONS (QUOTE ')
						(CDR LST)))
			     NIL LST))
	      (SETQ X (LIST (QUOTE QUOTE)
			    (PACK (CDR LST]
	    ((AND TYPE-IN? (EQ FAULTX EXPR)
		  (FMEMB FAULTX EDITCOMSA))     (* See comment in WTFIX about 
                                                edit commands.)
	      (RETEDIT (LIST FAULTX)))
	    ((AND DWIMUSERFN (SETQ X (DWIMUSERFN)))
	      (GO OUT))
	    ((OR NOSPELLFLG (GETP FAULTX (QUOTE GLOBALVAR))
		 (FMEMB FAULTX GLOBALVARS))

          (* For efficiency, GLOBALVARS is a global variable itself 
          for DWIMBLOCK. Thus FIXATOM obtains the top level value, not 
          the one rebound by BCOMPL2. However, in the case that there 
          are block declarations aafecting globalvars, the variables 
          would also have been added to NOFIXVARSLST, so this is ok.)


	      (RETDWIM))
	    ((AND VARS (SETQ X (FIXSPELL FAULTX 70 VARS NIL TAIL0 NIL NIL LST)))

          (* Corrects spellings using LAMBDA and PROG variables of 
          function in which error occurred, or function that is 
          broken.)


	      )
	    ((SETQ X (FIXSPELL FAULTX 70 SPELLINGS3 NIL TAIL0 NIL NIL LST)))
	    ((AND DWIMIFYFLG (EQ CLISPCONTEXT (QUOTE IF))
		  (SETQ X (FIXSPELL FAULTX 70 CLISPIFWORDSPLST NIL T NIL NIL 
				    LST)))
	      (RETEVAL (RETDWIM0 (QUOTE CLISPIF0))
		       (QUOTE (PROGN (SETQ CLISPRESPELL T)
				     NIL))
		       T))
	    ((AND DWIMIFYFLG (EQ CLISPCONTEXT (QUOTE FOR))
		  (SETQ X (FIXSPELL FAULTX 70 CLISPFORWORDSPLST NIL T NIL NIL 
				    LST)))
	      (RETEVAL (RETDWIM0 (QUOTE CLISPFOR0))
		       (QUOTE (PROGN (SETQ CLISPRESPELL T)
				     NIL))
		       T))
	    [(AND DWIMIFYFLG NOFIXVARSLST0
		  (SETQ X (FIXSPELL FAULTX 70 NOFIXVARSLST0 NIL TAIL0 NIL NIL 
				    LST]
	    ([AND CLISPFLG (NULL CLISPCHANGES)
		  (NULL CLISPERTYPE)
		  (CDR TAIL)
		  (SETQ X (FIXSPELL FAULTX 70 CLISPINFIXES NIL
				    (OR (AND DWIMIFYFLG (EQ CLISPCONTEXT
							    (QUOTE INFIX)))
					TAIL)
				    NIL NIL LST))
		  (COND
		    ((AND DWIMIFYFLG (EQ CLISPCONTEXT (QUOTE INFIX)))
		      (RETEVAL (RETDWIM0 (QUOTE CLISPATOM1))
			       (QUOTE (PROGN (SETQ CLISPRESPELL T)
					     NIL))
			       T))
		    (T (SETQ X (CLISPATOM (SETQ LST (DUNPACK (SETQ FAULTX X)
							     SKORLST3))
					  TAIL PARENT]
	      (COND
		((AND NEWTAIL (NULL DWIMIFYFLG))
		  (FIXATOM1)))
	      (GO OUT))
	    ((AND (EQ FAULTX (CAR TAIL))
		  (NUMBERP (CAR LST))
		  [SETQ X (SOME LST (FUNCTION (LAMBDA (X)
				    (NOT (NUMBERP X]
		  (FIXSPELL1 FAULTX (SETQ Y (CONS (PACK (LDIFF LST X))
						  (PACK X)))
			     NIL LST (QUOTE MUSTAPPROVE)))
	      (/RPLNODE TAIL (CAR Y)
			(CONS (CDR Y)
			      (CDR TAIL)))
	      (SETQ X (CAR Y))
	      (GO OUT))
	    (T (RETDWIM)))
          [COND
	    ((AND (NULL TAIL0)
		  (EQ FAULTX (CAR TAIL)))       (* If TAIL0 is not NIL, the 
                                                RPLNODE has aleady been done.)
	      (/RPLNODE TAIL X (CDR TAIL]
      OUT (RETDWIM FAULTPOS X])

(FIXATOM1
  [LAMBDA NIL

          (* Called when evaluation went too far before DWIM fixed an 
          CLISP expression. See comment in FIXATOM.)


    (AND SPAGHETTIFLG (ERROR (QUOTE "not implemented yet for spaghetti system")
			     (QUOTE )
			     T))
    (PROG ((POS FAULTPOS)
	   X Y Z POS1)
          (SETQ Y (FSTKARG -1 POS))
          (SETQ Z (FSTKARG 0 POS))
          (SELECTQ (CAR PARENT)
		   ((AND OR PROG PROG2 PROGN LAMBDA NLAMBDA)
		     (COND
		       ((NEQ TAIL (CAR Z))
			 (GO ERROR)))
		     (FRPLACA Z NEWTAIL)        (* Change the binding for the 
                                                tail)
		     (FIXCONTINUE (CADAR NEWTAIL))
		     (SETQ X (CAR NEWTAIL))
		     (GO OUT))
		   NIL)
          [COND
	    ([OR (NEQ TAIL (CAR Y))
		 (NEQ (CAR Z)
		      (COND
			((LISTP NEWTAIL)
			  (CAR PARENT))
			((ATOM (CADR PARENT))
			  (CADR PARENT))
			(T 

          (* For infixes like EQ, AND, OR, the function that was about 
          to be called may now be parenthesized, e.g. 
          (FOO X EQ Y) becomes (EQ (FOO X) Y))


			   (CAADR PARENT]

          (* The procedure followed assumes that Y gives the binding 
          for TAIL, and Z gives the binding for the name of the 
          function that is about to be called.
          This checks to make sure that this is in fact the case)


	      (GO BAD))
	    ((NLISTP NEWTAIL)

          (* Occurs when CAR of an xpression in which a CLISP operator 
          is used is the name of a function, e.g. 
          (FOO + X), (FOO X AND FIE Y). Note that at this point in the 
          evaluton, the nterpreter is evaluating the 'arguments' for 
          that function, and plans to call it when they have all been 
          evaluated.)


	      )
	    ((OR (CDR NEWTAIL)
		 (ZEROP (LOGAND (ARGTYPE (CAR PARENT))
				2)))

          (* Either there are more arguments following the CLISP 
          expression, or, in the case of a spread, evaluate, it 
          doesn't matter if an extra NIL is passed.
          Therefore, proceed by smashing the last argument with the 
          value of the CLISP expression, 
          (CAR NEWTAIL), change the binding for the tail to be 
          (CDR NEWTAIL), and RETDWIM with the next expression on TAIL, 
          (CADR NEWTAIL).)


	      [FRPLACA (VAG (SUB1 (LOC Y)))
		       (STKEVAL POS (FIXLISPX/ (CAR NEWTAIL]
	      (FRPLACA Y (CDR NEWTAIL))
	      (SETQ X (CADR NEWTAIL))
	      (GO OUT))
	    (T 

          (* The function to be called is a nospread function, e.g. 
          LIST, and the CLISP expression was its last argument, e.g. 
          (LIST X (--) *2) Therefore can only continue by reevaluating 
          the whole form.)


	       (FIXCONTINUE (CADAR NEWTAIL)
			    (AND (NULL TYPE-IN?)
				 FAULTFN]
          (FRPLACA Y NIL)                       (* Makes tail of the argument 
                                                list be NIL.)
          (FRPLACA Z (QUOTE FIXATOM2))

          (* A nospread, evaluate function whose value is the value of 
          its last argument.)


          (FRPLACD Z (VAG 2))

          (* Makes the function type be a NOSPREAD, EVALUATE function 
          to correspond with the type of FIXATOM2.)


          (SETQ X PARENT)
          (GO OUT)

          (* PARENT will be evaluated, and its value stored on the 
          stack. Then since the tail of the argument list is now NIL, 
          the interpreter figures that the evaluation of arguments is 
          finished, and calls the function.
          However since Z was changed, FIXATOM2 will be called 
          instead, and it will return as its value its last argument, 
          which will be the value of PARENT.
          Voila!)


      BAD                                       (* Stack not in normal state.)
          (SELECTQ (STKNAME (SETQ POS1 (FSTKNTH -1 POS)))
		   [COND
		     (COND
		       ((EQ PARENT NEWTAIL)

          (* The CLISP transformation changed the predicate of a COND 
          clause, e.g. (COND (FOO _ form --) --) Since the COND would 
          ordinarily continue down that clause, it is necessary to 
          continue by constructing an appropriate COND expression, and 
          returning its value as the value of the entire COND.)


			 [SETQ X (CONS (QUOTE COND)
				       (FMEMB PARENT (CAR Y]
			 (SETQ POS POS1)
			 (GO OUT))
		       (T 

          (* The CLISP transformation did not affect the predicate of 
          a COND clause, so can continue by just evaluating PARENT.)


			  (SETQ X (CAR NEWTAIL))
			  (GO OUT]
		   (PROGN 

          (* Error in SELECTQ clause, e.g. 
          (SELECTQ -- (-- A * B)))


			  (SETQ X (CONS (QUOTE PROGN)
					NEWTAIL))
			  (SETQ POS POS1)
			  (GO OUT))
		   NIL)
      ERROR
          (ERROR (QUOTE "DWIM is confused about the stack")
		 (QUOTE )
		 T)
      OUT (RETEVAL POS (FIXLISPX/ X)
		   T])

(FIXCONTINUE
  [LAMBDA (X FN)
    (SETQ X (OR (AND CLISPARRAY (GETHASH X CLISPARRAY))
		X))
    (COND
      ((OR (NLISTP X)
	   (FIXCONTINUE1 X))
	T)
      (T (FIXPRINTIN FN)
	 (DWIMESS (QUOTE " ok to reevaluate "))
	 (PRIN2 (RETDWIM2 X NIL 2)
		T T)
	 (PRIN1 (QUOTE " ?  ")
		T)
	 (OR (EQ (DWIMREADC (ITIMES DWIMWAIT 3)
			    (QUOTE Y))
		 (QUOTE Y))
	     (RETDWIM])

(FIXCONTINUE1
  [LAMBDA (X)                                   (* True if it is ok to 
                                                reevaluate X.)
    (OR (EQ (CAR X)
	    (QUOTE QUOTE))
	(AND (OR (FMEMB (CAR X)
			OKREEVALST)
		 (GETP (CAR X)
		       (QUOTE CROPS))
		 (EQ (CAR (GETP (GETP (CAR X)
				      (QUOTE CLISPCLASS))
				(QUOTE CLISPCLASSDEF)))
		     (QUOTE ARITH)))
	     (PROG NIL
	       LP  (COND
		     ((NULL (SETQ X (CDR X)))
		       (RETURN T))
		     ([AND (LISTP (CAR X))
			   (NULL (FIXCONTINUE1 (CAR X]
		       (RETURN NIL)))
	           (GO LP])

(FIXATOM2
  [LAMBDA X                                     (* Value is the last argument on
                                                the stack.)
    (ARG X X])

(FINDATOM
  [LAMBDA (ATM POS BLIP)

          (* Returns TAIL for which atom is CAR.
          If found on *form* BLIP, also sets free variable PARENT to 
          this form.)


    (PROG (XTAIL TEM NAME)
          (COND
	    ((NULL BLIP))
	    ((SETQ XTAIL (FMEMB ATM BLIP))
	      (SETQ PARENT BLIP)
	      (SETQ SUBPARENT (AND (OR (EQ (CAR PARENT)
					   (QUOTE SETQ))
				       (EQ (CAR PARENT)
					   (QUOTE SAVESETQ)))
				   XTAIL))
	      (RETURN XTAIL)))

          (* The EQ checks for no eval-blip on the stack, the NULL 
          check checks for whether ATM is in that binding.
          In either case, must try something else.)


          [COND
	    ((EQ (SETQ NAME (FSTKNAME POS))
		 (QUOTE PROG))                  (* Error of form 
                                                (PROG (.. (VAR U.B.A.) ..) ..))
	      [SOME (CADR BLIP)
		    (FUNCTION (LAMBDA (X)
			(SETQ XTAIL (FMEMB ATM (SETQ PARENT X]
	      (SETQ SUBPARENT XTAIL))
	    [[EQ ATM (CAR (SETQ TEM (BLIPEVAL (QUOTE PROG)
					      POS]

          (* U.B.A. occurs at top level of COND clause but in 
          consequent, e.g. (COND (& .. U.B.A.
          ..)), or at top level of SELECTQ clause, e.g. 
          (SELECTQ & .. (& .. U.B.A.) ..), or at top level of lambda 
          expression.)


	      (SETQ XTAIL TEM)
	      (COND
		((OR (EXPRP NAME)
		     (STACKP NAME))
		  [SETQ PARENT (COND
		      ((LISTP NAME)

          (* Not sure if this should still be here.
          at one time i think stkname returned the lambda expression 
          itself for open lambda. may never happen anymore, but not 
          sure.)


			NAME)
		      (T 

          (* This works correctly whether NAME is an xpr, i.e. error 
          occurred at top level of lambda that was functon definition, 
          or name is a STACKP, whic correspnds to case where error 
          occurs at top level of lambda expression passed as functonal 
          argument and then apply*'ed.)


			 (FGETD NAME]
		  (SETQ SUBPARENT (AND (EQ XTAIL (CDDR PARENT))
				       XTAIL)))
		[(SETQ FORMSFLG (EQ NAME (QUOTE COND)))
		  (SETQ PARENT (CAR (SOME (NEWFSTKARG 1 POS)
					  (FUNCTION (LAMBDA (X)
					      (TAILP XTAIL X]
		([AND (EQ NAME (QUOTE PROGN))
		      (EQ (FSTKNAME (SETQ POS (FSTKNTH -2 POS POS)))
			  (QUOTE SELECTQ))
		      (SETQ PARENT (CAR (SOME (NEWFSTKARG 1 POS)
					      (FUNCTION (LAMBDA (X)
						  (TAILP XTAIL X]
		  (SETQ SUBPARENT (AND (EQ XTAIL (CDR PARENT))
				       XTAIL]
	    ((AND (LISTP TEM)
		  (EQ ATM (CAAR TEM)))

          (* This is necessary for u.b.a.'s as predicate in COND 
          clause, e.g. (COND .. (U.B.A. ..)))


	      (SETQ PARENT (SETQ XTAIL (CAR TEM)))
	      (SETQ FORMSFLG T))
	    ((AND (LISTP (SETQ PARENT EXPR))
		  (SETQ XTAIL (FMEMB ATM PARENT)))

          (* Desperation. Will work for case like SETQ 
          (FOO 8CONS A B) where there is no higher PARENT containing 
          ATM, but it is contained in EXPR.)


	      (SETQ SUBPARENT (AND (EQ XTAIL (CDR PARENT))
				   XTAIL))
	      (SETQ FORMSFLG T)

          (* e.g. EDITFNS (' (FOO FIE) --) should go to 
          ((QUOTE --)) not (QUOTE -
))


	      ]
          (RETURN (AND PARENT XTAIL])

(CLISPATOM
  [LAMBDA (CLST TAIL PARENT NOFIX89)

          (* CLST is an exploded character list for CAR of TAIL, which 
          is a tail of PARENT, although not necessarily a proper tail.
          ONLYSPELLFLG=T indicates that the ONLY corrections to be 
          attempted are spelling corrections.
          Occurs on calls from CLISPATOM2a.)


    (AND (NULL ONLYSPELLFLG)
	 (PROG (TEM)
	       (COND
		 [(AND (NULL CLISPCHANGES)
		       (OR (EQ CLISPFLG T)
			   (AND (EQ CLISPFLG (QUOTE TYPE-IN))
				TYPE-IN?)))

          (* If CLISPCHANGES is not NIL, a CLISP correction has 
          already been found, so don't bother to find another, e.g. in 
          (X+Y + Z), if X and Y are not bound vriables, after ggetting 
          (IPLUS X Y Z), this would be undone and saved, pending 
          spelling correction on X+Y. Therefore don't do the 
          transformation that staats with +Z.)


		   (RETURN (COND
			     ((SETQ TEM (CLISPATOM0 CLST TAIL PARENT))
			       (LISPXWATCH CLISPSTATS)
			       (LISPXWATCH INFIXSTATS)
			       TEM)
			     (CLISPCHANGES (SETQ LST (DUNPACK FAULTXX CHCONLST))

          (* Since DWIMIFY2, and hence WTFIX, may have been called, 
          LST may have been clobbered.)


					   NIL]
		 ((AND (EQ (CAR CLST)
			   (QUOTE '))
		       (GETP (QUOTE ')
			     (QUOTE CLISPTYPE)))
                                                (* So ' can be disabled when 
                                                CLISP is turned off as well.)
		   [COND
		     [(CDR CLST)
		       [SETQ TEM (LIST (QUOTE QUOTE)
				       (PACK (CDR CLST]
		       (COND
			 ((NULL TAIL))
			 ((NEQ TAIL PARENT)
			   (/RPLNODE TAIL TEM (CDR TAIL)))
			 (T (RETDWIM]
		     ((NULL (CDR TAIL))
		       (RETDWIM))
		     ((EQ TAIL PARENT)
		       (/RPLNODE TAIL (QUOTE QUOTE)
				 (CDR TAIL))
		       (SETQ TEM TAIL))
		     (T (/RPLNODE TAIL (SETQ TEM (LIST (QUOTE QUOTE)
						       (CADR TAIL)))
				  (CDDR TAIL]
		   (RETURN TEM)))
	       (COND
		 ([OR NOFIX89 (NULL (OR (SETQ TEM (FMEMB 8 CLST))
					(SETQ TEM (FMEMB 9 CLST]
		   NIL)
		 [(AND (OR (LISTP FAULTX)
			   TAIL)
		       (FIX89 FAULTX (CAR TEM)))
		   (RETDWIM FAULTPOS (COND
			      ((ATOM FAULTX)
				(CAR TAIL))
			      (T FAULTX]
		 ((AND TYPE-IN? (EQ (CAR TEM)
				    8)
		       (EQ (CAR (SETQ TEM (FLAST CLST)))
			   9))

          (* This corresponds to the case where an atom was typed in 
          containing both an 8 and a 9, e.g. FILES?89 or 8EDITF9.
          Note that if the atom were part of a larger expression, 
          either CAR of form, or appearing in a tail, 
          (as indicated by TAIL being non-NIL), the fix is performed 
          by FIX89, and involves editing the expression.
          In the case covered here, the fix requires changing the EVAL 
          to an apppropriate APPLY. The case where the 8 or 9 error 
          appears in an APPLY context, or line format, is taken care 
          of in WTFIX.)


		   (FIX89TYPEIN (FMEMB 8 (SETQ TEM (LDIFF CLST TEM)))
				TEM T])

(GETVARS
  [LAMBDA (X)
    (PROG (L POS TEM)
          (COND
	    ((EQ X T)                           (* context is inside of a BREAK 
                                                -
                                                Gets variables of BRKFN.)
	      (SETQ POS (NEWSTKPOS (QUOTE BREAK1)
				   -1 FAULTPOS))
	      [COND
		([LITATOM (STKARGNAME 1 (SETQ TEM (FSTKNTH -1 POS]

          (* If the first argument's name is #0 or #100, there are no 
          genuine variables.)


		  (SETQ L (VARIABLES TEM]
	      (SETQ X (NEWFSTKARG 1 POS))
	      (RELSTK TEM)
	      (RELSTK POS)

          (* Sets X to BRKEXP the first argument to BREAK1.
          Used for getting PROG variables below.)


	      )
	    [(EQ (CAR X)
		 (QUOTE LAMBDA))                (* Gets variables for expression
                                                X.)
	      (SETQ L (APPEND (CADR X]
	    (T (RETURN NIL)))
          (RETURN (NCONC L (AND (LISTP X)
				(MAPCAR (CADR (FASSOC (QUOTE PROG)
						      X))
					(FUNCTION (LAMBDA (X)
					    (COND
					      ((ATOM X)
						X)
					      (T (CAR X])

(FIX89
  [LAMBDA (FORM N POS)

          (* Handles corrections for 8 and 9 errors.
          N is either 8 or 9.0 POS is optional, and if given, it is 
          the position of the 8 or 9 in the offending atom, and also 
          indicates that the user has already approved the 
          correction.)


    (PROG [SPLIT89FLG [C (COND
			   ((EQ N 8)
			     (QUOTE FIX8))
			   (T (QUOTE FIX9]
		      (WRONG (COND
			       ((ATOM FORM)
				 FORM)
			       (T (CAR FORM]
          (COND
	    ([OR (AND (ATOM FAULTX)
		      (NULL TAIL))
		 (AND (NULL POS)
		      (NULL (FIX89A FAULTX N]   (* pointless to attempt an 8 or 
                                                9 correction if TAIL is NIL.)
	      (RETURN NIL)))

          (* Gets user approval if necessary, i.e. if TYPE-IN? is NIL 
          and APPROVEFLG is T.)


          (EDITE EXPR (LIST (LIST (QUOTE ORR)
				  (LIST (LIST (COND
						((ATOM FORM)
						  (QUOTE F))
						(T (QUOTE F=)))
					      FORM T)
					(LIST C NIL POS))
				  NIL)))

          (* Constructs command of form ((ORR 
          ((F= FORM T) C) NIL)) C is either FIX8 or FIX9 depending on 
          call.)


          (RETURN (COND
		    ((NULL SPLIT89FLG)          (* Set in SPLIT89 if 
                                                successful.)
		      (LISPXPRINT (QUOTE couldn't)
				  T)
		      NIL)
		    (T (AND DWIMIFYFLG (SETQ 89CHANGE T))
		       T])

(FIXPRINTIN
  [LAMBDA (FN FLG)                              (* If FLG is T, printing goes on
                                                history lst.)
    (AND FN (NEQ FN (QUOTE TYPE-IN))
	 (PROG ((LISPXHIST (AND FLG LISPXHIST)))
	       (AND (NEQ (POSITION T)
			 0)
		    (LISPXSPACES 1 T))
	       (LISPXPRIN1 (QUOTE {)
			   T)
	       (LISPXPRIN1 (COND
			     [(OR (AND DWIMIFYFLG DWIMIFYING)
				  (NULL FAULTAPPLYFLG))
			       (COND
				 (LCASEFLG 

          (* Done this way instead of just printing the lower case 
          version because users may want to efer to the message to 
          undo a dwim correction, e.g. by typing UNDO : $IN$.)


					   (QUOTE "in "))
				 (T (QUOTE "IN "]
			     (LCASEFLG (QUOTE "below "))
			     (T (QUOTE "BELOW ")))
			   T)
	       (LISPXPRIN2 FN T T)
	       (LISPXPRIN1 (QUOTE })
			   T])

(FIX89A
  [LAMBDA (X N POS)
    [COND
      ((LISTP X)
        (SETQ X (CAR X]
    (OR POS (SETQ POS (STRPOS N X)))
    (COND
      ((FIXSPELL1 X (CONS [CONCAT (OR (SUBSTRING X 1 (SUB1 POS))
                                      (QUOTE ""))
                                  (COND
                                    ((EQ N 8)
                                      (QUOTE " ("))
                                    (T (QUOTE " )"]
                          (OR (SUBSTRING X (ADD1 POS))
                              (QUOTE "")))
                  NIL LST (AND (NULL TYPE-IN?)
                               (QUOTE MUSTAPPROVE)))
        T)
      (DWIMIFYFLG (SETQ ATTEMPTFLG T)
                  NIL])

(FIX89B
  [LAMBDA (N X LISPXHIST)
    (PROG [(C (COND
		((EQ N 9)
		  (QUOTE ") "))
		(T (QUOTE " ("]
          [COND
	    ((EQ (CAR X)
		 N)
	      (LISPXPRIN1 C T)
	      (LISPXPRIN2 (CADR X)
			  T T))
	    (T (LISPXPRIN2 (CAR X)
			   T T)
	       (LISPXPRIN1 C T)
	       (COND
		 ((SETQ X (CDDR X))
		   (LISPXPRIN2 (CAR X)
			       T T]
          (LISPXTERPRI T])

(SPLIT89
  [LAMBDA (N POS)

          (* Generates command that replaces atoms containing 8 or 9 
          with the corresponding atom or atoms separated by the 8 or 9 
          so macro calling it can determine where to insert or remove 
          parentheses.)


    (PROG (X Y Z)
          (SETQ X (DUNPACK (CAR L)
                           SKORLST3))
          [SETQ Y (COND
              (POS (SETQ Y (NLEFT X POS)))
              (T (FMEMB N X]
          [COND
            ((NULL Y)

          (* User has already corrected atom containing 8 or 9 Now we 
          must guess what form it is. Assume if N is 8, was error of 
          form 8CONS, if 9, X9)


              (RETURN (LIST (COND
                              ((EQ N 8)
                                (QUOTE B))
                              (T (QUOTE A)))
                            N]
          [COND
            ((CDR Y)
              (SETQ Z (CONS (PACK (CDR Y))
                            Z]
          (SETQ Z (CONS N Z))
          [COND
            ((NEQ Y X)
              (SETQ Z (CONS (PACK (LDIFF X Y))
                            Z]
          (SETQ SPLIT89FLG Z)
          (RETURN (CONS (QUOTE :)
                        Z])

(FIXT
  [LAMBDA NIL
    (PROG (FIXTN FIXTX POS Z)
          [COND
	    ((AND APPROVEFLG (NULL TYPE-IN?))
	      (DWIMESS (QUOTE "u.d.f. T"))
	      (AND FAULTFN (FIXPRINTIN FAULTFN))
	      (COND
		((NEQ (DWIMREADC (ITIMES DWIMWAIT 3)
				 (QUOTE Y)
				 (QUOTE "   fix?   "))
		      (QUOTE Y))
		  (AND DWIMIFYFLG (SETQ ATTEMPTFLG T))
		  (RETDWIM]

          (* Gets user approval if necessary, i.e. if TYPE-IN? is NIL 
          and APPROVEFLG is T.)


          (AND (SETQ Z (GET LISPXHIST (QUOTE LISPXPRINT*)))
	       (SETQ Z (FLAST Z)))
          (EDITE EXPR (LIST (LIST (QUOTE F=)
				  FAULTX T)
			    FIXT))
          (COND
	    (TYPE-IN? (PRIN1 (QUOTE "T fixed")
			     T)
		      (TERPRI T)
		      (GO OUT)))
          (SETQ FIXTX (SELECTQ FIXTN
			       (1 (QUOTE ("(COND --) (T --)" . "(COND -- (T --))"
					   )))
			       (2 (QUOTE ("(COND -- (-- & (T --)))" . 
"(COND -- (-- &) (T --))")))
			       (3 (QUOTE ("(COND -- ((T --)))" . 
"(COND -- (T --))")))
			       (HELP)))
          (FIXSPELL1 (CAR FIXTX)
		     (CDR FIXTX)
		     NIL T (QUOTE NEEDNOTAPPROVE))
          (COND
	    (DWIMIFYFLG (GO OUT))
	    ((NULL (SELECTQ FIXTN
			    [1 

          (* Can't tell if fell off end of COND, or if last predicate 
          was true and evaluated its consequent and then fell of COND.
          In former case, should continue, in latter must get next 
          form.)


			       (DWIMESS (QUOTE "continue with T clause? ")
					T)
			       (COND
				 ((EQ (SETQ FIXTX (DWIMREADC (ITIMES DWIMWAIT 3)
							     (QUOTE Y)))
				      (QUOTE Y))

          (* FIXTX has been set to (PROGN -
          rest of T clause) during editing.)


				   T)
				 ((EQ FIXTX (QUOTE N))

          (* The T clause has now been moved.
          To continue by skipping over it, it is necessary to return 
          with the NEXT form after where the T clause WAS.)


				   (SETQ FAULTX (CAR (NEWBLIPEVAL (QUOTE PROG)
								  FAULTPOS]
			    (2 (FIXCONTINUE FAULTX))
			    (3 T)
			    (HELP)))
	      (RETDWIM)))
      OUT [AND (NULL TYPE-IN?)
	       (NEQ (CAR SIDES)
		    (QUOTE CLISP% ))
	       (SETQ SIDES (LIST (QUOTE CLISP% )
				 (LIST (QUOTE *)
				       (OR (CDR Z)
					   (GET LISPXHIST (QUOTE LISPXPRINT*)))
				       SIDES]
          (RETDWIM FAULTPOS FAULTX])

(CLISPFUNCTION?
  [LAMBDA (TAIL TYP FN1 FN2 Y)

          (* REturns TRUE if (CAR TAIL) corresponds to the name of a 
          function (Possibly misspelled). If TYP=NOTVAR, checks first 
          to make sure (CAR TAIL) does not correspond to the name of a 
          variable.)



          (* FN1 and FN2 are used to compute the arguments to 
          FIXSPELL1. FN1 is given (CAR TAIL) and Y as its arguments, 
          FN2 (CAR TAIL) or the corrected spelling, and Y.
          If FN1 is supplied, FIXSPELL is called so as not to print 
          any messages, and the interaction takes place under 
          CLISPUNCTION? control via a direct call to FIXSPELL1.
          In this case, if TYP=QUIET, no message is printed at all.
          -
          If FN1 is not suppied, FIXSPELL will take care of the 
          interaction, if any, othrwisre there are no error messages.)


    (PROG (TEM LST)
          (COND
	    ((NULL (LITATOM (CAR TAIL)))
	      (RETURN NIL))
	    ((LISTP TYP)

          (* Means that we already know that 
          (CAR TAIL) is not the name of a variable, and is also not 
          the name of a function.)


	      (SETQ LST TYP)
	      (GO SPELL))
	    ([AND (EQ TYP (QUOTE NOTVAR))
		  (NULL (CLISPNOTVARP (CAR TAIL]
	      (RETURN NIL))
	    ([OR (FGETD (CAR TAIL))
		 (GETP (CAR TAIL)
		       (QUOTE EXPR))
		 (GETP (CAR TAIL)
		       (QUOTE MACRO))
		 (FMEMB (CAR TAIL)
			(COND
			  (DWIMIFYFLG NOFIXFNSLST0)
			  (T NOFIXFNSLST)))
		 (LISTP (GETP (CAR TAIL)
			      (QUOTE CLISPWORD]
	      (GO OUT))
	    ((OR NOSPELLFLG (STRPOSL CLISPCHARRAY (CAR TAIL)))
	      (RETURN NIL)))
          (SETQ LST (DUNPACK (CAR TAIL)
			     SKORLST3))
      SPELL
          (COND
	    ([NULL (SETQ TEM (CAR (NLSETQ (FIXSPELL (CAR TAIL)
						    70 SPELLINGS2
						    (AND FN1 (QUOTE NO-MESSAGE))
						    (COND
						      ((NULL FN1)
							TAIL)
						      (T T))
						    NIL NIL LST]
	      (RETURN NIL)))
      OUT (RETURN (COND
		    ([OR (NULL FN1)
			 (AND (EQ TYP (QUOTE QUIET))
			      (NULL TEM))
			 (FIXSPELL1 [COND
				      (TYPE-IN? (QUOTE ""))
				      (T (CONCAT "in ... " (APPLY*
						   FN1
						   (CAR TAIL)
						   Y]
				    (COND
				      (TYPE-IN? (APPLY* FN2
							(OR TEM (CAR TAIL))
							Y))
				      (T (CONCAT "is '" (COND
						   ((NULL TEM)
						     (CAR TAIL))
						   ((LISTP TEM)
						     (CAR TEM))
						   (T TEM))
						 
					 "' meant to be used as a function")))
				    NIL T (AND (OR FN1 (LISTP TEM))
					       (QUOTE MUSTAPPROVE))
				    (AND (LISTP TEM)
					 (QUOTE n]

          (* If TYP=QUIET (from DWIMIFY2), the message is printed only 
          on spelling correction. For other calls, e.g. TYP=OKVAR, or 
          TYP=NOTVAR, the message is printed even if no correction 
          involved.)


		      [AND TEM FN1 (COND
			     ((LISTP TEM)       (* Run on correction.)
			       (/RPLNODE TAIL (CAR TEM)
					 (CONS (CDR TEM)
					       (CDR TAIL)))
			       (SETQ TEM (CAR TEM)))
			     (T (/RPLNODE TAIL TEM (CDR TAIL]

          (* If FN1 is NIL, TAIL would have been given to FIXSPPELL, 
          and in this case the correction would already have been 
          stmashed into TAIL.)


		      (CAR TAIL])

(CLISPNOTVARP
  [LAMBDA (X)
    (AND (EQ (CAR X)
	     (QUOTE NOBIND))
	 (NOT (FMEMB X VARS))
	 [NOT (FMEMB X (COND
		       (DWIMIFYFLG NOFIXVARSLST0)
		       (T NOFIXVARSLST]
	 (OR (AND DWIMIFYFLG DWIMIFYING)
	     (NULL (NEWSTKSCAN X FAULTPOS)))
	 (NOT (GETP X (QUOTE GLOBALVAR)))
	 (NOT (FMEMB X GLOBALVARS])

(CLISPELL
  [LAMBDA (FORM TYP)
    (PROG (VAL TEM TAIL)
          [MAPC (GET LISPXHIST (QUOTE RESPELLS))
                (FUNCTION (LAMBDA (X)
                    (COND
                      ((SETQ TAIL (FMEMB (CAR X)
                                         FORM))
                        (SETQ TEM (CDR X))
                        [COND
                          [(LISTP TEM)
                            (/RPLNODE TAIL (CAR TEM)
                                      (CONS (CDR TEM)
                                            (CDR TAIL]
                          (T (/RPLNODE TAIL TEM (CDR TAIL]
                        (AND (OR (NULL TYP)
                                 (EQ (CAR (GETP (CAR TAIL)
                                                (QUOTE CLISPWORD)))
                                     TYP))
                             (SETQ VAL T]
          (RETURN VAL])

(DWIMIFY3
  [LAMBDA (L)

          (* Climbs L and makes list of all bound variabes.
          Sets EXPR to the top level expression, i.e. 
          (CAR (LAST L)))


    (MAPCONC L (FUNCTION (LAMBDA (X)
                 (SETQ EXPR X)
                 (SELECTQ (CAR X)
                          [PROG (MAPCAR (CADR X)
                                        (FUNCTION (LAMBDA (X)
                                            (COND
                                              ((ATOM X)
                                                X)
                                              (T (CAR X]
                          [[LAMBDA NLAMBDA FOR for]
                            (COND
                              ((ATOM (CADR X))
                                (LIST (CADR X)))
                              (T (APPEND (CADR X]
                          ((FOR for))
                          NIL])

(HELPFIX
  [LAMBDA (NOEDITFLG)

          (* Calls editor on last interpreted function or argument to 
          EVAL, and searches for the last interpreted form, i.e. the 
          one currently being interpreted.
          If user exits from editor via OK, and if this eval-blip was 
          responsible for the BREAK, also resets BRKEXP so user can 
          continue computation via OK.)


    (PROG ((POS (FSTKNTH (COND
			   ((AND (EVQ BRKTYPE)
				 SPAGHETTIFLG)
			     -2)
			   (T -1))
			 (QUOTE BREAK1)))
	   POS1)
          (RETURN
	    (PROG1
	      (PROG (FORM FN EXPR TYPE-IN? HELPFIXTAIL PARENT HELPFIXFLG 
			  NOCHANGEFLG TEM FORMSFLG SUBPARENT)
		    (EVQ BRKEXP)
		    (EVQ LASTPOS)
		LP  (SETQ POS1 (FSTKNTH -1 LASTPOS))
		    (COND
		      ((OR (NLISTP BRKTYPE)
			   (NOT (EQP LASTPOS POS)))

          (* All types of breaks except u.b.a.
          or u.d.f. Breaks, or else user has reset LASTPOS.
          Procedure is to search for *FORM* and then find super 
          expression containing it.)


			(SETQ FORM (BLIPEVAL (QUOTE EVAL)
					     POS1))

          (* NEED TO INSERT CODE TO HANDLE CASE WHERE EVAL-BLIP COMES 
          FROM AN ERSETQ OR NLSETQ IN A COMPILED FUNCTION.)


			[SETQ NOCHANGEFLG (NEQ (CAR FORM)
					       (EVALV (QUOTE BRKFN]

          (* Indicates whether to reset BRKEXP, i.e. did the scan find 
          the FORM causing the BREAK. For example, if performed 
          (ADD1 T) BRKEXP would be (ADD1 X), so after editing, it 
          should be reset to whatever (ADD1 T) now is.
          The situation where the FORM found does not correspond 
          occurs for example if an APPLY caused the error, or if the 
          error occurs out of a compiled function -
          In this case the FORM obtained by edit is the last 
          interpreted one. note that for U.B.A.
          Or U.D.F. Breaks, FORM is given to BREAK1.)


			)
		      [(NOT (ATOM BRKEXP))      (* U.D.F. BREAK)
			(COND
			  [(EQ (CAR BRKEXP)
			       (QUOTE APPLY))
			    (SETQ FORM (CADADR BRKEXP))
			    (OR (SETQ HELPFIXTAIL (FIXAPPLY1 LASTPOS FORM FORM
							     (CAR BRKTYPE)))
				(RETURN (QUOTE can't]
			  (T (SETQ FORM BRKEXP]
		      ((SETQ HELPFIXTAIL (FINDATOM BRKEXP LASTPOS (CAR BRKTYPE))
			  )

          (* U.B.A. BREAK. The value of BRKTYPE is a BLIPEVAL for 
          eval-blip performed in FAULT1 before the BREAK was induced 
          by a RETEVAL.)


			(SETQ FORM BRKEXP)))
		    [COND
		      ([OR (NULL FORM)
			   (NULL (SETQ FN (FINDFN (COND
						    ((AND (LISTP BRKTYPE)
							  (EQP LASTPOS POS))

          (* The only time to consider the function at LASTPOS as a 
          possible candidate is on error breaks when LASTPOS has not 
          been reset.)


						      LASTPOS)
						    (T POS1]
			(RETURN (QUOTE can't)))
		      ((ATOM EXPR)              (* Set in FINDFN.)
			(RETURN (QUOTE can't]
		    [COND
		      (NOEDITFLG 

          (* For use with IN? command: find and print parent form but 
          do not call editor.)


				 (PRIN2 FN T T)
				 (PRIN1 (QUOTE ":  ")
					T)
				 (RETURN (COND
					   ((NLISTP FORM)
					     PARENT)
					   (T FORM]
		    (PRIN1 (QUOTE "in ")
			   T)
		    (PRIN2 FN T T)
		    (PRINT (QUOTE ...)
			   T)
		    (COND
		      ([NULL
			  (NLSETQ
			    (EDITE
			      EXPR
			      (NCONC
				[COND
				  ((EQ EXPR FORM)
				    (SETQ HELPFIXTAIL (LIST FORM))
				    NIL)
				  ((ATOM FORM)
                                                (* The IF makes sure you find 
                                                the right atom.)
				    (LIST [LIST (QUOTE LC)
						(QUOTE F)
						FORM
						(QUOTE (IF (EQ (##)
							       HELPFIXTAIL]
					  0))
				  (T 

          (* Set HELPFIXTAIL so that if the user replaces the entire 
          offending expression, e.g. via MBD or XTR, 
          (instead of just changing portions of it), can pick up the 
          corresponding expression to for resetting BRKEXP.)


				     (LIST (LIST (QUOTE F=)
						 FORM T)
					   (QUOTE (E (SETQ HELPFIXTAIL
						       (## UP))
						     T]
				(QUOTE ((ORR (P)
					     NIL)
					(E (EDITL0 (SETQ HELPFIXFLG L))
					   T]

          (* Explanation of EDIT commands: NEQ is because EXPR may in 
          fact be the offending FORM, e.g. do EVAL of an expression 
          whose CAR is undefined. The F= is to make sure you find the 
          FORM that is EQ to FORM. The lc and if is necessary because 
          if FORM is an atom, HELPFIXTAIL will be non-nil, and must 
          check to make sure have found that u.b.a.
          If HELPFIXTAIL is non-nil,)


			(AND (NULL HELPFIXFLG)
			     (PRINT (QUOTE (not found))
				    T))
			(RETURN)))              (* Reset BRKEXP.)
		    (COND
		      ((AND DWIMFLG FILEPKGFLG (EXPRP FN))
			(NEWFILE? FN)))
		    (COND
		      (NOCHANGEFLG (GO NOCHANGE)))
		    (SETQ TEM (CAR HELPFIXTAIL))
		    [COND
		      (TYPE-IN? (SETQ TEM (LISPX/ TEM NIL (DWIMIFY3 HELPFIXFLG]

          (* HELPFIXFLG is L, the edit push-down list, leding up to 
          BRKEXP. DWIMIFY3 climbs it and returns list of bound 
          variables.)


		    (COND
		      ((LISTP BRKTYPE)          (* U.B.A. or U.D.F.
                                                break.)

          (* Note that the / substitution will not affect any editing 
          changes made beyond the scope of BRKEXP.
          The only way to catch these would be to destructively 
          substitute throughout EXPR.)


			(COND
			  ((EQ (CAR BRKEXP)
			       (QUOTE APPLY))   (* Fixes stack so if in mapping 
                                                function won't get another 
                                                u.d.f. Error)
			    (/RPLNODE (CDADR BRKEXP)
				      TEM NIL)
			    (FIXAPPLY1 LASTPOS FORM TEM BRKTYPE)
                                                (* NEEDS TO BE CHECKED WHEN 
                                                COMPILER ARRIVES.)
			    )
			  (T (SETQ BRKEXP TEM)))
			(RETURN FN))
		      (T 

          (* STKEVAL is used in the new BRKEXP because the lambda 
          variables of the function broken may clash with variables in 
          FORM. E.g. User gets a BREAK on FOO, looks at its arguments, 
          finds a bug. So he does an EDIT to get to the place where 
          FOO was called, say it is (FOO 
          (CAR X)), and changes CAR to CADR to correct it.
          Now even if FOO has an argument named X, he can continue in 
          the FOO BREAK because the new BRKEXP is 
          (STKEVAL (FSTKNTH -1 POS) (QUOTE 
          (FOO (CADR X)))))


			 (SETQ BRKEXP (FSTKNTH -1 POS))
			 (AND (NEQ CLEARSTKLST T)
			      (SETQ CLEARSTKLST (CONS BRKEXP CLEARSTKLST)))
			 (SETQ BRKEXP (LIST (QUOTE STKEVAL)
					    BRKEXP
					    (LIST (QUOTE QUOTE)
						  TEM)
					    T))
			 (RETURN FN)))
		NOCHANGE
		    (PRIN1 (QUOTE "Note: BRKEXP not changed.
")
			   T)
		    (RETURN FN))
	      (RELSTK POS)
	      (RELSTK POS1])

(HELPFIX1
  [LAMBDA (X HIST)

          (* Designed for use with UBA and UDF breaks.
          Performs the changes that would have been done in spelling 
          corrector.)


    (COND
      ((OR (NLISTP (EVQ BRKTYPE))
	   (NULL X))

          (* Not a u.b.a. Or u.d.f. BREAK, or else nothing typed on 
          line following ->)


	(PRINT (QUOTE ?)
	       T)
	NIL)
      (T (PROG (FAULTFN TAIL PARENT EXPR TYPE-IN? (POS (FSTKNTH (COND
								  (SPAGHETTIFLG
								    -1)
								  (T 0))
								(QUOTE BREAK1)))
			TEM FORMSFLG SUBPARENT)
	       (EVQ BRKEXP)
	       (SETQ FAULTFN (FINDFN (FSTKNTH 0 POS)))
	       (COND
		 ((ATOM BRKEXP)
		   (COND
		     ((AND [NULL (SETQ TAIL (FINDATOM BRKEXP POS (CAR BRKTYPE]
			   (CDR X))
		       (GO CAN'T)))
		   (SETQ BRKEXP (CAR X))
		   (AND DWIMFLG (NEQ (EVALV (CAR X)
					    POS)
				     (QUOTE NOBIND))
			(ADDSPELL (CAR X)
				  T)
			(MOVETOP (CAR X)
				 SPELLINGS3)
			(MOVETOP (CAR X)
				 USERWORDS))
		   (COND
		     (TAIL (HELPFIX2 TAIL (CAR X)
				     (NCONC (CDR X)
					    (CDR TAIL))
				     HIST)))
		   (GO OUT)))
	       (COND
		 ((EQ (CAR BRKEXP)
		      (QUOTE APPLY))
		   (COND
		     ((CDR X)

          (* Since this is an APPLY error, it doesn't make sense to 
          replace the function name by a function and an argument.)


		       (GO CAN'T)))
		   (AND DWIMFLG (GETD (CAR X))
			(ADDSPELL (CAR X)
				  2)
			(MOVETOP (CAR X)
				 SPELLINGS2))

          (* SPELLINGS2 are used because the APPLY error comes from 
          within a function and is more likely to be a function like 
          CONS, or ADD1, or print, than MAKEFILE, or LOAD.)


		   (FIXAPPLY1 POS (CAR (SETQ TEM (CDADR BRKEXP)))
			      (FIXLISPX/(CAR X))
			      (CAR BRKTYPE))
		   (HELPFIX2 TEM (FIXLISPX/(CAR X))
			     NIL HIST)
		   (HELPFIX2 (SETQ TEM (CDADDR BRKEXP))
			     (FIXLISPX/(CAR TEM)
			       (CAR X))
			     (CDR TEM)
			     HIST))
		 (T (AND DWIMFLG (GETD (CAR X))
			 (ADDSPELL (CAR X)
				   2)
			 (MOVETOP (CAR X)
				  SPELLINGS2))

          (* Adds to SPELLINGS2, list used to correct misspellings of 
          functions inside of other forms.)


		    (HELPFIX2 BRKEXP (FIXLISPX/(CAR X))
			      (NCONC (CDR X)
				     (CDR BRKEXP))
			      HIST)             (* E.g. User can say MEMBX -> 
                                                MEMB X)
		    ))
	   OUT (AND DWIMFLG FILEPKGFLG (EXPRP FAULTFN)
		    (NEWFILE? FAULTFN))
	       (RELSTK POS)
	       (RELSTK (EVQ LASTPOS))
	       (RETEVAL (QUOTE BREAK1)
			BRKEXP)
	   CAN'T
	       (PRINT (QUOTE can't)
		      T)
	       (RELSTK POS)
	       (RETURN])

(HELPFIX2
  [LAMBDA (X A D LISPXHIST0)
    (AND (LISTP X)
         LISPXHIST0
         (UNDOSAVE (CONS X (CONS (CAR X)
                                 (CDR X)))
                   LISPXHIST0))

          (* So that the undoinformation will be saved on the parent 
          event as well as on the -> event.)


    (/RPLNODE X A D])

(FINDFN
  [LAMBDA (POS FLG)

          (* Used by HELPFIX and WTFIX. Locates highest interpreted 
          form in the current chain of interpretation, sets free 
          variable EXPR to this expression and returns the NAME of the 
          corresponding function, or 'BREAK-EXP', 'EVAL', or 'TYPE-IN' 
          depending on context. also sets free variable TYPE-IN? to T 
          if the expression was typed in by the user.)



          (* When called from WTFIX, (FLG is T) and sets the variable 
          BREAKFLG to T if the expression was typed into a BREAK, 
          (In this case, DWIM uses the lambda and/or prog variables 
          for spelling corrections.))


    (PROG1
      (PROG (NAME TEM)
	    [COND
	      ((NULL POS)
		(SETQ POS (FSTKNTH -1]
	LP  (COND
	      ((NULL POS)
		(RETURN NIL)))
	    (SETQ NAME (FSTKNAME POS))
	LP1 (SELECTQ NAME
		     [(APPLY BLKAPPLY)
		       (COND
			 ((EQ (SETQ TEM (NEWFSTKARG 3 POS))
			      (QUOTE SELECTQ))
                                                (* The EVAL in a SELECTQ.)
			   (SETQ POS (FSTKNTH -2 POS POS))
			   (GO LP))
			 ((EQ TEM (QUOTE INTERNAL))
			   (GO LP3)))
		       (SETQ TYPE-IN? TEM)

          (* WTFIX would already know that this was an apply error 
          because of FAULTAPPLYFLG. However, FINDFN is called to find 
          out whether the expression was typed in or not.)


		       (RETURN (COND
				 (FLG (SETQ EXPR (NEWFSTKARG 2 POS))
				      (NEWFSTKARG 1 POS))
				 (T (SETQ EXPR (NEWFSTKARG 1 POS]
		     [APPLY* (RETURN (COND
				       (FLG (SETQ TEM (STKARGS POS))
					    (SETQ EXPR (CDR TEM))
					    (CAR TEM))
				       (T (SETQ EXPR (NEWFSTKARG 1 POS]
		     [EVAL (COND
			     ((EQ (SETQ TEM (NEWFSTKARG 2 POS))
				  (QUOTE SELECTQ))
			       (SETQ POS (FSTKNTH -2 POS POS))
			       (GO LP))
			     ((EQ TEM (QUOTE INTERNAL))
			       (GO LP3)))
			   (SETQ EXPR (NEWFSTKARG 1 POS))
			   (RETURN (SELECTQ
				     TEM
				     (NIL (QUOTE EVAL))
				     (:

          (* Call to EVAL comes from a BREAK 
          (i.e. via a LISPX which was called from BREAK1.))


				       (AND FLG (SETQ BREAKFLG T))
				       (SETQ TYPE-IN? T)
				       (QUOTE TYPE-IN))
				     (BREAK     (* Call to EVAL from evaluation 
                                                of a breakcommand.)
					    (AND FLG (SETQ BREAKFLG T))
					    (QUOTE BREAKCOMS))
				     [BREAK-EXP 
                                                (* Call to EVAL from EVAL, OK, 
                                                or GO command.)
						(COND
						  ((NULL (EVALV (QUOTE BRKTYPE)
								POS))

          (* Since BRKTYPE is NIL, we are in a user BREAK.
          Therefore, if broken function is an EXPR, want to stop 
          searching, otherwise continue (latter can only occur when 
          FINDFN is called as result of EDIT command since WTFIX will 
          never be called out of compiled function.))


						    (SETQ TEM
						      (NEWSTKPOS (QUOTE BREAK1)
								 -1 POS))
						    (RELSTK POS)
						    [SETQ NAME
						      (FSTKNAME (SETQ POS
								  (FSTKNTH
								    -1 TEM TEM]
						    (GO LP2))
						  (T 

          (* EVAL, OK, or GO command to non-user BREAK expression, 
          e.g. get a non-numeric arg BREAK, fix the BRKEXP, do an 
          EVAL, and get another error.)


						     (QUOTE BREAK-EXP]
				     (PROGN (SETQ TYPE-IN? T)
					    (QUOTE TYPE-IN]
		     (STKEVAL (COND
				((EQ (SETQ TEM (NEWFSTKARG 3 POS))
				     (QUOTE HELPFIX))
                                                (* Occurs when you type EVAL, 
                                                go, or ok following operation of
                                                HELPFIX.)
				  (GO LP3)))
			      (SETQ TYPE-IN? TEM)
			      (AND FLG (SETQ BREAKFLG TYPE-IN?))
                                                (* E.g. ?= command.)
			      (SETQ EXPR (NEWFSTKARG 2 POS))
			      (RETURN (QUOTE EVAL)))
		     (ERRORSET (SETQ TEM (FSTKNTH -1 POS))
			       (SETQ TEM (PROG1 (FSTKNAME TEM)
						(RELSTK TEM)))
			       (COND
				 ((OR (EQ TEM (QUOTE NLSETQ))
				      (EQ TEM (QUOTE ERSETQ))
				      (EQ (NEWFSTKARG 2 POS)
					  (QUOTE INTERNAL)))
				   (SETQ POS (FSTKNTH -2 POS POS))
				   (GO LP)))
			       (SETQ EXPR (NEWFSTKARG 1 POS))
			       (RETURN (QUOTE ERRORSET)))
		     NIL)
	LP2 [COND
	      [(LITATOM NAME)
		(COND
		  ([EXPRP (SETQ EXPR
			    (FGETD (COND
				     ([NULL (SETQ TEM (GETP NAME (QUOTE BROKEN]
				       NAME)
				     (T (OR (CDR (GETP NAME (QUOTE ALIAS)))
					    TEM]
		    (RETURN NAME]
	      ((ARRAYP NAME)
		(COND
		  ((EQ (CAR NAME)
		       EVALDEF)                 (* Linked call to EVAL.)
		    (SETQ NAME (QUOTE EVAL))
		    (GO LP1))
		  ((EQ (CAR NAME)
		       APPLYDEF)                (* Linked call to APPLY)
		    (SETQ NAME (QUOTE APPLY))
		    (GO LP1))
		  ([AND (LISTP (CAR NAME))
			(OR (EQ (CAAR NAME)
				(QUOTE LAMBDA))
			    (EQ (CAAR NAME)
				(QUOTE NLAMBDA]
                                                (* Linked functioncall to EXPR.)
		    (SETQ EXPR (CAR NAME))
		    (RETURN NAME]
	LP3 (SETQ POS (FSTKNTH -1 POS POS))
	    (GO LP))
      (RELSTK POS])

(GENSYM?
  [LAMBDA (X)
    (AND (EQ (NTHCHAR X -5)
             (QUOTE A))
         (EQ (NTHCHAR X -4)
             0])

(DWIMUNSAVEDEF
  [LAMBDA (FN FLG)
    (LISPXPRIN2 FN T T)
    [AND (NULL FLG)
	 (NULL TYPE-IN?)
	 (NEQ (CAR SIDES)
	      (QUOTE CLISP% ))
	 (SETQ SIDES (LIST (QUOTE CLISP% )
			   (LIST (QUOTE *)
				 (FLAST (GET LISPXHIST (QUOTE LISPXPRINT*)))
				 SIDES]

          (* FLG is TRUE on calls from CLISPIFY, in which case SIDES 
          is not relevant (or even bound))


    (LISPXPRIN1 (COND
		  (LCASEFLG (QUOTE " unsaved"))
		  (T (QUOTE " UNSAVED")))
		T)
    (LISPXTERPRI T)
    (UNSAVEDEF FN])

(WTFIXLOADEF
  [LAMBDA (FAULTEM1)                            (* FAULTEM1 is the value of the 
                                                FILEDEF property.)
    (PROG (FAULTEM2 FAULTEM3)
          (SETQ FAULTFN NIL)                    (* So file package wont try to 
                                                update it)
          (RETURN (COND
                    ([NULL (SETQ FAULTEM2
                             (OR [INFILEP (SETQ FAULTEM2
                                            (COND
                                              ((ATOM FAULTEM1)
                                                (* FAULTEM1 is the name of the 
                                                file.)
                                                FAULTEM1)
                                              (T 

          (* (CAR FAULTEM1) is the name of the file.
          CDR is the list of functions.)


                                                 (PROG1 (CAR FAULTEM1)
                                                        (SETQ FAULTEM1
                                                          (CDR FAULTEM1]
                                 (INFILEP (PACK (LIST (QUOTE <NEWLISP>)
                                                      FAULTEM2)))
                                 (INFILEP (PACK (LIST (QUOTE <LISP>)
                                                      FAULTEM2]
                                                (* IF FILE ISNT THERE DONT 
                                                BOTHER TO ASK.)
                      NIL)
                    ((COND
                        ((OR (ATOM FAULTEM1)
                             (NLISTP (CAR FAULTEM1)))
                          (DWIMESS (QUOTE "Shall I load ")
                                   (QUOTE MUSTAPPROVE))

          (* FIXSPELL1 notused since it requires the user see the 
          entire message before typing in an answer.)


                          (EQ (DWIMREADC DWIMWAIT (QUOTE Y)
                                         (CONCAT FAULTEM1 (QUOTE " ? ")))
                              (QUOTE Y)))
                        ([STRINGP (SETQ FAULTEM3 (EVAL (PROG1 (CAR FAULTEM1)
                                                              (SETQ FAULTEM1
                                                                (CDR FAULTEM1]

          (* (CAR FAULTEM1) computes either a string to be typed, or T 
          or NIL, meaning do it or dont do it.)


                          (FIXSPELL1 (QUOTE "")
                                     FAULTEM3
                                     (QUOTE "")
                                     NIL
                                     (QUOTE MUSTAPPROVE)))
                        (T FAULTEM3))
                      [RESETVAR NOLINKMESS T (COND
                          ((ATOM FAULTEM1)
                            (LOAD FAULTEM2))
                          (T (LOADFNS FAULTEM1 FAULTEM2]
                      T])

(CLISP% 
  [NLAMBDA CLISPX
    (PROG (CLISPTEM)
          [COND
	    ((AND (OR CLISPARRAY #CLISPARRAY)
		  (EQ [CAR (SETQ CLISPTEM (NEWBLIPEVAL (QUOTE EVAL)
						       (STKNTH -1 CLISPTRANFLG]
		      CLISPTRANFLG)
		  (EQ (CDR CLISPTEM)
		      CLISPX))
	      (CLISPTRAN CLISPTEM (CADR CLISPTEM))
	      (/RPLNODE CLISPTEM (CADDR CLISPTEM)
			(CDDDR CLISPTEM]
          (RETURN (EVAL (CAR CLISPX)
			(QUOTE INTERNAL])

(CHECKTRAN
  [LAMBDA (X)
    (OR (AND CLISPARRAY (GETHASH X CLISPARRAY))
	(AND CLISPTRANFLG (EQ (CAR X)
			      CLISPTRANFLG)
	     (PROG1 (CADR X)
		    (COND
		      ((OR CLISPARRAY #CLISPARRAY)
			(CLISPTRAN X (CADR X))
			(/RPLNODE X (CADDR X)
				  (CDDDR X])
)
  (RPAQQ LAMBDASPLST [LAMBDA NLAMBDA])
  [RPAQQ FIXT (IF (EQ (## BK 1)
		      (QUOTE COND))
		  ((E (SETQQ FIXTN 1)
		      T)
		   (E (SETQ FAULTX (CONS (QUOTE PROGN)
					 (CDR FAULTX)))
		      T)
		   (MV N BK))
		  (!0 0 (IF (EQ (## 1)
				(QUOTE COND))
			    ((ORR ((RI -1 -2)
				   (E (SETQQ FIXTN 2)
				      T)
				   (E (SETQ FAULTX (## -2 -1))
				      T))
				  ((BO -1)
				   (E (SETQQ FIXTN 3)
				      T)
				   (E (SETQQ FAULTX T)
				      T]
  (RPAQ DWIMUSERFN)
  (RPAQQ OKREEVALST
	 (AND OR PROGN SETQ SAVESETQ CAR CDR ADD1 SUB1 CONS LIST EQ EQUAL PRINT 
	      PRIN1 APPEND NEQ NOT NULL))
  (RPAQ NOFIXFNSLST)
  (RPAQ NOFIXFNSLST0)
  (RPAQ NOFIXVARSLST)
  (RPAQ NOFIXVARSLST0)
  (RPAQ NOSPELLFLG)
[DECLARE: DOEVAL@COMPILE DONTCOPY 
(DEFLIST(QUOTE(
  [/RPLNODE (LAMBDA (X A D HIST)
		    (COND ((LISTP X)
			   (AND LISPXHIST (UNDOSAVE (CONS X
							  (CONS (CAR X)
								(CDR X)))
						    LISPXHIST))
			   (FRPLACA X A)
			   (FRPLACD X D))
			  (T (/RPLACA X A)
			     (/RPLACD X D]
))(QUOTE BLKLIBRARYDEF))
]
  (RPAQQ FILEDEFLST
	 (ALLOCATESTRUC BREAKDOWN CALLS CIRCLMAKER CIRCLMAKER1 CIRCLPRINT 
			CLISPRECORD CPLISTS DEFSTRUC EDITA FREEVARS HELPSYS 
			INTERSCOPE MAKEMATCH PRINTSTRUCTURE RECCOMPOSE0 RECORD1 
			RECORDECL SETUPHASHARRAY STRUCTURE TRANSOR TRANSORSET 
			VARS WHOCALLS))
(DEFLIST(QUOTE(
  (ALLOCATESTRUC (RECORDSTRUC.COM ALLOCATESTRUC /TYPESTATUS))
  (BREAKDOWN BRKDWN.COM)
  (CALLS PRSTRUC.COM)
  (CIRCLMAKER CIRCL.COM)
  (CIRCLMAKER1 CIRCL.COM)
  (CIRCLPRINT CIRCL.COM)
  (CLISPRECORD RECORD.COM)
  (CPLISTS (UTILITY.COM CPLISTS CPLISTSM))
  (DEFSTRUC STRUC.COM)
  (EDITA EDITA.COM)
  (FREEVARS PRSTRUC.COM)
  (HELPSYS HELPSYS.COM)
  (INTERSCOPE INTERSCOPE.COM)
  (MAKEMATCH MATCH.COM)
  (PRINTSTRUCTURE PRSTRUC.COM)
  (RECCOMPOSE0 RECORD.COM)
  (RECORD1 RECORD.COM)
  (RECORDECL RECORD.COM)
  (SETUPHASHARRAY (RECORDSTRUC.COM SETUPHASHARRAY))
  (STRUCTURE STRUC.COM)
  (TRANSOR TRANSOR.COM)
  (TRANSORSET TRANSOR.COM)
  (VARS PRSTRUC.COM)
  (WHOCALLS (UTILITY.COM WHOCALLS WHOCALLS0 WHOCALLS1))
))(QUOTE FILEDEF))
(DEFLIST(QUOTE(
  (WTFIX (DWIM WTFIX CLISP DWIMIFY))
))(QUOTE FILEGROUP))
(DEFLIST(QUOTE(
  (' 15)
))(QUOTE CLISPTYPE))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA CLISP% )
  (ADDTOVAR NLAML)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (1090 83113 (WTFIX 1102 . 1284) (WTFIX0 1288 . 1906) (WTFIX1
1910 . 14533) (FIXLISPX/ 14537 . 14642) (RETDWIM 14646 . 20297) (RETDWIM0
20301 . 20631) (RETDWIM1 20635 . 25240) (RETDWIM2 25244 . 25553) (RETDWIM3
25557 . 26124) (RETEDIT 26128 . 26412) (FIX89TYPEIN 26416 . 27490) (FIXLAMBDA
27494 . 27865) (FIXAPPLY 27869 . 29678) (FIXAPPLY1 29682 . 32403) (FIXATOM
32407 . 36640) (FIXATOM1 36644 . 41682) (FIXCONTINUE 41686 . 42072) (
FIXCONTINUE1 42076 . 42673) (FIXATOM2 42677 . 42845) (FINDATOM 42849 . 46164)
(CLISPATOM 46168 . 49295) (GETVARS 49299 . 50438) (FIX89 50442 . 51908) (
FIXPRINTIN 51912 . 52792) (FIX89A 52796 . 53516) (FIX89B 53520 . 53910) (SPLIT89
53914 . 55163) (FIXT 55167 . 57550) (CLISPFUNCTION? 57554 . 60905) (CLISPNOTVARP
60909 . 61233) (CLISPELL 61237 . 62135) (DWIMIFY3 62139 . 63058) (HELPFIX
63062 . 70266) (HELPFIX1 70270 . 73001) (HELPFIX2 73005 . 73350) (FINDFN 73354
. 78715) (GENSYM? 78719 . 78843) (DWIMUNSAVEDEF 78847 . 79370) (WTFIXLOADEF
79374 . 82392) (CLISP%  82396 . 82831) (CHECKTRAN 82835 . 83110)))))
STOP
