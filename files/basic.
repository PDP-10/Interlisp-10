(FILECREATED "16-OCT-74 19:29:36" BASIC.;2 64823  

     changes to:  RELINK2

     previous date: "15-OCT-74 23:16:43" <NEWLISP>BASIC.;32)


  (LISPXPRINT (QUOTE BASICCOMS)
	      T T)
  [RPAQQ
    BASICCOMS
    ((FNS * BASICFNS)
     [P (COND
	  ((EQ (CAR (QUOTE GENNUM))
	       (QUOTE NOBIND))
	   [MAPC (QUOTE ((FRPLACA . RPLACA)
			 (FRPLACD . RPLACD)
			 (DECLARE . QUOTE)
			 (MAKEPDQ)
			 (SETCV)))
		 (FUNCTION (LAMBDA (X)
				   (PUTD (CAR X)
					 (GETD (CDR X]
	   [COND ((EXPRP (GETD (QUOTE LAPRD)))
		  [PUTDQ STREQUAL
			 (LAMBDA (X Y)
				 (COND
				   ((AND (STRINGP X)
					 (STRINGP Y))
				    (SETQ X (SUBSTRING X 1))
				    (SETQ Y (SUBSTRING Y 1))
				    (PROG (Z)
					  LP
					  [COND
					    ((EQ (SETQ Z (GNC X))
						 (GNC Y))
					     (COND (Z (GO LP))
						   (T (RETURN T]
					  (RETURN]
		  [PUTDQ STRPOS
			 (LAMBDA
			   (X Y START SKIP ANCHOR TAIL)
			   [COND [(LITATOM X)
				  (SETQ
				    X
				    (CDR (VAG (IPLUS (LOC X)
						     2]
				 ((NULL (STRINGP X))
				  (SETQ X (MKSTRING X]
			   [COND ((STRINGP Y))
				 [(LITATOM Y)
				  (SETQ
				    Y
				    (CDR (VAG (IPLUS (LOC Y)
						     2]
				 (T (SETQ Y (MKSTRING Y]
			   [COND (SKIP (SETQ SKIP (NTHCHAR SKIP 1]
			   (COND [START (COND ((MINUSP START)
					       (SETQ
						 START
						 (IPLUS START
							(NCHARS Y)
							1]
				 (T (SETQ START 1)))
			   (SETQ Y (SUBSTRING Y START))
			   (PROG ((N START)
				  W X1 Y1)
				 L2
				 (SETQ X1 (SUBSTRING X 1))
				 (SETQ Y1 (SUBSTRING Y 1))
				 LP
				 (COND
				   [(SETQ W (GNC X1))
				    (COND ((EQ W (GNC Y1))
					   (GO LP))
					  ((EQ W SKIP)
					   (GO LP))
					  (T (GO NX]
				   (TAIL (RETURN (IPLUS (NCHARS X)
							N)))
				   (T (RETURN N)))
				 NX
				 (COND (ANCHOR (RETURN)))
				 (COND ((GNC Y)
					(SETQ N (ADD1 N))
					(GO L2))
				       (T (RETURN]
		  [PUTDQ STRPOSL
			 (LAMBDA (L STR)
				 (PROG (TEM)
				       (SETQ STR (MKSTRING STR))
				       [SOME L (FUNCTION
					       (LAMBDA (X)
						       (SETQ
							 TEM
							 (STRPOS X STR]
				       (RETURN TEM]
		  (PUTDQ MAKEBITTABLE (LAMBDA (X)
					      X]
	   [COND ([AND (NEQ (CAR (QUOTE SPAGHETTIFLG))
			    (QUOTE NOBIND))
		       SPAGHETTIFLG
		       (NULL (GETD (QUOTE SCODEP]
		  (PUTDQ SCODEP (LAMBDA NIL NIL]
	   (RPAQQ GENNUM 10000)
	   (RPAQQ GENSTR "A0001")
	   (RPAQQ NOLINKMESS T)
	   (RPAQQ BINCOMPFLG T)
	   (RPAQQ BINFIXFLG T)
	   (SETQ STRPOSLARRAY (ARRAY 4 4))
	   (RPAQQ OCOREVALS NOBIND)
	   (RPAQQ SCOREVALS NOBIND]
     F *T* (BLOCKS * BASICBLOCKS)
     (P (RELINK (QUOTE BASICBLOCKS)))
     (DECLARE: DOEVAL@COMPILE DONTCOPY
	       (PROP MACRO FGETP FRPTQ OBIN OBOUT OSFBSZ OSIN ONIN 
		     ORFPTR OSFPTR))
     (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
	       (ADDVARS (NLAMA SELECTQ NLIST E)
			(NLAML NOLINKDEF1 RPAQQ FUNCTION]
  (RPAQQ BASICFNS
	 (LAPRD NIN BINRD LCSKIP LCCOP LCSK BINSKIP BINFIX DOLINK CAAR 
		CADR CDAR CDDR CAAAR CAADR CADAR CADDR CDAAR CDADR 
		CDDAR CDDDR CAAAAR CAAADR CAADAR CAADDR CADAAR CADADR 
		CADDAR CADDDR CDAAAR CDAADR CDADAR CDADDR CDDAAR CDDADR 
		CDDDAR CDDDDR ABS ADD1 ARRAYSIZE ARGLIST ARGLIST1 CGETD 
		DELETECONTROL DIFFERENCE ECHOCONTROL E EQUAL EVQ 
		FDIFFERENCE FIX FIXP FMINUS FLOAT FNTYP FNTYP1 FUNCTION 
		GENSYM GETSYNTAX HARRAY IDIFFERENCE ILESSP IMINUS LESSP 
		LRSH NARGS NEQ NILL NLIST NLIST1 NLISTP NTH RATOMS 
		RPAQQ RSH SELECTQ SELECTQ1 SETA SETD SETEDITC SETINTC 
		SETSYNTAX SMALLP STORAGE STREQUAL STRMEMB STRPOS 
		STRPOSL MAKEBITTABLE SUB1 SYNTAXP TYPEP ZEROP RELINK 
		RELINK1 RELINK2 NOLINKDEF1))
(DEFINEQ

(LAPRD
  [LAMBDA (FN)

          (* A note on bootstrap: LAPRD and BINRD are defined 
          in PUTDQ, but DOLINK is not, so thatLINKED functions 
          calls cannot be employed in BASIC until DOLINK is 
          defined. Therefore, the initial block in BASIC 
          defines DOLINK. It also redefines LAPRD and BINRD 
          because in the case of linked functon calls, the 
          defnitions for these functions use undefined 
          functions such as FMEMB. AFter this initial block, 
          BINRD is redefined so as to use LINKED calls.
          CGETD, FNTYP, ARGLIST, NARGS, and NCONC1 are 
          compiled using linked calls to facilitate 
          (STREQUAL is included in this block because EQUAL 
          uses it) breaking. Note that they must appear in 
          cbasic before RELINK, which uses them.
          also, CGETD must appear before FNTYP and FNTYP 
          before ARGLIST. Next appears LINKBLOCK containing 
          RELINK and DOLINK, finally EQUAL as a block.)


    (DECLARE
      (DEFLIST [QUOTE ((NIN (NIL (LOC (ASSEMBLE NIL
					        (MOVE 1 , KNIL)
					        (PUSHJ CP , IFSET)
					        (HRRZ 2 , FCHAR
						      (FX))
					        (HLLZS FCHAR (FX))
					        (HRRZ 1 , FILEN
						      (FX))
					        (SETZ 4 ,)
					        (SETZ 5 ,)
					        (JUMPN 2 , * 2)
					    C   (JSYS 50Q)
					        (CAIN 2 , 55Q)
					        (JRST E)
					        (CAIL 2 , 60Q)
					        (CAILE 2 , 71Q)
					        (JRST C)
					    B   (SUBI 2 , 60Q)
					        (MOVE 3 , 4)
					        (LSH 3 , 2)
					        (ADDB 3 , 4)
					        (ADDM 3 , 4)
					        (ADDM 2 , 4)
					        (JSYS 50Q)
					        (CAIL 2 , 60Q)
					        (CAILE 2 , 71Q)
					        (JRST A)
					        (JRST B)
					    E   (SETO 5 ,)
					        (JRST C)
					    A   (CAIE 2 , 15Q)
					        (JRST * 3)
					        (JSYS 50Q)
					        (MOVEI 2 , 37Q)
					        (HRRM 2 , FCHAR
						      (FX))
					        (MOVE 1 , 4)
					        (SKIPGE 5)
					        (MOVN 1 , 4]
	       (QUOTE MACRO)))
    (PROG (SLOC LEN PLITORG LA DF Z)
          [COND
	    ((EQ (PEEKC)
		 (QUOTE % ))
	      (RETURN (COND
			((EQ (SETQ LA (READ NIL FILERDTBL))
			     (QUOTE BINARY))
			  (BINRD FN))
			((SETQ Z (GETP LA (QUOTE CODEREADER)))
                                                (* Peters hook for 
                                                interfacing byte 
                                                compiler.)
			  (APPLY* (CAR Z)
				  FN))
			(T (ERROR (QUOTE "Bad compiled function")
				  FN]
          (SETQ LA (READ NIL FILERDTBL))        (* ARRAY length)
          (SETQ PLITORG (READ NIL FILERDTBL))
          [COND
	    ((MINUSP PLITORG)
	      (ERROR (QUOTE "INCOMPATIBLE COMPILED FILE")
		     (EVQ FILE]
          (SETQ LEN (READ NIL FILERDTBL))       (* Length of code plus 
                                                pointers, and relative 
                                                addr of relocation bits)
          [SETQ SLOC (VAG (IPLUS 2 (LOC (SETQ DF (ARRAY LA PLITORG]
          (SETQ PLITORG (VAG (IPLUS (LOC SLOC)
				    PLITORG)))
          (SETQ LA (VAG (IPLUS (LOC SLOC)
			       LA)))
      A   (CLOSER (LOC SLOC)
		  (NIN))
      X   [COND
	    ((NEQ (PEEKC)
		  (QUOTE %
))
	      (FRPLACA
		SLOC
		(VAG
		  (IPLUS
		    (OPENR (LOC SLOC))
		    (OR
		      (GETP (SETQ Z (RATOM NIL FILERDTBL))
			    (QUOTE COREVAL))
		      (SELECTQ
			Z
			((MHC FNCALL)
			  (ERROR (QUOTE "INCOMPATIBLE COMPILED FILE")
				 (EVQ FILE)))
			(ERROR (QUOTE "NO COREVAL")
			       Z]
          [SETQ SLOC (VAG (ADD1 (LOC SLOC]
          (COND
	    ((IGREATERP (LOC PLITORG)
			(LOC SLOC))
	      (GO A)))
          (SETQ PLITORG (VAG (IPLUS (LOC DF)
				    LEN 2)))
      C   (COND
	    ((IGREATERP (LOC PLITORG)
			(LOC SLOC))
	      (SETQ Z (READ NIL FILERDTBL))
	      [COND
		[(LISTP Z)
		  (COND
		    [(EQ (CAR Z)
			 (QUOTE LINKED-FN-CALL))
		      (DOLINK SLOC 0 (CDR Z)
			      FN T)
		      (COND
			((NULL (FMEMB FN LINKEDFNS))
			  (SETQ LINKEDFNS (CONS FN LINKEDFNS]
		    (T (FRPLACA SLOC (CAR Z))
		       (FRPLACD SLOC (COND
				  ((EQ (CDR Z)
				       0)
				    (VAG 0))
				  (T (CDR Z]
		(T (CLOSER (LOC SLOC)
			   (LOC Z]
	      [SETQ SLOC (VAG (ADD1 (LOC SLOC]
	      (GO C)))
      B   (COND
	    ((IGREATERP (LOC LA)
			(LOC SLOC))
	      (CLOSER (LOC SLOC)
		      (NIN))
	      (RATOM NIL FILERDTBL)
	      [SETQ SLOC (VAG (ADD1 (LOC SLOC]
	      (GO B)))
          (FRPLACD DF (VAG (IPLUS LEN 2)))
          (RELOC DF (IPLUS 2 (LOC DF)))
          (DEFC FN (VAG (IPLUS 2 (LOC DF])

(NIN
  [LAMBDA NIL
    (PROG (Z)
      A   (COND
	    ((OR (NUMBERP (SETQ Z (PEEKC)))
		 (EQ Z (QUOTE -)))
	      (RATOM NIL FILERDTBL))
	    (T (READC)
	       (GO A])

(BINRD
  [LAMBDA (FN FILE)
    (PROG ([JFN (VAG (OPNJFN (OR FILE (INPUT]
	   LA PLITORG LEN DF ENTRY CVALS VAL PTR)
          (READC FILE)
          (OSFBSZ JFN 36)
          (SETQ LA (OBIN JFN))
          (SETQ PLITORG (OBIN JFN))
          (SETQ LEN (OBIN JFN))
          (SETQ DF (ARRAY LA PLITORG))
          (SETQ ENTRY (VAG (IPLUS (LOC DF)
				  2)))          (* Read the code.)
          (OSIN ENTRY PLITORG JFN)              (* Read the relocation 
                                                data.)
          (OSIN (VAG (IPLUS (LOC ENTRY)
			    LEN))
		(IDIFFERENCE LA LEN)
		JFN)
          (FRPLACD DF (VAG (IPLUS 2 LEN)))      (* Store relocation 
                                                origin.)
          (RELOC DF (LOC ENTRY))
          (OSFBSZ JFN 7)                        (* Now read the literals
                                                and take care of linked 
                                                calls.)
          [PROG ((SLOC (VAG (IPLUS (LOC ENTRY)
				   PLITORG)))
		 (PLIT (VAG (IPLUS (LOC ENTRY)
				   LEN)))
		 Z)
	    C   (COND
		  ((IGREATERP (LOC PLIT)
			      (LOC SLOC))
		    (SETQ Z (READ FILE FILERDTBL))
		    [COND
		      [(LISTP Z)
			(COND
			  [(EQ (CAR Z)
			       (QUOTE LINKED-FN-CALL))
			    (DOLINK SLOC 0 (CDR Z)
				    FN T)
			    (COND
			      ((NULL (FMEMB FN LINKEDFNS))
				(SETQ LINKEDFNS (CONS FN LINKEDFNS]
			  (T (FRPLACA SLOC (CAR Z))
			     (FRPLACD SLOC (COND
					((EQ (CDR Z)
					     0)
					  (VAG 0))
					(T (CDR Z]
		      (T (CLOSER (LOC SLOC)
				 (LOC Z]
		    [SETQ SLOC (VAG (ADD1 (LOC SLOC]
		    (GO C]
          (SETQ CVALS (READ FILE FILERDTBL))

          (* CVALS is always a list, so there cannot be a c/r 
          hanging in anyone's input buffer at this point.)


          (OSFBSZ JFN 18)
      L1  (OR CVALS (GO OUT))
          (OR (SETQ VAL (FGETP (CAR CVALS)
			       (QUOTE COREVAL)))
	      (ERROR (QUOTE "No COREVAL")
		     (CAR CVALS)))
          (SETQ VAL (VAG (LOGAND VAL 262143)))
      L2  [SETQ PTR (VAG (IPLUS (LOC DF)
				(OBIN JFN]
          (COND
	    ((EQ PTR DF)                        (* I.E. WAS 0 READ)
	      (SETQ CVALS (CDR CVALS))
	      (GO L1)))
          [FRPLACA PTR (VAG (IPLUS (OPENR (LOC PTR))
				   (LOC VAL]
          (GO L2)
      OUT (OSFBSZ JFN 7)
          (DEFC FN ENTRY])

(LCSKIP
  [LAMBDA (FN FLG)                              (* Skip or copy FN, FLG 
                                                T to copy)
    (PROG (LEN PLITORG LA)
          [COND
	    [(EQ (PEEKC)
		 (QUOTE % ))
	      (RETURN (COND
			((EQ (SETQ LA (READ NIL FILERDTBL))
			     (QUOTE BINARY))
			  (BINSKIP FN FLG))
			((SETQ LEN (GETP LA (QUOTE CODEREADER)))
                                                (* Peters hook for 
                                                interfacing byte 
                                                compiler.)
			  (APPLY* (CDR LEN)
				  FN FLG))
			(T (ERROR (QUOTE "Bad compiled function")
				  FN]
	    ((AND FLG BINFIXFLG)                (* Function stored in 
                                                old format. BINCOMPFLG 
                                                says convert to new 
                                                format.)
	      (RETURN (BINFIX FN]
          (SETQ LA (READ NIL FILERDTBL))
          (SETQ PLITORG (READ NIL FILERDTBL))
          (SETQ LEN (READ NIL FILERDTBL))
          (COND
	    (FLG (PRINT FN NIL FILERDTBL)
		 (PRINT LA NIL FILERDTBL)
		 (PRINT PLITORG NIL FILERDTBL)
		 (PRINT LEN NIL FILERDTBL)))
          [COND
	    ((IGREATERP 0 PLITORG)              (* Reading blockcompiled
                                                code)
	      (SETQ PLITORG (IMINUS PLITORG]
          (COND
	    (FLG (LCCOP PLITORG))
	    (T (LCSK PLITORG)))
          (SETQ LA (IDIFFERENCE LA LEN))
          (SETQ LEN (IDIFFERENCE LEN PLITORG))
      A                                         (* Copy/skip literals)
          (COND
	    ((IGREATERP LEN 0)
	      (COND
		(FLG (PRINT (READ NIL FILERDTBL)
			    NIL FILERDTBL))
		(T (READ NIL FILERDTBL)))
	      (SETQ LEN (SUB1 LEN))
	      (GO A)))
          (COND
	    (FLG (LCCOP LA))
	    (T (LCSK LA])

(LCCOP
  [LAMBDA (N)                                   (* COPY N LINES FROM 
                                                INPUT FILE TO OUTPUT 
                                                FILE)
    (ASSEMBLE NIL
	      (MOVE 1 , KNIL)
	      (FASTCALL IFSET)
	      (PUSHN FX)                        (* SAVE FILE INDEX)
	      (MOVE 2 , KNIL)
	      (FASTCALL OFSET)
	      (MOVEI 4 , 0 (FX))
	      (CQ (VAG N))
	      (POPN 3)
	      (MOVE 5 , 1)
	      (TRZA 6 , 1)
	  CHAR(TRO 6 , 1)                       (* FLAG CHAR SEEN THIS 
                                                LINE)
	  IN1 (MOVEI FX , 0 (3))                (* INPUT FILE INDEX)
	      (PUSHJ CP , FIN)
	      (MOVEI FX , 0 (4))                (* OUTPUT FILE INDEX)
	      (PUSHJ CP , FOUT)
	      (CAIE 1 , 37Q)                    (* EOL ?)
	      (JRST CHAR)
	      (TRZN 6 , 1)                      (* YES, ANY CHARS THIS 
                                                LINE?)
	      (JRST IN1)                        (* NO, DONT COUNT)
	      (SOJG 5 , IN1)
	      (MOVE 1 , KNIL)
	      (RET])

(LCSK
  [LAMBDA (N)                                   (* SKIP N LINES OF INPUT
                                                FILE)
    (ASSEMBLE NIL
	      (MOVE 1 , KNIL)
	      (FASTCALL IFSET)
	      (PUSHN FX)                        (* SAVE FILE INDEX)
	      (CQ (VAG N))
	      (POPN FX)
	      (MOVE 5 , 1)
	      (TRZA 6 , 1)
	  CHAR(TRO 6 , 1)                       (* FLAG CHAR SEEN THIS 
                                                LINE)
	  IN1 (PUSHJ CP , FIN)
	      (CAIE 1 , 37Q)                    (* EOL ?)
	      (JRST CHAR)
	      (TRZN 6 , 1)                      (* YES, ANY CHARS THIS 
                                                LINE?)
	      (JRST IN1)                        (* NO, DONT COUNT)
	      (SOJG 5 , IN1)
	      (MOVE 1 , KNIL)
	      (RET])

(BINSKIP
  [LAMBDA (FN FLG FILE1 FILE2)

          (* Skip one function on FILE1 if FLG=NIL, copy from 
          FILE1 to FILE2 if FLG=T.)


    (PROG ([JFN1 (VAG (OPNJFN (OR FILE1 (INPUT]
	   [JFN2 (AND FLG (VAG (OPNJFN (OR FILE2 (OUTPUT]
	   LA PLITORG LEN CVALS NVALS RL)
          (READC FILE1)
          (OSFBSZ JFN1 36)
          (SETQ LA (OBIN JFN1))
          (SETQ PLITORG (OBIN JFN1))
          (SETQ LEN (OBIN JFN1))
          [COND
	    (FLG (PRIN2 FN FILE2 FILERDTBL)
		 (SPACES 1 FILE2)
		 (PRINT (QUOTE BINARY)
			FILE2 FILERDTBL)
		 (OSFBSZ JFN2 36)
		 (OBOUT LA JFN2)
		 (OBOUT PLITORG JFN2)
		 (OBOUT LEN JFN2)
		 (FRPTQ (IPLUS PLITORG (IDIFFERENCE LA LEN))
			(OBOUT (OBIN JFN1)
			       JFN2))
		 (OSFBSZ JFN2 7))
	    (T (OSFPTR JFN1 (IPLUS (ORFPTR JFN1)
				   PLITORG
				   (IDIFFERENCE LA LEN]
          (OSFBSZ JFN1 7)
          [COND
	    (FLG (FRPTQ (IDIFFERENCE LEN PLITORG)
			(PRINT (READ FILE1 FILERDTBL)
			       FILE2 FILERDTBL))
		 (COND
		   ((SETQ CVALS (READ FILE1 NIL FILERDTBL))
		     (PRIN2 CVALS FILE2 FILERDTBL))
		   (T (PRIN1 (QUOTE %(%))
			     FILE2)))
		 (SETQ NVALS (FLENGTH CVALS))
		 (OSFBSZ JFN2 18))
	    (T (FRPTQ (IDIFFERENCE LEN PLITORG)
		      (SKREAD FILE1))
	       (PROG NIL
		     (SETQ NVALS 0)
		 S1  (COND
		       ((NEQ (OBIN JFN1)
			     40)                (* Left paren, start of 
                                                CVALS list.)
			 (GO S1)))
		 S2  (COND
		       ((READ FILE1 NIL FILERDTBL)
                                                (* Go until terminating 
                                                right paren.)
			 (SETQ NVALS (ADD1 NVALS))
			 (GO S2]
          (OSFBSZ JFN1 18)
          [SETQ RL (VAG (GETP (QUOTE UUARG3)
			      (QUOTE COREVAL]
      C1  (COND
	    ((EQ NVALS 0)
	      (GO OUT)))
      C2  [COND
	    [FLG (OBOUT (CLOSER (LOC RL)
				(OBIN JFN1))
			JFN2)

          (* THE ODD CODE AVOIDS BOXING THE RELATIVE LOCATION 
          OR PUTTING UNBOXED VAL ON STACK)


		 (COND
		   ((IGREATERP (OPENR (LOC RL))
			       0)
		     (GO C2]
	    (T (COND
		 ((IGREATERP (OBIN JFN1)
			     0)
		   (GO C2]
          (SETQ CVALS (CDR CVALS))
          (SETQ NVALS (SUB1 NVALS))
          (GO C1)
      OUT (OSFBSZ JFN1 7)
          (COND
	    (FLG (OSFBSZ JFN2 7)
		 (TERPRI FILE2)))
          (RETURN])

(BINFIX
  [LAMBDA (FN FILE1 FILE2)
    (PROG ([JFN1 (VAG (OPNJFN (OR FILE1 (INPUT]
	   [JFN (VAG (OPNJFN (OR FILE2 (OUTPUT]
	   (SLOC 0)
	   LA PLITORG LEN Z CVALS LITS D)
          (PRIN2 FN FILE2 FILERDTBL)
          (SPACES 1 FILE2)
          (PRINT (QUOTE BINARY)
		 FILE2 FILERDTBL)
          (OSFBSZ JFN 36)
          (OBOUT (SETQ LA (READ FILE1 FILERDTBL))
		 JFN)
          (OBOUT (SETQ PLITORG (READ FILE1 FILERDTBL))
		 JFN)
          (OBOUT (SETQ LEN (READ FILE1 FILERDTBL))
		 JFN)
          (RATOM FILE1 FILERDTBL)
      A   (OBOUT (ONIN JFN1)
		 JFN)
      A1  (SELECTQ (SETQ Z (OBIN JFN1))
		   (13 (GO A1))
		   (32 (SETQ Z (RATOM FILE1 FILERDTBL))
		       [COND
			 [(SETQ D (FASSOC Z CVALS))
			   (FRPLACD D (CONS SLOC (CDR D]
			 (T (SETQ CVALS (CONS (LIST Z SLOC)
					      CVALS]
		       (READC FILE1))
		   ((31 10))
		   (HELP))
          (SETQ SLOC (ADD1 SLOC))
          (COND
	    ((IGREATERP PLITORG SLOC)
	      (GO A)))
      C   (COND
	    ((IGREATERP LEN SLOC)
	      (SETQ LITS (CONS (READ FILE1 FILERDTBL)
			       LITS))
	      (SETQ SLOC (ADD1 SLOC))
	      (GO C)))
      B   (COND
	    ((IGREATERP LA SLOC)
	      (OBOUT (READ FILE1 FILERDTBL)
		     JFN)
	      (SETQ SLOC (ADD1 SLOC))
	      (GO B)))
          (OSFBSZ JFN 7)
          [MAPC (DREVERSE LITS)
		(FUNCTION (LAMBDA (X)
		    (PRINT X FILE2 FILERDTBL]
          (COND
	    (CVALS (PRIN2 (MAPCAR CVALS (FUNCTION CAR))
			  FILE2 FILERDTBL))
	    (T (PRIN1 (QUOTE %(%))
		      FILE2)))
          (OSFBSZ JFN 18)
          [MAPC CVALS (FUNCTION (LAMBDA (X)
		    [MAPC (CDR X)
			  (FUNCTION (LAMBDA (RL)
			      (OBOUT (IPLUS RL 2)
				     JFN]
		    (OBOUT 0 JFN]
          (OSFBSZ JFN 7)
          (TERPRI FILE2])

(DOLINK
  [LAMBDA (BLKFN REL NM FN NOUNDOFLG)

          (* Each linked call corresonds to two literals.
          The second literal, whose address is given by 
          BLKFN+REL, contains in its left half 
          (CDR) the name of the function being called, and in 
          the right half an appropriate coreval.
          In the preceding literal, the right half contains 
          the definition of the function being called.)


    (PROG (A B C)
          (SETQ C 0)
          [COND
	    [(OR (NULL FN)
		 (NULL (FGETD NM)))

          (* FN=NIL corresponds to UNLINKFLG=T, meaning 
          unlink, i.e. break all links.
          This is done by linking them to A HOKEY DEFINITION 
          THAT CALLS NOLINKDEF1)


	      (SETQ A (LIST (QUOTE LAMBDA)
			    (QUOTE NOLINKARGS)
			    (LIST (QUOTE NOLINKDEF1)
				  BLKFN REL NM)))
	      (SETQ B (VAG (GETP (QUOTE EXCALQ)
				 (QUOTE COREVAL]
	    (T                                  (* E (RADIX 10Q))
	      [SETQ A (CAR (VAG (ADD1 (LOC NM]
                                                (* Gets definitin.)
	      (SETQ B
		(LOGAND
		  (RSH [LOC (CDR (VAG (ADD1 (LOC NM]
		       11Q)
		  777Q))                        (* INSTR OF DEF The RSH 
                                                is to avoid making a 
                                                laage number.)
	      [SETQ B
		(VAG
		  (COND
		    ((EQ B (RSH (GETP (QUOTE PUSHJ)
				      (QUOTE OPD))
				11Q))
		      (GETP (QUOTE CCALC)
			    (QUOTE COREVAL)))
		    (T
		      (SETQ C
			(LOGAND
			  [LOC (CDR (VAG (ADD1 (LOC NM]
			  740Q))
		      (OPENR (IPLUS (GETP (QUOTE POPTAB)
					  (QUOTE COREVAL))
				    B]          (* E (RADIX 10))
	      ]
          (SETQ REL (VAG REL))
          (COND
	    ((AND (NULL (FGETD NM))
		  FN
		  (NULL NOLINKMESS))            (* Not defined.)
	      (LISPXPRIN1 (QUOTE ******)
			  T)
	      (LISPXPRIN1 NM T)
	      (LISPXPRIN1 (QUOTE " not defined when link tried from ")
			  T)
	      (LISPXPRINT FN T)))
          [COND
	    ([AND (EQ NM (FNOPENRD BLKFN (LOC REL)))
		  (EQ A (FNOPENRA BLKFN (SUB1 (LOC REL]
                                                (* Same, don't RELINK as
                                                may be shared.)
	      NIL)
	    [NOUNDOFLG (FNCLOSER BLKFN (LOC REL)
				 (IPLUS (LLSH (LOC NM)
					      18)
					(LOC B)))
		       (FNCLOSER BLKFN (SUB1 (LOC REL))
				 (IPLUS (LLSH C 18)
					(LOC A]
	    (T (/FNCLOSERD BLKFN (LOC REL)
			   NM)
	       (/FNCLOSERA BLKFN (LOC REL)
			   B)
	       (/FNCLOSERA BLKFN (SUB1 (LOC REL))
			   A)
	       (/FNCLOSERD BLKFN (SUB1 (LOC REL))
			   (VAG C]
          (RETURN])

(CAAR
  [LAMBDA (X)
    (CAR (CAR X])

(CADR
  [LAMBDA (X)
    (CAR (CDR X])

(CDAR
  [LAMBDA (X)
    (CDR (CAR X])

(CDDR
  [LAMBDA (X)
    (CDR (CDR X])

(CAAAR
  [LAMBDA (X)
    (CAR (CAAR X])

(CAADR
  [LAMBDA (X)
    (CAR (CADR X])

(CADAR
  [LAMBDA (X)
    (CAR (CDAR X])

(CADDR
  [LAMBDA (X)
    (CAR (CDDR X])

(CDAAR
  [LAMBDA (X)
    (CDR (CAAR X])

(CDADR
  [LAMBDA (X)
    (CDR (CADR X])

(CDDAR
  [LAMBDA (X)
    (CDR (CDAR X])

(CDDDR
  [LAMBDA (X)
    (CDR (CDDR X])

(CAAAAR
  [LAMBDA (X)
    (CAAR (CAAR X])

(CAAADR
  [LAMBDA (X)
    (CAAR (CADR X])

(CAADAR
  [LAMBDA (X)
    (CAAR (CDAR X])

(CAADDR
  [LAMBDA (X)
    (CAAR (CDDR X])

(CADAAR
  [LAMBDA (X)
    (CADR (CAAR X])

(CADADR
  [LAMBDA (X)
    (CADR (CADR X])

(CADDAR
  [LAMBDA (X)
    (CADR (CDAR X])

(CADDDR
  [LAMBDA (X)
    (CADR (CDDR X])

(CDAAAR
  [LAMBDA (X)
    (CDAR (CAAR X])

(CDAADR
  [LAMBDA (X)
    (CDAR (CADR X])

(CDADAR
  [LAMBDA (X)
    (CDAR (CDAR X])

(CDADDR
  [LAMBDA (X)
    (CDAR (CDDR X])

(CDDAAR
  [LAMBDA (X)
    (CDDR (CAAR X])

(CDDADR
  [LAMBDA (X)
    (CDDR (CADR X])

(CDDDAR
  [LAMBDA (X)
    (CDDR (CDAR X])

(CDDDDR
  [LAMBDA (X)
    (CDDR (CDDR X])

(ABS
  [LAMBDA (X)
    (COND
      ((GREATERP 0 X)
	(MINUS X))
      (T X])

(ADD1
  [LAMBDA (X)
    (IPLUS X 1])

(ARRAYSIZE
  [LAMBDA (A)
    (SELECTQ (NTYP A)
	     [1 

          (* We permit A not to be the beginning of an array, 
          i.e. that (ARRAYBEG A) and A may not be EQ, so that 
          ARRAYSIZE will work for compiled functions.)


		(IPLUS -2 (LOC (CAR (ARRAYBEG A]
	     [4                                 (* Swapped array.)
		(SWPPOS A (FUNCTION (LAMBDA (A)

          (* A is now the swapping-buffer address where the 
          swapped array got placed by SWPPOS.)


			    (IPLUS -2 (LOC (CAR A]
	     (ERRORX (LIST 28 A])

(ARGLIST
  [LAMBDA (X)
    (PROG (DEF)
          [COND
	    ((SUBRP X)
	      (RETURN (SELECTQ (ARGTYPE X)
			       ((0 1)
				 (SELECTQ (NARGS X)
					  (1 (QUOTE (U)))
					  (2 (QUOTE (U V)))
					  (3 (QUOTE (U V W)))
					  (4 (QUOTE (U V W X)))
					  (5 (QUOTE (U V W X Y)))
					  NIL))
			       (QUOTE U]
          (SETQ DEF (CGETD X))
      TOP (RETURN (SELECTQ (NTYP DEF)
			   [1                   (* Ccode.)
			      (ARGLIST1 (VAG (IPLUS -2 (LOC DEF]
			   (4                   (* Scode.)
			      (SWPPOS DEF (FUNCTION ARGLIST1)))
			   (8 (SELECTQ (CAR DEF)
				       ([LAMBDA NLAMBDA]
					 (CADR DEF))
				       (FUNARG (ARGLIST (CADR DEF)))
				       (GO UNDEF)))
			   (GO UNDEF)))
      UNDEF
          (COND
	    ((SETQ DEF (GETP X (QUOTE EXPR)))
	      (GO TOP))
	    ((SETQ DEF (FNCHECK X T))
	      (RETURN (ARGLIST DEF)))
	    (T (ERROR (QUOTE "Args not available:")
		      X])

(ARGLIST1
  [LAMBDA (Y)

          (* Y is A pointer to an array header, swapped or not 
          doesn't matter as long as ARGLIST1 isn't swapped.)


    (PROG (N P A)

          (* I am too busy to worry about it right now, team, 
          but ARGLIST1 still needs work.
          The (CAR A) in the SELECTQ assumes, in the case 
          where N is initially 0, that CAR of NIL is NIL -
          Does MIT really care? Worse, if you gave a random 
          array to this or to the old ARGLIST, it could get a 
          random unboxed value for N and a random address for 
          P, and CONS up arbitrary sections of core.
          This is true for swapped arrays equally.
          -
          Also ARGLIST1 and ARGLIST want to be blockcompiled 
          together when I get around to making SWPPOS compile 
          open and tight. -
          Jwg 5/10/74.)


          [SETQ N (LOC (CDR (VAG (IPLUS 3 (LOC Y]

          (* N is number of args, boxed.
          Now set P to point to first one in the vector of 
          argument names.)


          [SETQ P (CAR (VAG (IPLUS 4 (LOC Y]
          [AND (EQ 2 (NTYP Y))
	       (SETQ P (VAG (IPLUS (LOC P)
				   (LOC Y]      (* Relocate if Y is ptr 
                                                to swapping buffer.)
      LP  [COND
	    ((EQ N 0)
	      (RETURN (SELECTQ
			[LOC (CAR (VAG (IPLUS 3 (LOC Y]
			((2 3)

          (* No-spread function, return its 
          (single) formal parameter as an atom, not A list.)


			  (CAR A))
			((1 0)
			  A)
			(ERROR (QUOTE "Args not available:")
			       (EVQ X]
          (SETQ A (CONS [CAR (VAG (IPLUS (LOC P)
					 (SETQ N (SUB1 N]
			A))
          (GO LP])

(CGETD
  [LAMBDA (X)
    (COND
      ((LITATOM X)
	(GETD X))
      (T X])

(DELETECONTROL
  [LAMBDA (TYPE MESSAGE TTBL)
    (PROG (X)
          (SETQ TTBL (GETTERMTABLE TTBL))
          (SELECTQ TYPE
		   [(ECHO NOECHO)
		     [SETQ X
		       (OPENR (LOC (SETQ TTBL
				     (VAG (IPLUS (LOC TTBL)
						 14]
		     (CLOSER (LOC TTBL)
			     (SELECTQ TYPE
				      (ECHO 0)
				      (NOECHO 1)
				      (HELP)))
		     (RETURN (COND
			       ((EQ X 0)
				 (QUOTE ECHO))
			       (T (QUOTE NOECHO]
		   NIL)
          (COND
	    ((STRINGP MESSAGE)
	      (SETQ X MESSAGE))
	    [(LITATOM MESSAGE)
	      (SETQ X (AND MESSAGE (CDR (VAG (IPLUS (LOC MESSAGE)
						    2]
	    (T (ERROR (QUOTE "ILLEGAL MESSAGE TYPE - CHARCONTROL")
		      MESSAGE)))
          (COND
	    ((IGREATERP (NCHARS MESSAGE)
			4)
	      (ERROR (QUOTE "ILLEGAL MESSAGE LENGTH - CHARCONTROL")
		     MESSAGE)))
          (SETQ MESSAGE
	    (ASSEMBLE NIL
		      [CQ (VAG (IPLUS (SELECTQ TYPE
					       ((DELETELINE LINEDELETE)
						 11Q)
					       (1STCHDEL 12Q)
					       (NTHCHDEL 13Q)
					       (POSTCHDEL 14Q)
					       (EMPTYCHDEL 15Q)
					       (ERRORX (LIST 33Q TYPE)))
				      (LOC TTBL]
		      (PUSHN 0 (1))
		      (MOV21)
		      (CQ X)
		      (CAMN 1 , KNIL)
		      (JRST OUT)
		      (FASTCALL UPATM)
		      (SETZM 0 (2))
		      (HRLI 2 , 440700Q)
		      (JUMPE 4 , OUT)
		  LOOP(ILDB 1 , 3)
		      (IDPB 1 , 2)
		      (SOJG 4 , LOOP)
		  OUT (CQ (CONCAT (QUOTE "12345")))
		      (FASTCALL UPATM)
		      (NREF (MOVEI 2 , 0))
		      (HRLI 2 , 440700Q)
		  LP  (ILDB 5 , 2)
		      (IDPB 5 , 3)
		      (SOJG 4 , LP)
		      (POPNN 1)))
          (RETURN (OR (SUBSTRING MESSAGE 1 (SUB1 (STRPOS (FCHARACTER
							   0)
							 MESSAGE)))
		      (QUOTE ""])

(DIFFERENCE
  [LAMBDA (X Y)
    (PLUS X (MINUS Y])

(ECHOCONTROL
  [LAMBDA (CHAR MODE TTBL)
    (PROG (X)
          (SETQ TTBL (GETTERMTABLE TTBL))
          (SETQ CHAR
	    (LOGAND [COND
		      ((NUMBERP CHAR))
		      ([AND (EQ (NCHARS CHAR)
				1)
			    (OR (AND (ILESSP (SETQ X (CHCON1 CHAR))
					     90)
				     (IGREATERP X 64))
				(AND (ILESSP (SETQ X (IPLUS X -32))
					     90)
				     (IGREATERP X 64]
			X)
		      (T (ERRORX (LIST 27 CHAR]
		    31))
          (SETQ X (IPLUS (ITIMES (IREMAINDER CHAR 18)
				 -2)
			 34))
          [SETQ MODE (SELECTQ MODE
			      (IGNORE 0)
			      (REAL 2)
			      (SIMULATE 3)
			      (UPARROW 1)
			      (NIL NIL)
			      (ERRORX (LIST 27 MODE]
          (SETQ CHAR (VAG (IPLUS (LOC TTBL)
				 (IQUOTIENT CHAR 18)
				 7)))
          [COND
	    (MODE (CLOSER (LOC CHAR)
			  (LOGOR (LOGAND (SETQ CHAR
					   (OPENR (LOC CHAR)))
					 (LOGXOR (LLSH 3 X)
						 -1))
				 (LLSH MODE X)))
		  (ASSEMBLE NIL
			    (FASTCALL SETMOD)))
	    (T (SETQ CHAR (OPENR (LOC CHAR]
          (RETURN (SELECTQ (LOGAND (LRSH CHAR X)
				   3)
			   (0 (QUOTE IGNORE))
			   (2 (QUOTE REAL))
			   (3 (QUOTE SIMULATE))
			   (QUOTE UPARROW])

(E
  [NLAMBDA XEEEE
    (EVAL XEEEE])

(EQUAL
  [LAMBDA (X Y)
    (COND
      ((EQ X Y))
      [(NLISTP X)
	(COND
	  ((NUMBERP X)
	    (EQP X Y))
	  ((STRINGP X)
	    (STREQUAL X Y]
      ((NLISTP Y)
	NIL)
      ((EQUAL (CAR X)
	      (CAR Y))
	(EQUAL (CDR X)
	       (CDR Y])

(EVQ
  [LAMBDA (X)
    X])

(FDIFFERENCE
  [LAMBDA (X Y)
    (FPLUS X (MINUS Y])

(FIX
  [LAMBDA (X)
    (COND
      ((FIXP X))
      (T (IPLUS X])

(FIXP
  [LAMBDA (X)
    (AND (NUMBERP X)
	 (NOT (FLOATP X))
	 X])

(FMINUS
  [LAMBDA (X)
    (FLOAT (MINUS X])

(FLOAT
  [LAMBDA (X)
    (COND
      ((FLOATP X))
      (T (FPLUS X])

(FNTYP
  [LAMBDA (X)
    (COND
      ((SUBRP X)
	(SELECTQ (COND
		   ((LITATOM X)
		     (ARGTYPE X))
		   (SPAGHETTIFLG (LSH (CAR X)
				      -4))
		   ((CAR X)))
		 (0 (QUOTE SUBR))
		 (1 (QUOTE FSUBR))
		 (2 (QUOTE SUBR*))
		 (3 (QUOTE FSUBR*))
		 NIL))
      (T [COND
	   ((LITATOM X)
	     (SETQ X (GETD X]
	 (SELECTQ
	   (NTYP X)
	   (1 (SELECTQ [LOC (CAR (VAG (ADD1 (LOC X]
		       (0 (QUOTE CEXPR))
		       (1 (QUOTE CFEXPR))
		       (2 (QUOTE CEXPR*))
		       (3 (QUOTE CFEXPR*))
		       NIL))
	   (4 (SELECTQ (ARGTYPE X)
		       (0 (QUOTE CEXPR))
		       (1 (QUOTE CFEXPR))
		       (2 (QUOTE CEXPR*))
		       (3 (QUOTE CFEXPR*))
		       NIL))
	   (8 (SELECTQ (CAR X)
		       (FUNARG (QUOTE FUNARG))
		       [LAMBDA (OR (AND (CADR X)
					(ATOM (CADR X))
					(QUOTE EXPR*))
				   (QUOTE EXPR]
		       [NLAMBDA (COND
			   ((AND (CADR X)
				 (ATOM (CADR X)))
			     (QUOTE FEXPR*))
			   (T (QUOTE FEXPR]
		       (FNTYP1 X)))
	   NIL])

(FNTYP1
  [LAMBDA NIL NIL])

(FUNCTION
  [NLAMBDA (EXP VLIST)
    (COND
      ((NULL VLIST)
	EXP)
      (T
	(LIST
	  (QUOTE FUNARG)
	  EXP
	  (PROG ([AR (ARRAY (ADD1 (LENGTH (COND
					    ((LISTP VLIST)
					      VLIST)
					    (T (SETQ VLIST
						 (EVAL VLIST]
		 COUNT)
	        (SETQ COUNT 3)
	    A   (COND
		  ((NULL VLIST)
		    (RETURN AR)))
	        (RPLACD (VAG (IPLUS COUNT (LOC AR)))
			(CAR VLIST))
	        (RPLACA (VAG (IPLUS COUNT (LOC AR)))
			(EVAL (CAR VLIST)))
	        (SETQ COUNT (ADD1 COUNT))
	        (SETQ VLIST (CDR VLIST))
	        (GO A])

(GENSYM
  [LAMBDA (CHAR)
    (MKATOM (RPLSTRING (RPLSTRING GENSTR 1 (SETQ GENNUM (ADD1 GENNUM)))
		       1
		       (OR CHAR (QUOTE "A"])

(GETSYNTAX
  [LAMBDA (CH TABLE)
    (PROG (X)
          [COND
	    ((AND (SMALLP CH)
		  (IGREATERP CH 0)
		  (ILESSP CH 128)))
	    ((EQ (NCHARS CH)
		 1)
	      (SETQ CH (CHCON1 CH)))
	    ((FMEMB CH
		    (QUOTE (RIGHTBRACKET LEFTBRACKET RIGHTPAREN 
					 LEFTPAREN MACRO SPLICE INFIX 
					 ESCAPE BREAK SEPR OTHER 
					 STRINGDELIM BREAKCHAR SEPRCHAR)
			   ))
	      (SETQ X T))
	    ((FMEMB CH
		    (QUOTE (DELETECHAR CHARDELETE CNTRLV CTRLV 
				       LINEDELETE DELETELINE RETYPE EOL 
				       NONE)))
	      (SETQ X 0))
	    (T (ERRORX (LIST 27 CH]
          (RETURN
	    (COND
	      [X
		(COND
		  [(EQ X 0)
		    (COND
		      ((EQ CH (QUOTE NONE))
			(SETQ TABLE (VAG (IPLUS (LOC (GETTERMTABLE))
						2)))
			(PROG ($$VAL I $$TEM1 $$TEM2)
			      (SETQ I 0)
			  $$LP(COND
				((IGREATERP I 127)
				  (RETURN $$VAL))
				((NOT
				    (PROG (J)
				          (SETQ J 0)
				      $$LP(COND
					    ((IGREATERP J 4)
					      (RETURN T)))
				          (AND
					    (EQ
					      (OPENR
						(IPLUS (LOC TABLE)
						       J))
					      I)
					    (RETURN NIL))
				      $$ITERATE
				          (SETQ J (IPLUS J 1))
				          (GO $$LP)))
				  (GO $$ITERATE)))
			      (SETQ $$TEM1 I)
			      [COND
				[$$TEM2 (FRPLACD $$TEM2
						 (SETQ $$TEM2
						   (FRPLACD
						     (CONS $$TEM1 
							   $$TEM2]
				(T (SETQ $$VAL (SETQ $$TEM2
				       (CONS $$TEM1]
			  $$ITERATE
			      (SETQ I (IPLUS I 1))
			      (GO $$LP)))
		      (T
			(AND
			  (NEQ
			    [SETQ X
			      (LOC
				(CAR
				  (VAG (IPLUS (LOC (GETTERMTABLE TABLE))
					      (SELECTQ CH
						       ((DELETECHAR
							   CHARDELETE)
							 2)
						       ((DELETELINE
							   LINEDELETE)
							 3)
						       (RETYPE 4)
						       ((CNTRLV CTRLV)
							 5)
						       (EOL 6)
						       (HELP]
			    1000)
			  (LIST X]
		  (T (PROG ($$VAL I $$TEM1 $$TEM2)
		           (SETQ I 0)
		       $$LP(COND
			     ((IGREATERP I 127)
			       (RETURN $$VAL))
			     ((NOT (SYNTAXP I CH TABLE))
			       (GO $$ITERATE)))
		           (SETQ $$TEM1 I)
		           [COND
			     [$$TEM2 (FRPLACD $$TEM2
					      (SETQ $$TEM2
						(FRPLACD (CONS $$TEM1 
							     $$TEM2]
			     (T (SETQ $$VAL (SETQ $$TEM2 (CONS $$TEM1]
		       $$ITERATE
		           (SETQ I (IPLUS I 1))
		           (GO $$LP]
	      [(TERMTABLEP TABLE)
		(COND
		  ([EQ (SETQ CH (VAG CH))
		       (CAR (SETQ TABLE (VAG (IPLUS (LOC TABLE)
						    2]
		    (QUOTE CHARDELETE))
		  ([EQ CH (CAR (VAG (IPLUS (LOC TABLE)
					   1]
		    (QUOTE LINEDELETE))
		  ([EQ CH (CAR (VAG (IPLUS (LOC TABLE)
					   2]
		    (QUOTE RETYPE))
		  ([EQ CH (CAR (VAG (IPLUS (LOC TABLE)
					   3]
		    (QUOTE CNTRLV))
		  ([EQ CH (CAR (VAG (IPLUS (LOC TABLE)
					   4]
		    (QUOTE EOL))
		  (T (QUOTE NONE]
	      (T (SETQ TABLE
		   (VAG (IPLUS [COND
				 ((EQ TABLE (QUOTE ORIG))
				   (GETP (QUOTE ORGRDT)
					 (QUOTE COREVAL)))
				 (T (LOC (GETREADTABLE TABLE]
			       CH 2)))
		 (SELECTQ (LOC (CDR TABLE))
			  (160 (QUOTE BREAKCHAR))
			  (96 (QUOTE SEPRCHAR))
			  (176 (QUOTE STRINGDELIM))
			  (40 (QUOTE ESCAPE))
			  (161 (QUOTE RIGHTBRACKET))
			  (162 (QUOTE LEFTBRACKET))
			  (163 (QUOTE LEFTPAREN))
			  (164 (QUOTE RIGHTPAREN))
			  (165 (LIST (QUOTE MACRO)
				     (CAR TABLE)))
			  (166 (LIST (QUOTE SPLICE)
				     (CAR TABLE)))
			  (167 (LIST (QUOTE INFIX)
				     (CAR TABLE)))
			  (0 (QUOTE OTHER))
			  (ERROR (QUOTE "Illegal readtable entry")
				 (LOC (CDR TABLE)))
			  NIL])

(HARRAY
  [LAMBDA (LEN)
    (ARRAY LEN 0 (VAG 0])

(IDIFFERENCE
  [LAMBDA (X Y)
    (IPLUS X (IMINUS Y])

(ILESSP
  [LAMBDA (X Y)
    (IGREATERP Y X])

(IMINUS
  [LAMBDA (X)
    (FIX (MINUS X])

(LESSP
  [LAMBDA (X Y)
    (GREATERP Y X])

(LRSH
  [LAMBDA (N M)
    (LLSH N (IMINUS M])

(NARGS
  [LAMBDA (X)
    (COND
      [(SUBRP X)
	(COND
	  (SPAGHETTIFLG
	    (LOGAND
	      (COND
		((LITATOM X)
		  (LSH [LOC (CDR (VAG (ADD1 (LOC X]
		       -5))
		(T (CAR X)))
	      15))
	  ((SELECTQ (ARGTYPE X)
		    ((2 3)
		      1)
		    ((0 1)
		      3)
		    NIL]
      (T (SELECTQ (NTYP (SETQ X (CGETD X)))
		  [1 (LOC (CDR (VAG (ADD1 (LOC X]
		  (4 (LOC (FNOPENRD X 1)))
		  (8 (SELECTQ (CAR X)
			      [[LAMBDA NLAMBDA]
				(COND
				  ((NULL (SETQ X (CADR X)))
				    0)
				  ((NLISTP X)
				    1)
				  (T (FLENGTH X]
			      (FUNARG (NARGS (CADR X)))
			      NIL))
		  NIL])

(NEQ
  [LAMBDA (X Y)
    (NOT (EQ X Y])

(NILL
  [LAMBDA NIL NIL])

(NLIST
  [NLAMBDA XNLIST
    (NLIST1 XNLIST])

(NLIST1
  [LAMBDA (XNLIST XNLIST1 XNLIST2)
    (COND
      ((NULL XNLIST)
	NIL)
      (T (SETQ XNLIST2 (EVAL (CAR XNLIST)))
	 (COND
	   ((AND [NULL (SETQ XNLIST1 (NLIST1 (CDR XNLIST]
		 (NULL XNLIST2))
	     NIL)
	   (T (CONS XNLIST2 XNLIST1])

(NLISTP
  [LAMBDA (X)
    (NULL (LISTP X])

(NTH
  [LAMBDA (X N)
    (COND
      ((IGREATERP 1 N)
	(CONS NIL X))
      (T (PROG NIL
	   LP  (COND
		 ((NOT (IGREATERP N 1))
		   (RETURN X))
		 ((NLISTP X)
		   (RETURN NIL)))
	       (SETQ X (CDR X))
	       (SETQ N (SUB1 N))
	       (GO LP])

(RATOMS
  [LAMBDA (A FILE RDTBL)
    (PROG (L X)
      B   (COND
	    ((EQ (SETQ X (RATOM FILE RDTBL))
		 A)
	      (RETURN (CAR L)))
	    ((SETQ L (TCONC L X))
	      (GO B])

(RPAQQ
  [NLAMBDA (X Y)
    (RPLACA X Y])

(RSH
  [LAMBDA (N M)
    (LSH N (IMINUS M])

(SELECTQ
  [NLAMBDA SELCQ
    (APPLY (QUOTE PROGN)
	   (SELECTQ1 (EVAL (CAR SELCQ)
			   (QUOTE SELECTQ))
		     (CDR SELCQ))
	   (QUOTE SELECTQ])

(SELECTQ1
  [LAMBDA (M L)
    (PROG (C)
      LP  (SETQ C L)
          [COND
	    ((NULL (SETQ L (CDR L)))
	      (RETURN C))
	    ([OR (EQ (CAR (SETQ C (CAR C)))
		     M)
		 (AND (LISTP (CAR C))
		      (FMEMB M (CAR C]
	      (RETURN (CDR C]
          (GO LP])

(SETA
  [LAMBDA (A N V)
    (COND
      ((OR (NOT (ARRAYP A))
	   (NEQ A (ARRAYBEG A)))
	(ERRORX (LIST 28 A)))
      ([AND (IGREATERP N
		       (IPLUS [LOC (CAR (VAG (ADD1 (LOC A]
			      -2))
	    (ILESSP N (SUB1 (COND
			      ((NEQ (CDR A)
				    (VAG 0))
				(LOC (CDR A)))
			      (T (LOC (CAR A]
	(FRPLACA (VAG (IPLUS (LOC A)
			     N 1))
		 V))
      ((AND (IGREATERP N 0)
	    (IGREATERP (SUB1 (LOC (CAR A)))
		       N))
	(CLOSER (IPLUS (LOC A)
		       N 1)
		V))
      (T (ERROR (QUOTE "out of bounds SETA")
		N)))
    V])

(SETD
  [LAMBDA (A N V)
    (COND
      ((OR (NOT (ARRAYP A))
	   (NEQ A (ARRAYBEG A)))
	(ERRORX (LIST 28 A)))
      ([AND (IGREATERP N
		       (IPLUS [LOC (CAR (VAG (ADD1 (LOC A]
			      -2))
	    (ILESSP N (SUB1 (COND
			      ((NEQ (CDR A)
				    (VAG 0))
				(LOC (CDR A)))
			      (T (LOC (CAR A]
	(FRPLACD (VAG (IPLUS (LOC A)
			     N 1))
		 V))
      ((AND (IGREATERP N 0)
	    (IGREATERP (SUB1 (LOC (CAR A)))
		       N))
	(CLOSER (IPLUS (LOC A)
		       N 1)
		V))
      (T (ERROR (QUOTE "out of bounds SETD")
		N)))
    V])

(SETEDITC
  [LAMBDA L

          (* Set line edit chars. Takes any number args which 
          are alternating edit-name and terminal INTERRUPT 
          code. To simply turn off a code, one must REPLACE 
          its function by a different code.
          NIL is interpreted as meaning ascii code 29, which 
          is control %] which cannot be typed on most 
          terminals.)


    (PROG ((N L)
	   LL TEM)
      A   (COND
	    ((ILESSP N 2)
	      (RETURN LL)))
          (SETQ LL
	    (CONS (ARG L (SUB1 N))
		  (CONS [COND
			  ([SETQ TEM
			      (FMEMB (ARG L (SUB1 N))
				     (QUOTE (EOL CHARDELETE DELETECHAR 
						 LINEDELETE DELETELINE 
						 RETYPE CTRLV CNTRLV]
			    (SETSYNTAX (OR (ARG L N)
					   29)
				       (CAR TEM]
			LL)))
          (SETQ N (IPLUS N -2))
          (GO A])

(SETINTC
  [LAMBDA L

          (* CHANGE INTERRUPT CHARS -
          ARG IS ANY NUMBER OF INTERRUPT-NAME 
          TERMINAL-INTERRUPT-CODE. THE TERMINAL INTERRUPT IS 
          THE SAME AS ASCII CODE FOR THE CONTROL CHARS.
          THE TERMINAL CODE FOR SPACE IS 27, FOR RUBOUT 28.0 
          TO TURN OFF AN INTERRUPT, ONE MUST REDEFINE IT AS 
          SOMETHING ELSE (ANOTHER TERMINAL CODE). CURRENTLY 
          NIL MEANS THE SAME AS TERMINAL CODE 31, WHICH IS 
          CURRENTLY UNASSIGNED.)


    (PROG ((N L)
	   LL TEM)
      A   (COND
	    ((ILESSP N 2)
	      (RETURN LL)))
          (SETQ LL (CONS (ARG L (SUB1 N))
			 (CONS [COND
				 ([SETQ TEM
				     (FASSOC (ARG L (SUB1 N))
					     (QUOTE ((HELP . 0)
						     (PRINTLEVEL . 1)
						     (STORAGE . 2)
						     (RUBOUT . 3)
						     (ERROR . 4)
						     (DOP . 5)
						     (RESET . 5)
						     (OUTPUTBUFFER . 6)
						     (BREAK . 7)
						     (USER . 8]
				   (SETINC (CDR TEM)
					   (OR (ARG L N)
					       31]
			       LL)))
          (SETQ N (IPLUS N -2))
          (GO A])

(SETSYNTAX
  [LAMBDA (CH CLASS TABLE)
    [COND
      [(SMALLP CH)
	(COND
	  ((OR (MINUSP CH)
	       (IGREATERP CH 127))
	    (ERRORX (LIST 27 CH]
      ((EQ (NCHARS CH)
	   1)
	(SETQ CH (CHCON1 CH)))
      (T (ERRORX (LIST 27 CH]
    (COND
      [(LISTP CLASS)
	(PROG1 (GETSYNTAX CH (SETQ TABLE (GETREADTABLE TABLE)))
	       (SELECTQ (CAR CLASS)
			[(MACRO SPLICE INFIX)
			  (COND
			    ((AND (NULL (CDDR CLASS))
				  (CADR CLASS))
			      (FRPLACA
				[FRPLACD (VAG (IPLUS (LOC TABLE)
						     CH 2))
					 (VAG (SELECTQ (CAR CLASS)
						       (MACRO 165)
						       (SPLICE 166)
						       (INFIX 167)
						       (HELP]
				(CADR CLASS)))
			    (T (ERRORX (LIST 27 CLASS]
			(ERRORX (LIST 27 CLASS]
      (T
	(PROG (X (MASK (VAG 255)))
	      (RETURN
		(COND
		  ((SETQ X (SELECTQ CLASS
				    (LEFTBRACKET (VAG 162))
				    (RIGHTBRACKET (VAG 161))
				    (LEFTPAREN (VAG 163))
				    (RIGHTPAREN (VAG 164))
				    (STRINGDELIM (VAG 176))
				    (ESCAPE (VAG 40))
				    NIL))
		    (PROG1 (ASSEMBLE NIL
				     (CQ (SETQ TABLE (GETREADTABLE
					     TABLE)))
				     (ADDI 1 , 2)
				     (HRLI 1 , -200Q)
				     (VAR (HRRZ 2 , X))
				 L1  (HLRZ 3 , 0 (1))
				     (ANDI 3 , 377Q)
				     (CAIN 2 , 0 (3))
				     (JRST L2)
				     (AOBJN 1 , L1)
				     (CQ NIL)
				     (JRST OUT)
				 L2  (SETZ 3 , 0)
				     (HRLM 3 , 0 (1))
				     (HLRE 1 , 1)
				     (ADDI 1 , ASZ 200Q)
				 OUT)
			   (FRPLACD (VAG (IPLUS CH 2 (LOC TABLE)))
				    X)))
		  [(SETQ X (SELECTQ CLASS
				    (BREAK (SETQ MASK (VAG 128))
					   (VAG 160))
				    (SEPR (SETQ MASK (VAG 64))
					  (VAG 96))
				    NIL))
		    (PROG1
		      (GETSYNTAX CH (SETQ TABLE (GETREADTABLE TABLE)))
		      (AND
			(EQ
			  (LOGAND
			    [LOC (CDR (SETQ CH
					(VAG (IPLUS CH 2 (LOC TABLE]
			    (LOC MASK))
			  0)
			(FRPLACD CH X]
		  ((SETQ X (SELECTQ CLASS
				    (BREAKCHAR (VAG 160))
				    (SEPRCHAR (VAG 96))
				    (OTHER (VAG 0))
				    NIL))
		    (PROG1 (GETSYNTAX CH (SETQ TABLE (GETREADTABLE
					  TABLE)))
			   (FRPLACD (VAG (IPLUS CH 2 (LOC TABLE)))
				    X)))
		  ((EQ CLASS (QUOTE NONE))
		    (AND (NEQ [SETQ CLASS (GETSYNTAX CH (SETQ TABLE
						       (GETTERMTABLE
							 TABLE]
			      (QUOTE NONE))
			 (CLOSER (IPLUS (SELECTQ CLASS
						 (CHARDELETE 2)
						 (LINEDELETE 3)
						 (RETYPE 4)
						 (CNTRLV 5)
						 (EOL 6)
						 (HELP))
					(LOC TABLE))
				 1000))
		    CLASS)
		  ((SETQ X (SELECTQ CLASS
				    ((DELETECHAR CHARDELETE)
				      (VAG 2))
				    ((DELETELINE LINEDELETE)
				      (VAG 3))
				    (RETYPE (VAG 4))
				    ((CNTRLV CTRLV)
				      (VAG 5))
				    (EOL (VAG 6))
				    NIL))
		    (PROG1
		      (AND
			(NEQ
			  [SETQ X
			    (LOC
			      (CAR
				(SETQ CLASS
				  (VAG (IPLUS (LOC (SETQ TABLE
						     (GETTERMTABLE
						       TABLE)))
					      (LOC X]
			  1000)
			X)
		      (OR (SYNTAXP CH (QUOTE NONE)
				   TABLE)
			  (SETSYNTAX CH (QUOTE NONE)
				     TABLE))
		      (CLOSER (LOC CLASS)
			      CH)))
		  ((SELECTQ CLASS
			    ((NIL T ORIG)
			      T)
			    (OR (READTABLEP CLASS)
				(TERMTABLEP CLASS)))
		    (SETSYNTAX CH (GETSYNTAX CH CLASS)
			       TABLE))
		  (T (SETSYNTAX CH (GETSYNTAX CLASS TABLE)
				TABLE])

(SMALLP
  [LAMBDA (N)
    (EQ (NTYP N)
	(NTYP 1])

(STORAGE
  [LAMBDA (FLG)                                 (* FLG T, INCLUDE SYSTEM
                                                ASSIGNED)

          (* Calls to prin1, terpri, print, and spaces changed 
          to correspoding lispx printing functions later in 
          loadup.)


    (TERPRI)
    (PRIN1 (QUOTE "TYPE USED      ASSIGNED"))
    [COND
      (FLG (PRIN1 (QUOTE "  SYSTEM"]
    (TERPRI)
    (PROG ((N 1)
	   (SU 0)
	   (SA 0)
	   (SS 0)
	   U)
      A   (COND
	    ([SETQ U (OR (USED N)
			 (COND
			   ((EQ N 2)
			     (ASSED 2]
	      (SETQ SU (IPLUS SU U))
	      (PRIN1 N)
	      (SPACES (IDIFFERENCE 5 (POSITION)))
	      (PRIN1 U)
	      (SPACES (IDIFFERENCE 15 (POSITION)))
	      (SETQ SA (IPLUS (PRIN1 (ASSED N))
			      SA))
	      [COND
		(FLG (SPACES (IDIFFERENCE 25 (POSITION)))
		     (SETQ SS (IPLUS (PRIN1 (ASSED N T))
				     SS]
	      (TERPRI)))
          (COND
	    ((ILESSP (SETQ N (ADD1 N))
		     64)
	      (GO A))
	    (T (PRIN1 (QUOTE "SUM  "))
	       (PRIN1 SU)
	       (SPACES (IDIFFERENCE 15 (POSITION)))
	       (PRIN1 SA)
	       (COND
		 (FLG (SPACES (IDIFFERENCE 25 (POSITION)))
		      (PRIN1 SS)))
	       (TERPRI])

(STREQUAL
  [LAMBDA (X Y)
    (ASSEMBLE NIL
	      (CQ X)
	      (STE (QUOTE STPTT))
	      (JRST FALSE)
	      (CQ Y)
	      (STE (QUOTE STPTT))
	      (JRST FALSE)
	      (CQ X)
	      (PUSHJ CP , UPATM)
	      (MOVE 5 , 3)
	      (MOVEI 6 , 0 (4))
	      (CQ Y)
	      (PUSHJ CP , UPATM)
	      (CAIE 4 , 0 (6))
	      (JRST FALSE)
	      (JUMPE 4 , TRUE)
	  A   (ILDB 1 , 3)
	      (ILDB 2 , 5)
	      (CAIE 1 , 0 (2))
	      (JRST FALSE)
	      (SOJG 4 , A)
	  TRUE(CQ X)
	      (RET)
	  FALSE
	      (HRRZ 1 , KNIL)
	      (RET])

(STRMEMB
  [LAMBDA (X Y)
    (PROG (C N)
          (SETQ Y (SUBSTRING Y 1))
      B   (SETQ N 1)
      A   (COND
	    ((NULL (SETQ C (NTHCHAR X N)))
	      (RETURN Y)))
          (COND
	    ((EQ C (NTHCHAR Y N))
	      (SETQ N (ADD1 N))
	      (GO A)))
          (COND
	    ((NULL (GNC Y))
	      (RETURN))
	    (T (GO B])

(STRPOS
  [LAMBDA (X Y START SKIP ANCHOR TAIL)
    [COND
      [(LITATOM X)
	(SETQ X (CDR (VAG (IPLUS (LOC X)
				 2]
      ((NULL (STRINGP X))
	(SETQ X (MKSTRING X]
    [COND
      ((STRINGP Y))
      [(LITATOM Y)
	(SETQ Y (CDR (VAG (IPLUS (LOC Y)
				 2]
      (T (SETQ Y (MKSTRING Y]
    (ASSEMBLE NIL
	      (CQ SKIP)
	      (CAMN 1 , KNIL)
	      (JRST A)
	      (CQ (VAG (CHCON1 SKIP)))
	      (SKIPA)
	  A   (SETO 1 ,)
	      (PUSHN 1)                         (* SKIP CHAR)
	      (CQ X)
	      (PUSHJ CP , UPATM)
	      (PUSH CP , 3)                     (* BYTE PTR. ORIG X)
	      (PUSHN 4)                         (* LENGTH ORIG X)
	      (CQ START)
	      (CAMN 1 , KNIL)
	      (SKIPA 1 , = 1)
	      (PUSHJ CP , IUNBOX)
	      (MOVE 7 , 1)                      (* SAVE START)
	      (CQ Y)
	      (PUSHJ CP , UPATM)
	      (PUSH CP , 3)                     (* BYTE PTR ORIG Y)
	      (PUSHN 4)                         (* LENGTH ORIG Y)
	      (SKIPG 7)
	      (ADDI 7 , 1 (4))                  (* START NEG, ADD LEN+1)
	      (JUMPLE 7 , FALSE)
	      (SUBI 4 , -1 (7))
	      (JUMPL 4 , FALSE)
	      (SUBI 7 , 1)
	      (IDIVI 7 , 5)
	      (ADDM 7 , 0 (CP))                 (* UPDATE BYTE PTR TO 
                                                START)
	      (SKIPA)
	      (IBP 0 (CP))
	      (SOJGE 10Q , * -1)
	      (SETZ 7 ,)
	      (CQ ANCHOR)
	      (CAME 1 , KNIL)
	      (SETO 7 ,)
	  B   (MOVE 3 , 0 (CP))
	      (MOVE 5 , -1 (CP))
	      (NREF (MOVE 6 , -1))
	      (CAIGE 4 , 0 (6))
	      (JRST FALSE)
	  L   (SOJL 6 , RY)
	      (ILDB 1 , 5)
	      (ILDB 2 , 3)
	      (CAIE 1 , 0 (2))
	      (NREF (CAMN 1 , -2))
	      (JRST L)
	      (JUMPN 7 , FALSE)                 (* QUIT IF ANCHORED)
	      (SOJLE 4 , FALSE)                 (* QUIT IF Y EMPTY)
	      (IBP 0 (CP))
	      (JRST B)
	  RY  (NREF (MOVE 1 , 0))
	      (LDV2 (QUOTE TAIL)
		    SP 2)
	      (CAME 2 , KNIL)
	      (NREF (ADD 1 , -1))
	      (SUBI 1 , -1 (4))
	      (PUSHJ CP , MKN)
	      (JRST OUT)
	  FALSE
	      (MOVE 1 , KNIL)
	  OUT (POPNN 3)
	      (SUB CP , BHC 2)
	      (RET])

(STRPOSL
  [LAMBDA (A STR START NEG)                     (* E (RADIX 10Q))
                                                (* Construct bit table 
                                                if necessary and set up 
                                                pointer.)
    (COND
      ((NOT (ARRAYP A))
	(SETQ A (MAKEBITTABLE A NEG STRPOSLARRAY)))
      (NEG (ASSEMBLE NIL
		     (CQ A)
		     (E (CEXP2 (QUOTE STRPOSLARRAY)))
		     (SETCM 3 , 2 (1))
		     (MOVEM 3 , 2 (2))
		     (SETCM 3 , 3 (1))
		     (MOVEM 3 , 3 (2))
		     (SETCM 3 , 4 (1))
		     (MOVEM 3 , 4 (2))
		     (SETCM 3 , 5 (1))
		     (MOVEM 3 , 5 (2)))
	   (SETQ NEG NIL)
	   (SETQ A STRPOSLARRAY)))
    (ASSEMBLE NIL
	      (CQ A)
	      (ADD 1 , = 102000002Q)
	      (PUSHN 1)
	      (PUSHN = 0))                      (* Construct byte 
                                                pointer and byte count 
                                                for atom or string.)
    (PROG NIL
      L1                                        (* Compute starting byte
                                                number and save on 
                                                number stack, replacing 
                                                NEG flag.)
          (ASSEMBLE NIL
		    (NREF (SETZM 0))
		    (CQ START)
		    (CAMN 1 , ' NIL)
		    (JRST CC)
		    (CQ (VAG (AC)))
		    (SUBI 1 , 1)
		    (NREF (MOVEM 1 , 0))
		    (JUMPGE 1 , CC)
		    (CQ (VAG (IPLUS (NCHARS STR)
				    START)))
		    (NREF (MOVEM 1 , 0))
		CC)
          (COND
	    ((STRINGP STR)
	      (ASSEMBLE NIL
		        (CQ STR)
		        (MOVE 1 , 0 (1))
		        (LDB 4 , = 251700000001Q)
		        (TLZ 1 , 777770Q)
		        (IDIVI 1 , 5)
		        (IMUL 2 , = -70000Q)
		        (ADDI 2 , 440700Q)
		        (HRL 1 , 2)))
	    ((LITATOM STR)
	      (ASSEMBLE NIL
		        (CQ STR)
		        (HLRZ 1 , 2 (1))
		        (HRLI 1 , 440700Q)
		        (ILDB 4 , 1)))
	    (T (SETQ STR (MKSTRING STR))
	       (GO L1)))                        (* Now have byte pointer
                                                in 1, count in 4)
      )
    (ASSEMBLE NIL
	      (POPN 2)
	      (JUMPL 2 , NO)
	      (SUB 4 , 2)
	      (JUMPLE 4 , NO)
	      (MOVN 4 , 4)
	      (HRLZ 4 , 4)
	      (JUMPE 2 , LP)                    (* Start at other than 
                                                first character, must 
                                                increment byte pointer.)
	      (ADD 4 , 2)
	      (IDIVI 2 , 5)
	      (ADD 1 , 2)                       (* Word part.
                                                Just do IBP's for byte 
                                                part)
	      (JUMPE 3 , LP)
	  LP1 (IBP 1)
	      (SOJG 3 , LP1)
	  LP  (ILDB 2 , 1)
	      (IDIVI 2 , 44Q)
	      (NREF (MOVE 2 , @ 0))
	      (ROT 2 , 0 (3))
	      (JUMPL 2 , YES)
	      (AOBJN 4 , LP)
	  NO  (CQ NIL)
	      (JRST OUT)
	  YES (HRRZ 1 , 4)
	      (ADDI 1 , 1)
	      (CQ (LOC (AC)))
	  OUT (POPNN 1))                        (* E (RADIX 10))
    ])

(MAKEBITTABLE
  [LAMBDA (L NEG A)                             (* E (RADIX 10Q))
    (OR (AND (ARRAYP A)
	     (IGREATERP (ARRAYSIZE A)
			3))
	(SETQ A (ARRAY 4 4)))
    (ASSEMBLE NIL
	      (CQ NEG)
	      (CAMN 1 , ' NIL)
	      (SKIPA 2 , = 0)
	      (MOVNI 2 , 1)
	      (VAR (HRRZ 3 , A))
	      (MOVEM 2 , 2 (3))
	      (MOVEM 2 , 3 (3))
	      (MOVEM 2 , 4 (3))
	      (MOVEM 2 , 5 (3))
	      (SKIPA 1 , INS)
	  INS (MOVE 2 , 0 (2))
	      (HRRI 1 , 2 (3))
	      (PUSH CP , 1)
	      (ANDI 2 , 400000Q)
	      (PUSHN 2)                         (* Construct bit table 
                                                from list of character 
                                                codes.)
	  L2  (CQ L)
	      (STE (QUOTE LISTT))
	      (JRST OUT)
	      (CQ (VAG (LOGAND (OR (NUMBERP (CAR L))
				   (CHCON1 (CAR L)))
			       177Q)))
	      (MOVE 2 , 1)
	      (IDIVI 2 , 44Q)
	      (MOVE 1 , @ 0 (CP))
	      (ROT 1 , 0 (3))
	      (TLO 1 , 400000Q)
	      (NREF (TSC 1 , 0))
	      (MOVN 3 , 3)
	      (ROT 1 , 0 (3))
	      (MOVEM 1 , @ 0 (CP))
	      (CQ (SETQ L (CDR L)))
	      (JRST L2)
	  OUT (SUB CP , BHC 1)
	      (POPNN 1)
	      (CQ A)                            (* E (RADIX 10))
	  ])

(SUB1
  [LAMBDA (X)
    (IPLUS X -1])

(SYNTAXP
  [LAMBDA (CH CLASS TABLE)
    (COND
      [(FMEMB CLASS (QUOTE (CHARDELETE DELETECHAR LINEDELETE DELETELINE 
				       RETYPE CNTRLV CTRLV EOL)))
	(EQ (VAG (LOGAND CH 177Q))
	    (CAR (VAG (IPLUS (LOC (GETTERMTABLE TABLE))
			     (SELECTQ CLASS
				      ((CHARDELETE DELETECHAR)
					2)
				      ((DELETELINE LINEDELETE)
					3)
				      (RETYPE 4)
				      ((CNTRLV CTRLV)
					5)
				      (EOL 6)
				      (HELP]
      ((EQ CLASS (QUOTE NONE))
	(SETQ TABLE (GETTERMTABLE TABLE))
	(SETQ CH (VAG (LOGAND CH 177Q)))
	(PROG (I)
	      (SETQ I 2)
	  LP  (COND
		((IGREATERP I 6)
		  (RETURN T)))
	      (AND (EQ (OPENR (IPLUS (LOC TABLE)
				     I))
		       (LOC CH))
		   (RETURN NIL))
	      (SETQ I (ADD1 I))
	      (GO LP)))
      (T [SETQ CH (CDR (VAG (IPLUS (LOC (GETREADTABLE TABLE))
				   (LOGAND CH 177Q)
				   2]
	 (SELECTQ CLASS
		  [(BREAK SEPR)
		    (NEQ 0 (LOGAND (LOC CH)
				   (SELECTQ CLASS
					    (BREAK 200Q)
					    (SEPR 100Q)
					    (HELP]
		  [(MACRO SPLICE INFIX LEFTPAREN RIGHTPAREN LEFTBRACKET 
			  RIGHTBRACKET BREAKCHAR SEPRCHAR ESCAPE 
			  STRINGDELIM OTHER)
		    (EQ (LOC CH)
			(SELECTQ CLASS
				 (MACRO 245Q)
				 (SPLICE 246Q)
				 (INFIX 247Q)
				 (LEFTPAREN 243Q)
				 (RIGHTPAREN 244Q)
				 (LEFTBRACKET 242Q)
				 (RIGHTBRACKET 241Q)
				 (STRINGDELIM 260Q)
				 (ESCAPE 50Q)
				 (BREAKCHAR 240Q)
				 (SEPRCHAR 140Q)
				 (OTHER 0)
				 (HELP]
		  (ERROR "Illegal syntax class" CLASS])

(TYPEP
  [LAMBDA (X N)
    (EQ (NTYP X)
	N])

(ZEROP
  [LAMBDA (X)
    (EQ X 0])

(RELINK
  [LAMBDA (FN UNLINKFLG)                        (* If UNLINKFLG is T, 
                                                unlinks all linked 
                                                calls.)
    (PROG (TEM)
          [COND
	    ((EQ FN (QUOTE WORLD))
	      (MAPC SYSLINKEDFNS (FUNCTION RELINK1))
	      (MAPC LINKEDFNS (FUNCTION RELINK1)))
	    ((FNTYP FN)
	      (RELINK1 FN))
	    [[OR (LISTP (SETQ TEM FN))
		 (LISTP (SETQ TEM (CAR TEM]
	      (MAPC TEM (FUNCTION (LAMBDA (X)
			(COND
			  ((NLISTP X)
			    (RELINK1 X))
			  [(NULL (CAR X))       (* Convention for 
                                                specifiying normal 
                                                compilation via block 
                                                declaration.)
			    (MAPC (CDR X)
				  (FUNCTION (LAMBDA (X)
				      (AND (NLISTP X)
					   (RELINK1 X]
			  (T                    (* So you can do RELINK 
                                                (BREAKBLOCKS))
			     (RELINK1 (CAR X]
	    (T (RETURN (QUOTE ?]
          (RETURN FN])

(RELINK1
  [LAMBDA (FN)
    (PROG (Z)
          (RETURN (COND
		    ((SCODEP (SETQ Z (CGETD FN)))
		      (SWPPOS Z (FUNCTION RELINK2)))
		    ([OR (CCODEP Z)
			 (CCODEP (SETQ Z
				   (CGETD (OR (GETP FN (QUOTE ADVISED))
					      (GETP FN (QUOTE BROKEN]
		      (RELINK2 Z T))
		    ((SCODEP Z)
		      (SWPPOS Z (FUNCTION RELINK2])

(RELINK2
  [LAMBDA (Z ARRAYFLG)
    (PROG (ADR END EXCALQ HCCALQ CCALC SBCALQ)
          [COND
	    [ARRAYFLG
	      [SETQ ADR (CAR (VAG (IPLUS 2 (LOC Z]
	      (SETQ END
		(VAG (IPLUS -2
			    [LOC (CDR (VAG (IPLUS (LOC Z)
						  -2]
			    (LOC Z]
	    (T
	      [SETQ ADR
		(VAG (IPLUS (LOC Z)
			    (LOC (CAR (VAG (IPLUS (LOC Z)
						  4]
	      (SETQ END (VAG (IPLUS (LOC Z)
				    (LOC (CDR Z]
          [SETQ EXCALQ (VAG (GETP (QUOTE EXCALQ)
				  (QUOTE COREVAL]
          [SETQ HCCALQ (VAG (GETP (QUOTE HCCALQ)
				  (QUOTE COREVAL]
          [SETQ CCALC (VAG (GETP (QUOTE CCALC)
				 (QUOTE COREVAL]
          [SETQ SBCALQ (VAG (GETP (QUOTE SBCALQ)
				  (QUOTE COREVAL]
      LP  [COND
	    ((EQ ADR END)
	      (RETURN T))
	    ((OR (EQ (SETQ Z (CAR ADR))
		     CCALC)
		 [AND (NULL (ILESSP (LOC Z)
				    (LOC HCCALQ)))
		      (NULL (IGREATERP (LOC Z)
				       (LOC EXCALQ]
		 (EQ Z SBCALQ))

          (* HERE WE ARE (YEECH) COUNTING ON ALL THE HCCAL'S 
          PRECEEDING EXCALQ IN LISP.MAC)


	      (AND (LITATOM (CDR ADR))
		   (DOLINK ADR 0 (CDR ADR)
			   (AND (NULL UNLINKFLG)
				FN)
			   T)))
	    ((ATOM (SETQ Z (CAR ADR)))
	      (AND (EQ (NTHCHAR Z -5)
		       (QUOTE A))
		   (EQ (NTHCHAR Z -4)
		       (QUOTE 0))
		   (RELINK1 Z)))
	    ((LISTP Z)
	      (AND (EQ (NTHCHAR (SETQ Z (CAR Z))
				-5)
		       (QUOTE A))
		   (EQ (NTHCHAR Z -4)
		       (QUOTE 0))
		   (RELINK1 Z]
          [SETQ ADR (VAG (ADD1 (LOC ADR]
          (GO LP])

(NOLINKDEF1
  [NLAMBDA (FN REL NAME)

          (* GET HERE FROM A LINKED CALL TO A FUNCTION THAT 
          WAS UNDEFINED AT TIME OF LINK.
          FN AND REL ARE LOCATORS FOR THE LINKED CALL LITERAL 
          IN THE CALLER , NAME IS THE CALLEE.)


    (PROG ((I NOLINKARGS)
	   ARGS)
      LP  (COND
	    ((ZEROP I)
	      (GO A)))
          (SETQ ARGS (CONS (ARG NOLINKARGS I)
			   ARGS))
          (SUB1VAR I)
          (GO LP)
      A   (COND
	    ((OR (NULL NAME)
		 (NOT (LITATOM NAME)))
	      (HELP)))
          [COND
	    ((FGETD NAME)

          (* The linkee is now defined.
          We should fix up the link and proceed transparently.
          Not an error.)


	      (DOLINK FN REL NAME T T)
	      (RETURN (APPLY NAME ARGS]

          (* The linkee is still undefined.
          Must make udf error, but remember that if he defines 
          name in the BREAK then we ought to do linkup this 
          time.)


          (RETURN (PROG1 (FAULTAPPLY NAME ARGS)
			 (AND (FGETD NAME)
			      (DOLINK FN REL NAME T T])
)
  (COND ((EQ (CAR (QUOTE GENNUM))
	     (QUOTE NOBIND))
	 [MAPC (QUOTE ((FRPLACA . RPLACA)
		       (FRPLACD . RPLACD)
		       (DECLARE . QUOTE)
		       (MAKEPDQ)
		       (SETCV)))
	       (FUNCTION (LAMBDA (X)
				 (PUTD (CAR X)
				       (GETD (CDR X]
	 [COND ((EXPRP (GETD (QUOTE LAPRD)))
		[PUTDQ STREQUAL (LAMBDA
			 (X Y)
			 (COND ((AND (STRINGP X)
				     (STRINGP Y))
				(SETQ X (SUBSTRING X 1))
				(SETQ Y (SUBSTRING Y 1))
				(PROG (Z)
				      LP
				      [COND ((EQ (SETQ Z (GNC X))
						 (GNC Y))
					     (COND (Z (GO LP))
						   (T (RETURN T]
				      (RETURN]
		[PUTDQ STRPOS
		       (LAMBDA
			 (X Y START SKIP ANCHOR TAIL)
			 [COND [(LITATOM X)
				(SETQ
				  X
				  (CDR (VAG (IPLUS (LOC X)
						   2]
			       ((NULL (STRINGP X))
				(SETQ X (MKSTRING X]
			 [COND ((STRINGP Y))
			       [(LITATOM Y)
				(SETQ
				  Y
				  (CDR (VAG (IPLUS (LOC Y)
						   2]
			       (T (SETQ Y (MKSTRING Y]
			 [COND (SKIP (SETQ SKIP (NTHCHAR SKIP 1]
			 (COND [START (COND ((MINUSP START)
					     (SETQ START
						   (IPLUS START
							  (NCHARS
							    Y)
							  1]
			       (T (SETQ START 1)))
			 (SETQ Y (SUBSTRING Y START))
			 (PROG ((N START)
				W X1 Y1)
			       L2
			       (SETQ X1 (SUBSTRING X 1))
			       (SETQ Y1 (SUBSTRING Y 1))
			       LP
			       (COND [(SETQ W (GNC X1))
				      (COND ((EQ W (GNC Y1))
					     (GO LP))
					    ((EQ W SKIP)
					     (GO LP))
					    (T (GO NX]
				     (TAIL (RETURN (IPLUS (NCHARS
							    X)
							  N)))
				     (T (RETURN N)))
			       NX
			       (COND (ANCHOR (RETURN)))
			       (COND ((GNC Y)
				      (SETQ N (ADD1 N))
				      (GO L2))
				     (T (RETURN]
		[PUTDQ STRPOSL (LAMBDA
			 (L STR)
			 (PROG (TEM)
			       (SETQ STR (MKSTRING STR))
			       [SOME L (FUNCTION (LAMBDA
						   (X)
						   (SETQ TEM
							 (STRPOS X STR]
			       (RETURN TEM]
		(PUTDQ MAKEBITTABLE (LAMBDA (X)
					    X]
	 [COND ([AND (NEQ (CAR (QUOTE SPAGHETTIFLG))
			  (QUOTE NOBIND))
		     SPAGHETTIFLG
		     (NULL (GETD (QUOTE SCODEP]
		(PUTDQ SCODEP (LAMBDA NIL NIL]
	 (RPAQQ GENNUM 10000)
	 (RPAQQ GENSTR "A0001")
	 (RPAQQ NOLINKMESS T)
	 (RPAQQ BINCOMPFLG T)
	 (RPAQQ BINFIXFLG T)
	 (SETQ STRPOSLARRAY (ARRAY 4 4))
	 (RPAQQ OCOREVALS NOBIND)
	 (RPAQQ SCOREVALS NOBIND)))
  (RPAQQ F NIL)
  (RPAQQ *T* T)
  [RPAQQ BASICBLOCKS ((NIL LAPRD DOLINK BINRD)
	  (NIL BINRD CGETD FNTYP ARGLIST ARGLIST1 NARGS GENSYM
	       (LINKFNS . T)
	       (GLOBALVARS GENSTR GENNUM)
	       STREQUAL SELECTQ LCSKIP LCCOP LCSK BINSKIP BINFIX)
	  (LINKBLOCK RELINK RELINK1 RELINK2 DOLINK
		     (ENTRIES RELINK RELINK2 DOLINK)
		     (GLOBALVARS SYSLINKEDFNS)
		     (LOCALFREEVARS UNLINKFLG))
	  (EQUAL)
	  (STRPOSLBLOCK STRPOSL MAKEBITTABLE (ENTRIES STRPOSL 
						      MAKEBITTABLE]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
  (BLOCK: NIL LAPRD DOLINK BINRD)
  (BLOCK: NIL BINRD CGETD FNTYP ARGLIST ARGLIST1 NARGS GENSYM
	  (LINKFNS . T)
	  (GLOBALVARS GENSTR GENNUM)
	  STREQUAL SELECTQ LCSKIP LCCOP LCSK BINSKIP BINFIX)
  (BLOCK: LINKBLOCK RELINK RELINK1 RELINK2 DOLINK
	  (ENTRIES RELINK RELINK2 DOLINK)
	  (GLOBALVARS SYSLINKEDFNS)
	  (LOCALFREEVARS UNLINKFLG))
  (BLOCK: EQUAL)
  (BLOCK: STRPOSLBLOCK STRPOSL MAKEBITTABLE (ENTRIES STRPOSL 
						     MAKEBITTABLE))
]
  (RELINK (QUOTE BASICBLOCKS))
[DECLARE: DOEVAL@COMPILE DONTCOPY 
(DEFLIST(QUOTE(
  [FGETP
    (X
      (PROG ((ATM (CAR X))
	     (PROP (CADR X))
	     Q B)
	    [SETQ Q (AND (LISTP PROP)
			 (EQ (CAR PROP)
			     (QUOTE QUOTE]
	    (RETURN
	      (SUBPAIR (QUOTE (ATM PROP B))
		       (LIST (COND (Q ATM)
				   (T (SETQ B
					    (LIST (LIST (QUOTE FGETPX)
							ATM)))
				      (QUOTE FGETPX)))
			     [COND (Q (CONS (QUOTE ')
					    (CDR PROP)))
				   ((LITATOM PROP)
				    (LIST (LIST (QUOTE VREF)
						PROP)))
				   (T (SETQ B
					    (CONS (LIST (QUOTE FGETPY)
							PROP)))
				      (QUOTE ((VREF FGETPY]
			     B)
		       (QUOTE (PROG B
				    (RETURN (ASSEMBLE NIL (CQ ATM)
						      (HRRZ 2 , . PROP)
						      FGETPLOOP
						      (HLRZ 1 , 0
							    (1))
						      (CAMN 1 , KNIL)
						      (JRST FGETPDONE)
						      (HRRZ 3 , 0
							    (1))
						      (HLRZ 1 , 0
							    (1))
						      (CAME 3 , 2)
						      (JRST FGETPLOOP)
						      (HRRZ 1 , 0
							    (1))
						      FGETPDONE]
  (FRPTQ ((N F)
	  (ASSEMBLE NIL (CQ (VAG N))
		    (JUMPLE 1 , RPT2)
		    (PUSHN 1)
		    RPT1
		    (CQ F)
		    (NREF (SOSE 0))
		    (JRST RPT1)
		    (POPNN 1)
		    RPT2)))
  [OBIN ((JFN)
	 (LOC (ASSEMBLE NIL (CQ JFN)
			(JSYS 40)
			(MOVE 1 , 2]
  [OBOUT ((BYTE JFN)
	  (ASSEMBLE NIL (CQ JFN)
		    [E (CEXP2 (QUOTE (VAG BYTE]
		    (JSYS 41]
  [OSFBSZ ((JFN N)
	   (ASSEMBLE NIL (CQ JFN)
		     [E (CEXP2 (QUOTE (VAG N]
		     (JSYS 38]
  (OSIN ((ORG N JFN)
	 (ASSEMBLE NIL (CQ (VAG N))
		   (JUMPLE 1 , OUT)
		   (PUSHN 1)
		   (CQ JFN)
		   (E (CEXP2 (QUOTE ORG)))
		   (HRLI 2 , 149760)
		   (POPN 3)
		   (MOVN 3 , 3)
		   (JSYS 42)
		   OUT)))
  [ONIN ((JFN)
	 (LOC (ASSEMBLE NIL (CQ JFN)
			(MOVEI 3 , 10)
			(JSYS 149)
			(MOVNI 2 , 1)
			(JSYS 34)
			(JFCL)
			(MOVE 1 , 2]
  [ORFPTR ((JFN)
	   (LOC (ASSEMBLE NIL (CQ JFN)
			  (JSYS 35)
			  (HRLZI 2 , 131071)
			  (MOVE 1 , 2]
  [OSFPTR ((JFN POS)
	   (ASSEMBLE NIL (CQ JFN)
		     [E (CEXP2 (QUOTE (VAG POS]
		     (JSYS 23)
		     (JFCL]
))(QUOTE MACRO))
]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA SELECTQ NLIST E)
  (ADDTOVAR NLAML NOLINKDEF1 RPAQQ FUNCTION)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (3718 59068 (LAPRD 3730 . 8518) (NIN 8522 . 8698) (BINRD
8702 . 11117) (LCSKIP 11121 . 13028) (LCCOP 13032 . 14137) (LCSK 14141
. 14949) (BINSKIP 14953 . 17365) (BINFIX 17369 . 19155) (DOLINK 19159
. 21898) (CAAR 21902 . 21941) (CADR 21945 . 21984) (CDAR 21988 . 22027)
(CDDR 22031 . 22070) (CAAAR 22074 . 22115) (CAADR 22119 . 22160) (CADAR
22164 . 22205) (CADDR 22209 . 22250) (CDAAR 22254 . 22295) (CDADR
22299 . 22340) (CDDAR 22344 . 22385) (CDDDR 22389 . 22430) (CAAAAR
22434 . 22477) (CAAADR 22481 . 22524) (CAADAR 22528 . 22571) (CAADDR
22575 . 22618) (CADAAR 22622 . 22665) (CADADR 22669 . 22712) (CADDAR
22716 . 22759) (CADDDR 22763 . 22806) (CDAAAR 22810 . 22853) (CDAADR
22857 . 22900) (CDADAR 22904 . 22947) (CDADDR 22951 . 22994) (CDDAAR
22998 . 23041) (CDDADR 23045 . 23088) (CDDDAR 23092 . 23135) (CDDDDR
23139 . 23182) (ABS 23186 . 23266) (ADD1 23270 . 23308) (ARRAYSIZE
23312 . 23868) (ARGLIST 23872 . 24815) (ARGLIST1 24819 . 26552) (CGETD
26556 . 26634) (DELETECONTROL 26638 . 28403) (DIFFERENCE 28407 . 28459)
(ECHOCONTROL 28463 . 29647) (E 29651 . 29690) (EQUAL 29694 . 29946)
(EVQ 29950 . 29978) (FDIFFERENCE 29982 . 30036) (FIX 30040 . 30109)
(FIXP 30113 . 30182) (FMINUS 30186 . 30231) (FLOAT 30235 . 30308)
(FNTYP 30312 . 31318) (FNTYP1 31322 . 31350) (FUNCTION 31354 . 31919)
(GENSYM 31923 . 32065) (GETSYNTAX 32069 . 35719) (HARRAY 35723 . 35774)
(IDIFFERENCE 35778 . 35833) (ILESSP 35837 . 35883) (IMINUS 35887 .
35930) (LESSP 35934 . 35978) (LRSH 35982 . 36029) (NARGS 36033 . 36663)
(NEQ 36667 . 36708) (NILL 36712 . 36738) (NLIST 36742 . 36789) (NLIST1
36793 . 37046) (NLISTP 37050 . 37094) (NTH 37098 . 37358) (RATOMS
37362 . 37545) (RPAQQ 37549 . 37592) (RSH 37596 . 37641) (SELECTQ
37645 . 37797) (SELECTQ1 37801 . 38076) (SETA 38080 . 38643) (SETD
38647 . 39210) (SETEDITC 39214 . 40058) (SETINTC 40062 . 41173) (
SETSYNTAX 41177 . 44563) (SMALLP 44567 . 44619) (STORAGE 44623 . 45843)
(STREQUAL 45847 . 46409) (STRMEMB 46413 . 46750) (STRPOS 46754 . 48919)
(STRPOSL 48923 . 52067) (MAKEBITTABLE 52071 . 53332) (SUB1 53336 .
53375) (SYNTAXP 53379 . 54893) (TYPEP 54897 . 54944) (ZEROP 54948
. 54984) (RELINK 54988 . 56085) (RELINK1 56089 . 56437) (RELINK2 56441
. 57982) (NOLINKDEF1 57986 . 59065)))))
STOP
