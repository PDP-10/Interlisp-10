(FILECREATED "17-OCT-74 16:04:58" DWIM.;1 47592  

     changes to:  FIXSPELL1

     previous date: "11-OCT-74 14:28:42" <LISP>DWIM.;3)


  (LISPXPRINT (QUOTE DWIMCOMS)
	      T T)
  [RPAQQ DWIMCOMS
	 ((FNS * DWIMFNS)
	  (VARS (USERWORDS)
		(SPELLINGS1 (QUOTE (DEFINEQ ARGLIST MOVD GETD FNTYP BREAK UNBREAK REBREAK TRACE 
					    BREAKIN MAKEFILE MAKEFILES LISTFILES FILES? WHEREIS 
					    CLEANUP PRETTYDEF PRETTYPRINT PP EDITF EDITV EDITP 
					    ADVISE UNADVISE UNSAVEDEF RECOMPILE TCOMPL COMPILE 
					    BRECOMPILE BCOMPL BLOCKCOMPILE MAPCAR MAPC LOAD 
					    TIME CLOSEF CLOSEALL OPENP OUTPUT INPUT OUTFILE 
					    INFILE LOGOUT PUT REMPROP GETP SYSIN SYSOUT SUBSYS 
					    CLISPIFY DWIMIFY FOR WHILE THEREIS DO NIL)))
		(SPELLINGS2 (QUOTE (ADD1 AND APPEND ASSOC ATOM COND CONS COPY ELT EQ EQUAL 
					 ERROR ERSETQ EVAL FASSOC FMEMB FRPLACA FRPLACD 
					 FUNCTION GO IDIFFERENCE IGREATERP ILESSP IMINUS IPLUS 
					 ITIMES LENGTH LIST LISTP MAPC MAPCAR MAPCONC MEMB 
					 MEMBER NCONC NCONC1 NEQ NLISTP NLSETQ NULL NUMBERP OR 
					 PRINT PRIN1 PROG PROGN PUT QUOTE READ RETURN RPLACA 
					 RPLACD SELECTQ SETA SETQ SPACES SUB1 TCONC TERPRI 
					 ZEROP /RPLACA /RPLACD IF F/L VALUEOF FOR WHILE THEREIS 
					 DO FETCH REPLACE CREATE RECORD NIL)))
		(SPELLINGS3 (QUOTE (NIL EDITMACROS BREAKMACROS BROKENFNS ADVISEDFNS PRETTYFLG 
					SYSPROPS DWIMFLG CLISPFLG LASTWORD USERWORDS 
					NOTLISTEDFILES FILELST NOTCOMPILEDFILES LISPXPRINTFLG 
					PROMPT#FLG TREATASCLISPFLG VARDEFAULT CLISPIFYPRETTYFLG 
					DWIMIFYCOMPFLG FILERDTBL EDITRDTBL)))
		DWIMODELST
		(FASTYPEFLG)
		(RUNONFLG T)
		(TREATASCLISPFLG)
		#USERWORDS #SPELLINGS1 #SPELLINGS2 #SPELLINGS3 (DWIMWAIT 10)
		(RESPELLS)
		(LCASEFLG T)
		(MODEL33FLG)
		(DWIMTTBL (COPYTERMTABLE)))
	  (P (SAVEDEF (QUOTE QUOTE))
	     (MOVD (QUOTE NEWQUOTE)
		   (QUOTE QUOTE))
	     (RAISE T DWIMTTBL)
	     (CONTROL T DWIMTTBL))
	  (PROP FILEGROUP DWIM)
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY (P (MINFS 25000 18)
							     (RECLAIM 18)
							     (MINFS 40000 8)
							     (MINFS 3000 12)
							     (MINFS 3000 28)
							     (RELINK (QUOTE WORLD)))
		    (PROP MACRO * (QUOTE (*)))
		    (VARS (COMMENTCNT 0)))
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA NEWQUOTE)
										(NLAML]
  (RPAQQ DWIMFNS (DWIM NEWQUOTE NEWFAULT1 ADDSPELL ADDSPELL1 MISSPELLED? FIXSPELL FIXSPELL1 
		       FIXSPELL2 DWIMESS DWIMREADC MOVETOP CHOOZ SKOR0 SKOR))
(DEFINEQ

(DWIM
  [LAMBDA (X)
    (COND
      ((NULL X)
	(/PUTD (QUOTE FAULT1)
	       (GETD (QUOTE OLDFAULT1)))
	(SETQ DWIMFLG NIL))
      ([SETQ X (ASSOC X (CAR (QUOTE DWIMODELST]
	(/PUTD (QUOTE FAULT1)
	       (GETD (QUOTE NEWFAULT1)))
	(SETQ DWIMFLG T)
	(SETQ FILEPKGFLG T)
	[MAPC (CDDR X)
	      (FUNCTION (LAMBDA (X)
		  (AND (LISTP X)
		       (SET (CAR X)
			    (CDR X]
	(CADR X))
      (T (ERROR (QUOTE "not on DWIMODELST.")
		(QUOTE )
		T])

(NEWQUOTE
  [NLAMBDA X
    (COND
      ((NULL (CDR X))
	(CAR X))
      (T (PROG (TEM)
	       [COND
		 ([AND (NEQ (SETQ TEM (STKNAME (STKNTH -1)))
			    (QUOTE QUOTE))
		       (EQ (GETD TEM)
			   (GETD (QUOTE NEWQUOTE]

          (* e.g. user didMOVD (QUOTE FOO) when he meant original 
          quote, not new one The EQ GETD check is just to make sure 
          the STKNAME found the right guy.)


		   (/PUTD TEM (GETP (QUOTE QUOTE)
				    (QUOTE SUBR)))
		   (RETURN (CAR X]
	       (ERROR (QUOTE "parenthesis error in")
		      (CONS (QUOTE QUOTE)
			    X])

(NEWFAULT1
  [LAMBDA (FAULTX FAULTARGS FAULTAPPLYFLG)      (* Replaces FAULT1)
    (PROG (FAULTZ)
          [COND
            ([SETQ FAULTZ (COND
                  (FAULTAPPLYFLG FAULTX)
                  (T (CAR FAULTX]
              [AND (LITATOM FAULTZ)
                   (SETQ FAULTZ (FGETD FAULTZ))
                   (SETQ FAULTZ (CHECKTRAN FAULTZ))
                   (COND
                     (FAULTAPPLYFLG (GO RETAPPLY))
                     (T (SETQ FAULTZ (CONS FAULTZ (CDR FAULTX)))
                        (GO RETEVAL]

          (* Covers the case where an atom has a definition that has a 
          clisp translation, e.g. FOO is defined as 
          (QLAMBDA --) There are two cases, FOO 
          (args) and (FOO args))


              ]
          (COND
            ((NLISTP FAULTX))
            [(SETQ FAULTZ (CHECKTRAN FAULTX))

          (* Covers the case where the form has a clis translation 
          itself, (most common), and the case where faultx is a 
          function object being applied and has a clisptranslation.)


              (COND
                (FAULTAPPLYFLG (GO RETAPPLY))
                (T (GO RETEVAL]
            ((AND (NULL FAULTAPPLYFLG)
                  (LISTP FAULTX)
                  (LISTP (SETQ FAULTZ (CAR FAULTX)))
                  (SETQ FAULTZ (CHECKTRAN FAULTZ)))

          (* Covers the case where car of form is a function objection 
          with a clisp translation, e.g. 
          ((QLAMBDA --) --))


              (SETQ FAULTZ (CONS FAULTZ (CDR FAULTX)))
              (GO RETEVAL)))
          (SETQ FAULTZ (WTFIX FAULTX FAULTARGS FAULTAPPLYFLG))
                                                (* INFO for diagnostic printed 
                                                by original FAULT1.)
          (RETURN (OLDFAULT1 FAULTX FAULTARGS FAULTAPPLYFLG FAULTZ))
      RETAPPLY
          [RETEVAL (QUOTE FAULTAPPLY)
                   (LIST (QUOTE APPLY)
                         (LIST (QUOTE QUOTE)
                               FAULTZ)
                         (LIST (QUOTE QUOTE)
                               (COND
                                 ((EQ (ARGTYPE FAULTZ)
                                      3)
                                   (CAR FAULTARGS))
                                 (T FAULTARGS)))
                         (QUOTE (QUOTE INTERNAL]
      RETEVAL
          (RETEVAL (QUOTE FAULTEVAL)
                   FAULTZ])

(ADDSPELL
  [LAMBDA (X SPLST N)

          (* Updates appropriate spellings lists as follows: if SPLST 
          is NIL, adds to USERWORDS and SPELLINGS2;
          -
          if SPLST is 0, just adds to USERWORDS;
          -
          if SPLST is 1, adds to SPELLINGS1;
          -
          if SPLST is 2, adds to SPELLINGS2;
          -
          if SPLST is 3, adds to USERWORDS and SPELLINGS3.
          -
          -
          SPELLINGS1 is the list of functions used in an APPLY 
          context, e.g. MAKEFILE, TCOMPL, DEFINEQ.
          SPELLINGS2 is the list of functions used in an EVAL context, 
          e.g. CONS, AND, RETURN. SPELLINGS3 is a list of variables.
          USERWORDS is a list of both functions and variables that the 
          user references.)


    (AND (LITATOM X)
         (SELECTQ SPLST
                  ((NIL 0)

          (* DEFINE uses SPLST NIL, adds word to SPELLINGS2 because 
          some user function must call it.
          However, it might not be a top-level function, so it isn't 
          added to SPELLINGS1 until used in that way.
          -
          SPLST 0 is for LOAD/PROP, and for use from EDITA, 
          PRINTSTRUCTURE, etc. doesn't add it to SPELLINGS2 since have 
          no indication that the function will be called by the user.)


                    (SETQ USERWORDS (ADDSPELL1 X USERWORDS #USERWORDS))
                    (AND (NULL SPLST)
                         (SETQ SPELLINGS2 (ADDSPELL1 X SPELLINGS2 #SPELLINGS2)))
                    (SETQ LASTWORD X))
                  (1 

          (* Called from LISPX on APPLY inputs, add to permanent 
          section, i.e. never forgets X.)


                     (SETQ SPELLINGS1 (ADDSPELL1 X SPELLINGS1)))
                  (2 

          (* Called from LISPX on EVAL inputs, never forgets X.
          Not however that words are added to temporary section of 
          SPELLINGS2 for TYPE=NIL or TYPE=0.)


                     (SETQ SPELLINGS2 (ADDSPELL1 X SPELLINGS2)))
                  ((T 3)

          (* Called from LISPX inputs consisting of just a variable, 
          or from SAVESET, i.e. any call to RPAQ or RPAQQ, or any call 
          to SET or SETQ via LISPX, or from EDITV.)


                    (SETQ USERWORDS (ADDSPELL1 X USERWORDS #USERWORDS))
                    (SETQ SPELLINGS3 (ADDSPELL1 X SPELLINGS3 #SPELLINGS3))
                    (SETQ LASTWORD X))
                  (COND
                    ((LISTP SPLST)
                      (ADDSPELL1 X SPLST N))
                    (T (ERROR (QUOTE "bad addspell type:")
                              SPLST T])

(ADDSPELL1
  [LAMBDA (WORD SPLST N)

          (* SPLST is divided into two sections, permanent and 
          temporary, separated by NIL. Words are never forgotten from 
          the permanent section. A maximum of N words are allowed in 
          the temporary section. When a correction occurs, the word is 
          moved to the front of the list, hence putting it in the 
          permanent section. -
          When ADDSPELL1 is called with N=NIL, words are added at the 
          end of the permanent section, i.e. just before the NIL.
          Otherwise they are added at the beginning of the temporary 
          section, and if there are more than N words in the temporary 
          list, the last is deleted.)


    [COND
      ((NULL SPLST)
        (SETQ SPLST (LIST NIL WORD)))
      ((AND (NEQ WORD (CAR SPLST))
            (NEQ WORD (CADR SPLST)))            (* Loop begins with third 
                                                element.)
        (PROG ((L1 SPLST)
               (L2 (CDDR SPLST))
               L3 M)

          (* L1 stays two behind L2 so that the last element of SPLST 
          can be deleted.)


              (COND
                ((NULL (CAR SPLST))
                  (SETQ L3 SPLST)
                  (SETQ M 1)                    (* L2 has already skipped one of
                                                the temporary words.)
                  )
                ((NULL (CADR SPLST))
                  (SETQ L3 SPLST)
                  (SETQ M 0)))

          (* Special check necessary because USERWORDS starts off with 
          NIL first, i.e. no permanent USERWORDS.
          If NIL not noticed, length won't be counted and nothing will 
          ever be deleted.)


          LP  (COND
                ((NULL L2)
                  (GO OUT))
                ((EQ WORD (CAR L2))
                  (COND
                    ((NULL L3)                  (* WORD is already in permanent 
                                                section.)
                      )
                    ((NULL N)

          (* WORD is in temporary section and would have been added to 
          permanent section. Add it to permanent and erase from 
          temporary.)


                      (FRPLACD (CDR L1)
                               (CDR L2))
                      (FRPLACD L2 (CDR L3))
                      (FRPLACD L3 L2))
                    (T 

          (* WORD is in temporary section and would have been added to 
          temporary section. MOVE it to front of temporary section.)


                       (FRPLACD (CDR L1)
                                (CDR L2))
                       (SETQ L3 (CDR L3))
                       (FRPLACD L2 (CDR L3))
                       (FRPLACD L3 L2)))
                  (RETURN))
                ((NULL (CAR L2))
                  (SETQ L3 (CDR L1))            (* CAR of L3 is the last member 
                                                of the permanent section.)
                  (SETQ M 0)))
              (SETQ L1 (CDR L1))
              (SETQ L2 (CDR L2))
              (AND M (ADD1VAR M))               (* M will be the length of 
                                                temporary section)
              (GO LP)
          OUT (COND
                ((NULL L3)

          (* NIL not found. Occurs if user is maintaining own spelling 
          list and not using temporary/permanent conventions.)


                  (/NCONC1 L1 WORD))
                [(NULL N)                       (* Add at end of permanent 
                                                section.)
                  (/RPLNODE L3 (CAR L3)
                            (CONS WORD (CDR L3]
                ((IGREATERP M N)

          (* Add at beginning of temporary section, delete 
          (AND REUSE) last element of temporary section.)


                  (/RPLNODE (CDR L1)
                            WORD
                            (CDDR L3))
                  (/RPLNODE (CDR L3)
                            (CADR L3)
                            (CDR L1))
                  (FRPLACD L1 NIL)              (* Not worth while to make the 
                                                deletion of last elemetn 
                                                undoable.)
                  )
                (T (/RPLNODE (CDR L3)
                             (CADR L3)
                             (CONS WORD (CDDR L3)))
                                                (* Add at beginning of temporary
                                                section.)
                   ]
    SPLST])

(MISSPELLED?
  [LAMBDA (XWORD REL SPLST FLG TAIL FN)

          (* MISSPELLED? can be used when XWORD may in fact be all 
          right. FIXSPELL should be used if you know XWORD is wrong.)


    (PROG NIL                                   (* REL is between 0 and 100 and 
                                                indicates percentage.)
          (RETURN (COND
		    ((OR (NULL XWORD)
			 (EQ XWORD (QUOTE )))
		      (LISPXWATCH SPELLSTATS1)
		      (PRIN1 (QUOTE =)
			     T)
		      (PRINT LASTWORD T T))
		    ((COND
			((NULL FN)
			  (FMEMB XWORD SPLST))
			(T (APPLY* FN XWORD)))
		      XWORD)
		    (T (FIXSPELL XWORD REL SPLST FLG TAIL FN])

(FIXSPELL
  [LAMBDA (XWORD REL SPLST FLG TAIL FN TIEFLG CLST APPROVALFLG)

          (* If FLG is T, XWORD is printed to left of = sign.
          -
          CLST is used when FIXSPELL is called from WTFIX.
          In this case, if TYPE-IN? is NIL, XWORD is printed, and a -> 
          is used instead of =. In addition, if FAULTFN is not NIL, 
          (IN FAULTFN) is also printed as part of the message.
          If CLST is a list, it is a DUNPACK of XWORD, since in most 
          cases WTFIX will already have computed this list.
          FLG is used to specify other types of messages besides ->.
          If TAIL is supplied, and word is equal to CAR of it, the 
          correction will be smahed into TAIL.
          If TAIL is non NIL, runon corrections will be attempted.
          (If TAIL=T, and a runon corection is approved, the dotted 
          pair is returned as the value.) If FLG=NO-MESSAGE, the 
          correction is returned without asking for approval.)


    (AND
      (LISTP SPLST)
      (LITATOM XWORD)
      (PROG ((TLST (DCHCON XWORD SKORLST1))
	     (L SPLST)
	     X TEM (NDBLS 0))
	    (COND
	      ((NULL XWORD)
		(RETURN NIL))
	      ((AND (OR (NULL CLST)
			TYPE-IN?)
		    (EQ XWORD (QUOTE )))
		(SETQ X LASTWORD)
		(FIXSPELL1 XWORD LASTWORD NIL CLST)
		(GO OUT1))
	      ([SETQ TEM (FASSOC XWORD (GET LISPXHIST (QUOTE RESPELLS]
                                                (* Already made this 
                                                correctionthis event.)
		(SETQQ APPROVALFLG NEEDNOTAPPROVE)
		(SETQ X (CDR TEM))
		(GO LP2)))
	    (SETQ X TLST)
	LP  (COND
	      ((NULL X)
		(GO A))
	      ((EQ (CAR X)
		   27)                          (* 27 Is alt-mode.)
		[COND
		  ((SETQ TEM (CDR X))

          (* If TEM is now NIL, the alt-mode is the last character, 
          and we can do the matching here in FIXSPELL, rather than 
          call SKOR0 for more general handling of alt-mode matching.
          As a result, more general alt-mode matching takes about 3 
          times as long as simple completion.)


		    (SETQ TLST (DUNPACK XWORD SKORLST1]
		(GO ALT))
	      ((EQ (CAR X)
		   TEM)
		(SETQ NDBLS (ADD1 NDBLS)))
	      (T (SETQ TEM (CAR X))             (* TEM keeps track of the 
                                                previous character.)
		 ))
	    (SETQ X (CDR X))
	    (GO LP)
	A   (COND
	      ((NULL MODEL33FLG)

          (* P,L,N,and O are on the same keys as @ \ ^ and _ only on 
          model 33's.)


		(GO LP1)))
	    (SETQ X (SELECTQ (CAR TLST)
			     (64                (* @)
				 (QUOTE P))
			     (92                (* \)
				 (QUOTE L))
			     (94                (* ^)
				 (QUOTE N))
			     (95                (* _)
				 (QUOTE O))
			     (GO LP1)))
	    [SETQ X (PACK (CONS X (CDR (OR (LISTP CLST)
					   (DUNPACK XWORD SKORLST2]
	    (COND
	      ([AND FN (NULL (COND
			       ((EQ FN (QUOTE GETD))
				 (FGETD X))
			       (T (APPLY* FN X]
		(GO LP1))
	      ((FMEMB X SPLST)
		(GO OUT))
	      (FN 

          (* Thus if a XWORD is misspelled by having its first 
          character changed from p to @, l to \, n to or o to _, and 
          satisfies FN, it will be corrected even if not on the 
          spelling list, and added to the list.)


		  (ATTACH X SPLST)
		  (GO OUT)))
	LP1 (SETQ X (CHOOZ TLST REL SPLST TAIL FN TIEFLG NDBLS CLST))
	LP2 [COND
	      ((NULL X)
		(RETURN NIL))
	      ((EQ TIEFLG (QUOTE ALL))
		(RETURN X))
	      ((LISTP X)
		(RETURN (COND
			  ((NULL TAIL)
			    NIL)
			  ((EQ FLG (QUOTE NO-MESSAGE))
			    X)
			  ((FIXSPELL1 XWORD X FLG CLST (OR APPROVALFLG
							   (QUOTE MUSTAPPROVE)))
                                                (* Runon correction.)
			    (COND
			      ((AND (LISTP TAIL)
				    (EQ XWORD (CAR TAIL)))
                                                (* Smash TAIL and eturn the 
                                                first word)
				(/RPLNODE TAIL (CAR X)
					  (CONS (CDR X)
						(CDR TAIL)))
				(CAR X))
			      (T                (* Return the dotted pair)
				 X]
	OUT (COND
	      ((EQ FLG (QUOTE NO-MESSAGE))
		(RETURN X))
	      ((FIXSPELL1 XWORD X FLG CLST APPROVALFLG)
                                                (* Prints appropriate message to
                                                user.)
		(MOVETOP X SPLST))
	      (T (RETURN NIL)))
	OUT1(AND (LISTP TAIL)
		 (EQ XWORD (CAR TAIL))
		 (/RPLNODE TAIL X (CDR TAIL)))
	    (RETURN X)
	ALT                                     (* Alt-mode matching.)
	    (RESETVAR EDITQUIETFLG T
	      (PROG NIL
		    (SETQ X NIL)
		LP3 [COND
		      ((NULL L)
			(RETURN))
		      ((NULL (CAR L)))
		      ([COND
			  (TEM (EDIT4E1 TLST (DUNPACK (CAR L)
						      SKORLST2)))
			  (T (PROG ((Y TLST)
				    (TEM (DCHCON (CAR L)
						 SKORLST2)))
                                                (* Terminal alt-mode matching.)
			       LP3 (COND
				     ((EQ (CAR Y)
					  27)
				       (RETURN T))
				     ((AND TEM (EQ (CAR Y)
						   (CAR TEM)))
				       (SETQ Y (CDR Y))
				       (SETQ TEM (CDR TEM))
				       (GO LP3]
			(COND
			  [(AND FN (NULL (COND
					   ((EQ FN (QUOTE GETD))
					     (FGETD (CAR L)))
					   (T (APPLY* FN (CAR L]
			  ((EQ TIEFLG (QUOTE ALL))
			    (SETQ X (CONS (CAR L)
					  X)))
			  (TIEFLG (SETQ X (CAR L)))
			  (X                    (* Already a match, therefore 
                                                ambiguous.)
			     (PRINT (QUOTE ambiguous)
				    T)
			     (SETQ X NIL)
			     (RETURN))
			  (T (SETQ X (CAR L]
		    (SETQ L (CDR L))
		    (GO LP3)))
	    (GO LP2])

(FIXSPELL1
  [LAMBDA (WORD X FLG CLST APPROVALFLG DEFAULT)             (* Performs interaction with user 
                                                            associated with a spelling or other 
                                                            corretion.)
    (PROG ([LISPXHIST (AND LISPXHIST (CONS (QUOTE *LISPXPRINT*)
					   (CONS NIL LISPXHIST]
	   TEM MESSFLG)

          (* LISPXHIST is rebound as we don't want to include any DWIM messages if the 
          change isn't actually performed, e.g. the user says NO.
          Therefore, we want to have LISPXPRIN1 et al save the output on a local 
          LISPXHIST, and then transfer it all over to the real LISPXHIST if the 
          correction goes through.)


          (AND (EQ WORD X)
	       (ERROR!))
          (COND
	    ((NEQ (POSITION T)
		  0)
	      (LISPXTERPRI T)
	      (TERPRI T)))
          (COND
	    ((OR (SETQ MESSFLG (OR (STRINGP WORD)
				   (STRINGP X)))
		 (EQ RESPELLS T))                           (* Dont keep respells.)
	      )
	    ((OR REREADFLG (STRPOS (QUOTE "")
				   WORD))                   (* Spelling completion)
	      )
	    ([OR (LISTP X)
		 (NULL (SETQ TEM (FASSOC X RESPELLS]
	      (SETQ RESPELLS (CONS (LIST X WORD)
				   RESPELLS)))
	    (T (NCONC1 TEM WORD)))
          (COND
	    ([AND (NEQ APPROVALFLG (QUOTE MUSTAPPROVE))
		  (COND
		    (CLST (AND TYPE-IN? (NULL MESSFLG)))
		    (T (NULL FLG]

          (* This is the case where the correction is a spelling correction 
          (as inidcated by MESSFLG being NIL), and no approval is needed.
          i.e. FIXSPELL1 is just going to print = followed by the word.)


	      [AND TEM (COND
		     ((EQ [SETQ TEM (AND CUTEFLG (IGREATERP (FLENGTH TEM)
							    5)
					 (SETQ TEM (RAND 1 7]
			  1)
		       (PRIN1 (QUOTE "Not again!
")
			      T]
	      (AND (OR (EQ REREADFLG (QUOTE T))
		       FLG)
		   (PRIN2 WORD T T))
	      (PRIN1 (QUOTE =)
		     T)
	      (FIXSPELL2 X)
	      (AND (EQ TEM 2)
		   (PRIN1 (QUOTE "You seem to be having a lot of trouble typing that!
")
			  T))
	      (GO OUT1)))
          (COND
	    ([AND (NEQ APPROVALFLG (QUOTE MUSTAPPROVE))
		  (COND
		    ((NULL CLST)
		      (OR (NULL FLG)
			  (NULL APPROVEFLG)))
		    (T 

          (* OR is true if approval is required. NOte that even if APPROVEFLG is T, 
          when there are two interpretations to a correction, as indicated by 
          CLISPCHANGES not being NIL, always aks approval.)


		       (NULL (OR (AND (NULL TYPE-IN?)
				      APPROVEFLG)
				 (AND CLST CLISPCHANGES]
	      (SETQQ APPROVALFLG NEEDNOTAPPROVE)

          (* Thus DWIMESS will know that approval will not be reqired so the buffers 
          need not be cleared.)


	      ))
          (DWIMESS WORD APPROVALFLG)
          (LISPXPRIN1 WORD T NIL T)                         (* Adds WORD to histry list but does
                                                            not actually print it.)
          (COND
	    ((AND CLST (NULL TYPE-IN?))
	      (FIXPRINTIN FAULTFN T)
	      (LISPXPRIN1 (OR FLG (QUOTE " -> "))
			  T))
	    (T (LISPXPRIN1 (COND
			     ((AND FLG (NEQ FLG T))
			       FLG)
			     (T (QUOTE =)))
			   T)

          (* E.g. For Shall I load ... message, FLG is "" for unary minus it is " ")


	       ))
          (AND (STRINGP WORD)
	       (STRINGP X)
	       (OR (NULL FLG)
		   (EQ FLG T))
	       (NOT (STREQUAL WORD (QUOTE "")))
	       (LISPXTERPRI T))

          (* On corrections where both left and right are strings, and FLG is normal 
          (thereby xcluding the TREAT AS CLISP case) print the strings on separate 
          lnes for readability.)


          (COND
	    ((EQ APPROVALFLG (QUOTE NEEDNOTAPPROVE))
	      (FIXSPELL2 X)
	      (GO OUT)))
          (FIXSPELL2 X T)
          (COND
	    ((AND (NEQ (SETQ TEM (DWIMREADC (COND
					      (MESSFLG 

          (* MESSFLG would be NIL for straight spelling correction.
          This says that the correction involves an 8 or a 9, or asks some question 
          about CLISP. User will probably need more time to think about it in this 
          case.)


						       (ITIMES 3 DWIMWAIT))
					      (T DWIMWAIT))
					    (COND
					      (DEFAULT)
					      ([AND (LISTP X)
						    (OR (ILESSP (SETQ TEM (NCHARS (CAR X)))
								3)
							(NOT (IGREATERP TEM
									(NCHARS (CDR X]

          (* Runon correction. Defaut is NO if less than three characters in first 
          word, or first word is not greater than second in length)


						(QUOTE n))
					      (T (QUOTE y)))
					    (QUOTE " ?  ")))
		       (QUOTE Y))
		  (NEQ TEM (QUOTE y)))
	      (AND (EQ TEM (QUOTE N))
		   (LISPXWATCH VETOSTATS))

          (* If value returned was 'n' as opposed to 'N', means defaulted to NO, not 
          vetoed.)


	      (RETURN NIL)))
          (LISPXTERPRI T NIL NIL T)

          (* Adds a TERPRI to history list if LISPXPRINTFLG is T, but does not 
          actually print a carriage return.)


      OUT (COND
	    ((CADR LISPXHIST)
	      (LISPXPUT (QUOTE *LISPXPRINT*)
			(CADR LISPXHIST)
			T
			(CDDR LISPXHIST))

          (* Makes the print information part of LISPXHIST.
          Before it was on a property that ws just consed onto the front.
          This will also add it to any other print information.)


	      ))
      OUT1[AND CLST LISPXHIST (NULL TYPE-IN?)
	       (NEQ (CAR SIDES)
		    (QUOTE CLISP% ))
	       (SETQ SIDES (LIST (QUOTE CLISP% )
				 (LIST (QUOTE *)
				       (CADR LISPXHIST)
				       SIDES]

          (* This marks the side information and print information as of the beginning 
          of this correction. For usefor selective undoing.
          CADR of LISPXHIST (which was rebound here), will be the beginning of the 
          PRINT information, which if approved, will be NCONCed onto the print 
          informaion for this event.)


          (COND
	    (MESSFLG (RETURN T))
	    (CLST (LISPXWATCH SPELLSTATS)
		  (AND LISPXHIST (LISPXPUT (QUOTE RESPELLS)
					   (LIST (CONS WORD X))
					   T LISPXHIST)))
	    (T (LISPXWATCH SPELLSTATS1)))
          (AND (LISTP X)
	       (LISPXWATCH RUNONSTATS))
          (RETURN T])

(FIXSPELL2
  [LAMBDA (X FLG)
    (COND
      ((LISTP X)
	(LISPXPRIN2 (CAR X)
		    T T)
	(LISPXSPACES 1 T)
	(LISPXPRIN2 (CDR X)
		    T T))
      ((STRINGP X)
	(LISPXPRIN1 X T))
      (T (LISPXPRIN2 X T T)))
    (COND
      ((NULL FLG)
	(LISPXTERPRI T])

(DWIMESS
  [LAMBDA (MESS FLG)
    [SETQ DWIMBUFS (COND
        ((OR (EQ FLG (QUOTE MUSTAPPROVE))
             (AND (NEQ FLG (QUOTE NEEDNOTAPPROVE))
                  APPROVEFLG))

          (* Want to clear out LINUF and SYSBUF to prevent CLBUFS from 
          misakenly returning left over typeahead from a previous 
          CLEARBUF.)


          (LINBUF)
          (SYSBUF)                              (* THE EXTRA ARGUMENT TO CLBUFS 
                                                PREVENTS READBUF FROM BEING 
                                                CLEARED.)
          (CLBUFS NIL T READBUF]
    (PRIN1 MESS T])

(DWIMREADC
  [LAMBDA (WAIT DEFAULT MESS CHARLST)

          (* reads one character, interprets it if Y N or ^, and returns the character 
          as its value.)


    (PROG (X TEM)
          (DOBE)
          (COND
	    ((READP T)
	      (PRIN1 BELLS T)

          (* There are two problems with DWIM teletype inteactions.
          The first is we have know way of knowing when the user typed something 
          without doing a DOBE, which causes a noticeable snag in teletype output.
          The second is that we would like the user to be able to answer a question 
          without having to WAIT for the entire message to be printed.
          The current algorithm is as follows: the user is not permitted to answer the 
          question until he has seen everything printed before the call to DWIMREADC.
          Anything typed before the beginning of the message, i.e. before the call to 
          DWIMESS, is saved and restored. Anything typed between then and the call to 
          DWIMREADC is discarded, since we do not know if it is type-ahead, or a 
          response to an anticipated question. However, in an attempt to minimize the 
          amount of type-ahead that is discarded, if the user is typing at the time of 
          the call to DWIMREADC, he is warned by several bells that an interaction is 
          coming, a DOBE performed to make sure he sees the warning, and only then are 
          his buffers cleared.)


	      (DOBE)
	      (CLEARBUF T)))
          (AND MESS (PRIN1 MESS T))
          (COND
	    ((NULL WAIT)
	      (GO READ)))
          (SETQ WAIT (ITIMES 2 WAIT))                       (* WAIT is in seconds.)
      WAITLOOP
          (DISMISS 500)
          (COND
	    ((READP T)
	      (GO READ))
	    ((IGREATERP (SETQ WAIT (SUB1 WAIT))
			0)
	      (GO WAITLOOP))
	    (T                                              (* Assume DEFAULT if nothing typed 
                                                            in WAIT/2 seconds.)
	       (PRIN1 (QUOTE ...)
		      T)
	       (PRIN1 (SETQ X DEFAULT)
		      T)
	       (GO INTERP)))
      READ(SETQ X (RESETFORM (SETTERMTABLE DWIMTTBL)
			     (READC T)))

          (* DWIMTTBL has (CONTROL T) and (RAISE T) performed.
          The latter means that if the user types lower case characters, they are 
          converted to uppercase. Note however that DWIMREADC will recognize lower 
          case y and n. This is so the caller can provide y or n as a default, and 
          distinguish the default cse from the case where the user types lowercase y 
          or n (which will be converted to uppercase automatically by the terminal 
          table))


      INTERP
          [COND
	    ((SETQ TEM (FASSOC X CHARLST))
	      (PRIN1 (CDR TEM)
		     T)
	      (TERPRI T))
	    (T (SELECTQ X
			(T (PRINT (QUOTE rue)
				  T)
			   (SETQQ X Y))
			(O (PRINT (QUOTE K)
				  T)
			   (SETQQ X Y))
			((Y y)
			  (PRINT (QUOTE es)
				 T))
			((N n)
			  (PRINT (QUOTE o)
				 T))
			(^(TERPRI T)
			  (RETEVAL (EVQ FAULTPOS)
				   (QUOTE (ERROR!))
				   T))
			((%  %
)                                                           (* User typed this just to tell 
                                                            DWIMREADC not to DEFAULT.)
			  (GO READ))
			(PROGN (PRIN1 (QUOTE " ?  
please type y or n -- ")
				      T)
			       (DOBE)
			       (CLEARBUF T)
			       (GO READ]
          (BKBUFS DWIMBUFS)
          (RETURN X])

(MOVETOP
  [LAMBDA (X L)
    (PROG ((Y L)
           Z)
      LP  (COND
            ((NULL Y)
              (RETURN L))
            ((NEQ (CAR Y)
                  X)
              (SETQ Z Y)
              (SETQ Y (CDR Y))
              (GO LP))
            ((NEQ Y L)                          (* Move to front of list)
              (FRPLACD Z (CDR Y))
              (FRPLACD Y (CDR L))
              (FRPLACD L Y)
              (FRPLACA Y (CAR L))
              (FRPLACA L X)))
          (RETURN L])

(CHOOZ
  [LAMBDA (XWORD REL SPLST TAIL FN TIEFLG NDBLS CLST)
    [COND
      ((NLISTP XWORD)                           (* When called from FIXSPELL, 
                                                XWORD is already a CHCON lst.)
	(SETQ XWORD (CHCON XWORD]
    (PROG ((NCXWORD0 (FLENGTH XWORD))
	   NCXWORD NCTWORD TEM SC VAL)
          [AND (NULL NDBLS)
	       (SETQ NDBLS 0)
	       (MAPC XWORD (FUNCTION (LAMBDA (X)
			 (COND
			   ((EQ X TEM)
			     (SETQ NDBLS (ADD1 NDBLS)))
			   (T (SETQ TEM X]      (* Counts number of 
                                                (possibly) doubled characters)
      LP  (COND
	    ((NULL (CAR SPLST))                 (* Marker.)
	      (GO LP1)))
          (SETQ NCTWORD (NCHARS (CAR SPLST)))
          (SETQ NCXWORD NCXWORD0)
          [COND
	    ((COND
		((IGREATERP NCTWORD NCXWORD)

          (* Checks to see if test word and unknown word differ 
          sufficiently in number of characters so as to make it 
          unnecessary to even call SKOR. This case is where test word 
          is longer than XWORD. If number of characters in XWORD, NCW, 
          divided by number of characters in test word, NCT, is less 
          than REL than don't bother to call SKOR.
          0 P)


		  (ILESSP (IQUOTIENT (ITIMES NCXWORD 100)
				     NCTWORD)
			  REL))
		((AND (NULL TAIL)
		      (ILESSP (IQUOTIENT (ITIMES NCTWORD 100)
					 (IDIFFERENCE NCXWORD NDBLS))
			      REL))

          (* XWORD longer than test word.
          However, must allow for possibility of doubled characters.)


		  ))
	      (GO LP1))
	    ([AND (SETQ SC (SKOR XWORD (SETQ TEM (DCHCON (CAR SPLST)
							 SKORLST2))
				 NCXWORD NCTWORD CLST))
		  (OR (NULL FN)
		      (COND
			((EQ FN (QUOTE GETD))
			  (FGETD (CAR SPLST)))
			(T (APPLY* FN (CAR SPLST]
	      (COND
		[(LISTP SC)
		  (AND RUNONFLG TAIL [OR (NULL VAL)
					 (IGREATERP NCTWORD
						    (NCHARS (CAAR VAL]
		       (SETQ VAL (LIST (CONS (CAR SPLST)
					     (PACKC SC]
		((ZEROP SC)
		  (SETQ VAL (CAR SPLST))
		  (GO OUT))
		[(IGREATERP (SETQ SC (IQUOTIENT (ITIMES 100
							(IDIFFERENCE
							  (SETQ TEM
							    (IPLUS NCXWORD 
								   NCTWORD))
							  (ITIMES SC 2)))
						TEM))
			    REL)

          (* The arithmetic expression computes the relative closeness 
          as a percentage (times 100) by dividing the difference 
          between the average number of characters and the number of 
          mistakes, over the average number of characters.
          This is (((a+b) /2) -
          sc) / (a+b) /2 Multiplying top and bottom by two gives 
          (A+B-2*SC/A+B))


		  (SETQ REL SC)                 (* Now only look for words 
                                                CLOSER than SC.)
		  (SETQ VAL (LIST (CAR SPLST]
		((EQ SC REL)
		  (SETQ VAL (CONS (CAR SPLST)
				  VAL]
      LP1 (COND
	    ((SETQ SPLST (CDR SPLST))
	      (GO LP)))
          [SETQ VAL (COND
	      ((EQ TIEFLG (QUOTE ALL))
		VAL)
	      ((AND (CDR VAL)
		    (NULL TIEFLG))              (* More than one.)
		NIL)
	      (T (CAR VAL]
      OUT (RETURN VAL])

(SKOR0
  [LAMBDA (X NCXWORD NDBLS L)

          (* A special call to SKOR for use by editor.
          L is an exploded chconlst of characteers, NCXWORD the number 
          of characters in L, NDBLS the number of doubled characters.
          SKOR0 compares X with L, and returns T if 'close'.)


    (PROG ((NCTWORD (NCHARS X))
           SC TEM TAIL)
          (RETURN (AND (COND
                         ((IGREATERP NCTWORD NCXWORD)
                           (NOT (ILESSP (IQUOTIENT (ITIMES NCXWORD 100)
                                                   NCTWORD)
                                        70)))
                         (T (IGREATERP (IQUOTIENT (ITIMES NCTWORD 100)
                                                  (IDIFFERENCE NCXWORD NDBLS))
                                       70)))
                       (NUMBERP (SETQ SC (SKOR L (DCHCON X SKORLST2)
                                               NCXWORD NCTWORD)))
                       (OR (ZEROP SC)
                           (IGREATERP (IQUOTIENT
                                        (ITIMES (IDIFFERENCE (SETQ TEM
                                                               (COND
                                                                 ((IGREATERP
                                                                     NCXWORD 
                                                                    NCTWORD)
                                                                   NCXWORD)
                                                                 (T NCTWORD)))
                                                             SC)
                                                100)
                                        TEM)
                                      70])

(SKOR
  [LAMBDA (XWORD TWORD NCX NCT FLG)

          (* This algorithm counts the number of mistakes in the 
          testword vis a vis the known word.
          A mistake is a character in the known word that does not 
          have a corresponding character in the test word, or vice 
          versa. Mistakes are not counted until the end of the 
          scoring, so that transpositions are not counted as mistakes.
          Instead, whenever an unexplained character is encountered, 
          the tail is put in a buffer for the corresponding word.
          (For reasons of efficiency, instead of a genuine buffer, two 
          PROG variables are used for each word: T1, T2, X1, and X2.
          Whenever these 'buffers' are exceeded, the skoring is 
          aborted and NIL is returned as the value of SKOR.) When a 
          character is found that does not match, it is first compared 
          with the buffer for the other word.
          If it is there, it is not counted as a mistake but as out of 
          order. Out of order characters are counted as mistakes if 
          they are misplaced by more than two positions, or if there 
          are any other mistakes, e.g. substitutions or missing 
          letters. Also, double letters are not counted as mistakes, 
          nor are shift mistakes, e.g. @RINT vs PRINT gives a value of 
          0)


    (PROG (X1 X2 T1 T2 X-1 XC TC (N 0)
	      (NTRANS 0))
      LP  (SETQ XC (CAR XWORD))
          (SETQ TC (CAR TWORD))
          (COND
	    [(NULL XWORD)
	      (COND
		((NULL TWORD)
		  (GO OUT))
		(T (GO LP2]
	    ((NULL TWORD)
	      (GO LP1))
	    ((OR (EQ XC TC)
		 (AND (OR (EQ XC (IPLUS TC 16))
			  (EQ XC (IPLUS TC -16)))
		      (SELECTQ TC
			       [(33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 
				    64 75 76 77 78 79)

          (* (! %" # $ %% & ' %( %) * + , -
          %. / @ K L M N O) to their respective shift characters The 
          last six transformations only operate on model 33's.)


				 (AND (EQ XC (IPLUS TC 16))
				      (OR MODEL33FLG (ILESSP TC 50]
			       [(49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 
				    80 91 92 93 94 95)

          (* (1 2 3 4 5 6 7 8 9 : ; < = > ? P %[ \ %] ^ _) to their 
          respective shift characters)


				 (AND (EQ XC (IPLUS TC -16))
				      (OR MODEL33FLG (ILESSP TC 65]
			       NIL))
		 [AND (NULL MODEL33FLG)
		      (OR (AND (EQ XC 48)
			       (EQ TC 95))
			  (AND (EQ XC 95)
			       (EQ XC 48]
		 (AND (EQ XC (IPLUS TC 32))
		      (IGREATERP XC 96))
		 (AND (EQ TC (IPLUS XC 32))
		      (IGREATERP TC 96))
		 (AND (EQ TC 49)
		      (EQ XC 76)))

          (* The 48-95 check is for 0 to _ The 32 check is for 
          upper-lower case substitutions.
          The 49-76 check is typing L instead of 1, i.e. misreading 
          the LISP manual.)


	      (SETQ XWORD (CDR XWORD))
	      (SUB1VAR NCX)
	      (SETQ TWORD (CDR TWORD))
	      (SUB1VAR NCT)
	      (SETQ X-1 XC)
	      (GO LP)))
      LP1 (COND
	    ((EQ XC (CAR T2))

          (* Character encountered in TWORD before XWORD, e.g. the P 
          in IPRNT vs PRINT. The case of RPINT vs PRINT is handled 
          specially without ever going to the buffers.)


	      (COND
		((IGREATERP (FLENGTH T2)
			    (IPLUS NCX 2))
		  (ADD1VAR N))
		(T (ADD1VAR NTRANS)))
	      (SETQ T2 NIL)
	      (SETQ XWORD (CDR XWORD))
	      (SUB1VAR NCX)
	      (SETQ X-1 XC)
	      (GO LP))
	    ((EQ XC (CAR T1))
	      (COND
		((IGREATERP (FLENGTH T1)
			    (IPLUS NCX 2))
		  (ADD1VAR N))
		(T (ADD1VAR NTRANS)))
	      (COND
		(T2 (SETQ T1 T2)
		    (SETQ T2 NIL))
		(T (SETQ T1 NIL)))
	      (SETQ XWORD (CDR XWORD))
	      (SUB1VAR NCX)
	      (SETQ X-1 XC)
	      (GO LP))
	    ((NULL TWORD)
	      (GO LP3)))
      LP2 (COND
	    ((EQ TC (CAR X2))
	      (COND
		((IGREATERP (FLENGTH X2)
			    (IPLUS NCT 2))
		  (ADD1VAR N))
		(T (ADD1VAR NTRANS)))           (* Character encountered in 
                                                XWORD first, e.g. I in IPRNT vs 
                                                PRINT.)
	      (SETQ X2 NIL)
	      (SETQ TWORD (CDR TWORD))
	      (SUB1VAR NCT)
	      (GO LP))
	    ((EQ TC (CAR X1))
	      (COND
		((IGREATERP (FLENGTH X1)
			    (IPLUS NCT 2))
		  (ADD1VAR N))
		(T (ADD1VAR NTRANS)))
	      (COND
		(X2 (SETQ X1 X2)
		    (SETQ X2 NIL))
		(T (SETQ X1 NIL)))
	      (SETQ TWORD (CDR TWORD))
	      (SUB1VAR NCT)
	      (GO LP))
	    ((AND XWORD (EQ XC (CADR TWORD))
		  (EQ TC (CADR XWORD))
		  (NEQ TC (CADDR TWORD)))

          (* Special check for most common case of transposition.
          The last clause is an attempt to distinguish the case of a 
          transposition from simply getting out of synch.
          e.g. consider MYCIN vs MICIN. The Y is discarded, and then 
          we are comparing CIN with ICIN.
          Treating CI as a transposition of IC is wrong in this case, 
          since it matches with CI if the I is discarded.)


	      (SETQ X-1 (CADR XWORD))
	      (SETQ XWORD (CDDR XWORD))
	      (SUB1VAR NCX)
	      (SUB1VAR NCX)
	      (ADD1VAR NTRANS)
	      (SETQ TWORD (CDDR TWORD))
	      (SUB1VAR NCT)
	      (SUB1VAR NCT)
	      (GO LP))
	    ((OR (EQ (CADR TWORD)
		     XC)
		 (IGREATERP NCT NCX))

          (* Remove from TWORD. Normally we remove characters from the 
          longer list. However, in order to enable runon corrections 
          like (BRKEAFOO) to work, we look ahead one character in 
          TWORD.)


	      (COND
		((NULL T1)
		  (SETQ T1 TWORD))
		((NULL T2)
		  (SETQ T2 TWORD))
		(T (RETURN NIL)))
	      (SETQ TWORD (CDR TWORD))
	      (SUB1VAR NCT)
	      (GO LP)))
      LP3 (COND
	    ((OR (EQ XC X-1)
		 (EQ XC (CADR XWORD)))

          (* About to remove from XWORD, check for double char.
          first check says was equal to last character.
          This occurs when last character was correct.
          Second check says equal to next character, so throw this one 
          away.)


	      (SETQ XWORD (CDR XWORD))
	      (SETQ NCXWORD (SUB1 NCXWORD))

          (* Bound in CHOOZ. When computing value of SKOR, want to 
          divide number of mistakes by actual length of word, i.e. 
          length minus number of doubled characters.
          Otherwise, making a word longer by adding extra characters 
          will make it CLOSER, e.g. ZZZZZZZ would correct to PP.)


	      (SUB1VAR NCX))
	    [[AND TAIL (NULL TWORD)
		  (NULL T1)
		  (NULL T2)
		  (NULL X1)
		  (NULL X2)
		  (ZEROP N)
		  (OR (ILESSP (ITIMES NTRANS 4)
			      NCTWORD)
		      (NULL (CDR XWORD]

          (* The ilessp check is to discourage runon corrections when 
          there is also a transposition unless the word is long, e.g. 
          PRETTYRPINTX will correct, but CNOSX wont.)


	      (RETURN (COND
			((AND FLG CLISPFLG (FMEMB (FCHARACTER (CAR XWORD))
						  CLISPCHARS))

          (* so that it does not consider runoncorrection splitting it 
          at a clisp operator. E.g. if X*Y appears in your functio and 
          X is the name of a variable but Y is not, when dwim goes on 
          to look for another corrrection because Y is not bound, it 
          shuld not offer X *Y as a possibility as this is almost 
          always wrong.)


			  NIL)
			([AND FLG CLISPFLG (EQ (CAR XWORD)
					       (COND
						 (MODEL33FLG 79)
						 (T 

          (* On non-33's, 0 is on the same key as _, and its code is 
          48.0)


						    48]
			  (CONS 95 (CDR XWORD)))
			(T XWORD]
	    (T (COND
		 ((NULL X1)
		   (SETQ X1 XWORD))
		 ((NULL X2)
		   (SETQ X2 XWORD))
		 (T (RETURN NIL)))
	       (SETQ XWORD (CDR XWORD))
	       (SUB1VAR NCX)
	       (SETQ X-1 XC)))
          (GO LP)
      OUT [COND
	    ((AND (NULL XWORD)
		  (NULL TWORD)
		  T1 X1)
	      (SETQ T1 (FLENGTH T1))
	      (SETQ X1 (FLENGTH X1))
	      (AND T2 (SETQ T2 (FLENGTH T2)))
	      (AND X2 (SETQ X2 (FLENGTH X2)))
	      (COND
		((OR (EQ T1 X1)
		     (EQ T1 X2))

          (* Check for substitution errors.
          Subtracts one so when two gets added below, net effect is 
          only counted as one.)


		  (SUB1VAR N)))
	      (COND
		((AND T2 (OR (EQ T2 X1)
			     (EQ T2 X2)))
		  (SUB1VAR N]
          [SETQ N (IPLUS N (COND
			   (X2 2)
			   (X1 1)
			   (T 0))
			 (COND
			   (T2 2)
			   (T1 1)
			   (T 0]
          (RETURN (COND
		    ((OR (EQ N 0)
			 FASTYPEFLG)

          (* If FASTYPEFLG is T, transpositions are not counted as 
          errors. Otherwise, transpositions are counted if there are 
          other errors, i.e. if thee are no errors except for 
          transpostions, SKOR returns 0.0)


		      N)
		    (T (IPLUS N NTRANS])
)
  (RPAQ USERWORDS)
  (RPAQQ SPELLINGS1
	 (DEFINEQ ARGLIST MOVD GETD FNTYP BREAK UNBREAK REBREAK TRACE BREAKIN MAKEFILE 
		  MAKEFILES LISTFILES FILES? WHEREIS CLEANUP PRETTYDEF PRETTYPRINT PP EDITF 
		  EDITV EDITP ADVISE UNADVISE UNSAVEDEF RECOMPILE TCOMPL COMPILE BRECOMPILE 
		  BCOMPL BLOCKCOMPILE MAPCAR MAPC LOAD TIME CLOSEF CLOSEALL OPENP OUTPUT INPUT 
		  OUTFILE INFILE LOGOUT PUT REMPROP GETP SYSIN SYSOUT SUBSYS CLISPIFY DWIMIFY 
		  FOR WHILE THEREIS DO NIL))
  (RPAQQ SPELLINGS2
	 (ADD1 AND APPEND ASSOC ATOM COND CONS COPY ELT EQ EQUAL ERROR ERSETQ EVAL FASSOC FMEMB 
	       FRPLACA FRPLACD FUNCTION GO IDIFFERENCE IGREATERP ILESSP IMINUS IPLUS ITIMES 
	       LENGTH LIST LISTP MAPC MAPCAR MAPCONC MEMB MEMBER NCONC NCONC1 NEQ NLISTP NLSETQ 
	       NULL NUMBERP OR PRINT PRIN1 PROG PROGN PUT QUOTE READ RETURN RPLACA RPLACD 
	       SELECTQ SETA SETQ SPACES SUB1 TCONC TERPRI ZEROP /RPLACA /RPLACD IF F/L VALUEOF 
	       FOR WHILE THEREIS DO FETCH REPLACE CREATE RECORD NIL))
  (RPAQQ SPELLINGS3
	 (NIL EDITMACROS BREAKMACROS BROKENFNS ADVISEDFNS PRETTYFLG SYSPROPS DWIMFLG CLISPFLG 
	      LASTWORD USERWORDS NOTLISTEDFILES FILELST NOTCOMPILEDFILES LISPXPRINTFLG 
	      PROMPT#FLG TREATASCLISPFLG VARDEFAULT CLISPIFYPRETTYFLG DWIMIFYCOMPFLG FILERDTBL 
	      EDITRDTBL))
  [RPAQQ DWIMODELST ((C CAUTIOUS (APPROVEFLG . T))
	  (T TRUSTING (APPROVEFLG]
  (RPAQ FASTYPEFLG)
  (RPAQ RUNONFLG T)
  (RPAQ TREATASCLISPFLG)
  (RPAQQ #USERWORDS 100)
  (RPAQQ #SPELLINGS1 30)
  (RPAQQ #SPELLINGS2 50)
  (RPAQQ #SPELLINGS3 30)
  (RPAQ DWIMWAIT 10)
  (RPAQ RESPELLS)
  (RPAQ LCASEFLG T)
  (RPAQ MODEL33FLG)
  (RPAQ DWIMTTBL (COPYTERMTABLE))
  (SAVEDEF (QUOTE QUOTE))
  (MOVD (QUOTE NEWQUOTE)
	(QUOTE QUOTE))
  (RAISE T DWIMTTBL)
  (CONTROL T DWIMTTBL)
(DEFLIST(QUOTE(
  (DWIM (DWIM WTFIX CLISP DWIMIFY))
))(QUOTE FILEGROUP))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY 
  (MINFS 25000 18)
  (RECLAIM 18)
  (MINFS 40000 8)
  (MINFS 3000 12)
  (MINFS 3000 28)
  (RELINK (QUOTE WORLD))

(DEFLIST(QUOTE(
  (* (X (QUOTE INSTRUCTIONS)))
))(QUOTE MACRO))

  (RPAQ COMMENTCNT 0)
]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA NEWQUOTE)
  (ADDTOVAR NLAML)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (2527 45313 (DWIM 2539 . 3001) (NEWQUOTE 3005 . 3596) (NEWFAULT1 3600 . 6090)
(ADDSPELL 6094 . 8781) (ADDSPELL1 8785 . 13506) (MISSPELLED? 13510 . 14192) (FIXSPELL 14196
. 19983) (FIXSPELL1 19987 . 26342) (FIXSPELL2 26346 . 26613) (DWIMESS 26617 . 27263) (DWIMREADC
27267 . 30828) (MOVETOP 30832 . 31351) (CHOOZ 31355 . 34539) (SKOR0 34543 . 36341) (SKOR 36345
. 45310)))))
STOP
