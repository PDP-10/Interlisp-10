;<LEWIS>GC.MAC;3     1-OCT-74 04:58:28    EDIT BY LEWIS
; MOVED ASSED, INUSE, AND MAKESYS BECAUSE THEY WERE PAST 20000
;<NEWLISP>GC.MAC;12     8-SEP-74 20:20:58    EDIT BY LEWIS
; FIX THE FIX TO MOVPGJ
;<NEWLISP>GC.MAC;11     7-SEP-74 19:31:46    EDIT BY LEWIS
; FIX UCKMRK TO SAVE AND RESTORE AC3
;<HARTLEY>GC.MAC;2    18-AUG-74 04:49:16    EDIT BY HARTLEY
;<NEWLISP>GC.MAC;9     2-AUG-74 01:24:28    EDIT BY LEWIS
; FIX PAGE MOVER SO OLD IS NOT DELETED TILL AFTER THE MOVE
;<NEWLISP>GC.MAC;7    17-JUL-74 08:45:22    EDIT BY LEWIS
; FIXED BUG IN SWEEPING PRIVATE LITS FROM SWAP.SYS FNS.
;<NEWLISP>GC.MAC;6    11-JUL-74 20:43:41    EDIT BY LEWIS
; MOVED INUSE AND ASSED SO THAT THEY ARE LESS THAN 20000
;<NEWLISP>GC.MAC;5     6-JUL-74 18:57:42    EDIT BY LEWIS
; FIXED SFRKB
;<FLIP>GC.MAC;1     1-JUL-74 20:37:52    EDIT BY LEWIS
; FIXED CALLS TO INTRS TO INCLUDE "STRING READING" AND EVATAB
;<LEWIS>GC.MAC;1     6-JUN-74 04:18:23    EDIT BY LEWIS
; ADDED STRING INPUT
;<GOODWIN>GC.MAC;29    30-APR-74 05:04:30	EDIT BY GOODWIN
; - INSTALL SWAPPER.
;<LEWIS>GC.MAC;1     9-APR-74 23:34:09	EDIT BY LEWIS
;<HARTLEY>GC.MAC;7    25-FEB-74 19:21:43	EDIT BY HARTLEY
;<HARTLEY>GC.MAC;5    19-FEB-74 20:47:22	EDIT BY HARTLEY
;<FLIP>GC.MAC;1    17-FEB-74 02:59:21	EDIT BY LEWIS


;26 JAN 74, 1742:
; GARBAGE COLLECTOR


U BTT,NPM	; BIT	TABLE TABLE
		; CONTAINS PTR TO BIT TABLE FOR EACH PAGE THAT NEEDS ONE

GP=CP		; USE	CP FOR	GC PDP
SYSBIT==100		;BIT IN TYPTAB ENTRY DENOTING SHARED DATA
PVTBIT==200		;TYPTAB BIT FOR ONCE SHARED, BECOME PRIVATE
FIXBIT==400		;TYPTAB BIT FOR NOT MOVABLE
RPGBIT==1		;BIT IN LEFT BTT FOR PAGE MOVING TO

U GCTYP		; TYPE BEING COLLECTED
U BGNPAG	;FIRST DATA PAGE:BGNCOR/NPS;LEFT IS -# PAGES
U NFRECH	;NUMBER OF FREE STRING CHARACTERS
U IGP		;INITIAL GP
U GCAC2,13	;SAVED AC'S 2-14
U XMINAR	;TEMP LOC OF REAL MINARR
U CMPTYP	;TYPE COMPACTING, 0 IF NONE
U CMPFN		;FN TO CHANGE POINTER FOR COMPACTING TYPE
U INIFN		;FN TO INITIALIZE NEW PAGES FOR COMPACTING TYPE
U FRSTNP	;FIRST NEW PAGE OF A GROUP
U NNP		;NUMBEROF NEW PAGES IN GROUP
U SYSCHK	;FLAG NON ZERO IF CONSISTENCY OF PAGE ACCESS BITS
		;... NEEDS CHECKING

;DATA TYPE TABLES ETC.

MTYPN==77		;MAX TYPE NUMBER
NTYPN==100		;NUMBER OF TYPE NUMBERS
MSYST==36		;MAX. DATA TYPE USED BY SYSTEM (STRINGS)

U TYPBLK,NTYPN		;TABLE OF POINTERS TO TYPE INFO FOR EACH TYPE
			;...LATER MAY ALSO CONTAIN TYPE NAME

;RELATIVE LOCATIONS OF INFO IN TABLES

TSIZ==0			;ENTRY SIZE IN LEFT
TBITS==0		;DESCRIPTION BITS IN RIGHT
TCHAS==1		;CALL TO CHASE ROUTINE
TUDE==2			;ROUTINE TO UPDATE POINTERS IN FIXED LENGTH
			;...ENTRY
TSWP==2			;ROUTINE TO UPDATE POINTERS IN WHOLE REGION
			;...OF CONTIGIOUS TYPE
TINI==3			;ROUTINE TO INITIALIZE A PAGE
TCKM==TINI+1		;ROUTINE TO CHECK IF MARKED
TMIN==TCKM+1		;MINFS FOR TYPE
TNPG=TMIN+1		;INITIAL NNUMBER OF PAGES ALLOCATED
TFRE==TNPG+1		;FREE POINTER
TNFR==TFRE+1		;NUMBER WORDS(OR ENTRIES) FREE
TNWD==TNFR+1		;NUMBER WORDS(OR ENTRIES ) USED
 NTWN==TNWD+1		;# WORDS OF INFO FOR NORMAL TYPES
TPLN==TNWD+1		;ROUTINE TO PLAN FOR CONTIGUOUS TYPE
TCHG==TPLN+1		;ROUTINE TO CHANGE POINTER TO CONT. TYPE
TMOV==TCHG+1		;ROUTINE TO COMPACT DATA
TBGN==TMOV+1		;ADDR. OF BEGINNING OG REGION
TEND==TBGN+1		;ADDR. OF END OF REGION
TNEXT==TEND+1		;POINTER TO NEXT INFO BLOCK, 0 IF NONE
 NTWC==TNEXT+1		;# WORD OF INFO FOR VAR. LENGTH TYPES

BGEN==1			; BIT IN BITS FOR GENERAL TYPE (E.G. ARRAY)
BCONT==2		; BIT IN BITS FOR CONTIGUOUS TYPE

;MORE DATA TYPE TABLES

U USEBLK,<<MTYPN-MSYST-1>*NTWN>	;HOLDS TYPBLKS FOR USER DATA TYPES
U TYPSIZ,NTYPN			;HOLDS SIZE INFO FOR USER DATA TYPES
U EVATAB,NTYPN	;TABLE OF FNS TO BE CALLED TO EVAL EACH TYPE.
		;-1 IF TYPE CANNOT BE CHANGED.

;ACCESS MACROS

	DEFINE GTB (RA,TA)
<	BB=0
	IFG TA,<
	IFL TA-20,<
	BB=-1
	HRRZ RA,TYPBLK(TA)>>

	IFE BB,<
	HRRZ RA,TA
	HRRZ RA,TYPBLK(RA)>>

	DEFINE MINFS (RA, TA)
	<GTB RA,TA
	HRRZ RA,TMIN(RA)>

	DEFINE NFRE (RA,TA)
	<GTB RA,TA
	HRRZ RA,TNFR(RA)>


;TABLES USED TO INITIALIZE TYPBLK INFO

NI1==7		;# OF PARAMS IN INITIALIZATION TABLES FOR NORMAL TYPES
NI2==3		;ADDITIONAL # OF PARAMS FOR CONTIGUOUS TYPES

TARR:	BCONT+BGEN
	PUSHJ GP,CHASAR
	PUSHJ GP,SWPARR
	PUSHJ GP,CLRPG
	PUSHJ GP,CKARR
	2000			;MINFS
	NAR
	PUSHJ GP,PLANAR
	PUSHJ GP,CHGARR
	PUSHJ GP,MOVARR

TLIST:	XWD 1,0
	PUSHJ GP,CHASLS
	PUSHJ GP,UDLIST
	JFCL
	PUSHJ GP,CKBIT
	2000
	NLW

TFIX:	XWD 1,0
	PUSHJ GP,CHASFX
	JFCL R
	JFCL
	PUSHJ GP,CKBIT
	1000
	NNM

TFLT:	XWD 1,0
	PUSHJ GP,CHASFL
	JFCL R
	JFCL
	PUSHJ GP,CKBIT
	1000
	NFN

TATM:	XWD 3,0
	PUSHJ GP,CHASAT
	PUSHJ GP,UDATM
	JFCL
	PUSHJ GP,CKAT
	2000
	NAT

TPNAM:	BCONT
	PUSHJ GP,MARKPN
	JFCL R
	PUSHJ GP,CLRPG
	PUSHJ GP,CKPN
	1000
	NPN
	PUSHJ GP,PLANPN
	PUSHJ GP,CHGPN
	PUSHJ GP,MOVPN

TSTR:	BCONT
	PUSHJ GP,MARKST
	JFCL R
	PUSHJ GP,CLRPG
	PUSHJ GP,CKPN
	1000
	NST
	PUSHJ GP,PLNSTR
	PUSHJ GP,CHGPN
	PUSHJ GP,MOVSTR

TSTPT:	XWD 1,0
	PUSHJ GP,CHASSP
	PUSHJ GP,UDSTPT
	JFCL
	PUSHJ GP,CKBIT
	1000
	NSP

THANDL:	XWD 1,0
	PUSHJ CP,CHASHD		;CHASE
	JFCL R		;UPDATE HANDLE
	JFCL
	PUSHJ GP,CKBIT
	1000
	NHDL
	HDLCHS==000400		;BIT IN LEFT HANDLE MEANING CHAS DONE

U TUSER,NI1			;WANT FOLLOWING TO BE REMOTE
				;... CAUSE THE SIZE MUST BE SET
FOO1:
	LOC	TUSER
	XWD	0,0
	PUSHJ	GP,UCHAS
	PUSHJ	GP,UDUSER
	JFCL
	PUSHJ	GP,UCKMRK
	1000
	1
	RELOC	FOO1

DEFINE IARRAY
	<TI=TARR
	ILOC=ARRBLK
	U ARRBLK,NTWC
	ENDAR=ARRBLK+TEND
	FREEAR=ARRBLK+TFRE
	MINARR=ARRBLK+TMIN
	NARRW=ARRBLK+TNWD
>

DEFINE ILIST
	<TI=TLIST
	ILOC=LSTBLK
	U LSTBLK,NTWN
	FRECNT=LSTBLK+TNFR
	MINLW=LSTBLK+TMIN
	NLISTW=LSTBLK+TNWD
>
DEFINE IFIX
	<TI=TFIX
	ILOC=FIXBLK
	U FIXBLK,NTWN
	FREENM=FIXBLK+TFRE
>
DEFINE IFLOAT
	<TI=TFLT
	ILOC=FLTBLK
	U FLTBLK,NTWN
	FREEFL=FLTBLK+TFRE
>
DEFINE IATOM
	<TI=TATM
	ILOC=ATMBLK
	U ATMBLK,NTWN
	FREEAT=ATMBLK+TFRE
	NATM=ATMBLK+TNWD
>

DEFINE IHANDL
	<TI=THANDL
	ILOC=HDLBLK
	U HDLBLK,NTWN
	FREHDL=HDLBLK+TFRE
	NHDLW=HDLBLK+TNWD
>

DEFINE IPNAM
	<TI=TPNAM
	ILOC=PNBLK
	U PNBLK,NTWC
	BGNPN=PNBLK+TBGN
	ENDPN=PNBLK+TEND
	FREEPN=PNBLK+TFRE
>
DEFINE ISTRNG
	<TI=TSTR
	ILOC=STRBLK
	U STRBLK,NTWC
	BGNSTR=STRBLK+TBGN
	ENDSTR=STRBLK+TEND
	FREESTR=STRBLK+TFRE
>
DEFINE ISTPT
	<TI=TSTPT
	ILOC=STPBLK
	U STPBLK,NTWN
	FREESP=STPBLK+TFRE
	NSTPTW=STPBLK+TNWD
>


DEFINE TYPSET (TYP)
<	I'TYP
	MOVE 2,TYP'T
	MOVEI 7,ILOC
	MOVEM 7,TYPBLK(2)
	MOVEI 10,TI
	PUSHJ GP,GCTBS
>
;TYPBLK SETUP ROUTINE
;ENTER 2 TYPE, 6 # PAGES, 7 LOC. TYPBLK, 10 LOC. OF INIT. VALUES

GCTBS:	MOVEI 5,0(7)
	HRLI 5,0(10)
	BLT 5,NI1-1(7)		;MOVE FIRST STUFF INTO BLOCK
	SETZM TFRE(7)		;CLEAR SOME MORE
	SETZM TNFR(7)
	SETZM TNWD(7)
	HRRZ 6,TNPG(7)
	MOVE 1,TBITS(7)
	TRNN 1,BCONT
	JRST GETFPG		;NORMAL TYPE, GET PAGES
	MOVEI 5,TPLN(7)
	HRLI 5,NI1(10)
	BLT 5,TPLN+NI2-1(7)
	SETZM TNEXT(7)
GCTBC:	MOVEI 10,0(2)		;GET PAGES FOR CONTIGUOUS TYPE
	MOVEI 5,0(6)		;# PAGES
	PUSHJ GP,MTPGSX		;FIND CONTIG. PAGES
	 JRST GCTBE		;NOT ENUF
	MOVNI 6,0(6)		;PAGE IS IN 4, # PAGES IN 6
	HRLI 4,0(6)
	MOVEI 3,0(4)
	MOVEM 10,TYPTAB(4)	;SET TYPTAB FOR PAGES
	AOBJN 4,.-1
	LSH 4,LPS
	MOVEM 4,TEND(7)
	LSH 3,LPS
	MOVEM 3,TBGN(7)
	MOVEM 3,TFRE(7)
	POPJ GP,

GCTBE:	TMSG GCEM3
	HALTF

GCEM3:	SIXBIT @STORAGE FULL/@


STPTGC:	MOVEM 1,GCSTPT		;SAVE STRINGPOINTER
	MOVE 1,STPTT
	CALL GC1
STGCA:	MOVE 1,GCSTPT
	RET

STRGC:	MOVEM 1,GCSTPT
	MOVE 1,STRNGT
	CALL GC1
	SOS 1,FREEST		;FREE IS OFF BY ONE- FUDGE
	MOVNI 1,1(1)
	ADD 1,ENDSTR
	IMULI 1,5
	MOVEM 1,NFRECH		;NO. FREE CHARACTERS
	CALL DOINTN		;NOW SEE IF INTERRUPT REQUESTED
	CALL	RESWAP		;Restore swapping buffer.
	JRST STGCA
U GCSTPT
U GCCP


CONSGC:	MOVEI 1,MINWPP
	MOVEM 1,CMINWP		;RESET MINWPP
	MOVE 1,LISTT
	TLZ F,CNSFLG
	JRST GC1

INTGC:	MOVE 1,FIXT
	JRST GC1

ARRGC:	EXCH 1,MINARR		;1 HAS NUMBER WORDS NEEDED
	MOVEM 1,XMINAR		;SAVE OLD MINARR
	CAML 1,MINARR
	MOVEM 1,MINARR		;GET MAX OF ARG AND ORIG. MINARR
	MOVE 1,ARRAYT
	JRST GC1

ATOMGC:	MOVE 1,ATOMT
GC1:	SETZM GINTD		;WILL BE SET IF INTERRUPT OCCURS
	TRO F,GCFLG		;NOTE GC NOW IN PROGRESS
	MOVEM	1,GCTYP
	SETZM FORKH		;NOTE NO FORK CREATED YET
	HRRZM CP,GCCP		;SAVE CP AT ENTRY FOR PDLTRP
	MOVE 1,[XWD 2,GCAC2]	;SAVE AC'S 2-13. SEE GCX1.
	BLT 1,GCAC2+11
	PUSH	PP,BR		;BR SAVED ON PP LEST HANDLES MOVE
	GETJRT			;GET CURRENT RUNTIME
	PUSH NP,1
	PUSH GP,PREX
	SKIPN 1,GCMESF
	JRST GC11
	CAMN 1,KT
	JRST GCM1
	MOVE 2,KT
	CALL PRIN1		;PRINT USER MESSAGE
	JRST GC11
GCM1:	MOVE 1,GCTYP
	TYPEQ <$GC: >
	CALL PNO10
	TMSG EOLM
GC11:	TLZ F,GCCF+GCMF+GCPF	;CLEAR GC FLAGS
	SETZM CMPTYP
	MOVE 1,BGNCOR	;GATHER INFO ABOUT PAGE ASSIGNMENTS
	MOVEM 1,NEWCNS
	MOVE 2,ENDCOR
	LSHC 1,-LPS
	HRLI 1,0(1)
	MOVSI 2,0(2)
	SUB 1,2
	MOVEM 1,BGNPAG
	MOVSI 7,-NTYPN
GC12:	HRRZ 6,TYPBLK(7)		;CLEAR COUNTS OF THINGS IN USE
	JUMPE 6,GC13
	PUSH NP,TNWD(6)		;SAVE OLD COUNT OF WORDS IN USE
	SETZM TNWD(6)
GC13:	AOBJN 7,GC12


PPSCAN:	HRRZ 2,IPP
PPS1:	CAIL 2,0(PP)
	JRST INTSCN	;DONE WITH PPDL
	HRRZ 1,1(2)	;GET WORD
	PUSH GP,2
	PUSHJ GP,CHAS
	MOVE 2,0(GP)
	HLRZ 1,1(2)
	PUSHJ GP,CHAS
	POP GP,2
	AOJA 2,PPS1


INTSS:	HRRZ 1,0(2)
	PUSH GP,2
	PUSHJ GP,CHAS
	POP GP,2
	AOBJN 2,INTSS
	POPJ GP,

INTSCN:	MOVE 2,[XWD -NKCELL,KNIL]
	PUSHJ GP,INTSS	;SCAN INTERNAL TABLE
	MOVE 2,[XWD -NFILES-1,FILEA]	;ONE EXTRA FOR STRING INPUT
	PUSHJ GP,INTSS
	MOVE 2,[XWD -NTYPN,EVATAB]	;SCAN EVAL TABLE
	PUSHJ	GP,INTSS


CPSCAN:	HRRZ 2,ICP
CPS1:	CAIL 2,0(CP)
	JRST ATSCAN
	HRRZ 1,1(2)
	CAIN 1,PPR
	HLRZ 1,1(2)		;FLAG IN RIGHT, CHECK NAME IN LEFT
	PUSH GP,2
	PUSHJ GP,CHAS
	POP GP,2
	AOJA 2,CPS1


ATSCAN:	MOVE 5,ATOMHT   ;SCAN ATOMS, USING HASH TABLE
	HRRZ 6,0(5)	;LENGTH -1
	HRLI 5,6
ATS1:	HRRZ 1,@5
	JUMPE 1,ATS3	;ENTRY NOT USED
	HRRZI 1,-2(1)	;HASH ENTRY -2 IS THE ATOM
	HRLZ 4,KNIL
	HRR 4,KNOB
	CAME 4,0(1)
	JRST ATS2	;EITHER CAR OR CDR USED
	HRRZ 4,1(1)	; NO CAR OR CDR ,CHECK FN
	CAME 4,KNIL
ATS2:	PUSHJ GP,CHAS		;SOMETHING USED, CHASE
ATS3:	SOJG 6,ATS1

SHRSCN:	PUSHJ GP,SHRPG		;SCAN AND CHASE FROM SHARED PAGES
	 PUSHJ GP,SHRSAR	;ARRAY PAGE
	 PUSHJ GP,SHRSL		;LIST PAGE
	 PUSHJ GP,SHRSAT	;ATOM PAGE
	 PUSHJ GP,SHRSSP	;STRING POINTER PAGE
	 PUSHJ GP,SHRUCH	;USER DATA TYPE PAGE
	CALL HDLPG		;FOR ALL HANDLE PAGES
	 CALL SHRSHC		; CHASE PTRS ON SHARED/PVT SHADOW PAGES

	MOVE 1,GCSTPT
	PUSHJ GP,MARKST		;MARK STRING ABUILDING IF ANY
	TLZ F,GCF		;DO SONG AND DANCE FOR HASH ARRAYS
HASHS1:	PUSHJ GP,SCNHA
	 PUSHJ GP,HSHCH		;XCT'ED FOR EACH ELEMENT OF ARRAY
	CALL HDLPG		;FOR ALL HANDLE PAGES
	 CALL SWPUHD		;FINISH CHASING SHADOW ARRAYS
	TLZE F,GCF		;ANYTHING NEW CHASED?
	JRST HASHS1
	PUSHJ GP,SCNHA
	 PUSHJ GP,HSHREC		;RECLAIM UNUSED ENTRIES
	CALL HDLPG
	 CALL HDLCLR		;CLEAR CHASED BITS FROM HANDLES
	JRST GCS


;FIND BEGINNING OF ARRAY, ARRAY PO	NTER IN 1

FBA:	PUSH GP,3
	MOVE 3,ARRAYT
	HRRZ 3,TYPBLK(3)
FBA3:	CAML 1,TBGN(3)
	CAML 1,TFRE(3)
	JRST FBAB		;NO SUCH ARRAY THIS SPACE, TRY NEXT
	MOVEI 2,0(1)
	LSH 2,-LPS
FBA1:	HRRZ 3,BTT(2)
	CAIN 3,0
	SOJA 2,FBA1		;NO ENTRY FOR THIS PAGE, BACK UP
	CAIGE 1,0(3)
	SOJA 2,FBA1		;ENTRY THIS PAGE TOO BIG, BACK UP
FBA2:	CAIN 1,0(3)
	JRST FBAX
	MOVEI 2,0(3)
	ADD 3,0(3)		;BEG OF NEXT ARRAY
	CAIL 2,0(3)
	JRST FBABAD		;LENGTH LESS OR EQ 0
	CAIL 1,0(3)
	JRST FBA2
	MOVEI 1,0(2)
FBAX:	POP GP,3
	POPJ GP,

FBAB:	HRRZ 3,TNEXT(3)
	JUMPG 3,FBA3
FBABAD:	MOVEI 1,0		;NO MORE ARRAY SPACES, RETURN 0
	JRST FBAX

UFBA:	CALL FBA		;USER ENTRY
	JUMPN 1,R
	MOVE 1,KNIL		;RETURN NIL IF NO SUCH
	RET

;SUBFNS FOR DETERMINING STORAGE ALLOCATION AND USE

;FIND # WORDS IN USE FOR DATA TYPE
;FOR NON-CONTIG. TYPES RESULT IS AS OF LAST GC

INUSE:	CALL IUNBOX
	HRRZ 2,TYPBLK(1)
	JUMPE 2,FALSE		;RETURN NIL IF NO SUCH TYPE
	MOVE 3,TBITS(2)
	TRNN 3,BCONT
	JRST INUSEA
	HRRZ 1,TFRE(2)		;CONTIG. TYPE
	SUB 1,TBGN(2)		;USE FRE-BGN
	JRST MKN

INUSEA:	HLRZ 3,3		;ENTRY SIZE
	MOVE 1,TNWD(2)		;TIMES ENTRIES IN USE
	IMULI 1,0(3)
	JRST MKN

;FIND # WDS ASSIGNEED TO DATA TYPE
;SECOND ARG T, COUNT SYSTEM ONLY

ASSED:	SETZ 5,
	CAME 2,KNIL
	MOVEI 5,SYSBIT
	CALL IUNBOX
	SETZ 4,
	MOVE 2,BGNPAG
	CAIN 1,2
	MOVSI 2,-NPM
ASSED1:	HRRZ 3,TYPTAB(2)
	XORI 3,0(5)
	TRNE 3,SYSBIT
	JRST ASSED2		;DONT COUNT SYSTEM PAGES
	ANDI 3,MTYPN
	CAIN 3,0(1)
	ADDI 4,NPS
ASSED2:	AOBJN 2,ASSED1
	MOVEI 1,0(4)
	JRST MKN

;MAKE SHARED SYSTEM
;REALLY SHOULD INCLUDE GC AND FLUSH UNUSED PAGES

NPPG==<GCIE+777>B44		;NUMBER PROGRAM PAGES

IFE TEN50,<
MKSYS:	MOVE 3,FREETB
	ADDI 3,3*NTWC	;ROOM FOR 3 MORE TYPBLKS?
	CAMLE 3,ENDTB
	JRST MKSYSQ		;NO GET A PAGE
	CALL IOFN
	MOVEM 2,SYSJFN		;SAVE FILE NAME
	MOVSI 1,400001
	GTJFN
	JRST FALSE
	PUSH CP,1		;SAAVE JFN
	MOVE 2,[XWD 440000,100000]	;36BIT WRITE
	OPENF
	 JRST	[POP CP,1
		 RLJFN
		  JFCL
		 JRST FALSE]
	GTAD
	MOVEM 1,SYSDAT		;REMEMBER WHEN SYSTEM CREATED
	HLRE 4,BGNPAG
	MOVNM 4,SYSPGS		;NNUMBER OF SYSTEM PAGES
	MOVEI 4,120000
	MOVE 2,[XWD -1,520000]
	MOVEM 2,MKSYST		;FIRST PAGE RWE
	MOVE 2,[XWD -NPPG,1]
	MOVEM 2,MKSYST+1
	IORM 4,MKSYST+1		;HAND CODE RE
	CALL MKSYS1		;SET SYSBITS
	MOVN 2,BGNCOR
	ASH 2,-LPS
	ADDI 2,NPPG+1
	MOVSI 2,0(2)
	HRRI 2,NPPG+1+520000
	MOVEM 2,MKSYST+2		;TEMPS RWE
	MOVE 2,BGNPAG
	MOVEM 2,MKSYST+3
	IORM 4,MKSYST+3
	CALL MKSYS1
	SETZM MKSYST+4
	MOVE 1,FREEAR		;RELEASE UNUSED ARRAY SPACE
	ADDI 1,MPS
	ANDI 1,-NPS
	MOVEI 3,0(1)
	EXCH 3,ENDAR
	LSH 1,-LPS
MKSY11:	CAMG 3,ENDAR
	JRST MKSYS6
	SETZM TYPTAB(1)
	SETZM BTT(1)
	SUBI 3,NPS
	AOJA 1,MKSY11

MKSYS1:	HRRZ 1,TYPTAB(2)
	ANDI 1,77
	JUMPE 1,MKSYS2		;UNUSED
	CAMN 1,BTABT
	JRST MKSYS2
	CAMN 1,LISTT		;IF LIST -
	JRST MKSYSL
MKSYSN:	PUSH CP,2
	MOVEI 1,0(2)
	HRLI 1,400000
	RPACS			;READ PAGE ACCESSS
	HLLZ 3,2
	POP CP,2
	TLNN 3,010000
	JRST MKSYS2		;PAGE DOENST EXIST
	MOVE 1,TYPTAB(2)
	TRZ 1,PVTBIT
	TRO 1,SYSBIT
	MOVEM 1,TYPTAB(2)
MKSYS2:	AOBJN 2,MKSYS1
	POPJ CP,

MKSYSL:	HLRZ 5,TYPTAB(2)
	LSH 5,-11
	CAIE 5,777
	JRST MKSYSM
	MOVEI 5,0(2)		;777 WDS FREE
	LSH 5,LPS		;NOW SEE IF REALLY EMPTY
	HRLI 5,-NPS
	HLRZ 3,0(5)
	JUMPN 3,MKSYSM
	AOBJN 5,.-2
	SETZM TYPTAB(2)		;YES - RELEASE PAGE
	SETZM BTT(2)
	JRST MKSYS2
MKSYSM:	HRRZS TYPTAB(2)		;CLEAR LEFT TYPTAB SO CONS WONT USE
	JRST MKSYSN

MKSYS6:	HRRZ 1,FREEAT		;CLEAR STUFF ON FREE LISTS
MKSYSC:	HRRZ 2,0(1)		;... SO WONT CAUSE TROUBLE LATER
	SETZM 0(1)
	SETZM 1(1)
	SETZM 2(1)
	SKIPE 1,2
	JRST MKSYSC
	HRRZ 1,FREESP
MKSYSD:	HRRZ 2,0(1)
	SETZM 0(1)
	SKIPE 1,2
	JRST MKSYSD
	MOVSI 2,-NTYPN		;LOOK FOR ALL TYPES IN USE
MKSYS5:	HRRZ 1,TYPBLK(2)
	JUMPE 1,MKSYS3
	MOVE 3,TBITS(1)
	TRNN 3,BCONT
	JRST MKSYS4
	MOVSI 3,0(1)		;CONNTIG. TYPE
	HRR 3,FREETB
	HRRZI 4,0(3)
	BLT 3,NTWC-1(4)		;MOVE TYPE INFO TO NEW SPACE
	MOVEM 4,TNEXT(1)	;NEXT PTS TO IT
	ADDI 4,NTWC
	MOVEM 4,FREETB
	SETZM TBGN(1)
	SETZM TEND(1)
MKSYS4:	SETZM TFRE(1)		;ALL TYPES SET FREEPTR
	SETZM TNFR(1)		;...AND COUNT 0
MKSYS3:	AOBJN 2,MKSYS5
	MOVE 1,HISHAD		;BUMP HISHAD (LIKE ENDCOR) TO
	TRZ 1,777		;PAGE BOUNDARY
	ADDI 1,1000
	EXCH 1,HISHAD		;MAYBE TRZ SHOULD BE TRZE?
	LSH 1,-LPS		;NOW SET SYSBITS FOR SHADOW PAGES
	HRRZI 2,FSYSBT
	CALL SFRKB
	SOJGE 1,.-2
	SETOM ZORGJQ		;FLAG TELLS SYSOUE IT'S A MAKESYS
	POP GP,SYSJFN		;IN PROGRESS AS AGAINST A SYSOUT
	JRST SYSOUE

MKSYSB:	MOVEI 1,LISP2		;RESET ENTRY VECTOR
	HRRM 1,EVEC
	MOVEI 1,RESETE
	HRRM 1,EVEC+1
	MOVSI 10,-NTYPN		;GO THRU ALL TYPES
MKSYS7:	HRRZ 7,TYPBLK(10)
	JUMPE 7,MKSYS8
	SETZM TNWD(7)
	MOVEI 2,0(10)		;TYPE
	HRRZ 6,TNPG(7)		;PAGES NEEDED
	MOVE 3,TBITS(7)
	TRNE 3,BCONT
	JRST MKSYS9
	PUSHJ CP,GETFPG
MKSYS8:	AOBJN 10,MKSYS7
	SETOM SYSCHK
	HRRZ 1,KT
	JRST GCIS

MKSYS9:	PUSH CP,10
	PUSHJ CP,GCTBC
	POP CP,10
	JRST MKSYS8

MKSYSA:	MOVEI CP,10
	CALL UNPROT
	CALL SETINT
	MOVE CP,ICP
	CALL MKSYSB
	CALL CLSALL
	CALL RESTCB		;Restore swapping buffer per tables.
				;Superfluous since we're gonna reset.
	MOVE 1,[XWD MYFRKS+1,SWFRKS]	;A LA SYSINR.
	BLT 1,SWFRKS+NSWFRKS-1
	JRST LISP2

;LIKE EVERYTHING ELSE THE TEMPS AREA IS NOW WRITE PROTECTED, BUT IT
;HAS TO BE WRITTEN EVEN BEFORE WE GET THE WTRP STUFF WIRED UP.
;HENCE WE EXPLICITLY UNPROTECT THESE PAGES NOW.

UNPROT:	HRRZI 5,BEGTMP		;VERY TRICKY! BEGIN NOT WITH A SWEEP
	HRRZI 1,(5)		;FROM PAGE 0 BECAUSE SETTING ITS
	CALL UNPRT1		;PVTBIT WOULD TRAP. SO BEGIN WITH PAGE
				;WHERE PVTBITS ARE KEPT. UNPRT1 MUST
				;THEREFORE DO SPACS BEFORE BITS RESET.
				;USES FACT THAT TYPTAB=BEGTMP!
	ADDI 5,1000
	CAIG 5,ENDTMP
	 JRST .-4
	SETZ 1,
	CALL UNPRT1		;NOW GET PAGE 0. THE REST CAN BE LEFT
	RET			;FOR WTRP.

UNPRT1:	LSH 1,-LPS
	HRLI 1,400000
	RPACS
	TLO 2,400		;SET CW BIT
	TLNE 2,10000		;BUT PAGE MUST EXIST.
	 SPACS
	MOVE 2,TYPTAB(1)
	IORI 2,PVTBIT
	TRZ 2,SYSBIT
	MOVEM 2,TYPTAB(1)
	RET


MKSYSQ:	PUSH CP,1
	MOVEI 1,ASZ+1
	CALL GETBLK
	MOVEM 1,FREETB
	ADDI 1,NPS
	MOVEM 1,ENDTB
	POP CP,1
	JRST MKSYS

U MKSYST,5
>	;END OF IFE TEN50
U SYSPGS		;# DATA PAGES ASSIGNED AT MKSYS TIME
U FREETB
U ENDTB
NTB=11*NTWC
U XTRATB,NTB

;REHASH HASH ARRAY - AFTER POINTERS HAVE BEEN UPDATED
;ARRAY IN 1

REHSHG:	MOVEI 6,0(1)
	HRLI 1,200000
	SKIPE FORKH
	JRST REHG3
	CFORK
	JRST GCERR
	MOVEM 1,FORKH
REHG3:	MOVE 4,ATOMHT		;PAGES 0 TO ATOMHT SAME BOTH FORKS
	LSH 4,-LPS
	MOVSI 1,400000
	HRLZ 2,FORKH
	MOVSI 3,160000		;ACCESS RWE
REHG1:	PMAP
	ADDI 2,1
	CAILE 4,1(1)
	AOJA 1,REHG1
	MOVEI 1,0(6)		;PAGES CONTAINING ARRAY
	LSH 1,-LPS		;MAP TO ATOMHT ON UP
	HRLI 1,400000
	HRRZ 4,0(6)
	ADDI 4,0(6)
	LSH 4,-LPS		;PAGE ON WHICH ARRAY ENDS - THIS FORK
REHG2:	PMAP
	ADDI 2,1
	CAIL 4,1(1)
	AOJA 1,REHG2
	MOVEI 3,777000
	SUB 3,ATOMHT
	LSH 3,-1
	ANDI 3,777000		;ADDRESS NEW VERSION - OTHER FORK
	MOVEI 4,0(6)
	ANDI 4,MPS
	ADD 4,ATOMHT		;ADDR OLD VERSION - OTHER FORK
	MOVE 1,FORKH
	SETZ 2,
	SFACS
	MOVEI 2,REHSHF
	SFORK
	WFORK
	RET

U FORKH

REHSHF:	HRRZ 2,0(4)
	MOVEM 2,0(3)
	MOVE 2,1(4)
	MOVEM 2,1(3)
	PUSH CP,4
	CALL REHSHS
	POP CP,4
	HRLI 4,0(1)		;MOVE NEW TO OLD
	HRRZ 1,0(4)
	ADDI 1,-1(4)
	BLT 4,0(1)
	HALTF


;FIND ALL PAGES WITH SYSBIT SET THAT HAVE BECOME PRIVATE
;CALLS TO ROUTINES FOR VARIOUS DATA TYPES FOLLOW CALL TO SHRPG
;USED FOR SCAN AND SWEEP OF SHARED DATA

SHRPG:	IFE TEN50,<
	MOVE 7,BGNPAG
SHRPG1:	MOVE 6,TYPTAB(7)
	TRNN 6,SYSBIT
	JRST SHRPG2		;NOT SYSTEM PAGE - IGNORE
	TRNE 6,PVTBIT
	JRST SHRPG4
	MOVEI 1,0(7)
	CALL SYSCH		;MAKE SURE BITS ARE RIGHT
	 JRST SHRPG2		;PAGE IS PROTECTED
SHRPG4:	ANDI 6,77		;SOMEBODY CHANGED IT
	MOVE 1,0(GP)
	CAMN 6,ARRAYT		;DOES PAGE NEED SCANNING?
	ADDI 1,1
	CAMN 6,LISTT
	ADDI 1,2
	CAMN 6,ATOMT
	ADDI 1,3
	CAMN 6,STPTT
	ADDI 1,4
	CAIG	6,MSYST		;USER TYPE?
	JRST	.+3		;NO
	CAIL	6,MTYPN		;MAYBE - CHECK SOME MORE
	ADDI	1,5		;YES
	CAME 1,0(GP)
	XCT -1(1)		;CALL APPROPRIATE ROUTINE IF ANY
SHRPG2:	AOBJN 7,SHRPG1
>
	POP GP,1
	SETZM SYSCHK		;BITS NOW AGREE WITH PAGE ACCESS
	JRST 5(1)

SYSCH:	IFE TEN50,<
	SKIPN SYSCHK		;ALL THIS IS TO AVOID BEING SCREWED
	RET		;BY USER WHO DOEES SSAVE NOTT SYSOUT
	PUSH PP,1		;MAKE SURE SHARED PAGES STILL WRITE 
	PUSH PP,2
	HRLI 1,400000		;...PROTECTED
	RPACS
	TLNN 2,040600		;COPY ON WRITE, WRITE, OR PRIVATE
	JRST SYSCH1		;OK
	MOVEI 2,PVTBIT		;NOT PROTECTED , SET PRIVATE BIT
	IORM 2,TYPTAB(1)
	AOS 0(GP)		;SKIP IF PAGE NOT PROTECTED
SYSCH1:	POP PP,2
	POP PP,1
>
	RET

;SCAN AND CHASE FROM SHARED LIST PAGE - PAGE IN 7

SHRSL:	MOVEI 5,0(7)
	LSH 5,LPS
	HRLI 5,-NPS
SHRSL1:	CARA 1,5
	PUSHJ GP,CHAS
	CDRA 1,5
	PUSHJ CP,CHAS
	AOBJN 5,SHRSL1
	POPJ GP,

;SCAN AND CHASE FROM SHARED ATOM PAGE - PAGE IN 7

SHRSAT:	MOVEI 5,0(7)
	LSH 5,LPS
	HRLI 5,-NPS/3
SHSAT1:	MOVEI 1,0(5)
	PUSHJ GP,CHSAT1
	ADDI 5,2
	AOBJN 5,SHSAT1
	POPJ GP,

;SCAN AND CHASE FROM SHARED STRING POINTERPAGE - PAGE IN 7

SHRSSP:	MOVEI 5,0(7)
	LSH 5,LPS
	HRLI 5,-NPS
SHRSS1:	MOVE 1,0(5)
	PUSHJ GP,MARKST
	AOBJN 5,SHRSS1
	POPJ GP,

;SCAN AND CHASE FROM SHARED ARRAY PAGE - PAGE IN 7

SHRSAR:	PUSHJ GP,SCNSAR
	 PUSHJ CP,CHLIST
	POPJ GP,

;SCAN AND CHASE FROM USER DATA TYPE PAGE - PAGE IN 7

SHRUCH:	HRRZ	3,TYPTAB(7)	;GET TYPE NUMBER
	PUSH	GP,TYPSIZ(3)	;SAVE NUMBER OF BOXED WORDS
	HLRM	3,0(GP)		;CLEAR STATUS BITS
	HRRZ	3,TYPBLK(3)
	HLRZ	3,TSIZ(3)	;GET NUMBER OF WORDS/ITEM
	MOVEI	5,NPS
	IDIVI	5,0(3)		;COMPUTE NUMBER OF ITEMS/PAGE
	PUSH	GP,5		;AND SAVE IT
	PUSH	GP,3
	MOVEI	5,0(7)		;CONVERT PAGE NUMBER OT ADDRESS
	LSH	5,LPS
USHRC2:	MOVEI	1,0(5)
	PUSHJ	GP,UCHAS4	;GO CHASE THE BOXED WORDS
	ADD	5,0(GP)		;BUMP ADDRESS
	SOSLE	-1(GP)		;DECREMENT COUNTER
	JRST	USHRC2		;AND LOOP
	SUB	GP,BHC+3	;POP JUNK
	POPJ	GP,
UCHAS4:	PUSH	GP,-3(GP)	;SET UP FOR TO USE UCHAS CODE
	JRST	UCHAS2

				;MARKING DONE AND ACTIVE UNITS COUNTED
				;NOW SEE IF SHUFFLING OR COMPACTING
				;ARE REQUIRED
GCS:	MOVE 2,GCTYP
	HRRZ 1,TYPBLK(2)
	MOVEI 3,BCONT
	TDNN 3,TBITS(1)
	JRST GCP1
GCEXP:	MOVEM 2,CMPTYP
	SETZM NNP	;COMPACT AND EXPAND A REGION
	PUSH GP,1
	MOVE 2,TEND(1)
	SUB 2,TBGN(1)	;NUMBER OF WORDS AVAILABLE
	SUB 2,TNWD(1)	;- # USED IS NUMBER FREE
	MOVEM 2,TNFR(1)
	CAML 2,TMIN(1)
	JRST GCEXP1	;ENOUGH FREE, JUST COMPACT
	MOVN 5,2
	ADD 5,TMIN(1)
	ADDI 5,MPS
	LSH 5,-LPS	;NUMBER OF ADDITIONAL PAGES REQUIRED
	MOVE 6,TBGN(1)
	LSH 6,-LPS
	MOVE 7,TEND(1)
	SUBI 7,1
	LSH 7,-LPS
	PUSHJ GP,ADJMT
	MOVEM 1,FRSTNP
	MOVEM 2,NNP
	MOVE 1,0(GP)
	MOVE 2,TINI(1)
	MOVEM 2,INIFN
GCEXP1:	XCT TPLN(1)
	POP GP,1
	MOVE 2,TCHG(1)
	MOVEM 2,CMPFN
	MOVE 2,TBITS(1)
	TRNE 2,BGEN
	TRNE 2,-1
	TLO F,GCPF
	TLO F,GCCF

GCP1:	TLNN F,GCPF		;BEFORE HANDLE BITS GET CLEARED
	JRST .+3
	CALL HDLPG		;FOR ALL HANDLE PAGES
	 CALL SWPHDB		;UPDATE PTRS IN NON-SYS SHADOW ARRAYS
	PUSHJ GP,SWPATH		;SWEEP ATOM HASH TABLE
	PUSHJ GP,SWPFIX		;SWEEP FIXED LENGTH TYPES
	PUSHJ GP,SWPARR
	TLNN F,GCPF+GCCF
	JRST PPRS1
	PUSHJ GP,SHRPG		;SWEEP SHARED DATA THAT HAS CHANGED
	 PUSHJ GP,SWPSAR
	 PUSHJ GP,SWPSL
	 PUSHJ GP,SWPSAT
	 PUSHJ GP,SWPSSP
	 PUSHJ GP,SWPSUS
	CALL HDLPG		;FOR ALL HANDLE PAGES
	 CALL SWPHDA		;UPDATE PTRS IN SYS/PVT SHADOW ARRAYS
	MOVE 4,[XWD -NKCELL,KNIL]	;IF POINTERS ARE CHANGING
	PUSHJ GP,INTRS	;RESCAN INTERNAL TABLES
	MOVE 4,[XWD -NFILES-1,FILEA]
	PUSHJ GP,INTRS
	MOVE 4,[XWD -NTYPN,EVATAB]	;UPDATE EVAL TABLE
	PUSHJ GP,INTRS
	HRRZ 4,IPP
PPRS:	CAIL 4,0(PP)
	JRST CPSC
	MOVE 1,1(4)
	PUSHJ GP,CHG2P
	MOVEM 1,1(4)
	AOJA 4,PPRS

INTRS:	HRRZ 1,0(4)
	PUSHJ GP,CHGPTR
	HRRM 1,0(4)
	AOBJN 4,INTRS
	POPJ GP,

CPSC:	HRRZ 3,ICP		;SCAN CONTROL STACK
CPSC1:	CAILE 3,0(CP)
	JRST PPRS3
	HRRZ 1,0(3)
	CAIE 1,PPR		;FLAG IN RIGHT
	JRST CPSC2
	HLRZ 1,0(3)		;MEANS NAME IN LEFT
	PUSHJ GP,CHGPTR
	HRLM 1,0(3)
	AOJA 3,CPSC1
CPSC2:	PUSHJ GP,CHGPTR	;CHANGE POSSIBLE COMP.CODE RET
	HRRM 1,0(3)
	AOJA 3,CPSC1

PPRS3:	SOS 1,ENDBT
	PUSHJ GP,CHGPTR
	ADDI 1,1
	EXCH 1,ENDBT
	CAMN 1,FREEBT
	JRST PPRS31		;FREEBT IS AT END
	HRRZ 1,FREEBT
	PUSHJ CP,CHGPTR
PPRS31:	HRRZM 1,FREEBT

PPRS1:	MOVE 1,GCTYP
	MOVE 2,XMINAR
	CAMN 1,ARRAYT		;IF COLLECTING ARRAYS
	MOVEM 2,MINARR		;RESTORE MINARR TO PERMANENT VALUE
	HRRZ 2,TYPBLK(1)
	PUSH GP,TNFR(2)	;SAVE FREE COUNT FOR TYPE COLLECTING
	PUSHJ GP,MOVARR		;JUST CLEARS GC PTR IF NOTHING MOVING
	TLNN F,GCMF+GCCF
	JRST PPRS2
	PUSHJ GP,MOVSTR
	PUSHJ GP,MOVPN
	PUSHJ GP,MOVPGS

PPRS2:	MOVEI 2,MTYPN
PPRS4:	HRRZ 7,TYPBLK(2)
	JUMPE 7,PPRS6
	MOVE 3,TBITS(7)
	POP NP,5		;OLD # WORDS IIN USE
	TRNE 3,BCONT		;LOOK FOR NON-CONTIG. TYPES
	JRST PPRS6
	HLRZ 3,3		;ENTRY SIZE
	MOVE 6,TMIN(7)
	CAMN 2,GCTYP		;TYPE COLLECTING?
	JRST PPRS5		;YES - GET MINFS
	MOVE 4,TNWD(7)		;OTHER TYPES
	SUB 4,5			;...SEE IF GROWING
	JUMPLE 4,PPRS6		;IF WORDS USED DECREASING DONT GET MORE
	ASH 4,2			;4 * INCREASE
	IMULI 4,0(3)		;* SIZE
	CAIGE 4,0(6)
	ASH 6,-1		;INCREASE<1/4 MINFS,GET 1/2 MINFS
PPRS5:	MOVE 5,TNFR(7)		;ENTRIES FREE
	IMULI 5,0(3)		;WORDS FREE
	SUBI 6,0(5)
	ADDI 6,MPS
	ASH 6,-LPS		;PAGES NEEDED
	JUMPLE 6,PPRS6
	PUSH GP,2
	PUSHJ GP,GETFPG
	POP GP,2
PPRS6:	SOJGE 2,PPRS4

GCXIT:	SKIPE 1,FORKH		;WAS FORK CREATED?
	KFORK			;YES, KILL IT
	POP GP,1
	SKIPE	GCMES2
	JRST	GCX2
	SKIPE 2,GCMESF
	CAME 2,KT
	JRST GCX1
	CALL PNO10		;PRINT OLD FREE COUNT
	TYPEQ <, >
	MOVE 1,GCTYP
	HRRZ 1,TYPBLK(1)
	HRRZ 1,TNFR(1)
	CALL PNO10		;PRINT NEW FREE COUNT
	TYPEQ < FREE WORDS$>
GCX1:	POP GP,PREX
	GETJRT			;CALCULATE TIME OF GC
	SUB 1,0(NP)
	ADDM 1,GCRT
	HRRZ 2,GCCP
	CAIE 2,0(CP)
	 TMSG GCEM2
	MOVS 1,[XWD 2,GCAC2]	;RESTORE ACS 2 - 13
	BLT 1,13
	POP	PP,BR		;& BR.
	SUB	NP,BHC+1
	MOVE 1,GCTYP
	HRRZ 1,TYPBLK(1)
	HRRZ 1,TNFR(1)
	JUMPE 1,RESET		;NO FREE WORDS - QUIT
	MOVE 1,GCTYP
	CAMN 1,STRNGT
	 RET			;Strings not quite done - delay int.
	CALL	DOINTN		;Clear interrupt system.
	JRST	RESWAP		;Restore swapping buffer, exit gc.

DOINTN:	TRZ F,GCFLG		;CLEAR GC IN PROGRESS
	SKIPN GINTD		;WAS INTERRUPT REQUESTED?
	 RET			;No, return.
	JRST @GINTD		;YES, GO TO ROUTINE

GCX2:	HRRZ	1,GCMES2	;PRINT USER TERMINATING GC MESSAGE
	MOVE	2,KT
	CALL	PRIN1
	TMSG	EOLM
	JRST	GCX1

GCEM2:	SIXBIT @$STACK OVERFLOW IN GC - COMPUTATION LOST$/@
;GET NEW PAGES FOR FIXED LENGTH TYPES
;ENTER 6 # PAGES, 7 TYPBLK PTR, 2 TYPE

GETFPG:	HRRZ 1,TFRE(7)
	CAME 2,LISTT
	JRST .+3
	SETZ 1,			;LISTS HAVE  ONE PAGE FREELISTS
	HRLI 2,<NPS-1>B26	;AND FREE COUNT IN LEFT TYPTAB
GCNPG:	HLRZ 3,TSIZ(7)
	PUSHJ GP,NEWPGG
	 POPJ GP,		;NO MORE PAGES AVAIL
	MOVEI 4,0(2)
	CAMN 4,LISTT
	JRST GCNPL
	MOVEM 1,TFRE(7)
	HLRZ 5,TSIZ(7)
	MOVEI 4,NPS
	IDIVI 4,0(5)
GCNP1:	ADDM 4,TNFR(7)		;UPDATE FREE COUNT
	SOJG 6,GCNPG
	POPJ GP,

GCNPL:	MOVEI 4,MPS		;LISTS  HAVE 777 WDS FREE ON NEW PAGE
	MOVEI 1,0
	JRST GCNP1
;SCAN FOR POINTERS ON SHARED ARIAY PAGE
;ROUTINE TO EXECOTE FOR EACH POINTER ON PAGE FOLLOWS CALL

SCNSAR:	MOVEI 1,0(7)
	LSH 1,LPS
	PUSH GP,1		;PAGE BEG
	MOVEI 6,NPS(1)
	PUSH GP,6		;PAGE END+1
	PUSHJ GP,FBA
	JUMPE 1,SWSAX		;NO SUCH ARRAY
	MOVEI 5,0(1)
SWSAR3:	HLRE 6,0(5)
	JUMPG 6,.+2
	HRRZ 6,0(5)
	JUMPLE 6,SWSAX		;LEN 0 OR LESS, NO SUCH ARRAY
	ADDI 6,0(5)		;ADDR OF END OF POINTERS
	HRRZ 4,1(5)
	ADDI 4,0(5)		;ADDR OF BEG OF POINTERS
	CAMGE 4,-1(GP)		;BELOW PAGE BEG?
	MOVE 4,-1(GP)		;YES - STEP TO PAGE BEG
	CAML 4,0(GP)		;PAST PAGE END?
	JRST SWSAX		;YES - QUIT
	CAML 6,0(GP)
	MOVE 6,0(GP)		;STOP AT LESSER OF END PTRS AND PAGE
SWSAR2:	CAIL 4,0(6)
	JRST SWSAR1
	XCT @ -2(GP)		;CALL ROUTINE WITH LOC OF POINTER IN 4
	AOJA 4,SWSAR2
SWSAX:	SUB GP,BHC+2
	AOS 0(GP)
	POPJ GP,

SWSAR1:	ADD 5,0(5)		;NEXT ARRAY
	MOVEI 5,0(5)
	JRST SWSAR3
GCF2==100000



;MOVE THE PAGES SCHEDULED TO MOVE

MOVPGS:	TLNN F,GCMF
	JRST MOVPG5
	MOVE 4,BGNPAG
MOVPG7:	HRRZ 1,BTT(4)
	JUMPE 1,.+3
	PUSHJ GP,CHGPT1		;UPDATE PTRS IN RIGHT HALF BTT
	HRRM 1,BTT(4)
IFE TEN50,<
	AOBJN 4,MOVPG7
	MOVE 1,PPTRP
	HRLI 1,400000
	RMAP
	MOVEM 1,MT
	MOVEM 2,AT
	MOVNI 1,1
	MOVE 2,PPTRP
	HRLI 2,400000
	PMAP
>
MOVPG8:	TLZ F,GCF+GCF2
	MOVE 4,BGNPAG
MOVPGD:	MOVEI 1,0(4)
	LDB 5,CHGPTP		;DEST OF PAGE
	JUMPE 5,MOVPGB		;MOVING?
	MOVE 3,TYPTAB(5)
	ANDI 3,77
	JUMPE 3,.+3
	CAIE 3,77
	JRST MOVPG9
	TLO F,GCF2
MOVPGJ:	MOVE 6,BTT(1)		;YES - SAVE BTT
	MOVE 7,TYPTAB(1)	;AND TYPTAB FOR SOURCE PAGE
	SETZM BTT(1)
	SETZM TYPTAB(1)
	TLZ 6,RPGBIT
	CAME 5,PPTRP
	HRLI 6,0
	MOVEM 6,BTT(5)
	MOVEM 7,TYPTAB(5)
	MOVEM 1,PS
IFE TEN50,<
	HRLI 1,400000
	RPACS
	MOVE 10,2
	TLNE 2,200		;SOURCE PRIVATE?
	JRST MOVPG3		;YES
	RMAP
	MOVE 3,2		;ACCESS
	MOVE 2,5
	HRLI 2,400000
	PMAP
	MOVE 2,PS		;YES - FLUSH FROM FORK
	HRLI 2,400000
	MOVNI 1,1
	PMAP
	JRST MOVPGB
>
MOVPG3:	HRLZ 1,PS		;BLT SOURCE TO DEST
	HRRI 1,0(5)
	LSH 1,LPS
	MOVEI 2,0(1)
	BLT 1,MPS(2)
MOVPGB:	AOBJN 4,MOVPGD
	TLZN F,GCF
	JRST MOVPGM
	TLZE F,GCF2
	JRST MOVPG8
	JRST MOVPGK
MOVPGM:
IFE TEN50,<
	MOVE 1,MT
	MOVE 3,AT
>
	MOVE 2,PPTRP
	MOVE 4,BLOCKT
	MOVEM 4,TYPTAB(2)
IFE TEN50,<
	HRLI 2,400000
	PMAP
>
MOVPG5:	MOVE 1,FRSTNP	;MOVING DONE NOW SET UP NEW PAGES
	MOVE 2,CMPTYP
	MOVE 3,NNP
	JUMPE 3,R
MOVPG4:	MOVEM 2,TYPTAB(1)
	HRRZS BTT(1)
	XCT INIFN
	ADDI 1,1
	SOJG 3,MOVPG4
	POPJ GP,
MOVPG9:	TLO F,GCF
	JRST MOVPGB

MOVPGK:	MOVE 4,BGNPAG
MOVPGN:	MOVEI 1,0(4)
	MOVE 6,BTT(4)
	TLNE 6,RPGBIT
	TLNN 6,777000
	JRST MOVPGL
	MOVE 5,PPTRP
	MOVE 4,BGNPAG
	SUB 4,BHC+1
	JRST MOVPGJ
MOVPGL:	AOBJN 4,MOVPGN
	HALTF		;SHOULDNT HAPPEN


CLRPG:	MOVEI 4,0(1)	;CLEAR PAGE IN 1
	LSH 4,LPS
	MOVSI 5,0(4)
	HRRI 5,1(4)
	SETZM 0(4)
	BLT 5,MPS(4)
	POPJ GP,

U MT
U AT
U MA
U AMA
U PS
U MB
U AMB
U NS
;FIND C(5) OR FEWER EMPTY PAGES (WITHOUT BIT TABLES)
;AND JUGGLE TILL THEY FOLLOW THE GROUP FROM B THRU E
;B IN 6, E IN 7

B==6
E==7
OG==10

ADJMT:	MOVEM 5,ADJT	;SAVE ORIGINAL COUNT
	MOVEI 4,0(E)
	PUSHJ GP,MTPA	;FIRST TRY IMMEDIATELY AFTTER E
	 JRST .+2
	JRST ADJMT3
	MOVE 1,GCTYP
	CAME 1,STRNGT
	CAMN 1,PNAMT
	JRST ADJMTB
	JRST ADJMT9
ADJMTB:	MOVE 5,ADJT	;FAILING THAT TRY FOR GROUP BIG ENOUGH
	ADDI 5,1(E)	;FOR B THRU E + NEW PAGES
	SUBI 5,0(B)
	PUSHJ GP,MTPGS
	 JRST ADJMT9
ADJMTR:	TLO F,GCMF
	MOVEI 1,0(B)	;SET PAGES TO MOVE
ADJMTA:	DPB 4,CHGPTP
	ADDI 1,1
	CAIG 1,0(E)
	AOJA 4,ADJMTA
	MOVEI 1,1(4)
	JRST ADJMT8
ADJMT9:	PUSH GP,PP
	MOVE 11,ADJT
ADJMT1:	PUSHJ GP,MTPG		;GET AN EMPTY PAGE
	 JRST ADJMT2
	HRRZI 2,77	;MAGIC RESERVED TYPE
	MOVEM 2,TYPTAB(4)
	PUSH PP,4	;REMEMBER PAGE NUMBER OF NEW PAGE
	SOJG 11,ADJMT1
ADJMT2:	MOVNI 2,0(11)	;- NUMBER REMAINING TO GET
	ADDB 2,ADJT	;+ NUMBER REQUESTED
	JUMPE 2,ADJMT7	;IS NUMBER FOUND, IF 0 RETURN
	TLO F,GCMF+GCPF		;FLAGS INDICATE PAGES SHUFFLING
	MOVEI 4,1(E)		;ARE ENUF PAGES FOLLOWING E
ADJML4:	PUSHJ GP,MOVQ		;... SINGLE AND MOVABLE?
	 JRST SHFPG
	ADDI 4,1
	SOJG 2,ADJML4
	MOVEI 4,1(E)
	ADD 4,ADJT
	MOVEI 1,1(E)		;YES - MOVE THEM TO EMPTY PAGES
	HRRZ 2,0(GP)
ADJML6:	HRRZ 3,TYPTAB(1)
	CAIN 3,77
	AOJA 1,ADJML6		;ALREDY EMPTY - DONT MOVE
	JUMPE 3,.-1
	MOVE 3,1(2)
	CAIGE 3,0(4)		;DONT MOVE TO PAGES AFTER E
	CAIGE 3,1(E)
	JRST .+2
	JRST ADJML5
	DPB 3,CHGPTP
	ADDI 1,1
ADJML5:	CAIGE 2,-1(PP)
	AOJA 2,ADJML6
ADJMT7:	POP GP,PP
ADJMT3:	MOVEI 1,1(E)		;FIRST NEW PAGE
ADJMT8:	MOVE 2,ADJT		;# NEW PAGES
	POPJ GP,

;SIMPLE WAYS FAIL, TRY BIG SHUFFLE

SHFPG:	MOVE PP,0(GP)
	MOVE 4,BGNPAG		;MAKE TABLE OF HOLES
SHFTBA:	PUSHJ GP,SHFTBS		;MOVABLE?
	 JRST SHFTBB		;NO
	PUSH PP,4		;YES - SAVE PAGE
	MOVEI 1,0
	JRST SHFTB9
SHFTB8:	PUSHJ GP,SHFTBS		;AND FIGURE OUT LENGTH
	JRST SHFTBC
SHFTB9:	ADDI 1,1
	AOBJN 4,SHFTB8
SHFTBC:	HRLM 1,0(PP)		;SAVE LENGTH
SHFTBB:	AOBJN 4,SHFTBA
	PUSH NP,PP		;SAVE PTR TO LAST HOLE
	MOVE 4,BGNPAG		;NOW MAKE TABLE OF CONTIG. CHUNKS
SHFPG5:	HRRZ 3,TYPTAB(4)
	TRNE 3,SYSBIT+FIXBIT
	JRST SHFPG1
	ANDI 3,77
	HRRZ 3,TYPBLK(3)
	JUMPE 3,SHFPG1
	HRRZ 2,TBITS(3)
	TRNN 2,BCONT		;CONTIGUOUS?
	JRST SHFPG1		;NO
	PUSH PP,4		;YES - SAVE FIRST PAGE
SHFPG3:	HRRZ 1,TBGN(3)		;LOOK FOR CHUNK OF WHICH
	HRRZ 2,TEND(3)		;THIS IS THE BEGINNING
	LSHC 1,-LPS
	HRRZ 3,TNEXT(3)
	CAIE 1,0(4)
	JRST SHFPG3
	SUBI 2,0(1)		;# PAGES IN CHUNK
	HRLI 2,0(2)
	MOVEI 1,0
	CAIN B,0(4)		;IS THIS THE CHUNK THATS EXPANDING?
	MOVE 1,ADJT		;... IF SO AUGMENT LENGTH
	ADD 4,2
	ADD 2,1
	HRLM 2,0(PP)		;SAVE LENGTH
	JUMPL 4,SHFPG5
SHFPG1:	AOBJN 4,SHFPG5

SHFPG6:	HRRZ 1,0(GP)		;SET UP STUFF FOR FIND
	ADDI 1,1		;PTR TO FIRST HOLE
	HLL 1,0(1)
	PUSH PP,1		;LEN,,PTR TO HOLE ON STACK
	HRRZ 1,0(NP)		;PTR TO LAST HOLE
	MOVEI 2,-1(PP)		;PTR TO LAST CHUNK
	SUB 2,1
	PUSH PP,2		;# CONTIG. CHUNKS
	ADDI 1,1
	PUSH PP,1		;PTR TO FIRST CHUNK
	PUSHJ GP,FIND
	 JRST SHUFB
	PUSH PP,BGNPAG		;SHUFFLE SINGLE PAGES
	MOVE 1,BGNPAG
SHUF1:	MOVE 2,BTT(1)
	TLNN 2,RPGBIT		;PAGE MOVING TO HERE?
	JRST SHUF2		;NO - OK
	LDB 2,CHGPTP		;YES
	JUMPN 2,SHUF2		;IF THIS PAGE GOING OUT, THEN OK
	HRRZ 2,TYPTAB(1)
	ANDI 2,77
	JUMPE 2,SHUF2
	CAIN 2,77
	JRST SHUF2
	EXCH 1,0(PP)		;FIND PLACE TO PUT THIS ONE
SHUF5:	MOVE 2,BTT(1)
	TLNE 2,RPGBIT
	JRST SHUF4		;YES
	HRRZ 2,TYPTAB(1)
	ANDI 2,77
	CAIE 2,77
	JUMPN 2,SHUF3
SHUFG:	MOVSI 2,RPGBIT		;EMPTY OR RESERVED
	IORM 2,BTT(1)
	MOVEI 2,0(1)
	EXCH 1,0(PP)
	DPB 2,CHGPTP
SHUF2:	AOBJN 1,SHUF1
	SUB NP,BHC+1
	POP GP,PP
	MOVEI 1,0(E)
	LDB 2,CHGPTP
	SKIPE 2
	MOVEI 1,0(2)
	ADDI 1,1
	JRST ADJMT8

SHUF3:	LDB 2,CHGPTP		;PG GOING SOMEPLACE?
	JUMPN 2,SHUFG		;YES - USE IT
SHUF4:	AOBJN 1,SHUF5		;NO TRY NEXT
	HALTF			;SCREWED UP

SHUFB:	POP GP,PP		;DIDNT FIT
	SUB NP,BHC+1
	MOVE 4,BGNPAG		;RELEASE RESERVED PAGES
SHUFB1:	HRRZ 3,TYPTAB(4)
	CAIN 3,77
	SETZM TYPTAB(4)
	AOBJN 4,SHUFB1
	MOVE 5,ADJT
	ADDI 5,1(E)
	SUBI 5,0(B)
	PUSHJ GP,MTPGS		;TRY AT END NOW
	 JRST SHUFB3
	JRST ADJMTR		;SUCCESS

SHUFB3:	SOSLE 5,ADJT		;FAILS - TRY FOR ONE LESS PAGE
	JRST ADJMT
	JRST ADJMT8		;GIVE UP

;PAGE IN 4 - SKIP IF NON-CONTIGUOUS,NON-BLOCK, NON-SYSTEM,
;NON-FIXED - RESERVED OR EMPTY ALSO OK

MOVQ:	MOVE 3,TYPTAB(4)
	TRNE 3,SYSBIT+FIXBIT
	POPJ GP,
	ANDI 3,77
	CAMN 3,BLOCKT
	POPJ GP,
	CAIN 3,77
	JRST MOVQ1
	JUMPE 3,MOVQ1
	HRRZ 3,TYPBLK(3)
	HRRZ 3,TBITS(3)
	TRNN 3,BCONT
MOVQ1:	AOS 0(GP)		;SKIP IF OK
	POPJ GP,

;PAGE IN 4 - SKIP IF NON-FIXED,NON-SYSTEM, I.E.MOVABLE

SHFTBS:	MOVE 3,TYPTAB(4)
	TRNE 3,SYSBIT+FIXBIT
	POPJ GP,
	ANDI 3,77
	CAME 3,BLOCKT
RSKIP:	AOS 0(GP)
	POPJ GP,

;FIND HOLES TO PUT CONTIG. CHUNKS IN
;ARGS ARE ON PP AS FOLLOWS
; CHUNK LEN,,FIRST PAGE
; CHUNK ..
; ...
; HOLE REMAINDER,,PTR TO HOLE DESC.
; # CHUNKS
; PTR TO CURRENT CHUNK , INITIALLY FIRST

FIND:	HRRZ 1,0(PP)		;PTR TO NEXT CHUNK TO TRY
FIND1:	CAIL 1,-2(PP)		;ALL TRIED?
	JRST FIND4		;YES
	HLRZ 2,0(1)		;LENGTH OF CHUNK
	HLRZ 3,-2(PP)		;AND LENGTH OF REMAINDER THIS HOLE
	CAIG 2,0(3)		;FITS?
	JRST FIND2		;YES
FIND6:	AOS 1,0(PP)
	JRST FIND1

FIND2:	HRRZ 3,-1(PP)
	CAIG 3,1		;ONLY ONE CHUNK?
	JRST FINDG		;YES - DONE
	MOVEI 2,-2(PP)		;NO
	HRLI 3,0(3)
	SUB 2,3
	MOVE 1,0(1)
FIND3:	MOVE 4,0(2)		;STACK CHUNKS FOR NEXT CALL
	CAME 4,1		;SKIP THE CURRENT ONE
	PUSH PP,4
	AOBJN 2,FIND3
	MOVE 4,0(2)
	HLLZ 1,1
	SUB 4,1		;UPDATE REM,,HOLE PTR
	PUSH PP,4		;STACK IT
	MOVEI 3,-1(3)
	PUSH PP,3
	MOVEI 2,-1(PP)
	SUB 2,3
	PUSH PP,2
	PUSHJ GP,FIND		;GO ROUND AGIN
	 JRST FIND6		;FAILURE - TRY NEXT ALT.
FINDG:	AOS 0(GP)		;GOOD RETURN - SKIP
	HRRZ 1,0(PP)
	MOVN 1,0(1)
	TRC 1,-1
	MOVE 2,-2(PP)		;REM,,
	MOVE 3,0(2)		;SIZE,,FIRST HOLE PAGE
	HLRZ 2,2		;REM
	SUBM 3,2		;SIZE,,PG-REM
	HLRZ 3,3		;SIZE
	ADDI 2,-1(3)
	HLL 2,1
	HRLZ 3,ADJT
	CAIN B,1(1)
	ADD 2,3
	MOVSI 3,RPGBIT
FIND7:	AOBJP 1,FINDB
	AOBJP 2,FIND9
	MOVEI 5,0(1)
	CAIN 5,0(2)
	JRST FIND7		;GOING WHERE IT IS
	DPB 2,CHGPTP
FIND9:	IORM 3,BTT(2)
	JRST FIND7


FIND4:	HRRZ 1,-2(PP)		;TRY NEXT HOLE
	HRRZ 4,0(NP)
	CAIN 1,0(4)
	JRST FINDB		;NO MORE HOLES - RETURN BAD
	ADDI 1,1		;NEXT HOLE
	HLL 1,0(1)		;LENGTH
	HRRZ 3,-1(PP)
	MOVEI 2,-2(PP)
	MOVEM 1,-2(PP)
	SUB 2,3
	MOVEM 2,0(PP)
	JRST FIND

FINDB:	HRRZ 3,-1(PP)
	SUB PP,BHC+3(3)
	POPJ GP,

U ADJT	;TEMPORARY
CHGPTP:	POINT 9,BTT(1),8
;TRY TO FIND C(5) CONTIGUOUS EMPTY PAGES
; RETURN SKIPPING WITH FIRST PAGE IN 4 IF OK

MTPGXX:	MOVEI 5,1
MTPGSX:	HRRZ 4,SYSPGS		;ENTRY TO GET  PAGES ABOVE SYSTEM
	HRLI 4,0(4)
	ADD 4,BGNPAG
	JUMPL 4,MTPGS2
	JRST MTPGS7
MTPG:	MOVEI 5,1	;ENTRY TO GET 1 PAGE
MTPGS:	MOVE 4,BGNPAG
MTPGS2:	HRRZ 2,TYPTAB(4)
	TRNN 2,77
	JRST MTPGS1
MTPGS6:	AOBJN 4,MTPGS2
MTPGS7:	MOVEI 4,-1(4)	;NONE IN ASSIGNED CORE
	PUSHJ GP,MTPA	;TRY FOLLOWING ASSIGNED CORE
	 POPJ GP,
	MOVEI 4,1(4)
	JRST RSKIP

MTPGS1:	PUSH GP,5	;FOUND AN EMPTY PAGE
	SOJE 5,MTPGS4
	PUSHJ GP,MTPA	;LOOK FOR N-1 AFTER IT
	 JRST MTPGS3
MTPGS4:	POP GP,5
	MOVEI 1,77	;SUCCESS, RESERVE FIRST PAGE FOUND
	MOVEM 1,TYPTAB(4)
	MOVEI 4,0(4)	;CLEAR LEFT
	JRST RSKIP
MTPGS3:	POP GP,5
	JRST MTPGS6

;FIND C(5) CONTIGUOUS EMPTY PAGES FOLLOWING PAGE IN 4
;IF SUCCESSFUL RESERVE PAGES AND SKIP

MTPA:	MOVEI 2,0(4)
	ADDI 2,0(5)
	CAIL 2,NPM
	POPJ GP,	;WILL EXCEED MAX CORE
	MOVE 2,ENDCOR
	LSH 2,-LPS
	MOVEI 3,0(4)
MTPA1:	ADDI 3,1
	CAIL 3,0(2)
	JRST MTPA2
	HRRZ 1,TYPTAB(3)
	TRNE 1,77
	POPJ GP,
	SOJG 5,MTPA1
MTPA3:	MOVEI 1,77
	CAIG 3,0(4)
	JRST RSKIP
	MOVEM 1,TYPTAB(3)
	SOJA 3,.-3
MTPA2:	PUSHJ CP,GETPG
	 POPJ GP,
	HRLZI 1,-1
	ADDM 1,BGNPAG
	SOJE 5,MTPA3
	ADDI 3,1
	JRST MTPA2

;GENERAL CHASE

CHAS:	MOVEI 2,0(1)
	LSH 2,-LPS		;GET PAGE
	MOVE 2,TYPTAB(2)
	TRNE 2,SYSBIT		;SHARED?
CHASR:	POPJ GP,		;YES - DONT CHASE
	ANDI 2,77		;GET TYPE
	HRRZ 2,TYPBLK(2)	;GET TYPBLK ENTRY
	JUMPE 2,CHASR		;NONE - DONT CHASE
	JRST @TCHAS(2)		;CALL CHASE ROUTINE FOR TYPE



; CHASE LIST , CHECK	IF MARKED, IF	SO QUIT
; ... IF NOT , MARK AND CHASE
;PTR IN 1

CHASLS:	PUSH GP,1
	ROT 1,-LPS
	HRRZ 2,BTT(1)		;ADDR OF BIT TABLE
	HRRI 1,0
	ROT 1,LPS-5		;REL WORD IN BIT TABLE
	ADDI 2,0(1)	;ABSL WORD	IN BIT	TABEL
	HRRI 1,0
	ROT 1,5		;GET BIT NUMBER BACK
	MOVE 1,GCBITS(1)	;GET THE BIT
	TDOE 1,0(2)
	JRST CL1	;ALREADY SET
	MOVEM	1,0(2)	;NOT SET, PUT IT IN
	AOS NLISTW
	CARA 1,0(GP)
	PUSHJ GP,CHAS
	POP GP,1
	CDRA 1,1
	JRST CHAS

CL1:	POP GP,1
	POPJ GP,

GCBITS:	QQ==0
	REPEAT 40,<1B<QQ>
QQ==QQ+1
>
;MARK ARRAY AND CHASE POINTERS, ARRAY POINTER IN 1
;ARRAY OVERHEAD
;	REL LOC OF RELOC BITS,,LENGTH
;	G.C. POINTER,,REL LOC OF POINTERS

CHASAR:	PUSHJ GP,FBA		;GET BEGINNING OF ARRAY
	JUMPE 1,CHSARX		;NO SUCH ARRAY
	HLRZ 2,1(1)
	CAIN 2,0(1)
	POPJ GP,	;GC PTR=SELF, ALREDY DONE
	JUMPN 2,GCERR	;NOT ZERO,ARRAYS CONFUSED
	HRLM 1,1(1)	;SET GC PTR TO SELF
	HRRZ 2,0(1)	;COUNT ARRAY WORDS IN USE
	ADDM 2,NARRW
	SKIPG 0(1)		;HASH ARRAY?
	JRST CHASHA
	CALL SWP1AR
	 CALL CHLIST
CHSARX:	POPJ GP,

CHASHA:	CALL SWP1AR
	 CALL CHASH1
	POPJ GP,

GCERR:	TMSG GCEM1
	POPJ GP,

GCEM1:	SIXBIT @ARRAYS FOULED/@

CHASH1:	HLRZ 1,0(4)
	CAIG 1,1
	POPJ GP,		;ENTRY UNUSED
	LDT 2,1
	CAMN 2,ATOMT
	JRST CHASH5		;ATOMS STAY
	CAMN 2,SMALLT
	JRST CHASH4		;SMALL NUMBERS STAY
	PUSHJ GP,CKMARK		;OTHER TYPES STAY IF OTHER REFERENCES
	 POPJ GP,		;NOT MARKED
CHASH4:	HRRZ 1,0(4)		;MARKED - CHASE VALUE
	PUSHJ GP,CHAS
	POPJ GP,

CHASH5:	PUSHJ GP,CHAS
	JRST CHASH4

;CHASE WORD WITH PTRS IN BOTH HALVES - ADDR OF WORD IN 4

CHLIST:	HRRZ 1,0(4)
	PUSHJ GP,CHAS
	HLRZ 1,0(4)
	JUMPN 1,CHAS
	RET



;BIT TABLE LOOKUP
;GIVEN	PTR IN	1 RETURNS BIT	IN 1
;AND PTR TO WORD IN BIT TABLE IN 2

BTLU:	ROT 1,-LPS
	HRRZ 2,BTT(1)		;ADDR OF BIT TABLE
	HRRI 1,0
	ROT 1,LPS-5		;REL. WORD IN BIT TABLE
	ADDI 2,0(1)		;ABSL WORD	IN BIT	TABLE
	HRRI 1,0
	ROT 1,5			;BIT NUMBER
	MOVE 1,GCBITS(1)	;THE BIT
	POPJ GP,

;CHASE	NUMBERS

CHASFL:
CHASFX:	MOVEI 3,TNWD(2)
CHASNM:	PUSHJ	GP,BTLU
	TDOE 1,0(2)
	POPJ GP,
	AOS @3
	MOVEM	1,0(2)
	POPJ GP,


;CHASE	ATOMS

CHASAT:	MOVEI 3,0(1)
	PUSHJ GP,CKATM		;GET BITS
	TDOE 2,0(1)		;MARKED?
	POPJ GP,		;YES - RETURN
	MOVEM 2,0(1)		;NO - MARK IT
	AOS NATM		;COUNT IT
	HLRZ 1,1
	SUBM 3,1		;NORMALIZE ORIG. PTR
CHSAT1:	PUSH GP,1		;ENTRY FROM SHARE SCAN
	CARA 1,1
	PUSHJ GP,CHAS
CA2:	HRRZ 1,0(GP)
	HRRZ 1,1(1)		;CHASE FN
	PUSHJ GP,CHAS
	HRRZ 1,0(GP)
	HLRZ 1,2(1)		;CHASE PNAME
	PUSHJ GP,CHAS
	POP GP,1
	CDRA 1,1		;CHASE CDR AND RETURN
	JRST CHAS

;CHECK IF ATOM MARKED,
; ENTER WITH PTR IN 1
;RETURN BIT WORD IN 1, THE BIT IN 2

CKATM:	MOVEI 2,0(1)
	LSH   2,-LPS
	PUSH GP,BTT(2)		;BIT TABLE ADDR FOR PAGE
	ANDI 1,MPS
	IDIVI 1,3
	HRLM 2,0(GP)		;SAVE REMAINDER TO ADJUST ORIG. PTR
	LSHC 1,-5
	ADDM 1,0(GP)
	ROT 2,5
	MOVE 2,GCBITS(2)	;THE BIT
	POP GP,1		;REMAINDER,,ADDR OF BITS
	POPJ GP,

;
;MARK PNAME, USES 35TH BIT
; A WORD IS MARKED IF ANY PART OF IT IS USED
;ASSUME  PNAME PAGES ARE CONTIGUOUS 
;AND PNAMES FREELY OVERLAP PAGE BOUNDARIES
;ENTER	WITH POINTER IN 1

MARKPN:	MOVE 3,GCTYP
	CAME 3,PNAMT
	POPJ GP,	;DONT MARK IF NOT COLLECTING PNAMES
	HLRZ 2,0(1)
	LSH 2,-13	;GET NO OF	CHARS FROM FIRST BYTE
	AOJA 2,MAST3	;IF COUNT DOESNT INCLUDE ITSELF

;CHASE STRING POINTER

CHASSP:	PUSH GP,1
	PUSHJ GP,BTLU
	TDOE 1,0(2)
	JRST CL1		;ALREADY MARKED
	AOS NSTPTW		;NOT MARKED, COUNT
	MOVEM 1,0(2)		;MARK
	POP GP,1
	MOVE 1,0(1)		;GET STRING POINTER
MARKST:	MOVE 2,GCTYP		;MARK STRING
	CAMN 2,STRNGT
	JRST MAST2
	CAME 2,PNAMT
	POPJ GP,		;NOT COLLECTING STRINGS, DONT BOTHER
MAST2:	MOVE 3,1
	TLZ 1,777770
	IDIVI 1,5		;GET ADDRESS
	LSH 3,-^D21		;GET CHAR COUNT
	ADDI 2,0(3)		;+ INITIAL CHAR POS
	MOVEI 3,0(1)
	LSH 3,-LPS
	HRRZ 3,TYPTAB(3)
	TRNE 3,SYSBIT
	POPJ GP,		;DONT MARK ON SHARED PAGES
	ANDI 3,77		;CHECK TYPE
	CAME 3,GCTYP		;TYPE COLLECTING?
MASTX:	POPJ GP,		;NO - QUIT
MAST3:	HRRZ 3,TYPBLK(3)
	JUMPE 2,MASTX		;LENGTH 0, QUIT
MAST1:	HRL 1,0(1)
	TLOE 1,1		;MARKED?
	JRST .+3
	HLRM 1,0(1)		;NO - MARK BIT 35
	AOS TNWD(3)		;AND COUNT WORD ***FIX SO NOT NEEDED
	SUBI 2,5
	JUMPLE 2,MASTX
	AOJA 1,MAST1

;CHAS A HANDLE

CHASHD:	PUSH GP,1
	PUSHJ GP,BTLU		;CHECK IF HANDLE MARKED
	TDOE 1,0(2)
	JRST CHSHD1		;ALREADY MARKED
	MOVEM 1,0(2)		;MARK IT
	AOS NHDLW		;COUNT IT
	POP GP,1
CHSHD2:	TLOE F,HDLFLG		;IN A HANDLE CHASE?
	RET			;YES - QUIT
	MOVSI 2,HDLCHS		;NO - MARK HANDLE AS CHASED
	IORM 2,0(1)
	HRLI BR,(1)		;SAVE BOXED HANDLE IN LH OF BR
	MOVE 1,0(1)		;GET HANDLE
	CALL GFRKB		;GET BITS FOR PAGE
	TRNE 2,FSYSBT		;ARRAY SYSTEM?
	JRST CHSHD3		;YES - QUIT
	CALL SWAPIN		;RH OF BR GETS BUFFADR OF BLOCK.
	HRRZI 1,(BR)		;OTHER AC'S PRESERVED.
	CALL SWP1AR		;FIND ALL PTR WORDS IN THE ARRAY
	 CALL CHLIST		;AND CHASE EM
CHSHD3:	TLZ F,HDLFLG
	RET

CHSHD1:	POP GP,1
	MOVE 2,0(1)
	TLNE 2,HDLCHS	;CHASED?
	RET			;YES - QUIT
	JRST CHSHD2		;NO - TRY

;CHASE A USER DATA TYPE
;POINTER IN 1

UCHAS:	MOVEM	1,UCHSTM	;SAVE FOR WHEN WE NORMALIZE
	PUSHJ	GP,UGTBIT	;GET BITS
	TDOE	2,0(1)		;MARKED?
	POPJ	GP,		;YES - RETURN
	MOVEM	2,0(1)		;NO - MARK IT
	HLRZ	1,1
	EXCH	1,UCHSTM	;NORMALIZE
	SUB	1,UCHSTM
	HRRZ	2,TYPBLK(3)
	AOS	TNWD(2)
	HRRZ	3,TYPSIZ(3)
	PUSH	GP,3		;SAVE NUMBER OF BOXED ITEMS
UCHAS2:	SOSGE	0(GP)		;DECREMENT COUNT, DONE?
	JRST	UCHAS3		;YES
	PUSH	GP,1		;SAVE POINTER
	CDRA	1,1		;CHASE CDR
	PUSHJ	GP,CHAS
	CARA	1,0(GP)		;CHASE CAR
	SOSL	-1(GP)		;DECREMENT COUNT, DONT CHASE IF DONE
	PUSHJ	GP,CHAS
	POP	GP,1
	AOJA	1,UCHAS2	;BUMP THE POINTER AND LOOP
UCHAS3:	SUB	GP,BHC+1	;"POP" JUNK
	POPJ	GP,

U UCHSTM	;JUST A TEMP FOR NORMALIZING.

;"GET BIT" FOR A USER DATA TYPE
;PTR IN 1
;RETURNS BIT WORD IN 1, BIT IN 2, TYPE IN 3

UGTBIT:	MOVEI	2,0(1)		;COMPUTE TYPE NUMBER
	LSH	2,-LPS
	MOVE	3,TYPTAB(2)
	ANDI	3,77
	PUSH	GP,BTT(2)	;BIT TABLE ADDR FOR PAGE
	ANDI	1,MPS
	HRRZ	2,TYPBLK(3)
	HLRZ	2,TSIZ(2)	;GET SIZE
	IDIV	1,2		;DIVIDE BY SIZE

	HRLM	2,0(GP)		;SAVE THE REMAINDER TO ADJUST ORIG. PTR
	LSHC	1,-5
	ADDM	1,0(GP)
	ROT	2,5
	MOVE	2,GCBITS(2)	;THE BIT
	POP	GP,1		;REMAINDER,,ADDR OF BITS
	POPJ	GP,

;SCAN FOR HASH ARRAYS - ROUTINE TO XCT FOR EACH ENTRY FOLLOWS CALL

SCNHA:	MOVE 5,ARRAYT
	MOVE 5,TYPBLK(5)
	HRRZ 4,TFRE(5)
	MOVEM 4,SCNEND
	HRRZ 4,TBGN(5)
SCNHA3:	CAML 4,SCNEND
	JRST RSKP
	SKIPL 3,0(4)
	JRST SCNHA2		;NOT HASH ARRAY
	HLRZ 2,1(4)
	JUMPE 2,SCNHA2		;ARRAY NOT USED
	MOVNI 3,-2(3)
	HRLI 3,0(3)
	HRRI 3,2(4)
SCNHA1:	HLRZ 1,0(3)
	CAILE 1,1		;CHECK FOR UNUSED ENTRY
	XCT @0(GP)		;CALL ROUTINE - ARRAY 4,ELT 3, LEFT 1
	AOBJN 3,SCNHA1
	MOVEI 4,0(3)
	JRST SCNHA3

SCNHA2:	ADDI 4,0(3)
	JRST SCNHA3

U SCNEND


;FANCY HASH CHASE

HSHCH:	PUSHJ GP,CKMARK		;PTR MARKED?
	 JRST HSHCHR		;NO DONT BOTHE WITH VAL
	HRRZ 1,0(3)		;YES
	PUSHJ GP,CKMARK		;IS VAL ALREADY MARKED?
	 JRST .+2
	JRST HSHCHR		;YES - NOTHING TO DO
	TLO F,GCF		;NO - SET FLAG
	PUSH GP,3
	HRRZ 1,0(3)		;AND CHASE IT
	PUSHJ GP,CHAS
	POP GP,3
HSHCHR:	POPJ GP,

HSHREC:	PUSHJ GP,CKMARK
	JRST .+2
	JRST HSHCHR
	MOVSI 1,1		;ENTRY UNESED - DELETE IT
	MOVEM 1,0(3)
	ADDM 1,0(4)
	POPJ GP,


;ROUTINES TO CHECK IF VARIOUS TYPES MARKED
;THESE ARE ONLY USED BY HASH ARRAY SONG AND DANCE

CKMARK:	MOVEI 2,0(1)
	LSH 2,-11
	HRRZ 2,TYPTAB(2)
	TRNE 2,SYSBIT
	JRST CKSKP
	ANDI 2,77
	HRRZ 2,TYPBLK(2)
	JUMPE 2,CKSKP		;NON EXISTENT TYPES(SMALL)ALWAYS MARKED
	JRST @TCKM(2)

CKBIT:	PUSHJ GP,BTLU
	TDNE 1,0(2)
CKSKP:	AOS 0(GP)
	POPJ GP,

CKAT:	PUSHJ GP,CKATM
	TDNE 2,0(1)
	AOS 0(GP)
	POPJ GP,

CKARR:	PUSH GP,3
	CALL FBA
	POP GP,3
	HLRZ 2,1(1)
	JUMPE 2,R
	JRST CKSKP

CKPN:	MOVE 2,0(1)
	TRNE 2,1
	AOS 0(GP)
	POPJ GP,

;GENERAL USER DATA TYPE

UCKMRK:	PUSH	GP,3		;SAVE AC3
	PUSHJ	GP,UGTBIT	;GET THE BIT
	POP	GP,3		;RESTORE AC 3
	TDNE	2,0(1)		;AND CHECK IT
	AOS	0(GP)
	POPJ	GP,

;SWEEP ALL PAGES OF FIXED SIZE, NON-CONTIGUOUS DATA TYPES
;LIST AND COUNT FREE ELEMENTS

SWPFIX:	MOVSI 2,-NTYPN
SWPFA:	HRRZ 1,TYPBLK(2)	;LOOK FOR NON-CONTIG. TYPES
	JUMPE 1,SWPFB		;IGNORE TYPES IF TYPBLK 0
	MOVE 3,TBITS(1)
	TRNE 3,BCONT
	JRST SWPFB		;CONTIGUOUS TYPE
	SETZM TFRE(1)		;FIXED TYPE - SET FREE PTR 0
	SETZM TNFR(1)		;SET FREE COUNT 0
SWPFB:	AOBJN 2,SWPFA
	MOVE 2,BGNPAG		;GO THRU ALL ASSIGNED PAGES
SWPF2:	HRRZ 10,TYPTAB(2)
	TRNE 10,SYSBIT
	JRST SWPF1		;DONT SWEEP SHARED PAGES
	ANDI 10,77		;GET TYPE
	HRRZ 7,TYPBLK(10)
	JUMPE 7,SWPF1		;TYPBLK 0 - IGNORE
	MOVE 1,TBITS(7)
	TRNE 1,BCONT
	JRST SWPF1
	CAMN 10,LISTT
	SETZM TFRE(7)
	PUSHJ GP,SWPPG		;CALL PAGE SWEEP
	CAME 10,LISTT		;EXTRA WORK FOR LISTS
	JRST SWPF1
	JUMPE 3,SWPL1		;FREE COUNT FOR PAGE 0 ?
	CAIE 3,1000		;OR FULL PAGE?
	JRST .+3
	SUBI 3,1		;ONLY HAVE ROOM FOR 9 BITS FREECOUNT
	SOS FRECNT
	ANDI 1,MPS		;LOW 9 BITS FREE PTR
	LSH 3,11
	IORI 3,0(1)
SWPL1:	HRLM 3,TYPTAB(2)	;SET LEFT HALF TYPTAB
SWPF1:	AOBJN 2,SWPF2
	MOVE 1,GCSTPT		;EXTRA STUFF FOR PTR TO NEW STRING
	MOVE 2,1		;CHECK FOR SPECIAL CASE
	TLZ 2,777770		;...NEW STRING, LENGTH 0
	IDIVI 2,5		;...AT END OF STORAGE
	CAMN 2,ENDSTR		;...ADDR IS OUTSIDE RANGE
	JRST SWPSP1
	PUSHJ CP,CHGSTR
SWPSP2:	MOVEM 1,GCSTPT
	POPJ GP,

SWPSP1:	SUBI 1,1		;FUDGE
	PUSHJ GP,CHGSTR
	ADDI 1,1
	JRST SWPSP2




;GENERAL SWEEP OF PAGE WITH FIXED SIZE ENTRIES AND BIT TABLE
;ENTER PAGE IN 2, TYPE IN 10
;RETURN NEW FREE POINTER IN 1 , PAGE IN 2, FREE COUNT THIS PAGE IN 3

SWPPG:	MOVE 7,TYPBLK(10)
	MOVE 6,[JRST SL2]
	TLNE F,GCMF+GCCF
	MOVE 6,TUDE(7)		;IF POINTERS NEED CHANGING
	MOVEM 6,SWPPJ		;SET SWPPJ TO UPDATE ROUTINE FOR TYPE
	HLRZ 5,TSIZ(7)
	MOVNI 3,NPS
	IDIVI 3,0(5)
	HRLI 5,101
	MOVE 7,TFRE(7)		;GET FREE POINTER

	PUSH GP,2
	MOVEI 4,0(2)
	LSH 4,LPS		;ADDR OF PAGE BEGINNING
	LSH	3,6		;LEAVE ROOM FOR 0-32 COUNTER
	HRLI 4,0(3)		;-NUMBER ENTRIEQ PER PAGE
	HRRZ 2,BTT(2)		;ADDR OF BIT TABLE FOR PAGE
	PUSH GP,2
	SETZ 3,
	SETZ 6,
SL1:	EXCH 6,@0(GP)		;PICK UP BITS AND CLEAR
SL4:	JUMPL 6,SWPPM		;DATUM MARKED
	AOJ 3,			;FREE - COUNT IT
	MOVEM 7,0(4)
	MOVEI 1,0(4)
	TLNE F,GCMF
	PUSHJ GP,CHGPT1
	MOVEI 7,0(1)
SL2:	LSH 6,1			;NEXT BIT
	ADD 4,5			;NEXT ENTRY
	JUMPGE 4,SWPP5		;END?
	TLZN	4,40		;NEXT BIT WORD?
	JRST SL4
	AOS 0(GP)
	JRST SL1

SWPPM:	XCT SWPPJ
	JRST SL2

U SWPPJ

SWPP5:	SUB GP,BHC+1
	MOVEI 1,0(7)
	MOVE 7,TYPBLK(10)
	MOVEM 1,TFRE(7)		;NEW FREE POINTER
	ADDM 3,TNFR(7)		;UPDATE FREECOUNT
	POP GP,2
	POPJ GP,

;SWEEPS OF SHARED PAGES THAT HAVE BECOME PRIVATE

;SWEEP SHARED ARRAY PAGE

SWPSAR:	PUSHJ GP,SCNSAR
	 PUSHJ GP,UDLIST
	POPJ GP,

;SWEEP SHARED LIST PAGE

SWPSL:	MOVEI 4,0(7)
	LSH 4,LPS
	HRLI 4,-NPS
	PUSHJ GP,UDLIST
	AOBJN 4,.-1
	POPJ GP,

;SWEEP SHARED ATOM PAGE

SWPSAT:	MOVEI 4,0(7)
	LSH 4,LPS
	HRLI 4,-NPS/3
	PUSHJ GP,UDATM
	ADDI 4,2
	AOBJN 4,.-2
	POPJ GP,

;SWEEP SHARED STRING POINTER PAGE

SWPSSP:	MOVEI 4,0(7)
	LSH 4,LPS
	HRLI 4,-NPS
	PUSHJ GP,UDSTPT
	AOBJN 4,.-1
	POPJ GP,

;SWEEP SHARED USER DATA TYPE PAGE

SWPSUS:	HRRZ	10,TYPTAB(7)	;GET TYPE NUBMER
	HRRZ	3,TYPBLK(10)
	HLRZ	3,TSIZ(3)	;GET SIZE OF ITEM
	PUSH	GP,3		;AND SAVE IT
	MOVEI	4,NPS
	IDIVI	4,0(3)		;COMPUTE NUMBER OF ITEMS/PAGE
	PUSH	GP,4		;AND SAVE IT
	MOVEI	4,0(7)
	LSH	4,LPS
SWUS2:	PUSH	GP,4
	PUSHJ	GP,UDUSER	;UPDATE ITEM
	POP	GP,4
	ADD	4,-1(GP)	;BUMP ADDRESS
	SOSLE	0(GP)		;DECREMENT COUNTER
	JRST	SWUS2		;AND LOOP
	SUB	GP,BHC+2	;POP OFF JUNK
	POPJ	GP,



;CHANGE POINTER IF ITS PAGE IS MOVING OR ITS TYPE IS COMPACTING OR BOTH
;ENTER AT CHGPT1 IF ONLY CONCERNED ABOUT PAGES MOVING
;POINTER IN 1 ON ENTRY AND EXIT

CHGPTR:	ROT 1,-LPS	;GET PAGE NUMBER
	TLNE F,GCCF	;IS SOMETHING COMPACTING??
	JRST CHGP2
CHGP3:	LDB 2,CHGPTP
	JUMPE 2,.+2
	HRRI 1,0(2)
CHGP4:	ROT 1,LPS
	POPJ GP,

CHGP2:	MOVE 2,TYPTAB(1)
	TRNE 2,SYSBIT
	JRST CHGP4
	ANDI 2,77
	CAME 2,CMPTYP
	JRST CHGP3
	ROT 1,LPS	;GET FULL POINTER BACK
	XCT CMPFN
CHGPT1:	ROT 1,-LPS	;NOW SEE IF NEW PAGE MOVES
	JRST CHGP3

;CHANGE POINTERS IN BOTH HALVES OF WORD IN 1 ON ENTRY AND EXIT

CHG2P:	PUSH GP,1
	HLRZ 1,1
	PUSHJ GP,CHGPTR
	EXCH 1,0(GP)
	HRRZI 1,0(1)
	PUSHJ GP,CHGPTR
	POP GP,2
	HRLI 1,0(2)
	POPJ GP,

;ROUTINES TO UPDATE POINTERS WITHIN VARIOUS DATA TYPES
;ADDRESS OF ELEMENT IN 4

;ATOMS
UDATM:	MOVE 1,0(4)
	PUSHJ GP,CHG2P
	MOVEM 1,0(4)
	HRRZ 1,1(4)
	PUSHJ GP,CHGPTR		;RIGHT HALF FUNCTION CELL
	HRRM 1,1(4)
	TLNE F,GCMF
	JRST UDA1		;PAGES SHUFFLING
	MOVE 2,PNAMT
	CAME 2,CMPTYP
	POPJ GP,
UDA1:	HLRZ 1,2(4)		;OR PNAMES COMPACTING
	PUSHJ GP,CHGPTR		;CHANGE PNAME POINTER
	HRLM 1,2(4)
	POPJ GP,

;LIST

UDLIST:	MOVE 1,0(4)
	PUSHJ GP,CHG2P
	MOVEM 1,0(4)
	POPJ GP,

;STRING POINTERS

UDSTPT:	MOVE 1,0(4)
	PUSHJ GP,CHGSTR
	MOVEM 1,0(4)
	POPJ GP,

;GENERAL USER DATA TYPES
;TYPE NUMBER IN 10

UDUSER:	PUSH	GP,3
	PUSH	GP,4
	HRRZ	3,TYPSIZ(10)	;GET NUMBER OF POINTER ITEMS
UDS2:	SOJL	3,UDS3		;DEC. COUNT, EXIT IF DONE
	CDRA	1,4		;UPDATE CDR
	PUSHJ	GP,CHGPTR
	HRLM	1,0(4)
	SOJL	3,UDS3		;DECREMENT COUNT AND EXIT IF DONE
	CARA	1,4		;UDPATE CAR
	PUSHJ	GP,CHGPTR
	HRRM	1,0(4)
	AOJA	4,UDS2		;BUMP ADDRESS AND LOOP
UDS3:	POP	GP,4
	POP	GP,3
	POPJ	GP,

;GO THRU ALL PNAMES,
;CONSTRUCT A LIST THRU THE HOLES, LEFT HALF
;NUM OF EMPTIES SO FAR, RIGHT HALF PTR TO NEXT HOLE
;ALSO PUT POINTER TO FIRST HOLE OF A PAGE IN BTT
;AND COUNT IN LEFT HALF TYPTAB


P==6
PLANPN:	MOVE 7,PNAMT
PLNPN1:	HRRZ 7,TYPBLK(7)
	MOVE 3,TBGN(7)		;FIRST PNAME WORD
	CAML 3,TEND(7)
	POPJ GP,		;NO PNAMES EXIST
	MOVEI 2,0(3)
	LSH 2,-LPS		;FIRST PAGE
	SETZ P,			;PTR TO LAST HOLE - INIT. 0
	MOVEI 10,-1(2)		;FLAG  = PAGE IF HOLE FOUND ON PAGE
	HRRZI 4,1
	HRRZI 5,SP7
SP6:	HLLOS BTT(2)		;-1 TO RIGHT BTT
SP3:	TDNN 4,0(3)		;CHECK BOTTOM BIT OF WORD
	JRST 0(5)		;NOT SET, HOLE BEGINNING OR CONTINUING
	ANDCAM 4,0(3)		;CLEAR MARK BIT
	HRRZI 5,SP7		;LOOKING FOR NEW HOLE
	AOJ 3,
SP8:	TRNE 3,MPS		;CHECK FOR END PAGE
	JRST SP3
	CAIE 10,0(2)		;ANY HOLES STARTED ON THIS PAGE?
	HLLM 3,TYPTAB(2)	;NO - PUT COUNT IN LEFT TYPTAB
	HRRZ 1,TEND(7)
	CAILE 1,0(3)		;END OF SPACE?
	AOJA 2,SP6		;NO, DO NEXT PAGE
	SKIPE P			;ANY HOLES AT ALL?
	HLLOM 3,0(P)		;YES - TERMINATE LIST
	HLRZ 3,3		;TOTAL EMPTY COUNT
	MOVNI 3,0(3)
	ADD 3,TEND(7)
	SUB 3,TBGN(7)
	MOVEM 3,TNWD(7)		;WORDS IN USE
	POPJ GP,
SP7:	JUMPE P,SP10		;FOUND HOLE - FIRST?
	MOVEM 3,0(P)		;NO - PUT COUNT,,HOLE PTR IN LAST
	CAIN 10,0(2)		;FIRST THIS PAGE?
	JRST SP9		;NO -
	SKIPA
SP10:	HRRM 3,BTT+1(10)	;ADDR FIRST HOLE TO BTT OF FIRST PAGE
	HLLM 3,TYPTAB(2)	;COUNT TO LEFT TYPTAB THIS PAGE
	HRRM 3,BTT(2)		;HOLE PTR TO BTT THIS PAGE
	MOVEI 10,0(2)		;FLAG HOLE SEEN THIS PAGE
SP9:	MOVEI 5,SP2		;LOOKING FOR END OF HOLE NOW
	MOVEI P,0(3)		;ADDR TO STORE NEXT COUNT,,HOLE-PTR
SP2:	AOBJP 3,SP8		;ALWAYS JUMPS

;SAME BUSINESS FOR STRINGS

PLNSTR:	MOVE 7,STRNGT
	JRST PLNPN1

;CHANGE A PNAME TO VALUE IT WILL HAVE
;AFTER PNAMES GET COMPACTED
;PTR IN 1 RETURN WITH NEW POINTER IN 1 
CHGPN:	MOVEI 2,0(1)
	LSH 2,-LPS
	HLL 2,TYPTAB(2)
	HRR 2,BTT(2)	;PTR TO NEXT HOLE
CP2:	CAIG 1,0(2)
	JRST CP1
	MOVE 2,0(2)
	JRST CP2
CP1:	HLRZ 2,2	;PTR < NEXT HOLE
	SUBI 1,0(2)	;SUBTRACT COUNT FROM POINTER
	POPJ GP,

;CHANGE A STRING POINTER
;POINTER IN 1 ON ENTRY AND EXIT

CHGSTR:	PUSH GP,1		;SAVE STRING LENGTH
	TLZ 1,777770
	IDIVI 1,5		;GET ADDRESS OF STRING
	HRRM 2,0(GP)		;SAVE CHAR POS
	PUSHJ GP,CHGPTR
	IMULI 1,5
	POP GP,2
	AND 2,[XWD 777770,7]
	ADD 1,2
	POPJ GP,

;SWEEP ATOM HASH TABLE - MARK DELETED ENTRIES AND UPDATE POINTERS

SWPATH:	HRRZ 3,ATOMHT
	HRRZ 4,@3		;LENGTH-1
	HRLI 3,4		;L-1(4)
SWA1:	HRRZ 1,@3
	JUMPE 1,SWA3		;UNUSED ENTRY
	MOVEI 1,-2(1)		;HASH ENTRY -2 IS ATOM POINTER
	MOVEI 2,0(1)
	LSH 2,-LPS
	HRRZ 2,TYPTAB(2)
	TRNE 2,SYSBIT
	JRST SWA3		;ON SHARED PAGE - STAYS
	PUSHJ GP,CKATM		;CHECK IF MARKED
	TDNE 2,0(1)
	JRST SWA4
	MOVSI 2,-1		;NOT MARKED - NO LONGER USED
	ADDM 2,@ATOMHT		;DECREMENT COUNT OF ATOMS IN USE
	MOVSI 2,1
	MOVEM 2,@3		;FLAG HASH ENTRY AS RECLAIMED
SWA3:	SOJG 4,SWA1
	POPJ GP,

SWA4:	HRRZ 1,@3		;USED - CHANGE POINTER
	PUSHJ GP,CHGPTR
	HRRM 1,@3
	JRST SWA3


;MOVE PNAMES, IF NOT MOVING JUST UPDATE BEG, END AND FREE POINTERS

P==1
LW==2
C==3
H==4
B==5

MOVSTR:	MOVE 1,STRNGT
	JRST MOVPN1

MOVPN:	MOVE 1,PNAMT
MOVPN1:	MOVE 7,TYPBLK(1)
	CAME 1,CMPTYP
	JRST UDSP
	HRRZ 1,TEND(7)		;COMPUTE # WORDS FREE
	SUB 1,TBGN(7)
	SUB 1,TNWD(7)
	JUMPE 1,UDSPE		;NONE JUST UPDATE POINTERS
	HRRZ P,TBGN(7)	;FIRST PNAME WORD
	LSH P,-LPS	;FIRST PAGE
	HRRZI C,0		;COUNT
	HRRZI H,BTT(P)		;ADDR OF PTR TO FIRST HOLE
	JRST MPN2
MPN1:	HLRZ C,0(H)	;TOTAL EMPTIES INCLUDING THIS HOLE
	HRRZI B,0(LW)	;OLD LAST WORD
	ADDI B,0(C)	;PLUS EMPTY COUNT
	HRLI B,0(B)	;IS NEW BEG FROM
	HRRI B,0(LW)	;OLD LAST WORD IS NEW BEG TO
MPN2:	HRRZ LW,0(H)	;NEXT HOLE
	CAIN LW,-1	;IF IT EXISTS
	JRST MPN3
	HRRZ H,0(H)
	JUMPE C,MPN1
	SUB LW,C	;- EMPTY COUNT, IS LAST WORD TO
	BLT B,-1(LW)
	JRST MPN1

MPN3:	HRRZ P,TEND(7)		;NO MORE HOLES
	SUB P,C		;MOVE LAST CHUNK
	CAIE P,0(B)	;IF ANYTHING TO MOVE
	BLT B,-1(P)
	HRLI P,0(P)		;CLEAR FROM END-COUNT
	ADDI P,1
	HRRZ LW,TEND(7)		;... THRU END -1
	CAILE LW,-1(P)
	SETZM -1(P)
	CAILE LW,0(P)
	BLT P,-1(LW)
	MOVE 1,TNWD(7)
	ADD 1,TBGN(7)
	HRRM 1,TFRE(7)		;UPDATE FREE TO ACCT FOR COMPACTING
UDSPE:	MOVE 2,NNP		;UPDATE END TO ACCT FOR EXPANSION
	LSH 2,LPS
	ADDM 2,TEND(7)
	ADDM 2,TNFR(7)
UDSP:	MOVE 1,TBGN(7)		;UPDATE BEG,END AND FREE POINTERS
	PUSHJ GP,CHGPT1		;... FOR ARRAYS AND PNAMES
	MOVEI 2,0(1)		;... ACCTS FOR PAGE SHUFFLING ONLY
	EXCH 1,TBGN(7)
	SUBI 2,0(1)
	ADDM 2,TFRE(7)
	ADDM 2,TEND(7)
	POPJ GP,


;MOVE ARRAYS (IF ARRAYS NOT MOVING, JUST CLEARS GC PTRS)

MOVARR:	MOVE 7,ARRAYT
	MOVE 7,TYPBLK(7)
	MOVE 4,TBGN(7)
MOVAR2:	CAML 4,TFRE(7)
	JRST MOVAR4
	HLRZ 1,1(4)		;GET GC POINTER - NEW LOC
	HRRZS 1(4)		;CLEAR IT
	MOVE 2,CMPTYP
	CAME 2,ARRAYT		;ARRAYS COMPACTING?
	JRST MOVAR6
	MOVEI 2,0(4)		;REMOVE ARRAY FROM BTT
	LSH 2,-LPS
	HRRZ 3,BTT(2)
	CAIN 3,0(4)
	HLLZS BTT(2)		;IF IT WAS THERE
	JUMPE 1,MOVAR3	;0 MEANS UNUSED
	MOVEI 2,0(1)		;PUT NEW LOC IN BTT
	LSH 2,-LPS
	HRRZ 3,BTT(2)
	CAIN 3,0
	HRRM 1,BTT(2)		;IF ENTRY IS 0
MOVAR6:	JUMPE 1,MOVAR3
	HLRE 5,0(4)		;RELOCATABLE?
	JUMPLE 5,MOVAR7
	TLNN F,GCMF+GCCF	;SHUFFLING OR COMPACTING?
	JRST MOVAR3		;NO - DONE
	PUSH GP,1
	PUSHJ GP,CHGPT1		;... GET FINAL NEW LOC
	MOVEI 2,0(1)
	MOVEI 1,0(4)
	SUBI 2,0(4)		;RELOC FACTOR
	JUMPE 2,MOVAR8
	PUSH GP,7
	PUSH GP,4
	CALL RELI		;RELOCATE
	POP GP,4
	POP GP,7
MOVAR8:	POP GP,1
MOVAR7:	CAIN 1,0(4)		;OLD LOC=COMPACTED LOC?
	JRST MOVAR3		;YES - DONE
	HRLI 1,0(4)
	MOVEI 3,-1(1)
	ADD 3,@4
	ADD 4,@4
	BLT 1,0(3)		;MOVE IT
	JRST MOVAR3+1
MOVAR3:	ADD 4,@4
	HRRZI 4,0(4)	;CLEAR LEFT
	JRST MOVAR2

MOVAR4:	MOVE 1,CMPTYP
	CAME 1,ARRAYT
	JRST UDSP
	MOVE 1,TBGN(7)	;CLEAR EMPTY REGION
	ADD 1,TNWD(7)
	MOVEM 1,TFRE(7)		;UPDATE FREE TO ACCT FOR COMPACTING
	CAML 1,TEND(7)
	JRST UDSPE		;NOTHING TO CLEAR
	SETZM 0(1)
	HRLI 1,0(1)
	ADDI 1,1
	MOVE 2,TEND(7)
	CAILE 2,1(1)
	BLT 1,-1(2)
	JRST UDSPE
;DECIDE WHERE ARRAYS WILL MOVE TO

PLANAR:	MOVE 7,ARRAYT
	MOVE 7,TYPBLK(7)
	MOVE 2,TBGN(7)
	MOVEI 3,0(2)	;DESTINATION
PLNAR2:	CAML 2,TFRE(7)
	POPJ GP,
	HRRZ 4,0(2)	;GET LENGTH
	JUMPLE 4,GCERR		;LENGTH INSANE
	HLRZ 1,1(2)	;GET GC POINTER
	JUMPE 1,PLNAR3	;UNUSED
	CAIE 1,0(2)
	JRST GCERR		;ARRAYS FOULED
	HRLM 3,1(2)
	ADDI 3,0(4)	;INCREASE DESTINATION
PLNAR3:	ADDI 2,0(4)
	JRST PLNAR2

;CHANGE ARRAY POINTER

CHGARR:	PUSH GP,1
	PUSHJ GP,FBA		;FIND BEGINNING
	HLRZ 2,1(1)		;NEW BEGINNING
	SUBI 2,0(1)
	POP GP,1
	ADD 1,2
	POPJ GP,


;CHANGE POINTERS IN ARRAYS IF NECESSARY

SWPARR:	TLNN F,GCPF
	POPJ GP,
	MOVE 5,ARRAYT
	MOVE 5,TYPBLK(5)
	MOVE 4,TBGN(5)
SWPAR2:	CAML 4,TFRE(5)
	POPJ GP,
	MOVEI 1,0(4)	;ARRAY POINTER
	MOVE 2,1(1)	;GC PTR,,REL.LOC.POINTERS
	TLZN 2,-1
	JRST SWPAR3	;UNUSED
	PUSHJ GP,SWP1AR		;FIND PTR WORDS IN ARRAY
	 PUSHJ GP,UDLIST	;AND UPDATE
SWPAR3:	SKIPL 0(4)
	JRST SWPAR4
	PUSH GP,4		;HASH  ARRAY GOTTA BE REEHASHED
	PUSH GP,5
	MOVEI 1,0(4)
	CALL REHSHG
	POP GP,5
	POP GP,4
SWPAR4:	HRRZ 2,0(4)
	ADDI 4,0(2)
	JRST SWPAR2

;FIND POINTERS IN SINGLE ARRAY - ADDR OF ARRAY IN 1
;INSTR FOLLOWING CALL XCT'D FOR EACH PTR WORD - ADDR IN 4

SWP1AR:	PUSH GP,4		;PRESERVE 4
	MOVEI 4,0(1)
	HRRZ 1,1(4)
	HLRE 2,0(4)	;REL.LOC.RELOCATION BITS
	JUMPG 2,.+2	;IF GREATER ZERO
	HRRZ 2,0(4)	;ELSE LENGTH
	ADDI 4,0(1)	;BEG OF POINTERS
	SUBI 1,0(2)	;REL.LOC. POINTERS-LENGTH
	JUMPE 1,SWP1AX	;NO POINTERS
	HRLI 4,0(1)	;IS -# OF POINTERS
SWPAR1:	XCT @ -1(GP)
	AOBJN 4,SWPAR1
SWP1AX:	POP GP,4
	AOS 0(GP)
	RET


;FIND HANDLE PAGES - CALL ROUTINE WITHE TYPTAB IN 3, PAGE IN 4

HDLPG:	MOVE 4,BGNPAG
HDLPG1:	HRRZ 3,TYPTAB(4)
	ANDI 3,77
	CAME 3,HANDLT
	JRST HDLPG2
	HRRZ 3,TYPTAB(4)
	PUSH GP,4
	XCT @-1(GP)
	POP GP,4
HDLPG2:	AOBJN 4,HDLPG1
	AOS 0(GP)
	RET


;GIVEN PAGE OF HANDLES, CHASE ALL PTRS ON SYS/PVT PAGES

SHRSHC:	MOVEI 2,CHLIST	;CHASE PTRS IN SYS/PVT PAGES OF SHADOW
	JRST SYSHDA

;UPDATE PTRS IN SYS/PVT SHADOW ARRAYS GIVEN HANDLE PAGE

SWPHDA:	MOVEI 2,UDLIST
;GIVEN PAGE OF HANDLES, CALL C(2) FOR EACH PTR IN SYS/PVT SHADOW

SYSHDA:	MOVEM 2,SYSHDR
	TRNN 3,SYSBIT		;IS HANDLE PAGE SYSTEM?
	RET		;NO - ASSUME CANT REF. SYS ARRAYS
	MOVEI 5,0(4)
	LSH 5,LPS
	HRLI 5,-NPS
SYSHD1:	MOVE 1,0(5)		;GO THRU HANDLES
	TLNN 1,-1
	JRST SYSHD2		;NOT REASONABLE HANDLE
	PUSH GP,5
	HRLI BR,(5)		;RETRIEVE THE (BOXED) HANDLE.
	CALL SCNSSA
	 PUSHJ GP,@SYSHDR
	POP GP,5
SYSHD2:	AOBJN 5,SYSHD1
	RET
U SYSHDR



;SCAN SYSTEM SHADOW ARRAYS, GIVEN UNBOXED HANDLE OF ARRAY IN 1
;ALSO BOXED HANDLE IN LH OF BR TO GIVE TO SWAPIN.
;FIND ALL POINTERS ON PAGES MADE PRIVATE, XCT FOLLOWING INST.
;WITH ADDR OF PTR WORD IN 4

SCNSSA:	MOVE 4,1		;HANDLE
	LDB 3,[POINT 9,4,8]	;GET # PAGES SPANNED??
SCNSS1:	CALL GFRKB
	TRNN 2,FSYSBT
	JRST .+3		;SHOULDNT BE REFS TO NON SYS PGS.
	TRNE 2,FPVTBT
	JRST SCNSS2
	ADDI 1,NPS
	SOJG 3,SCNSS1
	JRST SCNSSX		;NO PVT PAGES IN ARRAY

SCNSS2:	PUSH GP,4		;HANDLE
	PUSH GP,1		;ADDR OF FIRST PVT FORK PAGE
	MOVE 1,4
	TLO F,HDLFLG		;PREVENT RECURSION IN HANDLE CHASE
	CALL SWAPIN
	HRRZI 1,(BR)		;ADDRESS IN BUFFER WHERE IT GOT PUT.
	HLRE 6,0(1)		;GET END PTRS
	JUMPG 6,.+2
	HRRZ 6,0(1)
	JUMPLE 6,SCNSS7		;NO GOOD ARRAY
	ADDI 6,0(1)		;ADDR END PTRS IN CORE
	HRRZ 4,1(1)
	ADDM 4,-1(GP)		;ADDR BEG PTRS IN FORK
	ADDI 4,0(1)		;ADDR BEG PTRS IN CORE
	POP GP,5
	TRZ 5,777
SCNSS6:	MOVE 1,0(GP)
	CAMLE 5,1
	JRST SCNSS3		;IGNORE INITIAL NONPVT PAGES
	CALL GFRKB
	TRNN 2,FPVTBT
	JRST SCNSS3		;@AGE NOT PVT
	MOVEI 7,NPS(4)		;IS PVT
	TRZ 7,777
	CAIL 7,0(6)		;END PG PAST END PTRS?
	MOVEI 7,0(6)		;YES - QUIT AT END PTRS
SCNSS4:	CAIL 4,0(7)
	JRST SCNSS5
	XCT @-1(GP)
	AOJA 4,SCNSS4

SCNSS3:	ADDI 4,NPS		;STEP TO NEXT PAGE
	TRZ 4,777
SCNSS5:	MOVEI 1,NPS
	ADDM 1,0(GP)
	CAIGE 4,0(6)
	JRST SCNSS6
	TLZ F,HDLFLG
	SUB GP,BHC+1
SCNSSX:	AOS 0(GP)
	RET

SCNSS7:	SUB GP,BHC+2
	JRST SCNSSX


;GIVEN HANDLE PAGE SWEEP NON-SYSS SHADOW ARRAYS

SWPUHD:	MOVE 1,[PUSHJ GP,HDCHP]
	MOVE 2,[PUSHJ GP,CHLIST]
	JRST SWPUSA

;UPDATE PTRS IN NON-SYS SHADOW ARRAYS

SWPHDB:	MOVSI 1,(SKIPA)
	MOVE 2,[PUSHJ GP,UDLIST]
	JRST SWPUSA

HDCHP:	TLOE 1,HDLCHS
	RET			;ALREDY CHASED - IGNORE
	MOVEM 1,0(5)		;MARK IT
	AOS 0(GP)
	RET

;SWEEP OF NON-SYSTEM SHADOW ARRAYS
;GIVEN HANDLE PAGE IN 4, TYPTAB FOR PG IN 4
;CALL FOR HANDLE CHECK IN 1, CALL FOR WHAT TO DO TO  PTRS IN 2

SWPUSA:	TRNE 3,SYSBIT
	RET			;IGNORE SYSTEM HANDLES
	PUSH GP,1
	MOVEM 2,SWPUSR
	MOVEI 5,0(4)
	LSH 5,LPS
	HRLI 5,-NPS
SWPUS3:	MOVEI 1,0(5)
	CALL CKBIT
	 JRST SWPUSN		;HANDLE NOT USED
	MOVE 1,0(5)
	TLNN 1,-1
	JRST SWPUSN		;HANDLE NONESENSE
	CALL GFRKB
	TRNE 2,FSYSBT
	JRST SWPUSN		;IGNORE SYSTEM ARRAYS - SHOULD BE NONE
	XCT 0(GP)		;SKIP IF HANDLE WANTED
	JRST SWPUSN
	PUSH GP,5
	PUSH GP,3
	TLO F,GCF+HDLFLG
	HRLI BR,(5)
	CALL SWAPIN
	HRRZI 1,(BR)
	PUSHJ GP,SWP1AR
	XCT SWPUSR
	TLZ F,HDLFLG
	POP GP,3
	POP GP,5
SWPUSN:	AOBJN 5,SWPUS3
	SUB GP,BHC+1
	RET

U SWPUSR

FSYSBT==1
FPVTBT==2		;BITS IN FORK SYSBIT TABLES

;GIVEN FORK#,,ADDR IN 1, GET BITS IN 2 (PRESERVE 1)
;NOTE THAT'S A FORK NUMBER, NOT A HANDLE BUT A SWFRKS TABLE INDEX

GFRKB:	PUSH GP,1
	HLRZ 2,1
	ANDI 2,MFRKS
	MOVEI 1,0(1)
	LSH 1,-LPS
	HRRZ 2,FORKT(2)
	ROT 1,-4
	ADDI 2,0(1)
	HRRI 1,0
	ROT 1,5
	MOVE 2,0(2)
	ROT 2,2(1)
	ANDI 2,3
	POP GP,1
	RET

;GIVEN FORK#,,PAGE IN 1 BITS IN LOW 2
;SET FORK BITS (PRESERVE 1)  ... THIS IS USED BY WTRP

SFRKB:	PUSH GP,1
	PUSH GP,3
	HLRZ 3,1
	MOVEI 1,0(1)
	HRRZ 3,FORKT(3)
	ROT 1,-4
	ADDI 3,0(1)
	HRRI 1,0
	ROT 1,5
	MOVNI 1,2(1)
	ROT 2,0(1)
	IORM 2,0(3)
	POP GP,3
	POP GP,1
	RET

U FORKT,NFRKS		;CONTAINS ADDR OF BITS FOR FORK PGS
			;REMEMBER TO SET THIS UP AND PUT BITS
			;ON WRITABLE PAGES!!!!!


;CLEAR CHASED BITS FROM HANDLES

HDLCLR:	TRNE 3,SYSBIT		;NON-SYS PAGES ONLY
	RET
	MOVEI 5,0(4)
	LSH 5,LPS
	HRLI 5,-NPS
	MOVSI 2,HDLCHS
	ANDCAM 2,0(5)
	AOBJN 5,.-1
	RET


;GRAB AN UNASSIGNED PAGE
;AND N WORDS OF BIT TABLE--N IN AC1
;RETURN PAGE NUMBER IN 4
;SKIP IF SUCCESSFUL IN FINDING A PAGE

U FREEBT	;NEXT FREE WORD OF BIT TABLE STORAGE
U ENDBT		;LAST FREE WORD OF BIT TABLES

MTPGB:	PUSH GP,1
	PUSHJ GP,MTPG
	 JRST MTPGR
MTPGB2:	MOVE 1,FREEBT
	ADD 1,0(GP)
	CAMLE 1,ENDBT
	JRST MTPGB1	;NEED A NEW BIT TABLE PAGE
	EXCH 1,FREEBT
	MOVEM 1,BTT(4)
	AOS -1(GP)	;RETURN SKIPPING
MTPGR:	SUB GP,BHC+1	;POP
	POPJ GP,

MTPGB1:	PUSH GP,4	;SAVE FIRST PAGE FOUND
	PUSHJ GP,MTPG
	 JRST MTPGB3
	MOVE 1,BTABT
	MOVEM 1,TYPTAB(4)
	MOVEI 1,0(4)
	LSH 4,LPS
	MOVEM 4,FREEBT
	ADDI 4,NPS
	MOVEM 4,ENDBT
	PUSHJ GP,CLRPG
	POP GP,4
	JRST MTPGB2

MTPGB3:	POP GP,4	;NO PAGE FOR BITTABLE 
	SETZM TYPTAB(4)	;,RELEASE PAGE PREVIOUSLY CLAIMED
	JRST MTPGR


;GET A NEW PAGE WITH BIT TABLE AND INITIALIZE TO FREE LIST
;ENTER WITH OLD FREE POINTER IN 1 AND NEW C(TYPTAB(PAGE)) IN 2
;RETURN WITH NEW FREE POINTER IN 1,2 UNCHANGED
;AND SKIP IF SUCCESSFUL

NEWPG:	MOVEI 3,1		;ONE WORD ENTRIES
NEWPGG:	PUSH GP,1		;ENTRY SIZE IN 3
	PUSH GP,2
	PUSH GP,3
	MOVEI 1,NPS
	IDIVI 1,0(3)
	ADDI 1,37
	LSH 1,-5		;NUMBER BIT TABLE WORDS
	PUSHJ GP,MTPGB
	 JRST NEWPF
	POP GP,3
	POP GP,2
	MOVEM 2,TYPTAB(4)
	POP GP,1
	AOS 0(GP)	;SET TO SKIP
FREPG:	LSH 4,LPS	;MAKE FREELIST
	MOVEI 5,NPS(4)	;PAGE IN 4
	HRLI 4,3	;ENTRY SIZE IN 3
	MOVNI 3,0(3)
	JRST .+ 2
FRE1:	HRRZM 4,@4
	SUB 4,3
	CAILE 5,0(4)
	JRST FRE1
	CAIE 5,0(4)
	ADD 4,3
	MOVEM 1,@4	;FREE POINTER IN 1
	MOVEI 1,-NPS(5)	;NEW FREEPOINTER TO 1
	POPJ GP,

NEWPF:	SUB GP,BHC+3
	POPJ GP,


;INITIALIZE TABLES AND STUFF FOR GC

GCI:	SETZM TYPBLK		;CLEAR TYPBLK
	HRLI 1,TYPBLK
	HRRI 1,TYPBLK+1
	BLT 1,TYPBLK+MTYPN
	SETZM BTT
	HRLI 1,BTT
	HRRI 1,BTT+1	;CLEAR BITTABLE TABLE
	BLT 1,BTT+NPM-1
	SETZM FREEBT	;SET AVAIL BIT TABLE STORAGE TO EMPTY
	SETZM ENDBT
	SETZM	IBOXCN
	SETZM	FBOXCN
	SETZM CNSCNT
	SETZM SYSPGS
	SETZM FORKBT		;CLEAR FORK BIT TABLES
	HRLI 1,FORKBT
	HRRI 1,FORKBT+1
	BLT 1,FORKBT+NFRKBT-1
	MOVEI 1,FORKBT		;SET UP PTRS TO TABLES
	MOVSI 2,-NFRKS		;NOTE ARE HAVIN FORK 0 WHICH IS A CROCK
	HRRZM 1,FORKT(2)
	ADDI 1,40
	AOBJN 2,.-2
	MOVEI 1,XTRATB
	MOVEM 1,FREETB
	ADDI 1,NTB
	MOVEM 1,ENDTB
 	MOVE 1,BGNCOR
	LSH 1,-LPS
	HRRM 1,BGNPAG
	MOVE 2,ENDCOR
	LSH 2,-LPS
	SUB 1,2
	HRLM 1,BGNPAG
	TYPSET ATOM
	TYPSET LIST
	TYPSET FLOAT
	TYPSET FIX
	TYPSET STPT
	TYPSET STRNG
	TYPSET ARRAY
	TYPSET PNAM
	TYPSET HANDL
GCIS:	SETZM NEWCNS
	MOVEI 4,MINWPP
	MOVEM 4,CMINWP
	HRRZ 4,BGNSTR
	HRLI 4,440700
	MOVEM 4,FREEST
	MOVE 4,ENDSTR
	SUB 4,BGNSTR
	IMULI 4,5
	MOVEM 4,NFRECH
	RET

	LIT		;GET THESE IN BEFORE BEGTMP!!!!!
GCIE:

NFRKBT==NFRKS*40		;FORK BIT TABLES - 2 BITS PER PAGE
U FORKBT,NFRKBT

;LAST PAGE

U ENDTMP		;END OF TEMP STORAGE

	END LISP0


