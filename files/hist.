(FILECREATED "20-OCT-74 02:54:36" HIST.;1 90391  

     changes to:  LISPXFIND LISPXFIND0 HISTFNS HISTBLOCKS

     previous date: "10-OCT-74 18:27:00" <LISP>HIST.;4)


  (LISPXPRINT (QUOTE HISTCOMS)
	      T T)
  [RPAQQ
    HISTCOMS
    ((FNS * HISTFNS)
     (VARS (LISPXBUFS)
	   (TOPLISPXBUFS)
	   (LISPXHIST)
	   (LISPXUSERFN)
	   (ARCHIVEFN)
	   (ARCHIVEFLG T)
	   [LISPXMACROS
	     (QUOTE ([??T (PROG (TEM)
				(RESETVAR PRETTYTRANFLG T
					  (PRINTDEF (COND ([NULL (CDAR (SETQ
									 TEM
									 (LISPXFIND
									   LISPXHISTORY 
									   LISPXLINE
									   (QUOTE ENTRY)
									   T]
							   (CAAR TEM))
							  (T (CAR TEM)))
						    NIL T))
				(TERPRI T)
				(RETURN (CADDR TEM]
		     (LISP (SUBSYS (QUOTE LISP)))
		     (EXEC (SUBSYS))
		     (SNDMSG (SUBSYS (QUOTE SNDMSG)))
		     [RETRIEVE (PROG ((X (GETP (CAR LISPXLINE)
					       (QUOTE *HISTORY*)))
				      REREADFLG)
				     (COND ((NULL X)
					    (ERROR (CAR LISPXLINE)
						   (QUOTE " ?")
						   T)))
				     [MAPC X (FUNCTION (LAMBDA (X)
							       (HISTORYSAVE LISPXHISTORY X]
				     (RETURN (CAR LISPXLINE]
		     (BEFORE (LISPXSTATE (CAR LISPXLINE)
					 (QUOTE BEFORE)))
		     (AFTER (LISPXSTATE (CAR LISPXLINE)
					(QUOTE AFTER)))
		     (SY (TENEX (QUOTE "SY
")))
		     [DIR (TENEX (COND ((NULL LISPXLINE)
					(QUOTE "DIR
"))
				       (T (SETQ LISPXLINE (MKSTRING LISPXLINE))
					  (GNC LISPXLINE)
					  (GLC LISPXLINE)
					  (CONCAT (QUOTE "DIR ")
						  LISPXLINE
						  (QUOTE "
"]
		     [OK (RETFROM (OR (STKPOS (QUOTE USEREXEC))
				      (QUOTE LISPX]
		     (CONTIN (SUBSYS T]
	   (LISPXHISTORYMACROS)
	   (LISPXCOMS (QUOTE (REDO RETRY FIX USE  ... UNDO ?? NAME RETRIEVE BEFORE AFTER 
				   TYPE-AHEAD ARCHIVE FORGET BUFS CONTIN ??T)))
	   (LISPXHISTORY (QUOTE (NIL 0 30 100)))
	   (ARCHIVELST (QUOTE (NIL 0 50 100)))
	   (EDITHISTORY (QUOTE (NIL 0 30 100)))
	   (SYSTATS (QUOTE ((LISPXSTATS LISPX INPUTS)
			    (UNDOSAVES UNDO SAVES)
			    (UNDOSTATS CHANGES UNDONE)
			    NIL
			    (EDITCALLS CALLS TO EDITOR)
			    (EDITSTATS EDIT COMMANDS)
			    (EDITUNDOSAVES EDIT UNDO SAVES)
			    (EDITUNDOSTATS EDIT CHANGES UNDONE)
			    NIL
			    (P.A.STATS P.A. COMMANDS)
			    NIL
			    (CLISPIFYSTATS CALLS TO CLISPIFY)
			    NIL
			    (FIXCALLS CALLS TO DWIM)
			    (FIXTIME)
			    (ERRORCALLS WERE DUE TO ERRORS)
			    (DWIMIFYFIXES WERE FROM DWIMIFYING)
			    NIL "OF THOSE DUE TO ERRORS:" (TYPEINFIXES WERE DUE TO ERRORS IN 
								       TYPE-IN)
			    (PROGFIXES WERE DUE TO ERRORS IN USER PROGRAMS)
			    (SUCCFIXES1 OF THESE CALLS WERE SUCCESSFUL)
			    NIL "OF THE CALLS DUE TO DWIMIFYING:" (SUCCFIXES2 WERE SUCCESSFUL)
			    NIL
			    (SPELLSTATS OF ALL DWIM CORRECTIONS WERE SPELLING CORRECTIONS)
			    (CLISPSTATS WERE CLISP TRANSFORMATIONS)
			    (INFIXSTATS OF THESE WERE INFIX TRANSFORMATIONS)
			    (IFSTATS WERE IF/THEN/ELSE STATEMENTS)
			    (I.S.STATS WERE ITERATIVE STATEMENTS)
			    (MATCHSTATS WERE PATTERN MATCHES)
			    (RECORDSTATS WERE RECORD OPERATIONS)
			    NIL
			    (SPELLSTATS1 OTHER SPELLING CORRECTIONS, E.G. EDIT COMMANDS)
			    NIL
			    (RUNONSTATS OF ALL SPELLING CORRECTIONS WERE RUN-ON CORRECTIONS)
			    NIL
			    (VETOSTATS CORRECTIONS WERE VETOED)
			    NIL)))
	   (GREETHIST)
	   (GREETCLK)
	   (CUTEFLG T)
	   GREETDATES
	   (GREETLST)
	   GREETIMES
	   (NEWUSERFLG)
	   (USERNAME)
	   (CONSOLETIME 0)
	   (CONSOLETIME0 0)
	   (CPUTIME 0)
	   (CPUTIME0 0)
	   (EDITIME 0)
	   (PROMPT#FLG)
	   (LISPXPRINTFLG T)
	   DUMPSTATSVARS USERNAMEFILE (FIRSTNAME)
	   (SYSOUTGAG))
     [P [MAPC (QUOTE (LISPXPRIN1 LISPXPRIN2 LISPXTERPRI LISPXSPACES LISPXTAB))
	      (FUNCTION (LAMBDA (X)
				(MOVD (QUOTE LISPXPRINT)
				      X]
	(MAPC SYSTATS (FUNCTION (LAMBDA (X)
					(AND (LISTP X)
					     (EQ (CAAR X)
						 (QUOTE NOBIND))
					     (RPLACA (CAR X)
						     NIL]
     (ADVISE SYSOUT MAKESYS)
     (BLOCKS * HISTBLOCKS)
     (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA ADDSTATS 
										  VALUEOF)
									   (NLAML]
  (RPAQQ HISTFNS
	 (EVALQT USEREXEC LISPXREAD LISPXREADP LISPXUNREAD LISPX LISPX/ LISPX/1 LISPXEVAL 
		 HISTORYSAVE LISPXFIND LISPXFIND0 LISPXFIND1 HISTORYFIND HISTORYFIND1 VALUEOF 
		 LISPXUSE LISPXUSE1 LISPXUSEC PRINTHISTORY ENTRY# PRINTHISTORY1 GREET GREET0 
		 GREET1 GREET2 GREET3 ADDSTATS CHANGESLICE LISPXSTATE LISPXTYPEAHEAD LISPXPRINT 
		 LISPXPUT))
(DEFINEQ

(EVALQT
  [LAMBDA (CHAR)
    (AND (NULL CHAR)
	 (SETQ CHAR (QUOTE _)))
    (PROG (TEM)
          (SETQ READBUF NIL)
          (AND GREETCLK (IGREATERP GREETCLK (SETQ GREETCLK (CLOCK 3)))
	       (LISPXEVAL (QUOTE (GREET))
			  (QUOTE _)))

          (* Check made here instead ofin GREET so that all of its 
          free variables dont have to be looked up each time we 
          reenter EVALQT, e.g. after a control-D.)


          (SETQ TOPLISPXBUFS (OR (CLBUFS T)
				 TOPLISPXBUFS))

          (* Don't want to do a CLEARBUF because user may have typed 
          ahead at EXEC level. If necessary, CLEARBUF will already 
          have been done by control-d control-e or ERROR! depending on 
          how user reached the top.)


          (COND
	    ((EQ CLEARSTKLST T)                 (* Follwoing control-d Do a 
                                                CLEARSTK. Standard case.)
	      (CLEARSTK))
	    (T 

          (* BREAK1, ERRORX2 SAVESET, and a few other system functions 
          store frames on this list that can be eliminated after a 
          control-D.)


	       (MAPC CLEARSTKLST (FUNCTION RELSTK))
	       (SETQ CLEARSTKLST NIL)))
          (RESETRESTORE)
      LP  (PROMPTCHAR CHAR T LISPXHISTORY)
          (LISPX (LISPXREAD T T)
		 CHAR)
          (GO LP])

(USEREXEC
  [LAMBDA (LISPXID LISPXXMACROS LISPXXUSERFN)
    (RESETVAR READBUF NIL (PROG NIL
			        (AND (NULL LISPXID)
				     (SETQ LISPXID (QUOTE _)))
			    LP  (PROMPTCHAR LISPXID T LISPXHISTORY)
			        (ERSETQ (LISPX (LISPXREAD T T)
					       LISPXID LISPXXMACROS 
					       LISPXXUSERFN))
			        (GO LP])

(LISPXREAD
  [LAMBDA (FILE RDTBL)
    (PROG (X)
      LP  (COND
	    ((NLISTP READBUF)

          (* In order to supress a spurious prompt character following 
          an alt-mode command for recovering buffers, READBUF is set 
          to T (PROMPTCHAR does not print a ready character if it 
          thinks the next input is being 'REREAD'.))


	      (SETQ READBUF NIL)))
          (COND
	    ((NULL READBUF)
	      (SETQ REREADFLG NIL)
	      [SETQ X (COND
		  ((EQ LISPXREADFN (QUOTE READ))

          (* So the call will be linked, so the user can break on 
          read.)


		    (READ FILE RDTBL))
		  (T (APPLY* LISPXREADFN FILE RDTBL]
	      [COND
		([AND (LISTP X)
		      (NOT (ZEROP (OPENR CTRLU]
                                                (* User typed control-u during 
                                                read. The assemble is an OPENR.)
		  (CLOSER CTRLU 0)
		  (COND
		    ((NULL (NLSETQ (EDITE X)))
                                                (* Exited with STOP, just save 
                                                input but do not evaluate or 
                                                execute.)
		      (SETQ REREADFLG (QUOTE ABORT]
	      (RETURN X)))

          (* REREADFLG is later used to compare with the first entry 
          on the history list to see if the reread expression CAME 
          from that entry.)


          (SETQ X (CAR READBUF))
          (SETQ READBUF (CDR (SETQ REREADFLG READBUF)))
          (COND
	    ((EQ X HISTSTR0)

          (* HISTSTR0 Is used to delimit inputs;
          it acts like a carriage return for READLINE and LISPXREADP.)


	      (GO LP))
	    ((EQ X HISTSTR2)                    (* Used for REPEATING.
                                                Form is "repeat" x 
                                                (input) --.)
	      [SETQ READBUF
		(NCONC (COPY (CADR READBUF))
		       (COND
			 ((AND (NUMBERP (CAR READBUF))
			       (NOT (IGREATERP (CAR READBUF)
					       1)))

          (* Done repeating. Checks for 1, instead of 0, because the 
          last iteration corresponds to the first argument to NCONC.)


			   (CDDR READBUF))
			 (T (CONS HISTSTR0
				  (CONS HISTSTR2
					(CONS (COND
						((NUMBERP (CAR READBUF))
						  (SUB1 (CAR READBUF)))
						(T (CAR READBUF)))
					      (CDR READBUF]
	      (GO LP)))
          (RETURN X])

(LISPXREADP
  [LAMBDA (FLG)

          (* If FLG is T, acts like READP, otherwise like a 
          READP which only looks at this line.)


    (COND
      (READBUF (OR FLG (NEQ (CAR READBUF)
			    HISTSTR0)))
      ((READP T)
	(OR FLG (PROG NIL
		  LP  (RETURN (SELECTQ (PEEKC T)
				       (%
 NIL)
				       (%  (READC T)
					   (GO LP))
				       T])

(LISPXUNREAD
  [LAMBDA (LST)
    (SETQ READBUF (COND
	((NULL READBUF)
	  LST)
	(T (APPEND LST (CONS HISTSTR0 READBUF])

(LISPX
  [LAMBDA (LISPXX LISPXID LISPXXMACROS LISPXXUSERFN LISPXFLG)

          (* LISPX (for LISP eXec) is designed to save the user the 
          task of writing an exec by allowing him to easily tailor 
          LISPX to his applications. In this way, the user also gets 
          the benefit of the history features built into LISPX.
          LISPX determines the type of input, performs any extra reads 
          that are necessary, saves the input 
          (s) and the value on the history, and prints and returns the 
          value. (LISPX must do the printing since for history 
          commands, see below, nothing can be printed until the next 
          call to LISPX.) -
          -
          There are currently six different classes of inputs: 
          (1) EVAL, i.e. forms; (2) APPLY, i.e. functions and 
          arguments; (3) forms without parentheses, i.e. lines, 
          usually specifying CLISP transformation, e.g. FOR X IN ...
          In this case the entire line is treated as a form and 
          EVALed; (4) commands, similar to edit macros, definitions 
          are looked up on LISPXMACROS; (5) user input, as determined 
          by applying LISPXUSERFN. If this yields T, the value of the 
          event is the value of LISPXVALUE, which must be set by 
          LISPXUSERFN; and (6) history commands.
          -
          For types 1 thru 5, LISPX saves the inputs on the history 
          list before executing. Thus even if the operation is 
          aborted, the user can redo it, fix it, etc. -
          For commands 1, 2, and 3, the function name is looked up on 
          LISPXFNS. if the user simply wants a different function 
          called for tty inputs then in his program, such as is the 
          case with SETQ or SET, this can easily be done by putting 
          (fn1 . fn2) on the list LISPXFNS.
          -
          For commands of type 6, LISPX simply unreads the appropriate 
          information and exits. This means that if a user function 
          calls LISPX when it cannot interpret the input, history 
          operations will work provided only that the user function 
          obtains its input via LISPXREAD, and that any inputs 
          interpreted by the user function also save the input on the 
          history list. This is the way BREAK1 uses LISPX.)



          (* If LISPXFLG is T, any history commands are executed in 
          this call to LISPX, instead of unreading and exiting.
          This is used when the calling function knows that the input 
          should (must) be processed here, for example, in the E 
          command from the editor. Without this, E REDO would cause 
          the input referred to by the REDO command to be interpreted 
          as edit commands instead of LISPX inputs.
          If LISPXFLG is 'RETRY, CLOCK is backed up to force a BREAK 
          on any error.)


    (AND (NULL LISPXXMACROS)
	 (SETQ LISPXXMACROS LISPXMACROS))
    (AND (NULL LISPXXUSERFN)
	 LISPXUSERFN
	 (FGETD (QUOTE LISPXUSERFN))
	 (SETQQ LISPXXUSERFN LISPXUSERFN))

          (* If LISPX is called with its fifth argument, LISPXXUSERFN, 
          non-NIL, it is applied (with APPLY*). Otherwise, the top 
          level value of LISPXUSERFN is checked, and if non-NIL, 
          LISPXUSERFN itself is called. (The former is for calls from 
          USEREXEC, the latter corresponds to the old way of doing it.
          Similarly, if LISPX is called with its fourth argument, 
          LISPXXMACROS, non-NIL, it is used as the list of macros, 
          otherwise the top level value of LISPXMACROS is used.))


    (PROG ((HELPCLOCK (CLOCK 2))
	   LISPXOP LISPXLISTFLG LISPXLINE (LISPXHIST
	     (AND (EQ LISPXX (QUOTE ))
		  LISPXHIST))
	   LISPY LISPZ LISPXVALUE LISPXTEM)
          (AND [OR (COND
		     ((SETQ LISPXTEM (OR (CAR NIL)
					 (CDR NIL)))
		       (FRPLACA (QUOTE CAR/CDRNIL)
				LISPXTEM)
		       (PRIN1 (COND
				((CAR NIL)
				  (QUOTE CAR))
				(T (QUOTE CDR)))
			      T)
		       (FRPLACA NIL NIL)
		       (FRPLACD NIL NIL)
		       (PRIN1 (QUOTE " of NIL")
			      T)))
		   (COND
		     ((NEQ (SETQ LISPXTEM (CAR T))
			   (QUOTE T))
		       (FRPLACA (QUOTE T)
				(QUOTE T))
		       (FRPLACA (QUOTE CAR/CDRNIL)
				LISPXTEM)
		       (PRIN1 (QUOTE "CAR of T")
			      T]
	       (PRIN1 (QUOTE " was clobbered with ")
		      T)
	       (PRINT LISPXTEM T T)
	       (PRIN1 (QUOTE " - now restored.
")
		      T))
          [COND
	    ((NULL LISPXX)                      (* Spurious right parentheses or
                                                bracket.)
	      (RETURN (PRINT NIL T)))
	    ((NLISTP LISPXX)
	      (SETQ LISPXLINE (READLINE T NIL T))

          (* The second argument specifies that if there is juut a "]" 
          or ")" on the line, it should be read as a NIL, i.e. the 
          line should be (NIL). It also specifies that if the line 
          begins with a list which is not preceded by any spaces, the 
          list is to terminate the line regardless of whether or not 
          it is terminated by a %]. Thus the usr can type fn 
          (args))


	      ]
      TOP (COND
	    ((LISTP LISPXX)
	      (SETQ LISPXOP (CAR LISPXX))
	      (SETQ LISPXLINE (CDR LISPXX))

          (* This is for convenience of history commands: regardless 
          of whether the command was typed as a list or a line, 
          LISPXOP is always the name of the command, LISPXLINE its 
          'arguments'. If it turns out that LISPXOP is not a history 
          command, LISPXLINE will be set back to NIL 
          (below NOTCOM))


	      (SETQ LISPXLISTFLG T))
	    ((NOT (LITATOM LISPXX))
	      (GO NOTCOM)

          (* User might have typed in a number followed by something 
          else -
          Evaluate so that default to editor will occur.)


	      )
	    (T (SETQ LISPXOP LISPXX)))
      SELECT
          (SELECTQ LISPXOP
		   ( (RETURN (PRINT (EVAL (CAR LISPXLINE)
					    (QUOTE _))
				      T T)))
		   ((RETRY REDO FIX USE ... )
		     (GO REDOCOM))
		   (NAME (COND
			   ((NULL LISPXLINE)    (* To allow user to have NAME as
                                                the name of a variable.)
			     (SETQ LISPXX (QUOTE E))
			     (SETQ LISPXLINE (LIST (QUOTE NAME)))
			     (GO DO-IT)))
			 (GO REDOCOM))
		   [UNDO (AND (SETQ LISPXHIST (HISTORYSAVE LISPXHISTORY LISPXID 
							   NIL (QUOTE UNDO)
							   LISPXLINE))
			      (FRPLACA LISPXHIST (UNDOLISPX LISPXLINE]
		   (TYPE-AHEAD (LISPXTYPEAHEAD))
		   (BUFS (COND
			     ((AND TOPLISPXBUFS (OR (EQ LISPXID (QUOTE _))
						    (NULL LISPXBUFS)))
                                                (* TOPLISPXBUFS are used over 
                                                LISPXBUFS if at the top.)
			       (SETQ LISPXTEM TOPLISPXBUFS)
			       (SETQ TOPLISPXBUFS NIL))
			     (T (SETQ LISPXTEM LISPXBUFS)
				(SETQ LISPXBUFS NIL)))
			   (COND
			     ((NULL LISPXTEM)
			       (ERROR (QUOTE "nothing saved.")
				      (QUOTE )
				      T))
			     ((CAR LISPXTEM)

          (* Setting READBUF to T suppresses promptcharacter at next 
          input, otherwise it would come between LINBUF and SYSBUF on 
          teletype.)


			       (SETQ READBUF T)))
			   (BKBUFS LISPXTEM LISPXID))
		   (? (PRIN1 (QUOTE "commands are:
")
			     T)
		      (PRINT LISPXCOMS T T))
		   ((RETRY: FORGET ?? ARCHIVE)
		     (AND (EQ REREADFLG (QUOTE ABORT))
			  (ERROR!))

          (* Since these the commands do not call HISTORYSAVE, we must 
          check for control-U followed by STOP here.)


		     (SELECTQ LISPXOP
			      (RETRY:(SETQ HELPCLOCK (IDIFFERENCE HELPCLOCK 
								  HELPTIME))
				(SETQ LISPXX (CAR LISPXLINE))
				(SETQ LISPXLINE (CDR LISPXLINE))
				(GO TOP))
			      (FORGET [MAPC (COND
					      (LISPXLINE (LISPXFIND
							   LISPXHISTORY 
							   LISPXLINE
							   (QUOTE ENTRIES)))
					      (T (CAR LISPXHISTORY)))
					    (FUNCTION (LAMBDA (X)
						(UNDOLISPX2 X T]
				      (PRINT (QUOTE forgotten)
					     T T))
			      (?? (PRINTHISTORY (COND
						  ((EQ (CAR LISPXLINE)
						       (QUOTE @@))
						    (SETQ LISPXLINE
						      (CDR LISPXLINE))
						    ARCHIVELST)
						  (T LISPXHISTORY))
						LISPXLINE))
			      (ARCHIVE (FRPLACA ARCHIVELST
						(NCONC (SETQ LISPXTEM
							 (LISPXFIND
							   LISPXHISTORY 
							   LISPXLINE
							   (QUOTE COPIES)))
						       (CAR ARCHIVELST)))
				       (FRPLACA (CDR ARCHIVELST)
						(IPLUS (CADR ARCHIVELST)
						       (FLENGTH LISPXTEM)))
				       (PRINT (QUOTE archived)
					      T T))
			      NIL))
		   (GO NOTCOM))
          (LISPXWATCH P.A.STATS)
          (RETURN (QUOTE ))
      NOTCOM
          [COND
	    ([SETQ LISPY (FASSOC LISPXOP (OR LISPXXMACROS (CAR (QUOTE 
								LISPXMACROS]
	      (LISPXWATCH P.A.STATS)
	      (AND LISPXLISTFLG (SETQ LISPXLINE NIL))
	      (GO DO-IT))
	    ((SETQ LISPY (FASSOC LISPXOP LISPXHISTORYMACROS))
	      (GO REDOCOM))
	    ((FMEMB LISPXOP LISPXCOMS)

          (* Since LISPXOP is not one of the built in commands, and 
          not on LISPXMACROS, presumably the user has included it on 
          LISPXCOMS because he is going to process it in LISPXUSERFN.
          In any event, dont want to do any spelling correction.)


	      (AND LISPXLISTFLG (SETQ LISPXLINE NIL))
	      (GO DO-IT))
	    (LISPXLISTFLG                       (* Input is a single list.)
	      [COND
		[(EQ (CAR LISPXX)
		     (QUOTE LAMBDA))
		  (SETQ LISPXLINE (LIST (LISPXREAD T T]
		(T [AND DWIMFLG (LITATOM (CAR LISPXX))
			(COND
			  ((FGETD (CAR LISPXX))
			    (ADDSPELL (CAR LISPXX)
				      2))
			  ((AND [NULL (GETLIS (CAR LISPXX)
					      (QUOTE (EXPR FILEDEF CLISPWORD]
				(SETQ LISPXOP (FIXSPELL (CAR LISPXX)
							70 LISPXCOMS NIL LISPXX)
				  ))
			    (SETQ LISPXLINE (CDR LISPXX))
			    (GO SELECT]
		   (AND LISPXLISTFLG (SETQ LISPXLINE NIL]
	      (GO DO-IT))
	    ((NULL LISPXLINE)                   (* Input is a single atom.)
	      [AND DWIMFLG (LITATOM LISPXX)
		   (COND
		     ((NEQ (CAR LISPXX)
			   (QUOTE NOBIND))
		       (ADDSPELL LISPXX 3))
		     ((NEQ (EVALV LISPXX)
			   (QUOTE NOBIND))      (* Local variable, don't 
                                                spelling correct.)
		       )
		     ((SETQ LISPXOP (FIXSPELL LISPXX 70 LISPXCOMS NIL T))
		       [COND
			 ((LISTP LISPXOP)       (* RUN-ON spelling error.)
			   (SETQ LISPXLINE (LIST (CDR LISPXOP)))
			   (SETQ LISPXOP (CAR LISPXOP]
		       (SETQ LISPXX LISPXOP)
		       (GO SELECT]
	      (GO DO-IT))
	    (DWIMFLG                            (* Input is an atom followed by 
                                                something else.)
		     (COND
		       ((NOT (LITATOM LISPXX)))
		       ((FGETD LISPXX)
			 (ADDSPELL LISPXX 1))
		       ((AND [NULL (GETLIS LISPXX (QUOTE (EXPR FILEDEF]
			     (SETQ LISPXOP (FIXSPELL LISPXX 70 LISPXCOMS NIL T))
			     )
			 [COND
			   ((LISTP LISPXOP)
			     (SETQ LISPXLINE (CONS (CDR LISPXOP)
						   LISPXLINE))
			     (SETQ LISPXOP (CAR LISPXOP]
			 (SETQ LISPXX LISPXOP)
			 (GO SELECT]
      DO-IT
          (SETQ LISPXHIST (SETQ LISPZ (HISTORYSAVE LISPXHISTORY LISPXID NIL 
						   LISPXX LISPXLINE)))
          [SETQ LISPXVALUE
	    (COND
	      [LISPY                            (* From LISPXMACROS)
		     ([LAMBDA (LISPXLINE)
			 (EVAL (CADR LISPY)
			       LISPXID]
		       (COND
			 (LISPXLISTFLG (CDR LISPXX))
			 (T LISPXLINE]
	      ((AND LISPXXUSERFN (APPLY* LISPXXUSERFN LISPXX LISPXLINE))
                                                (* LISPXXUSERFN sets LISPXVALUE 
                                                to be the value.)
		LISPXVALUE)
	      ((NULL LISPXLINE)                 (* A form.)
		(EVAL (COND
			((NLISTP LISPXX)
			  LISPXX)
			(T (LISPX/ LISPXX)))
		      LISPXID))
	      ([AND CLISPFLG (OR (CDR LISPXLINE)
				 (AND (ATOM LISPXX)
				      (CAR LISPXLINE)
				      (ATOM (CAR LISPXLINE))
				      (NEQ (SETQ LISPXTEM (NTHCHAR
					       (CAR LISPXLINE)
					       1))
					   (QUOTE -))
				      (FMEMB LISPXTEM CLISPCHARS)
				      (NEQ (ARGTYPE LISPXX)
					   3]

          (* The special checks are to enable constructs like FOO _T 
          to work, even when FOO is also the name of a function, i.e. 
          instead of applying FOO to _T, 
          (which would cause an unusal CDR ARGLIST error) 
          (FOO _ T) is evaluated, which will invoke DWIM.)


		(EVAL (LISPX/ (CONS LISPXX LISPXLINE))
		      LISPXID))
	      (T (APPLY (LISPX/ LISPXX)
			(LISPX/ (CAR LISPXLINE)
				LISPXX)
			LISPXID]
          (AND LISPZ (FRPLACA LISPZ LISPXVALUE))
          (RETURN (PRINT LISPXVALUE T T))
      REDOCOM
          (LISPXWATCH P.A.STATS)
          [SETQ LISPXX (COND
	      (LISPXLISTFLG (LIST LISPXX))
	      (T (CONS LISPXX LISPXLINE]        (* The entire history command.)
          (COND
	    ([AND REREADFLG (TAILP REREADFLG (CADR (SETQ LISPY
						     (FMEMB (QUOTE REREAD)
							    (SETQ LISPXHIST
							      (CAAR 
							       LISPXHISTORY]
                                                (* This history command comes 
                                                from the previous event.)
	      (COND
		((OR [FMEMB (QUOTE ->)
			    (SETQ LISPZ (GET LISPXHIST (QUOTE *HISTORY*]
		     (FMEMB (QUOTE ->)
			    LISPXLINE))
		  (ERROR (QUOTE "i'm confused.")
			 (QUOTE )
			 T)))
	      (NCONC LISPZ (CONS (QUOTE ->)
				 LISPXX))
	      (SETQ LISPZ LISPY))
	    (T (NCONC (HISTORYSAVE LISPXHISTORY LISPXID)
		      (LIST (QUOTE *HISTORY*)
			    LISPXX
			    (QUOTE *GROUP*)
			    NIL))
	       (SETQ LISPXHIST (CAAR LISPXHISTORY))

          (* For history commands, LISPXHIST is set to the entire 
          event, rather than CDDR, since the value field is not needed 
          but the input field is.)


	       ))
          (SELECTQ
	    LISPXOP
	    ( (SETQ LISPY (LISPXUSEC LISPXLINE LISPXHISTORY)))
	    [RETRY (SETQ LISPY (CONS (QUOTE RETRY:)
				     (LISPXFIND LISPXHISTORY LISPXLINE
						(QUOTE REDO)
						T]
	    (NAME (SETQ LISPY (LISPXFIND LISPXHISTORY (CDR LISPXLINE)
					 (QUOTE INPUT)
					 T))
		  (/PUT (CAR LISPXLINE)
			(QUOTE *HISTORY*)
			(LISPXFIND LISPXHISTORY (CDR LISPXLINE)
				   (QUOTE COPIES)
				   T))
		  (/REMPROP (CAR LISPXLINE)
			    (QUOTE STATE))
		  (PRINT (CAR LISPXLINE)
			 T T))
	    [REDO (COND
		    ([AND (CDR LISPXLINE)
			  (OR (EQ (CAR (SETQ LISPXTEM (LAST LISPXLINE)))
				  (QUOTE TIMES))
			      (EQ (CAR LISPXTEM)
				  (QUOTE times]
		      (SETQ LISPXTEM (NLEFT LISPXLINE 2))
		      (SETQ LISPXLINE (LDIFF LISPXLINE LISPXTEM)))
		    (T (SETQ LISPXTEM NIL)))
		  (SETQ LISPY (LISPXFIND LISPXHISTORY LISPXLINE (QUOTE REDO)
					 T))
		  [COND
		    ((EQ LISPXID (QUOTE *))     (* For editor.)
		      (SETQ LISPY (COPY LISPY]
		  (AND LISPXTEM
		       (SETQ LISPY
			 (APPEND LISPY
				 (CONS HISTSTR0
				       (CONS HISTSTR2
					     (LIST (COND
						     ((NUMBERP (CAR LISPXTEM))
						       (SUB1 (CAR LISPXTEM)))
						     (T 
                                                (* means indefinitely)
							T))
						   LISPY]
	    [FIX (SETQ LISPY (COPY (LISPXFIND LISPXHISTORY
					      (COND
						((SETQ LISPXTEM
						    (FMEMB (QUOTE -)
							   LISPXLINE))

          (* User can say FIX -
          and give the commands. Then he doesn't have to wait for 
          editor to print EDIT, and him to type OK at the end.
          Also, the commands stored on the history list in this 
          fashion can be reexecuted by a REDO FIX command.)


						  (LDIFF LISPXLINE LISPXTEM))
						(T LISPXLINE))
					      (QUOTE INPUT)
					      T)))
		 (PROG (LISPXHIST)
		       (RETURN (EDITL (COND
					((CDR LISPY)
					  (LIST LISPY))
					(T (LIST (CAR LISPY)
						 LISPY)))
				      (CDR LISPXTEM]
	    (USE (SETQ LISPY (LISPXUSE LISPXLINE LISPXHISTORY LISPXHIST)))
	    (... (COND
		   ((NULL LISPXLINE)
		     (ERROR (QUOTE "... what??")
			    (QUOTE )
			    T)))
		 (SETQ LISPY (OR [CADR (FMEMB (QUOTE ...ARGS)
					      (SETQ LISPY (LISPXFIND
						  LISPXHISTORY NIL
						  (QUOTE ENTRY)
						  T]
				 (CDADR (FMEMB (QUOTE USE-ARGS)
					       LISPY))
				 (LISPXFIND LISPXHISTORY NIL (QUOTE INPUT)
					    T)))
		 (NCONC LISPXHIST (LIST (QUOTE ...ARGS)
					LISPY))
		 [SETQ LISPXTEM (COND
		     ((OR (NULL (CDR LISPY))
			  (EQ (CADR LISPY)
			      HISTSTR0))        (* EVAL input, substitute for 
                                                first argument which is CADAR)
		       (CADAR LISPY))
		     ((NLISTP (CADR LISPY))
		       (CADR LISPY))
		     (T                         (* APPLY input.)
			(CAADR LISPY]
		 [SETQ LISPY (CDR (MAPCONC LISPXLINE
					   (FUNCTION (LAMBDA (X)
					       (CONS HISTSTR0
						     (SUBST X LISPXTEM LISPY]

          (* The CDR removes the extra HISTSTR0 in this way, HISTSTR0 
          only occurs BETWEEN inputs.)


		 )
	    (SETQ LISPY (EVAL (CADR LISPY)
			      LISPXID)))        (* LISPY is now the input.)
          (COND
	    ((OR (NULL (CAR LISPXHIST))
		 (EQUAL (CAR LISPXHIST)
			LISPXX))
	      (FRPLACA LISPXHIST LISPY))
	    (T 

          (* This history command comes from a previous event that was 
          a group. The user must have constructed this group via a FIX 
          command, because a command such as REDO -1 USE -3 would not 
          utilize the history portion of the USE command 
          (LISPXFIND only checks for HISTORYFLG on single events, not 
          grouped events). The reason this type of command is not 
          permitted is that it is not clear whether event 
          specifications in the history command are supposed to "see" 
          earlier events in the group. (In the current implementation, 
          they would not because all history commands interpret event 
          specifications as of before the event they are contained 
          in.))


	       (ERROR (QUOTE "illegal history command")
		      (QUOTE )
		      T)))
          [COND
	    ((EQ LISPXOP (QUOTE NAME))

          (* NAME is handled as a history command so that the command 
          is stored before it tries to do the lookup, and to share in 
          other common code. but it is not actually redone or unread.)


	      )
	    [LISPXFLG (RESETVAR READBUF LISPY
			(PROG NIL
			      [COND
				(LISPZ (FRPLACA (CDR LISPZ)
						READBUF))
				(T (NCONC LISPXHIST (LIST (QUOTE REREAD)
							  READBUF]
			  LP  (COND
				((NULL READBUF)
				  (RETURN)))
			      (LISPX (LISPXREAD T T)
				     LISPXID)
			      (GO LP]
	    (LISPZ (FRPLACA (CDR LISPZ)
			    (LISPXUNREAD LISPY)))
	    (T (NCONC LISPXHIST (LIST (QUOTE REREAD)
				      (LISPXUNREAD LISPY]
          (RETURN (QUOTE ])

(LISPX/
  [LAMBDA (X FN VARS)
    (COND
      ((OR (NULL LISPXFNS)
	   (NULL LISPXHISTORY))
	X)
      [FN

          (* If FN is not NIL, it is the name of a function 
          and X is its argument list.
          Subsitution only occurs for functions that EVAL, 
          such as RPAQ, SETQ, and e.)


	(COND
	  ((NLISTP X)

          (* X is an (atomic) argument list, e.g. type PP FOO, 
          don't substitute for FOO.)


	    X)
	  (T
	    (SELECTQ
	      FN
	      (E (LISPX/1 X))
	      ((RPT MAP MAPC MAPLIST MAPCAR MAPCON MAPCONC SUBSET EVERY 
		    SOME)                       (* Functions known to 
                                                evaluate their 
                                                arguments.)
		(LISPX/1 X T))
	      (PROG (TEM)
		    (RETURN (COND
			      ((AND (OR (EQ (SETQ TEM (ARGTYPE FN))
					    1)
					(EQ TEM 3))
				    (EQ (GETP FN (QUOTE INFO))
					(QUOTE EVAL)))

          (* Slightly different check than in LISPX/1 and 
          DWIMIFY1, etc. This check wants to know whether this 
          function calls eval explicitly itself.
          The others say are the aaguments evaluated either by 
          virtue of it being a normal function, or an eval 
          call.)


				(LISPX/1 X T))
			      (T X]
      ((LISTP X)                                (* X is a form.)
	(LISPX/1 X))
      (T (OR (CDR (FASSOC X LISPXFNS))
	     X])

(LISPX/1
  [LAMBDA (X TAILFLG)
    (AND
      X
      (PROG ((TEM1 (CAR X))
	     TEM2 TEM3)
	    (COND
	      ((NLISTP X)
		(RETURN X))
	      ((LISTP (CAR X))
		(SETQ TEM1 (LISPX/1 (CAR X)))
		(GO DO-CDR)))
	    (COND
	      (TAILFLG (GO DO-CDR)))
	    (SETQ TEM1 (OR (CDR (FASSOC (CAR X)
					LISPXFNS))
			   (CAR X)))
	    [SELECTQ
	      (CAR X)
	      (QUOTE (RETURN X))
	      ((FUNCTION F/L)
		(SETQ TEM2 (LISPX/1 (CDR X)))
		(GO DO-CDR1))
	      ([LAMBDA NLAMBDA]
		(SETQ TEM3 (CADR X))
		(PROG [(VARS (COND
			       ((ATOM TEM3)
				 (CONS TEM3 VARS))
			       (T (APPEND TEM3 VARS]
		      (SETQ TEM2 (LISPX/1 (CDDR X)
					  T)))
		(GO DO-CDDR1))
	      [PROG [PROG ((VARS
			     (NCONC [MAPCAR (CADR X)
					    (FUNCTION (LAMBDA (X)
						(COND
						  ((ATOM X)
						    X)
						  (T (SETQ TEM3 T)
						     (CAR X]
				    VARS)))
		          (SETQ TEM2 (LISPX/1 (CDDR X)
					      (CAR X]
		    (COND
		      ((NULL TEM3)
			(GO DO-CDDR1)))
		    (RETURN
		      (CONS (QUOTE PROG)
			    (CONS [MAPCAR (CADR X)
					  (FUNCTION (LAMBDA (X)
					      (COND
						((ATOM X)
						  X)
						(T (LISPX/1 X T]
				  TEM2]
	      (COND
		[(EQ (CAR X)
		     CLISPTRANFLG)
		  (SETQ TEM3 (CADR X))
		  (RETURN (COND
			    ((EQ (SETQ TEM1 (LISPX/1 TEM3))
				 TEM3)
			      X)
			    (T (CONS CLISPTRANFLG (CONS TEM1
							(CDDR X]
		((AND (OR (EQ (SETQ TEM2 (ARGTYPE (CAR X)))
			      1)
			  (EQ TEM2 3))
		      (NEQ (GETP (CAR X)
				 (QUOTE INFO))
			   (QUOTE EVAL)))

          (* Do not substitute unless you know that the 
          function will evaluate its arguments, as with 
          ERSETQ, RESETVAR, etc. The eason for not just 
          returning is that the function name may be on 
          lispxfns, e.g. SETQQ becomes SAVESETQQ.)


		  (SETQ TEM2 (CDR X))
		  (GO DO-CDR1))
		((AND CLISPARRAY (NULL (FGETD (CAR X)))
		      (SETQ TEM3 (GETHASH X CLISPARRAY)))
		  (RETURN (LISPX/1 TEM3)))
		((AND (ATOM (CADR X))
		      (FMEMB (CADR X)
			     VARS))

          (* SETQ, RPLACA, NCONC, etc. don't have to be 
          undoable for bound vriabes, e.g. in MAPC, PROG, 
          etc.)


		  (SETQ TEM1 (CAR X))
		  (GO DO-CDDR]
	DO-CDR
	    (SETQ TEM2 (LISPX/1 (CDR X)
				T))
	DO-CDR1
	    [RETURN (COND
		      ((AND (EQ TEM1 (CAR X))
			    (EQ TEM2 (CDR X)))
			X)
		      (T (CONS TEM1 TEM2]
	DO-CDDR
	    (SETQ TEM2 (LISPX/1 (CDDR X)
				T))
	DO-CDDR1
	    (RETURN (COND
		      ((AND (EQ TEM1 (CAR X))
			    (EQ TEM2 (CDDR X)))
			X)
		      (T (CONS TEM1 (CONS (CADR X)
					  TEM2])

(LISPXEVAL
  [LAMBDA (LISPXFORM LISPXID)

          (* Evaluates LISPXFORM same as though were typed in 
          to LISPX. If LISPXID not given, _ is used.)


    (PROG (LISPXHIST)
          (OR LISPXID (SETQ LISPXID (QUOTE _)))
          (SETQ LISPXHIST (HISTORYSAVE LISPXHISTORY LISPXID NIL 
				       LISPXFORM))
          (FRPLACA LISPXHIST (EVAL (COND
				     ((NLISTP LISPXFORM)
				       LISPXFORM)
				     (T (LISPX/ LISPXFORM)))
				   LISPXID))
          (RETURN (CAR LISPXHIST])

(HISTORYSAVE
  [LAMBDA (HISTORY ID INPUT1 INPUT2 INPUT3 PROPS)

          (* HISTORY is of the form (LIST INDEX SIZE MOD) INDEX is 
          between 0 and MOD (MOD is usually 100 or a multiple of 100) 
          and is automatically incremented each time an entry is 
          added. SIZE is the length of LIST, and after LIST reaches 
          that length, old entries at the end are cannibalized and 
          moved to the front when new entries are added.
          The form of each entry on the HISTORY list is 
          (INPUT ID VALUE . PROPS) Value is initialized to .)



          (* The value of HISTORYSAVE is a pointer into the HISTORY 
          entry at the value position, i.e. RPLACA on the value of 
          HISTORYSAVE is used to store in the value.
          Groups are represented by the appearance of the property 
          GROUP. Its value is a list of the form 
          ((value . props)) If HISTORYSAVE is called with REREADFLG 
          corresponding to a part of the input field of the most 
          recent entry to HISTORY, no new entry is saved but instead a 
          (value . props) is added to the property value for GROUP.
          The value of HISTORYSAVE in this case is the 
          (value . props) pointer so that again RPLACA can be used to 
          store the value of the computation.
          This removes the burden from the functions calling 
          HISTORYSAVE of distinguishing between new input and 
          reexecution of input whose HISTORY entry has already been 
          set up.)


    (PROG ((L (CAR HISTORY))
	   (INDEX (CADR HISTORY))
	   (SIZE (CADDR HISTORY))
	   (MOD (OR (CADDDR HISTORY)
		    100))
	   (N 0)
	   X Y TEM)
          (COND
	    ((NULL HISTORY)
	      (RETURN NIL))
	    ((AND REREADFLG [SETQ X (CDR (FMEMB (QUOTE *GROUP*)
						(SETQ Y (CAAR HISTORY]
		  (OR [EQ (CAR Y)
			  (SETQ TEM (GET Y (QUOTE REREAD]
		      (TAILP REREADFLG TEM)))

          (* This input is the result of a history command, so do not 
          make a new entry. See above comment.
          The VAG 2 checks are for REPEAT and REPEATN, in which case 
          the materiel reread is not EQ, but has been appended on.
          See comment in LISPXREAD.)


	      [FRPLACA X (NCONC1 (CAR X)
				 (SETQ Y (CONS (QUOTE )
					       PROPS]
	      (RETURN Y)))
          [COND
	    ((IGREATERP (SETQ INDEX (ADD1 INDEX))
			MOD)
	      (SETQ INDEX (IPLUS INDEX (MINUS MOD]
      LP  (COND
	    ((CDDR L)
	      (ADD1VAR N)
	      (SETQ L (CDR L))
	      (GO LP))
	    ((IGREATERP SIZE (IPLUS N 2))
	      (FRPLACA HISTORY (CONS (SETQ X (LIST NIL NIL NIL))
				     (CAR HISTORY)))
	      (GO SMASH)))
          (SETQ X (CDR L))
          [COND
	    ([AND (NEQ HISTORY EDITHISTORY)
		  (OR (AND ARCHIVEFN (ARCHIVEFN (CAAR X)
						(CAR X)))
		      (GET (CAR X)
			   (QUOTE ARCHIVE]
	      (FRPLACA ARCHIVELST (CONS (LISPXFIND1 (CAR X))
					(CAR ARCHIVELST)))
	      (FRPLACA (CDR ARCHIVELST)
		       (ADD1 (CADR ARCHIVELST]
          (FRPLACD L NIL)                       (* Moves last entry to front.)
          (FRPLACA HISTORY (FRPLACD X (CAR HISTORY)))
          (SETQ X (CAR X))                      (* X is now the entry to be 
                                                canniablized.)
      SMASH
          (FRPLACA (CDR HISTORY)
		   INDEX)
          [COND
	    ((LISTP ID)                         (* ID is the new entry.)
	      (FRPLACA (CAR HISTORY)
		       (SETQ Y ID))
	      (GO OUT))
	    ((NLISTP (SETQ Y (CAR X)))          (* Y is now the input portion of
                                                the entry.)
	      (SETQ Y (CONS NIL NIL]
          (COND
	    [INPUT1 

          (* Means INPUT is (INPUT1 INPUT2 . INPUT3) used primarily 
          for APPLY INPUT when INPUT1 is function and INPUT2 args.)


		    (COND
		      ((CDR Y)                  (* Cannibalize previous input.)
			(FRPLACA Y INPUT1)
			(FRPLACA (CDR Y)
				 INPUT2)
			(FRPLACD (CDR Y)
				 INPUT3))
		      (T (SETQ Y (CONS INPUT1 (CONS INPUT2 INPUT3]
	    (INPUT2 

          (* Means INPUT is (INPUT2 . INPUT3) used primarily for EVAL 
          INPUT when INPUT2 is form.)


		    (FRPLACA Y INPUT2)
		    (FRPLACD Y INPUT3))
	    (T 

          (* Means INPUT is INPUT3, used primarily for line inputs, 
          such as HISTORY commands.)


	       (SETQ Y INPUT3)))
          (FRPLACA X Y)
          (FRPLACA (SETQ Y (CDR X))
		   ID)
          (COND
	    [(EQ (CADR Y)
		 (QUOTE ))

          (* Y may correspond to an event that has not yet completed 
          but will, e.g. you are in a break and have performed more 
          than 30 operations. Therefore Y, or at least that part of Y 
          beginning with the value field, should not be used since it 
          will be smashed wen the event finishes.)


	      (FRPLACD Y (SETQ Y (CONS (QUOTE )
				       PROPS]
	    (T (FRPLACA (SETQ Y (CDR Y))
			(QUOTE ))
	       (FRPLACD Y PROPS)))
      OUT (COND
	    ((EQ ID (QUOTE *))
	      (LISPXWATCH EDITSTATS))
	    (T (LISPXWATCH LISPXSTATS)))
          (COND
	    ((EQ REREADFLG (QUOTE ABORT))
	      (ERROR!)))
          (RETURN Y])

(LISPXFIND
  [LAMBDA (HISTORY LINE TYPE BACKUP QUIETFLG)

          (* QUIETFLG=T means tell editor not to print messages on alt-mode matches.
          Used by LISPXUSE and LISPXUSEC.)


    (COND
      ((NULL HISTORY)
	(ERROR (QUOTE "no history.")
	       (QUOTE )
	       T)))

          (* LINE specifies an entry or entries on HISTORY, and TYPE the desired 
          format of the value. LISPXFIND uses HISTORYFIND to get the corresponding 
          entries, and then decides what to do with them.)


    (RESETVAR EDITQUIETFLG (OR EDITQUIETFLG QUIETFLG)
      (PROG ((LST (CAR HISTORY))
	     (INDEX (CADR HISTORY))
	     (MOD (OR (CADDDR HISTORY)
		      100))
	     HISTORYFLG)
	    [COND
	      (BACKUP 

          (* Used when want to refer to HISTORY before last entry was made, e.g. for 
          UNDO so UNDO UNDO will work.)


		      (SETQ LST (CDR LST))
		      (SETQ INDEX (SUB1 INDEX]
	    [COND
	      ((AND REREADFLG (NULL (CAAR LST)))

          (* Special glitch to allow a bad history command which contains relative 
          event numbers to be reexecuted without changing the event specification 
          provided it is done immediately, e.g. user types USE FOO FOR FIE IN -2, 
          LISPX types FIE ? user can TYPE USE FUM FOR FIE, and -2 will refer to the 
          correct event.)


		(SETQ LST (CDR LST))
		(SETQ INDEX (SUB1 INDEX]
	FIND[COND
	      ((NULL LINE)
		(SETQ LINE (CAR LST))
		[COND
		  ((AND (EQ (CAAR LINE)
			    (QUOTE UNDO))
			(NEQ (CADDR LINE)
			     (QUOTE )))                   (* So can say UNDO then REDO or 
                                                            USE.)
		    (SETQ LINE (CADR LST]
		(GO SINGLE))
	      ((EQ (CAR LINE)
		   (QUOTE @@))                              (* Archive.)
		(RETURN (LISPXFIND ARCHIVELST (CDR LINE)
				   TYPE]
	    (SETQ LINE (PROG ((X LINE)
			      Y)

          (* Checking for AND above the handling of THRU and TO enables REDO 2 AND 4 
          THRU 7.0)


			 LP  (SETQ Y (NCONC Y (LISPXFIND0 [LDIFF X
								 (SETQ X
								   (OR (FMEMB (QUOTE AND)
									      (CDR X))
								       (FMEMB (QUOTE and)
									      (CDR X]
							  LST INDEX MOD)))
			     (COND
			       ((SETQ X (CDR X))
				 (GO LP)))
			     (RETURN Y)))
	GROUP
	    (COND
	      ((NULL (CDR LINE))
		(SETQ LINE (CAR LINE))
		(GO SINGLE)))                               (* LINE is a list of events.)
	    [AND ARCHIVEFLG (MAPC LINE (FUNCTION (LAMBDA (X)
				      (LISPXPUT (QUOTE ARCHIVE)
						T NIL X]
	    (RETURN (SELECTQ TYPE
			     [(INPUT REDO)

          (* The CDR removes the extra <c.r.>'S. In this way, <c.r.> only occurs 
          between inputs.)


			       (CDR (MAPCONC LINE (FUNCTION (LAMBDA (LINE)
						 (CONS HISTSTR0 (APPEND (CAR LINE]
			     ((ENTRY ENTRIES)
			       LINE)
			     ((COPY COPIES)
			       (MAPCAR LINE (FUNCTION LISPXFIND1)))
			     (GO BAD)))

          (* For COPIES and ENTRIES, calling function expects a LIST of events, for 
          COPY and ENTRY only one. (however if the event specification produces more 
          than one event, LISPXFIND treats COPY and ENTRY the same as COPIES and 
          ENTRIES.) ENTRY is used by LISPXUSE and the ...
          Command. Entries is used by FORGET. COPIES is used by NAME and ARCHIVE.
          -
          REDO is the same as INPUT except that the value returned will not be copied 
          again, so it must be copied here.)


	SINGLE                                              (* LINE is a single event.)
	    (AND ARCHIVEFLG (LISPXPUT (QUOTE ARCHIVE)
				      T NIL LINE))
	    (RETURN (SELECTQ TYPE
			     [INPUT (COND
				      ((OR HISTORYFLG (NULL (CAR LINE)))
					(GET LINE (QUOTE *HISTORY*)))
				      (T (CAR LINE]
			     [REDO 

          (* Cannot allow same structure TO appear in HISTORY list twice since entries 
          are cannibalized.)


				   (COND
				     ((OR HISTORYFLG (NULL (CAR LINE)))
				       (GET LINE (QUOTE *HISTORY*)))
				     (T (APPEND (CAR LINE]
			     (ENTRY LINE)
			     (ENTRIES (LIST LINE))
			     (COPY (LISPXFIND1 LINE))
			     (COPIES (LIST (LISPXFIND1 LINE)))
			     (GO BAD)))
	BAD (ERROR TYPE (QUOTE "- LISPXFIND ?")
		   T])

(LISPXFIND0
  [LAMBDA (LINE LST INDEX MOD)

          (* Value is a list of entries on history list.
          lispxfind decides whatto do with them.)


    (PROG (THRUFLG L1 L2 TEM)
          [COND
	    ((NULL (CDR LINE))
	      (RETURN (LIST (CAR (HISTORYFIND LST INDEX MOD LINE]
          (SELECTQ (CAR LINE)
		   (@

          (* E.g. REDO @ FOO, same as retrieve FOO and then REDO it, except don't get 
          two copies of FOO on HISTORY list.)


		     (COND
		       ([NULL (SETQ LINE (GETP (SETQ TEM (CADR LINE))
					       (QUOTE *HISTORY*]
			 (ERROR TEM (QUOTE " ?")
				T)))
		     (RETURN LINE))
		   ((FROM from)

          (* Input can be of form -
          FROM ... TO ... or ... TO ... -
          FROM ... THRU ... or ... THRU ... -
          FROM ...; TO ...; THRU ...; or a list of entries.)


		     (SETQ L1 (CDR LINE)))
		   ((TO THRU to thru)
		     [SETQ THRUFLG (OR (EQ (CAR LINE)
					   (QUOTE THRU))
				       (EQ (CAR LINE)
					   (QUOTE thru]
		     (SETQ L2 (HISTORYFIND LST INDEX MOD (CDR LINE)))
		     (GO LDIFF))
		   NIL)

          (* At this point we know it did not begin with TO or THRU.)


          [COND
	    [(AND [OR (SETQ TEM (FMEMB (QUOTE TO)
				       LINE))
		      (SETQ TEM (FMEMB (QUOTE to)
				       LINE))
		      (SETQ THRUFLG (SETQ TEM (OR (FMEMB (QUOTE THRU)
							 LINE)
						  (FMEMB (QUOTE thru)
							 LINE]
		  (NEQ (CAR (NLEFT LINE 1 TEM))
		       (QUOTE F)))
	      (SETQ L1 (HISTORYFIND LST INDEX MOD (OR L1 LINE)
				    TEM))
	      (SETQ L2 (HISTORYFIND LST INDEX MOD (CDR TEM]
	    (L1                                             (* Line began with FROM, but did not
                                                            contain a TO or THRU.)
		(SETQ L1 (HISTORYFIND LST INDEX MOD L1)))
	    (T (RETURN (LIST (CAR (HISTORYFIND LST INDEX MOD LINE]
      LDIFF
          (RETURN (COND
		    ((NULL L1)
		      (AND THRUFLG (SETQ L2 (CDR L2)))
		      (LDIFF LST L2))
		    [(NULL L2)
		      (DREVERSE (COND
				  ((NULL (CDR L1))
				    (APPEND LST))
				  (T (LDIFF LST (CDR L1]
		    ((TAILP L2 L1)
		      (AND THRUFLG (SETQ L2 (CDR L2)))
		      (LDIFF L1 L2))
		    (T (AND (NULL THRUFLG)
			    (SETQ L2 (CDR L2)))
		       (DREVERSE (COND
				   ((NULL (CDR L1))
				     (APPEND L2))
				   (T (LDIFF L2 (CDR L1])

(LISPXFIND1
  [LAMBDA (X)

          (* Produces a copy of a history entry so that if the 
          history list recycles, and this entry is 
          cannibalized, the value of LISPXFIND1 is not 
          touched.)


    (CONS (APPEND (CAR X))
	  (CONS (CAR (SETQ X (CDR X)))
		(CONS (CAR (SETQ X (CDR X)))
		      (CDR X])

(HISTORYFIND
  [LAMBDA (LST INDEX MOD X Y)

          (* Searches a history list and returns the corresponding entry.
          Y is a tail of X, and marks the end of this event specification, e.g. in F 2 
          AND Z, Y would be (AND Z))


    (PROG ((L LST)
	   Z TEM _FLG
	   =FLG)
      LP  [SELECTQ (SETQ Z (CAR X))
		   [\ (SETQ L (AND (EQUAL (CAAAR LASTHISTORY)
					  (CDR LASTHISTORY))
				   (CAR LASTHISTORY]
		   (=(SETQ =FLG T)
		     (SETQ X (CDR X))
		     (GO LP))
		   (_(SETQ _FLG
		       T)
		     (SETQ X (CDR X))
		     (GO LP))
		   (F [COND
			((AND (SETQ TEM (CDR X))
			      (NEQ TEM Y))

          (* Otherwise, F is not a special symbol, e.g. user types REDO F, meaning 
          search for F itself.)


			  (SETQ X (CDR X))
			  (SETQ Z (CAR X]
		      (HISTORYFIND1))
		   ((REDO USE FIX RETRY  Redo Use Fix)    (* i.e. REDO, USE etc. appear in the
                                                            event specificaton.)
		     (SETQ HISTORYFLG T)
		     (HISTORYFIND1))
		   (COND
		     ((OR _FLG
			  =FLG
			  (NOT (NUMBERP Z)))
		       (HISTORYFIND1)                       (* Does searching.)
		       )
		     [(ILESSP Z 0)

          (* Entries on LST are numbered starting at INDEX and decreasing by 1 if Z is 
          negative, count back corresponding number.
          if Z is positive, count forward, except when Z is first member on X in which 
          case Z is the absolute event address, i.e. Z refers to the index that would 
          be printed by the ?? command.)


		       (SETQ L (NTH L (IMINUS Z]
		     ((NEQ L LST)                           (* move forward.)
		       (SETQ L (NLEFT LST (ADD1 Z)
				      L)))
		     [(NOT (IGREATERP Z INDEX))
		       (SETQ L (CDR (NTH L (IDIFFERENCE INDEX Z]
		     ((IGREATERP (SETQ TEM (IPLUS INDEX MOD (IMINUS Z)))
				 0)

          (* E.g. Suppose history numbers have just 'RECYCLED', i.e. current history 
          is 5, and user references 97 must subtract 97 from 105 to find how far back 
          the entry is. The IGREATERP check is in case user simply typed very large 
          number.)


		       (SETQ L (CDR (NTH L TEM]
          (COND
	    ((NULL L)
	      (ERROR Z (QUOTE " ?")
		     T))
	    ((OR (EQ (SETQ X (CDR X))
		     Y)
		 (NULL X))
	      [SETQ LASTHISTORY (CONS L (CONS (CAR (SETQ TEM (CAAR L)))
					      (CDR TEM]

          (* For \ command. Input is copied so that it can be used as a check to see 
          whether this particular event has been recycled since it was last 
          referenced.)


	      (RETURN L)

          (* Note that value is a TAIL of the history list, not an element.)


	      ))
          (SETQ L (CDR L))
          (SETQ _FLG
	    NIL)
          (SETQ =FLG NIL)
          (SETQ HISTORYFLG NIL)
          (GO LP])

(HISTORYFIND1
  [LAMBDA NIL
    (PROG (PAT1 PAT2 TEM)
          [AND _FLG
	       (COND
		 ((EQ L LST)
		   (SETQ L (LAST L)))
		 (T (SETQ L (NLEFT LST 2 L]
          [COND
	    ((AND (ATOM Z)
		  (EQ (NTHCHAR Z 1)
		      (QUOTE _)))
	      (SETQ PAT1 (EDITFPAT (PACK (CDR (DUNPACK Z CHCONLST1)))
				   T)))
	    (T (SETQ PAT2 (EDITFPAT Z T]
      LP  [COND
	    ((COND
		((AND (EQ (CAAAR L)
			  (QUOTE UNDO))
		      (EQ (CADDAR L)
			  (QUOTE )))          (* UNDO events that failed to 
                                                find are ignored.)
		  NIL)
		[HISTORYFLG (AND (SETQ TEM (GET (CAR L)
						(QUOTE *HISTORY*)))
				 (OR (EQ PAT2 (CAR TEM))
				     (EQ PAT2 (CAAR TEM]
		(PAT1 (EDIT4E PAT1 (CAAAR L)))
		(T (EDITFINDP (COND
				(=FLG (COND
					([AND (FMEMB (QUOTE *PRINT*)
						     (CAR L))
					      (OR (EQ (SETQ TEM (CAAAR L))
						      (QUOTE OK))
						  (EQ TEM (QUOTE EVAL]

          (* Although the value of this event may match the pattern, 
          the user never saw the value printed out 
          (and PRINTHISTORY) wouldnt print it out.)


					  (SETQ L (CDR L))
					  (GO LP1)))
				      (CADDAR L))
				((AND (NULL REREADFLG)
				      (NULL (CAAR L)))
				  (GET (CAR L)
				       (QUOTE *HISTORY*)))
				(T (CAAR L)))
			      PAT2 T)))
	      (RETURN L))
	    (_FLG
	      (SETQ L (NLEFT LST 1 L)))
	    (T (SETQ L (CDR L]
      LP1 (COND
	    ((NULL L)
	      (RETURN NIL)))
          (GO LP])

(VALUEOF
  [NLAMBDA X
    (PROG (Y HISTORYFLG)
          [SETQ Y (COND
	      ((NULL X)
		(CADAR LISPXHISTORY))
	      (T (CAR (HISTORYFIND (CDAR LISPXHISTORY)
				   (SUB1 (CADR LISPXHISTORY))
				   (OR (CADDDR LISPXHISTORY)
				       100)
				   X]
          (RETURN (COND
		    ([NULL (SETQ X (GET Y (QUOTE *GROUP*]
		      (CADDR Y))
		    ((NULL (CDR X))
		      (CAAR X))
		    (T (MAPCAR X (FUNCTION CAR])

(LISPXUSE
  [LAMBDA (LINE HISTORY LSPXHST)
    (PROG (EXPR ARGS VARS STATE LST TEM USE-ARGS GENLST LISPXHIST)

          (* LISPXHIST rebound to NIL so ESUBST doesn't put any side 
          information on history.)


          (COND
	    ((NULL LINE)
	      (ERROR (QUOTE "use what??")
		     (QUOTE )
		     T)))
          (SETQ STATE (QUOTE VARS))
      LP                                        (* Parses input string using a 
                                                finite STATE machine.)
          [COND
	    ((OR (NULL LST)
		 (NULL (CDR LINE))
		 (NULL (SELECTQ (CAR LINE)
				((FOR for)
				  (COND
				    ((EQ STATE (QUOTE VARS))
				      (SETQ VARS (NCONC1 VARS LST))
				      (SETQ TEM (APPEND LST TEM))
				      (SETQ STATE (QUOTE ARGS))
				      (SETQ LST NIL)
				      T)))
				((AND and)
				  (COND
				    ((EQ STATE (QUOTE EXPR))
				      NIL)
				    (T [COND
					 ((EQ STATE (QUOTE ARGS))
					   (SETQ ARGS (NCONC1 ARGS LST)))
					 ((EQ STATE (QUOTE VARS))
                                                (* E.g. user types USE A AND B 
                                                following previous USE command.)
					   (SETQ VARS (NCONC1 VARS LST]
				       (SETQ STATE (QUOTE VARS))
				       (SETQ LST NIL)
				       T)))
				((IN in)
				  (COND
				    ((AND (EQ STATE (QUOTE VARS))
					  (NULL ARGS))
				      (SETQ VARS (NCONC1 VARS LST))
				      (SETQ TEM (APPEND LST TEM))
				      (SETQ STATE (QUOTE EXPR))
				      (SETQ LST NIL)
				      T)
				    ((EQ STATE (QUOTE ARGS))
				      (SETQ ARGS (NCONC1 ARGS LST))
				      (SETQ STATE (QUOTE EXPR))
				      (SETQ LST NIL)
				      T)))
				NIL)))
	      (SETQ LST (NCONC1 LST (CAR LINE)))
	      (COND
		((MEMBER (CAR LINE)
			 TEM)
		  (SETQ GENLST (CONS (CONS (CAR LINE)
					   (GENSYM))
				     GENLST))

          (* This enables USE A B FOR B A, USE A FOR B AND B FOR A, or 
          USE A FOR B AND B C FOR A)


		  ]
          (COND
	    ((SETQ LINE (CDR LINE))
	      (GO LP)))
          (SELECTQ STATE
		   (VARS (SETQ VARS (NCONC1 VARS LST)))
		   (ARGS (SETQ ARGS (NCONC1 ARGS LST)))
		   (EXPR (SETQ EXPR LST))
		   (HELP))                      (* ARGS and VARS are lists of 
                                                lists.)
          [AND (NULL EXPR)
	       ARGS
	       (SETQ EXPR (LIST (QUOTE F)
				(CAAR ARGS]

          (* EXPR specifies expressions to be substituted INTO.
          E.g. USE FOO FOR FIE IN FUM or USE FOO FOR FIE.
          In latter case, searches for FIE.
          The F is added because of numbers, e.g. USE 3 FOR 4 means 
          find 4, whereas USE FOO FOR FIE IN 4 means the 4TH 
          expression back.)


          [AND (NULL ARGS)
	       (SETQ USE-ARGS (CADR (FMEMB (QUOTE USE-ARGS)
					   (LISPXFIND HISTORY EXPR
						      (QUOTE ENTRY)
						      T T]
          (SETQ EXPR (LISPXFIND HISTORY EXPR (QUOTE INPUT)
				T T))           (* EXPR now is the expression 
                                                (s) to be substituted into.)
          (COND
	    (ARGS                               (* Arguments specifically named 
                                                by user, i.e. USE ...
                                                FOR ...)
		  (SETQ USE-ARGS (CONS ARGS EXPR))

          (* To be saved in case user gives a use command referring to 
          this event.)


		  (SETQ EXPR (LIST EXPR))
		  (GO LP1))
	    (USE-ARGS                           (* Arguments specified by other 
                                                USE command.)
		      (SETQ ARGS (CAR USE-ARGS))
		      (SETQ EXPR (LIST (CDR USE-ARGS)))
		      [COND
			((AND (CDR ARGS)
			      (NULL (CDR VARS)))

          (* User types command of the form USE A FOR B AND C FOR D 
          and follows this with USE E F.)


			  (SETQ VARS (MAPCAR (CAR VARS)
					     (FUNCTION CONS]
		      (GO LP1))
	    ((OR (CDR VARS)
		 (FMEMB HISTSTR0 EXPR))

          (* More than one operation, but no ARGS.
          or else multiple arguments specified in the referent 
          operation, e.g. it was of the form USE A FOR B AND C FOR D.)


	      (GO ERROR))
	    (T [SETQ TEM (COND
		   ((CDR EXPR)
		     (CAR EXPR))
		   (T (CAAR EXPR]
	       [SETQ TEM (CDR (MAPCONC (CAR VARS)
				       (FUNCTION (LAMBDA (X)
					   (CONS HISTSTR0 (ESUBST X TEM
								  (COPY EXPR)
								  T]
                                                (* E.g. LOAD (FOO) followed by 
                                                USE MAKEFILE RECOMPILE.)
	       (GO OUT)))
      LP1 

          (* Argument names have either been supplied by user or 
          obtained implicitly from another USE command.)


          (SETQ EXPR (LISPXUSE1 (CAR VARS)
				(CAR ARGS)
				EXPR))
          (SETQ VARS (CDR VARS))
          (COND
	    ((SETQ ARGS (CDR ARGS))
	      (GO LP1))
	    (VARS (GO ERROR)))
          [MAPC GENLST (FUNCTION (LAMBDA (X)
		    (ESUBST (CAR X)
			    (CDR X)
			    EXPR T]
          [SETQ TEM (CDR (MAPCONC EXPR (FUNCTION (LAMBDA (X)
				      (CONS HISTSTR0 X]

          (* Samples: USE A B C D FOR X Y means substitute A FOR X AND 
          B FOR Y AND then do it again with C FOR X AND D FOR Y.
          This is equivalent to USE A C FOR X AND B D FOR Y except 
          that first case can be followed by USE E F and will 
          automatically substitute FOR X AND Y.
          -
          USE A B C FOR D AND X Y Z FOR W means three operations, with 
          A FOR D AND X FOR W in the first, B FOR D AND Y FOR W in the 
          second, etc. -
          USE A B C FOR D AND X FOR Y means three operations, first 
          with A FOR D AND X FOR Y second with B FOR D AND X FOR Y 
          etc. equivalent to USE X FOR Y AND A B C FOR D.
          -
          USE A B C FOR D AND X Y FOR Z causes error.
          -
          USE A B FOR B A will work correctly, but USE A FOR B AND B 
          FOR A will result in all B's being changed to A's.
          The general rule is substitution proceeds from left to right 
          with each 'AND' handled separately.
          Whenever the number of variables exceeds the number of 
          expressions available, the expressions multiply.)


      OUT (NCONC LSPXHST (LIST (QUOTE USE-ARGS)
			       USE-ARGS))
          (RETURN TEM)
      ERROR
          (ERROR (QUOTE "for what ?")
		 (QUOTE )
		 T])

(LISPXUSE1
  [LAMBDA (VARS ARGS EXPRS)
    (PROG ((V VARS)
	   (A ARGS)
	   (E (COPY EXPRS))
	   L VFLG AFLG EFLG TEM)
          (SETQ L E)
      LP  (COND
	    ((AND GENLST (SETQ TEM (SASSOC (CAR V)
					   GENLST))
		  (STRPOS (QUOTE )
			  (CAR A)))
	      (ERROR (QUOTE "sorry, that's too hard.")
		     (QUOTE )
		     T)))
          (ESUBST (OR (CDR TEM)
		      (CAR V))
		  (CAR A)
		  (CAR E)
		  T)
          (COND
	    ((NULL (SETQ V (CDR V)))
	      (SETQ VFLG T)))
          (COND
	    ((NULL (SETQ A (CDR A)))
	      (SETQ AFLG T)))
          (COND
	    ((AND A V)
	      (GO LP))
	    ((SETQ E (CDR E))
	      (GO LP1)))
          (COND
	    ((AND (NULL A)
		  (NULL V))
	      (RETURN L)))
          (SETQ EFLG T)
          [SETQ L (NCONC L (SETQ E (COPY EXPRS]
      LP1 (COND
	    ((AND EFLG VFLG AFLG)
	      (ERROR (QUOTE "huh??")
		     (QUOTE )
		     T)))
          (COND
	    ((NULL V)
	      (SETQ V VARS)))
          (COND
	    ((NULL A)
	      (SETQ A ARGS)))
          (GO LP])

(LISPXUSEC
  [LAMBDA (LINE HISTORY)

          (* A short version of the USE command.
          $ X Y is equivalent to USE $Y$ FOR $X$.
          user can also say $ X = Y or $ X -> Y or $ Y FOR X.
          User can specify event with IN.
          However, the distributivity of USE command is not allowed.
          (Note that $ can be ued even if character editing is not 
          being performed, e.g. $ FOO FIE is probably easier to type 
          than USE FIE FOR FOO.) If the event referred to contains an 
          ERROR property, $ first performs the substitution on that 
          argument, and then substitues the corrected offender into 
          the expression. If the user omits a second argument, e.g. 
          types $ FOO, the substitution is performed for the offender.
          (In this case there must be an ERROR property.))


    (PROG (LISPY LISPZ LISPXTEM LISPX1 LISPX2 LISPXIN LISPXHIST)

          (* LISPXHIST rebound to NIL so ESUBST doesn't put any side 
          information on history.)


          [COND
	    ((CDR (SETQ LISPXIN (FMEMB (QUOTE IN)
				       LINE)))

          (* May be of the form $ X IN -- or $ X Y IN --.
          Note that -- may specify a group.)


	      (SETQ LINE (LDIFF LINE LISPXIN))
	      (SETQ LISPY (LISPXFIND HISTORY (SETQ LISPXIN (CDR LISPXIN))
				     (QUOTE ENTRY)
				     T T)))
	    ((NULL (CDR LINE))                  (* Form is just $ X.)
	      (SETQ LISPY (LISPXFIND HISTORY NIL (QUOTE ENTRY)
				     T T]
          (COND
	    ((NULL (CDR LINE))
	      (COND
		([NULL (SETQ LISPZ (CDR (FMEMB (QUOTE *ERROR*)
					       LISPY]

          (* Since no second argument was specified, this has to be an 
          ERROR correction. Note that it may have been of the form $ X 
          or $ X IN --.)


		  (PRIN1 (QUOTE "no error in")
			 T)
		  (PRINTHISTORY1 (CADR LISPY)
				 (CAR LISPY)
				 NIL T)
		  (ERROR!)))
	      (SETQ LISPX1 (CAR LINE))
	      (SETQ LISPX2 (CAR LISPZ))
	      (GO OUT)))                        (* Identify substituTEE and 
                                                substituTOR.)
          [COND
	    ((CDDR LINE)
	      (SELECTQ (CADR LINE)
		       ((TO = ->)
			 (SETQ LISPX1 (CADDR LINE))
			 (SETQ LISPX2 (CAR LINE)))
		       (FOR (SETQ LISPX1 (CAR LINE))
			    (SETQ LISPX2 (CADDR LINE)))
		       (ERROR (CADR LINE)
			      (QUOTE " ?")
			      T)))
	    (T (SETQ LISPX1 (CADR LINE))
	       (SETQ LISPX2 (CAR LINE]
          [COND
	    ((NULL LISPY)                       (* Form of command is $ X Y.
                                                Search for Y.)
	      (SETQ LISPXTEM (COND
		  [(AND (NLISTP LISPX1)
			(NLISTP LISPX2)
			(NOT (STRPOS (QUOTE )
				     LISPX2)))
		    (PACK (LIST (QUOTE )
				LISPX2
				(QUOTE ]
		  (T LISPX2)))
	      (SETQ LISPY (LISPXFIND HISTORY (SETQ LISPXIN (LIST LISPXTEM))
				     (QUOTE ENTRY)
				     T T]
          (SETQ LISPZ (CDR (FMEMB (QUOTE *ERROR*)
				  LISPY)))

          (* To see if the event contains an error property.
          Note that even if the user identifies an event using IN, if 
          the event contains an offender, the character substitution 
          takes place only in the error, not in the whole expression.
          See comment below after EDITFINDP.)


      OUT (SETQ LISPY (COPY (LISPXFIND HISTORY LISPXIN (QUOTE INPUT)
				       T T)))

          (* Need another call to LISPXFIND even though we already 
          have the entry because LISPXFIND contains smarts about what 
          fields to extract, e.g. did use say $ X Y IN USE or $ X Y IN 
          -1, etc.)


          (COND
	    ((NULL LISPZ)

          (* The user is using $ to avoid having to type alt-modes 
          around his patterns, otherwise this is essentially a 
          simplified USE command. therefore perform the substitution 
          in the input, i.e. LISPY)


	      (GO OUT1)))                       (* There was an error in the 
                                                indicated event.)
          (SETQ LISPZ (CAR LISPZ))
          (COND
	    ((AND (EQ LISPX2 LISPZ)
		  (NUMBERP LISPX1))

          (* $ 1 2 will change all 1's to 2's occurring inside of 
          other atoms or strings. It will not change the number 1 to 
          the number 2.0 Therefore, this check is for the case where 
          the 'bad guy' was a number, and the user was typing in the 
          correct number in the form of $ number.
          this frequently happens for correction to EDIT commands, 
          e.g. user types (ri 1 33) meaning 
          (ri 1 3) and then corrects by $ 3)


	      (SETQ LISPXTEM LISPX1)
	      (AND (NULL EDITQUIETFLG)
		   (PRIN2 LISPX2 T T)
		   (PRIN1 (QUOTE ->)
			  T)
		   (PRINT LISPX1 T T))

          (* Since in all other cases, ESUBST will cause a message of 
          this form to be printed, we also do it here to be 
          consistent.)


	      )
	    [(NULL LINE)
	      (COND
		[(LITATOM LISPZ)

          (* The effect of this is to cause the operation that caused 
          the error to be reexecuted this time searching for something 
          thatis 'close' to the word producing the error, e.g. user 
          types INSERT -- AFTER CONDD and system types CONDD ? user 
          then types $ causing the command INSERT -- AFTER CONDD$$ to 
          be executed.)


		  (SETQ LISPXTEM (PACK (LIST LISPZ (QUOTE ]
		(T (ERROR (QUOTE " ? ")
			  (QUOTE )
			  T]
	    ([NULL (NLSETQ (SETQ LISPXTEM (ESUBST LISPX1 LISPX2
						  (COND
						    ((LISTP LISPZ)
						      (COPY LISPZ))
						    (T LISPZ))
						  NIL T]

          (* The indicated characters do not appear in LISPZ, the 
          offender. Therefore, perform the substitution in the input.)


	      (GO OUT1)))
          (COND
	    ((EDITFINDP LISPY LISPZ)
	      (RETURN (SUBST LISPXTEM LISPZ LISPY)))
	    (T (PRIN2 LISPZ T T)
	       (PRIN1 (QUOTE " does not appear in ")
		      T)
	       (PRINTHISTORY1 NIL LISPY NIL T)
	       (ERROR!)))
      OUT1(RETURN (ESUBST LISPX1 LISPX2 LISPY T T])

(PRINTHISTORY
  [LAMBDA (HISTORY LINE SKIPFN NOVALUES)
    (AND (EQ HISTORY EDITHISTORY)
	 (SETQ NOVALUES T))

          (* NOVALUES is T for printing EDITHISTORY, indicates not to 
          print the value. if it is non-atomic, it is a form which is 
          evaluated in PRINTHISTORY1 in lieu of printing the value.
          This form can also be obtained from the property list of the 
          entry under property print.)


    (PROG ((L (CAR HISTORY))
	   LST X Y Z ID HELPCLOCK)
          [SETQ LST (COND
	      ((NULL LINE)
		(CAR HISTORY))
	      (T (LISPXFIND HISTORY LINE (QUOTE ENTRIES]
          (TERPRI T)
          (TERPRI T)
      LP  (COND
	    ((NULL LST)
	      (TERPRI T)
	      (TERPRI T)
	      (RETURN)))
          (SETQ X (CAR LST))
          (COND
	    ((AND SKIPFN (APPLY* SKIPFN X))     (* If SKIPFN applied to this 
                                                entry is T, it is skipped.)
	      (GO LP2)))
          (PRIN2 (ENTRY# HISTORY X)
		 T T)
          (PRIN1 (QUOTE %.)
		 T)
          (SETQ ID (CADR X))
          (COND
	    ((SETQ Y (GET X (QUOTE *HISTORY*)))
                                                (* No i.d. And no value.)
                                                (* Print the history command 
                                                with no i.d. and no value.)
	      (PRINTHISTORY1 NIL Y NIL T)))
          (COND
	    ((NULL (SETQ Y (FMEMB (QUOTE *GROUP*)
				  X)))
	      (PRINTHISTORY1 ID (CAR X)
			     (CADDR X)
			     (COND
			       ((EQ NOVALUES T)
				 T)
			       (NOVALUES (APPLY* NOVALUES X)))
			     (GET X (QUOTE *PRINT*))
			     (GET X (QUOTE *LISPXPRINT*)))
	      (GO LP2)))
          (SETQ Y (CADR Y))
          (SETQ Z (CAR X))
      LP1 (PRINTHISTORY1 ID (LDIFF Z (SETQ Z (FMEMB HISTSTR0 Z)))
			 (COND
			   (Y (CAAR Y))
			   (T 

          (* Occurs when reexecuting a group of operations which are 
          aborted before completion so that not all have values.)


			      (QUOTE )))
			 (COND
			   ((EQ NOVALUES T)
			     T)
			   (NOVALUES (APPLY* NOVALUES Z)))
			 (GET (CAR Y)
			      (QUOTE *PRINT*))
			 (GET (CAR Y)
			      (QUOTE *LISPXPRINT*)))
          (SETQ Y (CDR Y))
          (SETQ Z (CDR Z))
          (COND
	    ((AND Y (EQ (CAR Z)
			HISTSTR2))
	      (SETQ Z (CAR X))
	      (GO LP1))
	    (Z (GO LP1)))
      LP2 (SETQ LST (CDR LST))
          (GO LP])

(ENTRY#
  [LAMBDA (HIST X)
    (COND
      ((NOT (IGREATERP [SETQ X (IPLUS (CADR HIST)
				      (IMINUS (FLENGTH (CAR HIST)))
				      (FLENGTH (FMEMB X (CAR HIST]
		       0))
	(IPLUS X (OR (CADDDR HIST)
		     100)))
      (T X])

(PRINTHISTORY1
  [LAMBDA (ID X VAL NOVALUES VALUEFORM OTHER)

          (* If NOVALUES is T, means suppress printing of value.
          VALUEFORM is a form obtained from the property PRINT and if 
          present is evaluated in lieu of printing the value.)


    (PROG (Y TEM)
          (COND
	    ((OR (NULL X)
		 (EQ (CAR X)
		     HISTSTR2))
	      (RETURN NIL)))
          (TAB 5 NIL T)
          (AND ID (PRIN2 ID T T))
      LP  [COND
	    ((SETQ Y (FMEMB HISTSTR0 X))
	      (SETQ X (LDIFF X Y]
          (COND
	    [(CDDR X)
	      (MAPRINT X T NIL NIL NIL (FUNCTION (LAMBDA (X FL)

          (* MAPRINT does an apply* with this argument on the thing to 
          be printed and the fl.)


			   (PRIN2 X FL T]
	    [(CDR X)                            (* APPLY input)
	      (PRIN2 (CAR X)
		     T T)
	      (COND
		((NULL (SETQ TEM (CADR X)))
		  (PRIN1 (COND
			   (#RPARS (QUOTE %]))
			   (T (QUOTE %(%))))
			 T))
		(T (COND
		     ((OR (ATOM TEM)
			  NOVALUES)

          (* If NOVALUES is T, ppobaby is printing editor history 
          list, so print the space.)


		       (SPACES 1 T)))
		   (PRIN2 TEM T T]
	    (T                                  (* EVAL input)
	       (PRIN2 (CAR X)
		      T T)))
          (TERPRI T)
          (COND
	    (Y (SETQ X (CDR Y))
	       (SPACES 5 T)
	       (GO LP)))
      OTHER
          [COND
	    (OTHER (MAPC OTHER (FUNCTION (LAMBDA (Z)
			     (COND
			       ((NLISTP Z)
				 (PRIN1 Z T))
			       (T (APPLY (CAR Z)
					 (CDR Z]
          (COND
	    (NOVALUES)
	    ((LISTP VALUEFORM)
	      (TAB 5 NIL T)
	      (EVAL VALUEFORM))
	    (T (TAB 5 NIL T)
	       (PRINT VAL T T])

(GREET
  [LAMBDA (NAME FLG)
    (PROG (INITLST TEM MESSAGE)
          (AND LISPXHIST (NOT (FMEMB (QUOTE SIDE)
				     LISPXHIST))
	       (LISPXPUT (QUOTE SIDE)
			 (LIST -1)
			 NIL LISPXHIST))
          (TERPRI T)
          (TERPRI T)
          (UNDOLISPX2 (LIST (QUOTE SIDE)
			    GREETHIST))
          (SETQ GREETHIST (GET LISPXHIST (QUOTE SIDE)))     (* Undoes previous 
                                                            greeting if any.)
          [COND
	    [(NLISTP (SETQ NAME (CDR (GREET1 NAME]
	    (T (SETQ TEM (CADR NAME))
	       (SETQ INITLST (CDDR NAME))
	       (SETQ NAME (CAR NAME]
          [/RPLACA (QUOTE FIRSTNAME)
		   (AND NAME (SETQ NAME (L-CASE NAME T]

          (* This initialization must be done before the any oother 
          initialzation, since the latter may use the systm 
          scratchlists. The rest of the initialziation, i.e. satinit, 
          however, is postponed until after the user has been greeted 
          (so he doesnt have to wait excessively long))


          (COND
	    ((AND (NEQ CONSOLETIME0 0)
		  (NULL FLG))

          (* If CONSOLETIME0 is not 0, the system initializatio has 
          already been done. In this case, it is not done again, 
          unless user specifies so by calling GREET with FLG=T.
          The user can call GREET with FLG=NIL to simply do his own 
          private initialiation, e.g. he is usig a SYSIN made by 
          another user.)


	      (GO A)))
          (SETQ SPELLINGS1 (APPEND SPELLINGS1))             (* Copies SPELLINGS1
                                                            to a private page.)
          (SETQ SPELLINGS2 (APPEND SPELLINGS2))
          (SETQ SPELLINGS3 (APPEND SPELLINGS3))
          (SETQ CHCONLST (APPEND CHCONLST))                 (* Used by COMMENT 
                                                            and by FIXBLOCK for 
                                                            calls to DCHCON and 
                                                            DUNPACK)
          (SETQ CHCONLST1 (APPEND CHCONLST))
          (SETQ CHCONLST2 (APPEND CHCONLST))                (* Used by editor)
          (SETQ SKORLST1 (APPEND CHCONLST))
          (SETQ SKORLST2 (APPEND CHCONLST))
          (SETQ SKORLST3 (APPEND CHCONLST))                 (* Used by CHOOZ and
                                                            SKOR)

          (* Note that CHCONLST, CHCONLST1, and CHCONLST2 are 
          initialized to NIL by EDIT and PRETTY.
          However, at that point DCHCON and DUNPACK are defined as 
          CHCON and UNPACK. Thus the loadup procedure implicitly 
          requires that if mac is loaded, i.e. DCHCON and DUNPACK 
          defined correctly, CHCONLST, CHCONLST1, and CHCONLST2 must 
          be initialized to lists, hence HIST must be loaded and GREET 
          executed.)


          (RPLSTRING MACSCRATCHSTRING 1 (QUOTE "Y"))
          (SETQ CONSOLETIME (SETQ CPUTIME (SETQ EDITIME 0)))
          (SETQ CONSOLETIME0 (CLOCK 0))
          (SETQ CPUTIME0 (CLOCK 2))
      A   [AND (LISTP TEM)
	       (MAPC TEM (FUNCTION (LAMBDA (X)
			 (ERSETQ (EVAL X]                   (* Initisliation to 
                                                            be done before 
                                                            greeting, e.g. 
                                                            adding dates to 
                                                            greeting list.)
          (GREET0 GREETLST)
          (STATINIT)
          (GREET3 INITLST)
          (AND MESSAGE (LISPXPRINT MESSAGE T T))
          (RETURN T])

(GREET0
  [LAMBDA NIL
    (AND GREETDATES
	 (RESETVAR RANDSTATE T
	   (PROG (TEM DATE HOUR)
	         [SETQ HOUR (SUB1 (STRPOS (QUOTE :)
					  (SETQ DATE (DATE]
	         [SETQ HOUR (COND
		     ((EQ (NTHCHAR (SETQ HOUR (SUBSTRING DATE (SUB1 HOUR)
							 HOUR))
				   1)
			  (QUOTE % ))
		       (NTHCHAR HOUR 2))
		     (T (MKATOM HOUR]                       (* HOUR is now the 
                                                            number before the 
                                                            first : in the 
                                                            DATE.)
	         [COND
		   [[AND CUTEFLG (EQ (RAND 1 2)
				     1)
			 (SETQ TEM (CDR (SASSOC (SUBSTRING DATE 1 6)
						(APPEND GREETLST GREETDATES]
		     (SETQ TEM (GREET2 TEM (QUOTE !]
		   (T (SETQ TEM (GREET2 (CDR (ASSOC (COND
						      ((AND FIRSTNAME
							    (ILESSP HOUR 6))
							(QUOTE LATE))
						      ((ILESSP HOUR 12)
							(QUOTE MORNING))
						      ((ILESSP HOUR 18)
							(QUOTE AFTERNOON))
						      (T (QUOTE EVENING)))
						    (APPEND GREETLST GREETIMES))
					     )
					(QUOTE %.]
	         (COND
		   (FIRSTNAME (LISPXPRIN1 (QUOTE ", ")
					  T)
			      (LISPXPRIN1 FIRSTNAME T)))
	         (LISPXPRIN1 TEM T)
	         (LISPXTERPRI T])

(GREET1
  [LAMBDA (NAME)
    (PROG (TEM FL N)
          (COND
	    ([OR (NULL (SETQ N (USERNUMBER NAME)))
		 (NULL (SETQ FL (INFILEP USERNAMEFILE]
	      (RETURN NIL)))
          (INFILE FL)
          [COND
	    ((NEQ (SETQ TEM (READ NIL FILERDTBL))
		  0)                            (* Forms to be evaluated for 
                                                everyone, i.e. this provides a 
                                                patching facility.)
	      (SFPTR FL TEM)
	      (GREET3 (READ NIL FILERDTBL]
          (SFPTR FL (ITIMES 6 N))
          (RETURN (PROG1 (COND
			   ((EQ (SETQ TEM (READ NIL FILERDTBL))
				0)

          (* (USERAME N) used instead of just NAME, because NAME may 
          contain alt-modes.)


			     (/RPLACA (QUOTE USERNAME)
				      (MKATOM (USERNAME N)))
			     NIL)
			   (T (SFPTR FL TEM)
			      [/RPLACA (QUOTE USERNAME)
				       (CAR (SETQ TEM (READ NIL FILERDTBL]
			      TEM))
			 (CLOSEF])

(GREET2
  [LAMBDA (X Y)
    (PROG (TEM)
          [COND
	    ((NULL (CDR X))
	      (SETQ X (CAR X]
      TOP [COND
	    ((NLISTP X)
	      (LISPXPRIN1 X T T)
	      (RETURN Y))
	    ((NLISTP (CDR X))
	      (LISPXPRIN1 (OR (STRINGP (CAR X))
			      (EVAL (CAR X)))
			  T)
	      (RETURN (CDR X]
      LP  (COND
	    ((OR [NLISTP (SETQ TEM (CAR (NTH X (RAND 1 (LENGTH X]
		 CUTEFLG)
	      (SETQ X TEM)
	      (GO TOP)))
          (GO LP])

(GREET3
  [LAMBDA (LST)
    (AND LST (RESETLST (RESETSAVE USERWORDS USERWORDS)
		       (RESETSAVE CHANGEDFNSLST CHANGEDFNSLST)
		       (RESETSAVE CHANGEDVARSLST CHANGEDVARSLST)
		       (RESETSAVE DFNFLG T)
		       (PROG ((HELPCLOCK (CLOCK 2)))
			     (MAPC LST (FUNCTION (LAMBDA (X)
				       (ERSETQ (EVAL (LISPX/ X])

(ADDSTATS
  [NLAMBDA STATLST

          (* EAch statistic is a list -
          e.g. (LISPXSTATS LISPX INPUTS), 
          (UNDOSAVES UNDO SAVES))


    (AND (ARRAYP (CAR (QUOTE STATARRAY)))
	 (PROG ((OLDA STATARRAY)
		N)
	       (/NCONC SYSTATS STATLST)
	       (STATINIT)
	       (SETQ N (ARRAYSIZE OLDA))
	   LP  (SETA STATARRAY N (ELT OLDA N))
	       (COND
		 ([NOT (ZEROP (SETQ N (SUB1 N]
		   (GO LP)))
	       (RETURN STATLST])

(CHANGESLICE
  [LAMBDA (N HISTORY L)

          (* Undoing a CHANGSLICE involves another call to 
          CHANGESLICE, because you can't just replace the 
          pointers because of the ring buffer aspect of the 
          history list. In other words, the place where events 
          was deleted may now be the beginning of the history 
          list. Therefore, L represents the forgotten events 
          if any, in the case that the history list is being 
          enlarged by virtue of undoing a CHANGESLICE.)


    [COND
      ((ILESSP N 2)
	(ERROR (QUOTE "TOO SMALL")
	       (QUOTE )))
      ((NULL HISTORY)
	(CHANGESLICE N LISPXHISTORY)
	(CHANGESLICE N EDITHISTORY))
      (T (NCONC (CAR HISTORY)
		L)                              (* Add forgotten events,
                                                if any.)
	 (UNDOSAVE [LIST (QUOTE CHANGESLICE)
			 (CADDR HISTORY)
			 HISTORY
			 (CDR (SETQ L (NTH (CAR HISTORY)
					   N]
		   LISPXHIST)
	 (FRPLACA (CDDR HISTORY)
		  N)
	 (FRPLACD (CDDR HISTORY)
		  (LIST (ITIMES (ADD1 (IQUOTIENT (SUB1 N)
						 100))
				100)))
	 (COND
	   (L                                   (* Chop off the extra 
                                                events.)
	      (FRPLACD L]
    N])

(LISPXSTATE
  [LAMBDA (NAME STATE)                          (* STATE is either 'BEFORE' or 
                                                'AFTER')
    (PROG (X Y)
          [COND
	    ([NULL (SETQ X (GETP NAME (QUOTE STATE]
                                                (* First time STATE command used
                                                with NAME.)
	      [COND
		([NULL (SETQ Y (GETP NAME (QUOTE *HISTORY*]
		  (ERROR NAME (QUOTE " ?")
			 T))
		((EQ STATE (QUOTE AFTER))
		  (RETURN (QUOTE WAS]
	      (MAPC Y (FUNCTION UNDOLISPX2))
	      (/PUT NAME (QUOTE STATE)
		    (CONS (QUOTE BEFORE)
			  LISPXHIST)))
	    ((EQ STATE (CAR X))
	      (RETURN (QUOTE WAS)))
	    (T (UNDOLISPX2 X)
	       (/PUT NAME (QUOTE STATE)
		     (CONS STATE LISPXHIST]
          (RETURN STATE])

(LISPXTYPEAHEAD
  [LAMBDA NIL
    (PROG (X L)
      LP  (PRIN1 (QUOTE >)
		 T)
          [NLSETQ (SELECTQ (SETQ X (LISPXREAD T T))
			   ((OK GO)
			     (MAPC L (FUNCTION LISPXUNREAD))
			     (RETFROM (QUOTE LISPXTYPEAHEAD)))
			   (STOP (RETFROM (QUOTE LISPXTYPEAHEAD)))
			   (FIX (SETQ L (EDITE L)))
			   (Q (PRIN1 (QUOTE \\)
				       T)
				(PRINT (COND
					 ((NLISTP (SETQ X (CAR L)))
					   X)
					 (T (CAR X)))
				       T T)
				(SETQ L (CDR L)))
			   [?? (MAPC (REVERSE L)
				     (FUNCTION (LAMBDA (X)
					 (PRINTHISTORY1 (QUOTE >)
							X NIL T]
			   (SETQ L
			     (CONS [COND
				     ((OR (LISTP X)
					  (NULL (READP T)))
				       (LIST X))
				     (T 

          (* The extra argument to READLINE is so that a line 
          consisting of just %], e.g. FOO%] will read is as 
          (NIL) instead of NIL.)


					(CONS X (READLINE T NIL T]
				   L]
          (GO LP])

(LISPXPRINT
  [LAMBDA (X Y Z NODOFLG)

          (* This same definition is used for LISPXPRIN1, LISPXPRIN2, 
          LISPXTERPRI, LISPXSPACES, and LISPXTAB.
          (This implementations is a little more expensive when the 
          featre is actually used than having separate functions for 
          each of the io functions, but it requires less space, and 
          therefore does not penalize people that don't ue the 
          feaure.))


    ([LAMBDA (POS)                              (* This has the avantage of 
                                                working both compiled 
                                                andinterpreted.)
	(PROG (FN TEM)
	      (SETQ FN (STKNAME POS))
	      (RELSTK POS)
	      [SETQ FN (SELECTQ FN
				(LISPXPRIN1 (AND (EQ Y T)
						 (NLISTP X)
						 (SETQ TEM X))
                                                (* The atom or string itself 
                                                will be stored. This saves 3 
                                                cells.)
					    (QUOTE PRIN1))
				(LISPXPRIN2 (QUOTE PRIN2))
				(LISPXPRINT (QUOTE PRINT))
				(LISPXTERPRI (AND (EQ X T)
						  (SETQQ TEM %
))
					     (QUOTE TERPRI))
				(LISPXSPACES (AND (EQ Y T)
						  (EQ X 1)
						  (SETQQ TEM % ))
					     (QUOTE SPACES))
				(COND
				  ((NULL (STRPOS (QUOTE LISPX)
						 FN NIL NIL T))
				    (HELP FN))
				  (T (MKATOM (SUBSTRING FN 6 -1]
	      (AND LISPXPRINTFLG LISPXHIST
		   (LISPXPUT (QUOTE *LISPXPRINT*)
			     [LIST (OR TEM (CONS FN (NLIST X Y Z]
			     T LISPXHIST))
	      (RETURN (AND (NULL NODOFLG)
			   (APPLY* FN X Y Z]
      (STKNTH -1])

(LISPXPUT
  [LAMBDA (PROP L ADDFLG LST)
    (PROG (Y)
          (AND (NULL LST)
	       (SETQ LST (CAAR LISPXHISTORY)))

          (* Puts property at top level of entry.
          Used mostly for calls with PROP=ERROR.)


          [COND
	    [(SETQ Y (CDR (FMEMB PROP LST)))
	      (FRPLACA Y (COND
			 (ADDFLG (NCONC (CAR Y)
					L))
			 (T L]
	    (T (NCONC LST (LIST PROP L]
          (RETURN L])
)
  (RPAQ LISPXBUFS)
  (RPAQ TOPLISPXBUFS)
  (RPAQ LISPXHIST)
  (RPAQ LISPXUSERFN)
  (RPAQ ARCHIVEFN)
  (RPAQ ARCHIVEFLG T)
  [RPAQQ LISPXMACROS ([??T (PROG (TEM)
				 (RESETVAR PRETTYTRANFLG T
					   (PRINTDEF (COND
						       ([NULL (CDAR (SETQ TEM
									  (LISPXFIND
									    LISPXHISTORY 
									    LISPXLINE
									    (QUOTE ENTRY)
									    T]
							(CAAR TEM))
						       (T (CAR TEM)))
						     NIL T))
				 (TERPRI T)
				 (RETURN (CADDR TEM]
	  (LISP (SUBSYS (QUOTE LISP)))
	  (EXEC (SUBSYS))
	  (SNDMSG (SUBSYS (QUOTE SNDMSG)))
	  [RETRIEVE (PROG ((X (GETP (CAR LISPXLINE)
				    (QUOTE *HISTORY*)))
			   REREADFLG)
			  (COND ((NULL X)
				 (ERROR (CAR LISPXLINE)
					(QUOTE " ?")
					T)))
			  [MAPC X (FUNCTION (LAMBDA (X)
						    (HISTORYSAVE LISPXHISTORY X]
			  (RETURN (CAR LISPXLINE]
	  (BEFORE (LISPXSTATE (CAR LISPXLINE)
			      (QUOTE BEFORE)))
	  (AFTER (LISPXSTATE (CAR LISPXLINE)
			     (QUOTE AFTER)))
	  (SY (TENEX (QUOTE "SY
")))
	  [DIR (TENEX (COND ((NULL LISPXLINE)
			     (QUOTE "DIR
"))
			    (T (SETQ LISPXLINE (MKSTRING LISPXLINE))
			       (GNC LISPXLINE)
			       (GLC LISPXLINE)
			       (CONCAT (QUOTE "DIR ")
				       LISPXLINE
				       (QUOTE "
"]
	  [OK (RETFROM (OR (STKPOS (QUOTE USEREXEC))
			   (QUOTE LISPX]
	  (CONTIN (SUBSYS T]
  (RPAQ LISPXHISTORYMACROS)
  (RPAQQ LISPXCOMS
	 (REDO RETRY FIX USE  ... UNDO ?? NAME RETRIEVE BEFORE AFTER TYPE-AHEAD ARCHIVE 
	       FORGET BUFS CONTIN ??T))
  (RPAQQ LISPXHISTORY (NIL 0 30 100))
  (RPAQQ ARCHIVELST (NIL 0 50 100))
  (RPAQQ EDITHISTORY (NIL 0 30 100))
  (RPAQQ SYSTATS ((LISPXSTATS LISPX INPUTS)
	  (UNDOSAVES UNDO SAVES)
	  (UNDOSTATS CHANGES UNDONE)
	  NIL
	  (EDITCALLS CALLS TO EDITOR)
	  (EDITSTATS EDIT COMMANDS)
	  (EDITUNDOSAVES EDIT UNDO SAVES)
	  (EDITUNDOSTATS EDIT CHANGES UNDONE)
	  NIL
	  (P.A.STATS P.A. COMMANDS)
	  NIL
	  (CLISPIFYSTATS CALLS TO CLISPIFY)
	  NIL
	  (FIXCALLS CALLS TO DWIM)
	  (FIXTIME)
	  (ERRORCALLS WERE DUE TO ERRORS)
	  (DWIMIFYFIXES WERE FROM DWIMIFYING)
	  NIL "OF THOSE DUE TO ERRORS:" (TYPEINFIXES WERE DUE TO ERRORS IN TYPE-IN)
	  (PROGFIXES WERE DUE TO ERRORS IN USER PROGRAMS)
	  (SUCCFIXES1 OF THESE CALLS WERE SUCCESSFUL)
	  NIL "OF THE CALLS DUE TO DWIMIFYING:" (SUCCFIXES2 WERE SUCCESSFUL)
	  NIL
	  (SPELLSTATS OF ALL DWIM CORRECTIONS WERE SPELLING CORRECTIONS)
	  (CLISPSTATS WERE CLISP TRANSFORMATIONS)
	  (INFIXSTATS OF THESE WERE INFIX TRANSFORMATIONS)
	  (IFSTATS WERE IF/THEN/ELSE STATEMENTS)
	  (I.S.STATS WERE ITERATIVE STATEMENTS)
	  (MATCHSTATS WERE PATTERN MATCHES)
	  (RECORDSTATS WERE RECORD OPERATIONS)
	  NIL
	  (SPELLSTATS1 OTHER SPELLING CORRECTIONS, E.G. EDIT COMMANDS)
	  NIL
	  (RUNONSTATS OF ALL SPELLING CORRECTIONS WERE RUN-ON CORRECTIONS)
	  NIL
	  (VETOSTATS CORRECTIONS WERE VETOED)
	  NIL))
  (RPAQ GREETHIST)
  (RPAQ GREETCLK)
  (RPAQ CUTEFLG T)
  (RPAQQ GREETDATES ((" 1-APR" (PROGN (DISMISS 5000)
				      (PRIN1 (QUOTE "TENEX RESTARTING, WAIT..."))
				      (DISMISS 5000)
				      (QUOTE "

April Fool")))
	  ("12-FEB" . "Happy Lincoln's birthday")
	  ("14-FEB" . "Happy Valentine's day")
	  ("22-FEB" . "Happy Washington's birthday")
	  ("15-MAR" . "Beware the Ides of March")
	  ("17-MAR" . "Happy St. Patrick's day")
	  ("31-OCT" . "Trick or Treat")
	  ("22-NOV" . "Happy Thanksgiving")
	  ("25-DEC" . "Merry Christmas")
	  (" 1-JAN" . "Happy new year")))
  (RPAQ GREETLST)
  (RPAQQ GREETIMES ((MORNING "Good morning" "Good morning" Hello Hi)
	  (AFTERNOON "Good afternoon" "Good afternoon" Hello Hi)
	  (EVENING "Good evening" "Good evening" Hello Hi)
	  (LATE ("It's past your bedtime" . !)
		("You're working late tonight" . !)
		Hello Hi Hello Hi)))
  (RPAQ NEWUSERFLG)
  (RPAQ USERNAME)
  (RPAQ CONSOLETIME 0)
  (RPAQ CONSOLETIME0 0)
  (RPAQ CPUTIME 0)
  (RPAQ CPUTIME0 0)
  (RPAQ EDITIME 0)
  (RPAQ PROMPT#FLG)
  (RPAQ LISPXPRINTFLG T)
  [RPAQQ DUMPSTATSVARS ((E (SETQ CONSOLETIME (IPLUS CONSOLETIME (IDIFFERENCE (CLOCK 0)
									     CONSOLETIME0)))
			   (SETQ CPUTIME (IPLUS CPUTIME (IDIFFERENCE (CLOCK 2)
								     CPUTIME0)))
			   (SETQ CONSOLETIME0 (CLOCK 0))
			   (SETQ CPUTIME0 (CLOCK 2)))
	  (VARS CPUTIME (CPUTIME0 (CLOCK 2))
		CONSOLETIME
		(CONSOLETIME0 (CLOCK 0))
		EDITIME SYSTATS RESPELLS)
	  (ARRAY STATARRAY)
	  (P (STATINIT T]
  (RPAQQ USERNAMEFILE <LISP>USERNAMEFILE)
  (RPAQ FIRSTNAME)
  (RPAQ SYSOUTGAG)
  [MAPC (QUOTE (LISPXPRIN1 LISPXPRIN2 LISPXTERPRI LISPXSPACES LISPXTAB))
	(FUNCTION (LAMBDA (X)
			  (MOVD (QUOTE LISPXPRINT)
				X]
  [MAPC SYSTATS (FUNCTION (LAMBDA (X)
				  (AND (LISTP X)
				       (EQ (CAAR X)
					   (QUOTE NOBIND))
				       (RPLACA (CAR X)
					       NIL]
(DEFLIST(QUOTE(
  [SYSOUT (NIL [BEFORE NIL (SETQ CONSOLETIME (IPLUS CONSOLETIME (IDIFFERENCE (CLOCK 0)
									     CONSOLETIME0]
	       [BEFORE NIL (SETQ CPUTIME (IPLUS CPUTIME (IDIFFERENCE (CLOCK 2)
								     CPUTIME0]
	       (AFTER NIL (SETQ CONSOLETIME0 (CLOCK 0)))
	       (AFTER NIL (SETQ CPUTIME0 (CLOCK 2)))
	       (AFTER NIL (SETQ GREETCLK (CLOCK 3)))
	       [AFTER NIL (AND (LISTP !VALUE)
			       (PROGN (AND DRIBBLEFILE (SETQ DRIBBLEFILE T)
					   (DRIBBLE)
					   (LISPXPRIN1 (QUOTE 
						       "Note: dribble file now turned off
")
						       T))
				      (KFORK T)
				      (COND ((LISTP SYSOUTGAG)
					     (EVAL SYSOUTGAG))
					    (SYSOUTGAG)
					    ([OR (NULL USERNAME)
						 (EQ USERNAME (MKATOM (USERNAME]
					     (PRIN1 HERALDSTRING T)
					     (TERPRI T)
					     (TERPRI T)
					     (GREET0)
					     (TERPRI T))
					    (T (LISPXPRIN1 (QUOTE "****ATTENTION USER ")
							   T)
					       (LISPXPRIN1 (USERNAME)
							   T)
					       (LISPXPRIN1 (QUOTE 
						   ":
this sysout is initialized for user ")
							   T)
					       (LISPXPRIN1 USERNAME T)
					       (LISPXPRIN1 (QUOTE ".
")
							   T)
					       (LISPXPRIN1 (QUOTE 
							   "To reinitialize, type GREET()
")
							   T]
	       (BEFORE NIL (SETQ SYSOUTDATE (DATE]
  [MAKESYS (NIL (BEFORE NIL (PROGN (UNDOLISPX2 (LIST (QUOTE SIDE)
						     GREETHIST))
				   (SETQ GREETHIST NIL)
				   (SETQ GREETCLK 1000000)))
		(BEFORE NIL (SETQ MAKESYSDATE (DATE)))
		(BEFORE NIL (HERALD (SETQ HERALDSTRING
					  (CONCAT "
" (OR V "INTERLISP-10")
						  "  "
						  (SUBSTRING (SETQ TEM (DATE))
							     1
							     (IPLUS 2 (STRPOS (QUOTE -)
									      TEM 4)))
						  " ..."]
))(QUOTE READVICE))
  (READVISE SYSOUT MAKESYS)
  [RPAQQ HISTBLOCKS
	 ((LISPXBLOCK EVALQT USEREXEC LISPXREAD LISPXREADP LISPXUNREAD LISPX HISTORYSAVE LISPX/ 
		      LISPX/1 (ENTRIES EVALQT USEREXEC LISPX LISPX/ HISTORYSAVE LISPXREAD 
				       LISPXREADP LISPXUNREAD)
		      (NOLINKFNS LISPXTYPEAHEAD UNDOLISPX ARCHIVEFN)
		      (LINKFNS . T)
		      (SPECVARS LISPXLINE LISPXID LISPXVALUE LISPXLISTFLG)
		      (RETFNS LISPX)
		      (LOCALFREEVARS VARS)
		      (GLOBALVARS P.A.STATS EDITSTATS LISPXSTATS CLEARSTKLST)
		      (BLKLIBRARY LISPXWATCH GETP))
	  (LISPXFINDBLOCK LISPXFIND LISPXFIND0 LISPXFIND1 HISTORYFIND HISTORYFIND1 VALUEOF 
			  LISPXUSE LISPXUSE1 LISPXUSEC (ENTRIES LISPXFIND VALUEOF LISPXUSE 
								LISPXUSEC HISTORYFIND)
			  (LOCALFREEVARS _FLG L LST Z =FLG HISTORYFLG GENLST)
			  (GLOBALVARS LASTHISTORY ARCHIVEFLG))
	  (GREETBLOCK GREET GREET0 GREET1 GREET2 GREET3 (ENTRIES GREET GREET0)
		      (GLOBALVARS GREETDATES GREETLST GREETIMES GREETHIST CONSOLETIME0 EDITIME 
				  CPUTIME CONSOLETIME CPUTIME0 USERNAMEFILE FIRSTNAME USERNAME 
				  NEWUSERFLG)
		      (SPECVARS INITLST GREETLST NAME MESSAGE))
	  (NIL LISPXEVAL LISPXFIND1 PRINTHISTORY ENTRY# PRINTHISTORY1 LISPXTYPEAHEAD LISPXPRINT 
	       LISPXPUT (LINKFNS . T)
	       (NOLINKFNS PRINTHISTORY1]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
  (BLOCK: LISPXBLOCK EVALQT USEREXEC LISPXREAD LISPXREADP LISPXUNREAD LISPX HISTORYSAVE LISPX/ 
	  LISPX/1 (ENTRIES EVALQT USEREXEC LISPX LISPX/ HISTORYSAVE LISPXREAD LISPXREADP 
			   LISPXUNREAD)
	  (NOLINKFNS LISPXTYPEAHEAD UNDOLISPX ARCHIVEFN)
	  (LINKFNS . T)
	  (SPECVARS LISPXLINE LISPXID LISPXVALUE LISPXLISTFLG)
	  (RETFNS LISPX)
	  (LOCALFREEVARS VARS)
	  (GLOBALVARS P.A.STATS EDITSTATS LISPXSTATS CLEARSTKLST)
	  (BLKLIBRARY LISPXWATCH GETP))
  (BLOCK: LISPXFINDBLOCK LISPXFIND LISPXFIND0 LISPXFIND1 HISTORYFIND HISTORYFIND1 VALUEOF 
	  LISPXUSE LISPXUSE1 LISPXUSEC (ENTRIES LISPXFIND VALUEOF LISPXUSE LISPXUSEC 
						HISTORYFIND)
	  (LOCALFREEVARS _FLG L LST Z =FLG HISTORYFLG GENLST)
	  (GLOBALVARS LASTHISTORY ARCHIVEFLG))
  (BLOCK: GREETBLOCK GREET GREET0 GREET1 GREET2 GREET3 (ENTRIES GREET GREET0)
	  (GLOBALVARS GREETDATES GREETLST GREETIMES GREETHIST CONSOLETIME0 EDITIME CPUTIME 
		      CONSOLETIME CPUTIME0 USERNAMEFILE FIRSTNAME USERNAME NEWUSERFLG)
	  (SPECVARS INITLST GREETLST NAME MESSAGE))
  (BLOCK: NIL LISPXEVAL LISPXFIND1 PRINTHISTORY ENTRY# PRINTHISTORY1 LISPXTYPEAHEAD LISPXPRINT 
	  LISPXPUT (LINKFNS . T)
	  (NOLINKFNS PRINTHISTORY1))
]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA ADDSTATS VALUEOF)
  (ADDTOVAR NLAML)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (4577 81107 (EVALQT 4589 . 5929) (USEREXEC 5933 . 6269) (LISPXREAD 6273 . 8726)
(LISPXREADP 8730 . 9105) (LISPXUNREAD 9109 . 9232) (LISPX 9236 . 28492) (LISPX/ 28496 . 29952)
(LISPX/1 29956 . 32609) (LISPXEVAL 32613 . 33124) (HISTORYSAVE 33128 . 38422) (LISPXFIND 38426
. 42756) (LISPXFIND0 42760 . 45153) (LISPXFIND1 45157 . 45496) (HISTORYFIND 45500 . 48391)
(HISTORYFIND1 48395 . 49905) (VALUEOF 49909 . 50339) (LISPXUSE 50343 . 56908) (LISPXUSE1 56912
. 57968) (LISPXUSEC 57972 . 64191) (PRINTHISTORY 64195 . 66661) (ENTRY# 66665 . 66907) (
PRINTHISTORY1 66911 . 68627) (GREET 68631 . 72351) (GREET0 72355 . 73674) (GREET1 73678 .
74661) (GREET2 74665 . 75126) (GREET3 75130 . 75462) (ADDSTATS 75466 . 75919) (CHANGESLICE
75923 . 77210) (LISPXSTATE 77214 . 78032) (LISPXTYPEAHEAD 78036 . 78984) (LISPXPRINT 78988
. 80682) (LISPXPUT 80686 . 81104)))))
STOP
