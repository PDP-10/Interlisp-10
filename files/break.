(FILECREATED " 5-OCT-74 19:44:50" BREAK.;8 50488  

     changes to:  BREAKCOM2

     previous date: " 3-OCT-74 09:19:20" BREAK.;7)


  (LISPXPRINT (QUOTE BREAKCOMS)
	      T T)
  [RPAQQ BREAKCOMS ((FNS * BREAKFNS)
	  (VARS BREAKMACROS BREAKI NBREAKS NOBREAKS NOBREAKIN BREAKCOMSLST (BRKFILE T)
		(BROKENFNS)
		(BRKINFOLST)
		BAKTRACELST
		(BREAKRESETFORMS))
	  (BLOCKS * BREAKBLOCKS)
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
		    (ADDVARS (NLAMA TRACE REBREAK UNBREAK BREAK BREAK3)
			     (NLAML BREAKNARGS BREAKIN BREAK1]
  (RPAQQ BREAKFNS
	 (BREAK1 BREAKCOM BREAKCOM1 BREAKCOM2 BREAKEXIT BREAK2 BREAK?= BREAK= STKPOZ STKPOZ1 
		 STKPOZ2 BREAKREAD BAKTRACE BAKTRACE1 BAKTRACE3 BREAK3 BREAK BREAK0 BREAK0A 
		 UNBREAK UNBREAK0 REBREAK REBREAK0 TRACE BREAKIN BREAKIN1 UNBREAKIN SAVED 
		 SAVED1 GENSYM? RESTORENAMES VIRGINFN RESTORE PACK-IN- BREAKNARGS))
(DEFINEQ

(BREAK1
  [NLAMBDA (BRKEXP BRKWHEN BRKFN BRKCOMS BRKTYPE)
                                                (* BRKTYPE is for USE by DWIM 
                                                and HELPFIX.)
    (COND
      ((NULL (EVAL BRKWHEN (QUOTE BREAK-EXP)))
	(EVAL BRKEXP (QUOTE BREAK-EXP)))
      (T ([LAMBDA (NBREAKS)
	     (PROG (BRKID BRKVALUE !VALUE (LASTPOS (STKNTH (COND
							     ((AND BRKTYPE 
							       SPAGHETTIFLG)
							       -2)
							     (T -1))
							   (QUOTE BREAK1)))
			  HELPCLOCK BRKRDBUF BRKBUFS (TYPE-IN (NULL BRKCOMS))
			  (BRKFIL (OR (NULL BRKCOMS)
				      BRKFILE))
			  BRKRESETLST)

          (* BRKFIL is used for output only when BRKCOMS are not NIL, 
          e.g. for tracing. In this case, by setting BRKFILE to the 
          name of a file, the user can redirect the output to a file.)


	           (COND
		     ((AND LISPXHISTORY (NEQ CLEARSTKLST T))
		       (SETQ CLEARSTKLST (CONS LASTPOS CLEARSTKLST))
                                                (* In case user control-D's out 
                                                of the break, this will RELSTK 
                                                LASPOS.)
		       (AND (STACKP BRKTYPE)
			    (SETQ CLEARSTKLST (CONS BRKTYPE CLEARSTKLST)))

          (* occurs on ERRORX breaks. BRKTYPE will be used by the 
          RETFROM that is waiting to be called with the value returned 
          by BREAK1 as its second argument.)


		       ))
	           [COND
		     [(AND (NULL BRKFN)
			   (NLISTP BRKTYPE))

          (* The message (NIL broken) only makes sense for U.D.F.
          NIL breaks, in which case BRKTYPE is a list.
          For all others, the message is just 
          (broken))


		       (SETQ BRKID (QUOTE (broken]
		     [(ATOM BRKFN)
		       (SETQ BRKID (LIST BRKFN (QUOTE broken]
		     (T (SETQ BRKID BRKFN)
			(SETQ BRKFN (LIST (CAR BRKFN]
	           (COND
		     (BRKTYPE 

          (* Not a user BREAK. the buffers will be restored when the 
          BREAK is left.)


			      (SETQ BRKRDBUF READBUF)
			      [SETQ BRKBUFS (CLBUFS (EQ BRKTYPE (QUOTE 
								  INTERRUPT]
			      (SETQ READBUF NIL)
			      (AND (EQ BRKTYPE (QUOTE ERRORX))
				   (EQ (CAR (ERRORN))
				       2)
				   (SETQ LASTPOS (STKNTH -1 LASTPOS)))
                                                (* This to avoid garbage 
                                                backtraces.)
			      ))
	           (BREAKCOM2 T)

          (* BREAKRESETFORMS are a list of forms suitable for use in a 
          rsetform which are to be executed, bt their execution made 
          transparent to the evaluation of the break expression.
          thus they are restored before doing an EVAL, OK, GO, RETURN, 
          or REVERT, aand then reexecuted when entering or returning 
          into a break. especially useful for debugging ppograms that 
          fool around with i/o)


	           (COND
		     ((NEQ (CAR BRKCOMS)
			   (QUOTE TRACE))
		       (GO TOP)))
	           (TERPRI BRKFIL)
	           (BREAK2)                     (* Indents appropriate number of
                                                spaces.)
	           (PRIN2 BRKFN BRKFIL T)
	           (PRINT (QUOTE :)
			  BRKFIL T)
	           (SETQ BRKCOMS (CDR BRKCOMS))
	           (GO LP)
	       TOP (TERPRI BRKFIL)
	           (BREAK2)
	           (PRINT [COND
			    ((ATOM BRKFN)
			      BRKID)
			    (T (LIST BRKFN (QUOTE broken]
			  BRKFIL T)
	       LP  [COND
		     [BRKCOMS (COND
				([ERSETQ (BREAKCOM (PROG1 (CAR BRKCOMS)
							  (SETQ BRKCOMS
							    (CDR BRKCOMS]
				  (GO LP]
		     (T (NLSETQ (PROMPTCHAR (QUOTE :)
					    T LISPXHISTORY))
			(COND
			  ((ERSETQ (BREAKCOM (LISPXREAD T T)
					     T))
			    (GO LP]
	       ERROR
	           (SETQ LISPXBUFS (OR (CLBUFS)
				       LISPXBUFS))
                                                (* For a CONTINUE command WITHIN
                                                this BREAK.)
	           (SETQ READBUF NIL)

          (* We don't worry about saving READBUF on user induced 
          interruptions, e.g. control-d control-e since he can always 
          use REDO or RETRY.)


	           (SETQ BRKCOMS NIL)
	           (SETQ BRKFIL T)
	           (AND BREAKRESETFORMS (NULL BRKRESETLST)
			(BREAKCOM2 T))

          (* E.g. error occurred inside of an EVAL or OK, like from a 
          lower break exited via ^.)


	           (PRIN2 BRKID T T)
	           (TERPRI T)
	           (GO LP]
	   (ADD1 NBREAKS])

(BREAKCOM
  [LAMBDA (BRKCOM TYPE-IN)
    (PROG (BRKZ FLG (BRKFIL (OR TYPE-IN BRKFILE)))
      TOP (SELECTQ BRKCOM
		   [(^ STOP)
		     (RELSTK LASTPOS)
		     (AND (STACKP BRKTYPE)
			  (RELSTK BRKTYPE))     (* Occurs on ERRORX breaks.
                                                See comment in BREAK1.)
		     (BREAKCOM2)
		     (RETEVAL (QUOTE BREAK1)
			      (QUOTE (ERROR!]
		   (GO                          (* Evaluate BRKEXP unless 
                                                already evaluated, print value, 
                                                and exit.)
		       (BREAKCOM1 BRKEXP BRKCOM NIL BRKVALUE)
		       (BREAKEXIT))
		   (OK                          (* Evaluate BRKEXP, unless 
                                                already evaluated, do NOT print 
                                                value, and exit.)
		       (BREAKCOM1 BRKEXP BRKCOM BRKVALUE BRKVALUE)
		       (BREAKEXIT T))
		   ( (SETQ FLG T)
		       (SETQ BRKCOM (LISPXREAD T T))
		       (GO TOP))
		   (RETURN 

          (* User will type in expression to be evaluated and returned 
          as value of BREAK. otherwise same as GO.)


			   (BREAKCOM1 [SETQ BRKZ (COND
					  (BRKCOMS (CAR BRKCOMS))
					  (T (LISPXREAD T T]
				      (QUOTE RETURN)
				      NIL NIL (LIST (QUOTE RETURN)
						    BRKZ))
			   (BREAKEXIT))
		   (EVAL                        (* Evaluate BRKEXP but do not 
                                                exit from BREAK.)
			 (BREAKCOM1 BRKEXP BRKCOM)
			 (BREAKCOM2 T)
			 (COND
			   (TYPE-IN (BREAK2)
				    (PRIN2 BRKFN T T)
				    (PRIN1 (QUOTE " evaluated
")
					   T)))
			 (SETQ !VALUE (CAR BRKVALUE))
                                                (* For user's benefit.)
			 )
		   (VALUE (COND
			    ((NULL BRKVALUE)
			      (ERROR (QUOTE "not evaluated yet.")
				     (QUOTE )
				     T)))
			  (PRINT (BREAKCOM1 (QUOTE !VALUE)
					    (QUOTE VALUE))
				 BRKFIL T)
			  (RETURN))
		   (ARGS 

          (* The next 11 commands could be on BREAKMACROS but are 
          included here to 'PROTECT' the calls to PRINT, GETD, READ, 
          etc. contained in them.)


			 (PRINT (VARIABLES LASTPOS)
				T T))
		   [?=(BREAK?= (BREAKREAD (QUOTE LINE]
		   (@(PRINT [STKNAME (SETQ BRKZ (STKPOZ (BREAKREAD
							  (QUOTE LINE]
			    T T))
		   (REVERT (AND (SETQ BRKZ (BREAKREAD (QUOTE LINE)))
				(STKPOZ BRKZ))
			   (PRINT (STKNAME LASTPOS)
				  T T)
			   (PROG ((FN (STKNAME LASTPOS))
				  DEF FORM)
			         (SETQ FORM (MAKEAPPLY FN (STKARGS LASTPOS)))
			         [COND
				   ([NULL (AND (EXPRP (SETQ DEF (FGETD FN)))
					       (EQ (CAADDR DEF)
						   (QUOTE BREAK1]
				     (BREAK0 FN T (QUOTE (UB]
			         (BREAKCOM2)
			         (RETEVAL LASTPOS FORM T)))
		   (!EVAL                       (* Evaluate as though unbroken 
                                                and then restore BREAK.)
			  (SETQ BRKZ (GETD BRKFN))
			  (PUTD BRKFN (OR (GETD (GETP BRKFN (QUOTE BROKEN)))
					  BRKZ))
                                                (* The OR is in case it was 
                                                already unbroken.)
			  (BREAKCOM (QUOTE EVAL)
				    TYPE-IN)
			  (PUTD BRKFN BRKZ))
		   (!OK (BREAKCOM (QUOTE !EVAL))
			(BREAKCOM (QUOTE OK)))
		   (!GO (BREAKCOM (QUOTE !EVAL))
			(BREAKCOM (QUOTE GO)))
		   (EDIT (PROG (BRKVALUE)
			       (PRINT (BREAKCOM1 (QUOTE (HELPFIX))
						 BRKCOM)
				      T T)))
		   (IN? (PRINT (HELPFIX T)
			       T T))
		   [UB (PROG (BRKVALUE)
			     (SETQ BRKZ
			       (BREAKCOM1 [LIST (QUOTE UNBREAK0)
						(LIST (QUOTE QUOTE)
						      (COND
							((ATOM BRKFN)
							  BRKFN)
							(T (CAR BRKFN]
					  BRKCOM))
			     (AND TYPE-IN (PRINT BRKZ T T]
		   [=(COND
		       ((AND (LISPXREADP T)
			     (ATOM BRKEXP)
			     (LISTP BRKTYPE))
			 (SETQ BRKZ (LISPXREAD T T))
			 (RETFROM (QUOTE BREAK1)
				  (PRINT (BREAKCOM1 (LISPX/
						      (LIST (QUOTE SETQ)
							    BRKEXP BRKZ))
						    BRKCOM NIL NIL
						    (LIST BRKCOM BRKZ))
					 T T)))
		       (T (PRINT (QUOTE ?)
				 T T]
		   [-> (SETQ BRKZ (READLINE T))
		       (COND
			 (DWIMFLG (BREAKCOM1 (LIST (QUOTE HELPFIX1)
						   (LIST (QUOTE QUOTE)
							 BRKZ)
						   (LIST (QUOTE QUOTE)
							 LISPXHIST))
					     BRKCOM NIL NIL (CONS BRKCOM BRKZ)))
			 (T (PRINT (QUOTE ?)
				   T T]
		   (? (PRIN1 (QUOTE "commands are:
")
			     T)
		      (PRINT BREAKCOMSLST T T)
		      (PRIN1 (QUOTE "  plus lispx commands 
")
			     T))
		   (COND
		     ((AND (LITATOM BRKCOM)
			   (SETQ BRKZ (FASSOC BRKCOM BREAKMACROS)))

          (* If macro, stack its definition on front of BRKCOMS.
          This enables defining macros in terms of other macros.)


		       (SETQ BRKCOMS (APPEND (CDR BRKZ)
					     BRKCOMS)))
		     ((AND DWIMFLG (LITATOM BRKCOM)
			   (NOT (FMEMB BRKCOM LISPXCOMS))
			   [COND
			     [(OR (NULL TYPE-IN)
				  (NULL (LISPXREADP)))
			       (AND (EQ (CAR BRKCOM)
					(QUOTE NOBIND))
				    (EQ (EVALV BRKCOM)
					(QUOTE NOBIND]
			     (T (AND (NULL (FGETD BRKCOM))
				     (NULL (GETLIS BRKCOM (QUOTE (EXPR FILEDEF]
			   (SETQ BRKZ (FIXSPELL BRKCOM 70 BREAKCOMSLST
						(NULL TYPE-IN)
						T)))

          (* Says command would generate an unbound atom error so we 
          first try to correct spelling using BREAKCOMSLST in addition 
          to SPELLINGS3.)


		       [SETQ BRKCOM (COND
			   ((ATOM BRKZ)
			     BRKZ)
			   (T (LISPXUNREAD (LIST (CDR BRKZ)))
			      (CAR BRKZ]
		       (GO TOP))
		     ((NULL TYPE-IN)            (* Indicates BRKCOM is from 
                                                coms, and therefore value 
                                                shouldn't be printed.)
		       (EVAL BRKCOM (QUOTE BREAK)))
		     (T (AND FLG (LISPXUNREAD (LIST BRKCOM))
			     (SETQ BRKCOM (QUOTE )))
			(LISPX BRKCOM (QUOTE :])

(BREAKCOM1
  [LAMBDA (BRKX BRKCOM NOSAVEFLG NOEVALFLG BRKZ)
    (PROG [(BRKHIST (AND (NULL NOSAVEFLG)
			 (NULL FLG)
			 TYPE-IN LISPXHISTORY
			 (HISTORYSAVE LISPXHISTORY (QUOTE :)
				      NIL
				      (COND
					((NULL BRKZ)
					  BRKCOM))
				      BRKZ
				      (LIST (QUOTE *PRINT*)
					    (LIST (QUOTE BREAK3)
						  (OR BRKFN (QUOTE 'BREAK'))
						  NBREAKS]
          [AND (NULL NOEVALFLG)
	       (SETQ BRKVALUE (LIST ([LAMBDA (HELPCLOCK LISPXHIST)
					(AND (EQ BRKX BRKEXP)
					     (BREAKCOM2))
					(EVAL BRKX (COND
						(BRKZ 

          (* Distinguishes between evaluation of a typed-in expression 
          and an expression coming from a user function.
          USED by DWIM.)


						      (QUOTE :))
						(T (QUOTE BREAK-EXP]
				      (CLOCK 2)
				      (OR BRKHIST LISPXHIST]
          (AND BRKHIST (FRPLACA BRKHIST (CAR BRKVALUE)))
          (RETURN (CAR BRKVALUE])

(BREAKCOM2
  [LAMBDA (FLG)

          (* If FLG=T, evaluates BREAKRSETFORMS, if NIL restores forms on 
          BREAKRESETFORMS to value they had when they entered the break or returned 
          from a lower evaluation. note that we dont save the results of the 
          restoration, since if eval-ing the break expression produces some changes to 
          the that affect thos forms, it is the latter state that is relevant.
          e.g. if (CONTROL) is on breakresetforms, and a break is entered with 
          (CONTROL T), but EVAL-ing the brkexp causes 
          (CONTROL) to be executed, then dont want break exited with 
          (CONTROL T).)


    (AND BREAKRESETFORMS (COND
	   [FLG (SETQ BRKRESETLST (MAPCAR BREAKRESETFORMS (FUNCTION EVAL]
	   (BRKRESETLST [MAP2C BREAKRESETFORMS BRKRESETLST (FUNCTION (LAMBDA (X Y)
				   (APPLY* (CAR X)
					   Y]
			(SETQ BRKRESETLST NIL])

(BREAKEXIT
  [LAMBDA (NOPRINTFLG)
    (BREAKCOM2)

          (* Note if already restored, e.g. break being exited via an 
          OK or GO command, then BRKRESETLST will be NIL and wont have 
          to re-restore)


    (RELSTK LASTPOS)
    [COND
      (NOPRINTFLG                               (* Do not print value.)
		  (PRINT BRKFN BRKFIL T))
      (T 

          (* In the event that the exit command came from BRKCOMS, 
          e.g. user is tracing, want to keep BREAK= from calling 
          BREAK2 a second time.)


	 (BREAK= (OR BRKFN (QUOTE 'BREAK'))
		 (CAR BRKVALUE]
    (BKBUFS BRKBUFS)                            (* BRKBUFS set at beginning of 
                                                BREAK.)
    (SETQ READBUF (APPEND READBUF BRKRDBUF))
    (RETFROM (QUOTE BREAK1)
	     (CAR BRKVALUE])

(BREAK2
  [LAMBDA (N)
    (SPACES (ITIMES BREAKI (IREMAINDER (SUB1 (OR N NBREAKS))
				       5))
	    BRKFIL])

(BREAK?=
  [LAMBDA (BRK3X)                               (* Handles ?= commands.)
    (PROG (BRK3TEM BRK3Y BRK3Z)
          [AND LISPXHISTORY TYPE-IN (NULL FLG)
	       (SETQ BRK3Y (HISTORYSAVE LISPXHISTORY (QUOTE :)
					NIL
					(QUOTE ?=)
					BRK3X
					(LIST (QUOTE *PRINT*)
					      (SETQ BRK3Z (LIST (QUOTE BREAK3)
								NBREAKS]
          (COND
	    ((NULL BRK3X)                       (* E.g. ?= typed, or ?= NIL in 
                                                BREAKCOMSLST => print all 
                                                arguments.)
	      (COND
		((ZEROP (SETQ BRK3X (STKNARGS LASTPOS)))
		  (PRINT (QUOTE )
			 T T)
		  (RETURN)))
	      (SETQ BRK3TEM 0)
	      (GO LP1)))
      LP  (COND
	    ((NUMBERP (CAR BRK3X))
	      (BREAK= (STKARGNAME (CAR BRK3X)
				  LASTPOS)
		      (NEWSTKARG (CAR BRK3X)
				 LASTPOS)
		      BRK3Y BRK3Z))
	    ((LISTP (CAR BRK3X))
	      (BREAK= (CAR BRK3X)
		      (STKEVAL LASTPOS (LIST (LIST (QUOTE LAMBDA)
						   (AND (NULL FLG)
							(QUOTE (LISPXHIST)))
						   (LISPX/ (CAR BRK3X)))
					     (KWOTE BRK3Y))
			       T)
		      BRK3Y BRK3Z)

          (* Cannot simply bind LISPXHIST here in BREAK?= as the 
          STKEVAL would cause UNDOSAVE to pick up LISPXHIST as of a 
          higher point on the stack.)


	      )
	    ((EQ (CAR BRK3X)
		 (QUOTE NIL))

          (* This permits user to TRACE and just see the value and no 
          argument printout by performing 
          (TRACE (FN)) which TRACE converts to 
          (TRACE (FN NIL)) note that (TRACE FN) would give all 
          arguments.)


	      NIL)
	    (T (BREAK= (CAR BRK3X)
		       (EVALV (CAR BRK3X)
			      LASTPOS)
		       BRK3Y BRK3Z)))
          (COND
	    ((SETQ BRK3X (CDR BRK3X))
	      (GO LP)))
          (RETURN)
      LP1 (COND
	    ((EQ BRK3TEM BRK3X)
	      (RETURN)))
          (BREAK= (STKARGNAME (SETQ BRK3TEM (ADD1 BRK3TEM))
			      LASTPOS)
		  (NEWSTKARG BRK3TEM LASTPOS)
		  BRK3Y BRK3Z)
          (GO LP1])

(BREAK=
  [LAMBDA (X Y BRK3Y BRK3Z)
    (PROG NIL                                   (* Prints name = value;
                                                used by ?= commands and TRACE.)
                                                (* BRK3Y and BRK3Z are for use 
                                                in connection with history.)
          (COND
	    ((NULL TYPE-IN)
	      (BREAK2)))
          (PRIN2 X BRKFIL T)
          (COND
	    (BRK3Z                              (* Saves expression to left of 
                                                '=' sign)
		   (NCONC1 BRK3Z X)))
          (PRIN1 (QUOTE " = ")
		 BRKFIL)
          [COND
	    (BRK3Y                              (* Saves value to right of '=' 
                                                sign)
		   (COND
		     ((NLISTP (CAR BRK3Y))      (* First time through, still has
                                                initial value of .)
		       (FRPLACA BRK3Y (LIST Y)))
		     (T (NCONC1 (CAR BRK3Y)
				Y]
          (PRINT Y BRKFIL T])

(STKPOZ
  [LAMBDA (X)
    (PROG [FN (LSTPOS (STKNTH (COND
				((AND BRKTYPE SPAGHETTIFLG)
				  -2)
				(T -1))
			      (QUOTE BREAK1]    (* Called from BREAK?= and by @ 
                                                macro)
          (COND
	    ((AND X (ATOM X))
	      (STKPOZ1 X)
	      (GO EXIT)))
      LP  (COND
	    ((NULL X)
	      (GO EXIT)))
          [SELECTQ (CAR X)
		   (_(PRIN1 (QUOTE "not available in spaghetti system")
			    T)
		     (ERROR!))
		   (@(SETQ LSTPOS LASTPOS)
		     (SETQ X (CDR X)))
		   (COND
		     ((NUMBERP (CAR X))
		       [SETQ LSTPOS (COND
			   ((MINUSP (CAR X))
			     (STKNTH (CAR X)
				     LSTPOS LSTPOS))
			   (T (STKPOZ2 (CAR X)
				       LSTPOS]
		       (SETQ X (CDR X)))
		     ((EQ (CADR X)
			  (QUOTE /))            (* E.g. FOO / 2 means second 
                                                occurrence of FOO)
		       (STKPOZ1 (CAR X)
				(IMINUS (CADDR X)))
		       (SETQ X (CDDDR X)))
		     (T (SETQ LSTPOS (STKNTH -1 LSTPOS LSTPOS))
                                                (* So FOO FOO will be equivalent
                                                to FOO / 2)
			(STKPOZ1 (CAR X))
			(SETQ X (CDR X]
          (GO LP)
      EXIT(AND (NEQ LSTPOS LASTPOS)
	       (RELSTK LASTPOS))
          (RETURN (SETQ LASTPOS LSTPOS])

(STKPOZ1
  [LAMBDA (FN N)
    (PROG (TEM)
          (SETQ LSTPOS (COND
	      ((SETQ TEM (NEWSTKPOS FN N LSTPOS))
		(RELSTK LSTPOS)
		TEM)
	      (T (ERROR FN (QUOTE "not found")
			T])

(STKPOZ2
  [LAMBDA (N POS)

          (* Returns the stack position N below POS by starting at 
          current position and backing up the control links until it 
          reaches a point N frames before POS.)


    (PROG (POS1 POS2)
          (SETQ POS1 (STKNTH -1))
      LP  (COND
	    ((EQP POS1 POS)
	      (RELSTK POS1)
	      (RETURN NIL))
	    ((NOT (ZEROP N))
	      (SETQ N (SUB1 N))
	      (SETQ POS1 (STKNTH -1 POS1 POS1))
	      (GO LP)))
          (SETQ POS2 (STKNTH -1))
      LP1 

          (* POS1 stays N ahead of POS2. When POS1 reaches END, POS2 
          is the desired position.)


          (COND
	    ((NULL POS1)
	      (RELSTK POS2)
	      (RETURN NIL))
	    ((EQP POS1 POS)
	      (RELSTK POS1)
	      (RETURN POS2)))
          (SETQ POS1 (STKNTH -1 POS1 POS1))
          (SETQ POS2 (STKNTH -1 POS2 POS2))
          (GO LP1])

(BREAKREAD
  [LAMBDA (FLG)                                 (* Gets input for next BREAK 
                                                command -
                                                used by BREAKMACROS.)
    (COND
      [BRKCOMS (PROG1 (CAR BRKCOMS)
		      (SETQ BRKCOMS (CDR BRKCOMS]
      ((EQ FLG (QUOTE LINE))                    (* Macro wants a line for input,
                                                e.g. ?=)
	(READLINE T))
      (T 

          (* Macro wants a single item, this is different than calling 
          read since READLINE will return NIL if nothing is there 
          WHILE read will wait.)


	 (CAR (READLINE T])

(BAKTRACE
  [LAMBDA (FROM TO SKIPFN TYPE)

          (* TYPE is a bit mask telling BACKTRACE what is to be 
          printed. 1 is variables, 2 is eval blips, 4 is everything, 8 
          suppresses function name and "UNTRACE:", and 16 uses access 
          links.)


    (RESETFORM (PRINTLEVEL)
	       (PROG ((POS (COND
			     ((EQ SPAGHETTIFLG T)
			       (STKNTH 0 FROM))
			     (T FROM)))
		      FN X Y Z)
		 LP  (SETQ FN (STKNAME POS))
		 LP1 (COND
		       ([AND (SETQ X (FASSOC FN BAKTRACELST))
			     (COND
			       ((ATOM (SETQ Z (CADR X)))
				 (SETQ Y (BAKTRACE1 (CDDR X)
						    POS)))
			       (T (SOME (CDR X)
					(FUNCTION (LAMBDA (X)
					    (SETQ Z (CAR X))
					    (SETQ Y (BAKTRACE1 (CDR X)
							       POS]
			 (PRINT Z T T)
			 (SETQ POS Y))
		       ((AND SKIPFN (APPLY* SKIPFN FN)))
		       (T (COND
			    ((NEQ TYPE 0)
			      (BACKTRACE POS POS (IPLUS TYPE 8))
                                                (* Tells BACKTRACE not to print 
                                                "UNTRACE:" or the function 
                                                name.)
			      ))
			  (BAKTRACE3 FN)        (* Prints function name.)
			  ))
		     (COND
		       ((AND (SETQ POS (STKNTH -1 POS POS))
			     (NEQ POS TO))
			 (GO LP)))
		     (TERPRI T])

(BAKTRACE1
  [LAMBDA (LST ST)

          (* 'MATCHES' LST against stack starting at POS.
          Returns NIL or position of last function that matches.)


    (PROG (TEM (POS ST)
	       POS0)
      LP  (COND
	    ((NULL LST)
	      (RELSTK ST)
	      (RETURN POS))
	    ([NULL (SETQ POS (STKNTH -1 (SETQ POS0 POS]
	      (GO OUT))
	    [(OR (EQ (SETQ TEM (CAR LST))
		     (QUOTE &))
		 (EQ TEM (STKNAME POS]
	    ((NLISTP TEM)
	      (GO OUT))
	    ([NULL (SOME TEM (FUNCTION (LAMBDA (X)
			     (COND
			       ((EQ X (QUOTE -))
                                                (* Optional match)
				 (SETQ POS POS0))
			       ((SETQ X (BAKTRACE1 X POS0))
				 (SETQ POS X]
	      (GO OUT)))
          (SETQ LST (CDR LST))
          (AND (NEQ POS0 POS)
	       (NEQ POS0 ST)
	       (RELSTK POS0))
          (GO LP)
      OUT (AND (NEQ POS0 ST)
	       (RELSTK POS0))
          (AND (NEQ POS ST)
	       (RELSTK POS))
          (RETURN NIL])

(BAKTRACE3
  [LAMBDA (FN)
    (COND
      ((ATOM FN)
	(PRINT FN T T))
      (T (RESETFORM (PRINTLEVEL 2)
		    (PRINT FN T T])

(BREAK3
  [NLAMBDA Y
    (PROG (BRKCOMS (BRKFIL T)
		   (VAL (EVQ VAL))
		   (X (EVQ X))
		   (TYPE-IN T))                 (* Prints various BREAK commands
                                                for history list.)
          (COND
	    ((EQ VAL (QUOTE ))                (* VAL and X are bound in 
                                                PRINTHISTORY1)
	      (BREAK2 (CADR Y))
	      (PRIN1 (QUOTE <)
		     T)
	      (PRIN2 (CAR Y)
		     T T)
	      (PRINT (QUOTE >)
		     T T))
	    (T (SELECTQ (CAR X)
			(OK (BREAK2 (CADR Y))
			    (PRINT (LIST (CAR Y))
				   T T))
			((GO RETURN)
			  (BREAK2 (CADR Y))
			  (BREAK= (CAR Y)
				  VAL))
			(EVAL (BREAK2 (CADR Y))
			      (PRIN2 (CAR Y)
				     T T)
			      (PRIN1 (QUOTE " evaluated
")
				     T))
			[?=(PROG ((N (CAR Y))
				  (Y (CDR Y)))
			     LP  (BREAK2 N)
			         (BREAK= (CAR Y)
					 (CAR VAL))
			         (SETQ Y (CDR Y))
			         (COND
				   ((SETQ VAL (CDR VAL))
				     (TAB 5 NIL T)
				     (GO LP]
			(PRINT VAL T T])

(BREAK
  [NLAMBDA X
    (MAPCON (COND
              ((ATOM X)                         (* Most likely case is 
                                                NIL, i.e. TRACE 
                                                LASTWORD.)
                (LIST X))
              (T X))
            (FUNCTION (LAMBDA (L)
                (PROG (X)
                      (COND
                        ((OR (ATOM (SETQ X (CAR L)))
                             (EQ (CADR X)
                                 (QUOTE IN)))
                          (BREAK0 X T NIL NIL L))
                        (T (BREAK0 (CAR X)
                                   (CADR X)
                                   (CADDR X)
                                   (CADDDR X)
                                   L])

(BREAK0
  [LAMBDA (FN WHEN COMS BRKFN TAIL)
    (PROG (X Y Z VAL)
          (AND (NULL BRKFN)
	       (SETQ BRKFN (QUOTE BREAK1)))
      TOP (SETQ VAL FN)
          [COND
	    [(LISTP FN)
	      (RETURN (COND
			[(NEQ (CADR FN)
			      (QUOTE IN))

          (* Used to BREAK on several functions using same breaking 
          condition (WHEN) and/or same COMS.)


			  (MAPCONC FN (FUNCTION (LAMBDA (X)
				       (BREAK0 X WHEN COMS]
			[(ATOM (SETQ X (CAR FN)))
			  (COND
			    ((ATOM (SETQ Y (CADDR FN)))
			      (BREAK0A X Y))
			    (T 

          (* Used to BREAK on one function where it appears in several 
          others, e.g. (PRINT IN (FOO FIE FUM)))


			       (MAPCONC Y (FUNCTION (LAMBDA (Y)
					    (BREAK0A X Y]
			[(ATOM (SETQ Y (CADDR FN)))

          (* Used to BREAK on several functions in one, e.g. 
          ((PRIN1 PRIN2 PRINT) IN FOO))


			  (MAPCONC X (FUNCTION (LAMBDA (X)
				       (BREAK0A X Y]
			(T                      (* Combination of above two 
                                                cases.)
			   (MAPCONC X (FUNCTION (LAMBDA (X)
					(MAPCONC Y (FUNCTION (LAMBDA (Y)
						     (BREAK0A X Y]
	    ((NULL (SETQ X (GETD FN)))
	      (COND
		((GETP FN (QUOTE EXPR))
		  (PRIN2 FN T T)
		  (PRIN1 (QUOTE " UNSAVED.
")
			 T)
		  (UNSAVEDEF FN (QUOTE EXPR))
		  (GO TOP))
		((SETQ X (MISSPELLED? FN 70 USERWORDS NIL TAIL
				      (FUNCTION GETD)))
		  (SETQ FN X)
		  (GO TOP)))
	      (/PUT FN (QUOTE BROKEN)
		    (GENSYM))
	      (/PUTD FN (LIST (QUOTE NLAMBDA)
			      (GENSYM)
			      (LIST BRKFN NIL WHEN FN COMS)))
	      [SETQ VAL (CONS FN (QUOTE (was undefined]
	      (GO A))
	    ([AND (EXPRP X)
		  (OR (EQ (CAADDR X)
			  (QUOTE BREAK1))
		      (GETP FN (QUOTE BROKEN]
	      (/RPLACA (SETQ Y (CADDR X))
		       BRKFN)
	      (/RPLACA (SETQ Y (CDDR Y)) WHEN)
	      (/RPLACD (CDR Y)
		       (LIST COMS))
	      (COND
		([SETQ Y (FASSOC (QUOTE BREAK0)
				 (GETP FN (QUOTE BRKINFO]

          (* This detects the BREAK (FOO) MOVD 
          (FOO FIE) BREAK (FIE) situation, also BREAK 
          (FOO) BREAK ((FOO IN FIE)) in these cases, FIE and 
          FOO-IN-FIE would appear to be broken even WHEN they were 
          not.)


		  (/RPLACD Y (LIST WHEN COMS))
		  (/RPLACA (QUOTE BROKENFNS)
			   (CONS FN (/DREMOVE FN BROKENFNS)))

          (* Moves FN to front of BROKENFNS so that UNBREAK of T will 
          UNBREAK it.)


		  (RETURN (LIST FN)))
		(T (SETQ X (CONS (CAR X)
				 (CONS (CADR X)
				       (CDADR (CADDR X]
          (SETQ X (SAVED FN (QUOTE BROKEN)
			 X))                    (* Computes appropriate 
                                                s-expression definition for this
                                                function.)
          (/PUTD FN (LIST (CAR X)
			  (CADR X)
			  (LIST BRKFN (CONS (QUOTE PROGN)
					    (CDDR X))
			     WHEN FN COMS)))
      A   [COND
	    ((NULL (FMEMB FN BROKENFNS))
	      (/RPLACA (QUOTE BROKENFNS)
		       (CONS FN BROKENFNS]
          (/ADDPROP FN (QUOTE BRKINFO)
		    (LIST (QUOTE BREAK0) WHEN COMS))

          (* Used for rebreaking. Information saved at time of BREAK 
          instead of retrieved when unbroken because for BREAKIN, 
          information is not available in a convenient form at time of 
          UNBREAK. i.e. program would have to search through entire 
          definition looking for calls to BREAK1.)


          (RETURN (LIST VAL])

(BREAK0A
  [LAMBDA (X Y)
    (PROG (Z)

          (* Note that while information about -IN- breaks is stored 
          on the property list of the atom, e.g. FOO-IN-FIE, and it is 
          the atom which is added to BROKENFNS, the user should be 
          able to refer to the function using either the atom form or 
          the list form, whether he is talking to BREAK, UNBREAK, or 
          REBREAK. (Of course, the very first time he breaks the 
          function, he must refer to in list form, e.g. 
          (FOO IN FIE) or else the alias will not be created.))


          (RETURN (COND
		    ((ATOM (SETQ Z (CHNGNM Y X)))
                                                (* X was found in Y)
		      (BREAK0 Z WHEN COMS BRKFN))
		    (T (LIST Z])

(UNBREAK
  [NLAMBDA X
    (COND
      ((NULL X)
        (SETQ X (REVERSE BROKENFNS))            (* So that most recently
                                                broken function will be 
                                                unbroken last.)
        (/RPLACA (QUOTE BROKENFNS)
                 NIL)
        (/RPLACA (QUOTE BRKINFOLST)
                 NIL)))
    (MAPCON X (FUNCTION (LAMBDA (L)
                (UNBREAK0 (CAR L)
                          L])

(UNBREAK0
  [LAMBDA (FN TAIL)
    (MAPCAR (PACK-IN- FN)
            (FUNCTION (LAMBDA (FN)
                (PROG [VAL (ALIAS (GETP FN (QUOTE ALIAS)))
                           (BRKINFO (GETP FN (QUOTE BRKINFO]
                      [COND
                        ((EQ FN T)
                          (SETQ FN (CAR BROKENFNS)))
                        ([AND DWIMFLG (NULL (FMEMB FN BROKENFNS))
                              (NULL (OR (GETD FN)
                                        (GETP FN (QUOTE EXPR]

          (* Only spelling correct if FN is not a function.
          This is because certain functions such as UNSAVEDEF 
          call UNBREAK0 just to make sure function is not 
          broken. Also, user may perform 
          (UNBREAK FOO) just to be sure.
          In these cases, don't want to correct spelling.)


                          (SETQ FN
                            (OR (FIXSPELL FN 70 BROKENFNS NIL TAIL)
                                (FIXSPELL FN 70 USERWORDS NIL TAIL
                                          (FUNCTION GETD))
                                FN]
                      (AND DWIMFLG (SETQ LASTWORD FN))
                      (/RPLACA (QUOTE BROKENFNS)
                               (/DREMOVE FN BROKENFNS))
                      (SETQ VAL (RESTORE FN (QUOTE BROKEN)))
                      (COND
                        ((GETP FN (QUOTE BROKEN-IN))
                          (UNBREAKIN FN)
                          (/REMPROP FN (QUOTE BROKEN-IN))
                          (SETQ VAL FN)))
                      [COND
                        (BRKINFO (/RPLACA (QUOTE BRKINFOLST)
                                          (CONS (CONS FN (CONS ALIAS 
                                                            BRKINFO))
                                                BRKINFOLST))
                                 (/REMPROP FN (QUOTE BRKINFO]
                      (COND
                        ([AND ALIAS (NULL (GETP FN (QUOTE ADVISED]
                          (CHNGNM (CAR ALIAS)
                                  (CDR ALIAS)
                                  T)))
                      (RETURN VAL])

(REBREAK
  [NLAMBDA X
    (PROG (SPLST)
          (RETURN
            (COND
              ((NULL X)                         (* Reverse so that most 
                                                recently unbroken 
                                                function will be 
                                                rebroken last.)
                (MAPCONC (REVERSE BRKINFOLST)
                         (FUNCTION REBREAK0)))
              ((EQ (CAR X)
                   T)
                (REBREAK0 (CAR BRKINFOLST)))
              (T
                (SETQ SPLST (MAPCAR BRKINFOLST (FUNCTION CAR)))
                                                (* For spellings 
                                                correction.)
                (MAPCONC
                  X
                  (FUNCTION (LAMBDA (FN)
                      (MAPCONC
                        (PACK-IN- FN)
                        (FUNCTION (LAMBDA (FN)
                            (PROG (Y)
                                  [COND
                                    ((AND DWIMFLG
                                          (NULL (SETQ Y (FASSOC FN 
                                                         BRKINFOLST)))
                                          (NULL (GETD FN)))
                                      (SETQ FN
                                        (OR
                                          (FIXSPELL FN 75 SPLST)
                                          (FIXSPELL
                                            FN 75 USERWORDS NIL NIL
                                            (FUNCTION GETD))
                                          FN]
                                  (RETURN
                                    (COND
                                      ((OR Y (SETQ Y (FASSOC FN 
                                                         BRKINFOLST)))

          (* Information is stored on BRKINFOLST by function 
          name. If user is performing A REBREAK on 
          (FOO IN FIE) the information will not be found 
          unless it is looked for under FOO-IN-FIE, hence the 
          call to PACK-IN- which converts list forms of 
          aliases to their atomic form.)


                                        (REBREAK0 Y))
                                      (T
                                        (LIST
                                          (CONS FN
                                                (QUOTE (- NO BREAK 
                                                        INFORMATION 
                                                          SAVED])

(REBREAK0
  [LAMBDA (INFO)
    (PROG ((FN (CAR INFO))
           (ALIAS (CADR INFO)))
          (RETURN
            (MAPCONC
              (CDDR INFO)
              (FUNCTION (LAMBDA (X)
                  (AND DWIMFLG (SETQ LASTWORD FN))
                  (COND
                    [(NEQ (CAR X)
                          (QUOTE BREAK0))
                      (LIST (APPLY (QUOTE BREAKIN)
                                   (CONS FN X]
                    (T
                      (APPLY
                        (QUOTE BREAK0)
                        (CONS (COND
                                (ALIAS 

          (* Only want to do the CHANGENAME once.
          Therefore set ALIAS to NIL in case there are other 
          breaks as well, e.g. user does BREAK 
          ((FOO IN FIE)) and then BREAK 
          (((FOO IN FIE) (NULL Z))))


                                       (PROG1 (LIST (CDR ALIAS)
                                                    (QUOTE IN)
                                                    (CAR ALIAS))
                                              (SETQ ALIAS NIL)))
                                (T FN))
                              (CDR X])

(TRACE
  [NLAMBDA X
    (MAPCONC (COND
               ((ATOM X)                        (* Most likely case is 
                                                NIL, i.e. TRACE 
                                                LASTWORD.)
                 (LIST X))
               (T X))
             (FUNCTION (LAMBDA (Z)
                 (PROG (Y)
                       [COND
                         [(OR (ATOM Z)
                              (EQ (CADR Z)
                                  (QUOTE IN)))
                           (SETQ Y (QUOTE (TRACE ?= NIL GO]
                         (T (SETQ Y (LIST (QUOTE TRACE)
                                          (QUOTE ?=)
                                          (OR (CDR Z)
                                              (QUOTE (NIL)))
                                          (QUOTE GO)))
                            (SETQ Z (CAR Z]
                       (RETURN (BREAK0 Z T Y])

(BREAKIN
  [NLAMBDA (FN WHERE WHEN BRKCOMS)
    (RESETVAR UPFINDFLG T
      (PROG (W BRK X TEM)
	    (SETQ FN (FNCHECK FN))
	    (COND
	      ([NULL (EXPRP (SETQ X (GETD (OR (GETP FN (QUOTE BROKEN))
					      FN]
		(ERROR FN (QUOTE "NOT AN EXPR.")
		       T)))
	    [COND
	      ((NULL (FMEMB FN BROKENFNS))
		(/RPLACA (QUOTE BROKENFNS)
			 (CONS FN BROKENFNS]
	    [COND
	      [(NULL WHERE)                     (* Convenient default case, 
                                                especially for BREAKIN for NIL, 
                                                meaning (BREAKIN LASTWORD))
		(PRIN1 (QUOTE (BEFORE))
		       T)
		(SETQ WHERE (LIST (QUOTE BEFORE)
				  (QUOTE TTY:]
	      ((NULL (ATOM (CAR WHERE)))
		(SETQ W (CDR WHERE))
		(SETQ WHERE (CAR WHERE]
	LOOP[COND
	      [(FMEMB (CAR WHERE)
		      (SETQQ TEM (AFTER AROUND BEFORE]
	      ((SETQ TEM (FIXSPELL (CAR WHERE)
				   60 TEM T WHERE))
		(FRPLACA WHERE TEM))
	      (T (RETURN (LIST (CAR WHERE)
			       (QUOTE ?]
	    (SETQ BRK (LIST (OR WHEN T)
			    (BREAKIN1 (CONS FN (CONS (QUOTE BROKEN) WHERE)))
			    BRKCOMS))
	    [SETQ BRK (COND
		[(EQ (CAR WHERE)
		     (QUOTE AROUND))
		  (LIST (QUOTE MBD)
			(CONS (QUOTE BREAK1)
			      (CONS (QUOTE *)
				    BRK]
		(T (LIST (CAR WHERE)
			 (CONS (QUOTE BREAK1)
			       (CONS NIL BRK]
	    (COND
	      ((NEQ (CADR WHERE)
		    (QUOTE TTY:))               (* Don't print 'SEARCHING...' 
                                                for (before/after/around tty))
		(PRIN1 (QUOTE searching...)
		       T)))
	    (OR [NLSETQ (EDITE X
			       (LIST [CONS (QUOTE LC)
					   (APPEND (CDR WHERE)
						   (CAR (QUOTE NOBREAKIN]
				     BRK
				     (QUOTE (E (PROGN (/PUT FN (QUOTE BROKEN-IN)
							    T)
						      (/ADDPROP FN
								(QUOTE BRKINFO)
								(LIST
								   WHERE
								   WHEN BRKCOMS)
								))
					       T]
		(PRINT (QUOTE (not found))
		       T T))
	    (AND (NEQ (POSITION T)
		      0)
		 (TERPRI T))
	    (COND
	      (W (SETQ WHERE (CAR W))
		 (SETQ W (CDR W))
		 (GO LOOP)))
	    (RETURN FN])

(BREAKIN1
  [LAMBDA (X)
    (MAPCAR X (FUNCTION (LAMBDA (X)
                (COND
                  ((NOT (ATOM X))
                    (BREAKIN1 X))
                  (T (PACK (LIST X (QUOTE ])

(UNBREAKIN
  [LAMBDA (FN)                                  (* Just does the 
                                                editing. Property values
                                                not affected.)
    (RESETVAR UPFINDFLG T
      (PROG ((DEF (CGETD FN)))
            [COND
              ((EXPRP DEF)
                (EDITE
                  DEF
                  (QUOTE
                    ((LPQ
                       F BREAK1
                       (COMS (SELECTQ (CAR (NLSETQ (## 4 3)))
                                      (AROUND (QUOTE (XTR 2)))
                                      ((AFTER BEFORE)

          (* The first clause is so that whenever possible, 
          breaks are removed by patching around.
          If just a delete were done, the interpreter would 
          skip the next form since cdr of the current list of 
          forms would be patched. The only time this fails is 
          when a breakis inserted as the first elemen of a 
          list, e.g. as a cond prediate.)


                                        (QUOTE (ORR (BK UP (2))
                                                    DELETE)))
                                      NIL]
            (RETURN FN])

(SAVED
  [LAMBDA (FN WHERE DF GS)
    (AND (NULL DF)
	 (HELP))
    (PROG (ARGS TYP)
          (COND
	    ((NULL GS)                          (* We are going to clobber FN, 
                                                so save its definition.)
	      (/PUTD [SETQ GS (PACK (LIST FN (GENSYM (QUOTE B]
		     DF)))
          (COND
	    ((EXPRP DF)                         (* DF is already an EXPR, so no 
                                                more need be done.)
	      (COND
		((NOT (FNTYP DF))               (* Something else in function 
                                                cell.)
		  (ERROR FN (QUOTE "NOT A FUNCTION")))
		(WHERE (/PUT FN WHERE GS)))
	      (RETURN DF)))
          (SETQ TYP (FNTYP DF))
          (SETQ ARGS (ARGLIST DF))
          (SETQ DF (SAVED1 TYP GS ARGS))
          (COND
	    (WHERE (/PUT FN WHERE GS)))
          (RETURN (LIST (SELECTQ TYP
				 ((CEXPR SUBR CEXPR* SUBR* SEXPR SEXPR*)
				   (QUOTE LAMBDA))
				 (QUOTE NLAMBDA))
			ARGS DF])

(SAVED1
  [LAMBDA (TYP FN ARGS)

          (* I have inserted the swapped function types, but 
          it was a long search for the problem because the 
          HELP was an ERROR! for reasons I have not yet 
          encountered. I changed it, change it back if you 
          know why it was ERROR! before.
          JWG 5/74)

                                                (* Constructs body of 
                                                definition.)
    (SELECTQ TYP
	     ((CEXPR SUBR SEXPR)
	       (CONS FN ARGS))
	     [(CFEXPR FSUBR SFEXPR)

          (* BLKAPPLY is same as APPLY but user might have a 
          BREAK on APPLY, i.e. this is in lieu of a BRKAPPLY 
          The internal is for DWIM, i.e. so FINDFN will look 
          through this functon.)


	       (LIST (QUOTE BLKAPPLY)
		     (LIST (QUOTE QUOTE)
			   FN)
		     (CONS (QUOTE LIST)
			   ARGS)
		     (QUOTE (QUOTE INTERNAL]
	     [(CEXPR* SUBR* SEXPR*)
	       (LIST (QUOTE BLKAPPLY)
		     (LIST (QUOTE QUOTE)
			   FN)
		     (LIST (QUOTE BREAKNARGS)
			   ARGS)
		     (QUOTE (QUOTE INTERNAL]
	     [(CFEXPR* FSUBR* SFEXPR*)
	       (LIST (QUOTE BLKAPPLY)
		     (LIST (QUOTE QUOTE)
			   FN)
		     ARGS
		     (QUOTE (QUOTE INTERNAL]
	     (HELP])

(GENSYM?
  [LAMBDA (X)
    (AND (EQ (NTHCHAR X -5)
             (QUOTE A))
         (EQ (NTHCHAR X -4)
             0])

(RESTORENAMES
  [LAMBDA (FN)
    (PROG1 [MAPCAR (APPEND (GETP FN (QUOTE NAMESCHANGED)))
		   (FUNCTION (LAMBDA (X)
		       (CHNGNM FN X T]
	   (/REMPROP FN (QUOTE NAMESCHANGED])

(VIRGINFN
  [LAMBDA (FN FLG)
    (PROG [D (X1 (GETP FN (QUOTE BROKEN)))
	     (X2 (GETP FN (QUOTE ADVISED)))
	     (X3 (GETP FN (QUOTE NAMESCHANGED)))
	     (X4 (GETP FN (QUOTE BROKEN-IN)))
	     (X5 (GETP FN (QUOTE EXPR]
          (COND
	    (FLG (COND
		   ((OR X1 X4)
		     (PRIN2 FN T T)
		     (PRIN1 (QUOTE " unbroken.
")
			    T)
		     (UNBREAK0 FN)))
		 [COND
		   (X2 (PRIN2 FN T T)
		       (PRIN1 (QUOTE " unadvised.
")
			      T)
		       (APPLY (QUOTE UNADVISE)
			      (LIST FN]
		 (COND
		   (X3 (PRIN2 FN T T)
		       (PRIN1 (QUOTE " names restored.
")
			      T)
		       (RESTORENAMES FN)))
		 (COND
		   ((AND [NULL (EXPRP (SETQ D (GETD FN]
			 X5)
		     (SETQ D X5)))
		 (RETURN D)))
          (SETQ D (GETD (OR (AND X2 (GETP FN (QUOTE ADVISED)))
			    X1 FN)))
          [COND
	    ((OR (NLISTP D)
		 (NLISTP (CDR D)))
	      (RETURN (OR X5 D]
          (COND
	    (X4 (SETQ D (UNBREAKIN (COPY D)))
		(SETQ FLG T)))
          [COND
	    (X3 [COND
		  ((NULL FLG)
		    (SETQ D (COPY D]
		(MAPC X3 (FUNCTION (LAMBDA (X)
			  (SETQ D (/DSUBST X (PACK (LIST X (QUOTE -IN-)
							 FN))
					   D]
          (RETURN D])

(RESTORE
  [LAMBDA (FN X)
    (PROG (Y)
          (RETURN (COND
		    ((SETQ Y (GETP FN X))
		      (/PUTD FN (GETD Y))
		      (AND (NULL (RELSTK (STKPOS FN)))
			   (/PUTD Y))
		      (/REMPROP FN X)
		      FN)
		    (T (LIST FN (QUOTE NOT)
			     X])

(PACK-IN-
  [LAMBDA (X)

          (* Allows user to refer to alias-functions using 
          either atomic or list form by always converting to 
          atomic form. called by REBREAK, UNBREAK0, READVISE0, 
          UNADVISE, and ADVISEDUMP. returns a list of 
          functions.)


    (PROG ((TEM1 (CAR X))
           (TEM2 (CADDR X)))
          (RETURN (COND
                    ((NLISTP X)
                      (LIST X))
                    ((NEQ (CADR X)
                          (QUOTE IN))
                      (ERROR (QUOTE "NOT OF FORM (FN1 IN FN2)")
                             X T))
                    [(LISTP TEM1)
                      (MAPCONC TEM1 (FUNCTION (LAMBDA (Y)
                                   (PACK-IN- (LIST Y (QUOTE IN)
                                                   TEM2]
                    [(LISTP TEM2)
                      (MAPCONC TEM2 (FUNCTION (LAMBDA (Y)
                                   (PACK-IN- (LIST TEM1 (QUOTE
                                                           IN)
                                                   Y]
                    (T (LIST (PACK (LIST TEM1 (QUOTE -IN-)
                                         TEM2])

(BREAKNARGS
  [NLAMBDA (BRKX)                               (* Makes a list of the 
                                                arguments to a nospread 
                                                EVAL type function.)
    (PROG (BRKY (BRKN (EVAL BRKX)))
      LP  (COND
            ((NOT (IGREATERP BRKN 0))
              (RETURN BRKY)))
          (SETQ BRKY (CONS (APPLY (QUOTE ARG)
                                  (LIST BRKX BRKN))
                           BRKY))
          (SETQ BRKN (SUB1 BRKN))
          (GO LP])
)
  [RPAQQ BREAKMACROS ((BT (BAKTRACE LASTPOS NIL (BREAKREAD)
				    0))
	  (BTV (BAKTRACE LASTPOS NIL (BREAKREAD)
			 1))
	  (BTV* (BAKTRACE LASTPOS NIL (BREAKREAD)
			  3))
	  (BTV! (BAKTRACE LASTPOS NIL (BREAKREAD)
			  7]
  (RPAQQ BREAKI 3)
  (RPAQQ NBREAKS 0)
  (RPAQQ NOBREAKS (GO QUOTE *))
  (RPAQQ NOBREAKIN ([COMS (COND ([SOME (CDR L)
				       (FUNCTION (LAMBDA (X)
							 (MEMB (CAR X)
							       NOBREAKS]
				 (ERROR!))
				((CAR (NLSETQ (SELECTQ (## 1 !0 BK)
						       ([LAMBDA NLAMBDA]
							T)
						       NIL)))
				 (ERROR!))
				(T (SELECTQ (## !0 1)
					    ((COND SELECTQ)
					     1)
					    NIL]
	  (IF (NEQ (CAR WHERE)
		   (QUOTE AROUND))
	      (MARK (>;)
		    (IF (AND (NEQ (##)
				  (## _))
			     (LISTP (##)))
			((E (PROGN (PRIN1 (QUOTE "BREAK INSERTED ")
					  T)
				   (PRIN1 (CAR WHERE)
					  T)
				   (SPACES 1 T)
				   (## P))
			    T))
			NIL))
	      NIL)))
  (RPAQQ BREAKCOMSLST
	 (?= @ VALUE BT EVAL OK GO RETURN BTV BTV* BTV! ARGS !EVAL !OK !GO EDIT UB = -> IN? 
	     STOP ^ ))
  (RPAQ BRKFILE T)
  (RPAQ BROKENFNS)
  (RPAQ BRKINFOLST)
  (RPAQQ BAKTRACELST ((PROGN **BREAK** EVAL ((ERRORSET)
			      -)
			     BREAK1BLOCK BREAK1)
	  (EVAL (**BREAK** ((LISPXBLOCK LISPX)
			    -)
			   ERRORSET BREAK1BLOCK BREAK1)
		(**TOP** LISPX LISPXBLOCK EVALQT)
		(**EDITOR** ((LISPXBLOCK LISPX)
			     -)
			    ERRORSET ERRORSET ((EDITL0 ERRORSET ERRORSET ERRORSET)
			     -)
			    EDITL0 ERRORSET ERRORSET EDITBLOCK EDITL EDITE
			    ((ERRORSET ERRORSET EDITFBLOCK EDITF)
			     (ERRORSET ERRORSET EDITFBLOCK EDITV)
			     (ERRORSET ERRORSET EDITFBLOCK EDITP)
			     -))
		(**USEREXEC** LISPX ERRORSET LISPXBLOCK USEREXEC))
	  (APPLY (**BREAK** LISPXBLOCK LISPX ERRORSET BREAK1BLOCK BREAK1)
		 (**TOP** LISPX LISPXBLOCK EVALQT)
		 (**EDITOR** LISPXBLOCK LISPX ERRORSET ERRORSET ((EDITL0 ERRORSET ERRORSET 
									 ERRORSET)
			      -)
			     EDITL0 ERRORSET ERRORSET EDITBLOCK EDITL EDITE
			     ((ERRORSET ERRORSET EDITFBLOCK EDITF)
			      (ERRORSET ERRORSET EDITFBLOCK EDITV)
			      (ERRORSET ERRORSET EDITFBLOCK EDITP)
			      -))
		 (**USEREXEC** LISPX ERRORSET LISPXBLOCK USEREXEC))
	  (BLKAPPLY **BREAK** PROGN EVAL ERRORSET BREAK1BLOCK BREAK1)))
  (RPAQ BREAKRESETFORMS)
  (RPAQQ BREAKBLOCKS
	 ((PACK-IN-)
	  (BREAK0 BREAK0 BREAK0A (SPECVARS LINKS)
		  (LOCALFREEVARS WHEN COMS BRKFN))
	  (NIL SAVED SAVED1 BREAKREAD RESTORE BREAK UNBREAKIN UNBREAK0 UNBREAK REBREAK0 REBREAK 
	       TRACE GENSYM? RESTORENAMES (NOLINKFNS EDITE)
	       VIRGINFN BREAKNARGS (LINKFNS . T))
	  (BREAK1BLOCK BREAK1 BREAKCOM BREAKCOM1 BREAKCOM2 BREAKEXIT BREAK2 BREAK?= BREAK= 
		       STKPOZ STKPOZ1 STKPOZ2 BREAK3 (ENTRIES BREAK1 BREAK3)
		       (LOCALFREEVARS BRKEXP BRKVALUE BRKCOMS BRKFN !VALUE LASTPOS BRKTYPE 
				      TYPE-IN BRKBUFS BRKRDBUF LSTPOS FLG BRKFIL BRKRESETLST)
		       (SPECVARS !VALUE LASTPOS BRKEXP BRKCOMS NBREAKS BRKRESETLST)
		       (RETFNS BREAK1))
	  (BAKTRACE BAKTRACE BAKTRACE1 BAKTRACE3)
	  (BREAKIN BREAKIN BREAKIN1)))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
  (BLOCK: PACK-IN-)
  (BLOCK: BREAK0 BREAK0 BREAK0A (SPECVARS LINKS)
	  (LOCALFREEVARS WHEN COMS BRKFN))
  (BLOCK: NIL SAVED SAVED1 BREAKREAD RESTORE BREAK UNBREAKIN UNBREAK0 UNBREAK REBREAK0 REBREAK 
	  TRACE GENSYM? RESTORENAMES (NOLINKFNS EDITE)
	  VIRGINFN BREAKNARGS (LINKFNS . T))
  (BLOCK: BREAK1BLOCK BREAK1 BREAKCOM BREAKCOM1 BREAKCOM2 BREAKEXIT BREAK2 BREAK?= BREAK= 
	  STKPOZ STKPOZ1 STKPOZ2 BREAK3 (ENTRIES BREAK1 BREAK3)
	  (LOCALFREEVARS BRKEXP BRKVALUE BRKCOMS BRKFN !VALUE LASTPOS BRKTYPE TYPE-IN BRKBUFS 
			 BRKRDBUF LSTPOS FLG BRKFIL BRKRESETLST)
	  (SPECVARS !VALUE LASTPOS BRKEXP BRKCOMS NBREAKS BRKRESETLST)
	  (RETFNS BREAK1))
  (BLOCK: BAKTRACE BAKTRACE BAKTRACE1 BAKTRACE3)
  (BLOCK: BREAKIN BREAKIN BREAKIN1)
]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA TRACE REBREAK UNBREAK BREAK BREAK3)
  (ADDTOVAR NLAML BREAKNARGS BREAKIN BREAK1)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (904 46385 (BREAK1 916 . 5551) (BREAKCOM 5555 . 11607) (BREAKCOM1 11611 . 12546)
(BREAKCOM2 12550 . 13467) (BREAKEXIT 13471 . 14314) (BREAK2 14318 . 14433) (BREAK?= 14437
. 16503) (BREAK= 16507 . 17565) (STKPOZ 17569 . 18918) (STKPOZ1 18922 . 19115) (STKPOZ2 19119
. 20011) (BREAKREAD 20015 . 20689) (BAKTRACE 20693 . 22041) (BAKTRACE1 22045 . 23029) (BAKTRACE3
23033 . 23165) (BREAK3 23169 . 24236) (BREAK 24240 . 25035) (BREAK0 25039 . 28579) (BREAK0A
28583 . 29364) (UNBREAK 29368 . 29855) (UNBREAK0 29859 . 32058) (REBREAK 32062 . 34721) (
REBREAK0 34725 . 35936) (TRACE 35940 . 36894) (BREAKIN 36898 . 39044) (BREAKIN1 39048 . 39249)
(UNBREAKIN 39253 . 40502) (SAVED 40506 . 41528) (SAVED1 41532 . 42823) (GENSYM? 42827 . 42951)
(RESTORENAMES 42955 . 43138) (VIRGINFN 43142 . 44337) (RESTORE 44341 . 44607) (PACK-IN- 44611
. 45836) (BREAKNARGS 45840 . 46382)))))
STOP
