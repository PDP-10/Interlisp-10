(FILECREATED "11-OCT-74 14:22:32" DWIMIFY.;10 90677  

     changes to:  DWIMBLOCKS

     previous date: " 7-OCT-74 18:28:28" DWIMIFY.;9)


  (LISPXPRINT (QUOTE DWIMIFYCOMS)
	      T T)
  [RPAQQ DWIMIFYCOMS ((FNS * DWIMIFYFNS)
	  (VARS (!)
		(!!)
		(COMPILEUSERFN (QUOTE COMPILEUSERFN))
		(#CLISPARRAY 250)
		(RECORDHASHFLG T)
		(CLISPI.SGAG))
	  (BLOCKS * DWIMBLOCKS)
	  (PROP MACRO CLISP% )
	  (PROP FILEGROUP DWIMIFY)
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA 
										 DWIMIFYFNS)
										(NLAML]
  (RPAQQ DWIMIFYFNS
	 (DWIMIFYFNS DWIMIFY DWIMIFY0 DWIMIFY1 DWIMIFY1? DWMFY1 DWIMIFY1A DWIMIFY1B DWIMIFY2 
		     DWIMIFY2? DWMFY2 DWIMIFY2A SHRIEKER CLISPIF CLISPIF0 CLISPIF1 CLISPIF2 
		     CLISPFOR CLISPFOR0 CLISPFOR1 CLISPFOR2 CLISPFOR3 CLISPFORVARS 
		     CLISPFORVARS1 CLISPFOR4 CLISPFORNEG CLISPFORF/L CLISPFORERR CLISPFORERR1 
		     CLISPRESPELL COMPILEUSERFN CLISPTRAN I.S.TYPE))
(DEFINEQ

(DWIMIFYFNS
  [NLAMBDA FNS
    (PROG ((CLK (CLOCK 0))
	   (CLK2 (CLOCK 2))
	   TEM)
          (SETQ NOFIXFNSLST0 NOFIXFNSLST)
          (SETQ NOFIXVARSLST0 NOFIXVARSLST)
          [SETQ TEM (MAPCAR (COND
			      ((NULL (CDR FNS))
				(STKEVAL (QUOTE DWIMIFYFNS)
					 (CAR FNS)
					 (QUOTE INTERNAL)))
			      (T FNS))
			    (FUNCTION (LAMBDA (X)
				(COND
				  ((IGREATERP (IDIFFERENCE (SETQ TEM
							     (CLOCK 0))
							   CLK)
					      30000)
				    (SETQ CLK TEM)
				    (PRIN2 X T T)
				    (PRIN1 (QUOTE ", ")
					   T)))
				(DWIMIFY0 X]
          (LISPXWATCH FIXTIME (IDIFFERENCE (CLOCK 2)
					   CLK2))
          (RETURN TEM])

(DWIMIFY
  [LAMBDA (X L)
    (PROG ((CLK2 (CLOCK 2))
           VAL TEM)

          (* If X is an atom and L is NIL, X is treated as the name of 
          a function, and its entire definition is DWIMIFIED.
          Otherwise, X is a piece of a function, and L the edit puh 
          down list that leads to X (i.e. L is the push-dwown list 
          after performing a !0) L is used to compute the bound 
          variables, as well as to determine whether X is an element 
          or tail.)


          (SETQ NOFIXFNSLST0 NOFIXFNSLST)
          (SETQ NOFIXVARSLST0 NOFIXVARSLST)
          (SETQ VAL (DWIMIFY0 X L))
          (LISPXWATCH FIXTIME (IDIFFERENCE (CLOCK 2)
                                           CLK2))
          (COND
            ((AND (LISTP X)
                  (NULL L))
              (RESETFORM (OUTPUT T)
                         (RESETVAR PRETTYTRANFLG T (PRINTDEF VAL NIL T)))
              (TERPRI T)))
          (RETURN VAL])

(DWIMIFY0
  [LAMBDA (X Y VARS EXPR)

          (* Some general comments: -
          DWIMIFYFLG is bound in DWIMIFY0, WTFIX, and WTFIX0.
          It is set to T whenever WTFIX is called and given EXPR, 
          TAIL, PARENT, etc. as arguments, i.e. from DWIMIFY1 or 
          DWIMIFY2. Note that this may occur due to an explicit call 
          to DWIMIFY0, or due to evaluating certain CLISP expressions, 
          e.g. IF statements, which call DWIMIFY1 or DWIMIFY2.
          These two cases are distinguished by the value of 
          DWIMIFYING. -
          DWIMIFYING is bound in DWIMIFY0 
          (to T), and whenever DWIMIFY1 or DWIMIFY2 are called from 
          contexts where DWIMIFYING may not be bound, e.g. from 
          CLISPIF. In these latter cases, DWIMIFYING is bound to 
          (AND DWIMIFYFLG DWIMIFYING). Thus DWIMIFYING is always bound 
          when DWIMIFYFLG is bound, and is T when under a call to 
          DWIMIFY0, otherwise NIL. Note that checking DWIMIFYING 
          without also checking DWIMIFYFLG may cause a U.B.A.
          DWIMIFYING error. Similary, other state variables that are 
          bound in DWIMIFY0 but not rebound by DWIMIFY1 or DWIMIFY2 
          such as CLISPCONTEXT, DWIMIFYCHANGE, etc., are assumed to be 
          bound when DWIMIFYFLG is T, so that any call to DWIMIFY1 or 
          DWIMIFY2 must also guarantee that these variables are bound.
          If the caller is not sure, it should use DWIMIFY1? and 
          DWIMIFY2? since these do the appropriate checks.
          -
          NOFIXFNSLST0 and NOFIXVARSLST0 are global varaales.
          They are initializaed to NOFIXFNSLST and NOFIXVARLST by 
          DWIMIFY and DWIMIFYFNS, as well as CLISPIF, CLISPFOR, etc. 
          when they enter the DWIMIFY functions, i.e. DWIMIFY1 and 
          DWIMIFY2 for the first time. NOFIXFNSLST and NOFIXVARLST are 
          the variable that the user can add things to.
          -
          VARS is bound in WTFIX and in DWIMIFY0.
          DWIMIFY1 and DWIMIFY2 supply VARS in their call to WTFIX.
          Otherwise WTFIX comptes them. -
          ATTEMPTFLG is bound in DWIMIFY1 and DWIMIFY2.
          It is used to inform DWIMIFY1 or DWIMIFY2, in the event that 
          WTFIX was unable to make a correction, NOT to add the atom 
          to NOFIXLST. For example, this occurs when a correction was 
          offered to the user but rejected, e.g. U.D.F.
          T, and user declines the fix, T is not added to NOFIXLST.)


    (PROG (FN FAULTFN DWIMIFY0CHANGE DWIMIFYCHANGE TEM CLISPCONTEXT
	      (DWIMIFYING T)
	      (DWIMIFYFLG T))
      TOP [COND
	    ((OR (LISTP X)
		 Y)
	      [COND
		((NLISTP Y)
		  (SETQ FAULTFN (OR Y (QUOTE TYPE-IN)))

          (* On calls from COMPILEUSERFN, X is the expression to be 
          DWIMIFIED. Y is the name of the function, and EXPR and VARS 
          are supplied.)


		  (AND (NULL EXPR)
		       (SETQ EXPR X))           (* E.G. User types in a direct 
                                                caal to DWIMIFY.)
		  (RETURN (DWIMIFY1 X]
	      [COND
		((LISTP (SETQ FAULTFN (EVQ ATM)))
                                                (* New editor conventions.)
		  (SETQ FAULTFN (CAR FAULTFN]   (* ATM is bound in EDITE.)
	      (SETQ VARS (DWIMIFY3 Y))
	      (LISPXPUT (QUOTE RESPELLS)
			NIL NIL LISPXHIST)      (* Essentially, a new call to DW
                                                is treated as a new event.)
                                                (* DWIMIFY3 also sets EXPR.)
	      (RETURN (COND
			((TAILP X (CAR Y))
			  (DWIMIFY2 X (CAR Y)))
			((EQ (CAAR Y)
			     (QUOTE COND))
			  (DWIMIFY2 (CDR X)
				    X)
			  X)
			([AND (EQ (CAAR Y)
				  (QUOTE SELECTQ))
			      (NEQ X (CADAR Y))
			      (CDR (FMEMB X (CAR Y]
			  (DWIMIFY2 (CDR X)
				    X)
			  X)
			(T (DWIMIFY1 X]
          (SETQ EXPR (EXPRCHECK (SETQ FN X)))   (* If EXPRCHECK performs 
                                                spelling correction, it will 
                                                rset FN.)
          (SETQ FAULTFN FN)
          (DWIMIFY1 EXPR)
          [COND
	    (DWIMIFY0CHANGE (AND FILEPKGFLG (OR (GET LISPXHIST (QUOTE 
							       *LISPXPRINT*))
						(NULL CLISPIFYPRETTYFLG))
				 [SOME (CDR (GET LISPXHIST (QUOTE SIDE)))
				       (FUNCTION (LAMBDA (X)
					   (NEQ (CAR X)
						(QUOTE /PUTHASH]
				 (NEWFILE? FN))

          (* The reason for the OR is that if there are no messages 
          printed, then the only changes were well-defined clisp 
          transformations, and therefore if clispifyprettyflg is not 
          NIL, there is no point in re-clispifying and 
          reprettyprinting the function.)


			    (AND (NOT (EXPRP FN))
				 (DWIMUNSAVEDEF FN]
          (RETURN FN])

(DWIMIFY1
  [LAMBDA (FORM CLISPCONTEXT FORMSFLG)
    (DWMFY1 FORM])

(DWIMIFY1?
  [LAMBDA (FORM CLISPCONTEXT FORMSFLG)
    (COND
      (DWIMIFYFLG (DWMFY1 FORM))
      (T 

          (* See comment in dwimify0. DWIMIFY1? is used where caller 
          is not sure whether state variables have been set up.)


	 (PROG ((DWIMIFYING (AND DWIMIFYFLG DWIMIFYING))
		(DWIMIFYFLG T)
		DWIMIFYCHANGE)
	       (SETQ NOFIXFNSLST0 NOFIXFNSLST)
	       (SETQ NOFIXVARSLST0 NOFIXVARSLST)
	       (RETURN (DWMFY1 FORM])

(DWMFY1
  [LAMBDA (FORM)
    (PROG ((X FORM)
	   TEM CLISPCHANGE 89CHANGE ATTEMPTFLG CARISOKFLG)
          [COND
	    ((NLISTP FORM)
	      (SETQ TEM (LIST X))
	      (DWIMIFY2 TEM TEM NIL T)
	      (RETURN (CAR TEM]
      TOP [COND
	    ([AND (NEQ (CAR X)
		       (QUOTE LAMBDA))
		  (NEQ (CAR X)
		       (QUOTE NLAMBDA))
		  (OR (NULL (CHECKTRAN X))
		      CLISPRETRANFLG
		      (RETURN X))
		  (NOT (COND
			 [(LISTP (CAR X))

          (* Checks whether CAR is a function object with a remote 
          translation. Also converts to hash array from CLISP%  if 
          hash array exists. CARISOKFLG is set so dont have to recheck 
          at LP1.)


			   (OR (EQ (CAAR X)
				   (QUOTE LAMBDA))
			       (EQ (CAAR X)
				   (QUOTE NLAMBDA))
			       (SETQ CARISOKFLG (AND (CHECKTRAN (CAR X))
						     (NULL CLISPRETRANFLG]
			 ((LITATOM (CAR X))
			   (OR (FGETD (CAR X))
			       (FMEMB (CAR X)
				      NOFIXFNSLST0)
			       (GETP (CAR X)
				     (QUOTE EXPR))
			       (GETP (CAR X)
				     (QUOTE MACRO]
                                                (* The AND is true if CAR of 
                                                form is not recognized.)
	      (COND
		[(PROG (NEXTAIL)
		       (RETURN (WTFIX0 X X X X)))
                                                (* Successful correction.)
		  (COND
		    [CLISPCHANGE (COND
				   ((NEQ CLISPCHANGE (QUOTE PARTIAL))

          (* The tail must be DWIMIFIED if the transformation did not 
          affect the entire form, e.g. (FOO<...> ...))


				     (RETURN FORM))
				   ((LISTP (CAR X))
				     (GO LP1))
				   (T (SETQ CLISPCHANGE NIL)
				      (GO TOP)
                                                (* Recheck CAR of FORM, as it 
                                                may still be misspelled.)
				      ]
		    (89CHANGE (SETQ 89CHANGE NIL)
			      (GO TOP)

          (* Recheck CAR of FORM, as it still may be misspelled, e.g. 
          (conss8car X))


			      ]
		((AND CLISPCHANGE (NEQ CLISPCHANGE (QUOTE PARTIAL)))

          (* This means a CLISPCHANGE failed and not to bother with 
          dwimifying rest of form, e.g. a bad IF or FOR statement.)


		  (RETURN FORM))
		((AND (NULL ATTEMPTFLG)
		      (LITATOM (CAR X)))

          (* ATTEMPTFLG is used to distinguish between the case where 
          DWIM does not recognize the problem at all, and that where 
          it did but was unable to make the correction, e.g. a 
          malformed IF, or else the user vetoed the correction.)


		  (SETQ NOFIXFNSLST0 (CONS (CAR X)
					   NOFIXFNSLST0]

          (* The call to WTFIX is made before specific checks on CAR 
          of FORM, since CAR of the FORM may be misspelled.)


          (COND
	    ((LISTP (CAR X))                    (* Skip selectq)
	      (GO LP1)))
          [SELECTQ (CAR X)
		   ((DECLARE *)
		     NIL)
		   [(QUOTE GO)
		     (COND
		       ((CDDR X)
			 (RETURN (DWIMIFY1A X (CDDR X)))
			 (RETURN X]
		   (SELECTQ (DWIMIFY2 (CDR X)
				      FORM T NIL T)
			    (AND (NLISTP (CADDR X))
				 (DWIMIFY2 (CDDR X)
					   FORM NIL NIL T))
			    (SETQ X (CDDR X))
			    (PROG NIL
			      LP  (COND
				    ((NULL (CDR X))
				      (DWIMIFY2 X FORM T)
				      (RETURN FORM)))
			          (DWIMIFY2 (CDAR X)
					    (CAR X)
					    T)
			          (SETQ X (CDR X))
			          (GO LP)))
		   [[LAMBDA NLAMBDA]
		     ([LAMBDA (VARS)
			 (DWIMIFY2 (CDDR X)
				   FORM T]
		       (COND
			 ((NULL (SETQ TEM (CADR X)))
			   VARS)
			 ((ATOM TEM)
			   (CONS TEM VARS))
			 (T (APPEND TEM VARS]
		   ((SETQ SETN RPAQ)
		     (AND (NOT (FMEMB (CADR X)
				      VARS))
			  (NOT (FMEMB (CADR X)
				      NOFIXVARSLST0))
			  (SETQ NOFIXVARSLST0 (CONS (CADR X)
						    NOFIXVARSLST0)))
		     (DWIMIFY2 (CDDR X)
			       FORM T))
		   (PROG ([LAMBDA (VARS)
			     (DWIMIFY2 (CDDR X)
				       FORM T]
			   (NCONC [MAPCAR (CADR X)
					  (FUNCTION (LAMBDA (X)
					      (COND
						((ATOM X)
						  X)
						(T (DWIMIFY2 (CDR X)
							     X T)
						   (CAR X]
				  VARS)))
		   [COND
		     (MAPC (CDR X)
			   (FUNCTION (LAMBDA (X)
			       (DWIMIFY2 X X NIL T]
		   [FUNCTION (DWIMIFY1 (COND
					 ((LISTP (CADR X))
					   (CADR X))
					 ((NULL (CDDR X))

          (* Doesnt DWIMIFY for (FUCNTION FOO 
          (X Y)) i.e. FUNARY with atomic argument.)


					   (CDR X]
		   ((RESETVAR RESETFORM)
		     (DWIMIFY2 (CDDR X)
			       FORM T))
		   ((AND OR NLSETQ)             (* special check for most common
                                                of eval-nlambdas.)
		     (GO LP1))
		   (ASSEMBLE (RETURN FORM))
		   (COND
		     [(EQ (CAR X)
			  CLISPTRANFLG)

          (* Corresponds to hh case where CLISPRETRANFLG is T, since 
          otherwise would have been caught by CHECKTRAN at LP1 and 
          returned.)


		       (RETURN (DWIMIFY1 (CADR X]
		     ((AND (NEQ (GETP (CAR X)
				      (QUOTE INFO))
				(QUOTE EVAL))
			   (OR (EQ (SETQ TEM (ARGTYPE (CAR X)))
				   1)
			       (EQ TEM 3)
			       (FMEMB (CAR X)
				      NLAMA)
			       (FMEMB (CAR X)
				      NLAML)))
                                                (* Don't DWIMIFY the tails of 
                                                nlambdas.)
		       )
		     (T (GO LP1]
          (RETURN FORM)
      LP1 (DWIMIFY2 (CDR X)
		    FORM)
          [COND
	    [(LISTP (CAR X))
	      (AND (NULL CARISOKFLG)
		   (NULL CLISPCHANGE)
		   (DWIMIFY1 (CAR X)))

          (* Note that if CAR is a list, it itself has not yet been 
          dwimified, e.g. may be a misspelled LAMBDA.
          However If CLISPCHANGE is not NIL, this expression was 
          produced by the call to WTFIX and hence is already 
          dwimified.)


	      (COND
		([AND (NULL FORMSFLG)
		      (NEQ (CAAR X)
			   (QUOTE LAMBDA))
		      (NEQ (CAAR X)
			   (QUOTE NLAMBDA))
		      (NULL CARISOKFLG)
		      (NULL (CHECKTRAN (CAR X]
		  (RETURN (DWIMIFY1A X]
	    ([AND (CDDR X)
		  (OR (EQ (CAR X)
			  (QUOTE CAR))
		      (EQ (CAR X)
			  (QUOTE CDR))
		      (GETP (CAR X)
			    (QUOTE CROPS]
	      (RETURN (DWIMIFY1A X (CDDR X]
          (RETURN FORM])

(DWIMIFY1A
  [LAMBDA (PARENT TAIL FN)
    (COND
      ((OR FN (AND DWIMIFYFLG DWIMIFYING))
	(AND (FIXPRINTIN (OR FN FAULTFN))
	     (LISPXSPACES 1 T))
	(LISPXPRIN1 (QUOTE "(possible) parentheses error in
")
		    T)
	(LISPXPRINT (RETDWIM2 PARENT TAIL)
		    T T)
	(COND
	  (TAIL (LISPXPRIN1 (QUOTE "at ")
			    T)
		(LISPXPRINT (CONCAT (QUOTE "... ")
				    (SUBSTRING (RETDWIM2 TAIL NIL 2)
					       2 -1))
			    T T)))
	PARENT])

(DWIMIFY1B
  [LAMBDA (TAIL PARENT SUBPARENT FORMSFLG ONEFLG FAULTFN CLISPCONTEXT)

          (* An external entry to DWIMBLOCK.
          DWIMIFYFLG must be bound. Used by SHRKFY.
          Also by CLISPIFY1. CLISPCONTEXT=LINEAR means dont descend 
          into expressions. Used by calls from CLISPIFYING.)


    (EVQ DWIMIFYFLG)
    (AND DWIMIFYFLG (EVQ DWIMIFYING))
    (PROG ((DWIMIFYING (AND DWIMIFYFLG DWIMIFYING))
	   (DWIMIFYFLG T)
	   DWIMIFYCHANGE)
          (COND
	    (DWIMIFYING (EVQ DWIMIFY0CHANGE))
	    (T (EVQ FAULTPOS)))
          (EVQ EXPR)
          (EVQ VARS)
          (SETQ NOFIXFNSLST0 NOFIXFNSLST)
          (SETQ NOFIXVARSLST0 NOFIXVARSLST)
          (COND
	    ((AND (NULL FORMSFLG)
		  (EQ TAIL PARENT))
	      (DWIMIFY1 TAIL CLISPCONTEXT))
	    (T (DWIMIFY2 TAIL PARENT SUBPARENT FORMSFLG ONEFLG)))
          (RETURN DWIMIFYCHANGE])

(DWIMIFY2
  [LAMBDA (TAIL PARENT SUBPARENT FORMSFLG ONEFLG ONLYSPELLFLG)
    (DWMFY2])

(DWIMIFY2?
  [LAMBDA (TAIL PARENT SUBPARENT FORMSFLG ONEFLG ONLYSPELLFLG)
    (COND
      (DWIMIFYFLG (DWMFY2))
      (T 

          (* See comment in dwimify0. DWIMIFY2? is used where caller 
          is not sure whether state variables have been set up.)


	 (PROG ((DWIMIFYING (AND DWIMIFYFLG DWIMIFYING))
		(DWIMIFYFLG T)
		DWIMIFYCHANGE CLISPCONTEXT)
	       (SETQ NOFIXFNSLST0 NOFIXFNSLST)
	       (SETQ NOFIXVARSLST0 NOFIXVARSLST)
	       (RETURN (DWMFY2])

(DWMFY2
  [LAMBDA NIL                                   (* handles tails.)
    (AND (LISTP TAIL)
	 (PROG ((TAIL0 TAIL)
		X CLISPCHANGE 89CHANGE NEXTAIL ATTEMPTFLG TEM FNFLG NOTOKFLG)
	       (AND (OR (EQ SUBPARENT T)
			(EQ PARENT TAIL))
		    (SETQ SUBPARENT TAIL))

          (* Means dont ever back up beyond this point, e.g. in prog 
          variables, if you write (PROG ((X FOO Y LT 3) ..
          dont want LT to gobble the x.)))


	   LP  (SETQ CLISPCHANGE NIL)
	       (SETQ 89CHANGE NIL)
	       (SETQ NEXTAIL NIL)
	       (COND
		 ((NULL TAIL)
		   (GO OUT))
		 ((LISTP (SETQ X (CAR TAIL)))
		   (AND (NEQ CLISPCONTEXT (QUOTE LINEAR))
			(DWIMIFY1 X))
		   [AND FORMSFLG (EQ TAIL PARENT)
			(OR (EQ (CAR X)
				(QUOTE LAMBDA))
			    (EQ (CAR X)
				(QUOTE NLAMBDA)))
			(/RPLNODE TAIL (CONS (CAR TAIL)
					     (CDR TAIL]
		   (GO LP1))
		 [(OR (EQ (CAR PARENT)
			  (QUOTE PROG))
		      (NOT (LITATOM X]
		 ((CLISPNOTVARP X)

          (* (CAR TAIL) is not recognized as a variable.
          Note that when DWIMIFYING, WTFIX will be called on a 
          variable which is used freely, but does not have a top level 
          binding, i.e. DWIMIFYING hile the variable is bound is not 
          sufficient, because we do not do a STKSCAN for its value, as 
          this would be expensive. (STKSCAN is done when DWIMIFY2 is 
          called out of an evaluation.))


		   (COND
		     [(AND FORMSFLG (EQ TAIL PARENT)
			   (DWIMIFY2A TAIL (QUOTE QUIET)))

          (* DWIMIFY2A calls CLISPFUNCTION? to see if 
          (CAR TAIL) is the name of a function.
          If FORMSFLG is true and (CAR TAIL) is name of function, then 
          TAIL may be one form with parenteeses removed.)


		       (COND
			 ((OR (NEQ X (CAR TAIL))
			      (NEQ FORMSFLG (QUOTE FOR)))

          (* Either the user has approved the combined spelling 
          correction and insertion of paentheses, or else we are not 
          under an I>S> without an oerator.
          (E.g. FOR X IN Y WHILE ATOM PRINT X, In this cae dont want 
          to insert parentheses.) Note that if FOO is also the name of 
          a variable as well as a function, no harm will be done in 
          cases like IF A THEN FOO _ X. Only possible problem is for 
          case like IF A THEN FOO _ X Y, where FFO is both a 
          functionand a variable. In this case, parens would be 
          inserted, and then an error generated.
          HOwever, this is extremely unlikely, since in most cases it 
          would be written as IF A THEN FOO_X Y 
          (not to mention the added improbability of FOO being both 
          the name of a function and a variable.))


			   (GO INSERT))
			 (T 

          (* (CAR TAIL) is the name of a function, but user hasnt been 
          consulted, and we are under a FOR with no operator, so 
          wait.)


			    (SETQ FNFLG T)

          (* Now drop through to next COND and call to WTFIX 
          (because (CAR TAIL) may be a miispelled variable.))


			    ]
		     ([AND (EQ FORMSFLG (QUOTE FOR))
			   (EQ TAIL (CDR PARENT))
			   (OR (LISTP (CAR PARENT))
			       (NULL NOTOKFLG)
			       (NULL FNFLG))
			   (DWIMIFY2A TAIL (QUOTE QUIET))
			   (OR (NEQ X (CAR TAIL))
			       (LISTP (CAR PARENT]

          (* Corresponds to the case where the user left a DO out of a 
          for statement. Already know that the first thing in TAIL is 
          not the name of a function. However, only take action if the 
          usr approves combined correction, 
          (or (CAR PARENT) is a list.) since it is still possible that 
          X is the (misspelled) name of a variable.)


		       (SETQQ FORMSFLG FOR1)
		       (GO INSERT))
		     ([AND [LISTP (SETQ TEM (GETP X (QUOTE CLISPWORD]
			   (NEQ (CAR TEM)
				(CAR (GETP (CAR PARENT)
					   (QUOTE CLISPWORD]
		       (AND (EQ TAIL PARENT)
			    (SETQ NOTOKFLG T))

          (* See comment below on NOTOKFLG.
          Note that if FORMSFLG is true and 
          (EQ TAIL PARENT), then CLISPFUNCTION? 
          (via DWIMIFY2A) above would have returned T.)


		       (DWIMIFY1A PARENT TAIL)
                                                (* Stop dwimifying, strong 
                                                evidence that expression is 
                                                screwed up.)
		       (GO OUT)))
		   (COND
		     ((AND (NULL (AND ONLYSPELLFLG NOSPELLFLG))
			   (WTFIX0 X TAIL PARENT SUBPARENT ONLYSPELLFLG))

          (* If both ONLYSPELLFLG and NOSPELLFLG are true, no point in 
          calling WTFIX. ONLYSPELLFLG is true on calls fro 
          CLISPATOM2A.)


		       (COND
			 (89CHANGE (SETQ NOTOKFLG NIL)
				   (SETQ FNFLG NIL)

          (* If 89CHANGE, then want to look at 
          (CAR TAIL) again, e.g. ... (CONS 
          (CAR XX9)))


				   (GO LP)))
		       (GO LP1)))               (* At this point we know that 
                                                (CAR TAIL) is not ok.)
		   (AND (EQ TAIL TAIL0)
			(SETQ NOTOKFLG T))      (* NOTOKFLG=T means first 
                                                expression in TAIL was not 
                                                recognized as a variable.)
		   [COND
		     [(AND FORMSFLG (EQ TAIL PARENT))

          (* After DWIMIFYING the whole tail, if CAR is still an atom, 
          we may want to insert parentheses, e.g. 
          (FOO _ X Y) is ok, but (FOO X Y) may need to be converted to 
          ((FOO X Y)))


		       ]
		     [(FGETD X)

          (* Don't add a function name to NOFIXVARSLST0 since this is 
          tantamount to sanctiooning it as a variale.)


		       (COND
			 ((AND (EQ FORMSFLG (QUOTE FOR))
			       (EQ TAIL (CDR PARENT))
			       (OR (LISTP (CAR PARENT))
				   (NULL NOTOKFLG)
				   (NULL FNFLG)))
			   (SETQQ FORMSFLG FOR1)
			   (GO INSERT))
			 ((AND (NEQ CLISPCONTEXT (QUOTE IF))
			       (NEQ ONLYSPELLFLG (QUOTE NORUNONS))
			       (NOT (EXPRP X))
			       (NEQ X (QUOTE E))
			       (NEQ X (QUOTE *)))

          (* Printx message but dwimify rest of tail -
          might not be a parentheses error.)


			   (DWIMIFY1A PARENT TAIL]
		     ((NULL ATTEMPTFLG)
		       (SETQ NOFIXVARSLST0 (CONS X NOFIXVARSLST0]
		   (GO LP1)))
	   LP1 (COND
		 (ONEFLG (GO OUT)))
	       [SETQ TAIL (COND
		   ((NULL NEXTAIL)
		     (CDR TAIL))
		   ((EQ NEXTAIL T)
		     NIL)
		   (T (CDR NEXTAIL]
	       (GO LP)
	   OUT (COND
		 ([OR (NULL FORMSFLG)
		      (NOT (LITATOM (CAR TAIL0]
		   (GO OUT1))
		 ([OR (EQ FORMSFLG (QUOTE FOR1))
		      (AND (EQ FORMSFLG (QUOTE FOR))
			   (OR (NULL NOTOKFLG)
			       (NULL FNFLG))
			   (LISTP (CADR TAIL0]

          (* Corresponds to the cse where the user left out a DO.
          Want to check this before below as in this case dont want to 
          stick in paens around entire form.)


		   (GO OUT1))
		 ((EQ FORMSFLG T)

          (* (CAR TAIL0) is the name of a functionand NOT the name of 
          a variable.)


		   (AND NOTOKFLG FNFLG (GO ASK)))
		 [(CDR TAIL0)                   (* FORMSFLG is FOR or IF)
		   (COND
		     ((OR NOTOKFLG (DWIMIFY2A TAIL0 (QUOTE QUIET)))

          (* (CAR TAIL) is not the name of a variable, or else IS the 
          name of a function. The reason for the call to 
          CLISPFUNCTION? (via DWIMIFY2A) instead of checking FNFLG is 
          that in the case that (CAR TAIL) was the name of a variable 
          as indicated by NOTOKFLG=NIL, CLISPFUNCTION? would not have 
          been called earlier.)


		       (/RPLNODE TAIL0 (CONS (CAR TAIL0)
					     (CDR TAIL0)))
		       (GO OUT1]
		 ((AND NOTOKFLG FNFLG)

          (* (CAR TAIL) is not the name of a variable and is the name 
          of a function, but nothing follows it.
          E.g. IF -- THEN RETURN ELSE --)


		   (/RPLNODE TAIL0 (CONS (CAR TAIL0)
					 (CDR TAIL0)))
		   (GO OUT1)))
	   OUT1(RETURN (COND
			 ((NULL ONEFLG)
			   TAIL0)
			 (NOTOKFLG 

          (* In this way, the function thatcaled DWIMIFY2 can find out 
          whether or not the atom in question is OK.
          NOte that if it appears on NOFIXLST, it is OK, i.e. havng 
          been seen before, we treat it the same as a variable or what 
          not.)


				   NIL)
			 ((NULL NEXTAIL)
			   TAIL)
			 ((EQ NEXTAIL T)
			   PARENT)
			 (T NEXTAIL)))
	   ASK (COND
		 ((NULL (FIXSPELL1 [COND
				     (TYPE-IN? (QUOTE ""))
				     (T (CONCAT (QUOTE "... ")
						(SUBSTRING (RETDWIM2 TAIL0)
							   2 -1]
				   (CONCAT (QUOTE "... ")
					   (MKSTRING (RETDWIM2 TAIL0))
					   (QUOTE ")"))
				   NIL T))
		   (GO OUT1)))
	   INSERT
	       (/RPLNODE TAIL (CONS (CAR TAIL)
				    (CDR TAIL)))
	       (DWIMIFY1 (CAR TAIL)
			 CLISPCONTEXT)
	       (GO LP1])

(DWIMIFY2A
  [LAMBDA (TAIL TYP)
    (CLISPFUNCTION? TAIL TYP (FUNCTION [LAMBDA (X Y)
                        (SUBSTRING (RETDWIM2 Y)
                                   2 -1])
                    [FUNCTION (LAMBDA (X Y)
                        (CONCAT [MKSTRING
                                  (RETDWIM2 (COND
                                              [(LISTP X)
                                                (* Run-on.)
                                                (CONS (CAR X)
                                                      (CONS (CDR X)
                                                            (CDR Y]
                                              (T (CONS X (CDR Y]
                                (QUOTE ")"]
                    TAIL])

(SHRIEKER
  [LAMBDA (LOOKAT)

          (* Shrieker is designed to "understand" expressions of the 
          form (! A B !! C !! D E F), where A, B, C,...
          represent lists, ! indicates that the list following it is 
          to be (non-destructively) expanded 
          (e.g. A's elements are to be brought to the top level of the 
          list which contains A), and !! indicates that the list 
          following it is to be destructively expanded.
          Thus, if A= (H I J), B= (K L M), C= 
          (N O P), the result of evaluating 
          (! A !! B C) should be a list (H I J K L M C). SHRIEKER does 
          not actually evaluate the list given to it, but rather 
          returns a form which will have the correct evaluation.
          Thus, if SHRIEKER is given the 
          (shriekified) list (! A !! B C), it will return the form 
          (APPEND A (NCONC1 B C)). Should A,B,C have the values given 
          above, then evaluation of this form will leave A unchanged, 
          but B will have been destructively altered, and will now 
          evaluate to the list (K L M (N O P)).)


    (PROG (CARTEST RESULTP)
          (COND
            ((OR (ATOM LOOKAT)
                 (NLISTP LOOKAT))
              (SETQ WORKFLAG NIL)
              (RETURN LOOKAT)))

          (* As is evident from a look at the code, SHRIEKER is a 
          fairly straightforward recursive prog;
          analysis of the argument, LOOKAT, is doen in effect from the 
          tail of LOOKat to its head. I>e.
          given LOOKAT SHRIEKER separates it into two parts 
          (roughly car and cdr), where one part 
          (CARTEST) is the first element of LOOKAT that is not ! or !! 
          , and the other part is the tail of LOOKAT below CARTEST-- 
          LOOKAT is reset to evaluate to this tail and SHRIEKER is 
          called recursively on the new LOOKAT, eventually returning a 
          list structure, to which we setq RESULTP, that is the LISP 
          equivalent of LOOKAT (which, with its !'s and !!'s is an 
          expression in CLISP). The calling incarnation of SHRIEKER 
          uses RESULTP and its knowledge of the shriek-sysmbol 
          (! or ! ! or !!) immediately before CARTEST, to determine 
          how CARTEST and RESULTP should be used to form the list 
          structure that will be returned, possibly to higher level 
          incarnations of SHRIEKER. into then possibly incarnations 
          SHRIEKER.)


          (SETQ CARTEST (CAR LOOKAT))
          (SETQ LOOKAT (CDR LOOKAT))
          [RETURN (COND
                    ((EQ CARTEST (QUOTE !!))
                      (GO A1))
                    [(EQ CARTEST (QUOTE !))
                      (COND
                        (LOOKAT (SETQ CARTEST (CAR LOOKAT))
                                (SETQ LOOKAT (CDR LOOKAT))
                                (COND
                                  ((EQ CARTEST (QUOTE !))
                                    (GO A1)))

          (* This conditional insures that SHRIEKER will understnad 
          that the sequence ! ! means the atom !!.
          Control will be sent to the statement after A1, which will 
          make sure that CARTEST is NCONCed onto RESULTP 
          (if car of RESULTP is APPEND, CONS, NCONC1, or LIST) or will 
          stuff CARTEST into second place in RESULTP, which is 
          presumalby an NCONC expression-- all provided that WORKFLAG 
          is NIL...)


                                (SETQ RESULTP (SHRIEKER LOOKAT))
                                                (* Here's our recursive call to 
                                                SHRIEKER..)
                                (COND
                                  ((NULL RESULTP)

          (* WORKFLAG is a flag that is passed between incarnations of 
          SHRIEKER and is the means by which SHRIEKER is able to 
          distinguish between user-created code and SHRIEKER-created 
          code. If WORKFLAG eq's T then SHRIEKER knows that what has 
          been returned as RESULTP is user-created code and should not 
          be altered.)


                                    (SETQQ WORKFLAG !IT)
                                    (LIST (QUOTE APPEND)
                                          CARTEST))
                                  ((ATOM RESULTP)
                                    (SETQQ WORKFLAG APPENDING)
                                    (LIST (QUOTE APPEND)
                                          CARTEST RESULTP))
                                  ((NULL WORKFLAG)
                                    (SETQQ WORKFLAG APPENDING)
                                    (LIST (QUOTE APPEND)
                                          CARTEST RESULTP))
                                  (T 

          (* If the COND falls througn to this point then we may 
          assume that RESULTP is SHRIEKER-created and do a SELECTQ on 
          car of RESULTP (which should be either APPEND, NCONC, 
          NCONC1, CONS, or LIST) to determine whether we should stuff 
          CARTEST into RESULTP or not.)


                                     (SELECTQ WORKFLAG
                                              (APPENDING (ATTACH CARTEST
                                                                 (CDR RESULTP))
                                                         RESULTP)
                                              ((NCONCING CONSING LISTING 
                                                         NCONC1ING)
                                                (SETQQ WORKFLAG APPENDING)
                                                (LIST (QUOTE APPEND)
                                                      CARTEST RESULTP))
                                              (!IT (SETQQ WORKFLAG APPENDING)
                                                   (ATTACH CARTEST
                                                           (CDR RESULTP))
                                                   RESULTP)
                                              (!!IT (SETQQ WORKFLAG APPENDING)
                                                    (LIST (QUOTE APPEND)
                                                          CARTEST
                                                          (CADR RESULTP)))
                                              (LIST (QUOTE APPEND)
                                                    CARTEST RESULTP]
                    [LOOKAT 

          (* If we arrive here then we know that SHRIEKER's arguemnt-- 
          hte intial value of LOOKAT--is a list, the first element of 
          which is not ! or !!. Accordingly, we attempt to CONS or 
          LIST together CARTEST and RESULTP, depending on the nature 
          of RESULTP and the value of WORKFLAG left by the recursive 
          call to SHRIEKER in the statement below.)


                            (SETQ RESULTP (SHRIEKER LOOKAT))
                            (COND
                              ((NULL WORKFLAG)
                                (SETQQ WORKFLAG LISTING)
                                (LIST (QUOTE LIST)
                                      CARTEST))
                              (T (SELECTQ WORKFLAG
                                          ((CONSING APPENDING NCONCING 
                                                    NCONC1ING)
                                            (SETQQ WORKFLAG CONSING)
                                            (LIST (QUOTE CONS)
                                                  CARTEST RESULTP))
                                          (LISTING (ATTACH CARTEST
                                                           (CDR RESULTP))
                                                   RESULTP)
                                          ((!!IT !IT)
                                            (SETQQ WORKFLAG CONSING)
                                            (LIST (QUOTE CONS)
                                                  CARTEST
                                                  (CADR RESULTP)))
                                          (LIST (QUOTE CONS)
                                                CARTEST RESULTP]
                    (T 

          (* If we reach this point then we know that SHRIEKER was 
          called on a singleton, i.e. the intial vlaue of LOOKAT was a 
          list of one element, so we create the appropriate list 
          structure around that element and setq WORKFLAG to NIL, 
          enabling a possible parent SHRIEKER to modify our code.)


                       (SETQQ WORKFLAG LISTING)
                       (LIST (QUOTE LIST)
                             CARTEST]
      A1  (RETURN (COND
                    (LOOKAT (SETQ CARTEST (CAR LOOKAT))
                            (SETQ LOOKAT (CDR LOOKAT))
                            (SETQ RESULTP (SHRIEKER LOOKAT))
                            (COND
                              ((NULL RESULTP)
                                (SETQQ WORKFLAG !!IT)
                                (LIST NCONCLKUP CARTEST))
                              ((ATOM RESULTP)
                                (SETQQ WORKFLAG NCONCING)
                                (LIST NCONCLKUP CARTEST RESULTP))
                              ((NULL WORKFLAG)
                                (SETQQ WORKFLAG NCONCING)
                                (LIST NCONCLKUP CARTEST RESULTP))
                              (T (SELECTQ WORKFLAG
                                          (NCONCING (ATTACH CARTEST
                                                            (CDR RESULTP))
                                                    RESULTP)
                                          ((APPENDING CONSING)
                                            (SETQQ WORKFLAG NCONCING)
                                            (LIST NCONCLKUP CARTEST RESULTP))
                                          [NCONC1ING
                                            (SETQQ WORKFLAG NCONCING)
                                            (LIST NCONCLKUP CARTEST
                                                  (CADR RESULTP)
                                                  (CONS (QUOTE LIST)
                                                        (CDDR RESULTP]
                                          (!IT (SETQQ WORKFLAG NCONCING)
                                               (LIST NCONCLKUP CARTEST
                                                     (CADR RESULTP)))
                                          (!!IT (SETQQ WORKFLAG NCONCING)
                                                (ATTACH CARTEST (CDR RESULTP))
                                                RESULTP)
                                          [LISTING (COND
                                                     ((NULL (CDDR RESULTP))
                                                       (SETQQ WORKFLAG 
                                                              NCONC1ING)
                                                       (LIST NCONC1LKUP CARTEST
                                                             (CADR RESULTP)))
                                                     (T (SETQQ WORKFLAG 
                                                               NCONCING)
                                                        (LIST NCONCLKUP CARTEST 
                                                              RESULTP]
                                          (LIST NCONCLKUP CARTEST RESULTP])

(CLISPIF
  [LAMBDA (FORM)
    (LISPXWATCH CLISPSTATS)
    (LISPXWATCH IFSTATS)
    (AND DWIMIFYFLG (SETQ ATTEMPTFLG T))

          (* Translates (IF -- THEN -- ELSEIF -- THEN -- ELSE --) to 
          equivalent COND.)


    (PROG ((CLISPCONTEXT (QUOTE IF))
           CLISPRESPELL
           (DWIMIFYING (AND DWIMIFYFLG DWIMIFYING))
           [VARS (OR VARS (AND (NULL DWIMIFYFLG)
                               (GETVARS (OR BREAKFLG (LISTP EXPR]
           (FNSLST0 NOFIXFNSLST0)
           (VARSLST0 NOFIXVARSLST0)
           TEM)
      LP  (COND
            ((NULL DWIMIFYFLG)
              (SETQ NOFIXFNSLST0 NOFIXFNSLST)
              (SETQ NOFIXVARSLST0 NOFIXVARSLST)))
          (COND
            ((UNDONLSETQ (SETQ TEM (CLISPIF0 FORM))
                         CLISPIF0)
              (RETURN TEM))
            ((NULL CLISPRESPELL)
              (RETDWIM))
            ((CLISPELL FORM (QUOTE IFWORD))

          (* A misspelled IF wwrd was detected.
          We now go through respellings and make any corrections that 
          occur in FORM. Note that more than one correction may have 
          been involved, e.g. IF FOO XTHENN PRINT X.)


              (SETQ NOFIXFNSLST0 FNSLST0)
              (SETQ NOFIXVARSLST0 VARSLST0)

          (* The additions made to these lists may be wrong as a 
          result of the misspelling of the IF word, e.g. a variaae kay 
          have appeared in a function slot.)


              (SETQ CLISPRESPELL NIL)
              (GO LP)))
          (RETDWIM])

(CLISPIF0
  [LAMBDA (FORM)
    (PROG [X PRED TEM L L0 L-1 CLAUSE DWIMIFYCHANGE
             (FORM0 (AND CLISPIFTRANFLG (CONS (CAR FORM)
                                              (CDR FORM]
          (SETQ L0 (SETQ L (CDR FORM)))
      LP  (SELECTQ (CAR L)
                   [(IF if)
                     (COND
                       ((EQ L (CDR L-1))

          (* No IF's should be seen after the initial one except when 
          immediately following an ELSE. In this case the two words 
          are treated the same as ELSEIF.)


                         (SETQ PRED NIL))
                       (T (GO ERROR]
                   ((ELSEIF
                      elseif)
                     (SETQ X (NCONC1 X (CLISPIF1 PRED L0 L FORM)))
                     (SETQ PRED NIL))
                   ((ELSE
                      else)
                     (SETQ X (NCONC1 X (CLISPIF1 PRED L0 L FORM)))
                     (SETQ L-1 L)               (* To enable ELSE IF as two 
                                                words.)
                     (SETQ PRED T))
                   [(THEN
                        then)
                     (SETQ PRED (COND
                         ((EQ L0 L)
                           (GO ERROR))
                         (T 

          (* The reason for doing the LDIFF even when L is 
          (CDR L0) is that can't just set pred to CAR of L is becuase 
          then couldnt distinguish no predicate from IF NIL THEN -- 
          (Actually encountered by one user.))


                            (LDIFF L0 L]
                   (GO LP1))
          (SETQ L0 (CDR L))
      LP1 (COND
            ((SETQ L (CDR L))
              (GO LP)))
          (SETQ X (NCONC1 X (CLISPIF1 PRED L0 L FORM)))
          (/RPLNODE FORM (QUOTE COND)
                    X)
          (SETQ L (CDR FORM))

          (* The COND must appear in the original definition before 
          DWIMIFYing can be done, or else correction of 8 and 9 errors 
          won't work. Some unnecessary work may be done by virtue of 
          DWIMIFYING the whole IF statement, even when it is being 
          evaluated (as opposed to being dwimified). however, in most 
          cases, if the user employs IF, there will be other CLISP 
          constructs in the predicates and consequents.)


      LP2 (SETQ CLAUSE (CAR L))
          (COND
            ((LISTP (CAR CLAUSE))
              (DWIMIFY1 (CAR CLAUSE)
                        (QUOTE IF)))
            (T (SETQ TEM (CDR CLAUSE))
               (FRPLACD CLAUSE NIL)
               (DWIMIFY2 CLAUSE CLAUSE NIL (QUOTE IF))
               (FRPLACD CLAUSE TEM)))
          (DWIMIFY2 (SETQ TEM (CDR CLAUSE))
                    TEM NIL (QUOTE IF))
          (COND
            ((SETQ L (CDR L))
              (GO LP2)))
          (CLISPIF2 FORM)
          (COND
            (FORM0 (SETQ X (CONS (CAR FORM)
                                 (CDR FORM)))
                   (/RPLNODE FORM (CAR FORM0)
                             (CDR FORM0))
                   (CLISPTRAN FORM X)))
          (RETURN FORM)
      ERROR
          (SETQ CLISPERTYPE (LIST 4 L FORM))
          (ERROR!])

(CLISPIF1
  [LAMBDA (PRED L0 L FORM)
    (COND
      (PRED (CONS (COND
                    ((CDR PRED)
                      PRED)
                    (T (CAR PRED)))
                  (LDIFF L0 L)))
      ((EQ L0 L)

          (* Note that ELSE or ELSEIF can imediately follow a THEN by 
          virtue of the PRED check in earlier clause.)


        (SETQ CLISPERTYPE (LIST 4 L FORM))
        (ERROR!))
      ((EQ (CDR L0)
           L)
        (LIST (CAR L0)))
      (T (LIST (LDIFF L0 L])

(CLISPIF2
  [LAMBDA (X)
    (PROG (TEM1 TEM2 TEM3)
          (COND
            ((NEQ (CAR X)
                  (QUOTE COND)))
            ((AND (EQ [CADR (SETQ TEM1 (CAR (SETQ TEM2 (FLAST X]
                      X)
                  (EQ (CAR TEM1)
                      T)
                  (NULL (CDDR TEM1)))

          (* Changes expression of X (COND -- 
          (T (COND **))) to (COND -- **) useful for producing more 
          aesthetic code when the 'DO' portion of a 'FOR' statement is 
          an 'IF' Converts)


              (/RPLNODE TEM2 (CADR X)
                        (CDDR X)))
            ((AND (EQ (CAR TEM1)
                      T)
                  (EQ [CADR (SETQ TEM3 (CAR (SETQ TEM2 (NLEFT X 2]
                      X)
                  (NULL (CDDR TEM2)))

          (* Converts expression of X (COND 
          (& (COND --)) (T **)) to (COND 
          ((NEGATION &) **) --))


              (/RPLNODE TEM1 (CAR TEM3)
                        (CDR TEM1))
              (/RPLNODE TEM2 TEM1 (CDADR TEM3])

(CLISPFOR
  [LAMBDA (FORM)
    (LISPXWATCH CLISPSTATS)
    (LISPXWATCH I.S.STATS)
    (AND DWIMIFYFLG (SETQ ATTEMPTFLG T))

          (* Translates (IF -- THEN -- ELSEIF -- THEN -- ELSE --) to 
          equivalent COND.)


    (PROG [(CLISPCONTEXT (QUOTE FOR))
           TEM CLISPRESPELL (DWIMIFYING (AND DWIMIFYFLG DWIMIFYING))
           (VARS (OR VARS (AND (NULL DWIMIFYFLG)
                               (GETVARS (OR BREAKFLG (LISTP EXPR]
      LP  (COND
            ((NULL DWIMIFYFLG)
              (SETQ NOFIXFNSLST0 NOFIXFNSLST)
              (SETQ NOFIXVARSLST0 NOFIXVARSLST)))
          (SETQ CLISPRESPELL NIL)
          (COND
            ((UNDONLSETQ (SETQ TEM (CLISPFOR0 FORM))
                         CLISPFOR0)
              (RETURN TEM))
            ((NULL CLISPRESPELL)
              (RETDWIM))
            ((CLISPELL FORM (QUOTE FORWORD))

          (* A misspelled I.S. wwrd was detected.
          We now go through respellings and make any corrections that 
          occur in FORM. Note that more than one correction may have 
          been involved, e.g. FOR X IN YWHILLE Z FOO XTHENN PRINT X.)


              (SETQ CLISPRESPELL NIL)
              (GO LP)))
          (RETDWIM])

(CLISPFOR0
  [LAMBDA (I.S.)
    (PROG (DWIMIFYCHANGE (X I.S.)
			 FOROPR LASTPTR FORPTRS FORBODY TEM FOROPR1 I.V. FIRSTI.V. IVINITFLG 
			 PROGVARS INITVARS MAKEPROGFLG TERMINATEFLG TERM ITER LSTVAR
			 (LSTVARS (QUOTE ($$LST1 $$LST2 $$LST3 $$LST4 $$LST5 $$LST6)))
			 EXCEPTPREDS RETPREDS RETEXP UNDOLST FOR BIND AS FROM TO IN/ON
	     BY FINALLY EACHTIME FIRST CLISPWORD)
          (COND
	    ((NULL DWIMIFYFLG)
	      (SETQ NOFIXFNSLST0 NOFIXFNSLST)
	      (SETQ NOFIXVARSLST0 NOFIXVARSLST)))
      LP  (COND
	    ([NOT (LITATOM (SETQ TEM (CAR X]
	      (GO LP1)))
      RECHECK
          [SETQ LASTPTR (COND
	      ([NULL (SETQ CLISPWORD (GETP TEM (QUOTE CLISPWORD]
		(GO LP1))
	      ((OR (NLISTP CLISPWORD)
		   (NEQ (CAR CLISPWORD)
			(QUOTE FORWORD)))                   (* E.g. OR, AND, etc.)
		(GO LP1))
	      ((NLISTP (CDR CLISPWORD))

          (* This converts everything to the lowercase version thereby simplifying the 
          selectq. (There is no information tored to enable getting back to uppercase 
          from lowercase (using properties) so that lowercase is the only available 
          canonical representation.))


		(SETQ TEM (CDR CLISPWORD)))
	      (T                                            (* This implements synonyms, e.g. 
                                                            WHERE is the same as WHEN.)
		 (SETQ TEM (CADDR CLISPWORD))
		 (GO RECHECK]
          [SETQ LASTPTR (SELECTQ LASTPTR
				 (for (LIST (QUOTE FOR)
					    (SETQ FOR X)))
				 (as (OR TERMINATEFLG (SETQ TERMINATEFLG (OR IN/ON RETPREDS
									    TO)))
				     [COND
				       ((OR FOR AS I.V.))
				       ((OR FROM IN/ON TO)
                                                            (* E.g. IN X AS I FROM 1 TO 10 DO 
                                                            --.)
					 (SETQ PROGVARS (CONS (SETQ FIRSTI.V. (SETQQ I.V. $$TEM)
								)
							      PROGVARS]
				     (SETQ IN/ON NIL)
				     (SETQ FROM NIL)
				     (SETQ TO NIL)
				     (SETQ BY NIL)

          (* Primarily for error detection, i.e. now can just check to see if say both 
          IN/ON and FRM appear in one stretch.)


				     (SETQ LASTPTR (LIST (QUOTE AS)
							 (SETQ AS X)))
				     (GO LP0))
				 (bind (SETQ LASTPTR (LIST (QUOTE BIND)
							   (SETQ BIND X)))
				       (GO LP0))
				 (from (AND IN/ON (CLISPFORERR IN/ON X (QUOTE BOTH)))
				       (LIST (QUOTE FROM)
					     (SETQ FROM X)))
				 ((in on)
				   (AND (SETQ TEM (OR FROM TO))
					(CLISPFORERR TEM X (QUOTE BOTH)))
				   (LIST (QUOTE IN/ON)
					 (SETQ IN/ON X)))
				 (to (AND IN/ON (CLISPFORERR IN/ON X (QUOTE BOTH)))
				     (LIST (QUOTE TO)
					   (SETQ TO X)))
				 (by (LIST (QUOTE BY)
					   (SETQ BY X)))
				 (while 

          (* WHILE, UNTIL, UNLESS< WHEN, Finally, FIRST, and EACHTIME can appear more 
          than once. the corresponding FORPTR'S are gathered on a list and processed 
          by a call to either CLISPFOR2 for the first four, and CLISPFOR3 for latter 
          three (which can have imlicit progns as well.))


					(SETQ RETPREDS (CONS (SETQ LASTPTR (LIST (QUOTE
										    WHILE)
										 X))
							     RETPREDS))
					(GO LP0))
				 (until (SETQ RETPREDS (CONS (SETQ LASTPTR (LIST (QUOTE
										    UNTIL)
										 X))
							     RETPREDS))
					(GO LP0))
				 (unless (SETQ EXCEPTPREDS (CONS (SETQ LASTPTR
								   (LIST (QUOTE UNLESS)
									 X))
								 EXCEPTPREDS))
					 (GO LP0))
				 (when (SETQ EXCEPTPREDS (CONS (SETQ LASTPTR
								 (LIST (QUOTE WHEN)
								       X))
							       EXCEPTPREDS))
				       (GO LP0))
				 (finally (SETQ FINALLY (CONS (SETQ LASTPTR
								(LIST (QUOTE FINALLY)
								      X))
							   FINALLY))
					  (GO LP0))
				 (eachtime (SETQ EACHTIME (CONS (SETQ LASTPTR
								  (LIST (QUOTE EACHTIME)
									X))
							     EACHTIME))
					   (GO LP0))
				 (first (SETQ FIRST (CONS (SETQ LASTPTR (LIST (QUOTE FIRST)
									      X))
						       FIRST))
					(GO LP0))
				 (old (GO LP1))
				 (COND
				   ((SETQ TEM (GETP LASTPTR (QUOTE I.S.TYPE)))
                                                            (* COLLECT< DO, JOIN, SUM ETC.)
				     [AND FOROPR (COND
					    ((AND (EQ FOROPR1 (QUOTE do))
						  (EQ (CDR FOROPR)
						      X))   (* User said DO COLLECT or DO JOIN.
                                                            Ignore the DO.)
					      (/RPLNODE FOROPR (CAR X)
							(CDR X))
					      (SETQ FOROPR1 LASTPTR)
					      (GO LP1))
					    ((AND (EQ FOROPR1 (QUOTE thereis))
						  (OR (EQ (CAR X)
							  (QUOTE SUCHTHAT))
						      (EQ (CAR X)
							  (QUOTE suchthat)))
						  (NULL FOR)
						  (SETQ FOR (FASSOC (QUOTE FOROPR)
								    FORPTRS)))
                                                            (* Special glitch to allow ISTHERE 
                                                            -- SUCHTHAT --)
					      (FRPLACA FOR (QUOTE FOR))
                                                            (* Changes the ISTHERE to FOR.)
					      (SETQ FOR (CADR FOR)))
					    (T (CLISPFORERR FOROPR X (QUOTE BOTH]
				     (SETQ FOROPR1 LASTPTR)
				     [COND
				       ((SETQ TEM (CADDDR TEM))
					 (SETQ X (/NCONC X
							 (PROG1 TEM
								(SETQ UNDOLST
								  (CONS (LIST (SETQ TEM
										(LAST X))
									      (CAR TEM))
									UNDOLST]
                                                            (* See comment in I.S.TYPE)
				     (LIST (QUOTE FOROPR)
					   (SETQ FOROPR X)))
				   (T (CLISPFORERR X]
          (AND (SETQ TEM (FASSOC (CAR LASTPTR)
				 FORPTRS))
	       (NULL AS)
	       (CLISPFORERR (CADR TEM)
			    (CADR LASTPTR)
			    (QUOTE TWICE)))
      LP0 (COND
	    ((AND (NULL (CDR X))
		  (EQUAL I.S. (CAR HISTENTRY)))
	      (PRIN1 (QUOTE ...)
		     T)
	      (PEEKC T)
	      (NCONC I.S. (READLINE T))
	      (GO LP0)))
          (SETQ FORPTRS (NCONC1 FORPTRS LASTPTR))
      LP1 (COND
	    ((SETQ X (CDR X))
	      (GO LP)))
          (SETQ TEM VARS)
          [MAP FORPTRS (FUNCTION (LAMBDA (PTRS)
		   (SETQ PROGVARS (SELECTQ (CAAR PTRS)
					   ((BIND AS)
					     (APPEND PROGVARS (CLISPFORVARS PTRS)))
					   (FOR 

          (* The reason for the reverse in order in the APPEND beloow is in caseBIND 
          appears before FOR, and a PROG is not being made, must have FOR variables 
          first. NOte if a prog is being made, it doesnt matter.)

                                                            (* The call to CLISPFORVARS will 
                                                            also set I.V. and FIRSTI.V.)
						(APPEND (CLISPFORVARS PTRS)
							PROGVARS))
					   (IN/ON (PROG [(VARS (COND
								 (FOROPR TEM)
								 (T VARS]
						        (CLISPFOR1 PTRS T))

          (* IN/ON should be handled before adding VARS because that is when its 
          operand is evaluqted. (Except when there is no FOROPR, because we really 
          might be DWIMIFYING what will be the FOROPR.))


						  PROGVARS)
					   PROGVARS]

          (* Need to do this before CLISPFOR1 to get all ofthe variables 'bound' i.e. 
          added to rs, and to note the names of the i.v.
          (s))


          [COND
	    ((AND (NULL I.V.)
		  (OR FROM IN/ON TO))

          (* This can only occur if there is no FOR and no AS.
          If thee is no FOR and an AS, the I.V. for the initial segment, if one is 
          needed, is set up in the SELECTQ at LP.)


	      (SETQ PROGVARS (CONS (SETQQ I.V. $$TEM)
				   PROGVARS]
          (MAP FORPTRS (FUNCTION CLISPFOR1))
          [SETQ FORBODY (AND FOROPR (COND
			       ((NLISTP (CAR FOROPR))
				 (LIST (CADR FOROPR)))
			       (T 

          (* This occurs when the FOROPR specifies more than one operation, i.e. an 
          implicit PROGN. In this case, FOROPR was reset to the body of the PROGN.)


				  (CAR FOROPR]
          [COND
	    (RETPREDS (GO MAKEPROG))
	    ((NULL FOROPR)
	      (ERRORMESS1 (QUOTE "No DO, COLLECT, or JOIN in:")
			  I.S.)
	      (ERROR!))
	    (TO (GO MAKEPROG))
	    ((NULL IN/ON)
	      (COND
		([AND (NULL CLISPI.S.GAG)
		      (NULL TERMINATEFLG)
		      (NULL (CLISPFOR4 (GETP FOROPR1 (QUOTE I.S.TYPE]

          (* Before printing this message, check I>S>TYPE for possilb RETURN or GO, as 
          with THEREIS, SUCHTHAT, etc.)


		  (PRIN1 (QUOTE "Possible non-terminating iterative statement:
")
			 T)
		  (PRINT [MAPCAR I.S. (FUNCTION (LAMBDA (X)
				     (RETDWIM2 X NIL 1]
			 T T)))
	      (GO MAKEPROG))
	    ((OR FROM AS (CDR PROGVARS)
			 INITVARS MAKEPROGFLG
		FINALLY FIRST EACHTIME [NOT (FMEMB FOROPR1 (QUOTE (collect join do]
				       (AND EXCEPTPREDS TYPE-IN? (NULL DWIMIFYFLG)))

          (* On TYPE-IN? do not convert to MAPCONC, i.e. convert to a PROG, as 
          otherwise the MAPCONC would be converted toa /MAPCONC, which is 
          unnecessary.)


	      (GO MAKEPROG))
	    (EXCEPTPREDS (SETQ EXCEPTPREDS (CLISPFOR2 EXCEPTPREDS T))
			 [SETQ TEM (COND
			     ((CDR EXCEPTPREDS)
			       (CONS (QUOTE AND)
				     EXCEPTPREDS))
			     (T (CAR EXCEPTPREDS]           (* TEM is a predicate)
			 [SETQ TEM
			   (CONS TEM (SELECTQ
				   FOROPR1
				   ((do join)
				     FORBODY)
				   [collect (COND
					      ([AND (EQ (CAR FORBODY)
							I.V.)
						    (NULL (CDR FORBODY))
						    (OR (EQ (CAR IN/ON)
							    (QUOTE IN))
							(EQ (CAR IN/ON)
							    (QUOTE in]
                                                            (* COLLECT i.v. WHEN -- or UNLESS --
                                                            translates to SUBSET.)
						(SETQQ FOROPR1 subset)
						NIL)
					      (T (SETQQ FOROPR1 join)
						 (NCONC (LDIFF FORBODY (SETQ TEM (FLAST FORBODY)
								 ))
							(LIST (LIST (QUOTE LIST)
								    (CAR TEM]
				   (HELP]
			 (SETQ FORBODY (LIST (COND
					       ((CDDR TEM)
						 (LIST (QUOTE COND)
						       TEM))
					       [(CDR TEM)
						 (CONS (QUOTE AND)
						       (COND
							 ((EQ (CAAR TEM)
							      (QUOTE AND))
							   (APPEND (CDAR TEM)
								   (CDR TEM)))
							 (T TEM]
					       (T           (* Subset)
						  (CAR TEM]
          [SETQ X (CONS (SELECTQ (CAR IN/ON)
				 ((IN in)
				   (SELECTQ FOROPR1
					    (subset (QUOTE SUBSET))
					    (collect (QUOTE MAPCAR))
					    (join (CLISPLOOKUP (QUOTE MAPCONC)
							       (CADR IN/ON)))
					    (do (QUOTE MAPC))
					    (HELP)))
				 ((ON on)
				   (SELECTQ FOROPR1
					    (collect (QUOTE MAPLIST))
					    (join (CLISPLOOKUP (QUOTE MAPCON)
							       (CADR IN/ON)))
					    (do (QUOTE MAP))
					    (HELP)))
				 (HELP))
			(CONS (CADR IN/ON)
			      (LIST (CLISPFORF/L FORBODY PROGVARS]
          (COND
	    (BY (NCONC1 X (CLISPFORF/L (LIST (SUBST I.V. (CADR IN/ON)
						    (CADR BY)))
				       PROGVARS))

          (* The reason for the subst is the manual says you can refer to the current 
          tail in a BY by using either the I.V> or the operand to IN/ON.
          This normalizes it to I>V., which is always 
          (CAR PROGVARS). NOte similar operation in SUBPAIR about 3 pages from here.)


		))
          (GO OUT)
      MAKEPROG
          (COND
	    ([AND (EQ FOROPR1 (QUOTE collect))
		  (SETQ X (GETP (QUOTE fcollect)
				(QUOTE I.S.TYPE]

          (* This is the form for MAPCAR used by the compiler.
          Its advantage is it doesnt call NCONC1 and results in no extra function 
          calls. User can disable this by removing the property of FCOLLECT.)


	      [SETQ PROGVARS (APPEND PROGVARS (SETQ TEM (GET (CADDDR X)
							     (QUOTE BIND]
	      (SETQ VARS (APPEND VARS TEM)))
	    ((NULL FOROPR1)
	      [SETQ RETEXP (LIST (LIST (QUOTE RETURN]
	      (GO MP0))
	    ([NULL (SETQ X (GETP FOROPR1 (QUOTE I.S.TYPE]
	      (HELP)))
          [PROG ((VARS (APPEND (QUOTE (BODY $$VAL I.V.))
			       VARS)))
	        [SETQ FORBODY (SUBPAIR (QUOTE (BODY I.V.))
				       (LIST (COND
					       ((CDR FORBODY)
						 (CONS (QUOTE PROGN)
						       FORBODY))
					       (T (CAR FORBODY)))
					     (OR FIRSTI.V. I.V.))
				       (DWIMIFY1 (COPY (CAR X]
	        (SETQ FORBODY (COND
		    ((EQ (CAR FORBODY)
			 (QUOTE PROGN))
		      (APPEND (CDR FORBODY)))
		    (T (LIST FORBODY]                       (* FORBODY is now a list of forms.)
          (AND (SETQ TEM (CADDR X))
	       (OR (EQ TEM (QUOTE $$VAL))
		   (LISTP TEM))
	       (SETQ PROGVARS (CONS (COND
				      ((CADR X)
					(LIST (QUOTE $$VAL)
					      (CADR X)))
				      (T (QUOTE $$VAL)))
				    PROGVARS)))

          (* Dont add $$VAL to progvars if its value is definitely not going to be 
          used, e.g. DO, NEVER, etc.)


          (SETQ RETEXP (LIST (LIST (QUOTE RETURN)
				   TEM)))
      MP0 (COND
	    ((NULL AS)
	      (GO NX)))
          (SETQ I.V. FIRSTI.V.)
      MP1 (SETQ IN/ON NIL)
          (SETQ FROM NIL)
          (SETQ TO NIL)
          (SETQ BY NIL)
      MP2 (SELECTQ (CAAR FORPTRS)
		   (FROM (SETQ FROM (CADAR FORPTRS)))
		   (BY (SETQ BY (CADAR FORPTRS)))
		   (IN/ON (SETQ IN/ON (CADAR FORPTRS)))
		   (TO (SETQ TO (CADAR FORPTRS)))
		   (AS (GO NX))
		   NIL)
          (COND
	    ((SETQ FORPTRS (CDR FORPTRS))
	      (GO MP2)))
      NX  (SETQ LSTVAR (CAR LSTVARS))
          (COND
	    (IN/ON (SETQ TEM (CADR IN/ON))
		   [COND
		     [(AND [COND
			     ((OR (EQ TEM (QUOTE OLD))
				  (EQ TEM (QUOTE old)))     (* IN OLD --)
			       (SETQ TEM (CADDR IN/ON)))
			     ((OR (EQ (CAR TEM)
				      (QUOTE OLD))
				  (EQ (CAR TEM)
				      (QUOTE old)))         (* IN (OLD --))
			       (SETQ TEM (CADR TEM]
			   (COND
			     ((LITATOM TEM)                 (* IN OLD X or IN (OLD X))
			       (SETQ LSTVAR TEM))
			     ((EQ (CAR TEM)
				  (QUOTE SETQ))

          (* IN OLD X _ .. or IN (OLD X _ ..), or IN OLD 
          (X _ ..) or IN (OLD (X _ ..)))


			       (SETQ LSTVAR (CADR TEM))
			       (SETQ INITVARS (NCONC1 INITVARS TEM]
		     [(OR (EQ (CAR IN/ON)
			      (QUOTE ON))
			  (EQ (CAR IN/ON)
			      (QUOTE on)))                  (* Normal case, no 'OLD'.
                                                            No need for dummy variable for ON.)
		       (SETQ LSTVAR I.V.)
		       (SETQ INITVARS (NCONC1 INITVARS (LIST (QUOTE SETQ)
							     I.V. TEM]
		     (T (SETQ PROGVARS (CONS (LIST LSTVAR TEM)
					     PROGVARS]
		   (SETQ RETPREDS (CONS (LIST (QUOTE NLISTP)
					      LSTVAR)
					RETPREDS))
		   [AND (NEQ I.V. LSTVAR)
			(SETQ TERM (NCONC1 TERM (LIST (QUOTE SETQ)
						      I.V.
						      (COND
							((OR (EQ (CAR IN/ON)
								 (QUOTE IN))
							     (EQ (CAR IN/ON)
								 (QUOTE in)))
							  (LIST (QUOTE CAR)
								LSTVAR))
							(T LSTVAR]
		   [SETQ ITER (NCONC1 ITER (CONS (QUOTE SETQ)
						 (CONS LSTVAR
						       (COND
							 [BY (SUBPAIR (LIST I.V. (CADR IN/ON))
								      (LIST LSTVAR LSTVAR)
								      (LIST (CADR BY]
							 (T (LIST (LIST (QUOTE CDR)
									LSTVAR]
		   (GO BUILDIT))
	    (FROM [SETQ INITVARS (NCONC1 INITVARS (CONS (QUOTE SETQ)
							(CONS I.V. (LIST (CADR FROM]

          (* Done this way instead of adding to PROGVARS because I.V.
          may not even be on PROGVARS if it is an OLD variable.)


		  (SETQ IVINITFLG T)))
          [COND
	    (TO [SETQ TEM (COND
		    [(NUMBERP (CADR BY))
		      (COND
			((MINUSP (CADR BY))
			  (QUOTE LT))
			(T (QUOTE GT]
		    [BY (SETQ PROGVARS (CONS (QUOTE $$TEM)
					     PROGVARS))
			[SETQ BY (LIST (QUOTE BY)
				       (LIST (QUOTE SETQ)
					     (QUOTE $$TEM)
					     (CADR BY]
			(LIST (QUOTE AND)
			      (QUOTE $$TEM)
			      (LIST (QUOTE OR)
				    (LIST (QUOTE ZEROP)
					  (QUOTE $$TEM))
				    (LIST (QUOTE COND)
					  (LIST (LIST (QUOTE MINUSP)
						      (QUOTE $$TEM))
						(LIST (CLISPLOOKUP (QUOTE LT)
								   I.V.)
						      I.V.
						      (CADR TO)))
					  (LIST T (LIST (CLISPLOOKUP (QUOTE GT)
								     I.V.)
							I.V.
							(CADR TO]
		    ((AND (FIXP (CADR FROM))
			  (FIXP (CADR TO))
			  (ILESSP (CADR TO)
				  (CADR FROM)))
		      (SETQQ BY (BY -1))
		      (QUOTE LT))
		    (T (QUOTE GT]
		[AND (NULL IVINITFLG)
		     (SETQ INITVARS (NCONC1 INITVARS (LIST (QUOTE SETQ)
							   I.V. 1]
		(SETQ RETPREDS (CONS (COND
				       ((NLISTP TEM)
					 (LIST (CLISPLOOKUP TEM I.V.)
					       I.V.
					       (CADR TO)))
				       (T TEM))
				     RETPREDS]
          [COND
	    ((OR BY FROM TO)
	      (SETQ ITER (NCONC1 ITER (LIST (QUOTE SETQ)
					    I.V.
					    (COND
					      ((OR FROM TO)
						(LIST (CLISPLOOKUP (QUOTE +)
								   I.V.)
						      I.V.
						      (OR (CADR BY)
							  1)))
					      (T (CADR BY]
      BUILDIT
          (COND
	    ((AND AS FORPTRS)
	      (SETQ I.V. (CADDAR FORPTRS))
	      (SETQ IVINITFLG (CADDDR (CAR FORPTRS)))
	      (SETQ FORPTRS (CDR FORPTRS))
	      (AND (NULL (SETQ LSTVARS (CDR LSTVARS)))
		   (CLISPFORERR (QUOTE "too many concurrent loops
")))
	      (GO MP1)))
          (SETQ EXCEPTPREDS (CLISPFOR2 EXCEPTPREDS))
          (SETQ RETPREDS (CLISPFOR2 RETPREDS))
          [COND
	    (RETPREDS [COND
			(FINALLY (SETQ TEM (CLISPFOR3 FINALLY))
				 (SETQ RETEXP (COND
				     ((EQ (CAAR (FLAST TEM))
					  (QUOTE RETURN))
				       TEM)
				     (T (NCONC TEM RETEXP]
		      (SETQ RETPREDS (CONS (COND
					     ((CDR RETPREDS)
					       (CONS (QUOTE OR)
						     RETPREDS))
					     (T (CAR RETPREDS)))
					   RETEXP]
          [COND
	    (EXCEPTPREDS [SETQ EXCEPTPREDS (LIST (COND
						   ((CDR EXCEPTPREDS)
						     (CONS (QUOTE OR)
							   EXCEPTPREDS))
						   (T (CAR EXCEPTPREDS)))
						 (LIST (QUOTE GO)
						       (QUOTE $$ITERATE]
			 (SETQ FORBODY (CONS (COND
					       (RETPREDS (LIST (QUOTE COND)
							       RETPREDS EXCEPTPREDS))
					       (T (LIST (QUOTE COND)
							EXCEPTPREDS)))
					     FORBODY)))
	    (RETPREDS (SETQ FORBODY (CONS (LIST (QUOTE COND)
						RETPREDS)
					  FORBODY]
          [SETQ X (CONS (QUOTE PROG)
			(CONS PROGVARS (NCONC INITVARS (AND FIRST (CLISPFOR3 FIRST))
					      (CONS (QUOTE $$LP)
						    (NCONC TERM (AND EACHTIME (CLISPFOR3
										 EACHTIME))
							   FORBODY
							   (LIST (QUOTE $$ITERATE))
							   ITER
							   (LIST (LIST (QUOTE GO)
								       (QUOTE $$LP]
      OUT [MAPC UNDOLST (FUNCTION (LAMBDA (X)
		    (FRPLACA (CAR X)
			     (CADR X))
		    (FRPLACD (CAR X)
			     (CDDR X]

          (* Restores those places where I.V.'s where stuck in, e.g. FOR X IN Y 
          COLLECT FOO was temporarily converted to FOR X IN Y COLLECT 
          (FOO X), and IN Y COLLECT FOO would have been chaged to IN Y COLLECT 
          (FOO $$TEM))


          (CLISPTRAN I.S. X)
          (RETURN I.S.])

(CLISPFOR1
  [LAMBDA (PTRS FLG)
    (PROG ((X (CADAR PTRS))
	   X1
	   (Y (CADADR PTRS))
	   Z TEM LSTFLG)

          (* X is the TAIL of the iterative statement beginning with 
          the operator, Y the tail beginning with the next opeator.)


          (SELECTQ (CAAR PTRS)
		   ((FOR BIND)
		     (RETURN))
		   (IN/ON (AND (NULL FLG)
			       (RETURN))        (* Already done.)
			  )
		   (AS (SETQ I.V. (CADDAR PTRS))
		       (RETURN))
		   NIL)
          [SETQ X1 (COND
	      ((OR (EQ (CADR X)
		       (QUOTE OLD))
		   (EQ (CADR X)
		       (QUOTE old)))
		(OR MAKEPROGFLG (SETQ MAKEPROGFLG T))
		(CDDR X))
	      (T (CDR X]
          (COND
	    ((EQ X1 Y)                          (* 2 FORWORDS in a row.)
	      (CLISPFORERR X Y (QUOTE MISSING)))
	    ((NEQ (CDR X1)
		  Y)                            (* More than one expression 
                                                between two forwords.)
	      (GO BREAK)))
          [COND
	    ((NLISTP (CAR X1))
	      (COND
		([AND (NEQ (CAAR PTRS)
			   (QUOTE FROM))
		      (NEQ (CAAR PTRS)
			   (QUOTE IN/ON))
		      (NEQ (CAAR PTRS)
			   (QUOTE TO))
		      (SETQ Z (CLISPFUNCTION? X1 (QUOTE NOTVAR]
                                                (* E.G. DO PRINT, BY SUB1, etc.)
		  [COND
		    ((NULL (SETQ TEM (OR FIRSTI.V. I.V.)))
		      (CLISPFORERR X NIL (QUOTE WHAT)))
		    ((EQ (COND
			   ((EQ X FOROPR)
			     TEM)
			   (T (SETQ TEM I.V.)))
			 (QUOTE $$TEM))

          (* In the case that an i.v. was supplied, make the change 
          permanent. For $$TEM, undo it later.)


		      (SETQ UNDOLST (CONS (CONS X1 (CONS (CAR X1)
							 (CDR X1)))
					  UNDOLST]
		  (/RPLNODE X1 (LIST Z TEM)
			    (CDR X1)))
		(T (DWIMIFY2 X1 X X1 T T)))
	      (SETQ Z (CAR X1))
	      (GO OUT))
	    ((OR (EQ (CAAR X1)
		     (QUOTE OLD))
		 (EQ (CAAR X1)
		     (QUOTE old)))
	      (OR MAKEPROGFLG (SETQ MAKEPROGFLG T))
	      (DWIMIFY2 (CDAR X1)
			(CAR X1)
			T)
	      (SETQ Z (CAR X1))
	      (GO OUT))
	    (T (DWIMIFY1 (CAR X1)
			 NIL T)
	       (SETQ Z (CAR X1))
	       (COND
		 ([AND (LISTP (CAAR X1))
		       (NOT (FNTYP (CAAR X1]
		   (SETQ LSTFLG T)
		   (SETQ Z (CAR X1))
		   (GO A))
		 (T (GO OUT]
      BREAK
          (COND
	    (Y (/RPLNODE (SETQ Z (NLEFT X 1 Y))
			 (CAR Z)
			 NIL)))                 (* Breaks the list justbefore 
                                                the next operator.)
          (/RPLNODE X1 (SETQ Z (CONS (CAR X1)
				     (CDR X1)))
		    Y)

          (* Puts parentheses in -
          E.g. For X in FOO Y do -- becomes for X in 
          (FOO Y) do necessary in order to call DWIMIFY.
          Maybe should give DWIMIFY an rgument like stoptail?)



          (* Done this way instead of changing CDR X because CDR of 
          first PTR is not EQ to the entry in the history list.)


          [DWIMIFY2 Z Z T (COND
		      (FOROPR (QUOTE IF))
		      (T (QUOTE FOR]
      A   (COND
	    ((NULL (CDR Z))

          (* Because DWIMIFY2 was called with FORMSFLG T, this came 
          out as a list of forms, but there was only one form.
          E.g. X_ (FOO) became ((SETQ X (FOO))).)


	      (/RPLNODE (CDR X)
			(CAR Z)
			Y)
	      (SETQ Z (CAR Z))
	      (GO OUT)))
      B   [SELECTQ (CAAR PTRS)
		   ((FOROPR FIRST FINALLY EACHTIME)
                                                (* More than one form permitted 
                                                in operator -
                                                means implicit progn.)
		     (CLISPFOR4 Z)
		     (SETQ UNDOLST (CONS (CONS X (CONS (CAR X)
						       (CDR X)))
					 UNDOLST))
		     (/RPLNODE X (APPEND Z)
			       (CDR X))

          (* Smashes the operatr itself with the body of i.s.
          so that when we get back to clispfor0, can distinguish the 
          implicit progn case from others.
          The setting of UNDOLST is to enable restoration.)


		     [AND (NULL LSTFLG)
			  (/RPLNODE (CDR X)
				    (CAR Z)
				    (NCONC (CDR Z)
					   (CDDR X]
                                                (* Takes parentheses back out.)
		     (RETURN))
		   (COND
		     (LSTFLG (CLISPFORERR X))
		     (FOROPR (CLISPFORERR FOROPR X1))
		     (T 

          (* E.g. For X in Y print Z --. When we get grouping in 
          DWIMIFY, will b able to hndle for X in CDR Y print Z)



          (* This really should be taken care of in DWIMIFY2 -
          I.e. (Y prinnt Z))


			(/RPLNODE X1 (CAR Z)
				  (/NCONC (CDR Z)
					  Y))
			(SETQQ FOROPR1 do)
			(SETQ FOROPR (/ATTACH (QUOTE DO)
					      (CDR X1)))
			(RPLACD PTRS (CONS (LIST (QUOTE FOROPR)
						 FOROPR)
					   (CDR PTRS)))
			(SETQ Z (CAR Z]
      OUT (AND (LISTP Z)
	       (CLISPFOR4 Z))
          (RETURN])

(CLISPFOR2
  [LAMBDA (LST FLG)
    (PROG (TEM)
          [MAP (SETQ LST (DREVERSE LST))
	       (FUNCTION (LAMBDA (X)
		   (SETQ TEM (CADADR (CAR X)))
                                                (* The actual expression.)
		   (RPLACA X (SELECTQ (CAAR X)
				      [WHEN (COND
					      (FLG 

          (* When FLG is true, we are computing a condition forDOING 
          it, and when FLG=NIL, for not doing it, hence difference in 
          sign.)


						   TEM)
					      (T (CLISPFORNEG TEM]
				      (UNLESS (COND
						(FLG (CLISPFORNEG TEM))
						(T TEM)))
				      (WHILE (CLISPFORNEG TEM))
				      (UNTIL (COND
					       ((NUMBERP TEM)
						 (LIST (CLISPLOOKUP
							 (QUOTE GT)
							 I.V.)
						       I.V. TEM))
					       (T TEM)))
				      (CAR X]
          (RETURN LST])

(CLISPFOR3
  [LAMBDA (LST)

          (* Used to process FINALLY, EACHTIME, and FIRST lists.
          LST is a list of form (FINALLY . tail))


    (PROG (TEM)
          (RETURN (MAPCONC (DREVERSE LST)
			   (FUNCTION (LAMBDA (X)
			       (SETQ TEM (CADR X))
			       (OR (LISTP (CAR TEM))
				   (LIST (CADR TEM])

(CLISPFORVARS
  [LAMBDA (PTRS)

          (* Does for FOR and BIND what CLISPFOR1 does for the rest of 
          the ptrs. LST is either a (FOR --) or 
          (BIND --) entry from PTRS. CLISPFOR3 handles the following 
          pathological cases. The variables may be spread out, or 
          listed, they may involve assignments, either spread out or 
          listed, and they may be terminated by a form or function in 
          the case that there is no FOROPR.
          E.g. FOR X Y Z (PRINT X), FOR (X Y Z) PRINT X, FOR X Y _ T Z 
          PRINTT X, FOR (X (Y_T) Z) (PRINT X) etc.)


    (PROG (TEM OLDFLG L L1 VARLST IV (CLISPCONTEXT (QUOTE FOR/BIND)))
                                                (* clispcontext tells CLISPATOM2
                                                not to try spelling correction 
                                                on the variable name.)
          (SETQ L1 (CADADR PTRS))
          (SETQ L (SETQ LST (CDADAR PTRS)))
      LP  [COND
            ((EQ L L1)
              (GO NX))
            [(LITATOM (CAR L))
              (COND
                ((STRPOS (QUOTE "_")
                         (CAR L))
                  (SETQ L (DWIMIFY2 L LST NIL T T))

          (* The SETQ is because in the case the _ is a separate atom, 
          the DWIMIFY2 will return the tail before L.)


                  ]
            ((NLISTP (CAR L))
              (CLISPFORERR L))
            (T (SELECTQ (CAAR L)
                        ((SETQQ SAVESETQQ)

          (* SAVESETQ and SAVESETQQ can occur on typein if the user 
          should happen to DW a portion of the I.s.)


                          )
                        ((SETQ SAVESETQ)
                          (DWIMIFY2 (CDDAR L)
                                    (CAR L)
                                    T))
                        (COND
                          [(STRPOS (QUOTE "_")
                                   (CAR L))

          (* The second argument to CLISPFORVARS1 corresonds to 
          FORMSFLG in the call to DWIMIFY2, e.g. FOR X 
          (Y_T) want FORMSFLG to be NIL. but FOR 
          (X_T Y) want it to be T.)


                            (CLISPFORVARS1 (CAR L)
                                           (EQ L1 (CDR LST]
                          ((AND (EQ L LST)
                                (EQ (CDR L)
                                    L1))        (* Says this is the first 
                                                argument.)
                            (CLISPFORVARS1 (CAR L)
                                           T))
                          (FOROPR (CLISPFORERR L FOROPR))
                          (T 

          (* Necessary because L may not really correspnd to ssructure 
          in the original statement, because of ldiff.)


                             (GO ADDDO]
          (SETQ L (CDR L))
          (GO LP)
      NX  

          (* The area between LST and L now corresponds to the 
          (dwimified) variables. They may appears as a segment or as a 
          list.)


          (SETQ L (COND
              ([AND (EQ (CDR LST)
                        L)
                    (LISTP (CAR LST))
                    (NOT (FMEMB (CAAR LST)
                                (QUOTE (SETQ SETQQ OLD old SAVESETQ SAVESETQQ]
                (SETQ L1 NIL)
                (CAR LST))
              (T LST)))

          (* L now corresponds to the beginning of the list of 
          variables, L1 to its end. VARLST will be used to assemble 
          the vlue.)


      LP1 [COND
            ((EQ L L1)
              (AND IV (NEQ (CAAR PTRS)
                           (QUOTE BIND))
                   (NULL I.V.)
                   (SETQ FIRSTI.V. (SETQ I.V. IV)))

          (* IV is the first variable encountered in the variable list 
          (may be OLD vriable))


              (RETURN (DREVERSE VARLST)))
            ((OR (EQ (CAR L)
                     (QUOTE OLD))
                 (EQ (CAR L)
                     (QUOTE old)))
              (SETQ OLDFLG T)
              (SETQ MAKEPROGFLG T)
              (SETQ L (CDR L))
              (SETQ TEM (CAR L)))
            ([AND (LISTP (CAR L))
                  (OR (EQ (CAAR L)
                          (QUOTE OLD))
                      (EQ (CAAR L)
                          (QUOTE old]
              (SETQ OLDFLG T)
              (SETQ MAKEPROGFLG T)
              (SETQ TEM (CADAR L)))
            (T (SETQ OLDFLG NIL)
               (SETQ TEM (CAR L]
          [COND
            [(AND TEM (LITATOM TEM))
              (SETQ VARS (CONS TEM VARS))
              [COND
                ((NULL IV)
                  (SETQ IV TEM)
                  (AND (EQ (CAAR PTRS)
                           (QUOTE AS))
                       (FRPLACD (CDAR PTRS)
                                (LIST IV]
              (AND (NULL OLDFLG)
                   (SETQ VARLST (CONS TEM VARLST]
            [(SELECTQ (CAR TEM)
                      ((SETQ SAVESETQ)
                        T)
                      ((SETQQ SAVESETQQ)
                        (FRPLACA TEM (QUOTE SETQ))
                        (FRPLACA (CDDR TEM)
                                 (LIST (QUOTE QUOTE)
                                       (CADDR TEM)))
                        T)
                      NIL)
              (SETQ MAKEPROGFLG T)              (* Says the expression must 
                                                translate into an open prog.)
              (SETQ VARS (CONS (CADR TEM)
                               VARS))
              [COND
                ((NULL IV)
                  (SETQ IV (CADR TEM))
                  (SETQ IVINITFLG T)
                  (AND (EQ (CAAR PTRS)
                           (QUOTE AS))
                       (FRPLACD (CDAR PTRS)
                                (LIST IV IVINITFLG]
              [COND
                (OLDFLG (SETQ INITVARS (CONS TEM INITVARS)))
                (T (SETQ VARLST (CONS (CDR TEM)
                                      VARLST]
              (FRPLACA L (COND
                         [(ATOM (CADDR TEM))
                           (PACK (LIST (CADR TEM)
                                       (QUOTE _)
                                       (CADDR TEM]
                         (T (LIST (PACK (LIST (CADR TEM)
                                              (QUOTE _)))
                                  (CADDR TEM]
            (T (CLISPFORERR (LIST TEM]
          (SETQ L (CDR L))
          (GO LP1)
      ADDDO
          (/RPLNODE L (QUOTE DO)
                    (CONS (CAR L)
                          (CDR L)))
          (SETQ L1 L)
          (FRPLACD PTRS (CONS (LIST (QUOTE FOROPR)
                                    (SETQ FOROPR L))
                              (CDR PTRS)))
          (GO NX])

(CLISPFORVARS1
  [LAMBDA (L FLG)
    (PROG (TAIL)
          (SETQ TAIL L)
      LP  [COND
            ((NULL TAIL)
              (RETURN))
            ((STRPOS (QUOTE "_")
                     (CAR TAIL))
              (COND
                ((LITATOM (CAR TAIL))
                  (DWIMIFY2 TAIL L NIL FLG T))
                (T (CLISPFORVARS1 (CAR TAIL]
          (SETQ TAIL (CDR TAIL))
          (GO LP])

(CLISPFOR4
  [LAMBDA (X)
    (SELECTQ (CAR X)
	     ((GO RETURN)
	       (SETQ TERMINATEFLG T)
	       (SETQ MAKEPROGFLG T))
	     (PROG NIL)
	     (SOME X (FUNCTION (LAMBDA (X)
		       (AND (LISTP X)
			    (CLISPFOR4 X])

(CLISPFORNEG
  [LAMBDA (X)
    (SELECTQ (AND (LISTP X)
		  (CAR X))
	     ((NOT NULL)
	       (CADR X))
	     (NEQ (CONS (QUOTE EQ)
			(CDR X)))
	     (EQ (CONS (QUOTE NEQ)
		       (CDR X)))
	     (NLISTP (CONS (QUOTE LISTP)
			   (CDR X)))
	     (LISTP (CONS (QUOTE NLISTP)
			  (CDR X)))
	     (LIST (QUOTE NOT)
		   X])

(CLISPFORF/L
  [LAMBDA (BODY VAR)
    (PROG NIL
          (LIST (QUOTE FUNCTION)
                (COND
                  ((AND (EQUAL VAR (CDAR BODY))
                        (NULL (CDR BODY)))
                    (CAAR BODY))
                  (T (CONS (QUOTE LAMBDA)
                           (CONS VAR BODY])

(CLISPFORERR
  [LAMBDA (X Y TYPE)
    (PROG (TEM)
          (AND (FIXPRINTIN FAULTFN)
	       (SPACES 1 T))
          (LISPXPRIN1 (QUOTE "error in iterative statement")
		      T)
          (AND
	    TYPE
	    (LISPXPRINT (QUOTE ,)
			T)
	    (LISPXPRIN1
	      (SELECTQ
		TYPE
		(BOTH (QUOTE "can't use both of these operators together"))
		(TWICE (QUOTE "operator appears twice"))
		(MISSING (QUOTE "missing operand"))
		(WHAT (LISPXPRIN1 (CADR X)
				  T)
		      (QUOTE " what ?  (no i.v. specified)"))
		NIL)
	      T))
          (LISPXPRINT (QUOTE :)
		      T)
          (COND
	    ((OR (AND X (NLISTP X))
		 (AND Y (NLISTP Y)))
	      (LISPXPRIN2 X T T)
	      (AND Y (LISPXPRIN2 Y T T))
	      (ERROR!))
	    ((TAILP X Y)
	      (SETQ TEM X)
	      (SETQ X Y)
	      (SETQ Y TEM)))
          (CLISPFORERR1 X Y)
          (COND
	    (Y (CLISPFORERR1 Y)))
          (TERPRI T)
          (ERROR!])

(CLISPFORERR1
  [LAMBDA (X Y)
    (PROG (TEM)
          (COND
	    ((NEQ X I.S.)
	      (LISPXPRIN1 (QUOTE " ... ")
			  T)))
          (SETQ TEM (OR [CADADR (SOME FORPTRS (FUNCTION (LAMBDA (Z)
					  (TAILP (CADR Z)
						 X]
			Y))
      LP  (LISPXPRIN2 (RETDWIM2 (CAR X)
				NIL 3)
		      T T)
          (COND
	    ((AND (SETQ X (CDR X))
		  (NEQ X TEM))
	      (LISPXSPACES 1 T)
	      (GO LP])

(CLISPRESPELL
  [LAMBDA (TAIL WORDS FLG)

          (* CLISPRESPELL essentially asks is it possible to inerpret 
          (CAR TAIL) as one of WORDS. It first checks to make sure 
          (CAR TAIL) isnt already something else-- e.g. a function, 
          variable, member of NOFIXFNSLST 
          (which is the same as being a function) etc.)


    (AND (NULL NOSPELLFLG)
	 TAIL
	 (LITATOM (CAR TAIL))
	 (NOT (FGETD (CAR TAIL)))
	 (NULL (GETP (CAR TAIL)
		     (QUOTE EXPR)))
	 (NULL (GETP (CAR TAIL)
		     (QUOTE CLISPWORD)))
	 (CLISPNOTVARP (CAR TAIL))
	 (CAR (NLSETQ (FIXSPELL (CAR TAIL)
				70 WORDS FLG (AND (NEQ FLG (QUOTE NO-MESSAGE))
						  TAIL)
				NIL NIL (DUNPACK (CAR TAIL)
						 SKORLST3])

(COMPILEUSERFN
  [LAMBDA (X Y)
    (COND
      [(LISTP (CAR Y))
        (AND [SETQ X (OR (AND CLISPARRAY (GETHASH (CAR Y)
                                                  CLISPARRAY))
                         (AND CLISPTRANFLG (EQ (CAAR Y)
                                               CLISPTRANFLG)
                              (CADAR Y]
             (CONS X (CDR Y]
      ((AND CLISPARRAY (GETHASH Y CLISPARRAY)))
      ((NLISTP (GETP (CAR Y)
                     (QUOTE CLISPWORD)))
        NIL)
      (T (RESETVAR FILEPKGFLG NIL (DWIMIFY0 Y FN (UNION ARGS OTHERVARS)
                                            DEF))
         (COND
           ((AND CLISPARRAY (GETHASH Y CLISPARRAY)))
           ((NULL (GETP (CAR Y)
                        (QUOTE CLISPWORD)))     (* IF's are transled directly 
                                                into COND's, and dont use 
                                                hashing.)
             Y)
           (T (ERROR (QUOTE "unable to dwimify")
                     Y])

(CLISPTRAN
  [LAMBDA (X TRAN)
    (COND
      ((OR CLISPARRAY (COND
             (#CLISPARRAY (SETQ CLISPARRAY (LIST (HARRAY #CLISPARRAY)))
                          (SETQ #CLISPARRAY NIL)

          (* Latter so user can turn clisphashing on and off by simply 
          reseting CLISPARRAY.)


                          T)))                  (* Otherwise use CLISP%  
                                                translation.)
        (/PUTHASH X TRAN CLISPARRAY))
      (TRAN                                     (* Can be called erase a 
                                                translation.)
            (/RPLNODE X CLISPTRANFLG (CONS TRAN (CONS (CAR X)
                                                      (CDR X])

(I.S.TYPE
  [LAMBDA (NAME FORM INIT VAL OTHERS)

          (* E.g. NAME=SUM, FORM= (SETQ $$VAL 
          ($$VAL + BODY)), INIT=0, and VAL= $$VAL OTHERS permits 
          adding arbitrary i.s. operators, intended mainly to specify 
          BIND's, FIRST's, FINALLY's, etc. since neither the i.v.
          nor the body can be referred to in OTHERS.)


    (PROG ((X (L-CASE NAME))
           TEM)
          [COND
            ((ATOM FORM)                        (* Synonym)
              (/PUT NAME (QUOTE CLISPWORD)
                    (SETQ TEM (LIST (QUOTE FORWORD)
                                    X FORM)))
              (/PUT X (QUOTE CLISPWORD)
                    TEM))
            (T (/PUT NAME (QUOTE CLISPWORD)
                     (SETQ TEM (CONS (QUOTE FORWORD)
                                     X)))
               (/PUT X (QUOTE CLISPWORD)
                     TEM)
               (/PUT X (QUOTE I.S.TYPE)
                     (NLIST FORM INIT VAL OTHERS]
          (AND (NOT (FMEMB NAME CLISPFORWORDSPLST))
               (/NCONC1 CLISPFORWORDSPLST NAME)
               (/NCONC I.S.OPRLST (LIST NAME X)))
          (RETURN NAME])
)
  (RPAQ !)
  (RPAQ !!)
  (RPAQQ COMPILEUSERFN COMPILEUSERFN)
  (RPAQ #CLISPARRAY 250)
  (RPAQ RECORDHASHFLG T)
  (RPAQ CLISPI.SGAG)
  [RPAQQ DWIMBLOCKS
	 ((DWIMBLOCK WTFIX WTFIX0 WTFIX1 FIXLISPX/ RETDWIM RETDWIM0 RETDWIM1 RETEDIT 
		     FIX89TYPEIN FIXLAMBDA FIXAPPLY FIXAPPLY1 FIXATOM FIXATOM1 FIXCONTINUE 
		     FIXCONTINUE1 FINDATOM CLISPATOM GETVARS FIX89 FIXPRINTIN FIX89A FIX89B 
		     FIXT CLISPFUNCTION? CLISPNOTVARP CLISPELL HELPFIX HELPFIX1 HELPFIX2 FINDFN 
		     GENSYM? MISSPELLED? FIXSPELL FIXSPELL1 FIXSPELL2 MOVETOP CHOOZ SKOR0 SKOR 
		     DWIMIFYFNS DWIMIFY DWIMIFY0 DWIMIFY1 DWIMIFY1? DWMFY1 CHECKTRAN DWIMIFY1A 
		     DWIMIFY1B DWIMIFY2 DWIMIFY2? DWMFY2 DWIMIFY2A CLISPATOM0 CLISPATOM1 
		     CLRPLNODE STOPSCAN? CLUNARYMINUS? CLISPATOM1A CLISPATOM1B CL89CHECK 
		     CLISPATOM2 CLISPLOOKUP GETLOCALDEC CLISPATOM2A CLISPATOM2B CLISPATOM2C 
		     CLISPATOM2D CLISPERROR CLISPCAR/CDR CLISPCAR/CDR1 SHRIEKER CLISPIF 
		     CLISPIF0 CLISPIF1 CLISPIF2 CLISPFOR CLISPFOR0 CLISPFOR1 CLISPFOR2 
		     CLISPFOR3 CLISPFORVARS CLISPFORVARS1 CLISPFOR4 CLISPFORNEG CLISPFORF/L 
		     CLISPFORERR CLISPFORERR1 CLISPRESPELL DWIMUNSAVEDEF
		     (SPECVARS FAULTX FAULTARGS FAULTAPPLYFLG FAULTFN EXPR VARS TAIL PARENT 
			       FIXTN SPLIT89FLG HELPFIXTAIL HELPFIXFLG TYPE-IN? CLISPCHANGES 
			       DWIMIFYFLG DWIMIFYING CLISPRESPELL CLISPCHANGE FN FAULTPOS)
		     (ENTRIES WTFIX HELPFIX HELPFIX1 MISSPELLED? FIXSPELL FIXSPELL1 CHOOZ SKOR0 
			      DWIMIFYFNS DWIMIFY DWIMIFY0 DWIMIFY1A DWIMIFY1B CLISPERROR FINDFN 
			      GETLOCALDEC DWIMUNSAVEDEF)
		     (GLOBALVARS OKREEVALST FUNNYATOMLST FIXT NOSPELLFLG FIXCALLS DWIMIFYFIXES 
				 ERRORCALLS TYPEINFIXES PROGFIXES FIXTIME SUCCFIXES1 SUCCFIXES2 
				 SPELLSTATS SPELLSTATS1 RUNONSTATS VETOSTATS CLISPSTATS 
				 INFIXSTATS IFSTATS I.S.STATS UNDOSTATS SKIPTHIS #CLISPARRAY 
				 GLOBALVARS LAMBDASPLST CLISPI.S.GAG)
		     (NOLINKFNS DWIMUSERFN MAKEMATCH RECCOMPOSE0 CLISPRECORD)
		     (LOCALFREEVARS 89CHANGE 89FLG ANGCNT AS ATTEMPTFLG BACKUPFLG BREAKFLG 
				    BRKEXP BRKFN BRKTYPE BROADSCOPE CLISPCHANGE CLISPCHANGES 
				    CLISPCONTEXT CLISPERTYPE CLISPRESPELL CLTYP CURRTAIL 
				    DWIMIFYCHANGE DWIMIFY0CHANGE DWIMIFYFLG DWIMIFYING ENDTAIL 
				    EXPR FAULTAPPLYFLG FAULTARGS FAULTFN FAULTPOS FAULTX 
				    FAULTXX FIRSTI.V. FIXCLK FORMSFLG FOROPR FOROPR1 FORPTRS 
				    FROM HISTENTRY I.S. I.V. IN/ON INITVARS IVINITFLG LASTPOS 
				    LISPFN LST MAKEPROGFLG NCONC1LKUP NCONCLKUP NCTWORD NCXWORD 
				    NEGFLG NEWTAIL NEXTAIL SUBPARENT NOFIX89 NOSAVEFLG ONEFLG 
				    ONLYSPELLFLG PARENT SIDES TAIL TENTATIVE TERMINATEFLG TYP 
				    TYPE-IN? UNDOLST UNDOSIDE UNDOSIDE0 VAR1 VAR2 VARS WORKFLAG)
		     (BLKLIBRARY GETP /RPLNODE NCONC1 NLEFT LISPXWATCH))
	  (ADDSPELLBLOCK ADDSPELL ADDSPELL1 (ENTRIES ADDSPELL ADDSPELL1)
			 (BLKLIBRARY /RPLNODE))
	  (NEWFAULT1BLOCK NEWFAULT1 CHECKTRAN (ENTRIES NEWFAULT1)
			  (GLOBALVARS #CLISPARRAY)
			  (NOLINKFNS WTFIX))
	  (NIL DWIMESS DWIMREADC (GLOBALVARS DWIMTTBL)
	       RETDWIM2 RETDWIM3 FIXPRINTIN WTFIXLOADEF (LINKFNS . T)
	       (NOLINKFNS WTFIX)
	       CLISPTRAN
	       (GLOBALVARS #CLISPARRAY]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
  (BLOCK: DWIMBLOCK WTFIX WTFIX0 WTFIX1 FIXLISPX/ RETDWIM RETDWIM0 RETDWIM1 RETEDIT FIX89TYPEIN 
	  FIXLAMBDA FIXAPPLY FIXAPPLY1 FIXATOM FIXATOM1 FIXCONTINUE FIXCONTINUE1 FINDATOM 
	  CLISPATOM GETVARS FIX89 FIXPRINTIN FIX89A FIX89B FIXT CLISPFUNCTION? CLISPNOTVARP 
	  CLISPELL HELPFIX HELPFIX1 HELPFIX2 FINDFN GENSYM? MISSPELLED? FIXSPELL FIXSPELL1 
	  FIXSPELL2 MOVETOP CHOOZ SKOR0 SKOR DWIMIFYFNS DWIMIFY DWIMIFY0 DWIMIFY1 DWIMIFY1? 
	  DWMFY1 CHECKTRAN DWIMIFY1A DWIMIFY1B DWIMIFY2 DWIMIFY2? DWMFY2 DWIMIFY2A CLISPATOM0 
	  CLISPATOM1 CLRPLNODE STOPSCAN? CLUNARYMINUS? CLISPATOM1A CLISPATOM1B CL89CHECK 
	  CLISPATOM2 CLISPLOOKUP GETLOCALDEC CLISPATOM2A CLISPATOM2B CLISPATOM2C CLISPATOM2D 
	  CLISPERROR CLISPCAR/CDR CLISPCAR/CDR1 SHRIEKER CLISPIF CLISPIF0 CLISPIF1 CLISPIF2 
	  CLISPFOR CLISPFOR0 CLISPFOR1 CLISPFOR2 CLISPFOR3 CLISPFORVARS CLISPFORVARS1 CLISPFOR4 
	  CLISPFORNEG CLISPFORF/L CLISPFORERR CLISPFORERR1 CLISPRESPELL DWIMUNSAVEDEF
	  (SPECVARS FAULTX FAULTARGS FAULTAPPLYFLG FAULTFN EXPR VARS TAIL PARENT FIXTN 
		    SPLIT89FLG HELPFIXTAIL HELPFIXFLG TYPE-IN? CLISPCHANGES DWIMIFYFLG 
		    DWIMIFYING CLISPRESPELL CLISPCHANGE FN FAULTPOS)
	  (ENTRIES WTFIX HELPFIX HELPFIX1 MISSPELLED? FIXSPELL FIXSPELL1 CHOOZ SKOR0 DWIMIFYFNS 
		   DWIMIFY DWIMIFY0 DWIMIFY1A DWIMIFY1B CLISPERROR FINDFN GETLOCALDEC 
		   DWIMUNSAVEDEF)
	  (GLOBALVARS OKREEVALST FUNNYATOMLST FIXT NOSPELLFLG FIXCALLS DWIMIFYFIXES ERRORCALLS 
		      TYPEINFIXES PROGFIXES FIXTIME SUCCFIXES1 SUCCFIXES2 SPELLSTATS 
		      SPELLSTATS1 RUNONSTATS VETOSTATS CLISPSTATS INFIXSTATS IFSTATS I.S.STATS 
		      UNDOSTATS SKIPTHIS #CLISPARRAY GLOBALVARS LAMBDASPLST CLISPI.S.GAG)
	  (NOLINKFNS DWIMUSERFN MAKEMATCH RECCOMPOSE0 CLISPRECORD)
	  (LOCALFREEVARS 89CHANGE 89FLG ANGCNT AS ATTEMPTFLG BACKUPFLG BREAKFLG BRKEXP BRKFN 
			 BRKTYPE BROADSCOPE CLISPCHANGE CLISPCHANGES CLISPCONTEXT CLISPERTYPE 
			 CLISPRESPELL CLTYP CURRTAIL DWIMIFYCHANGE DWIMIFY0CHANGE DWIMIFYFLG 
			 DWIMIFYING ENDTAIL EXPR FAULTAPPLYFLG FAULTARGS FAULTFN FAULTPOS 
			 FAULTX FAULTXX FIRSTI.V. FIXCLK FORMSFLG FOROPR FOROPR1 FORPTRS FROM 
			 HISTENTRY I.S. I.V. IN/ON INITVARS IVINITFLG LASTPOS LISPFN LST 
			 MAKEPROGFLG NCONC1LKUP NCONCLKUP NCTWORD NCXWORD NEGFLG NEWTAIL 
			 NEXTAIL SUBPARENT NOFIX89 NOSAVEFLG ONEFLG ONLYSPELLFLG PARENT SIDES 
			 TAIL TENTATIVE TERMINATEFLG TYP TYPE-IN? UNDOLST UNDOSIDE UNDOSIDE0 
			 VAR1 VAR2 VARS WORKFLAG)
	  (BLKLIBRARY GETP /RPLNODE NCONC1 NLEFT LISPXWATCH))
  (BLOCK: ADDSPELLBLOCK ADDSPELL ADDSPELL1 (ENTRIES ADDSPELL ADDSPELL1)
	  (BLKLIBRARY /RPLNODE))
  (BLOCK: NEWFAULT1BLOCK NEWFAULT1 CHECKTRAN (ENTRIES NEWFAULT1)
	  (GLOBALVARS #CLISPARRAY)
	  (NOLINKFNS WTFIX))
  (BLOCK: NIL DWIMESS DWIMREADC (GLOBALVARS DWIMTTBL)
	  RETDWIM2 RETDWIM3 FIXPRINTIN WTFIXLOADEF (LINKFNS . T)
	  (NOLINKFNS WTFIX)
	  CLISPTRAN
	  (GLOBALVARS #CLISPARRAY))
]
(DEFLIST(QUOTE(
  (CLISP%  (X (CAR X)))
))(QUOTE MACRO))
(DEFLIST(QUOTE(
  (DWIMIFY (DWIM WTFIX CLISP DWIMIFY))
))(QUOTE FILEGROUP))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA DWIMIFYFNS)
  (ADDTOVAR NLAML)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (963 84242 (DWIMIFYFNS 975 . 1653) (DWIMIFY 1657 . 2641) (DWIMIFY0 2645 . 7561)
(DWIMIFY1 7565 . 7634) (DWIMIFY1? 7638 . 8090) (DWMFY1 8094 . 14448) (DWIMIFY1A 14452 . 14905)
(DWIMIFY1B 14909 . 15798) (DWIMIFY2 15802 . 15890) (DWIMIFY2? 15894 . 16373) (DWMFY2 16377
. 25380) (DWIMIFY2A 25384 . 26160) (SHRIEKER 26164 . 37931) (CLISPIF 37935 . 39492) (CLISPIF0
39496 . 42735) (CLISPIF1 42739 . 43252) (CLISPIF2 43256 . 44326) (CLISPFOR 44330 . 45570)
(CLISPFOR0 45574 . 64755) (CLISPFOR1 64759 . 69659) (CLISPFOR2 69663 . 70500) (CLISPFOR3 70504
. 70833) (CLISPFORVARS 70837 . 77817) (CLISPFORVARS1 77821 . 78241) (CLISPFOR4 78245 . 78477)
(CLISPFORNEG 78481 . 78819) (CLISPFORF/L 78823 . 79144) (CLISPFORERR 79148 . 80089) (
CLISPFORERR1 80093 . 80510) (CLISPRESPELL 80514 . 81249) (COMPILEUSERFN 81253 . 82302) (
CLISPTRAN 82306 . 83053) (I.S.TYPE 83057 . 84239)))))
STOP
