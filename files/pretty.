(FILECREATED "20-OCT-74 03:53:53" PRETTY.;42 71384  

     changes to:  PRETTYBLOCKS PRETTYDEF

     previous date: "17-OCT-74 15:29:08" PRETTY.;41)


  (LISPXPRINT (QUOTE PRETTYCOMS)
	      T T)
  [RPAQQ PRETTYCOMS
	 ((FNS * PRETTYFNS)
	  (VARS (BRLST)
		(PRETTYMACROS)
		(COMMENTFLG (QUOTE *))
		(**COMMENT**FLG (QUOTE "  **COMMENT**  "))
		(PRETTYFLG T)
		#RPARS SYSPROPS (CHANGEDFNSLST)
		(CHANGEDVARSLST)
		[PRETTYTYPELST (QUOTE ((CHANGEDFNSLST FNS "functions")
				       (CHANGEDVARSLST VARS]
		(CLISPIFYPRETTYFLG)
		(PRETTYTRANFLG)
		(PRETTYCOMSPLST (QUOTE (VARS PROP IFPROP COMPROP COMPROP* P DECLARE PD ADDVARS 
					     USERMACROS FNS ARRAY E COMS ADVISE ADVICE BLOCKS)))
		(FONTCHANGEFLG)
		(CHAR37 (CHARACTER 37))
		(PRETTYTABFLG T)
		(DECLARECOMLST (QUOTE (DOCOPY DOEVAL@COMPILE DOEVAL@LOAD DONTCOPY 
					      DONTEVAL@COMPILE DONTEVAL@LOAD EVAL@COMPILE 
					      EVAL@LOAD COPY COPY COMPILERVARS)))
		(USEMAPFLG T)
		(NEWFILE?USERFN)
		(WIDEPAPERFLG)
		(AVERAGEVARLENGTH 4)
		(AVERAGEFNLENGTH 5)
		(#CAREFULCOLUMNS 0))
	  (P (WIDEPAPER))
	  (BLOCKS * PRETTYBLOCKS)
	  (PROP FILEGROUP PRETTY)
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
		    (ADDVARS (NLAMA PPT PP* PP PUTPROPS)
			     (NLAML PRETTYDEF0]
  (RPAQQ PRETTYFNS
	 (PRETTYDEF PRETTYDEF0 PRETTYDEF1 PRINTDATE PRINTDATE1 PRINTFNS PRETTYCOM PRETTYVAR 
		    PRETTYCOM1 ENDFILE MAKEDEFLIST PUTPROPS PP PP* PPT PRETTYPRINT PRETTYPRINT1 
		    PRETTYPRINT2 PRINTDEF1 PRINTDEF SUPERPRINT RPARS SUBPRINT SUBPRINT1 
		    SUBPRINT2 PRINTPROG ENDLINE TAB READARRAY FITP FITP1 FITP2 WIDEPAPER 
		    NEWFILE? UPDATEFILES UPDATEFILES1 NEWFILE0 NEWFILE1 NEWFILE1A NEWFILE2 
		    WHEREIS FILECOMS FILEFNSLST GETFILEMAP))
(DEFINEQ

(PRETTYDEF
  [LAMBDA (PRTTYFNS PRTTYFILE PRTTYCOMS REPRINTFNS SOURCEFILE CHANGES)
    (PROG ((PRTYX (OUTPUT))
	   PRTYZ PRTTYTEM PRETTYCOMSLST PRTTYSPELLFLG OLDFILEMAP (NEWFILEMAP
	     (AND BUILDMAPFLG (LIST NIL)))
	   MAPADR NLAMALST NLAMLST LAM?LST FILEDATES (RDTBL (GETREADTABLE)))

          (* NEWFILEMAP corresponds to the map being built for the file being written.
          OLDFILEMAP corresponds to the map that exists for SOURCEFILE, if any.)


          (COND
	    ((LISTP PRTTYFILE)
	      (SETQ PRTTYFILE (CAR PRTTYFILE))
	      (SETQ PRTYZ T)))
          [COND
	    ((OR (EQ SOURCEFILE T)
		 (AND REPRINTFNS (NULL SOURCEFILE)))

          (* SOURCEFILE plays the role of CFILE for recompiling.
          It permits PRETTYPRINT to obtain the definitions from the file withou having 
          to reprettyprint them, or even having them loaded into core.
          T (or NIL if REPRINTFNS is specified) is the same as PRETTYFILE.
          -
          REPRINTFNS specifies those functions to be printed anew.
          REPRINTFNS=T means reprint all EXPRS, a la recompile.
          For example, if you have an entire file loaded in, but only change a few 
          functions, using this option can speed up dumping the file by a factor of 
          two. If REPRINTFNS=ALL, all functions that contain in core exprs, whether on 
          function defiition cell or property lists, are reprinted.
          REPRINTFNS can also be a list. MAKEFILE uses this for the REMAKE option by 
          specifying as REPRINTFNS the list CHANGES.
          In any case, if the function does not contain an in core defnition, 
          prettyprint will try to find one on the file.
          i.e. act as though REPRINTFNS were NIL.)


	      (SETQ SOURCEFILE (NAMEFIELD PRTTYFILE T]
          [COND
	    (SOURCEFILE (COND
			  [(XNLSETQ (INFILE SOURCEFILE)
				    NOBREAK)    (* INFILE is called in order that 'correction' 
                                                take place.)
			    (SETQ SOURCEFILE (INPUT))
			    (COND
			      ((EQ REPRINTFNS (QUOTE EXPRS))
				(SETQ REPRINTFNS T))
			      ((EQ REPRINTFNS (QUOTE CHANGES))
				(SETQ REPRINTFNS CHANGES)))
			    (COND
			      [(NULL (SETQ OLDFILEMAP (GETFILEMAP SOURCEFILE (NAMEFIELD 
										 SOURCEFILE T]
			      ((NULL (CAR OLDFILEMAP))
                                                (* complete map.)
				)
			      ((LISTP (CAR OLDFILEMAP))

          (* only partial map built up. should only happen for files that were made 
          with BUILDMAPFLG=NIL, since otherwise there would be a coplete map on the 
          file.)


				(SFPTR SOURCEFILE (CAAR OLDFILEMAP)))
			      (T 

          (* Redundancy check. Should only occur if there was a compiled function in 
          the file. and a partial map was formed that stopped after that function.)


				 (HELP]
			  (T (SETQ SOURCEFILE NIL)
			     (PRIN1 PRTTYFILE T)
			     (PRIN1 (QUOTE " not found, so it will be written anew.
")
				    T]
          [SETQ PRTYZ (ERSETQ (PROG NIL
				    (RESETSAVE (SETREADTABLE FILERDTBL))
				    (COND
				      ((OR (NULL PRTTYFILE)
					   (EQ PRTTYFILE T))
					(SETQ PRTYZ T)
					(SETQ NEWFILEMAP NIL))
				      ((OPENP PRTTYFILE (QUOTE OUTPUT))
					(OUTPUT PRTTYFILE))
				      (T (OUTFILE PRTTYFILE)
					 (PRINTDATE (SETQ PRTTYFILE (OUTPUT))
						    CHANGES)

          (* The reason for the NAMEFIELD and OUTPUT instead of using PRTTYFILE is 
          that the user may have used alt-modes.)


					 ))
				    (SETQ PRTTYFILE (OUTPUT))
                                                (* Gets full name.)
				    (RESETSAVE NIL (LIST (QUOTE PRETTYDEF0)
							 PRTTYFILE SOURCEFILE RDTBL))
				    (COND
				      ((OR (LISTP PRTTYFNS)
					   (LISTP (CAR PRTTYFNS)))
					(PRINTFNS PRTTYFNS)
					(PRETTYCOM PRTTYFNS T)))
				    (COND
				      ((AND (NLISTP PRTTYCOMS)
					    (NLISTP (CAR PRTTYCOMS)))
					(GO OUT)))
				    (PRETTYCOM PRTTYCOMS T)
				    [MAP (SETQ PRETTYCOMSLST (COND
					     ((ATOM PRTTYCOMS)
					       (CAR PRTTYCOMS))
					     (T PRTTYCOMS)))
					 (FUNCTION (LAMBDA (L)
					     (PRETTYCOM (CAR L)
							NIL L]

          (* The original value of PRTTYCOMS is saved so that it can be rewritten if a 
          spelling correction occurs. The list PRTTYCOMSLST is searched by PRETTYCOM1 
          for * commands to see if the variable has be dumped out as well.)


				OUT (COND
				      ((PRETTYDEF1)

          (* The coms were reprinted by PRETTYDEF1 due to a change to nlama and or 
          nlaml)


					)
				      (PRTTYSPELLFLG 

          (* A correction on prettycoms was performed, so dump it out aain to get the 
          corrected version on the file.)


						     (PRETTYCOM PRTTYCOMS T)))
				    (COND
				      (NEWFILEMAP (PRIN1 (QUOTE "(DECLARE: DONTCOPY
  "))
						  (SFPTR PRTTYFILE (PRIN2 (SFPTR PRTTYFILE 
										 MAPADR)))

          (* This expresion writes the current file positon into the filecreated 
          expression, and then restores the file pointer.)


						  (PRIN2 (LIST (QUOTE FILEMAP)
							       NEWFILEMAP))
                                                (* printed instead of prettyprinted, so wont 
                                                take up two pages of listing.)
						  (PRIN1 (QUOTE ")
"))
						  (/PUT (NAMEFIELD PRTTYFILE T)
							(QUOTE FILEMAP)
							(CONS PRTTYFILE NEWFILEMAP))

          (* Also stoes MAP on property list, so can be ued for subsequent makeiles.)


						  ))
				    (OUTPUT PRTYX)

          (* Output done before ENDFILE in case output was, in fact, PRTTYFILE before 
          the call to PRETTYDEF, and PRTTYFILE is now being left closed)


				    (COND
				      ((NULL PRTYZ)
					(ENDFILE PRTTYFILE)))
				    (AND FILEDATES (/PUT (NAMEFIELD PRTTYFILE T)
							 (QUOTE FILEDATES)
							 FILEDATES))
				    (RETURN PRTTYFILE]
          (SETQ RESETVARSLST (CDR RESETVARSLST))
          (COND
	    (SOURCEFILE (CLOSEF SOURCEFILE)))
          (COND
	    (PRTYZ (RETURN (CAR PRTYZ)))
	    ([AND (NEQ PRTTYFILE T)
		  (SETQ PRTTYFILE (OPENP PRTTYFILE (QUOTE OUTPUT]
	      (CLOSEF PRTTYFILE)
	      (DELFILE PRTTYFILE)))
          (SETREADTABLE RDTBL)
          (ERROR!])

(PRETTYDEF0
  [NLAMBDA (PRTTYFILE SOURCEFILE RDTBL)         (* Cleans up after prettydef in case of 
                                                control-d.)
    (COND
      ([AND (NEQ PRTTYFILE T)
	    (SETQ PRTTYFILE (OPENP PRTTYFILE (QUOTE OUTPUT]
	(CLOSEF PRTTYFILE)
	(DELFILE PRTTYFILE)))
    [COND
      (SOURCEFILE (AND (SETQ SOURCEFILE (OPENP SOURCEFILE (QUOTE INPUT)))
		       (CLOSEF SOURCEFILE]
    (SETREADTABLE RDTBL])

(PRETTYDEF1
  [LAMBDA NIL                                   (* Updates the DECLARE: for NLAMA/NLAML)
    (PROG (PRTTYCOM PRTTYTEM PRTTYNEW)
          (COND
	    [[NULL (SOME PRETTYCOMSLST (FUNCTION (LAMBDA (X)
			     (AND (EQ (CAR X)
				      (QUOTE DECLARE:))
				  (SETQ PRTTYTEM (MEMB (QUOTE COMPILERVARS)
						       (SETQ PRTTYCOM X)))
				  (EQ (CAAR (SETQ PRTTYTEM (CDR PRTTYTEM)))
				      (QUOTE ADDVARS]
	      (AND (NULL NLAMALST)
		   (NULL NLAMLST)
		   (RETURN NIL))

          (* If thee is no DECLARE: and no nlambdas, dont bother to add any.
          note tha if thee is IS a DECLARE:, then we must check even if there are no 
          nlambdas, because consider what happens when user changes the only nlambda 
          to a lambda -
          must replace the declare: by a nop addvars.)


	      [SETQ PRTTYCOM (SUBPAIR (QUOTE (NLAMALST NLAMLST))
				      (LIST NLAMALST NLAMLST)
				      (QUOTE (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY 
						       COMPILERVARS (ADDVARS (NLAMA . NLAMALST)
									     (NLAML . NLAMLST]
	      (COND
		((AND (LISTP PRETTYCOMSLST)
		      (NLISTP PRTTYCOMS))
		  (/NCONC1 PRETTYCOMSLST PRTTYCOM)
		  (PRETTYCOM PRTTYCOMS T]
	    ([NOT (EQUAL (CAR PRTTYTEM)
			 (SETQ PRTTYNEW (LIST (QUOTE ADDVARS)
					      [CONS (QUOTE NLAMA)
						    (UNION NLAMALST (INTERSECTION LAM?LST
										  (CDADAR
										    PRTTYTEM]
					      (CONS (QUOTE NLAML)
						    (UNION NLAMLST (INTERSECTION
							     LAM?LST
							     (CDR (CADDAR PRTTYTEM]

          (* The reason for the unions and intersections is that prettydef simply may 
          not know the fntyps of some of the functions in the file, namely those on 
          lam?lst, and theefore tese should not be removed from NLAMA and NLAML if 
          they are there from a previous makefile.)


	      (/RPLACA PRTTYTEM PRTTYNEW)
	      (AND (NLISTP PRTTYCOMS)
		   (PRETTYCOM PRTTYCOMS T)))
	    (T (RETURN NIL)))
          (PRETTYCOM PRTTYCOM)
          (RETURN T])

(PRINTDATE
  [LAMBDA (PRTTYFILE CHANGES)
    (PROG ((DAT (DATE))
	   (FILE (NAMEFIELD PRTTYFILE T))
	   PREVDATE PREVERS)
          [COND
	    (FILEPKGFLG (/PUT FILE (QUOTE FILECHANGES)
			      (SETQ CHANGES (UNION (GETP FILE (QUOTE FILECHANGES))
						   CHANGES)))

          (* The reason for the order of aaguments in UNION is so thatthe changes will 
          be listed in rouhly the order made.)


			[SETQ FILEDATES (CONS (CONS DAT PRTTYFILE)
					      (AND [SETQ PREVDATE
						     (CAR (LAST (GETP FILE (QUOTE FILEDATES]
						   (LIST PREVDATE]

          (* Right now, FILEDATES simply keeps latest version and date, and original 
          version and date. Latter for integrity checks on makefile remake, as 
          described in filepackage. Note that dont want to change FILEDATES property 
          until prettydef copletes. In case of control-d, the file will be deleted 
          automatically.)


			(SETQ PREVERS (CDR PREVDATE))
			(SETQ PREVDATE (CAR PREVDATE]
          (PRINTDATE1 PRTTYFILE CHANGES DAT PREVDATE PREVERS)

          (* PRINTDATE1 does the actual printing.
          It is a separate funciion so thtit can be called again below in the case of 
          a font change, because this will cause a page eject and user will want to 
          tear off that page and still see his filecreated expression 
          (which in this case will actually be inside of the font info expression, 
          headed by a *))


          [COND
	    ((AND PARCFLG FONTCHANGEFLG)
	      (PRIN1 FONTSTRING)
	      (PRINTDATE1 PRTTYFILE CHANGES DAT PREVDATE PREVERS (QUOTE "]


"]
          (RETURN DAT])

(PRINTDATE1
  [LAMBDA (FILE CHANGES DAT PREVDATE PREVERS STR)
                                                (* does the printing.)
    (PRIN1 (QUOTE "(FILECREATED "))
    (PRIN2 DAT)
    (SPACES 1)
    (PRIN2 FILE)
    [COND
      ((AND BUILDMAPFLG PRTTYFILE (NEQ PRTTYFILE T))
	(SETQ MAPADR (ADD1 (SFPTR PRTTYFILE)))
	(SPACES 8)

          (* The address of where the map begins will be stored in this slot 8 spaces 
          left because when radix is 8, can overflow seven spaces by a file of 300000 
          characters (Alice did it))


	]
    [COND
      (FILEPKGFLG [COND
		    (CHANGES (MAPRINT CHANGES NIL (QUOTE "

     changes to:  ")
				      NIL
				      (QUOTE " ")
				      (FUNCTION PRIN2]
		  (COND
		    (PREVDATE (TERPRI)

          (* The TERPRI is not included in the next string, so as to avoid a spurious 
          carriage return. i.e. PRINT will think since the string "

previous date: " contains 17 characters, it wont fit on the line and do a carriage 
          return first, even though the string begins with a carriage return.)


			      (PRIN1 (QUOTE "
     previous date: "))
			      (PRIN2 PREVDATE)
			      (COND
				(PREVERS (SPACES 1)
					 (PRIN2 PREVERS]
    (PRIN1 (OR STR (QUOTE ")


"])

(PRINTFNS
  [LAMBDA (X)
    (PROG (FNADRLST)
          [COND
	    (NEWFILEMAP (SETQ FNADRLST (TCONC NIL (SFPTR PRTTYFILE)))
			(TCONC FNADRLST NIL)
			(NCONC1 NEWFILEMAP (CAR FNADRLST]
          (PRIN1 (QUOTE %())
          (PRINT (QUOTE DEFINEQ))
          (PRETTYPRINT X (OR FNADRLST T))
          (PRIN1 (QUOTE %)))
          (AND FNADRLST (RPLACA (CDAR FNADRLST)
				(SFPTR PRTTYFILE)))
          (TERPRI])

(PRETTYCOM
  [LAMBDA (PRTTYCOM PRTTYFLG PRETTYCOMSTAIL)
    (PROG (PRTTYTEM)
          [COND
	    ((OR (NULL PRTTYCOM)
		 (EQ PRTTYCOM (QUOTE NOBIND)))

          (* So that RECOMPILE and BRECOMPILE do not have to check before calling 
          PRETTYCOM.)


	      (RETURN))
	    (PRTTYFLG (PRINTDEF1 (LIST (COND
					 (LISPXPRINTFLG (QUOTE LISPXPRINT))
					 (T (QUOTE PRINT)))
				       (LIST (QUOTE QUOTE)
					     PRTTYCOM)
				       T T]
          (COND
	    ((ATOM PRTTYCOM)
	      (COND
		((AND (NULL PRTTYFLG)
		      (EQ (CAR PRTTYCOM)
			  (QUOTE NOBIND))
		      DWIMFLG
		      [SETQ PRTTYTEM (FIXSPELL PRTTYCOM 70 USERWORDS T PRETTYCOMSTAIL
					       (FUNCTION (LAMBDA (X)
						   (NEQ (CAR X)
							(QUOTE NOBIND]
		      (SETQ PRTTYSPELLFLG T))
		  (SETQ PRTTYCOM PRTTYTEM)))
	      (PRETTYVAR PRTTYCOM PRTTYFLG)

          (* FNS and VARS are printed as (RPAQQ atom value T) so that LOAD ALLPROP 
          will still stre them in the value cell.)


	      (RETURN PRTTYCOM))
	    (PRTTYFLG                           (* PRETTYDEF called with a list for FNS or 
                                                VARS,)
		      (RETURN PRTTYCOM)))
      TOP [SELECTQ (CAR PRTTYCOM)
		   (DECLARE: 

          (* Normally, expressions appearing in a symbolic file are 
          (1) evaluated upon loading the file, (2) not evaluated when compiling the 
          file, and (3) copied to the compile file.
          DECLARE: can be used to change state around any PRETTYCOM.
          The atomic symbols DONTCOPY, DOCOPY, DONTEVAL@COMPILE, DOEVAL@COMPILE, 
          DONTEVAL@LOAD, and DOEVAL@LOAD have the obvious meaning.
          DECLARE: eliminates the pretty commands DECLARE, COMPROP, COMPROP*, PD, PC, 
          and PC*. DECLARE: is defined as a functionthat evaluates all list 
          expressions except when under a DONTEVAL@LOAD state.)


			     (PRIN1 (QUOTE "[DECLARE: "))
			     [MAP (PRETTYCOM1 PRTTYCOM T)
				  (FUNCTION (LAMBDA (X)
				      (COND
					((ATOM (CAR X))
					  [COND
					    ((NOT (MEMB (CAR X)
							DECLARECOMLST))
					      (COND
						((AND DWIMFLG (FIXSPELL (CAR X)
									70 DECLARECOMLST T X))
						  (SETQ PRTTYSPELLFLG T))
						(T (GO ERROR]
					  (PRIN1 (CAR X))
					  (SPACES 1))
					(T (TERPRI)
					   (PRETTYCOM (CAR X)
						      NIL X]
			     (PRIN1 (QUOTE "]
")))
		   [(PROP IFPROP)
		     (PROG ((PRTTYFLG (EQ (CAR PRTTYCOM)
					  (QUOTE IFPROP)))
			    (PRTTYTEM (CADR PRTTYCOM))
			    (PRTTYX (PRETTYCOM1 (CDR PRTTYCOM)
						T)))
                                                (* IFPROP only dumps those property values that 
                                                are non-NIL.)
		           (COND
			     [(LISTP PRTTYTEM)
			       (MAPC PRTTYTEM (FUNCTION (LAMBDA (X)
					 (MAKEDEFLIST PRTTYX X PRTTYFLG PRTTYCOM]
			     ((NEQ PRTTYTEM (QUOTE ALL))
			       (MAKEDEFLIST PRTTYX PRTTYTEM PRTTYFLG PRTTYCOM))
			     (T (MAPC PRTTYX (FUNCTION (LAMBDA (ATM)
					  (PRIN1 (QUOTE "  (PUTPROPS "))
					  (PRIN2 ATM)
					  (SETQ PRTTYTEM (ADD1 (POSITION)))
					  (MAP (CDR ATM)
					       [FUNCTION (LAMBDA (X)
						   (COND
						     ((NOT (MEMB (CAR X)
								 SYSPROPS))
						       (SPACES 1)
						       (PRINTDEF (CAR X)
								 PRTTYTEM)
						       (SPACES 1)
						       (PRINTDEF (CADR X)
								 (POSITION]
					       (FUNCTION CDDR))
					  (PRIN1 (QUOTE ")
"]
		   (P (MAPC (SETQ PRTTYTEM (PRETTYCOM1 PRTTYCOM T))
			    (FUNCTION PRINTDEF1)))
		   (VARS (MAPC (PRETTYCOM1 PRTTYCOM T)
			       (FUNCTION PRETTYVAR)))
		   [ADDVARS (MAPC (PRETTYCOM1 PRTTYCOM T)
				  (FUNCTION (LAMBDA (X)
				      (PRINTDEF1 (CONS (QUOTE ADDTOVAR)
						       X]
		   [USERMACROS
		     [PRINTDEF1 (CONS (QUOTE ADDTOVAR)
				      (CONS (QUOTE USERMACROS)
					    (SETQ PRTTYTEM
					      (COND
						[(SETQ PRTTYTEM (PRETTYCOM1 PRTTYCOM T))
						  (MAPCONC USERMACROS
							   (FUNCTION (LAMBDA (X)
							       (AND (MEMB (CAR X)
									  PRTTYTEM)
								    (LIST X]
						(T USERMACROS]
		     (PROG (TEM1 TEM2)
		           [MAPC PRTTYTEM (FUNCTION (LAMBDA (X)
				     (COND
				       ((CADR X)
					 (SETQ TEM2 (CONS (CAR X)
							  TEM2)))
				       (T (SETQ TEM1 (CONS (CAR X)
							   TEM1]
		           [AND TEM1 (PRINTDEF1 (CONS (QUOTE ADDTOVAR)
						      (CONS (QUOTE EDITCOMSA)
							    TEM1]
		           (AND TEM2 (PRINTDEF1 (CONS (QUOTE ADDTOVAR)
						      (CONS (QUOTE EDITCOMSL)
							    TEM2]
		   (FNS (PROG (PRTTYSPELLFLG)
			      (PRINTFNS (PRETTYCOM1 PRTTYCOM T))
			      (AND PRTTYSPELLFLG (EQ (CADR PRTTYCOM)
						     (QUOTE *))
				   (ATOM (SETQ PRTTYTEM (CADDR PRTTYCOM)))
				   (PRETTYCOM PRTTYTEM))
                                                (* The FNSlst had an error in it that was 
                                                corrected.)
			  ))
		   (ARRAY (MAPC (PRETTYCOM1 PRTTYCOM T)
				(FUNCTION PRINTARRAY)))
		   (E (MAPC (PRETTYCOM1 PRTTYCOM T)
			    (FUNCTION EVAL)))
		   [COMS (SETQ PRTTYTEM (PRETTYCOM1 PRTTYCOM T))
			 (PROG ((PRETTYCOMSLST (APPEND PRTTYTEM PRETTYCOMSLST)))
			       (MAP PRTTYTEM (FUNCTION (LAMBDA (X)
					(PRETTYCOM (CAR X)
						   NIL X]
		   (ADVISE (ADVISEDUMP (PRETTYCOM1 PRTTYCOM T)
				       T))
		   (ADVICE (ADVISEDUMP (PRETTYCOM1 PRTTYCOM T)))
		   (BLOCKS (SETQ PRTTYTEM (PRETTYCOM1 PRTTYCOM T))
			   (PRIN1 (QUOTE "[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
"))
			   [MAPC PRTTYTEM (FUNCTION (LAMBDA (X)
				     (PRINTDEF1 (CONS (QUOTE BLOCK:)
						      X]
			   (PRIN1 (QUOTE "]
")))
		   (COND
		     ([SETQ PRTTYTEM (ASSOC (CAR PRTTYCOM)
					    (QUOTE ((COMPROP PROP DOEVAL@COMPILE)
						    (COMPROP* PROP DOEVAL@COMPILE DONTCOPY)
						    (DECLARE P DONTEVAL@LOAD DOEVAL@COMPILE 
							     DONTCOPY)
						    (PD P DOEVAL@COMPILE)
						    (PC P DOEVAL@COMPILE)
						    (PC* P DOEVAL@COMPILE DONTCOPY]
		       [SETQ PRTTYTEM (CONS (QUOTE DECLARE:)
					    (APPEND (CDDR PRTTYTEM)
						    (LIST (CONS (CADR PRTTYTEM)
								(CDR PRTTYCOM]
		       (AND (EQ PRTTYCOM (CAR PRETTYCOMSTAIL))
			    (/RPLACA PRETTYCOMSTAIL PRTTYTEM)
			    (SETQ PRTTYSPELLFLG T))
		       (PRETTYCOM PRTTYTEM))
		     [(SETQ PRTTYTEM (ASSOC (CAR PRTTYCOM)
					    PRETTYMACROS))
		       (MAP (SUBPAIR (CADR PRTTYTEM)
				     (PRETTYCOM1 PRTTYCOM T)
				     (CDDR PRTTYTEM))
			    (FUNCTION (LAMBDA (X)
				(PRETTYCOM (CAR X)
					   NIL X]
		     ((FIXSPELL (CAR PRTTYCOM)
				70 PRETTYCOMSPLST T PRTTYCOM)
		       (SETQ PRTTYSPELLFLG T)
		       (GO TOP))
		     (T (GO ERROR]
          (RETURN PRTTYCOM)
      ERROR
          (ERROR (QUOTE "Bad prettycom")
		 PRTTYCOM T])

(PRETTYVAR
  [LAMBDA (VAR FLG)
    (PROG (TEM)

          (* Dumps value of VAR for reloading. If VAR is non-atomic, of form 
          (var form) where VAR is to be dumped so as to be set to value of form, 
          computed at LOAD time.)


          (PRINTDEF1 (COND
		       ((ATOM VAR)
			 (LIST (QUOTE RPAQQ)
			       VAR
			       (CAR VAR)))
		       ((EQ (CAR (SETQ TEM (CADR VAR)))
			    (QUOTE QUOTE))
			 (LIST (QUOTE RPAQQ)
			       (CAR VAR)
			       (CADR TEM)))
		       (T (CONS (QUOTE RPAQ)
				VAR])

(PRETTYCOM1
  [LAMBDA (PRTYCOM PRTYFLG)
    (PROG (PRTYX)
          (RETURN (COND
		    ((EQ (CAR (SETQ PRTYX (CDR PRTYCOM)))
			 (QUOTE *))
		      (COND
			([AND (ATOM (SETQ PRTYX (CADR PRTYX)))
			      PRTYFLG
			      (NOT (MEMB PRTYX PRETTYCOMSLST))
			      (NULL (SOME PRETTYCOMSLST (FUNCTION (LAMBDA (COM)
					      (AND (EQ (CAR COM)
						       (QUOTE VARS))
						   (NEQ COM PRTYCOM)
						   (OR (MEMB PRTYX COM)
						       (ASSOC PRTYX COM]

          (* Checks to see if the variable is already being dumped and dumps it if 
          not.)


			  (PRETTYCOM PRTYX)))
		      (EVAL PRTYX))
		    (T PRTYX])

(ENDFILE
  [LAMBDA (Y)
    (PRINT (QUOTE STOP)
	   Y)
    (CLOSEF Y])

(MAKEDEFLIST
  [LAMBDA (X PROP FLG COM)
    (PROG (TEM)
          (PRIN1 (QUOTE "(DEFLIST(QUOTE(
"))
          [MAPC X (FUNCTION (LAMBDA (Z)
		    (COND
		      ((SETQ TEM (FMEMB PROP (CDR Z)))
			(PRINTDEF (LIST Z (CADR TEM)))
			(TERPRI))
		      ((NULL FLG)               (* PROP command)
			(PRINT (LIST (QUOTE no)
				     PROP
				     (QUOTE property)
				     (QUOTE for)
				     Z)
			       T]
          (PRIN1 (QUOTE "))(QUOTE "))
          (PRIN2 PROP)
          (PRIN1 (QUOTE "))
"])

(PUTPROPS
  [NLAMBDA X
    (MAP (CDR X)
	 [FUNCTION (LAMBDA (Y)
	     (/PUT (CAR X)
		   (CAR Y)
		   (CADR Y]
	 (FUNCTION CDDR])

(PP
  [NLAMBDA X
    (RESETLST (RESETSAVE (OUTPUT T))
	      (RESETSAVE (SETREADTABLE T))
	      (COND
		[(ATOM X)
		  (CAR (PRETTYPRINT (LIST X]
		(T (PRETTYPRINT X])

(PP*
  [NLAMBDA X
    (RESETLST (RESETSAVE (OUTPUT T))
	      (RESETSAVE (SETREADTABLE T))
	      (RESETSAVE **COMMENT**FLG NIL)
	      (COND
		[(ATOM X)
		  (CAR (PRETTYPRINT (LIST X]
		(T (PRETTYPRINT X])

(PPT
  [NLAMBDA X
    (RESETLST (RESETSAVE (OUTPUT T))
	      (RESETSAVE (SETREADTABLE T))
	      (RESETSAVE PRETTYTRANFLG T)
	      (COND
		[(ATOM X)
		  (CAR (PRETTYPRINT (LIST X]
		(T (PRETTYPRINT X])

(PRETTYPRINT
  [LAMBDA (FNS PRETTYDEFLG)                     (* PRETTYDEFLG is T when called from PRETTYDEF.)

          (* Note that prettyprint does all of its printing to standard output file 
          and using current readtable. it assumes that higher functions have set these 
          appropriately, as is the case when called from prettydef, pp, pp*,)


    (PROG ((FNSLST FNS)
	   LST
	   (CLK (CLOCK 0))
	   TEM FN DEF ADR NEWADRLST SKIPPEDLST)
          (AND (LISTP PRETTYDEFLG)
	       (SETQ NEWADRLST PRETTYDEFLG))    (* Corresponds to the current entry on 
                                                NEWFILEMAP. Is in TCONC format.)
          [COND
	    ((ATOM FNSLST)
	      (SETQ FNSLST (CAR FNSLST]
          (SETQ LST FNSLST)
      LP  [COND
	    (NEWADRLST (SETQ ADR (SFPTR PRTTYFILE))
		       (COND
			 ((SETQ TEM (CADR NEWADRLST))

          (* This check would fail first time through the loop, but subsequent times 
          would store end address for pevious function written.)


			   (RPLACD (CDR TEM)
				   (IPLUS -2 ADR))

          (* The -2 is to discount the TERPRI done after the definition.
          Note that it doesnt matter whether the function was dumped by copying it 
          from the old file or printed anew. In both cases, all that is happening is 
          the file position in the output file is read before and after printing.)


			   ]
          (COND
	    ((NLISTP LST)
	      (RETURN FNS))
	    ((AND PRETTYDEFLG (IGREATERP (IDIFFERENCE (SETQ TEM (CLOCK 0))
						      CLK)
					 30000))
	      (SETQ CLK TEM)
	      (PRIN1 (CAR LST)
		     T)
	      (PRIN1 (QUOTE ", ")
		     T)))
          (SETQ FN (CAR LST))
          [AND NEWADRLST (TCONC NEWADRLST (LIST FN (IPLUS ADR 2]
      LP1 [SETQ DEF (COND
	      ((CDR FN)                         (* Checks for property list, if none saves call 
                                                to VIRGINFN.)
		(VIRGINFN FN))
	      (T (GETD FN]
          (AND PRETTYDEFLG (SELECTQ (ARGTYPE DEF)
				    (1 (SETQ NLAMLST (CONS FN NLAMLST)))
				    (3 (SETQ NLAMALST (CONS FN NLAMALST)))
				    (NIL (SETQ LAM?LST (CONS FN LAM?LST)))
				    NIL))       (* So prettydef can add the appropriate 
                                                DECLARE:)
          (COND
	    [(NULL DEF)
	      (COND
		((AND (NULL PRETTYDEFLG)
		      (LISTP (CAR FN)))
		  (PRINTDEF (CAR FN))
		  (TERPRI))
		(T (GO NOPRINT]
	    ((NULL (EXPRP DEF))
	      (GO NOPRINT))
	    (T (AND DWIMFLG (ADDSPELL FN))
	       (COND
		 ((AND PRETTYDEFLG SOURCEFILE [NULL (SELECTQ REPRINTFNS
							     (ALL T)
							     ((T EXPRS)
							       (EXPRP FN))
							     (AND (LISTP REPRINTFNS)
								  (FMEMB FN REPRINTFNS]
		       (PRETTYPRINT1 FN))       (* See comment in PRETTYDEF.)
		   (GO LP2))
		 (CLISPIFYPRETTYFLG [AND (SELECTQ CLISPIFYPRETTYFLG
						  ((T EXPRS)
						    (EXPRP FN))
						  (ALL T)
						  (CHANGES (AND PRETTYDEFLG (MEMB FN CHANGES)))
						  (MEMB FN CLISPIFYPRETTYFLG))
					 (RESETVAR FILEPKGFLG NIL (SETQ DEF (CLISPIFY DEF]

          (* If the function is stored on property list, only clispify if user 
          specifically said MAKEFILE (file CLISPIFY), otherwise, assume that functions 
          on property list have already been clispified)


				    ))
	       (TERPRI)
	       (COND
		 ((AND FONTCHANGEFLG LAMBDAFONTSTR)
		   (PRIN1 LAMBDAFONTSTR)
		   (PRIN1 (QUOTE %())
		   (PRIN1 FN)
		   (PRIN1 DEFAULTFONTSTR)
		   (TERPRI))
		 (T (PRIN1 (QUOTE %())
		    (PRINT FN)))
	       (PRINTDEF DEF NIL T PRETTYDEFLG)
	       (PRIN1 (QUOTE %)))
	       (TERPRI)))
      LP2 (SETQ LST (CDR LST))
          (GO LP)
      NOPRINT
          (COND
	    ((AND PRETTYDEFLG SOURCEFILE (PRETTYPRINT1 FN))
	      (GO LP3))
	    ((AND (NULL PRETTYDEFLG)
		  (SETQ TEM (EDITF0 FN)))
	      (LOADFNS FN TEM (QUOTE PROP))
	      (COND
		((GETP FN (QUOTE EXPR))
		  (GO LP1)))
	      (PRINT (CONS FN (QUOTE (not found)))
		     T T))
	    ((AND DWIMFLG (NULL DEF)
		  (SETQ TEM (MISSPELLED? FN 70 USERWORDS (AND PRETTYDEFLG T)
					 LST))
		  (NEQ TEM FN))
	      (/RPLACA LST (SETQ FN TEM))
	      (AND NEWADRLST (FRPLACA (CADR NEWADRLST)
				      FN))      (* Fixes filemap.)
	      (AND PRETTYDEFLG (SETQ PRTTYSPELLFLG T))
	      (GO LP1)))
          (LISPXPRINT (CONS FN (QUOTE (not printable)))
		      T)
          (AND LISPXHISTORY (LISPXPUT (QUOTE *ERROR*)
				      FN NIL (CAAR LISPXHISTORY)))
          (COND
	    (NEWADRLST (SETQ TEM (NLEFT (CAR NEWADRLST)
					2))
		       (RPLACD TEM)
		       (RPLACD NEWADRLST TEM)))
      LP3 (SETQ LST (CDR LST))
          (GO LP])

(PRETTYPRINT1
  [LAMBDA (FN)

          (* Like BRECOMPILE1. Obtains FN from SOURCEFILE.
          works whether the file has previously been mapped by PRETTYDEF, LOAD, or 
          LOADFNS (or patially mapped))


    (PROG (ADR TEM)
          (COND
	    ((NULL OLDFILEMAP)
	      (GO DEFQLP))
	    ((PRETTYPRINT2 FN)
	      (RETURN FN))
	    ((NULL (CAR OLDFILEMAP))
	      (RETURN NIL)                      (* The entire file has been scanned.)
	      )
	    (T (GO FNLP)                        (* Already inside of DEFINEQ.)
	       ))
      DEFQLP                                    (* Find DEFINEQ)
          (SELECTQ (SETQ TEM (RATOM SOURCEFILE))
		   ((STOP NIL)                  (* End of file reached.)
		     (SETQ OLDFILEMAP (CONS NIL OLDFILEMAP))
                                                (* Just to inform future calls to PRETTYPRINT1 
                                                not to bother scanning.)
		     (RETURN NIL))
		   [%( (COND
			 ((EQ (SETQ TEM (RATOM SOURCEFILE))
			      (QUOTE DEFINEQ))
			   (COND
			     ((NULL OLDFILEMAP)
			       (SETQ OLDFILEMAP (LIST T))

          (* In case functionis found right off, OLDFILEMAP must not be left as NIL or 
          else next call to PRETTYPRINT1 will not realize are alredy inside of 
          DEFINEQ.)


			       ))
			   (GO FNLP))
			 (T (SKREAD SOURCEFILE (CONCAT (QUOTE %()
						       TEM]
		   (SKREAD SOURCEFILE TEM))
          (GO DEFQLP)
      FNLP(SELECTQ (SETQ TEM (RATOM SOURCEFILE))
		   (%)                          (* End of DEFINEQ.)
		       (GO DEFQLP))
		   ((%( %[)
		     NIL)
		   (GO HELP))
          (SETQ ADR (SUB1 (SFPTR SOURCEFILE)))
          (SETQ TEM (RATOM SOURCEFILE))
          (SFPTR SOURCEFILE ADR)
          (SKREAD SOURCEFILE)
          (COND
	    ((EQ TEM FN)
	      (PRETTYPRINT2 FN ADR (SFPTR SOURCEFILE))
                                                (* copies the bytes.)
	      (RETURN FN))
	    (T (SETQ OLDFILEMAP (CONS (CONS TEM (CONS ADR (SFPTR SOURCEFILE)))
				      OLDFILEMAP))

          (* Note that this situation only occurs when 
          (a) the entire file was not peviously scanned, e.g. if loaded with 
          buildmapflg off, and (b) user is doing a remake, and 
          (c) this functio was either dumped directly because it was changed, or else 
          it has been deleted from the FNS. The function is added to OLDFILEMAP just 
          in case it is out of order.)


	       (GO FNLP)))
      HELP(HELP (QUOTE "SYSOUT and show W.Teitelman"])

(PRETTYPRINT2
  [LAMBDA (FN FROM TO)

          (* Copies function from sourcefile to prettyfile.
          looking it up on the map when not already given address.
          returns nil if not there)


    (PROG (TEM)
          (COND
	    (FROM)
	    ([SOME OLDFILEMAP (FUNCTION (LAMBDA (X)
		       (COND
			 ((NLISTP X)
			   NIL)
			 ((EQ (CAR X)
			      FN)

          (* occurs when remaking a file without a map, and a function is previously 
          skipped that later is needed.)


			   (SETQ TEM X))
			 ((LISTP (CDDR X))
			   (SETQ TEM (FASSOC FN (CDDR X]
	      (SETQ FROM (CADR TEM))
	      (SETQ TO (CDDR TEM)))
	    (T (RETURN NIL)))
          (SFPTR SOURCEFILE (ADD1 FROM))
          (COND
	    ((NEQ FN (SETQ TEM (READ SOURCEFILE)))
                                                (* Consistency check.)
	      (LISPXPRINT (CONS FN TEM)
			  T)
	      (ERROR (QUOTE "filemap does not agree with contents of")
		     SOURCEFILE T)))
          (COPYBYTES SOURCEFILE PRTTYFILE (IPLUS FROM -2)
		     (IPLUS TO 2))
          (RETURN FN])

(PRINTDEF1
  [LAMBDA (E)
    (PRINTDEF E)
    (TERPRI])

(PRINTDEF
  [LAMBDA (EXPR LEFT DEF PRETTYDEFLG)
    (PROG ((I (OR LEFT 2))
	   (LASTCOL (LINELENGTH))
	   HEAD HELPCLOCK (CRCNT 0))
          (COND
	    ((NULL PRETTYFLG)
	      (PRIN2 EXPR))
	    (T (TAB I 0)
	       (SUPERPRINT EXPR])

(SUPERPRINT
  [LAMBDA (E BRFLG)

          (* BRFLG says do not print a %), expression will be terminated by a %].
          Value is T if a carraiger return was printed, NIL otherwise.)


    (PROG (TEM1 TEM2)
          [COND
	    ((AND (LISTP E)
		  DEF
		  (EQ (CAR E)
		      COMMENTFLG)
		  (NEQ HEAD (QUOTE SELECTQ))
		  (NEQ HEAD (QUOTE COND)))
	      (RETURN (COMMENT1 E)))
	    ([AND (NLISTP E)
		  [NOT (IGREATERP I (SETQ TEM1 (POSITION]
		  (IGREATERP (ADD1 TEM1)
			     (SETQ TEM2 (IDIFFERENCE LASTCOL (NCHARS E T]

          (* TEM2 is the first column at which the ATOM will fit on a line.)


	      ([LAMBDA (I)
		  (ENDLINE]
		(COND
		  ((IGREATERP (SETQ TEM2 (IPLUS TEM2 -5))
			      I)                (* This is (MIN P-5 I))
		    I)
		  (T TEM2]
          (RETURN (COND
		    ((NLISTP E)
		      (PRIN2 E))
		    (T ([LAMBDA (I)
			   (COND
			     ((AND #RPARS (NULL BRFLG)
				   (RPARS E))
			       (PRIN1 (QUOTE %[))
			       (SETQ BRFLG T)
			       (SETQQ TEM1 %]))
			     (T (PRIN1 (QUOTE %())
				(SETQ TEM1 NIL)))
			   [COND
			     ((AND DEF CLISPTRANFLG (NULL PRETTYTRANFLG)
				   (EQ (CAR E)
				       CLISPTRANFLG))
                                                (* PRETTYTRANFLG=NIL means print the CLISP.)
			       (SETQ E (CDDR E)))
			     ([AND DEF PRETTYTRANFLG
				   (OR (AND CLISPARRAY [COND
					      [(LITATOM (CAR E))
						(NULL (FGETD (CAR E]
					      ((LISTP (CAR E))
						(NULL (OR (EQ (CAAR E)
							      (QUOTE LAMBDA))
							  (EQ (CAAR E)
							      (QUOTE NLAMBDA]
					    (SETQ TEM2 (GETHASH E CLISPARRAY)))
				       (AND CLISPTRANFLG (EQ (CAR E)
							     CLISPTRANFLG)
					    (SETQ TEM2 (CADR E))
					    (SETQ E (CDDR E]

          (* If (CAR E) is an atom, and it is the name of a function, a translation 
          wouldnt be invoked, so dont bother to check for one.)


			       (COND
				 ((EQ PRETTYTRANFLG T)
                                                (* PRETTYTRANFLG=T means print the translation.)
				   (SETQ E TEM2))
				 (T 

          (* For other values, e.g. BOTH, an xpression of the form 
          (CLISP%  translation . expression) is printed, 
          (even when the translation was originaly in the hash array). This saves 
          both, and when reloaded, and dwiified or run, CLISP%  rehashes and removes 
          the CLISP%  (assuming CLISPARRAY is set up that way))


				    (PRIN2 CLISPTRANFLG)
				    (SUPERPRINT TEM2)
				    (ENDLINE]
			   (SUBPRINT E BRFLG)
			   (COND
			     ((NOT (ILESSP (POSITION)
					   LASTCOL))
			       (ENDLINE)))
			   (COND
			     (TEM1 (PRIN1 TEM1))
			     ((NULL BRFLG)
			       (PRIN1 (QUOTE %)]
			 (IPLUS I (COND
				  ((NLISTP (CAR E))
				    2)
				  ((NULL DEF)
				    1)
				  ((OR (EQ HEAD (QUOTE COND))
				       (EQ HEAD (QUOTE SELECTQ))
				       (EQ (CAAR E)
					   (QUOTE LAMBDA)))

          (* In function definition, the sublists in a list of lists are aligned 
          except for the indicatd cases.)


				    2)
				  (T 1])

(RPARS
  [LAMBDA (E)
    (SELECTQ (CAR E)
	     ([LAMBDA NLAMBDA]
	       T)
	     (DEFINEQ 

          (* Dont want square brakcets around DEFINEQ's expressions, because this 
          means last function pair is special with respect to LOaDFNS.)


		      NIL)
	     (PROG ((N 1)
		    (X E)
		    Y
		    (Z E))
	       LP  (COND
		     ([LISTP (SETQ X (CDR (SETQ Y X]
		       (GO LP))
		     ((LISTP (SETQ X (CAR Y)))
		       (ADD1VAR N)
		       (SETQ Z X)
		       (GO LP))
		     (T (RETURN (NOT (ILESSP N #RPARS])

(SUBPRINT
  [LAMBDA (E BRFLG END)
    (PROG (CURRENT DOCRFLG (HEAD (CAR E))
		   (L (CDR E))
		   (I0 (POSITION))
		   NEXT TEM CRCNT0 CLISPWORD)
      LP  (COND
	    ((OR (NULL E)
		 (EQ E END))
	      (RETURN E))
	    ((NLISTP E)
	      (PRIN1 (QUOTE " . "))
	      (PRIN2 E)
	      (RETURN)))
          (SETQ CRCNT0 CRCNT)
          (SETQ CURRENT (CAR E))
          (AND CLISPFLG DEF (SETQ CLISPWORD (AND (SETQ TEM (GETP CURRENT (QUOTE CLISPWORD)))
						 (ATOM (CAR TEM))
						 TEM)))
          (SETQ TEM NIL)
          (AND DEF PRETTYDEFLG FONTCHANGEFLG (LITATOM CURRENT)
	       (SETQ TEM (COND
		   ((LISTP CLISPWORD)
		     CLISPFONTSTR)
		   ((AND FONTWORDS (FMEMB CURRENT FONTWORDS))
		     USERFONTSTR)
		   ((AND (EQ L (CDR E))
			 (NULL END))
		     (COND
		       ((FMEMB CURRENT (COND
				 ((EQ FONTFNS T)
				   FNSLST)
				 ((LISTP FONTFNS)
				   FONTFNS)))
			 USERFONTSTR)
		       ((FGETD CURRENT)
			 SYSTEMFONTSTR)))
		   ((AND (GETP CURRENT (QUOTE CLISPTYPE))
			 (NOT (FMEMB CURRENT CLISPCHARS)))
                                                (* Infix operators like GT, AND, etc.)
		     CLISPFONTSTR)))
	       (NEQ TEM (QUOTE UNDERLINE))
	       (PRIN1 TEM))

          (* When printing a function, via a caal to prettydef, and fontflg is turned 
          on, and the function is either on FNS or on FONTFLG, do a fontchange.)


          (SUPERPRINT CURRENT (AND (NULL (SETQ E (CDR E)))
				   BRFLG))
          [AND TEM (COND
		 ((EQ TEM (QUOTE UNDERLINE))
		   (SETQ TEM (NCHARS CURRENT))
		   [POSITION NIL (PROG1 (POSITION)
					(POSITION NIL 0)
					(RPTQ TEM (PRIN1 (CHARACTER 8)))
					(RPTQ TEM (PRIN1 (CHARACTER 24]

          (* Resets POSITION to 0 before printing the control characters and then sets 
          it bck to where it was. Done this way instead of decrementing position 
          because of the posisibiliy of resetting position to a negative number.)


		   )
		 (T (POSITION NIL (IPLUS (POSITION)
					 -4))
		    (PRIN1 DEFAULTFONTSTR]

          (* CURRENT is always the element just printed, NEXT the one about to be 
          printed, i.e. CAR of E.)

                                                (* BRFLG only affects last expression in list.)
      LP0 (COND
	    ((EQ E END)
	      (RETURN E))
	    ((NLISTP E)
	      (GO LP))
	    ((OR (NULL CLISPFLG)
		 (NULL DEF))
	      (GO LP1))
	    [(NOT (LITATOM (SETQ NEXT (CAR E]
	    ((GETP NEXT (QUOTE CLISPWORD))

          (* AND and OR are treated like prettywords because they are broadscope 
          operators, i.e. they permit segments, and therefore the standard FITP test 
          can't be ued.)


	      (GO CLISPWORD))
	    ((EQ (NTHCHAR NEXT 1)
		 (QUOTE <))
	      [COND
		((EQ (SETQ TEM (SUBPRINT2 E END))
		     (CDR E))
		  (GO LP1))
		((OR (LISTP CURRENT)
		     (NOT (FITP E NIL TEM)))
		  (ENDLINE))
		(T (SPACES 1)
		   (AND (EQ L E)
			(SETQ I (POSITION]
	      (SETQ CRCNT0 CRCNT)
	      (PROG (I)
		    (SETQ I (IPLUS (POSITION)
				   2))
		    (SETQ E (SUBPRINT E BRFLG TEM)))
	      (SETQQ CURRENT >)
	      (GO LP0)))
          (COND
	    ((LISTP CURRENT)
	      (AND (LITATOM NEXT)
		   (EQ (CAR NEXT)
		       (QUOTE NOBIND))
		   (NOT (FMEMB NEXT FUNNYATOMLST))
		   (NEQ (SETQ TEM (NTHCHAR NEXT 1))
			(QUOTE '))
		   (NEQ TEM (QUOTE <))
		   (FMEMB TEM CLISPCHARS)
		   (GO LP))                     (* E.g. ((FOO) *FIE))
	      )
	    ((NOT (LITATOM CURRENT))
	      (GO LP1))
	    ((OR (EQ (CAR CLISPWORD)
		     (QUOTE IFWORD))
		 (EQ (CAR CLISPWORD)
		     (QUOTE FORWORD)))
	      (SETQ DOCRFLG NIL)
	      (AND (NULL END)
		   (SETQ END T))                (* See use of END at LP2 beloow)
	      )
	    ((AND (NOT (ATOM NEXT))
		  [COND
		    [(EQ L E)
		      (AND (NULL (FGETD CURRENT))
			   (NULL (GETP CURRENT (QUOTE EXPR]
		    (T (EQ (CAR CURRENT)
			   (QUOTE NOBIND]
		  (NOT (FMEMB CURRENT FUNNYATOMLST))
		  (FMEMB (SETQ TEM (NTHCHAR CURRENT -1))
			 CLISPCHARS)
		  (NEQ TEM (QUOTE >)))          (* E.g. X* (FOO) Don't space)
	      (GO LP))
	    ((AND (STRPOS (QUOTE "_")
			  CURRENT)
		  (NEQ (NTHCHAR CURRENT -1)
		       (QUOTE _)))

          (* E.G. IF -- THEN FOO_X FIE_Y is more readable if the assignments are on 
          separate lines.)


	      (GO CR)))
      LP1 [COND
	    ((EQ L E)                           (* First time through, i.e. just superprinted 
                                                HEAD of list.)
	      (AND DEF (SELECTQ CURRENT
				(COND
				  (GO CR))
				(PROG (PRINTPROG E BRFLG)
				      (RETURN))
				((ASSEMBLE ASSEM)
				  (RESETFORM (RADIX 8)
					     (PRINTPROG E BRFLG))
				  (RETURN))
				(SELECTQ (SETQ DOCRFLG T)
					 (* To insure carriage return after select-expression))
				((SETQ RESETVAR)
				  (GO SP))
				(FUNCTION (AND (NULL (CDR E))
					       (GO SP))

          (* Normally, I is not reset for FUNCTION, and the margin for the body of the 
          lambda definition is directly under FUNCTION to conserve space.
          However, when FUNCTION is given a second argument, this would cause 
          confusion, so I is reset in this case.)


					  )
				([LAMBDA NLAMBDA]
				  (SETQ DOCRFLG T)
				  (SPACES 1)
				  (GO LP))
				NIL))
	      (COND
		([OR (LISTP CURRENT)
		     (NULL (FITP E T (OR (LISTP END)
					 (AND CLISPWORD (SUBPRINT1 E (CAR CLISPWORD]
                                                (* Don't reset I.)
		  (GO CR))
		((EQ (NTHCHAR CURRENT 1)
		     (QUOTE <))
		  (GO SP))
		(T 

          (* Don't go to SP to space because don't want DOCRFLG changed, i.e. if 
          U=SELECTQ, then DOCRFLG has been set to insure carriage return after 
          selector.)


		   (SPACES 1)
		   (SETQ I (POSITION))
		   (GO LP]
      LP2 (AND (NEQ CRCNT0 CRCNT)
	       (OR (LISTP CURRENT)
		   (EQ CURRENT (QUOTE >)))
	       (GO CR))

          (* Printing last "thing" (usually a list) caused a c.r.
          Also occurs if printing angle brackets which contain a list inside, e.g. < 
          (FOO (FIE) X) > and c.r. will occur after >.)


          (SETQ NEXT (CAR E))
          (COND
	    [(LISTP CURRENT)
	      (COND
		((OR (NULL END)
		     (EQ (CAR CURRENT)
			 COMMENTFLG)
		     (NOT (LITATOM NEXT)))
		  (GO CR))
		((OR (GETP NEXT (QUOTE CLISPWORD))
		     (GETP NEXT (QUOTE CLISPTYPE)))
		  (GO SP))
		(T (GO CR]
	    ((NLISTP NEXT)
	      (GO SP))
	    (DOCRFLG 

          (* DOCRFLG is set to T whenever a carriage return is performed.
          It is reset to NIL whenever a carriage return is NOT performed, e.g. when 
          two atoms are adjacent. while it is T, carriage returns are performed 
          FOLLOWING all expressions. For example, in -
          (A B (C) D (E) F G (H)) (C) D (E) and F would be on separate lines, but F, 
          G, and (H) would all be ont he same line.)


		     (GO CR))
	    ((FITP NEXT)
	      (GO SP))
	    (T (GO CR)))
      SP  (SETQ DOCRFLG NIL)
          (SPACES 1)
          (GO LP)
      CR  (SETQ DOCRFLG T)
          (ENDLINE)
          (GO LP)
      CLISPWORD
          (PROG ((I I)
		 (I0 I0))
	        (SELECTQ NEXT
			 ((THEN
			    ELSE
			    ELSEIF
			      then
			    else
			    elseif)             (* THEN, ELSE, and ELSEIF always start a new 
                                                line.)
			   [SETQ I (ADD1 (ENDLINE (IPLUS I0 (COND
							   ((OR (EQ NEXT (QUOTE
									     THEN))
								(EQ NEXT (QUOTE
									     then)))
							     3)
							   (T 1]

          (* Note that in most cases, I will be reset again in subprint after printing 
          the CLISPWORD. It will remain this value only if the nexxt expression wont 
          fit.)


			   (SETQ E (SUBPRINT E BRFLG (SUBPRINT1 (CDR E)
								(QUOTE IFWORD)
								END)))
			   (RETURN))
			 ((AND OR and or)

          (* So when new left margin is coputed in next cond, it will be based on 
          inner expression.)


			   (SETQ I0 I)
			   (SETQ TEM (SUBPRINT1 (CDR E)
						NIL END))
			   (GO SKIP))
			 ((! !!)
			   (SETQ TEM (CDDR E))
			   (GO SKIP))
			 NIL)
	        (SETQ TEM (SUBPRINT1 (CDR E)
				     (QUOTE FORWORD)
				     END))
	    SKIP[SETQ I (ADD1 (COND
				((NEQ CRCNT0 CRCNT)

          (* Last expression involved a carriae return, so start on new line, e.g. FOR 
          X IN (FOO (FIE) (FUM)) DO --)


				  (ENDLINE (IPLUS I0 2)))
				((NOT (FITP E NIL TEM))

          (* If the segment of the list between here and the next CLISPFORWORD will 
          not fit, carriage return now.)


				  (ENDLINE (IPLUS I0 2)))
				(T (SPACES 1)
				   (POSITION]
	        (SETQ CRCNT0 CRCNT)
	        (SETQ E (SUBPRINT E BRFLG TEM)))
          (GO LP0)

          (* We are now in the position of just having printed the element bbefore E, 
          and are ready to look ahead at the next one, so go to LP0.)


      ])

(SUBPRINT1
  [LAMBDA (E X END)

          (* Searches E to END for an element that is a ember of L.)


    (PROG (TEM)
      LP  (COND
	    ((OR (EQ E END)
		 (NLISTP E))
	      (RETURN E))
	    ((AND (LITATOM (CAR E))
		  (SETQ TEM (GETP (CAR E)
				  (QUOTE CLISPWORD)))
		  (OR (NULL X)
		      (EQ (CAR TEM)
			  X)))
	      (RETURN E)))
          (SETQ E (CDR E))
          (GO LP])

(SUBPRINT2
  [LAMBDA (E END)
    (PROG ((N 0)
	   L)
      LP  (COND
	    ((OR (EQ E END)
		 (NLISTP E))
	      (RETURN E))
	    ((NOT (LITATOM (CAR E)))
	      (SETQ E (CDR E))
	      (GO LP)))
          (SETQ L (DUNPACK (CAR E)
			   CHCONLST))
          (SETQ E (CDR E))
      LP1 [COND
	    ((NULL L)
	      (COND
		((ZEROP N)
		  (RETURN E)))
	      (GO LP))
	    ((EQ (CAR L)
		 (QUOTE <))
	      (SETQ N (ADD1 N)))
	    ((EQ (CAR L)
		 (QUOTE >))
	      (SETQ N (SUB1 N]
          (SETQ L (CDR L))
          (GO LP1])

(PRINTPROG
  [LAMBDA (E BRFLG)
    (PROG (V (I (IPLUS (POSITION)
		       -3))
	     CLISPTEM)

          (* Resets I to column corresponding to to the 'R' in 'PROG'.
          This is the column PROG labels start in.)


          (SPACES 1)
          (PROG ((I (IPLUS I 4)))
	        (SUPERPRINT (CAR E)
			    (AND (NULL (SETQ E (CDR E)))
				 BRFLG)))       (* Prints PROG variables.)
      LP  (COND
	    ((NULL E)
	      (RETURN)))
      LP1 (ENDLINE)
          (COND
	    ((NULL E)                           (* ENDLINE resets E when it sees a comment.)
	      (RETURN))
	    ((NLISTP (CAR E))
	      (GO ATM)))
          (SPACES 4)
      IN  (PROG ((I (IPLUS I 4)))
	        (SUPERPRINT (CAR E)
			    (AND (NULL (SETQ E (CDR E)))
				 BRFLG)))
          (GO LP)
      ATM (SETQ V (POSITION))
          (SETQ CLISPTEM NIL)
          (AND CLISPFLG (STRPOS (QUOTE "_")
				(CAR E))
	       (SETQ CLISPTEM (CAR E))
	       (SPACES 4))

          (* This atom is not a prog label but an CLISP form, e.g. FOO_NIL.
          Space it over to line up with the prog clauses.)


          (PRIN2 (CAR E))                       (* Print the label.)
          (COND
	    ((NULL (SETQ E (CDR E)))
	      (RETURN))
	    ((NLISTP (CAR E))                   (* Two labels in a row.)
	      (ENDLINE)
	      (GO ATM))
	    [CLISPTEM (COND
			((EQ (NTHCHAR CLISPTEM -1)
			     (QUOTE _))

          (* The next element is part of this CLISP expression and should be printed 
          on the same line, e.g. FOO_ (FIE))


			  )
			(T (ENDLINE)
			   (SPACES 4]
	    ((ILESSP [SETQ V (IPLUS 4 V (IMINUS (POSITION]
		     0)                         (* Long label.)
	      (GO LP1)

          (* Necessary to go back to LP1 rather than just do the ENDLINE follwwed by 4 
          spaces because ENDLINE may reset E if a comment is next.)


	      )
	    (T (SPACES V)))
          (GO IN])

(ENDLINE
  [LAMBDA (N)
    [COND
      ((AND DEF (LISTP E)
	    (LISTP (CAR E))
	    (EQ (CAAR E)
		COMMENTFLG)
	    (NEQ HEAD (QUOTE SELECTQ))
	    (NEQ HEAD (QUOTE COND)))            (* A comment.)
	(SUPERPRINT (CAR E))
	(SETQ E (CDR E))
	(ENDLINE N))
      (T (SETQ CRCNT (ADD1 CRCNT))

          (* Used to tell SUBPRINT that a carraiger return was performed, i.e. no 
          longer are on same line as before.)


	 (TERPRI)
	 (COND
	   (PRETTYTABFLG (RPTQ (IQUOTIENT (OR N I)
					  8)
			       (PRIN1 (QUOTE %	)))
			 (SPACES (IREMAINDER (OR N I)
					     8))
			 (POSITION NIL (OR N I)))
	   (T (SPACES (OR N I]
    N])

(TAB
  [LAMBDA (POS MINSPACES FILE)
    (PROG (X)
          (SPACES (COND
		    ((IGREATERP (IPLUS (SETQ X (POSITION FILE))
				       (OR MINSPACES 1))
				POS)
		      (TERPRI FILE)
		      POS)
		    (T (IDIFFERENCE POS X)))
		  FILE])

(READARRAY
  [LAMBDA (N1 N2)
    (PROG (X (A (ARRAY N1 N2))
	     M)
      LP  (COND
	    ((NEQ (READC)
		  (QUOTE %())
	      (GO LP)))
          (SETQ M 1)
      LP1 (COND
	    ((NOT (IGREATERP M N1))
	      (SETA A M (READ))
	      (SETQ M (ADD1 M))
	      (GO LP1))
	    ((NULL (READ))

          (* PRINTARRAY writes a NIL if there are no elements in the array for which 
          the left half must be set using SETD, otherwise it writes a T.)


	      (GO OUT)))
          (SETQ M (ADD1 N2))
      LP2 (COND
	    ((NOT (IGREATERP M N1))
	      (SETD A M (READ))
	      (SETQ M (ADD1 M))
	      (GO LP2)))
      OUT (READ)                                (* Reads the final right parentheses surrounding
                                                the elements of the array.)
          (RETURN A])

(FITP
  [LAMBDA (X TAILFLG ENDTAIL)

          (* Value is T indicates do not perform carriage return before continuing 
          printing, NIL means do. i.e. doesnt fit.
          There are two cases, one where X is a tail 
          (only called for the first tail, i.e. CDR of an exprssion) and the second 
          where it is an element. They differ in their treatment of linear lists of 
          atoms. If one is about to print (FOO A B C D E F) and it wont fit on a line, 
          then do a carriage return and staat printing.
          However, if A B C D E F doesnt fit, doesnt mean to do a carriage return 
          (and then line all the atoms up in a column). The idea is that long lists 
          are given as much room as possible (the first carriage return) but not at 
          the expense of making them be vertical.)


    (PROG ((N (IPLUS LASTCOL (IMINUS (POSITION))
		     -1)))
          (RETURN (COND
		    (TAILFLG                    (* igreaterp used to compare with 6 kept it 
                                                consistent for sourrce compare.)
			     (AND (IGREATERP N (IPLUS AVERAGEVARLENGTH 2))
				  (FITP1 X N ENDTAIL)))
		    (T (FITP2 X N ENDTAIL])

(FITP1
  [LAMBDA (TAIL N ENDTAIL N1)

          (* ENDTAIL specifies the end of TAIL. This option is used when printing 
          CLISP eexpressions where it is necessary to know if a certain portion of a 
          lst will fit , i.e. between two clispwords.)

                                                (* Checks to see if TAIL could fit in N spaces.)
    (PROG ((M 0)
	   (FLG T))
      LP  (COND
	    [(OR (NLISTP TAIL)
		 (EQ TAIL ENDTAIL))

          (* M is number of characters (plus spaces) in atomic arguments encountered 
          before first non-atomic form or end of TAIL.
          see COMMENT in FITP)


	      (RETURN (OR TAILFLG (ILESSP M N]
	    [(NLISTP (CAR TAIL))

          (* We have already checked to see if AN average length variable could fit 
          before calling FITP1.)


	      (AND FLG (SETQ M (IPLUS M (ADD1 (COND
						((ILESSP N #CAREFULCOLUMNS)

          (* When getting near right margin, actually perform the nchars check.
          #CAREFULCOLUMNS is initially set to 20 
          (it can be set to 100 meaning always perform the nchars check, but this 
          slows down the prettyprinting))


						  (NCHARS (CAR TAIL)
							  T))
						(T 
                                                (* Initially 4)
						   AVERAGEVARLENGTH]
	    ((NULL (FITP2 (CAR TAIL)
			  (OR N1 N)))

          (* The extra argument to FITP1 is for use in connectionwith 
          CLISPPRETTYWORDS, e.g. FOR, IF, etc. Normally, we figure that any lists can 
          be printed at the position corresponding to the first argument, ut with 
          FOR's and IF's et al, they would always be preceded by the corresponding 
          CLISP word.)


	      (RETURN NIL))
	    (T 

          (* Non-atomic form reached, stop counting variables since after this will be 
          in vertical format anyway.)


	       (SETQ FLG NIL)))
          (SETQ TAIL (CDR TAIL))
          (GO LP])

(FITP2
  [LAMBDA (X N ENDTAIL)
    (PROG (NC)
          (RETURN (COND
		    ((EQ (CAR X)
			 (QUOTE *))
		      T)
		    [(LISTP (CAR X))            (* Non-atomic CAR of form, e.g. COND clause, 
                                                open lambda, etc.)
		      (COND
			((FITP2 (CAR X)
				(SETQ N (SUB1 N)))
                                                (* SUB1 for the extra left parentheses.)
			  (OR (NULL (CDR X))
			      (FITP1 (CDR X)
				     (SUB1 N)
				     ENDTAIL]
		    ([ILESSP N (IPLUS 2 (COND
					((ILESSP N #CAREFULCOLUMNS)
					  (SETQ NC (NCHARS (CAR X)
							   T)))
					(T (IPLUS (SETQ NC AVERAGEFNLENGTH)
						  3]

          (* Checks to see if there is space for function name and two parentheses.
          when there are more than #CAREFULCOLUMNS columns left, approximate using 
          value of AVERAGEFNLENGTH. We add 3 to it here just to guarad against a long 
          name at the last minute, i.e. right margin)


		      NIL)
		    ((NULL (CDR X))
		      T)
		    ((SELECTQ (CAR X)
			      (COND
				(* The (IPLUS N -2)
				   corresponds to what I would be decremented
				   on the recursive call to superprint.)
				(SETQ N (IPLUS N -2)))
			      (FUNCTION (SETQ N (IPLUS N -2))

          (* 21= the 8 characters in 'FUNCTION' plus the 6 characters in 'LAMBDA' plus 
          3 characters (minimum) for LAMBDA arglist, plus two parens, and two spaces)


					(IGREATERP N 21))
			      ([LAMBDA NLAMBDA]
				(SETQ N (IPLUS N -2))

          (* 11 = 6 characters for LAMBDA plus paren, plus space, plus three 
          characters for arglist.)


				(IGREATERP N 11))
			      (SETQ (SETQ N (IPLUS N -2))
                                                (* 6 = 4 characters in SETQ plus paren, plus 
                                                space)
				(IGREATERP N (IPLUS 6 AVERAGEVARLENGTH)))
			      (IGREATERP (SETQ N (IPLUS N (IMINUS NC)
							-2))
					 (ADD1 AVERAGEFNLENGTH)))

          (* the default clause in the selectq checks to see if function and at least 
          one atomic argument (we know there is at least one) will fit.
          The -2 corresponds to the left paren and the space.
          i dont think the add1 should be there, but in old algorithm, it was a 6, and 
          i wanted files to look exactly the same with new algorithm when 
          #CAREFULCOLUMNS was set to 0)



          (* The call to FITP1 checks to see if using normal alignment algorithm, the 
          expression can fit.)


		      (FITP1 (CDR X)
			     N ENDTAIL (AND (OR (EQ [CAR (SETQ X (GETP X (QUOTE CLISPWORD]
						    (QUOTE IFWORD))
						(EQ (CAR X)
						    (QUOTE FORWORD)))
					    (IPLUS N (IMINUS NC)
						   -1])

(WIDEPAPER
  [LAMBDA (FLG)
    (PROG1 WIDEPAPERFLG (COND
	     ((SETQ WIDEPAPERFLG FLG)
	       (LINELENGTH (SETQ FILELINELENGTH 120))
	       (SETQ FIRSTCOL 80)
	       (SETQ PRETTYLCOM 28))
	     (T (LINELENGTH (SETQ FILELINELENGTH 72))
		(SETQ FIRSTCOL 48)
		(SETQ PRETTYLCOM 14])

(NEWFILE?
  [LAMBDA (NAME CHANGEDLST)
    (AND (LITATOM NAME)
	 (PROG (TEM)
	       (SETQ TEM (SELECTQ CHANGEDLST
				  ((T VARS)

          (* The actual updating of the file properties is not performed until either 
          a FILES?, CLEANUP, or a call to ADDFILE, e.g. a LOAD or MAKEFILE.)


				    (QUOTE CHANGEDVARSLST))
				  ((NIL FNS FN)
				    (QUOTE CHANGEDFNSLST))
				  CHANGEDLST))
	       (AND NEWFILE?USERFN (FMEMB TEM NEWFILE?USERFN)
		    (NEWFILE?USERFN NAME))
	       (RPLACA TEM (CONS NAME (CAR TEM)))
	       (AND LISPXHIST (UNDOSAVE (LIST (QUOTE /RPLACA)
					      (CAR TEM))
					LISPXHIST))
	       (RETURN NAME)

          (* Undone by smashing with NIL, so that each call to NEWFILE? can be handled 
          independently.)


	   ])

(UPDATEFILES
  [LAMBDA (PRLST FLST)
    (MAPC (CAR (QUOTE PRETTYTYPELST))
	  (FUNCTION (LAMBDA (X)
	      (/RPLACA (CAR X)
		       (UPDATEFILES1 (CAAR X)
				     (CADR X)
				     (CDR (ASSOC (CAR X)
						 PRLST))
				     FLST])

(UPDATEFILES1
  [LAMBDA (L TYPE L0 FLST)

          (* Value is a list of those elements on L that were NOT updated.)


    (PROG (L1 L2)
          [MAP L (FUNCTION (LAMBDA (L)
		   (AND (CAR L)
			(NOT (NEWFILE0 (CAR L)
				       (CDR L)))
			(SETQ L1 (CONS (CAR L)
				       L1]      (* Removes duplicates and NIL's.)
          (COND
	    ((NULL L1)
	      (RETURN NIL)))
          [MAPC FILELST (FUNCTION (LAMBDA (FILE)
		    (NEWFILE1 FILE (COND
				((NOT (FMEMB (CDAR (GETP FILE (QUOTE FILEDATES)))
					     FLST))
				  L1)
				(T 

          (* For this file, only update those elements that were on before the file 
          operation. e.g. suppose you EDIT FOO1 then do LOADFNS 
          (FOO2 FOO), FOO gets updated for FOO1 but not for FOO2.)


				   (INTERSECTION L1 L0)))
			      TYPE]
          [RETURN (MAPCONC L1 (FUNCTION (LAMBDA (X)
			       (AND (NOT (NEWFILE0 X L2))
				    (LIST X]    (* L2 is a list of those elements found.)
      ])

(NEWFILE0
  [LAMBDA (X Y)
    (COND
      ((ATOM X)
	(FMEMB X Y))
      (T (MEMBER X Y])

(NEWFILE1
  [LAMBDA (FILE LST TYPE)

          (* LST is a lst of names. TYPE indicates what they are, e.g. FNS, VARS, etc, 
          and is used in NEWFILE2 to determine whether or not to xpand PRETTYMACROS.
          NEWFILE1 updates the property lit for FILE for each element in LST 
          'contained' in FILE. Also adds such entries to L2, bound in UPDATEFILES1.)


    (PROG (X (UPDATEFLG T))
          [COND
	    ([OR (NULL LST)
		 (NLISTP (SETQ X (GETP FILE (QUOTE FILE]
                                                (* Occurs for compiled files for which 
                                                interpreted version has also been loaded.)
	      (RETURN NIL))
	    ((OR (EQ TYPE T)
		 (EQ TYPE (QUOTE VARS)))
	      (NEWFILE1A (CAAR X]
          (NEWFILE2 LST (CAAAR X)
		    TYPE T])

(NEWFILE1A
  [LAMBDA (Y)

          (* The value of LST is a list of function or variables that have been 
          chaged. If Y is on this list, it is added to L2.
          X is the value for prorty FILE for the file FILE.
          If Y is anot on X, it is added to X, and FILE removed from NOTCMPILEDFILES 
          and/or NOTLISTEDFILES when necessary.)


    [AND (NEWFILE0 Y LST)
	 (SETQ L2 (CONS Y L2))
	 (COND
	   ((NEWFILE0 Y (CDR X))                (* ALREADY THERE)
	     NIL)
	   (T [COND
		((NULL (CDR X))                 (* First one.)
		  (/RPLACA (QUOTE NOTLISTEDFILES)
			   (REMOVE FILE NOTLISTEDFILES))
		  (/RPLACA (QUOTE NOTCOMPILEDFILES)
			   (REMOVE FILE NOTCOMPILEDFILES]
	      (/NCONC1 X Y]
    NIL])

(NEWFILE2
  [LAMBDA (NAME COMS TYPE UPDATEFLG)

          (* Returns T if NAME is 'CONTAINED' in COMS.
          If NAME is NIL, then value is a list of all of the functions contained in 
          COMS. If NAME=T, value is T if there are any elements of type TYPE, 
          otherwise NIL (this feature is used for deciding whether or not 
          (and how) to compile files.) Called by FILEFNSLST 
          (which is used by BRECOMPILE) and by NEWFILE1.)



          (* When UPDATEFLG=T, NAME is a list of elements, NEWFILE2 checks each 
          element on the list and if contaied in this file, NEWFILE2 calls NEWFILE1a 
          to update the file property and perform other bookkeeping.
          In this case, the value of NEWFILE2 is NIL.)


    (AND (LISTP COMS)
	 (PROG (COM TEM TEM1 VAL)
	       (AND (EQ TYPE NIL)
		    (SETQQ TYPE FNS))
	       (AND (EQ TYPE T)
		    (SETQQ TYPE VARS))
	   LP  (COND
		 ((NULL COMS)
		   (RETURN VAL))
		 ((ATOM (SETQ COM (CAR COMS)))
		   (COND
		     ((NEQ TYPE (QUOTE VARS)))
		     ((NULL NAME)               (* Collect the VARS. In this case, want to go on
                                                scanning commands.)
		       (SETQ VAL (NCONC1 VAL COM)))
		     ((OR (EQ NAME T)
			  (EQ NAME COM))
		       (RETURN T))
		     (UPDATEFLG (NEWFILE1A COM)))
		   (GO LP1))
		 ((EQ TYPE (CAR COM))
		   [COND
		     [(NULL NAME)               (* Collec the types.)
		       (SETQ VAL (NCONC VAL (APPEND (PRETTYCOM1 COM]
		     [(EQ NAME T)
		       (COND
			 ((PRETTYCOM1 COM)

          (* Being used as a predicate to ask if there are any of type type.
          The call to PRETTYCOM1 returns the argument to the command, which may turn 
          out to be NIL, e.g. (FNS * FOOFNS) where FOOFNS=NIL.)


			   (RETURN T]
		     ((EQ TYPE (QUOTE VARS))    (* VARS have to be treated specially.)
		       (GO NXT))
		     (T (SETQ TEM (PRETTYCOM1 COM))
			(COND
			  (UPDATEFLG 

          (* The MAPC returns NIL so the 'serach' goes on, i.e. there may be other 
          commands which contain elements of the changedlst.)


				     (MAPC TEM (FUNCTION NEWFILE1A)))
			  ((NEWFILE0 NAME TEM)
                                                (* E.G. Called from WHEREIS.)
			    (RETURN T]
		   (GO LP1)))
	   NXT [COND
		 ((EQ TYPE (QUOTE VARS))
		   [COND
		     ((EQ (CADR COM)
			  (QUOTE *))
		       (COND
			 ((EQ NAME (CADDR COM))
			   (RETURN T))
			 (UPDATEFLG (NEWFILE1A (CADDR COM]
		   (COND
		     ((OR (EQ (CAR COM)
			      (QUOTE VARS))
			  (EQ (CAR COM)
			      (QUOTE ADDVARS)))
		       (SETQ TEM (PRETTYCOM1 COM))

          (* Note that if the value of the variable is mentioned in the command, e.g. 
          (VARS -- (FOO &) --) then editing FOO does not change the file.
          However, if TYPE is 'PRED, then want to return T.
          This is the case when called from WHEREIS.)


		       (COND
			 [UPDATEFLG 

          (* NAME iss a list of variable names. For each variable on TEM, perform 
          updating if also on NAME.)


				    (MAPC TEM (FUNCTION (LAMBDA (Y)
					      (COND
						((ATOM Y)
						  (NEWFILE1A Y))
						((FMEMB (CAR Y)
							NAME)

          (* This variable is initialized in the file, therefore remove it from 
          CHANGEDVARSLST. However, do not update the file property.)


						  (SETQ L2 (CONS (CAR Y)
								 L2]
			 ((OR (FMEMB NAME TEM)
			      (FASSOC NAME TEM))
			   (RETURN T)))
		       (GO LP1))
		     ((AND (EQ (CAR COM)
			       (QUOTE PROP))
			   (EQ (CADDR COM)
			       (QUOTE *)))

          (* E.g. (PROP OPD * OPCODES) When you EDIT OPCODES, changes the file.)


		       [COND
			 ((EQ NAME (CADDDR COM))
			   (RETURN T))
			 (UPDATEFLG (NEWFILE1A (CADDDR COM]
		       (GO LP1]
	       [COND
		 ((EQ (CAR COM)
		      (QUOTE COMS))
		   (SETQ COMS (APPEND (PRETTYCOM1 COM)
				      (CDR COMS)))
		   (GO LP))
		 ((SETQ TEM (FASSOC (CAR COM)
				    PRETTYMACROS))
		   (COND
		     ([NULL (SETQ TEM1 (GETP (CAR COM)
					     (QUOTE PRETTYTYPE]
		       (SETQ COMS (NCONC (SUBPAIR (CADR TEM)
						  (CDR COM)
						  (CDDR TEM)
						  T)
					 (CDR COMS)))
		       (GO LP))
		     ((SETQ TEM1 (APPLY* TEM1 COM TYPE NAME))

          (* Value of property should be function of two arguments, the command and 
          TYPE. The result of applying TEM1 to COM and TYPE should be a list of the 
          elements of that TYPE.)



          (* The third argument to the PRETTYTYPE function is Peter's option and is 
          not yet documented. Allows him to write slightly more clever function so 
          they dont have to just compute a list of all of the elements.
          however, function has to know a little bit about internal convention of file 
          package, namely that when NAME is a list, it must return a list of all 
          elements that are contained on NAME and also in this command.)


		       (COND
			 [(NULL NAME)           (* NAME=NIL means want list of all elements of 
                                                type TYPE.)
			   (SETQ VAL (NCONC VAL (APPEND TEM1]
			 ((EQ NAME T)
			   (RETURN T))
			 (UPDATEFLG 

          (* NAME is the same as LST higher up, and is a list of the elements of 
          interest, i.e. those that were changed..)


				    (MAPC TEM1 (FUNCTION NEWFILE1A)))
			 ((NLISTP TEM1)

          (* E.g. TEM1 returned NIL if wasnt there, T or name of thing if was.)


			   TEM1)
			 ((NEWFILE0 NAME TEM1)

          (* TEM1 is just set up to return a list of elements present, so must check 
          and see if NAME is among them.)


			   (RETURN T]
	   LP1 (SETQ COMS (CDR COMS))
	       (GO LP])

(WHEREIS
  [LAMBDA (X TYPE FILES)
    (COND
      ((NULL TYPE)
	(SETQQ TYPE FNS))
      ((EQ TYPE T)
	(SETQQ TYPE VARS)))
    (AND X (SUBSET (COND
		     ((EQ FILES T)
		       (APPEND FILELST SYSFILES))
		     ((NULL FILES)
		       FILELST)
		     (T FILES))
		   (FUNCTION (LAMBDA (FILE)
		       (PROG ((COMS (FILECOMS FILE (QUOTE COMS)))
			      FNS VARS FNLST COMLST)
			     [SETQ COMLST (COND
				 ((LISTP (CAR COMS)))
				 (T 

          (* Note that this version of WHEREIS works for old files, i.e. FNS and VARS, 
          as well as COMS. After a while, can remove the extra code)


				    (SETQ FNS (FILECOMS FILE (QUOTE FNS)))
				    (SETQ VARS (FILECOMS FILE (QUOTE VARS)))
				    (SETQ FNLST (LISTP (CAR FNS)))
				    (LISTP (CAR VARS]
			     (RETURN (OR (AND (EQ TYPE (QUOTE VARS))
					      (OR (EQ X COMS)
						  (EQ X VARS)))
					 (AND (EQ TYPE (QUOTE FNS))
					      (MEMB X FNLST))
					 (NEWFILE2 X COMLST TYPE])

(FILECOMS
  [LAMBDA (FL X)
    (PROG (TEM)
          (SETQ FL (NAMEFIELD FL))
          (RETURN (COND
		    ([AND (NULL X)
			  (LISTP (SETQ TEM (GETP FL (QUOTE FILE]
		      (CAAR TEM))
		    (T (PACK (LIST FL (OR X (QUOTE COMS])

(FILEFNSLST
  [LAMBDA (FILE)
    (NEWFILE2 NIL (CAR (FILECOMS FILE))
	      (QUOTE FNS])

(GETFILEMAP
  [LAMBDA (FILE FL)

          (* Value is map for FILE either obtained from the file itself, or from its 
          property list.)

                                                (* FL is (NAMEFIELD FL T))
    (AND USEMAPFLG (PROG (TEM)
		         (RETURN (COND
				   ([EQ FILE (CAR (SETQ TEM (GETP FL (QUOTE FILEMAP]
				     (CDR TEM))
				   ((PROG1 [AND (EQ (CAR (SETQ TEM (READ NIL FILERDTBL)))
						    (QUOTE FILECREATED))
						(NUMBERP (SETQ TEM (CADDDR TEM)))
						(PROGN (SFPTR FILE TEM)
						       (EQ (CAR (SETQ TEM (READ NIL FILERDTBL)))
							   (QUOTE FILEMAP]
					   (SFPTR FILE 0))
				     (CADR TEM])
)
  (RPAQ BRLST)
  (RPAQ PRETTYMACROS)
  (RPAQQ COMMENTFLG *)
  (RPAQQ **COMMENT**FLG "  **COMMENT**  ")
  (RPAQ PRETTYFLG T)
  (RPAQQ #RPARS 4)
  (RPAQQ SYSPROPS
	 (ACCESSFN ADVICE ADVISED ALIAS AMAC BLKLIBRARYDEF BRKINFO BROADSCOPE BROKEN BROKEN-IN 
		   CLISPCLASS CLISPCLASSDEF CLISPFORM CLISPINFIX CLISPNEG CLISPTYPE CLISPWORD 
		   CLMAPS CODE CONVERT COREVAL CROPS CTYPE EDIT-SAVE EXPR FILE FILEHISTORY 
		   FILEDATES FILEDEF FILEGROUP FILEMAP FILETYPE HISTORY I.S.TYPE INFO LASTVALUE 
		   LISPFN MACRO MAKE NAMESCHANGED NARGS OLDVALUE OPD PRETTYTYPE READVICE SETFN 
		   SUBR UBOX UNARYOP VALUE \DEF))
  (RPAQ CHANGEDFNSLST)
  (RPAQ CHANGEDVARSLST)
  (RPAQQ PRETTYTYPELST ((CHANGEDFNSLST FNS "functions")
	  (CHANGEDVARSLST VARS)))
  (RPAQ CLISPIFYPRETTYFLG)
  (RPAQ PRETTYTRANFLG)
  (RPAQQ PRETTYCOMSPLST
	 (VARS PROP IFPROP COMPROP COMPROP* P DECLARE PD ADDVARS USERMACROS FNS ARRAY E COMS 
	       ADVISE ADVICE BLOCKS))
  (RPAQ FONTCHANGEFLG)
  (RPAQ CHAR37 (CHARACTER 37))
  (RPAQ PRETTYTABFLG T)
  (RPAQQ DECLARECOMLST (DOCOPY DOEVAL@COMPILE DOEVAL@LOAD DONTCOPY DONTEVAL@COMPILE 
			       DONTEVAL@LOAD EVAL@COMPILE EVAL@LOAD COPY COPY COMPILERVARS))
  (RPAQ USEMAPFLG T)
  (RPAQ NEWFILE?USERFN)
  (RPAQ WIDEPAPERFLG)
  (RPAQ AVERAGEVARLENGTH 4)
  (RPAQ AVERAGEFNLENGTH 5)
  (RPAQ #CAREFULCOLUMNS 0)
  (WIDEPAPER)
  [RPAQQ PRETTYBLOCKS
	 ((PRETTYPRINTBLOCK PRETTYPRINT PRETTYPRINT1 PRETTYPRINT2 (ENTRIES PRETTYPRINT)
			    (LOCALFREEVARS PRETTYDEFLG FNSLST ADRLST)
			    (GLOBALVARS FONTCHANGEFLG DEFAULTFONTSTR LAMBDAFONTSTR)
			    (SPECVARS FNSLST))
	  (PRETTYBLOCK PRINTDEF SUPERPRINT SUBPRINT SUBPRINT1 SUBPRINT2 PRINTPROG RPARS ENDLINE 
		       FITP FITP1 FITP2 COMMENT1 COMMENT2 TAB (ENTRIES PRINTDEF)
		       (RETFNS SUPERPRINT)
		       (LOCALFREEVARS I LASTCOL HEAD E TAILFLG EXPR DEF CRCNT PRETTYDEFLG 
				      FNSLST)
		       (BLKLIBRARY GETP)
		       (GLOBALVARS FONTCHANGEFLG FONTFNS FONTWORDS USERFONTSTR CLISPFONTSTR 
				   SYSTEMFONTSTR DEFAULTFONTSTR LAMBDAFONTSTR COMMENTFONTSTR 
				   CHAR37 PRETTYTABFLG AVERAGEFNLENGTH AVERAGEVARLENGTH 
				   #CAREFULCOLUMNS))
	  (NEWFILEBLOCK UPDATEFILES UPDATEFILES1 NEWFILE0 NEWFILE1 NEWFILE1A NEWFILE2 
			FILEFNSLST (ENTRIES UPDATEFILES NEWFILE2 FILEFNSLST)
			(LOCALFREEVARS LST L2 X FILE))
	  (NIL TAB (LINKFNS . T)
	       NEWFILE?
	       (NOLINKFNS NEWFILE?USERFN)
	       (GLOBALVARS NEWFILE?USERFN)
	       WIDEPAPER
	       (GLOBALVARS WIDEPAPERFLG FILELINELENGTH]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
  (BLOCK: PRETTYPRINTBLOCK PRETTYPRINT PRETTYPRINT1 PRETTYPRINT2 (ENTRIES PRETTYPRINT)
	  (LOCALFREEVARS PRETTYDEFLG FNSLST ADRLST)
	  (GLOBALVARS FONTCHANGEFLG DEFAULTFONTSTR LAMBDAFONTSTR)
	  (SPECVARS FNSLST))
  (BLOCK: PRETTYBLOCK PRINTDEF SUPERPRINT SUBPRINT SUBPRINT1 SUBPRINT2 PRINTPROG RPARS ENDLINE 
	  FITP FITP1 FITP2 COMMENT1 COMMENT2 TAB (ENTRIES PRINTDEF)
	  (RETFNS SUPERPRINT)
	  (LOCALFREEVARS I LASTCOL HEAD E TAILFLG EXPR DEF CRCNT PRETTYDEFLG FNSLST)
	  (BLKLIBRARY GETP)
	  (GLOBALVARS FONTCHANGEFLG FONTFNS FONTWORDS USERFONTSTR CLISPFONTSTR SYSTEMFONTSTR 
		      DEFAULTFONTSTR LAMBDAFONTSTR COMMENTFONTSTR CHAR37 PRETTYTABFLG 
		      AVERAGEFNLENGTH AVERAGEVARLENGTH #CAREFULCOLUMNS))
  (BLOCK: NEWFILEBLOCK UPDATEFILES UPDATEFILES1 NEWFILE0 NEWFILE1 NEWFILE1A NEWFILE2 FILEFNSLST
	  (ENTRIES UPDATEFILES NEWFILE2 FILEFNSLST)
	  (LOCALFREEVARS LST L2 X FILE))
  (BLOCK: NIL TAB (LINKFNS . T)
	  NEWFILE?
	  (NOLINKFNS NEWFILE?USERFN)
	  (GLOBALVARS NEWFILE?USERFN)
	  WIDEPAPER
	  (GLOBALVARS WIDEPAPERFLG FILELINELENGTH))
]
(DEFLIST(QUOTE(
  (PRETTY (PRETTY COMMENT))
))(QUOTE FILEGROUP))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA PPT PP* PP PUTPROPS)
  (ADDTOVAR NLAML PRETTYDEF0)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (1759 67514 (PRETTYDEF 1771 . 8169) (PRETTYDEF0 8173 . 8619) (PRETTYDEF1 8623
. 10678) (PRINTDATE 10682 . 12357) (PRINTDATE1 12361 . 13646) (PRINTFNS 13650 . 14073) (
PRETTYCOM 14077 . 20907) (PRETTYVAR 20911 . 21454) (PRETTYCOM1 21458 . 22107) (ENDFILE 22111
. 22184) (MAKEDEFLIST 22188 . 22705) (PUTPROPS 22709 . 22845) (PP 22849 . 23023) (PP* 23027
. 23241) (PPT 23245 . 23456) (PRETTYPRINT 23460 . 28205) (PRETTYPRINT1 28209 . 30793) (
PRETTYPRINT2 30797 . 31890) (PRINTDEF1 31894 . 31952) (PRINTDEF 31956 . 32201) (SUPERPRINT
32205 . 35329) (RPARS 35333 . 35880) (SUBPRINT 35884 . 44980) (SUBPRINT1 44984 . 45390) (
SUBPRINT2 45394 . 45945) (PRINTPROG 45949 . 47895) (ENDLINE 47899 . 48557) (TAB 48561 . 48809)
(READARRAY 48813 . 49649) (FITP 49653 . 50879) (FITP1 50883 . 52867) (FITP2 52871 . 55662)
(WIDEPAPER 55666 . 55958) (NEWFILE? 55962 . 56754) (UPDATEFILES 56758 . 56999) (UPDATEFILES1
57003 . 58001) (NEWFILE0 58005 . 58098) (NEWFILE1 58102 . 58929) (NEWFILE1A 58933 . 59685)
(NEWFILE2 59689 . 65527) (WHEREIS 65531 . 66510) (FILECOMS 66514 . 66752) (FILEFNSLST 66756
. 66847) (GETFILEMAP 66851 . 67511)))))
STOP
