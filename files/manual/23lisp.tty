










                                       1
                             SECTION 23

                     CLISP - CONVERSATIONAL LISP





 23.1  Introduction



The syntax of LISP is very simple, in the sense that it can be
described concisely, but not in the sense that LISP programs are easy
to read or write!  This simplicity of syntax is achieved by, and at
the expense of, extensive use of explicit structuring, namely grouping
through parenthesesization.  Unlike many languages, there are no
reserved words in LISP such as IF, THEN, AND, OR, FOR, DO, BEGIN, END,
                                                         2
etc., nor reserved characters like +, -, *, /, =, _, etc.  This
eliminates entirely the need for parsers and precedence rules in the
LISP interpreter and compiler, and thereby makes program manipulation
of LISP programs straightforward.  In other words, a program that
"looks at" other LISP programs does not need to incorporate a lot of
syntactic information.  For example, a LISP interpreter can be written
in one or two pages of LISP code ([McC1], pp. 70-71).   It is for this
reason that LISP is by far the most suitable, and frequently used,
programming language for writing programs that deal with other
programs as data, e.g., programs that analyze, modify, or construct
other programs.



However, it is precisely this same simplicity of syntax that makes
LISP programs difficult to read and write (especially for beginners).
'Pushing down' is something programs do very well, and people do
poorly.  As an example, consider the following two 'equivalent'
sentences:





**FOOTNOTES**
1
    CLISP was designed and implemented by W. Teitelman.  It is
    discussed in [Tei5].


2
    except for parentheses (and period), which are used for indicating
    structure, and space and end-of-line, which are used for
    delimiting identifiers.




                                 23.1



    "The rat that the cat that the dog that I owned chased caught ate
    the cheese."

                             versus

    "I own the dog that chased the cat that caught the rat that ate
    the cheese."



Natural language contains many linguistic devices such as that
illustrated in the second sentence above for minimizing embedding,
because embedded sentences are more difficult to grasp and understand
than equivalent non-embedded ones (even if the latter sentences are
somewhat longer).  Similarly, most high level programming languages
offer syntactic devices for reducing apparent depth and complexity of
a program: the reserved words and infix operators used in ALGOL-like
languages simultaneously delimit operands and operations, and also
convey meaning to the programmer.  They are far more intuitive than
parentheses.  In fact, since LISP uses parentheses (i.e. lists) for
almost all syntactic forms, there is very little information contained
in the parentheses for the person reading a LISP program, and so the
parentheses tend mostly to be ignored: the meaning of a particular
LISP expression for people is found almost entirely in the words, not
in the structure.  For example, the following expression



            (COND (EQ N 0) 1) (T TIMES N FACTORIAL ((SUB1 N)))



is recognizable as FACTORIAL even though there are five misplaced or
missing parentheses.  Grouping words together in parentheses is done
more for LISP's benefit, than for the programmer's.



CLISP is designed to make INTERLISP programs easier to read and write
by permitting the user to employ various infix operators, IF-THEN-ELSE
statements, FOR-DO-WHILE-UNLESS-FROM-TO-etc. expressions, which are
automatically converted to equivalent INTERLISP expressions when they
are first interpreted.  For example, FACTORIAL could be written in
CLISP:



                (IF N=0 THEN 1 ELSE N*(FACTORIAL N-1))



Note that this expression would become an equivalent COND after it had
been interpreted once, so that programs that might have to analyze or
otherwise process this expression could take advantage of the simple
syntax.



There have been similar efforts in other LISP systems, most notably
the MLISP language at Stanford [Smi1].  CLISP differs from these in
that it does not attempt to replace the LISP syntax so much as to
augment it.  In fact, one of the principal criteria in the design of
CLISP was that users be able to freely intermix LISP and CLISP without



                                 23.2



having to identify which is which.  Users can write programs, or type
in expressions for evaluation, in LISP, CLISP, or a mixture of both.
In this way, users do not have to learn a whole new language and
syntax in order to be able to use selected facilities of CLISP when
and where they find them useful.



CLISP is implemented via the error correction machinery in INTERLISP
(see Section 17).  Thus, any expression that is well-formed from
INTERLISP's standpoint will never be seen by CLISP (i.e., if the user
defined a function IF, he would effectively turn off that part of
CLISP).  This means that interpreted programs that do not use CLISP
constructs do not pay for its availability by slower execution time.
In fact, the INTERLISP interpreter does not 'know' about CLISP at all.
It operates as before, and when an erroneous form is encountered, the
interpreter calls an error routine which in turn invokes the Do-What-
I-Mean (DWIM) analyzer which contains CLISP.  If the expression in
question turns out to be a CLISP construct, the equivalent INTERLISP
form is returned to the interpreter. In addition, the original CLISP
expression, is modified so that it becomes the correctly translated
INTERLISP form.  In this way, the analysis and translation are done
only once.



Integrating CLISP into the INTERLISP system (instead of, for example,
implementing it as a separate preprocessor) makes possible Do-What-I-
Mean features for CLISP constructs as well as for pure LISP
expressions.  For example, if the user has defined a function named
GET-PARENT, CLISP would know not to attempt to interpret the form
(GET-PARENT) as an arithmetic infix operation.  (Actually, CLISP would
never get to see this form, since it does not contain any errors.)  If
the user mistakenly writes (GET-PRAENT), CLISP would know he meant
(GET-PARENT), and not (DIFFERENCE GET PRAENT), by using the
information that PRAENT is not the name of a variable, and that GET-
PARENT is the name of a user function whose spelling is "very close"
to that of GET-PRAENT.  Similarly, by using information about the
program's environment not readily available to a preprocessor, CLISP
can successfully resolve the following sorts of ambiguities:



1)  (LIST X*FACT N), where FACT is the name of a variable, means
    (LIST (X*FACT) N).



2)  (LIST X*FACT N), where FACT is not the name of a variable but
    instead is the name of a function, means (LIST X*(FACT N)), i.e.,
    N is FACT's argument.



3)  (LIST X*FACT(N)), FACT the name of a function (and not the name of
    a variable), means (LIST X*(FACT N)).



4)  cases (1),(2) and (3) with FACT misspelled!






                                 23.3



The first expression is correct both from the standpoint of CLISP
syntax and semantics and the change would be made without the user
being notified.  In the other cases, the user would be informed or
consulted about what was taking place.  For example, to take an
extreme case, suppose the expression (LIST X*FCCT N) were encountered,
where there was both a function named FACT and a variable named FCT.
The user would first be asked if FCCT were a misspelling of FCT.  If
                                                                     3
he said YES, the expression would be interpreted as (LIST (X*FCT) N).
If he said NO, the user would be asked if FCCT were a misspelling of
FACT, i.e., if he intended X*FCCT N to mean X*(FACT N).  If he said
YES to this question, the indicated transformation would be performed.
If he said NO, the system would then ask if X*FCCT should be treated
                                                           4
as CLISP, since FCCT is not the name of a (bound) variable.  If he
said YES, the expression would be transformed, if NO, it would be left
alone, i.e., as (LIST X*FCCT N).  Note that we have not even
considered the case where X*FCCT is itself a misspelling of a variable
name, e.g., a variable named XFCT (as with GET-PRAENT).  This sort of
transformation would be considered after the user said NO to
X*FCCT N -> X*(FACT N).  The graph of the possible interpretations for
(LIST X*FCCT N) where FCT and XFCT are the names of variables, and
FACT is the name of a function, is shown in Figure 23-1 below.











                             Figure 23-1


**FOOTNOTES**
3
    Through this discussion, we speak of CLISP or DWIM asking the
    user.  Actually, if the expression in question was typed in by the
    user for immediate execution, the user is simply informed of the
    transformation, on the grounds that the user would prefer an
    occasional misinterpretation rather than being continuously
    bothered, especially since he can always retype what he intended
    if a mistake occurs, and ask the programmer's assistant to UNDO
    the effects of the mistaken operations if necessary.  For
    transformations on expressions in user programs, the user can
    inform CLISP whether he wishes to operate in CAUTIOUS or
    TRUSTING mode.  In the former case (most typical) the user will
    be asked to approve transformations, in the latter, CLISP will
    operate as it does on type-in, i.e., perform the transformation
    after informing the user.


4
    This question is important because many INTERLISP users already
    have programs that employ identifiers containing CLISP operators.
    Thus, if CLISP encounters the expression A/B in a context where
    either A or B are not the names of variables, it will ask the user
    if A/B is intended to be CLISP, in case the user really does have
    a free variable named A/B.




                                 23.4





































































                                 23.5



The final states for the various terminal nodes shown in the graph
are:



    1:   (LIST (TIMES X FCT) N)

    2:   (LIST (TIMES X (FACT N)))

    3:   (LIST XFCT N)

    4:   (LIST (TIMES X FCCT) N)

    5:   (LIST X*FCCT N)



CLISP can also handle parentheses errors caused by typing 8 or 9 for
'(' or ')'.  (On most terminals, 8 and 9 are the lower case characters
for '(' and ')', i.e., '(' and '8' appear on the same key, as do ')'
and '9'.)  For example, if the user writes N*8FACTORIAL N-1, the
parentheses error can be detected and fixed before the infix operator
* is converted to the INTERLISP function TIMES.  CLISP is able to
distinguish this situation from cases like N*8*X meaning
(TIMES N 8 X), or N*8X, where 8X is the name of a variable, again by
using information about the programming environment.  In fact, by
integrating CLISP with DWIM, CLISP has been made sufficiently tolerant
of errors that almost everything can be misspelled!  For example,
CLISP can successfully translate the definition of FACTORIAL:



               (IFF N=0 THENN1 ESLE N*8FACTTORIALNN-1)



to the corresponding COND, while making 5 spelling corrections and
                             5
fixing the parenthesis error.



This sort of robustness prevails throughout CLISP.  For example, the
                                                        6
iterative statement permits the user to say things like:



**FOOTNOTES**
5
    CLISP also contains a facility for converting from INTERLISP back
    to CLISP, so that after running the above incorrect definition of
    FACTORIAL, the user could 'CLISPIFY' the now correct LISP version
    to obtain (IF N=0 THEN 1 ELSE N*(FACTORIAL N-1)).


6
    This expression should be self explanatory, except possibly for
    the operator OLD, which says X is to be the variable of
    iteration, i.e., the one to be stepped from N to M, but X is not
    to be rebound.  Thus when this loop finishes execution, X will be
    equal to N+1.




                                 23.6



         FOR OLD X FROM M TO N DO (PRINT X) WHILE (PRIMEP X)



However, the user can also write OLD (X_M), (OLD X_M), (OLD (X_M)),
permute the order of the operators, e.g.,
DO PRINT X TO N FOR OLD X_M WHILE PRIMEP X, omit either or both sets
of parentheses, misspell any or all of the operators FOR, OLD, FROM,
TO, DO, or WHILE, or leave out the word DO entirely!  And, of course,
                                           7
he can also misspell PRINT, PRIMEP, M or N!



CLISP is well integrated into the INTERLISP system.  For example, the
above iterative statement translates into an equivalent INTERLISP form
                          8
using PROG, COND, GO, etc.  When the interpreter subsequently
encounters this CLISP expression, it automatically obtains and
                          9
evaluates the translation.  Similarly, the compiler "knows" to compile
the translated form.  However, if the user PRETTYPRINTs his program,
at the corresponding point in his function, PRETTYPRINT "knows" to
print the original CLISP.  Similarly, when the user edits his program,
the editor keeps the translation invisible to the user.  If the user
modifies the CLISP, the translation is automatically discarded and
recomputed the next time the expression is evaluated.



In short, CLISP is not a language at all, but rather a system.  It
plays a role analagous to that of the programmer's assistant (Section
22).  Whereas the programmer's assistant is an invisible intermediary
agent between the user's console requests and the INTERLISP executive,
CLISP sits between the user's programs and the INTERLISP interpreter.






**FOOTNOTES**
7
    In this example, the only thing the user could not misspell is the
    first X, since it specifies the name of the variable of iteration.
    The other two instances of X could be misspelled.


8
    (PROG NIL
          (SETQ X M)
      $$LP(COND
            ((OR (IGREATERP X N)
                 (NOT (PRIMEP X)))
               (RETURN)))
          (PRINT X)
          (SETQ X (ADD1 X))
          (GO $$LP))


9
    See page 23.27, for discussion of how translations are stored.




                                 23.7



Only a small effort has been devoted to defining the core syntax of
CLISP.  Instead, most of the effort has been concentrated on providing
a facility which 'makes sense' out of the input expressions using
context information as well as built-in and acquired information about
user and system programs.  It has been said that communication is
based on the intention of the speaker to produce an effect in the
recipient.  CLISP operates under the assumption that what the user
said was intended to represent a meaningful operation, and therefore
tries very hard to make sense out of it.  The motivation behind CLISP
is not to provide the user with many different ways of saying the same
thing, but to enable him to worry less about the syntactic aspects of
his communication with the system.  In other words, it gives the user
a new degree of freedom by permitting him to concentrate more on the
problem at hand, rather than on translation into a formal and
unambiguous language.





 23.2  CLISP Syntax



Throughout CLISP, a non-atomic form, i.e., a list, can always be
substituted for a variable, and vice versa, without changing the
interpretation.  For example, if the value of (FOO X) is A, and the
value of (FIE Y) is B, then (LIST (FOO X)+(FIE Y)) has the same value
as (LIST A+B).  Note that the first expression consists of a list of
four elements: the atom 'LIST', the list '(FOO X)', the atom '+', and
the list '(FIE X)', whereas the second expression, (LIST A+B),
consists of a list of only two elements: the atom 'LIST' and the atom
'A+B'.  Since (LIST (FOO X)+(FIE Y)) is indistinguishable from
(LIST (FOO X) + (FIE Y)) because spaces before or after parentheses
                                             10
have no effect on the INTERLISP READ program,   to be consistent,
extra spaces have no effect on atomic operands either.  In other
words, CLISP will treat (LIST A+ B), (LIST A +B), and (LIST A + B) the
same as (LIST A+B).





 23.3  Infix Operators



CLISP recognizes the arithmetic infix operators +, -, *, /, and ^.
These are converted to IPLUS, IDIFFERENCE (or in the case of unary





**FOOTNOTES**
10
    CLISP does not use its own special READ program because this would
    require the user to explicitly identify CLISP expressions, instead
    of being able to intermix INTERLISP and CLISP.






                                 23.8



                                            11
minus, IMINUS), ITIMES, IQUOTIENT, and EXPT.   The usual precedence
                                                                  12
rules apply (although these can be easily changed by the user),
i.e., * has higher precedence than + so that A+B*C is the same as
A+(B*C), and both * and / are lower than ^ so that 2*X^2 is the same
as 2*(X^2).  Operators of the same precedence group from left to
right, e.g., A/B/C is equivalent to (A/B)/C.  Minus is binary whenever
possible, i.e., except when it is the first operator in a list, as in
(-A) or (-A), or when it immediately follows another operator, as in
     13 14
A*-B.   



Note that grouping with parentheses can always be used to override the
normal precedence grouping, or when the user is not sure how a
particular expression will parse.



                                                               15
CLISP also recognizes as infix operators =, GT, LT, GE, and LE,   as


**FOOTNOTES**
11
    The I in IPLUS denotes integer arithmetic, i.e., IPLUS converts
    its arguments to integers, and returns an integer value.
    INTERLISP also contains floating point arithmetic functions as
    well as mixed arithmetic functions (see Section 13).  CLISP
    contains a facility for declaring which type of arithmetic is to
    be used, either by making a global declaration, or by separate
    declarations about individual functions or variables.  See section
    on declarations, page 23.30.


12
    The complete order of precedence for CLISP operators is given in
    Figure 23-2, page 23.14.


13
    There are some do-what-I-mean features associated with Unary
    minus, as in (LIST -X Y).  See section on operation, page 23.55.


14
    Note that + in front of a number will disappear when the number is
    read, e.g., (FOO X +2) is indistinguishable from (FOO X 2).  This
    means that (FOO X +2) will not be interpreted as CLISP, or be
    converted to (FOO (IPLUS X 2)).  Similarly, (FOO X -2) will not be
    interpreted the same as (FOO X-2).  To circumvent this, always
    type a space between the + or - and a number if an infix operator
    is intended, e.g., write (FOO X + 2).


15
     Greater  Than,  Less  Than,  Greater than or  Equal to, and  Less
    than or  Equal to, respectively.  GT, LT, GE, and LE are all
    affected by the same declarations as + and *, with the initial
    default to use IGREATERP and ILESSP.




                                 23.9



                                                              16
well as various predicates, e.g., MEMBER, AND, OR, EQUAL, etc.   AND
is higher than OR, e.g., (X OR Y AND Z) is the same as
(X OR (Y AND Z)), and both AND and OR are lower than the other infix
operators, e.g., (X AND Y EQUAL Z) is the same as (X AND (Y EQUAL Z)).
All of the infix predicates have lower precedence than INTERLISP
forms, i.e., (FOO X GT FIE Y) is the same as ((FOO X) GT (FIE Y)),
since it is far more common to apply a predicate to two forms, than to
use a Boolean as an argument to a function, e.g. (FOO (X GT (FIE Y))).
However, again, the user can easily change this.



Note that only single character operators, e.g. +, _, =, etc., can
appear in the  interior of an atom. All other operators must be set
off from identifiers with spaces.  For example, XLTY will not be
                    17
recognized as CLISP.



















**FOOTNOTES**
16
    Currently the complete list is MEMBER, MEMB, FMEMB, ILESSP,
    IGREATERP, LESSP, GREATERP, FGTP, EQ, NEQ, EQP, EQUAL, OR, and
    AND.  New infix operators can be easily added, as described in the
    section on CLISP internal conventions, page 23.59.


17
    In some cases, DWIM will be able to diagnose this situation as a
    run-on spelling error, in which case after the atom is split
    apart, CLISP will be able to perform the indicated transformation.

















                                23.10



                         *             *              *



: is an infix operator used in CLISP for extracting substructures
           18
from lists,   e.g., X:3 specifies the 3rd element of X, (FOO Y)::2
specifies the second tail of (FOO Y), i.e., (CDDR (FOO Y)), and Z:1:2
is the second element of the first element of Z, or (CADAR Z).
Negative numbers may be used to indicate position counting from the
end of a list, e.g., X:-1 is the last element of X, or (CAR (LAST X)),
                                       19
X::-1 is the last tail, i.e., (LAST X).



                         *             *              *



                         
_ is used to indicate assignment, e.g., X_Y translates to
           20 21
(SETQ X Y).      In conjunction with : and ::, _ can also be used to
perform a more general type of assignment, namely one involving
structure modification.  For example, X:2_Y means make the second




**FOOTNOTES**
18
    The record facility, page 23.42, provides another way of
    extracting substructures by allowing the user to assign names to
    the various parts of the structure and then retrieve from or store
    into the corresponding structure by name. The pattern match
    facility, page 23.33, also can be used to extract substructure.
    : is also used to indicate both record and pattern match
    operations.


19
    The interpretation of negative numbers can be explained neatly in
    terms of edit commands: :-n returns what would be the current
    expression after executing the command -n, and ::-n returns what
    would be the current expression after executing -n followed by UP.


20
    If  x does not have a value, and is not the name of one of the
    bound variables of the function in which it appears, spelling
    correction is attempted.  However, since this may simply be a case
    of assigning an initial value to a new free variable, DWIM will
    always ask for approval before making the correction.


21
    Note that an atom of the form X_Y, appearing at the top level of a
    PROG, will not be recognized as an assignment statement because it
    will be interpreted as a PROG label by the INTERLISP interpreter,
    and therefore will not cause an error, so DWIM and CLISP will
    never get to see it.  Instead, one must write (X_Y).




                                23.11



                                                         22 23
element of X be Y, in INTERLISP terms (RPLACA (CDR X) Y).   
                                                24
Negative numbers can also be used, e.g., X:-2_Y.   _ is also used to
indicate assignment in record operations, page 23.42, and pattern
match operations, page 23.33.



_ has different precedence on the left from on the right.  On the
left, _ is a "tight" operator, i.e., high precedence, so that A+B_C is
the same as A+(B_C).  On the right, _ has broader scope so that A_B+C
is the same as A_(B+C).



On typein, $_form (alt-mode_form) is equivalent to set the "last
                 25
thing mentioned".   For example, immediately after examining the value
of LONGVARIABLENAME, the user could set it by typing $_ followed by a
form.  





 23.4  Prefix Operators



CLISP recognizes ' and ~ as prefix operators.   ' means QUOTE
when it is the first character in an identifier, and is ignored when
it is used in the interior of an identifier.  Thus, X='Y means
(EQ X (QUOTE Y)), but X=CAN'T means (EQ X CAN'T), not (EQ X CAN)
followed by (QUOTE T).  This enables users to have variable and
function names with ' in them (so long as the ' is not the first
character).





**FOOTNOTES**
22
    Note that the value of this operation is the value of  rplaca,
    which is the corresponding node.


23
    The user can indicate he wants  /rplaca and  /rplacd used
    (undoable version of  rplaca and  rplacd, see Section 22), or
     frplaca and  frplacd (fast versions of  rplaca and  rplacd, see
    Section 5), by means of declarations (page 23.30). The
    initial default is for  rplaca and  rplacd.


24
    which translates to (RPLACA (NLEFT X 2) Y).


25
    i.e. is equivalent to (SETQ lastword form). See Section 17.




                                23.12



Following ', all operators are ignored for the rest of the identifier,
e.g., '*A means (QUOTE *A), and 'X=Y means (QUOTE X=Y), not
                 26
(EQ (QUOTE X) Y).



On typein, '$ (i.e. 'alt-mode) is equivalent to
(QUOTE value-of-lastword) (see Section 17).  For example, after
calling  prettyprint on LONGFUNCTION, the user could move its
                                           27
definition to FOO by typing (MOVD '$ 'FOO).



~ means NOT.  ~ can negate a form, as in ~(ASSOC X Y), or ~X, or
negate an infix operator, e.g., (A ~GT B) is the same as (A LEQ B).
Note that ~A=B means (EQ (NOT A) B).





















**FOOTNOTES**
26
    To write (EQ (QUOTE X) Y), one writes Y='X, or 'X =Y.  This is one
    place where an extra space does make a difference.


27
    Not (MOVD $ 'FOO), which would be equivalent to
    (MOVD LONGFUNCTION 'FOO), and would (probably) cause a U.B.A.
    LONGFUNCTION error, nor MOVD($ FOO), which would actually move the
    definition of $ to FOO, since DWIM and the spelling corrector
    would never be invoked.















                                23.13



                Order of Precedence of CLISP operators




                        '

                        :

                                                           28
                        _ (left precedence)

                                                           29
                        - (unary), ~

                        ^

                        *, /

                        +, - (binary)

                        _ (right precedence)

                        =

                        INTERLISP forms

                        LT, GT, EQUAL, MEMBER, etc.

                        AND

                        OR

                        IF, THEN, ELSEIF, ELSE

                        iterative statement operators





                             Figure 23-2








**FOOTNOTES**
28
    _ has a different left and right precedence, e.g., A+B_C+D is
    the same as A+(B_(C+D)).  In other words, _ has minimal scope on
    the left and maximal scope on the right.


29
    When ~ negates an operator, e.g., ~=, ~LT, the two operators are
    treated as a single operator whose precedence is that of the
    second operator.  When ~ negates a function, e.g., (~FOO X Y), it
    negates the whole form, i.e., (~(FOO X Y)).




                                23.14



                                             30
 23.5  Constructing Lists - the <,> operators




Angle brackets are used in CLISP to indicate list construction.  The
appearance of a '<' corresponds to a '(' and indicates that a list is
to be constructed containing all the elements up to the corresponding
'>'. For example, <A B <C>> translates to (LIST A B (LIST C)).  !
can be used to indicate that the next expression is to be inserted in
the list as a segment, e.g., <A B ! C> translates to
(CONS A (CONS B C)) and <! A ! B C> to (APPEND A B (LIST C)). !!
is used to indicate that the next expression is to be inserted as a
segment, and furthermore, all list structure to its right in the angle
brackets is to be physically attached to it, e.g., <!! A B> translates
                                                           31 32
to (NCONC1 A B), and <!!A !B !C> to (NCONC A (APPEND B C)).      Note
that <, !, !!, and > need not be separate atoms, for example,
<A B ! C> may be written equally well as < A B !C >.  Also, arbitrary
INTERLISP or CLISP forms may be used within angle brackets.  For
example, one can write <FOO_(FIE X) ! Y> which translates to
(CONS (SETQ FOO (FIE X)) Y).  CLISPIFY converts expressions in  cons,
 list,  append,  nconc,  nconc1,  /nconc, and  /nconc1 into equivalent
CLISP expressions using <, >, !, and !!.



Note: angle brackets differ from other CLISP operators in that they
act more like brackets than operators. For example, <A B 'C>
translates to (LIST A B (QUOTE C)) even though following ', all
                                                     33
operators are ignored for the rest of the identifier.   Note however
that <A B ' C> D> is equivalent to (LIST A B (QUOTE C>) D).










**FOOTNOTES**
30
    The <,> operator was written by P.C. Jackson.


31
    Not (NCONC (APPEND A B) C), which would have the same value, but
    would attach C to B, and not attach either to A.


32
    The user can indicate  /nconc or  /nconc1 be used instead of
     nconc and  nconc1 by declarations.


33
    Only if a previous unmatched < has been seen, e.g.  (PRINT 'A>B)
    will print the atom A>B.




                                23.15



 23.6  IF, THEN, ELSE



CLISP translates expressions employing IF|THEN|ELSEIF|ELSE into
equivalent conditional expressions.  The segment between IF|ELSEIF and
the next THEN corresponds to the predicate of a COND clause, and the
segment between THEN and the next ELSE|ELSEIF as the consequent(s).
ELSE is the same as ELSEIF T THEN.



IF, THEN, ELSE, and ELSEIF are of lower precedence than all infix and
prefix operators, as well as INTERLISP forms, so that parentheses can
be omitted between IF|ELSEIF, and THEN.  For example,
                                                             34
(IF FOO X Y THEN --) is equivalent to (IF (FOO X Y) THEN --).
Similarly, CLISP treats (IF X THEN FOO X Y ELSE --) as equivalent to
(IF X THEN (FOO X Y) ELSE --) because it does not 'make sense' to
evaluate a variable for effect.  In other words, even if FOO were also
the name of a variable, (COND (X FOO X Y)) doesn't make sense.
Essentially, CLISP determines whether the segment between THEN and the
next ELSE|ELSEIF corresponds to one form or several and acts
            35
accordingly.   Thus, (IF -- THEN (FOO X) Y ELSE --) corresponds to a
clause with two consequents.  Similarly, (IF -- THEN FOO_X Y ELSE --)
corresponds to a clause with two consequents, and is equivalent to
                               36
(IF -- THEN (FOO_X) Y ELSE --).














**FOOTNOTES**
34
    If FOO is the name of a variable, IF FOO THEN -- is translated as
    (COND (FOO --)) even if FOO is also the name of a function.  If
    the functional interpretation is intended, FOO should be enclosed
    in parentheses, e.g., IF (FOO) THEN --.  Similary for
    IF -- THEN FOO ELSEIF --.


35
    occasionally interacting with the user to resolve ambiguous cases.


36
    To write the equivalent of a singleton cond clause, i.e., a clause
    with a predicate but no consequent, write either nothing following
    the THEN, or omit the THEN entirely, e.g.,
    (IF (FOO X) THEN ELSEIF --) or (IF (FOO X) ELSEIF --), meaning if
    (FOO X) is not NIL, it is the value of the  cond.




                                23.16



 23.7  Iterative Statements



The following is an example of a CLISP iterative statement:


             (WHILE X_(READ)~='STOP DO (PRINT (EVAL X)))



This statement says "READ an expression and set X to it.  If X is not
equal to the atom STOP, then evaluate X, print the result, and
         37
iterate."



The i.s. (iterative statement) in its various forms permits the user
to specify complicated iterative statements in a straightforward and
visible manner.  Rather than the user having to perform the mental
transformations to an equivalent INTERLISP form using PROG, MAPC,
MAPCAR, etc., the system does it for him.  The goal was to provide a
robust and tolerant facility which could "make sense" out of a wide
class of iterative statements.  Accordingly, the user should not feel
obliged to read and understand in detail the description of each
operator given below in order to use iterative statements.



Currently, the following i.s. operators are implemented: FOR, BIND,
OLD, IN, ON, FROM, TO, BY, WHEN, WHILE, UNTIL, UNLESS, COLLECT, JOIN,
DO, SUM, COUNT, ALWAYS, NEVER, THEREIS, AS, FIRST, FINALLY, EACHTIME.
Their function is explained below.  New operators can be defined as
described on page 23.25.  Misspellings of operators are recognized
and corrected.  The order of appearance of operators is not
          38
important;   CLISP scans the entire statement before it begins to
construct the equivalent INTERLISP form.



DO form             specifies what is to be done at each
                   iteration.  DO with no other operator specifies an



**FOOTNOTES**
37
    The statement translates to:
    (PROG NIL $$LP (COND ((EQ (SETQ X (READ)) (QUOTE STOP)) (RETURN)))
    (PRINT (EVAL X)) (GO $$LP))


38
    DWIM and CLISP are invoked on iterative statements because  car of
    the i.s. is not the name of a function, and hence generates an
    error.  If the user defines a function by the same name as an i.s.
    operator, e.g. WHILE, TO, etc., the operator will no longer have
    the CLISP interpretation when it appears as  car of a form,
    although it will continue to be treated as an i.s. operator if it
    appears in the interior of an i.s.




                                23.17



                   infinite loop.  If some explicit or implicit
                   terminating condition is specified, the value of
                   the i.s. is NIL.  Translate to MAPC or MAP whenever
                   possible.



COLLECT form        like DO, except specifies that the value of
                    form at each iteration is to be collected in a
                   list, which is returned as the value of the i.s.
                   when it terminates.  Translates to MAPCAR or
                   MAPLIST whenever possible.



JOIN form      like DO, except that the values are NCONCed.
                   Translates to MAPCONC or MAPCON whenever
                            39
                   possible.



SUM form            like DO, except specifies that the values of
                    form at each iteration be added together and
                   returned as the value of the i.s., e.g.
                   (FOR I FROM 1 TO 5 SUM I^2) is equal to
                               40
                   1+4+9+16+25.



COUNT pred     like DO, except counts number of times that  pred
                   is true, and returns that count as its value.



ALWAYS pred         like DO, except returns T if the value of
                    pred is non-NIL for all iterations (returns NIL as
                   soon as the value of  pred is NIL), e.g.
                   (FOR X IN Y ALWAYS (ATOM X)) is the same as
                   (EVERY Y (FUNCTION ATOM)).



NEVER pred          like ALWAYS, except returns T if the value of
                    pred is never true, i.e. NEVER pred is the same as
                   ALWAYS ~pred.






**FOOTNOTES**
39
    /NCONC, /MAPCONC, and /MAPCON are used when the declaration
    UNDOABLE is in effect.


40
     iplus,  fplus, or  plus will be used for the translation
    depending on the declarations in effect.




                                23.18



THEREIS pred        returns the first value of the i.v. for which
                    pred is non-NIL, e.g.
                   (FOR X IN Y THEREIS NUMBERP) returns the first
                   number in Y, and is equivalent to
                                                     41
                   (CAR (SOME Y (FUNCTION NUMBERP))).



DO, COLLECT, JOIN, SUM, ALWAYS, NEVER, and THEREIS are examples of a
certain kind of i.s. operator called an  i.s.type.  The  i.s.type
specifies what is to be done at each iteration.  Each i.s. must have
one and only one  i.s.type.  The function  i.s.type, page 23.25,
provides a means of defining additional  i.s.types.



FOR var             specifies the variable of iteration, or i.v.,
                   which is used in conjunction with IN, ON, FROM, TO,
                   and BY.  The variable is rebound for the scope of
                   the i.s., except when modified by OLD as described
                   below.



FOR vars             vars a list of variables, e.g.,
                   FOR (X Y Z) IN --.  The first variable is the i.v.,
                   the rest are dummy variables.  See BIND below.



OLD var             indicates  var is not to be rebound, e.g.,
                   (FOR OLD X FROM 1 TO N DO -- UNTIL --),



BIND var, vars used to specify dummy variables, e.g.,
                   FOR (X Y Z) IN -- is equivalent to
                   FOR X BIND (Y Z) IN --.  BIND can be used without
                   FOR.  For example, in the i.s. shown on page 23.17,
                   X could be made local by writing
                   (BIND X WHILE X_(READ)~='STOP...).



Note:    FOR, OLD, and BIND variables can be initialized by using _,
e.g., (FOR OLD (X_form) BIND (Y_form)...).



IN form             specifies that the i.s. is to iterate down a
                   list with the i.v. being reset to the corresponding



**FOOTNOTES**
41
    THEREIS returns the i.v. instead of the tail (as does the function
     some) in order to provide an interpretation consistent with
    statements such as (FOR I FROM 1 TO 10 THEREIS --), where there is
    no tail.  Note that (SOME Y (FUNCTION NUMBERP)) is equivalent to
    (FOR X  ON Y THEREIS (NUMBERP (CAR X))).




                                23.19



                   element at each iteration.  For example,
                   FOR X IN Y DO -- corresponds to
                   (MAPC Y (FUNCTION (LAMBDA (X) --))).  If no i.v.
                   has been specified, a dummy is supplied, e.g.,
                   IN Y COLLECT CADR is equivalent to
                   (MAPCAR Y (FUNCTION CADR)).



ON form             same as IN except that the i.v. is reset to
                   the corresponding tail at each iteration.  Thus IN
                   corresponds to MAPC, MAPCAR, and MAPCONC, while ON
                   corresponds to MAP, MAPLIST, and MAPCON.



IN OLD var          specifies that the i.s. is to iterate down
                    var, with  var itself being reset to the
                   corresponding tail at each iteration, e.g., after
                   (FOR X IN OLD L DO -- UNTIL --) finishes, L will be
                   some tail of its original value.



IN OLD (var_form)   same as IN OLD  var, except  var is first set
                   to value of  form.



ON OLD var         same as IN OLD  var except the i.v. is reset to the
                   current value of  var at each iteration, instead of
                   to car[var].



ON OLD (var_form)   same as ON OLD  var, except  var is first set
                   to value of  form.



WHEN pred      provides a way of excepting certain iterations.
                   For example, (FOR X IN Y COLLECT X WHEN NUMBERP X)
                   collects only the elements of Y that are numbers.



UNLESS pred         same as WHEN except for the difference in
                   sign, i.e., WHEN Z is the same as UNLESS ~Z.



WHILE pred          provides a way of terminating the i.s.  WHILE
                    pred evaluates  pred before each iteration, and if
                   the value is NIL, exits.



UNTIL pred          Same as WHILE except for difference in sign,
                   i.e., WHILE PRED is equivalent to UNTIL ~PRED.



UNTIL n             n a number, equivalent to UNTIL (i.v. GT n).



                                23.20



FROM form      is used to specify an initial value for a numerical
                   i.v.  The i.v. is automatically incremented by 1
                   after each iteration (unless BY is specified).
                   If no i.v. has been specified, a dummy i.v. is
                   supplied and initialized, e.g.,
                   (COLLECT SQRT FROM 2 TO 5) returns
                   (1.414 1.732 2.0 2.236).



TO form             is used to specify the final value for a
                   numerical i.v.  If FROM is not specified, the
                   i.v. is initialized to 1.  If no i.v. has been
                   specified, a dummy i.v. is supplied and
                   initialized.  If BY is not specified, the i.v.
                   is automatically incremented by 1 after each
                             42
                   iteration.   When the i.v. is definitely being
                   incremented, i.e. either BY is not specified, or
                   its operand is a positive number, the i.s.
                   terminates when the i.v. exceeds the value of  form
                   (which is reevaluated each iteration) e.g.,
                   (FOR X FROM 1 TO 10 --), is equivalent to
                   (FOR X FROM 1 UNTIL (X GT 10) --).



                   Similarly, when the i.v. is definitely being
                   decremented the i.s. terminates when the i.v.
                   becomes less than the value of  form (see
                   description of BY).



BY x (with IN/ON)   If IN or ON have been specified, the
                   value of  x determines the tail for the next
                   iteration, which in turn determines the value for
                   the i.v. as described earlier, i.e. the new i.v. is
                    car of the tail for IN, the tail itself for ON.
                   In conjunction with IN, the user can refer to the
                   current tail within  x by using the i.v., e.g.
                   (FOR Z IN L BY (CDDR  Z) ...).  At translation
                   time, the name of the internal variable which holds
                   the value of the current tail is substituted for
                   the i.v. throughout  x.  For example,
                   (FOR X IN Y BY (CDR (MEMB 'FOO (CDR X))) COLLECT X)
                   specifies that after each iteration,  cdr of the
                   current tail is to be searched for the atom FOO,
                   and ( cdr of) this latter tail to be used for the
                   next iteration.





**FOOTNOTES**
42
    except when both the operands to TO and FROM are numbers, and TO's
    operand is less than FROM's operand, e.g. FROM 10 TO 1, in which
    case the i.v. is decremented by 1 after each iteration.  In this
    case, the i.s. terminates when the i.v. becomes less than the
    value of  form.




                                23.21



BY x (without IN/ON)     If IN or ON have not been used, BY
                   specifies how the i.v. itself is reset at each
                   iteration.  If FROM or TO have been
                   specified, the i.v. is known to be numerical, so
                   the new i.v. is computed by adding the value of  x
                   (which is reevaluated each iteration) to the
                   current value of the i.v., e.g.,
                   (FOR N FROM 1 TO 10 BY 2 COLLECT N) makes a list of
                   the first five odd numbers.



                                              43
                   If  x is a positive number,   the i.s. terminates
                   when the value of the i.v. exceeds the value of
                   TO's operand.  If  x is a negative number, the i.s.
                   terminates when the value of the i.v. becomes less
                   than TO's operand, e.g.
                   (FOR I FROM N TO M BY -2 UNTIL (I LT M) ...).
                   Otherwise, the terminating condition for each
                   iteration depends on the value of  x for that
                   iteration: if  x < 0, the test is whether the i.v.
                   is less than TO's operand, if  x > 0 the test is
                   whether the i.v. exceeds TO's operand, otherwise if
                                                             44
                    x=0, the i.s. terminates unconditionally.



                   If FROM or TO have not been specified, the
                   i.v. is simply reset to the value of  x after each
                   iteration, e.g. (FOR I FROM N BY 2 ...) is
                   equivalent to (FOR I_N BY (IPLUS I 2) ...).



FIRST form           form is evaluated once before the first
                   iteration, e.g.

                   (FOR X Y Z IN L -- FIRST (FOO Y Z)), and FOO could
                   be used to initialize Y and Z.



FINALLY form         form is evaluated after the i.s.





**FOOTNOTES**
43
     x itself, not its value, which in general CLISP would have no way
    of knowing in advance.


44
    A temporary variable is used so that  x is only evaluated once.
    However, code for TO's operand appears twice in the translation,
    even though it is evaluated only once.






                                23.22



                              45
                   terminates.   For example,

                   (FOR X IN L BIND Y_0 DO (IF ATOM X THEN Y_Y+1)

                   FINALLY (RETURN Y)) will return the number of atoms
                   in L.



EACHTIME form   form is evaluated at the beginning of each
                   iteration before, and regardless of, any testing.
                   For example, consider (FOR I FROM 1 TO N DO (...
                   (FOO I) ...) UNLESS (... (FOO I) ...) UNTIL (...
                   (FOO I) ...)).  The user might want to set a
                   temporary variable to the value of (FOO I) in order
                   to avoid computing it three times each iteration.
                   However, without knowing the translation, he would
                   not know whether to put the assignment in the
                   operand to DO, UNLESS, or UNTIL, i.e. which one
                   would be executed first.  He can avoid this problem
                   by simply writing EACHTIME J_(FOO I).



AS var              is used to specify an iterative statement
                   involving more than one iterative variable, e.g.
                   (FOR X IN Y AS U IN V DO --) corresponds to  map2c.
                   The i.s. terminates when any of the terminating
                   conditions are met, e.g.
                   (FOR X IN Y AS I FROM I TO 10 COLLECT X) makes a
                   list of the first ten elements of Y, or however
                   many elements there are on Y if less than 10.



                   The operand to AS,  var, specifies the new i.v.
                   For the remainder of the i.s., or until another AS
                   is encountered, all operators refer to the new i.v.
                   For example,
                   (FOR I FROM I TO N1 AS J FROM 1 TO N2 BY 2

                   AS K FROM N3 TO 1 BY -1 --) terminates when I
                   exceeds N1, or J exceeds N2, or K becomes less than
                   1.  After each iteration, I is incremented by 1, J
                   by 2, and K by -1.










**FOOTNOTES**
45
    Except in the case of termination due to the appearance of a
    RETURN in some operand.  See page 23.24.  Thus in
    (FOR X IN Y THEREIS NUMBERP FINALLY --) the FINALLY operand would
    be evaluated if Y were exhausted, but not if a number was found.




                                23.23



 Miscellaneous



1.  Lowercase versions of all i.s. operators are equivalent to the
    uppercase, e.g., (for X in Y ...).

2.  Each i.s. operator is of lower precedence than all INTERLISP
    forms, so parentheses around the operands can be omitted, and will
    be supplied where necessary, e.g., BIND (X Y Z) can be written
    BIND X Y Z, OLD (X_form) as OLD X_form, WHEN (NUMBERP X) as
    WHEN NUMBERP X, etc.

3.  RETURN or GO may be used in any operand.  RETURN means
    return from the i.s. (with the indicated value), not from the
    function in which the i.s appears.  GO refers to a label elsewhere
    in the function in which the i.s. appears, except for
    (GO ITERATE), which  means transfer control to the iterate
    portion of the loop, i.e. that part that resets the tail,
    increments the counter, or whatever, in preparation for the next
    iteration. The appropriate label will be substituted for ITERATE.

4.  In the case of FIRST, FINALLY, EACHTIME, or one of the
    i.s.types, e.g. DO, COLLECT, SUM, etc., the operand can consist of
    more than one form, e.g., COLLECT (PRINT X:1) X:2, in which case a
    PROGN is supplied.

5.  Each operand can be the name of a function, in which case it is
                               46 47 48
    applied to the (last) i.v.,         e.g.,
    FOR X IN Y DO PRINT WHEN NUMBERP, is the same as
    FOR X IN Y DO (PRINT X) WHEN (NUMBERP X).  Note that the i.v. need
    not be explicitly specified, e.g., IN Y DO PRINT WHEN NUMBERP will
    work.










**FOOTNOTES**
46
    For i.s.types, e.g. DO, COLLECT, JOIN, the function is always
    applied to the first i.v. in the i.s., whether explicity named or
    not.  For example, (IN Y AS I FROM 1 TO 10 DO PRINT) prints
    elements on Y, not integers between 1 and 10.


47
    Note that this feature does not make much sense for FOR, OLD,
    BIND, IN, or ON, since they "operate" before the loop starts, when
    the i.v. may not even be bound.


48
    In the case of BY in conjunction with IN, the function is
    applied to the current tail e.g., FOR X IN Y BY CDDR ..., is the
    same as FOR X IN Y BY (CDDR X)... See page 23.21.




                                23.24



 Errors in Iterative Statements



An error will be generated and an appropriate diagnostic printed
if any of the following conditions hold:



l.  Operator with null operand, i.e. two adjacent operators, as in FOR
    X IN Y UNTIL DO --

2.  Operand consisting of more than one form (except as operand to
    FIRST, FINALLY, or one of the i.s.types), e.g., FOR X IN Y (PRINT
    X) COLLECT --.

3.  Same operator appears twice.

4.  Both IN and ON used on same i.v.

5.  FROM or TO used with IN or ON on same i.v.

6.  More than one i.s.type, e.g. a DO and a SUM.



In 3, 4, or 5, an error is not generated if an intervening AS occurs.



If an error occurs, the i.s. is left unchanged.



If no DO, COLLECT, JOIN or any of the other i.s.types are specified,
CLISP will first attempt to find an operand consisting of more than
one form, e.g., FOR X IN Y  (PRINT X) WHEN ATOM X, and in this case
will insert a DO after the first form.  (In this case, condition 2 is
not considered to be met, and an error is not generated.) If CLISP
cannot find such an operand, a warning message is printed: NO DO,
COLLECT, OR JOIN: followed by the i.s.  However, the i.s. is still
translated, e.g. (WHILE form) can be used to execute  form repeatedly
until its value is NIL.



Similarly, if no terminating condition is detected, i.e. no IN, ON,
WHILE, UNTIL, TO, or a RETURN or GO, a warning message is printed:
POSSIBLE NON-TERMINATING ITERATIVE STATEMENT: followed by the i.s.
However, since the user may be planning to terminate the i.s. via an
error, control-E, or a  retfrom from a lower function, the i.s. is
still translated.




 Defining New Iterative Statement Operators




The i.s.type specifies what is to be done at each iteration, e.g.
collecting values on a list, adding numbers, searching for a



                                23.25



particular condition, etc.  Each i.s. can have one and only one
i.s.type.  The function  i.s.type provides a means of defining new
i.s.types.



i.s.type[name;form;init;val]   name is the name of the i.s.type.
                         form is the form to be evaluated at each
                        iteration.  In  form $$VAL can be used to
                        reference the value being assembled, I.V. to
                        reference the current value of the i.v., and
                        BODY to reference the body of the
                        statement, i.e.  name's operand.



For example, for COLLECT,  form would be
                                                              49
(SETQ $$VAL (NCONC1 $$VAL BODY)), for SUM: ($$VAL_$$VAL+BODY),   for
NEVER: (AND BODY (RETURN NIL)), and for THEREIS:
(AND BODY (RETURN I.V.)).



                         init specifies the initial value for $$VAL,
                        e.g.  for SUM,  init is 0.   val specifies the
                        value to be returned when the i.s. terminates.



                         i.s.type is undoable.



Examples:

1)  To define RCOLLECT, a version of COLLECT which uses  cons instead
    of  nconc1 and then reverses the list of values:

    i.s.type[RCOLLECT;(SETQ $$VAL (CONS BODY $$VAL));NIL;(DREVERSE $$V



2)  To define TCOLLECT, a version of COLLECT which uses  tconc:

    i.s.type[TCOLLECT;(TCONC $$VAL BODY); (CONS); (CAR $$VAL)]



3)  To define PRODUCT:

    i.s.type[PRODUCT;($$VAL_$$VAL*BODY);1;$$VAL]





**FOOTNOTES**
49
    $$VAL+BODY is used instead of (IPLUS $$VAL BODY), so that the
    choice of function used in the translation, i.e.  iplus,  fplus,
    or  plus, will be determined by the declarations then in effect.




                                23.26



 i.s.type performs the appropriate modifications to the property
list for  name, as well as for the lower case version of name, and
also updates the appropriate spelling lists.



 i.s.type can also be used to define synonyms for all i.s. operators,
(not just those that are i.s.types), by calling  i.s.type with  form
an atom, e.g. i.s.type[WHERE;WHEN] makes WHERE be the same as
WHEN.  Similarly, following i.s.type[ISTHERE;THEREIS] one can write
(ISTHERE ATOM IN Y), and following i.s.type[FIND;FOR] and
i.s.type[SUCHTHAT;THEREIS], one can write
                                  50
(FIND X IN Y SUCHTHAT X MEMBER Z).   



This completes the description of iterative statements.





 23.8  CLISP Translations



 The translation of infix operators and IF|THEN|ELSE statements
are handled in CLISP by replacing the CLISP expression with the
corresponding INTERLISP expression, and discarding the original CLISP,
because (1) the CLISP expression is easily recomputable (by
            51
 clispify),    and (2) the INTERLISP expressions are simple and
straightforward.  In addition to saving the space required to retain
both the CLISP and the INTERLISP, another reason for discarding the
original CLISP is that it may contain errors that were corrected in
the course of translation, e.g.  the user writes FOO_FOOO:1,
N*8FOO X), etc.  If the original CLISP were retained, either the user
would have to go back and fix these errors by hand, thereby negating
the advantage of having DWIM perform these corrections, or else DWIM
would have to keep correcting these errors over and over.



Where (1) or (2) are not the case, e.g. with iterative statements,



**FOOTNOTES**
50
    In the current system, WHERE is synonymous with WHEN, SUCHTHAT and
    ISTHERE with THEREIS, and FIND with FOR.


51
    Note that  clispify is sufficiently fast that it is practical for
    the user to configure his INTERLISP system so that all expressions
    are automatically  clispifyed immediately before they are
    presented to him.  For example, he can define an edit macro to use
    in place of P which calls  clispify on the current expression
    before printing it. Similarly, he can inform  prettyprint to call
     clispify on each expression before printing it, etc.




                                23.27



                                         52 53
pattern matches, record expressions, etc.      the original CLISP is
retained (or a slightly modified version thereof), and the translation
is stored elsewhere, usually in  clisparray,  a hash array.  The
interpreter automatically checks this array using  gethash when given
a form  car of which is not a function.  Similarly, the compiler
performs a  gethash when given a form it does not recognize to see
if it has a translation, which is then compiled instead of the form.
Whenever the user changes a CLISP expresson by editing it, the editor
automatically deletes its translation (if one exists), so that the
next time it is evaluated or dwimified, the expression will be
retranslated.  The function  ppt and the edit commands PPT and
CLISP: are available for examining translations, see page 23.64.
Similarly, if  prettytranflg is T,  prettyprint will print the
                                                           54
translations instead of the corresponding CLISP expression.











**FOOTNOTES**
52
    For example, the translation of X:5:3 is (CADDR (CAR (CDDDDR X))),
    which is difficult to read. Therefore, such expressions are
    handled by retaining the CLISP and storing the translation
    elsewhere, as described below.


53
    The handling of translations for IF|THEN|ELSE statements is
    determined by the value of  clispiftranflg. If T, the translations
    are stored elsewhere, and the (modified) CLISP retained as
    described below. If NIL, the corresponding COND replaces the
    IF|THEN|ELSE expression.  The initial value of  clispiftranflg is
    NIL.


54
    Note that the user can always examine the translation himself by
    performing (GETHASH expression CLISPARRAY).



















                                23.28






                      55
If  clisparray is NIL,   translations are implemented instead by
replacing the CLISP expression by an expression of the form
                                             56
(CLISP%  translation . CLISP-expression),   e.g.
(FOR X IN Y COLLECT (CAR X)) would be replaced by

(CLISP%  (MAPCAR Y (FUNCTION CAR)) FOR X IN Y COLLECT (CAR X)).  Both
the editor and prettyprint know about CLISP%  expressions and treat
them specially by suppressing the translations:  Prettyprint prints
just the CLISP (unless  prettytranflg=T, as described below), while
the editor makes the translation completely invisible, e.g. if the
current expression were the above CLISP%  expression, F MAPCAR would
fail to find the MAPCAR, and (3 ON) would replace IN with ON, i.e. the
editor operates as though both the CLISP%  and the MAPCAR were not
there.  As with translations implemented via  clisparray, if the CLISP
expression is changed by editing it, the translation is automatically
deleted.



CLISP%  expressions will interpret and compile correctly: CLISP%  is
defined as an nlambda nospread function with an appropriate compiler
macro. Note that if the user sets  clisparray to NIL, he can then
break, trace, or advise CLISP%  to monitor the evaluation of iterative
statements, pattern matches, and record operations. This technique
will work even if  clisparray was not NIL at the time the expressions
were originally translated, since setting  clisparray to NIL will
effectively delete the translations, thereby causing the CLISP
expressions to be retranslated when they are first encountered. Note
that if the user only wishes to monitor the CLISP in a certain
function, he can accomplish this by embedding its definition in
(RESETVAR CLISPARRAY NIL *).




If a CLISP%  expression is encountered and  clisparray is not NIL, the
translation is transferred to the hash array, and the CLISP% 



**FOOTNOTES**

55
     clisparray is initially NIL, and  #clisparray is its size.  The
    first time a translation is performed, a hash array of this size
    is created.  Therefore to disable  clisparray, both it and
     #clisparray should be set to NIL.


56
    CLISP%  is an atom  consisting of the six characters C, L, I, S,
    P, and space, which must be preceded by the escape character % in
    order for it to be included as a part of an identifier.  The
    intent was to deliberately make this atom hard to type so as to
    make it unlikely that it would otherwise appear in a user's
    program or data, since the editor and prettyprint treat it very
    specially, as described above.




                                23.29



expression replaced by just the CLISP.  Setting  prettytranflg to
CLISP%  causes  prettyprint to print CLISP expressions that have been
translated in the form of (CLISP%  translation . CLISP-expression),
even if the translation is currently stored in  clisparray. These two
features together provide the user with a way of dumping CLISP
expressions together with their translations so that when reloaded
(and run or dwimified), the translations will automatically be
transferred to  clisparray.



In summary, if  prettytranflg=NIL, only the CLISP is printed (used for
producing listings).  If  prettytranflg=T, only the translation is
printed (used for exporting programs to systems that do not provide
                                                           57
CLISP, and to examine translations for debugging purposes).   If
 prettytranflg=CLISP% , an expression of the form
(CLISP%  translation . CLISP) is printed, (used for dumping both CLISP
and translations).  The preferred method of storing translations is in
 clisparray, so that if any CLISP%  expressions are converted while
 clisparray is not NIL, they will automatically be converted so as to
use  clisparray.  If  clisparray=NIL, they will be left alone, and
furthermore, new translations will be implemented using CLISP% 
expressions.




 23.9  Declarations



Declarations are used to affect the choice of INTERLISP function
used as the translation of a particular operator.  For example, A+B
can be translated as either (IPLUS A B), (FPLUS A B), or (PLUS A B),
depending on the declaration in effect.  Similarly X:1_Y can mean
(RPLACA X Y), (FRPLACA X Y), or (/RPLACA X Y), and <!!A B> either
(NCONC1 A B) or (/NCONC1 A B).  The table below gives the declarations
available in CLISP, and the INTERLISP functions they indicate.  The
choice of function on all CLISP transformations are affected by these
declarations, i.e. iteraive statements, pattern matches, record
operations, as well as infix and prefix operators.



The user can make (change) a global declaration by calling the
function CLISPDEC and giving it as its argument a list of
declarations, e.g., (CLISPDEC (QUOTE (FLOATING UNDOABLE))).  Changing
a global declaration does not affect the speed of subsequent CLISP
transformations, since all CLISP transformation are table driven (i.e.
property list), and global declarations are accomplished by making the
appropriate internal changes to CLISP at the time of the declaration.
If a function employs local declarations (described below), there will
be a slight loss in efficiency owing to the fact that for each CLISP
transformation, the declaration list must be searched for possibly
relevant declarations.


**FOOTNOTES**
57
    Note that  makefile will reset  prettytranflg to T, using
     resetvar, when called with the option NOCLISP.




                                23.30



Declarations are implemented in the order that they are given, so that
later declarations override earlier ones.  For example, the
declaration FAST specifies that FRPLACA, FRPLACD, FMEMB, and FLAST be
used in place of RPLACA, RPLACD, MEMB, and LAST; the declaration
RPLACA specifies that RPLACA be used. Therefore, the declarations
(FAST RPLACA RPLACD) will cause FMEMB, FLAST, RPLACA, and RPLACD to be
used.



The initial global declaration is INTEGER and STANDARD.



 Table of Declarations



 Declaration             INTERLISP functions to be used


INTEGER or FIXED        IPLUS, IMINUS, IDIFFERENCE, ITIMES, IQUOTIENT,
                        ILESSP, IGREATERP

FLOATING                FPLUS, FMINUS, FDIFFERENCE, FTIMES, FQUOTIENT,
                        LESSP, FGTP

MIXED                   PLUS, MINUS, DIFFERENCE, TIMES, QUOTIENT,
                        LESSP, GREATERP

FAST                    FRPLACA, FRPLACD, FMEMB, FLAST, FASSOC

UNDOABLE                /RPLACA, /RPLACD, /NCONC, /NCONC1, /MAPCONC,
                        /MAPCON

STANDARD                RPLACA, RPLACD, MEMB, LAST, ASSOC, NCONC,
                        NCONC1, MAPCONC, MAPCON

RPLACA, RPLACD,         corresponding function
/RPLACA, ...




 Local Declarations



The user can also make declarations affecting a selected function or
functions by inserting an expression of the form
(CLISP: . declarations) immediately following the argument list, i.e.,
as CADDR of the definition.  Such local declarations take precedence
over global declarations.  Declarations affecting selected variables
can be indicated by lists, where the first element is the name of a
variable, and the rest of the list the declarations for that variable.
For example, (CLISP: FLOATING (X INTEGER)) specifies that in this
function integer arithmetic be used for computations involving X, and
                                               58
floating arithmetic for all other computations.   The user can also







                                23.31



make local record declarations by inserting a record declaration,
e.g. (RECORD --), (ARRAYRECORD --), etc., in the local declaration
list.  Local record declarations override global record
declarations for the function in which they appear.  Local
declarations can also be used to override the global setting of
certain DWIM/CLISP parameters effective only for transformations
within that function, by including in the local declaration an
expression of the form (variable = value), e.g. (PATVARDEFAULT =
QUOTE).



The CLISP: expression is converted to a comment of a special form
recognized by CLISP.  Whenever a CLISP transformation that is affected
by declarations is about to be performed in a function, this comment
will be searched for a relevant declaration, and if one is found, the
corresponding function will be used.  Otherwise, if none are found,
the global declaration(s) currently in effect will be used.



Local declarations are effective in the order that they are given, so
that later declarations can be used to override earlier ones, e.g.
(CLISP: FAST RPLACA RPLACD) specifies that FMEMB, FLAST, RPLACA, and
RPLACD be used.  An exception to this is that declarations for
specific variables take precedence of general, function-wide
declarations, regardless of the order of appearance, as in
(CLISP: (X INTEGER) FLOATING).



 Clispify also checks the declarations in effect before selecting
an infix operator to ensure that the corresponding CLISP construct
would in fact translate back to this form.  For example, if a FLOATING
declaration is in effect,  clispify will convert (FPLUS X Y) to X+Y,
but leave (IPLUS X Y) as is.  Note that if (FPLUS X Y) is CLISPIFYed
while a FLOATING declaration is under effect, and then the declaration
is changed to INTEGER, when X+Y is translated back to INTERLISP, it
will become (IPLUS X Y).













**FOOTNOTES**
58
    'involving' means where the variable itself is an operand.  For
    example, with the declaration (FLOATING (X INTEGER)) in effect,
    (FOO X)+(FIE X) would translate to FPLUS, i.e., use floating
    arithmetic, even though X appears somewhere inside of the
    operands, whereas X+(FIE X) would translate to IPLUS.  If there
    are declarations involving both operands, e.g. X+Y, with (X
    FLOATING) (Y INTEGER), whichever appears first in the declaration
    list will be used.




                                23.32



                                  59
 23.10  The Pattern Match Compiler



CLISP contains a fairly general pattern match facility.  The
purpose of this pattern match facility is to make more convenient the
specifying of certain tests that would otherwise be clumsy to write
(and not as intelligible), by allowing the user to give instead a
pattern which the datum is supposed to match.  Essentially, the user
writes "Does the (expression) X look like (the pattern) P?" For
example, X:(& 'A -- 'B) asks whether the second element of X is an A,
and the last element a B.  The implementation of the matching is
performed by computing (once) the equivalent INTERLISP expression
which will perform the indicated operation, and substituting this for
the pattern, and not by invoking each time a general purpose
capability such as that found in FLIP or PLANNER.  For example, the
translation of X:(& 'A -- 'B) is:
(AND  (EQ (CADR X) (QUOTE A))  (EQ (CAR (LAST X)) (QUOTE B))).  Thus
the CLISP pattern match facility is really a Pattern Compiler, and the
emphasis in its design and implementation has been more on the
efficiency of object code than on generality and sophistication of its
matching capabilities.  The goal was to provide a facility that could
and would be used even where efficiency was paramount, e.g. in inner
loops.  As a result, the CLISP pattern match facility does not contain
(yet) some of the more esoteric features of other pattern match
languages, such as repeated patterns, disjunctive and conjunctive
patterns, recursion, etc.  However, the user can be confident that
what facilities it does provide will result in INTERLISP expressions
                                              60
comparable to those he would generate by hand.



The syntax for pattern match expressions is form:pattern, where
pattern is a list as described below.  As with iterative statements,
the translation of patterns, i.e., the corresponding INTERLISP
expressions, are stored in  clisparray, a hash array, as
described on page 23.27.  The original expression, form:pattern, is
replaced by an expression of the form (MATCH form WITH pattern).
CLISP also recognizes expressions input in this form.



If  form appears more than once in the translation, and it is not
either a variable, or an expression that is easy to (re)compute, such
as (CAR Y), (CDDR Z), etc.,  a dummy variable will be generated and
bound to the value of  form so that  form is not evaluated a multiple
number of times.  For example, the translation of (FOO X):($ 'A $) is
simply (MEMB (QUOTE A) (FOO X)), while the translation of
(FOO X):('A 'B --) is:


**FOOTNOTES**
59
    The pattern match compiler was written by L. M. Masinter.


60
    Wherever possible, already existing INTERLISP functions are used
    in the translation, e.g., the translation of ($ 'A $) uses MEMB,
    ($ ('A $) $) uses ASSOC, etc.




                                23.33



                   [PROG ($$2) (RETURN
                         (AND (EQ (CAR (SETQ $$2 (FOO X)))
                                  (QUOTE A))
                              (EQ (CADR $$2) (QUOTE B].



In the interests of efficiency, the pattern match compiler assumes
that all lists end in NIL, i.e. there are no LISTP checks inserted in
the translation to check tails.  For example, the translation of
X:('A & --) is (AND (EQ (CAR X) (QUOTE A)) (CDR X)), which will match
with (A B) as well as (A . B).  Similarly, the pattern match compiler
does not insert LISTP checks on elements, e.g. X:(('A --) --)
translates simply as (EQ (CAAR X) (QUOTE A)), and X:(($1 $1 --) --) as
          61
(CDDAR X).   Note that the user can explicitly insert LISTP checks
himself by using @, as described on page 23.36, e.g.
X:(($1 $1 --)@LISTP --) translates as (AND (LISTP (CAR X)) (CDDAR X)).




 Pattern Elements



A pattern consists of a list of pattern elements.  Each pattern
element is said to match either an element of a data structure or a
segment.  (cf. the editor's pattern matcher, "--" matches any
arbitrary segment of a list, while & or a subpattern match only one
element of a list.) Those patterns which may match a segment of a list
are called SEGMENT patterns; those that match a single element are
called ELEMENT patterns.




 Element Patterns



There are several types of element patterns, best given by their
syntax:










**FOOTNOTES**
61
    The insertion of LISTP checks for elements is controlled by the
    variable  patlistpcheck. When  patlistpcheck is T, LISTP
    checks are inserted, e.g. X:(('A --) --) translates as:
     (AND  (LISTP X)  (LISTP (CAR X))  (EQ (CAAR X) (QUOTE A))).
     patlistpcheck is initially NIL. Its value can be changed within a
    particular function by using a local declaration, as described on
    page 23.31.




                                23.34



 PATTERN            MEANING



$1, or &           matches an arbitrary element of a list



'expression        matches only an element which is equal to the
                                             62
                   given expression e.g., 'A,   '(A B).



=form              matches only an element which is  equal to the
                   value of form, e.g., =X, =(REVERSE Y).



==form             same as =, but uses an  eq check instead of
                    equal.



atom               treatment depends on setting of  patvardefault.

                   If  patvardefault is ' or QUOTE, same as
                   'atom.

                   If  patvardefault is = or EQUAL, same as =atom.

                   If  patvardefault is == or EQ, same as ==atom.

                   If  patvardefault is _ or SETQ, same as atom_&.

                                                 63
                    patvardefault is initially =.



Note: numbers and strings are always interpreted as though
 patvardefault were =, regardless of its setting.   Eq,  memb,
and  assoc are used for comparisons involving small integers.



(pattern1 ... patternn) n >= 1   matches a list which matches the
                   given patterns, e.g., (& &), (-- 'A).




**FOOTNOTES**
62
     eq,  memb, and  assoc  are automatically used in the translation
    when the quoted expression is atomic, otherwise  equal,  member,
    and  sassoc.


63
     patvardefault can be changed within a particular function by
    using a local declaration, as described on page 23.31.




                                23.35



element-pattern@function-object   matches an element if the
                   element-pattern matches it, and the function-object
                   (name of a function or a LAMBDA expression) applied
                   to that element returns non-NIL, e.g. &@NUMBERP
                   matches a number, ('A --)@FOO matches a list whose
                   first element is A, and for which FOO applied to
                                        64
                   that list is non-NIL.



*                  matches any arbitrary element.  If the entire
                   match succeeds, the element which matched the *
                   will be returned as the value of the match.



Note: normally, the pattern match compiler constructs an expression
whose value is guaranteed to be non-NIL if the match succeeds and NIL
if it fails.  However, if a * appears in the pattern, the
expression generated will either return NIL if the match fails, or
whatever matched the * even though that may be NIL.  For example,
X:('A * --) translates as
(AND  (EQ (CAR X) (QUOTE A))  (CDR X)  (CADR X)).



~element-pattern   matches an element if the element is not
                   matched by element-pattern, e.g.
                    ~'A,  ~=X,  ~(-- 'A --).




 Segment Patterns



$, or --           matches any segment of a list (including
                   one of zero length).



The difference between $ and -- is in the type of search they
generate.  For example, X:($ 'A 'B $) translates as
(EQ (CADR (MEMB (QUOTE A) X)) (QUOTE B)), whereas X:(-- 'A 'B $)
translates as: [SOME X (FUNCTION (LAMBDA ($$2 $$1)
(AND (EQ $$2 (QUOTE A)) (EQ (CADR $$1) (QUOTE B].  Thus, a paraphrase
of ($ 'A 'B $) would be "Is the element following the first A a B?",
whereas a paraphrase of (-- 'A 'B $) would be "Is there any A
immediately followed by a B?" Note that the pattern employing $ will
result in a more efficient search than that employing --.  However,
($ 'A 'B $) will not match with (X Y Z A M N O A B C), but
(-- 'A 'B $) will.


**FOOTNOTES**
64
    For 'simple' tests, the function-object is applied before a match
    is attempted with the pattern, e.g. ((-- 'A --)@LISTP --)
    translates as (AND  (LISTP (CAR X))  (MEMB (QUOTE A) (CAR X))),
    not the other way around.




                                23.36



Essentially, once a pattern following a $ matches, the $ never resumes
searching, whereas -- produces a translation that will always continue
searching until there is no possibility of success.  However, if the
pattern match compiler can deduce from the pattern that continuing a
search after a particular failure cannot possibly succeed, then the
translations for both -- and $ will be the same. For example, both
X:($ 'A $3 $) and (-- 'A $3 --) translate as
(CDDDR (MEMB (QUOTE A) X)), because if there are not three elements
following the first A, there certainly will not be three elements
following subsequent A's, so there is no reason to continue searching,
even for --.  Similarly, ($ 'A $ 'B $) and (-- 'A -- 'B --) are
equivalent.



$2, $3, etc.       matches a segment of the given length.  Note
                   that $1 is not a segment pattern.



!element-pattern   matches any segment which the given element
                   pattern would match as a list.  For example, if the
                   value of FOO is (A B C) !=FOO will match the
                   segment ... A B C ...  etc.  Note that !* is
                   permissible and means Value-of-match_$, e.g.
                   X:($ 'A !*) translates to (CDR (MEMB (QUOTE A) X)).



Note: since ! appearing in front of the last pattern specifies a match
with some tail of the given expression, it also makes sense in this
case for a ! to appear in front of a pattern that can only match with
an atom, e.g., ($2 !'A) means match if  cddr of the expression is the
atom A.  Similarly, X:($ ! 'A) translates to
(EQ (CDR (LAST X)) (QUOTE A)).



!atom              treatment depends on setting of
                    patvardefault.  If  patvardefault is ' or
                   QUOTE, same as !'atom (see above discussion).  If
                    patvardefault is = or EQUAL, same as !=atom.  If
                    patvardefault is == or EQ, same as !==atom.  If
                    patvardefault is _ or SETQ, same as atom_$.



                                                               65
.                  The atom '.' is treated exactly like !.   In


**FOOTNOTES**
65
    With one exception, namely '.' preceding an assignment does not
    have the special interpretation that ! has preceding an assignment
    (see page 23.38).  For example, X:('A . FOO_'B) translates as:
    (AND  (EQ (CAR X) (QUOTE A))  (EQ (CDR X) (QUOTE B))
    (SETQ FOO (CDR X))), but X:('A ! FOO_'B) translates as:
                   (AND (EQ (CAR X) (QUOTE A))
                         (NULL (CDDR X))
                         (EQ ( CADR X) (QUOTE B))
                         (SETQ FOO (CDR X))).




                                23.37



                   addition, if a pattern ends in an atom, the '.' is
                   first changed to !, e.g., ($1 . A) and ($1 ! A) are
                   equivalent, even though the atom '.' does not
                   explicitly appear in the pattern.



Segment-pattern@function-object   matches a segment if the
                   segment-pattern matches it, and the function object
                   applied to the corresponding segment (as a list)
                   returns non-NIL, e.g. ($@CDDR 'D $) matches
                   (A B C D E) but not (A B D E), since CDDR of (A B)
                   is NIL.



Note:  an @ pattern applied to a segment will require computing the
corresponding structure (with  ldiff) each time the predicate is
applied (except when the segment in question is a tail of the list
being matched).




 Assignments



Any pattern element may be preceded by a variable and a '_',
meaning if the match succeeds (i.e., everything matches), the variable
given is to be set to what matches that pattern element. For
example, if X = (A B C D E), X:($2 Y_$3) will set Y to (C D E).
Assignments are not performed until the entire match has succeeded.
Thus, assignments cannot be used to specify a search for an element
                                                66
found earlier in the match, e.g.  X:(Y_$1 =Y --)   will not match with
              67
(A A B C ...).   This type of match is achieved by using
place-markers, described below.



If the variable is preceded by a !, the assignment is to the tail
of the list as of that point in the pattern, i.e. that portion of the
list matched by the remainder of the pattern. For example, if X is
(A B C D E), X:($ !Y_'C 'D $) sets Y to (C D E), i.e.  cddr of X.  In



**FOOTNOTES**
66
    The translation of this pattern is:
    (COND ((AND (CDR X) (EQUAL (CADR X) Y))
            (SETQ Y (CAR X))
            T)).
    The AND is because if Y is NIL, the pattern should match with
    (A NIL), but not with just (A). The T is because (CAR X) might be
    NIL.


67
     unless, of course, the value of Y was A before the match started.




                                23.38



other words, when ! precedes an assignment, it acts as a modifier to
the _, and has no effect whatsoever on the pattern itself, e.g.
X:('A 'B) and X:('A !FOO_'B) match identically, and in the latter
case, FOO will be set to CDR of X.



Note: *_pattern-element and !*_pattern-element are acceptable, e.g.
X:($ 'A *_('B --) --) translates as:

              [PROG ($$2) (RETURN
                    (AND (EQ (CAADR (SETQ $$2 (MEMB (QUOTE A) X)))
                             (QUOTE B))
                         (CADR $$2]




 Place-markers



Variables of the form #n,  n a number, are called
place-markers, and are interpreted specially by the pattern match
compiler.  Place-markers are used in a pattern to mark or refer to a
particular pattern element. Functionally, they are used like ordinary
variables, i.e. they can be assigned values, or used freely in forms
appearing in the pattern, e.g.  X:(#1_$1 =(ADD1 #1)) will match the
list (2 3).  However, they are not really variables in the sense that
they are not bound, nor can a function called from within the pattern
expect to be able to obtain their values.  For convenience, regardless
of the setting of  patvardefault, the first appearance of a defaulted
place-marker is interpreted as though  patvardefault were _. Thus the
above pattern could have been written as X:(#1 =(ADD1 #1)).
Subsequent appearances of a place-marker are interpreted as though
 patvardefault were =. For example, X:(#1 #1 --) is equivalent to
X:(#1_$1 =#1 --), and translates as
                                      68
(AND (CDR X) (EQUAL (CAR X) (CADR X)).



 Replacements



Any pattern element may be followed by a '_' and a form, meaning if
the match succeeds, the part of the data that matched is to be
                                      69
replaced (e.g., with RPLACA or RPLACD)   with the value of <form>.



**FOOTNOTES**
68
    Just (EQUAL (CAR X) (CADR X)) would incorrectly match with (NIL).


69
    The user can indicate he wants  /rplaca and  /rplacd used, or
     frplaca and  frplacd, by means of declarations.  The initial
    default is for  rplaca and  rplacd.




                                23.39



For example, if X =(A B C D E), X:($ 'C $1_Y $1) will replace the
fourth element of X with the value of Y.  As with assignments,
replacements are not performed until after it is determined that the
entire match will be successful.



Replacements involving segments splice the corresponding structure
into the list being matched, e.g. if X is (A B C D E F) and FOO is
(1 2 3), after the pattern ('A $_FOO 'D $) is matched with X, X will
be (A 1 2 3 D E F), and FOO will be  eq to CDR of  x, i.e.
(1 2 3 D E F).



                         *             *              *



Note that ($ FOO_FIE $) is ambiguous, since it is not clear whether
FOO or FIE is the pattern element, i.e. whether _ specifies assignment
or replacement.  For example, if  patvardefault is =, this
pattern can be interpreted as ($ FOO_=FIE $), meaning search for the
value of FIE, and if found set FOO to it, or ($ =FOO_FIE $) meaning
search for the value of FOO, and if found, store the value of FIE into
the corresponding position.  In such cases, the user should
disambiguate by not using the  patvardefault option, i.e. by
specifying ' or =.




 Reconstruction



 The user can specify a value for a pattern match operation other
than what is returned by the match by writing after the pattern =>
followed by another form, e.g. X:(FOO_$ 'A --
                   70
) => (REVERSE FOO),   which translates as:

                   [PROG ($$2) (RETURN
                         (COND ((SETQ $$2 (MEMB (QUOTE A) X))
                                 (SETQ FOO (LDIFF X $2))
                                 (REVERSE FOO].



Place-markers in the pattern can be referred to from within  form,
e.g. the above could also have been written as X:(!#1 'A --
)=>(REVERSE #1).  If -> is used in place of =>, the expression
being matched is also physically changed to the value of  form.  For
example, X:(#1 'A !#2) -> (CONS #1 #2) would remove the second element
from X, if it were equal to A.


**FOOTNOTES**
70
    The original CLISP is replaced by an expression of the form
    (MATCH form1 WITH pattern => form2).  CLISP also recognizes
    expressions input in this form.




                                23.40



In general, form1:pattern->form2 is translated so as to compute  form2
if the match is successful, and then smash its value into the first
node of  form1.  However, whenever possible, the translation does not
actually require  form2 to be computed in its entirety, but instead
the pattern match compiler uses  form2 as an indication of what should
be done to  form1. For example, X:(#1 'A !#2) -> (CONS #1 #2)
translates as:

(AND  (EQ (CADR X) (QUOTE A))  (RPLACD X (CDDR X))).




 Examples



X:(-- 'A --)            -- matches any arbitrary segment.  'A matches
                        only an A, and the 2 nd -- again matches an
                        arbitrary segment; thus this translates to
                        (MEMB (QUOTE A) X).



X:(-- 'A)               Again, -- matches an arbitrary segment;
                        however, since there is no -- after the 'A, A
                        must be the last element of X.  Thus this
                        translates to: (EQ (CAR (LAST X)) (QUOTE A)).



X:('A 'B -- 'C $3 --)   CAR of X must be A, and CADR must be B, and
                        there must be at least three elements after
                        the first C, so the translation is:

                        (AND (EQ (CAR X) (QUOTE A))
                             (EQ (CADR X) (QUOTE B))
                             (CDDDR (MEMB (QUOTE C) (CDDR X))))



X:(('A 'B) 'C Y_$1 $)   Since ('A 'B) does not end in $ or --,
                        (CDDAR X) must be NIL.

                        (COND
                          ((AND (EQ (CAAR X) (QUOTE A))
                                (EQ (CADAR X) (QUOTE B))
                                (NULL (CDDAR X))
                                (EQ (CADR X) (QUOTE C))
                                (CDDR X))
                            (SETQ Y (CADDR X))
                            T))


X:(#1 'A $ 'B 'C #1 $)  #1 is implicitly assigned to the first element
                        in the list. The $ searches for the first B
                        following A. This B must be followed by a C,
                        and the C by an expression equal to the first
                        element.

                        [PROG ($$2) (RETURN
                              (AND (EQ (CADR X) (QUOTE A))
                                   (EQ [CADR (SETQ $$2 (MEMB (QUOTE B)
                                       (QUOTE C))


                                23.41



                                   (EQUAL (CADDR $$2) (CAR X]



X:(#1 'A -- 'B 'C #1 $) Similar to the pattern above, except that --
                        specifies a search for any B followed by a C
                        followed by the first element, so the
                        translation is:

                        [AND (EQ (CADR X) (QUOTE A))
                             (SOME (CDDR X) (FUNCTION (LAMBDA ($$2 $$1
                                       (AND (EQ $$2 (QUOTE B))
                                            (EQ (CADR $$1) (QUOTE C))
                                            (EQUAL (CADDR $$1) (CAR X]



This concludes the description of the pattern match compiler.





                               71
 23.11  The Record Package



The advantages of "data-less" or data-structure-independent
programming have long been known: more readable code, fewer bugs, the
ability to change the data structure without having to make major
modifications to the program, etc. The record package in CLISP both
encourages and facilitates this good programming practice by providing
a uniform syntax for accessing and storing data into many different
types of data structures, e.g. those employing arrays, list
structures, atom property lists, hash links, etc., or any combination
thereof, as well as removing from the user the task of writing the
various access and storage routines themselves. The user declares
(once) the data structure(s) used by his programs, and thereafter
indicates the manipulations of the data in a data-structure-
independent manner.  The record package automatically computes from
the declaration(s) the corresponding INTERLISP expressions necessary
to accomplish the indicated access/storage operations.  The user can
change his data structure simply by changing the corresponding
declaration(s), and his program automatically (re)adjusts itself to
the new conventions.



The user informs the record package about the format of his data
structure by making a record declaration.  A record declaration
defines a  record, i.e. a data structure.  (Note that the record
itself is an abstraction that exists only in the user's head.) The
record declaration is essentially a template which describes the
record, associating names with its various parts or fields.  For
example, the record declaration (RECORD MSG (ID (FROM TO) . TEXT))



**FOOTNOTES**
71
    The record package was written by L. M. Masinter.




                                23.42



describes a data structure called MSG, which contains four fields: ID,
FROM, TO, and TEXT.  The user can then reference these fields by name,
either to retrieve their contents, or to store new data into them, by
using the : operator followed by the field name.  For example, for the
above record declaration, X:FROM would be equivalent (and translate)
                                                 72
to (CAADR X), and Y:TO_Z to (RPLACA (CDADR Y) Z).   The fields of a
record can be further broken down into subfields by additional
declarations within the record, e.g.

(RECORD MSG (ID (FROM TO) . TEXT) (RECORD TEXT (HEADER TXT))) would
permit the user to refer to TEXT, or to its subfields HEADER and TXT.



Note that what the record declaration is really doing is specifying
the data-paths of the structure, and thereby specifying how the
corresponding access/storage operations are to be carried out.  For
example, (RECORD MSG (ID (FROM TO) . TEXT) (RECORD TEXT (HEADER TXT)))
says the HEADER of a MSG is to be found as the first element of its
TEXT, which is the second tail of the MSG itself.  Hence,
X:HEADER_string is achieved by performing (RPLACA (CDDR X) string).



Note also that when the user writes X:HEADER, he is implicitly saying
the X is an instance of the record MSG, or at least is to be treated
as such for this particular operation. In other words, the
interpretation of X:FORM  never depends on the value of X.  The record
package (currently) does not provide any facility which uses run-time
checks to determine data paths, nor is there any error checking other
than that provided by INTERLISP itself.  For example, if X happened to
                                                    73
be an array, X:HEADER would still compute (CAADR X).



RECORD (used to specify elements and tails of a list structure) is
just one of several record-types currently implemented.  For example,
the user can specify 'optional' fields, i.e. property list format, by
using the record type PROPRECORD, or fields to be associated with
parts of the data structure via hash links, by using the record-type
HASHRECORD, or even specify the access definitions in the record
declaration himself, by using the record-type ACCESSFN.  These are
described in detail below.





**FOOTNOTES**
72
    or /RPLACA or FRPLACA, depending on the CLISP declaration in
    effect.


73
    However, it is possible to make the interpretation of X:HEADER
    differ from that of Y:HEADER (regardless of the values of X and
    Y), by using local record declarations, as described on page
    23.31.  Note that this distinction depends on a translation-time
    check, not run-time.




                                23.43



The record package also provides a facility for creating new data
structures using a record declaration as a guide or template.  Initial
values for the various fields can be specified in the CREATE
expression, or defaulted to values specified in the record
declaration itself.  Alternatively, CREATE can be instructed to use an
existing datum as a model, i.e. to obtain the field values for the new
datum from the corresponding fields of the existing datum, or even to
actually use (cannibalize) the structure of the existing datum itself.



As with all DWIM/CLISP facilities, the record package contains many
do-what-I-mean features, spelling correction on field names, record
types, etc.  In addition, the record package includes a RECORDS
 prettydef macro for dumping record declarations, as well as the
appropriate modifications to the file package (Section 14), so that
 files? and  cleanup will inform the user about records that need to
be dumped.




 Record Declarations



A record declaration is an expression of the form

    (record-type record-name fields . {defaults and/or subfields})

This expression is evaluated to effect the corresponding
            74
declaration.



1.  record-type specifies the "type" of data being described by the
   record declaration, and thereby implicitly specifies the data
   paths, i.e. how the corresponding access/storage operations are
   performed.   record-type currently is either RECORD, TYPERECORD,
                                                                75
   ARRAYRECORD, ATOMRECORD, PROPRECORD, HASHRECORD, or ACCESSFN.
   RECORD and TYPERECORD are used to describe list structures,
   ARRAYRECORD to describe arrays, ATOMRECORD to describe (the
   property list of) atoms, and PROPRECORD to describe lists that use
   property list format.  HASHRECORD can be used with any type of
   data: since it simply specifies the data path to be a hash-link.
   ACCESSFN is also type-less; the user specifies the data-path(s) in
   the record declaration itself, as described below.



**FOOTNOTES**
74
    Local record declarations are performed by including an expression
    of this form in the CLISP declaration for that function (page
    23.31), rather than evaluating the expression itself.


75
    When user-defined data types are introduced to INTERLISP, a
    corresponding record-type will be added to the record package.




                                23.44



2.  record-name is a literal atom used to identify the record
   declaration for dumping to files via the RECORDS  prettydef
   macro, and for creating instances of the record via
   CREATE. For most top-level declarations,  record-name is
   optional, e.g. (RECORD (ID (FROM TO) . TEXT)) is perfectly
              76
   acceptable.



   For TYPERECORD,  record-name is obligatory and is used as an
   indicator in CAR of the datum to signify what "type" of record it
   is.  CREATE will insert an extra field containing  record-name at
   the beginning of the structure, and the translation of the access
                                                                 77
   and storage functions will take this extra field into account.



   For subfield declarations,  record-name is also obligatory, and
   specifies the parent field that is being elaborated, as described
   below.



3.  fields describes the structure of the record. Its exact
   interpretation varies with the  record-type:




          For RECORD,  fields is a list whose non-NIL literal atoms
          are taken as field-names to be associated with the
          corresponding elements and tails of a list structure.  NIL
          can be used as a place marker to fill an unnamed field, e.g.
          (A NIL B) describes a three element list, with B
          corresponding to the third element.



          
          For TYPERECORD,  fields has the same meaning as for RECORD.
          However, since CAR of the datum contains an indicator
          signifying its "type," the translation of the access/storage
          functions differ from those of RECORD.  For example, for
          (TYPERECORD MSG (ID (FROM TO) . TEXT)), X:FROM translates as
          (CAADDR X), not (CAADR X).





**FOOTNOTES**
76
    If  record-name is omitted, it simply means that the user cannot
    specify the record by name, e.g. when calling CREATE, or when
    using the RECORDS  prettydef command.


77
    Note: this type-field is not used by the record package.  It is
    provided for the user's own applications.




                                23.45



          For ATOMRECORD,  fields is a list of property names,
          e.g.  (ATOMRECORD (EXPR CODE MACRO BLKLIBRARYDEF)).
          Accessing will be performed with  getp, storing with  put.



          For PROPRECORD,  fields is also a list of property
          names.  Accessing is performed with  get, storing with
                78
           putl.   For example,

          (RECORD ENTRY (INPUT VALUE ID . PROPS) (PROPRECORD PROPS
          (HISTORY LISPXPRINT SIDE GROUP ERROR))) could be used to
                                                                 79
          describe an entry on the history list (see Section 22).



          For HASHRECORD (or HASHLINK),  fields is usually just
           field-name, i.e. an atom, and is the name by which the
          corresponding hash-value is referred to.  For example, for
          (RECORD (A B . C) (HASHRECORD B FOO)), X:FOO translates as
          (GETHASH (CADR X)).  If  field-name is a list, it is
          interpreted as (field-name arrayname arraysize).  In this
          case,  arrayname indicates the hash-array to be used.  For
          example, (HASHRECORD (CLISP CLISPARRAY)) would permit the
          user to obtain the CLISP translation of X by simply writing
          X:CLISP.   arraysize is used for initializing the hash
          array: if  arrayname has not been initialized at the time of
          the declaration, it will be set to
          (HARRAY (OR arraysize 100)).



          For ARRAYRECORD,  fields is a list of field-names that
          are associated with the corresponding elements of the array.
          NIL can be used as a place marker for an unnamed field
          (element). Positive integers can be used as abbreviation for
          the corresponding number of NILs. For example,
          (ARRAYRECORD (ORG DEST NIL ID 3 TEXT)) describes an eight
          element array, with ORG corresponding to the first element,
          ID to the fourth, and TEXT to the eighth.


**FOOTNOTES**
78
    A new function (part of the record package), similar to  put,
    which takes a list as its first argument, searches the list
    looking for an occurrence of the given property name (its second
    argument). If found, it replaces the next element with the new
    property value (its third argument), otherwise adds the property
    name and property value to the list.


79
    Note that (ATOMRECORD (FOO FIE))) is equivalent to (RECORD (VALUE
    . PROPS) (PROPRECORD PROPS (FOO FIE))), the difference being in
    the translations.  In the first case, X:FIE translates as
    (GETP X (QUOTE FIE)),, in the second case, as
    (GET (CDR X) (QUOTE FIE)).  Note also that in the first case, if X
    is not a literal atom, INTERLISP (i.e.  getp) will generate an
    error.




                                23.46



          For ACCESSFN (or ACCESSFNS),  fields is a list of the
          form (field-name accessdefinition setdefinition), or a list
          of elements of this form.  accessdefinition is a function of
          one argument, the datum, and will be used for accessing.
           setdefinition is a function of two arguments, the datum and
                                                  80
          the new value,  and is used for storing.   For example,
          (HASHRECORD FOO) and (ACCESSFN (FOO GETHASH PUTHASH)) are
          equivalent: in both cases, X:FOO translates as
          (GETHASH FOO).  Similarly, (ACCESSFN (DEF GETD PUTD)) would
                                                                 81
          permit defining functions by writing fn:DEF_definition.



4. {defaults and/or subfields} is optional. It may contain expressions
   of the form:



          (1) field-name _ form - specifies the default value for
           field-name. Used by CREATE.



          (2) DEFAULT _ form - specifies default value for every field
          not given a specific default via (1).



          (3) a subfield declaration - i.e. a record declaration of
          any of the above types.  For subfield declarations,
           record-name is obligatory.  Instead of identifying the
          declaration as with the case of top level declarations,
           record-name identifies the parent field or record that is
          being described by the subfield declaration. It must be
          either the record-name of the immediately superior
          declaration, or one of its field-names (or else an error is
          generated).



          Subfields can be nested to an arbitrary depth.



          Note that in some cases, it makes sense for a given field to
          have more than one subfield declaration. For example, in
          (RECORD (A . B) (PROPRECORD B (FOO FIE FUM))
          (HASHRECORD B C)), B is elaborated by both a PROPRECORD and



**FOOTNOTES**
80
    Currently, an error is generated if CREATE is called with a record
    declaration containing an ACCESSFNS record-type.


81
    [ACCESSFN (DEF GETD (LAMBDA (FN DEF) (DEFINE (LIST (LIST FN DEF]
    would be preferable to using  putd.




                                23.47



          HASHRECORD.  Similarly, (RECORD (A B) (RECORD A (C D))
          (RECORD A (FOO FIE))) is also acceptable, and essentially
          "overlays" (FOO FIE) and (C D), i.e. X:FOO and X:C would be
          equivalent.  In such cases, the first subfield declaration
          is the one used by CREATE, e.g.

          (RECORD X (A B)  
          (RECORD A (C D))  (RECORD A (FOO FIE FUM)) ) will cause
          (CREATE X) to construct ((NIL NIL) NIL), not
          ((NIL NIL NIL) NIL), as would be the case if the subfield
          declaration (RECORD A (C D)) were removed.  




 CREATE



Record operations can be applied to arbitrary structures, i.e.
structures created directly by user programs can be manipulated in a
data-independent manner using record declarations.  However, to be
completely data-independent, new data should be created using the same
declarations that define its data paths. This can be done by means of
                                                               82
an expression of the form (CREATE record-name . {assignments}).
{assignments} is optional and may contain expressions of the following
form:



     (1) field-name _ form        specifies initial value for
                                   field-name.



     (2) USING form          specifies that for all fields not
                                  given a value by (1), the value of
                                  the corresponding field in  form is
                                  to be used.



     (3) COPYING form        like USING except the corresponding
                                  values are copied ( copy).



     (4) REUSING form        like USING, except that wherever
                                  possible, the corresponding
                                  structure in  form is used (similar



**FOOTNOTES**
82
    CREATE is not defined as a function. Instead, DWIM calls the
    appropriate function in the record package giving it the entire
    CREATE expression as an argument.  The translation of the CREATE
    expression, i.e. the INTERLISP form which is evaluated to
    construct the datum, is then stored elsewhere, as with iterative
    statements and pattern matches.




                                23.48



                                  to operation of  subpair and
                                   sublis).



For example, following (RECORD FOO (A B C)),

(CREATE FOO A_T USING X) translates as (LIST T (CADR X) (CADDR X)),

(CREATE FOO A_T COPYING X)) as (LIST T (COPY (CADR X)) (COPY (CADDR X)

(CREATE FOO A_T REUSING X) as (CONS T (CDR X)).



A CREATE expression translates into an appropriate INTERLISP form
using  cons,  list,  put,  putl,  puthash,  seta, etc., that creates
the new datum with the various fields initialized to the appropriate
values.  If values are neither explicitly specified, nor implicitly
specified via USING or COPYING, the DEFAULT value in the declaration
                83               84
is used, if any,   otherwise NIL.   




 Implementation



Record operations are implemented by replacing expressions of the form
X:FOO by  (FETCH FOO OF X), and X:FOO_Y by
                               85
(REPLACE FOO OF X WITH Y),   and then storing the translation
elsewhere, usually in a hash array, as described on page 23.27.
Translations of CREATE expressions are also stored elswhere.





**FOOTNOTES**
83
    For RECORD and TYPERECORD declarations with non-NIL defaults, all
    elements and named tails will be initialized; unnamed tails will
    not be initialized.  For example, (RECORD FOO (A NIL B) DEFAULT_T)
    will cause (CREATE FOO) to construct (T T T) not (T T T . T). Of
    course, (RECORD FOO (A B . C) DEFAULT_T) will cause (CREATE FOO)
    to construct (T T . T) as expected.


84
    For PROPRECORD, initialization is only performed where necessary.
    For example, (RECORD FOO (A B) (PROPRECORD (C D E))) would cause
    (CREATE FOO) to construct (NIL NIL), not
    (NIL (C NIL D NIL E NIL)).
    (RECORD FOO (A B) (PROPRECORD (C D E) DEFAULT_T)) however, will
    construct (NIL (C T D T E T)).


85
    CLISP also recognizes expressions input in this form.




                                23.49



The translation of each record operation is computed using information
retrieved from the property list of the field name, under the property
CLISPRECORDFIELD.  Thus, (global) field names must be unique,
i.e. cannot be the same as the name of any other field in any other
record.  Records can also be declared local to a particular function
by using a CLISP declaration, as described on page 23.31.  Local
record declarations override global ones, and a local record can have
a field name the same as that of a local record of another function,
or the same as a field name of a global record.



For both global and local records, the translation is computed using
all CLISP declarations in effect as described on page 23.30, e.g. if
the declaration UNDOABLE in in effect, /RPLACA, /RPLACD, /PUTHASH,
etc. will be used.



When the user redeclares a global record, the translations of all
                                                            86
expressions involving that record are automatically deleted,   and
thus will be recomputed using the new information.  If the user
changes a local record declaration, or changes some other CLISP
declaration, e.g. STANDARD to FAST, and wishes the new information to
affect record expressions already translated, he must make sure the
corresponding translations are removed, usually either by CLISPIFYING
or changing the expression by editing it.  





 23.12  CLISPIFY



 Clispify converts INTERLISP expressions to CLISP.  Note that the
expression given to  clispify need not have originally been input as
CLISP, i.e.,  clispify can be used on functions that were written
before CLISP was even implemented.   Clispify is cognizant of
                                                         87
declaration rules as well as all of the precedence rules.   For
example,  clispify will convert (IPLUS A (ITIMES B C)) into A+B*C, but






**FOOTNOTES**
86
    from  clisparray.  If the user is not using this method for
    storing translations, i.e. is instead using the CLISP%  method
    (page 23.29), those expressions already translated will remain as
    they are. (There is no practical way to locate them.)


87
     clispify is table driven exactly the same as CLISP, so that if
    the user changes any precedence, or defines new operators,
     clispify "automatically" knows about it.




                                23.50



                                    88
(ITIMES A (IPLUS B C)) into A*(B+C).    Clispify converts calls to the
six basic mapping functions, MAP, MAPC, MAPCAR, MAPLIST, MAPCONC, and
MAPCON, into equivalent iterative statements.  It also converts
certain easily recognizable internal PROG loops to the corresponding
i.s.  For example,



         ... label (COND (pred ... forms ... (GO label))) ...

becomes

                                                                89
         ... label (WHILE pred DO ... forms ...) ...



 Clispify is not destructive to the original INTERLISP expression,
i.e.  clispify produces a new expression without changing the
         90
original.    Clispify will not convert expressions appearing as
                               91
arguments to NLAMBDA functions.



The value of various global parameters affect the operation of
 clispify:








**FOOTNOTES**
88
     clispify also knows how to handle expressions consisting of a
    mixture of INTERLISP and CLISP, e.g. (IPLUS A B*C) is converted to
    A+B*C, but (ITIMES A B+C) to (A*(B+C)).   clispify handles such
    cases by first  dwimifying the expression.


89
     clispify can convert all iterative statements input in CLISP back
    to CLISP, regardless of how complicated the translation was,
    because the original CLISP is saved.


90
    The new expression may however contain some 'pieces' of the
    original, since  clispify attempts to minimize the number of
    CONSes by not copying structure whenever possible.


91
    Except for those functions for which  clispify contains built in
    information about how they process their arguments, e.g.  prog,
     selectq,  function,  progn,  ersetq,  nlsetq,  resetvar,
     resetform, etc.




                                23.51



 cl:flg

The user can disable the : transformation by setting the variable
 cl:flg to NIL.  This will cause  clispify not to transform
expressions such as (CADR X) to X:2.  Note that  clispify does not
convert to : notation when the argument is not atomic or a simple list
(a function name and one atomic argument), regardless of the setting
of this flag.  The initial value of  cl:flg is T.



 clremparsflg

 Clispify will remove parentheses in certain cases from simple forms,
where 'simple' means a function name and one or two atomic arguments.
For example, (COND ((ATOM X) --)) will CLISPIFY to (IF ATOM X THEN --
).  However, if  clremparsflg is set to NIL,  clispify will
produce (IF (ATOM X) THEN --).  Note that regardless of the setting of
this flag, the expression can be input in either form.  The initial
value of  clremparsflg is T.



 clispifypackflg

 clispifypackflg affects the treatment of infix operators with atomic
operands.  If  clispifypackflg is T,  clispify will pack these
into single atoms, e.g., (IPLUS A (ITIMES B C)) becomes A+B*C.  If
 clispifypackflg is NIL, no packing is done, e.g., the above becomes
A + B * C.  The initial value of  clispifypackflg is T.



 funnyatomlst

Suppose the user has variables named A, B, and A*B.  If  clispify were
to convert (ITIMES A B) to A*B, A*B would not translate back correctly
to (ITIMES A B), since it would be the name of a variable, and
therefore would not cause an error.  The user can prevent this from
happening by adding A*B to the list  funnyatomlst.  Then,
(ITIMES A B) would  clispify to A * B.



Note that A*B's appearance on  funnyatomlst would not enable
DWIM/CLISP to decode A*B+C as (IPLUS A*B C);  funnyatomlst is used
only by  clispify.  Thus, if an identifier contains a CLISP character,
it should always be separated (with spaces) from other operators.  For
example, if X* is a variable, the user should write (SETQ X* form) in
CLISP as X* _form, not X*_form.  However, in general, it is best to
 avoid use of identifiers containing CLISP character operators as much
as possible.



 clispifyprettyflg

If T, causes  prettyprint to  clispify all expressions before printing
them (but not to redefine any functions).   clispifyprettyflg is
temporarily reset to T, using  resetvar, when  makefile is called with
the option CLISPIFY, or when the file in question has property
FILETYPE with value CLISP on its property list.
 clispifyprettyflg is initially NIL.



                                23.52



                         *             *              *



In addition to the above controls, disabling a CLISP operator
(see  cldisable, page 23.63) will also disable the corresponding
CLISPIFY transformation.  Thus, if _ is "turned off", A_B will not
transform to (SETQ A B), nor vice versa.




 23.13  Dwimify



 Dwimify is effectively a preprocessor for CLISP.   Dwimify
operates by scanning an expression as though it were being
interpreted, and for each form that would generate an error, calling
                 92
DWIM to 'fix' it.   Thus the user will see the same messages, and be
asked for approval in the same situations, as he would if the
expression were actually run.  If DWIM is unable to make a correction,
no message is printed, the form is left as it was, and the analysis
proceeds.



 Dwimify knows exactly how the interpreter works.  It knows the syntax
of  progs,  selectqs,  lambda expressions,  setqs, et al.  It knows
that the argument of  nlambdas are not evaluated.  It also knows how
variables are bound.  In the course of its analysis of a particular
expression,  dwimify builds a list of the bound variables from the
LAMBDA expressions and PROGs that it encounters.  It uses this list
for spelling corrections.   Dwimify also knows not to try to 'correct'
variables that are on this list since they would be bound if the
expression were actually being run.  However, note that  dwimify
cannot, a priori, know about variables that are used freely but would
be bound in a higher function if the expression were evaluated in its
normal context.  Therefore,  dwimify will try to 'correct' these
variables.  Similarly,  dwimify will attempt to correct forms for
which  car is undefined, even when the form is not in error from the
user's standpoint, but the corresponding function has simply not yet
been defined.



In most cases, an attempt to transform a form that is already as the
user intended will have no effect (because there will be nothing to
which that form could reasonably be transformed).  However, in order
to avoid needless calls to DWIM or to avoid possible confusion, the
user can inform  dwimify not to attempt corrections or transformations
on certain functions or variables  by adding them to the list




**FOOTNOTES**
92
    Thus  dwimify performs all DWIM transformations, not just CLISP
    transformations, i.e., it does spelling correction, fixes 8-9
    errors, handles F/L, etc.




                                23.53



                                                     93
 nofixfnslst or  nofixvarslst respectively.



 Dwimify and  dwimifyfns (used to  dwimify several functions)
maintain two internal lists of those functions and variables for which
corrections were unsuccessfully attempted.  These lists are
initialized to  nofixfnslst and  nofixvarslst.  Once an attempt is
made to fix a particular function or variable, and the attempt fails,
the function or variable is added to the corresponding list, so that
on subsequent occurrences (within this call to  dwimify or
 dwimifyfns), no attempt at correction is made.  For example, if FOO
calls FIE several times, and FIE is undefined at the time FOO is
dwimified,  dwimify will not bother with FIE after the first
occurrence.  In other words, once  dwimify "notices" a function or
                                              94
variable, it no longer attempts to correct it.   Moreover, once
 dwimify "notices" such functions or variables, it subsequently treats
them the same as though they were actually defined or set.



Note that these internal lists are local to each call to  dwimify and
 dwimifyfns, so that if a function containing FOOO, a misspelled call
to FOO, is  dwimified before FOO is defined or mentioned, if the
function is dwimified again after FOO has been defined, the correction
will be made.



Note that the user can undo selected transformations performed by
 dwimify, as described in section 22.




 Compiling CLISP



Since the compiler does not know about CLISP, in order to compile
functions containing CLISP constructs, the definitions must first be
 dwimified.  The user can automate this process in several ways:



1)  If the variable  dwimifycompflg is T, the compiler will
always  dwimify expressions before compiling them.   dwimifycompflg is
initially NIL.


**FOOTNOTES**
93
    Note that the user could achieve the same effect by simply setting
    the corresponding variables, and giving the functions dummy
    definitions.


94
     Dwimify and  dwimifyfns also "notice" free variables that are set
    in the expression being processed.




                                23.54



2)  If a file has the property FILETYPE with value CLISP on its
property list,  tcompl,  bcompl,  recompile, and  brecompile will
operate as though  dwimifycompflg is T and  dwimify all expressions
                 95
before compiling.



3)  If the function definition has a CLISP declaration (see page
23.30), including a null declaration, i.e., just (CLISP:), the
definition will be automatically dwimified before compiling.



Note:  tcompl,  bcompl,  recompile, and  brecompile all scan the
entire file before doing any compiling, and take note of the names of
all functions that are defined in the file as well as the names of all
variables that are set by adding them to  nofixfnslst and
 nofixvarslst, respectively.  Thus, if a function is not
currently defined, but is defined in the file being compiled, when
 dwimify is called before compiling, it will not attempt to correct
the function when it appears as  car of a form.



Note:   compileuserfn (Section 18) is defined to call  dwimify on
iterative statements, as well as IF-THEN statements.  Thus, if the
only CLISP constructs in a function appear inside of iterative
statements or IF statements, the function does not have to be
dwimified before compiling.





 23.14  Operation



CLISP is a part of the basic INTERLISP system.  Without any
special preparations, the user can include CLISP constructs in
programs, or type them in directly for evaluation (in  eval or  apply
format), and when the "error" occurrs, and DWIM is called, it will
             96
destructively   transform the CLISP to the equivalent INTERLISP
expression and evaluate the INTERLISP expression.  User approval is




**FOOTNOTES**
95
    If the value of property FILETYPE is CLISP,  makefile would have
    automatically clispified all functions before prettyprinting, as
    described in Section 14.


96
    CLISP transformations, like all DWIM corrections, are undoable.







                                23.55



                                         97
not requested, and no message is printed.



However, if a CLISP construct contains an error, an appropriate
diagnostic is generated, and the form is left unchanged.  For example,
if the user writes (LIST X+Y*), the error diagnostic
MISSING OPERAND AT X+Y* IN (LIST X+Y*) would be generated.
Similarly, if the user writes (LAST+EL X), CLISP knows that
((IPLUS LAST EL) X) is not a valid INTERLISP expression, so the error
diagnostic MISSING OPERATOR IN (LAST+EL X) is generated.  (For
example, the user might have meant to say (LAST+EL*X).) Note that if
LAST+EL were the name of a defined function, CLISP would never see
this form.



Since the bad CLISP transformation might not be CLISP at all, for
example, it might be a misspelling of a user function or variable,
DWIM holds all CLISP error messages until after trying other
corrections.  If one of these succeeds, the CLISP message is
discarded.  Otherwise, if all fail, the message is printed (but no
                98
change is made).   For example, suppose the user types (R/PLACA X Y).
CLISP generates a diagnostic, since ((IQUOTIENT R PLACA) X Y) is
obviously not right.  However, since R/PLACA spelling corrects to
/RPLACA, this diagnostic is never printed.



If a CLISP infix construct is well formed from a syntactic standpoint,
                                                         99
but one or both of its operands are atomic and not bound,   it is
possible that either the operand is misspelled, e.g., the user wrote
X+YY for X+Y, or that a CLISP transformation operation was not
intended at all, but that the entire expression is a misspelling.  For
example, if the user has a variable named LAST-EL, and writes
(LIST LAST-ELL).  Therefore, CLISP computes, but does not actually
perform, the indicated infix transformation.  DWIM then continues, and
if it is able to make another correction, does so, and ignores the
CLISP interpretation.  For example, with LAST-ELL, the transformation
LAST-ELL -> LAST-EL would be found.



**FOOTNOTES**
97
    This entire discussion also applies to CLISP transformation
    initiated by calls to DWIM from  dwimify.


98
    Except that CLISP error messages are not printed on type-in.  For
    example, typing X+*Y will just produce a U.B.A. X+*Y message.


99
    For the purpose of  dwimifying,, 'not bound' means no top level
    value, not on list of bound variables built up by  dwimify during
    its analysis of the expression, and not on  nofixvarslst,
    i.e., not previously seen.




                                23.56



If no other transformation is found, and DWIM is about to interpret a
construct as CLISP for which one of the operands is not bound, DWIM
will ask the user whether CLISP was intended, in this case by printing
                         100
LAST-ELL TREAT AS CLISP ?   



The same sort of procedure is followed with 8 and 9 errors.  For
example, suppose the user writes FOO8*X where FOO8 is not bound.  The
CLISP transformation is noted, and DWIM proceeds.  It next asks the
user to approve FOO8*X -> FOO ( *X.  (For example, this would make
sense if the user has (or plans to define) a function named *X.)  If
he refuses, the user is asked whether FOO8*X is to be treated as
CLISP.  Similarly, if FOO8 were the name of a variable, and the user
writes FOOO8*X, he will first be asked to approve
                     101
FOOO8*X -> FOOO ( XX,    and if he refuses, then be offered the
FOOO8 -> FOO8 correction.



CLISP also contains provision for correcting misspellings of infix
operators (other than single characters), IF words, and i.s.
operators.  This is implemented in such a way that the user who does
not misspell them is not penalized.  For example, if the user writes
IF N=0 THEN 1 ELSSE N*(FACT N-1) CLISP does not operate by checking
each word to see if it is a misspelling of IF, THEN, ELSE, or ELSEIF,
since this would seriously degrade CLISP's performance on all IF
statements.  Instead, CLISP assumes that all of the IF words are
spelled correctly, and transforms the expression to
(COND ((ZEROP N) 1 ELSSE N*(FACT N-1))).  Later, after DWIM cannot
find any other interpretation for ELSSE, and using the fact that this
atom originally appeared in an IF statement, DWIM attempts spelling
correction, using (IF THEN ELSE ELSEIF) for a spelling list.  When
this is successful, DWIM 'fails' all the way back to the original IF
statement, changes ELSSE to ELSE, and starts over.  Misspellings of
AND, OR, LT, GT, etc. are handled similarly.



CLISP also contains many Do-What-I-Mean features besides spelling
corrections.  For example, the form (LIST +X Y) would generate a
MISSING OPERATOR error.  However, (LIST -X Y) makes sense, if the



**FOOTNOTES**
100
    If more than one infix operator was involved in the CLISP
    construct, e.g., X+Y+Z, or the operation was an assignment to a
    variable already noticed, or  treatasclispflg is T (initially
    NIL), the user will simply be informed of the correction.
    Otherwise, even if DWIM was enabled in TRUSTING mode, the
    user will be asked to approve the correction.


101
    The 8-9 transformation is tried before spelling correction since
    it is empirically more likely that an unbound atom or undefined
    function containing an 8 or a 9 is a parenthesis error, rather
    than a spelling error.




                                23.57



minus is unary, so DWIM offers this interpretation to the user.
Another common error, especially for new users, is to write
(LIST X*FOO(Y)) or (LIST X*FOO Y), where FOO is the name of a
function, instead of (LIST X*(FOO Y)).  Therefore, whenever an operand
that is not bound is also the name of a function (or corrects to one),
the above interpretations are offered.






 23.15  CLISP Interaction with User



Syntactically and semantically well formed CLISP transformations
are always performed without informing the user.  Other CLISP
transformations described in the previous section, e.g. misspellings
of operands, infix operators, parentheses errors, unary minus - binary
minus errors, all follow the same protocol as other DWIM
transformations (Section 17).  That is, if DWIM has been enabled in
TRUSTING mode, or the transformation is in an expression typed in
by the user for immediate execution, user approval is not requested,
                         102
but the user is informed.    However, if the transformation involves a
user program, and DWIM was enabled in CAUTIOUS mode, the user
will be asked to approve.  If he says NO, the transformation is not
performed.  Thus, in the previous section, phrases such as "one of
these (transformations) succeeds" and "the transformation LAST-ELL ->
LAST-EL would be found" etc., all mean if the user is in CAUTIOUS mode
and the error is in a program, the corresponding transformation will
be performed only if the user approves (or defaults by not
responding).  If the user says NO, the procedure followed is the same
as though the transformation had not been found.  For example, if A*B
appears in the function FOO, and B is not bound (and no other
transformations are found) the user would be asked

                                                           103
                    A*B [IN FOO]  TREAT AS CLISP ?

If the user approved, A*B would be transformed to (ITIMES A B), which
would then cause a U.B.A. B error in the event that the program was
being run (remember the entire discussion also applies to DWIMIFYing).
If the user said NO, A*B would be left alone.





**FOOTNOTES**
102
    However, in certain situations, DWIM will ask for approval even if
    DWIM is enabled in TRUSTING mode.  For example, the user will
    always be asked to approve a spelling correction that might also
    be interpreted as a CLISP transformation, as in
    LAST-ELL -> LAST-EL.


103
    The waiting time on such interactions is three times as long as
    for simple corrections, i.e., 3* dwimwait.




                                23.58



 23.16  CLISP Internal Conventions



Note: the reader can skip this section and proceed to "Function
and Variables" (page 23.61), unless he wants to add new operators, or
modify the action of existing ones (other than by making
declarations).



CLISP is almost entirely table driven by property lists for the
corresponding infix or prefix operators.  Thus it is relatively easy
to add new infix or prefix operators or change old ones, simply by
                                            104
adding or changing selected property values.



CLISPTYPE               The property value of the property
                        CLISPTYPE is the precedence number of the
                                 105
                        operator:    higher values have higher
                        precedence, i.e. are tighter.  Note that the
                        actual value is unimportant, only the value
                        relative to other operators.  For example,
                        CLISPTYPE for :, ^, and * are 14, 6, and 4
                        respectively.  Operators with the same
                        precedence group left to right, e.g., / also
                        has precedence 4, so  A/B*C is (A/B)*C.



                        An operator can have a different left and
                        right precedence by making the value of
                        CLISPTYPE be a dotted pair of two numbers,
                        e.g., CLISPTYPE of _ is (8 . -12).  In
                        this case,  car is the left precedence, and
                         cdr the right, i.e.,  car is used when
                        comparing with operators on the  left, and
                         cdr with operators on the right.  For
                        example, A*B_C+D is parsed as A*(B_(C+D))
                        because the left precedence of _ is 8, which
                        is higher than that of *, which is 4.  The
                        right precedence of _ is -12, which is lower
                        than that of +, which is 2.






**FOOTNOTES**
104
    There is some built in information for handling minus, :, ', <, >,
    and ~, i.e., the user could not himself add such 'special'
    operators, although he can disable them.


105
    Unless otherwise specified, the property is stored on the property
    list of the operator.




                                23.59



                        If the CLISPTYPE property for any infix
                        operator is removed, the corresponding CLISP
                        transformation is disabled, as well as the
                        inverse CLISPIFY transformation.



UNARYOP                 The value of property UNARYOP must be T
                        for unary operators.  The operand is always on
                        the right, i.e., unary operators are always
                        prefix operators.



BROADSCOPE              The value of property BROADSCOPE is T if
                        the operator has lower precedence than
                        INTERLISP forms, e.g., LT, EQUAL, AND, etc.
                        For example, (FOO X AND Y) parses as
                        ((FOO X) AND Y).  If the BROADSCOPE property
                        were removed from the property list of AND,
                        (FOO X AND Y) would parse as (FOO (X AND Y)).



LISPFN                  The value of the property LISPFN is the
                        name of the function to which the infix
                        operator translates.  For example, the value
                        of LISPFN for ^ is EXPT, for ' QUOTE, etc.  If
                        the value of the property LISPFN is NIL, the
                        infix operator itself is also the function
                        e.g., AND, OR, EQUAL.



SETFN                   If FOO has a SETFN property FIE, then
                        (FOO --)_X translates to (FIE -- X).  For
                        example, if the user makes ELT be an infix
                        operator, e.g. #, by putting appropriate
                        CLISPTYPE and LISPFN properties on the
                        property list of # then he can also make #
                        followed by _ translate to SETA, e.g. X#N_Y to
                        (SETA X N Y), by putting SETA on the property
                        list of ELT under the property SETFN.  Putting
                        (ELT) (i.e. list[ELT])) on the property list
                        of SETA under property SETFN will enable SETA
                        forms to CLISPIFY back to ELT's.



CLISPINFIX              The value of this property is the CLISP
                        infix to be used in CLISPIFYing.  This
                        property is stored on the property list of the
                        corresponding INTERLISP function, e.g., the
                        value of property CLISPINFIX for EXPT is ^,
                        for QUOTE is ' etc.



Global declarations operate by changing the corresponding LISPFN and
CLISPINFIX properties.






                                23.60



clispchars              is a list of single character operators
                        that can appear in the interior of an atom.
                        Currently these are: +, -, *, /, ^, ~, ', =,
                        _, :, <, and >.



clispcharray       is a bit table of the characters on
                         clispchars used for calls to  strposl (see
                        Section 10).   clispcharray is initialized by
                        performing

                        (SETQ CLISPCHARRAY (MAKEBITTABLE CLISPCHARS)).



clispinfixes            is a list of infix operators used for
                        spelling correction.



As an example, suppose the user wants to make | be an infix character
operator meaning OR.  He performs:


    _(PUT (QUOTE |) (QUOTE CLISPTYPE)
         (GETP (QUOTE OR) (QUOTE CLISPTYPE)))
    _PUT(| LISPFN OR)
    _PUT(| BROADSCOPE T)
    _PUT(OR CLISPINFIX |)
    _SETQ(CLISPCHARS (CONS (QUOTE |) CLISPCHARS))
    _SETQ(CLISPCHARRAY (MAKEBITTABLE CLISPCHARS))





 23.17  CLISP Functions and Variables



clispflg                if set to NIL, disables all CLISP infix
                        or prefix transformations (but does not affect
                        IF/THEN/ELSE statements, or iterative
                        statements).



                        If  clispflg=TYPE-IN, CLISP transformations
                        are performed only on expressions that are
                        typed in for evaluation, i.e. not on user
                        programs.



                        If  clispflg=T, CLISP transformations are
                        performed on all expressions.



                        The initial value for  clispflg is T.
                         clispifying anything will cause  clispflg to
                        be set to T.



                                23.61



clisparray              hash array used for storing translations.
                         clisparray is checked by  faulteval on
                        erroneous forms before calling DWIM, and by
                        the compiler.



nofixfnslst             list of functions that  dwimify will not
                        try to correct.  See page 23.54.



nofixvarslst            list of variables that  dwimify will not
                        try to correct.  See page 23.54.



nospellflg              If  nospellflg is T,  dwimify will not
                        perform any spelling corrections.  The initial
                        value of  nospellflg is NIL.



dwimify[x;l]            dwimifies  x, i.e., performs all
                        corrections and transformations that would be
                        performed if  x were run.  If  x is an atom
                        and  l is NIL,  x is treated as the name of a
                        function, and its entire definition is
                        dwimified.

                        Otherwise, if  x is a list or  l is not NIL,
                         x is the expression to be dwimified.  If  l
                        is not NIL, it is the edit push-down list
                        leading to  x, and is used for determining
                        context, i.e., what bound variables would be
                        in effect when  x was evaluated, whether  x is
                        a form or sequence of forms, e.g., a cond
                                    106
                        clause, etc.



dwimifyfns[fns]         nlambda, nospread. Dwimifies each
                        function on  fns.  If  fns consists of only
                        one element, the value of car[fns] is used,
                        e.g., dwimifyfns[FOOFNS].  Every 30 seconds,
                         dwimifyfns prints the name of the function it
                        is processing, a la  prettyprint.



dwimifycompflg          if T,  dwimify is called before compiling
                        an expression.  See page 23.54.





**FOOTNOTES**
106
    If  x is an iterative statement and  l is NIL,  dwimify will
    also print the translation, i.e. what is stored in the hash array.




                                23.62



clispdec[declst]        puts into effect the declarations in
                         declst.   clispdec performs spelling
                        corrections on words not recognized as
                        declarations.   clispdec is undoable.



clispify[x;l]           clispifies  x.  If  x is an atom and  l
                        is NIL,  x is treated as the name of a
                        function, and its definition (or EXPR
                        property) is clispified.  After  clispify has
                        finished,  x is redefined (using /PUTD) with
                        its new CLISP definition.  The value of
                         clispify is  x.  If  x is atomic and not the
                        name of a function, spelling correction is
                        attempted.  If this fails, an error is
                        generated.



                        If  x is a list, or  l is not NIL,  x itself
                        is the expression to be clispified.  If l is
                        not NIL, it is the edit push-down list leading
                        to  x and is used to determine context as with
                         dwimify, as well as to obtain the local
                        declarations, if any.  The value of
                         clispify is the clispified version of
                         x.



                        See earlier section on CLISPIFY for more
                        details.



clispifyfns[fns]        nlambda, nospread.  Calls  clispify on
                        each member of  fns under errorset protection.
                        If  fns consists of only one element, the
                        value of car[fns] is used, e.g.,
                        clispifyfns[FOOFNS].  Every 30 seconds,
                         clispifyfns prints the name of the function
                        it is working, a la  prettyprint.  Value is
                        list of functions  clispifyed.



cldisable[op]      disables  op, e.g.  cldisable[-] makes - be
                        just another character.   cldisable can be
                        used on all CLISP operators, e.g. infix
                        operators, prefix operators, iterative
                        statement operators, etc.   cldisable is
                        undoable.



clispiftranflg     affects handling of translations of
                        IF|THEN|ELSE statements.  If T, the
                        translations are stored elsewhere, and the
                        (modified) CLISP retained.  If NIL, the
                        corresponding COND expression, replaces the
                        CLISP.  clispiftranflg is initially NIL. See
                        page 23.27.



                                23.63



cl:flg                  affects  clispify's handling of forms
                        beginning with  car,  cdr, ...  cddddr.  See
                        page 23.52.



clremparsflg            affects  clispify's removal of
                        parentheses from "small" forms.  See page
                        23.52.



clispifypackflg         if T, informs  clispify to pack operator
                        and atomic operands into single atoms; if NIL,
                        no packing is done.  See page 23.52.



clispifyprettyflg       if T, causes  prettyprint to CLISPIFY
                        expressions before printing them.
                         clispifyprettyflg is (temporarily) reset to T
                        when  makefile is called with the option
                        CLISPIFY.  clispifyprettyflg is
                        initially NIL.



prettytranflg           If T, causes  prettyprint to print
                        translations instead of CLISP expressions.
                        This is useful for creating a file for
                        compilation, or for exporting to a LISP system
                        that does not have CLISP.   prettytranflg is
                        (temporarily) reset to T when  makefile is
                        called with the option NOCLISP. If
                         prettytranflg is CLISP% , both the CLISP
                        and translations are printed in appropriate
                        form.  For more details, see page 23.30.
                         prettytranflg is initially NIL.



PPT           is both a function and an edit macro for
                        prettyprinting translations. It performs a PP
                        after first resetting  prettytranflg to T,
                        thereby causing any translations to be printed
                        instead of the corresponding CLISP.



CLISP:                  edit macro that obtains the translation
                        of the correct expression, if any, from
                         clisparray, and calls  edite on it.



funnyatomlst            list of identifiers containing CLISP
                        operators.  Used by  clispify to avoid
                        accidentally constructing a user identifier,
                        e.g., (ITIMES A B) should not become A*B if
                        A*B is the name of a PROG variable.  See page
                        23.52.





                                23.64



CL                      edit macro.  Replaces current expression
                        with CLISPIFYed current expression.  Current
                        expression can be an element or tail.



DW                      edit macro.  DWIMIFYs current expression,
                        which can be an element (atom or list) or
                        tail.



Both CL and DW can be called when the current expression is either an
element or a tail and will work properly.  Both consult the
declarations in the function being edited, if any, and both are
undoable.



lowercase[flg]          If  flg=T,  lowercase makes the necessary
                        internal modifications so that  clispify will
                        use lower case versions of AND, OR, IF, THEN,
                        ELSE, ELSEIF, and all i.s. operators.  This
                        produces more readable output.  Note that the
                        user can always type in either upper or lower
                        case (or a combination), regardless of the
                        action of  lowercase.



                        If  flg=NIL,  clispify will use uppercase
                        versions of AND, OR, et al.  The value of
                         lowercase is its previous 'setting'.
                         Lowercase is undoable.



                         lowercase also sets  model33flg to
                        null[flg], as well as performing
                        raise[null[flg]].   model33flg affects the
                        operation of the spelling corrector to the
                        extent that it says something about the layout
                        of the keyboard (see Section 17).  raise[T] is
                        the same as the TENEX command RAISE, and
                        informs TENEX to raise all lower case
                        characters on input, i.e. convert them to
                        uppercase.  raise[] corresponds to NO RAISE.
                        


















                                23.65



