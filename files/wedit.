(FILECREATED "16-SEP-74 23:48:08" WEDIT.;10 41822  

     changes to:  WEDITCOMS

     previous date: "14-SEP-74 23:41:50" WEDIT.;6)


  (LISPXPRINT (QUOTE WEDITCOMS)
	      T T)
  [RPAQQ WEDITCOMS
	 ((FNS * WEDITFNS)
	  (VARS EDITMACROS EDITOPS MAXLOOP (USERMACROS)
		(HISTORYCOMS (QUOTE (?? REDO FIX USE NAME RETRIEVE DO 
					!N !E !F TYPE-AHEAD  BUFS 
					ETC.)))
		(EDITCOMSA (QUOTE (OK STOP SAVE TTY: E ? PP PP* PPV PPT 
				      P ^ !0 MARK UNDO !UNDO TEST 
				      UNBLOCK _ \ \P __ F BF UP DELETE 
				      NX BK !NX CAP LOWER RAISE NEX 
				      REPACK ?? REDO FIX USE NAME 
				      RETRIEVE DO !N !E !F TYPE-AHEAD 
				      JOINC DW !DW CL CLISP:)))
		(EDITCOMSL (QUOTE (S R R1 RC RC1 E I N P F FS F= ORF BF 
				     NTH IF RI RO LI LO BI BO M NX BK 
				     ORR MBD XTR THRU TO A B : AFTER 
				     BEFORE MV LP LPQ LC LCL _ BELOW SW 
				     BIND COMS LOWER RAISE MAKEFN 2ND 
				     3RD %%F %% REPACK INSERT REPLACE 
				     CHANGE DELETE EMBED SURROUND MOVE 
				     EXTRACT SWITCH ; >; ?? REDO FIX 
				     USE NAME RETRIEVE DO MARK \ SPLITC 
				     EXAM SHOW)))
		(EDITRACEFN)
		(EDITUSERFN))
	  (BLOCKS * EDITBLOCKS)
	  (PROP FILEGROUP WEDIT)
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
		    (ADDVARS (NLAMA ##)
			     (NLAML]
  (RPAQQ WEDITFNS
	 (EDITDEFAULT EDITDEFAULT1 ## EDUP EDIT* EDOR EDRPT EDLOC 
		      EDLOCL EDIT: EDITMBD EDITXTR EDITELT EDITCONT 
		      EDITSW EDITMV EDITTO EDITBELOW EDITRAN TAILP 
		      EDITSAVE EDITH ESUBST ESUBST1))
(DEFINEQ

(EDITDEFAULT
  [LAMBDA (EDITX)
    (PROG (EDITY EDITZ [HISTFLG (AND TYPEIN EDITHIST
				     (NULL (AND REREADFLG (TAILP REREADFLG
								 (CAAAR 
								EDITHISTORY]
		 LISPXHIST)

          (* LISPXHIST is rebound so that messages associated with 
          spelling corrections will not appear on history list.)


          (COND
	    ((AND EDITUSERFN (SETQ EDITY (EDITUSERFN EDITX)))
	      (RETURN (EDITCOM EDITY TYPEIN)))
	    [(AND (LISTP EDITX)
		  (SETQ EDITY (FASSOC (CAR EDITX)
				      EDITOPS)))
	      (RETURN (EDITRAN EDITX (CDR EDITY]
	    [LCFLG (RETURN (COND
			     ((EQ LCFLG T)
			       (EDITQF EDITX))
			     (T                 (* E.g. LCFLG= _ in BELOW 
                                                command.)
				(EDITCOM (LIST LCFLG EDITX)
					 TYPEIN]
	    [(ATOM EDITX)
	      (COND
		((AND EDITHISTORY TYPEIN (FMEMB EDITX HISTORYCOMS))
		  (RETURN (EDITH EDITX)))
		[(FMEMB EDITX EDITCOMSL)
		  (COND
		    ((AND [NULL (CDR (SETQ EDITX
				       (COND
					 (TYPEIN (READLINE EDITRDTBL
							   (LIST EDITX)))
					 ((EQ EDITX (CAR COMS))
					   (EDITSMASH COMS (CONS (CAR COMS)
								 (CDR COMS)))
					   (CAR COMS]
			  (NEQ (CAR EDITX)
			       (QUOTE :)))

          (* : by itself means DELETE if nothing else follows it.
          : is not an atomic command so that : -- will work as a line 
          command.)


		      (ERROR!)))
		  (COND
		    (HISTFLG (FRPLACA (CAAR EDITHISTORY)
				      EDITX]
		[(AND TYPEIN (EQ (NTHCHAR EDITX 1)
				 8))
		  [EDITDEFAULT1 (SETQ EDITY (RPLSTRING EDITX 1 (QUOTE "("]
		  (GNC EDITY)
		  [SETQ EDITX (READLINE EDITRDTBL (LIST (MKATOM EDITY]
		  (COND
		    (HISTFLG (FRPLACA (CAAAR EDITHISTORY)
				      EDITX]
		((AND TYPEIN HISTFLG (FNTYP EDITX)
		      (COND
			([NULL (AND (CDR (SETQ EDITY (READLINE EDITRDTBL
							       (LIST EDITX)
							       T)))
				    (NULL (CDDR EDITY))
				    (OR (NULL (CADR EDITY))
					(LISTP (CADR EDITY)))
				    (NOT (FMEMB (CAADR EDITY)
						EDITCOMSL]
			  (SETQ READBUF (APPEND (CDR EDITY)
						(CONS HISTSTR0 READBUF)))
                                                (* put it back.)
			  NIL)
			(T T)))
		  (EDITDEFAULT1 (QUOTE E)
				EDITX)
		  (FRPLACA (CAAR EDITHISTORY)
			   (SETQ EDITX EDITY))
		  (EDITH (QUOTE !E))
		  (RETURN))
		([AND DWIMFLG (OR TYPEIN (EQ EDITX (CAR COMS)))
		      (SETQ EDITY
			(COND
			  ((AND (EQ (NTHCHAR EDITX -1)
				    (QUOTE P))
				(GLC (SETQ EDITY (MKSTRING EDITX)))
				(SELECTQ (SETQ EDITY (MKATOM EDITY))
					 ((^ _ UP NX BK !NX UNDO REDO CL DW)
					   T)
					 (NUMBERP EDITY)))
                                                (* The GLC removes the last 
                                                character.)
			    (EDITDEFAULT1 EDITY (QUOTE P))
			    (CONS EDITY (QUOTE P)))
			  (T (FIXSPELL EDITX 70 EDITCOMSA (NULL TYPEIN)
				       T]
		  [COND
		    ((LISTP EDITY)
		      [COND
			[TYPEIN (SETQ READBUF (CONS (CDR EDITY)
						    (CONS HISTSTR0 READBUF]
			(T (EDITSMASH COMS (CAR EDITY)
				      (CONS (CDR EDITY)
					    (CDR COMS]
		      (SETQ EDITY (CAR EDITY)))
		    ((NULL TYPEIN)
		      (EDITSMASH COMS EDITY (CDR COMS]
		  (SETQ EDITX EDITY)
		  (GO BACKUP))
		[[AND [CDR (SETQ EDITY (COND
			       (TYPEIN (READLINE EDITRDTBL (LIST EDITX)))
			       ((EQ EDITX (CAR COMS))
				 COMS]
		      (COND
			((NEQ (CAR EDITY)
			      EDITX)

          (* In the call to READLINE above, the user typed control-U 
          and changed the command himself.)


			  T)
			((AND DWIMFLG (SETQ EDITZ (FIXSPELL EDITX 70 EDITCOMSL
							    (NULL TYPEIN)
							    T)))
                                                (* E.g. user types MBBD -- 
                                                without parentheses.)
			  (COND
			    [(LISTP EDITZ)
			      (EDITSMASH EDITY (CAR EDITZ)
					 (CONS (CDR EDITZ)
					       (CDR EDITY]
			    (T (EDITSMASH EDITY EDITZ (CDR EDITY]
		  (AND (NULL TYPEIN)
		       (EDITSMASH COMS (CONS (CAR COMS)
					     (CDR COMS)))
		       (SETQ EDITY (CAR COMS)))
		  (SETQ EDITX EDITY)
		  (COND
		    (HISTFLG (FRPLACA (CAAR EDITHISTORY)
				      EDITX]
		(T (COND
		     (HISTFLG                   (* EDITY was set to READLINE 
                                                above.)
			      (FRPLACA (CAAR EDITHISTORY)
				       EDITY)))
		   (ERROR!]
	    ((AND (EQ (CAR EDITX)
		      (QUOTE !))
		  (NULL (CDR EDITX)))
	      (EDITDEFAULT1 (QUOTE (1)))
	      (FRPLACA EDITX 1))
	    ((AND (EQ (CAR EDITX)
		      (QUOTE #))
		  (NULL (CDR EDITX)))
	      (EDITDEFAULT1 (QUOTE (3)))
	      (FRPLACA EDITX 3))
	    ((AND EDITHISTORY (FMEMB (CAR EDITX)
				     HISTORYCOMS))
	      (RETURN (EDITH EDITX)))
	    [(AND DWIMFLG (ATOM (CAR EDITX))
		  (SETQ EDITY (FIXSPELL (CAR EDITX)
					70 EDITCOMSL (NULL TYPEIN)
					T)))
	      (COND
		[(LISTP EDITY)
		  (EDITSMASH EDITX (CAR EDITY)
			     (CONS (CDR EDITY)
				   (CDR EDITX]
		(T (EDITSMASH EDITX EDITY (CDR EDITX]
	    (T (ERROR!)))
          [RETURN (COND
		    ((EQ REREADFLG (QUOTE ABORT))
		      NIL)
		    ((SETQ EDITY (FASSOC (CAR EDITX)
					 EDITOPS))

          (* Command has been corrected, might as well try the EDITOPS 
          check to avoid going back around through EDITCOM again.)


		      (EDITRAN EDITX (CDR EDITY)))
		    (T (EDITCOM (SETQ COM EDITX)
				TYPEIN]
      BACKUP
          (SETQ COM EDITX)
          (COND
	    (HISTFLG (FRPLACA EDITHISTORY (CDAR EDITHISTORY))
		     (FRPLACA (CDR EDITHISTORY)
			      (SUB1 (CADR EDITHISTORY)))
		     (EDITSAVE COM)

          (* Can't just smash com onto front of history because now 
          that it has been corrected, EDITSAVE may not actually save 
          it, e.g. suppose COM is a misspelled P.)


		     ))
          (RETURN (EDITCOM COM TYPEIN])

(EDITDEFAULT1
  [LAMBDA (X Y)
    (PRIN1 (QUOTE =)
	   T)
    (PRIN2 X T T)
    (COND
      (Y (SPACES 1 T)
	 (PRIN2 Y T T)))
    (TERPRI T)
    (LISPXWATCH SPELLSTATS1])

(##
  [NLAMBDA COMS
    (PROG ((L (EVQ L))
           UNDOLST1
           (LASTAIL (EVQ LASTAIL))
           (MARKLST (EVQ MARKLST))
           (UNFIND (EVQ UNFIND)))

          (* ## is an external entry to the editblock, so local 
          freevariables must be looked up or traps will occur.
          LASAIL, MARKLT, and UNDOLST1 are rebound 
          (and therefore looked up) here to avoid their being changed 
          by the call to ##. The rest are looked up in EDITL0 because 
          it is called with EDITLFLG=nil.)


          (RETURN (CAR (COND
                         ((NULL COMS)
                           L)
                         (T (EDITL0 L COMS])

(EDUP
  [LAMBDA NIL                                   (* Always equivalent to a 0 
                                                followed by an appropriate NTH.)
    (PROG (C-EXP L1 X)
          (SETQ C-EXP (CAR L))
          (COND
	    ((NULL (SETQ L1 (CDR L)))
	      (SETQQ COM "can't - at top.
")
	      (ERROR!))
	    ((TAILP C-EXP (CAR L1))             (* Already UP.)
	      (RETURN))
	    ((AND (EQ C-EXP (CAR LASTAIL))
		  (TAILP LASTAIL (CAR L1)))
	      (SETQ X LASTAIL))
	    ([NOT (SETQ X (MEMB C-EXP (CAR L1]
	      (ERROR!))
	    ((MEMB C-EXP (CDR X))
	      (PRIN2 C-EXP T T)
	      (PRIN1 (QUOTE " - location uncertain.
")
		     T)
	      (ERROR!)))
          [COND
	    ([OR (EQ X (CAR L1))
		 (AND (EQ (CAAR L1)
			  CLISPTRANFLG)
		      (EQ X (CDDAR L1]

          (* Since (NTH 1) is now a nop, to insure that 0 always does 
          something, this check is to take care of 1 followed by UP.)


	      (SETQ L L1))
	    (T (SETQ L (CONS X L1]
          (RETURN])

(EDIT*
  [LAMBDA (N)                                   (* Equivalent to a !0 followed 
                                                by an appropriate number.)
    (CAR (SETQ L (PROG (COM (L L)
                            [X (PROG ((L L))
                                     (EDUP)
                                     (RETURN (CAR L]
                            TEM)

          (* COM is rebound here because EDITCOM resets it so that 
          'CURRENT' command is typed when failure occurs.
          However, want to see BK typed, not !0 or -3)


                       (EDITCOM (QUOTE !0))
                       (SETQ TEM (CAR L))
                       [COND
                         ([COND
                             ((MINUSP N)
                               (SETQ TEM (NLEFT TEM (MINUS N)
                                                X)))
                             (T (LISTP (SETQ TEM (CDR (NTH X N]
                           (SETQ LASTAIL TEM)
                           (RETURN (CONS (CAR TEM)
                                         L]
                       (ERROR!])

(EDOR
  [LAMBDA (COMS)
    (PROG NIL
      LP  [COND
            ((NULL COMS)
              (ERROR!))
            ([NLSETQ (SETQ L (PROG ((L L))
                                   (EDITCOMS (CAR COMS))
                                   (RETURN L]
              (RETURN (CAR L]
          (SETQ COMS (CDR COMS))
          (GO LP])

(EDRPT
  [LAMBDA (EDRX QUIET)
    (PROG ((EDRL L)
	   (EDRPTCNT 0))
      LP  (COND
	    ((AND MAXLOOP (IGREATERP EDRPTCNT MAXLOOP))
	      (PRIN1 (QUOTE "maxloop exceeded.
")
		     T))
	    ((NLSETQ (EDITCOMS EDRX))
	      (SETQ EDRL L)
	      (SETQ EDRPTCNT (ADD1 EDRPTCNT))
	      (GO LP))
	    ((NULL QUIET)
	      (PRIN1 EDRPTCNT T)
	      (PRIN1 (QUOTE " occurrences.
")
		     T)))
          (SETQ L EDRL)                         (* L is left as of last 
                                                successful completion of loop.)
          (RETURN])

(EDLOC
  [LAMBDA (EDX FLG)
    (PROG ((OLDL L)
           (OLDF UNFIND)
           (LCFLG T)
           EDL FINDFLAG COMS)
          (COND
            ((NLISTP EDX)
              (EDITCOM EDX))
            ((AND (NULL (CDR EDX))
                  (NLISTP (CAR EDX)))
              (EDITCOM (CAR EDX)))
            (T (GO LP)))
          (SETQ UNFIND OLDL)
          (RETURN (CAR L))
      LP  (SETQ EDL L)
          [COND
            ((NLSETQ (EDITCOMS EDX))
              (SETQ UNFIND OLDL)
              (RETURN (CAR L]
          (COND
            ((OR FLG (EQUAL EDL L))

          (* If command of form (LC FOO (IF --)) this will check 
          whether failure was because there were no more FOO'S or 
          because of the IF clause. In the latter case, the search 
          continues.)



          (* FLG is T on calls from EDIT:, EDITXTR, EDITMBD, and 
          EDITMV. In this case, the search does not continue, e.g. if 
          user says (MOVE COND 3 TO AFTER --) and the next COND does 
          not have a third clause, the MOVE fails.
          Of course, the user can always type 
          (MOVE (LC COND 3) TO AFTER --) if he intends to search for a 
          COND containing three elements.)


              (SETQ L OLDL)
              (SETQ UNFIND OLDF)
              (ERROR!)))
          (GO LP])

(EDLOCL
  [LAMBDA (COMS)
    (CAR (SETQ L (NCONC (PROG [(L (LIST (CAR L]
                              (EDLOC COMS T)
                              (RETURN L))
                        (CDR L])

(EDIT:
  [LAMBDA (TYPE LC X)
    (PROG (TOFLG)
          [SETQ X (MAPCAR X (FUNCTION (LAMBDA (X)
                              (COND
                                [(EQ (CAR X)
                                     (QUOTE ##))
                                  (PROG ((L L)
                                         UNDOLST1
                                         (LCFLG T))
                                        (RETURN (COPY (EDITCOMS (CDR X]
                                (T X]
          (COND
            (LC [COND
                  ((EQ (CAR LC)
                       (QUOTE HERE))
                    (SETQ LC (CDR LC]
                (EDLOC LC T)))
          (EDUP)
          (SELECTQ TYPE
                   ((B BEFORE)
                     (EDIT2F -1 X))
                   [(A AFTER)
                     (COND
                       ((CDAR L)
                         (EDIT2F -2 X))
                       (T (EDITCOML (CONS (QUOTE N)
                                          X)
                                    COPYFLG]
                   [(: FOR)
                     (COND
                       ((OR X (CDAR L))
                         (EDIT2F 1 X))
                       ((MEMB (CAR L)
                              (CADR L))

          (* Singleton list, e.g. (-- ((A)) --) 
          (DELETE A) -
          result is (-- NIL --); or (-- (A) --) and say 
          (DELETE A 1) result is (-- NIL --))


                         (EDUP)
                         (EDIT2F 1 (LIST NIL)))
                       (T                       (* Delete last element of list 
                                                of more than 1 element.)
                          (EDITCOMS (QUOTE (0 (NTH -2)
                                              (2]
                   (ERROR!))
          (RETURN L])

(EDITMBD
  [LAMBDA (LC X)
    (PROG (Y TOFLG)
          (COND
            (LC (EDLOC LC T)))
          (EDUP)
          [SETQ Y (COND
              (TOFLG (CAAR L))
              (T (LIST (CAAR L]
          [EDIT2F 1 (COND
                    ((NULL (EDITFINDP X (QUOTE *)))
                      (LIST (APPEND X Y)))
                    (T (LSUBST Y (QUOTE *)
                               X]
          [SETQ L (CONS (CAAR L)
                        (COND
                          ((TAILP (CAR L)
                                  (CADR L))     (* To remove the extra 
                                                (annoying) tail.)
                            (CDR L))
                          (T L]
          (RETURN L])

(EDITXTR
  [LAMBDA (LC X)
    (PROG (TOFLG)
          (COND
            ((AND LC (NEQ (CAR LC)
                          (QUOTE HERE)))
              (EDLOC LC T)))
          [PROG ([L (LIST (COND
                            ((TAILP (CAR L)
                                    (CADR L))   (* Effectively does a 1)
                              (CAAR L))
                            (T (CAR L]
                 UNFIND)
                (EDLOC X T)
                (SETQ X (COND
                    ((TAILP (CAR L)
                            (CADR L))
                      (CAAR L))
                    (T (CAR L]
          (EDUP)
          [EDIT2F 1 (COND
                    (TOFLG                      (* APPEND X for undoing.)
                           (APPEND X))
                    (T (LIST X]
          [AND (NULL TOFLG)
               (LISTP (CAAR L))
               (SETQ L (CONS (CAAR L)
                             (COND
                               ((TAILP (CAR L)
                                       (CADR L))
                                                (* To remove the extra 
                                                (annoying) tail caused by the 
                                                UP.)
                                 (CDR L))
                               (T L]
          (RETURN L])

(EDITELT
  [LAMBDA (LC L)
    (PROG (Y)
          (EDLOC LC)
      LP  (SETQ Y L)
          (COND
            ((CDR (SETQ L (CDR L)))
              (GO LP)))
          (RETURN (CAR Y])

(EDITCONT
  [LAMBDA (LC1 LC2)

          (* E.g. (COND CONTAINING RETURN) -
          equivalent to three commands: F COND followed by 
          (LCL RETURN) followed by (_ COND) NOTE: this finds INNERMOST 
          expression, i.e. if a COND contains another COND which 
          contains a return, (COND CONTAINING RETURN) will find the 
          inner one.)


    (SETQ L (PROG ((L L))
                  (SETQ LC1 (EDITFPAT LC1))
              LP  (COND
                    ((NULL (EDIT4F LC1 (QUOTE N)))
                      (ERROR!))
                    ((NULL (NLSETQ (EDLOCL LC2)))
                      (GO LP)))
              LP1 (COND
                    ((NULL (SETQ L (CDR L)))
                      (ERROR!))
                    ([COND
                        ((ATOM LC1)
                          (EQ LC1 (CAAR L)))
                        ((EQ (CAR LC1)
                             (QUOTE ))
                          (EDIT4E LC1 (CAAR L)))
                        (T (EDIT4E LC1 (CAR L]
                      (RETURN L)))
                  (GO LP1])

(EDITSW
  [LAMBDA (M N)
    (PROG ((Y (EDITNTH (CAR L)
                       M))
           (Z (EDITNTH (CAR L)
                       N))
           TEM)
          (SETQ TEM (CAR Y))
          (EDITSMASH Y (CAR Z)
                     (CDR Y))
          (EDITSMASH Z TEM (CDR Z])

(EDITMV
  [LAMBDA (LC OP X)
    (PROG ((L0 L)
	   L1 L2 TOFLG (COM0 COM))
          (COND
	    ((EQ OP (QUOTE HERE))
	      (COND
		((NULL LC)

          (* (MOVE TO HERE --) is the same as 
          (MOVE -- TO HERE))


		  (SETQ LC X)
		  (SETQ X NIL)))
	      (SETQ OP (QUOTE :)))
	    [(EQ (CAR X)
		 (QUOTE HERE))
	      (COND
		((NULL LC)

          (* (MOVE TO AFTER HERE --) is the same as 
          (MOVE -- TO AFTER HERE))


		  (SETQ LC (CDR X))
		  (SETQ X NIL))
		(T (SETQ X (CDR X]
	    ((EQ (CAR LC)
		 (QUOTE HERE))

          (* (MOVE HERE TO AFTER --) is same as 
          (MOVE TO AFTER --))


	      (SETQ LC NIL)))
          (AND X (NEQ (CAR X)
		      (QUOTE TTY:))
	       (EDLOC X T))
          (PROG ((L L0)
		 (LASTAIL LASTAIL))
	        (AND LC (EDLOC LC T))
	        (SETQ L1 L)                     (* L1 will be used to delete the
                                                thing being moved.)
	        (EDUP)
	        (SETQ L2 L))
          (AND (EQ (CAR X)
		   (QUOTE TTY:))
	       (EDLOC X T))

          (* Normally we must locate X first because LC may specify 
          TO's or THRU's which would affect numbers in X, e.g. 
          (MOVE (2 THRU 3) TO AFTER 5) However, it is distracting to 
          do a TTY: first and then have LC fail, so in this special 
          case, we do LC first.)


          (SETQ COM OP)
          (COND
	    ((MEMB (CAAR L2)
		   L)
	      (PRIN1 (QUOTE "destination is inside expression being moved.
")
		     T)
	      (SETQ COM COM0)
	      (ERROR!)))
          [EDITCOML (COND
		      [TOFLG (CONS OP (APPEND (CAAR L2]
		      (T (LIST OP (CAAR L2]     (* This makes COPYFLG be bound 
                                                to NIL while executing this 
                                                command.)
          (PROG ((L L1)
		 (LASTAIL (CAR L2)))
	        (EDITCOMA (QUOTE DELETE)))
          [SETQ UNFIND (COND
	      ((AND LC X)                       (* (MOVE -- TO AFTER --) unfind 
                                                is where you put it.)
		L)
	      ([NULL (AND (CDR L2)
			  (NOT (MEMB (CAR L2)
				     (CADR L2)))
			  (NOT (TAILP (CAR L2)
				      (CADR L2]

          (* E.g. MOVE to --, or MOVE -- to after here.
          UNFIND is where the thing that was moved used to be.)


		L2)
	      (T 

          (* CAR of L2 is not connected to the rest of L2, e.g. occurs 
          when you MOVE the last thing in a list.
          In this case, make UNFIND be equivalent to doing a 0 at the 
          place where the object that was moved used to be.)


		 (CDR L2]
          (RETURN L])

(EDITTO
  [LAMBDA (LC1 LC2 FLG)

          (* Locates LC1 does an UP, and then attempts to do a BI at 
          that level, i.e. LC2 specifies an element in the NTH or BI 
          sense -
          that expression at this level containing C3.)


    (SETQ L (PROG ((L L))
                  (COND
                    (LC1 (EDLOC LC1)
                         (EDUP)))
                  (SETQ COM LC2)
                  (PROG (COM)
                        (BI 1 (COND
                              ((AND (NUMBERP LC1)
                                    (NUMBERP LC2)
                                    (IGREATERP LC2 LC1))
                                (IPLUS LC2 (IMINUS LC1)
                                       1))
                              (T LC2))
                            (CAR L)))
                  [COND
                    ((AND (EQ FLG (QUOTE TO))
                          (CDAAR L))            (* Does not include endpoint.)
                      (RI 1 -2 (CAR L]
                  (EDITCOM 1)

          (* In case segment to be deleted is at beginning of list, 
          this ensures that it is the segment that is deleted, not the 
          list.)


                  (RETURN L)))
    (SETQ TOFLG T])

(EDITBELOW
  [LAMBDA (PLACE DEPTH)                         (* See comment in EDITCOML)
    (PROG ((L0 (PROG ((L L)
                      (LCFLG (QUOTE _)))
                     (EDITCOM PLACE)
                     (RETURN L)))
           L1 N)
          (COND
            ((NULL DEPTH)
              (SETQ COM C)
              (SETQ DEPTH 1))
            ((MINUSP (SETQ COM (EVAL DEPTH)))

          (* If anything goes wrong from hhe on, the error message 
          shuld print the value of DEPTH.)


              (ERROR!))
            (T (SETQ DEPTH COM)))
          (SETQ L1 (REVERSE L))
          (SETQ L0 (FMEMB (CAR L0)
                          L1))
      LP  [COND
            ((NULL L0)
              (ERROR!))
            [(ZEROP DEPTH)
              (FRPLACD L0)
              (SETQ UNFIND L)
              (RETURN (SETQ L (DREVERSE L1]
            ((NOT (TAILP (CADR L0)
                         (CAR L0)))
              (SETQ DEPTH (SUB1 DEPTH]
          (SETQ L0 (CDR L0))
          (GO LP])

(EDITRAN
  [LAMBDA (C DEF)
    (SETQ L
      (OR [PROG ((L L)
                 (L0 L)
                 WORDS C1 TEM)
                (COND
                  ([AND (NULL DEF)
                        (NULL (SETQ DEF (CDR (FASSOC (CAR C)
                                                     EDITOPS]
                    (ERROR!))
                  ((NULL (SETQ WORDS (CAR DEF)))
                    (GO OUT)))
                (COND
                  ([SETQ C1 (SOME C (FUNCTION (LAMBDA (X)
                                      (FMEMB X WORDS]
                    (GO OUT))
                  ([SETQ C1 (SOME C (FUNCTION (LAMBDA (X Y)
                                      (SETQ TEM (FIXSPELL X 70 WORDS
                                                          (NULL TYPEIN)
                                                          Y]
                    (EDITSMASH C1 TEM (CDR C1))
                    (GO OUT))
                  (T (ERROR!)))
            OUT [SETQ TEM
                  (BLKAPPLY (CAR (SETQ DEF (CADR DEF)))
                            (PROG ((#1 (CDR (LDIFF C C1)))
                                   (#2 (CAR C1))
                                   (#3 (CDR C1)))
                                  (RETURN (MAPCAR (CDR DEF)
                                                  (FUNCTION (LAMBDA (X)
                                                      (COND
                                                        ((ATOM X)
                                                (* So you don't have to QUOTE 
                                                atoms.)
                                                          (SELECTQ
                                                            X
                                                            (#1 #1)
                                                            (#2 #2)
                                                            (#3 #3)
                                                            X))
                                                        (T (EVAL X]
                (RETURN (COND
                          ([AND TEM (CDR L0)
                                (NOT (MEMB (CAR L0)
                                           (CADR L0)))
                                (NOT (TAILP (CAR L0)
                                            (CADR L0]
                            TEM)
                          (T L0]
          L])

(TAILP
  [LAMBDA (X Y)                                 (* True if X is A tail of Y X 
                                                and Y non-null.)
                                                (* Included with editor for 
                                                block compilation purposes.)
    (AND X (PROG NIL
             LP  (COND
                   ((NLISTP Y)
                     (RETURN NIL))
                   ((EQ X Y)
                     (RETURN X)))
                 (SETQ Y (CDR Y))
                 (GO LP])

(EDITSAVE
  [LAMBDA (COM)

          (* This function was originally included in HIST but is now 
          in the editor for block compilation.)


    (PROG (X)
          [SELECTQ COM
                   ((SAVE P ? PP PP* E)
                     (RETURN))
                   (COND
                     ((AND (NUMBERP COM)
                           [NUMBERP (CAR (SETQ X (CAAAR EDITHISTORY]
                           (NOT (FMEMB HISTSTR0 X)))
                                                (* CAAR is first entry, CAAAR 
                                                the input.)
                       (NCONC1 X COM)
                       (RETURN X))
                     ((OR (FMEMB COM HISTORYCOMS)
                          (AND (LISTP COM)
                               (FMEMB (CAR COM)
                                      HISTORYCOMS)))
                       (RETURN]
          (SETQ EDITHIST (HISTORYSAVE EDITHISTORY (QUOTE *)
                                      NIL COM))

          (* EDITHIST is bound in EDITL0.
          Note that it is imperative for subsequently storing the undo 
          information to save the history entry BEFORE executing the 
          command since you cannot be sure that the first entry on 
          EDITHISTORY corresponds to the command just completed, e.g. 
          consider a loop command with a TTY in it.)


          (RETURN NIL])

(EDITH
  [LAMBDA (C)
    (PROG (X COMS LINE)
          [SELECTQ C
		   ((DO !E !F !N)

          (* USE is used when operator was incorrect, wheras DO is 
          used when operator was omitted.)


		     [SETQ X (SELECTQ C
				      (!E 

          (* !E is equivalent to DO E, !F to DO F, and !N to DO N.)


					  (QUOTE E))
				      (!F (QUOTE F))
				      (!N (QUOTE N))
				      (COND
					((NULL (SETQ LINE (READLINE EDITRDTBL)))
					  (ERROR!))
					(T (CAR LINE]
		     (SETQ COMS (LISPXFIND EDITHISTORY NIL (QUOTE INPUT)))

          (* If COMS is a LINE command, e.g. FIE FUM, DO COMS is the 
          same as (COMS FIE FUM) If COMS is a list command, e.g. 
          (FIE FUM), same as (COMS (FIE FUM)))


		     [SETQ COMS (COND
			 ((FMEMB HISTSTR0 COMS)
			   (SETQ COM C)
			   (ERROR!))
			 ((OR (EQ X (QUOTE E))
			      (EQ X (QUOTE F)))
                                                (* Always a LINE command)
			   (CONS X COMS))
			 ((CDR COMS)            (* Was a LINE command.)
			   (LIST (CONS X COMS)))
			 (T                     (* Was a list command.)
			    (LIST (LIST X (CAR COMS]
		     (HISTORYSAVE EDITHISTORY (QUOTE *)
				  NIL NIL COMS (LIST (QUOTE *HISTORY*)
						     (CONS C LINE)))
		     (SETQ READBUF COMS)
		     (LISPXWATCH P.A.STATS))
		   (UNDO (NCONC (CAAAR EDITHISTORY)
				(SETQ LINE (READLINE EDITRDTBL)))
			 (SETQ COM NIL)
			 (SETQ X NIL)
			 [MAPC (LISPXFIND EDITHISTORY LINE (QUOTE ENTRIES)
					  T)
			       (FUNCTION (LAMBDA (Y)
				   (AND (SETQ Y (CADDR Y))
					(SETQ X T)
					(UNDOEDITCOM Y T]
			 (COND
			   ((NULL X)
			     (PRIN1 (QUOTE "nothing saved.
")
				    T)))
			 (LISPXWATCH P.A.STATS)
			 (RETURN))
		   (BUFS (LISPX C)            (* Restores input buffers.
                                                Transparent to history.)
			   (RETURN NIL))
		   (RESETLST (RESETSAVE LISPXHISTORY EDITHISTORY)
			     (RESETSAVE (SETREADTABLE EDITRDTBL NIL T)
					(LIST (QUOTE SETREADTABLE)
					      (GETREADTABLE T)
					      NIL T))
                                                (* so reading and printing will 
                                                be done with editreadtable.)
			     (PROGN (SETQ COM NIL)
				    (LISPX C (QUOTE *]

          (* LISPX will set up READBUF. At this point we know C is on 
          the list HISTORYCOMS, so it might be USE, REDO, FIX, etc. 
          Using LISPX this way means new history commands for LISPX 
          can also be used in the editor simply by adding them to the 
          list HISTORYCOMS.)


          (AND READBUF (SETQ EDITHIST (CDDAAR EDITHISTORY)))
                                                (* For saving undo information 
                                                for this command 
                                                (s) back in EDITL1.)
      LP  (COND
	    ((NULL READBUF)
	      (RETURN)))
          (EDITCOM (SETQ COM (LISPXREAD T EDITRDTBL))
		   T)
          (GO LP])

(ESUBST
  [LAMBDA (X Y Z ERRORFLG CHARFLG)

          (* Does a /DSUBST a la R command in editor.
          Thus gives an error if Y not found in Z, and also allows you 
          to specify X and Y using alt-modes, or patterns.
          note that order of arguments is that of SUBST and DSUBST, 
          not R, i.e. Y'S become X'S.)


    (PROG ([L (LIST (SETQ Z (LIST Z]
           COM UNFIND LASTAIL UNDOLST1)
          (COND
            ((NLSETQ (EDIT4F Y X T CHARFLG))
              (AND LISPXHIST (UNDOSAVE (LIST (QUOTE ESUBST1)
                                             UNDOLST1)
                                       LISPXHIST))
              (RETURN (CAR Z)))
            (ERRORFLG (ERROR Y (QUOTE " ?")
                             T)))
          (ERROR!])

(ESUBST1
  [LAMBDA (X)                                   (* Undoes an ESUBST.)
    (MAPC X (FUNCTION (LAMBDA (X)
              (/RPLACA (CAR X)
                       (CADR X))
              (/RPLACD (CAR X)
                       (CDDR X])
)
  [RPAQQ
    EDITMACROS
    ((FIX8 NIL (FIX8))
     (FIX8 (X N)
	   (BIND (E (SETQ #1 (EDITFPAT (QUOTE X)))
		    T)
		 (IF (NOT (ATOM (##)))
		     (1))
		 (COMS (SPLIT89 8 N))
		 (F 8 T)
		 (1)
		 (LI 1)
		 (IF (TAILP (CAR L)
			    (CADR L))
		     (!0)
		     NIL)
		 (LPQ [IF (OR (NULL #1)
			      (NOT (EDIT4E #1 (## 1]
		      UP
		      (RO 1)
		      !0)))
     (FIX9 NIL (FIX9))
     (FIX9 (X N)
	   (BIND (E (SETQ #1 (EDITFPAT (QUOTE X)))
		    T)
		 (IF (NOT (ATOM (##)))
		     (1))
		 (COMS (SPLIT89 9 N))
		 (F 9 T)
		 (E [SETQ #2 (ADD1 (LENGTH (CAR L]
		    T)
		 !0 MARK
		 (LPQ [IF (OR (NULL #1)
			      (NOT (EDIT4E #1 (## 1]
		      UP
		      (E (SETQ #3 (LENGTH (CAR L)))
			 T)
		      (I RI 1 (MINUS #2))
		      (E (SETQ #2 #3)
			 T)
		      1 !0)
		 __
		 (DELETE NX)))
     (CAP NIL RAISE (I 1 (L-CASE (## 1)
				 T)))
     [LOWER (C)
	    (I R (QUOTE C)
	       (L-CASE (QUOTE C]
     (RAISE (C)
	    (I R (L-CASE (QUOTE C))
	       (QUOTE C)))
     [RAISE NIL (IF (NLISTP (##))
		    UP NIL)
	    (I 1 (U-CASE (## 1]
     [LOWER NIL (IF (NLISTP (##))
		    UP NIL)
	    (I 1 (L-CASE (## 1]
     (MAKEFN (FORM ARGS N M)
	     [IF (QUOTE M)
		 ((BI N M)
		  (LC . N)
		  (BELOW \))
		 ((IF (QUOTE N)
		      ((BI N)
		       (LC . N)
		       (BELOW \))
		      ((LI 1]
	     (E [MAP2C (QUOTE ARGS)
		       (CDR (QUOTE FORM))
		       (FUNCTION (LAMBDA (X Y)
					 (/DSUBST X Y (##]
		T)
	     (E [DEFINE (LIST (LIST (CAR (QUOTE FORM))
				    (CONS (QUOTE LAMBDA)
					  (CONS (QUOTE ARGS)
						(##]
		T)
	     UP
	     (1 FORM))
     [2ND X (ORR ((LC . X)
		  (LC . X]
     [3RD X (ORR ((LC . X)
		  (LC . X)
		  (LC . X]
     (%%F (X Y)
	  (E (EDITQF (L-CASE (QUOTE X)
			     (QUOTE Y)))
	     T))
     [%% X (COMS (CONS (CAR (QUOTE X))
		       (COMMENT3 (CDR (QUOTE X))
				 (CAR (LAST L]
     (NEX NIL (BELOW _)
	  NX)
     (NEX (X)
	  (BELOW X)
	  NX)
     [REPACK NIL (IF (LISTP (##))
		     (1)
		     NIL)
	     (I : ([LAMBDA (X Y)
			   (SETQ COM (QUOTE REPACK))
			   [SETQ Y (APPLY (QUOTE CONCAT)
					  (EDITE (UNPACK X]
			   [COND ((NOT (STRINGP X))
				  (SETQ Y (MKATOM Y]
			   (PRINT Y T T]
		 (##]
     (REPACK (X)
	     (LC . X)
	     REPACK)
     (; X MARK [ORR [(I >; (COND ((RAISEP)
				  (QUOTE (* % . X)))
				 (T (QUOTE (* . X]
		    ((E (QUOTE CAN'T]
	__)
     (>; (X)
	 (BIND (MARK #1)
	       0
	       (_ ((*ANY* PROG PROGN COND SELECTQ LAMBDA NLAMBDA 
			  ASSEMBLE)
		   --))
	       (MARK #2)
	       (E (SETQ #3 (SELECTQ (## 1)
				    ((COND SELECTQ)
				     2)
				    1))
		  T)
	       (\ #1)
	       (ORR (1 1)
		    (1)
		    NIL)
	       (BELOW (\ #2)
		      #3)
	       (IF (QUOTE X)
		   [(ORR (NX (B X))
			 ((IF (EQ (## (\ #2)
				      0 1)
				  (QUOTE PROG))
			      NIL
			      (BK))
			  (A X))
			 ((\ #2)
			  (>; X]
		   NIL)))
     (SHOW X MARK (ORF . X)
	   __
	   (LPQ (ORF . X)
		MARK 1 !0 (ORR P NIL)
		__))
     (EXAM X MARK (ORF . X)
	   __
	   (BIND (LPQ (ORF . X)
		      MARK
		      (S #1)
		      1 !0 (ORR P NIL)
		      (S #2)
		      TTY:
		      (S #3)
		      __
		      (IF (NEQ #3 #2)
			  \ NIL)))
	   (E (QUOTE done)))
     (SPLITC (X)
	     (F COND T)
	     (BI 1 X)
	     (-2 COND)
	     (LI 2)
	     UP
	     (BO 1))
     (JOINC NIL (F COND T)
	    UP
	    (BI 1 2)
	    1
	    (BO 2)
	    (2)
	    (RO 1)
	    (BO 1))
     (NOCLISP COMS (RESETVAR CLISPTRANFLG NIL . COMS))
     (NOCLISP NIL (NOCLISP TTY:))
     (CL NIL (BIND (IF (NULL (CDR L))
		       [(IF (FNTYP (##))
			    ((MARK #3)
			     3 UP)
			    ((E (PROGN (SETQQ COM CL)
				       (PRINT (QUOTE can't)
					      T T)
				       (ERROR!]
		       NIL)
		   [IF (TAILP (SETQ #1 (##))
			      (## !0 (E (SETQ #2 L)
					T)))
		       ((I : (CLISPIFY #1 #2))
			(LO 1))
		       ((COMS (CONS (QUOTE :)
				    (CLISPIFY #1 #2))
			      (AND (LISTP (## 1))
				   1]
		   (IF #3 ((\ #3))
		       NIL)))
     (DW NIL (BIND (IF (NULL (CDR L))
		       [(IF (FNTYP (##))
			    ((MARK #3)
			     3 UP)
			    ((E (PROGN (SETQQ COM DW)
				       (PRINT (QUOTE can't)
					      T T)
				       (ERROR!]
		       NIL)
		   (IF (TAILP (SETQ #1 (##))
			      (## !0 (E (SETQ #2 L)
					T)))
		       ((E (DWIMIFY #1 #2)
			   T))
		       ((I : (DWIMIFY #1 #2))
			(IF (LISTP (## 1))
			    1 NIL)))
		   (IF #3 ((\ #3))
		       NIL)))
     (!DW NIL (RESETVAR CLISPRETRANFLG T DW))
     (CLISP: NIL (BIND (E (COND ((SETQ #1 (AND CLISPARRAY
					       (GETHASH (##)
							CLISPARRAY)))
				 (SETQQ COM CLISP:)
				 (EDITE #1))
				(T (PRIN1 (QUOTE "not translated.
")
					  T)))
			  T)))
     (PP* NIL (RESETVAR **COMMENT**FLG NIL PP))
     (PPT NIL (RESETVAR PRETTYTRANFLG T PP]
  [RPAQQ EDITOPS ((INSERT (BEFORE AFTER FOR)
			  (EDIT: #2 #3 #1))
	  (REPLACE (WITH BY)
		   (EDIT: : #1 #3))
	  (CHANGE (TO)
		  (EDIT: : #1 #3))
	  (DELETE NIL (EDIT: : #1))
	  (EMBED (IN WITH)
		 (EDITMBD #1 #3))
	  (SURROUND (WITH IN)
		    (EDITMBD #1 #3))
	  (MOVE (TO)
		(EDITMV #1 (CAR #3)
			(CDR #3)))
	  (EXTRACT (FROM)
		   (EDITXTR #3 #1))
	  (SWITCH (AND)
		  (EDITSW #1 #3]
  (RPAQQ MAXLOOP 30)
  (RPAQ USERMACROS)
  (RPAQQ HISTORYCOMS
	 (?? REDO FIX USE NAME RETRIEVE DO !N !E !F TYPE-AHEAD  BUFS
ETC.))
  (RPAQQ EDITCOMSA
	 (OK STOP SAVE TTY: E ? PP PP* PPV PPT P ^ !0 MARK UNDO !UNDO 
	     TEST UNBLOCK _ \ \P __ F BF UP DELETE NX BK !NX CAP LOWER 
	     RAISE NEX REPACK ?? REDO FIX USE NAME RETRIEVE DO !N !E !F 
	     TYPE-AHEAD JOINC DW !DW CL CLISP:))
  (RPAQQ EDITCOMSL
	 (S R R1 RC RC1 E I N P F FS F= ORF BF NTH IF RI RO LI LO BI BO 
	    M NX BK ORR MBD XTR THRU TO A B : AFTER BEFORE MV LP LPQ LC 
	    LCL _ BELOW SW BIND COMS LOWER RAISE MAKEFN 2ND 3RD %%F %% 
	    REPACK INSERT REPLACE CHANGE DELETE EMBED SURROUND MOVE 
	    EXTRACT SWITCH ; >; ?? REDO FIX USE NAME RETRIEVE DO MARK \ 
	    SPLITC EXAM SHOW))
  (RPAQ EDITRACEFN)
  (RPAQ EDITUSERFN)
  [RPAQQ EDITBLOCKS
	 ((EDITBLOCK EDITL EDITL0 EDITL1 UNDOEDITL EDITCOM EDITCOMA 
		     EDITCOML EDITMAC EDITCOMS EDIT!UNDO UNDOEDITCOM 
		     UNDOEDITCOM1 EDITCOM1 EDITSMASH EDITNCONC EDIT1F 
		     EDIT2F EDITNTH BPNT BPNT0 BPNT1 RI RO LI LO BI BO 
		     EDITDEFAULT EDITDEFAULT1 ## EDUP EDIT* EDOR EDRPT 
		     EDLOC EDLOCL EDIT: EDITMBD EDITXTR EDITELT 
		     EDITCONT EDITSW EDITMV EDITTO EDITBELOW EDITRAN 
		     TAILP EDITSAVE EDITH
		     (ENTRIES EDITL EDITL0 ## UNDOEDITL BPNT0)
		     (SPECVARS L ATM COM LCFLG #1 #2 #3 UNDOLST 
			       UNDOLST1 LASTAIL MARKLST UNFIND LASTP1 
			       LASTP2 COMS EDITCHANGES EDITHIST0)
		     (RETFNS EDITL0)
		     (BLKAPPLYFNS RI RO LI LO BI BO EDIT: EDITMBD 
				  EDITMV EDITXTR EDITSW)
		     (BLKLIBRARY NTH LAST MEMB NLEFT LISPXWATCH)
		     (NOLINKFNS PRINTDEF EDITRACEFN EDITUSERFN)
		     (LOCALFREEVARS FINDFLAG EDITHIST UNDOLST1 COM L L0 
				    COM0 UNDOLST EDITLFLG ATM MARKLST 
				    EDITHIST0 UNFIND TYPEIN LCFLG 
				    LASTP1 LASTP2 LASTAIL COPYFLG COMS 
				    TOFLG C LVL EDITCHANGES)
		     (GLOBALVARS EDITCALLS P.A.STATS EDITUNDOSTATS 
				 EDITUNDOSAVES SPELLSTATS1 P.A.STATS 
				 EDITUSERFN EDITIME))
	  (EDITFINDBLOCK EDIT4E EDIT4E1 EDITQF EDIT4F EDITFPAT 
			 EDITFPAT1 EDIT4F1 EDIT4F2 EDIT4F3 EDITSMASH 
			 EDITFINDP EDITBF EDITBF1 ESUBST
			 (ENTRIES EDIT4E EDIT4E1 EDITQF EDIT4F EDITFPAT 
				  EDITFINDP EDITBF ESUBST)
			 (LOCALFREEVARS C3 CHANGEFLG N TOPLVL FF NEWFLG 
					FLG)
			 (GLOBALVARS EDITUNDOSAVES))
	  (EDITFBLOCK EDITF EDITV EDITP EDITF0 EDITF1
		      (ENTRIES EDITF EDITV EDITP EDITF0 EDITF1)
		      (SPECVARS EDITCHANGES]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
  (BLOCK: EDITBLOCK EDITL EDITL0 EDITL1 UNDOEDITL EDITCOM EDITCOMA 
	  EDITCOML EDITMAC EDITCOMS EDIT!UNDO UNDOEDITCOM UNDOEDITCOM1 
	  EDITCOM1 EDITSMASH EDITNCONC EDIT1F EDIT2F EDITNTH BPNT BPNT0 
	  BPNT1 RI RO LI LO BI BO EDITDEFAULT EDITDEFAULT1 ## EDUP 
	  EDIT* EDOR EDRPT EDLOC EDLOCL EDIT: EDITMBD EDITXTR EDITELT 
	  EDITCONT EDITSW EDITMV EDITTO EDITBELOW EDITRAN TAILP 
	  EDITSAVE EDITH (ENTRIES EDITL EDITL0 ## UNDOEDITL BPNT0)
	  (SPECVARS L ATM COM LCFLG #1 #2 #3 UNDOLST UNDOLST1 LASTAIL 
		    MARKLST UNFIND LASTP1 LASTP2 COMS EDITCHANGES 
		    EDITHIST0)
	  (RETFNS EDITL0)
	  (BLKAPPLYFNS RI RO LI LO BI BO EDIT: EDITMBD EDITMV EDITXTR 
		       EDITSW)
	  (BLKLIBRARY NTH LAST MEMB NLEFT LISPXWATCH)
	  (NOLINKFNS PRINTDEF EDITRACEFN EDITUSERFN)
	  (LOCALFREEVARS FINDFLAG EDITHIST UNDOLST1 COM L L0 COM0 
			 UNDOLST EDITLFLG ATM MARKLST EDITHIST0 UNFIND 
			 TYPEIN LCFLG LASTP1 LASTP2 LASTAIL COPYFLG 
			 COMS TOFLG C LVL EDITCHANGES)
	  (GLOBALVARS EDITCALLS P.A.STATS EDITUNDOSTATS EDITUNDOSAVES 
		      SPELLSTATS1 P.A.STATS EDITUSERFN EDITIME))
  (BLOCK: EDITFINDBLOCK EDIT4E EDIT4E1 EDITQF EDIT4F EDITFPAT EDITFPAT1 
	  EDIT4F1 EDIT4F2 EDIT4F3 EDITSMASH EDITFINDP EDITBF EDITBF1 
	  ESUBST (ENTRIES EDIT4E EDIT4E1 EDITQF EDIT4F EDITFPAT 
			  EDITFINDP EDITBF ESUBST)
	  (LOCALFREEVARS C3 CHANGEFLG N TOPLVL FF NEWFLG FLG)
	  (GLOBALVARS EDITUNDOSAVES))
  (BLOCK: EDITFBLOCK EDITF EDITV EDITP EDITF0 EDITF1
	  (ENTRIES EDITF EDITV EDITP EDITF0 EDITF1)
	  (SPECVARS EDITCHANGES))
]
(DEFLIST(QUOTE(
  (WEDIT (EDIT WEDIT))
))(QUOTE FILEGROUP))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA ##)
  (ADDTOVAR NLAML)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (1559 32243 (EDITDEFAULT 1571 . 7522) (EDITDEFAULT1
7526 . 7705) (## 7709 . 8404) (EDUP 8408 . 9432) (EDIT* 9436 . 10556)
(EDOR 10560 . 10900) (EDRPT 10904 . 11486) (EDLOC 11490 . 12859) (EDLOCL
12863 . 13060) (EDIT: 13064 . 14933) (EDITMBD 14937 . 15686) (EDITXTR
15690 . 17059) (EDITELT 17063 . 17255) (EDITCONT 17259 . 18360) (EDITSW
18364 . 18655) (EDITMV 18659 . 21373) (EDITTO 21377 . 22643) (EDITBELOW
22647 . 23687) (EDITRAN 23691 . 26150) (TAILP 26154 . 26703) (EDITSAVE
26707 . 28134) (EDITH 28138 . 31193) (ESUBST 31197 . 31990) (ESUBST1
31994 . 32240)))))
STOP
