(FILECREATED "10-OCT-74 19:03:22" CLISPIFY.;3 120258 

     changes to:  LOWERCASE CLISPIFYCOMS

     previous date: "13-SEP-74 04:21:08" CLISPIFY.;2)


  (LISPXPRINT (QUOTE CLISPIFYCOMS)
	      T T)
  [RPAQQ CLISPIFYCOMS
	 ((FNS * CLISPIFYFNS)
	  [E (CLISPDEC (QUOTE (STANDARD INTEGER]
	  (VARS (CLISPFLG T)
		(FUNNYATOMLST)
		I.S.OPRLST CLISPFORWORDSPLST CLISPIFWORDSPLST
		(CLISPTRANFLG (QUOTE CLISP% ))
		(CLISPIFTRANFLG)
		(CLISPRETRANFLG)
		(CLREMPARSFLG NIL)
		(CL:FLG T)
		CLISPINFIXES CAR/CDRSTRING (CLISPIFYPACKFLG T)
		(CLISPCHARS (QUOTE (^ * / + - = _ : ' ~ +- ~= < > @)))
		(CLISPCHARRAY (MAKEBITTABLE CLISPCHARS))
		CLISPRECORDTYPES)
	  (IFPROP (CLISPTYPE LISPFN UNARYOP CLISPCLASS CLISPCLASSDEF CLISPNEG)
		  * CLISPCHARS)
	  (IFPROP (CLISPTYPE LISPFN UNARYOP CLISPINFIX CLISPCLASS CLISPCLASSDEF 
			     CLISPNEG BROADSCOPE)
		  * DECLWORDS)
	  (IFPROP (CLISPTYPE LISPFN UNARYOP CLISPINFIX CLISPCLASS CLISPCLASSDEF 
			     CLISPNEG BROADSCOPE)
		  * CLISPWORDS)
	  (PROP SETFN ELT SETA)
	  (PROP CLISPFORM ZEROP ADD1 SUB1 NEQ)
	  (PROP CLISPTYPE ~EQUAL ~MEMBER ~MEMB)
	  (PROP NARGS * NARGSLST)
	  (PROP CLMAPS MAPC MAP MAPCAR MAPLIST MAPCONC MAPCON SUBSET)
	  (PROP CLISPWORD * I.S.OPRLST)
	  (PROP CLISPWORD IF THEN ELSE ELSEIF if then else elseif AND OR and or 
		! !! CREATE USING COPYING FETCH REPLACE create using copying 
		fetch replace with of WITH OF CLISP clisp MATCH match)
	  (IFPROP I.S.TYPE * I.S.OPRLST)
	  (BLOCKS * CLISPIFYBLOCKS)
	  (P (LOWERCASE T))
	  (DECLARE: DOEVAL@COMPILE DONTCOPY (PROP BLKLIBRARYDEF GETP))
	  (FNS RECORD)
	  [P (MAPC CLISPRECORDTYPES (FUNCTION (LAMBDA (X)
						      (/MOVD (QUOTE RECORD)
							     X]
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
		    (ADDVARS (NLAMA RECORD CLISPIFYFNS)
			     (NLAML]
  (RPAQQ CLISPIFYFNS
	 (CLISPIFYFNS CLISPIFY CLISPIFY1 CLISPIFY2 CLISPIFY2A CLISPIFY2B 
		      CLISPIFY2C CLISP3 CLISP3A CLISPACKUP CLISP3B CLISP4 
		      CLISPCOND CLISPCOND1 CLISPAND CLISPAND1 CLISPIFYNOT 
		      CLREMPARS CLISPIFYCROPS0 CLISPIFYCROPS CLISPIFYCROPS1 
		      CLISPIFYRPLAC CLISPIFYMAPS CLMAPS1 CLMAPS2 CLISPDEC 
		      CLISPDEC0 CLISPDEC1 EXPRCHECK CLSTOPSCAN? CLISPIFYLOOKUP 
		      CLISPLOOKUP0 CLISPLOOKUP1 CLISPLOOKUP2 LOWERCASE 
		      SHRIEKIFY SHRKFY SHRKFY2 WHILEDOUNTIL WHILEDO1 CLDISABLE))
(DEFINEQ

(CLISPIFYFNS
  [NLAMBDA FNS
    (PROG ((CLK (CLOCK 0))
	   TEM)
          (RETURN (MAPCONC (COND
			     ((AND (NULL (CDR FNS))
				   (NULL (EXPRCHECK (CAR FNS)
						    T)))
			       (STKEVAL (QUOTE CLISPIFYFNS)
					(CAR FNS)
					(QUOTE INTERNAL)))
			     (T FNS))
			   (FUNCTION (LAMBDA (X)
			       (COND
				 ((IGREATERP (IDIFFERENCE (SETQ TEM
							    (CLOCK 0))
							  CLK)
					     30000)
				   (SETQ CLK TEM)
				   (PRIN2 X T T)
				   (PRIN1 (QUOTE ", ")
					  T)))
			       (ERSETQ (CLISPIFY X])

(CLISPIFY
  [LAMBDA (X L)

          (* If X is an atom and EXPR is NIL, X is treated as the name 
          of a function, and after CLISPIFYING, the functin will be 
          redfined. Otherwise, X is an expression, EXPR the 
          (optional) top level xpression, e.g. X is a part of a 
          function, and EXPR is its defintion, and PARENT is X's 
          immediate PARENT. NOte that X can be a form or a tail, as 
          indicated by wheter it is a member or tail of PARENT.)


    (LISPXWATCH CLISPIFYSTATS)
    (PROG (TEM FN OPR0 CLTYP0 BROADSCOPE DECLST EXPR VARS PARENT SUBPARENT FORM 
	       SEG TAIL LST)
          (COND
	    [(OR (LISTP X)
		 L)
	      (COND
		((NULL L)
		  (SETQ EXPR X))
		(T (SETQ PARENT (CAR L))
		   (AND (TAILP (SETQ TEM (EVQ LASTAIL))
			       (CAR L))
			(SETQ TAIL TEM))
		   [COND
		     ((LISTP (SETQ FN (EVQ ATM)))
                                                (* New editor conventions.)
		       (SETQ FN (CAR FN]        (* ATM is bound in EDITE)
		   (SETQ VARS (DWIMIFY3 L))     (* DWIMIFY3 climbs L and gathers
                                                up the VARS, and alo sets EXPR.)
		   ]
	    (T [SETQ FORM (SETQ EXPR (EXPRCHECK (SETQ FN X]
                                                (* EXPRCHECK uses FN freely, 
                                                i.e. it resets it if spelling 
                                                correctionis performed.)
	       ))
          (AND (NULL FN)
	       (SETQQ FN TYPE-IN))
          (SETQ DECLST (GETLOCALDEC EXPR FN))
          [COND
	    ((NULL FORM)                        (* Corresponds to first clause 
                                                in first COND.)
	      (RETURN (COND
			((NULL L)               (* E.G. User just types in 
                                                CLISPIFY some expression.)
			  (CLISPIFY2 X))
			((TAILP X PARENT)
			  (SETQ FORM PARENT)
			  (SETQ TEM (CLISPIFY1 X))
			  (CONS (CAR TEM)
				(CDR TEM)))
			([OR (EQ (CAAR L)
				 (QUOTE COND))
			     (AND (EQ (CAAR L)
				      (QUOTE SELECTQ))
				  (NEQ X (CADAR L))
				  (CDR (FMEMB X PARENT]
			  (SETQ FORM (CAR X))

          (* The LIST is because while this expression should be 
          CLISPIFIED as a tail (it being a COND clause), it is an 
          element in the structure and the CL macro is expecting a 
          list returned.)


			  (LIST (CLISPIFY1 X)))
			(T                      (* Commands expect a list 
                                                returned)
			   (CLISPIFY2A X]
          (SETQ TEM (CLISPIFY2 EXPR))
          (RETURN (COND
		    ((NULL FN)
		      TEM)
		    (T (COND
			 ((NULL (GETD FN))
			   (DWIMUNSAVEDEF FN T)))
		       (/PUTD FN TEM)
		       (AND FILEPKGFLG (NEWFILE? FN))
		       FN])

(CLISPIFY1
  [LAMBDA (TAIL OPR0 CLTYP0 BROADSCOPE NOVALFLG SUBPARENT)

          (* Processes tails. When OPR0 is not NIL, called from 
          CLISP3, and inserts OPR0 between each call to CLISPIFY2.
          If BROADSCOPE is T, OPR0 is an operator with higher 
          precedence than user functions, e.g. EQ, LS, AND, etc. In 
          this case, the arguments need not be parenthesized, e.g. 
          (AND (FOO X) Y) -> (FOO X AND Y))


    (PROG (SEG TEM LST (TAIL0 TAIL)
	       (PARENT FORM)
	       Z)
          (COND
	    ((NULL SUBPARENT)

          (* PARENT and SUBPARENT are used in CLISP4 for checking for 
          partial CLISPIFICATION and resulting calls to DWIMIFY.
          e.g. when CLISPIFYING and expression like 
          (FOO X* (IPLUS X Y)) it is necessary to backup and DWIMIFY, 
          but for (SELECTQ X (X* (IPLUS X Y)) NIL) it is not.
          PARENT and SUBPARENT are rebound in CLISPIFY1 
          (rather than CLISPIFY2). Therefore they are alsoebound by 
          functions that recurse by calling CLISPIFY2 directly, i.e. 
          CLISPIFYRPLAC, CLISPIFYCROPS, and CLISPIFYCOND.)


	      (SETQ SUBPARENT TAIL)))
          [COND
	    ((EQ NOVALFLG (QUOTE NOTLAST))

          (* Says all forms are nor being used for value, EXCEPT for 
          last one.)


	      (SETQ NOVALFLG (FLAST TAIL]
      LP  [COND
	    [(NULL TAIL)
	      (RETURN (COND
			((NULL LST)
			  TAIL0)
			(TAIL0 (NCONC LST TAIL0))
			(T LST]
	    [(NLISTP TAIL)
	      (RETURN (COND
			(TAIL0 (NCONC LST TAIL0))
			(T (FRPLACD (FLAST LST)
				    TAIL)
			   LST]
	    (OPR0 (COND
		    (LST (NCONC1 LST OPR0))
		    ((GETP OPR0 (QUOTE UNARYOP))
		      (SETQ LST (LIST OPR0]
          [SETQ TEM (COND
	      ((AND (ATOM Z)
		    (EQ (NTHCHAR Z -1)
			(QUOTE ')))
		(CAR TAIL))
	      (T (CLISPIFY2 (CAR TAIL)
			    (COND
			      ((EQ NOVALFLG T))
			      (NOVALFLG (NEQ TAIL NOVALFLG]
          (SETQ Z (CAR TAIL))
          [COND
	    ((OR SEG (NEQ TEM (CAR TAIL))
		 OPR0
		 (EQ CLTYP0 T))

          (* The idea in CLISPIFYing is to do as few CONSes as 
          necessary, i.e. only construct new structure where needed.
          TAIL0 keeps track of the last point in TAIL for which a 
          corresponding element has been added to L.
          Here we know that a new element will hve to be added to L, 
          and so any intermediate elements that were not added because 
          the clispified result was the same as the original 
          structure, will now have to be added, e.g. consider 
          (LIST A B (SETQ X Y) C D E). The C D and E tail need not be 
          copied, however until we reach 
          (SETQ X Y) we do not know that the A and B will have to be 
          copied, i.e in (LIST A B C) no conses are performed.
          Note that CLTYP0=T is effectively a COPYFLG.
          This is used in particular when CLISPIFYING a COND, i.e. 
          OPR0 is NIL, but CLTYP0 isT.)


	      [AND (NEQ TAIL TAIL0)
		   (SETQ LST (NCONC LST (LDIFF TAIL0 TAIL]
	      [SETQ LST (COND
		  (SEG 

          (* Supposedly, whenever SEG is set to T, the entire form has 
          already been copied. An EQ check is not sufficient, as 
          expressions produced by CLIPIFYing may not be EQ to original 
          expressions, but still have common tails.)


		       (NCONC LST TEM))
		  (T (NCONC1 LST TEM]
	      (SETQ TAIL0 (CDR TAIL]
          (SETQ TAIL (CDR TAIL))
          (SETQ SEG NIL)
          (GO LP])

(CLISPIFY2
  [LAMBDA (FORM NOVALFLG NEGFLG)                (* CLISPIFIES a form.)
                                                (* NOVALFLG is T if FORM is not 
                                                being used for value.)
    (AND FORM (PROG NIL
                LP  (RETURN (OR (CLISPIFY2B FORM)
                                (GO LP)))

          (* CLISPIFY2b returns NIL (via a RETFROM in CLISP3) when it 
          was necessary to DWWIMIFY the prent expression and staat 
          over, e.g. (FOO X* (IPLUS Y Z)))


                ])

(CLISPIFY2A
  [LAMBDA (FORM FLG)

          (* Whereas the value of CLISPIFY2 is either an item or a 
          segment, depending on SEG, the value of CLISPIFY2A is always 
          a segment, so thatthe caaling function need not check SEG, 
          it can just NCONC or APPEND.)


    (PROG (TEM SEG)
          (SETQ TEM (CLISPIFY2 FORM))
          (RETURN (COND
                    ([AND SEG (OR (NULL FLG)
                                  (NULL (CDR TEM]

          (* If FLG is T, the expression is to be parenthesized, even 
          if SEG is T, unless it is just atomic.)


                      TEM)
                    (T (LIST TEM])

(CLISPIFY2B
  [LAMBDA (FORM)

          (* Does the work of CLISIPIFY2.
          This function is separate from CLISPIFY2 so that CLISPIFYNOT 
          can CLISPIFY the inner form, and then check to ee if NEGLFG 
          has been set to NIL. It is also used when a for a 
          'recursive' call on the same or equivalent form, again so 
          that NEGFLG is not rebound, e.g. 
          (ZEROP --) is the same as (EQ -- 0), and is implemented by 
          caaling CLISPIFY2b again, itead of CLISPIFY2.)


    (PROG (TEM1 TEM2 TEM3)
      TOP [COND
	    ((NLISTP FORM)
	      (COND
		([AND (LISTP CLTYP0)
		      (SETQ TEM1 (GETP FORM (QUOTE CLISPWORD)))
		      (EQ (CAR TEM1)
			  (CAR (GETP (CAR CLTYP0)
				     (QUOTE CLISPWORD]
		  [AND LCASEFLG (SETQ TEM2 (COND
			   ((NLISTP (CDR TEM1))
			     (CDR TEM1))
			   (T 

          (* The CLISPWORD property can be of the form 
          (FIND find FOR) when FIND is a synonym for FOR.)


			      (CADR TEM1]       (* Converts FOR words and IF 
                                                words to loercase.)
		  (SETQ CLTYP0 TAIL)))
	      (RETURN (OR TEM2 FORM)))
	    ((LISTP (CAR FORM))
	      (RETURN (CLISPIFY1 FORM]
          [RETURN
	    (SELECTQ
	      (CAR FORM)
	      [[LAMBDA NLAMBDA]
		(AND (LISTP (CADR FORM))
		     (SETQ VARS (APPEND (CADR FORM)
					VARS)))

          (* This is a quick and dirty attempt to collect vars in cse 
          have to call DWIMIFY1B. VARS are not rebound each 
          expression, so open lambda variables will justbuild up.)


		(CONS (CAR FORM)
		      (CONS (CADR FORM)
			    (CLISPIFY1 (CDDR FORM)
				       NIL NIL NIL (OR NOVALFLG (QUOTE NOTLAST]
	      (FUNCTION (CLISPIFY2C FORM))
	      [CAR (CLISPIFYCROPS0 (QUOTE (:1]
	      [CDR (CLISPIFYCROPS0 (QUOTE (::1]
	      ((LAST FLAST)
		(AND (NEQ (CAR FORM)
			  (CLISPIFYLOOKUP (CAR FORM)
					  (CADR FORM)
					  (CADDR FORM)))
		     (GO A))
		(CLISPIFYCROPS0 (LIST -1)))
	      [NLEFT (COND
		       [(AND (NUMBERP (SETQ TEM1 (CADDR FORM)))
			     (NULL (CDDDR FORM)))
			 (CLISPIFYCROPS0 (LIST (MINUS TEM1]
		       (T (GO A]
	      [(NTH FNTH)                       (* (NTH X 10) clispifies to 
                                                X::9)
		(COND
		  [[AND CL:FLG (NUMBERP (CADDR FORM))
			(EQ (CAR FORM)
			    (CLISPIFYLOOKUP (CAR FORM)
					    (CADR FORM]
		    (CLISPIFYCROPS0 (LIST (SUB1 (CADDR FORM]
		  (T (GO A]
	      ((RPLACA FRPLACA /RPLACA)
		(CLISPIFYRPLAC FORM (QUOTE :1)
			       T))
	      ((RPLACD FRPLACD /RPLACD)
		(CLISPIFYRPLAC FORM (QUOTE ::1)
			       T))
	      ((CLISP: GO DECLARE)
		FORM)
	      (* (COND
		   ((EQ (CADR FORM)
			(QUOTE DECLARATIONS:))
		     (CONS (QUOTE CLISP:)
			   (CDDR FORM)))
		   (T FORM)))
	      (COND
		(COND
		  [(CDR FORM)
		    (FRPLACA (PROG ((L FORM)
				    VAL)        (* An open MAPCONC.)
			       LP  (COND
				     ((NULL (SETQ L (CDR L)))
				       (RETURN VAL)))
			           (SETQ VAL (NCONC VAL (CLISPCOND
						      (CAR L)
						      (CDR L)
						      VAL)))
			           (GO LP))
			     (COND
			       (LCASEFLG (QUOTE if))
			       (T (QUOTE IF]
		  (T FORM)))
	      [AND (COND
		     [NOVALFLG                  (* Treat AND as COND.)
			       (FRPLACA (CLISPAND FORM)
					(COND
					  (LCASEFLG (QUOTE if))
					  (T (QUOTE IF]
		     (T (GO A]
	      [OR (COND
		    [(AND NOVALFLG (NULL (CDDDR FORM)))
		      (FRPLACA (CLISPCOND (CONS (LIST (QUOTE NOT)
						      (CADR FORM))
						(CDDR FORM)))
			       (COND
				 (LCASEFLG (QUOTE if))
				 (T (QUOTE IF]
		    (T (GO A]
	      [SELECTQ (CLISP4 (CDR FORM))
		       (CLISP4 (CDDR FORM)
			       FORM
			       (CDR FORM))
		       (SETQ PARENT FORM)
		       (SETQ SUBPARENT (CDR FORM))
		       (SETQ TEM1 (CLISPIFY2A (CADR FORM)
					      T))
		       [SETQ TEM2 (MAPCAR
			   (SETQ FORM (CDDR FORM))
			   [FUNCTION (LAMBDA (FORM)
			       (CONS (CAR FORM)
				     (CLISPIFY1 (CDR FORM)
						NIL NIL NIL
						(OR NOVALFLG (QUOTE NOTLAST]
			   (FUNCTION (LAMBDA NIL
			       (AND (CDDR FORM)
				    (SETQ FORM (CDR FORM]
		       (CONS (QUOTE SELECTQ)
			     (NCONC TEM1 TEM2 (CLISPIFY2A (CADR FORM)
							  T]
	      (PROGN [SETQ TEM1 (CLISPIFY1 (CDR FORM)
					   NIL NIL NIL (OR NOVALFLG
							   (QUOTE NOTLAST]
		     (CLISPIFY2C FORM TEM1))
	      [PROG (RETURN
		      (CONS
			(QUOTE PROG)
			(CONS [MAPCAR (CADR FORM)
				      (FUNCTION (LAMBDA (X)
					  (COND
					    ((ATOM X)
					      (SETQ VARS (CONS X VARS))
					      X)
					    (T (SETQ VARS (CONS (CAR X)
								VARS))
					       (CONS (CAR X)
						     (CLISPIFY1 (CDR X]
			      (CLISPIFY1 (WHILEDOUNTIL (CDDR FORM))
					 NIL NIL NIL T]
	      [NULL (COND
		      ([AND (LISTP (CADR FORM))
			    (OR (EQ (GETP (SETQ TEM1 (CAADR FORM))
					  (QUOTE CTYPE))
				    (QUOTE PRED))
				(GETP TEM1 (QUOTE CLISPTYPE]

          (* e.g. (NULL (NUMBERP X)) is treated as 
          (NOT (NUMBERP X)))


			(CLISPIFYNOT (CADR FORM)))
		      (T (SETQ FORM (LIST (QUOTE EQ)
					  (CADR FORM)
					  NIL))
			 (GO TOP]
	      (NOT (CLISPIFYNOT (CADR FORM)))
	      (SETQ (SETQ VARS (CONS (CADR FORM)
				     VARS))     (* In case any dwimifying occurs
                                                as a result of partial 
                                                clispification.)
		(GO A))
	      [SETQQ (COND
		       ((AND CLISPFLG (GETP (QUOTE _)
					    (QUOTE CLISPTYPE)))
			 [SETQ FORM (LIST (QUOTE SETQ)
					  (CADR FORM)
					  (COND
					    ((OR (NULL (SETQ TEM1 (CADDR FORM)))
						 (NUMBERP TEM1))
					      TEM1)
					    (T (LIST (QUOTE QUOTE)
						     TEM1]
			 (GO TOP))
		       (T (GO B]
	      ((CONS LIST APPEND NCONC NCONC1 /NCONC /NCONC1)
		(COND
		  ((OR (NULL CLISPFLG)
		       (NULL (GETP (QUOTE <)
				   (QUOTE CLISPTYPE)))
		       NOVALFLG)
		    (GO B))
		  ((EQ [CAR (SETQ TEM1 (PROG ((PARENT FORM))
					     (RETURN (SHRIEKIFY FORM]
		       (QUOTE <))
		    (CLISP3 (QUOTE <)
			    TEM1 T T))
		  (T                            (* E.G. didnt convert because of
                                                declarations.)
		     TEM1)))
	      [(match MATCH)
		[PROG ((OPR0 (AND [NULL (CDR (SETQ TEM2 (CDDDR FORM]
				  OPR0)))

          (* OPR0 rebound to NIL if -> or => used in match expression, 
          because in this case, want CLISPIFYCROPS to 'wrap it up'.)


		      (SETQ TEM1 (CLISPIFYCROPS (CADR FORM)
						(LIST (CAR TEM2))
						(QUOTE match]
		(COND
		  ((NULL (SETQ TEM2 (CDR TEM2)))
		    TEM1)
		  (T (NCONC TEM1 (CONS (CAR TEM2)
				       (CLISPIFY1 (CDR TEM2]
	      ((fetch FETCH)
		(MAP FORM (FUNCTION CLISP4))
		(CLISPIFYCROPS (CADDDR FORM)
			       (LIST (CADR FORM))
			       (QUOTE fetch)))
	      ((replace REPLACE)
		(CLISPIFYRPLAC FORM (QUOTE replace)
			       T))
	      (ASSEMBLE FORM)
	      (COND
		((EQ (CAR FORM)
		     CLISPTRANFLG)
		  (SETQ FORM (CDDR FORM))
		  (CLISPIFY1 FORM NIL FORM))
		(T (GO A]
      A   [COND
	    [(SETQ TEM1 (GETP (CAR FORM)
			      (QUOTE CROPS)))
	      (RETURN (CLISPIFYCROPS0 (SUBPAIR (QUOTE (A D))
					       (QUOTE (:1 ::1))
					       TEM1]
	    [[AND (SETQ TEM1 (GETP (CAR FORM)
				   (QUOTE CLISPCLASS)))
		  (OR (EQ [CAR (SETQ TEM2 (GETP TEM1 (QUOTE CLISPCLASSDEF]
			  (QUOTE ARITH))
		      DECLST)
		  (SETQ TEM3 (GETP TEM1 (QUOTE CLISPTYPE]
                                                (* E.G. (CAR FORM) is FPLUS, 
                                                TEM1 is +.)
	      (COND
		((EQ (CAR FORM)
		     (CLISPIFYLOOKUP (CAR FORM)
				     (CADR FORM)
				     (CADDR FORM)
				     TEM1 TEM2))
		  (RETURN (CLISP3 TEM1 FORM TEM3]
	    ((AND (SETQ TEM1 (GETP (CAR FORM)
				   (QUOTE CLISPINFIX)))
		  (OR NEGFLG CLTYP0 (FMEMB TEM1 CLISPCHARS)))

          (* E.g. IF (CAR FORM) is ILESSP, TEM1 would be LS.
          The CLTYP0 is because only want to convert to infix if under 
          another operator, e.g. (LIST (AND X Y)) is clearer than 
          (LIST (X AND Y)))


	      (RETURN (CLISP3 TEM1 FORM (GETP TEM1 (QUOTE CLISPTYPE]
          [RETURN (COND
		    ((SETQ TEM1 (GETP (CAR FORM)
				      (QUOTE CLISPFORM)))
                                                (* E.G. ZEROP, NEQ, ADD1, and 
                                                SUB1.)
		      (SETQ FORM (LSUBST (CDR FORM)
					 (QUOTE *)
					 TEM1))
		      (GO TOP))
		    ([AND (SETQ TEM1 (GETP (CAR FORM)
					   (QUOTE CLISPTYPE)))
			  (OR CLTYP0 (AND NEGFLG (GETP (CAR FORM)
						       (QUOTE CLISPNEG]

          (* E.g. EQUAL or CONS. The CLTYP0 is because converting 
          these sort of expressions to infix notaion is only more 
          readable when below anther operator, e.g. 
          (LIST (X CONS Y)) is not as clear as 
          (LIST (CONS X Y)))


		      (CLISP3 (CAR FORM)
			      FORM TEM1))
		    [[LISTP (SETQ TEM1 (GETP (CAR FORM)
					     (QUOTE SETFN]

          (* The third aagument to CLISPIFYRPLAC indicates this is a : 
          transformation. It is also true if there is an ACCESSFN 
          property. E.g. FOO has ACCESSFN GETFOO SETFN SETFOO and 
          SETFOO has SETFN (FOO))


		      (CLISPIFYRPLAC FORM (CAR TEM1)
				     (GETP (CAR TEM1)
					   (QUOTE ACCESSFN]
		    ((AND TEM1 (EQ (SETQ TEM2 (GETP (CAR FORM)
						    (QUOTE ACCESSFN)))
				   (CAR FORM)))

          (* Occurs when FOO is its own accessfn, e.g. FOO has 
          ACCESSFN FOO SETFN SETFOO.)


		      (CLISPIFYCROPS0 (LIST TEM2)))
		    ([LISTP (SETQ TEM1 (GETP (CAR FORM)
					     (QUOTE ACCESSFN]
		      (CLISPIFYCROPS0 TEM1))
		    ((SETQ TEM1 (GETP (CAR FORM)
				      (QUOTE CLMAPS)))
		      (CLISPIFYMAPS (CAR TEM1)
				    (CDR TEM1)))
		    ((AND (NULL (FGETD (CAR FORM)))
			  (GETP (CAR FORM)
				(QUOTE CLISPWORD)))
		      (CLISPIFY1 FORM NIL FORM))
		    ((AND (OR (EQ (SETQ TEM1 (ARGTYPE (CAR FORM)))
				  1)
			      (EQ TEM1 3))
			  (NEQ (GETP (CAR FORM)
				     (QUOTE INFO))
			       (QUOTE EVAL)))   (* Dont clispify the tails of 
                                                nlambdas that dont evaluate 
                                                their arguments.)
		      FORM)
		    ((AND [COND
			    [(LITATOM (CAR FORM))
			      (NULL (FGETD (CAR FORM]
			    ((LISTP (CAR FORM))
			      (NULL (OR (EQ (CAAR FORM)
					    (QUOTE LAMBDA))
					(EQ (CAAR FORM)
					    (QUOTE NLAMBDA]
			  (GETHASH FORM CLISPARRAY))
		      (PUTHASH FORM NIL CLISPARRAY)
		      (CLISPIFY2B FORM))
		    ((NULL (CDR FORM))

          (* NULL checks for No arguments, so must leve as item since 
          otherwise would be convereted by dwimify to a variable, e.g. 
          (EQ (FOO) FORM) cannot become FOO=X.
          The AND checks for nlambdas.)


		      FORM)
		    (T (GO B]
      B   

          (* On this call subparent is specified as being the fomr 
          itself because OF cases like (x* 
          (IPLUS X Y)))


          (RETURN (CLISPIFY2C FORM NIL FORM])

(CLISPIFY2C
  [LAMBDA (FORM X SUBPARENT)

          (* (CAR FORM) is not to be treated specially.
          CLISPIFY2C simply calls CLISPIFY1.)


    (PROG (TEM)
          (OR X (SETQ X (CLISPIFY1 (CDR FORM)
                                   NIL NIL NIL NIL SUBPARENT)))
          (RETURN (COND
                    ((NEQ X (CDR FORM))
                      (CONS (CAR FORM)
                            X))
                    (T FORM])

(CLISP3
  [LAMBDA (OPR X CLTYP FLG)
    (PROG (L (BROADSCOPE (GETP OPR (QUOTE BROADSCOPE)))
	     TEM)
          [COND
	    ((OR (NULL CLTYP)
		 (NULL CLISPFLG))

          (* This permits user to disable CLISPIFY transformations and 
          CLISP transformaions simply by remving CLISPYTPE property.)


	      (RETURN (CLISPIFY2C X]
          (SETQ L (CDR X))
          (COND
	    (FLG                                (* X was alrady CLISPIFIED.
                                                Used by CLISPIFYNOT.)
		 (SETQ L X)
		 (GO OUT))
	    ((EQ OPR (QUOTE '))
	      (SETQ L (LIST OPR (CAR L)))
	      (GO OUT))
	    ([AND NEGFLG (SETQ TEM (GETP OPR (QUOTE CLISPNEG]
	      (SETQ NEGFLG NIL)
	      (SETQ OPR TEM)))
          [AND (NULL (GETP OPR (QUOTE UNARYOP)))
	       (NULL (CDR L))
	       (COND
		 ((EQ OPR (QUOTE _))
		   (SETQ L (LIST (CADR X)
				 NIL)))
		 (T                             (* E.G. (IPLUS X))
		    (RETURN (CONS (CAR X)
				  (CLISPIFY1 (CDR X]
          (MAP (CDR FORM)
	       (FUNCTION CLISP4))

          (* This handles things like (ITIMES X+Y Z) which would 
          otherwise go to X+Y*Z)



          (* This takes care of the cases 
          (FOO X* (IPLUS X Y)) or (FOO (IPLUS X Y) *Z) In this case, 
          TAIL would be ((IPLUS X Y) --) and PARENT 
          (FOO --) corresonding to the value of FORM two calls back on 
          CLISPIFY2B)


          [AND (NEQ (CAR PARENT)
		    (QUOTE PROG))
	       (NEQ (CAR PARENT)
		    (QUOTE SETQ))
	       (TAILP TAIL SUBPARENT)
	       (PROG (POS)
		     (COND
		       ((OR (AND (NEQ TAIL SUBPARENT)
				 (SETQ TEM (NLEFT SUBPARENT 1 TAIL))
				 (CLISP4 TEM PARENT SUBPARENT))
			    (AND (CDR TAIL)
				 (CLISP4 (CDR TAIL)
					 PARENT SUBPARENT)))
			 [COND
			   ((NULL (SETQ POS (NEWSTKPOS (QUOTE CLISPIFY2B)
						       -2)))
                                                (* Can occur if user calls CL at
                                                funny atom.)
			     (PRINT (QUOTE can't)
				    T T)
			     (RETEVAL (QUOTE CLISPIFY)
				      (QUOTE (PROGN (SETQQ COM CL)
						    (ERROR!]
			 (RETFROM POS NIL]
          (SETQ L (CLISPIFY1 L OPR CLTYP BROADSCOPE))
      OUT (RETURN
	    (COND
	      ([AND (ATOM (CAR L))
		    (SELECTQ (ARGTYPE (CAR L))
			     ((1 3)
			       T)
			     NIL)
		    (OR (NULL CLISPIFYPACKFLG)
			(NOT (FMEMB OPR CLISPCHARS]

          (* Kaplan insists on this check.
          He has variables and nlambda function of the same name.
          Note if function isnot defined at clispify time, you lose, 
          i.e. (AND FOO X) will go to (FOO AND X).)


		(CLISPIFY2C X))
	      ((NULL OPR0)                      (* Parent form is a regular 
                                                function.)
		[SETQ SEG
		  (COND
		    (CLTYP0

          (* Parent form is an IF or FOR.
          Pathological cases occur when clispifying an already 
          paatially clispified expression, e.g. 
          (IF a then (AND B C) D). Here cant remove parentheses, but 
          in (IF (AND A B) THEN C) you can.)


		      (COND
			((EQ CLTYP0 (QUOTE COND))

          (* Started out with a COND. CLISPCOND is careful about 
          setting CLTYP0 so it is safe to remove parentheses.)


			  T)
			((NLISTP CLTYP0)
			  (HELP))
			([AND (EQ TAIL (CDR CLTYP0))
			      [OR (NULL (CDR TAIL))
				  (EQ (CAR (GETP (CADR TAIL)
						 (QUOTE CLISPWORD)))
				      (CAR (GETP (CAR CLTYP0)
						 (QUOTE CLISPWORD]
			      (NULL (SOME L (FUNCTION (LAMBDA (X)
					      (LISTP (GETP X (QUOTE CLISPWORD]

          (* Says there is only one expression there so safe to remove 
          parentehses, e.g. (IF A THEN (AND B C) ELSE D) The reason 
          for the SOME is that cant remve parens if any of the words 
          in L are also operators, e.g. user writes 
          (WHILE (IGREATERP X COUNT) do --) can't remove parens 
          because COUNT is also an operator.)


			  T)))
		    (BROADSCOPE 

          (* If BROADSCOPE is T, form must be parentheseized, e.g. 
          (FOO (AND X Y)) must be (FOO (X AND Y)) not 
          (FOO X AND Y).)


				NIL)
		    (T                          (* Unary MINUS must be 
                                                parenthesized)
		       (NEQ (CAR L)
			    (QUOTE -]
		(CLISP3A L))
	      ([AND (NEQ OPR0 (QUOTE <))
		    (NEQ OPR (QUOTE <))
		    (OR (AND LST (CLSTOPSCAN? CLTYP CLTYP0))
			(AND (CDR TAIL)
			     (NOT (CLSTOPSCAN? CLTYP0 CLTYP]

          (* OR is true if inner operaton must be parenthesized.
          First clause corresponds to case where there is an operand 
          to the left of this one, and the inner operator would stop 
          the scan of the outer one, i.e. the one on the left, e.g. 
          (ITIMES A (IPLUS B C)), must go to A* 
          (B+C). Second clause corresponds to case where there is an 
          operand to the right of this one, and the outer operator, 
          i.e. the one on the right, would NOT stop the inner, e.g. 
          (ITIMES (IPLUS A B) C), mustgo to 
          (A+B) *C. The reason for both checks is that operands may 
          act differently to the left than right.
          For example, (A+B+C) groups as 
          ((A+B) +C). Therefore, (IPLUS (IPLUS A B) C), can be 
          CLISPIFIED to A+B+C. Similarly, 
          (IPLUS (SETQ X Y) Z) must go to 
          ((X_Y) +Z), whereas (IPLUS X (SETQ Y Z)) can go to 
          (X_Y+Z))


		(SETQ SEG NIL)
		(CLISP3A L))
	      (T (SETQ SEG T)                   (* And packing will be done by 
                                                higher operator.)
		 L])

(CLISP3A
  [LAMBDA (L)

          (* L is a list of operands and operators.
          CLISP3A packs up the atoms. Its value is always a list.
          CLISPCHARS is a list of those infix operators which can be 
          packed with their operands. Most of these are single 
          characters, but for example ~= appears on this list.)


    (COND
      ((OR (EQ (CAR PARENT)
               (QUOTE PROG))
           (EQ (CAR PARENT)
               (QUOTE SELECTQ)))

          (* E.g., so infix operators dont pack to a single atom and 
          therefore be interpreted as prog lables.)


        (SETQ SEG NIL)))
    (COND
      ((NULL CLISPIFYPACKFLG)
        L)
      (T (CLISPACKUP L])

(CLISPACKUP
  [LAMBDA (L)
    (PROG ((LL L)
           L1 L2 TEM L-1 OPRFLG)
      TOP [COND
            ((NOT (ATOM (CAR LL)))
              (SETQ L-1 NIL)
              (GO PACKUP))
            ((EQ (CAR LL)
                 (QUOTE '))                     (* ' has to be handled 
                                                specially)
              [COND
                ((NOT (FMEMB (CAR L2)
                             CLISPCHARS))

          (* If the previous element was NOT an operatr, the ' must 
          start a separate atom, therefore pack up the segment up to 
          the '.)


                  (CLISP3B L1 L2)
                  (AND (ATOM (CADR LL))
                       (CLISP3B LL (CDR LL)))

          (* The ' and its argument must also be packed up, even if 
          other opeators follow, because ' is always the last operaar 
          in an atom.)


                  )
                (T (SETQ LL (CLISP3B L1 (COND
                                       ((ATOM (CADR LL))
                                         (CDR LL))
                                       (T LL]
              (SETQ L1 (SETQ L-1 NIL))
              (GO LP1))
            ((AND (EQ (CAR LL)
                      (QUOTE >))
                  (NEQ (CADR LL)
                       (QUOTE >)))
              (SETQ LL (CLISP3B (OR L1 L-1)
                                LL))
              (SETQ L1 (SETQ L-1 NIL))
              (GO LP1))
            ((AND (EQ (CAR LL)
                      (QUOTE <))
                  (NEQ (CAR L2)
                       (QUOTE <)))
              (CLISP3B L1 L2)
              (SETQ L1 (SETQ L-1 NIL)))
            ((NOT (FMEMB (CAR LL)
                         CLISPCHARS))
              (COND
                ((NOT (LITATOM (CAR LL)))
                  (SETQ L-1 LL))
                ((FMEMB (QUOTE CLISPTYPE)
                        (CDAR LL))

          (* FMEMB is used instead of GETP so that we can tell CLISP3A 
          not to pack up thinks like ~EQUAL without making them be 
          oprators.)


                  (SETQ L-1 NIL)
                  (GO PACKUP))
                ([COND
                    (FUNNYATOMLST 

          (* The STRPOSL in the next clause slows CLISPIFY down about 
          10 per cent, but is necessary to catch funnyatoms.
          If the user specifies FUNNYATOMLST, its a little faster.)


                                  (AND (NEQ FUNNYATOMLST T)
                                       (FMEMB (CAR LL)
                                              FUNNYATOMLST)))
                    (T (STRPOSL CLISPCHARRAY (CAR LL]

          (* The STRPOSL prevents a 'funny atom' from being packed 
          with another operator, e.g. (IPLUS *X Y) goes to *X +Y.
          Setting OPRFLG to NIL will cause us to GO to PACKUP.)


                  (SETQ L-1 NIL)
                  (GO PACKUP))
                (T (SETQ L-1 LL)))
              (COND
                (OPRFLG 

          (* OPRFLG is T if previous element was a CLISPCHAR.
          Therefore, continue scanning this cluster.)


                        (GO LP1))
                (T (GO PACKUP]                  (* At this point we know that 
                                                the current element is a 
                                                CLISPCHAR.)
          (AND (NULL L1)
               (SETQ L1 (OR L-1 LL)))

          (* L1 marks the beginning of the sequence of atoms to be 
          packed. If L-1 is not NIL, the atom before this one is not a 
          CLISP word and is to be included, e.g. 
          (A + B) Note that we don't want to set L1 until we do see a 
          CLISPCHAR, e.g. (AND A B (EQ X Y)) beecomes 
          (A AND B AND X=Y). This is why we must save the last 
          non-operator on L-1 until this point.)


          (COND
            ((EQ (CAR LL)
                 (QUOTE +))
              (AND (EQ (CADR LL)
                       (QUOTE -))
                   (FRPLACA LL (QUOTE +-))
                   (FRPLACD LL (CDDR LL)))

          (* This simplifies the code as it allows 
          (IPLUS -- (IMINUS --) --) to be treated the same as 
          IDIFFERENCE.)


              )
            ((NEQ (CAR LL)
                  (QUOTE +-))
              (GO A)))

          (* At this point we know (CAR L) is either a + or a +-.
          (+- is the symbol for binary miinus.) The next COND checks 
          for some special cases.)


          [COND
            [(AND L-1 (NUMBERP (SETQ TEM (CADR LL)))
                  (MINUSP TEM))
              (AND [COND
                     ((EQ (CAR LL)
                          (QUOTE +-))

          (* E.g. (IDIFFERENCE X -3) -> X +- -3 so change the +- to + 
          and reverse the sign.)


                       (FRPLACA LL (QUOTE +)))
                     ((GETP (QUOTE -)
                            (QUOTE CLISPTYPE))

          (* E.g. (IPLUS X -3) -> X + -3, so change the + to -
          and reverse the sign. The GETP is because -
          may be disabled, and wold not be detected beyond this point.
          Note that if user disables -, he should also disable +-.)


                       (FRPLACA LL (QUOTE -]
                   (FRPLACA (CDR LL)
                            (MINUS TEM]
            ((EQ (CAR LL)
                 (QUOTE +-))
              (COND
                ((EQ (CADR LL)
                     (QUOTE -))

          (* E.g. (IDIFFERENCE X (IMINUS &)) -> X +- -&, so change the 
          +- to + and reverse the sign)


                  (FRPLACA LL (QUOTE +))
                  (FRPLACD LL (CDDR LL)))
                (T (FRPLACA LL (QUOTE -]
      A   (SETQ L-1 NIL)
          (SETQ OPRFLG T)
          (GO LP)
      LP1 (SETQ OPRFLG NIL)
      LP  (SETQ L2 LL)                          (* L2 stays one behind L0.)
          (COND
            ((NULL LL))
            ((SETQ LL (CDR LL))
              (GO TOP))
            (T (GO PACKUP)))
          (RETURN L)
      PACKUP
          (AND L1 (CLISP3B L1 L2))
          (SETQ L1 NIL)
          (GO LP1])

(CLISP3B
  [LAMBDA (L1 L2)
    (PROG (TEM (L3 (CDR L2)))
          (COND
            ((NULL L1)
              (RETURN L2))
            ((EQ L2 L1)
              (RETURN L1)))
          (FRPLACD L2)
          (RETURN (COND
                    ((AND (EQ (CAR (SETQ TEM (PACK L1)))
                              (QUOTE NOBIND))
                          (NOT (FMEMB TEM FUNNYATOMLST))
                          (NOT (NUMBERP TEM)))

          (* The FMEMB prevents packing up 
          (ITIMES A B) ino A*B if A*B is a 'funny atom', since in this 
          case it wold not ever be unpacked by DWIM.)


                      (FRPLACA L1 TEM)
                      (FRPLACD L1 L3)
                      L1)
                    (T (FRPLACD L2 L3)
                       L2])

(CLISP4
  [LAMBDA (TAIL PARENT SUBPARENT)

          (* CLISP4 is called when an xpression is abut to be 
          converted into infix notation. IN this case, both the 
          interior of the expression, FORM, and its neighbors in 
          PARENT, are examined. The interior is xamed by calls of the 
          form (MAP FORM (FUNCTION CLISP4)), and does not require 
          knowing PARENT and SUBPARENT. PARENT and SUBPARENT are used 
          to check the neighbors, and only from calls to CLISP3.
          CLISPIFY1 normally rebinds PARENT and SUBPARENT, but oon 
          direct calls to CLISPIFy2 not from CLISPIFY1, e.g. from 
          CLISPIFY2B itself, or CLISPIFYCROPS, CLISPIFYRPLAC, etc. 
          PARENT and SUBPARENT should be rebound, usually to NIL 
          because the neighbor-check is handled by checking above, 
          i.e. before descending.)


    (AND CLISPFLG (LITATOM (CAR TAIL))
	 (EQ (CAAR TAIL)
	     (QUOTE NOBIND))
	 (NOT (FMEMB (CAR TAIL)
		     VARS))
	 [NULL (AND (EQ TAIL PARENT)
		    (FGETD (CAR TAIL]
	 (PROG ((N 1)
		DWIMIFYFLG)
	   LP  (COND
		 ((NULL (SETQ N (STRPOSL CLISPCHARRAY (CAR TAIL)
					 N)))
		   (RETURN NIL))
		 ((GETP (NTHCHAR (CAR TAIL)
				 N)
			(QUOTE CLISPTYPE))
		   (RETURN N)))
	       (SETQ N (ADD1 N))
	       (GO LP))
	 (RESETVAR NOSPELLFLG T (PROG ((DWIMIFYFLG T)
				       (DWIMIFYING T)
				       DWIMIFY0CHANGE)
				      (RETURN (DWIMIFY1B TAIL (OR PARENT FORM)
							 (OR SUBPARENT FORM)
							 NIL T FN (QUOTE LINEAR]
)

(CLISPCOND
  [LAMBDA (CLAUSE CPYFLG VAL)
    (PROG (OPR0 (CLTYP0 (QUOTE COND))
		TEM1 TEM2 PARENT SUBPARENT)

          (* CLTYP0 is bound inform CLISP3 that it is ok to remove 
          parentheses from expressions converted to infix notation, 
          e.g. (SETQ CLAUSE (FOO)))


          (RETURN (COND
		    [(AND VAL (EQ (CAR CLAUSE)
				  T))

          (* Don't use ELSE unless previous clauses seen, otherewise 
          (COND (T --)) gets messed up, i.e. becomes IF --.)


		      (CONS (COND
			      (LCASEFLG (QUOTE
					  else))
			      (T (QUOTE
				   ELSE)))
			    (CLISPCOND1 (CDR CLAUSE]
		    (T [SETQ TEM1 (AND (CDR CLAUSE)
				       (CONS (COND
					       (LCASEFLG (QUOTE
							     then))
					       (T (QUOTE
						      THEN)))
					     (CLISPCOND1 (CDR CLAUSE)
							 CPYFLG T]
		       (SETQ TEM2 (CLISPIFY2 (CAR CLAUSE)))
		       (CONS (COND
			       (LCASEFLG (QUOTE
					   elseif))
			       (T (QUOTE
				    ELSEIF)))
			     (COND
			       (SEG (SETQ SEG NIL)
				    (NCONC TEM2 TEM1))
			       ((CLREMPARS TEM2)
                                                (* Says is a small list.)
				 (APPEND TEM2 TEM1))
			       (T (CONS TEM2 TEM1])

(CLISPCOND1
  [LAMBDA (L CPYFLG)

          (* If CPYFLG is T, something will be NCONCed onto the value 
          returned by CLISPCOND1, so we must make sure that it does 
          not aapear in the original function.)


    (PROG (TEM)
          [SETQ TEM (CLISPIFY1 L NIL (AND (NULL (CDR L))
                                          (QUOTE COND))
                               NIL
                               (OR NOVALFLG (QUOTE NOTLAST]
          (RETURN (COND
                    [(AND (NULL (CDR TEM))
                          (CLREMPARS (CAR TEM)))
                      (COND
                        ([AND CPYFLG (EQ (FLAST (CAR TEM))
                                         (FLAST (CAR L]

          (* FLAST i is necesaary because forms may not be EQ but 
          still have common tails, ee.g. 
          (FOO (SETQ X Y) Z) becomes (FOO X_Y Z), but 
          (Z) is same as in original expression.)


                          (APPEND (CAR TEM)))
                        (T (CAR TEM]
                    ((AND CPYFLG (EQ (FLAST TEM)
                                     (FLAST L)))
                      (APPEND TEM))
                    (T TEM])

(CLISPAND
  [LAMBDA (FORM)
    (PROG (TEM)
          (RETURN
            (CLISPCOND
              (COND
                ((OR (NULL (CDDDR FORM))
                     (CLISPAND1 (CADDR FORM)))

          (* E.G. (AND X Y) -> IF X THEN Y.
          Similary, (AND X Y --) -> IF X THEN Y -- if it is known that 
          Y is always true.)


                  (CDR FORM))
                (T 

          (* E.G. (AND X Y Z) -> IF X AND Y THEN z.)


                   (CONS [LDIFF FORM (SETQ TEM
                                  (OR (SOME (CDDDR FORM)
                                            (FUNCTION CLISPAND1))
                                      (FLAST FORM]
                         TEM])

(CLISPAND1
  [LAMBDA (FORM)

          (* Returns T if FORM is known to return a NON-NIL value.
          used in clispifying ANDs.)


    (COND
      ((LISTP FORM)
        (SELECTQ (CAR FORM)
                 ((CONS LIST RPLACA RPLACD FRPLACA FRPLACD /RPLACA /RPLACD)
                   T)
                 (QUOTE (CADR FORM))
                 (SETQ (CLISPAND1 (CADDR FORM)))
                 (SETQQ (CADDR FORM))
                 ((PRINT PRIN1)
                   (CLISPAND1 (CADR FORM)))
                 [COND
                   (AND (CLISPAND1 (CAAR (FLAST FORM)))
                        (EVERY (CDR FORM)
                               (FUNCTION (LAMBDA (CLAUSE)
                                   (CLISPAND1 (CAR (FLAST CLAUSE]
                 NIL))
      ((LITATOM FORM)
        (EQ FORM T))
      (T T])

(CLISPIFYNOT
  [LAMBDA (FORM)
    (PROG (TEM1 TEM2)
          (SETQ NEGFLG (NOT NEGFLG))
          (SETQ TEM1 (CLISPIFY2B FORM))
          (RETURN (COND
                    ((NULL NEGFLG)
                      TEM1)
                    ([AND CLISPFLG (SETQ TEM2 (GETP (QUOTE ~)
                                                    (QUOTE CLISPTYPE]
                      (CLISP3 (QUOTE ~)
                              (LIST (QUOTE ~)
                                    TEM1)
                              TEM2 T))
                    (T (LIST (QUOTE NOT)
                             TEM1])

(CLREMPARS
  [LAMBDA (X)
    (AND CLREMPARSFLG (LISTP X)
         (CDR X)
         (NULL (CDDDR X))
         (ATOM (CAR X))
         (ATOM (CADR X))
         (ATOM (CADDR X))
         (FGETD (CAR X))
         (NULL (STRPOSL CLISPCHARRAY (CAR X])

(CLISPIFYCROPS0
  [LAMBDA (CROPSLST)
    (MAP (CDR FORM)
         (FUNCTION CLISP4))

          (* Handles things like (CAR X_Y) and 
          (LAST X_Y) by first dwimifying,, when necessary.)


    (CLISPIFYCROPS (CADR FORM)
                   CROPSLST
                   (CAR FORM])

(CLISPIFYCROPS
  [LAMBDA (X CROPSLST CROPFN Y)

          (* X was originally of the form 
          (car/cdr/... X). Y is given on calls from CLISPIFYRPLAC.
          In this case, Y is either NCONC, NCONC1, etc. or CAR or CDR 
          (correspnding to RPLACA or RPLACD). Y tells CLISPIFYCROPS 
          not to do a CLISP3A, and is also added to the end of the 
          CROP operatrs.)


    (PROG (TEM1 TEM2 PARENT SUBPARENT)
          [COND
	    ([AND (NULL Y)
		  (OR (NULL CLISPFLG)
		      (NULL (SETQ TEM1 (GETP (QUOTE :)
					     (QUOTE CLISPTYPE]
                                                (* CLISPIFYRPLAC makes this 
                                                check before calling 
                                                CLISPIFYCROPS.)
	      (RETURN (CLISPIFY2C FORM]
          (PROG (OPR0 CLTYP0)
	        (COND
		  (CL:FLG (SETQQ OPR0 :)
			  (SETQ CLTYP0 TEM1)))

          (* This means that if : is encountered in the course of 
          clipifying x, clisifycrops will just return the list of :1's 
          and ::1's. Thus CADR of CDDR will clisify to :4, not ::3:1.)


	        (SETQ TEM1 (CLISPIFY2 X)))
          (COND
	    ((NULL SEG)

          (* Makes rest of program simpler since TEM1 now always 
          corresponds to a segment.)


	      (SETQ TEM1 (LIST TEM1)))
	    ((OR (NULL CL:FLG)
		 (NEQ (CADR TEM1)
		      CAR/CDRSTRING))

          (* The NEQ says TEM1 is a sequence of operators and operands 
          other than a CAR or CDR perator, E.g.
          (CADR (SETQ X Y)))


	      [COND
		((CDR (SETQ TEM1 (CLISP3A TEM1)))
		  (SETQ TEM1 (LIST TEM1))

          (* This insures that the clispified form will be 
          parenthesized. This is necessar unless it reduces to a 
          single atom, i.e. CLISP3A returns a list of one element, 
          since otherwise, the operator might be broadscope, e.g. 
          (CADR (AND X Y)))


		  ]
	      (GO OUT)))
          (COND
	    ([OR (NULL CL:FLG)
		 (AND (LISTP (CAR TEM1))
		      (COND
			[(EQ CL:FLG T)
			  (OR (CDDAR TEM1)
			      (LISTP (CADAR TEM1]
			((EQ CL:FLG (QUOTE ALL))
                                                (* Says go back to : notation 
                                                regardless of length of 
                                                expression.)
			  (SOME (CAR TEM1)
				(FUNCTION LISTP)))
			((LISTP CL:FLG)
			  (NULL (APPLY* CL:FLG (CAR TEM1]
                                                (* E.G. The first operand is a 
                                                list, therefore don't use : 
                                                notation.)
	      (GO OUT))
	    [(EQ OPR0 (QUOTE :))

          (* Leaves it as A's and D's for higher operator, which is 
          also a :, to process. The reason for doing this is that 
          (CAR (CDDR X)) can therefore become :3 not ::2:1.)


	      (SETQ SEG T)
	      [COND
		((NEQ (CADR TEM1)
		      CAR/CDRSTRING)

          (* Special STRING used to mark list to inidicate that what 
          follows is a list of A's and D's for CLISPIFYCROPS1.
          Note that the marker may already be in there from a lower 
          call to CLISPIFYCROPS)


		  (SETQ CROPSLST (CONS CAR/CDRSTRING CROPSLST]
	      (RETURN (NCONC TEM1 (APPEND CROPSLST]
	    ((EQ (CADR TEM1)
		 CAR/CDRSTRING)
	      (FRPLACD TEM1 (CDDR TEM1))        (* Reeove marker)
	      (SETQ TEM2 TEM1))
	    ((NULL (CDR TEM1))

          (* Of form (atom), e.g. CLISPIFYCROPS was called with X an 
          atom, as in CLISPIFYING (CAR X) 
          (Remember that we hae listed the result of CLISPIFYING so 
          that all cses can be treated as segments))


	      (SETQ TEM2 TEM1))
	    (T (HELP)))
          (FRPLACD TEM2 (CLISPIFYCROPS1 (NCONC (CDR TEM2)
					       CROPSLST)
					Y))
          (SETQ SEG T)
          [RETURN (COND
		    ((OR Y OPR0)
		      TEM1)
		    (T (CLISP3A TEM1]
      OUT (SETQ SEG NIL)
          (RETURN (COND
		    ((NULL Y)

          (* TEM1 is the CLISPIFIED X, as a segment, so CONS the 
          CROPFN back on it.)


		      (SELECTQ CROPFN
			       [fetch (CONS (QUOTE fetch)
					    (CONS (CAR CROPSLST)
						  (CONS (QUOTE of)
							TEM1]
			       [match (CONS CROPFN (APPEND TEM1
							   (CONS (QUOTE
								    with)
								 CROPSLST]
			       (CONS CROPFN TEM1)))
		    ((NULL CROPFN)
		      TEM1)
		    (T (LIST (CONS CROPFN TEM1])

(CLISPIFYCROPS1
  [LAMBDA (LST Y)

          (* takes a list (in reverse order) consisting of :1 
          (for car) ::1 (for cdr), numbers 
          (for nth), and other litatoms (from record operations) and 
          produces the appropriate list contaiing just :'s and numbers 
          suitable for packing.)


    (PROG (X N TAILSTATE TEM)
      LP  (COND
	    (LST (SETQ TEM (CAR LST)))
	    (Y (SETQ TEM Y)
	       (SETQ Y NIL))
	    (T (SETQ TEM NIL)
	       (GO OUT)))
      LP1 [SELECTQ
	    TEM
	    (:1 

          (* :1 used instead of CAR, or A, because want to choose a 
          name that is unlikely to appear as a record field.)


		(SETQ X (CONS (COND
				((NULL TAILSTATE)
				  1)
				((MINUSP N)
				  N)
				(T (ADD1 N)))
			      (CONS (QUOTE :)
				    X)))
		(SETQ TAILSTATE NIL))
	    [::1 (COND
		   ((NULL TAILSTATE)
		     (SETQ TAILSTATE T)
		     (SETQ N 1))
		   ((NEQ N -1)
		     (SETQ N (ADD1 N)))
		   (T (SETQ X (CONS -1 (CONS (QUOTE :)
					     X)))
		      (SETQ N 1]
	    (COND
	      ((NUMBERP TEM)
		(SETQ TAILSTATE T)
		(SETQ N TEM))
	      [(NLISTP TEM)                     (* ACCESS function, e.g. X:FOO.)
		(SETQ X (CONS TEM (CONS (QUOTE :)
					X]
	      [(NULL (CDR TEM))
		(SETQ X (CONS (CAR TEM)
			      (CONS (QUOTE :)
				    X]
	      (T (SETQ X (CONS [PACK (CONS (CAR TEM)
					   (MAPCONC (CDR TEM)
						    (FUNCTION (LAMBDA (X)
							(LIST (QUOTE %.)
							      X]
			       (CONS (QUOTE :)
				     X]
          (SETQ LST (CDR LST))
          (GO LP)
      OUT [AND TAILSTATE (SETQ X (CONS N (CONS (QUOTE :)
					       (CONS (QUOTE :)
						     X]
          (AND TEM (SETQ X (APPEND TEM X)))     (* Adds the : or :: foo NCONC or
                                                Nconc2)
          (RETURN (DREVERSE X])

(CLISPIFYRPLAC
  [LAMBDA (X TYP :FLG)
    (PROG (TEM CROPS (CLTYP00 CLTYP0)
	       (OPR0 (QUOTE _))
	       (CLTYP0 (GETP (QUOTE _)
			     (QUOTE CLISPTYPE)))
	       LFT RGHT TYP0 (PARENT0 PARENT)
	       PARENT SUBPARENT)
          [COND
	    ([OR (NULL CLTYP0)
		 (NULL CLISPFLG)
		 (NULL (GETP (QUOTE :)
			     (QUOTE CLISPTYPE]
                                                (* _ transformation disabled)
	      (RETURN (CLISPIFY2C X]
          (MAP (CDR X)
	       (FUNCTION CLISP4))

          (* To handle cases like (RPLACA X_Y T), which if not first 
          dwiified, would go to X_Y:1_T.)


          (COND
	    ((EQ TYP (QUOTE replace))
	      (SETQ LFT (CADDDR X))
	      (SETQ RGHT (CDR (CDDDDR X)))
	      (SETQ TYP0 (CADR X)))
	    ((NEQ (CAR X)
		  (CLISPIFYLOOKUP (CAR X)
				  (CADR X)
				  (CADDR X)))   (* E.g. RPLACA-RPLACD being used
                                                in this function and this is an 
                                                FRPLACA.)
	      (RETURN (CLISPIFY2C X)))
	    (T (SETQ LFT (CADR X))
	       [SETQ RGHT
		 (NTH (CDR X)
		      (OR (GETP (CAR X)
				(QUOTE NARGS))
			  (AND (NOT (SUBRP (CAR X)))
			       (NARGS (CAR X)))
			  (/PUT (CAR X)
				(QUOTE NARGS)
				(HELP (QUOTE "How many arguments for")
				      (CAR X]

          (* The problem is finding which of the arguments in thise 
          xpression belong to the accessfunction and which to the 
          setfn, e.g. Can't just default to all but last because last 
          might not be supplied, e.g. (RPLACA X) must clispify to 
          X:1_NIL, not X:1_X. The number of arguments is obtained 
          either from the property NARGS, of from the function NARGS, 
          (if the function in question is not a SUBR//) or else an 
          eror is gnerated)


	       (SETQ TYP0 TYP)))
          [COND
	    ((NULL :FLG)

          (* Doesnt involve :'s, e.g. from a SETFN.
          For example, if the original form were 
          (SETA X Y Z), TYP would be ELT, and CLISPIFY2A would be 
          called on (ELT X Y))


	      [SETQ TEM (CLISPIFY2A (CONS TYP (LDIFF (CDR X)
						     RGHT]
	      (GO OUT))
	    ([AND (LISTP LFT)
		  (COND
		    ((SETQ CROPS (GETP (CAR LFT)
				       (QUOTE CROPS)))
		      (SETQ CROPS (SUBPAIR (QUOTE (A D))
					   (QUOTE (:1 ::1))
					   CROPS]

          (* E.g. (RPLACA (CDR X) --) becomes X:2_--.
          instead of X::1:1_ --)


	      (SETQ TEM (CLISPIFYCROPS (CADR LFT)
				       CROPS
				       (CAR LFT)
				       TYP0)))
	    (T (SETQ TEM (CLISPIFYCROPS LFT NIL NIL TYP0]
          [COND
	    ((NULL (CDR TEM))

          (* The first argument did not clispify to something 
          containing :'s, so we will not use the _ notation)


	      (SETQ SEG NIL)
	      (RETURN (COND
			[(EQ TYP (QUOTE replace))
			  (CONS TYP (CONS TYP0
					  (CONS (QUOTE of)
						(NCONC TEM (CONS (QUOTE
								    with)
								 (CLISPIFY1
								   RGHT]
			(T (CONS (CAR X)
				 (NCONC TEM (CLISPIFY1 RGHT]
      OUT (SETQ SEG (NULL CLTYP00))
          (SETQ PARENT PARENT0)
          (RETURN (CLISP3A (NCONC TEM (COND
				    ((CAR RGHT)
				      (CONS (QUOTE _)
					    ([LAMBDA (LST TAIL)

          (* LST is rbound to T to indicate to CLISP3 that there are 
          operands to the left of this expression 
          (namely TEM and _). Otherwise things like 
          (RPLACD X (OR (FOO Y) Y)) would go to X::1_ 
          (FOO Y) OR Y where actually the or should be parentheseized.
          TAIL is rebound to NIL so that CLISP3 will know there isnt 
          anything on the right..)


						(CLISPIFY2A (CAR RGHT]
					      T)))
				    (T (LIST (QUOTE _)
					     NIL])

(CLISPIFYMAPS
  [LAMBDA (IN-ON OPR)
    (PROG (VAR (FN1 (CADDR FORM))
	       (FN2 (CADDDR FORM))
	       TEM)
          [COND
	    ([OR (ATOM FN1)
		 (NEQ (CAR FN1)
		      (QUOTE FUNCTION))
		 [AND FN2 (OR (ATOM FN2)
			      (NEQ (CAR FN2)
				   (QUOTE FUNCTION]
		 (NEQ (CAR FORM)
		      (CLISPIFYLOOKUP (CAR FORM)
				      (CADR FORM]
                                                (* E.G. (MAPCAR X Y))
	      (RETURN (CLISPIFY1 FORM]
          (SETQ FN1 (CLMAPS1 FN1))
          (SETQ FN2 (CLMAPS1 FN2))
          (RETURN (NCONC (AND [SETQ VAR (COND
				  ((NOT (ATOM FN1))
				    (CAADR FN1))
				  ((EQ (CADR FORM)
				       (QUOTE X))
				    (QUOTE Y))
				  (T (QUOTE X]
			      (LIST (COND
				      (LCASEFLG (QUOTE for))
				      (T (QUOTE FOR)))
				    VAR))
			 (LIST IN-ON)
			 (COND
			   ((AND [NULL (CDR (SETQ TEM (CLISPIFY2A (CADR FORM]
				 (CLREMPARS (CAR TEM)))
			     (APPEND (CAR TEM)))
			   (T TEM))
			 [CLMAPS2 FN2 (COND
				    (LCASEFLG (QUOTE by))
				    (T (QUOTE BY]
			 (CLMAPS2 FN1 OPR])

(CLMAPS1
  [LAMBDA (FN)
    (COND
      ((NEQ (CAR FN)
            (QUOTE F/L))
        (CADR FN))
      (T (CONS (QUOTE LAMBDA)
               (COND
                 ((AND (CDDR FN)
                       (NOT (FGETD (CAADR FN)))
                       (EVERY (CADR FN)
                              (FUNCTION ATOM)))
                   (CDR FN))
                 (T (CONS (LIST (QUOTE X))
                          (CDR FN])

(CLMAPS2
  [LAMBDA (DEF WORD)
    (AND DEF (PROG (X Y TEM OPR0 CLTYP0)
	           [COND
		     ((EQ WORD (QUOTE subset))
		       [SETQ WORD (COND
			   (LCASEFLG (QUOTE when))
			   (T (QUOTE WHEN]
		       (SETQ Y (LIST (COND
				       (LCASEFLG (QUOTE collect))
				       (T (QUOTE COLLECT)))
				     VAR]
	           [SETQ X (COND
		       ((ATOM DEF)
			 (LIST DEF))
		       ([AND (FMEMB WORD (QUOTE (DO JOIN do join)))
			     (NULL (CDDDR DEF))
			     (COND
			       ((AND (EQ (CAR (SETQ X (CADDR DEF)))
					 (QUOTE COND))
				     (NULL (CDDR X)))

          (* The form of the function is 
          (LAMBDA & (COND (--))) TEM is set to the clause.)


				 (SETQ TEM (CADR X)))
			       ((EQ (CAR X)
				    (QUOTE AND))
                                                (* If the NULL yields true, the 
                                                form is (AND & &))
				 (NULL (CDDR (SETQ TEM (CDR X]
			 (SETQ Y TEM)
			 (SETQ X (CDR Y))       (* X now corresonds to the body 
                                                of the iteraion.)
			 [SETQ Y (CONS [COND
					 [(EQ (CAAR Y)
					      (QUOTE NOT))
					   (SETQ Y (CADAR Y))
					   (COND
					     (LCASEFLG (QUOTE unless))
					     (T (QUOTE UNLESS]
					 (T (SETQ Y (CAR Y))
					    (COND
					      (LCASEFLG (QUOTE when))
					      (T (QUOTE WHEN]
				       (COND
					 ((AND [NULL (CDR (SETQ TEM
							    (CLISPIFY2A Y]
					       (CLREMPARS (CAR TEM)))
					   (CAR TEM))
					 (T TEM]
			 [COND
			   ((AND (OR (EQ WORD (QUOTE JOIN))
				     (EQ WORD (QUOTE join)))
				 [NULL (CDDAR (SETQ TEM (FLAST X]
				 (EQ (CAAR TEM)
				     (QUOTE LIST)))
			     [SETQ WORD (COND
				 (LCASEFLG (QUOTE collect))
				 (T (QUOTE COLLECT]
			     (SETQ X (NCONC (LDIFF X TEM)
					    (CDAR TEM]

          (* E.g. JOIN (COND (& -- (LIST &))) -> COLLECT -- WHEN &)


			 (CLISPIFY1 X))
		       (T (CLISPIFY1 (CDDR DEF]
	           [COND
		     ((NLISTP DEF)
		       (SETQ TEM NIL))
		     [(NEQ (CAADR DEF)
			   VAR)

          (* Entire LAMBDA expression must be included because the 
          variable is not the same as that in the FOR, i.e. not the 
          same as the one in the first functional argument.)


		       (RETURN (CONS WORD (CONS (CONS (CAR DEF)
						      (CONS (CADR DEF)
							    X))
						Y]
		     ((SETQ TEM (CDADR DEF))
		       (SETQ TEM (CONS (COND
					 (LCASEFLG (QUOTE bind))
					 (T (QUOTE BIND)))
				       (APPEND TEM]
	           (RETURN (NCONC TEM (CONS WORD (COND
					      ((AND (NULL (CDR X))
						    (CLREMPARS (CAR X)))
						(APPEND (CAR X)
							Y))
					      (T (APPEND X Y])

(CLISPDEC
  [LAMBDA (DECLST)                              (* Does global declaratin)
    (AND DECLST (ATOM DECLST)
         (SETQ DECLST (LIST DECLST)))
    (PROG ((LST DECLST)
           TEM CLASSDEF)
      TOP (COND
            ((NULL LST)
              (RETURN DECLST)))
          [SELECTQ
            (CAR LST)
            [(INTEGER FIXED MIXED FLOATING)
              (MAPC (QUOTE (+ - * / +- LT GT))
                    (FUNCTION (LAMBDA (X)       (* E.g. X IS *, /, +, ETC.)
                        (COND
                          ((SETQ TEM (GETP X (QUOTE LISPFN)))
                                                (* May have been disabled)
                            (/REMPROP TEM (QUOTE CLISPINFIX))
                            [/PUT X (QUOTE LISPFN)
                                  (SETQ TEM
                                    (CAR (NTH (CDR (GETP X (QUOTE CLISPCLASSDEF)
                                                         ))
                                              (CDR (GETP (CAR LST)
                                                         (QUOTE CLISPCLASS]

          (* E.G. CLISPCLASS for FLOATING is 
          (ARITH . 2), for * is (ARITH ITIMES FTIMES TIMES) meaning 
          the FLOATING version for * is FTIMES.)


                            (/PUT TEM (QUOTE CLISPINFIX)
                                  X]
            [(STANDARD UNDOABLE FAST)
              (SETQ CLASSDEF (GETP (CAR LST)
                                   (QUOTE CLISPCLASS)))
              (MAPC DECLWORDS
                    (FUNCTION (LAMBDA (X)
                        (COND
                          ([AND [EQ (QUOTE ACCESS)
                                    (CAR (SETQ TEM (GETP X (QUOTE CLISPCLASSDEF]
                                (SETQ TEM (CAR (NTH (CDR TEM)
                                                    (CDR CLASSDEF]
                            (/PUT X (QUOTE LISPFN)
                                  TEM]
            (COND
              [(LISTP (CAR LST))
                (COND
                  ((FMEMB (CAAR LST)
                          CLISPRECORDTYPES)
                    (EVAL (CAR LST)))
                  (T (GO ERROR]
              ([AND (FMEMB (CAR LST)
                           DECLWORDS)
                    (ATOM (SETQ TEM (GETP (CAR LST)
                                          (QUOTE CLISPCLASS]
                (/PUT TEM (QUOTE LISPFN)
                      (CAR LST)))
              ((SETQ TEM (OR (PROG (TYPE-IN? FAULTFN)
                                   (RETURN (FIXSPELL (CAR LST)
                                                     70 DECLWORDS)))
                             (GO ERROR)))
                (/RPLNODE LST TEM (CDR LST))
                (GO TOP]
          (SETQ LST (CDR LST))
          (GO TOP)
      ERROR
          (ERROR (QUOTE "illegal declaration")
                 (CAR LST])

(CLISPDEC0
  [LAMBDA (X FN)
    (/RPLNODE X (QUOTE *)
              (CONS (QUOTE DECLARATIONS:)
                    (CLISPDEC1 (CDR X)
                               FN)))
    (CDDR X])

(CLISPDEC1
  [LAMBDA (X FAULTFN)
    (MAPCON X (FUNCTION (LAMBDA (X)
                (PROG (TEM TYPE-IN?)
                  TOP (RETURN (COND
                                [(LISTP (CAR X))
                                  (LIST (COND
                                          ((OR (EQ (CADAR X)
                                                   (QUOTE =))
                                               (FMEMB (CAAR X)
                                                      CLISPRECORDTYPES))
                                            (CAR X))
                                          (T (CONS (CAAR X)
                                                   (CLISPDEC1 (CDAR X]
                                ((FMEMB (CAR X)
                                        DECLWORDS)
                                  (LIST (CAR X)))
                                ((FIXSPELL (CAR X)
                                           70 DECLWORDS NIL X NIL
                                           (DUNPACK (CAR X)
                                                    SKORLST1))
                                  (GO TOP))
                                (T (ERROR (QUOTE "illegal declaration")
                                          (CAR X])

(EXPRCHECK
  [LAMBDA (X)
    (PROG (D)
          (COND
            ((NOT (LITATOM X))
              (ERROR X (QUOTE "not a function.")))
            [(EXPRP (SETQ D (VIRGINFN X T]
            ((GETD X)
              (GO NOEXPR))
            ([NULL (AND DWIMFLG (SETQ D (MISSPELLED? X 70 USERWORDS NIL NIL
                                                     (FUNCTION GETD]
              (AND FLG (RETURN NIL))
              (ERROR X (QUOTE "not defined.")))
            ([NOT (EXPRP (SETQ D (VIRGINFN (SETQ X D]
              (GO NOEXPR)))
          (SETQ FN X)
          (AND DWIMFLG (ADDSPELL X 0))
          (RETURN D)
      NOEXPR
          (ERROR X (QUOTE "not an expr."])

(CLSTOPSCAN?
  [LAMBDA (CLTYPX CLTYP)

          (* STOPSCAN? is T if operator corresponding to CLTYPX would 
          stop scan for operator corresponding to CLTYP, i.e. if 
          former is of lower or same precedence as latter.)


    (AND CLTYPX CLTYP (NOT (ILESSP (COND
                                     ((ATOM CLTYP)
                                       CLTYP)
                                     (T (CDR CLTYP)))
                                   (COND
                                     ((ATOM CLTYPX)
                                       CLTYPX)
                                     (T (CAR CLTYPX])

(CLISPIFYLOOKUP
  [LAMBDA (WORD VAR1 VAR2 CLASS CLASSDEF)

          (* In most cases, it is not necessary to do a full lookup.
          This is q uick an dirty check inside of the block to avoid 
          calling CLISPLOOKUP0 whenever there are no declarations.)


    (PROG (TEM)
          [OR CLASS (SETQ CLASS (GETP WORD (QUOTE CLISPCLASS]
          [OR CLASSDEF (SETQ CLASSDEF (GETP CLASS (QUOTE CLISPCLASSDEF]
          [SETQ TEM (COND
              ((AND CLASS DECLST)

          (* must do full lookup. Note that for CLISPLOOKUP, 
          CLISPLOOKUP0 is only called when there is a CLASSDEF.
          Here it is called when there is a CLASS property.
          This is bcause what CLISPIFYLOOKUP is really asking is what 
          would the infix operator corresponding to WORD go to if 
          DWIMIIED, e.g. if WORD is FGTP, CLISPIFYLOOKUP is reaally 
          asking what does GT go to.)


                (CLISPLOOKUP0 WORD VAR1 VAR2 DECLST NIL CLASS CLASSDEF))
              (T 

          (* The last GETP , i.e. for CLASS, is so we dont have to 
          implement global declaraions by puttig a LISPFN property on 
          each member of the class.)


                 (OR (GETP WORD (QUOTE LISPFN))
                     (GETP CLASS (QUOTE LISPFN))
                     WORD]
          [COND
            ((AND (EQ (CAR CLASSDEF)
                      (QUOTE ARITH))
                  (EQ TEM (CADR CLASSDEF))
                  (OR (FLOATP VAR1)
                      (FLOATP VAR2)))
              (SETQ TEM (CADDR CLASSDEF]
          (RETURN TEM])

(CLISPLOOKUP0
  [LAMBDA (WORD VAR1 VAR2 DECLST LISPFN CLASS CLASSDEF)

          (* LISPFN is returned if no local declaration is found 
          affecting FN. CLASS is the CLASS for FN, e.g. RPLACA, +, 
          MEMB, etc. CLASS is supplied when looking up local record 
          declaration (in his case it is RECORD) or when looking up a 
          local value for a variable, such as VARDEFAULT ina pattern 
          match, in which case it is VALUE.)



          (* To define a new class of functions a la RPLACA, FRPLACA, 
          and /RPLACA, one must add all three names to DECLWORDS, put 
          the name of the standard one on the property lits of each 
          under property CLISPCLASS, and put under the standard one on 
          property CLISPCLASSDEF the property 
          (ACCESS standard undoable fast) version, where undoable or 
          fast can be NIL. Then CLISPDEC STANDARD, UNDOABLE, or FAST 
          will have the right effect, and calling CLISPLOOKUP on the 
          names of either of the functions will eturn the current 
          "Setting".)


    (PROG (TEM)
          (COND
            ((OR (NULL DECLST)
                 (NULL CLASS))

          (* CLISPLOOKUP0 is always supposed to be called with a 
          non-NIL CLASS and DECLST.)


              (HELP)))
          [OR CLASSDEF (SETQ CLASSDEF (GETP CLASS (QUOTE CLISPCLASSDEF]
          (SETQ VAR1 (CLISPLOOKUP2 VAR1))
          (SETQ VAR2 (CLISPLOOKUP2 VAR2))
          (RETURN (COND
                    ((SETQ TEM (CLISPLOOKUP1 DECLST))
                      TEM)
                    (T 

          (* The last GETP in the OR below , i.e. for CLASS, is so we 
          dont have to implement global declaraions by puttig a LISPFN 
          property on each member of the class.)


                       (SELECTQ CLASS
                                (VALUE (CAR WORD))
                                ((RECORD RECORDFIELD)
                                  NIL)
                                (OR LISPFN (GETP WORD (QUOTE LISPFN))
                                    (GETP CLASS (QUOTE LISPFN))
                                    WORD])

(CLISPLOOKUP1
  [LAMBDA (LST)

          (* Searches LST for a delcaration releveant to CLASS, which 
          is equal to (GETP WORD (QUOTE CLISPCLASS.)))


    (PROG (TEM VAL)
      LP  (COND
            ((NULL LST)
              (RETURN VAL))
            [(LISTP (SETQ TEM (CAR LST)))
              (AND CLISPTRANFLG (EQ (CAR TEM)
                                    CLISPTRANFLG)
                   (SETQ TEM (CDDR TEM)))
              (COND
                [(EQ (CADR TEM)
                     (QUOTE =))
                  (AND (EQ CLASS (QUOTE VALUE))
                       (EQ (CAR TEM)
                           WORD)
                       (SETQ VAL (CADDR TEM]
                [(OR (EQ CLASS (QUOTE RECORD))
                     (EQ CLASS (QUOTE RECORDFIELD)))
                  (AND (FMEMB (CAR TEM)
                              CLISPRECORDTYPES)
                       [COND
                         [(EQ CLASS (QUOTE RECORDFIELD))
                           (FMEMB WORD (CAR (RECORDECL TEM]
                         (T (EQ WORD (CADR (RECORDECL TEM]
                       (SETQ VAL (CAR LST]
                ((EQ (CAR TEM)
                     CLASS)

          (* So user can look up his own 'classes', e.g. say 
          (CLISP: (FOOTYPE)) and then look up FOOTYPE.
          Terry uses this.)


                  (SETQ VAL (CAR LST)))
                ([AND (OR (EQ (SETQ TEM (CAAR LST))
                              VAR1)
                          (EQ TEM VAR2))
                      (SETQ TEM (CLISPLOOKUP1 (CDAR LST]
                  (RETURN TEM]
            [[ATOM (SETQ TEM (GETP (CAR LST)
                                   (QUOTE CLISPCLASS]

          (* E.g. WORD is FRPLACA CLASS is RPLACA, and 
          (CAR LST) is /RPLACA. TEM is also RPLACA.)


              (AND (EQ TEM CLASS)
                   (SETQ VAL (CAR LST]
            ([AND (EQ (CAR TEM)
                      (CAR CLASSDEF))
                  (SETQ TEM (CAR (NTH (CDR CLASSDEF)
                                      (CDR TEM]

          (* E.G. WORD is FRPLACA and (CAR LST) is FAST.
          or WORD is + and (CAR LST) is FLOATING.
          The eason for checking that the nth element is not nil is 
          that FAST does not apply to NCONC, even though both are 
          ACCESS type declarations, similaly, undoable does not apply 
          to LAST.)


              (SETQ VAL TEM)))
      LP1 (SETQ LST (CDR LST))
          (GO LP])

(CLISPLOOKUP2
  [LAMBDA (X)
    (COND
      ((NLISTP X)
        X)
      ((OR (EQ (CAR X)
               (QUOTE SETQ))
           (EQ (CAR X)
               (QUOTE SETQQ)))
        (CADR X))
      ((EQ (CADR X)
           (QUOTE _))
        (CAR X])

(LOWERCASE
  [LAMBDA (FLG)
    (PROG1 LCASEFLG
	   (PROG (FN TEM)
	         (AND (NULL CHCONLST)
		      (SETQ CHCONLST (QUOTE NIL)))
                                                (* Because LOWERCASE is often 
                                                done in initialization, i.e. 
                                                before CHCONLST is set.)
	         [SETQ FN (COND
		     (FLG (QUOTE L-CASE))
		     (T (QUOTE U-CASE]
	         (RPAQ LCASEFLG FLG)
	         [MAPC (QUOTE (MAPC MAP MAPCAR MAPLIST MAPCONC MAPCON))
		       (FUNCTION (LAMBDA (X)
			   (/PUT X (QUOTE CLMAPS)
				 (CONS [APPLY* FN (CAR (SETQ TEM
							 (GETP X (QUOTE CLMAPS]
				       (APPLY* FN (CDR TEM]
	         (/PUT (QUOTE OR)
		       (QUOTE CLISPINFIX)
		       (APPLY* FN (QUOTE OR)))
	         (/PUT (QUOTE AND)
		       (QUOTE CLISPINFIX)
		       (APPLY* FN (QUOTE AND])

(SHRIEKIFY
  [LAMBDA (LOOKAT)
    (PROG (RESULTP CARTEST (OPR0 (QUOTE <))
                   CLTYP0 PARENT SUBPARENT)
          (SELECTQ (SETQ CARTEST (CAR LOOKAT))
                   [(NCONC /NCONC)
                     (COND
                       ((NEQ CARTEST (CLISPIFYLOOKUP (QUOTE NCONC)
                                                     NIL))
                         (RETURN (CLISPIFY2C LOOKAT]
                   [(NCONC1 /NCONC1)
                     (COND
                       ((NEQ CARTEST (CLISPIFYLOOKUP (QUOTE NCONC1)
                                                     NIL))
                         (RETURN (CLISPIFY2C LOOKAT]
                   NIL)
          (SETQ RESULTP (LIST (QUOTE <)))
          (SHRKFY LOOKAT (QUOTE STARTING)
                  T)
          (RETURN (COND
                    ((CDR RESULTP)
                      (NCONC1 RESULTP (QUOTE >])

(SHRKFY
  [LAMBDA (LOOKAT WORKFLAG STAGEFLAG)

          (* SHRKFY is a translator from LISP expressions involving 
          CONS, LIST, APPEND, NCONC, NCONC1, /NCONC, and /NCONC1 to 
          CLISP expressions using !, !!, and <;
          thus it is the inverse translator to SHRIEKER.
          Although this is a large program, its operation is fairly 
          simple. Several prog labels, from A1 to A5, have been 
          introduced to aid this explication.
          Control flows straight through SHRKFY, from top to bottom, 
          with no awkward detours or loops.
          In essence, SHRKFY is a stack of three large selectq's, each 
          of which does some computation necessary for the next.)


    (PROG ((CARSAFEFLAG T)
           CARLOOKAT CDRLOOKAT CDARLOOKAT CAARLOOKAT OPFLG CARFLAG CDDARLOOKAT 
           RESULTQ RESULTR OP2FLG OP3FLG FIRSTARGFLG APPSINGFLG)
          (AND (EQ LOOKAT (CDR FORM))
               (MAP LOOKAT (FUNCTION CLISP4)))

          (* This is Warren's scanner function, which recognizes CLISP 
          expressions inside LOOKAT, and converts them to LISP 
          expressions.)


          (SETQ CARLOOKAT (CAR LOOKAT))
          (COND
            ((LISTP CARLOOKAT)
              (SETQ CAARLOOKAT (CAR CARLOOKAT))
              (SETQ CDARLOOKAT (CDR CARLOOKAT))
              (SETQ CDDARLOOKAT (CDR CDARLOOKAT))
              (SETQQ CARFLAG ITSALIST))
            (T (SETQQ CARFLAG ELEMENTAL)))

          (* These canonical prog varnames remain constant throughout 
          the program. I.e. CAARLOOKAT is always 
          (CAAR LOOKAT), etc.)


          (SETQ CDRLOOKAT (CDR LOOKAT))
      A1  

          (* SHRKFY works by emulating, or mimicing, the actions of 
          APPEND, CONS, LIST, NCONC, NCONC1, etc., on their arguments 
          with respect to the CLISP operators !, !!, and <.
          Whenever SHRKFY is called, WORKFLAG is the name of the 
          function being emulated and STAGEFLAG is the "stage" 
          (either T or NIL) that the emulation has reached.
          The first time that SHRKFY is called to mimic a function, 
          STAGEFLAG will be T, which is SHRKFY's signal that this is 
          indeed the first time it has been called, and that LOOKAT is 
          CDR of the original form. STAGEFLAG will then be setq'd to 
          NIL. Depending on the value of STAGEFLAG and CDRLOOKAT 
          (which tells SHRKFY whether or not there or more arguments 
          besides CARLOOKAT), OPFLG will be setq'd to '!, '!!, or 
          'LISTIT, and control will then flow to A2.)


          (SELECTQ WORKFLAG
                   [(NCONC /NCONC)
                     (COND
                       (STAGEFLAG (SETQQ OPFLG !!))
                       (CDRLOOKAT (SETQQ OPFLG !!))
                       (T (SETQQ OPFLG !)))
                     (COND
                       (STAGEFLAG 

          (* FIRSTARGFLG is setq'd to T to save the fact that 
          CARLOOKAT is the first argument of the form.)


                                  (SETQ STAGEFLAG NIL)
                                  (SETQ FIRSTARGFLG T]
                   [CONS (COND
                           (STAGEFLAG (SETQQ OPFLG LISTIT)
                                      (SETQ STAGEFLAG NIL)
                                      (SETQ FIRSTARGFLG T))
                           (CDRLOOKAT (SETQQ OPFLG LISTIT))
                           (T (SETQQ OPFLG !]
                   (APPEND (COND
                             (STAGEFLAG (SETQ STAGEFLAG NIL)
                                        (SETQ FIRSTARGFLG T)))
                           (SETQQ OPFLG !))
                   (LIST (SETQQ OPFLG LISTIT))
                   [(NCONC1 /NCONC1)
                     (COND
                       (STAGEFLAG (SETQQ OPFLG !!))
                       (T (SETQQ OPFLG LISTIT)))
                     (COND
                       (STAGEFLAG (SETQ STAGEFLAG NIL)
                                  (SETQ FIRSTARGFLG T]
                   [STARTING 

          (* The very first time that SHRKFY is called 
          (by SHRIEKIFY), WORKFLAG is eq to 'STARTING.
          This branch takes care of recognizing whether the form 
          LOOKAT has at least one argument.
          If it does, then SHRKFY is called recursively on CDRLOOKAT, 
          with WORKFLAG = CARLOOKAT. Otherwise SHRKFY returns to 
          SHRIEKIFY.)


                             (COND
                               (CDRLOOKAT       (* the form has at least one 
                                                argument.)
                                          (RETURN (SHRKFY CDRLOOKAT CARLOOKAT 
                                                          STAGEFLAG)))
                               (T (SELECTQ CARLOOKAT
                                           ((LIST APPEND NCONC /NCONC)

          (* (APPEND), (LIST), (NCONC), and 
          (/NCONC) all evaluate to NIL. RESULTP will be 
          (<) when we return to SHRIEKIFY, which will return NIL.)


                                             (RETURN NIL))
                                           ((CONS NCONC1 /NCONC1)

          (* (CONS), (LIST), (NCONC1), (/NCONC1) all evaluate to 
          (NIL), so this branch adds NIL to RESULTP and returns to 
          SHRIEKIFY.)


                                             (RETURN (NCONC1 RESULTP NIL)))
                                           NIL]
                   NIL)
      A2  [COND
            (CDRLOOKAT 

          (* RESULTR holds SHRKFY's translation of the arguments after 
          CARLOOKAT. Nothing will be done with it until the final COND 
          at the top level of the SHRKFY prog, which takes care of 
          adding RESULTR onto RESULTP. The next three selectq's at A3, 
          A4, and A5 are devoted to adding the proper translation of 
          CARLOOKAT to RESULTP.)


                       (SETQ RESULTR (SHRKFY2 CDRLOOKAT WORKFLAG STAGEFLAG))
                       (SETQ RESULTR (CDR RESULTR]
      A3  (SELECTQ
            OPFLG
            ((!! !)
              (SELECTQ CARFLAG
                       [ELEMENTAL (COND
                                    (CARLOOKAT 

          (* If CARLOOKAT is not nil and not a list then we just add 
          it on to RESULTP, preceded by the appropriate operator 
          ('! or '!!). The selectq with the call to DWIMIFY1A enables 
          us to catch errors like (APPEND A B CONS D E) and issue a 
          message to the user that there is a 
          "(possible) parentheses error." SHRKFY, however, continues 
          with its computation.)


                                               (NCONC RESULTP (LIST OPFLG 
                                                                  CARLOOKAT))
                                               (SELECTQ CARLOOKAT
                                                        ((APPEND CONS LIST 
                                                                 NCONC NCONC1 
                                                                 /NCONC /NCONC1 
                                                                 QUOTE)
                                                          (DWIMIFY1A FORM 
                                                                     LOOKAT FN))
                                                        NIL))
                                    (T 

          (* makes sure that (APPEND NIL A), 
          (NCONC NIL A), etc. go to <! NIL ! A>, <!! NIL ! A>, not <! 
          A >. Otherwise, ! NIL and !! NIL are left out of RESULTP.
          Thus, (APPEND A B NIL C D) goes to <! A ! B ! C ! D>.
          This conditional could be refined a little to let cases like 
          (NCONC1 NIL A) go to < A >, rather than <!! NIL A>.)


                                       (COND
                                         ((AND FIRSTARGFLG (NULL (CDR CDRLOOKAT)
                                                                 )
                                               CDRLOOKAT)
                                           (NCONC RESULTP (LIST OPFLG NIL]
                       [ITSALIST                (* CARLOOKAT is a list 
                                                (form).)
                         (COND
                           [CDARLOOKAT 

          (* If CDARLOOKAT is non-nil then we know there's at least 
          one argument in the form, so we do a selectq on CAARLOOKAT, 
          the first element of the form, which is expected to be a 
          function name. This selectq finds out which function name, 
          and saves this information in OP2FLG.
          (In certain cases, CARSAFEFLAG will be setq'd to NIL.) 
          Without exception, control then flows to the major selectq 
          on OP2FLG, which has the prog label A4.)


                                       (SELECTQ CAARLOOKAT
                                                ((LIST CONS)
                                                  (SETQ OP2FLG CAARLOOKAT))
                                                (APPEND (COND
                                                          ((NULL CDDARLOOKAT)

          (* If CDDARLOOKAT is nil, then we know that the form 
          CARLOOKAT, which has APPEND as its function name, has 
          exactly one argument. So APPSINGFLG is setq'd to T, to save 
          the fact that CARLOOKAT is an APPEND singleton.)


                                                            (SETQ APPSINGFLG T))
                                                          )
                                                        (SETQQ OP2FLG APPEND))
                                                ((NCONC NCONC1 /NCONC /NCONC1)
                                                  (SETQ OP2FLG CAARLOOKAT)

          (* CARSAFEFLAG is setq'd to NIL to indicate that CARLOOKAT 
          may be (in this case, is) a destructive operation.)


                                                  (SETQ CARSAFEFLAG NIL))
                                                (QUOTE 

          (* SHRKFY understands that if CARLOOKAT is a QUOTE form then 
          it is not a destructive operation.
          So CARSAFEFLAG is not affected, but OP2FLG is setq'd to 
          OPFLG, which will result in calling CLISPIFY2A on 
          CARLOOKAT.)


                                                       (SETQ OP2FLG OPFLG))
                                                (PROGN 

          (* CARLOOKAT is a form, and its first element is a function 
          name that SHRKFY doesn't recognize.
          So CARSAFEFLAG is setq'd to NIL, to indicate that there may 
          be a destructive operation going on, and OP2FLG is setq'd to 
          OPFLG (i.e. either '! or '!!), which will result in calling 
          CLISPIFY2A on CARLOOKAT, when control flows to the selectq 
          following the prog label A4.)


                                                       (SETQ OP2FLG OPFLG)
                                                       (SETQ CARSAFEFLAG NIL]
                           (T 

          (* this branch handles ! (APPEND), !! 
          (CONS), ! (CONS), !! (NCONC), etc. I.e.
          CARLOOKAT is a form with no arguments.
          If its function name is recognized by SHRKFY, then the 
          appropriate code will be added automatically to RESULTP.
          Although control will flow to the SELECTQ following A4, 
          nothing will happen there, because OP2FLG is NIL.
          Similarly for the SELECTQ on OP3FLG, following A5.
          Control will wind up at the final COND at the top level of 
          the SHRKFY prog, which takes care of adding RESULTR to 
          RESULTP. On the other hand, if SHRKFY does not recognize the 
          function name in CARLOOKAT, OP2FLG will be setq'd to OPFLG, 
          which will cause CLISPIFY2A to be called on CARLOOKAT, when 
          control flows to the selectq following A4.)


                              (SELECTQ CAARLOOKAT
                                       [(APPEND NCONC LIST QUOTE /NCONC)

          (* (APPEND) (NCONC) (LIST) (QUOTE) and 
          (/NCONC) all evaluate to NIL. Thus ! 
          (APPEND) is the same as ! NIL, and can be left out of 
          RESULTP, unless doing so would cause the next element in 
          LOOKAT to be copied when it shouldn't be.
          E.g. (APPEND (APPEND) A) should go to 
          (<! NIL ! A>), not (<! A>). The same conditional is used to 
          avoid this special case as in the branch above when CARFLAG 
          = 'ELEMENTAL. This conditional could be refined a little to 
          let cases like (NCONC1 (APPEND) A) go to 
          (< A >), rather than to (<!! NIL A>), as they do currently.)


                                         (COND
                                           ((AND FIRSTARGFLG
                                                 (NULL (CDR CDRLOOKAT))
                                                 CDRLOOKAT)
                                             (NCONC RESULTP (LIST OPFLG NIL]
                                       [(CONS NCONC1 /NCONC1)

          (* (CONS) (NCONC1) and (/NCONC1) all evaluate to 
          (NIL), so this branch replaces ! 
          (CONS) by ! <NIL>, etc. The brackets are left in for the 
          sake of simplicity, because some cases require that they 
          stay in. Thus if (NCONC A (CONS) B C) went to <!! A NIL !! B 
          ! C>, then it would dwimify back to 
          (NCONC A (CONS NIL (NCONC B C))), which is not equivalent.
          However, brackets can probably be left out whenever OPFLG = 
          '! and WORKFLAG = 'APPEND or 'CONS, which is a refinement 
          that merits investigation. A small COND here would thus 
          allow SHRKFY to simplify (CONS A 
          (APPEND)) to (LIST A NIL) and (APPEND 
          (APPEND) A) to (CONS NIL A).)


                                         (NCONC RESULTP (LIST OPFLG
                                                              (QUOTE <)
                                                              NIL
                                                              (QUOTE >]
                                       (PROGN 

          (* SHRKFY doesn't recognize the function name in CARLOOKAT, 
          so this form will be given to CLISPIFY2A when control flows 
          to the selectq following A4, and CARSAFEFLAG will be setq'd 
          to NIL, to indicate that something destructive could be 
          happening.)


                                              (SETQ OP2FLG OPFLG)
                                              (SETQ CARSAFEFLAG NIL]
                       NIL))
            (LISTIT 

          (* This branch is analogous to the one above 
          (where OPFLG = '! or '!!), except that here CARLOOKAT is 
          simply being listed, or added on.)


                    (SELECTQ
                      CARFLAG
                      (ELEMENTAL 

          (* Note that there is an additional call to DWIMIFY1A here, 
          which lets us catch errors like 
          (CONS NCONC D E) and issue a message to the user that there 
          is a ' (possible) parentheses error.)


                                 (NCONC1 RESULTP CARLOOKAT)
                                 (SELECTQ CARLOOKAT
                                          ((APPEND CONS LIST NCONC NCONC1 
                                                   /NCONC /NCONC1 QUOTE)
                                            (DWIMIFY1A FORM LOOKAT FN))
                                          NIL))
                      [ITSALIST (COND
                                  [CDARLOOKAT (SELECTQ CAARLOOKAT
                                                       ((CONS LIST APPEND)
                                                         (SETQ OP2FLG 
                                                           CAARLOOKAT))
                                                       ((NCONC NCONC1 /NCONC 
                                                               /NCONC1)
                                                         (SETQ CARSAFEFLAG NIL)
                                                         (SETQ OP2FLG 
                                                           CAARLOOKAT))
                                                       (QUOTE (SETQQ OP2FLG 
                                                                    ADDITON))
                                                       (PROGN (SETQ CARSAFEFLAG 
                                                                NIL)
                                                              (SETQQ OP2FLG 
                                                                    ADDITON]
                                  (T (SELECTQ CAARLOOKAT
                                              ((APPEND NCONC LIST QUOTE /NCONC)
                                                (NCONC1 RESULTP NIL))
                                              [(CONS NCONC1 /NCONC1)
                                                (NCONC RESULTP
                                                       (LIST (QUOTE <)
                                                             NIL
                                                             (QUOTE >]
                                              (PROGN (SETQQ OP2FLG ADDITON)
                                                     (SETQ CARSAFEFLAG NIL]
                      NIL))
            NIL)
      A4  (SELECTQ
            OP2FLG
            ((!! !)
              (NCONC (NCONC1 RESULTP OP2FLG)
                     (CLISPIFY2A CARLOOKAT)))
            (ADDITON (NCONC RESULTP (CLISPIFY2A CARLOOKAT)))
            [(APPEND CONS LIST NCONC NCONC1 /NCONC /NCONC1)

          (* CARLOOKAT is a form of at least one argument, and its 
          function name is one of the special functions recognized by 
          SHRKFY. This function name is the value of OP2FLG.
          Most of the general optimizations described in the memo on 
          SHRKFY take place in this selectq.)


              (SELECTQ OP2FLG
                       [(NCONC /NCONC)

          (* If OP2FLG = 'NCONC, '/NCONC, 'NCONC1, or '/NCONC1, and is 
          not eq to the value of the corresponding CLISPIFYLOOKUP, 
          then control will be sent to A5, where CARLOOKAT will be 
          given to CLISPIFY2C.)


                         (COND
                           ((NEQ OP2FLG (CLISPIFYLOOKUP (QUOTE NCONC)
                                                        NIL))
                             (SETQQ OP3FLG CLISPIFY2CIT)
                             (GO A5]
                       [(NCONC1 /NCONC1)
                         (COND
                           ((NEQ OP2FLG (CLISPIFYLOOKUP (QUOTE NCONC1)
                                                        NIL))
                             (SETQQ OP3FLG CLISPIFY2CIT)
                             (GO A5]
                       NIL)

          (* Within the prog below, FORM is rebound to CARLOOKAT, so 
          that Warren's scanner will be appropriately triggered.
          SHRKFY2 is called, rather than SHRKFY, so that the lower 
          level SHRKFY will be able to work with its own, fresh, 
          RESULTP. The RESULTP that is returned by SHRKFY2 will be 
          made the value of the current SHRKFY's RESULTQ.
          This RESULTQ will be a list of CLISP expressions, including 
          ! and !!, without enclosing angle brackets.
          The question of whether to add the angle brackets or not is 
          resolved by the body of this branch, and the nature of this 
          decision is stored in OP3FLG. Control then flows to the 
          selectq following A5, where RESULTQ, with appropriate 
          surrounding brackets (and preceding operators ! or !!), will 
          be added to RESULTP. We may think of RESULTQ as always, 
          implicitly, having angle brackets around it, and thus the 
          simple operation (NCONC RESULTP RESULTQ) corresponds to 
          "removing" the angle brackets. This operation is denoted by 
          (SETQQ OP3FLG OFFANGLES), while the operation of leaving the 
          brackets in and preceding them by '!! or '! is denoted by 
          (SETQQ OP3FLG OPANGLE).)


              (PROG ((FORM CARLOOKAT))
                    (SETQ RESULTQ (SHRKFY2 CDARLOOKAT OP2FLG T)))
              (SETQ RESULTQ (CDR RESULTQ))
              (COND
                (RESULTQ
                  (SELECTQ
                    OPFLG
                    [(!! !)
                      (COND
                        [CDRLOOKAT (COND
                                     ((AND CARSAFEFLAG (EQ WORKFLAG
                                                           (QUOTE APPEND)))

          (* APPEND is the only non-destructive function which has 
          OPFLG = '! when CDRLOOKAT is non-nil.
          By convention, brackets are never removed from RESULTQ when 
          OPFLG = '!!, nor are they ever removed when RESULTQ is 
          "unsafe" (e.g. when RESULTQ contains '!! at its top level) 
          and CDRLOOKAT is non-nil; CARSAFEFLAG is nil if RESULTQ is 
          unsafe. This accounts for the optimizations described in 
          paragraphs #1,2,3 of my memo on SHRKFY.)


                                       (SETQQ OP3FLG OFFANGLES))
                                     (T (SETQQ OP3FLG OPANGLE]
                        (T

          (* CDRLOOKAT is nil, so CARLOOKAT is the last argument of 
          the form we are emulating. It may also be the first, which 
          we can detect if FIRSTARGFLG is T, in which case we are 
          emulating a singleton.)


                          (SELECTQ
                            WORKFLAG
                            (APPEND (SELECTQ OP2FLG
                                             [(CONS NCONC NCONC1 LIST /NCONC 
                                                    /NCONC1)
                                               (COND
                                                 (FIRSTARGFLG 

          (* Since CDRLOOKAT is nil and FIRSTARGFLG is T, LOOKAT is a 
          singleton and we are emulating an APPEND singleton.
          So brackets are not removed.)


                                                              (SETQQ OP3FLG 
                                                                    OPANGLE))
                                                 ((OR (EQ OP2FLG (QUOTE LIST))
                                                      (EQ OP2FLG (QUOTE CONS)))

          (* Otherwise, if CARLOOKAT is a LIST or CONS form, brackets 
          can be removed, according to paragraph #4 of the memo on 
          SHRKFY optimizations.)


                                                   (SETQQ OP3FLG OFFANGLES))
                                                 (T 
                                                (* Otherwise brackets stay in.)
                                                    (SETQQ OP3FLG OPANGLE]
                                             [APPEND 

          (* This branch accounts for the optimzations described in 
          paragraph #5 of the memo on SHRKFY.)


                                                     (COND
                                                       ((OR FIRSTARGFLG 
                                                            APPSINGFLG)

          (* If CARLOOKAT is an append singleton then brackets are not 
          removed, because it is the last argument of the APPEND form 
          we are emulating. Or if FIRSTARGFLG is T, then since 
          CDRLOOKAT is nil, we must be inside an append singleton, of 
          which CARLOOKAT is the only argument, so brackets are not 
          removed.)


                                                         (SETQQ OP3FLG OPANGLE))
                                                       (T (SETQQ OP3FLG 
                                                                 OFFANGLES]
                                             NIL))
                            (CONS               (* See paragraph #6 of the memo 
                                                on SHRKFY.)
                                  (SELECTQ OP2FLG
                                           ((NCONC NCONC1 /NCONC /NCONC1)
                                             (SETQQ OP3FLG OPANGLE))
                                           ((CONS LIST)
                                             (SETQQ OP3FLG OFFANGLES))
                                           [APPEND (COND
                                                     (APPSINGFLG (SETQQ OP3FLG 
                                                                    OPANGLE))
                                                     (T (SETQQ OP3FLG OFFANGLES]
                                           NIL))
                            ((NCONC /NCONC)     (* See paragraph #7 of the memo 
                                                on SHRKFY.)
                              (SELECTQ OP2FLG
                                       [(LIST APPEND CONS)
                                         (COND
                                           (FIRSTARGFLG 
                                                (* We're emulating an NCONC 
                                                singleton.)
                                                        (SETQQ OP3FLG OPANGLE))
                                           (CDDARLOOKAT 
                                                (* These cases all dwimify back 
                                                correctly.)
                                                        (SETQQ OP3FLG OFFANGLES)
                                                        )
                                           (T (SETQQ OP3FLG OPANGLE]
                                       ((NCONC NCONC1 /NCONC /NCONC1)
                                         (SETQQ OP3FLG OPANGLE))
                                       NIL))
                            ((NCONC1 /NCONC1)

          (* There's no need to concern ourselves about bracket 
          removal here. Since CDRLOOKAT is NIL, and OPFLG = '! or '!!, 
          and WORKFLAG = 'NCONC1 or '/NCONC1, OPFLG must eq '!! 
          (and FIRSTARGFLG must eq T, but we don't need to check for 
          it), because NCONC1 never setq's OPFLG to '!.)


                              (SETQQ OP3FLG OPANGLE))
                            NIL]
                    [LISTIT                     (* Brackets can't be removed.)
                            (NCONC RESULTP (LIST (QUOTE <))
                                   RESULTQ
                                   (LIST (QUOTE >]
                    NIL))
                (T 

          (* RESULTQ has been pseudo-evaluated to NIL, so it 
          disappears from or remains in RESULTP according to the rules 
          desccribed in paragraphs #8 through #13 of the memo on 
          SHRKFY.)


                   (SELECTQ OPFLG
                            ((!! !)
                              (SELECTQ OP2FLG
                                       [(APPEND NCONC LIST /NCONC)
                                         (COND
                                           ((AND FIRSTARGFLG
                                                 (NULL (CDR CDRLOOKAT))
                                                 CDRLOOKAT)
                                             (NCONC RESULTP (LIST OPFLG NIL]
                                       [(CONS NCONC1 /NCONC1)
                                         (NCONC RESULTP (LIST OPFLG
                                                              (QUOTE <)
                                                              NIL
                                                              (QUOTE >]
                                       NIL))
                            (LISTIT (SELECTQ OP2FLG
                                             ((APPEND NCONC LIST /NCONC)
                                               (NCONC1 RESULTP NIL))
                                             [(CONS NCONC1 /NCONC1)
                                               (NCONC RESULTP
                                                      (LIST (QUOTE <)
                                                            NIL
                                                            (QUOTE >]
                                             NIL))
                            NIL]
            NIL)
      A5  

          (* Here we add RESULTQ to RESULTP, according to the decision 
          made in the previous major selectq, at A4.)


          (SELECTQ OP3FLG
                   (OFFANGLES (NCONC RESULTP RESULTQ))
                   [OPANGLE (NCONC RESULTP (LIST OPFLG (QUOTE <))
                                   RESULTQ
                                   (LIST (QUOTE >]
                   (CLISPIFY2CIT (SELECTQ OPFLG
                                          [(! !!)
                                            (NCONC RESULTP (LIST OPFLG
                                                                 (CLISPIFY2C
                                                                   CARLOOKAT]
                                          (LISTIT (NCONC1 RESULTP (CLISPIFY2C
                                                            CARLOOKAT)))
                                          NIL))
                   NIL)
          [COND
            (RESULTR 

          (* RESULTR holds SHRKFY's translation of CDRLOOKAT, and of 
          course does not have "implicit angle brackets" around it, so 
          we just add it on to RESULTP.)


                     (NCONC RESULTP RESULTR))
            ((AND FIRSTARGFLG (EQ WORKFLAG (QUOTE NCONC1)))

          (* In this branch, since RESULTR is nil, it has either been 
          pseudo-evaluated to nil or else we've been emulating an 
          NCONC1 singleton. This branch makes sure 
          (NCONC1 A) goes to (<!! A NIL>).)


              (NCONC1 RESULTP NIL))
            ((AND (EQ WORKFLAG (QUOTE APPEND))
                  CDRLOOKAT)

          (* This branch makes sure that CARLOOKAT is copied.
          Since CDRLOOKAT is non nil, but RESULTR is nil, we know that 
          RESULTR has been psuedo-evaluated to nil.
          If (APPEND A B (CONS) NIL (NCONC)) simply went to 
          (<! A ! B >) and dwimified back to 
          (APPEND A B), B would no longer be copied.
          So, for this case alone, we need to add a nil;
          the same problem does not arise within a CONS, LIST, or 
          NCONC form. In fact, not doing anything in these cases 
          allows us to optimize (CONS A (APPEND)) to 
          (LIST A), and (NCONC A B (NCONC)) to 
          (NCONC A B). On the other hand, 
          (LIST A B (NCONC)) naturally goes to 
          (<A B NIL>) and back to (LIST A B NIL).)


              (NCONC RESULTP (LIST (QUOTE !)
                                   NIL]
          (RETURN RESULTP])

(SHRKFY2
  [LAMBDA (LOOKAT WORKFLAG STAGEFLAG)
    (PROG (RESULTP)
          (SETQ RESULTP (LIST (QUOTE TEMPATOM)))
          (SHRKFY LOOKAT WORKFLAG STAGEFLAG)
          (RETURN RESULTP])

(WHILEDOUNTIL
  [LAMBDA (FORM)
    (PROG (PL FX FX1 CONDX TGO TEM WHILE DO UNTIL)

          (* All syntatical patterns of the following format: LABEL 
          (COND (p1 e1...e2 (GO LABEL)) clause1...clause2) will be 
          converted to the form: LABEL (WHILE p1 DO e1...e2 
          (COND clause1...clause2)). In addition, all patterns: LABEL 
          e1...e2 (COND (p1 (GO LABEL)) clause1...clause2) will be 
          converted to the form: LABEL (DO e1...e2 UNTIL 
          (NOT p1)) (COND clause1...clause2). This function is invoked 
          by CLISPIFY2B during CLISPIFY processing of a PROG.)


          (SETQ FX FORM)
      TOP (COND
	    ((NULL FX)
	      (RETURN FORM))
	    ((NOT (ATOM (CAR FX)))
	      (SETQ FX (CDR FX))
	      (GO TOP)))

          (* At this point a prog label has been detected and CADR of 
          FX is a list. A test will now be made to determine if is an 
          appropriate COND expression)


          (SETQ PL (CAR FX))
          (SETQ FX1 FX)
          (COND
	    [(AND [LISTP (CAR (SETQ FX (CDR FX]
		  (EQ (CAR (SETQ CONDX (CAR FX)))
		      (QUOTE COND))
		  (EQ [CAAR (SETQ TGO (LAST (CADR CONDX]
		      (QUOTE GO))
		  (EQ (CADAR TGO)
		      PL)
		  (NULL (EDITFINDP (CADR CONDX)
				   (QUOTE RETURN)
				   T)))
	      (SETQ DO (LDIFF (CDADR CONDX)
			      TGO))

          (* If the COND clause contains a predicate only, the DO 
          expresstion will be omitted.)


	      [SETQ WHILE (CONS (QUOTE WHILE)
				(CONS (CAADR CONDX)
				      (AND DO (CONS (QUOTE DO) DO]

          (* If the COND expression contains only one clause, the COND 
          expression, constructed for the remaining clauses, is 
          omitted.)


	      (SETQ TEM (CONS WHILE (WHILEDO1 (CDDR CONDX]
	    (T (GO TOP)))
          (RETURN (NCONC (LDIFF FORM FX1)
			 (NCONC (CONS PL TEM)
				(WHILEDOUNTIL (CDR FX])

(WHILEDO1
  [LAMBDA (X)
    (COND
      ((NULL X)
        NIL)
      ((AND (NULL (CDR X))
            (EQ (CAAR X)
                T))
        (APPEND (CDAR X)))
      (T (LIST (CONS (QUOTE COND)
                     X])

(CLDISABLE
  [LAMBDA (OP)
    (PROG (TEM FLG)
          [AND (SETQ TEM (SELECTQ OP
				  ((< !)        (* I.S.TYPE for JOIN uses <)
				    (QUOTE join))
				  (+(QUOTE sum))
				  NIL))
	       (SETQ TEM (GETP TEM (QUOTE I.S.TYPE)))
	       (DWIMIFY0 (CAR TEM)
			 NIL
			 (QUOTE ($$VAL BODY]
          [MAPC (QUOTE (CLISPTYPE LISPFN UNARYOP CLISPCLASS CLISPCLASSDEF 
				  CLISPNEG CLISPINFIX BROADSCOPE CLISPFORM 
				  I.S.TYPE CLISPWORD CLMAPS))
		(FUNCTION (LAMBDA (X)
		    (AND (/REMPROP OP X)
			 (SETQ FLG T]
          [MAPC (QUOTE (I.S.OPRLST CLISPFORWORDSPLST CLISPINFIXES))
		(FUNCTION (LAMBDA (X)
		    (/RPLACA X (REMOVE OP (CAR X]
          (COND
	    ((MEMB OP CLISPCHARS)
	      (/RPLACA (QUOTE CLISPCHARS)
		       (REMOVE OP CLISPCHARS))
	      [COND
		((EQ OP (QUOTE -))
		  (CLDISABLE (QUOTE +-)))
		((EQ OP (QUOTE +-))
		  (CLDISABLE (QUOTE -]
	      (/RPLACA (QUOTE CLISPCHARRAY)
		       (MAKEBITTABLE CLISPCHARS))
	      (SETQ FLG T)))
          (RETURN (AND FLG OP])
)
  (RPAQ CLISPFLG T)
  (RPAQ FUNNYATOMLST)
  (RPAQQ I.S.OPRLST
	 (ALWAYS AS BIND BY COLLECT COUNT DO EACHTIME FCOLLECT FINALLY FIND 
		 FIRST FOR FROM IN ISTHERE JOIN NEVER OLD ON SUCHTHAT SUM 
		 THEREIS THRU TO UNLESS UNTIL WHEN WHERE WHILE always as bind 
		 by collect count do eachtime fcollect finally find first for 
		 from in isthere join never old on suchthat sum thereis thru to 
		 unless until when where while))
  (RPAQQ CLISPFORWORDSPLST
	 (WHILE ALWAYS AS BIND BY COLLECT COUNT DO EACHTIME FINALLY FIRST FOR 
		FROM IN JOIN NEVER OLD ON SUCHTHAT SUM THEREIS TO UNLESS UNTIL 
		WHEN WHERE))
  (RPAQQ CLISPIFWORDSPLST (THEN ELSE ELSEIF IF))
  (RPAQQ CLISPTRANFLG CLISP% )
  (RPAQ CLISPIFTRANFLG)
  (RPAQ CLISPRETRANFLG)
  (RPAQ CLREMPARSFLG NIL)
  (RPAQ CL:FLG T)
  (RPAQQ CLISPINFIXES
	 (LT MEMB AND OR GT MEMBER ILESSP IGREATERP LE GE LEQ GEQ EQ NEQ EQP 
	     EQUAL EQUALS NOT FMEMB FGTP LESSP GREATERP -> =>))
  (RPAQQ CAR/CDRSTRING "CAR/CDR")
  (RPAQ CLISPIFYPACKFLG T)
  (RPAQQ CLISPCHARS
	 (^ * / + - = _ : ' ~ +- ~= < > @))
  (RPAQ CLISPCHARRAY (MAKEBITTABLE CLISPCHARS))
  (RPAQQ CLISPRECORDTYPES (RECORD TYPERECORD PROPRECORD HASHLINK ACCESSFN 
				  ACCESSFNS HASHRECORD ATOMRECORD ARRAYRECORD 
				  DATATYPE))
(DEFLIST(QUOTE(
  (^ 6)
  (* 4)
  (/ 4)
  (+ 2)
  (- 7)
  (= -20)
  (_ (8 . -12))
  (: (14 . 13))
  (' 15)
  (~ 7)
  (+- 2)
  (< T)
  (> T)
))(QUOTE CLISPTYPE))
(DEFLIST(QUOTE(
  (^ EXPT)
  (* ITIMES)
  (/ IQUOTIENT)
  (+ IPLUS)
  (- IMINUS)
  (= EQ)
  (_ SETQ)
  (' QUOTE)
  (~ NOT)
  (+- IDIFFERENCE)
))(QUOTE LISPFN))
(DEFLIST(QUOTE(
  (- T)
  (' T)
  (~ T)
  (< T)
))(QUOTE UNARYOP))
(DEFLIST(QUOTE(
  (* *)
  (/ /)
  (+ +)
  (- -)
  (+- +-)
))(QUOTE CLISPCLASS))
(DEFLIST(QUOTE(
  (* (ARITH ITIMES FTIMES TIMES))
  (/ (ARITH IQUOTIENT FQUOTIENT QUOTIENT))
  (+ (ARITH IPLUS FPLUS PLUS))
  (- (ARITH IMINUS FMINUS MINUS))
  (+- (ARITH IDIFFERENCE FDIFFERENCE DIFFERENCE))
))(QUOTE CLISPCLASSDEF))
(DEFLIST(QUOTE(
  (= ~=)
))(QUOTE CLISPNEG))
  (RPAQQ DECLWORDS
	 (STANDARD UNDOABLE INTEGER FAST /NCONC /NCONC1 FLAST FLOATING /RPLACA 
		   MIXED FIXED RPLACA RPLACD /RPLACD FRPLACA FRPLACD NCONC 
		   NCONC1 LAST MEMB FMEMB ASSOC FASSOC MAPCONC /MAPCONC MAPCON 
		   /MAPCON RPLNODE /RPLNODE FRPLNODE RPLNODE2 /RPLNODE2 
		   FRPLNODE2 SETA /SETA PUTHASH /PUTHASH PUT /PUT PUTL /PUTL 
		   NTH FNTH))
(DEFLIST(QUOTE(
  (MEMB -20)
  (FMEMB -20)
))(QUOTE CLISPTYPE))
(DEFLIST(QUOTE(
  (RPLACA RPLACA)
  (RPLACD RPLACD)
  (NCONC NCONC)
  (NCONC1 NCONC1)
  (LAST LAST)
  (MEMB MEMB)
  (ASSOC ASSOC)
  (MAPCONC MAPCONC)
  (MAPCON MAPCON)
  (RPLNODE RPLNODE)
  (RPLNODE2 RPLNODE2)
  (SETA SETA)
  (PUTHASH PUTHASH)
  (PUT PUT)
  (PUTL PUTL)
  (NTH NTH)
))(QUOTE LISPFN))
(DEFLIST(QUOTE(
))(QUOTE UNARYOP))
(DEFLIST(QUOTE(
))(QUOTE CLISPINFIX))
(DEFLIST(QUOTE(
  (STANDARD (ACCESS . 1))
  (UNDOABLE (ACCESS . 2))
  (INTEGER (ARITH . 1))
  (FAST (ACCESS . 3))
  (/NCONC NCONC)
  (/NCONC1 NCONC1)
  (FLAST LAST)
  (FLOATING (ARITH . 2))
  (/RPLACA RPLACA)
  (MIXED (ARITH . 3))
  (FIXED (ARITH . 1))
  (RPLACA RPLACA)
  (RPLACD RPLACD)
  (/RPLACD RPLACD)
  (FRPLACA RPLACA)
  (FRPLACD RPLACD)
  (NCONC NCONC)
  (NCONC1 NCONC1)
  (LAST LAST)
  (MEMB MEMB)
  (FMEMB MEMB)
  (ASSOC ASSOC)
  (FASSOC ASSOC)
  (MAPCONC MAPCONC)
  (/MAPCONC MAPCONC)
  (MAPCON MAPCON)
  (/MAPCON MAPCON)
  (RPLNODE RPLNODE)
  (/RPLNODE RPLNODE)
  (FRPLNODE RPLNODE)
  (RPLNODE2 RPLNODE2)
  (/RPLNODE2 RPLNODE2)
  (FRPLNODE2 RPLNODE2)
  (SETA SETA)
  (/SETA SETA)
  (PUTHASH PUTHASH)
  (/PUTHASH PUTHASH)
  (PUT PUT)
  (/PUT PUT)
  (PUTL PUTL)
  (/PUTL PUTL)
  (NTH NTH)
  (FNTH NTH)
))(QUOTE CLISPCLASS))
(DEFLIST(QUOTE(
  (RPLACA (ACCESS RPLACA /RPLACA FRPLACA))
  (RPLACD (ACCESS RPLACD /RPLACD FRPLACD))
  (NCONC (ACCESS NCONC /NCONC))
  (NCONC1 (ACCESS NCONC1 /NCONC1))
  (LAST (ACCESS LAST NIL FLAST))
  (MEMB (ACCESS MEMB NIL FMEMB))
  (ASSOC (ACCESS ASSOC NIL FASSOC))
  (MAPCONC (ACCESS MAPCONC /MAPCONC))
  (MAPCON (ACCESS MAPCON /MAPCON))
  (RPLNODE (ACCESS RPLNODE /RPLNODE FRPLNODE))
  (RPLNODE2 (ACCESS RPLNODE2 /RPLNODE2 FRPLNODE2))
  (SETA (ACCESS SETA /SETA))
  (PUTHASH (ACCESS PUTHASH /PUTHASH))
  (PUT (ACCESS PUT /PUT))
  (PUTL (ACCESS PUTL /PUTL))
  (NTH (ACCESS NTH NIL FNTH))
))(QUOTE CLISPCLASSDEF))
(DEFLIST(QUOTE(
  (MEMB ~MEMB)
  (FMEMB ~FMEMB)
))(QUOTE CLISPNEG))
(DEFLIST(QUOTE(
  (MEMB T)
  (FMEMB T)
))(QUOTE BROADSCOPE))
  (RPAQQ CLISPWORDS
	 (LS GR LT GT LE GE LEQ GEQ EQ NEQ EQP EQUAL EQUALS NOT AND OR and or 
	     MEMBER SETQ QUOTE CONS IPLUS IMINUS IDIFFERENCE ITIMES IQUOTIENT 
	     ILESSP IGREATERP FPLUS FMINUS FDIFFERENCE FTIMES FQUOTIENT FGTP 
	     PLUS MINUS DIFFERENCE TIMES QUOTIENT LESSP GREATERP EXPT -> =>))
(DEFLIST(QUOTE(
  (LS -20)
  (GR -20)
  (LT -20)
  (GT -20)
  (LE -20)
  (GE -20)
  (LEQ -20)
  (GEQ -20)
  (EQ -20)
  (NEQ -20)
  (EQP -20)
  (EQUAL -20)
  (EQUALS -20)
  (AND -25)
  (OR -26)
  (and -25)
  (or -26)
  (MEMBER -20)
  (CONS -8)
  (ILESSP -20)
  (IGREATERP -20)
  (FGTP -20)
  (MINUS 8)
  (LESSP -20)
  (GREATERP -20)
  (-> 7)
  (=> 7)
))(QUOTE CLISPTYPE))
(DEFLIST(QUOTE(
  (LS ILESSP)
  (GR IGREATERP)
  (LT ILESSP)
  (GT IGREATERP)
  (EQUALS EQUAL)
  (and AND)
  (or OR)
))(QUOTE LISPFN))
(DEFLIST(QUOTE(
  (NOT T)
  (MINUS T)
))(QUOTE UNARYOP))
(DEFLIST(QUOTE(
  (EQ =)
  (EQUAL EQUALS)
  (NOT ~)
  (AND AND)
  (OR OR)
  (SETQ _)
  (QUOTE ')
  (IPLUS +)
  (IMINUS -)
  (IDIFFERENCE +-)
  (ITIMES *)
  (IQUOTIENT /)
  (ILESSP LT)
  (IGREATERP GT)
  (EXPT ^)
))(QUOTE CLISPINFIX))
(DEFLIST(QUOTE(
  (LS LT)
  (GR GT)
  (LT LT)
  (GT GT)
  (IPLUS +)
  (IMINUS -)
  (IDIFFERENCE +-)
  (ITIMES *)
  (IQUOTIENT /)
  (ILESSP LT)
  (IGREATERP GT)
  (FPLUS +)
  (FMINUS -)
  (FDIFFERENCE +-)
  (FTIMES *)
  (FQUOTIENT /)
  (FGTP GT)
  (PLUS +)
  (MINUS -)
  (DIFFERENCE +-)
  (TIMES *)
  (QUOTIENT /)
  (LESSP LT)
  (GREATERP GT)
))(QUOTE CLISPCLASS))
(DEFLIST(QUOTE(
  (LT (ARITH ILESSP LESSP LESSP))
  (GT (ARITH IGREATERP FGTP GREATERP))
))(QUOTE CLISPCLASSDEF))
(DEFLIST(QUOTE(
  (LS GE)
  (GR LE)
  (LT GE)
  (GT LE)
  (EQUALS ~EQUAL)
  (MEMBER ~MEMBER)
))(QUOTE CLISPNEG))
(DEFLIST(QUOTE(
  (LS T)
  (GR T)
  (LT T)
  (GT T)
  (LE T)
  (GE T)
  (LEQ T)
  (GEQ T)
  (EQ T)
  (NEQ T)
  (EQP T)
  (EQUAL T)
  (EQUALS T)
  (NOT T)
  (AND T)
  (OR T)
  (and T)
  (or T)
  (MEMBER T)
  (ILESSP T)
  (IGREATERP T)
  (FGTP T)
  (LESSP T)
  (GREATERP T)
))(QUOTE BROADSCOPE))
(DEFLIST(QUOTE(
  (ELT SETA)
  (SETA (ELT))
))(QUOTE SETFN))
(DEFLIST(QUOTE(
  (ZEROP (EQ * 0))
  (ADD1 (IPLUS * 1))
  (SUB1 (IPLUS * -1))
  (NEQ (NOT (EQ . *)))
))(QUOTE CLISPFORM))
(DEFLIST(QUOTE(
  (~EQUAL NIL)
  (~MEMBER NIL)
  (~MEMB NIL)
))(QUOTE CLISPTYPE))
  (RPAQQ NARGSLST
	 (ATOM ARRAYP FIXP MINUSP FLOATP SMALLP NULL LISTP NUMBERP STRINGP 
	       LITATOM EXPRP FNTYP ZEROP NLISTP CAR CDR RPLACA RPLACD FRPLACA 
	       FRPLACD))
(DEFLIST(QUOTE(
  (ATOM 1)
  (ARRAYP 1)
  (FIXP 1)
  (MINUSP 1)
  (FLOATP 1)
  (SMALLP 1)
  (NULL 1)
  (LISTP 1)
  (NUMBERP 1)
  (STRINGP 1)
  (LITATOM 1)
  (EXPRP 1)
  (FNTYP 1)
  (ZEROP 1)
  (NLISTP 1)
  (CAR 1)
  (CDR 1)
  (RPLACA 2)
  (RPLACD 2)
  (FRPLACA 2)
  (FRPLACD 2)
))(QUOTE NARGS))
(DEFLIST(QUOTE(
  (MAPC (IN . DO))
  (MAP (ON . DO))
  (MAPCAR (IN . COLLECT))
  (MAPLIST (ON . COLLECT))
  (MAPCONC (IN . JOIN))
  (MAPCON (ON . JOIN))
  (SUBSET (in . subset))
))(QUOTE CLMAPS))
(DEFLIST(QUOTE(
  (ALWAYS (FORWORD . always))
  (AS (FORWORD . as))
  (BIND (FORWORD . bind))
  (BY (FORWORD . by))
  (COLLECT (FORWORD . collect))
  (COUNT (FORWORD . count))
  (DO (FORWORD . do))
  (EACHTIME (FORWORD . eachtime))
  (FCOLLECT (FORWORD . fcollect))
  (FINALLY (FORWORD . finally))
  (FIND (FORWORD find FOR))
  (FIRST (FORWORD . first))
  (FOR (FORWORD . for))
  (FROM (FORWORD . from))
  (IN (FORWORD . in))
  (ISTHERE (FORWORD isthere THEREIS))
  (JOIN (FORWORD . join))
  (NEVER (FORWORD . never))
  (OLD (FORWORD . old))
  (ON (FORWORD . on))
  (SUCHTHAT (FORWORD suchthat THEREIS))
  (SUM (FORWORD . sum))
  (THEREIS (FORWORD . thereis))
  (THRU (FORWORD thru TO))
  (TO (FORWORD . to))
  (UNLESS (FORWORD . unless))
  (UNTIL (FORWORD . until))
  (WHEN (FORWORD . when))
  (WHERE (FORWORD where WHEN))
  (WHILE (FORWORD . while))
  (always (FORWORD . always))
  (as (FORWORD . as))
  (bind (FORWORD . bind))
  (by (FORWORD . by))
  (collect (FORWORD . collect))
  (count (FORWORD . count))
  (do (FORWORD . do))
  (eachtime (FORWORD . eachtime))
  (fcollect (FORWORD . fcollect))
  (finally (FORWORD . finally))
  (find (FORWORD find FOR))
  (first (FORWORD . first))
  (for (FORWORD . for))
  (from (FORWORD . from))
  (in (FORWORD . in))
  (isthere (FORWORD isthere THEREIS))
  (join (FORWORD . join))
  (never (FORWORD . never))
  (old (FORWORD . old))
  (on (FORWORD . on))
  (suchthat (FORWORD suchthat THEREIS))
  (sum (FORWORD . sum))
  (thereis (FORWORD . thereis))
  (thru (FORWORD thru TO))
  (to (FORWORD . to))
  (unless (FORWORD . unless))
  (until (FORWORD . until))
  (when (FORWORD . when))
  (where (FORWORD where WHEN))
  (while (FORWORD . while))
))(QUOTE CLISPWORD))
(DEFLIST(QUOTE(
  (IF (IFWORD . if))
  (THEN (IFWORD . then))
  (ELSE (IFWORD . else))
  (ELSEIF (IFWORD . elseif))
  (if (IFWORD . if))
  (then (IFWORD . then))
  (else (IFWORD . else))
  (elseif (IFWORD . elseif))
  (AND T)
  (OR T)
  (and T)
  (or T)
  (! T)
  (!! T)
  (CREATE (RECORDWORD . create))
  (USING (RECORDWORD . using))
  (COPYING (RECORDWORD . copying))
  (FETCH (RECORDWORD . fetch))
  (REPLACE (RECORDWORD . replace))
  (create (RECORDWORD . create))
  (using (RECORDWORD . using))
  (copying (RECORDWORD . copying))
  (fetch (RECORDWORD . fetch))
  (replace (RECORDWORD . replace))
  (with (RECORDWORD . with))
  (of (RECORDWORD . of))
  (WITH (RECORDWORD . with))
  (OF (RECORDWORD . of))
  (CLISP (PREFIXFN . clisp))
  (clisp (PREFIXFN . clisp))
  (MATCH (MATCHWORD . match))
  (match (MATCHWORD . match))
))(QUOTE CLISPWORD))
(DEFLIST(QUOTE(
  (always ((AND (NULL BODY)
		(RETURN NIL))
	   NIL T))
  (collect ((SETQ $$VAL (NCONC1 $$VAL BODY))
	    NIL $$VAL))
  (count ((AND BODY (SETQ $$VAL (ADD1 $$VAL)))
	  0 $$VAL))
  (do (BODY))
  [fcollect ([PROGN (SETQ $$TEM1 BODY)
		    (COND [$$TEM2 (FRPLACD $$TEM2 (SETQ $$TEM2
							(FRPLACD (CONS $$TEM1 
								     $$TEM2]
			  (T (SETQ $$VAL (SETQ $$TEM2 (CONS $$TEM1]
	     NIL $$VAL (BIND ($$TEM1 $$TEM2]
  (join ((SETQ $$VAL (< !! $$VAL !! BODY>))
	 NIL $$VAL))
  (never ((AND BODY (RETURN NIL))
	  NIL T))
  (sum ((SETQ $$VAL ($$VAL + BODY))
	0 $$VAL))
  [thereis ((AND BODY (RETURN I.V.]
))(QUOTE I.S.TYPE))
  [RPAQQ CLISPIFYBLOCKS
	 ((CLISPIFYBLOCK CLISPIFYFNS CLISPIFY CLISPIFY1 CLISPIFY2 CLISPIFY2A 
			 CLISPIFY2B CLISPIFY2C CLISP3 CLISP3A CLISPACKUP 
			 CLISP3B CLISP4 CLISPCOND CLISPCOND1 CLISPAND CLISPAND1 
			 CLISPIFYNOT CLREMPARS CLISPIFYCROPS0 CLISPIFYCROPS 
			 CLISPIFYCROPS1 CLISPIFYRPLAC CLISPIFYMAPS CLMAPS1 
			 CLMAPS2 SHRIEKIFY SHRKFY SHRKFY2 CLISPIFYLOOKUP 
			 CLSTOPSCAN? WHILEDOUNTIL WHILEDO1
			 (ENTRIES CLISPIFYFNS CLISPIFY CLISPACKUP)
			 (SPECVARS EXPR VARS FN DWIMIFYFLG DWIMIFYING 
				   DWIMIFY0CHANGE)
			 (BLKLIBRARY GETP LISPXWATCH)
			 (LOCALFREEVARS DECLST CLTYP0 BROADSCOPE OPR0 LST SEG 
					TAIL FN FORM PARENT SUBPARENT VAR 
					NOVALFLG NEGFLG RESULTP SAFEFLAG VARS)
			 (GLOBALVARS FUNNYATOMLST CAR/CDRSTRING CL:FLG 
				     CLISPIFYSTATS)
			 (RETFNS CLISPIFY2B))
	  (CLISPLOOKUP0 CLISPLOOKUP0 CLISPLOOKUP1 CLISPLOOKUP2 (GLOBALVARS
			  DECLWORDS CLISPRECORDTYPES)
			(LOCALFREEVARS WORD CLASS CLASSDEF VAR1 VAR2)
			(NOLINKFNS RECORDECL))
	  (NIL CLISPDEC CLISPDEC1 (GLOBALVARS CLISPRECORDTYPES DECLWORDS]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
  (BLOCK: CLISPIFYBLOCK CLISPIFYFNS CLISPIFY CLISPIFY1 CLISPIFY2 CLISPIFY2A 
	  CLISPIFY2B CLISPIFY2C CLISP3 CLISP3A CLISPACKUP CLISP3B CLISP4 
	  CLISPCOND CLISPCOND1 CLISPAND CLISPAND1 CLISPIFYNOT CLREMPARS 
	  CLISPIFYCROPS0 CLISPIFYCROPS CLISPIFYCROPS1 CLISPIFYRPLAC 
	  CLISPIFYMAPS CLMAPS1 CLMAPS2 SHRIEKIFY SHRKFY SHRKFY2 CLISPIFYLOOKUP 
	  CLSTOPSCAN? WHILEDOUNTIL WHILEDO1 (ENTRIES CLISPIFYFNS CLISPIFY 
						     CLISPACKUP)
	  (SPECVARS EXPR VARS FN DWIMIFYFLG DWIMIFYING DWIMIFY0CHANGE)
	  (BLKLIBRARY GETP LISPXWATCH)
	  (LOCALFREEVARS DECLST CLTYP0 BROADSCOPE OPR0 LST SEG TAIL FN FORM 
			 PARENT SUBPARENT VAR NOVALFLG NEGFLG RESULTP SAFEFLAG 
			 VARS)
	  (GLOBALVARS FUNNYATOMLST CAR/CDRSTRING CL:FLG CLISPIFYSTATS)
	  (RETFNS CLISPIFY2B))
  (BLOCK: CLISPLOOKUP0 CLISPLOOKUP0 CLISPLOOKUP1 CLISPLOOKUP2 (GLOBALVARS
	    DECLWORDS CLISPRECORDTYPES)
	  (LOCALFREEVARS WORD CLASS CLASSDEF VAR1 VAR2)
	  (NOLINKFNS RECORDECL))
  (BLOCK: NIL CLISPDEC CLISPDEC1 (GLOBALVARS CLISPRECORDTYPES DECLWORDS))
]
  (LOWERCASE T)
[DECLARE: DOEVAL@COMPILE DONTCOPY 
(DEFLIST(QUOTE(
  [GETP (LAMBDA (ATM PROP)
		(AND (LITATOM ATM)
		     (PROG ((Z (CDR ATM)))
			   LOOP
			   [COND ((NLISTP Z)
				  (RETURN NIL))
				 ((EQ (CAR Z)
				      PROP)
				  (RETURN (CADR Z]
			   (SETQ Z (CDDR Z))
			   (GO LOOP]
))(QUOTE BLKLIBRARYDEF))
]
(DEFINEQ

(RECORD
  [NLAMBDA NAME&FIELDS
    (LISPXWATCH RECORDSTATS)
    (PROG (FN)
          (RECORD1 (CONS (STKNAME (SETQ FN (STKNTH -1)))
			 NAME&FIELDS])
)
  [MAPC CLISPRECORDTYPES (FUNCTION (LAMBDA (X)
					   (/MOVD (QUOTE RECORD)
						  X]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA RECORD CLISPIFYFNS)
  (ADDTOVAR NLAML)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (2375 106393 (CLISPIFYFNS 2387 . 2931) (CLISPIFY 2935 . 5800)
(CLISPIFY1 5804 . 9392) (CLISPIFY2 9396 . 9962) (CLISPIFY2A 9966 . 10634)
(CLISPIFY2B 10638 . 21923) (CLISPIFY2C 21927 . 22377) (CLISP3 22381 . 28171)
(CLISP3A 28175 . 28894) (CLISPACKUP 28898 . 35139) (CLISP3B 35143 . 35938)
(CLISP4 35942 . 37499) (CLISPCOND 37503 . 38740) (CLISPCOND1 38744 . 39944)
(CLISPAND 39948 . 40669) (CLISPAND1 40673 . 41512) (CLISPIFYNOT 41516 . 42122)
(CLREMPARS 42126 . 42380) (CLISPIFYCROPS0 42384 . 42680) (CLISPIFYCROPS 42684
. 47240) (CLISPIFYCROPS1 47244 . 49100) (CLISPIFYRPLAC 49104 . 52917) (
CLISPIFYMAPS 52921 . 53996) (CLMAPS1 54000 . 54440) (CLMAPS2 54444 . 57164)
(CLISPDEC 57168 . 60099) (CLISPDEC0 60103 . 60294) (CLISPDEC1 60298 . 61556)
(EXPRCHECK 61560 . 62257) (CLSTOPSCAN? 62261 . 62899) (CLISPIFYLOOKUP 62903
. 64521) (CLISPLOOKUP0 64525 . 66733) (CLISPLOOKUP1 66737 . 69252) (CLISPLOOKUP2
69256 . 69517) (LOWERCASE 69521 . 70418) (SHRIEKIFY 70422 . 71329) (SHRKFY
71333 . 102995) (SHRKFY2 102999 . 103192) (WHILEDOUNTIL 103196 . 105126) (
WHILEDO1 105130 . 105360) (CLDISABLE 105364 . 106390)) (119849 120018 (RECORD
119861 . 120015)))))
STOP
