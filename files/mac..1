(FILECREATED "11-OCT-74 18:29:47" MAC.;1 66330  

     changes to:  MACFNS

     previous date: " 7-OCT-74 20:04:21" <NEWLISP>MAC.;4)


  (LISPXPRINT (QUOTE MACCOMS)
	      T T)
  [RPAQQ
    MACCOMS
    ((FNS * MACFNS)
     (BLOCKS * MACBLOCKS)
     (PROP MACRO FCHARACTER)
     (P (MOVD (QUOTE CHARACTER)
	      (QUOTE FCHARACTER))
	(SETQ FCHARAR (ARRAY 128))
	(PROG ((I 1))
	      $$$LP
	      [COND ((IGREATERP I 128)
		     (RETURN))
		    (T (SETA FCHARAR I (CHARACTER (SUB1 I]
	      (SETQ I (ADD1 I))
	      (GO $$$LP)))
     [VARS
       (USERFORKLST)
       (CFORKTIME (CLOCK 3))
       (USERFORKS (HARRAY 29))
       (MACSCRATCHSTRING
	 (QUOTE
	   

"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
	   ))
       (SUBSYSSPELLINGS (QUOTE (LISPX EXEC MACRO SRCCOM TECO SNDMSG 
				      LISP DELVER TELNET FTP NETSTAT 
				      READMAIL CALENDAR HOSTAT RSEXEC 
				      FAIL]
     (E (RADIX 10]
  (RPAQQ MACFNS
	 (DCHCON DUNPACK SORT SORT1 ALPHORDER MERGE SUBSYS CFORK 
		 GCFORKS KFORK KFORK1 RFSTS GEVEC GPJFN GTJFN RLJFN 
		 FILDIR GNJFN JFNS DELFILE RENAMEFILE FILEPOS 
		 PAGEFAULTS LOADAV GETAB SIXBIT GETER ERSTR IDATE 
		 USERNUMBER USERNAME STRCONC0 RPLSTR0 SETSTRBUF RAND 
		 RANDSET))
(DEFINEQ

(DCHCON
  [LAMBDA (X SCRATCHLIST FLG RDTBL)             (* E (AND (OPENP) 
                                                (RADIX 10Q)))

          (* Destructive CHCON. Returns value equal to value 
          of (CHCON X FLG) but uses conses from SCRATCHLIST.
          Communicates internally by global variable DCHCONGV.
          Does not erode SCRATCHLIST, i.e. conses not lost.
          If SCRATCHLIST not long enough returns a real CHCON.
          Works for all data-types.)


    (PROG (X1 X2 X3)
          (ASSEMBLE NIL
		    [CQ
		      (SETQ DCHCONGV
			(OR
			  (LISTP SCRATCHLIST)
			  (ERROR (QUOTE 
				   "DCHCON: SCRATCHLIST not a list")
				 SCRATCHLIST]
		    (LDV2 (QUOTE FLG)
			  SP 3)
		    (MOVEI 2 , DCHCONSUBROUTINE)
		    (CQ X)
		    (CAME 3 , KNIL)
		    (JRST USEPRIN2)
		    (FASTCALL IPRE)
		    (JRST DONE)
		USEPRIN2
		    (VAR (HRRZ 3 , RDTBL))
		    (FASTCALL IPRE2)
		DONE[CQ
		      (RETURN
			(COND
			  ((NLISTP (SETQ X1 DCHCONGV))
                                                (* SCRATCHLIST was not 
                                                long enough. Pass the 
                                                buck to a real CHCON)
			    (CHCON X FLG))
			  ((EQ X1 SCRATCHLIST)

          (* In the case where X is a NULL string and FLG is 
          NIL, 0 chars get written out and X1 is EQ to 
          SCRATCHLIST. This causes the code in the last 
          condclause to circularize SCRATCHLIST, which can be 
          generally regarded as a BAD THING.
          So check, and return NIL.)


			    NIL)
			  ((NLISTP (SETQ X2 (CDR X1)))
                                                (* SCRATCHLIST was just 
                                                long enough. No 
                                                cons-scrambling to do.)
			    (CDR SCRATCHLIST))
			  (T

          (* The usual exit case: there were some conses left 
          over at the end of SCRATCHLIST.
          splice them in between the first and second CONS -- 
          this is the reason for never using the first CONS -- 
          and return what used to be the second CONS.
          All the frplacs are into values which have been 
          tested LISTP, except the value of FLAST, so check 
          that.)


			    (SETQ X3 (CDR SCRATCHLIST))
			    (FRPLACD X1 NIL)
			    (FRPLACD SCRATCHLIST X2)
			    (SETQ X2 (FLAST X2))
			    (COND
			      ((LISTP X2)
				(FRPLACD X2 X3))
			      (T
				(ERROR
				  (QUOTE
				    
			    "DCHCON - Unusual CDR on SCRATCHLIST: ")
				  X2)))
			    X3]
		DCHCONSUBROUTINE
		    (PUSHN)
		    (CQ (CDR DCHCONGV))
		    (STE (QUOTE LISTT))
		    (JRST FRETURN)
		    (NREF (EXCH 2 , 0))
		    (ADDI 2 , ASZ)
		    (HRRM 2 , 0 (1))
		    (MOV21)
		EXIT(CQ (QUOTE DCHCONGV))
		    (HRRM 2 , 0 (1))
		    (POPN 2)
		    (RET)

          (* When you run out of conses on SCRATCHLIST, 
          DCHCONGV becomes NLISTP. Would like to just return a 
          real CHCON at that point but there is no clean way 
          to do equivalent of RETFROM from internal routines 
          (IPRE). So instead just keep doing NOP'S for each 
          character until IPRE unwinds.)


		FRETURN
		    (MOVE 2 , KNIL)
		    (JRST EXIT])

(DUNPACK
  [LAMBDA (X SCRATCHLIST FLG RDTBL)             (* Like DCHCON but 
                                                returns UNPACK instead 
                                                of CHCON.)
    [MAP (SETQ SCRATCHLIST (DCHCON X SCRATCHLIST FLG RDTBL))
	 (FUNCTION (LAMBDA (TAIL)
	     (FRPLACA TAIL (FCHARACTER (CAR TAIL]
    SCRATCHLIST])

(SORT
  [LAMBDA (DATA COMPAREFN)
    (COND
      [(NLISTP DATA)
	(COND
	  (DATA (ERROR (QUOTE "DATA NOT LIST:")
		       DATA]
      (T (OR COMPAREFN (SETQ COMPAREFN (FUNCTION ALPHORDER)))
	 (FRPLACD (LAST DATA)
		  NIL)
	 (SORT1 DATA])

(SORT1
  [LAMBDA (DATA END)
    (COND
      ((OR (EQ DATA END)
	   (EQ (CDR DATA)
	       END))
	DATA)
      (T (PROG ((LIS DATA)
		(ALT DATA)
		TEM)

          (* Split DATA by setting ALT to one cell before its 
          midpoint. DATA remains EQ to the original list.)


	   LP  (COND
		 ((AND (NEQ (SETQ LIS (CDR LIS))
			    END)
		       (NEQ (SETQ LIS (CDR LIS))
			    END))
		   (SETQ ALT (CDR ALT))
		   (GO LP)))
	       (SETQ TEM (SORT1 DATA (CDR ALT)))
	       (SORT1 (SETQ LIS (CDR ALT))
		      END)

          (* Merge DATA thru ALT with LIS 
          (= (CDR ALT)) up to END. This is a little tricky 
          because DATA must remain EQ to its original value.)


	   ALP (COND
		 ((EQ TEM LIS)                  (* Exhausted first 
                                                list.)
		   (RETURN DATA)))
	   BLP (COND
		 ((SELECTQ COMPAREFN
			   (T (ALPHORDER (CAAR TEM)
					 (CAAR LIS)))
			   (APPLY* COMPAREFN (CAR TEM)
				   (CAR LIS)))
		   (SETQ TEM (CDR TEM))
		   (GO ALP)))

          (* Move first element of second list 
          (LIS = (CDR ALT)) to before first element of first 
          list (TEM). This must be done by exchanging the CARs 
          and then patching up the CDRs, to retain the EQ 
          property. This is a 'critical section' in that data 
          will be lost if a hard interrupt occurs, but it 
          cannot be interrupted by ^H because it does no 
          function calls.)


	       [COND
		 [(EQ TEM ALT)                  (* Special case.)
		   [FRPLACA TEM (PROG1 (CAR LIS)
				       (FRPLACA LIS (CAR TEM]
		   (SETQ LIS (CDR (SETQ TEM (SETQ ALT LIS]
		 (T [FRPLACD ALT (PROG1 (CDR LIS)
					(FRPLACA TEM
						 (PROG1 (CAR LIS)
							(FRPLNODE2
							  LIS TEM)
							(FRPLACD TEM 
								LIS]
		    (SETQ TEM LIS)
		    (SETQ LIS (CDR ALT]
	       (COND
		 ((NEQ LIS END)
		   (GO BLP)))                   (* Exhausted second 
                                                list.)
	       (RETURN DATA])

(ALPHORDER
  [LAMBDA (A B)

          (* ALPHORDER compares two items from a list being 
          sorted, returns T if they are in order, i.e. if it 
          is ok to place A before B in the final list.
          Order of precedence is numbers, literals, and 
          everything else. Numbers are sorted by size;
          literals (strings, atoms and pnames) are sorted 
          character by character by the magnitude of the 
          character code (straight alphabetization is a subset 
          of this) and other types are not sorted among 
          themselves.)


    (PROG ((TB (NTYP B)))
          (SELECTQ (NTYP A)
		   (24Q (ASSEMBLE NIL           (* A is SMALLP)
			          (CQ A)
			          (SUBI 1 , ASZ))
                                                (* Fast unbox for small 
                                                numbers.)
			(GO UNBOXEDINT))
		   (22Q (ASSEMBLE NIL
			          (CQ A)
			          (MOVE 1 , 0 (1))
                                                (* Fast unbox for large 
                                                numbers.)
			      )                 (* A is integer)
			(GO UNBOXEDINT))
		   [20Q                         (* A is floating)
			(SELECTQ TB
				 [20Q           (* Both floating.
                                                Do open FGREATERP.)
				      (ASSEMBLE NIL
					        (CQ B)
					        (MOVE 2 , 0 (1))
                                                (* Fast unbox but into 
                                                floating format.)
					        (CQ A)
					        (CAMGE 2 , 0 (1))
					        (SKIPA 1 , KNIL)
					        (CQ T)
					        (CQ (RETURN (AC]
				 (24Q (ASSEMBLE NIL
					        (CQ B)
					        (SUBI 1 , ASZ)))
				 [22Q (ASSEMBLE NIL
					        (CQ B)
					        (MOVE 1 , 0 (1]
				 (RETURN T))    (* Return T for A 
                                                floating, B 
                                                non-numeric.)
			(ASSEMBLE NIL
			          (FASTCALL FXFLT)
                                                (* Unboxed (integer) B 
                                                in ac1. FLOAT it and 
                                                compare to A.)
			          (LDV2 (QUOTE A)
					SP 2)
			          (CAMGE 1 , 0 (2))
			          (SKIPA 1 , KNIL)
			          (CQ T)
			          (CQ (RETURN (AC]
		   (14Q (ASSEMBLE NIL           (* A is LITATOM)
			          (CQ A)
			          (HLRZ 1 , 2 (1)))
			(GO LIT))
		   ((30Q 34Q)                   (* A is string or pname)
		     (ASSEMBLE NIL
			       (CQ A))
		     (GO LIT))
		   (SELECTQ TB
			    ((34Q 30Q 14Q 24Q 22Q 20Q)

          (* A is list, ARRAY or junk;
          B is something legal so it belongs first.)


			      (RETURN NIL))
			    (RETURN T)))        (* Both junk;
                                                return T.)
      UNBOXEDINT
          [ASSEMBLE NIL                         (* Unboxed integer A in 
                                                ac1. Stack it.)
		    (PUSHN)
		    (CQ (SELECTQ TB
				 (24Q (ASSEMBLE NIL
					        (CQ B)
					        (SUBI 1 , ASZ)))
				 [22Q (ASSEMBLE NIL
					        (CQ B)
					        (MOVE 1 , 0 (1]
				 [20Q (ASSEMBLE NIL
					        (NREF (MOVE 1 , 0))
					        (FASTCALL FXFLT)

          (* A integral, B floating. float unboxed A on stack 
          and load ac1 with unboxed B.)


					        (NREF (MOVEM 1 , 0))
					        (CQ B)
					        (MOVE 1 , 0 (1]
				 (RETURN T)))   (* A numeric, B not.)
		    (NREF (CAMGE 1 , 0))

          (* Compare two unboxed numbers.
          Fixed or floating doesn't matter as long as both the 
          same.)


		    (SKIPA 1 , KNIL)
		    (CQ T)
		    (POPNN 1)
		    (CQ (RETURN (AC]
      LIT (ASSEMBLE NIL
		    (FASTCALL UPATM)

          (* Ac3 has byte ptr to A; ac4 has NCHARS.
          Notice use of CP here.)


		    (PUSH CP , 3)
		    (PUSHN 4)
		    [CQ (SELECTQ TB
				 ((24Q 22Q 20Q)
				   (ASSEMBLE NIL
					     (POP CP , 1))
                                                (* A was literal, B 
                                                numeric.)
				   (RETURN))
				 ((30Q 34Q)
				   (ASSEMBLE NIL
					     (CQ B)))
				 [14Q (ASSEMBLE NIL
					        (CQ B)
					        (HLRZ 1 , 2 (1]
				 (ASSEMBLE NIL
				           (POP CP , 1)
                                                (* A was literal, B was 
                                                list or junk.)
				           (CQ (RETURN T]

          (* At last the basic alphabetizer.
          Ac6 has NCHARS A; ac5 has byte pointer to A;
          ac4 has NCHARS B (from this call to UPATM), ac3 has 
          byte pointer to B.)


		    (FASTCALL UPATM)
		    (POP CP , 5)
		    (POPN 6)
		LP  (SOJL 6 , SUCCEED)          (* A won because 
                                                shorter)
		    (SOJL 4 , FAIL)             (* B won because 
                                                shorter.)
		    (ILDB 1 , 5)
		    (ILDB 2 , 3)
		    (CAMN 1 , 2)
		    (JRST LP)                   (* Chars the same, try 
                                                again.)
		    (CAML 1 , 2)

          (* A and B have different spellings.
          Compare magnitude of character byte and exit with 
          result.)


		FAIL(SKIPA 1 , KNIL)
		SUCCEED
		    (CQ T)
		    (CQ (RETURN (AC])

(MERGE
  [LAMBDA (A B COMPAREFN)
    (PROG ((CFN (OR COMPAREFN (FUNCTION ALPHORDER)))
	   ATAIL BTAIL)
          [COND
	    ((NULL B)                           (* MERGE will work if 
                                                either arg is NIL.)
	      (RETURN A))
	    ((NULL A)
	      (RETURN B))
	    ((NLISTP B)                         (* No possible meaning 
                                                here; user must be in 
                                                error.)
	      (ERROR (QUOTE "ARG NOT LIST:")
		     B))
	    ((NLISTP A)
	      (ERROR (QUOTE "ARG NOT LIST:")
		     A))
	    ([NOT (SELECTQ CFN
			   (T (ALPHORDER (CAAR A)
					 (CAAR B)))
			   (APPLY* CFN (CAR A)
				   (CAR B]

          (* (CAR A) must be before (CAR B) at LOOP 
          (see comment below). If not, swap A and B.
          -
          The SELECTQ compares the next things on A and B.)


	      (SETQ A (PROG1 B (SETQ B A]
          (SETQ ATAIL A)

          (* It is desireable to make the value of the merged 
          list available to the user not only as the return 
          from MERGE, but also on both the CONSES given as 
          arguments. To this end, the MERGE is actually 
          performed on the lists A and 
          (CONS (CAR B) (CDR B)), so that when we return, the 
          original B may be smashed with 
          (CAR A) and (CDR A).)


          (SETQ BTAIL (CONS (CAR B)
			    (CDR B)))

          (* Whenever we pass LOOP, we know that ATAIL is 
          LISTP, BTAIL is LISTP, and 
          (CAR ATAIL) belongs before 
          (CAR BTAIL). We therefore look to see if there is 
          anything more on ATAIL; if not, tie on BTAIL and 
          return. Otherwise, compare 
          (CADR ATAIL) to (CAR BTAIL). If ATAIL wins, just 
          take one CDR and go around.
          But if BTAIL wins, then we swap variable/structures: 
          ATAIL is rplacd'd to the structure that was on 
          BTAIL, and BTAIL is bound to the old CDR of ATAIL.
          We then take the CDR and go around.
          Observe that this swapping preserves the assumptions 
          made at LOOP.)


      LOOP[COND
	    [(NLISTP (CDR ATAIL))
	      (FRPLACD ATAIL BTAIL)
	      (RETURN (FRPLACA (FRPLACD B (CDR A))
			       (CAR A]
	    [(SELECTQ CFN
		      (T (ALPHORDER (CAADR ATAIL)
				    (CAAR BTAIL)))
		      (APPLY* CFN (CADR ATAIL)
			      (CAR BTAIL]
	    (T (FRPLACD ATAIL (PROG1 BTAIL (SETQ BTAIL (CDR ATAIL]
          (SETQ ATAIL (CDR ATAIL))
          (GO LOOP])

(SUBSYS
  [LAMBDA (FILE/FORK INCOMFILE OUTCOMFILE ENTRYPOINTFLG)
    (PROG (FORK TTYMODE SAVEJFN IJFN OJFN ICLOSE OCLOSE STARTADR TEMP)
      TOP [SETQ SAVEJFN
	    (COND
	      ((EQ FILE/FORK T)                 (* Continue last FORK.)
		(SETQ FILE/FORK LASTSUBSYS)
		(SETQQ ENTRYPOINTFLG CONTINUE)
		(GO TOP))
	      ([AND (FIXP FILE/FORK)
		    (IGREATERP FILE/FORK 400000Q)
		    (ILESSP FILE/FORK 400035Q)
		    (EQ FILE/FORK (ELTD USERFORKS (IDIFFERENCE 
							  FILE/FORK 
							    400000Q]
                                                (* User restarting old 
                                                one.)
		(SETQ FORK FILE/FORK)
		(SETQ TEMP (RFSTS FORK))
		(COND
		  ((OR (NULL TEMP)
		       (EQ (CAR TEMP)
			   -1))                 (* FORK mysteriously 
                                                died (like there was a 
                                                SYSOUT overnite.))
		    (KFORK FORK)
		    (ERROR (QUOTE "ILLEGAL FORK:")
			   FORK)))
		(SETQ STARTADR
		  (SELECTQ
		    ENTRYPOINTFLG
		    ((NIL CONTINUE)
		      (CADDR TEMP))
		    (START (GEVEC FORK))
		    (REENTER (ADD1 (GEVEC FORK)))
		    (ERROR
		      (QUOTE
			

"SUBSYS - ENTRYPOINTFLG NOT ONE OF START, REENTER, CONTINUE OR NIL:")
		      ENTRYPOINTFLG)))
		(GO MIDDLE))
	      ((OR (NULL FILE/FORK)
		   (EQ FILE/FORK (QUOTE EXEC)))
		(GTJFN (QUOTE <SYSTEM>EXEC.SAV)
		       NIL NIL 100000Q))
	      ((GTJFN FILE/FORK (QUOTE .SAV)
		      NIL 100000Q))
	      ((GTJFN (PACK (LIST (QUOTE <SUBSYS>)
				  FILE/FORK
				  (QUOTE .SAV)))
		      NIL NIL 100000Q))
	      ((AND (SETQ SAVEJFN (FIXSPELL FILE/FORK 74Q 
					    SUBSYSSPELLINGS))
		    (NEQ FILE/FORK SAVEJFN))
		(SETQ FILE/FORK SAVEJFN)
		(GO TOP))
	      (T (ERROR (QUOTE "SUBSYS - BAD FILE/FORK")
			FILE/FORK]
          (SETQ FORK (CFORK))
          (ASSEMBLE NIL
		    (CQ (VAG FORK))
		    (PUSHN)
		    (CQ (VAG SAVEJFN))
		    (POPN 2)
		    (HRLM 2 , 1)                (* JSYS GET, takes 
                                                fork,,jfn in ac1.)
		    (JSYS 200Q))
          (SETQ STARTADR (GEVEC FORK))
      MIDDLE
          [SETQ IJFN (COND
	      ((NULL INCOMFILE)
		(CAR (GPJFN)))
	      [(STRINGP INCOMFILE)

          (* INCOMFILE is a command string.
          Set up a temporary file, print the string on it with 
          PRIN1, close; then open for input and return jfn.)


		[SETQ IJFN (OUTPUT (OUTFILE (QUOTE 
					      SUBSYS.INCOMFILE;-1;T]
                                                (* Next higher version, 
                                                temporary.)
		(PRIN1 INCOMFILE IJFN)
		(OPNJFN (SETQ ICLOSE (INPUT (INFILE (CLOSEF IJFN]
	      ((OPENP INCOMFILE (QUOTE INPUT))
		(OPNJFN (SETQ ICLOSE INCOMFILE)))
	      ((INFILEP INCOMFILE)
		(INPUT (INFILE INCOMFILE))
		(OPNJFN (SETQ ICLOSE INCOMFILE)))
	      (T (ERROR (QUOTE "SUBSYS - BAD INCOMFILE:")
			INCOMFILE]
          [SETQ OJFN (COND
	      ((NULL OUTCOMFILE)
		(CDR (GPJFN)))
	      ((OPENP OUTCOMFILE (QUOTE OUTPUT))
		(OPNJFN (SETQ OCLOSE OUTCOMFILE)))
	      ((OUTFILEP OUTCOMFILE)
		(OUTPUT (OUTFILE OUTCOMFILE))
		(OPNJFN (SETQ OCLOSE OUTCOMFILE)))
	      (T (ERROR (QUOTE "SUBSYS - BAD OUTCOMFILE:")
			OUTCOMFILE]
          (ASSEMBLE NIL
		    (MOVEI 1 , 101Q)
		    (JSYS 107Q)

          (* RFMOD. Jfn for tty in 1, mode bits returned in 2, 
          save on TTYMODE so can restore after lower FORK 
          run.)


		    (MOVE 1 , 2)
		    (FASTCALL MKN)
		    (SETQ TTYMODE)
		    (MOVE 7 , CTCTP)
		T1  (HLRZ 1 , 0 (7))
		    (TRNN 1 , 400000Q)          (* Skip if not 
                                                assigned.)
		    (JSYS 140Q)

          (* JSYS DTI. Deassigns Terminal Interrupt code.
          Stepping thru the Lisp interrupt table pointed to by 
          CTCTP (which stands for Channel Table ConTrol 
          Pointer or something like that and just contains 
          pointer to CHNTAB). Effect is to turn off all 
          Lisp-activated interrupts I think.)


		    (AOBJN 7 , T1)              (* Done turning 
                                                interrupts off;
                                                set up primary JFNS.)
		    (CQ (VAG OJFN))
		    (PUSHN)
		    (CQ (VAG IJFN))
		    (NREF (HRLM 1 , 0))
		    (CQ (VAG FORK))
		    (POPN 2)
		    (JSYS 207Q)                 (* SPJFN. Fork handle in
                                                ac1, IJFN,,OJFN in AC2.)
                                                (* Now start FORK at 
                                                STARTADR.)
		    (PUSHN)
		    (CQ (VAG STARTADR))
		    (MOVE 2 , 1)
		    (POPN)
		    (JSYS 157Q)                 (* SFORK)
		    (JSYS 163Q)

          (* WFORK. Causes LISP to wait until lower FORK 
          terminates. Takes forkhandle in ac1.)


		    (CQ (VAG TTYMODE))          (* Restore tty mode.)
		    (MOVE 2 , 1)
		    (MOVEI 1 , 101Q)
		    (JSYS 110Q)                 (* SFMOD.)
		    (PUSHJ CP , SETINT)
		    (PUSHJ CP , SETMOD)

          (* Both sfmod and SETMOD are necessary: SETMOD does 
          an sfcoc, and a sfmod as well, but doesn't reset all 
          bits.)


		)
          (AND ICLOSE (CLOSEF ICLOSE))
          (AND OCLOSE (CLOSEF OCLOSE))
          (TERPRI T)

          (* In case lower fork left us in the middle of a 
          line, e.g. SNDMSG)


          (RETURN (SAVESET (QUOTE LASTSUBSYS)
			   FORK NIL (QUOTE NOPRINT])

(CFORK
  [LAMBDA NIL
    (PROG (HANDLE REL)
          (AND USERFORKLST [NOT (EQP CFORKTIME (SETQ CFORKTIME
				       (CLOCK 3]
	       (GCFORKS))

          (* A gc has occurred since last call to CFORK, so 
          there may be some forks to collect.)


          (SETQ HANDLE
	    (LOC (ASSEMBLE NIL
		           (HRLZI 1 , 200000Q)
		           (JSYS 152Q)          (* CFORK. Bit sez pass 
                                                any special capabilities
                                                down.)
		           (SKIPA)
		           (JRST END)
		           (CQ (ERROR (ERSTR (LOC (AC)))
				      (QUOTE "TRY KILLING SOME FORKS."))
			       )
		       END)))
          (SETD USERFORKS (SETQ REL (IDIFFERENCE HANDLE 400000Q))
		HANDLE)
          [SETA USERFORKS REL (CAR (SETQ USERFORKLST
				     (CONS (CONS REL)
					   USERFORKLST]
          (RETURN HANDLE])

(GCFORKS
  [LAMBDA NIL
    (MAPC USERFORKLST (FUNCTION FRPLACD))       (* Clear the marks.)
    [MAPHASH USERFORKS (FUNCTION (LAMBDA (VALUE)
		 (FRPLACD VALUE T]              (* Mark the 'live' 
                                                ones.)
    [MAP USERFORKLST (FUNCTION (LAMBDA (TAIL)
	     (COND
	       ((NULL (CDAR TAIL))              (* Not marked, must be 
                                                dead)
		 (KFORK1 (CAAR TAIL))

          (* Instead of dremoving each guy from the list and 
          probably confusing MAP someday,)


		 (FRPLACA TAIL)                 (* Just replace them 
                                                with NIL's.)
		 ]
    (SETQ USERFORKLST (DREMOVE NIL USERFORKLST))
                                                (* And clear all the 
                                                oils afterward in one 
                                                big DREMOVE.)
    NIL])

(KFORK
  [LAMBDA (FORK)

          (* Two cautions: if FORK is not legally entered in 
          my array and list, do not do a real KFORK since that 
          would allow the experimenters to bomb the forks used 
          by LISP internally, for overlays etc. -
          Secondly always remove forks from the lists because 
          otherwise user has no way to clear them if he should 
          do his own KFORK, or after SYSIN, etc.)


    [COND
      [(EQ FORK T)                              (* Clear all user 
                                                forks.)
	(MAPHASH USERFORKS (FUNCTION (LAMBDA (VALUE ITEM)
		     (KFORK ITEM]
      (T (SETQ USERFORKLST (DREMOVE (KFORK1 FORK)
				    USERFORKLST]
    NIL])

(KFORK1
  [LAMBDA (FORK)

          (* Entry for killing forks without taking them off 
          of USERFORKLST, for GCFORKS' use ONLY, because you 
          can't map that list and DREMOVE guys at the same 
          time.)


    (PROG (V REL)
          (COND
	    ((OR (IGREATERP FORK 400034Q)
		 (ILESSP FORK 400001Q))         (* Range check, don't 
                                                allow 400000Q since that
                                                is 'this fork.')
	      (RETURN)))
          (COND
	    ([EQ FORK (ELTD USERFORKS (SETQ REL (IDIFFERENCE FORK 
							    400000Q]

          (* the EQ check prevents him from making up fork 
          numbers, or holding on to them after KFORK, then 
          killing them again and losing because in meantime 
          they got reassigned to another use.)


	      (ASSEMBLE NIL
		        (CQ (VAG FORK))
		        (PUSHN)
		        (JSYS 156Q)

          (* RFSTS. If FORK not alive, lh1 set to -1 and KFORK 
          will trap.)


		        (HLRE 1 , 1)
		        (JUMPL 1 , END)
		        (POPN)
		        (JSYS 153Q)             (* KFORK)
		    END)))
          (SETQ V (ELT USERFORKS REL))          (* Value of KFORK1 is 
                                                element to DREMOVE from 
                                                USERFORKLST.)
          (CLOSER (IPLUS (LOC USERFORKS)
			 REL 1)
		  0)                            (* Clear the word of 
                                                USERFORKS.)
          (RETURN V])

(RFSTS
  [LAMBDA (FORK)

          (* Returns list of RFSTS info, in form 
          (status channel pc) where status is lh1, channel is 
          rh1, and pc is pc; see JSYS manual.)


    (ASSEMBLE NIL
	      (CQ (VAG (OR FORK 400000Q)))
	      (CAIL 1 , 400000Q)
	      (CAIL 1 , 400035Q)
	      (JRST LOSE)
	      (JSYS 156Q)                       (* RFSTS)
	      (PUSHN)
	      (HLRE 1 , 1)
	      (CAIN 1 , -1)
	      (JRST LOSE)
	      (MOVE 1 , 2)
	      (FASTCALL MKN)
	      [CQ (SETQ FORK (CONS (AC]
	      (NREF (HRRE 1 , 0))
	      (FASTCALL MKN)
	      (CQ (SETQ FORK (CONS (AC)
				   FORK)))
	      (POPN)
	      (HLRE 1 , 1)
	      (FASTCALL MKN)
	      (CQ (CONS (AC)
			FORK))
	      (JRST OUT)
	  LOSE(CQ NIL)
	  OUT])

(GEVEC
  [LAMBDA (FORK)
    (AND (RFSTS FORK)
	 (LOC (ASSEMBLE NIL
		        (CQ (VAG FORK))
		        (JSYS 205Q)             (* GEVEC)
		        (MOVE 1 , 2])

(GPJFN
  [LAMBDA (FORK)
    (ASSEMBLE NIL
	      (CQ (VAG (OR FORK 400000Q)))
	      (JSYS 206Q)
	      (HLRE 1 , 2)
	      (PUSHN)
	      (HRREI 1 , 0 (2))
	      [CQ (SETQ FORK (LOC (AC]
	      (POPN)
	      (CQ (CONS (LOC (AC))
			FORK])

(GTJFN
  [LAMBDA (FILE EXT V FLAGS)

          (* General scheme: create a table on numberstack to 
          use for long GTJFN call. Below table write the 
          strings for the name and extension, converting 
          internal alt-modes to control F'S.)


    [DECLARE
      (COND
	((NULL SPAGHETTIFLG)
	  (DEFLIST
	    [QUOTE
	      ((PUSHNN (NLAMBDA L
			 [MAPC L (FUNCTION (LAMBDA (A)
				   (STORIN (APPEND (QUOTE (PUSH NP ,))
						   A]
			 NIL]
	    (QUOTE AMAC]
    (PROG NIL
          [COND
	    ((EQ 56Q (CHCON1 EXT))

          (* User specified an extension like ".SAV" and the 
          period will cause GTJFN to die.
          Take of the period.)


	      (SETQ EXT (SUBSTRING EXT 2 -1]
          (ASSEMBLE NIL
		    (CQ
		      (SELECTQ
			(NTYP FILE)
			(30Q                    (* STRINGP, nothing to 
                                                do.)
			     FILE)
			[14Q                    (* Atom, get pname)
			     (CDR (VAG (IPLUS 2 (LOC FILE]
			(RETURN)))
		    (PUSH CP , 1)
		    (CQ
		      (SELECTQ
			(NTYP EXT)
			(30Q EXT)
			[14Q (CDR (VAG (IPLUS 2 (LOC EXT]
			(MKSTRING EXT)))
		    (PUSH CP , 1)

          (* First word of table is FLAGS,,VERSION.
          Observe that I do not cover my table, so I am 
          careful not to call VAG and such stuff after I start 
          to build it, since if they did 
          (PUSHN) they would clobber my table.)


		    (CQ (VAG (OR FLAGS 0)))
		    (PUSH CP , 1)
		    (CQ (VAG (OR V 0)))
		    (PUSHNN (1)
			    (= 377777377777Q)
			    (= 0)
			    (= 0)
			    (= 0)
			    (XXXMHC)
			    (XXXMHC)
			    (= 0))              (* NOTE WELL THAT XXXMHC
                                                IS REALLY IOFNMP)
		    (POP CP , 1)
		    (NREF (HRLM 1 , -7))
		    (MOVE 2 , XXXMHC)

          (* 'DEFAULT EXTENSION' word of table.
          We store there a byte pointer to the part of the 
          numberstack immediately below this table.)


		    (POP CP , 1)
		    (PUSHJ CP , SUBROUTINE)
		    (NREF (MOVEM 2 , -1))

          (* This should be zero. I'm using it for a temp, to 
          hold the 'MAIN STRING POINTER', i.e. the pointer to 
          the FILE arg.)


		    (POP CP , 1)
		    (PUSHJ CP , SUBROUTINE)
		    (NREF (SETZB 2 , 0))
		    (NREF (EXCH 2 , -1))        (* See, I told you.)
		    (CQ EXT)

          (* Special case: if EXT was NIL, we have actually 
          given "NIL" for the default extension.
          Remedy situation by zeroing the word of the table, 
          to indicate system default for that field 
          (in the case of the extension, that's no extension.))


		    (CAMN 1 , KNIL)
		    (NREF (SETZM -2))
		    (NREF (MOVEI 1 , -7))
		    (JSYS 20Q)                  (* GTJFN)
		    (SKIPA 1 , KNIL)
		    (PUSHJ CP , MKN)
		    (CQ (RETURN (AC)))
		SUBROUTINE
		    (FASTCALL UPATM)

          (* UPATM takes a string or pname in ac1, preserves 
          acs 1 and 2 and returns a byte pointer in ac3 and a 
          byte count in ac4.)


		SUBROUTINE1
		    (ILDB 1 , 3)
		    (CAIE 4 , 1)
		    (CAIE 1 , 33Q)
		    (SKIPA)                     (* Convert alt-modes to 
                                                control F'S unless last 
                                                char)
		    (HRRZI 1 , 6)
		    (IDPB 1 , 2)
		    (SOJG 4 , SUBROUTINE1)
		    (IDPB 4 , 2)                (* Add NULL byte on end 
                                                to terminate.)
		    (RET])

(RLJFN
  [LAMBDA (JFN)

          (* Releases specified JFN, -1 for all JFN'S which do 
          not specify open files. Returns T on success, NIL if 
          error occurred, and TENEX error diagnostic available 
          by (ERSTR -1))


    (ASSEMBLE NIL
	      (CQ (VAG JFN))
	      (JSYS 23Q)
	      (SKIPA 1 , KNIL)
	      (CQ T])

(FILDIR
  [LAMBDA (FILEGROUP FORMATFLG)
    (PROG ((JFN (GTJFN FILEGROUP NIL NIL 100100Q))
	   FILES)
          (OR JFN (RETURN))
      LP  (SETQ FILES (CONS (JFNS (LOGAND JFN 777777Q)
				  FORMATFLG)
			    FILES))
          (AND (GNJFN JFN)
	       (GO LP))
          (RETURN (DREVERSE FILES])

(GNJFN
  [LAMBDA (JFN)
    (ASSEMBLE NIL
	      (CQ (VAG JFN))
	      (JSYS 17Q)                        (* GNJFN)
	      (SKIPA 1 , KNIL)
	      (CQ T])

(JFNS
  [LAMBDA (JFN AC3)

          (* Converts a JFN (Lisp small number) to a filename 
          (Lisp atom.) Returns NIL if JFN in any way illegal.
          AC3 is normally NIL, otherwise user has read up on 
          JFNS in JSYS manual)


    (PROG (V)
          (ASSEMBLE NIL
		    (CQ JFN)
		    (SUBI 1 , ASZ)
		    (PUSHN)
		    (JSYS 24Q)

          (* GETSTS; if B10 is off then the JFN is illegal and 
          JFNS will trap.)


		    (TLNE 2 , 200Q)
		    (JRST TAG)
		    (CQ (RETURN))
		TAG (CQ (VAG (OR AC3 222222040001Q)))
                                                (* Flag word controls 
                                                format of filename.
                                                See JSYS manual)
		    (PUSHN)
		    [CQ (COND
			  ((NULL (STRINGP MACSCRATCHSTRING))
			    (SETSTRBUF]
		    (CQ MACSCRATCHSTRING)
		    (PUSHJ CP , UPATM)
		    (MOVES 0 (3))
		    (MOVE 1 , 3)

          (* Destination designator in ac1 specifies bytes for 
          MACSCRATCHSTRING. Is 310Q chars long, hope nobody 
          breaks it.)


		    (POPN 3)                    (* Formatting bits.)
		    (POPN 2)                    (* JFN)
		    (JSYS 30Q)                  (* JFNS.)
		)
          (SETQ V (STRCONC0))
          (RETURN (COND
		    (AC3 

          (* If a3 provided, i.e. request fancy formatting, 
          return as string because may be > 144Q chars.)


			 V)
		    (T (MKATOM V])

(DELFILE
  [LAMBDA (F)                                   (* SHOULD SOMEDAY TAKE 
                                                STARS.)

          (* Cleanupflg says delete all but current version if 
          any. Return list of the ones deleted.)


    (PROG (X)
          (COND
	    ((OPENP F)

          (* Error if file open, since user can close it and 
          try again but cannot very well get it open again to 
          same place.)


	      (ERROR (QUOTE "Close file before deleting:")
		     F))
	    ((NULL (SETQ X (GTJFN F NIL -2)))

          (* This used to be ERRORX call type 16;
          but since we started using ERRORTYPELST to trap such 
          calls to ERRORX and 'fall back' to <LISP> or 
          <NEWLISP> or whatever to find the missing file, it 
          became a non-feature: you would say "DELFILE(MAC)" 
          and it would reply "=<LISP>MAC" and delete the 
          system version.)


	      (ERROR (QUOTE "DELFILE - File not found: ")
		     F)))
          (SETQ F (JFNS X))
          (ASSEMBLE NIL
		    (CQ (VAG X))
		    (JSYS 26Q)

          (* JSYS DELF. Deletes file just like TENEX DELETE 
          command, i.e. marks it for 'real deletion' at next 
          EXPUNGE. Thus file can be undeleted.)


		    (SKIPA 1 , KNIL)
		    (CQ F])

(RENAMEFILE
  [LAMBDA (OLD NEW)
    (PROG (OLDJFN NEWJFN VAL)
          (SETQ OLDJFN (OR (GTJFN OLD)
			   (RETURN)))
          (SETQ NEWJFN (OR (GTJFN NEW NIL -1)
			   (RETURN)))
          (SETQ VAL (OR (JFNS NEWJFN)
			(RETURN)))
          (ASSEMBLE NIL
		    (CQ (VAG NEWJFN))
		    (PUSHN)
		    (CQ (VAG OLDJFN))
		    (NREF (HRRZ 2 , 0))
		    (JSYS 35Q)

          (* JSYS RNAMF, renames file identified by JFN in ac1 
          to be filename identified by JFN in ac2.
          If latter is old file, contents irretrievably lost;
          should not happen unless NEW contains a version 
          number, since GTJFN is called with version number of 
          -1, which means next highest version.
          OLDJFN is released by RNAMF, but NEWJFN must be 
          explicitly released using RLJFN.
          We get both JFNS ourself, with GTJFN, but the effect 
          of renaming a file currently open in lisp for input 
          or output is uncertain.)


		    (PUSHJ CP , ERROR)
		    (POPN)
		    (JSYS 23Q)                  (* JSYS RLJFN.)
		    (PUSHJ CP , ERROR)
		    (CQ (RETURN VAL))
		ERROR
		    (CQ (SETQ VAL))
		    (RET])

(FILEPOS
  [LAMBDA (X FILE START END SKIP TAIL)

          (* FILEPOS is a sort of STRPOS for searching a file 
          for the next occurrence of a specified character 
          sequence. The value of FILEPOS is the byte address 
          of the first character of the sequence found, or NIL 
          if not found. -
          -
          X is the sequence to look for, and may be any type;
          a string is made if necessary.
          -
          FILE is the file to be searched, and must have been 
          opened by INFILE or IOFILE.
          The primary input will be used if FILE is NIL.
          If FILEPOS returns NIL, the file is not affected in 
          any way: your next read, PEEKC or whatever 
          (including writes if FILE open for BOTH) will have 
          exactly the same effect it would have had if the 
          FILEPOS hadn't been called.
          Otherwise, FILEPOS resets the disk pointer so that 
          the next character read will be the first character 
          of the sequence matched, i.e. the character 
          addressed by the value returned from FILEPOS.
          -
          START is the byte address on FILE at which to begin 
          looking, which is the current value of the file 
          pointer (i.e. the place you have 'read to') if NIL.
          -
          END is the byte address at which to give up.
          If END is not given, the file will be searched to 
          the EOF. A match will succeed only if all of the 
          characters in the matching sequence on the disk are 
          before END. -
          -
          SKIP is a dummy-match character a la STRPOS.
          -
          TAIL is also a la STRPOS, causing value of return, 
          and new file position, to be address of first 
          character after matched sequence instead of address 
          of first character matched.)


    (PROG ((FILE (OR FILE (INPUT)))
	   OLDPOS)
          (SETQ OLDPOS (SFPTR FILE -1))

          (* Save current disk address on OLDPOS, in case of 
          failure. Use the SUBR SFPTR here to benefit from 
          some error checks it will make, and to zero CHPOS, 
          the character-position account for the file.
          Hereafter, save time by fiddling the disk pointer 
          directly, using the file's jfn and the JSYS's SFPTR 
          and RFPTR. Note that disk pointer is set to EOF, 
          value of which will be read below.)


          (ASSEMBLE NIL
		    (C
		      (SUBLIS
			(QUOTE ((JFN . 0)
				(FILEND . -1)
				(FIRSTPAT . -2)
				(NCHARSMONE . -3)
				(SKIPCHAR . -4)
				(OLDFPTR . -5)
				(BACKUP . -6)
				(FILCNT . 3)
				(PATBYT . 4)
				(PATPTR . 5)
				(PATCNT . 6)
				(BCKUP . 7)
				(JBIN . 50Q)
				(JRFPTR . 43Q)
				(JSFPTR . 27Q)
				(JGTSTS . 24Q)))
			(QUOTE
			  (ASSEMBLE NIL
				    (PUSHN)
				    (PUSHN)
				    (PUSHN)
				    (PUSHN)
				    (PUSHN)
				    (PUSHN)
				    (PUSHN)

          (* The ADD above grabs 7 numberstack temporaries.
          For clarity, the SUBLIS above is used to permit 
          symbolic reference of temporaries, accumulators and 
          JSYS's in the inner (quoted) assemble.
          -
          TEMPORARIES -
          -
          JFN holds the file's jfn. -
          -
          FILEND is the address at which to give up, either 
          END or end of file. -
          -
          FIRSTPAT is the first pattern char, or -1 if first 
          char is skip char. -
          0<CP> is not named but is pointer to rest of 
          pattern, after FIRSTPAT removed.
          -
          NCHARSMONE is NCHARS of rest of pattern.
          -
          SKIPCHAR is either SKIP byte or -1 if none.
          -
          OLDFPTR saves file address when starting possible 
          match, in case it fails. -
          -
          BACKUP is used with accumulator BCKUP to flag case 
          where FIRSTPAT matches a carriage-return/linefeed 
          pair from the file, either because FIRSTPAT is 
          itself EOL or because FIRSTPAT is skip char.
          This information only needed at WIN+5, the SKIPE 
          instruction. -
          -
          AC's in central algorithm -
          -
          1 Constant: holds jfn. JSYS's like it there.
          -
          2 Variously byte and byte-address for or returned 
          from JSYS's. -
          -
          3 FILCNT Control count for disk.
          -
          4 PATBYT Current pattern byte.
          -
          5 PATPTR When matching, pointer to remainder of 
          pattern string. -
          -
          6 PATCNT When matching, control count of pattern 
          chars left. -
          -
          7 BCKUP See BACKUP above.)


				    (CQ FILE)
				    (FASTCALL IFSET)

          (* Set up JFN. IFSET gives illegal file errors and 
          returns an index, in ac 3, to FILEN, table of 
          jfn's.)


				    (HRRZ 1 , FILEN (3))
				    (NREF (MOVEM 1 , JFN))
				    (JSYS JRFPTR)

          (* RFPTR records the address of EOF because of SFPTR 
          above. Set FILEND to EOF,)


				    (JRST JSYSERR)
				    (NREF (MOVEM 2 , FILEND))
				    (CQ END)
				    (CAMN 1 , KNIL)
                                                (* But if END given,)
				    (JRST ONE 1)
				    (CQ (VAG (AC)))
				    (NREF (CAMG 1 , FILEND))
                                                (* And we don't camg to 
                                                a bad end,)
				    (JUMPGE 1 , ONE)
				    (CQ
				      (QUOTE
					
				 "ATTEMPT TO READ PAST END OF FILE"))
				    (JRST ERRIT)
				ONE (NREF (MOVEM 1 , FILEND))
                                                (* Then set FILEND to it
                                                instead.)
				    (CQ (VAG (OR START OLDPOS)))

          (* Initialize OLDFPTR to START if given, else 
          OLDPOS. Search will begin at this address.)


				    (NREF (MOVEM 1 , OLDFPTR))
				    (CQ
				      (COND
					[(LITATOM X)
                                                (* Make X a PNAME.)
					  (CDR
					    (VAG (IPLUS (LOC X)
							2]
					((NULL (STRINGP X))
					  (MKSTRING X))
					(T X)))
				    (FASTCALL UPATM)

          (* UPATM takes a string or pname in ac1, returns a 
          PDP10 byte pointer in ac3, NCHARS in ac4.)


				    (ILDB 1 , 3)

          (* Initialize FIRSTPAT to first pattern byte.
          Reset to -1 by initialization for SKIPCHAR if they 
          match.)


				    (NREF (MOVEM 1 , FIRSTPAT))

          (* Stack pointer to (SUBSTRING X 2 -1). Must use 
          control stack for pointers.)


				    (PUSH CP , 3)
				    (SUBI 4 , 1)

          (* Initialize NCHARSMONE to NCHARS of pattern minus 
          one, i.e. NCHARS of pattern after FIRSTCHAR 
          removed.)


				    (NREF (MOVEM 4 , NCHARSMONE))
				    [CQ (VAG (COND
					       (SKIP (CHCON1 SKIP))
					       (T -1]
                                                (* Initialize SKIPCHAR.
                                                Use -1 if SKIP not given
                                                to prevent match.)
				    (NREF (MOVEM 1 , SKIPCHAR))
				    (NREF (CAMN 1 , FIRSTPAT))
				    (NREF (SETOM FIRSTPAT))
                                                (* Reset FIRSTPAT to -1 
                                                if it matches skip 
                                                character.)
				    (NREF (MOVE 1 , JFN))
                                                (* Only ac that needs 
                                                initializing is jfn in 
                                                ac 1)
                                                (* Start of main 
                                                algorithm.)
				RESET
				    (NREF (MOVE 2 , OLDFPTR))
                                                (* Go back to OLDFPTR on
                                                disk.)
				    (JSYS JSFPTR)
				    (JRST JSYSERR)
				    (NREF (MOVE FILCNT , FILEND))
                                                (* Compute FILCNT, 
                                                bytes-to-go on disk.)
				    (SUB FILCNT , 2)
				    (NREF (MOVE PATBYT , FIRSTPAT))
				SCAN(PUSHJ CP , READBYTE)
                                                (* Read a disk byte.
                                                Fail exit from algorithm
                                                is in READBYTE.)
				    (CAME 2 , PATBYT)
                                                (* If the byte, returned
                                                in 2, matches,)
				    (JUMPG PATBYT , SCAN)

          (* Or if FIRSTPAT was skip char, set up match 
          procedure. Otherwise, go back and keep scanning.)


				    (MOVE PATPTR , 0 (CP))
                                                (* Set up ac's for match
                                                routine.)
				    (NREF (MOVE PATCNT , NCHARSMONE))
				    (JSYS JRFPTR)
                                                (* Save current file 
                                                position.)
				    (JRST JSYSERR)
				    (NREF (MOVEM 2 , OLDFPTR))
				    (NREF (MOVEM BCKUP , BACKUP))

          (* Also save flag for WIN case.
          BACKUP is numberstack word, gets set only here, each 
          time we try another possible match.
          BCKUP is ac, is reset by each call to READBYTE.
          The matcher uses READBYTE, so must save BCKUP here.)


				MATCH
				    (SOJL PATCNT , WIN)
                                                (* Success exit from 
                                                main algorithm.
                                                Control count on pattern
                                                runs out.)
				    (ILDB PATBYT , PATPTR)
                                                (* Fetch next pattern 
                                                byte.)
				    (PUSHJ CP , READBYTE)
				    (NREF (CAME PATBYT , SKIPCHAR))
				    (CAMN PATBYT , 2)
				    (JRST MATCH)
				    (JRST RESET)
                                                (* End of main 
                                                algorithm)

          (* READBYTE is the routine to get one character from 
          disk. Must force FILEPOS to return NIL if out of 
          bounds; RETNIL does that. Must convert 
          carriage-return/linefeed sequences to EOL's without 
          losing control count. Must check after seeing zero 
          byte to see if file really ok;
          UNXEOF does that.)


				READBYTE
				    (SOJL FILCNT , RETNIL)
				    (SETZ BCKUP , 0)
				    (JSYS JBIN)
				    (JUMPE 2 , UNXEOF)
				    (CAIE 2 , 15Q)
				    (POPJ CP , 0)
				    (SOJL FILCNT , RETNIL)
				    (JSYS JBIN)
				    (JUMPN 2 , * 2)
				    (PUSHJ CP , UNXEOF)
				    (HRRZI 2 , 37Q)
				    (SETO BCKUP , 0)
				    (POPJ CP , 0)
				UNXEOF
				    (JSYS JGTSTS)
				    (TLNN 2 , 1000Q)
				    (POPJ CP , 0)
                                                (* File ok, zero byte 
                                                must be legit so return 
                                                it.)
				    (CQ (QUOTE "UNEXPECTED END OF FILE")
					)
				    (JRST ERRIT)
				JSYSERR
				    (CQ (QUOTE "ERROR IN FILEPOS"))
				    (JRST ERRIT)

          (* RETNIL is called by READBYTE to force return of 
          NIL. Must flush the control stack word created by 
          the PUSHJ which called READBYTE itself.
          (Machts nichts whether READBYTE called from SCAN or 
          from MATCH.) Restore file to original position and 
          pick up NIL for value.)


				RETNIL
				    (SUB CP , BHC 1)
				    (CQ (VAG OLDPOS))
				    (MOV21)
				    (NREF (MOVE 1 , JFN))
				    (JSYS JSFPTR)
				    (JRST JSYSERR)
				    (CQ NIL)
				    (JRST OUT)

          (* WIN is success return. If TAIL is NIL, reset to 
          OLDFPTR and back up over the disk byte which matched 
          FIRSTPAT. But if BACKUP is on, FIRSTPAT was matched 
          by two bytes, an EOL pair, so back up one more.)


				WIN (LDV2 (QUOTE TAIL)
					  SP 2)
				    (CAME 2 , KNIL)
				    (JRST WIN1)
				    (NREF (MOVE 2 , OLDFPTR))
				    (SUBI 2 , 1)
				    (NREF (SKIPE BACKUP))
				    (SUBI 2 , 1)
				    (JSYS JSFPTR)
				    (JRST JSYSERR)
				WON (MOVE 1 , 2)
				    (FASTCALL MKN)
				    (JRST OUT)

          (* WIN1 when TAIL is non-nil.
          File is at the correct position already.
          Just get position and return it.)


				WIN1(JSYS JRFPTR)
				    (JRST JSYSERR)
				    (JRST WON)

          (* ERRIT is error routine. Restore old file position 
          before calling ERROR. Message is in ac 1)


				ERRIT
				    (CQ (ERROR (PROG1 (AC)
						      (SFPTR FILE 
							     OLDPOS))
					       (QUOTE )))

          (* Answer in ac 1; OUT must flush temps and return.
          Critical to flush the control-stack word.)


				OUT (POPNN 7)
				    (SUB CP , BHC 1])

(PAGEFAULTS
  [LAMBDA NIL
    (ASSEMBLE NIL
	      (SKIPA 1 , * 1)
	      (XWD 604763Q 644164Q)             (* SIXBIT value for 
                                                'PGSTAT')
	      (JSYS 16Q)

          (* JSYS SYSGT takes a SIXBIT name of some TENEX 
          internal table, returns in ac2 the internal name 
          (numeric address) which is recognized by other 
          JSYS'S which read and set.)


	      (HRRZ 1 , 2)
	      (HRLI 1 , 1)
	      (JSYS 10Q)

          (* JSYS GETAB, takes table name in rh1, index in 
          lh1, reads that word into ac1 and skips.
          DLM sez word 1 of table 'PGSTAT' is the number of 
          pagefaults which have occurred in this fork.)


	  FALSE
	      (SKIPA 1 , KNIL)
	      (FASTCALL MKN])

(LOADAV
  [LAMBDA NIL                                   (* First ARG is 
                                                (SIXBIT (QUOTE SYSTAT)))
    (GETAB -140614133614Q 14Q (QUOTE FLOATING])

(GETAB
  [LAMBDA (TABLENAME INDEX FORMATFLG)

          (* Makes the JSYS GETAB available.
          TABLENAME is a number a string 
          (OR LITATOM) and expected to be one of the system 
          tables documented in section 3 of the JSYS manual, 
          which GETAB will know about.
          INDEX is the INDEX, into that table.
          FORMATFLG can be 'floating to get answer as 
          floating-point, as in LOADAV, or NIL to get 
          fixed-point. Perhaps if there is a use FORMATFLG 
          might believe ascii or SIXBIT etc.)


    (ASSEMBLE NIL
	      [CQ (VAG (COND
			 ((FIXP TABLENAME)
			   TABLENAME)
			 (T (SIXBIT TABLENAME]
	      (JSYS 16Q)                        (* SYSGT)
	      (PUSHN 2)
	      (CQ (VAG (OR INDEX 0)))
	      (NREF (HRLM 1 , 0))
	      (POPN)
	      (JSYS 10Q)                        (* GETAB)
	      (JRST ERROR)
	      (VAR (HRRZ 2 , FORMATFLG))
	      (CAME 2 , ' FLOATING)
	      (JRST A)
	      (FASTCALL MKFN)
	      (JRST OUT)
	  A   (CQ (LOC (AC)))
	      (JRST OUT)
	  ERROR
	      (CQ (ERSTR NIL T))
	  OUT])

(SIXBIT
  [LAMBDA (X)

          (* Converts a fixed-point number to an string, and 
          an atom or string to a fixed-point number.
          Originally written for GETAB.)


    (COND
      [(FIXP X)
	(ASSEMBLE NIL
	          (CQ (VAG X))
	          (PUSHN)
	          [CQ (COND
			((NULL (STRINGP MACSCRATCHSTRING))
			  (SETSTRBUF]
	          (CQ MACSCRATCHSTRING)
	          (PUSHJ CP , UPATM)
	          (MOVES 0 (3))
	          (POPN 2)
	      LOOP(SETZ 1 , 0)
	          (LSHC 1 , 6)
	          (JUMPE 1 , OUT)
	          (ADDI 1 , 40Q)
	          (IDPB 1 , 3)
	          (JRST LOOP)
	      OUT (IDPB 1 , 3)                  (* Add NULL byte to 
                                                terminate.)
	          (CQ (STRCONC0]
      (T
	(LOC (ASSEMBLE NIL
		       [CQ (COND
			     [(LITATOM X)
			       (CDR (VAG (IPLUS 2 (LOC X]
			     ((STRINGP X)
			       X)
			     (T (ERROR (QUOTE "SIXBIT: ILLEGAL ARG")
				       X]
		       (PUSHJ CP , UPATM)
		       (CAILE 4 , 6)
		       (HRRZI 4 , 6)
		       (HRREI 5 , -6 (4))
		       (SETZ 1 , 0)
		   LOOP(SOJL 4 , LOOP2)
		       (ILDB 2 , 3)
		       (LSH 1 , 6)
		       (ADDI 1 , -40Q (2))
		       (JRST LOOP)
		   LOOP2
		       (AOJG 5 , OUT)
		       (LSH 1 , 6)
		       (JRST LOOP2)
		   OUT])

(GETER
  [LAMBDA NIL                                   (* JSYS GETER, returns 
                                                most recent system error
                                                number.)
    (LOC (ASSEMBLE NIL
	           (CQ (VAG 400000Q)            (* This fork.)
		       )
	           (JSYS 12Q)                   (* GETER)
	           (HRRZI 1 , 0 (2])

(ERSTR
  [LAMBDA (ERN ERRFLG)

          (* Makes the JSYS ERSTR available.
          ERN is the error number as returned from GETER, or 
          NIL or minus one for most recent error.
          Returns the TENEX error diagnostic as a string.
          Used for assemble code where you call JSYS's and 
          want to do something reasonable with their error 
          returns. If ERRFLG is T actually call ERROR;
          else just return the string.)


    (ASSEMBLE NIL
	      (CQ ERN)
	      (CAMN 1 , KNIL)
	      (SKIPA 1 , MINUS1)
	      (PUSHJ CP , GUNBOX)
	      (PUSHN)
	      [CQ (COND
		    ((NULL (STRINGP MACSCRATCHSTRING))
		      (SETSTRBUF]
	      (CQ MACSCRATCHSTRING)
	      (PUSHJ CP , UPATM)
	      (MOVES 0 (3))
	      (MOVE 1 , 3)                      (* Destination 
                                                designator in ac1, 
                                                points into the dirty 
                                                string.)
	      (POPN 2)                          (* Error number to RH of
                                                ac2)
	      (HRLI 2 , 400000Q)                (* LH ac2 specifies 
                                                fork, 400000Q = this 
                                                fork.)
	      (HRLZI 3 , 0 (4))

          (* Maximum number of characters to transfer must be 
          in ac3 left, UPATM (SETSTRBUF that is) left it in 
          ac4.)


	      (JSYS 11Q)                        (* ERSTR)
	      (JFCL)
	      (JRST FALSE)                      (* ERSTR double-skips if
                                                happy.)
	      (SETZ 3 ,)
	      (IDPB 3 , 1)                      (* Null byte supposedly 
                                                provided by ERSTR but it
                                                isn't.)
	      (CQ (STRCONC0))
	      (JRST END)
	  MINUS1
	      (XWD 777777Q 777777Q)
	  FALSE
	      (CQ NIL)
	  END])

(IDATE
  [LAMBDA (D)
    (ASSEMBLE NIL
	      (CQ D)
	      (CAMN 1 , KNIL)
	      (JRST DO-GTAD)
	      [CQ (COND
		    ((NULL (STRINGP MACSCRATCHSTRING))
		      (SETSTRBUF]
	      (CQ MACSCRATCHSTRING)
	      (PUSHJ CP , UPATM)
	      (MOVES 0 (3))
	      (MOVE 1 , 3)
	      (SETZM 2)
	      (JSYS 221Q)                       (* JSYS IDTIM)
	      (JRST FALSE)
	      (MOVE 1 , 2)
	      (JRST BOX)
	  DO-GTAD
	      (JSYS 227Q)                       (* GTAD)
	      (JRST BOX)
	  FALSE
	      (SKIPA 1 , KNIL)
	  BOX (FASTCALL MKN])

(USERNUMBER
  [LAMBDA (A)
    (ASSEMBLE NIL
	      (CQ A)
	      (CAMN 1 , KNIL)
	      (JRST LOGIN-DIRECTORY)
	      (CAMN 1 , KT)
	      (JRST CONNECTED-DIRECTORY)
	      (CQ (RPLSTR0 (AC)))
	      (HRLZI 2 , 400000Q)
	      (CAMN 1 , KNIL)
	      (SETZ 2 , 0)
	      (PUSHN 2)
	      [CQ (COND
		    ((NULL (STRINGP MACSCRATCHSTRING))
		      (SETSTRBUF]
	      (CQ MACSCRATCHSTRING)
	      (PUSHJ CP , UPATM)
	      (MOVES 0 (3))
	      (MOVE 2 , 3)
	      (POPN)
	      (JSYS 40Q)
	      (JFCL)
	  FALSE
	      (SKIPA 1 , KNIL)
	      (JRST BOX)
	      (JRST OUT)
	  CONNECTED-DIRECTORY
	      (JSYS 13Q)
	      (SKIPA 1 , 2)
	  LOGIN-DIRECTORY
	      (JSYS 13Q)
	  BOX (ADDI 1 , ASZ)
	  OUT])

(USERNAME
  [LAMBDA (A)
    (ASSEMBLE NIL
	      (CQ A)
	      (CAME 1 , KNIL)
	      (JRST A)                          (* Login directory 
                                                name.)
	      (JSYS 13Q)

          (* GJINF returns login directory number in ac1, 
          connected directory in ac2, other stuff too.)


	      (JRST D)
	  A   (CAME 1 , KT)
	      (JRST C)                          (* Connected directory)
	      (JSYS 13Q)
	      (SKIPA 1 , 2)
	  C   (SUBI 1 , ASZ)
	  D   (PUSHN)
	      [CQ (COND
		    ((NULL (STRINGP MACSCRATCHSTRING))
		      (SETSTRBUF]
	      (CQ MACSCRATCHSTRING)
	      (PUSHJ CP , UPATM)
	      (MOVES 0 (3))
	      (MOVE 1 , 3)
	      (POPN 2)
	      (JSYS 41Q)                        (* DIRST)
	      (JRST FALSE)
	      (CQ (STRCONC0))
	      (JRST END)
	  FALSE
	      (CQ NIL)
	  END])

(STRCONC0
  [LAMBDA NIL

          (* Utility for my internal use, blockcompiled away, 
          returns (CONCAT (SUBSTRING MACSCRATCHSTRING 1 
          (STRPOS MACSCRATCHSTRING (CHARACTER 0)))))


    (ASSEMBLE NIL
	      (CQ MACSCRATCHSTRING)             (* Globalvar.)
	      (PUSHJ CP , UPATM)
	      (PUSH CP , 3)                     (* Ptr to stack so gc 
                                                will update it.)
	      (PUSHJ CP , MKSTRS)               (* Init. Stringmaker)
	      (SKIPA)
	  LP  (PUSHJ CP , MKSTR1)               (* Emit 1 char.)
	      (ILDB 1 , 0 (CP))
	      (JUMPN 1 , LP)
	      (POP CP , 2)                      (* Flush CP word.)
	      (MOVE 1 , UNP1)
	      (PUSHJ CP , MKSP])

(RPLSTR0
  [LAMBDA (STR)

          (* My internal utility, inverse of STRCONC0: writes 
          STR onto MACSCRATCHSTRING, starting at front, and 
          adds a NULL byte after it. Argument must be string 
          or pname, or it will give error.
          Special hack: if ARG ends in alt-mode, altmode is 
          stripped off and T returned, else returns NIL.
          For USERNUMBER.)


    (ASSEMBLE NIL
	      (CQ STR)
	      (LDTY 2)
	      (CAIN 2 , 30Q)                    (* String?)
	      (JRST OK)                         (* Yes.)
	      (CAIE 2 , 14Q)                    (* Litatom?)
	      (JRST OHOH)                       (* Only called 
                                                internally.)
	      (HLRZ 1 , 2 (1))                  (* Convert to pname.)
	      (JRST OK)
	  OVFLO
	      (CQ (ERROR (QUOTE "Too big for string buff:")
			 STR))
	  OHOH(CQ (ERROR (QUOTE "Arg not string or atom:")
			 STR))
	  OK  (PUSHJ CP , UPATM)
	      (PUSH CP , 3)
	      (PUSHN 4)
	      [CQ (COND
		    ((NULL (STRINGP MACSCRATCHSTRING))
		      (SETSTRBUF]
	      (CQ MACSCRATCHSTRING)
	      (PUSHJ CP , UPATM)
	      (MOVES 0 (3))                     (* MAKE SURE BYTE PG 
                                                UNSHARED)
	      (NREF (CAMG 4 , 0))               (* Scratch > str? must 
                                                be greater so str+null 
                                                g.e.)
	      (JRST OVFLO)
	      (POPN 4)
	      (POP CP , 2)

          (* Assignments: -
          1 bytebucket -
          2 read ptr to str -
          3 write ptr to buf -
          4 count)


	      (JUMPE 4 , OUT)
	  LOOP(ILDB 1 , 2)
	      (IDPB 1 , 3)
	      (SOJG 4 , LOOP)
	      (CAIN 1 , 33Q)                    (* Last byte altmode?)
	      (DPB 4 , 3)                       (* Clobber with NULL.)
	  OUT (IDPB 4 , 3)                      (* Write NULL after.)
	      (CAIE 1 , 33Q)                    (* Altmodep again)
	      (SKIPA 1 , KNIL)                  (* No.)
	      (CQ T)                            (* Yes.)
	  ])

(SETSTRBUF
  [LAMBDA NIL                                   (* Internal function to 
                                                intialize 
                                                MACSCRATCHSTRING)
    (ASSEMBLE NIL
	  INITIT
	      (PUSHJ CP , MKSTRS)               (* Init. Internal 
                                                stringmaker.)
	      (HRRZI 1 , 130Q)                  (* Use X for the 
                                                characters.)
	      (HRRZI 2 , 310Q)
	      (PUSHJ CP , MKSTR1)               (* Add 1 char.)
	      (SOJG 2 , * -1)
	      (MOVE 1 , UNP1)                   (* Retrieve byte-pointer
                                                for string being built,)
	      (PUSHJ CP , MKSP)                 (* Box it.)
	      (SETQ MACSCRATCHSTRING)

          (* Save value and POPJ back to the call above using 
          the POPJ added by friendly compiler.)


	  OUT])

(RAND
  [LAMBDA (LOWER UPPER)

          (* Generates a random integer between LOWER and 
          UPPER inclusive. Cribbed from code written by RST 
          for FORTRAN.)


    (PROG (R1 R2)
          (ASSEMBLE NIL
		TOP [CQ (SETQ R1 (CAAR (QUOTE RANDSTATE]
		    (SKI)
		    (JRST INIT)
		    [CQ (SETQ R2 (CDAR (QUOTE RANDSTATE]
		    (SKI)
		    (JRST INIT)
		    (MOVE 1 , 0 (1))
		    (PUSHN)
		    (CQ R1)
		    (MOVE 1 , 0 (1))
		    (PUSHN)
		    (NREF (MOVE 2 , -1))
		    (LSHC 2 , 1)
		    (NREF (ADD 2 , 0))
		    (JFCL 4 , * 1)
		    (NREF (ADDB 1 , 0))
		    (JFCL 4 , RAND1)
		RAND2
		    (NREF (ADDB 2 , -1))
		    (JRST DONE)
		RAND1
		    (AOJA 2 , RAND2)
		DONE(CQ R2)
		    (POPN 2)
		    (MOVEM 2 , 0 (1))
		    (CQ R1)
		    (NREF (MOVE 2 , 0))
		    (MOVEM 2 , 0 (1))
		    (CQ (VAG (NTYP LOWER)))
		    (CAMN 1 , FLOATT)
		    (JRST FLOATING)
		    (CQ (VAG (NTYP UPPER)))
		    (CAME 1 , FLOATT)
		    (JRST FIXED)
		FLOATING
		    (NREF (MOVE 1 , 0))
		    (JFFO 1 , * 1)
		    (LSH 1 , -11Q (2))
		    (JUMPN 1 , FLOATON)
		    (CQ (RETURN (FLOAT LOWER)))
		FLOATON
		    (MOVN 2 , 2)
		    (FSC 1 , 200Q (2))
		    (PUSHN)
		    (CQ LOWER)
		    (FASTCALL FUNBOX)
		    (PUSHN)
		    (CQ UPPER)
		    (FASTCALL FUNBOX)
		    (NREF (FSBR 1 , 0))
		    (NREF (FMPR 1 , -1))
		    (NREF (FADR 1 , 0))
		    (FASTCALL MKFN)
		    (POPNN 2)
		    (CQ (RETURN (AC)))

          (* This initialization sequence will usually happen 
          only on the first call to RAND.
          The user doesn't have to know anything about 
          initialization, and values from CLOCK are used so 
          that different sequences will be generated from one 
          login to the next.)


		FIXED
		    (CQ (VAG LOWER))
		    (PUSHN)
		    (CQ (VAG UPPER))
		    (NREF (SUB 1 , 0))
		    (ADDI 1 , 1)
		    (NREF (MOVE 2 , -1))
		    (LSH 2 , -1)
		    (MUL 2 , 1)
		    (MOVE 1 , 2)
		    (NREF (ADD 1 , 0))
		    (POPNN 2)
		    [CQ (RETURN (LOC (AC]
		INIT(CQ (RANDSET T))
		    (JRST TOP])

(RANDSET
  [LAMBDA (X)
    (PROG NIL
          (COND
	    ((NULL X)
	      (GO OUT))
	    ([NOT (OR (EQ X T)
		      (AND (LISTP X)
			   (FIXP (CAR X))
			   (FIXP (CDR X]
	      (ERROR (QUOTE "ARG NOT PREVIOUS VALUE OF RANDSET")
		     X)))
          (FRPLACA (QUOTE RANDSTATE)
		   (CONS (IPLUS 23420Q)
			 (IPLUS 23420Q)))       (* Initialize to CONS of
                                                two fresh, guaranteed 
                                                type-18 numbers.)
          [COND
	    [(EQ X T)

          (* Request initialize it ourself, using CLOCK.
          See notes on main branch at bottom.)


	      (CLOSER (LOC (CAAR (QUOTE RANDSTATE)))
		      (IPLUS (CLOCK 2)
			     (LSH (CLOCK 2)
				  22Q)))
	      (CLOSER (LOC (CDAR (QUOTE RANDSTATE)))
		      (IPLUS (CLOCK)
			     (LSH (CLOCK)
				  22Q]
	    (T (CLOSER (LOC (CAAR (QUOTE RANDSTATE)))
		       (CAR X))

          (* Transfer values from X into new boxes.
          -
          The point of all the chicanery here is to make sure 
          that we never set RANDSTATE to anything but CONS of 
          two type-18 numbers. The worrisome case arises when 
          RAND has run a while, and by chance the value of the 
          type-18 numbers from X is really in the SMALLP 
          range. We cannot 'copy' that value the intuitive 
          way, with IPLUS, because when it got reboxed it 
          would be SMALLP, and then the next call to RAND 
          would re-initialize with clock.)


	       (CLOSER (LOC (CDAR (QUOTE RANDSTATE)))
		       (CDR X]
      OUT (RETURN (CONS (IPLUS (CAAR (QUOTE RANDSTATE)))
			(IPLUS (CDAR (QUOTE RANDSTATE])
)
  [RPAQQ MACBLOCKS
	 ((DCHCONBLOCK DUNPACK DCHCON (ENTRIES DUNPACK DCHCON)
		       (GLOBALVARS DCHCONGV))
	  (FORKBLOCK SUBSYS KFORK KFORK1 CFORK GCFORKS GPJFN RFSTS
		     (ENTRIES SUBSYS KFORK CFORK RFSTS)
		     (GLOBALVARS LASTSUBSYS USERFORKLST USERFORKS 
				 CFORKTIME SUBSYSSPELLINGS))
	  (MACSTRBLOCK JFNS SIXBIT GETAB ERSTR USERNAME USERNUMBER 
		       STRCONC0 RPLSTR0 SETSTRBUF
		       (ENTRIES JFNS SIXBIT GETAB ERSTR USERNAME 
				USERNUMBER)
		       (GLOBALVARS MACSCRATCHSTRING))
	  (FILDIR FILDIR GNJFN)
	  (SORT SORT SORT1 (LOCALFREEVARS COMPAREFN]
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY
  (BLOCK: DCHCONBLOCK DUNPACK DCHCON (ENTRIES DUNPACK DCHCON)
	  (GLOBALVARS DCHCONGV))
  (BLOCK: FORKBLOCK SUBSYS KFORK KFORK1 CFORK GCFORKS GPJFN RFSTS
	  (ENTRIES SUBSYS KFORK CFORK RFSTS)
	  (GLOBALVARS LASTSUBSYS USERFORKLST USERFORKS CFORKTIME 
		      SUBSYSSPELLINGS))
  (BLOCK: MACSTRBLOCK JFNS SIXBIT GETAB ERSTR USERNAME USERNUMBER 
	  STRCONC0 RPLSTR0 SETSTRBUF
	  (ENTRIES JFNS SIXBIT GETAB ERSTR USERNAME USERNUMBER)
	  (GLOBALVARS MACSCRATCHSTRING))
  (BLOCK: FILDIR FILDIR GNJFN)
  (BLOCK: SORT SORT SORT1 (LOCALFREEVARS COMPAREFN))
]
(DEFLIST(QUOTE(
  [FCHARACTER ((X)
	       (ASSEMBLE NIL (CQ X)
			 (ANDI 1 , 127)
			 (HRRZ 2 , @ ' FCHARAR)
			 (ADDI 1 , 2 (2))
			 (HRRZ 1 , 0 (1]
))(QUOTE MACRO))
  (MOVD (QUOTE CHARACTER)
	(QUOTE FCHARACTER))
  (SETQ FCHARAR (ARRAY 128))
  (PROG ((I 1))
	$$$LP
	[COND ((IGREATERP I 128)
	       (RETURN))
	      (T (SETA FCHARAR I (CHARACTER (SUB1 I]
	(SETQ I (ADD1 I))
	(GO $$$LP))
  (RPAQ USERFORKLST)
  (RPAQ CFORKTIME (CLOCK 3))
  (RPAQ USERFORKS (HARRAY 29))
  (RPAQQ
    MACSCRATCHSTRING 

"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    )
  (RPAQQ SUBSYSSPELLINGS
	 (LISPX EXEC MACRO SRCCOM TECO SNDMSG LISP DELVER TELNET FTP 
		NETSTAT READMAIL CALENDAR HOSTAT RSEXEC FAIL))
(DECLARE: DONTCOPY
  (FILEMAP (NIL (1406 64231 (DCHCON 1418 . 4756) (DUNPACK 4760 . 5123)
(SORT 5127 . 5373) (SORT1 5377 . 7441) (ALPHORDER 7445 . 12987) (MERGE
12991 . 15596) (SUBSYS 15600 . 21199) (CFORK 21203 . 22118) (GCFORKS
22122 . 23087) (KFORK 23091 . 23838) (KFORK1 23842 . 25421) (RFSTS
25425 . 26197) (GEVEC 26201 . 26367) (GPJFN 26371 . 26622) (GTJFN
26626 . 30219) (RLJFN 30223 . 30575) (FILDIR 30579 . 30885) (GNJFN
30889 . 31047) (JFNS 31051 . 32544) (DELFILE 32548 . 33886) (RENAMEFILE
33890 . 35082) (FILEPOS 35086 . 48496) (PAGEFAULTS 48500 . 49293)
(LOADAV 49297 . 49493) (GETAB 49497 . 50613) (SIXBIT 50617 . 51947)
(GETER 51951 . 52338) (ERSTR 52342 . 54379) (IDATE 54383 . 54943)
(USERNUMBER 54947 . 55678) (USERNAME 55682 . 56560) (STRCONC0 56564
. 57304) (RPLSTR0 57308 . 59452) (SETSTRBUF 59456 . 60406) (RAND 60410
. 62513) (RANDSET 62517 . 64228)))))
STOP
