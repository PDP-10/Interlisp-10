(FILECREATED "12-SEP-74 18:06:11" CLISP.;1 63336  

     previous date: "12-AUG-74 20:55:55" <LISP>CLISP.;2)


  (LISPXPRINT (QUOTE CLISPCOMS)
	      T)
  (RPAQQ CLISPCOMS ((FNS * CLISPFNS)
	  (PROP FILEGROUP CLISP)))
  (RPAQQ CLISPFNS
	 (CLISPATOM0 CLISPATOM1 CLRPLNODE STOPSCAN? CLUNARYMINUS? CLISPATOM1A 
		     CLISPATOM1B CL89CHECK CLISPATOM2 CLISPLOOKUP GETLOCALDEC 
		     CLISPATOM2A CLISPATOM2B CLISPATOM2C CLISPATOM2D CLISPERROR 
		     CLISPCAR/CDR CLISPCAR/CDR1))
(DEFINEQ

(CLISPATOM0
  [LAMBDA (LST TAIL PARENT)
    (AND (NULL SUBPARENT)
	 (SETQ SUBPARENT PARENT))
    (PROG (TEM CLISPRESPELL (CURRTAIL TAIL)
	       89FLG
	       (NOFIXVARSLST1 NOFIXVARSLST0))
      TOP (SETQ CLISPRESPELL NIL)
          [COND
	    ((SETQ TEM (UNDONLSETQ (CLISPATOM1 TAIL)
				   CLISPATOM1))
                                                (* Successful.)
	      (RETURN (CAR TEM]
          (SETQ NOFIXVARSLST0 NOFIXVARSLST1)
          [COND
	    (CLISPRESPELL (SETQ CLISPRESPELL NIL)
			  [MAPC (GET LISPXHIST (QUOTE RESPELLS))
				(FUNCTION (LAMBDA (X)
				    (COND
				      ((SETQ LST (FMEMB (CAR X)
							TAIL))
					(SETQ TEM (CDR X))
					[COND
					  [(LISTP TEM)
					    (/RPLNODE LST (CAR TEM)
						      (CONS (CDR TEM)
							    (CDR LST]
					  (T (/RPLNODE LST TEM (CDR LST]
					(SETQ CLISPRESPELL T]
			  (SETQ LST (DUNPACK (CAR TAIL)
					     CHCONLST))
			  (COND
			    (CLISPRESPELL 

          (* MIsspelling found. Note that even if the word wasnt 
          found, LST is reset since some tentative changes were tried, 
          it was probably clobbered.)


					  (SETQ CURRTAIL TAIL)
					  (GO TOP]
          (RETURN (COND
		    (89FLG                      (* E.G. N*8FOO -- fix the 8-9 
                                                error first.)
			   [PROG ((FAULTX (CAR CURRTAIL)))
			         (SETQ TEM (FIX89 FAULTX (CAR 89FLG)
						  (LENGTH 89FLG]
			   (AND TEM (LITATOM (CAR TAIL))
				(CLISPATOM0 (DUNPACK (CAR TAIL)
						     SKORLST3)
					    TAIL PARENT])

(CLISPATOM1
  [LAMBDA (TAIL)

          (* This function and its subfunctions handle infix 
          operators. LST is an exploded list of characters for CAR of 
          TAIL, which is a tail of PARENT.
          If LST contains an CLISP operator, or CAR of TAIL is one, 
          CLISPATOM1 scans the rest of tail until it reaches the end 
          of this cluster. For example, if TAIL is 
          (... A* B + C D+E ...), the scan will stop after C.
          The scan separates out the operators from the operands.
          Note that because any operand can be a list, and hence 
          separated from its operator, an operator can occur interior 
          to an atom, as in A*B, at the end of an atom, as in 
          (A* (--)), at the front of an atom, as in 
          ((--) *A), or by itself, as in 
          ((--) * (--)). Therefore, we permit the same options when 
          the operand is a atomic, i.e. the user can type A*B, A* B, A 
          *B, or A * B. Note that in the latter two cases, the first 
          argument to the operator is not contained in TAIL, and it is 
          necessary for CLISPATOM1 to back tail up one element using 
          PARENT.)



          (* After the scan has been completed, the form for the first 
          operator is assembled. Since operators are always processed 
          left to right, the first operand to this operator is always 
          the single element preceding it 
          (unless it is a unary operator). The right boundary, and 
          hence the second operand, is determined by the operator, 
          e.g. * is tighter than +, which is tighter than LS, etc. 
          Thus ... A*B+C ... becomes ... 
          (ITIMES A B) + C ... while ... A+B*C ...
          becomes ... (IPLUS A B * C) In either case, the rest of this 
          cluster is processed from within this call to CLISPATOM1, 
          thereby taking advantage of the fact that we know that the 
          atoms do not contain operators, and therefore don't have to 
          be unpacked and examined character by character.)


    (PROG ((L LST)
	   (LST0 LST)
	   CURRTAIL-1 CLTYP CLTYP1 ENDTAIL BROADSCOPE BACKUPFLG OPRFLAG NOTFLG 
	   TYP ATMS NOSAVEFLG TENTATIVE TEM (ANGCNT 0))
          (COND
	    ((SETQ CLTYP1 (GETP (CAR CURRTAIL)
				(QUOTE CLISPTYPE)))
	      (GO NEXT2)))
      TOP (SETQ ATMS NIL)
      LP  (COND
	    ((NULL L)                           (* End of an atom.)
	      (COND
		((NULL TYP)

          (* If we have gone through the first atom without finding an 
          CLISP operator, we are done.)


		  (COND
		    ((NULL 89FLG)

          (* The case where there was an 8 or 9 and an operator has 
          been handled in CL89CHECK.)


		      )
		    (CURRTAIL 

          (* 8 and 9 errors are handled here instead of back in 
          CLISPATOM where there is similar code, because there may be 
          more than one 8 or 9 in the expression, and the first one 
          may be ok, e.g. 8*X*8ADD1 Y)


			      (AND [FIX89A (CAR CURRTAIL)
					   (CAR 89FLG)
					   (IMINUS (SETQ TEM (LENGTH 89FLG]
				   (FIX89 FAULTX (CAR 89FLG)
					  TEM)
				   (GO OUT2)))
		    ((AND TYPE-IN? (EQ (CAR 89FLG)
				       8)
			  (EQ (CAR (SETQ TEM (FLAST LST)))
			      9))

          (* This corresponds to the case where an atom was typed in 
          containing both an 8 and a 9, e.g. FILES?89 or 8EDITF9.
          Note that if the atom were part of a larger expression, 
          either CAR of form, or appearing in a tail, 
          (as indicated by CURRTAIL being non-NIL), the fix is 
          performed by FIX89, and involves editing the expression.
          In the case covered here, the fix requires changing the EVAL 
          to an apppropriate APPLY.)


		      (FIX89TYPEIN (FMEMB 8 (SETQ TEM (LDIFF LST TEM)))
				   TEM T)))
		  (RETURN NIL))
		(LST0 (SETQ OPRFLAG T)

          (* OPRFLAG is T means the element just processed did NOT end 
          in an operator, e.g. A+B, or just A.)


		      (SETQ TEM (PACK LST0))

          (* Collects characters to the right of the last operator in 
          the atom, or all the characters in the atom, if it contained 
          no operator.)


		      (CL89CHECK TEM)
		      (SETQ ATMS (NCONC1 ATMS TEM))
		      (SETQ NOTFLG NIL)))
	      (SETQ 89FLG NIL)
	      (GO NEXT)))
          (SETQ CLTYP1 (GETP (CAR L)
			     (QUOTE CLISPTYPE)))
          (SELECTQ (CAR L)
		   [-(AND CLTYP1 (COND
			    ((NULL (AND (EQ L LST0)
					(CLUNARYMINUS? OPRFLAG)))

          (* Says minus is binary. See comments i CLUNARYMINUS?.
          By replacing binary minus with +- in CLISPATOM1, all the 
          rest of the CLISP function can treat minus as unary.)


			      (FRPLACA L (QUOTE +-))
			      (SETQ CLTYP1 (GETP (QUOTE +-)
						 (QUOTE CLISPTYPE]
		   ((8 9)
		     (OR 89FLG (SETQ 89FLG L)))
		   ('(AND (NEQ L LST0)
			  (GO LP1))

          (* ' is ignored interior to atoms, e.g. USER can have a 
          function named ATOM' or a variable named A' which is not 
          necessarily defined or bound at time of DWIMIFYing.)


		     )
		   (<(AND CLTYP1 (SETQ ANGCNT (ADD1 ANGCNT)))

          (* Note that by removing CLISPTYPE property, the user can 
          disable this and all other transformations.)


		     )
		   [> (COND
			((NULL CLTYP1))
			((ZEROP ANGCNT)
			  (SETQ CLISPERTYPE (LIST (QUOTE >)
						  PARENT))
			  (ERROR!))
			(T (SETQ ANGCNT (SUB1 ANGCNT]
		   [! (COND
			((NOT (ZEROP ANGCNT))   (* Separate ! when under <>.)
			  (GO OPR]
		   NIL)
          (AND CLTYP1 (GO OPR))
      LP1 (COND
	    ((AND OPRFLAG (NULL BROADSCOPE)
		  (ZEROP ANGCNT)
		  (EQ L LST))

          (* If OPRFLAG is T and the first character in LST is not an 
          operator, no need to scan further, e.g. A*B C unless we are 
          processing a broad scope operator, e.g. 
          (A EQ FOO B) or unless ANGCNT is not 0, i.e. we are inside 
          of an <> pair.)


	      (OR ENDTAIL (SETQ ENDTAIL CURRTAIL))

          (* If ENDTAIL has not been set yet, set it.
          Note that ENDTAIL may already have been set, e.g. A*B+C D, 
          in which case ENDTAIL would correspnd to the position of the 
          +.)


	      (GO OUT)

          (* If this is the first character in an atom, then we cango 
          to out, e.g. A+B C. HOwever, this may be the first character 
          following a >, as in FOO_<A B>C, in which case we have to 
          finish out the atom.)


	      ))
          (SETQ L (CDR L))                      (* Peel off the current 
                                                character and go on.)
          (GO LP)
      NEXT                                      (* We have just exhausted the 
                                                lit of characters for an atm.)
          [COND
	    ((NULL TAIL)                        (* We were originally given just
                                                an atom, e.g. user types 
                                                FOO_FIE.)
	      (SETQ TAIL ATMS))
	    ([AND TAIL (OR (CDR ATMS)
			   (NEQ (CAR ATMS)
				(CAR CURRTAIL]

          (* Splice burst version of atom into CURRTAIL, and set 
          CURRTAIL to point to the as yet unexamined part of it.
          If the OR is not true, CURRTAIL would not be changd so don't 
          bother e.g. (LIST A + B * C))


	      [/RPLNODE CURRTAIL (CAR ATMS)
			(NCONC (CDR ATMS)
			       (SETQ CURRTAIL (CDR (SETQ CURRTAIL-1 CURRTAIL]
                                                (* CURRTAIL-1 is used for 
                                                backing up, see below.)
	      )
	    (T (SETQ CURRTAIL (CDR (SETQ CURRTAIL-1 CURRTAIL]
          (COND
	    ((NULL CURRTAIL)                    (* We have reached the end of 
                                                the faulty form.)
	      (GO OUT)))
      NEXT1                                     (* Look at the next thing in 
                                                CURRTAIL.)
          (COND
	    ((AND (OR (NEQ (CAR CURRTAIL-1)
			   (QUOTE '))
		      OPRFLAG)
		  (LITATOM (CAR CURRTAIL))
		  (CLISPNOTVARP (CAR CURRTAIL)))

          (* The OR check is to handle cases like 
          (.. ' F/L) which I think means wquote the whole thing.
          NOte that this comes up in expressions like <A 'F/L> since 
          when SHRIEKER calls DWIMIFY2, the ' and F/L have already 
          been split apart.)


	      (COND
		((SETQ CLTYP1 (GETP (CAR CURRTAIL)
				    (QUOTE CLISPTYPE)))
		  (GO NEXT2)))
	      [SETQ LST0 (SETQ L (SETQ LST (DUNPACK (CAR CURRTAIL)
						    SKORLST3]
	      (COND
		((AND (NEQ ANGCNT 0)
		      (SETQ TEM (FMEMB (QUOTE >)
				       (CDDR L)))
		      (NOT (FMEMB (QUOTE <)
				  L)))

          (* < and > are thought of as brackets, rather than 
          operaaors. Therefore this is necessary in order thatthings 
          like <1 2 -1> work, i.e. -
          not treated as binary in this case, also <a b 'c>, and 
          finally if A*B is the name of a variable <X A*B> Note that 
          this doesnt quite handle all cases: <A*B> where A*B is the 
          name of a variable, will be broken apart, but then it isnt 
          clear whats intended.)


		  (CLRPLNODE CURRTAIL (PACK (LDIFF L TEM))
			     (CONS (PACK TEM)
				   (CDR CURRTAIL)))
		  (GO NEXT1)))
	      (GO TOP))
	    ((AND OPRFLAG (SETQ TEM (NLEFT TAIL 2 CURRTAIL))
		  (NEQ (CAR TEM)
		       (QUOTE '))
		  (NEQ (CAR TEM)
		       (QUOTE :))
		  [OR (NULL (CAR CURRTAIL))
		      (AND (LISTP (CAR CURRTAIL))
			   (NOT (CLISPFUNCTION? (CAR CURRTAIL)
						(QUOTE OKVAR]
		  (CLISPFUNCTION? (SETQ TEM (CDR TEM))
				  (QUOTE NOTVAR)
				  [FUNCTION (LAMBDA (X Y)
				      (CONCAT X (COND
						((NULL Y)
						  (QUOTE "()"))
						(T (RETDWIM2 Y]
				  [FUNCTION (LAMBDA (X Y)
				      (MKSTRING (CONS X (RETDWIM2 Y]
				  (CAR CURRTAIL)))

          (* This clause checks for user typing in apply mode, e.g. 
          X_CONS (A B))


	      (SETQQ TENTATIVE CERTAINLY)

          (* Once you print a message, you dont want to go and try 
          another interpretation.)


	      (/RPLNODE TEM (CONS (CAR TEM)
				  (CAR CURRTAIL))
			(CDR CURRTAIL))
	      (SETQ CURRTAIL (CDR (SETQ CURRTAIL-1 TEM)))
	      (SETQ OPRFLAG T)
	      (SETQ NOTFLG NIL)
	      (GO NEXT1))
	    ((AND OPRFLAG (NULL BROADSCOPE)
		  (ZEROP ANGCNT))               (* Finished. E.g.
                                                A*B (--))
	      (OR ENDTAIL (SETQ ENDTAIL CURRTAIL))
	      (GO OUT))
	    ((SETQ CURRTAIL (CDR (SETQ CURRTAIL-1 CURRTAIL)))
                                                (* E.g. A* (--))
	      (SETQ OPRFLAG T)
	      (SETQ NOTFLG NIL)
	      (GO NEXT1))
	    (T (GO OUT)))
      NEXT2                                     (* (CAR CURRTAIL) is an 
                                                operaaor. CLTYP1 is its 
                                                CLISPTYPe.)
          (SELECTQ (CAR CURRTAIL)
		   (<(SETQ ANGCNT (ADD1 ANGCNT)))
		   (> (COND
			((ZEROP ANGCNT)
			  (SETQ CLISPERTYPE (LIST (QUOTE >)
						  PARENT))
			  (ERROR!)))
		      (SETQ ANGCNT (SUB1 ANGCNT)))
		   [-(COND
		       ((NULL (CLUNARYMINUS? OPRFLAG))

          (* The minus is biary. SEe comments at earlier call to 
          CLUNARYMINUS? in CLSPATOM1.)


			 (/RPLNODE CURRTAIL (QUOTE +-)
				   (CDR CURRTAIL))
			 (SETQ CLTYP1 (GETP (QUOTE +-)
					    (QUOTE CLISPTYPE]
		   [(-> =>)
		     (COND
		       ((EQ TYP (QUOTE :))
			 (SETQ CLTYP CLTYP1)
			 (GO NEXT3))
		       (T (SETQ CLISPERTYPE (CAR CURRTAIL))
			  (ERROR!]
		   NIL)
          (COND
	    (ENDTAIL)
	    [(NULL TYP)                         (* This is the first operator.)
	      (SETQ TYP (CAR CURRTAIL))
	      (SETQ CLTYP CLTYP1)
	      (SETQ BROADSCOPE (GETP TYP (QUOTE BROADSCOPE)))
	      (SETQ NOTFLG (EQ (GETP TYP (QUOTE LISPFN))
			       (QUOTE NOT]
	    (NOTFLG 

          (* NOTFLG is true when we are processing a NOT opeator, and 
          it immediately precedes the current operator.
          In this case, the scope of the NOT is the scope of the next 
          opeator, e.g. (X ~GR FOO Y))


		    (SETQ CLTYP CLTYP1)
		    (SETQ BROADSCOPE (GETP (CAR CURRTAIL)
					   (QUOTE BROADSCOPE)))
		    (SETQ NOTFLG (EQ (GETP (CAR CURRTAIL)
					   (QUOTE LISPFN))
				     (QUOTE NOT)))

          (* So that NOTFLG is not turned off when there are two ~'s 
          in a row, e.g. (X ~~GR FOO Y OR Z))


		    )
	    ((STOPSCAN? CLTYP1 CLTYP (CAR CURRTAIL)
			OPRFLAG)

          (* This operator delimits the scope of the first operator 
          found. Set ENDTAIL to be the first thing not within the 
          scope of the operator. The AND is so that a unary operator 
          will terminate the scope of a binary operator that has a 
          right hand operand, e.g. X+Y -Z, X_Y 'Z, etc.)


	      (SETQ ENDTAIL CURRTAIL)))
      NEXT3
          (SETQ OPRFLAG (EQ (CAR CURRTAIL)
			    (QUOTE >)))         (* OPRFLAG is T aater > since no
                                                right hand operand is reuired.)
          (COND
	    ((SETQ CURRTAIL (CDR (SETQ CURRTAIL-1 CURRTAIL)))
	      (GO NEXT1)))
      OUT                                       (* We are finished scanning.
                                                Now call CLISPATOM2 to assemble 
                                                the correct form.)
          (COND
	    ((NEQ (CAR TAIL)
		  TYP)
	      (GO OUT1))
	    ((GETP TYP (QUOTE UNARYOP))
	      (GO OUT1))
	    ((OR (EQ PARENT TAIL)
		 (EQ SUBPARENT TAIL))           (* E.g. (+ X) or 
                                                (SETQ Y + X))
	      (SETQ CLISPERTYPE (LIST 1 TAIL PARENT))
	      (ERROR!)))
          (SETQ TAIL (NLEFT (OR SUBPARENT PARENT)
			    1 TAIL))

          (* SUBPARENT can be used to mark that point in a list beyond 
          which not to back up, e.g. (LAMBDA 
          (X) FOO X LT Y))


          (SETQ BACKUPFLG T)
      OUT1(CLISPATOM2)
          [COND
	    ((SETQ CLTYP (GETP (SETQ TYP (CAR ENDTAIL))
			       (QUOTE CLISPTYPE)))
	      (SETQ TEM (CLISPATOM1A TYP CLTYP TAIL))
	      (COND
		((OR DWIMIFYFLG (EQ TEM PARENT))
		  (SETQ TAIL TEM]               (* COMMENT)
      OUT2(SETQ TEM (COND
	      ((AND (NULL FORMSFLG)
		    (EQ TAIL PARENT))
		T)
	      (T TAIL)))
          (COND
	    (DWIMIFYFLG (SETQ NEXTAIL TEM))
	    (BACKUPFLG (SETQ NEWTAIL TEM)))
          [SETQ TEM (COND
	      ((AND (NULL FORMSFLG)
		    (OR (NULL PARENT)
			(EQ TAIL PARENT)))
		TAIL)
	      (T (CAR TAIL]
          (COND
	    ((AND TENTATIVE (NEQ TENTATIVE (QUOTE CERTAINLY)))

          (* Tentative is set to CERTAINLY when we are sure the 
          correction will be CLISP, and to avoid somebody else setting 
          to T %. IN this casse there will be no message.
          This occurs when a message has already been printed, e.g. in 
          X*FOO Y , when user is asked FOO Y -> 
          (FOO Y), the approveal of the CLISP transformation is 
          implicit.)


	      (SETQ CLISPCHANGES (LIST TEM (CLISPATOM1B)
				       TAIL CURRTAIL TENTATIVE NOFIXVARSLST0))
	      (AND DWIMIFYFLG (SETQ CLISPCHANGE NIL))
	      (ERROR!)))
          (RETURN TEM)
      OPR                                       (* We have hit an operator 
                                                inside of an atom.)
          (COND
	    ((NEQ L LST0)
	      (SETQ TEM (PACK (LDIFF LST0 L)))
                                                (* Collects characters to the 
                                                right of the last operator in 
                                                the atom.)
	      (AND (NEQ (CAR L)
			(QUOTE _))
		   (CL89CHECK TEM))
	      (COND
		((AND (FLOATP TEM)
		      (OR (EQ (CAR L)
			      (QUOTE +))
			  (EQ (CAR L)
			      (QUOTE +-)))
		      (EQ (CAR (NLEFT LST0 1 L))
			  (QUOTE E)))           (* E.G. X+1.0E-5*Y)
		  (AND (EQ (CAR L)
			   (QUOTE +-))
		       (FRPLACA L (QUOTE -)))
		  (GO LP1)))
	      (SETQ ATMS (NCONC1 ATMS TEM))
	      (SETQ NOTFLG NIL)))
          (SETQ ATMS (NCONC1 ATMS (CAR L)))
          [COND
	    (ENDTAIL)
	    [(NULL TYP)                         (* First operator.)
	      (SETQ TYP (CAR L))
	      (SETQ CLTYP CLTYP1)
	      (SETQ BROADSCOPE (GETP TYP (QUOTE BROADSCOPE)))
	      (SETQ NOTFLG (EQ (GETP TYP (QUOTE LISPFN))
			       (QUOTE NOT]
	    [NOTFLG 

          (* It is not only necessary that we are processing a NOT, 
          but that it immediately precede the current operator.)


		    (SETQ CLTYP CLTYP1)
		    (SETQ BROADSCOPE (GETP (CAR L)
					   (QUOTE BROADSCOPE)))
		    (SETQ NOTFLG (EQ (GETP (CAR L)
					   (QUOTE LISPFN))
				     (QUOTE NOT]
	    ((STOPSCAN? CLTYP1 CLTYP (CAR L)
			(OR (NEQ L LST0)
			    OPRFLAG))

          (* This operator delimits the scope of the first operator 
          found. Set ENDTAIL to be the first thing not within the 
          scope of the operator.)


	      (SETQ ENDTAIL (COND
		  ((EQ L LST)

          (* The scope delimiting operator was the first thing in an 
          atom, e.g. A*B +C or A*B + C.)


		    CURRTAIL)
		  (T (FLAST ATMS]
          (SETQ OPRFLAG (EQ (CAR L)
			    (QUOTE >)))         (* OPRFLAG is T aater > since no
                                                right hand operand is reuired.)
          (COND
	    ([AND (CDR L)
		  CURRTAIL
		  (OR (EQ (CAR L)
			  (QUOTE >))
		      (EQ (CAR L)
			  (QUOTE ~]

          (* So that the rest of the atom will be looked at as a unit 
          before being unpacked, e.g. ~GR, want to look up GR.
          Also want to look at rest of atom as a unit following >, 
          e.g. FOO_<A B>EQUAL C. By starting over with a new atom, we 
          also perform the OPRFLAG terminating check, as in FOO_<A 
          B>C.)


	      (/RPLNODE CURRTAIL (CAR CURRTAIL)
			(CONS (PACK (CDR L))
			      (CDR CURRTAIL)))
	      (SETQ L NIL)))
          (SETQ 89FLG NIL)
          (SETQ LST0 (CDR L))
          (SETQ L (AND (NEQ (CAR L)
			    (QUOTE '))
		       (CDR L)))

          (* Following a ' no operaars are recognized in the rest of 
          the atm.)


          (GO LP])

(CLRPLNODE
  [LAMBDA (X A D)
    (PROG ((L (CDR UNDOSIDE)))
          (COND
	    (NOSAVEFLG                          (* X is not contained in 
                                                original expression, so don't 
                                                bother to save)
		       (GO OUT)))
      LP  (COND
	    ((EQ L (CDR UNDOSIDE0))             (* X hass not previously been 
                                                saved)
	      (/RPLNODE X A D)
	      (RETURN X))
	    ((NEQ X (CAAR L))

          (* If X is EQ to CAR of one of the entries on UNDOOSIDE, 
          then the contents of this node have already been saved, so 
          it is ok to smash it.)


	      (SETQ L (CDR L))
	      (GO LP)))
      OUT (FRPLACA X A)
          (FRPLACD X D)
          (RETURN X])

(STOPSCAN?
  [LAMBDA (CLTYPX CLTYP OPR OPRFLAG)

          (* STOPSCAN? is T if operator corresponding to CLTYPX would 
          stop scan for operator corresponding to CLTYP, i.e. if 
          former is of lower or same precedence as latter.)


    (AND CLTYPX CLTYP (PROG NIL
			    (COND
			      (BROADSCOPE (COND
					    ((OR (EQ OPR (QUOTE <))
						 (EQ OPR (QUOTE >)))
					      (RETURN NIL)))
                                                (* If BROADSCOPE, only stops 
                                                scan if precdence is less than 
                                                or equal.)
					  )
			      ((EQ OPR (QUOTE >))
				(RETURN (AND (EQ TYP (QUOTE <))
					     (ZEROP ANGCNT)))

          (* If TYP is not <, this jus indicates the end of an 
          operand, i.e <> is simply viewed as bracketing.
          E.g. could be X_<...>=Y in which case scan would not stop, 
          or X_<...> FOO in which case scan would be stopped by virtue 
          of OPRFLAG getting set to T and the check on OPRFLAG in 
          clispatom1.)


				)
			      ((GETP OPR (QUOTE UNARYOP))
				[RETURN (AND OPRFLAG
					     (EQ ANGCNT (COND
						   ((EQ OPR (QUOTE <))
                                                (* E.G. A+B <C>)
						     1)
						   (T 0]

          (* If OPRFLAG is NIL, we have just seen a unary operator 
          with no operand, so under no circumstance stop the scan.
          E.g. X*-Y. Note that this does NOT say do not consider next 
          operand as possible operatr, so that X*-+Y will generate an 
          error, not try to multiply X by 
          (minus +). The case whee the unary operaar is ' is handled 
          specially in CLISPATOM1 and CLISPATOM1A.)


				))
			    (RETURN (AND (ZEROP ANGCNT)
					 (NOT (ILESSP (COND
							((ATOM CLTYP)
							  CLTYP)
							(T (CDR CLTYP)))
						      (COND
							((ATOM CLTYPX)
							  CLTYPX)
							(T (CAR CLTYPX])

(CLUNARYMINUS?
  [LAMBDA (OPRFLAG)

          (* True if minus is unary. This is the case when either 
          (1) it immediately follows an operator 
          (the (AND TYP (NULL OPRFLAG)) check) or 
          (2) it is the first thing in a list 
          (the (EQ CURRTAIL SUBPARENT) check) or else, car of form is 
          a function and not a variable, and -
          negates its first argument. The case where car of form is 
          amisspeleed function is handled, because the tentatitve 
          correction for binry minus will be tried, and then when 
          spelling correction on function name suceeds, this will be 
          implemeneted. then there will be another call to clispatom 
          when its aagument is evaluated, and this time the functionis 
          spelled right. Note that the cse where car of a form is a 
          misspelled variable works also, even when the variabl could 
          be confusec for a function, since the correction on the 
          variable is tried first.)


    (PROG (TEM)
          (RETURN
	    (OR
	      (AND TYP (NULL OPRFLAG))
	      (EQ CURRTAIL SUBPARENT)
	      (AND
		(EQ CURRTAIL (CDR SUBPARENT))
		(FNTYP (CAR SUBPARENT))
		(OR (LISTP (CAR SUBPARENT))
		    (CLISPNOTVARP (CAR SUBPARENT)))
		(OR
		  TYPE-IN?
		  (FIXSPELL1
		    [CONS (CAR SUBPARENT)
			  (CONS (CADR SUBPARENT)
				(NCONC [AND (EQ (CADR SUBPARENT)
						(QUOTE -))
					    (LIST (RETDWIM2 (CADDR SUBPARENT]
				       (RETDWIM2 (CDDR (COND
							 ((EQ (CADR SUBPARENT)
							      (QUOTE -))
							   (CDR SUBPARENT))
							 (T SUBPARENT]
		    (QUOTE "THE %"-%" IS UNARY")
		    (QUOTE " ")
		    T])

(CLISPATOM1A
  [LAMBDA (TYP CLTYP TAIL NOSAVEFLG)

          (* This function is similar to CLISPATOM1 except that 
          elements of TAIL do not have to be unpacked.
          It is called from either CLISPATOM1 or CLISPATOM2 when more 
          than one operator was encountered in a cluster.
          CADR of TAIL is TYP, the next operator to be processed, and 
          CLTYP is its CLISPTYPE. CLISPATOM1A scans down TAIL looking 
          for the right hand boundary of TYP, but does not unpack any 
          atoms. It then calls CLISPATOM2 to assemble the form, and 
          then if necessary repeats the process.
          For example, if the original cluster was A+B*C, the call to 
          CLISPATOM2 from CLISPATOM1 would replace this with 
          (IPLUS A B * C). CLISPATOM2 would then call CLISPATOM1A with 
          TAIL= (B * C). Similary, if the original cluster were A*B+C, 
          the call to CLISPATOM2 from CLISPATOM1 would replace this 
          with (ITIMES A B) with + C having been spliced into the 
          tail. CLISPATOM1 would then call CLISPATOM1A with TAIL= 
          ((ITIMES A B) + C ...))


    (PROG (ENDTAIL OPRFLAG BROADSCOPE CLTYP0 ANGCNT)
      TOP (SETQ ANGCNT (COND
	      ((EQ TYP (QUOTE <))
		1)
	      (T 0)))
          [SETQ ENDTAIL (COND
	      ((EQ TYP (CAR TAIL))              (* TYP is car of TAIL for unary 
                                                operatrs, CADR for binary.)
		TAIL)
	      (T (CDR TAIL]
          [COND
	    ([AND (EQ TYP (QUOTE ~))
		  (SETQ CLTYP0 (GETP (CADR ENDTAIL)
				     (QUOTE CLISPTYPE]
	      (SETQ CLTYP CLTYP0)
	      (SETQ ENDTAIL (CDR ENDTAIL]
          (SETQ BROADSCOPE (GETP TYP (QUOTE BROADSCOPE)))
          (SETQ OPRFLAG NIL)
      LP  [COND
	    ((EQ (CAR ENDTAIL)
		 (QUOTE '))
	      (SETQ ENDTAIL (CDDR ENDTAIL))
	      (SETQ OPRFLAG T))
	    (T (SETQ ENDTAIL (CDR ENDTAIL]
          (COND
	    ((NULL ENDTAIL)
	      (GO OUT))
	    ((SETQ CLTYP0 (GETP (CAR ENDTAIL)
				(QUOTE CLISPTYPE)))
	      (SELECTQ (CAR ENDTAIL)
		       (<(SETQ ANGCNT (ADD1 ANGCNT)))
		       (> (COND
			    ((ZEROP ANGCNT)
			      (SETQ CLISPERTYPE (LIST (QUOTE >)
						      PARENT))
			      (ERROR!)))
			  (SETQ ANGCNT (SUB1 ANGCNT)))
		       NIL)
	      (AND (STOPSCAN? CLTYP0 CLTYP (CAR ENDTAIL)
			      OPRFLAG)
		   (GO OUT))
	      (SETQ OPRFLAG (EQ (CAR ENDTAIL)
				(QUOTE >)))     (* E.g. X_<A B> see comment in 
                                                CLISPATOM1)
	      )
	    ((AND OPRFLAG (ZEROP ANGCNT)
		  (NULL BROADSCOPE))
	      (GO OUT))
	    (T (SETQ OPRFLAG T)))
          (GO LP)
      OUT (CLISPATOM2)
          (COND
	    ((SETQ CLTYP (GETP (SETQ TYP (CAR ENDTAIL))
			       (QUOTE CLISPTYPE)))

          (* E.g. A+B*C+D. The first call to CLISPATOM1A is with TAIL 
          (B * C + D). The first call to CLISPATOM2 changes this to 
          ((ITIMES B C) + D), and then we loop back to the top of 
          CLISPATOM1A.)


	      (GO TOP)))
          (AND TENTATIVE (SETQQ TENTATIVE PROBABLY))

          (* Don't consider another interpretation if there are two or 
          more CLISP operators in this cluster.)


          (RETURN TAIL])

(CLISPATOM1B
  [LAMBDA NIL                                   (* Copies changes.)
    (PROG ((L UNDOSIDE)
	   (L1 (CDR UNDOSIDE0))
	   LST)
      LP  [COND
	    ((EQ (SETQ L (CDR L))
		 L1)
	      (RETURN LST))
	    ((LISTP (CAAR L))
	      (SETQ LST (CONS (CONS (CAAR L)
				    (CONS (CAAAR L)
					  (CDAAR L)))
			      LST)))
	    ((EQ (CAAR L)
		 (QUOTE /PUTHASH))              (* Pattern match.)
	      (SETQ LST (CONS (LIST (QUOTE /PUTHASH)
				    (CADAR L)
				    (GETHASH (CADAR L)
					     CLISPARRAY)
				    CLISPARRAY)
			      LST]
          (GO LP])

(CL89CHECK
  [LAMBDA (X)

          (* Checks to see if an 8 or a 9 was seen inside of what 
          looks like an unbound atom, e.g. N*8FOO, where 8FOO is not 
          bound. In this case, must do the 8-9 fix before the infix 
          transformation.)


    (AND 89FLG CURRTAIL (LITATOM X)
	 (CLISPNOTVARP X)
	 (COND
	   ((FIX89A (CAR CURRTAIL)
		    (CAR 89FLG)
		    (IMINUS (LENGTH 89FLG)))

          (* LENGTH is used to specify the position of the 8 or 9 in 
          the atom, since thee may be more than one.)


	     (ERROR!)

          (* This undoes all the changes made inCLISPATOM1.
          When control gets back to CLISPATOM0, iit will know to call 
          FIX89 because 89FLG is not NIL.)


	     )
	   (T (SETQ 89FLG NIL])

(CLISPATOM2
  [LAMBDA NIL                                   (* Assembles LISP forms from the
                                                CLISP expressions)
    (PROG ((PARENT PARENT)
	   VAR1 VAR2 Z (UNARYFLG (GETP TYP (QUOTE UNARYOP)))
	   (LISPFN (GETP TYP (QUOTE LISPFN)))
	   TEM NEGFLG)
          (AND (NEQ TYP (CAR TAIL))
	       UNARYFLG
	       (SETQ TAIL (CDR TAIL)))

          (* On calls from CLISPATOM1A, TYP is always CADR of TAIL.
          e.g. in X+Y 'Z, on the call to CLISPATOM2 to process ', TAIL 
          would be (IPLUS X Y) ' Z.)


          [COND
	    ((EQ (CAR ENDTAIL)
		 (QUOTE >))
	      (SETQ TEM ENDTAIL)
	      (SETQ ENDTAIL (CDR ENDTAIL]
          [COND
	    ((NULL (CDR TAIL))
	      (SETQ CLISPERTYPE 1)
	      (ERROR!))
	    ((NULL ENDTAIL))
	    [(AND (NULL FORMSFLG)
		  (GETP (CAR ENDTAIL)
			(QUOTE CLISPTYPE)))
	      (COND
		((NEQ TAIL PARENT))
		([OR (NULL (GETP (CAR ENDTAIL)
				 (QUOTE UNARYOP)))
		     (AND (EQ (CAR ENDTAIL)
			      (QUOTE ~))
			  (GETP (CADR ENDTAIL)
				(QUOTE CLISPTYPE]
                                                (* X+Y~=Z is OK.)
		  )
		((AND UNARYFLG (CLISPATOM2C TAIL))
                                                (* E.G. (~FOO 'X Y) is OK.)
		  )
		(T                              (* E.G. (X + Y ' Z))
		   (SETQ CLISPERTYPE (LIST 2 TAIL PARENT))
		   (ERROR!]
	    [(AND (NULL FORMSFLG)
		  (EQ PARENT TAIL))

          (* An missing operand error is going to be generated if 
          something isnt done in the next COND, e.g 
          (X*Y Z))


	      (COND
		((AND ENDTAIL (EQ CLISPCONTEXT (QUOTE IF))
		      (CLISPRESPELL ENDTAIL CLISPIFWORDSPLST))
		  (RETEVAL (RETDWIM0 (QUOTE CLISPIF0))
			   (QUOTE (PROGN (SETQ CLISPRESPELL T)
					 NIL))
			   T))
		((AND ENDTAIL (CLISPRESPELL ENDTAIL CLISPINFIXES))

          (* E.g. (X + Y LSS Z). Note that we do not try to correct 
          spelling on infixes unless the form is otherwise going to 
          cause an eror, e.g. in (FOO X_Y ORR --), the ORR is not 
          checked for here. Thus in the event that the next thing on 
          ENDTAIL is a CLISP transformation, e.g. 
          (FOO X_Y Z_W), we do not have to do any extra work.
          This algorithm contains the implicit assumption that all the 
          operatrs on CLISPINFIXES (i.e. the ones we correct for) will 
          terminate the scope of all non-broadscope operators.
          Otherwise, if FOO is a non-broadscope operator, and FIE 
          would not terminate FOO, and FIE is on CLISPINFIXES, the 
          form (LIST A FOO B FIEE C) would parse as 
          (LIST (A FOO B) FIE C), which is wrong.
          In this case, not only would we have to backup to CLISPATOM1 
          using RETEVAL as in CLIPATOMB, we would also have to check 
          for misspelled operaaors appearng in CAR of ENDTAIL even 
          when an error would not otherwise be generated, e.g. in 
          (LIST X_Y Z_W) we would have to check the spelling of Z_W.
          Note that when the current operator is broadscope, we always 
          perform spelling correction (via the call to DWIIFY! in 
          CLISPTOM2B) since once parentheses are inserted, we can't 
          distinguish e.g. (X AND Y ORR Z) from 
          (X AND (Y ORR Z)).)


		  )
		([CLISPATOM2C (COND
				(UNARYFLG TAIL)
				(T (CDR TAIL]   (* E.G. FOO_GETP 'FIE 'EXPR)
		  )
		(T                              (* E.g. (LIST * X Y))
		   (SETQ CLISPERTYPE (LIST 2 TAIL PARENT))
		   (ERROR!]
	    ((CLISPATOM2C (COND
			    (UNARYFLG TAIL)
			    (T (CDR TAIL]
          (COND
	    ((EQ TYP (QUOTE <))

          (* Note that as currently implemented, ENDTAIL can be NIL.
          i.e. there is no check for whether or not matching > where 
          actually found. This enables user to insert expressions like 
          <<X <Y and terminate them with a %] instead of having to 
          balance out the angle brackets.)


	      [PROG [(CLISPCONTEXT (AND DWIMIFYFLG (EQ CLISPCONTEXT
						       (QUOTE IF))
					CLISPCONTEXT))
		     WORKFLAG
		     (NCONCLKUP (CLISPLOOKUP (QUOTE NCONC)))
		     (NCONC1LKUP (CLISPLOOKUP (QUOTE NCONC1]

          (* IFCONTEXT is preserved because in the case of an unpaired 
          <, i.e., if CAR of ENDTAIL was not >, the scope may include 
          the entire IF statement, e.g. IF A THEN <B C ELSSE D If we 
          generated an error when there was no matching <, then 
          IFCONTEXT could be bound to NIL here.
          This is not done in order that angle brackets can be closed 
          with a ")" or "]", e.g. typing in << -- < -- "]")


		    (SETQ TEM (SHRIEKER (DWIMIFY2? (SETQ TEM
						     (LDIFF (CDR TAIL)
							    TEM))
						   TEM NIL T]

          (* DWIMIFYING must be done before SHRIEKER is called, since 
          it expects each individual member of the lst to correspond 
          to a single unit.)


	      (COND
		((AND (NULL ENDTAIL)
		      (NULL FORMSFLG)
		      (OR (NULL PARENT)
			  (EQ PARENT TAIL)))
		  (CLRPLNODE TAIL (CAR TEM)
			     (CDR TEM))
		  (SETQ TEM T))
		(T (CLRPLNODE TAIL TEM ENDTAIL)
		   (SETQQ TEM PARTIAL)))
	      (AND DWIMIFYFLG (SETQ CLISPCHANGE TEM))
	      (GO OUT)))
      TOP [COND
	    ((EQ TYP (QUOTE ~))
	      (COND
		((NEQ (CAR TAIL)
		      TYP)

          (* In most cases, CAR TAIL will be TYP.
          However, can also case where user leaves out a space, e.g. 
          (LIST~X Y) or (X~MEMB Y) or (X~=Y). Performing this check 
          simplifies the code considerably.)


		  (SETQ TAIL (CDR TAIL))
		  (SETQ UNARYFLG T)))
	      (COND
		((EQ TAIL PARENT)

          (* E.g. (~ FOO X) or (~ X) or (~FOO XXA) or 
          (~X))


		  )
		([OR (EQ (SETQ TEM (CADR TAIL))
			 (QUOTE ~))
		     (AND (GETP TEM (QUOTE CLISPTYPE))
			  (NOT (GETP TEM (QUOTE UNARYOP]

          (* E.G. (X ~MEMB Y), or (X~MEMB Y), i.e. ~ is being used to 
          negate an operator.)


		  (SETQ BACKUPFLG T)
		  (SETQ TAIL (NLEFT PARENT 1 TAIL))
		  (CLRPLNODE TAIL (CAR TAIL)
			     (CDDR TAIL))       (* Remove the NOT.)
		  (SETQ UNARYFLG NIL)
		  (SETQ TYP (CADR TAIL))
		  (SETQ LISPFN (GETP TYP (QUOTE LISPFN)))
		  (SETQ NEGFLG (NOT NEGFLG))
		  (GO TOP))
		((CLISPRESPELL (CDR TAIL)
			       CLISPINFIXES)    (* E.G. X ~GRR Y AND Z.)
		  (COND
		    ([SETQ TEM (FASSOC TEM (GET LISPXHIST (QUOTE RESPELLS]
		      (LISPXPUT
			(QUOTE RESPELLS)
			[LIST (CONS (PACK (LIST TYP (CAR TEM)))
				    (CONS (PACK (LIST TYP (CADR TEM)))
					  (CDDR TEM]
			T LISPXHIST)            (* So CLISPATOM0 can find the 
                                                place to make tte correction.)
		      ))
		  (RETEVAL (RETDWIM0 (QUOTE CLISPATOM1))
			   (QUOTE (PROGN (SETQ CLISPRESPELL T)
					 (ERROR!)))
			   T]
          (COND
	    ((EQ ENDTAIL (CDR TAIL))

          (* Occurs when a unary operator is immediately followed by 
          another operatr, e.g. X='+ or -*X.
          In former case, ' will be transformed above in CLISPATOM.
          Note that ' MUST be a CLISP operator in order for things 
          like FOO_' (--) to work.)


	      (SETQ CLISPERTYPE 2)
	      (ERROR!)))
      A   (SETQ VAR2 (LDIFF (COND
			      (UNARYFLG (CDR TAIL))
			      (T (CDDR TAIL)))
			    ENDTAIL))
          [COND
	    (BROADSCOPE (CLISPATOM2B TYP VAR2)

          (* Inserts parentheses, e.g. converts 
          (FFO X AND FIE Y) to ((FOO X) AND 
          (FIE Y)) Note that this must be done at this point because 
          once AND is made CAR of parent, subsequent AND's inside no 
          longer have broad scope, e.g. after 
          (A AND FOO X AND FIE Y) becomes 
          (AND A (FOO X) AND (FIE Y)) the second AND cannot have broad 
          scope or it would gobble everything back to the first AND.)


			(COND
			  ((NEQ TAIL (OR SUBPARENT PARENT))
			    (SETQ TEM (OR SUBPARENT PARENT))

          (* SUBPARENT can be used to mark that point in a list beyond 
          which not to back up, e.g. (LAMBDA 
          (X) FOO X LT Y))


			    (CLRPLNODE TEM (LDIFF TEM (CDR TAIL))
				       (CDR TAIL))
			    (SETQ BACKUPFLG T)
			    (SETQ TAIL TEM]
          (SETQ VAR1 (CAR TAIL))
          (SELECTQ
	    TYP
	    (:(SETQ Z (CLISPCAR/CDR (SETQ TEM VAR2)))

          (* the value returned by CLISPCAR/CDR indicates whether 
          there was more than one operator involved, and is used to 
          set CLISPCHANGE below.)


	      (SETQ TEM (CLISPATOM2D NIL VAR1))
                                                (* Inserts new expressioninto 
                                                TAIL.)
	      (COND
		(DWIMIFYFLG (AND CLISPCHANGE (GO OUT))
			    (SETQ CLISPCHANGE TEM))
		((NOT (ATOM (CADR VAR2)))
		  (GO OUT)))
	      (CLISPATOM2A (CDR VAR2)
			   VAR2)
	      (AND TENTATIVE Z (SETQQ TENTATIVE PROBABLY))
                                                (* Means there was more than one
                                                : operator.)
	      (GO OUT))
	    (_[COND
		((NLISTP VAR1)
		  (SETQ TEM TYP))
		(T                              (* _ in connection with a : 
                                                operator.)
		   [SETQ TEM (SELECTQ (CAR VAR1)
				      (CAR (QUOTE RPLACA))
				      (CDR (QUOTE RPLACD))
				      ((NCONC NCONC1)
					(CAR VAR1))
				      ((replace REPLACE)
                                                (* From record declaration 
                                                assigmnent.)
					(CLISPATOM2D NIL (CLISPRECORD VAR1 VAR2 
								      T))
					(GO C1)

          (* Where the right hand operand to the _ will be DWIMIFIED, 
          and TENTATIVE set, etc.)


					)
				      (COND
					((SETQ TEM (GETP (CAR VAR1)
							 (QUOTE SETFN)))

          (* E.G. User converts X|FOO to 
          (GETP X FOO), and puts PUT on SETFN of GETP, so that X|FOO_T 
          becomes (PUT X FOO T))


					  (CLISPATOM2D
					    NIL
					    (CONS (CLISPLOOKUP TEM
							       (CADR VAR1))
						  (APPEND (CDR VAR1)
							  VAR2)))

          (* SETFN. Must be handled this way because VAR1 may 
          correspond to more than one operand, e.g. X|FOO_T -> 
          (ELT X FOO) _T and must go to (SETA X FOO T))


					  (GO C1))
					(T (SETQQ CLISPERTYPE _)
					   (ERROR!]
		   (SETQ LISPFN (GETP TEM (QUOTE LISPFN)))
		   (SETQ VAR1 (CADR VAR1]
	      (SETQ LISPFN (CLISPLOOKUP TEM VAR1 NIL LISPFN))
	      [COND
		((AND (EQ LISPFN (QUOTE SETQ))
		      (EQ (CAR VAR2)
			  (QUOTE '))
		      (NULL (CDDR VAR2)))

          (* Last AND clause to detect FOO _ ' FIE :: 2 type of 
          operations.)


		  (SETQQ LISPFN SETQQ)
		  (SETQ VAR2 (CDR VAR2]
	      (COND
		((AND TYPE-IN? (EQ VAR1 (QUOTE )))
		  (PRIN1 (QUOTE =)
			 T)
		  (PRINT (SETQ VAR1 LASTWORD)
			 T T)))
	      (GO INSERT))
	    [(LEQ LE)
	      (COND
		((NULL (FGETD TYP))
		  (SETQQ TYP GT)
		  (SETQ NEGFLG (NOT NEGFLG))
		  (SETQ LISPFN (GETP TYP (QUOTE LISPFN]
	    [(GEQ GE)
	      (COND
		((NULL (FGETD TYP))
		  (SETQQ TYP LT)
		  (SETQ NEGFLG (NOT NEGFLG))
		  (SETQ LISPFN (GETP TYP (QUOTE LISPFN]
	    NIL)
          (SETQ LISPFN (CLISPLOOKUP TYP VAR1 (CAR VAR2)
				    LISPFN))
          (COND
	    (UNARYFLG [SETQ VAR1 (COND
			  ((CDR VAR2)

          (* E.g. NOT is a unary operator which may take more than one 
          expression, e.g. NOT A = B)


			    VAR2)
			  ((AND TYPE-IN? (EQ LISPFN (QUOTE QUOTE))
				(EQ (CAR VAR2)
				    (QUOTE )))
			    (PRIN1 (QUOTE =)
				   T)
			    (PRINT LASTWORD T T))
			  (T (CAR VAR2]
		      (SETQ VAR2 NIL)
		      (GO INSERT))
	    ((NULL VAR2)                        (* E.g. (LIST A*))
	      (SETQ CLISPERTYPE 1)
	      (ERROR!)))
          [SETQ TEM (COND
	      ((AND VAR2 (NULL (CDR VAR2)))
		(CAR VAR2]                      (* TEM is the right-hand 
                                                argument, if it is a single 
                                                item.)
          (COND
	    ((SELECTQ LISPFN
		      [(ILESSP LESSP)
			(COND
			  ((EQ TEM 0)
			    (SETQQ LISPFN MINUSP]
		      [EQ (COND
			    ((EQ TEM 0)
			      (SETQQ LISPFN ZEROP))
			    ((AND VAR2 (NULL (CDR VAR2))
				  (NULL (CAR VAR2)))
			      (SETQQ LISPFN NULL]
		      [IPLUS (COND
			       ((AND (LISTP VAR1)
				     (EQ (CAR VAR1)
					 (QUOTE IPLUS)))

          (* Leave asis, so X+Y+1 goes to 
          (IPLUS X Y 1) instead of (ADD1 
          (IPLUS X Y)))


				 NIL)
			       ((EQ TEM 1)
				 (SETQQ LISPFN ADD1))
			       ((EQ TEM -1)
				 (SETQQ LISPFN SUB1]
		      [IDIFFERENCE (COND
				     ((AND (LISTP VAR1)
					   (EQ (CAR VAR1)
					       (QUOTE IPLUS))
					   (NULL (CDR VAR2)))
				       [SETQ VAR2
					 (LIST (COND
						 ((NUMBERP (CAR VAR2))
						   (MINUS (CAR VAR2)))
						 (T (LIST (QUOTE IMINUS)
							  (CAR VAR2]
				       (SETQQ LISPFN IPLUS)
				       NIL)
				     ((EQ TEM 1)
				       (SETQQ LISPFN SUB1]
		      NIL)
	      (SETQ VAR2 NIL)))
      INSERT
          (SETQ TEM (CLISPATOM2D LISPFN (CONS VAR1 VAR2)))
          (COND
	    ((AND PARENT (ATOM PARENT))
	      (CLISPATOM2A TAIL TAIL)
	      (GO OUT)))

          (* Corresponds to the case where the entire expression 
          became an atom, e.g. X~=NIL gging to X, or -
          3 going to -3.0)


          (SETQ Z (CDR PARENT))

          (* Z is used to find the operands for DWIMIFYING.
          It is now set so that CAR of it coresponds VAR1 and CADR of 
          it coresponds CAR of VAR2.)


          (COND
	    ((OR (EQ LISPFN (QUOTE QUOTE))
		 (EQ LISPFN (QUOTE SETQQ)))
	      (AND DWIMIFYFLG (SETQ CLISPCHANGE TEM))
	      (GO OUT))
	    (DWIMIFYFLG (AND CLISPCHANGE (NULL UNARYFLG)
			     (GO C1))

          (* If CLISPCHANGE is T and this is not a UNARY operation, 
          the first operand has already been dwimified.)


			(SETQ CLISPCHANGE TEM))
	    ((NOT (ATOM (CAR Z)))
	      (GO C1)))
          (AND (NEQ LISPFN (QUOTE SETQ))
	       (CLISPATOM2A Z PARENT))

          (* Dwimifies VAR1, e.g. ((A+B) *C). If CLISPCHANGE is T, 
          VAR1 has already been processed, e.g. A*B+C, becomes 
          ((ITIMES A A) + C), and the A and B have already been 
          checked by the first call to CLISPATOM2.
          VAR1 is also dwimified when running provided it is atomic.
          so that if it or VAR2 is unbound, an alternate correction 
          will be tried, e.g. mistyping a variable named FOO-1 as 
          FOOO-1.)


      C1  [COND
	    (UNARYFLG (GO C2))
	    ([AND (LISTP VAR1)
		  (EQ LISPFN (CAR VAR1))
		  (FMEMB LISPFN
			 (QUOTE (AND OR IPLUS ITIMES FPLUS FTIMES PLUS TIMES]

          (* Handles nospreads, e.g. A+B+C becomes 
          (IPLUS A B C) Note that where necessary, VAR1 has already 
          been dwimified.)


	      (CLRPLNODE Z (CADR VAR1)
			 (APPEND (CDDR VAR1)
				 VAR2]
          (SETQ Z VAR2)
          (COND
	    ((OR DWIMIFYFLG (LITATOM (CAR Z)))
	      (CLISPATOM2A Z PARENT)))
      C2  

          (* Z is now set so that it corresponds to the right hand 
          argument of the oprator.)


          (COND
	    ([AND Z (SETQ CLTYP (GETP (SETQ LISPFN (CAR Z))
				      (QUOTE CLISPTYPE]
                                                (* The second operand is itself 
                                                an operator, e.g. a+*b.)
	      (COND
		([OR (NULL (CDR Z))
		     (NULL (GETP LISPFN (QUOTE UNARYOP]

          (* The GETP check is because this is not an error if the 
          operator is unary.)


		  (SETQ CLISPERTYPE 2)
		  (ERROR!)))
	      (CLISPATOM1A LISPFN CLTYP Z ENDTAIL)

          (* If ENDTAIL is non-nil, the LDIFF copied this portion of 
          TAIL, so it is not necessary to do any saving.)


	      )
	    ((NULL (CDR Z)))
	    ((SETQ CLTYP (GETP (SETQ LISPFN (CADR Z))
			       (QUOTE CLISPTYPE)))
	      (CLISPATOM1A LISPFN CLTYP Z ENDTAIL)))
          [AND NEGFLG (CLRPLNODE PARENT (QUOTE NOT)
				 (LIST (CONS (CAR PARENT)
					     (CDR PARENT]
                                                (* An operator was negated, e.g.
                                                X ~MEMB y)
          [COND
	    ((AND (EQ (CAR PARENT)
		      (QUOTE NOT))
		  (LISTP (SETQ TEM (CADR PARENT)))
		  (SETQ TEM (SELECTQ (CAR TEM)
				     ((NOT NULL)
				       (CADR TEM))
				     (EQ (CONS (QUOTE NEQ)
					       (CDR TEM)))
				     (NEQ (CONS (QUOTE EQ)
						(CDR TEM)))
				     NIL)))

          (* Special stuff for negation. Done fter everything to take 
          care of both X~=Y, and ~ (EQ X Y) in the same way.
          Note that X~=NIl and ~ (NULL X) go to X only if the 
          expression appears in the tail.
          (X~=NIL) can't be changed to X since cant change a list ot 
          an atom.)


	      [COND
		((EQ PARENT (CAR TAIL))
		  (CLRPLNODE TAIL TEM (CDR TAIL)))
		((LISTP TEM)
		  (CLRPLNODE TAIL (CAR TEM)
			     (CDR TEM]
	      (AND TENTATIVE (SETQQ TENTATIVE PROBABLY]
      OUT (RETURN TAIL])

(CLISPLOOKUP
  [LAMBDA (WORD VAR1 VAR2 LISPFN)

          (* In most cases, it is not necessary to do a full lookup.
          This is q uick an dirty check inside of the block to avoid 
          calling CLISPLOOKUP0 It will work whenever there are no 
          local declarations.)


    (PROG (TEM CLASS CLASSDEF)
          (SETQ CLASS (GETP WORD (QUOTE CLISPCLASS)))
          (SETQ CLASSDEF (GETP WORD (QUOTE CLISPCLASSDEF)))
          [SETQ TEM (COND
	      ((AND CLASSDEF (SETQ TEM (GETLOCALDEC EXPR FAULTFN)))

          (* must do full lookup. Note that it is not necessary to do 
          a call to CLISPLOOKUP0 if word has a CLASS, but no CLASSDEF, 
          e.g. FGTP, FMEMB, etc., since if these are ued as infix 
          operators, they mean the corresponding functin regardless of 
          declaraton. I.e. The CLASSDEF property says that this is the 
          name of an infix operator. The CLASS property is used as a 
          back pointer to the name of the operator/class of which this 
          word is a member.)


		(CLISPLOOKUP0 WORD VAR1 VAR2 TEM LISPFN CLASS CLASSDEF))
	      (T (SELECTQ CLASS
			  (VALUE (RETURN (CAR WORD)))
			  ((RECORD RECORDFIELD)
			    (RETURN NIL))
			  (OR LISPFN (GETP WORD (QUOTE LISPFN))
			      WORD]
          [COND
	    ([AND (EQ (CAR CLASSDEF)
		      (QUOTE ARITH))
		  (EQ TEM (CADR CLASSDEF))
		  (OR [COND
			((NLISTP VAR1)
			  (FLOATP VAR1))
			(T (EQ (CAR VAR1)
			       (CADDR CLASSDEF]
		      (COND
			((NLISTP VAR2)
			  (FLOATP VAR2))
			(T (EQ (CAR VAR2)
			       (CADDR CLASSDEF]
	      (SETQ TEM (CADDR CLASSDEF]
          (RETURN TEM])

(GETLOCALDEC
  [LAMBDA (EXPR FN)
    (PROG (TEM)
          (RETURN (COND
		    ((AND (EQ (CAR (SETQ TEM (CADDR EXPR)))
			      (QUOTE *))
			  (EQ (CADR TEM)
			      (QUOTE DECLARATIONS:)))
		      (CDDR TEM))
		    ((EQ (CAR TEM)
			 (QUOTE CLISP:))
		      (CLISPDEC0 TEM (OR FN FAULTFN])

(CLISPATOM2A
  [LAMBDA (TAIL PARENT)
    (AND TAIL
	 (PROG ((DWIMIFYING (AND DWIMIFYFLG DWIMIFYING))
		(CLISPCONTEXT (AND DWIMIFYFLG CLISPCONTEXT))
		DWIMIFYCHANGE TEM)

          (* CLISPATOM2A sets up state variables itself rather than 
          calling DWIMIFY1? or DWIMIFY2? because it wants to be able 
          to add to NOFIXVARSLST0.)


	       (COND
		 ((NULL DWIMIFYFLG)
		   (SETQ NOFIXFNSLST0 NOFIXFNSLST)
		   (SETQ NOFIXVARSLST0 NOFIXVARSLST)))
	       (SETQ TEM
		 (COND
		   ((OR (NEQ TYP (QUOTE _))
			(EQ CLISPCONTEXT (QUOTE FOR/BIND)))
		     T)
		   ((OR (FMEMB VAR1 VARS)
			(FMEMB VAR1 NOFIXVARSLST0))
		     (QUOTE PROBABLY))
		   ([NULL (AND (EQ (CAR VAR1)
				   (QUOTE NOBIND))
			       (OR DWIMIFYING (NULL (NEWSTKSCAN VAR1 FAULTPOS)))
			       (NOT (GETP (CAR VAR1)
					  (QUOTE GLOBALVAR)))
			       (NOT (FMEMB (CAR VAR1)
					   GLOBALVARS]

          (* Added to NOFIXVARSLST0 so will be avilable for spelling 
          correction in the future.)


		     (SETQ NOFIXVARSLST0 (CONS VAR1 NOFIXVARSLST0))
		     (QUOTE PROBABLY))
		   ([AND (EQ VAR1 (CADR PARENT))
			 (NULL NOSPELLFLG)
			 (OR [AND VARS
				  (SETQ TEM
				    (FIXSPELL VAR1 70 VARS NIL NIL NIL NIL
					      (DUNPACK VAR1 SKORLST3)
					      (QUOTE MUSTAPPROVE]
			     (SETQ TEM
			       (FIXSPELL VAR1 70 SPELLINGS3 NIL NIL NIL NIL
					 (DUNPACK VAR1 SKORLST3)
					 (QUOTE MUSTAPPROVE]

          (* FIXSPELL is called instead of CLISPRESPELL because we 
          dont want runon corrections, and also we have performed msot 
          of the checks of CLISPRESPELL.)


		     (CLRPLNODE (CDR PARENT)
				TEM
				(CDDR PARENT))
		     (QUOTE CERTAINLY))
		   (T (SETQ NOFIXVARSLST0 (CONS VAR1 NOFIXVARSLST0))

          (* Added to NOFIXVARSLST0 so that it will be available for 
          spelling correction in the future.)


		      T)))
	       (RETURN (COND
			 [(LISTP (CAR TAIL))
			   (COND
			     ((NEQ CLISPCONTEXT (QUOTE LINEAR))
			       (DWIMIFY1 (CAR TAIL)))
			     (T (CAR TAIL]
			 ([AND TAIL (CAR TAIL)
			       (LITATOM (CAR TAIL))
			       (NOT (GETP (CAR TAIL)
					  (QUOTE CLISPTYPE]

          (* We already know that the atom has no operators internal 
          to it, having scanned through it earlier.)


			   (SETQ CLISPCONTEXT NIL)
			   (COND
			     ((AND (NULL (DWIMIFY2 TAIL PARENT T NIL T
						   (QUOTE NORUNONS)))
				   (NULL TENTATIVE)
				   (FMEMB TYP CLISPCHARS))
			       (SETQ TENTATIVE TEM])

(CLISPATOM2B
  [LAMBDA (TYP L)
    (PROG (TEM)
      LP  (COND
	    ((NULL (CDR L))
	      (RETURN))
	    ((EQ (CADR L)
		 TYP)
	      (SETQ L (CDDR L)))
	    ((SETQ TEM (FMEMB TYP (CDR L)))
	      (CLRPLNODE L (LDIFF L TEM)
			 TEM)
	      (DWIMIFY1? (CAR L)
			 (QUOTE INFIX))

          (* Necessary because of possible spelling errors in 
          operators, e.g. X OR Y ANDD Z. See comment at beginning of 
          CLISPATOM1.)


	      (SETQ L (CDR TEM)))
	    (T (CLRPLNODE L (CONS (CAR L)
				  (CDR L))
			  NIL)
	       (DWIMIFY1? (CAR L)
			  (QUOTE INFIX))
	       (RETURN)))
          (GO LP])

(CLISPATOM2C
  [LAMBDA (TAIL0)

          (* Checks for the case where user leaves out arentheses in 
          front of functon name that follows an operator, e.g. 
          (LIST X+ADD1 Y))


    (PROG (TEM STR)
          (SETQ TAIL0 (CDR TAIL0))              (* TAIL0 is as of the right hand
                                                operand.)
          (COND
	    ((OR (EQ TYP (QUOTE '))
		 (EQ TYP (QUOTE :))
		 (EQ TYP (QUOTE <)))
	      (RETURN NIL)))
          (COND
	    ((AND (LITATOM (CAR TAIL0))
		  (NULL (GETP (CAR TAIL0)
			      (QUOTE UNARYOP)))
		  (CLISPFUNCTION?
		    TAIL0
		    (QUOTE NOTVAR)
		    [FUNCTION (LAMBDA (X Y)
			(CONCAT [COND
				  ((EQ (CDR Y)
				       (CDAR Y))
                                                (* Unary operator)
				    (CAAR Y))
				  (T (CONCAT (RETDWIM2 (CAAR Y))
					     (COND
					       ((EQ (CADAR Y)
						    (QUOTE +-))
						 (QUOTE -))
					       (T (CADAR Y]
				(SUBSTRING (RETDWIM2 (CDR Y))
					   2 -1]
		    [FUNCTION (LAMBDA (X Y)
			(CONCAT [COND
				  ((EQ (CDR Y)
				       (CDAR Y))
                                                (* Unary operator)
				    (CAAR Y))
				  (T (CONCAT (RETDWIM2 (CAAR Y))
					     (COND
					       ((EQ (CADAR Y)
						    (QUOTE +-))
						 (QUOTE -))
					       (T (CADAR Y]
				[RETDWIM2 (COND
					    [(LISTP X)
					      (CONS (CAR X)
						    (CONS (CDR X)
							  (CDDR Y]
					    (T (CONS X (CDDR Y]
				(QUOTE ")"]
		    (CONS TAIL TAIL0)))

          (* The GETP check is for situations like 
          (LIST X_'FOO Y) i.e. a unary operator could never take care 
          of the rest of the list.)


	      (/RPLNODE TAIL0 (CONS (CAR TAIL0)
				    (CDR TAIL0)))
	      (SETQ ENDTAIL NIL)

          (* Once you print a message, you dont want to go and try 
          another interpretation.)


	      (SETQQ TENTATIVE CERTAINLY])

(CLISPATOM2D
  [LAMBDA (X Y)

          (* Inserts new expression into TAIL.
          Value is T if expression was not parenthesized, PARTIAL if 
          it was, i.e. if it corresponded to the new CAR of TAIL.
          If X is NIL, Y is the whole expression.)


    (COND
      ((AND (NULL ENDTAIL)
	    (NULL FORMSFLG)
	    (OR (NULL PARENT)
		(EQ PARENT TAIL)))

          (* This is the case in which we do not want to 'subordinate' 
          the expression with an extra pair of parentheses.
          E.g. (LIST (A+B)). The ENDTAIL check is necessary because if 
          it is not NIL, there are more expressions following the 
          first one, e.g. (LIST (A*B+C)) and we must keep this 
          expression separate, i.e. make 
          (A*B+C) become ((ITIMES A A) + C))


	(COND
	  [(NULL X)

          (* Y is the entire expression to be inserted, but we can't 
          use it because we have to "take out" the parentheses.)


	    (CLRPLNODE TAIL (CAR Y)
		       (CDR Y))
	    (AND (SETQ X (GETHASH Y CLISPARRAY))
		 (CLISPTRAN TAIL X))

          (* Must move translation to new expression.
          This only occurs if the expression is enclosed in 
          prentheses, e.g. (X: (--)))


	    ]
	  (T (CLRPLNODE TAIL X Y)))
	(SETQ PARENT TAIL)
	T)
      (T                                        (* Here we must parenthesize the
                                                expression so as to subordinate 
                                                it.)
	 [SETQ Y (COND
	     ((NULL X)
	       Y)
	     ((AND (EQ TYP (QUOTE -))
		   (NUMBERP (CAR Y)))
	       (MINUS (CAR Y)))
	     (T (CONS X Y]
	 (CLRPLNODE TAIL Y ENDTAIL)

          (* ENDTAIL being all the stuff not belonging to the CLISP 
          expression, i.e. beyond its scope.)


	 (SETQ PARENT (CAR TAIL))
	 (QUOTE PARTIAL])

(CLISPERROR
  [LAMBDA (TYPE FLG)
    (COND
      (FLG (EVQ FAULTFN)
	   (EVQ PARENT)
	   (EVQ TAIL)
	   (EVQ TYPE-IN?)))
    (PROG (TEM AT IN)
          (COND
	    ((NULL TYPE-IN?)
	      (FIXPRINTIN FAULTFN)
	      (LISPXSPACES 1 T)))
          (LISPXPRIN1 (SELECTQ [SETQ TEM (COND
				   ((ATOM TYPE)
				     TYPE)
				   (T (CAR TYPE]
			       (1 (QUOTE "missing operand"))
			       (2 (QUOTE "missing operator"))
			       ((: :: -> =>)
				 (LISPXPRIN1 (QUOTE "improper use of ")
					     T)
				 TEM)
			       (4 (QUOTE "bad if statement"))
			       (> (QUOTE "missing <"))
			       (_(QUOTE "incorrect use of _"))
			       (FIELDNAME (QUOTE "undefined field name"))
			       TEM)
		      T)
          (COND
	    ((LISTP TYPE)
	      (GO A))
	    ((NEQ PARENT TAIL)
	      (LISPXPRIN1 (QUOTE " at ")
			  T)
	      (LISPXPRIN2 (RETDWIM2 (CAR TAIL))
			  T T)))
          (LISPXPRIN1 (QUOTE " in    ")
		      T)
          (LISPXPRIN2 (RETDWIM2 PARENT TAIL)
		      T T)
          (LISPXTERPRI T)
          (RETURN)
      A   (SETQ AT (CADR TYPE))
          (SETQ IN (CADDR TYPE))
          (COND
	    ((OR (EQ AT IN)
		 (NULL IN))
	      (LISPXPRIN1 (QUOTE " in    ")
			  T)
	      (LISPXPRINT (RETDWIM2 AT)
			  T T)
	      (RETURN)))
          (LISPXTERPRI T)
          (LISPXPRIN1 (QUOTE "at    ")
		      T)
          (MAPRINT (RETDWIM2 (NLEFT IN 1 AT)
			     (CDDR AT))
		   T
		   (QUOTE "... ")
		   (QUOTE %))
		   NIL NIL T)
          (LISPXTERPRI T)
          (LISPXPRIN1 (QUOTE "in    ")
		      T)
          (LISPXPRINT (RETDWIM2 IN)
		      T T)
          (RETURN])

(CLISPCAR/CDR
  [LAMBDA (LST)                                 (* Handles the : infix operatr.)
    (PROG ((SETQFLG (EQ (CAR ENDTAIL)
			(QUOTE _)))
	   TAILFLG N TEM VAL)
          (SETQ VAR2 NIL)
      LP  (SETQ TAILFLG NIL)
          [COND
	    ((EQ (CAR LST)
		 (QUOTE :))                     (* Tail)
	      (SETQ TAILFLG T)
	      (SETQ LST (CDR LST]
          (COND
	    ((NULL LST)
	      (SETQ VAR1 (LIST (COND
				 ((NULL SETQFLG)
				   (GO ERROR))
				 (TAILFLG       (* X::_)
					  (QUOTE NCONC))
				 (T (QUOTE NCONC1)))
			       VAR1))
	      (RETURN VAL)))
          (COND
	    ((EQ (SETQ N (CAR LST))
		 (QUOTE -))
	      (COND
		([NOT (NUMBERP (SETQ N (CADR LST]
		  (GO ERROR)))
	      (SETQ N (MINUS N))
	      (SETQ LST (CDR LST))
	      (GO NEG))
	    ((NOT (NUMBERP N))
	      (COND
		(TAILFLG (GO ERROR))
		((LISTP N)
		  (SETQ VAR1 (LIST (QUOTE match)
				   VAR1
				   (QUOTE with)
				   N))
		  (COND
		    ((OR (EQ (CADR LST)
			     (QUOTE ->))
			 (EQ (CADR LST)
			     (QUOTE =>)))
		      (NCONC VAR1 (CDR LST))
		      (DWIMIFY2? (SETQ TEM (CDDR LST))
				 VAR1 TEM)
		      (SETQ LST NIL)))
		  (CLISPTRAN VAR1 (MAKEMATCH VAR1))
		  (AND (NULL VAR2)
		       (SETQ VAR2 VAR1)))
		[[SETQ TEM (CLISPRECORD VAR1 N (AND SETQFLG
						    (NULL (CDR LST]
		  (SETQ VAR1 TEM)
		  (AND (NULL VAR2)
		       (SETQ VAR2 (NLEFT VAR1 2]
		((SETQ TEM (GETP N (QUOTE ACCESSFN)))
		  (SETQ VAR1 (LIST TEM VAR1))
		  (AND (NULL VAR2)
		       (SETQ VAR2 VAR1)))
		(T (SETQQ CLISPERTYPE FIELDNAME)
		   (ERROR!)))
	      (GO LP2))
	    ((ILESSP N 0)
	      (GO NEG)))
      LP1 [COND
	    ((AND (IGREATERP N 4)
		  (ILESSP N 9))                 (* X:N for N greater than 8 goes
                                                to (NTH X N))
	      (SETQ N (IPLUS N -4))
	      (SETQ VAR1 (LIST (QUOTE CDDDDR)
			       VAR1))
	      (AND (NULL VAR2)
		   (SETQ VAR2 VAR1))

          (* VAR2 marks the TAIL where the original operand appears, 
          so thaadwimifying will continue from there.)


	      (GO LP1))
	    ((AND SETQFLG (NULL (CDR LST)))
	      (SETQ VAR1 (CLISPCAR/CDR1 1 (CLISPCAR/CDR1 (SUB1 N)
							 VAR1 T)
					TAILFLG T)))
	    (T (SETQ VAR1 (CLISPCAR/CDR1 N VAR1 TAILFLG]
      LP2 (COND
	    ((NULL (SETQ LST (CDR LST)))
	      (RETURN VAL))
	    ((EQ (CAR LST)
		 (QUOTE :))
	      (SETQ VAL T)
	      (SETQ LST (CDR LST))
	      (GO LP)))
      ERROR
          [SETQ CLISPERTYPE (COND
	      (TAILFLG (QUOTE ::))
	      (T (QUOTE :]
          (ERROR!)
      NEG (COND
	    ((AND SETQFLG (NULL (CDR LST))
		  TAILFLG)
	      [SETQ VAR1 (LIST (QUOTE NLEFT)
			       VAR1
			       (ADD1 (IMINUS N]
	      (AND (NULL VAR2)
		   (SETQ VAR2 VAR1))
	      (SETQ VAR1 (LIST (QUOTE CDR)
			       VAR1))
	      (RETURN VAL)))
          [SETQ VAR1 (COND
	      ((EQ N -1)
		(LIST (CLISPLOOKUP (QUOTE LAST)
				   VAR1)
		      VAR1))
	      (T (LIST (QUOTE NLEFT)
		       VAR1
		       (IMINUS N]
          (AND (NULL VAR2)
	       (SETQ VAR2 VAR1))
          [COND
	    ((NULL TAILFLG)
	      (SETQ VAR1 (LIST (QUOTE CAR)
			       VAR1]
          (GO LP2])

(CLISPCAR/CDR1
  [LAMBDA (N X TAILFLG SETQFLG)

          (* All three level car and cdr operations go back to the 
          corresponding function, i.e. CDAAR clispifies to X:1:1::1 
          and goes back to CDAAR.)


    (PROG (TEM)
          [SETQ TEM (COND
	      ((ZEROP N)
		(RETURN X))
	      ([AND (NULL SETQFLG)
		    (LISTP X)
		    (SETQ TEM (COND
			((EQ N 1)
			  (SELECTQ (CAR X)
				   [CAR 

          (* The apparent incompleteness of the SELECTQ is bcause CAR 
          of CDR would appear in CLISS as :2 and be handled directly, 
          similarly for CDR of CDR.)


					(COND
					  (TAILFLG (QUOTE CDAR))
					  (T (QUOTE CAAR]
				   [CAAR 

          (* Similarly, CAR of CDAR would come in as CADR of CAR, CDR 
          of CDAR as CDDR of CAR, so checks for CDAR and CDDR are not 
          necessary.)


					 (COND
					   (TAILFLG (QUOTE CDAAR))
					   (T (QUOTE CAAAR]
				   [CADR (COND
					   (TAILFLG (QUOTE CDADR))
					   (T (QUOTE CAADR]
				   NIL))
			((AND (EQ N 2)
			      (EQ (CAR X)
				  (QUOTE CAR)))

          (* CADR of CDR would be written as X:3, similaly CAAR of 
          CDR, CDAR of CDR, and CDDR of CDR are all taken care of.)


			  (COND
			    (TAILFLG (QUOTE CDDAR))
			    (T (QUOTE CADAR]
		(FRPLACA X TEM))
	      [(IGREATERP N 4)
		(SETQ TEM (CLISPLOOKUP (QUOTE NTH)
				       VAR1))
		(COND
		  (TAILFLG (LIST TEM X (ADD1 N)))
		  (T (SETQ TEM (LIST TEM X N))
		     (AND (NULL VAR2)
			  (SETQ VAR2 TEM))
		     (LIST (QUOTE CAR)
			   TEM]
	      ([NULL (SETQ TEM (FASSOC N (QUOTE ((1 CAR . CDR)
						 (2 CADR . CDDR)
						 (3 CADDR . CDDDR)
						 (4 CADDDR . CDDDDR]
		(HELP))
	      (TAILFLG (LIST (CDDR TEM)
			     X))
	      (T (LIST (CADR TEM)
		       X]
          (AND (NULL VAR2)
	       (SETQ VAR2 TEM))
          (RETURN TEM])
)
(DEFLIST(QUOTE(
  (CLISP (DWIM WTFIX CLISP DWIMIFY))
))(QUOTE FILEGROUP))
(DECLARE: DONTCOPY
  (FILEMAP (NIL (490 63235 (CLISPATOM0 502 . 2074) (CLISPATOM1 2078 . 20787)
(CLRPLNODE 20791 . 21614) (STOPSCAN? 21618 . 23627) (CLUNARYMINUS? 23631 .
25335) (CLISPATOM1A 25339 . 28619) (CLISPATOM1B 28623 . 29212) (CL89CHECK
29216 . 29996) (CLISPATOM2 30000 . 47428) (CLISPLOOKUP 47432 . 49104) (
GETLOCALDEC 49108 . 49411) (CLISPATOM2A 49415 . 51960) (CLISPATOM2B 51964
. 52600) (CLISPATOM2C 52604 . 54550) (CLISPATOM2D 54554 . 56445) (CLISPERROR
56449 . 58110) (CLISPCAR/CDR 58114 . 61338) (CLISPCAR/CDR1 61342 . 63232)))))
STOP
