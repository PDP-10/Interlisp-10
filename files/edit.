(FILECREATED "17-SEP-74 03:06:15" EDIT.;5 74241  

     changes to:  EDITL1

     previous date: "13-SEP-74 04:07:00" EDIT.;4)


  (LISPXPRINT (QUOTE EDITCOMS)
	      T T)
  [RPAQQ EDITCOMS ((FNS * EDITFNS)
	  (VARS (UPFINDFLG T)
		MAXLEVEL FINDFLAG (EDITQUIETFLG)
		(EDITLOADFNSFLG T))
	  (PROP FILEGROUP EDIT)
	  (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
		    (ADDVARS (NLAMA EDITP EDITV EDITF EDITFNS)
			     (NLAML EDITF2]
  (RPAQQ EDITFNS
	 (EDITFNS EDITF EDITF0 EDITF1 EDITF2 EDITV EDITP EDITE EDITL EDITL0 
		  EDITL1 UNDOEDITL EDITCOM EDITCOMA EDITCOML EDITMAC EDITCOMS 
		  EDIT!UNDO UNDOEDITCOM UNDOEDITCOM1 EDITCOM1 EDITSMASH 
		  EDITNCONC EDIT1F EDIT2F EDIT4E EDIT4E1 EDITQF EDIT4F EDIT4F1 
		  EDIT4F2 EDIT4F3 EDITFPAT EDITFPAT1 EDITFINDP EDITBF EDITBF1 
		  EDITNTH BPNT BPNT0 BPNT1 RI RO LI LO BI BO))
(DEFINEQ

(EDITFNS
  [NLAMBDA X

          (* FNS is a list (or name of a list) of functions to be 
          edited; (CDR X) are the operations to be performed.)


    (MAPC (EVAL (CAR X)
		(QUOTE INTERNAL))
	  (FUNCTION (LAMBDA (Y)
	      (ERSETQ (APPLY (QUOTE EDITF)
			     (CONS (PROG1 (PRIN2 Y T T)
					  (SPACES 1 T))
				   (CDR X])

(EDITF
  [NLAMBDA EDITFX
    (AND EDITFX (NLISTP EDITFX)
	 (ERRORX (LIST 25 EDITFX)))
    (PROG (EDITFN EDITFCOMS EDITFY EDITFTEM)
          (SETQ EDITFN (CAR EDITFX))
      LP  (SETQ EDITFCOMS (CDR EDITFX))
          [COND
	    ((LISTP EDITFN)
	      (SETQ EDITFN (EVAL EDITFN]
          (COND
	    ((EXPRP (SETQ EDITFY (GETD EDITFN)))
	      (COND
		[(NULL (SETQ EDITFTEM (GETLIS (CDR EDITFN)
					      (QUOTE (BROKEN ADVISED]
		([OR (EXPRP (CADR EDITFTEM))
		     (NULL (GETP EDITFN (QUOTE EXPR]

          (* If the unadvsed or unbroken definitioon is an expr, allow 
          user to edit it, since his edits will also affect the 
          original definition. If the pristine definition is not an 
          EXPR, and there is also not an EXPR defiition on the proprty 
          list, nothing else to do but let him edit it.
          IN both cases alert him.)


		  (PRIN1 (QUOTE "Note: you are editing a")
			 T)
		  (AND (EQ (CAR EDITFTEM)
			   (QUOTE ADVISED))
		       (PRIN1 (QUOTE n)
			      T))
		  (SPACES 1 T)
		  (PRIN2 (CAR EDITFTEM)
			 T T)
		  (PRIN1 (COND
			   ((EXPRP (CADR EDITFTEM))
			     (QUOTE " definition."))
			   ((SUBRP (CADR EDITFTEM))
			     (QUOTE " subr!"))
			   (T (QUOTE " compiled function!")))
			 T)
		  (TERPRI T))
		([OR (EQ (CAR EDITFTEM)
			 (QUOTE BROKEN))
		     (OR (NULL DWIMFLG)
			 (FIXSPELL1 (QUOTE "Do you want ")
				    (QUOTE " to be unadvised")
				    EDITFN NIL (QUOTE MUSTAPPROVE]
		  (VIRGINFN EDITFN T)
		  (GO LP)))
	      (/PUTD EDITFN (EDITF1 EDITFY EDITFCOMS EDITFN)))
	    ([EXPRP (SETQ EDITFY (GETP EDITFN (QUOTE EXPR]
	      (PRIN1 (QUOTE "prop ")
		     T)
	      (EDITF1 EDITFY EDITFCOMS EDITFN (QUOTE PROP)))
	    ([SETQ EDITFY
		(EDITF0 EDITFN
			(AND (NULL EDITLOADFNSFLG)
			     (QUOTE " not editable, shall I load it from "]
	      [COND
		([CDR (SETQ EDITFTEM (SUBSET (GETBLOCKDEC EDITFN EDITFY T)
					     (FUNCTION (LAMBDA (EDITFN)
						 (NOT (EXPRP (VIRGINFN EDITFN]
		  (OR
		    (FIXSPELL1
		      (QUOTE "Shall I also load the rest of the functions (")
		      (QUOTE ") in its block")
		      (SUB1 (LENGTH EDITFTEM))
		      NIL
		      (QUOTE MUSTAPPROVE))
		    (SETQ EDITFTEM NIL]
	      (LOADFNS (OR EDITFTEM EDITFN)
		       EDITFY
		       (QUOTE PROP))
	      (COND
		((GETP EDITFN (QUOTE EXPR))
		  (GO LP)))
	      (ERROR EDITFN (QUOTE "not found.")))
	    ((GETD EDITFN)                      (* User really meant to type 
                                                EDITF, not EDITV or EDITP.)
	      (GO ERROR))
	    [(LISTP (CAR EDITFN))
	      (PRINT (QUOTE =EDITV)
		     T T)
	      (RETURN (APPLY (QUOTE EDITV)
			     (CONS EDITFN EDITFCOMS]
	    [(CDR EDITFN)
	      (PRINT (QUOTE =EDITP)
		     T T)
	      (RETURN (APPLY (QUOTE EDITP)
			     (CONS EDITFN EDITFCOMS]
	    ((AND DWIMFLG (SETQ EDITFY (MISSPELLED? EDITFN 75 USERWORDS))
		  (NEQ EDITFY EDITFN))
	      (SETQ EDITFN EDITFY)
	      (GO LP))
	    (T (GO ERROR)))
          (RETURN EDITFN)
      ERROR
          (ERROR EDITFN (QUOTE "not editable.")
		 T])

(EDITF0
  [LAMBDA (FN STR)
    (PROG (FL TEM)
          (RETURN
	    (AND
	      FN DWIMFLG FILEPKGFLG (SETQ FL (CAR (WHEREIS FN (QUOTE FNS)
							   FILELST)))
	      (XNLSETQ
		[CLOSEF (SETQ FL
			  (INPUT (INFILE (COND
					   ([NULL (SETQ TEM
						    (GETP FL (QUOTE FILE]
					     (NAMEFIELD FL T))
					   ((EQ (CDAR TEM)
						(QUOTE compiled))
					     (NAMEFIELD FL))
					   [(CDAR (LISTP (GETP FL (QUOTE 
								  FILEDATES]
					   (T 

          (* the file on FILEDATES is used above because it may have 
          directory informaton.)


					      (NAMEFIELD FL T]
		NOBREAK)
	      [COND
		((NULL STR)
		  (LISPXPRIN1 (QUOTE "loading from ")
			      T)
		  (LISPXPRINT FL T T))
		(T (FIXSPELL1 FN FL STR NIL (QUOTE MUSTAPPROVE]
	      FL])

(EDITF1
  [LAMBDA (EXPR COMS ATM TYPE)

          (* Used by both EDITF and EDITV.
          Calls EDITE in such a way that if a change occurs, and EDITE 
          is exited via OK, STOP, or even conrol-D, the appropriate 
          call to NEWFILE? is executed. Since it checks to see if a 
          change has been made, it also does the UNSAVEDEFING for 
          EDITF in he case that we are editing a PROP.
          Value is the edited expression or generates an error.)


    (RESETLST (PROG (EDITCHANGES EDITFTEM)
		    [RESETSAVE NIL (CONS (QUOTE EDITF2)
					 (SETQ EDITCHANGES
					   (LIST ATM NIL TYPE]
		    (NLSETQ (SETQ EDITFTEM (EDITE EXPR COMS EDITCHANGES)))
		    (COND
		      [(CADR EDITCHANGES)       (* A change was made.)
			(FRPLACA (CDR EDITCHANGES)
				 (QUOTE UNDOABLE))
                                                (* So the call to EDITF2 in 
                                                RESETFORM will calls NEWFILE? 
                                                undoably)
			(COND
			  ((NULL EDITFTEM)
			    (ERROR!))
			  ((EQ TYPE (QUOTE PROP))
			    (UNSAVEDEF ATM)
			    (PRINT (QUOTE unsaved)
				   T T)
			    (/PUTD ATM EDITFTEM]
		      ((NULL EDITFTEM)
			(ERROR!))
		      ((EQ TYPE (QUOTE PROP))
			(PRIN1 (QUOTE "not changed, so not unsaved
")
			       T)))
		    (COND
		      (DWIMFLG (ADDSPELL ATM (SELECTQ TYPE
						      ((PROP NIL)
							NIL)
						      (T T)
						      0))

          (* TYPE is NIL or PROP for calls from EDITF, T for calls 
          from EDITV, and 0 for calls fromEDITP.
          ~TYPE can also be the name of a CHANGEDLST in the case of a 
          direct call from the user.)


			       ))
		    (RETURN EDITFTEM])

(EDITF2
  [NLAMBDA (ATM CHANGES TYPE)
    (AND FILEPKGFLG CHANGES (PROG ((LISPXHIST (AND (NEQ CHANGES T)
						   LISPXHIST)))

          (* If CHANGES is T, means control-D was typed, so want the 
          NEWFILE? not to be undoable since the edit isnt.)


			          (COND
				    ((EQ TYPE 0)
                                                (* For explanation of TYPE, see 
                                                comment in EDITF1.)
				      (RETURN))
				    ((EQ TYPE (QUOTE PROP))
				      (SETQ TYPE NIL)))
			          (NEWFILE? ATM TYPE])

(EDITV
  [NLAMBDA EDITVX
    (AND EDITVX (NLISTP EDITVX)
	 (ERRORX (LIST 25 EDITVX)))
    (PROG ((EDITVAR (CAR EDITVX))
	   EDITVY EDITCHANGESFLG)
          (COND
	    ((NOT (ATOM EDITVAR))
	      (EDITE (EVAL EDITVAR (QUOTE INTERNAL))
		     (CDR EDITVX))
	      (RETURN T)))
      TOP (COND
	    ([AND DWIMFLG (OR (NULL EDITVAR)
			      (EQ (EVALV EDITVAR)
				  (QUOTE NOBIND]
	      (COND
		[(GETD EDITVAR)
		  (PRINT (QUOTE =EDITF)
			 T T)
		  (RETURN (APPLY (QUOTE EDITF)
				 (CONS EDITVAR (CDR EDITVX]
		((SETQ EDITVY (MISSPELLED? EDITVAR 75 USERWORDS))
		  (SETQ EDITVAR EDITVY)
		  (GO TOP)))

          (* The functional argument allows user to say EDITV 
          (EDITM) meaning EDITMACROS, even though there is a 
          function called EDITMAC.)


	      ))
          (SAVESET EDITVAR (EDITF1 (EVAL EDITVAR (QUOTE INTERNAL))
				   (CDR EDITVX)
				   EDITVAR T)
		   NIL
		   (QUOTE NOSAVE))
          (RETURN EDITVAR])

(EDITP
  [NLAMBDA EDITPX
    (AND EDITPX (NLISTP EDITPX)
	 (ERRORX (LIST 25 EDITPX)))
    (PROG (ATM)
          [COND
	    ([NOT (ATOM (SETQ ATM (CAR EDITPX]
	      (RETURN NIL))
	    ((AND DWIMFLG (NLISTP (CDR ATM)))
	      (SETQ ATM (OR (MISSPELLED? ATM 75 USERWORDS)
			    ATM]
          (/RPLACD ATM (EDITF1 (CDR ATM)
			       (CDR EDITPX)
			       ATM 0))

          (* EDITP implemented via call to EDITF1 even though it does 
          not currently make use of whether or not a change has been 
          made to update file package because some users may want to 
          efffect such an operation by advising EDITE in EDITFBLOCK)


          (RETURN ATM])

(EDITE
  [LAMBDA (EXPR COMS ATM)
    (COND
      ((NLISTP EXPR)
	(ERROR EXPR (QUOTE "NOT EDITABLE.")))
      ((SETQ EXPR (LAST (EDITL (LIST EXPR)
			       COMS ATM)))
	(CAR EXPR))
      (T (HELP (QUOTE (NULL LIST])

(EDITL
  [LAMBDA (L COMS ATM MESS)                     (* Takes edit push-down list L 
                                                as argument. Returns L as 
                                                value.)
    (RESETVAR READBUF NIL
      (PROG (LASTAIL MARKLST UNDOLST UNDOLST0 UNDOLST1 UNFIND LASTP1 LASTP2 
		     TEM1 TEM2 EDITHIST0 EDITIME0 EDITCHANGES)
	    (AND (LISTP ATM)
		 (SETQ EDITCHANGES (CDR ATM))
		 (SETQ ATM (CAR ATM)))

          (* EDITCHANGES is a cell used for marking whether this edit 
          caused any changes.)


	    (COND
	      ((EQ (CAR COMS)
		   (QUOTE START))
		(SETQ READBUF (CDR COMS))
		(SETQ COMS NIL)))
	    [COND
	      ((AND ATM (NULL COMS)
		    EDITHISTORY)
		[LISPXPUT (QUOTE ENTERED)
			  (SETQ TEM1 (LIST ATM))
			  NIL
			  (CAR (SETQ EDITHIST0 (CAR EDITHISTORY]
		(SETQ EDITHIST0 (CONS EDITHIST0 TEM1))
                                                (* Marks beginning of this 
                                                session.)
		(LISPXWATCH EDITCALLS)
		(SETQ EDITIME0 (CLOCK 0]
	    (SETQ TEM2 (CAR (LAST L)))

          (* TEM2 is the top level xpression.
          NOte that L is usually a list of only one element, i.e. you 
          usually start editing atthe top, but not necessarily, since 
          editl can be called dirctly.)


	    [COND
	      ([OR
		  [EQ TEM2 (CAR (LAST (CAR (SETQ TEM1 (GETP (QUOTE EDIT)
							    (QUOTE LASTVALUE]
		  [AND ATM (EQ TEM2 (CAR (LAST (CAR (SETQ TEM1
						      (GETP ATM (QUOTE 
								  EDIT-SAVE]
		  (SOME
		    (CAR LISPXHISTORY)
		    (FUNCTION (LAMBDA (X)
			(EQ TEM2
			    (CAR (LAST (CAR (SETQ TEM1
					      (CADR (FMEMB (QUOTE EDIT)
							   X]

          (* First clause is old method of always saving last call on 
          editor property list. Second clause searches history list 
          for a call to editor corresponding to this expression.)


		(SETQ L (CAR TEM1))
		(SETQ MARKLST (CADR TEM1))
		(SETQ UNDOLST (CADDR TEM1))
		[COND
		  ((CAR UNDOLST)                (* Don't want to block it 
                                                twice.)
		    (SETQ UNDOLST (CONS NIL UNDOLST]
		(SETQ UNDOLST0 UNDOLST)

          (* Marks UNDOLST as of this entry to editor, so UNDO of this 
          entire EDIT session won't go too far back.)


		(SETQ UNFIND (CDDDR TEM1]
	    (COND
	      ([PROG1 (NLSETQ (SETQ L (EDITL0 L COMS MESS T)))
		      [COND
			(UNDOLST1 (SETQ UNDOLST (CONS (CONS T (CONS L UNDOLST1))
						      UNDOLST]
		      (COND
			((NEQ UNDOLST UNDOLST0)
			  (AND LISPXHIST (UNDOSAVE (LIST (QUOTE UNDOEDITL)
							 L UNDOLST UNDOLST0)
						   LISPXHIST))
                                                (* Takes care of making the 
                                                entire call to EDITL undoable.)
			  ))
		      (COND
			(EDITIME0 (FRPLACA (QUOTE EDITIME)
					   (IPLUS EDITIME (IDIFFERENCE
						    (CLOCK 0)
						    EDITIME0]

          (* If one of COMS causes an error, or if call to session is 
          terminated by a STOP, still want to move undo information to 
          LISPXHISTORY.)


		(RETURN L))
	      (T (ERROR!])

(EDITL0
  [LAMBDA (L COMS MESS EDITLFLG)

          (* EDITL0 should only be called while under an EDITL since 
          the global states of the edit, e.g. UNFIND, LASTP1, UNDOLST, 
          etc. are all bound in EDITL. Note that individual calls to 
          EDITL0 are not undoable, i.e. any changes that are made are 
          stored on UNDOLST or UNDOLST1, not on LISPXHISTORY.
          Only for calls to EDITL are the changes transfered to 
          LISPXHISTORY. Note also that when COMS are specified, all 
          structure changes are saved on UNDOLST1.
          When the editor is used on-line, structure changes for each 
          command are saved on UNDOLST1 and at the end of each 
          command, gathered up and stored on UNDOLST.)


    (COND
      ((NULL EDITLFLG)

          (* EDITL0 is being called from outside the block, look up 
          these variables to avoid traps.)


	(EVQ LASTAIL)
	(EVQ MARKLST)
	(EVQ UNDOLST)
	(EVQ UNDOLST1)
	(EVQ UNFIND)
	(EVQ LASTP1)
	(EVQ LASTP2)
	(EVQ ATM)
	(EVQ EDITCHANGES)
	(EVQ EDITHIST0)))
    (PROG (FINDFLAG LCFLG TOFLG EDITHIST L0 COM0 COM)
          (COND
	    (COMS (EDITCOMS COMS)
		  (RETURN L)))
          (AND (NEQ (POSITION T)
		    0)
	       (TERPRI T))
          (PRINT (OR MESS (QUOTE edit))
		 T T)
      LP  (EDITL1)                              (* Only way to exit is via 
                                                EDITEXIT which does a RETFROM.)
          (SETQ LISPXBUFS (OR (CLBUFS T)
			      LISPXBUFS))       (* User control-e'd out of read,
                                                CLEARBUF has already been done.)
          (GO LP])

(EDITL1
  [LAMBDA NIL
    (ERSETQ (PROG NIL
	      CT  (SETQ FINDFLAG NIL)
	      A   (SETQ EDITHIST NIL)
	          (SETQ UNDOLST1 NIL)           (* Holds any changes from 
                                                execution of this command.)
	          (PROMPTCHAR (QUOTE *)
			      NIL EDITHISTORY)
	          (SETQ COM (LISPXREAD T EDITRDTBL))
	          (SETQ L0 L)                   (* Marks L as of beginning of 
                                                this command. Used by UNDO.)
	          [SETQ COM0 (COND
		      ((ATOM COM)
			COM)
		      (T (CAR COM]              (* Saves command name.
                                                Needed for storing on UNDOLST 
                                                below.)

          (* Saves current L and command name for UNDOLST.
          Command name may be changed during execution to enable 
          better error diagnostics, e.g. on any find commands inside 
          of a complicated operation.)


	          (AND EDITHISTORY (EDITSAVE COM))
	          (COND
		    ([PROG1 (XNLSETQ (EDITCOM COM T)
				     T STOP)
			    [COND
			      (UNDOLST1 (SETQ UNDOLST1 (CONS COM0 (CONS L0 
								   UNDOLST1)))
					(SETQ UNDOLST (CONS UNDOLST1 UNDOLST]
			    (COND
			      (EDITHIST         (* Set in EDITSAVE.)
					(FRPLACA EDITHIST UNDOLST1]
		      (GO A)))
	          (TERPRI T)
	          (SETQ LISPXBUFS (OR (CLBUFS)
				      LISPXBUFS))
	          [COND
		    (COM                        (* If COM is NIL, message has 
                                                already been printed.)
			 (COND
			   ((STRINGP COM)
			     (PRIN1 COM T))
			   (T (PRIN2 COM T T)
			      (PRIN1 (QUOTE "  ?
")
				     T)))
			 (AND EDITHIST (LISPXPUT (QUOTE *ERROR*)
						 COM NIL EDITHIST]
	          (GO CT])

(UNDOEDITL
  [LAMBDA (L ULST ULST0)
    (PROG (UNDOLST1 COM)
          [MAP ULST [FUNCTION (LAMBDA (X)
		   (AND (CAR X)
			(UNDOEDITCOM (CAR X]
	       (FUNCTION (LAMBDA (X)
		   (COND
		     ((NEQ (SETQ X (CDR X))
			   ULST0)
		       X]
          (COND
	    ((NULL UNDOLST1)
	      (PRINT (QUOTE (UNDOEDITL - SHOW WT))
		     T T)))
          (EDITSMASH ULST (CAR ULST0)
		     (CDR ULST0))
          (AND LISPXHIST (UNDOSAVE [LIST (QUOTE UNDOEDITL)
					 L
					 (LIST (CONS T (CONS L UNDOLST1]
				   LISPXHIST])

(EDITCOM
  [LAMBDA (C TYPEIN)
    (SETQ COM C)

          (* In case there is an error, user will see what command was 
          being executed.)


    (SELECTQ EDITRACEFN
	     (NIL)
	     ((TRACE BREAK)
	       (PRIN1 (QUOTE "COM = ")
		      T)
	       (BPNT0 C 1 T)
	       (PRIN1 (QUOTE "C-EXP = ")
		      T)
	       (BPNT0 (CAR L)
		      1 T (CADR L))
	       [COND
		 ((EQ EDITRACEFN (QUOTE BREAK))
		   (APPLY (QUOTE BREAK1)
			  (LIST NIL T C]
	       (TERPRI T))
	     (EDITRACEFN C))
    [COND
      [FINDFLAG (COND
		  ((EQ FINDFLAG (QUOTE BF))
		    (SETQ FINDFLAG NIL)
		    (EDITBF C))
		  (T (SETQ FINDFLAG NIL)
		     (EDITQF C]
      ((NUMBERP C)
	(SETQ L (EDIT1F C L)))
      ((ATOM C)
	(EDITCOMA C (NULL TYPEIN)))
      (T (EDITCOML C (NULL TYPEIN]
    (CAR L])

(EDITCOMA
  [LAMBDA (C COPYFLG)
    (PROG (TEM TEM1)                            (* Interprets atomic commands.)
          (SELECTQ C
		   (NIL                         (* Nop.)
			NIL)
		   (OK [COND
			 ((OR (NULL EDITLFLG)
			      (EQ EDITLFLG T))
			   (AND ATM (REMPROP ATM (QUOTE EDIT-SAVE)))
			   [PUT (QUOTE EDIT)
				(QUOTE LASTVALUE)
				(SETQ TEM (CONS (LAST L)
						(CONS MARKLST (CONS UNDOLST L]
			   (COND
			     (LISPXHIST [NCONC LISPXHIST
					       (LIST (QUOTE EDIT)
						     TEM
						     (QUOTE EDITHIST)
						     (CONS EDITHIST0
							   (CAR EDITHISTORY]

          (* Note that EDITHIST0 is of the form 
          ((car edithistory) atm). To determine if the history list 
          has wrapped around, one computes 
          (EQ (GET (CAAR EDITHIST0) (QUOTE ENTERED)) 
          (CDR EDITHIST0)))


					]
		       (RETFROM (QUOTE EDITL0)
				L T))
		   (STOP 

          (* Aborts edit session. However all changes will have been 
          saved for undoing on UNDOLST and/or UNDOLST1.)


			 (RETEVAL (QUOTE EDITL0)
				  (QUOTE (ERROR!))
				  T))
		   (SAVE                        (* Exit and save.)
			 [COND
			   ((NEQ EDITLFLG T)
			     (ERROR (QUOTE "NOT LEGAL UNDER TTY:")
				    (QUOTE )
				    T))
			   (ATM (PUT (QUOTE EDIT)
				     (QUOTE LASTVALUE)
				     (PUT ATM (QUOTE EDIT-SAVE)
					  (CONS L (CONS MARKLST (CONS UNDOLST 
								     UNFIND]
			 (RETFROM (QUOTE EDITL0)
				  L T))
		   [TTY:(SETQ COM COM0)         (* So that COM0 will be printed 
                                                if TTY: is aborted via stop.)
		     (COND
		       ((SETQ TEM1 (PROG (UNDOLST1 UNDOLST)

          (* UNDOLST1 must be protected since there may have been some 
          changes executed in this command before the TTY: was 
          reached.)


				         [SETQ TEM (NLSETQ (EDITL0
							     L NIL
							     (QUOTE tty:)
							     (QUOTE tty:]
				         (RETURN UNDOLST)

          (* UNDOLST1 will be NIL because TTY: can only be exited by 
          typing in a STOP or OK.)


				     ))
			 (SETQ UNDOLST1 (CONS (CONS (QUOTE GROUPED)
						    TEM1)
					      UNDOLST1))

          (* Note that once the TTY: command has completed operation, 
          all of the changes executed under it are grouped together as 
          being changes of the TTY: command.)


			 ))
		     (COND
		       (TEM (SETQ L (CAR TEM)))
		       ([EVALV (QUOTE COMS)
			       (SETQ TEM (STKPOS (QUOTE EDITL0]

          (* If COMS is not NIL, the editor is being used as 
          subroutine, e.g. (BREAKIN -- (AFTER TTY:)). In this case, 
          want to abort the entire call to EDITL0.)


			 (RETEVAL TEM (QUOTE (ERROR!))
				  T))
		       (T                       (* Otherwise, just abort this 
                                                command, e.g. (MOVE TTY TO HERE)
)
			  (RELSTK TEM)
			  (PROG (TEM2)
			    LP  (SETQ TEM1 (NEWSTKPOS (QUOTE ERRORSET)
						      -1 TEM2))
			        (RELSTK TEM2)
			        (SETQ TEM2 TEM1)
                                                (* This can be eliminated when 
                                                STKPOS takes the extra optional 
                                                argument.)
			        (COND
				  ((NULL TEM2)
				    (HELP))
				  ((NEQ (NEWSTKARG 3 TEM2)
					(QUOTE STOP))
				    (SETQ TEM2 (STKNTH -1 TEM2 TEM2))
				    (GO LP)))
			        (RETFROM TEM2 NIL T]
		   [E (COND
			(TYPEIN (LISPX (LISPXREAD T T)
				       (QUOTE *)
				       NIL NIL T))
			(LCFLG (EDITQF C))
			(T (ERROR!]
		   (P (COND
			((NEQ LASTP1 L)
			  (SETQ LASTP2 LASTP1)
			  (SETQ LASTP1 L)))
		      (BPNT0 (CAR L)
			     1 T (CADR L)))
		   (? (COND
			((NEQ LASTP1 L)
			  (SETQ LASTP2 LASTP1)
			  (SETQ LASTP1 L)))
		      (BPNT0 (CAR L)
			     100 T (CADR L)))
		   [(PP PPV)
		     (COND
		       ((NEQ LASTP1 L)
			 (SETQ LASTP2 LASTP1)
			 (SETQ LASTP1 L)))
		     (RESETLST (RESETSAVE (OUTPUT T))
			       (RESETSAVE (SETREADTABLE T))
			       (RESETSAVE PRETTYFLG T)
			       (PROGN (PRINTDEF (CAR L)
						NIL
						(NEQ C (QUOTE PPV)))
				      (TERPRI T]
		   (^(AND (CDR L)
			  (SETQ UNFIND L))
		     (SETQ L (FLAST L)))
		   [!0 

          (* Continues to do 0's until TAILP is false, i.e. takes you 
          back to next highest left parentheses regardless of state of 
          edit push down list)


		       (COND
			 ((NULL (CDR L))
			   (ERROR!)))
		       (PROG NIL
			 LP  (SETQ L (CDR L))
			     (COND
			       ((TAILP (CAR L)
				       (CADR L))
				 (GO LP]
		   (MARK (SETQ MARKLST (CONS L MARKLST)))
		   [UNDO (COND
			   [(AND TYPEIN (LISPXREADP))
                                                (* Indicates that this UNDO 
                                                command uses the history list.)
			     (COND
			       (EDITHISTORY (EDITH C))
			       (T (ERROR!]
			   (T (EDIT!UNDO TYPEIN]
		   (!UNDO (EDIT!UNDO T T))
		   (TEST (SETQ UNDOLST (CONS NIL UNDOLST)))
		   [UNBLOCK (COND
			      ((SETQ TEM (FMEMB NIL UNDOLST))
				(EDITSMASH TEM (CONS NIL NIL)
					   (CDR TEM)))
			      (T (PRIN1 (QUOTE "not blocked.
")
					T]
		   [_(COND
		       (MARKLST (AND (CDR L)
				     (SETQ UNFIND L))
				(SETQ L (CAR MARKLST)))
		       (T (ERROR!]
		   [\ (COND
			(UNFIND (SETQ C L)
				(SETQ L UNFIND)
				(AND (CDR C)
				     (SETQ UNFIND C)))
			(T (ERROR!]
		   [\P (COND
			 ((AND LASTP1 (NEQ LASTP1 L))
			   (SETQ L LASTP1))
			 ((AND LASTP2 (NEQ LASTP2 L))
			   (SETQ L LASTP2))
			 (T (ERROR!]
		   [__(COND
		       (MARKLST (AND (CDR L)
				     (SETQ UNFIND L))
				(SETQ L (CAR MARKLST))
				(SETQ MARKLST (CDR MARKLST)))
		       (T (ERROR!]
		   [(F BF)
		     (COND
		       ((NULL TYPEIN)
			 (AND (NULL COMS)
			      (ERROR!))
			 (SETQ FINDFLAG C)
			 (RETURN NIL)))
		     (SETQ TEM (LISPXREAD T EDITRDTBL))
		     (COND
		       ([AND EDITHISTORY (NULL (AND REREADFLG
						    (TAILP REREADFLG
							   (CAAAR EDITHISTORY]
			 (NCONC1 (CAAAR EDITHISTORY)
				 TEM)))
		     (COND
		       ((EQ C (QUOTE F))
			 (EDITQF TEM))
		       ((EQ C (QUOTE BF))
			 (EDITBF TEM))
		       (T (ERROR!]
		   (UP (EDUP))
		   (DELETE (SETQ C (QUOTE (DELETE)))
                                                (* For undoing.)
			   (EDIT: (QUOTE :)))
		   (NX (EDIT* 1))
		   (BK (EDIT* -1))
		   [!NX                         (* Goes through a string of 
                                                right parentheses to next 
                                                element.)
			(SETQ L (PROG ((L L)
				       (UF L))
				  LP  (COND
					((NULL (SETQ L (CDR L)))
					  (ERROR!))
					([NULL (CDR (FMEMB (CAR L)
							   (CADR L]
					  (GO LP)))
				      (EDITCOM (QUOTE NX))
				      (SETQ UNFIND UF)
				      (RETURN L]
		   (COND
		     ([AND [NULL (SETQ TEM (CDR (EDITMAC C EDITMACROS]
			   (NULL (SETQ TEM (CDR (EDITMAC C USERMACROS]
		       (RETURN (EDITDEFAULT C)))
		     (T (EDITCOMS (COPY TEM])

(EDITCOML
  [LAMBDA (C COPYFLG)
    (PROG (C2 C3 TEM)                           (* Handles list commands.)
      LP  (SETQ C2 (CADR C))
          (SETQ C3 (CADDR C))
          (COND
	    ((AND LCFLG (SELECTQ C2
				 ((TO THRU THROUGH)
				   [COND
				     ((NULL (CDDR C))
				       (SETQ C3 -1)
				       (SETQ C2 (QUOTE THRU]
				   T)
				 NIL))
	      (EDITTO (CAR C)
		      C3 C2)
	      (RETURN))
	    ((NUMBERP (CAR C))
	      (EDIT2F (CAR C)
		      (CDR C))
	      (RETURN))
	    ((EQ C2 (QUOTE ..))
	      (EDITCONT (CAR C)
			(CDDR C))
	      (RETURN)))
          (SELECTQ
	    (CAR C)
	    [S (OR C2 (ERROR!))
	       (EDITCOM1 (LIST (LIST (COND
				       ((OR (EQ C2 (QUOTE #1))
					    (EQ C2 (QUOTE #2))
					    (EQ C2 (QUOTE #3)))
					 (QUOTE SET))
				       (T (QUOTE SAVESET)))
				     C2
				     (PROG ((L L)
					    UNFIND)
				           (RETURN (EDLOC (CDDR C]
	    (MARK (SET C2 L))
	    (\ (SETQ UNFIND L)
	       (SETQ L (EDITCOM1 C2 T)))
	    (R (EDIT4F C2 C3 T))
	    (R1 (EDIT4F C2 C3 1))
	    ((RC RC1)
	      (EDIT4F C2 C3 (OR (EQ (CAR C)
				    (QUOTE RC))
				1)
		      T))
	    (E (SETQ TEM (EDITCOM1 C2 T))
	       (COND
		 ((NULL (CADDR C))
		   (PRINT TEM T T)))
	       (RETURN TEM))
	    (I
	      [SETQ C
		(CONS
		  (COND
		    ((ATOM C2)
		      C2)
		    (T (EDITCOM1 C2 T)))
		  (EDITCOM1
		    (LIST (LIST (QUOTE MAPCAR)
				(COND
				  (TYPEIN (MAPCAR (CDDR C)
						  (FUNCTION LISPX/)))
				  (T (CDDR C)))
				(QUOTE EVAL]
	      (SETQ COPYFLG NIL)
	      (GO LP))
	    [N (COND
		 ((ATOM (CAR L))
		   (ERROR!)))
	       (EDITNCONC (CAR L)
			  (COND
			    (COPYFLG (COPY (CDR C)))
			    (T                  (* APPEND makes it much easier 
                                                for EDITHISTORY.)
			       (APPEND (CDR C]
	    (P (COND
		 ((NEQ LASTP1 L)
		   (SETQ LASTP2 LASTP1)
		   (SETQ LASTP1 L)))
	       (BPNT (CDR C)))
	    (F (EDIT4F C2 C3))
	    [FS (MAPC (CDR C)
		      (FUNCTION (LAMBDA (X)
			  (EDITQF (SETQ COM X]
	    (F=(EDIT4F (CONS (QUOTE ==)
			     C2)
		       C3))
	    (ORF (EDIT4F (COND
			   ((CDDR C)
			     (CONS (QUOTE *ANY*)
				   (CDR C)))
			   (T (CADR C)))
			 (QUOTE N)))
	    (BF (EDITBF C2 C3))
	    [NTH [SETQ TEM (COND
		     ((AND (LISTP (CAR L))
			   (EQ (CAAR L)
			       CLISPTRANFLG))
		       (CDDAR L))
		     (T (CAR L]
		 (COND
		   ((NEQ TEM (SETQ TEM (EDITNTH TEM C2)))
		     (SETQ L (CONS TEM L]
	    [IF 

          (* Provides for conditional editing.
          Form is (if pred) or (if pred coms1 coms2))


		(COND
		  ((CAR (NLSETQ (EDITCOM1 C2 T)))
                                                (* If predicate evaluates to 
                                                true then perform list of 
                                                commands)
		    (EDITCOMS C3))
		  ((CDDDR C)

          (* If false and default commands given 
          (but may be NIL) execute them.)


		    (EDITCOMS (CADDDR C)))
		  (T 

          (* Otherwise generate error. This would be used to terminate 
          a LP or ORR clause.)


		     (ERROR!]
	    [(RI RO LI LO BI BO)
	      (BLKAPPLY (CAR C)
			(APPEND (CDR C)
				(LIST (CAR L]
	    (M (SETQ USERMACROS (CONS [COND
					[(ATOM C2)
					  (COND
					    ((SETQ TEM (EDITMAC C2 USERMACROS))
					      (RPLACD TEM (CDDR C))
					      (RETURN))
					    (T (NCONC1 EDITCOMSA C2)
					       (CONS C2 (CONS NIL (CDDR C]
					(T (COND
					     ((SETQ TEM (EDITMAC (CAR C2)
								 USERMACROS T))
					       (RPLACA TEM (CADDR C))
					       (RPLACD TEM (CDDDR C))
					       (RETURN))
					     (T (NCONC1 EDITCOMSL (CAR C2))
						(CONS (CAR C2)
						      (CDDR C]
				      USERMACROS)))
	    (NX (EDIT* C2))
	    (BK (EDIT* (IMINUS C2)))
	    (ORR (EDOR (CDR C)))
	    (MBD (EDITMBD NIL (CDR C)))
	    (XTR (EDITXTR NIL (CDR C)))
	    ((THRU TO)

          (* Same as (NIL THRU C2) i.e. starts here, does an up, and 
          then a (BI 1 C2) etc.)


	      (EDITTO NIL C2 (CAR C)))
	    ((A B : AFTER BEFORE)
	      (EDIT: (CAR C)
		     NIL
		     (CDR C)))
	    (MV (EDITMV NIL (CADR C)
			(CDDR C)))
	    [(LP LPQ)
	      (EDRPT (CDR C)
		     (EQ (CAR C)
			 (QUOTE LPQ]
	    (LC (EDLOC (CDR C)))
	    (LCL (EDLOCL (CDR C)))
	    [_(SETQ L (PROG ((L L)
			     (UF L)
			     TEM)
			    (SETQ C3 (EDITFPAT C2))
			LP  [SETQ TEM (COND
				((AND (LISTP (CAR L))
				      (EQ (CAAR L)
					  CLISPTRANFLG))
				  (CDDAR L))
				(T (CAR L]
			    (COND
			      ((COND
				  ((ATOM C3)
				    (EQ C3 (CAR TEM)))
				  [(EQ (CAR C3)
				       (QUOTE IF))
				    (CAR (NLSETQ (EDITCOM1 (CADR C3)
							   T]
				  ((OR (EQ (CAR C3)
					   (QUOTE ))
				       (EQ (CAR C3)
					   (QUOTE )))
                                                (* Alt-mode.)
				    (EDIT4E C3 (CAR TEM)))
				  (T (EDIT4E C3 TEM)))
				(SETQ UNFIND UF)
				(RETURN L))
			      ((SETQ L (CDR L))
				(GO LP)))
			    (SETQ COM C2)
			    (ERROR!]
	    (BELOW 

          (* Allows specification of new position in terms of depth 
          below some other position. E.g.
          (BELOW COND 1) indicates cond-clause you are currently in.
          (BELOW \ 2) Says 2 below UNFIND.
          This is useful for getting around in long lists, e.g. user 
          might perform an F SELECTQ then F FOO.
          To get to next SELECTQ clause, he does 
          (BELOW \ 1) and then Observe Observe that you can also save 
          the depth directly by performing 
          (S FOO (LENGTH L)) and then USE BELOW as in 
          (BELOW ^ FOO))


		   (EDITBELOW C2 C3))
	    (SW (EDITSW (CADR C)
			(CADDR C)))
	    [BIND 

          (* Makes available temporary variables for EDIT macros.
          Used by FIX8 and FIX9 macros.)


		  (PROG (#1 #2 #3)
		        (EDITCOMS (CDR C]
	    [COMS (MAPC (CDR C)
			(FUNCTION (LAMBDA (X)
			    (EDITCOM (SETQ COM (EDITCOM1 X T]
	    (COMSQ (EDITCOMS (CDR C)))
	    [RESETVAR (SETQ TEM (SETQ RESETVARSLST (CONS (CONS C2 (CAR C2))
							 RESETVARSLST)))
	      (COND
		([NULL (PROG1 (XNLSETQ (PROGN (FRPLACA C2 (EDITCOM1 C3 T))
					      (EDITCOMS (CDDDR C)))
				       NIL STOP)
			      (FRPLACA (CAAR TEM)
				       (CDAR TEM))
			      (SETQ RESETVARSLST (CDR TEM]
		  (ERROR!]
	    (COND
	      ([AND (NULL (SETQ TEM (EDITMAC (CAR C)
					     EDITMACROS T)))
		    (NULL (SETQ TEM (EDITMAC (CAR C)
					     USERMACROS T]
		(RETURN (EDITDEFAULT C)))
	      ([NOT (ATOM (SETQ C3 (CAR TEM]
		(EDITCOMS (SUBPAIR C3 (CDR C)
				   (CDR TEM)
				   T)))
	      (T (EDITCOMS (SUBST (CDR C)
				  C3
				  (CDR TEM])

(EDITMAC
  [LAMBDA (C LST FLG)
    (PROG (X Y)
      LP  [COND
            ((NULL LST)
              (RETURN NIL))
            ([EQ C (CAR (SETQ X (CAR LST]
              (SETQ Y (CDR X))
              (COND
                ([COND
                    (FLG (CAR Y))
                    (T (NULL (CAR Y]
                  (RETURN Y]
          (SETQ LST (CDR LST))
          (GO LP])

(EDITCOMS
  [LAMBDA (COMS)                                (* MAPC not used because 
                                                EDITDEFAULT needs tail for 
                                                spelling corrections.)
    (PROG NIL
      LP  [COND
	    ((NLISTP COMS)
	      (AND COMS (EDITCOM COMS))

          (* Permits commands that take lists of commands as 
          arguments, e.g. ORR, IF, etc. to be given a single atomic 
          command.)


	      (RETURN (CAR L]
          (EDITCOM (CAR COMS))
          (SETQ COMS (CDR COMS))
          (GO LP])

(EDIT!UNDO
  [LAMBDA (PRINTFLG !UNDOFLG)
    (AND EDITHISTORY (LISPXWATCH P.A.STATS))
    (PROG ((LST UNDOLST)
	   FLG)
      LP  (COND
	    ((OR (NULL LST)
		 (NULL (CAR LST)))
	      (GO OUT)))
          (SELECTQ (CAAR LST)
		   ((NIL !UNDO UNBLOCK)
		     (GO LP1))
		   [UNDO (COND
			   ((NULL !UNDOFLG)
			     (GO LP1]
		   NIL)
          (UNDOEDITCOM (CAR LST)
		       PRINTFLG)
          (COND
	    ((NULL !UNDOFLG)
	      (RETURN)))
          (SETQ FLG T)
      LP1 (SETQ LST (CDR LST))
          (GO LP)
      OUT (COND
	    (FLG (RETURN))
	    ((CDR LST)
	      (PRINT (QUOTE blocked)
		     T T))
	    (T (PRIN1 (QUOTE "nothing saved.
")
		      T])

(UNDOEDITCOM
  [LAMBDA (X FLG)                               (* If FLG is T, name of command 
                                                is printed.)
    (PROG (C)
          (COND
	    ((NLISTP X)
	      (ERROR!))
	    ((NULL (SETQ C (CAR X)))            (* Has been undone before, but 
                                                UNDO it again.)
	      (SETQ C (QUOTE ALREADY))
	      (GO OUT))
	    ([NEQ (CAR (FLAST L))
		  (CAR (FLAST (CADR X]

          (* The expression being edited is not the one referred to by 
          this undo command. This can happen if you undo by using 
          history list outside of scope of this editing.)


	      (PRIN1 (QUOTE "different expression.
")
		     T)
	      (SETQ COM NIL)
	      (ERROR!)))
          (SETQ L (CADR X))
          [PROG (L)

          (* L bound to NIL so that EDITSMASH doesnt search up it 
          looking for CLISP markers.)


	        (UNDOEDITCOM1 X)
	        (EDITSMASH X NIL (CONS (CAR X)
				       (CDR X]

          (* Marks it so UNDO will skip it in future.
          Note that undoing this UNDO will unmark it.)


      OUT (AND FLG (PRIN2 [COND
			    ((NULL C)
			      (QUOTE already))
			    ((NOT (NUMBERP C))
			      C)
			    (T (CONS C (QUOTE (--]
			  T T)
	       (PRIN1 (QUOTE " undone.
")
		      T))
          (RETURN T])

(UNDOEDITCOM1
  [LAMBDA (X)

          (* Takes a single entry on UNDOLST, i.e. list of the form 
          (command-name L . UNDOLST1) and maps down the UNDOLST1 
          portion performing the corresonding EDITSMASHes.)


    (MAPC (CDDR X)
          (FUNCTION (LAMBDA (X)
              (COND
                ((EQ (CAR X)
                     (QUOTE GROUPED))

          (* Used by TTY: command, which must add entire UNDOLST from 
          subordinate call to EDITL0 to its own UNDOLST1.)


                  (MAPC (CDR X)
                        (FUNCTION UNDOEDITCOM1)))
                ((EQ (CAR X)
                     (QUOTE LISPXHIST))
                  (EDITCOM1 (CDR X)))
                (T (EDITSMASH (CAR X)
                              (CADR X)
                              (CDDR X))
                   (LISPXWATCH EDITUNDOSTATS])

(EDITCOM1
  [LAMBDA (LST FLG)

          (* LST is a list of expressions of the form used for saving 
          undo information on LISPXHIST, i.e. CAR of form is to be 
          applied to CDR. EDITCOM1 executes the forms and then 
          transfers the undo information to the edit history list so 
          that UNDO can work as an edit command.
          EDITCOM1 is used by the S and I command, and for undoing 
          these commands. Value is the result of last application -
          used by I command to get result of evaluaton back.)


    (PROG ((LISPXHIST (CONS (QUOTE SIDE)
                            (CONS (LIST 0)
                                  LISPXHIST)))
           TEM)

          (* LISPXHIST is rebound this way so that the SIDE 
          information doesnt get stored on the regular side slot.
          LISPXHIST is not completely rebound, i.e. to just the side 
          info, so that other messages etc. will still be stored on 
          the correct entry)


          [COND
            [FLG                                (* IF FLG is T, LST is a single 
                                                form.)
                 (SETQ TEM (EVAL (COND
                                   (TYPEIN (LISPX/ LST))
                                   (T LST]
            (T (MAPC LST (FUNCTION (LAMBDA (X)
                         (SETQ TEM (COND
                             ((LISTP (CAR X))
                               (/RPLNODE (CAR X)
                                         (CADR X)
                                         (CDDR X)))
                             (T (APPLY (CAR X)
                                       (CDR X]
          (AND [SETQ LISPXHIST (CDR (GET LISPXHIST (QUOTE SIDE]
               (SETQ UNDOLST1 (CONS (CONS (QUOTE LISPXHIST)
                                          LISPXHIST)
                                    UNDOLST1)))
          (RETURN TEM])

(EDITSMASH
  [LAMBDA (OLD A D)
    (COND
      ((NLISTP OLD)
	(ERROR!)))
    (AND EDITCHANGES (FRPLACA EDITCHANGES T))
    (SETQ UNDOLST1 (CONS (CONS OLD (CONS (CAR OLD)
					 (CDR OLD)))
			 UNDOLST1))
    (AND EDITHISTORY (LISPXWATCH EDITUNDOSAVES))
    (FRPLACA OLD A)
    (FRPLACD OLD D)
    (PROG ((L L))
      LP  (COND
	    ((NULL L)
	      (RETURN OLD))
	    ((NLISTP (CAR L)))
	    ((EQ (CAAR L)
		 CLISPTRANFLG)

          (* Deletes CLISP translation. NOt made part of the edit 
          event, because of the possibility of the uer performing two 
          changes, and then undoing the first, which would then 
          restore the translation, even though it no longer corresond 
          to the untranslated and chaged CLISP.)


	      (/RPLNODE (CAR L)
			(CADDAR L)
			(CDDDAR L)))
	    ((AND CLISPARRAY (GETHASH (CAR L)
				      CLISPARRAY))
	      (/PUTHASH (CAR L)
			NIL CLISPARRAY)))
          (SETQ L (CDR L))
          (GO LP])

(EDITNCONC
  [LAMBDA (X Y)
    (COND
      ((NULL X)
        Y)
      ((NLISTP X)
        (ERROR!))
      (T (PROG1 X (EDITSMASH (SETQ X (LAST X))
                             (CAR X)
                             Y])

(EDIT1F
  [LAMBDA (C L)
    (PROG (TEM)
          [COND
            [(EQ C 0)
              (RETURN (COND
                        ((CDR L)
                          (RETURN (CDR L)))
                        (T (SETQQ COM "can't - at top.
")
                           (ERROR!]
            ((NLISTP (CAR L))
              (ERROR!))
            ((EQ (CAAR L)
                 CLISPTRANFLG)
              (SETQ TEM (CDDAR L)))
            (T (SETQ TEM (CAR L]
          (RETURN (COND
                    [(IGREATERP C 0)
                      (COND
                        ((NLISTP (SETQ TEM (NTH TEM C)))
                          (ERROR!))
                        (T (CONS (CAR (SETQ LASTAIL TEM))
                                 L]
                    ([NULL (SETQ TEM (NLEFT TEM (IMINUS C]
                      (ERROR!))
                    (T (CONS (CAR (SETQ LASTAIL TEM))
                             L])

(EDIT2F
  [LAMBDA (N X)
    (PROG ([CL (COND
                 ((AND (LISTP (CAR L))
                       (EQ (CAAR L)
                           CLISPTRANFLG))
                   (CDDAR L))
                 (T (CAR L]
           TEM)

          (* Handles all deletion, replacement and insertion.
          For deletion and replacement, saves information about what 
          was destroyed on variable LASTCHANGE.
          The command UNDO can then be used to restore the structure.)


          [COND
            ((NLISTP CL)
              (ERROR!))
            (COPYFLG (SETQ X (COPY X)))
            (T                                  (* APPEND makes it much easier 
                                                for EDITHISTORY.)
               (SETQ X (APPEND X]
          (COND
            [(IGREATERP N 0)
              (COND
                ([AND (NEQ N 1)
                      (OR [NLISTP (SETQ TEM (NTH CL (SUB1 N]
                          (NLISTP (CDR TEM]
                  (SETQ COM N)
                  (ERROR!))
                ((NULL X)                       (* Delete)
                  (GO DELETE))
                (T                              (* Replace)
                   (GO REPLACE]
            ([OR (EQ N 0)
                 (NULL X)
                 (NLISTP (SETQ TEM (NTH CL (IMINUS N]
              (ERROR!))
            (T                                  (* Insert)
               (COND
                 ((NEQ N -1)
                   (SETQ CL TEM)))              (* Insertion also physically 
                                                changes indicated tail.)
               (EDITSMASH CL (CAR X)
                          (CONS (CAR CL)
                                (CDR CL)))
               [COND
                 ((CDR X)
                   (EDITSMASH CL (CAR CL)
                              (NCONC (CDR X)
                                     (CDR CL]
               (RETURN)))
      DELETE
          [COND
            ((EQ N 1)
              (OR (LISTP (CDR CL))
                  (ERROR!))

          (* To delete first element you must effectively replace it 
          by second element and delete second element.
          This is why you cannot delete the first element of a list 
          when it is the only one.)


              (EDITSMASH CL (CADR CL)
                         (CDDR CL)))
            (T 

          (* Deleting any other element is done by patching around it, 
          i.e. by changing previous CDR to point to its CDR.
          In general, you can't solve problem so pointers into tails 
          will always be updated without going down the entire list 
          and moving everything over. See manual.)


               (SETQ CL TEM)
               (EDITSMASH CL (CAR CL)
                          (CDDR CL]
          (RETURN)
      REPLACE
          [COND
            ((NEQ N 1)
              (SETQ CL (CDR TEM]

          (* Replacement physically changes indicated tail i.e. if you 
          are editing (A B C D) and set FOO to 
          (NTH 3) i.e. (C D) and then do a 
          (3 X Y) FOO will be changed to 
          (X Y D))


          (EDITSMASH CL (CAR X)
                     (CDR CL))
          (COND
            ((CDR X)
              (EDITSMASH CL (CAR CL)
                         (NCONC (CDR X)
                                (CDR CL])

(EDIT4E
  [LAMBDA (PAT X CHANGEFLG)
    (COND
      ((EQ PAT X)
	T)
      ((NLISTP PAT)
	(OR (EQ PAT (QUOTE &))
	    (AND (NUMBERP PAT)
		 (EQP PAT X))
	    (AND (STRINGP PAT)
		 (STREQUAL PAT X)
		 T)))
      ((EQ (CAR PAT)
	   (QUOTE *ANY*))
	(PROG NIL
	  LP  (COND
		((NULL (SETQ PAT (CDR PAT)))
		  (RETURN NIL))
		((EDIT4E (CAR PAT)
			 X)
		  (RETURN T)))
	      (GO LP)))
      ((EQ (CAR PAT)
	   (QUOTE ))                          (*  is the way the line 
                                                printer prints alt-modes.)
	(AND (OR (LITATOM X)
		 (STRINGP X))
	     (EDIT4E1 (CDR PAT)
		      (DUNPACK X CHCONLST2)
		      X CHANGEFLG)))
      ((EQ (CAR PAT)
	   (QUOTE ))

          (* This pattern specifies a search for a 'close' word, using 
          the spelling corrector, i.e. SKOR.
          CADR of PAT is the number of characters in the word, CDDR 
          its CHCON. The pattern is constructed by EDITFPAT when it 
          encounters a word or string that ends in .)


	(AND (OR (LITATOM X)
		 (STRINGP X))
	     (SKOR0 X (CADR PAT)
		    (CADDR PAT)
		    (CDDDR PAT))
	     (PROGN (AND (NEQ EDITQUIETFLG T)
			 (PRIN1 (QUOTE =)
				T)
			 (PRINT X T T))
		    T)))
      [(EQ (CAR PAT)
	   (QUOTE --))
	(OR (NULL (SETQ PAT (CDR PAT)))
	    (PROG NIL
	      LP  (COND
		    ((EDIT4E PAT X)
		      (RETURN T))
		    ((NLISTP X)
		      (RETURN NIL)))
	          (SETQ X (CDR X))
	          (GO LP]
      ((EQ (CAR PAT)
	   (QUOTE ==))
	(EQ (CDR PAT)
	    X))
      ((NLISTP X)
	NIL)
      ([EDIT4E (CAR PAT)
	       (CAR (COND
		      ((EQ (CAR X)
			   CLISPTRANFLG)
			(SETQ X (CDDR X)))
		      (T X]
	(EDIT4E (CDR PAT)
		(CDR X])

(EDIT4E1
  [LAMBDA (PAT LST X CHANGEFLG)

          (* Compares PAT and X. PAT is a DUNPACK of an atom or string 
          which contains one or more alt-modes.
          An alt-mode can match any number 
          (including zero) of characters in X, e.g. NUM$, $BERP, and 
          $U$E$ all match NUMBERP. If CHANGEFLG is T and PAT matches 
          X, the value of EDIT4E1 is a list of pointer pairs 
          corresponding to the beginning and end of the sequence 
          matched by each alt-mode.)


    (PROG (PAT1 LST1 LST2 MATCH)
      LP  (COND
	    [(NULL PAT)
	      (COND
		((OR (NULL LST)
		     (NULL PAT1))

          (* If LST is NIL, then the final characters in PAT matched 
          those in X, e.g. $BERP vs NUMBERP.
          If PAT1 is NIL, then the last character in PAT was an 
          altmode, e.g. NUM$ vs NUMBERP, so extra characters in LST 
          are acceptable.)


		  (GO SUCC))
		(LST1 (SETQ LST LST1)
		      (SETQ LST1 NIL)
		      (SETQ PAT PAT1))
		(T (RETURN NIL]
	    ((EQ (CAR PAT)
		 (QUOTE ))
	      [COND
		((AND CHANGEFLG LST2 LST1)

          (* An alt-mode was seen before.
          (Note that we cannot determine the scope of an alt-mode 
          until the next one is encountered, or the end of the match 
          is reached.) LST2 was the value of LST as of the beginning 
          of the alt-mode match, LST1 the value of LST as of its end.
          However, if LST1 is NIL, then there were two alt-modes in a 
          row, and we ignore the last one.)


		  (SETQ MATCH (CONS (CONS LST2 LST1) MATCH]
	      (SETQ PAT (SETQ PAT1 (CDR PAT)))

          (* PAT1 is a pointer into PAT as of the first character 
          after an alt-mode. It is used for backing up after a 
          partially successful match, e.g. if PAT is $XYZ$ and X is 
          XYXYZ.)


	      (SETQ LST1 NIL)
	      (SETQ LST2 LST)
	      (GO LP))
	    ((NULL LST)
	      (RETURN NIL))
	    ((EQ (CAR PAT)
		 (CAR LST))
	      (COND
		((NULL LST1)
		  (SETQ LST1 LST)))
	      (SETQ PAT (CDR PAT)))
	    ((NULL (SETQ PAT PAT1))
	      (RETURN NIL))
	    (LST1 (SETQ LST LST1)
		  (SETQ LST1 NIL)))
          (SETQ LST (CDR LST))
          (GO LP)
      SUCC(COND
	    [CHANGEFLG (AND (NEQ EDITQUIETFLG T)
			    (PRIN2 X T T))

          (* EDIT4F2 will be called, and it will print -> followed by 
          the new atom or string.)


		       (RETURN (DREVERSE (CONS (CONS LST2 LST1) MATCH]
	    ((NEQ EDITQUIETFLG T)
	      (PRIN1 (QUOTE =)
		     T)
	      (PRINT X T T)))
          (RETURN T])

(EDITQF
  [LAMBDA (PAT)
    (PROG (Q1)
          (COND
	    ([AND (LISTP (SETQ Q1 (CAR L)))
		  (SETQ Q1 (MEMB PAT (COND
				   ((EQ (CAR Q1)
					CLISPTRANFLG)
				     (CDDDR Q1))
				   (T (CDR Q1]
	      (SETQ L (CONS (COND
			      (UPFINDFLG Q1)
			      (T (SETQ LASTAIL Q1)
				 (CAR Q1)))
			    L)))
	    (T (EDIT4F PAT (QUOTE N])

(EDIT4F
  [LAMBDA (PAT C3 CHANGEFLG CHARFLG)

          (* Searches the expression being edited, starting from 
          current point and continuing in print order, until a 
          position is found for which the current level list matches 
          PAT. Then, if (CAR L) is atomic, effectively does an UP 
          (unless UPFINDFLG=NIL) Thus F (SETQ X --) and F SETQ will 
          produce the same result. -
          If C3 is T, the search starts with the current exppession.
          If C3 is 'N', the search skips the current expression, 
          although it does search inside of it.)


    (PROG (LL X TAIL (FF (CONS))
	      (TOPLVL (NULL C3))
	      N NEWFLG (PAT0 PAT))
          (SETQ PAT (EDITFPAT PAT T))           (* Checks PAT for altmodes.)
          (SETQ LL L)
          (COND
	    (CHANGEFLG (SETQ N (COND
			   ((NUMBERP CHANGEFLG)
			     CHANGEFLG)
			   (T                   (* Means change all 
                                                occurrences.)
			      -1)))
		       (SETQ TOPLVL NIL)
		       (SETQ C3 (EDITFPAT1 C3))
		       [AND CHARFLG (NLISTP PAT)
			    (NLISTP C3)
			    [SETQ PAT (CONS (QUOTE )
					    (CONS (QUOTE )
						  (NCONC1 (UNPACK PAT)
							  (QUOTE ]
			    (SETQ C3 (CONS (QUOTE )
					   (CONS (QUOTE )
						 (NCONC1 (UNPACK C3)
							 (QUOTE ]

          (* If CHARFLG is T and neither pattern nor format contain 
          alt-modes, supply them, i.e. user wants a character 
          replacement operation. This option is used by the RC and RC1 
          commands, and by ESUBST.)


		       )
	    [(EQ C3 (QUOTE N))
	      (SETQ N 1)
	      [COND
		((NLISTP (CAR L))
		  (GO LP1))
		((EQ (CAAR L)
		     CLISPTRANFLG)
		  (SETQ X (CADDAR L)))
		(T (SETQ X (CAAR L]
	      (SETQ LL (CONS X L))
	      (COND
		((AND (NLISTP X)
		      UPFINDFLG)

          (* E.g. If at (COND --) and do F COND, cannot be allowed to 
          match with this COND, as the subsequent UP would leave you 
          right where you started. However, if UPFINDFLG is NIL, then 
          it is ok to match with this COND.)


		  (GO LP1]
	    (T (SETQ N C3)))
          (COND
	    ((NOT (NUMBERP N))
	      (SETQ N 1)))
          [COND
	    ([COND
		[(TAILP (CAR LL)
			(CADR LL))
		  (AND (EQ (CAR PAT)
			   (QUOTE ...))
		       (EDIT4E (CDR PAT)
			       (CAR LL]
		(T (EDIT4E PAT (CAR LL]

          (* This EDIT4E check is necessary because once search 
          starts, EDIT4F1 is always looking down one level, i.e. at 
          car's of list it is examining. Similarly, since once the 
          search starts, tails are only matched against patterns 
          beginning with ..., we do not call EDIT4E here on a TAIL 
          unless the pattern also begins with ...)


	      (COND
		[CHANGEFLG (COND
			     ([NULL (AND (EQ PAT (QUOTE &))
					 (LISTP (CAR L]

          (* R can't work if you are already there, e.g. current 
          expression is B and user says (R B C), or current expression 
          is (CAR X) and user says (R (CAR X) 
          (CDR Y)). the AND check is to enable commands like 
          (r1 & .) to work. In this case, it is assumed that & meant 
          the first element in the current expression, not the current 
          expression itself.)


			       (PRINT (QUOTE can't)
				      T T)
			       (ERROR!]
		((ZEROP (SETQ N (SUB1 N)))
		  (RETURN (SETQ L LL]
          (SETQ X (CAR LL))
      LP  (COND
	    [(EDIT4F1 PAT X MAXLEVEL TAIL)
	      (AND (CDR L)
		   (SETQ UNFIND L))
	      (RETURN (CAR (SETQ L (NCONC (CAR FF)
					  (COND
					    ((EQ (CADR FF)
						 (CAR LL))
                                                (* To avoid repetitions.)
					      (CDR LL))
					    (T LL]
	    (TOPLVL (GO ERROR))
	    ((EQ CHANGEFLG T)

          (* R command only affects current expression.
          However, R1 is equivalent to an F and then a replacement and 
          so is allowed to search above the current expression.)


	      (COND
		(NEWFLG (RETURN T)))
	      (GO ERROR)))
      LP1 (SETQ X (CAR LL))

          (* Ascend from this element and begin searching the next 
          element in the next higher list.)


          (COND
	    ((NULL (SETQ LL (CDR LL)))
	      (COND
		(NEWFLG                         (* This was a replacement 
                                                operation which has found a 
                                                successful match.)
			(RETURN T)))
	      (GO ERROR))
	    ([SETQ TAIL (COND
		  ((AND (EQ X (CAR LASTAIL))
			(TAILP LASTAIL (CAR LL)))

          (* This is sort of an open UP. It is necessary to handle the 
          case where the current expression is atomic and the next 
          higher expression contains two instances of it.)


		    LASTAIL)
		  (T (MEMB X (CAR LL]
	      (SETQ X (CDR TAIL))
	      (GO LP)))
          (GO LP1)
      ERROR
          (SETQ COM PAT0)
          (ERROR!])

(EDIT4F1
  [LAMBDA (PAT X LVL TAIL)

          (* In most cases, EDIT4F1 treats X as a list, and matches 
          PAT against elements of X. However, if TAIL is not NIL, 
          EDIT4F1 will also look at X itself if 
          (1) X is not a list (this covers the case where a list ends 
          in an atom other than NIL), or 
          (2) PAT begins with ... In both cases, X is EQ to CDR of 
          TAIL, and TAIL is used if replacement is being carried out.)


    (PROG ((L L)
           TEM XX)
          (AND CHANGEFLG (SETQ L (CONS X L)))

          (* So that if there are any replacements in CLISP 
          expressions that have been translated, editsmash will know 
          to remove the translations.)


          [COND
            ((AND (LISTP X)
                  (NULL TAIL)
                  (EQ (CAR X)
                      CLISPTRANFLG))
              (SETQ XX X)
              (SETQ X (CDDR X]
      LP  [COND
            ((AND (LISTP PAT)
                  (EQ (CAR PAT)
                      (QUOTE ...)))

          (* This check is made before the NULL check because F 
          (...) is acceptable and means find the first list ending in 
          NIL.)


              (GO CHECK...))
            ((NULL X))
            ((AND LVL (NOT (IGREATERP LVL 0)))
                                                (* NIL = infinity.)
              (PRIN1 (QUOTE "maxlevel exceeded.
")
                     T))
            ((LISTP X)
              (GO ELEMENT))
            ((AND TAIL (SETQ TEM (EDIT4E PAT X CHANGEFLG)))
                                                (* Compares PAT with atomic tail
                                                of a list.)
              [COND
                (CHANGEFLG (SETQ X (EDIT4F2 TAIL TEM C3 T]
              (COND
                ((ZEROP (SETQ N (SUB1 N)))
                  (GO SUCC)))

          (* Note that the current expression is left at the 
          (atomic) tail to prevent accidents like 
          (MOVE FOO TO ...) and FOO is CDR of 
          (FIE . FOO))


              ]
          (RETURN NIL)
      CHECK...
          (COND
            [(AND TAIL (SETQ TEM (EDIT4E (CDR PAT)
                                         X CHANGEFLG)))

          (* Note that at this point, X may still be atomic, as in F 
          (... . B))


              [COND
                (CHANGEFLG (SETQ X (EDIT4F2 TAIL TEM C3 T]
              (COND
                ((ZEROP (SETQ N (SUB1 N)))
                  (GO SUCC))
                (CHANGEFLG 

          (* Don't want to go to LP1 because you don't want to search 
          through new structure inserted by replacement.)


                           (RETURN NIL))
                ((NLISTP X)
                  (RETURN NIL))
                (T (GO LP1]
            ((NLISTP X)
              (RETURN NIL))
            (T                                  (* PAT is a ... pattern, so 
                                                don't compare it with elements.)
               (GO DESCEND)))
      ELEMENT
          [COND
            ((SETQ TEM (EDIT4E PAT (CAR X)
                               CHANGEFLG))
              (COND
                (CHANGEFLG (EDIT4F2 X TEM C3)))
              (COND
                ((ZEROP (SETQ N (SUB1 N)))
                  [COND
                    ((OR (NULL UPFINDFLG)
                         (LISTP (CAR X)))

          (* Instead of adding atom and then doing UP -
          this check is made and atom not added if UPFINDFLG is T.)


                      (SETQ LASTAIL X)          (* For use by UP.)
                      (SETQ X (CAR X]
                  (GO SUCC))
                (CHANGEFLG 

          (* Don't want to go to DESCEND because you don't want to 
          search through new structure inserted by replacement 
          operation.)


                           (GO LP1]
      DESCEND
          (COND
            ((AND (NULL TOPLVL)
                  (LISTP (CAR X))
                  (EDIT4F1 PAT (CAR X)
                           (AND LVL (SUB1 LVL)))
                  (ZEROP N))
              (SETQ X (CAR X)))
            (T (GO LP1)))
      SUCC(AND XX (EQ X (CDDR XX))
               (SETQ X XX))                     (* CLISP%  expression.)
          (COND
            ([AND FF (NOT (AND X (EQ X (CADR FF]
                                                (* To eliminate repetitions.)
              (TCONC FF X)))
          (RETURN (OR FF T))
      LP1 (SETQ TAIL X)
          (SETQ X (CDR X))
          (AND LVL (SETQ LVL (SUB1 LVL)))
          (GO LP])

(EDIT4F2
  [LAMBDA (NODE MATCH FORMAT CDRFLG)

          (* Analagous to CONSTRUCT in FLIP, with EDITFPAT1 playing 
          the role of FORMTRAN. Replaces CAR of NODE by FORMAT 
          (CDR if CDRFLG=T). MATCH is the value returned by EDIT4E.
          If MATCH is a list of pointers and FORMAT begins with $, 
          EDIT4F2 assembles a new atom or string, replacing those 
          sequences not matched by alt-modes with elements from NEW.
          For example, user types (R $1 $2) then all terminal 1's will 
          be changed to 2's.)


    (PROG ([X (COND
		(CDRFLG (CDR NODE))
		(T (CAR NODE]
	   FLG)
          (SETQ NEWFLG T)                       (* to let EDIT4F know that a 
                                                successful match was found.)
          (SETQ FORMAT (EDIT4F3 FORMAT MATCH X))
          (COND
	    ((EQ EDITQUIETFLG T)
	      (GO OUT))
	    ((NEQ MATCH T)                      (* EDIT4E printed X.)
	      )
	    (FLG 

          (* MATCH was T, indicating no alt-modes, and therefore X was 
          not printed by EDIT4E1. However, FLG being T means a format 
          was used, and therefore X must be printed here.
          For example, (R FOO $1))


		 (PRIN2 X T T))
	    (T (GO OUT)))
          (PRIN1 (QUOTE ->)
		 T)
          (PRINT FORMAT T T)
      OUT [COND
	    (CDRFLG (EDITSMASH NODE (CAR NODE)
			       FORMAT))
	    (T (EDITSMASH NODE FORMAT (CDR NODE]
          (RETURN FORMAT])

(EDIT4F3
  [LAMBDA (FORMAT MATCH X)
    (PROG (LST)
          (COND
            ((EQ (CAR FORMAT)
                 (QUOTE ))
              (SETQ FLG T))
            [(LISTP FORMAT)
              (RETURN (CONS (EDIT4F3 (CAR FORMAT) MATCH X)
                            (EDIT4F3 (CDR FORMAT) MATCH X]
            (T (RETURN FORMAT)))
      LP  [COND
            [(NULL (SETQ FORMAT (CDR FORMAT)))
              (RETURN (COND
                        ((AND (EQ MATCH T)
                              (NULL (CDR LST)))
                          (CAR LST))
                        ((STRINGP X)
                          (APPLY (QUOTE CONCAT)
                                 LST))
                        (T (PACK LST]
            [(EQ (CAR FORMAT)
                 (QUOTE ))
              (SETQ LST (NCONC LST (COND
                                 ((EQ MATCH T)

          (* Permits user to say (R FOO $1) meaning change all FOO's 
          to FOO1's, etc.)


                                   (LIST X))
                                 (T (PROG1 (LDIFF (CAAR MATCH)
                                                  (CDAR MATCH))
                                           (SETQ MATCH (CDR MATCH]
            (T (SETQ LST (NCONC1 LST (CAR FORMAT]
          (GO LP])

(EDITFPAT
  [LAMBDA (PAT FLG)

          (* Done once at beginning of find operation.
          Replaces atoms ending in alt-modes with patterns recognized 
          by EDIT4E. Analagous to PATTRAN in FLIP, with role of MATCH 
          being played by EDIT4E1.)


    (PROG (TEM)
          (RETURN
            (COND
              [(LISTP PAT)
                (COND
                  ((OR (EQ (CAR PAT)
                           (QUOTE ==))
                       (EQ (CAR PAT)
                           (QUOTE ))
                       (EQ (CAR PAT)
                           (QUOTE )))
                    PAT)
                  (T (CONS (EDITFPAT (CAR PAT))
                           (EDITFPAT (CDR PAT]
              ([OR (EQ PAT (QUOTE ))
                   (NOT (SETQ TEM (STRPOS (QUOTE )
                                          PAT]
                PAT)
              [(AND (EQ (NTHCHAR PAT (SETQ TEM (ADD1 TEM)))
                        (QUOTE ))
                    (EQ TEM (NCHARS PAT)))

          (* Used to specify a search for a 'close' word using SKOR.
          See comment in EDIT4E.)


                (SETQ TEM (CHCON PAT))
                (FRPLACD (NLEFT TEM 3))
                (CONS (QUOTE )
                      (CONS (LENGTH TEM)
                            (CONS (PROG ((ND 0)
                                         CHAR)
                                        [MAPC TEM (FUNCTION (LAMBDA (X)
                                                  (COND
                                                    ((EQ X CHAR)
                                                      (SETQ ND (ADD1 ND)))
                                                    (T (SETQ CHAR X]
                                        (RETURN ND))
                                  TEM]
              (T (CONS (QUOTE )
                       (COND
                         (FLG (DUNPACK PAT CHCONLST1))
                         (T (UNPACK PAT])

(EDITFPAT1
  [LAMBDA (X)

          (* Analgous to FORMTRAN in FLIP, with EDIT4F2 playing the 
          role of CONSTRUCT. Used by EDIT4F once at the beginning of a 
          find operation that also specifies replacement -
          i.e. an R command. Converts an atom or string containing alt 
          modes into a list of the character sequences, e.g. if X is 
          $ABC$DEF$ then the value of EDITFPAT1 is 
          ($ $ ABC $ DEF $) (The first $ is merely a flag.))


    (COND
      ((OR (LITATOM X)
           (STRINGP X))
        (COND
          [(STRPOS (QUOTE )
                   X)
            (SETQ X (DUNPACK X CHCONLST2))
            (CONS (QUOTE )
                  (MAPCAR X [FUNCTION (LAMBDA (DUMMY)
                              (COND
                                ((EQ (CAR X)
                                     (QUOTE ))
                                  (SETQ X (CDR X))
                                  (QUOTE ))
                                (T (PACK (LDIFF X (SETQ X (FMEMB (QUOTE )
                                                                 X]
                          (FUNCTION (LAMBDA (DUMMY)
                              X]
          (T X)))
      [(LISTP X)
        (CONS (EDITFPAT1 (CAR X))
              (EDITFPAT1 (CDR X]
      (T X])

(EDITFINDP
  [LAMBDA (X PAT FLG)

          (* Allows the user to use the edit find operation as a 
          predicate without being inside the editor or doing any 
          conses.)


    (PROG ((N 1)
           CHANGEFLG LASTAIL TOPLVL FF)
          (AND (NULL FLG)
               (SETQ PAT (EDITFPAT PAT T)))
          (RETURN (OR (EDIT4E PAT X)
                      (EDIT4F1 PAT X MAXLEVEL])

(EDITBF
  [LAMBDA (PAT N)
    (PROG ((LL L)
           X Y (FF (CONS)))

          (* Same as EDIT4F, except searches in reverse printorder.
          If N is T (or at top level) search includes current 
          expression, otherwise starts with first expression that 
          would be printed before the current expression.)


          (SETQ COM PAT)
          (SETQ PAT (EDITFPAT PAT))
          (COND
            ((OR (NLISTP (CAR LL))
                 (AND (NULL N)
                      (CDR LL)))                (* Do not examine current 
                                                expression.)
              (GO LP1)))
      LP  [COND
            ((EDITBF1 PAT (CAR LL)
                      MAXLEVEL Y)
              (SETQ UNFIND L)
              (RETURN (CAR (SETQ L (NCONC (CAR FF)
                                          (COND
                                            ((EQ (CAR LL)
                                                 (CADR FF))
                                              (CDR LL))
                                            (T LL]
      LP1 (SETQ X (CAR LL))
          (COND
            ((NULL (SETQ LL (CDR LL)))
              (ERROR!))
            ([OR (SETQ Y (MEMB X (CAR LL)))
                 (SETQ Y (TAILP X (CAR LL]
              (GO LP)))
          (GO LP1])

(EDITBF1
  [LAMBDA (PAT X LVL TAIL)
    (PROG [Y XX (...PAT (AND (LISTP PAT)
                             (EQ (CAR PAT)
                                 (QUOTE ...]
          (AND (LISTP X)
               (EQ (CAR X)
                   CLISPTRANFLG)
               (SETQ XX X)
               (SETQ X (CDDR X)))
      LP  [COND
            ((AND LVL (NOT (IGREATERP LVL 0)))
              (PRIN1 (QUOTE "maxlevel exceeded.
")
                     T)
              (RETURN NIL))
            ((EQ TAIL X)
              (RETURN (COND
                        ((AND (NOT ...PAT)
                              (EDIT4E PAT X))

          (* Only compare with X after you have searched inside it, 
          e.g. if backing up to (COND -- 
          (COND --)) should find inner COND.)


                          (TCONC FF X]
          (SETQ Y X)
      LP1 (COND
            ([NULL (OR (EQ (CDR Y)
                           TAIL)
                       (NLISTP (CDR Y]

          (* TAIL is where you were last time.
          Go until you find the tail before it.)


              (SETQ Y (CDR Y))
              (GO LP1)))
          (SETQ TAIL Y)                         (* Y is a tail of X, TAIL is CDR
                                                of Y.)
          (COND
            ((AND PAT (CDR TAIL)
                  (NLISTP (CDR TAIL))
                  (EDIT4E PAT (CDR TAIL)))      (* Atomic tail.)
              (SETQ TAIL (CDR TAIL)))
            ((AND ...PAT (EDIT4E (CDR PAT)
                                 (CDR TAIL)))
              (SETQ TAIL (CDR TAIL)))
            ([AND (LISTP (CAR TAIL))
                  (EDITBF1 PAT (CAR TAIL)
                           (AND LVL (SUB1 LVL]
                                                (* Descend first before 
                                                comparing with outer one.)
              (SETQ TAIL (CAR TAIL)))
            [(AND (NOT ...PAT)
                  (EDIT4E PAT (CAR TAIL)))
              (COND
                ((OR (NULL UPFINDFLG)
                     (LISTP (CAR TAIL)))
                  (SETQ LASTAIL TAIL)
                  (SETQ TAIL (CAR TAIL]
            (T (AND LVL (SETQ LVL (SUB1 LVL)))
               (GO LP)))
          (AND XX (EQ TAIL (CDDR XX))
               (SETQ TAIL XX))
          (COND
            ([NOT (AND TAIL (EQ TAIL (CADR FF]
              (TCONC FF TAIL)))
          (RETURN FF])

(EDITNTH
  [LAMBDA (X N)

          (* If N is non-numeric, EDITELT is called, so that one can 
          give commands such as (BI COND SETQ) meaning do a BI 
          starting at the element containing COND up to the one 
          containing SETQ.)


    (PROG (TEM)
          [COND
            ((NLISTP X)
              (ERROR!))
            ((EQ (CAR X)
                 CLISPTRANFLG)
              (SETQ X (CDDR X]
          (RETURN (COND
                    ((NOT (NUMBERP N))

          (* Normally EDITELT returns the element of this level list 
          containing N. However, if N is atomic and ends with an 
          alt-mode, it will fail the first FMEMB, and EDITELT will 
          return the tail of the list, so the second MEMB will fail.
          This is the reason for the TAILP.)


                      (OR (MEMB N X)
                          (MEMB (SETQ N (EDITELT N (LIST X)))
                                X)
                          (TAILP N X)))
                    ((ZEROP N)
                      (ERROR!))
                    ([SETQ TEM (COND
                          ((MINUSP N)
                            (NLEFT X (IMINUS N)))
                          (T (NTH X N]
                      TEM)
                    (T (SETQ COM N)
                       (ERROR!])

(BPNT
  [LAMBDA (X)
    (PROG (Y N Z)
          [COND
            ((ZEROP (CAR X))
              (SETQ Y (CAR L))
              (SETQ Z (CADR L)))
            (T (SETQ Y (CAR (EDITNTH (CAR L)
                                     (CAR X]
          [COND
            ((NULL (CDR X))
              (SETQ N 1))
            ([NULL (NUMBERP (SETQ N (CADR X]
              (ERROR!))
            ((MINUSP N)
              (SETQ N (ADD1 N)))
            (T 

          (* Makes (P 0 N) have same effect as it did in old system.)


               (SETQ N (SUB1 N]
          (RETURN (BPNT0 Y N T Z])

(BPNT0
  [LAMBDA (X LVL FILE Y)

          (* Equivalent to printing X with printlevel set to LVL+1 if 
          LVL is positive, or LVL-1 if negative.)


    (AND (LISTP X)
	 (EQ (CAR X)
	     CLISPTRANFLG)
	 (SETQ X (CDDR X)))
    (COND
      ([NULL (NLSETQ (RESETFORM (PRINTLEVEL LVL)
				(COND
				  [(NLISTP X)
				    (COND
				      ((AND Y (EQ X (CDR (LAST Y)))
					    (NOT (MEMB X Y)))
					(PRIN1 (QUOTE "...  . ")
					       FILE)
					(PRIN2 X FILE T)

          (* We use standard system read table for printing on grounds 
          that even if this is going to a file, user is only dumping 
          it with bpnt to look at it, not to read it back in.)


					(PRIN1 (QUOTE ")
")
					       FILE))
				      (T (PRINT X FILE T]
				  (T (PRIN1 (COND
					      ((AND Y (TAILP X Y))
                                                (* Tail)
						(QUOTE "... "))
					      (T (QUOTE %()))
					    FILE)
				     (BPNT1 (CAR X)
					    FILE)
				     (PROG (TEM)
				       LP  (COND
					     ((NULL (SETQ X (CDR X)))
					       (RETURN))
					     ((NLISTP X)
					       (PRIN1 (QUOTE " . ")
						      FILE)
					       (PRIN2 X FILE T)
					       (RETURN))
					     ((AND (ILESSP LVL 0)
						   (LISTP TEM)
						   (LISTP (CAR X)))
					       (TERPRI FILE))
					     (T (SPACES 1 FILE)))
				           (BPNT1 (SETQ TEM (CAR X))
						  FILE)
				           (GO LP))
				     (PRIN1 (QUOTE %))
					    FILE)
				     (TERPRI FILE]
	(SETQ COM NIL)
	(ERROR!])

(BPNT1
  [LAMBDA (X FILE)
    (COND
      ((AND (LISTP X)
	    (EQ (CAR X)
		COMMENTFLG)
	    **COMMENT**FLG)
	(PRIN1 **COMMENT**FLG FILE))
      (T (PRIN2 (COND
		  ((AND (LISTP X)
			(EQ (CAR X)
			    CLISPTRANFLG))
		    (CDDR X))
		  (T X))
		FILE T])

(RI
  [LAMBDA (M N X)
    (PROG (A B)
          (SETQ A (EDITNTH X M))
          (SETQ B (EDITNTH (CAR A)
                           N))
          (COND
            ((OR (NULL A)
                 (NULL B))
              (ERROR!)))
          [PROG ((L (CONS (CAR A)
                          L)))

          (* The only reason for this is so that EDITSMASH will also 
          check (CAR a) for clisp translation.
          Note that RI is the only command which lets you change 
          something INSIDE of L. (The R command for xample is 
          rebinding L as it goes down.))


                (EDITSMASH A (CAR A)
                           (EDITNCONC (CDR B)
                                      (CDR A]
          (EDITSMASH B (CAR B)
                     NIL])

(RO
  [LAMBDA (N X)
    (SETQ X (EDITNTH X N))
    (COND
      ((OR (NULL X)
           (NLISTP (CAR X)))
        (ERROR!)))
    (EDITSMASH (SETQ N (LAST (CAR X)))
               (CAR N)
               (CDR X))
    (EDITSMASH X (CAR X])

(LI
  [LAMBDA (N X)
    (SETQ X (EDITNTH X N))
    (COND
      ((NULL X)
        (ERROR!)))
    (EDITSMASH X (CONS (CAR X)
                       (CDR X])

(LO
  [LAMBDA (N X)
    (SETQ X (EDITNTH X N))
    (COND
      ((OR (NULL X)
           (NLISTP (CAR X)))
        (ERROR!)))
    (EDITSMASH X (CAAR X)
               (CDAR X])

(BI
  [LAMBDA (M N X)
    (PROG (A B)
          (COND
            ((NULL X)                           (* Does (BI M M))
              (SETQ X N)
              (SETQ N M)))
          [SETQ B (CDR (SETQ A (EDITNTH X N]
          (SETQ X (EDITNTH X M))
          (COND
            ((AND A (TAILP A X))
              (EDITSMASH A (CAR A))
              (EDITSMASH X (CONS (CAR X)
                                 (CDR X))
                         B))
            (T (ERROR!])

(BO
  [LAMBDA (N X)
    (SETQ X (EDITNTH X N))
    (COND
      ((NLISTP (CAR X))
        (ERROR!)))
    (EDITSMASH X (CAAR X)
               (EDITNCONC (CDAR X)
                          (CDR X])
)
  (RPAQ UPFINDFLG T)
  (RPAQQ MAXLEVEL 300)
  (RPAQQ FINDFLAG NIL)
  (RPAQ EDITQUIETFLG)
  (RPAQ EDITLOADFNSFLG T)
(DEFLIST(QUOTE(
  (EDIT (EDIT WEDIT))
))(QUOTE FILEGROUP))
[DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 
  (ADDTOVAR NLAMA EDITP EDITV EDITF EDITFNS)
  (ADDTOVAR NLAML EDITF2)
]
(DECLARE: DONTCOPY
  (FILEMAP (NIL (863 73896 (EDITFNS 875 . 1219) (EDITF 1223 . 4362) (EDITF0
4366 . 5162) (EDITF1 5166 . 6931) (EDITF2 6935 . 7513) (EDITV 7517 . 8495)
(EDITP 8499 . 9190) (EDITE 9194 . 9417) (EDITL 9421 . 12645) (EDITL0 12649
. 14340) (EDITL1 14344 . 16196) (UNDOEDITL 16200 . 16738) (EDITCOM 16742 .
17562) (EDITCOMA 17566 . 24760) (EDITCOML 24764 . 31585) (EDITMAC 31589 .
31983) (EDITCOMS 31987 . 32577) (EDIT!UNDO 32581 . 33275) (UNDOEDITCOM 33279
. 34656) (UNDOEDITCOM1 34660 . 35535) (EDITCOM1 35539 . 37498) (EDITSMASH
37502 . 38493) (EDITNCONC 38497 . 38722) (EDIT1F 38726 . 39663) (EDIT2F 39667
. 43118) (EDIT4E 43122 . 44869) (EDIT4E1 44873 . 47505) (EDITQF 47509 . 47864)
(EDIT4F 47868 . 52937) (EDIT4F1 52941 . 57629) (EDIT4F2 57633 . 59126) (EDIT4F3
59130 . 60432) (EDITFPAT 60436 . 62439) (EDITFPAT1 62443 . 63774) (EDITFINDP
63778 . 64189) (EDITBF 64193 . 65541) (EDITBF1 65545 . 68005) (EDITNTH 68009
. 69349) (BPNT 69353 . 69963) (BPNT0 69967 . 71520) (BPNT1 71524 . 71794)
(RI 71798 . 72594) (RO 72598 . 72844) (LI 72848 . 73009) (LO 73013 . 73196)
(BI 73200 . 73686) (BO 73690 . 73893)))))
STOP
