<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Dove>Lisp.mc!1</title>
  </head>
  <body>
    <pre>
{File name xLisp.mc -- modified for Punt testingDescription:  DandeLion InterLisp EmulatorAuthor: PurcellCreated: June 8, 1981 on mem content trap}SetTask[0];ErrTrap:	Rx &larr; RRot1 ErrnIBnStkp, ClrIntErr, CANCELBR[$, 0F],	c1, at[0];ErrLoop:	Xbus &larr; Rx LRot0, XwdDisp,	c2;	Xbus &larr; MStatus, XLDisp, DISP2[CSParErr],	c3;CSParErr:	Q &larr; 0+1, KCtl &larr; 0, CANCELBR[sink2, 3],	c1, at[0,4,CSParErr];{MP9001}StackErr:	Q &larr; 2, CANCELBR[sink2, 3],	c1, at[2,4,CSParErr];{MP9002}IBEmptyErr:	Q &larr; 3, CANCELBR[sink2, 3],	c1, at[3,4,CSParErr];{MP9003}{LMemErr:	Noop, BRANCH[VirtAddrErr, EmuMemErr, 1],	c1, at[1,4,CSParErr];moved to InitLisp}{VirtAddrErr:	Q &larr; 4, GOTO[sink3],	c2;{MP9004}moved to InitLisp}{EmuMemErr:	Q &larr; 5, GOTO[sink3],	c2;{MP9005}moved to InitLisp}{*************************	IVAR, IVARX, PVAR, PVARX, FVAR, FVARX, STOREN	25%  4 clicks**************************}{L0 set to low nible of opcode; set L3 to 0-3 for I,P,F or S var}IVAR:	MAR &larr; S &larr; [rhS, S + 1], GOTO[IVar1], L3 &larr; 0,	c1, opcode[100'b];{40}	MAR &larr; S &larr; [rhS, S + 1], GOTO[IVar1], L3 &larr; 0,	c1, opcode[101'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[IVar1], L3 &larr; 0,	c1, opcode[102'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[IVar1], L3 &larr; 0,	c1, opcode[103'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[IVar1], L3 &larr; 0,	c1, opcode[104'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[IVar1], L3 &larr; 0,	c1, opcode[105'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[IVar1], L3 &larr; 0,	c1, opcode[106'b];IVARX:	MAR &larr; S &larr; [rhS, S + 1], GOTO[IVar1], L3 &larr; 0,	c1, opcode[107'b];PVAR:	MAR &larr; S &larr; [rhS, S + 1], GOTO[PVar1], L3 &larr; 1,	c1, opcode[110'b];{48}	MAR &larr; S &larr; [rhS, S + 1], GOTO[PVar1], L3 &larr; 1,	c1, opcode[111'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[PVar1], L3 &larr; 1,	c1, opcode[112'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[PVar1], L3 &larr; 1,	c1, opcode[113'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[PVar1], L3 &larr; 1,	c1, opcode[114'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[PVar1], L3 &larr; 1,	c1, opcode[115'b];	MAR &larr; S &larr; [rhS, S + 1], GOTO[PVar1], L3 &larr; 1,	c1, opcode[116'b];PVARX:	MAR &larr; S &larr; [rhS, S + 1], GOTO[PVar1], L3 &larr; 1,	c1, opcode[117'b];FVAR:	MAR &larr; S &larr; [rhS, S + 1], L2 &larr; 0,	c1, opcode[120'b];{50}	 uTOSH &larr; MDR &larr; TOSH, DISP3[VnoCar0, 4], L3 &larr; 4,	c2;	MAR &larr; S &larr; [rhS, S + 1], L2 &larr; 1,	c1, opcode[121'b];	 uTOSH &larr; MDR &larr; TOSH, DISP3[VnoCar0, 4], L3 &larr; 4,	c2;	MAR &larr; S &larr; [rhS, S + 1], L2 &larr; 2,	c1, opcode[122'b];	 uTOSH &larr; MDR &larr; TOSH, DISP3[VnoCar0, 4], L3 &larr; 4,	c2;	MAR &larr; S &larr; [rhS, S + 1], L2 &larr; 3,	c1, opcode[123'b];	 uTOSH &larr; MDR &larr; TOSH, DISP3[VnoCar0, 4], L3 &larr; 4,	c2;	MAR &larr; S &larr; [rhS, S + 1], L2 &larr; 4,	c1, opcode[124'b];	 uTOSH &larr; MDR &larr; TOSH, DISP3[VnoCar0, 4], L3 &larr; 4,	c2;	MAR &larr; S &larr; [rhS, S + 1], L2 &larr; 5,	c1, opcode[125'b];	 uTOSH &larr; MDR &larr; TOSH, DISP3[VnoCar0, 4], L3 &larr; 4,	c2;	MAR &larr; S &larr; [rhS, S + 1], L2 &larr; 6,	c1, opcode[126'b];	 uTOSH &larr; MDR &larr; TOSH, DISP3[VnoCar0, 4], L3 &larr; 4,	c2;FVARX:	MAR &larr; S &larr; [rhS, S + 1], L2 &larr; 7,	c1, opcode[127'b];	 uTOSH &larr; MDR &larr; TOSH, DISP3[VnoCar0, 4], L3 &larr; 4,	c2;@COPYN:	MAR &larr; S &larr; [rhS, S + 1], GOTO[SVar1],  L3 &larr; 5,	c1, opcode[75'b];IVar1:	MDR &larr; TOSH, DISP3[VnoCar0],	c2;PVar1:	MDR &larr; TOSH, DISP3[VnoCar0, 1],	c2;SVar1:	MDR &larr; TOSH, DISP3[VnoCar0, 5],	c2;{place these intructions for dispatch at VCar1 and for pageCross dispatch}	S &larr; S + 0FF + 1, GOTO[VCar1],	c3, at[2,8,VnoCar0];	S &larr; S + 0FF + 1, GOTO[VCar1],	c3, at[3,8,VnoCar0];	S &larr; S + 0FF + 1, GOTO[VCar1], L3 &larr; 4,	c3, at[6,8,VnoCar0];	S &larr; S + 0FF + 1, GOTO[VCar1],	c3, at[7,8,VnoCar0];VCar1:	MAR &larr; [rhS, S + 0], L3Disp, {retry the stack ref}	c1;	MDR &larr; TOSH, DISP3[VnoCar0],	c2;	Q &larr; uIVar, L2Disp, GOTO[V2],	c3, at[0,8,VnoCar0];	Q &larr; PV, L2Disp, GOTO[V2],	c3, at[1,8,VnoCar0];	Q &larr; PV, L2Disp, GOTO[V2],	c3, at[4,8,VnoCar0];	Q &larr; S - ib,	c3, at[5,8,VnoCar0];	MAR &larr; S &larr; [rhS, S + 1],	c1;	MDR&larr;TOS, Rx&larr;Q, L2&larr;3, CANCELBR[VarX, 3],WriteOK,	c2;V2:	MAR &larr; S &larr; [rhS, S + 1], DISP4[Voff, 8],	c1;Voff:	 MDR&larr;TOS, Rx&larr;Q+ 0, L2&larr;2, CANCELBR[Var, 2],WriteOK,	c2, at[8, 10, Voff];	 MDR&larr;TOS, Rx&larr;Q+2, L2&larr;2, CANCELBR[Var,2],WriteOK,	c2, at[9,10, Voff];	 MDR&larr;TOS, Rx&larr;Q+4, L2&larr;2, CANCELBR[Var,2],WriteOK,	c2, at[0A,10, Voff];	 MDR&larr;TOS, Rx&larr;Q+ 6, L2&larr;2, CANCELBR[Var,2],WriteOK,	c2, at[0B,10, Voff];	 MDR&larr;TOS, Rx&larr;Q+8, L2&larr;2, CANCELBR[Var,2],WriteOK,	c2, at[0C,10, Voff];	 MDR&larr;TOS, Rx&larr;Q+0A, L2&larr;2,CANCELBR[Var,2],WriteOK, c2, at[0D,10, Voff];	 MDR&larr;TOS, Rx&larr;Q+0C, L2&larr;2, CANCELBR[Var,2],WriteOK, c2, at[0E,10, Voff];VoffX:	 MDR&larr;TOS, Rx&larr;Q+ ib, L2&larr;3, CANCELBR[VarX, 3],WriteOK, c2, at[0F,10, Voff];Var:	rhRx &larr; nRhS, GOTO[Var2],	c3;VarX:	rhRx &larr; nRhS, GOTO[Var2],	c3;Var2:	MAR &larr; [rhRx, Rx + 0], L3Disp,	c1;	[] &larr; S xor uStkLimO, ZeroBranch, DISP3[IVar3, 2],	c2;IVar3:	TOSH &larr; MD, L2Disp, BRANCH[Var4, StkOvr1],	c3, at[2, 8, IVar3];PVar3:	TOSH &larr; MD, L2Disp, BRANCH[Var4, StkOvr1],	c3, at[3, 8, IVar3];SVar3:	TOSH &larr; MD, L2Disp, BRANCH[Var4, StkOvr1],	c3, at[7, 8, IVar3];Var4:	MAR &larr; Q &larr; [rhRx, Rx + 1], BRANCH[$, varPcX, 0E{2}],	c1;	PC &larr; PC + PC16, L2 &larr; L2.0, IBDisp, DISP2[varEnd],	c2;varPcX:	PC &larr; PC + 1, L2 &larr; L2.0, IBDisp, DISP2[varEnd],	c2;DNI.TOSg: {common tail}varEnd:	TOS &larr; MD, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0, 4, varEnd];varEndCar:	Q &larr; 80'd, GOTO[sink1], {"impossible"}	c3, at[2, 4, varEnd];{MP9080}{Stack Limit:}StkOvr1:	MAR &larr; Q &larr; [rhRx, Rx + 1],  BRANCH[$, varPcXov, 0E{2}],	c1;	PC &larr; PC + PC16, CANCELBR[varEndOv, 2],	c2;varPcXov:	PC &larr; PC + 1, CANCELBR[varEndOv, 2],	c2;varEndOv:	TOS &larr; MD, GOTO[StackOverflow],	c3;{*******************************	PVAR&larr;, PVARX&larr;, IVARX&larr;	4%  2 clicks*******************************}SPVAR:	MAR &larr; Q &larr; [rhPV, PV + 0 + 1], GOTO[SVar],	c1, opcode[130'b];{58}	MAR &larr; Q &larr; [rhPV, PV + 2 + 1], GOTO[SVar],	c1, opcode[131'b];	MAR &larr; Q &larr; [rhPV, PV + 4 + 1], GOTO[SVar],	c1, opcode[132'b];	MAR &larr; Q &larr; [rhPV, PV + 6 + 1], GOTO[SVar],	c1, opcode[133'b];	MAR &larr; Q &larr; [rhPV, PV + 8 + 1], GOTO[SVar],	c1, opcode[134'b];	MAR &larr; Q &larr; [rhPV, PV + 0A + 1], GOTO[SVar],	c1, opcode[135'b];	MAR &larr; Q &larr; [rhPV, PV + 0C + 1], GOTO[SVar],	c1, opcode[136'b];SVar:	MDR &larr; TOS, Rx&larr;Q, rhRx&larr;nRhS, BRANCH[SVNoCar, SVCarry, 1],	c2;SVCarry:	Rx &larr; Q + 0FF +1,	c3;	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TOS,	c2;SVNoCar:	PC &larr; PC + PC16, GOTO[SVTail],	c3;@STOREN:	MAR &larr; Q &larr; [rhS, S - ib],	c1, opcode[74'b];	MDR &larr; TOS, Rx&larr;Q, rhRx&larr;nRhS, BRANCH[STXNoC, STXCar, 1],	c2;STXCar:	Rx &larr; Q - 0FF -1, GOTO[STCar1],	c3;STCar1:	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TOS,	c2;STXNoC:	PC &larr; PC + 1, GOTO[SVTail],	c3;@SPVARX:	MAR &larr; Q &larr; [rhPV, PV + ib + 1],	c1, opcode[137'b];{5F}	MDR &larr; TOS, Rx&larr;Q, rhRx&larr;nRhS, BRANCH[SVXNoC, SVXCar, 1],	c2;SVXCar:	Rx &larr; Q + 0FF +1, GOTO[SVCar1],	c3;@SIVARX:	rhRx&larr;nRhS,     {1% 3 clicks}	c1, opcode[142'b];{62}	Rx &larr; uIVar,	c2;	Rx &larr; Rx + ib + 1, GOTO[SVCar1],	c3;SVCar1:	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TOS,	c2;SVXNoC:	PC &larr; PC + 1,	c3;SVTail:	MAR &larr; [rhRx, Rx - 1], L2 &larr; L2.0,	c1;	MDR &larr; TOSH, IBDisp, DISP2[DNI.nop], WriteOK,	c2;DNI.nop: {common tail}	L2 &larr; L2.0, DISPNI[OpTable],	c3;CantGetHere:	Q &larr; 88'd, GOTO[sink1],	c3, at[2, 4, DNI.nop];{*******************************	GVAR	3%  5 clicks*******************************}GVAR:	MAR &larr; S &larr; [rhS, S + 1],	c1, opcode[140'b];	MDR &larr; TOSH, TT &larr; ib, BRANCH[$, GVCross, 1],	c2;GVnoCross:	TT &larr; TT LRot8,	c3;	MAR &larr; S &larr; [rhS, S + 1],	c1;	MDR &larr; TOS, CANCELBR[$, 2], WriteOK,	c2;	TT &larr; (TT or ib) LShift1, NegBr,	c3;	BRANCH[gvarlo, gvarhi],	c1;gvarlo:	rhTT &larr; VALspace, GOTO[gvarx],	c2;gvarhi:	rhTT &larr; VALspaceHi, GOTO[gvarx],	c2;gvarx:	,	c3;	Map &larr; Q &larr; [rhTT,TT], L0 &larr; L0.RedoGV,	c1;	L1 &larr; L1.PopOnly,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;{RedoGV:}	MAR&larr; [rhRx, Q + 0], BRANCH[GVMap,$],	c1, at[L0.RedoGV,10,RMapFixCaller];	[] &larr; S xor uStkLimO, ZeroBranch,	c2;	TOSH &larr; MD, BRANCH[$, GVStkOvr],	c3;	MAR &larr; Q &larr; [rhRx, Q + 1],  L2 &larr; L2.0,	c1;	PC &larr; PC + 1 + PC16, IBDisp, CANCELBR[DNI.TOSg, 0],	c2;GVMap:	CALL[RLMapFix]{will return to RedoGV},	c2;{Stack Limit:}GVStkOvr:	MAR &larr; Q &larr; [rhRx, Q + 1], 	c1;	PC &larr; PC + 1 + PC16, CANCELBR[$,2],	c2;	TOS &larr; MD, GOTO[StackOverflow],	c3;{page cross}GVCross:	S &larr; S + 0FF + 1,	c3;	MAR &larr; [rhS, S + 0],	c1;	MDR &larr; TOSH, GOTO[GVnoCross],	c2;{*******************************	PVARd&larr;	2%  4 clicks*******************************}SPVARd:	MAR &larr; Q &larr; [rhPV, PV + 0 + 1], GOTO[SVarD],	c1, opcode[270'b];{B8}	MAR &larr; Q &larr; [rhPV, PV + 2 + 1], GOTO[SVarD],	c1, opcode[271'b];	MAR &larr; Q &larr; [rhPV, PV + 4 + 1], GOTO[SVarD],	c1, opcode[272'b];	MAR &larr; Q &larr; [rhPV, PV + 6 + 1], GOTO[SVarD],	c1, opcode[273'b];	MAR &larr; Q &larr; [rhPV, PV + 8 + 1], GOTO[SVarD],	c1, opcode[274'b];	MAR &larr; Q &larr; [rhPV, PV + 0A + 1], GOTO[SVarD],	c1, opcode[275'b];	MAR &larr; Q &larr; [rhPV, PV + 0C + 1], GOTO[SVarD],	c1, opcode[276'b];SVarD:	MDR &larr; TOS, Rx &larr; Q, rhRx &larr; nRhS, BRANCH[$, SVDCarry, 1],	c2;SVDcont:	,	c3;	MAR &larr; [rhRx, Rx - 1],	c1;	MDR &larr; TOSH, CANCELBR[$, 2], WriteOK,	c2;	GOTO[POP],	c3;SVDCarry:	Rx &larr; Rx + 0FF +1,	c3;	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TOS, GOTO[SVDcont],	c2;{*************************	GETBASEN	3%  3 clicks**************************}GETBASEN:		TT &larr; TOS + ib, CarryBr, L2 &larr; L2.0,	c1, opcode[310'b];{C8}	Rx{TOSH+1} &larr; TOSH+1, BRANCH[$, GBNseg],	c2;	rhTT &larr; TOSH LRot0,	c3;MapGBN:	Map &larr; Q &larr; [rhTT,TT], L0 &larr; L0.RedoGBN,	c1;	PC &larr; PC + 1, L1 &larr; L1.DecDec,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;{RedoGBN:}	MAR&larr; [rhRx,Q+0], BRANCH[GBNMap,$],	c1,at[L0.RedoGBN,10,RMapFixCaller];	TOSH &larr; smallpl, IBDisp, GOTO[DNI.TOSg],	c2;GBNMap:	CANCELBR[RLMapFix, 3]{will return to RedoGBN},	c2;GBNseg:	rhTT &larr; Rx{TOSH+1} LRot0,  GOTO[MapGBN],	c3;{*************************	GETBASEPTRN (base, 1st byte=offset)**************************}GETBASEPTRN:		TT &larr; TOS + ib, CarryBr, 	c1, opcode[311'b];{C9}	Rx{TOSH+1} &larr; TOSH+1, BRANCH[$, BPseg],	c2;	rhTT &larr; TOSH LRot0,	c3;MapBP:	Map &larr; Q &larr; [rhTT,TT], L0 &larr; L0.RedoBP,	c1;	PC &larr; PC + 1, L1 &larr; L1.DecDec,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;{RedoBP:}	MAR&larr; [rhRx, Q + 0], BRANCH[BPMap,$],	c1,at[L0.RedoBP,10,RMapFixCaller];	TOSH &larr; 0FF,	c2;	TOSH &larr; MD and TOSH,	c3;	MAR&larr; [rhRx, Q + 1], L2 &larr; L2.0,	c1;	IBDisp, CANCELBR[DNI.TOSg, 0],	c2;BPMap:	CALL[RLMapFix]{will return to RedoBP},	c2;BPseg:	rhTT &larr; Rx{TOSH+1} LRot0, GOTO[MapBP],	c3;{*************************	GETBASEBYTE:  {ptr, disp}	3%  4.5 clicks**************************}GETBASEBYTE:   {ptr, disp}	MAR &larr; [rhS, S], S &larr; S -1,	c1, opcode[302'b];{C2}	Ybus &larr; TOSH xor smallpl, NZeroBr, CANCELBR[$,2],	c2;	TT &larr; MD{ptr}, BRANCH[$, ufnBY],	c3;	MAR &larr; [rhS, S], S &larr; S - 1, L1 &larr; L1.PushOnly,	c1;	Rx &larr; TOS RShift1, YDisp, BRANCH[$, BYCarry, 1],	c2;BYret:	rhTT &larr; MD{ptrH}, TT &larr; TT + Rx, CarryBr, BRANCH[BYeven, $, 0E],	c3;BYodd:	Map &larr; [rhTT, TT], {L0 &larr; L0.BYRedoO,} BRANCH[$, BYOseg],	c1;	Q &larr; {u}0FF,  L0 &larr; L0.BYRedoO,	c2;	Rx &larr; rhRx &larr; MD, XRefBr, 	c3;BYRedoO:	MAR &larr; [rhRx, TT + 0],  BRANCH[BYMapUDO,$],	c1, at[L0.BYRedoO,10, RMapFixCaller];	PC &larr; PC + PC16, L2 &larr; L2.0, IBDisp,	c2;	TOS &larr; MD and Q, L2 &larr; L2.0, DISPNI[OpTable],	c3;BYeven:	Map &larr; [rhTT, TT],  BRANCH[$, BYEseg],	c1;	Noop,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;{BYedoE:}	MAR&larr; [rhRx, TT + 0], L0 &larr; L0.BYRedoE, BRANCH[BYMapUDE,$],	c1, at[L0.BYRedoE,10, RMapFixCaller];	Q &larr; ~0FF, L2 &larr; L2.0,	c2;	TOS &larr; MD and Q,	c3;	TOS &larr; TOS LRot8, GOTO[IB.pc1],	c1;ufnBY:	Rx &larr; 302'b, CANCELBR[ufn2incS, 3]	c1;BYMapUDE:	CALL[RLMapFix],	c2;BYMapUDO: CALL[RLMapFix],	c2;{page cross:}BYCarry:	S &larr; S - 0FF, CANCELBR[$, 0F],	c3;	MAR &larr; [rhS, S + 0],	c1;	S &larr; S - 1, GOTO[BYret], Ybus &larr; TOS, YDisp,	c2;BYOseg:	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c2;	rhTT &larr; Q LRot0, GOTO[BYodd],	c3;BYEseg:	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c2;	rhTT &larr; Q LRot0, GOTO[BYeven],	c3;{*************************PUTBASEN:   {ptr, val =&gt; ptr}	1%  4 clicks**************************}PUTBASEN:	MAR &larr; [rhS, S], S &larr; S - 1,	c1, opcode[315'b];{CD}	Ybus &larr; TOSH xor smallpl, NZeroBr, CANCELBR[$, 2],	c2;	Rx &larr; MD{ptr}, BRANCH[$, ufnPUTB],	c3;	MAR &larr; [rhS, S], S &larr; S - 1, L0 &larr; L0.RedoW,	c1;	TT &larr; Rx + ib, CarryBr, BRANCH[$, PBCar, 1],	c2;PBCont:	Q{ptrH} &larr; rhTT &larr; MD{ptrH}, BRANCH[$, PBSeg],	c3;PBsegok:	Map &larr; {TT &larr;}  [rhTT, TT +0{- 1}], {Xbus &larr; ib,}	c1;	uuRx{ptr} &larr; Rx, PC &larr; PC + 1, L1 &larr; L1.PushDec2,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;{RedoW:}	MAR &larr; [rhRx, TT + 0], DISP2[PBMap],	c1,at[L0.RedoW,10,WMapFixCaller];	MDR &larr; TOS, TOSH &larr; Q{ptrH}, IBDisp, L2 &larr; L2.0,	c2, at[1, 4, PBMap];DNI.funny:	TOS &larr; uuRx{ptr}, L2 &larr; L2.0, DISPNI[OpTable],	c3;	CALL[WLMapFix], {will return to RedoW}	c2, at[0, 4, PBMap];	CALL[WLMapFix], {will return to RedoW}	c2, at[2, 4, PBMap];	CALL[WLMapFix], {will return to RedoW}	c2, at[3, 4, PBMap];ufnPUTB:	Rx &larr; 315'b, GOTO[ufn2incS]	c1;{memory reference is good, but S is +0FF instead of -1}PBCar:	Noop, BRANCH[$, PBCarSeg],	c3;	MAR &larr; S{S - 0FF} &larr; [rhS, 0 + 0],	c1;	S &larr; S - 1, GOTO[PBCont],	c2;PBCarSeg:	MAR &larr; S{S - 0FF} &larr; [rhS, 0 + 0],	c1;	S &larr; S - 1, Xbus &larr; 1, XDisp, GOTO[PBCont],	c2;PBSeg:	Q &larr; Q+1,	c1;	rhTT &larr; Q{ptrH+1} LRot0,	c2;	Q &larr; Q - 1, GOTO[PBsegok],	c3;{*************************}PUTBASEPTRN:   {(ptr, val =&gt; ptr)	2%  5 clicks}	MAR &larr; [rhS, S], S &larr; S -1,	c1, opcode[316'b];{CE}	PC &larr; PC + 1, CANCELBR[$, 2],	c2;	Rx &larr; MD{ptr},	c3;	MAR &larr; [rhS, S + 0], L0 &larr; L0.RedoPBP, 	c1;	{uuRx &larr; Rx,} TT &larr; Rx + ib {+ 1},CarryBr, 	c2;	Q{ptrH} &larr;  rhTT &larr; MD{ptrH}, BRANCH[$, PBPSeg],	c3;PBPok:	Map &larr; [rhTT, TT+0],	c1;	uuRx &larr; Rx, S &larr; S +{-} 1, L1 &larr; L1.DecDec{PushDec2},	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;{fiddle with S to make Cin one for uuRx &larr; Rx}{RedoPBP:}	MAR &larr; [rhRx, TT + 1], DISP2[PBPMap],	c1,at[L0.RedoPBP,10,WMapFixCaller];	MDR &larr; TOS, CANCELBR[$, 2], WriteOK,	c2, at[1, 4, PBPMap];	S &larr; S-2,	c3;	MAR &larr; [rhRx, TT + 0], L2 &larr; L2.0,	c1;	MDR &larr; TOSH, TOSH &larr; Q{ptrH}, IBDisp, GOTO[DNI.funny],	c2;{	TOS &larr; uuRx{ptr}, DISPNI[OpTable],	c3;}	CANCELBR[WLMapFix, 3], {return to RedoPBP}	c2, at[0, 4, PBPMap];	CANCELBR[WLMapFix, 3], {return to RedoPBP}	c2, at[2, 4, PBPMap];	CANCELBR[WLMapFix, 3], {return to RedoPBP}	c2, at[3, 4, PBPMap];PBPSeg:	Q &larr; Q+1,	c1;	rhTT &larr; Q{ptrH+1} LRot0,	c2;	Q &larr; Q - 1, GOTO[PBPok],	c3;{*************************}PUTBASEBYTE:   {ptr, disp, val =&gt; val}	{3%  9{7}clicks}	MAR &larr; [rhS, S], S &larr; S -1,	c1, opcode[307'b];{C7}{S = S - 1}	Ybus &larr; TOSH xor smallpl, NZeroBr, CANCELBR[$, 2],	c2;	Rx &larr; MD{disp}, BRANCH[$, ufnPBY],	c3;	MAR &larr; [rhS, S + 0],	c1;	S &larr; S -1,	c2;{S = S - 2}	Q &larr; MD{dispH},	c3;	MAR &larr; [rhS, S], S &larr; S -1,	c1;{S = S - 3}	Ybus &larr; Q xor smallpl, NZeroBr, CANCELBR[$,2],	c2;	uRx &larr; Rx, TT &larr; MD{ptr}, BRANCH[$, ufnPBY1],	c3;	MAR &larr; [rhS, S], S &larr; S - 1, L1 &larr; L1.Push2OK,	c1;{S = S - 4}	Rx &larr; Rx RShift1, YDisp, BRANCH[$, PBYCarry, 1],	c2;PBYret:	rhTT &larr; MD{ptrH}, TT &larr; TT + Rx, CarryBr, BRANCH[$, oddS, 0E],	c3;evenS:	Map &larr; [rhTT, TT], BRANCH[$, PBYESeg],	c1;	Q &larr; 0FF, L0 &larr; L0.WBYRedoE,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;{WBYRedoE:}	MAR &larr; [rhRx, TT + 0], DISP2[WBYMapUDE],	c1, at[L0.WBYRedoE,10,WMapFixCaller];	TOS &larr; TOS LRot8,	c2, at[1, 4, WBYMapUDE];joinY:	Q &larr; MD and Q,	c3;	Q &larr; Q or TOS,	c1;	TOS &larr; TOS LRot8 xor TOS,	c2;	TOS &larr; TOS and 0FF,	c3;		MAR &larr; [rhRx, TT + 0], L2 &larr; L2.0,	c1;	MDR &larr; Q, IBDisp, GOTO[DNI.pc1],	c2;oddS:	Map &larr; {Q &larr;} [rhTT, TT], BRANCH[$, PBYOSeg],	c1;	L0 &larr; L0.WBYRedoO,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;WBYRedoO:	MAR &larr; [rhRx, TT + 0], DISP2[WBYMapUDO],	c1, at[L0.WBYRedoO,10,WMapFixCaller];	Q &larr; ~0FF, GOTO[joinY],	c2, at[1, 4, WBYMapUDO];ufnPBY:	Rx &larr; 307'b, CANCELBR[ufn2incS, 3]	c1;ufnPBY1:	Rx &larr; 307'b, GOTO[ufn2inc3S],	c1;	CALL[WLMapFix],	c2, at[0, 4, WBYMapUDE];	CALL[WLMapFix],	c2, at[2, 4, WBYMapUDE];	CALL[WLMapFix],	c2, at[3, 4, WBYMapUDE];		CALL[WLMapFix],	c2, at[0, 4, WBYMapUDO];	CALL[WLMapFix],	c2, at[2, 4, WBYMapUDO];	CALL[WLMapFix],	c2, at[3, 4, WBYMapUDO];{page cross:}PBYCarry:	S &larr; S - 0FF, CANCELBR[$, 0F],	c3;	MAR &larr; [rhS, S + 0],	c1;	S &larr; S - 1, GOTO[PBYret], Xbus &larr; uRx, XDisp,	c2;PBYESeg:	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c2;	rhTT &larr; Q LRot0, GOTO[evenS],	c3;PBYOSeg:	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c2;	rhTT &larr; Q LRot0, GOTO[oddS],	c3;{*************************	ADDBASE (ptr, disp)	1%  3 clicks**************************}ADDBASE:	MAR &larr; [rhS, S], S &larr; S -1,	c1, opcode[320'b];{D0}	Ybus &larr; TOSH xor smallpl, NZeroBr, CANCELBR[$,2],	c2;	Rx &larr; MD, BRANCH[$, ufnAB],	c3;	MAR &larr; [rhS, S + 0], {S &larr; S -1,}	c1;	TOS &larr; TOS + Rx, CarryBr,	c2;	TOSH &larr; MD, BRANCH[adBnoc, adBcar],	c3;adBnoc:	GOTO[addBtail],	c1;adBcar:	TOSH &larr; TOSH + 1, GOTO[addBtail],	c1;addBtail:	S &larr; S - 1, IBDisp, L2 &larr; L2.0,	c2;DNI.pc1: {common tail}	PC &larr; PC + PC16, L2 &larr; L2.0, DISPNI[OpTable]	c3;ufnAB:	Rx &larr; 320'b, GOTO[ufn2incS],	c1;{*************************	HILOC, LOLOC	2%  1 click**************************}HILOC:	TOS &larr; TOSH, GOTO[LoLoc1],	c1, opcode[322'b];{D2}LOLOC:	Noop,	c1, opcode[323'b];{D3}LoLoc1:	TOSH &larr; smallpl, IBDisp, L2 &larr; L2.0, GOTO[DNI.pc1],	c2;{*************************	COPY	3% 2 clicks**************************}COPY:	MAR &larr; S &larr; [rhS, S + 1],	c1, opcode[144'b];{64}CopyRet:	MDR &larr; TOSH, S &larr; S + 1, BRANCH[$, CopyCarry, 1],	c2;	Ybus &larr; S xor uStkLimO, ZeroBranch,	c3;	MAR &larr; [rhS, S + 0], BRANCH[$, CopyStkLim],	c1;	MDR &larr; TOS, IBDisp, L2 &larr; L2.0, GOTO[DNI.pc1],	c2;{page cross:}CopyCarry:	S &larr; S + 0FF,	c3;	MAR &larr; [rhS, S + 0], GOTO[CopyRet],	c1;{Stack Limit:}CopyStkLim:	MDR &larr; TOS, 	c2;	PC &larr; PC + PC16, GOTO[StackOverflow],	c3;{*************************	NIL, KT, ZERO, ONE, SIC, SNIC	15 %  2 clicks	SICX, ACONST, ATOMNUMBER	 5 %  3 clicks**************************}LinkCross:	PV &larr; Q{PV - 9 + 100h} - 0FF - 1, 	c3;	MAR &larr; Q{PV- 9} &larr; [rhPV, PV + 0], GOTO[link2],	c1;MYALINK:	MAR &larr; Q{PV- 9} &larr; [rhPV, PV - 9], L3 &larr; L3.pls1,	c1, opcode[146'b];link2:	PV &larr; Q + 9, BRANCH[$, LinkCross, 1],	c2;	Q &larr; MD, XLDisp, L2 &larr; L2.0,	c3;	MAR &larr; S &larr; [rhS, S + 2], BRANCH[linkE, linkO, 0E],	c1;linkE:	STK &larr; MDR &larr; TOS, TOS &larr; Q - 0A, DISP2[NoCar],	c2;linkO:	STK &larr; MDR &larr; TOS, TOS &larr; Q - 0B, DISP2[NoCar],	c2;ACONST:	Rx &larr; ib, L3 &larr; L3.atm3,	c1, opcode[147'b];{67}	Rx &larr; Rx LRot8, GOTO[xx],	c2;ATOMN:	Rx &larr; ib, L3 &larr; L3.pls3, GOTO[sic2],	c1, opcode[160'b];{70}SICX:	Rx &larr; ib, L3 &larr; L3.pls3,	c1, opcode[156'b];{6E}sic2:	Rx &larr; Rx LRot8, GOTO[xx],	c2;xx:	Q &larr; Rx or ib, Cin&larr;pc16,  {prepare for inc3}	c3;	MAR &larr; S &larr; [rhS, S + 2],	c1;	STK &larr; MDR &larr; TOS, TOS &larr; Q, L2 &larr; L2.0, DISP2[NoCar],	c2;NIL:	MAR &larr; S &larr; [rhS, S + 2], L3 &larr; L3.atm1,	c1, opcode[150'b];{68}L3Zero:	STK &larr; MDR &larr; TOS, TOS &larr; 0, L2 &larr; L2.0, DISP2[NoCar],	c2;KT:	MAR &larr; S &larr; [rhS, S + 2], L3 &larr; L3.atm1,	c1, opcode[151'b];{69}	STK &larr; MDR &larr; TOS, TOS &larr; KTval, L2 &larr; L2.0, DISP2[NoCar],	c2;ZERO:	MAR &larr; S &larr; [rhS, S + 2], L3 &larr; L3.pls1,	c1, opcode[152'b];{6A}	STK &larr; MDR &larr; TOS, TOS &larr; 0, L2 &larr; L2.0, DISP2[NoCar],	c2;ONE:	MAR &larr; S &larr; [rhS, S + 2], L3 &larr; L3.pls1,	c1, opcode[153'b];{6B}	STK &larr; MDR &larr; TOS, TOS &larr; 1, L2 &larr; L2.0, DISP2[NoCar],	c2;SIC:	MAR &larr; S &larr; [rhS, S + 2], L3 &larr; L3.pls2,	c1, opcode[154'b];{6C}	uTOS &larr; MDR &larr; TOS, TOS &larr; ib, L2 &larr; L2.0, DISP2[NoCar],	c2;SNIC:	Q &larr; ib,     {shorten ?%!}	c1, opcode[155'b];{6D}	Q &larr; Q - 0FF - 1,	c2;	Noop,	c3;	MAR &larr; S &larr; [rhS, S + 2], L3 &larr; L3.neg2,	c1;	uTOS &larr; MDR &larr; TOS, TOS &larr; Q, L2 &larr; L2.0, DISP2[NoCar],	c2;Carry:	S &larr; S + 0FF + 1, L3Disp,	c3, at[2,4,NoCar];	MAR &larr; [rhS, S + 0], BRANCH[saveS, saveU, 0B],	c1;saveU:	MDR &larr; uTOS, L2 &larr; L2.0, GOTO[NoCar],	c2;saveS:	MDR &larr; STK, L2 &larr; L2.0, GOTO[NoCar],	c2;NoCar:	Ybus &larr; S xor uStkLimO, ZeroBranch, L3Disp,	c3, at[0,4,NoCar];	MAR &larr; [rhS, S - 1], Xbus&larr;0, XC2npcDisp, L3Disp, DISP4[SicTosh, 8],	c1;	MDR &larr; TOSH, TOSH &larr; 0{atom}, IBDisp, DISP4[Kinc, 6], WriteOK,	c2, at[8, 10, SicTosh];	MDR &larr; TOSH, TOSH &larr; 0{atom},  DISP4[KincL, 6], WriteOK,	c2, at[9, 10, SicTosh];	MDR &larr; TOSH, TOSH &larr; smallpl, IBDisp, DISP4[Kinc, 6], WriteOK,	c2, at[0A, 10, SicTosh];	MDR &larr; TOSH, TOSH &larr; smallpl, DISP4[KincL, 6], WriteOK,	c2, at[0B, 10, SicTosh];	MDR &larr; TOSH, TOSH &larr; smallpl, IBDisp, CANCELBR[inc2, 0F], WriteOK,	c2, at[0C, 10, SicTosh];	MDR &larr; TOSH, TOSH &larr; smallpl, CANCELBR[incL2, 0F], WriteOK,	c2, at[0D, 10, SicTosh];	MDR &larr; TOSH, TOSH &larr; smallneg, IBDisp, CANCELBR[inc2, 0F], WriteOK, c2, at[0E, 10, SicTosh];	MDR &larr; TOSH, TOSH &larr; smallneg, CANCELBR[incL2, 0F], WriteOK,	c2, at[0F, 10, SicTosh];inc2:	PC &larr; PC + 1, L2 &larr; L2.0, DISPNI[OpTable],	c3;incL2:	PC &larr; PC + 1, L2 &larr; L2.0, GOTO[StackOverflow],	c3;inc1:	PC &larr; PC + PC16, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[6,10, Kinc];	PC &larr; PC + PC16, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[7,10, Kinc];incL1:	PC &larr; PC + PC16, GOTO[StackOverflow],	c3, at[6,10, KincL];	PC &larr; PC + PC16, GOTO[StackOverflow],	c3, at[7,10, KincL];inc3:	PC &larr; PC + 1, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0E,10, Kinc];	PC &larr; PC + 2, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0F,10, Kinc];incL3:	PC &larr; PC + 1, GOTO[StackOverflow],	c3, at[0E,10, KincL];	PC &larr; PC + 2, GOTO[StackOverflow],	c3, at[0F,10, KincL];{*************************	GCONST**************************}{uPCCrossL will be off no matter what: suceed, fault, stkOver}GCONST:	MAR &larr; S &larr; [rhS, S + 1],	c1, opcode[157'b];{6F}	uTOSH &larr; MDR &larr; TOSH, TOSH &larr; ib, BRANCH[$, GCCarry, 1],	c2;GCNoCarry:	Rx &larr; ib, L0 &larr; L0.RedoGC,	c3;	MAR &larr; PC &larr; [rhPC, PC + 2], L1 &larr; L1.TrapGC{fault trap},	c1;	Rx &larr; Rx LRot8, BRANCH[$, GCPCCarry, 1],	c2;GCPCNoC:	IB &larr; MD, Q &larr; Rx,	c3;GCok:	MAR &larr; S &larr; [rhS, S + 1],	c1;	MDR &larr; TOS, TOS &larr; Q or ib, CANCELBR[$, 2], WriteOK,	c2;	Ybus &larr; S xor uStkLimO, ZeroBranch, L2 &larr; L2.0,	c3;	MAR &larr; [rhPC, PC + 1], BRANCH[$, GConStkLim],	c1;RefillNE1:	AlwaysIBDisp, L0 &larr; L0.NERefill.Set, DISP2[NoRCross],	c2;{exceptions:}{if page cross succeedes update UvPCpageL and uPCCrossL}GCCarry:	S &larr; S + 0FF + 1,	c3;	MAR &larr; [rhS, S + 0],	c1;	MDR &larr; uTOSH, GOTO[GCNoCarry],	c2;GCPCCarry:	Q &larr; 0FF + 1, L1 &larr; L1.TrapGC{fault trap},	c3;	TT &larr; UvPCpageL, GOTO[UpdatePC2],	c1;{uPCCrossL will be off no matter what: suceed, fault, stkOver}GCCross:	uPCCrossL &larr; TT{0 low}, PC &larr; MD, rhPC &larr; MD, XRefBr,	c3, at[L0.RedoGC,10,ECross];	MAR &larr; Q &larr; [rhPC, Q + 0], BRANCH[GCMap, $],	c1;	UvPCpageL &larr; TT, PC &larr; Q, GOTO[GCPCNoC],	c2;{PC page cross plus map update: save Rx}GCMap:	uRx &larr; Rx,  {returns at GCRedo}	c2;	Rx &larr; PC, Xbus &larr; PC LRot0,XwdDisp, GOTO[RLMapFix1],	c3;GCRedo:	MAR &larr; PC &larr; [rhPC, Q + 0], CANCELBR[$],	c1, at[L0.RedoGC, 10, RMapFixCaller];	Q &larr; uRx,	c2;	UvPCpageL &larr; TT, IB &larr; MD, GOTO[GCok],	c3;GCTrap:	TOSH &larr; uTOSH,	c1, at[L1.TrapGC,10,Fix];	PC &larr; Q{PC}{++} - 2,	c2;	S &larr; S -1, GOTO[NoFixes],	c3;{Stack Limit:}GConStkLim:	CANCELBR[$, 2],	c2;	GOTO[StackOverflow],	c3;{*************************	POP	5%  2 click**************************}POP:	MAR &larr; [rhS, S - 1],	c1, opcode[277'b];{BF}	PC &larr; PC + PC16, CANCELBR[$, 2],	c2;	TOSH &larr; MD,	c3;	MAR &larr; [rhS, S + 0],	c1;	S &larr; S - 2, IBDisp, L2 &larr; L2.0, GOTO[DNI.TOSg],	c2;{opcode 300Q was designated as POP.N where alphabyte says how many things to pop, but I forgot how we spec'd whether POP.N 0 had no effect or popped one thing. Which is more convenient?}@POP.N:	opcode[300'b],	Rx &larr; LShift1 ib, SE &larr; 0,	c1;	S &larr; S - Rx,	c2;	PC &larr; PC + PC16, GOTO[POP],	c3;	{*************************	SWAP**************************}SWAP:	MAR &larr; [rhS, S - 1],	c1, opcode[375'b];{FD}	PC &larr; PC + PC16, MDR &larr; TOSH, CANCELBR[$, 2], WriteOK,	c2;	TOSH &larr; MD,	c3;	MAR &larr; [rhS, S + 0],	c1;	MDR &larr; TOS, IBDisp, L2 &larr; L2.0, GOTO[DNI.TOSg],	c2;{*************************	NOP**************************}NOP:	PC &larr; PC + PC16, GOTO[IB.nop],	c1, opcode[376'b];{FE}{*************************	EQ		3%  3 clicks**************************}EQ:	MAR &larr; [rhS, S], S &larr; S - 1,	c1, opcode[360'b];{F0}	PC &larr; PC + PC16, CANCELBR[$, 2],	c2;	Rx &larr; MD xor TOS,	c3;	MAR &larr; [rhS, S + 0],	c1;	S &larr; S - 1,	c2;	TT &larr; MD xor TOSH,	c3;	Ybus &larr; Rx or TT, ZeroBr, L2 &larr; L2.0,	c1;	TOSH &larr; 0{atm}, IBDisp, BRANCH[eqNIL, eqKT],	c2;eqNIL:	TOS &larr; 0{NIL}, L2 &larr; L2.0, DISPNI[OpTable],	c3;eqKT:	TOS &larr; KTval, L2 &larr; L2.0, DISPNI[OpTable],	c3;{***********************}APPLY:  {(S) Flush top of  stack}	opcode[016'b],{0E}	MAR &larr; [rhS, S - 1], L3{ib's}&larr;0,	c1;applyTl:	TT &larr; 0FF + 1{400=AT.INTERPRETER%}, CANCELBR[$ ,2],	c2;	Q &larr; MD{nargsHi},	c3;	MAR &larr; [rhS, S + 0],	c1;	Ybus &larr; Q xor smallpl, NZeroBr,	c2;	{TOSH &larr; }rhTOSH &larr; MD{nargs}, BRANCH[$, appUfn],	c3;	rhTT &larr; TOSH{defHi} LRot0, ZeroBr,	c1;	TOSH{args2} &larr; rhTOSH{args} LShift1, BRANCH[$, applyCode],	c2;notCCode:	PV &larr; PV - 6,	c3;	MAR &larr; [rhPV, PV + 0],	c1;	MDR &larr; TOSH{iVar} &larr; S - TOSH{arg2} - 1,	c2;	PV &larr; PV + 6,	c3;	MAR &larr; [rhS, S - 1],	c1;	MDR &larr; rhTT, CANCELBR[interpret3, 2], WriteOK,	c2;applyCode:	TT &larr; TOS, GOTO[apply2],	c3;apply2:	MAR &larr; [rhPV, PV - 6],	c1;	MDR &larr; TOSH{iVar} &larr; S - TOSH{arg2} - 1, BRANCH[$, SCar9, 1],	c2;SC9Cont:	,	c3;	uTT &larr; TT, TT &larr; LShift1 TT, SE &larr; 1, NegBr,	c1;	BRANCH[appLoDEF, appHiDEF],	c2;appLoDEF:	rhTT &larr; DEFspace, GOTO[fnMD],	c3;appHiDEF:	rhTT &larr; DEFspaceHi, GOTO[fnMD],	c3;appUfn:	Q &larr; 14'd, GOTO[sink2],	c1;{MP9014}{***********************}FNX:	MAR &larr; Q &larr; [rhS, S + 1], L0 &larr; L0.RefillFNX,	c1, opcode[015'b];{0D}	STK &larr; MDR &larr; TOSH,{ rhTT &larr; DEFspace,} BRANCH[Cont5, SCar5, 1],	c2;Cont5:	TOSH &larr; ib LShift1, XC2npcDisp,	c3;	MAR &larr; [rhPC, PC + 2], BRANCH[$, noNeed, 0E], L1 &larr; L1.FNX,	c1;	TOSH &larr; TOSH - 2, BRANCH[$, FNXCross, 1],	c2;	TOSH &larr; Q - TOSH, IB &larr; MD, GOTO[fnIV], L3{ib's}&larr;3,	c3;noNeed:	TOSH &larr; TOSH - 2, CANCELBR[$, 0E], L1 &larr; L1.FNX,	c2;	TOSH &larr; Q - TOSH, GOTO[fnIV], L3{ib's}&larr;3,	c3;{***********************}FN0:	MAR &larr; Q &larr; [rhS, S + 1], L3{ib's}&larr;2,	c1, opcode[010'b];{08}	STK &larr; TOSH, MDR &larr; TOSH, TOSH &larr; 1 + Q +1, BRANCH[Cont1, SCar1, 1],	c2;FN1:	MAR &larr; Q &larr; [rhS, S + 1], L3{ib's}&larr;2,	c1, opcode[011'b];{09}FN1Ext:	STK &larr; MDR &larr; TOSH, TOSH &larr; Q - 0, BRANCH[Cont1, SCar1, 1],	c2;FN2:	MAR &larr; Q &larr; [rhS, S + 1], L3{ib's}&larr;2,	c1, opcode[012'b];{0A}FVcall:	STK &larr; MDR &larr; TOSH, TOSH &larr; Q - 2, BRANCH[Cont1, SCar1, 1],	c2;FN3:	MAR &larr; Q &larr; [rhS, S + 1], L3{ib's}&larr;2,	c1, opcode[013'b];{0B}	STK &larr; MDR &larr; TOSH, TOSH &larr; Q - 4, BRANCH[Cont1, SCar1, 1],	c2;FN4:	MAR &larr; Q &larr; [rhS, S + 1], L3{ib's}&larr;2,	c1, opcode[014'b];{0C}	STK &larr; MDR &larr; TOSH, TOSH{iVar} &larr; Q -6, BRANCH[Cont1, SCar1, 1],	c2;Cont1:	{rhTT &larr; DEFspace},	c3; {iVar (new) stored as end of old frame}{High half of S to match  Q}{Q: Sev; TOSH: iVar(new)}fnIV:	MAR &larr; [rhPV, PV - 6],	c1;	MDR &larr; TOSH{iVar}, TT &larr; ib, BRANCH[$, SCar6, 1],	c2;SC6Cont:	TT &larr; TT LRot8,	c3;fnS: {Flush top of stack}	{Q: S even}{High half of S to match  Q}	MAR &larr; Q &larr; [rhS, Q+1],{High half of S to match  Q}	c1; {Q &larr; odd}	MDR &larr; TOS,  S &larr; Q + 2, CANCELBR[$, 2], WriteOK,	c2;	TT &larr; TT or ib,	c3;	{fix for 16 bit atoms}	uTT &larr; TT, NegBr,	c1;	TT &larr; LShift1 TT, SE &larr; 1, BRANCH[FNLoDef, FNHiDef],	c2;FNLoDef:	rhTT &larr; DEFspace, GOTO[fnMD],	c3;FNHiDef:	rhTT &larr; DEFspaceHi, GOTO[fnMD],	c3;{***********************}fnMD: {MapDef;   rhTT,TT{FunDef} S{oddEmpty} L3{ib's} PV.iVar=TOSH{iVar} PC:+0}	TT &larr; Map &larr; [rhTT{FunDefs}, TT - 1], L0 &larr; L0.FCRedo, 	c1;	TOS &larr; UvCL, L1 &larr; L1.FC,	c2;	uIVar &larr; TOSH, Rx &larr; rhRx &larr; MD, XRefBr,	c3;fnD: {Get def cell high}	MAR &larr; [rhRx, TT + 0], BRANCH[FCMap, $], c1, at[L0.FCRedo, 10,RMapFixCaller];	Q &larr; PC and 0FF, L1 &larr; L1.FCH,	c2;	Q &larr; Q - TOS{UvCL}, rhTT{UvChighL} &larr; MD, XHDisp{compiled?},	c3;fnD0: {Get def cell low}	MAR &larr; [rhRx, TT+1], BRANCH[interpret, $, 2],	c1;	Rx{uStkLimO} &larr; uStkLimO, CANCELBR[$, 2], L0 &larr; L0.FCHRedo,	c2;	uPC &larr; PC, TT{UvCL} &larr; MD, L3Disp{deltaPC},	c3;fnMH: {Map function header}	Map &larr; [rhTT, TT], BRANCH[incPC1, incPC2, 0E],	c1;incPC1:	uTOS{savUvCL} &larr; TOS, TOS{pc} &larr; Q + PC16, GOTO[jMH],	c2;incPC2:	uTOS{savUvCL} &larr; TOS, TOS &larr; Q + 1, GOTO[jMH],	c2;jMH:	uTOSH{iVar} &larr; TOSH, PC &larr; rhPC &larr; MD, XRefBr,	c3;fnH0: {Fetch function header 0}	{S: odd, empty}FCHred:	MAR &larr; Q &larr; [rhPC, TT + 0], L1 &larr; L1.FCH, BRANCH[FCHMap, $],	c1{, at[L0.FCHRedo, 10,RMapFixCaller]};	TOSH{args} &larr; RShift1 (S-TOSH{iVar}-1), SE&larr;0,	c2;	UvCL &larr; TT, TT{stk} &larr; MD,	c3;fnH1: {Fetch function header 1}	{TOSH{args} non-neg}	MAR &larr; PC &larr; [rhPC, Q + 1],	c1;	Q{stkNeed} &larr; TT{stk} + S, CarryBr, CANCELBR[$, 2],	c2;	TT{na} &larr; MD, XHDisp, BRANCH[fnH2, FnCstkov],	c3;fnH2: {Regs:  TOSH{args}, TOS{PC-UvCL}, Rx{uStkLim0}, Q{stkNeed}, TT{na}, PC{header}, PV{pv},  S{s} }	MAR &larr; [rhPC, PC + 1], BRANCH[$, LamStar, 2],	c1;	Ybus &larr; Rx{uStkLim0} - Q{stkNeed}, CarryBr, CANCELBR[$, 2],	c2;	Rx{pv#} &larr; MD, XHDisp, BRANCH[FnStkOvr, fnH3],	c3;fnH3: {Fetch function header 3}	MAR &larr; [rhPC, PC + 2], L0&larr;2, BRANCH[h30, h31, 2],	c1;h30:	TOSH{wdsXtr+1} &larr; TOSH{args} - TT{na} LShift1, SE&larr;1, NegBr, CANCELBR[h4, 2],	c2;h31:	TOSH{wdsXtr+1} &larr; TOSH{args} - TT{na} LShift1,  SE&larr;1,NegBr, CANCELBR[h4, 2],	c2;h4:	Q{start} &larr; MD, BRANCH[enough, grow],	c3;grow: {grow the stack if necessary}	MAR &larr; [rhS, S-1],	c1;	MDR &larr; TT &larr; 0, CANCELBR[$, 2], WriteOK,	c2;	TOSH &larr; TOSH + 1,	c3;fnG:	MAR &larr; S &larr; [rhS, S+0],	c1;	MDR&larr;TT{zero}, TOSH{wdsXtr}&larr;TOSH+1, NegBr,	c2;	S &larr; S+2, BRANCH[enough, grow],	c3;{(N) trim stack and push uBFmark (once was nargs)}	{TOSH{argsXtr} non-neg}enough:	MAR &larr; S &larr; [rhS, S - TOSH{wdsXtr+1}],	c1;FnNCont:	MDR &larr; uBFmark, BRANCH[$, FnNCar, 1],	c2;	TOSH{UvPCpageLOld} &larr; UvPCpageL,	c3;fnB: {push IVar)}	MAR &larr; S &larr; [rhS, S+1],	c1;	MDR &larr; uIVar, CANCELBR[$, 2], WriteOK,	c2;	S &larr; S+1,	c3;fnF: {push uFXmark}	MAR &larr; S &larr; [rhS, S+0], L3Disp{deltaPC},	c1;	MDR &larr; uFXmark, BRANCH[pcInc0, pcInc2, 0D], WriteOK,	c2;pcInc0:	TOSH{pc} &larr; TOSH{UvPCpageLOld} + TOS{PC+UvCL}, NegBr,  GOTO[savPv],	c3;pcInc2:	TOSH{pc} &larr; TOSH{UvPCpageLOld} + TOS{PC+UvCL}+1, NegBr,  GOTO[savPv],	c3;savPv: {Alink &larr; oldPvar}	MAR &larr; S &larr; [rhS, S+1], BRANCH[$, NegPcError],	c1;	MDR &larr; PV{old}, S &larr; S+1, CANCELBR[$, 2], WriteOK,	c2;	TOS{start-1} &larr; (Q{start} - 1) RShift1, SE&larr;0,	c3;{(P) Clear PC16, Store relative byte PC  = 2*[UvPCpageL-UvCL+(PC and 0FF)]+PC16}{	MD	    TOS &larr; UvCL,	}{	D:	    Q &larr; PC and 0FF,	}{		    Q{PC-UvCL} &larr; Q - TOS,	}{	MH	    TOS{PC-UvCL} &larr; Q + PC16 {+PC16},	}{ 	N:	    TOSH &larr; UvPCpageL,	}{	F:	    TOSH{relWdPC} &larr; TOSH{UvPCpageL} + TOS{PC-UvCL} {+ 1},	}{		    MDR &larr; TOSH + TOSH + pc16,	}fnP:	MAR{PC} &larr; PV &larr; [rhPV, PV - 5],	c1;	MDR &larr; TOSH &larr; TOSH{pc}+TOSH+PC16, BRANCH[$, FnPCar, 1],	c2;FnPCont:	PV{new} &larr; S + 8{empty fields}, XC2npcDisp,	c3;fnC: {push code base low}	MAR &larr; [rhS, S+0], IB &larr; 6{constant}, BRANCH[fnPcOdd, fnPcEv, 0E],	c1;fnPcOdd:	MDR &larr; TOSH &larr; UvCL, GOTO[fnC0], Cin&larr;pc16,	c2;fnPcEv:	MDR &larr; TOSH &larr; UvCL, GOTO[fnC0],	c2;fnC0:	TOSH{UvPCpageL} &larr; TOSH and ~0FF,	c3;fnC1: {push code base high}	MAR &larr; Q &larr; [rhS, S+1], IBPtr &larr; 1, L0Disp{pv# zero},	c1;	MDR &larr; TT &larr; rhTT, WriteOK, BRANCH[plp, plpD, 0E],	c2;plpD:	UvChighL &larr; TT, S &larr; Q{S} + ib{6} + 1, GOTO[loopDone],	c3;plp:	UvChighL &larr; TT, S &larr; Q{S} + ib{6} + 1, {room for next, PC, nameTable, Blink and, Clink}	c3;{(V) push #pvar unbound pointers}loopP:	MAR &larr; S &larr; [rhS, S+0],	c1;	MDR &larr; TT{ones}&larr; ~TT xor TT,	c2;	S &larr; S + 2,	c3;	MAR &larr; S &larr; [rhS, S+0],	c1;	MDR &larr; TT{ones},Rx{pv#}&larr;Rx-1, NegBr,	c2;	S &larr; S + 2, BRANCH[loopP, loopDone],	c3;{(F) start fetch from the byte PC, PC16 cleared previously}loopDone:	MAR &larr; PC &larr; [rhPC, PC{+1} + TOS{start-1}],	c1;	S &larr; S + 1, BRANCH[$, CCross,1],	c2;	UvPCpageL &larr; TOSH, IB &larr; MD,	c3;	MAR &larr; [rhPC, PC + 1], IBPtr&larr;0, L2 &larr; L2.0,	c1; 	AlwaysIBDisp, TOSH &larr; 0, L0&larr; L0.NERefill.Set, DISP2[NoRCross],	c2;CCross:	UvPCpageL &larr; TOSH,	c3;	TOSH &larr; 0,	c1;	Noop,	c2;	Q &larr; 0FF + 1, L0 &larr; L0.JRemap, GOTO[UpdatePC],	c3;{exceptions:}SCar1:	Noop,	c3;	Noop, 	c1;	TOSH &larr; TOSH + 0FF + 1, {derived from Q}	c2;	S &larr; S + 1, {High half of S to match  Q}	c3;	MAR &larr; Q &larr; [rhS, S + 0],	c1;	MDR &larr; STK, GOTO[Cont1],	c2;SCar5:	S &larr; Q + 0FF + 1,	c3;	MAR &larr; Q &larr; [rhS, S + 0],{High half of S to match  Q}	c1;	MDR &larr; TOSH, {S &larr; S - 1,}{High half of S to match  Q} GOTO[Cont5],	c2;NegPcError:	Q &larr; 13'd,  CANCELBR[sink3, 3],	c2;{MP9013}FNXCross:	uPCCrossL &larr; (~TT xor TT),	c3;	TOSH &larr; Q - TOSH,	c1;	uRx{savQ} &larr; Q,  c2;	Q &larr; 0FF +  1,	c3;	TT &larr; UvPCpageL, GOTO[UpdatePC2],	c1;{FCross:}	{UpdatePC returns here}	Rx &larr; rhRx &larr; MD, XRefBr,	c3, at[L0.RefillFNX,10,ECross];{FXRedo:}	MAR &larr; [rhRx, PC + 2], BRANCH[FXMapUD, $],	c1, at[L0.RefillFNX,10,RMapFixCaller];	Q &larr; uRx{SavQ}, CANCELBR[$,2],	c2;	IB &larr; MD, L3{ib's}&larr;3, GOTO[fnIV],	c3;FXMapUD:	Noop, CANCELBR[RLMapFix, 3], {returns at FXRedo}	c2;FXFix:	TOSH &larr; STK, GOTO[NoMoreFix],	c1, at[L1.FNX,10,Fix];SCar6:	STK &larr; PV, PV &larr; PV - 6,	c3;	MAR &larr; [rhPV, PV + 0],	c1;	MDR &larr; TOSH, PV &larr; STK, GOTO[SC6Cont],	c2;SCar9:	STK &larr; PV, PV &larr; PV - 6,	c3;	MAR &larr; [rhPV, PV + 0],	c1;	MDR &larr; TOSH, PV &larr; STK, GOTO[SC9Cont],	c2;FnNCar:	S &larr; S -0FF - 1, 	c3;	MAR &larr; [rhS, S + 0], GOTO[FnNCont],	c1;FnPCar:	PV &larr; PV -0FF - 1, 	c3;	MAR &larr; [rhPV, PV + 0],	c1;	MDR &larr; TOSH, GOTO[FnPCont],	c2;{S odd empty}interpret:	TOS{atm} &larr; uTT, CANCELBR[$, 2],	c2;	TT &larr; 0FF + 1,	c3;interpret1:	MAR &larr; [rhS, S - 1],	c1;	MDR &larr; 0{rhTT}, CANCELBR[$, 2], WriteOK,	c2;interpret3:	uTT &larr; TT, TT &larr; LShift1 TT, SE &larr; 1, NegBr,	c3;	MAR &larr; [rhS, S + 0], BRANCH[$, intDefhi],	c1;	MDR &larr; TOS{atm}, rhTT &larr; DEFspace,	c2;intDEFdone:	S &larr; S + 2, GOTO[fnMD],	c3;intDefhi:	MDR &larr; TOS{atm}, rhTT &larr; DEFspaceHi, GOTO[intDEFdone],	c2;LamStar:	TT{na} &larr; TOSH{args}, CANCELBR[$, 2],	c2;	Noop, GOTO[fnH2], {try again}	c3;FCMap:	CANCELBR[RLMapFix, 3],	c2;FCHMap:	Rx &larr; PC, CALL[RLMapFix],	c2;	Noop, CANCELBR[$, 1],	c1, at[L0.FCHRedo, 10,RMapFixCaller];	Rx{uStkLimO} &larr; uStkLimO, 	c2;	Xbus &larr; 1, XDisp, GOTO[FCHred],	c3;FnCstkov:	TOSH{iVar} &larr; uTOSH, CANCELBR[FnStkOvc, 3],	c1;FnStkOvr:	TOSH{iVar} &larr; uTOSH, CANCELBR[FnStkOvc, 3],	c1;FnStkOvc:	TT{UvCL} &larr; uTOS,	c2;	UvCL &larr; TT, 	c3;	Rx &larr; {0 -} SubovFXP, L3Disp{deltaPC}, GOTO[fchFix2],	c1; {*************************}FCHFix:  	{preserves Rx:FXP#}	L3Disp{deltaPC},	c1, at[L1.FCH,10,Fix];fchFix2:	BRANCH[decPC1, decPC2, 0E],	c2;decPC1:	PC &larr; uPC, GOTO[FCFix], Cin&larr;pc16,	c3;decPC2:	PC &larr; uPC, GOTO[FCFix],	c3;FCFix:	L3Disp,	c1, at[L1.FC,10,Fix];	TOS &larr; uTT, DISP4[PCdelt, 0C],	c2;	PC &larr; PC + PC16, GOTO[FCFix1],	c3, at[0C, 10, PCdelt];	PC &larr; PC + 1, GOTO[FCFix1],	c3, at[0D, 10, PCdelt];	PC &larr; 1 + PC + PC16, GOTO[FCFix1],	c3, at[0E, 10, PCdelt];	PC &larr; PC + 2, GOTO[FCFix1],	c3, at[0F, 10, PCdelt];FCFix1:	MAR &larr; [rhS, S - 1],	c1;	MDR &larr; smallpl, CANCELBR[$, 2], WriteOK,	c2;	TOSH{args} &larr; RShift1 (S-TOSH{iVar}-1), SE&larr;0,	c3;	MAR &larr; [rhS, S + 0],	c1;	MDR &larr; TOSH{args}, TOSH &larr; 0, L2 &larr; 1{InCall},	c2;	GOTO[PuntFor],	c3;	{ E N D }</pre>
  </body>
</html>
