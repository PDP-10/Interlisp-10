<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Dove>LispFmemb.mc!1</title>
  </head>
  <body>
    <pre>
{LispFmemb.mccal:  13-Dec-84 13:53:18}{- - - - - - - - - - - - - - - - - - - - - - - - - -  #      name        len-1    stk level effect   UFN table entry 34      FMEMB       0        -1                 FMEMB	(FMEMB arg list)if list=NIL, return NILif list is not LISTP, call UFNif (CAR list)=arg, return listlist &larr; (CDR list)loop}@FMEMB:	opcode[34'b],		{fetch tos-1}	MAR &larr; [rhS, S - 1], L3 &larr; L3.fmemb,	c1;	Ybus &larr; TOSH or TOS, ZeroBr, CANCELBR[fmcomm, 2],	c2;{test if tos = nil}fmcomm:	TT &larr; MD, BRANCH[$, commretnil]	c3;{hi 16 bits of tos-1}	MAR &larr; [rhS, S + 0],	c1;	uTOSHm1 &larr; TT,	c2;{uTOSHm1 &larr; hi 16 bits of tos-1}	TT &larr; MD,	c3;{lo 16 bits of tos-1}	uTOSm1 &larr; TT,	c1;{uTOSm1 &larr; lo 16 bits of tos-1}	TT &larr; TOSH and 0FF,	c2;	Rx &larr; TOS, CALL[CADR]	c3;{	CADR  SUBROUTINE: takes ptr to CONS cell, returns CAR and CDR of cell	Rx has lo bits of VA of cell	TT has hi bits of VA of cell	L3 used for return thru CADRret	trashes Q, L0, L1, rhRx, rhTT	trashes uTT, uRx, UQSave	returns:		TT has hi bits of CDR of cell		Rx has lo bits of CDR of cell		uCARlo has lo bits of CAR of cell		uCARhi has hi bits of CAR of cell	will ufnX if cdrcell not NIL or type list	will pagefault {NoFixes} if cell page faults}		at[L3.fmemb, 10, CADRret],		{test if CAR = tos-1}	Q &larr; uTOSm1,	c1;	Q &larr; Q xor uCARlo,	c2;	Ybus &larr; Q , ZeroBr,	c3;	Q &larr; uTOSHm1, BRANCH[fmlonok, $],	c1;	Q &larr; Q xor uCARhi,	c2;	Ybus &larr; Q - 1, PgCarryBr,	c3;	BRANCH[fmCARequaltosm1, fmhinok],	c1;	fmlonok:	Ybus &larr; Rx or TT, ZeroBr, GOTO[fmgoagain],	c2;fmhinok:	Ybus &larr; Rx or TT, ZeroBr, GOTO[fmgoagain],	c2;fmgoagain:	TOS &larr; Rx, MesaIntBr, BRANCH[fmtestint, fmretnil],	c3;{will use old return point}fmCARequaltosm1:	{tos-1 = car}	S &larr; S - 2, IBDisp, L2 &larr; L2.0, GOTO[DNI.pc1],	c2;{return current TOSH TOS}commretnil:	GOTO[fmnilexit],	c1;fmretnil:	{return nil}	CANCELBR[fmnilexit],	c1;fmnilexit:	TOSH &larr; 0,	c2;	TOS &larr; 0, GOTO[fmexit]	c3;fmexit:	S &larr; S - 2, GOTO[IB.pc1],	c1;	{test for interrupt}fmtestint:	TOSH &larr; TT and 0FF, BRANCH[fmnoint1, $],	c1;	Ybus &larr; uWP, ZeroBr,	c2;	Ybus &larr; uWDC, NZeroBr, BRANCH[$, fmnoint2],	c3;	uWP &larr; 0, BRANCH[fmIntNow, fmnoint3],	c1;fmIntNow:	,	c2;	GOTO[BLTIntNow],	c3;{	ClrIntErr, Rx &larr; 1,	c1;	uWDC &larr; Rx,{off interrupts}	c2;	Rx &larr;  KbdFXP, L2 &larr; 0, GOTO[PUNT],	c3;}fmnoint2:	CANCELBR[$],	c1;fmnoint3:	GOTO[fmNOint],	c2;fmnoint1:	GOTO[fmNOint],	c2;fmNOint:	CALL[CADR],	c3;{- - - - - - - - - - - - - - - - - - - - - - - - - -  #      name        len-1    stk level effect   UFN table entry 26      ASSOC       0        -1                 FASSOC	(ASSOC  key  alist)	returns the first sublist of alist whose car is EQ key	else returns nil- - - - - - - - - - - - - - - - - - - - - - - - - -}{	if (CAR (CAR alist) ) = key then return (CAR alist)	alist &larr; (CDR alist)	interrupt test and loopback}@ASSOC:	opcode[26'b],	MAR &larr; [rhS, S - 1], L3 &larr; L3.fassoc1,	c1;	Ybus &larr; TOSH or TOS, ZeroBr, CANCELBR[fmcomm, 2],	c2;{	SUBROUTINE: takes ptr to CONS cell, returns CAR and CDR of cell	Rx has lo bits of VA of cell	TT has hi bits of VA of cell	L3 used for return thru CADRret	trashes Q, L0, L1, rhRx, rhTT	trashes uTT, uRx, uPV	returns:		TT has hi bits of CDR of cell		Rx has lo bits of CDR of cell		uCARlo has lo bits of CAR of cell		uCARhi has hi bits of CAR of cell	will ufnX if cdrcell not NIL or type list	will pagefault {NoFixes} if cell page faults}		at[L3.fassoc1, 10, CADRret],		{save CDR}	uCDRhi &larr; TT,	c1;	uCDRlo &larr; Rx,	c2;		{save CAR}	TT &larr; uCARhi, L3 &larr; L3.fassoc2,	c3;	Rx &larr; uCARlo,	c1;	uCARsavlo &larr; Rx,	c2;	uCARsavhi &larr; TT, CALL[CADR],	c3;		at[L3.fassoc2, 10, CADRret],		{compare CAR with tos-1}	Q &larr; uTOSHm1,	c1;	Q &larr; Q xor uCARhi,	c2;	Rx &larr; Q,	c3;	Q &larr; uTOSm1,	c1;	Q &larr; Q xor uCARlo,	c2;	Ybus &larr; Q or Rx, ZeroBr,	c3;	BRANCH[fassocback, fassocfound],	c1;fassocback:	TT &larr; uCDRhi, L3 &larr; L3.fassoc1,	c2;	Rx &larr; uCDRlo,	c3;	Ybus &larr; TT or Rx, ZeroBr,	c1;	TOS &larr; Rx, BRANCH[$, fassocretnil],	c2;	GOTO[fmtestint],	c3;fassocfound:	TOSH &larr; uCARsavhi,	c2;	TOS &larr; uCARsavlo, GOTO[fmexit],	c3;fassocretnil:	TOSH &larr; 0, GOTO[fmexit],	c3;{- - - - - - - - - - - - - - - - - - - - - - - - - -  #      name        len-1    stk level effect   UFN table entry 47      LISTGET       0        -1                 ??	(LISTGET  prop  plist)	returns the first value of plist whose property is EQ key	else returns nil- - - - - - - - - - - - - - - - - - - - - - - - - -}{	if (CAR plist) = key then return (CAR (CDR plist) )	plist &larr; (CDR (CDR plist) )	interrupt test and loopback}@LISTGET:	opcode[47'b],	MAR &larr; [rhS, S - 1], L3 &larr; L3.fprop1,	c1;	Ybus &larr; TOSH or TOS, ZeroBr, CANCELBR[fmcomm, 2],	c2;		at[L3.fprop1, 10, CADRret],		{test if CAR = tos-1}	Q &larr; uTOSm1,	c1;	Q &larr; Q xor uCARlo,	c2;	Ybus &larr; Q , ZeroBr,	c3;	Q &larr; uTOSHm1, BRANCH[fplonok, $],	c1;	Q &larr; Q xor uCARhi, L3 &larr; L3.fprop2,	c2;	Ybus &larr; Q - 1, PgCarryBr,	c3;	BRANCH[fpCARequaltosm1, fphinok],	c1;	fplonok:	GOTO[fpgoagain],	c2;fphinok:	GOTO[fpgoagain],	c2;fpgoagain:		{plist &larr; (CDR (CDR plist) ) . . loopback}	CALL[CADR],	c3;		at[L3.fprop2, 10, CADRret],	Ybus &larr; Rx or TT, ZeroBr,	c1;	TOSH &larr; TT, BRANCH[$, fpretnil],	c2;	TOS &larr; Rx, MesaIntBr, GOTO[fmtestint],	c3;fpretnil:	TOS &larr; 0, GOTO[fmexit],	c3;fpCARequaltosm1:		{return (CAR (CDR plist) )}	L3 &larr; L3.fprop3, GOTO[fpgoagain],	c2;		at[L3.fprop3, 10, CADRret],	TOSH &larr; uCARhi,	c1;	TOS &larr; uCARlo,	c2;	GOTO[fmexit],	c3;	{ E N D }</pre>
  </body>
</html>
