<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Dove>LispRecl.mc!1</title>
  </head>
  <body>
    <pre>
{	&lt;tajo&gt;LispRecl.mcLast edit:      9-Mar-84 12:30:37 by don}{- - - - - - - - - - - - - - - - - - - - - - - - - -  #      name        len-1    stk level effect   UFN table entry172      RECLAIMCELL 0        0                  \GCRECLAIMCELL\CDR.NIL= 200qLISTPDTD is the DTD for type LISTP, i.e., at DTDbase + (LLSH ListType 4)Cons pages start with two word header:	word 0: [cnt, nxtcell]	(two 8-bit fields: count of available cells				on this page, and word# of next free cell				on this page)	word 1: nextpage	(page# of next cons page) {negative if not on free chain}If not LISTP then puntReclaim list:	code&larr;PTR:cdrcode	if (code and 200q) = 0 then punt	[or optional: if code = 0 then punt]	FreeListCell(PTR)	val&larr; deleteref(PTR:carfield)		* deleteref CAR	if code # \CDR.NIL	  then PTR&larr;PTR:pagebase + (code lsh 1) * point to cdr or lvcdr		{ if (code and 200q) = 0		* optional		    then FreeListCell(PTR)		* cdr indirect--free cell		    PTR&larr; GetBasePtr(PTR)] }	if deleteref(PTR)			* deleteref CDR	  then val&larr;PTR	return valFreeListCell(PTR):	PAGE &larr; address of PTR's page	if PAGE:Nextpage &lt; 0 then punt	* only when page was full	PTR:cdrcode &larr; PAGE:nextcell	PAGE:nextcell &larr; word# of PTR	PAGE:count &larr; PAGE:count + 1How to reclaim other types, roughly (needs type table change):	if Type bit "ok to reclaim" is off, call UFN	store DTD:FREELST in first two words of DATUM	store DATUM in DTD:FREELST[not required; implemented for Listp on D0, Dorado?]- - - - - - - - - - - - - - - - - - - - - - - - - -}	SetTask[0];@RECLAIMCELL:	opcode[172'b],	TT &larr; 172'b, L2 &larr; L2.Recl,	c1;	{Xbus &larr; TOSH LRot12, XDisp, }GOTO[NewTypC3],	c2;{		NewTyp will call ufn[TT] if tos is not a valid LISP pointer (i.e. if it is larger than a 22 bit number).	ELSE: typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry. }	{fetch Type}	MAR &larr; [rhRx, Rx], Rx &larr; ListType + 0,	c1, at[L2.Recl,10, NewTypRet];	rhTT &larr; TOSH LRot0,	c2;	Q &larr; MD{Type} xor Rx,	c3;	{map PTR -- last place for fault}	Map &larr; TT &larr; [rhTT, TOS], L0 &larr; L0.RedoRecl	c1;	PC &larr; PC - PC16, L1 &larr; L1.NoFixes,	c2;	rhRx &larr; Rx &larr; MD, XwdDisp,	c3;	MAR &larr; [rhRx, TOS + 0], DISP2[ReclMap],	c1, at[L0.RedoRecl, 10, WMapFixCaller];	Ybus &larr; Q - 1, PgCarryBr,	c2, at[1, 4, ReclMap];{test Type=ListP?}	TT &larr; MD{CDR,,CARhi}, BRANCH[$, ReplNotListufn],	c3;{get hi cell contents}	MAR &larr; [rhRx, TOS + 1],	c1;	uCARhi &larr; TT, NegBr, CANCELBR[$, 2],	c2;{test if cdrcode and 200 = 0}	Q &larr; MD{CARlo}, BRANCH[ReclIndufn, $],	c3;{get lo cell contents}{SUBROUTINE?: FLC  --  FreeListCell(PTR):	PAGE &larr; address of PTR's page	if PAGE:Nextpage &lt; 0 then punt	* only when page was full	PTR:cdrcode &larr; PAGE:nextcell	PAGE:nextcell &larr; word# of PTR	PAGE:count &larr; PAGE:count + 1}{	assume real addr of PTR in rhRx  Rx TOS }	MAR &larr; [rhRx, 1 + 0],	c1;	uCARlo &larr; Q,	c2;	TT &larr; MD{nextpage},	c3;{get wd 1 of page = nextpage}	MAR &larr; [rhRx, 0 + 0],	c1;	Ybus &larr; TT, NegBr,	c2;{test if nextpage &lt; 0 : if so ufn}	Q &larr; MD{cnt,,nxtcell}, BRANCH[$, ReclPgFullufn],	c3;{get wd 0 of page}	uNxtCell &larr; Q,	c1;{save old nxtcell}	TT &larr; TOS and 0FF,	c2;{TT &larr; new nxtcell}	Q &larr; Q and ~0FF,	c3;{Q &larr; old cnt in Hi}	Q &larr; TT{new nxtcell  Lo} or Q{old cnt  Hi},	c1;{merge cnt and new nxtcell}	Q &larr; Q + 0FF + 1,	c2;{add 1 to old cnt}	TT &larr; uNxtCell,	c3;{TT &larr; old nxtcell}	MAR &larr; [rhRx, 0 + 0],	c1;{rewrite  cnt,,nxtcell}	MDR &larr; Q,	c2;{ = cnt + 1,,new nxtcell}	TT &larr; TT LRot8,	c3;{TT &larr; old nxtcell,,garbage}	MAR &larr; [rhRx, TOS + 0],	c1;{PTR:cdrcode &larr; PAGE:nextcell}	MDR &larr; TT, L2 &larr; L2.Recl1,	c2;	uTOS &larr; TOS,	c3;{set tos to NIL}	uTOSH &larr; TOSH,	c1;	TOS &larr; uGcLov &larr; 0,	c2;	TOSH &larr; uGcZero &larr; 0,	c3;	{delref to CAR}	{use PTR for all 24 bits}	Rx &larr; uCARhi,	c1;	TT &larr; uCARlo,	c2;	Rx &larr; Rx and 0FF,	c3;	Q &larr; Q.DelRef, CALL[GcLookup],	c1;	Ybus &larr; uGcZero, ZeroBr,	c2, at[L2.Recl1, 10, GcLookRet];	BRANCH[$, ReclLvtos1],	c3;	TOS &larr; uGcLlo,	c1;	TOSH &larr; uGcLhi,	c2;	uGcZero &larr; 0,	c3;ReclLvtos1:	{delref to CDR}	{use @PTR: for high 16 bits, cdrcode for low 8}	{verify that not cdrnil}	TT &larr; uTOS, L2 &larr; L2.Recl2,	c1;	TT &larr; TT and ~0FF,	c2;	Rx &larr; uCARhi,	c3;	Rx &larr; Rx LRot8,	c1;	Rx &larr; LShift1 (Rx and 07F), SE &larr; 0,	c2;	Ybus &larr; Rx, ZeroBr,	c3;{test if cdrNIL}	TT &larr; TT or Rx, BRANCH[$, ReclCdrNil]	c1;	Rx &larr; uTOSH,	c2;	Rx &larr; Rx and 0FF,	c3;	Q &larr; Q.DelRef, CALL[GcLookup],	c1;	Ybus &larr; uGcZero, ZeroBr, L3{ib's} &larr; 0,	c2, at[L2.Recl2, 10, GcLookRet];	Ybus &larr; uGcLov{set by GcLookup}, NZeroBr,  BRANCH[ReclFixtos, $],	c3;	Rx &larr; AtomGCSCAN {371'b}, BRANCH[ReclNoOvXit, ReclOvXit],	c1;ReclFixtos:	TOS &larr; uGcLlo, CANCELBR[$],	c1;	TOSH &larr; uGcLhi,	c2;ReclX1:	Ybus &larr; uGcLov{set by GcLookup}, NZeroBr, L3{ib's} &larr; 0,	c3;ReclX2:	Rx &larr; AtomGCSCAN {371'b}, BRANCH[ReclNoOvXit, ReclOvXit],	c1;ReclNoOvXit:	L2 &larr; L2.0, IBDisp, GOTO[DNI.pc1],	c2;ReclOvXit:	GOTO[RplFNXIT],	c2;{	IB &larr; Rx LRot0,	c3;	MAR &larr; Q &larr; [rhS, S + 1], IBPtr &larr; 0, GOTO[FN1Ext],	c1;}	GOTO[WLMapFix],	c2, at[0, 4, ReclMap];	GOTO[WLMapFix],	c2, at[2, 4, ReclMap];	GOTO[WLMapFix],	c2, at[3, 4, ReclMap];ReclCdrNil:	GOTO[ReclX1],	c2;ReplNotListufn:	GOTO[ufnX2],	c1;ReclIndufn:	GOTO[ufnX2],	c1;ReclPgFullufn:	GOTO[ufnX2],	c1;	{ E N D }</pre>
  </body>
</html>
