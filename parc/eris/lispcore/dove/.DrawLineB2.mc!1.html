<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Dove>DrawLineB2.mc!1</title>
  </head>
  <body>
    <pre>
{  Filename: DrawLineB2.mc   Description: Lisp line-drawing microcode.   Author: Mitch Lichtenberg   Creation date: 25-Jun-83 16:51:58      Modified: 17-Apr-84  9:17:48      Entry format:     TOS  --&gt; Maximum number of Y steps allowed {uYCount}     SP-0 --&gt; Maximum number of X steps allowed {uXCount}     SP-2 --&gt; Initial Delta {Delta}     SP-4 --&gt; Function number: {L2}     		0: Set pixel		1: Reset Pixel		2: Invert Pixel     SP-6 --&gt; Relative Y coordinate of end of line (for the bucket) {uYT}     SP-8 --&gt; Width of bitmap (in words), signed to indicate Y direction {uYIncHi - uYIncLo}     SP-10 -&gt; Relative X coordinate of end of line (for the bucket) {uXT}     SP-12 -&gt; bit index [0..15] of bit to start at {CurBit}     SP-14 -&gt; Pointer to first word in bitmap {uPAdrHi - uPAdrLo}	***   Registers used:	Delta{TOSH}: contains the delta counter for determining step direction	rhTT,,TT: contain the Virtual address of the word containing the pixel to modify	rhRx,,Rx: contain the Real Address of the word containing the pixel,  and used as a temp reg	CurBit{TOS}: contains the bit-mask for the current pixel	uXT,uYT: values for X and Y slope {used to modify Delta}	uXCount,uYCount: maximum pixels to be drawn in X/Y	uYIncHi,uYIncLo: Y step value	L0 holds Map update return value	L1 holds Map fix for PFault value	L2 holds Drawline Function {0: PAINT, 1: ERASE, 2,3: INVERT}	L3 holds 2 if uYT &gt; uXT {major direction}}{	IN BANK 1@DRAWLINE:	opcode[73'b],	Bank &larr; DLBank,	c1;	uYCount &larr; TOS,	c2;	S &larr; S - 14'd, CROSS[DLEntry],	c3;}	MAR &larr; [rhS,S + 0],	c1, at[DLEntry]; {- 14  Lo}	Q &larr; 3, L0 &larr; L0.DLMap,	c2;  	TT &larr; MD,	c3;	MAR &larr; [rhS,S - 1],	c1; {- 14 Hi}	S &larr; S + 2, CANCELBR[$, 2],	c2;  	rhTT &larr; MD,	c3;	MAR &larr; [rhS,S + 0],	{Get bitindex}		c1; {-12}	S &larr; S + 2, L1 &larr; L1.DLFixesB2,	c2;  	Rx &larr; MD,	c3;{	convert value to bit mask in CurBit}	CurBit &larr; RRot1 1,	c1;dlCBloop:	Rx &larr; Rx - 1, NegBr,	c2;	BRANCH[dlCBshift, dlCBset],	c3;dlCBshift:	CurBit &larr; RRot1 CurBit, GOTO[dlCBloop],	c1;dlCBset:	MAR &larr; [rhS,S + 0],	{Get X bucket stepper}	c1; {-10}	S &larr; S + 2,	c2;	Rx &larr; MD,	c3;	MAR &larr; [rhS,S - 1],	{Get Y Increment sign}		c1; {-8 Hi}	uXT &larr; Rx, CANCELBR[$,2],	c2;  	Xbus &larr; MD, XDisp, {width}	c3;	MAR &larr; [rhS, S + 0], BRANCH[PosInc,NegInc,0E],		c1; {-8 Lo}PosInc:	uYIncHi &larr; 0,{Positive Increment} GOTO[GetY],	c2;NegInc:	uYIncHi &larr; ~TOS xor TOS,{Negative Increment} GOTO[GetY],	c2;GetY:	Rx &larr; MD, c3;	,	c1;	uYIncLo &larr; Rx, c2;	S &larr; S + 2,	c3;	MAR &larr; [rhS, S + 0],					c1; {-6}	S &larr; S + 2,						c2;	Rx &larr; MD, {Y bucket stepper}				c3;	MAR &larr; [rhS,S + 0],					c1;  {-4}	S &larr; S + 2,						c2;	Q &larr; MD and Q{3},	c3; {Drawing function}	MAR &larr; [rhS,S + 0],	c1; {-2}	S &larr; S + 2,	c2;	Delta &larr; MD,	c3; {Initial Delta}	MAR &larr; [rhS,S + 0],	c1; {-0}	Ybus &larr; Q, YDisp,	c2;	Q &larr; MD, DISP2[DLsetL2], L2 &larr; 0{put function in L2},	c3; {X pixel count}	uXCount &larr; Q, GOTO[dlhere],	c1, at[0, 4, DLsetL2]; 	uXCount &larr; Q, GOTO[dlhere],	c1, at[1, 4, DLsetL2]; 	uXCount &larr; Q, GOTO[dlhere],	c1, at[2, 4, DLsetL2]; 	uXCount &larr; Q, GOTO[dlhere],	c1, at[3, 4, DLsetL2]; dlhere:	Q &larr; uXT,  {Get X and Y bucket stepper values back}	c2;	uYT &larr; Rx,	c3;{Delta is in the range 0..MAX(XT,YT).. }	Ybus &larr; Q - Rx, NegBr, {normalize delta}	c1;	BRANCH[Xbig,Ybig],	c2;Xbig:	Delta &larr; Q - Delta - 1, GOTO[dlPlot], L3 &larr; 0,	c3;Ybig:	Delta &larr; Rx - Delta - 1, GOTO[dlPlottoo], L3 &larr; 2,	c3;{All of the arguments are now set up.}{=======================================================================}dlPlottoo:	Map &larr; [rhTT, TT], GOTO[dlPlot1],	c1;dlPlot:	Map &larr; [rhTT, TT], BRANCH[dlPlot1, dlXfixY],	c1;dlPlot1:	,	c2;	rhRx &larr; Rx &larr; MD, XwdDisp{XDirtyDisp},	c3;	MAR &larr; [rhRx, TT + 0], DISP2[DLMapFix],	c1, at[L0.DLMap, 10, WMapFixCallerB2];	,	c2, at[1, 4, DLMapFix];	Q &larr; MD, L2Disp,	c3;	MAR &larr; [rhRx, TT + 0], DISP2[dlFnDisp], L3Disp,	c1;	MDR &larr; Q or CurBit, BRANCH[dlXStuff, dlYStuff, 1],	c2, at[0, 4, dlFnDisp];	MDR &larr; Q and ~CurBit, BRANCH[dlXStuff, dlYStuff, 1],	c2, at[1, 4, dlFnDisp];	MDR &larr; Q xor CurBit, BRANCH[dlXStuff, dlYStuff, 1],	c2, at[2, 4, dlFnDisp];	MDR &larr; Q xor CurBit, BRANCH[dlXStuff, dlYStuff, 1],	c2, at[3, 4, dlFnDisp];{=======================================================================}dlXStuff:	Rx &larr; uXCount, GOTO[dlXS1], c3;dlXStufftoo:	Rx &larr; uXCount, GOTO[dlXS1], c3;dlXS1:	Rx &larr; Rx - 1, ZeroBr,	c1;	uXCount &larr; Rx, BRANCH[$, dlXThru],	c2;	CurBit &larr; RRot1 CurBit,	c3;dlXS3:	Ybus &larr; CurBit, NegBr, L3Disp,	c1;	Rx &larr; uYT, DISP2[dlXDisp],	c2;	TT &larr; TT + 1, CarryBr, GOTO[dlXmore],	c3, at[1, 4, dlXDisp];	TT &larr; TT + 1, CarryBr, GOTO[dlXmore],	c3, at[3, 4, dlXDisp];dlXmore:	Q &larr; rhTT, BRANCH[dlXrhTTok, $], L3Disp,	c1;	Q &larr; Q + 1, CANCELBR[$, 3],	c2;	rhTT &larr; Q LRot0,	c3;	L3Disp,	c1;dlXrhTTok:	DISP2[dlXDisp],	c2;	Delta &larr; Delta - Rx, NegBr, GOTO[dlPlot],	c3, at[0, 4, dlXDisp];{X only}	Delta &larr; Delta + Rx, GOTO[dlYrem],	c3, at[2, 4, dlXDisp];{X and Y}dlXfixY:	Rx &larr; uXT,	c2;	Delta &larr; Delta + Rx, GOTO[dlYrem],	c3;dlYStuff:	Rx &larr; uXT,	c3;	Delta &larr; Delta - Rx, NegBr,	c1;	BRANCH[$, dlXStufftoo],	c2;	,	c3;dlYrem:	Rx &larr; uYCount,	c1;	Rx &larr; Rx - 1, ZeroBr,	c2;	uYCount &larr; Rx, BRANCH[$, dlYThru],	c3;	Rx &larr; uYIncLo,	c1;	Q &larr; rhTT, 	c2;	TT &larr; TT + Rx, CarryBr,	c3;	Rx &larr; uYIncHi, BRANCH[dlYnocar, dlYcar],	c1;dlYnocar:	Q &larr; Q + Rx, GOTO[dlYdone],	c2;dlYcar:	Q &larr; Q + Rx + 1, GOTO[dlYdone],	c2;dlYdone:	rhTT &larr; Q LRot0, GOTO[dlPlot],	c3;dlYThru:	,	c1;	,	c2;dlXThru:	Q &larr; rhTT, GOTO[dlNormExit],	c3;{=======================================================================}{MAP Update for DrawLine routine}	GOTO[WLMapFixB2],	c2, at[0, 4, DLMapFix];	GOTO[WLMapFixB2],	c2, at[2, 4, DLMapFix];	GOTO[WLMapFixB2],	c2, at[3, 4, DLMapFix];{uses standard remap routines now!WMapDLFix: Xbus &larr; Rx LRot0, XwdDisp, 	c3;	Map &larr; [rhTT,TT], DISP2[DLMFix],	c1;	MDR &larr; Rx or {0B0}030, GOTO[Retry],	c2, at[0,4,DLMFix];	MDR &larr; Rx or {0B0}030, GOTO[Retry],	c2, at[1,4,DLMFix];	GOTO[DLTrap],	c2, at[2,4,DLMFix];	GOTO[DLTrap],	c2, at[3,4,DLMFix];Retry:	,	c3;	MAR &larr; [rhRx, TT + 0], GOTO[GetWD],	c1;{DLTrap : In the event of a page fault, we come here.}DLTrap:	,	c3;uses standard remap routines now!}	MAR &larr; [rhS,S + 0],	c1, at[L1.DLFixesB2, 10, TrapFixesB2]; {- 0}	MDR &larr; uXCount,	c2;	S &larr; S - 2,	c3;	L3Disp,	c1;	BRANCH[dlX, dlY, 1],	c2;dlX:	Q &larr; uXT, GOTO[dlSaveDelta],	c3;dlY:	Q &larr; uYT, GOTO[dlSaveDelta],	c3;dlSaveDelta:	MAR &larr; [rhS, S + 0],	c1; {- 2}DelPos:	MDR &larr; Q - Delta - 1, GOTO[DLcont],	c2;DLcont:	S &larr; S - 10'd,	c3;	Rx &larr; 0,	c1;dlSetBitLoop:	Ybus &larr; CurBit, NegBr,	c2;	CurBit &larr; LRot1 CurBit, BRANCH[dlAdd1toBit, dlBitok],	c3;dlAdd1toBit:	Rx &larr; Rx + 1, GOTO[dlSetBitLoop],	c1;dlBitok:	MAR &larr; [rhS, S + 0],	c1; {- 12}	MDR &larr; Rx,	c2;	S &larr; S - 2,	c3;	MAR &larr; [rhS,S + 0],	c1; {- 14}	MDR &larr; TT,	c2;	S &larr; S - 1, L1 &larr; L1.NoFixes,	c3;	MAR &larr; [rhS, S + 0],	c1;	MDR &larr; rhTT,	c2;	S &larr; S + 15'd,	c3;	Bank &larr; EmuBank,	c1;	TOSH &larr; smallpl, L1 &larr; L1.NoFixes,	c2;	TOS &larr; uYCount, CROSS[PFaultB1],	c3;{dlNormExit:  When we are finished drawing, execution comes here. The opcode returns the address of the end of the line.}dlNormExit:	Bank &larr; EmuBank,	c1;	TOS &larr; TT,	c2; 	TOSH &larr; Q, CROSS[DLExit],	c3;{	IN BANK 1	S &larr; S - 16'd,	c1, at[DLExit];	L2 &larr; L2.0, PC &larr; PC + PC16, IBDisp,	c2;	L2 &larr; L2.0, DISPNI[OpTable],	c3;}	{ E N D }</pre>
  </body>
</html>
