<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Dove>dbJump.mc!3</title>
  </head>
  <body>
    <pre>
{file:  MJump.mclast edit   21-Feb-84 17:51:10Mitch  9-Jun-85 20:13:43 daybreak did something wierd around %5}	SetTask[0];{*************************	JUMP	1%  2 clicks**************************}@JUMP:	opcode[200'b],	MAR &larr; PC &larr; [rhPC, PC+1], GOTO[JnPos],	c1;	MAR &larr; PC &larr; [rhPC, PC+1+PC16], GOTO[JnPos],	c1,opcode[201'b];	MAR &larr; PC &larr; [rhPC, PC+2], GOTO[JnPos],	c1,opcode[202'b];	MAR &larr; PC &larr; [rhPC, PC+2+PC16], GOTO[JnPos],	c1,opcode[203'b];	MAR &larr; PC &larr; [rhPC, PC+3], GOTO[JnPos],	c1,opcode[204'b];	MAR &larr; PC &larr; [rhPC, PC+3+PC16], GOTO[JnPos],	c1,opcode[205'b];	MAR &larr; PC &larr; [rhPC, PC+4], GOTO[JnPos],	c1,opcode[206'b];	MAR &larr; PC &larr; [rhPC, PC+4+PC16], GOTO[JnPos],	c1,opcode[207'b];	MAR &larr; PC &larr; [rhPC, PC+5], GOTO[JnPos],	c1,opcode[210'b];{88}	MAR &larr; PC &larr; [rhPC, PC+5+PC16], GOTO[JnPos],	c1,opcode[211'b];	MAR &larr; PC &larr; [rhPC, PC+6], GOTO[JnPos],	c1,opcode[212'b];	MAR &larr; PC &larr; [rhPC, PC+6+PC16], GOTO[JnPos],	c1,opcode[213'b];	MAR &larr; PC &larr; [rhPC, PC+7], GOTO[JnPos],	c1,opcode[214'b];	MAR &larr; PC &larr; [rhPC, PC+7+PC16], GOTO[JnPos],	c1,opcode[215'b];	MAR &larr; PC &larr; [rhPC, PC+8], GOTO[JnPos],	c1,opcode[216'b];	MAR &larr; PC &larr; [rhPC, PC+8+PC16], GOTO[JnPos],	c1,opcode[217'b];JnPos:	Xbus&larr;0, XC2npcDisp, BRANCH[$, JnCross, 1],	c2;	IB &larr; MD, BRANCH[ptr1, ptr0, 0E],	c3;JnCross:	Q &larr; 0FF + 1, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3;@JUMPX:	opcode[260'b],	S &larr; S+1, Xbus&larr;ibNA, XLDisp, L2 &larr; L2.ok,	c1;	Rx &larr; ib RShift1, XLDisp, SE &larr; 0, BRANCH[jxp, jxn, 1],	c2;jxp:	Noop, BRANCH[jpe, jpo, 2],	c3;jxn:	Rx &larr; 7F-Rx, BRANCH[jne, jno, 2],	c3;{*************************	FJUMP, TJUMP	4%  4 clicks**************************}@FJUMP:	opcode[220'b],	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0,	c1;	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 1,	c1, opcode[221'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 2,	c1, opcode[222'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 3,	c1, opcode[223'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 4,	c1, opcode[224'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 5,	c1, opcode[225'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 6,	c1, opcode[226'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 7,	c1, opcode[227'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 8,	c1, opcode[230'b];{98}	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 9,	c1, opcode[231'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0A,	c1, opcode[232'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0B,	c1, opcode[233'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0C,	c1, opcode[234'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0D,	c1, opcode[235'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0E,	c1, opcode[236'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0F,	c1, opcode[237'b];fj:	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;@TJUMP:	opcode[240'b],	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1;	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[241'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[242'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[243'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[244'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[245'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[246'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[247'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[250'b];{A8}	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[251'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[252'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[253'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[254'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[255'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[256'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[257'b];tj:	Ybus &larr; TOSH or TOS, ZeroBr, CANCELBR[jmp, 2],	c2;jmp:	TOS &larr; MD, BRANCH[$, NoJump], L2Disp,	c3;	MAR &larr; [rhS, S + 0], DISP4[TgetsL,1],	c1;TgetsL:	Rx &larr; 1, L2Disp, GOTO[jjoin],	c2, at[1, 10, TgetsL];	Rx &larr; 2, L2Disp, GOTO[jjoin],	c2, at[3, 10, TgetsL];	Rx &larr; 3, L2Disp, GOTO[jjoin],	c2, at[5, 10, TgetsL];	Rx &larr; 4, L2Disp, GOTO[jjoin],	c2, at[7, 10, TgetsL];	Rx &larr; 5, L2Disp, GOTO[jjoin],	c2, at[9, 10, TgetsL];	Rx &larr; 6, L2Disp, GOTO[jjoin],	c2, at[0B, 10, TgetsL];	Rx &larr; 7, L2Disp, GOTO[jjoin],	c2, at[0D, 10, TgetsL];	Rx &larr; 8, L2Disp, GOTO[jjoin],	c2, at[0F, 10, TgetsL];NoJump:	MAR &larr; [rhS, S], S &larr; S -1, CANCELBR[$, 0F],	c1;	PC &larr; PC+PC16, L2 &larr; L2.0, IBDisp, DISP2[njNoCar],	c2;	S &larr; S - 0FF,	c3, at[2, 10, njNoCar];	MAR &larr; [rhS, S+0],	c1;	S &larr; S -1, L2 &larr; L2.0, IBDisp,	c2;njNoCar:	TOSH &larr; MD, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0, 10, njNoCar];{*************************	FJUMPX, TJUMPX**************************}{based on the stack pointer conventions:}{Q: does MAR&larr; interfere with XLDisp when no pagecarry?}@FJUMPX:	opcode[262'b],	MAR &larr; [rhS, S], S &larr; S -1, Xbus&larr;ibNA, XLDisp,	c1;	Ybus &larr; TOSH or TOS, {rhTOSH &larr; nRhS,} NZeroBr, BRANCH[pos, neg, 1],	c2;@TJUMPX:	opcode[263'b],	MAR &larr; [rhS, S], S &larr; S -1, Xbus&larr;ibNA, XLDisp,	c1;	Ybus &larr; TOSH or TOS, {rhTOSH &larr; nRhS,} ZeroBr, BRANCH[pos, neg, 1],	c2;{*************************	NFJUMPX, NTJUMPX	2%  4 clicks**************************}@NFJUMPX:	opcode[264'b],	{different on jump: don't pop}	MAR &larr; [rhS, S], S &larr; S -1, Xbus&larr;ibNA, XLDisp,	c1;	Ybus &larr; TOSH or TOS, NZeroBr, BRANCH[Npos, Nneg, 1],	c2;@NTJUMPX:	opcode[265'b],MAR &larr; [rhS, S], S &larr; S -1, Xbus&larr;ibNA, XLDisp,	c1;	Ybus &larr; TOSH or TOS, ZeroBr, BRANCH[Npos, Nneg, 1],	c2;Npos:	uTOS &larr; TOS, TOS &larr; MD, BRANCH[$, NoJumpP],	c3;	TOS &larr; uTOS,	c1;	Rx &larr; ib RShift1, XLDisp, SE &larr; 0,	c2;	S &larr; S + 2, BRANCH[jpe, jpo, 2],	c3;Nneg:	uTOS &larr; TOS, TOS &larr; MD, BRANCH[$, NoJumpF],	c3;	Rx &larr; 0FF,	c1;	Noop,	c2;	Noop,	c3;	TOS &larr; uTOS, {L2 &larr;   L2.TOS,}	c1;	Rx &larr; (ib xor Rx) RShift1, XLDisp, SE &larr; 0,	c2;	S &larr; S + 2, BRANCH[jne, jno, 2],	c3;{*************************	JUMPXX**************************}@JUMPXX:	opcode[261'b],	Rx &larr; ib, XLDisp,	c1;jw:	Rx &larr; Rx LRot8, BRANCH[jwPos, jwNeg, 1],	c2;jwPos:	Rx &larr; RShift1 (Rx or ib), SE&larr;0, XLDisp, GOTO[jwtos],	c3;jwNeg:	Rx &larr; RShift1 (Rx or ib), SE&larr;1, XLDisp, GOTO[jwtos],	c3;jwtos:	PC &larr; PC and 0FF, BRANCH[jwEven, jwOdd, 2],	c1;{PC,,pc16&larr;location in page}jwEven:	PC &larr; PC + Rx, GOTO[jwCross],	c2;jwOdd:	PC &larr; PC + Rx + PC16, GOTO[jwCross],	c2;jwCross:		uPCCrossL &larr; 0,	c3;	,	c1;	,	c2;	Q &larr; PC and ~0FF, L0 &larr; L0.JRemap, GOTO[UpdatePC],	c3;{*************************	Common Jump Code**************************}pos:	{uTOS &larr; TOS,} TOS &larr; MD, BRANCH[$, NoJumpX],	c3;	MAR &larr; [rhS, S+0],	c1;	Rx &larr; ib RShift1, XLDisp, SE &larr; 0,	c2;jjoin:	{uTOSH &larr; TOSH,} TOSH &larr; MD, BRANCH[jpe, jpo, 0E],	c3; {!!!}jpe:	MAR &larr; PC &larr; [rhPC, PC + Rx], GOTO[jp], {#}MesaIntBr,	c1;jpo:	MAR &larr; PC &larr; [rhPC, PC + Rx + PC16], {#}MesaIntBr,	c1;jp:	S &larr; S - 1, Xbus &larr; 0, XC2npcDisp, {#}DISP2[JumpPX],	c2;jp3:	IB &larr; MD, BRANCH[ptr1, ptr0, 0E],	c3, {#}at[0, 4, JumpPX];ptr0:	MAR &larr; [rhPC, PC + 1], IBPtr&larr;0, L2 &larr; L2.0, GOTO[RefillNE2],	c1; ptr1:	MAR &larr; [rhPC, PC + 1], IBPtr&larr;1, L2 &larr; L2.0, GOTO[RefillNE2],	c1;NoJumpP:	MAR &larr; [rhS, S], S &larr; S -1, Xbus &larr; ib, GOTO[nj],	c1;NoJumpF:	MAR &larr; [rhS, S], S &larr; S -1, Xbus &larr; ib, GOTO[nj],	c1;NoJumpN:	MAR &larr; [rhS, S], S &larr; S -1, Xbus &larr; ib, GOTO[nj],	c1;NoJumpX:	MAR &larr; [rhS, S], S &larr; S -1, Xbus &larr; ib, GOTO[nj],	c1;nj:	PC &larr; PC+1, IBDisp, L2 &larr; L2.0, DISP4[njxNoCar],	c2;	S &larr; S - 0FF,	c3, at[2, 10, njxNoCar];	MAR &larr; [rhS, S+0],	c1;	S &larr; S -1, IBDisp, L2 &larr; L2.0,	c2;njxNoCar:	TOSH &larr; MD, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0, 10, njxNoCar];	Q &larr; 0FF + 1, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3, {#}at[2, 4, JumpPX];	Q &larr; ~0FF, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3, {#}at[2, 4, JumpNX];	Q &larr; 0FF + 1, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3, {#}at[3, 4, JumpPX];	Q &larr; ~0FF, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3, {#}at[3, 4, JumpNX];	IB &larr; MD, uPCCrossL &larr; 0, BRANCH[ptrJ1, ptrJ0, 0E],	c3, {#}at[1, 4, JumpPX];	IB &larr; MD, uPCCrossL &larr; 0, BRANCH[ptrJ1, ptrJ0, 0E],	c3, {#}at[1, 4, JumpNX];ptrJ0:	IBPtr&larr;0, GOTO[MInt],	c1; ptrJ1:	IBPtr&larr;1, GOTO[MInt],	c1;neg:	TOS &larr; MD, BRANCH[$, NoJumpN],	c3;	TT &larr; 0FF,	c1;	Noop, {elim by TOSH &larr; 0, rhTOSH &larr; MD}	c2;	Noop, {MAR &larr; [rhTOSH, S], TOSH &larr; 0FF}	c3;	STK &larr; MAR &larr; [rhS, S], {S &larr; 0FE+1, L2 &larr; L2.STK,}	c1;	Rx &larr; (ib xor TT{S}) RShift1, SE &larr; 0, XLDisp, CANCELBR[$, 2],	c2;	TOSH &larr; MD, BRANCH[jne, jno, 2],	c3;jne:	MAR &larr; PC &larr; [rhPC, PC - Rx -1], GOTO[jn], {#}MesaIntBr,	c1;jno:	MAR &larr; PC &larr; [rhPC, PC - Rx - PC16], GOTO[jn], {#}MesaIntBr,	c1;jn:	S &larr; S - 1, Xbus &larr; 0, XC2npcDisp, {#}DISP2[JumpNX],	c2;jn3:	IB &larr; MD, BRANCH[ptr1, ptr0, 0E],	c3, {#}at[0, 4, JumpNX];{*************************}{Jump.dfn	comments on PC, IFU, page crossing and control transferThe DLion Interlisp-D Instruction Fetch Unit (IFU) is implemented in hardware and microcode.Code arrays cannot cross segments.  Name tables cannot cross pages.The IFU state variables and their values AT OPCODE ENTRY are:	STATE CONCEPTUALLY STORED IN THE LOCAL FRAMEcodeB		UvCL + UvChighL*2&uarr;16			fn header		tPC		2*[UvPCpageL-UvCL+(PC and 0FF)]+PC16	true byte PC	ADDITIONAL IFU STATEIBCnt=IBPtr	number of valid bytes in IFU  (must correlate even/odd with pc16 in puntFor? elsewhere ErrnIBnStkp?)CACHED IFU STATE :UvChighL	(codeB)/(2&uarr;16)				code base highUvCL		(0FFFF and codeB)UvPCpageL	(0FF00 and (codeB + tPC/2)rhPC		upper Map(codeB + tPC/2))			PC real segment and flagsPC		(0FF and tPC/2)+(0FF00 and Map(codeB + tPC/2))	PC real word addresspc16		(tPC and 1)					PC byte flip flopuPCCrossL	((tPC and 1FE)=1FE) = (PC = (FF mod 100)) 	MInt		interrupt or uPCCrossLIFU STATE AT OPCODE ENTRYA1) OPCODE ENTRY				STANDARDA2) OPCODE ENTRY abort to Pfault PUNT		uPCCrossL and (PC and FE)#FE has special meaning (for puntFor? for 4 byte ops?) =&gt; tPC &larr; tPC + 200						L2 has special meaningB1) OPCODE EXIT to refill		(1b)	(Mint)    if (uPCCrossL and (PC and FF)#FF)		then UpdatePC + 100; {uPCCrossL &larr; 0}					(2)	(RefillE) if ~uPCCrossL and IBCnt=0 and (tPC and 1FF)=0 then UpdatePC + 100					(1a)	(RefilNE) uPCCrossL &larr; (PC and FF)=FF						B2) OPCODE EXIT to "punt forward"	(1b)	if uPCCrossL and (PC and FE)#FE 			then UpdatePC + 100					(2)	if {~uPCCrossL and} IBCnt=0 and (tPC and 1FF)=0 	then UpdatePC + 100PAGE CROSS PRINCIPLE: Notice page cross by (1a+1b)IFU containing bytes from 2 pages or (2) by IFU exhausted at exactly page boundry.PAGE CROSS PRINCIPLE for 4 bytes (i) still valid (ii):{c) going to PCUpdate				tPC &larr; tPC + 2*Q}f) at fmMD of function call			L3}{Buffer Empty Refill.  Control goes from NoRCross to RefillNE since RefillE+1 does not contain an IBDisp.}RefillE:	MAR &larr; [rhPC, PC], PC &larr; PC - PC16, L0 &larr; L0.ERefill,	c1, at[400];	PC &larr; PC+PC16 {restore}, DISP2[NoRCross],	c2;{changed!!}{Buffer Not Empty Refill.}	{"Noop" location of Instruction Dispatch table}OpTable:RefillNE:		at[OpTable],Refil:{		rhRio &larr; 5, c1;		Rio &larr; 0, c2;		, c3;		MAR&larr;[rhRio, Rio+0A2], c1;		MDR &larr; PC,CANCELBR[$,2], LOOPHOLE[wok], c2;		, c3;		MAR &larr; [rhRio, Rio+0A3], c1;		MDR &larr; PV, CANCELBR[$,2], LOOPHOLE[wok],c2;		, c3;}	MAR &larr; [rhPC, PC + 1], L2 &larr; L2.0,	c1;RefillNE2:	AlwaysIBDisp, L0 &larr; L0.NERefill.Set, DISP2[NoRCross],	c2;NoRCross:	IB &larr; MD, uPCCrossL &larr; 0, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0,4,NoRCross];RCross:	Q &larr; 0FF + 1, GOTO[UpdatePC],	c3, at[2,4,NoRCross];{************************	Refill Remap Routines*******************************}{Entry:T	old real PCQ[0-7]	page displacement to be added to virtual PCQ[8-15]	ignoredPC[0-7]	ignoredPC[8-15]	valid location within new pagepc16	must be validExit:UvPCpageL	new virtual PC pageTT	new virtual PC pagerhTT	UvChighLPC	new real PC valueQ	new real PC value}{L0.ERefill &amp; uPCCrossL indicate remap and fetch (NE) PC+1}UpdatePC:	TT &larr; UvPCpageL, L1 &larr; L1.Refill{for fault trap},	c1, at[0F,10];UpdatePC2:	TT &larr; TT + Q, rhTT &larr; UvChighL,	c2;UpdatePC3:	Q{lowPC} &larr; PC,	c3;	Map &larr; [rhTT, TT], L0Disp,	c1;  {%5 -- was Map &larr; MAR &larr; [rhTT, 0+0]}	TT &larr; TT and ~0FF , DISP4[ECross],	c2;	PC &larr; Q{lowPC},{+} GOTO[NoMoreFix],	c1, at[L1.Refill,10,Fix];{Buffer Empty Refill page cross OR PCCross flag true.  Remap the PC (which points to 1st or 2nd word of page).  If we are doing an empty refill, return to the Empty Refill code at NoRCross.  If we are updating the PC because PCCross is true, return to Refill-interrupt code.}{Even if we fault, have UvPCpageL updated.}ECross:	UvPCpageL &larr; TT, PC &larr; MD, rhPC &larr; MD, ReadXRefBr,	c3, at[L0.ERefill,10,ECross];	MAR &larr; Q &larr; [rhPC, Q+0], Xbus &larr; uPCCrossL, XRefBr, ReadBRANCH[EMapUD, $],	c1, at[L0.ERefill,10,RMapFixCaller];	PC &larr; Q, BRANCH[NoRCross, PageCrossed],	c2;EMapUD:	Rx &larr; PC, CANCELBR[RLMapFix]  {returns at ERedo},	c2;{Buffer Not Empty Refill page cross.  Fetch the first word of the next page and do NOT Remap PC.  Set PCCross true and the Refill-Interrupt hardware bit.  Dispatch on the IB (as in the RefillNE code).}NECross:	Rx &larr; MD, rhRx &larr; MD, ReadXRefBr,	c3, at[L0.NERefill,10,ECross];	MAR &larr; [rhRx, 0+0], MesaIntRq, ReadBRANCH[NEMapUD, $],	c1, at[L0.NERefill,10,RMapFixCaller];	AlwaysIBDisp, L2 &larr; L2.0,	c2;	IB &larr; MD, uPCCrossL &larr; (~TT xor TT), L2 &larr; L2.0, DISPNI[OpTable],	c3;NEMapUD:	uPCCrossL &larr; (~TT xor TT), CALL[RLMapFix]  {returns at NERedo},	c2;{Jump Cross Remap.  Remap the PC (which can point to any word of a page).  uPCCrossL should remain unaltered in case the page cross test at Jgo is true.}{Even if we fault, have UvPCpageL updated.}JCross:	UvPCpageL &larr; TT, PC &larr; MD, rhPC &larr; MD, ReadXRefBr,	c3, at[L0.JRemap,10,ECross];	MAR &larr; Q &larr; [rhPC, Q+0], ReadBRANCH[JMapUD, $],	c1, at[L0.JRemap,10,RMapFixCaller];	PC &larr; Q, Xbus&larr;0, {L2Disp,} XC2npcDisp,	c2;	IB &larr; MD, BRANCH[ptr1, ptr0, 0E],	c3;JMapUD:	Rx &larr; PC, CALL[RLMapFix]  {returns at JRedo},	c2;{*************************	Common tails**************************}NoWayJose: GOTO[IgnoreInt], c3;IgnoreInt:	Noop,								c1;IBDispOnlyL: IBDisp, L2 &larr; L2.0, GOTO[DISPNIonly],				c2;DISPNIonly:	L2 &larr; L2.0, DISPNI[OpTable],					c3;{*************************	Interrupt Processing**************************}MInt0:	TT &larr; 0{buffer empty}, Xbus &larr; uPCCrossL, XRefBr, GOTO[MInt],		c1, at[600];MInt1:	TT &larr; TT xor ~TT{not empty}, Xbus &larr; uPCCrossL, XRefBr, GOTO[MInt],	c1, at[700];MInt:	BRANCH[$, Crossing],				c2;{******************* New Daybreak Interrupt Code *********************}RefillInt:	rInt &larr; IntStat,	ClrIntErr,					c3;	Ybus &larr; rInt, YDisp, GOTO[IntDisp],				c1;IntDisp:	Q &larr; uWP, DISP4[IntReasons,0C],	c2;	GOTO[IntReturns], {neither IOP nor timer}			c3, at[0C,10,IntReasons];	Q &larr; Q or u8000, GOTO[IntReturns], {timer only}			c3, at[0D,10,IntReasons];	GOTO[ReadAndClearIOPBits], {IOP only}				c3, at[0E,10,IntReasons];	Q &larr; Q or u8000, GOTO[ReadAndClearIOPBits], {both IOP and timer}	c3, at[0F,10,IntReasons];ReadAndClearIOPBits:	MAR &larr; [rhIOP, rIOP + 1], SetLOCK, CANCELBR[$],			c1;	Rx &larr; ~u8000, CANCELBR[$,2],					c2;	Rx &larr; Rx and MD {mask off the timer bit}, ClrLOCK,		c3;	MAR &larr; [rhIOP, rIOP + 1],					c1;	MDR &larr; 0, LOOPHOLE[wok], CANCELBR[$,2],				c2;{	Q &larr; Q or Rx,							c3;}	Q &larr; Q and u8000, ZeroBr,				c3;  {%T Timer fix?}{at this point Q contains the new bits for uWP}IntReturns:	rhRx &larr; oldIOPageHigh, BRANCH[$,IntsOffC2], c1;  {point at IOPage, RA 50000}	Ybus &larr; uWDC, ZeroBr, c2;	Rx &larr; 0, BRANCH[IntsOff, CheckIntCmd], c3;	Set[xT012Control, 43];   {** This SET is also in LispMiscDaybreak.mc **}	CheckIntCmd:	MAR &larr; [rhRx, Rx+PeriodicInterruptOffset], c1;	Rio &larr; u2000,CANCELBR[$,2], c2;	Rio &larr; MD and Rio, L3 &larr; 0D, c3;	Ybus &larr; Rio, ZeroBr, c1;	rhRio &larr; xT012Control, BRANCH[LispIntOn, IntsOffC3], c2;IntsOff: uWP &larr; Q, GOTO[IBDispOnlyL], c1;IntsOffC2: GOTO[IntsOffC3], c2;IntsOffC3: uWP &larr; Q,GOTO[IgnoreInt], c3;RegDef[rClockSave,		R,	0A];LispIntOn:	{link3 = 0D}	uTOS &larr; TOS, ClrIntErr, CALL[ReadTimer], c3;		{ReadTimer smashes TOS}at[0D, 10, DoveMiscOut]	Q &larr; uClockLow{62KHz}, c1;	Rx &larr; Q - rClockSave, c2;	Rx{250Hz=4ms} &larr;  Rx LRot8, c3;		Rx &larr; Rx - 4, PgCarryBr{16ms=60Hz}, c1;	TOS &larr; uTOS, BRANCH[IntsOffC33, $], c2;	rClockSave &larr; Q, c3;	uWP &larr; 0, rInt &larr; 0 LShift1, SE &larr; 1, c1;	uWDC &larr; rInt,{off interrupts}	c2;	Rx &larr; KbdFXP, L2 &larr; 0, GOTO[PuntFor],	c3;	IntsOffC33: uWP &larr; 0,GOTO[IgnoreInt], c3;{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-}{uPCCrossL is true.  Check if we are still on last word of page.  If not, go update the PC to point to the next page.  T contains 0 if buffer is empty, -1 otherwise.  This is put back into uPCCrossL.  If buffer is not empty control goes from ECross to PageCross which ignores the first word fetched.}Crossing:	Ybus &larr; PC + 1, PgCarryBr, CANCELBR[$],	c3;	L0 &larr; L0.ERefill, BRANCH[$, NotAcross],	c1;	uPCCrossL &larr; TT,  GOTO[RCross],	c2;  {We haven't crossed the boundary yet.  Save state again, keep uPCCrossL true.}NotAcross:	AlwaysIBDisp, L2 &larr; L2.0, GOTO[DNI.nop],	c2;{We've crossed the page boundary &amp; updated the PC to point to the next page.  Zero uPCCrossL. We know the buffer is not empty, but we also know it is not full so we exit through RefillNE.}PageCrossed:	uPCCrossL &larr; 0,  GOTO[RefillNE],	c3, at[1,4,NoRCross];	{ E N D }	</pre>
  </body>
</html>
