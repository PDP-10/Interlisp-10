{LispMiscDayBreak.mc, Last changed by Lichtenberg, 20-Jun-85 15:24:29	Converted to Lisp  by MPL, 20-Jun-85 15:24:29	Based on MiscDicentra by HGM, November 1983DayBreak specific portion of Misc.mc }{ 	Copyright (C) 1984, 1985 by Xerox Corporation.  All rights reserved.}{timer addresses and commands}Set[T1Count, 41];Set[T2Count, 42];Set[T012Control, 43]; {** This SET is also in dbMoreLisp.mc **}Set[T12Latch, 0DC];{  The following opcodes are defined here:	DOVEMISC 0     Read input word    Stk effect  0	DOVEMISC 1     Write output word  Stk effect -1	DOVEMISC 2     Write MP Code      Stk effect  0	DOVEMISC 3     Read Timer*        Stk effect  0	DOVEMISC 4     Byte Swap TOS      Stk effect  0	DOVEMISC 5     LOCKMEM            Stk effect -3	DOVEMISC 6     NOTIFYIOP          Stk effect  0	DOVEMISC 7     SetWakeupBits      Stk effect  0}@DOVEMISC: Rio _ TOS,   opcode[71'b], c1;	rhRio _ Rio LRot0, c2;	Rio _ TOS, c3;	, c1;	Xbus _ ib,  XDisp, c2;	DISP4[DoveMiscs], c3;	DoveMiscOut: PC _ PC + 1, GOTO[IB.nop], c1, at[L3.WriteMP, 10, DoveMiscOut];{*****************************************************************************	INPUT	Input*****************************************************************************}	IO _ [rhRio, Rio+0], 			c1, at[0,10,DoveMiscs];	TOSH _ 0, c2;	TOS _ MD, GOTO[DoveMiscOut], c3;{*****************************************************************************	OUTPUT	Output*****************************************************************************}	MAR _ [rhS, S + 0], c1, at[1,10,DoveMiscs];	S _ S - 2, c2;	TT _ MD, c3;		IO _ [rhRio, Rio+0], c1;	MDR _ TT, c2;	GOTO[DoveMiscOut], c3;{*****************************************************************************	 Write maintenance panel*****************************************************************************}@WRITEMP:	TT _ uMaintPanel,L3 _ L3.WriteMP, {maint panel code}	c1, at[2,10,DoveMiscs];WriteMPEntry:	rhTT _ uIORgnHigh, TT _ rIORgn + TT,			c2;	TOS _ TOS LRot8, {must byteswap}			c3;	MAR _ [rhTT, TT + 0],					c1;	MDR _ TOS,						c2;	TT _ TT + 1, {maint panel down-notify mask}		c3;	MAR _ [rhTT, TT + 0],					c1;	Noop,							c2;	TOS _ MD, 						c3; {TOS contains notify mask}	MAR _ [rhIOP, rIOP + 0], SetLOCK,			c1;	SetMPIntIOP,						c2;	TOS _ TOS or MD, ClrLOCK,				c3;	MAR _ [rhIOP, rIOP + 0], ClrMPIntIOP,			c1;	MDR _ TOS, L3Disp,					c2;	RET[DoveMiscOut], c3;{*****************************************************************************	RR - Read Registers*****************************************************************************}{Read Interval timer}@RRIT:	rhRio _ T012Control,		c1, at[3,10,DoveMiscs];	Rx _ 0, 			c2;	L3 _ L3.RRIT,		c3;{ The two halves of the counter are synchronized by a latch command given to the 8254 control register.  The counts are correct and synchronized to the command, not to when the counters are read. }  ReadTimer:	IO _ [rhRio, 0], {Control Register}			c1;	MDR _ T12Latch, {Latching the counts}			c2;	rhRio _ T2Count,					c3;{ read timer two, higher 16 bits }	IO _ [rhRio, 0], {Cnt 2 LSB}				c1;	TT _ 0FF,						c2;	Q _ MD and TT, {mask high byte}				c3;	IO _ [rhRio, 0], {Cnt 2 MSB}				c1;	rhRio _ T1Count,					c2;	TOS _ MD and TT, {mask high byte}			c3;{ read timer one, lower 16 bits, and finish higher (interlaced instructions)}	IO _ [rhRio, 0], {Cnt 1 LSB}				c1;	TOS _ TOS LRot8 or Q, {combine timer 2 bytes}		c2;	Q _ MD and TT, {mask high byte}				c3;	IO _ [rhRio, 0], {Cnt 1 MSB}				c1;	TOS _ 0 - TOS, {down count},				c2;	TT _ MD and TT, {mask high byte}				c3;	TT _ TT LRot8 or Q, {combine timer 1 bytes}		c1;	TT _ 1 - TT, {down count, carries at 1}			c2;	Ybus _ TT or Rx, NZeroBr, {timing glitch when TT is 0}	c3;	uClockBits _ 0, BRANCH[$,RITOut], 			c1;	Rx _ 1, {need only one repeat}				c2;	rhRio _ T012Control, GOTO[ReadTimer],			c3;	RITOut: uClockLow _ TT,L3Disp, c2;	uClockHigh _ TOS,  RET[DoveMiscOut], c3;	{-------------------------------------------------------------------------}@BYTESWAP:	TOS _ TOS LRot8, c1, at[4,10,DoveMiscs];	L2_L2.0,  c2;	TOSH _ smallpl, GOTO[DoveMiscOut], c3;{-------------------------------------------------------------------------}{@LOCKMEM: [operation, offset, value, mask] RETURNS [result]}{ignore mask, since we have hardware lock}{T is loaded with value for operation}{TT is loaded with offset into IORegion, whose base address is in [uIORgnHigh, rIORgn]}{lower three bits of operation used for dispatch}Set[lock.add,08];Set[lock.and,09];Set[lock.or,0A];Set[lock.xchg,0B];Set[lock.wrIfNil,0C];{ Lisp calling params:		TOS --> Operation 		TOS-1 --> Offset		TOS-2 --> Value		TOS-3 --> Mask		 }@LOCKMEM:	MAR _ [rhS, S + 0], c1, at[5,10,DoveMiscs];	S _ S - 2, c2;	TT _ MD, c3;   {TT = Offset}	MAR _ [rhS, S + 0], c1;	S _ S - 2, c2;	Rx _ MD, c3;   {Rx = Value}		MAR _ [rhS, S + 0], c1;	stackP _ 0, c2;	TOSH _ MD, c3;   {TOSH = Mask}	S _ S - 2, c1;	STK _ TOS, c2;	rhTT _ uIORgnHigh, TT _ rIORgn + TT, {assume no carry}	c3;	MAR _ [rhTT, TT + 0], SetLOCK, Xbus _ STK {operation}, XDisp,	c1;	DISP4[LockMemOp,08],				c2;LockAdd:	TOS _ MD, ClrLOCK,					c3, at[lock.add,10,LockMemOp];	MAR _ [rhTT, TT + 0],					c1;	MDR _ TOS _ Rx + TOS, GOTO[LockMemOut], c2;LockAnd:	Rx _ Rx and MD, ClrLOCK, GOTO[LockMemStore],		c3, at[lock.and,10,LockMemOp];LockOr:	Rx _ Rx or MD, ClrLOCK, GOTO[LockMemStore],		c3, at[lock.or,10,LockMemOp];LockMemStore:	MAR _ [rhTT, TT + 0],					c1;LockMemStore2:	  MDR _  Rx, GOTO[LockMemOut],	c2;LockXChg:	TOS _ MD, ClrLOCK,					c3, at[lock.xchg,10,LockMemOp];	MAR _ [rhTT, TT + 0],					c1;	MDR _ Rx, GOTO[LockMemOut],	c2;LockWrIfNil:	TOS _ MD,						c3, at[lock.wrIfNil,10,LockMemOp];	Noop, {necessary because of timing constraints}		c1;	Noop, {ditto}						c2;	Ybus _ TOS, ZeroBr, ClrLOCK,				c3;	MAR _ [rhTT, TT + 0], BRANCH[$,LockMemStore2],		c1;	MDR _ TOS {must write to clear lock}, GOTO[LockMemOut],	c2;	LockMemOut:  TOSH _ smallpl, GOTO[DoveMiscOut], c3;{-------------------------------------------------------------------------}@NOTIFYIOP: {TOS contains notify mask}	MAR _ [rhIOP, rIOP + 0], SetLOCK,			c1, at[6,10,DoveMiscs];	SetMPIntIOP,						c2;	TOS _ TOS or MD, ClrLOCK,				c3;	MAR _ [rhIOP, rIOP + 0], ClrMPIntIOP,			c1;	MDR _ TOS,						c2;	GOTO[DoveMiscOut], c3;{-------------------------------------------------------------------------}@SetWakeupBits:	TT _ uWP,  MesaIntRq,				c1, at[07,10,DoveMiscs];	TT _ TT or TOS,						c2;	uWP _ TT,  GOTO[DoveMiscOut], 		c3;{-------------------------------------------------------------------------}