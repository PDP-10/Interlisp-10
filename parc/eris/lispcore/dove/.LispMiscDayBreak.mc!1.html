<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Dove>LispMiscDayBreak.mc!1</title>
  </head>
  <body>
    <pre>
{LispMiscDayBreak.mc, Last changed by Lichtenberg, 20-Jun-85 15:24:29	Converted to Lisp  by MPL, 20-Jun-85 15:24:29	Based on MiscDicentra by HGM, November 1983DayBreak specific portion of Misc.mc }{ 	Copyright (C) 1984, 1985 by Xerox Corporation.  All rights reserved.}{timer addresses and commands}Set[T1Count, 41];Set[T2Count, 42];Set[T012Control, 43]; {** This SET is also in dbMoreLisp.mc **}Set[T12Latch, 0DC];{  The following opcodes are defined here:	DOVEMISC 0     Read input word    Stk effect  0	DOVEMISC 1     Write output word  Stk effect -1	DOVEMISC 2     Write MP Code      Stk effect  0	DOVEMISC 3     Read Timer*        Stk effect  0	DOVEMISC 4     Byte Swap TOS      Stk effect  0	DOVEMISC 5     LOCKMEM            Stk effect -3	DOVEMISC 6     NOTIFYIOP          Stk effect  0	DOVEMISC 7     SetWakeupBits      Stk effect  0}@DOVEMISC: Rio &larr; TOS,   opcode[71'b], c1;	rhRio &larr; Rio LRot0, c2;	Rio &larr; TOS, c3;	, c1;	Xbus &larr; ib,  XDisp, c2;	DISP4[DoveMiscs], c3;	DoveMiscOut: PC &larr; PC + 1, GOTO[IB.nop], c1, at[L3.WriteMP, 10, DoveMiscOut];{*****************************************************************************	INPUT	Input*****************************************************************************}	IO &larr; [rhRio, Rio+0], 			c1, at[0,10,DoveMiscs];	TOSH &larr; 0, c2;	TOS &larr; MD, GOTO[DoveMiscOut], c3;{*****************************************************************************	OUTPUT	Output*****************************************************************************}	MAR &larr; [rhS, S + 0], c1, at[1,10,DoveMiscs];	S &larr; S - 2, c2;	TT &larr; MD, c3;		IO &larr; [rhRio, Rio+0], c1;	MDR &larr; TT, c2;	GOTO[DoveMiscOut], c3;{*****************************************************************************	 Write maintenance panel*****************************************************************************}@WRITEMP:	TT &larr; uMaintPanel,L3 &larr; L3.WriteMP, {maint panel code}	c1, at[2,10,DoveMiscs];WriteMPEntry:	rhTT &larr; uIORgnHigh, TT &larr; rIORgn + TT,			c2;	TOS &larr; TOS LRot8, {must byteswap}			c3;	MAR &larr; [rhTT, TT + 0],					c1;	MDR &larr; TOS,						c2;	TT &larr; TT + 1, {maint panel down-notify mask}		c3;	MAR &larr; [rhTT, TT + 0],					c1;	Noop,							c2;	TOS &larr; MD, 						c3; {TOS contains notify mask}	MAR &larr; [rhIOP, rIOP + 0], SetLOCK,			c1;	SetMPIntIOP,						c2;	TOS &larr; TOS or MD, ClrLOCK,				c3;	MAR &larr; [rhIOP, rIOP + 0], ClrMPIntIOP,			c1;	MDR &larr; TOS, L3Disp,					c2;	RET[DoveMiscOut], c3;{*****************************************************************************	RR - Read Registers*****************************************************************************}{Read Interval timer}@RRIT:	rhRio &larr; T012Control,		c1, at[3,10,DoveMiscs];	Rx &larr; 0, 			c2;	L3 &larr; L3.RRIT,		c3;{ The two halves of the counter are synchronized by a latch command given to the 8254 control register.  The counts are correct and synchronized to the command, not to when the counters are read. }  ReadTimer:	IO &larr; [rhRio, 0], {Control Register}			c1;	MDR &larr; T12Latch, {Latching the counts}			c2;	rhRio &larr; T2Count,					c3;{ read timer two, higher 16 bits }	IO &larr; [rhRio, 0], {Cnt 2 LSB}				c1;	TT &larr; 0FF,						c2;	Q &larr; MD and TT, {mask high byte}				c3;	IO &larr; [rhRio, 0], {Cnt 2 MSB}				c1;	rhRio &larr; T1Count,					c2;	TOS &larr; MD and TT, {mask high byte}			c3;{ read timer one, lower 16 bits, and finish higher (interlaced instructions)}	IO &larr; [rhRio, 0], {Cnt 1 LSB}				c1;	TOS &larr; TOS LRot8 or Q, {combine timer 2 bytes}		c2;	Q &larr; MD and TT, {mask high byte}				c3;	IO &larr; [rhRio, 0], {Cnt 1 MSB}				c1;	TOS &larr; 0 - TOS, {down count},				c2;	TT &larr; MD and TT, {mask high byte}				c3;	TT &larr; TT LRot8 or Q, {combine timer 1 bytes}		c1;	TT &larr; 1 - TT, {down count, carries at 1}			c2;	Ybus &larr; TT or Rx, NZeroBr, {timing glitch when TT is 0}	c3;	uClockBits &larr; 0, BRANCH[$,RITOut], 			c1;	Rx &larr; 1, {need only one repeat}				c2;	rhRio &larr; T012Control, GOTO[ReadTimer],			c3;	RITOut: uClockLow &larr; TT,L3Disp, c2;	uClockHigh &larr; TOS,  RET[DoveMiscOut], c3;	{-------------------------------------------------------------------------}@BYTESWAP:	TOS &larr; TOS LRot8, c1, at[4,10,DoveMiscs];	L2&larr;L2.0,  c2;	TOSH &larr; smallpl, GOTO[DoveMiscOut], c3;{-------------------------------------------------------------------------}{@LOCKMEM: [operation, offset, value, mask] RETURNS [result]}{ignore mask, since we have hardware lock}{T is loaded with value for operation}{TT is loaded with offset into IORegion, whose base address is in [uIORgnHigh, rIORgn]}{lower three bits of operation used for dispatch}Set[lock.add,08];Set[lock.and,09];Set[lock.or,0A];Set[lock.xchg,0B];Set[lock.wrIfNil,0C];{ Lisp calling params:		TOS --&gt; Operation 		TOS-1 --&gt; Offset		TOS-2 --&gt; Value		TOS-3 --&gt; Mask		 }@LOCKMEM:	MAR &larr; [rhS, S + 0], c1, at[5,10,DoveMiscs];	S &larr; S - 2, c2;	TT &larr; MD, c3;   {TT = Offset}	MAR &larr; [rhS, S + 0], c1;	S &larr; S - 2, c2;	Rx &larr; MD, c3;   {Rx = Value}		MAR &larr; [rhS, S + 0], c1;	stackP &larr; 0, c2;	TOSH &larr; MD, c3;   {TOSH = Mask}	S &larr; S - 2, c1;	STK &larr; TOS, c2;	rhTT &larr; uIORgnHigh, TT &larr; rIORgn + TT, {assume no carry}	c3;	MAR &larr; [rhTT, TT + 0], SetLOCK, Xbus &larr; STK {operation}, XDisp,	c1;	DISP4[LockMemOp,08],				c2;LockAdd:	TOS &larr; MD, ClrLOCK,					c3, at[lock.add,10,LockMemOp];	MAR &larr; [rhTT, TT + 0],					c1;	MDR &larr; TOS &larr; Rx + TOS, GOTO[LockMemOut], c2;LockAnd:	Rx &larr; Rx and MD, ClrLOCK, GOTO[LockMemStore],		c3, at[lock.and,10,LockMemOp];LockOr:	Rx &larr; Rx or MD, ClrLOCK, GOTO[LockMemStore],		c3, at[lock.or,10,LockMemOp];LockMemStore:	MAR &larr; [rhTT, TT + 0],					c1;LockMemStore2:	  MDR &larr;  Rx, GOTO[LockMemOut],	c2;LockXChg:	TOS &larr; MD, ClrLOCK,					c3, at[lock.xchg,10,LockMemOp];	MAR &larr; [rhTT, TT + 0],					c1;	MDR &larr; Rx, GOTO[LockMemOut],	c2;LockWrIfNil:	TOS &larr; MD,						c3, at[lock.wrIfNil,10,LockMemOp];	Noop, {necessary because of timing constraints}		c1;	Noop, {ditto}						c2;	Ybus &larr; TOS, ZeroBr, ClrLOCK,				c3;	MAR &larr; [rhTT, TT + 0], BRANCH[$,LockMemStore2],		c1;	MDR &larr; TOS {must write to clear lock}, GOTO[LockMemOut],	c2;	LockMemOut:  TOSH &larr; smallpl, GOTO[DoveMiscOut], c3;{-------------------------------------------------------------------------}@NOTIFYIOP: {TOS contains notify mask}	MAR &larr; [rhIOP, rIOP + 0], SetLOCK,			c1, at[6,10,DoveMiscs];	SetMPIntIOP,						c2;	TOS &larr; TOS or MD, ClrLOCK,				c3;	MAR &larr; [rhIOP, rIOP + 0], ClrMPIntIOP,			c1;	MDR &larr; TOS,						c2;	GOTO[DoveMiscOut], c3;{-------------------------------------------------------------------------}@SetWakeupBits:	TT &larr; uWP,  MesaIntRq,				c1, at[07,10,DoveMiscs];	TT &larr; TT or TOS,						c2;	uWP &larr; TT,  GOTO[DoveMiscOut], 		c3;{-------------------------------------------------------------------------}</pre>
  </body>
</html>
