<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>GC>LispDMC.DM!2>LSTACK.mc</title>
  </head>
  <body>
    <pre>
:Title[LSTACK.mc, StackFrame manipulations];** Edit History* March 22, 1985 masinter, Formatting only* January 17, 1985  11:32 PM, Masinter, add STORE.N, COPY.N* January 13, 1984  9:25 PM, JonL, LBIND merged in here*		PUSHTMD, TL.ST0TMD, TL.PUSHNIL and TL.PUSHTRUE to LVARCONST,*		removed PUSHQT (no users?)* January 6, 1984  4:55 AM, JonL, Note that REPNIL appears here (when ?)*		added TL.REPNIL2 for CDR's benefit* January 3, 1984  8:32 PM, JonL, Removed FIXSTACKREGS (was  *			nowhere else referenced) and added lots of commentary* December 27, 1983  11:30 AM, JonL, moved opCOPY from LINST* December 26, 1983  3:11 PM, JonL, added subroutine ABFETCH,*			SWAP starts out StackM2BR, and to use ABFETCH* December 21, 1983  7:48 AM, JonL, brought in opSWAP, opPOP,*			and REPSMALLT; Moved NEXTOP to LOPS* December 15, 1983  3:49 PM -- added label REPTMD1 - JonL* December 9, 1983  1:14 PM -- Added ARG0 - JonL* Prior dates -- Masinter	KnowRBase[LTEMP0];	TOP LEVEL;	InsSet[LispInsSet, 1];*--------------------------------------------------------------------opCOPY:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase;   T&larr; Md, fetch&larr; T, branch[PUSHTMD];regOP1[144, StackM2BR, opCOPY, noNData];*--------------------------------------------------------------------opCOPYN:*--------------------------------------------------------------------   T&larr; (TSP) - (T), TisID;   T&larr; (fetch&larr; T) - 1, flipMemBase;   T&larr; Md, fetch&larr; T, branch[PUSHTMD];regOP2[75, StackM2BR, opCOPYN, noNData];*--------------------------------------------------------------------opSTOREN:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase;   T&larr; Md, LTEMP0 &larr; (fetch&larr; T) - (3c);   LTEMP0&larr; (LTEMP0) - (T), TisID, branch[TL.ST0TMD];regOP2[74, StackM2BR, opSTOREN, noNData];*--------------------------------------------------------------------opPOP:*--------------------------------------------------------------------regOP1[277, StackBR, opPOP, noNData];	LEFT&larr; (LEFT) + 1;TL.POP1:	TSP&larr; (TSP) - (2c), NextOpcode;*--------------------------------------------------------------------opSWAP:*-------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMembase, call[ABFETCH];	* Bhi in LTEMP0											* Blo in LTEMP1	LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;					* Ahi in LTEMP2	LTEMP3&larr; Md,								* Alo in LTEMP3	T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;				* Ahi&larr; Bhi	T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;				* Alo&larr; Blo	T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP2;				* Bhi&larr; Ahi	store&larr; T, dbuf&larr; LTEMP3, NextOpcode;				* Blo&larr; AloregOP1[375, StackM2BR, opSWAP, noNData];*--------------------------------------------------------------------SUBROUTINE;	ABFETCH:*--------------------------------------------------------------------* For two-arguments A and B on stack (B in TOS)* Enter with fetch pending on Bhi,*            T positioned over Blo,*            membase is StackBr*  typical entry starts membase at StackM2BR and does*         T&larr; (fetch&larr; TSP) - 1, flipMembase, call[ABFETCH];* Exit with Bhi in LTEMP0*           Blo in LTEMP1*           fetch pending on Ahi*           T positioned over Alo	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);	 				* Hi.word in LTEMP0	LTEMP1&larr; Md, T&larr; (fetch&larr; T) + 1, return;			 	* Lo.word in LTEMP1TOPLEVEL;*--------------------------------------------------------------------opMYALINK:*--------------------------------------------------------------------regOP1[146, StackBR, opMYALINK, noNData];	T&larr; (PVAR) - (FXBACK[ALINK]);	fetch&larr; T, T&larr; (177776c);	T&larr; T and Md;	T&larr; T - (FX.PVAR), branch[PUSHSMALLT];UfnOps[145];			* MYARGCOUNTUfnOps[141];			* ARG0% Someday, we'd like to do these two *--------------------------------------------------------------------opMYARGCOUNT:*--------------------------------------------------------------------regOP1[145, StackBR, opMYARGCOUNT, noNData];	T&larr; (PVAR) - (FXBACK[ALINK]), call[.GETMYARGCOUNT];         * Get Alink wd to see if fastp 	branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[TL.PUSHT];SUBROUTINE;.GETMYARGCOUNT:	T&larr; (fetch&larr; T)+(FXDIF[BFLAGS,ALINK]); * T points to BFLAGS in BF	LTEMP0&larr; Md, fetch&larr; T;			*LTEMP0 holds Alink,fetch Bflags contents	branch[.+2, R even], LTEMP0, LTEMP0 &larr; (BfPadded); 	    TOP LEVEL; callUFN; 	SUBROUTINE;	*Punt out if not fastp case	pd &larr; (LTEMP0) and (Md);	branch[.+2, alu=0], T&larr; (T - (IVAR)) rsh 1; * and nargs &larr; # IVAR wds / 2	    T&larr; T - 1, RETURN; 	* when "padded", there is an extra cell. sub it off	return;TOP LEVEL;*--------------------------------------------------------------------opARG0:*--------------------------------------------------------------------regOP1[141, StackM2BR, opARG0, noNData];	T&larr; (fetch&larr; TSP) + 1;			* One arg, the index of IVAR 	T&larr; Md, fetch&larr; T;				*   wanted	pd&larr; T-(SmallHi), LTEMP1&larr; Md;	branch[.+2, alu=0], T&larr; (LTEMP1) + (LTEMP1), flipMemBase;*punt if ~SMALLPOSP	   callUFN;				*  or if = 0	branch[.+2, alu#0], LTEMP2&larr; T + (IVAR);	* args are double wds	   callUFN;* BEGINNING OF TESTING 	nop;	T&larr; (PVAR) - (FXBACK[ALINK]), call[.GETMYARGCOUNT]; * at this point, T has MYARGCOUNT in it	pd&larr; (LTEMP1) - T - 1, flipMemBase; 	branch [.+2, carry'];	   callUFN;* arg too large!* end of test	T&larr; (fetch&larr; LTEMP2) + 1;	T&larr; Md, fetch&larr; T;	T&larr; Md, TSP &larr; (store&larr; TSP) + 1, dbuf&larr; T;	TSP &larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;%*--------------------------------------------------------------------opBIND:*--------------------------------------------------------------------* Binds n1 pvars to NIL and * n2 pvars to the n2 items on the stack* Last pvar stored into is N* pushes binding mark [-(n1+n2)-1,, 2*N]	T&larr; LTEMP0&larr; Id;						* n1 (first 4 bits) #NILs	LTEMP1&larr; Id, Cnt&larr; T;					* n2 (next 4 bits)  #values 	T&larr; (Id) lsh 1;						* 2*N	T&larr; (PVAR) + (Q&larr; T);	branch[.endBindNils, Cnt=0&amp;-1], LTEMP2&larr; T + 1; .BindVarToNil:	LTEMP2&larr; (store&larr; LTEMP2) - 1, DBuf&larr; AT.NIL;	LTEMP2&larr; (store&larr; LTEMP2) - 1, DBuf&larr; 0c,	branch[.BindVarToNil,Cnt#0&amp;-1];.endBindNils:	Cnt&larr; LTEMP1, T&larr; LTEMP1;							* #values to bind	LEFT&larr; (LEFT) + T;.BindVarToVal:	T&larr; (TSP) - 1, branch[.EndBind, Cnt=0&amp;-1];	TSP&larr; (fetch&larr; T) - 1;	T&larr; Md, (fetch&larr; TSP);	T&larr; Md, LTEMP2&larr; (store&larr; LTEMP2) - 1, dbuf&larr; T;	LTEMP2&larr; (store&larr; LTEMP2) - 1, DBuf&larr; T, branch[.BindVarToVal];.EndBind:	T&larr; (0s) - (LTEMP1);								* -N2	T&larr; T - (LTEMP0) - 1;								* -N1-N2-1PUSHTQ: 	branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;:if[Debugging];	pd&larr; T and not (77c);	branch[.+2, alu=0];		uCodeCheck[badpushval];:endif;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; Q, NextOpCode;IFUreg[21, 3, StackBR, 0, opBIND, noNData, 0, 1];*--------------------------------------------------------------------opUNBIND:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase;	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1, flipMemBase;	TSP&larr; T, Q&larr; Md, branch[opDUNBIND];*--------------------------------------------------------------------opDUNBIND:*--------------------------------------------------------------------	T&larr; TSP&larr; (fetch&larr; TSP) - (2c);	LTEMP1&larr; Md, T&larr; T + 1;	branch[opDUNBIND, R&gt;=0], LTEMP1, LTEMP1&larr; not (LTEMP1);*	T points (relative to StackM2BR) to the odd word*	LTEMP1 has (n1+n2)	flipMemBase;	fetch&larr; T;	Cnt&larr; LTEMP1;	T&larr; (PVAR) + (Md) + 1;.unbindvar:					* Loop here	branch[.unbindend, Cnt=0&amp;-1], T&larr; T - 1;:if[Debugging];	* check if slot was not bound	fetch &larr; T;	pd &larr; Md;	branch[.+2, alu&gt;=0];	   uCodeCheck[UnBindNotBound];:endif;	T&larr; (store&larr; T) - 1, dbuf&larr; AllOnes, branch[.unbindvar];.unbindend:	call[FIXLEFT];	pd&larr; Id;		branch[PUSHTQ, alu=0], T&larr; LTEMP0;	* Id=0 for unbind	NextOpCode;regOP1[22, StackM2BR, opUNBIND, 0];		* UNBINDregOP1[23, StackM2BR, opDUNBIND, 1];	* DUNBIND</pre>
  </body>
</html>
