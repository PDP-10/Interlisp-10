<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>GC>LispDMC.DM!2>LCALLRET.mc</title>
  </head>
  <body>
    <pre>
:Title[LCALLRET];** Edit History* March 13, 1985  9:45 AM, Masinter, remove calls to SAVEUCODESTATE* January 6, 1985  12:18 AM, JonL, let .ATOMICFN flipMembase when*     litatom index number has the 2&uarr;15 bit on* February 9, 1984  1:07 AM, JonL, fixed screwup in label ufnPC:* February 2, 1984  11:04 AM, JonL, fixes to callers of SAVEUCODESTATE* January 31, 1984  5:02 PM, temporarily add call to SAVEUCODESTATE*		to opUFN, ufnPC, and callers of DOCALLPUNT* January 24-27, 1984, JonL, Globalize DOCALLPUNT* January 13, 1984  8:07 PM, JonL, call and return code into one file* January 4, 1984  7:26 PM, JonL, moved in some subroutines from*		LSTACK.mc -- ADDSTK from LSTACK; ufnPC resets Hardware stack* December 31, 1983  12:51 PM, JonL, set memBase at ufnPC so code can*		branch directly to it; added some commentary* November 29, 1983  2:42 PM, JonL, removed spurious BrLo&larr; DEFLO.* December 7, 1982  4:38 PM, Masinter - - - *--------------------------------------------------------------------* Function call*--------------------------------------------------------------------KnowRBase[LTemp0];TOPLEVEL;InsSet[LispInsSet, 1];*--------------------------------------------------------------------opFN:				* FN0-4 operators*--------------------------------------------------------------------	NARGS&larr; Id;	T&larr; Id;	T&larr; LSH[T,10];	DEFLO&larr; (Id) + T;	* 16 bit atom index*--------------------------------------------------------------------.FNCALL1:			* Entry for DOCALLPUNT*--------------------------------------------------------------------	LTEMP0&larr; Id - (PCX') - 1;						* Return PC, for a n-byte op	CHECKPCX;*--------------------------------------------------------------------.FNCALL2:			* Entry for FNx and opUFN*--------------------------------------------------------------------   T&larr; (PVAR) - (FXBACK[PC]);	* Suspend the current frame   store&larr; T, dbuf&larr; LTEMP0, Branch[.ATOMICFN];	*  by saving the PC.atfXtnd:	memBase&larr; StackBR, Call[ADDSTK];*--------------------------------------------------------------------.ATOMICFN:			* Build a frame and start running the function whose *							index is DEFLO; NARGS args are on stack already.*--------------------------------------------------------------------	T&larr; (DEFLO) + (DEFLO), memBase&larr; DefBR;	* T&larr; word index of defcell   PSTATE&larr; T-T-1, branch[.+2, carry'];		flipMemBase;* CAN FAULT!!!	T&larr; (FETCH&larr; T) + 1;			* Fetch contents of defcell	LTEMP0&larr; MD, fetch&larr; T, T&larr; (rhmask);	* LTEMP0&larr; hi def	branch[.+2, R&lt;0], LTEMP0&larr; T and (LTEMP0), * SignBit of defcell is 	T&larr; Md, memBase&larr; ifuBR; 	*  flag for compiled code	DEFHI&larr; (atomHiVal), Branch[.notCCODE];	BrHi&larr; LTEMP0;	LTEMP1&larr; BrLo&larr; T;			* LTEMP1&larr; fnLo* CAN FAULT!!!	FETCH&larr; 0s;				* Fetch first word of	T&larr; LSH[LTEMP0, 10];			*  function header	LTEMP0&larr; (LTEMP0) + T;			* Recompute fnheader	T&larr; MD, fetch&larr; 1s;	T&larr; (ESP) - T;	pd&larr; T - (TSP);				* ESP - #WORDS - TSP	branch[.+2, carry], LTEMP2&larr; Md,		* LTEMP2&larr; def.na 	T&larr; (fetch&larr; 2s) + 1;	DEFHI&larr; (atomHiVal), Branch[.atfXtnd];:if[FNStats];	branch[.nofnstat, R&lt;0], LTEMP3&larr; Md,FnStatsPtr, fetch&larr; T; 		PCF&larr; Md, PSTATE&larr; A0; call[FNSTAT];	branch[.afterfnstat];:else;	LTEMP3&larr; Md, fetch&larr; T;:endif;.nofnstat:	PCF&larr; Md, PSTATE&larr; A0;			* start IFU early.afterfnstat:* No faults after here* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **    KLUDGE FOR FINDING OUT WHO IS CALLED: SMASH DEF WITH BIT     **    FETCH&larr; (4S); IVAR&larr; MD;                                       **    BRANCH[.+2, R&lt;0], IVAR&larr; IVAR OR (100000C);                   **    STORE&larr; (4S), DBUF&larr; IVAR;                                     ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	T&larr; (NARGS) + (NARGS), memBase&larr; StackBR;PCXBAD;	IVAR&larr; (TSP) - T;	T&larr; (PVAR) - (FXBACK[NEXT]);	store&larr; T, dbuf&larr; IVAR;							* store FX.next	branch[.NoAdj, R&lt;0], T&larr; LTEMP2;	T&larr; (NARGS) - T;.tryagain:	branch[.NoAdj', alu=0], pd&larr; T;	branch[.TooMany, alu&gt;0];	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;	T&larr; T+1, branch[.tryagain];.TooMany:	TSP&larr; (TSP) - (2c);	T&larr; T-1, branch[.tryagain];.NoAdj':	T&larr; (store&larr; TSP) + 1, dbuf&larr; BFBlock, branch[.+2];.NoAdj:	T&larr; (store&larr; TSP) + 1, dbuf&larr; BFBlock;%.NoAdj':	Branch[.+2], pd&larr; (TSP) and (2c);.NoAdj:	pd&larr; (TSP) and (2c);	branch[.QuadP,  alu=0], T&larr; (store&larr; TSP) + 1, dbuf&larr; BFBlock;		T&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;		* Smash in a cell of 0's if not		T&larr; (store&larr; T) + 1, dbuf&larr; 0c;			*  quadword aligned; new BF wd		T&larr; (store&larr; T) + 1, dbuf&larr; (add[BFBlock!, BFPadded!]c);.QuadP:%	T&larr; (store&larr; T) + 1, dbuf&larr; IVAR;		* new IVAR	T&larr; (store&larr; T) + 1, dbuf&larr; FxtnBlock;	* default flags	T&larr; (store&larr; T) + 1, dbuf&larr; PVAR;		* old PVAR	T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;					* fn address hi	store&larr; T, dbuf&larr; LTEMP0;								* fn address lo	T&larr; PVAR&larr; T + (FXDIF[PVAR, DEFHI]);	dblbranch[.StorePVS, .endfn, R&gt;=0], Cnt&larr; LTEMP3;.StorePVS:	T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes;	* "Pvars", in multiples	T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes;	*  of 2 cells	T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes;	T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes, 	 dblbranch[.StorePVS, .endfn, Cnt#0&amp;-1];.endfn:	T&larr; TSP&larr; T + (4c);	T&larr; ((ESP) - T) rsh 1;	LEFT&larr; T - (LeftOffset), NextOpCode;.notCCODE:	T&larr; (TSP), memBase&larr; StackBR;	T&larr; (store&larr; T) + 1, dbuf&larr; DEFHI;	TSP&larr; (store&larr; T) + 1, dbuf&larr; DEFLO;	NARGS&larr; (NARGS) + 1;	DEFLO&larr; AT.INTERPRETER, branch[.ATOMICFN];*--------------------------------------------------------------------SUBROUTINE;	ADDSTK:	 * add space to stack frame for FNCALL etc*--------------------------------------------------------------------	T&larr; (fetch&larr; ESP) + 1;									* next stack word	T&larr; Md, fetch&larr; T;	pd&larr; T xor (FreeStackBlock);	branch[.+2, alu=0];		TOP LEVEL;	Branch[STKOVPUNT];	 TOPLEVEL;	ESP&larr; (ESP) + (Md);.mergefree:	T&larr; (fetch&larr; ESP) + 1;	T&larr; Md, fetch&larr; T;	pd&larr; T xor (FreeStackBlock);	branch[.+2, alu=0], T&larr; ESP;		LEFT&larr; T - (TSP), Branch[FIXLEFT1];	ESP&larr; (ESP) + (Md), branch[.mergefree];TOPLEVEL; IFUpause[10, 3, StackBR, 0, opFN, 0, 0, 0];	*FN0IFUpause[11, 3, StackBR, 0, opFN, 1, 0, 0];	*FN1IFUpause[12, 3, StackBR, 0, opFN, 2, 0, 0];	*FN2IFUpause[13, 3, StackBR, 0, opFN, 3, 0, 0];	*FN3IFUpause[14, 3, StackBR, 0, opFN, 4, 0, 0];	*FN4*--------------------------------------------------------------------opFNX:*--------------------------------------------------------------------* Takes 3 argument bytes; first is NARGS, 2nd and 3rd are fn #.* since IFU won't handle 4 byte instructions, the first arg is* gotten from the IFU, and the fn is fetched directly. Things are* much simpler if the opcode happens to be word aligned. 	NARGS&larr; Id;	DEFLO&larr; T&larr; (Id)-(PCX')-1;		* Id is length- get byte# of 3rd byte	LTEMP0&larr; T rsh 1;			* word which contains hi byte of fnPAGEFAULTOK;	LTEMP0&larr; (FETCH&larr; LTEMP0) + 1;	branch[.+2, R odd], DEFLO&larr; MD, 					T&larr; T + (2c);	* T has new PC		LTEMP0&larr; T, memBase&larr; StackBR, branch[.FNCALL2];FNXsplit:	LTEMP0&larr; T, FETCH&larr; LTEMP0;			* save PC, fetch lo byte	memBase&larr; StackBR, T&larr; MD;			* T has lo byte of fn in hi bytePAGEFAULTNOTOK;	DEFLO&larr; Rcy[DEFLO, T, 10], branch[.FNCALL2];	* and fix upIFUpause[15, 2, ifuBR, 0, opFNX, noNData, 0, 0];*--------------------------------------------------------------------opAPPLYFN:*--------------------------------------------------------------------* TOS = FN TO CALL, TOS-1 = NARGS, TOS-... = arguments to FN	T&larr; (fetch&larr; TSP) + 1;							* fetch defhi	DEFHI&larr; Md, T&larr; (fetch&larr; T) - (3c);			* fetch deflo	DEFLO&larr; Md, T&larr; (fetch&larr; T) + 1;				* fetch narghi	T&larr; Md, fetch&larr; T, flipMemBase;	NARGS&larr; Md, pd&larr; T xor (SmallHi);	branch[.+2, alu=0], TSP&larr; (TSP) - (4c);		UCodeCheck[BadRetCall];	LTEMP0&larr; Id - (PCX') - 1;				* Save return PC	T&larr; (PVAR) - (FXBACK[PC]);	store&larr; T, dbuf&larr; LTEMP0;	pd&larr; (DEFHI) xor (AtomHiVal);				* Check for atomic fn	branch[.+2, alu=0];		branch[.notCCODE];	branch[.ATOMICFN];IFUpause[16, 1, StackM2BR, 0, opAPPLYFN, NoNData, 0, 0];	*APPLYFN:if[NotReduced];*--------------------------------------------------------------------opCKAPPLY:*--------------------------------------------------------------------* TOS = FN TO CALL	T&larr; (fetch&larr; TSP) + 1;		LTEMP0&larr; Md, fetch&larr; T;										* hiloc	T&larr; Md, memBase&larr; DefBR, pd&larr; LTEMP0;	branch[.+2, alu=0], T&larr; T + T;		CallUFN;		* not litatomPAGEFAULTOK;	FETCH&larr; T;	LTEMP0&larr; MD;PAGEFAULTNOTOK;	branch[.+2, R&lt;0], pd&larr; (LTEMP0) and (20000c);		CallUFN;								* not CCODEP	branch[.+2, alu=0];		CallUFN;							* not argtype=0, 2	NextOpCode;regOP1[17, StackM2BR, opCKAPPLY, NoNData];	*CKAPPLY:else;	UfnOps[17];:endif;*--------------------------------------------------------------------opUFN:*--------------------------------------------------------------------* All "undefined" entries in the IFU memory come here, with *	a call is manufactured to the function fetched *  from the UFN table, according to byte at PC. * Format of table:	defindex[0:15]		left word;*							nargs[8:15]			right word.ufn0:	memBase&larr; ifuBR;	T&larr; LTEMP1&larr; not(PCX');			* T&larr; current PC (byte offset)	LTEMP0&larr; T rsh 1;							* LTEMP0&larr; current PC word address	CHECKPCX;PAGEFAULTOK;	LTEMP0&larr; (fetch&larr; LTEMP0) + 1;		* fetch word containing current op	T&larr; Md, fetch&larr; LTEMP0;	Branch[.ufnPCR, R odd], LTEMP1, LTEMP1&larr; Md;.ufnPCL:		LTEMP1&larr; RCY[T, LTEMP1, 10];		T&larr; RSH[T, 10], branch[.ufnPC2];.ufnPCR:	T&larr; (T) and (rhmask);.ufnPC2:	memBase&larr; ufnBR, T&larr; T + T;PAGEFAULTNOTOK;	T&larr; (fetch&larr; T) + 1;	DEFLO&larr; Md, fetch&larr; T;	NARGS&larr; Md, memBase&larr; StackBR;	T&larr; RSH[NARGS, 10];	LTEMP0&larr; BDispatch&larr; T;	NARGS&larr; (NARGS) and (rhmask), branch[.ufns];.ufns:   DISPTABLE[3],	branch[.ufnPC3];	T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[.ufnpsh1];	T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[.ufnpsh2];.ufnpsh1:	LTEMP1&larr; RSH[LTEMP1, 10];			* Only an "alpha" byte.ufnpsh2:	TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;		* Push the opcode databytes.ufnPC3:	LTEMP0&larr; (LTEMP0) - (PCX'), call[FIXLEFT];	memBase&larr; StackBR, branch[.FNCALL2];*--------------------------------------------------------------------*  ufnPC:   GLOBAL,		*--------------------------------------------------------------------* CallUFN macro just turns into "SaveLink&larr; Link, Call[ufnPC]"ufnPC:   GLOBAL,	T&larr; A0, RBase&larr; RBase[LTEMP0];*	May come here from totally random places, so do a little cleanup:if[StackEmpty!];	T&larr; StackEmpty;* otherwise, T&larr; A0 handled it:endif;	StkP&larr; T, Branch[opUFN]; 						* Resets the hardware stack*--------------------------------------------------------------------DOCALLPUNT:		GLOBAL,			* Called from unbox, etc. *--------------------------------------------------------------------* Enter with DEFLO the atom index of fnname to call *				 NARGS has number of arguments to pass* Flush out Id, recompute up LEFT   T&larr; Id, call[FIXLEFT];   T&larr; Id, memBase&larr; StackBR, branch[.FNCALL1];*--------------------------------------------------------------------* RETURN*--------------------------------------------------------------------   KnowRBase[LTEMP0];   top level;   InsSet[LispInsSet, 1];opRETURN:   T&larr; (fetch&larr; TSP) - 1, FlipMemBase;   LTEMP0&larr; Md, fetch&larr; T, T&larr; (FXBACK[ALINK]);   LTEMP1&larr; Md, T&larr; (PVAR) - T;   fetch&larr; T, LTEMP3&larr; (rhmask);				* get alink field   LTEMP2&larr; Md;   branch[.nquick, R odd], LTEMP2, T&larr; (LTEMP2) - (FXBACK[IVAR]);   T&larr; (fetch&larr; T) + (FXDIF[DEFLO, IVAR]);   Q&larr; IVAR, IVAR&larr; Md, T&larr; (fetch&larr; T) + 1;		* new IVAR   DEFLO&larr; Md, T&larr; (fetch&larr; T) + (FXDIF[PC, DEFHI]);   T&larr; Md, PVAR&larr; (fetch&larr; T) + (FXDIF[PVAR, PC]);   T&larr; T and (LTEMP3), memBase&larr; ifuBR;			* new PVAR   BrLo&larr; DEFLO;:if[FNStats];   BrHi&larr; T, branch[.retstat, R&gt;=0], FnStatsPtr;:else;   BrHi&larr; T;:endif;   T&larr; ESP, PCF&larr; Md;.finishret:   LEFT&larr; T - Q, memBase&larr; StackBR;   T&larr; (store&larr; Q) + 1, dbuf&larr; LTEMP0;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;   LEFT&larr; (LEFT) rsh 1;   LEFT&larr; (LEFT) - (add[LeftOffset!, 1]c), NextOpCode;:if[FNStats];.retstat:   DEFHI&larr; T; PCF&larr; Md, call[.storeretstat];	* finish this operation   T&larr; ESP, branch[.finishret];:endif;IFUpause[20,1,StackM2BR,0,opReturn,noNData, 0, 0];*--------------------------------------------------------------------* NQUICK cases of return*--------------------------------------------------------------------	m[HardReturn, CallUFN];.nquick:	T&larr; (PVAR) - (FXBACK[ALINK]);	T&larr; (fetch&larr; T) + (FXDIF[CLINK, ALINK]);	LTEMP2&larr; Md, T&larr; (fetch&larr; T) + (FXDIF[BLINK, CLINK]);	pd&larr; (LTEMP2) - (Md) - 1, branch[.+2, R odd];		UCodeCheck[BadFrame];	branch[.+2, alu=0], LTEMP2&larr; (LTEMP2) - 1;		HardReturn;								* alink#clink* LTEMP2 is returnee	T&larr; (LTEMP2) - (FXBACK[FLAGS]);   	fetch&larr; T;									* flagword	T&larr; Md;:if[Debugging];	LTEMP3&larr; T and (StackMask);	pd&larr; (LTEMP3) xor (FxtnBlock);	branch[.+2, alu=0];		uCodeCheck[BadFrame];:endif;	pd&larr; T and (rhmask);	branch[.+2, alu=0], T&larr; (LTEMP2) - (FXBACK[NEXT]);		HardReturn;								* usecnt of returnee # 0	fetch&larr; T, T&larr; FreeStackBlock;	LTEMP3&larr; fetch&larr; Md;						* LTEMP3 points to returnee's next	pd&larr; T xor (Md);							* T &larr; flags	branch[.+2, alu#0], T&larr; IVAR;		branch[DORETURN];* check for contiguous BF   pd&larr; T xor (LTEMP3);						* is IVAR=returnee's next?   branch[.+2, alu=0], T&larr; (PVAR) - (FXBACK[BLINK]);		HardReturn;   fetch&larr; T;   T&larr; Md;   fetch&larr; T;   T&larr; Md;   pd&larr; T and (rhmask);   DblBranch[DORETURN, DOHARDRETURN, alu=0];DOHARDRETURN:	HardReturn;DORETURN:										* do return to LTEMP2	T&larr; (PVAR) - (FXBACK[BFLAGS]);	fetch&larr; T, T&larr; add[BfResidual!, rhmask!]c;	pd&larr; T and Md;	branch[.freefx, alu=0], T&larr; IVAR;:if[Debugging];.checkfreebf:	T&larr; (PVAR) - (FXBACK[ALINK]);	fetch&larr; T;	LTEMP3&larr; Md;	branch[.+2, R odd], LTEMP3;		UCodeCheck[ShouldBeSlowFrame];	T&larr; (PVAR) - (FXBACK[BLINK]);:else;.checkfreebf:	T&larr; (PVAR) - (FXBACK[BLINK]);:endif;	fetch&larr; T, T&larr; (rhmask);	LTEMP3&larr; fetch&larr; Md;					* get bf flags	LTEMP4&larr; Md, pd&larr; T and Md;	branch[.nqnz, alu#0], T&larr; (LTEMP3) + (2c);:if[Debugging];	T&larr; (LTEMP3) + 1;	T&larr; (fetch&larr; T) + 1;	pd&larr; (IVAR) - (Md);	branch[.+2, alu=0];		uCodeCheck[IVARWRONG];:endif;	T&larr; T - (IVAR);	IVAR&larr; (store&larr; IVAR) + 1, dbuf&larr; FreeStackBlock;	store&larr; IVAR, dbuf&larr; T, branch[.clresid];.nqnz:										* leave BF alone, decrement use count	T&larr; (LTEMP4) - 1;	store&larr; LTEMP3, dbuf&larr; T;.clresid:	T&larr; (PVAR) - (FXBACK[BFLAGS]);:if[Debugging];   fetch&larr; T;   LTEMP3&larr; Md;   pd&larr;(LTEMP3) and (BFResidual);   branch[.+2, alu#0];	uCodeCheck[StackBad];   nop;:endif;.freefx:				* make from T to ESP into a free block   ESP&larr; (ESP) - T;   T&larr; (store&larr; T) + 1, dbuf&larr; FreeStackBlock;   store&larr; T, dbuf&larr; ESP;   PVAR&larr; LTEMP2;*--------------------------------------------------------------------RTN2:	* return to frame at PVAR with LTEMP0,,LTEMP1*--------------------------------------------------------------------   memBase&larr; StackBR;:if[Debugging];   T&larr; (PVAR) - (FXBACK[FLAGS]);   fetch&larr; T;   T&larr; Md;   T&larr; T and (StackMask);   pd&larr; T xor (FxtnBlock);   branch[.+2, alu=0];	uCodeCheck[BadFrame];:endif;   T&larr; (PVAR) - (FXBACK[IVAR]);   T&larr; (fetch&larr; T) + (FXDIF[NEXT,IVAR]);   IVAR&larr; Md, fetch&larr; T;   ESP&larr; Md;   TSP&larr; Md, fetch&larr; Md;.extend:   ESP&larr; (fetch&larr; ESP) + 1;   T&larr; Md;   pd&larr; T xor (FreeStackBlock);   branch[.+2, alu#0], T&larr; ESP&larr; (fetch&larr; ESP) - 1;	ESP&larr; (ESP) + (Md), branch[.extend];   T&larr; (T - (TSP)) rsh 1;   branch[.+2, carry], LEFT&larr; T - (LeftOffset);	uCodeCheck[noStackAtPunt];   T&larr; (PVAR) - (FXBACK[FLAGS]);   fetch&larr; T;   LTEMP2&larr; Md;   pd&larr; (LTEMP2) and (FXInCall);   branch[.retcall, alu#0], pd&larr; (LTEMP2) and (FXNoPushReturn);   branch[.nopush, alu#0], Q&larr; TSP;   T&larr; (store&larr; Q) + 1, dbuf&larr; LTEMP0;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;   branch[.retfe2, R&gt;=0], Left&larr; (Left) - 1;	uCodeCheck[NoStackAtPunt];.nopush:   LTEMP2&larr; (LTEMP2) and not (FXNoPushReturn);   store&larr; T, dbuf&larr; LTEMP2;			* turn off no pushbit   .retfe2:   T&larr; (PVAR) - (FXBACK[IVAR]);   T&larr; (fetch&larr; T) + (FXDIF[DEFLO, IVAR]);   IVAR&larr; Md, T&larr; (fetch&larr; T) + 1;   DEFLO&larr; Md, T&larr; (fetch&larr; T) + (FXDIF[PC, DEFHI]);   DEFHI&larr; Md, fetch&larr; T, T&larr; (rhmask);   DEFHI&larr; (DEFHI) and T, memBase&larr; ifuBR;   BrHi&larr; DEFHI;   BrLo&larr; DEFLO;   PCF&larr; Md;:if[FNStats];   branch[.+2, R&lt;0], FnStatsPtr;   call[.storeretstat];   NextOpCode;:else;   nop;   NextOpCode;:endif;.retcall:   LTEMP2&larr; (LTEMP2) and not (FXInCall);   store&larr; T, dbuf&larr; LTEMP2;   T&larr; (TSP) - 1;   T&larr; (fetch&larr; T) - 1;   DEFLO&larr; Md, T&larr; (fetch&larr; T) - 1;   DEFHI&larr; Md, T&larr; (fetch&larr; T) - 1;   NARGS&larr; Md; fetch&larr; T;:if[Debugging];   pd&larr; DEFHI;   branch[.+2, alu=0], LTEMP0&larr; Md;	uCodeCheck[BadRetCall];   pd&larr; (LTEMP0) xor (SmallHi);   branch[.+2, alu=0];	uCodeCheck[BadRetCall];:endif;   TSP&larr; T, branch[.ATOMICFN];</pre>
  </body>
</html>
