<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>GC>LispDMC.DM!2>LispDiskDefs.mc</title>
  </head>
  <body>
    <pre>
*-----------------------------------------------------------Title[LispDiskDefs.mc...July 18, 1985  5:05 PM, MASINTER];* Disk controller definitions, shared by microcode for all disk formats.* Like DiskDefs but with registers moved around to see if this is the problem*-----------------------------------------------------------*-----------------------------------------------------------* R-register assignments*-----------------------------------------------------------SetRMRegion[DiskRegs];	Reserve[2];	* DefaultPartition, MaxPartition (see RegisterDefs)	RVN[TridentFlag];* enable and control Trident disk emulation	RVN[KTemp1];	RVN[K400];	* constant 400	RVN[KAddr];	* disk address (or parts thereof)	RVN[Sector];	* sector counter	RVN[MaxSectors];* maximum number of sectors expected	RVN[KPtr];	* command block pointer	RVN[KTemp3];	RVN[KCmmd];	* disk command (hardware)	RVN[DskMAddr];	* memory address for data	RVN[KStatus];	* disk software status	RVN[KSelect];	* [0..3] zero (tagDrive)			* [4] one iff sectors do not evenly divide the disk			* [5] unused			* [6..10] zero (tagSubSector, tagLoadSubSector)			* [11] one tagSelectDrive			* [12..15] currently addressed drive	RVN[KTemp0];	RVN[KTemp2];*-----------------------------------------------------------* Device assignments*-----------------------------------------------------------	Device[DiskControl, 10]; * control register (output)	Device[DiskMuff, 11];	* muffler and wakeup control (output);				* muffler data in bit 15 (input)	Device[DiskData, 12];	* disk read/write data (input/output);				* must be selected to enable WrFifoTW	Device[DiskRam, 13];	* format ram (output)	Device[DiskTag, 14];	* tag bus (output)*-----------------------------------------------------------* Muffler addresses, as viewed by controller.* Add 2000 to produce normal (system-wide) muffler addresses.*-----------------------------------------------------------MC[muffsState, 0];		* Group of 20 controller state mufflers*	MC[muffTempSense, muffsState, 0];	MC[muffIndexTW, muffsState, 1];	MC[muffSectorTW, muffsState, 2];	MC[muffSeekTagTW, muffsState, 3];	MC[muffRdFifoTW, muffsState, 4];	MC[muffWrFifoTW, muffsState, 5];*	MC[muffReadData, muffsState, 6];*	MC[muffWriteData, muffsState, 7];*	MC[muffEnableRun, muffsState, 10];*	MC[muffDebugMode, muffsState, 11];*	MC[muffRdOnlyBlock', muffsState, 12];*	MC[muffWriteBlock', muffsState, 13];*	MC[muffCheckBlock', muffsState, 14];*	MC[muffActive, muffsState, 15];	MC[muffSelect.0, muffsState, 16];	MC[muffSelect.1, muffsState, 17];MC[muffsStatus, 20];		* Group of 20 drive and error status mufflers*	MC[muffSeekInc, muffsStatus, 0];	MC[muffHeadOvfl, muffsStatus, 1];*	MC[muffDevCheck, muffsStatus, 2];*	MC[muffNotSelected, muffsStatus, 3];*	MC[muffNotOnLine, muffsStatus, 4];	MC[muffNotReady, muffsStatus, 5];*	MC[muffSectorOvfl, muffsStatus, 6];	MC[muffFifoUnderflow, muffsStatus, 7];	MC[muffFifoOverflow, muffsStatus, 10];*	MC[muffReadDataErr, muffsStatus, 11]; * = compare error usually*	MC[muffReadOnly, muffsStatus, 12];*	MC[muffCylOffset, muffsStatus, 13];*	MC[muffIOBParityErr, muffsStatus, 14];*	MC[muffFifoParityErr, muffsStatus, 15];	MC[muffWriteError, muffsStatus, 16];	MC[muffReadError, muffsStatus, 17];MC[muffsRam, 40];		* Format Ram address and dataMC[muffsTag, 60];		* Tag bus to driveMC[muffsFifo, 100];		* Fifo control mufflers*-----------------------------------------------------------* Control bits: output to DiskMuff register*-----------------------------------------------------------	MC[clearCompareErr, 20000];	* clear CompareErr flipflop	MC[setCheckSumErr, 10000];	* set ReadDataErr flipflop	MC[clearIndexTW, 4000];		* clear IndexTW	MC[clearSectorTW, 2000];	* clear SectorTW	MC[clearSeekTagTW, 1000];	* clear SeekTagTW	MC[clearErrors, 400];		* clear error flipflops*	MC[muffAddr, 377];		* muffler address	MC[clearAllTWs, clearIndexTW, clearSectorTW, clearSeekTagTW];	MC[clearAll, clearAllTWs, clearErrors];*-----------------------------------------------------------* Control bits: output to DiskControl register*-----------------------------------------------------------	MC[clearEnableRun, 2000];	* clear EnableRun	MC[debugMode, 1000];		* set DebugMode if 1, clear if 0	MC[blockTilIndex, 400];		* set BlockTilIndex if 1, clear if 0*	MC[commands, 377];		* disk commands: 4 2-bit bytes,*					* one per block, indicating:		MC[commandWrite, 1];		MC[commandCompare, 2];		MC[commandRead, 3];*-----------------------------------------------------------* Control bits: output to DiskTag register*-----------------------------------------------------------	MC[tagDrive, 100000];	MC[tagCylinder, 40000];	MC[tagHead, 20000];	MC[tagControl, 10000];	MC[tagBus, 7777];* TagBus interpretation for DriveTag:*	MC[tagSubSector, 1700];		* subsector count	MC[tagLoadSubSector, 40];	* load subsector for currently-addressed drive	MC[tagSelectDrive, 20];		* select the specified drive	MC[tagDriveNumber, 17];		* drive number* TagBus interpretation for CylinderTag:*	MC[tagCylinderNumber, 7777];* TagBus interpretation for HeadTag:*	MC[tagOffset, 200];		* offset head position*	MC[tagOffsetDirection, 100];	* direction of offset*	MC[tagHeadNumber, 77];* TagBus interpretation for ControlTag:	MC[tagAltoLeader, 4000];	* search for Alto Trident sync pattern*	MC[tagStrobeEarly, 1000];*	MC[tagStrobeLate, 400];	MC[tagWrite, 200];	MC[tagRead, 100];*	MC[tagResetHAR, 20];	MC[tagDiskReset, 10];		* reset errors latched in the drive	MC[tagHeadSelect, 4];		* turn on selected head for read/write	MC[tagReZero, 2];		* restore disk to cylinder 0*	MC[tagHeadAdvance, 1];		* increment head address register</pre>
  </body>
</html>
