<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>GC>LispDMC.DM!2>LMEM.mc</title>
  </head>
  <body>
    <pre>
:Title[LMEM];* Edit History* March 11, 1985  6:17 PM, Masinter, fix bug where BLT* 		of number &gt; 2&uarr;15 would always exit* February 2, 1985  2:55 PM, Masinter, attempt to fix bug where BLT* January 21, 1985  11:54 AM, Masinter, bum VAG2 a bit, clean up a *		PAGEFAULTOK or two* January 17, 1984  4:02 AM, JonL, added .pbsFetch for PUTBASEN and*		PUTBITS* January 17, 1984  2:10 AM, JonL, added .gbsFetch for use by GETBASEN,*		GETBASEPTRN, and GETBITS; also tailed them out thru REPSMT2* January 17, 1984  1:25 AM, JonL, abstracted .addrNfetch, changed*		DOGETBYTE to .getByte and let it use LTEMP1 instead of LTEMP0* January 17, 1984  12:51 AM, JonL, squeezed one inst out of opADDBASE* January 13, 1984  10:42 PM, JonL, spawned LMEM off LOW.mc* January 4, 1984  7:08 PM, JonL, tailed opPUTBASEPTR and opPUTBITS*		into TL.POP1.  * December 15, 1983  3:45 PM, JonL,  HILOC to tail into REPTMD1*--------------------------------------------------------------------* Low-Level Memory referencing*--------------------------------------------------------------------   TOP LEVEL;   knowrbase[LTEMP0];   InsSet[LispInsSet, 1];*--------------------------------------------------------------------opHILOC:*--------------------------------------------------------------------   fetch&larr; TSP, T&larr; (SmallHi), branch[REPTMD1];regOP1[322, StackM2BR, opHILOC, noNData];*--------------------------------------------------------------------opLOLOC:*--------------------------------------------------------------------   store&larr; TSP, dbuf&larr; SmallHi, NextOpCode;regOP1[323, StackM2BR, opLOLOC, noNData];*--------------------------------------------------------------------opADDBASE:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.addrNfetch];	branch[.adbs1, alu#0], LTEMP1&larr; (LTEMP1) + (Md);	* + Lo.word of addr	branch[.+2, carry], LEFT&larr; (LEFT) + 1;		TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode; * Done - fast case   T&larr; (store&larr; T) - 1, dbuf&larr; LTEMP1;			* Carry over into next   TSP&larr; (fetch&larr; T) + (2c);				*  next segment   LTEMP0&larr; (1s) + (Md);   store&larr; T, dbuf&larr; LTEMP0, NextOpCode;SUBROUTINE;.addrNfetch:* Enter and exit with StackBR* Leaves 0 on pd iff TOS is a smallposp	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (2c);	* LTEMP0&larr; Hi.word of n	LTEMP1&larr; Md, (fetch&larr; T);			* LTEMP1&larr; Lo.word of n	pd&larr; (LTEMP0) xor (SmallHi), Return;	* Is n a smallP?TOPLEVEL;.adbs1:	CallUFN;%	*  This could continue something like . . .	LEFT&larr; (LEFT) - 1, memBase&larr; StackM2BR;	T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX1];	T&larr; (TSP) + 1, flipMemBase;						* Change back to StackM2BR	T&larr; (fetch&larr; T) - 1;								* TSP was "pulled back" 	(fetch&larr; T), LTEMP1&larr; Md;							* LTEMP1&larr; lo.word of addr	T&larr; (LTEMP1) + Q, LTEMP1&larr; T;					* Lo.word sum	LTEMP0&larr; (LTEMP0) + (Md), XorSavedCarry;	* Hi.word sum	T&larr; (store&larr; LTEMP1) + 1, dbuf&larr; T;				* Store Lo.word	(store&larr; T), dbuf&larr; LTEMP0, NextOpCode;		* Store Hi.word%regOP1[320, StackM2BR, opADDBASE, noNData];*--------------------------------------------------------------------opVAG2:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX2];	T&larr; (store&larr; TSP) + 1, dbuf&larr; Q;	TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;regOP1[321, StackM2BR, opVAG2, noNData];*--------------------------------------------------------------------opBLT: * (destinationaddr sourceaddr #wds)*--------------------------------------------------------------------* Defined to move one word at a time, from the high end to the*   low end, and be continuable after interrupts.* These highly-bummed ideas are taken from Taft's implementation of *  Mesa BLT and BLTL, found in DMesaRW.mc* Enter with: *		Q set to 20b*        T set to number of words to move minus one*        stack has running count (minus 1)* Branch back around the loop:  *		stack updated to next value*        T set up 17 for the next full munch* Before starting the transfer, touch the last word of the source and*  destination blocks, to force any page faults that would happen, to*  happen now rather than in the inner loop.  Maybe need not touch the *  first words, since a fault there will abort the loop before it has *  done anything permanent.  Also, "pre-warm" the cache for the next *  time around.	T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.addrNfetch];	Branch[.+2, alu=0], T&larr; T - 1;			CallUFN;					* Punt: #wds not smallposp	LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;		* Why 2 for StkP? 'Cause	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;		*  BitBlt does it that way	LTEMP3&larr; Md, (fetch&larr; T), T&larr; (2c);	* Fetch on hi.word of Dest	T&larr;  pd&larr; LTEMP1, StkP&larr; T;		* LTEMP1 had #wds to move	branch[.bltxit, alu=0],			* zero words to transfer?	 T&larr; Md, stack&larr; T - 1, memBase&larr; BBDSTBR;	* Stack&larr; #wds-1	branch[.+2, alu&gt;=0], BRHi&larr; T;		CallUFN;		* call UFN if &gt; 2&uarr;15 words	T&larr; (20c); 	Q&larr; T, T&larr; T - 1;				* Q&larr; (20c), T&larr; (17c)	BRLo&larr; LTEMP3;	T&larr; (stack) and T, memBase&larr; BBSRCBR;	* T&larr; #wds-1 mod 20b	BRHi&larr; LTEMP0;	BRLo&larr; LTEMP2;	PSTATE&larr; (add[PS.PFOK!, PS.INBLT!]c); .bltloop:	Cnt&larr; T;	LTEMP0&larr; T&larr; (FETCH&larr; stack) - T;		* Fetch on first src wd	LTEMP2&larr; (FETCH&larr; T) - (Q);			* Fetch on last src wd	PreFetch&larr; LTEMP2, flipMemBase;	FETCH&larr; stack;					* Fetch on first dest wd	FETCH&larr; LTEMP0;					* Fetch on last dest wd	PreFetch&larr; LTEMP2, T&larr; MD, flipMemBase;	* Synchronize PageFaults***   Here's the tight inner loop to move a munch.bltmm:	fetch&larr; stack, flipMemBase;	stack&larr; (STORE&larr; stack) - 1, dbuf&larr; Md, flipMembase, 		Branch[.bltmm, Cnt#0&amp;-1];	***		pd&larr; stack, Branch[.+2, Reschedule'];	* Tails into BitBlt code if 		Branch[BBXitToContinue];										*  need to xit for interrupt	T&larr; (17c), Branch[.bltloop, alu&gt;=0];	* Should be 17 or -1, not 0.bltdone:	PSTATE&larr; A0;.bltxit:	LEFT&larr; (LEFT) + (2c);								* LEFT is re-computed if	TSP&larr; (TSP) - (4c), NextOpCode;		*  there is a fault-out%	T&larr; (fetch&larr; TSP) + 1;	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (2c);	pd&larr; (LTEMP0) xor (SmallHi);	branch[.+2, alu=0], LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;		CallUFN;	LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1;	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;	LTEMP3&larr; Md, fetch&larr; T, pd &larr; T&larr; (LTEMP2);	branch[.+2, alu#0], LTEMP2&larr; Md, memBase&larr; BBDSTBR, T&larr; T - 1;		branch[.bltdone];	* no words to copy	Cnt&larr; T;  			* number of words to transfer - 1	BRHi&larr; LTEMP2;	BRLo&larr; LTEMP3;	memBase&larr; BBSRCBR;	BRHi&larr; LTEMP0;	BRLo&larr; LTEMP1;* and now for the loop. This should really keep state in Stack a la BITBLT:	PAGEFAULTOK;	FETCH&larr; T, flipMemBase;	T&larr; (store&larr; T) - 1, dbuf&larr; MD, flipMembase, branch[.-1, Cnt#0&amp;-1];	PAGEFAULTNOTOK;.bltdone:	Left&larr; (Left) + (2c);	TSP&larr; (TSP) - (4c), NextOpCode;%regOP1[304, StackM2BR, opBLT, noNData];*--------------------------------------------------------------------opGETBASEN:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1, Call[.gbsFetch];PAGEFAULTOK;	IFETCH&larr; LTEMP0;	T&larr; MD, memBase&larr; StackM2BR, Branch[REPSMALLT];regOP2[310, StackM2BR, opGETBASEN, noNData];SUBROUTINE;.gbsFetch:	T&larr; Md, fetch&larr; T, LTEMP1&larr; (rhmask);	LTEMP0&larr; Md, memBase&larr; ScratchLZBR;	BrHi&larr; T, Return;TOPLEVEL;*--------------------------------------------------------------------opGETBITS: *--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1, Call[.gbsFetch];PAGEFAULTOK;	IFETCH&larr; LTEMP0, TisID;	memBase&larr; StackM2BR;	LTEMP0&larr; MD, RF&larr; Id;	T&larr; ShiftLMask[LTEMP0], memBase&larr; StackM2BR, Branch[REPSMALLT];regOP3[312, StackM2BR, opGETBITS, noNData];*--------------------------------------------------------------------opGETBASEPTRN: *--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1, Call[.gbsFetch];PAGEFAULTOK;	LTEMP0&larr; (IFETCH&larr; LTEMP0) + 1;	T&larr; MD, ifetch&larr; LTEMP0;PAGEFAULTNOTOK;	T&larr; T and (LTEMP1), memBase&larr; StackM2BR;	T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, Branch[REPSMT2];regOP2[311, StackM2BR, opGETBASEPTRN, noNData];*--------------------------------------------------------------------opGETBASEBYTE:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.addrNfetch];	* See opADDBASE	branch[.+2, alu=0], T&larr; T - 1;		CallUFN;								* Index not smallPosp	fetch&larr; T, LTEMP0&larr; Md;   memBase&larr; LScratchBR, LEFT&larr; (LEFT) + 1;   LTEMP0&larr; Md, BrLo&larr; LTEMP0;   BrHi&larr; LTEMP0, call[.getByte];   T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;regOP1[302, StackM2BR, opGETBASEBYTE, noNData];SUBROUTINE;.getByte:* called by BIN, GETBASEBYTE;* Assumes current memBase is pointer, LTEMP1 is byte offset* Returns byte in LTEMP1* Must not clobber T	dblbranch[.dgbeven, .dgbodd, R even], LTEMP1&larr; (LTEMP1) rsh 1;.dgbeven:  PAGEFAULTOK;	FETCH&larr; LTEMP1;	LTEMP1&larr; MD, memBase&larr; StackBR;  PAGEFAULTNOTOK;	LTEMP1&larr; RSH[LTEMP1, 10], return;.dgbodd:  PAGEFAULTOK;	FETCH&larr; LTEMP1;	LTEMP1&larr; MD, memBase&larr; StackBR;  PAGEFAULTNOTOK;	LTEMP1&larr; (LTEMP1) and (rhmask), return;TOP LEVEL;*--------------------------------------------------------------------opPUTBASEN:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1, Call[.pbsFetch];			* fetch val hi	STORE&larr; T, dbuf&larr; LTEMP0;:if[Debugging];   T&larr; MD, TSP &larr; (TSP) - (2c);	PAGEFAULTNOTOK, NextOpCode;:else;   T&larr; MD, TSP &larr; (TSP) - (2c), NextOpCode;			* wait for faults:endif;SUBROUTINE;.pbsFetch:	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);				* LTEMP0&larr; Hi.newByte	pd&larr; (LTEMP0) xor (SmallHi);						* check for smallPosp	branch[.+2, alu=0], LTEMP0&larr; Md, Q&larr; Md,			* LTEMP0&larr; newByte						T&larr; (fetch&larr; T) + 1;		TOPLEVEL; CallUFN; SUBROUTINE;								LTEMP2&larr; Md, fetch&larr; T;								* LTEMP2&larr; Hi.addr	LEFT&larr; (LEFT) + 1, memBase&larr; ScratchLZBR;	T&larr; (Id) + (Md);										* T&larr; Lo.addr + alpha	branch[.+2, carry'], BrHi&larr; LTEMP2;		LTEMP2&larr; (LTEMP2) + 1, branch[.-1];:if[Debugging];	PAGEFAULTOK, Return;:else;	Return;:endif;TOPLEVEL;regOP2[315, StackM2BR, opPUTBASEN, noNData];*--------------------------------------------------------------------opPUTBITS:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1, Call[.pbsFetch];			* fetch val hi	FETCH&larr; T;	WF&larr; Id, LTEMP1&larr; T;	T&larr; ShMdBothMasks[LTEMP0];PAGEFAULTNOTOK;	store&larr; LTEMP1, dbuf&larr; T, Branch[TL.POP1];regOP3[317, StackM2BR, opPUTBITS, noNData];*--------------------------------------------------------------------opPUTBASEPTRN:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1;									* fetch val hi	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);				* fetch val lo	Q&larr; Md, T&larr; (fetch&larr; T) + 1;							* fetch addrhi	LTEMP2&larr; Md, fetch&larr; T;								* LTEMP0, Q have newval	memBase&larr; ScratchLZBR, LEFT&larr; (LEFT) + 1;	T&larr; (Id) + (Md);	branch[.+2, carry'], BrHi&larr; LTEMP2;		LTEMP2&larr; (LTEMP2) + 1, branch[.-1];:if[Debugging];PAGEFAULTOK;	T&larr; (STORE&larr; T) + 1, dbuf&larr; LTEMP0;	STORE&larr; T, dbuf&larr; Q;PAGEFAULTNOTOK, Branch[TL.POP1];:else;	T&larr; (STORE&larr; T) + 1, dbuf&larr; LTEMP0;	STORE&larr; T, dbuf&larr; Q, Branch[TL.POP1];:endif;regOP2[316, StackM2BR, opPUTBASEPTRN, noNData];*--------------------------------------------------------------------opPUTBASEBYTE:	* PUTBASEBYTE(base, displacement, value)*--------------------------------------------------------------------   T&larr; (TSP) - 1;   T&larr; (fetch&larr; T) - 1;   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;	* LTEMP0 has new byte   pd&larr; (LTEMP0) and not (rhmask);   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1, branch[.+2, alu=0];   	CallUFN;   pd&larr; (LTEMP1) xor (SmallHi);   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1, branch[.+2, alu=0];* LTEMP1&larr;offset	CallUFN;   LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;	pd&larr; (LTEMP2) xor (SmallHi);   LTEMP2&larr; Md, fetch&larr; T, branch[.+2, alu=0];	CallUFN;   LEFT&larr; (LEFT) + 1, memBase&larr; LScratchBR;   LTEMP2&larr; Md, BrLo&larr; LTEMP2;   BrHi&larr; LTEMP2;	PAGEFAULTOK;   branch[.putRight, R odd], LTEMP1&larr; (LTEMP1) rsh 1;   FETCH&larr; LTEMP1;   T&larr; Md, TSP&larr; T;	* CAN FAULT   T&larr; T and (rhmask);   Q&larr; LTEMP0;   LTEMP0&larr; LSH[LTEMP0, 10];   T&larr; T + (LTEMP0), branch[.restoreByte];.putRight:   FETCH&larr; LTEMP1;   T&larr; Md, TSP&larr; T;	* CAN FAULT   T&larr; T and (lhmask);   T&larr; T + (LTEMP0), Q&larr; LTEMP0, branch[.restoreByte];.restoreByte:   store&larr; LTEMP1, dbuf&larr; T;	PAGEFAULTNOTOK;   LEFT&larr; (LEFT) + 1, memBase&larr; StackBR;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; Q, NextOpCode;regOP1[307, StackBR, opPUTBASEBYTE, noNData];</pre>
  </body>
</html>
