{File name:  LispFPTBase.mcLast edited by cal    21-Oct-83 11:57:59 Last edited by Sturgis  15-Sep-83 16:40:30  Descrition: Floating point code for Lisp {modified from Cedar fpt code}Created by H. Sturgis }{***********************************************************************************************De normalization codeenter with  T, ~Q holding the 32 bit quantity,   L0 prepared for return, TT holding shift count	(note that Q is negated)contents of TT is destroyedDe normalized result is in T, QQ[15] is a sticky bit***********************************************************************************************}DeNormC1:						c1;DeNormC2:						c2;DeNormC3:	TT _ -TT - 1,	c3;DeNormA:	TT _ TT + 1, NZeroBr,	c1;	Ybus _ Q and 1, ZeroBr, BRANCH[DeNormA1, $],			c2;	T _ DRShift1 T, SE _ 0, BRANCH[DeNormA, DeNormB],		c3;DeNormA1: {stcky bit is 0}	Q _ ~Q, L0Disp, CANCELBR[$],		c3;	RET[DeNormRets],	c1;{sticky bit will be 1}DeNormB:	TT _ TT + 1, NZeroBr,	c1;	BRANCH[DeNormB1, $],	c2;	T _ DRShift1 T, SE _ 0, GOTO[DeNormB],	c3;DeNormB1: {stcky bit is 1}	Q _ ~Q, L0Disp,	c3;	Q _ Q or 1, RET[DeNormRets],	c1;	{****************************************************************************multiply codeThis procedure calls unpack2 to break the arguments up into components	Sign1 Exp1  HighHalf1  LowHalf1	Sign2 Exp2  HighHalf2  LowHalf2	where the high halves have 16 bits and the lowhalves have 8 bitsWe compute four products to be added together to form a 48 bit product									LowHalf1*LowHalf2					|	        B	|        A	|							HighHalf1*LowHalf2			|  	E	|         C	|				    			LowHalf1*HighHalf2			|	F	|         D	|						HighHalf1*HighHalf2	|	H	|	G	|								48 bit product	|	Z	|	Y	|            X	|          W	|	}	{the arguments are now unpacked, and a ZeroBr is pending if either are 0}	{first we add the exponents and xor the signs}	{note: in the case of 1*1, the result fraction will have first sign bit at x1, thus the result exponent must be 128 so that subsequent  normalization will reduce exponet to 127, the correct value for 1.  This is obtained by adding exponents and subtracting 126.}	T _ uExp1,	c2, at[L2.FptMul, 10, FptPrepRet];	TT _ uExp2,						c3;	T _ T + TT,						c1;	T _ T - 126'd, 					c2;	uExp1 _ T,						c3;	TT _ uSign1,						c1;	Q _ uSign2,						c2;	uSign1 _ TT xor Q,					c3;{now compute uLowHalf1*uLowHalf2}	T _ uLowHalf1,					c1;	T _ T LRot8,						c2;	uLowHalf1 _ Q _ T,					c3;	TOS _ uLowHalf2,					c1;	TOS _ TOS LRot8,						c2;	uLowHalf2 _ Rx _ TOS,					c3;	T _ 0, L0 _ L0.mult2,					c1;	TT _ 7, CALL[FptMultLoopC3],				c2;	TT _ 0FF or Q,					c1, at[L0.mult2, 10, FptMultLoopRets];	TT _ ~TT,						c2;	uStickyBit _ TT, {A(=W)}				c3;{at this point, uStickyBit is non zero iff A(=W) is non zero, and T contains B}{now compute T+uHighHalf1*uLowHalf2, which is <E+carry,B+C+carry>}		TT _ T,						c1;	T _ uLowHalf2, {already rotated}				c2;	Q _ T,						c3;	T _ uHighHalf1, L0 _ L0.mult3,				c1;	Rx _ T,						c2;	T _ TT,						c3;	TT _ 7, CALL[FptMultLoopC2],				c1;	uLowHalf2 _ T, {E+carry}				c1, at[L0.mult3, 10, FptMultLoopRets];	Rx _ ~Q,						c2;	Rx _ Rx LRot8,					c3;	TT _ Rx and 377'b, {B+C+Carry}				c1;{now compute TT+uLowHalf1*uHighHalf2, which is <F+carry, B+C+D+carry>}	T _ uLowHalf1, {already rotated}				c2;	Q _ T,						c3;	T _ uHighHalf2, L0 _ L0.mult4,				c1;	Rx _ T,						c2;	T _ TT,						c3;	TT _ 7, CALL[FptMultLoopC2],				c1;	uLowHalf1 _ T, {F+carry}					c1, at[L0.mult4, 10, FptMultLoopRets];	Rx _ ~Q,						c2;	Rx _ Rx LRot8,					c3;	Q _ Rx and 377'b, {B+C+D+Carry(=X)}			c1;	Q _ Q or uStickyBit, {T#0 iff X#0 or W#0}			c2;	uStickyBit _ Q,					c3;{now compute uLowHalf1(=F+carry)+uLowHalf2(=E+carry)+uHighHalf1*uHighHalf2 = <H+carry, E+F+G+carry> = <Z,Y>}	Q _ uHighHalf1,					c1;	Rx _ uHighHalf2,					c2;	T _ uLowHalf1, {F+carry}					c3;	TT _ uLowHalf2, {E+carry}				c1;	T _ T + TT, CarryBr, L0 _ L0.mult5,				c2;	TT _ 15'd, BRANCH[mull0, mull1],				c3;mull1:	uLowHalf1 _ ~TOS xor TOS, {uLowHalf1_-1, save the carry}				CALL[FptMultLoopC2],		c1;mull0:	uLowHalf1 _ 0, {save the carry}CALL[FptMultLoopC2],		c1;	TT _ uLowHalf1,					c1, at[L0.mult5, 10, FptMultLoopRets];	T _ T-TT, {include the carry}				c2;	uHighHalf1 _ T,	{Z}				c3;	uLowHalf1 _ ~Q, {Y} GOTO[RePackC2],			c1;{****************************************************************************fpt multiply loopat entry:	TT holds bit count-1 (n-1) of multiplier (n must be at least 2)		i.e. for an 8 bit multiplier, enter with 7 in TT	Q holds multiplier, right adjusted	T holds initial product	Rx holds multiplicand	can be called from any cycle, uses an integral number of clicksat end:	high 16 bits of product is in T	low n bits of product is complimented in top n bits of Q	(bottom 16-n bits of Q holds top 16-n bits of original multiplier)	returns via L0time: n clicks****************************************************************************}FptMultLoopC2:						c2;FptMultLoopC3:						c3;FptMultLoopC1:	[] _ Q and 1, NZeroBr,				c1;		TT _ TT-1, ZeroBr,		BRANCH[FptMultLoop0, FptMultLoop1],		c2;FptMultLoop0:	T _ DARShift1(T+0),			BRANCH[FptMultLoopC1, FptMultLoopEnd],	c3;FptMultLoop1:	T _ DARShift1(T+Rx),			BRANCH[FptMultLoopC1, FptMultLoopEnd],	 c3;FptMultLoopEnd:	[] _ Q and 1, NZeroBr,				c1;		L0Disp, BRANCH[FptMultLoopEnd0, FptMultLoopEnd1],	c2;FptMultLoopEnd0:	T _ DARShift1(T+0), RET[FptMultLoopRets],		c3;FptMultLoopEnd1:	T _ DARShift1(T+Rx), RET[FptMultLoopRets],		c3;{issues remaining:	divide by zero trap (now forces infinity)	one might be able to unrole the division loop	at the moment, the remainder is corrected after first sixteen subtractions, need not do so if one were more careful	adjust starting cycle of division loop?	move L0 disp earlier in loop exit sequence?							}{****************************************************************************division codeThis procedure calls unpack2 to break the arguments up into components	Sign1 Exp1  HighHalf1  LowHalf1	Sign2 Exp2  HighHalf2  LowHalf2	where the high halves have 16 bits and the lowhalves have 8 bits****************************************************************************}	{the arguments are now unpacked}	T _ uExp1, 						c2, at[L2.FptDiv, 10, FptPrepRet];	TT _ uExp2,						c3;	T _ T - TT,						c1;	T _ T + 127'd,  {re bias exponent}				c2;	uExp1 _ T,						c3;	TT _ uSign1,						c1;	Q _ uSign2,						c2;	uSign1 _ TT xor Q,					c3;	uDivCount _ divCount, {save a non temporary R reg}			c1;	uDivResult _ divResult, {save a non temporary R reg}			c2;{now load the operands, right shifted by 1 bit to allow room to shift left during the divide loop, also test for zero divisor}	divisorHigh _ uHighHalf2, ZeroBr,				c3;	Q _ uLowHalf2, ZeroBr, BRANCH[FptDivB, FptDivA],			c1;FptDivA:	Q _ ~Q, BRANCH[$, FptDivZero],				c2;	divisorHigh _ DRShift1 divisorHigh, SE _ 0,			GOTO[FptDivC],			c3;FptDivB:	Q _ ~Q, CANCELBR[$],					c2;	divisorHigh _ DRShift1 divisorHigh, SE _ 0,			GOTO[FptDivC],			c3;FptDivC:	divisorLow _ ~Q,					c1;	T _ uHighHalf1,					c2;	Q _ ~ uLowHalf1,					c3;	T _ DRShift1 T, SE _ 0,					c1;	Q _ ~Q, L0 _ L0.div2,					c2;{as per Ed Tafts Dorado code, we will do a total of 26 iterations, 24 for quotient bits, + 2 guard bits.  They are done by first doing 16 iterations, then 10 iterations}	divCount _ 16'd, CALL[FptDivLoopC1],				c3;	uHighHalf1 _ divResult,					c2, at[L0.div2, 10, FptDivLoopRets];	T _ DLShift1 T, SE _ 1, {puts a 0 into Q.15} L0 _ L0.div3, {remainder did not get its last left shift}							c3;	divCount _ 10'd, CALL[FptDivLoopC2],				c1;	divResult _ divResult  LRot4,				c2, at[L0.div3, 10, FptDivLoopRets];	[] _ T or Q, NZeroBr,					c3;	divResult _ LShift1 (divResult), SE _ 0,	BRANCH[FptDivD, FptDivE],	c1;	{now we install the correct sticky bit}FptDivD:	divResult _ LShift1 (divResult), SE _ 0,	GOTO[FptDivF],		c2;FptDivE:	divResult _ LShift1 (divResult), SE _ 1,	GOTO[FptDivF],		c2;FptDivF:	uLowHalf1 _ divResult , GOTO[FptDivExit],			c3;{divide by zero}FptDivZero:	divCount _ uDivCount, {restore a non temporary R reg}		c3;	divResult _ uDivResult, {restore a non temporary R reg}		c1;	GOTO[FPTrapsC3],					c2;	FptDivExit:	divCount _ uDivCount, {restore a non temporary R reg}		c1;	divResult _ uDivResult, {restore a non temporary R reg}		c2;	uStickyBit _ 0, GOTO[RePackC1],				c3;{***********************************************************************************************divide loop	dividend in <T,Q>	divisor in <divisorHigh, divisorLow>	bit count in divCount, performs bitCOunt subtractions	return point in L0	will accumulate bits in divResult	<T,Q> will hold the remainder***********************************************************************************************}FptDivLoopC1:						c1;FptDivLoopC2:						c2;FptDivLoopC3:	divResult _ 0, GOTO[FptDivSubA],				c3;{in this part of the loop the contents of <T,Q> are positive}FptDivSub:	{delay}						c2;	divResult _ LShift1 (divResult), SE _ 1,				c3;FptDivSubA:	Q _ Q-divisorLow, CarryBr,				c1;	divCount _ divCount-1, ZeroBr, 		BRANCH[FptDivSub1, FptDivSub0],			c2;FptDivSub0:	T _ T-divisorHigh, CarryBr, BRANCH[$, FptDivSubExit1],		c3;	T _ DLShift1 T, SE _ 1, {puts a 0 into Q.15}		BRANCH[FptDivAdd, FptDivSub],			c1;FptDivSub1:	T _ T-divisorHigh-1, CarryBr,  BRANCH[$ , FptDivSubExit2],		c3;	T _ DLShift1 T, SE _ 1, {puts a 0 into Q.15}		BRANCH[FptDivAdd, FptDivSub],			c1;FptDivSubExit1: BRANCH[FptDivAddExit, FptDivSubExit],			c1;FptDivSubExit2: BRANCH[FptDivAddExit, FptDivSubExit],			c1;FptDivSubExit: divResult _ LShift1 (divResult), SE _ 1, GOTO[FptDivLoopExit],		c2;{in this part of the loop the contents of <T,Q> are negative (in  2's complement)}FptDivAdd:	{delay}						c2;	divResult _ LShift1 (divResult), SE _ 0,				c3;		Q _ Q+divisorLow, CarryBr,				c1;	divCount _ divCount-1, ZeroBr, 		BRANCH[FptDivAdd0, FptDivAdd1],			c2;FptDivAdd0:	T _ T+divisorHigh, CarryBr, BRANCH[$,  FptDivAddExit1],		c3;	T _ DLShift1 T, SE _ 1, {puts a 0 into Q.15}		BRANCH[FptDivAdd, FptDivSub],			c1;FptDivAdd1:	T _ T+divisorHigh+1, CarryBr, BRANCH[$, FptDivAddExit2],		c3;	T _ DLShift1 T, SE _ 1, {puts a 0 into Q.15}		BRANCH[FptDivAdd, FptDivSub],			c1;FptDivAddExit1: BRANCH[FptDivAddExit, FptDivSubExit],			c1;FptDivAddExit2: BRANCH[FptDivAddExit, FptDivSubExit],			c1;{we have subtracted one too many times, so add back in to get correct remainder}FptDivAddExit: divResult _ LShift1 (divResult), SE _ 0, 			c2;	Q _ Q + divisorLow, CarryBr,				c3;	{delay} BRANCH[FptDivAX0, FptDivAX1],			c1;		FptDivAX1: T _ T + divisorHigh + 1, GOTO[FptDivLoopExit],			c2;		FptDivAX0: T _ T + divisorHigh, GOTO[FptDivLoopExit],			c2;		FptDivLoopExit:  L0Disp,						c3;	RET[FptDivLoopRets],					c1;	 {issues remaining:	efficiency:   The choice of which where arguments are at unNormed is bad, by some juggling of arg1 and arg2 should be able to reduce some of the costs of the three de-norm cases.							}{****************************************************************************sub code****************************************************************************}	{the arguments are now unpacked}	T _ uSign2,						c2, at[L2.FptSub, 10, FptPrepRet];	T _ T xor 1, {change sign}				c3;	uSign2 _ T,GOTO[add1],					c1;{****************************************************************************add code****************************************************************************}	{the arguments are now unpacked, subtract enters here}add1:	T _ uExp1,						c2, at[L2.FptAdd, 10, FptPrepRet];	TT _ uExp2,						c3;	TT _ T - TT, NegBr,					c1;	 Ybus _ TT, ZeroBr, BRANCH[unNorm2, unNorm1], 			c2;{Exp2 > Exp1, so we have to shift fractional part of arg1 to the right, TT has negative of  shift count}unNorm1:	Q _ uLowHalf1, CANCELBR[$],				c3;	Rx _ uSign2,						c1;	T _ uSign1,						c2;	uSign2 _ T,						c3;	uSign1 _ Rx,						c1;	Rx _ uExp2,						c2;	uExp1 _ Rx,						c3;	T _ uHighHalf1,					c1;	TT _ -TT, GOTO[unNorm],					c2;{Exp1 >= Exp2, so we may have to shift fract part of arg2, TT has shift count}unNorm2:	Q _ uHighHalf1, BRANCH[$, unNormNeither],			c3;	T _ uHighHalf2,					c1;	uHighHalf2 _ Q,					c2;	Rx _ uLowHalf1,					c3;	Q _ uLowHalf2,					c1;	uLowHalf2 _ Rx, GOTO[unNorm],				c2;unNormNeither:	T _ uSign1,						c1;	Q _ uSign2,						c2;	uSign1 _ Q,						c3;	uSign2 _ T,						c1;	T _ uHighHalf1,					c2;	Q _ uLowHalf1,  GOTO[unNormedC1],				c3;{The fractional part of the argument with smaller exponent is in T,Q; the amount of shift is in TT, uSign1 contains sign of argument with larger exponent (the nominal sign), uExp1 contains nominal exponent, uSign2 contains other sign}{The fractional part of the argument with the higher exponent is in <uHighHalf2, uLowhalf2>}unNorm:	Rx _ 20'b,	c3;	TT _ TT - Rx,  NegBr,	c1;	Ybus _ TT - Rx , NegBr, BRANCH[$, unNormLt20],	c2;	Ybus _ T or Q, NZeroBr, BRANCH[$, unNormLt40],	c3;{total shift >= 40'b bits}	T _ 0, BRANCH[unNormZ, unNormNZ],				c1;unNormZ:	Q _ 0, GOTO[unNormedC3],	c2;unNormNZ:	Q _ 1, GOTO[unNormedC3],	c2;{40'b > total indicated shift >= 20'b, TT holds "indicated shift - 20'b"}unNormLt40:	Ybus  _ Q, NZeroBr, CANCELBR[$],				c1;	BRANCH[unNormLt40A, unNormLt40B],			c2;unNormLt40A:	Q _ T , GOTO[unNormLt40C],				c3;unNormLt40B:	Q _ T or 1, GOTO[unNormLt40C],				c3;unNormLt40C:	T _ 0, L0 _ L0.add1,					c1;	Q _ ~Q, CALL[DeNormC3],				c2;{20'b > total indicated shift , TT holds "indicated shift -20'b", Rx contains 20'b}unNormLt20:	TT _ TT+Rx, CANCELBR[$],	c3;	L0 _ L0.add1,	c1;	Q _ ~Q, CALL[DeNormC3],	c2;	{T,Q holds the shifted version of the argument  with the small exponent, <uHighHalf2, uLowHalf2> contains the other argument.  uSign1 contains sign of argument  in <uHighHalf2, uLowHalf2>  (the nominal sign), uExp1 contains nominal exponent, uSign2 contains other sign)}unNormedC3: {delay}	c3;unNormedC1: {delay}	c1;unNormed:	Rx _ uSign1,	c2, at[L0.add1, 10, DeNormRets];	TT _ uSign2,	c3;	[] _ Rx xor TT, NZeroBr,	c1;	TT _ uLowHalf2, BRANCH[addUnNormed, subUnNormed],	c2;{equal signs, so add}addUnNormed:	Q _ TT + Q, CarryBr,	c3;	TT _ uHighHalf2, BRANCH[addUnNormedA, addUnNormedB],	c1;addUnNormedA:	T _ TT+T, CarryBr, GOTO[addUnNormedC],	c2;addUnNormedB:	T _ TT+T+1, CarryBr, GOTO[addUnNormedC],	c2;addUnNormedC:	Ybus _ Q and 1, NZeroBr,  BRANCH[$, addUnNormedD],		c3;	uLowHalf1 _ Q, ZeroBr, CANCELBR[unNormedB], 		c1;{addition overflowed, so have to shift right and adjust exponents}addUnNormedD:	Q _ ~Q, BRANCH[addUnNormedE, addUnNormedF],	c1;addUnNormedE: {Q _ Q or 0} GOTO[addUnNormedG],	c2;addUnNormedF: Q _ Q and ~2, {Q _ Q or 22} GOTO[addUnNormedG],	c2;addUnNormedG:	T _ DRShift1 T, SE _ 1, 	c3;	Q _ ~Q,	c1;	Rx _ uExp1,	c2;	Rx _ Rx+1, 	c3;	uExp1 _ Rx,	c1;	{delay}	c2;	{delay} GOTO[unNormedA],	c3;{non equal signs, so subtract shifted fraction}{carryBr seems to take on a subtraction if there is no borrow}subUnNormed:	Q _ TT - Q, CarryBr,				c3;	TT _ uHighHalf2, BRANCH[subUnNormedB, subUnNormedA],	c1;subUnNormedA:	T _ TT - T, CarryBr, GOTO[subUnNormedC],		c2;subUnNormedB:	T _ TT - T - 1, CarryBr, GOTO[subUnNormedC],		c2;subUnNormedC:	{delay} BRANCH[subUnNormedD, $],			c3;	uLowHalf1 _ Q, ZeroBr, GOTO[unNormedB],			c1;{last subtraction produced overflow, so use opposite sign (from uSign2), and subtract tentative result from 0 to produce a sign magnitude result}subUnNormedD:	Q _ 0 - Q, CarryBr,				c1;	TT _ uSign2, BRANCH[subUnNormedD1, subUnNormedD0],	c2;subUnNormedD1: T _ 0 - T - 1, GOTO[subUnNormedE],		c3;subUnNormedD0: T _ 0 - T, GOTO[subUnNormedE],			c3;subUnNormedE:	uSign1 _ TT,					c1;	{delay}					c2;	{delay}					c3;	unNormedA:	uLowHalf1 _ Q, GOTO[$],			c1;unNormedB:	uHighHalf1 _ T, NZeroBr, BRANCH[$, unNormedC],					c2;	uStickyBit _ 0, CANCELBR[RePackC1],			c3;	unNormedC:	uStickyBit _ 0, BRANCH[$, RePackC1],		c3;		uSign1 _ 0, {force positive on zero}, GOTO[RePackC2],	c1;{issues remaining:	most negative long integer	most negative integer							}{****************************************************************************compare code****************************************************************************}	{the arguments are now unpacked}	Rx _ uSign2, 					c2, at[L2.FptCmp, 10, FptPrepRet];	TT _ uSign1,					c3;	[] _ Rx xor TT, NZeroBr,			c1;	TT _ uExp1, BRANCH[$, cmpNeSigns],		c2;	T _ uExp2,					c3;		T _ T-TT, CarryBr,				c1;	[] _ T, NZeroBr, BRANCH[CmpAbs1High3, $],	c2;	TT _ uHighHalf1, BRANCH[$, CmpAbs2High1],	c3;		T _ uHighHalf2,					c1;	T _ T - TT, CarryBr,				c2;	[] _ T, NZeroBr, BRANCH[CmpAbs1High1, $],	c3;		TT _ uLowHalf1, BRANCH[$, CmpAbs2High2],	c1;	T _ uLowHalf2,					c2;	T _ T - TT, CarryBr,				c3;		[] _ T, NZeroBr, BRANCH[CmpAbs1High2, $],	c1;	TOS _ 0, BRANCH[cmpExit3, CmpAbs2High3],	c2;	{signs are unequal, Rx contains uSign2}cmpNeSigns:	T _ uExp2,					c3;	T _ T or TT,					c1;	TT _ uHighHalf2,				c2;	T _ T or TT,					c3;	TT _ uHighHalf1,				c1;	T _ T or TT,					c2;	TT _ uLowHalf2,				c3;	T _ T or TT,					c1;	TT _ uLowHalf1,				c2;	T _ T or TT, ZeroBr,				c3;	BRANCH[$, CmpZeros],				c1;	GOTO[CmpAbs2High3],				c2;{un equal signs, but arguments are both zero}CmpZeros: TOS _ 0, GOTO[cmpExit3],				c2;CmpAbs1High1:	{delay} CANCELBR[$], 			c1;		GOTO[CmpAbs1High3],			c2;	      CmpAbs1High2:	{delay} CANCELBR[$],			c2;		[] _ Rx, NZeroBr, GOTO[CmpNEa],		c3;	CmpAbs1High3:	[] _ Rx, NZeroBr, CANCELBR[CmpNEb],	c3;CmpAbs2High1: {delay}		 			c1;CmpAbs2High2: {delay}					c2;{next inst also covers unequal sign case, Rx holding usign2}CmpAbs2High3: [] _ Rx, ZeroBr, GOTO[CmpNEa],		c3;CmpNEa:	BRANCH[Cmp1High, Cmp2High],			c1;CmpNEb:	BRANCH[Cmp1High, Cmp2High],			c1;Cmp1High:	TOS _ KTval, GOTO[cmpExit3],		c2;Cmp2High:	TOS _ 0, GOTO[cmpExit3],		c2;		{ E N D }