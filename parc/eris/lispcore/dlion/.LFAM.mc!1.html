<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>dlion>LFAM.mc!1</title>
  </head>
  <body>
    <pre>
{File name LFAM.mcDescription:  DandeLion InterLisp Emulator LispFloatArrayAuthor: CharnleyLast modified: Charnley              28-Jun-84 11:37:59Created:   8-Jun-84 10:04:55}{	(MAGIC S2 S1 D Kount)   op = 373'b  alpha = 4	S1  --  pointer to first source complex number	S2  --  pointert to last source complex number	D   --  pointer to first dest complex number	within the loop	S1  =  S1init + 4*(Kount - 1)  {alpha, gamma}	S2  =  S2init - 4*(Kount - 1)    {beta, delta}	D   =   Dinit + 8*(Kount - 1)  {D.0, D.1, D.2, D.3}		D(n.0)  &larr;  S1(n.0) + S2(-n.0)  {alpha + beta}		D(n.1)  &larr;  S1(n.1) - S2(-n.1)    {delta - gamma}		D(n.2)  &larr;  S1(n.1) + S2(-n.1)  {delta + gamma}		D(n.3)  &larr;  S1(n.0) - S2(-n.0)    {alpha - beta}	S1, S2, and D are quadword alligned}{	INNER LOOP FLOAT SEQUENCE 	 B &larr; alpha	 A &larr; beta [add] [unload]	XXXXX  D.2 &larr; RESULT (delta+gamma)	 A &larr; beta [sub] [unload]	XXXXX  D.1 &larr; RESULT (delta-gamma)	 B &larr; delta [unload]	--------------------------------        LOOP START	D.0 &larr; RESULT (alpha+beta)	 A &larr; gamma [add] [unload]	D.3 &larr; RESULT (alpha-beta)	 A &larr; gamma [sub]	 B &larr; alpha	 A &larr; beta [add] [unload]	D.2 &larr; RESULT (delta+gamma)	 A &larr; beta [sub] [unload]	D.1 &larr; RESULT (delta-gamma)	 B &larr; delta [unload]	--------------------------------       LOOP END	D.0 &larr; RESULT (alpha+beta)	 A &larr; gamma [add] [unload]	D.3 &larr; RESULT (alpha-beta)	--------------------------------	 A &larr; gamma [sub]	XXXXX  B &larr; alpha	XXXXX  A &larr; beta [add] [unload]	D.2 &larr; RESULT (delta+gamma)	XXXXX  A &larr; beta [sub] [unload]	D.1 &larr; RESULT (delta-gamma)}RegDef[uFLAmB, U, 35];	GOTO[FLOATARRAYPREP],	c3, at[L2.magic, 10, FOP2Disp];{MAGIC}lfam.s:{	loop pipe start up }	at[L2.magic, 10, LFAop],{FOP2 = MAGIC}	Zimph &larr; LShift1 Kount - 1, SE &larr; 0,	c1;	L0 &larr; L0.S1mag0, FloatMode.RN.AI.FAST, FloatPIPE,	c2;	Zimph &larr; LShift1 Zimph,  SE &larr; 0,CALL[LFAremapS1],	c3;{	MAR &larr; S1 &larr; [S1 + 4*Kount-1],	c1; }	stackP &larr; 6{FLBMinusA},	c2, at[L0.S1mag0, 10, LFAremapS1ret];	FloatAB &larr; MD{alpha},	c3;	MAR &larr; [rhS1, S1 + 1],	c1;	CANCELBR[$, 2],	c2;	FloatAB &larr; MD{alpha},	c3;	Zimph &larr; LShift1 Kount - 1, SE &larr; 0,	c1;	L0 &larr; L0.S2mag0,	c2;	Zimph &larr; LShift1 Zimph, CALL[LFAremapNS2],	c3;{	MAR &larr; S2 &larr; [S2 - 4*Kount-1],	}	,	c2, at[L0.S2mag0, 10, LFAremapS2ret];	Stemp &larr; FloatA &larr; MD{beta}, FLPlus,	c3;	MAR &larr; [rhS2, S2 + 1],	c1;	USrcVALo &larr; Stemp, CANCELBR[$, 2],	c2;	Stemp &larr; FloatA &larr; MD{beta},	c3;	FloatPump, uStemp &larr; Stemp,	c1;	FloatPump,	c2;	FloatA &larr; USrcVALo{beta}, {FLBMinusA,}	c3;	FloatA &larr; uStemp{beta},	c1;	FloatPump,	c2;	FloatPump,	c3;	MAR &larr; S2 &larr; [rhS2, S2 + 2],	c1;	CANCELBR[$, 2],	c2;	FloatAB &larr; MD{delta}, FloatUnloadS, Float.M,	c3;	MAR &larr; [rhS1, S2 + 1], L0 &larr; L0.lfam.di,	c1;	, CANCELBR[$, 2],	c2;	FloatAB &larr; MD{delta}, FloatUnloadS, Float.L,	c3;	Zimph &larr; LShift1 Kount - 1, SE &larr; 0,	c1;	Zimph &larr; LShift1 Zimph, SE &larr; 0,	c2;	Zimph &larr; LShift1 Zimph, SE &larr; 0,CALL[LFAremapD]	c3;{	MAR &larr; D &larr; [D + 8*Kount-1],	c1; }	Q &larr; MDR &larr; FloatResult{alpha+beta}, GOTO[lfam.entry], FloatPump,	c2, at[L0.lfam.di, 10, LFAremapDret];{	-	-	-	-	-	-	-}lfam.loop:	MAR &larr; D &larr; [rhD, D - 10'd],	c1;{D.0}	Q &larr; MDR &larr; FloatResult{alpha+beta}, BRANCH[$, fixDA, 1], FloatPump,	c2;fixDAret:lfam.entry:	pop,	c3;{S: 6 to 5}	MAR &larr; [rhD, D + 1], L0 &larr; L0.lfam.s2a,	c1;	Q &larr; MDR &larr; FloatResult, CANCELBR[$, 2], LOOPHOLE[wok], FloatPump,	c2;	pop,	c3;{S: 5 to 4}	MAR &larr; S1 &larr; [rhS1, S1 + 2],	c1;	CANCELBR[$, 2],	c2;	Stemp &larr; FloatA &larr; MD{gamma}, FLPlus, FloatUnloadS, Float.M, push,	c3;{S: 4 to 5}	MAR &larr; [rhS1, S1 + 1], push,	c1;{S: 5 to 6}	USrcVALo{6} &larr; Stemp, CANCELBR[$, 2],	c2;	Stemp &larr; FloatA &larr; MD{gamma}, FloatUnloadS, Float.L,	c3;	MAR &larr; D &larr; [rhD, D + 6],	c1;{D.3}	Q &larr; MDR &larr; FloatResult{alpha-beta}, LOOPHOLE[wok], BRANCH[$, fixDB, 1], FloatPump,	c2;fixDBret:	, uSaveTT &larr; Stemp,	c3;	,	c1;	,	c2;	Kount &larr; Kount - 1, ZeroBr,	c3;	MAR &larr; [rhD, D + 1], BRANCH[$, lfam.exit]	c1;	Q &larr; MDR &larr; FloatResult, CANCELBR[$, 2], LOOPHOLE[wok], FloatPump,	c2;	FloatA &larr; USrcVALo{gamma}, {FLBMinusA,}	c3;	MAR &larr; S1 &larr; [rhS1, S1 - 6], pop,	c1;{S: 6 to 5}	FloatA &larr; uSaveTT{gamma}, BRANCH[$, fixS1A, 1],	c2;fixS1Aret:	Stemp{Db} &larr; FloatAB &larr; MD{alpha},	c3;	MAR &larr; [rhS1, S1 + 1], pop,	c1;{S: 5 to 4}	, CANCELBR[$, 2],	c2;	Stemp{Db} &larr; FloatAB &larr; MD{alpha},	c3;	MAR &larr; S2 &larr; [rhS2, S2 + 2],	c1;	BRANCH[$, fixS2A, 1],	c2, at[L0.lfam.s2a, 10, LFAremapS2ret];fixS2Aret:	Stemp &larr; FloatA &larr; MD{beta}, FLPlus, FloatUnloadS, Float.M, push,	c3;{S: 4 to 5}	MAR &larr; [rhS2, S2 + 1], push,	c1;{S: 5 to 6}	STK{6} &larr; Stemp, CANCELBR[$, 2],	c2;	Stemp &larr; FloatA &larr; MD{beta}, FloatUnloadS, Float.L,	c3;	MAR &larr; D &larr; [rhD, D - 2],	c1;{D.2}	Q &larr; MDR &larr; FloatResult{delta+gamma}, LOOPHOLE[wok], CANCELBR[$, 2], FloatPump,	c2;	,	c3;	MAR &larr; [rhD, D + 1],	c1;	Q &larr; MDR &larr; FloatResult, CANCELBR[$, 2], LOOPHOLE[wok], FloatPump,	c2;	uSaveTT &larr; Stemp,	c3;	FloatA &larr; STK{beta}, {FLAMinusB,} FloatUnloadS, Float.M,	c1;	FloatA &larr; Stemp LRot0{beta}, FloatUnloadS, Float.L,	c2;	,	c3;	MAR &larr; D &larr; [rhD, D - 2],	c1;{D.1}	Q &larr; MDR &larr; FloatResult{delta-gamma}, LOOPHOLE[wok], BRANCH[$, fixDD, 1], FloatPump,	c2;fixDDret:	,	c3;	MAR &larr; [rhD, D + 1],	c1;	Q{Db} &larr; MDR &larr; FloatResult, CANCELBR[$, 2], LOOPHOLE[wok], FloatPump,	c2;	,	c3;	MAR &larr; S2 &larr; [rhS2, S2 + 2],	c1;	CANCELBR[$, 2],	c2;	Q{Db} &larr; FloatAB &larr; MD{delta}, FloatUnloadS, Float.M,	c3;	MAR &larr; [rhS2, S2 + 1],	c1;	, CANCELBR[$, 2],	c2;	Q{Db} &larr; FloatAB &larr; MD{delta}, GOTO[lfam.loop], FloatUnloadS, Float.L,	c3;{	-	-	-	-	-	-	-}lfam.exit:	MDR &larr; FloatResult, CANCELBR[$, 2], LOOPHOLE[wok], FloatPump,	c2;	FloatA &larr; USrcVALo{gamma}, {FLAMinusB,}	c3;	FloatA &larr; uSaveTT{gamma},	c1;	FloatPump,	c2;	FloatPump,	c3;	,	c1;	FloatPump, FloatUnloadS, Float.M,	c2;	FloatPump, FloatUnloadS, Float.L,	c3;	MAR &larr; D &larr; [rhD, D - 2],	c1;	Q &larr; MDR &larr; FloatResult{delta+gamma}, LOOPHOLE[wok], CANCELBR[$, 2], FloatPump,	c2;fixDEret:	,	c3;	MAR &larr; [rhD, D + 1],	c1;	Q &larr; MDR &larr; FloatResult, CANCELBR[$, 2], LOOPHOLE[wok], FloatPump,	c2;	,	c3;	FloatPump, FloatUnloadS, Float.M,	c1;	FloatPump, FloatUnloadS, Float.L,	c2;	,	c3;	MAR &larr; D &larr; [rhD, D - 2],	c1;	Q &larr; MDR &larr; FloatResult{delta-gamma}, LOOPHOLE[wok], BRANCH[$, fixDF, 1], FloatPump,	c2;fixDFret:	,	c3;	MAR &larr; [rhD, D + 1],	c1;	MDR &larr; FloatResult, CANCELBR[$, 2], LOOPHOLE[wok], FloatPump,	c2;	Q &larr; 6, L1 &larr; L1.LFAexit,	c3;	GOTO[LFACommonExit],	c1;{	exceptions }fixDA:	{8*K + 0}	Zimph &larr; LShift1 Kount - 1, SE &larr; 0,	c3;	Zimph &larr; LShift1 Zimph, SE &larr; 0,	c1;	UQSave &larr; Q, L0 &larr; L0.lfam.da,	c2;	Zimph &larr; LShift1 Zimph, SE &larr; 0, CALL[LFAremapD],	c3;	MDR &larr; UQSave, GOTO[fixDAret],	c2, at[L0.lfam.da, 10, LFAremapDret];fixDB:	{8*K + 6}	Zimph &larr; LShift1 Kount, SE &larr; 0,	c3;	Zimph &larr; LShift1 Zimph, SE &larr; 0,	c1;	UQSave &larr; Q, L0 &larr; L0.lfam.db,	c2;	Zimph &larr; LShift1 Zimph - 1, SE &larr; 0, CALL[LFAremapD],	c3;	MDR &larr; UQSave, GOTO[fixDBret],	c2, at[L0.lfam.db, 10, LFAremapDret];fixDD:	{8*K + 2} {Kount has been decremented!}	Zimph &larr; LShift1 Kount, SE &larr; 0,	c3;	Zimph &larr; LShift1 Zimph, SE &larr; 1,	c1;	UQSave &larr; Q, L0 &larr; L0.lfam.dd,	c2;	Zimph &larr; LShift1 Zimph, SE &larr; 0, CALL[LFAremapD],	c3;	MDR &larr; UQSave, GOTO[fixDDret],	c2, at[L0.lfam.dd, 10, LFAremapDret];fixDF:	{8*K + 2} {Kount has been decremented!}	Zimph &larr; LShift1 Kount, SE &larr; 0,	c3;	Zimph &larr; LShift1 Zimph, SE &larr; 1,	c1;	UQSave &larr; Q, L0 &larr; L0.lfam.df,	c2;	Zimph &larr; LShift1 Zimph, SE &larr; 0, CALL[LFAremapD],	c3;	MDR &larr; UQSave, GOTO[fixDFret],	c2, at[L0.lfam.df, 10, LFAremapDret];fixS1A:	{4*K + 0} {Kount has been decremented!}	Zimph &larr; LShift1 Kount, SE &larr; 0,	c3;	Zimph &larr; LShift1 Zimph, SE &larr; 0,	c1;	L0 &larr; L0.lfam.s1a,	c2;	CALL[LFAremapS1],	c3;	GOTO[fixS1Aret],	c2, at[L0.lfam.s1a, 10, LFAremapS1ret];fixS2A:	{4*K + 0}	Zimph &larr; LShift1 Kount - 1, SE &larr; 0,	c3;	Zimph &larr; LShift1 Zimph, SE &larr; 0,	c1;	L0 &larr; L0.lfam.s2a,	c2;	CALL[LFAremapNS2],	c3;LFAremapNS2:	Zorch &larr; uS2Lo,	c1;	Zorch &larr; Zorch - Zimph, CarryBr,	c2;	rhZorch &larr; uS2Hi, BRANCH[LFANS2car, LFANS2nocar],	c3;LFANS2car:	Q &larr; rhZorch,	c1;	Q &larr; Q - 1,	c2;	rhZorch &larr; Q LRot0,	c3;LFANS2nocar:	{map S2}	Map &larr; [rhZorch, Zorch], GOTO[lfa.S2map],	c1;	{ E N D }</pre>
  </body>
</html>
