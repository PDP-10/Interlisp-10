{File name : DTIGERPPORTTEST.mcAuthor : Gwan SantosaCreated : 29-Nov-84 15:32:14===============================================================================DTIGER PARALLEL PORT DIAGNOSTIC===============================================================================OTNCNT	data sent to PPort and counter	REFREG	expected valueTEMREG	temporary register, used as scratch pad	INDATA	data read from PPortFLTCNT	fault counterOTNCNT	is used as a counter and as a data that we send to PPort.	Before we send it to PPort, we swap H and L byte, and	when we want to increment the count, we swap them once more	before we increment it.	A0 A1 A2....... represent the bits of OTNCNT after we swap H and L byte.	TEST ALGORITHM :	For each pattern, there are 4 possible expected values, depending on	A6 and A7, we calculate the expected value first,	put zero on all unwanted/don't care bits, and store it in REFREG,	at the same time, for each case, we calculate the mask bits to mask off	unwanted bits of the result (don't care bits).	Then we send the pattern to PPort, and sample the output	using a feedback circuit and store it in INDATA,	mask off unwanted bits, and compare the result with	the one stored in REFREG.	If any errors occur, the FLTCNT will be incremented,	at DONE, if FLTCNT=0, then there is no error, else	there is an error			}	START:	OTNCNT _ zero,				c1;	{Start with 0000}	FLTCNT _ zero,				c2;	{initialize fault count}LOOP1:	REFREG _ OTNCNT,			c3;	{Load reference register with counter}		OTNCNT _ OTNCNT LRot8,			c1;	{Swap H and L byte of counter}	Xbus _ REFREG LRot0, XDisp, 		c2; 	{Check bit 14 and 15}	DISP4[EXPB, 0C],			c3;	{4 ways branches, depends on bit 6 and 7}{test the case where A6 A7 = 00}{			  -- --   	   }	{Expected value is : 0111 A8 A9 XX XXXXXXXX}{Mask register contains 7C00}	EXB0:	REFREG _ OTNCNT,			c1, at[0C,10,EXPB];	REFREG _ REFREG LRot12,			c2;	{reposition OTNCNT bit 8 and 9}	REFREG _ ~REFREG,			c3;	{invert them}		REFREG _ REFREG and n0C,		c1; 	{mask off unwanted bits}	REFREG _ REFREG or n70,			c2;	{ored with 01110000}	REFREG _ REFREG LRot8,			c3;	{Swap H and L byte}		MSKREG _  n7C, 				c1;	{Set up mask register}     	MSKREG _ MSKREG LRot8,			c2;	{to mask result with 7C00}	GOTO[MERGE],				c3;	{continue}{test the case where A6 A7 = 01}{			  -- --    -----------------------}{Expected value is : 0111 A0 A1 XX A0 A1 A2 A3 A4 A5 A6 A7}{Mask register contains 7CFF}EXB1:	REFREG _ OTNCNT,			c1, at[0D,10,EXPB];	REFREG _ ~REFREG LRot4,			c2;	{Reposition bit 0 and 1}	REFREG _ REFREG and n0C,		c3;	{Kill unwanted bits}		REFREG _ REFREG or n70,			c1;	{Put 0111 pattern}	REFREG _ REFREG LRot8,			c2;	{Swap H and L byte}		TEMREG _ ~OTNCNT LRot8,			c3;	{Swap H and L byte, invert them}		TEMREG _ TEMREG and nFF,		c1;	{Mask off the new H byte}	REFREG _ REFREG or TEMREG,		c2;	{concatenate TEMREG and REFREG}	MSKREG _ n7C,				c3;	{Set up mask register}		MSKREG _ MSKREG LRot8,			c1;	{Swap H and L byte}	MSKREG _ MSKREG or nFF,			c2;	{Mask register contains 7CFF}	GOTO[MERGE],				c3;	{Continue}{test the case where A6 A7 = 10}{			 -----------------------	    }{The expected value is : A10 A11 A12 A13 A14 A15 XX XXXXXXXX}{Mask register contains FC00}			EXB2:	REFREG _ OTNCNT,			c1, at[0E,10,EXPB];	REFREG _ ~REFREG,			c2;	{invert}	REFREG _ REFREG and n3F,		c3;	{Mask out A8 A9}					REFREG _ REFREG LRot8,			c1;	{Swap H and L byte}		REFREG _ LRot1 REFREG,			c2;	{Rote 2 positions to the left}	REFREG _ LRot1 REFREG,			c3;		MSKREG _ nFC,				c1;	{Set up mask register}	MSKREG _ MSKREG LRot8,			c2;	{Swap H and L byte}							{Mask register contains FC00}	GOTO[MERGE],				c3;	{Continue}	{test the case where A6 A7 = 11}{The expected value is : A2 A3 A4 A5 A6 A7 XX A0 A1 A2 A3 A4 A5 A6 A7}{Mask register contains FCFF}	EXB3:	TEMREG _ OTNCNT,			c1, at[0F,10,EXPB];		TEMREG _ TEMREG LRot8,			c2;	{Swap H and L byte}	TEMREG _ TEMREG and nFF,		c3;	{Kill A8 ..... A15}	 	REFREG _ TEMREG and n3F,		c1;	{Copy result into REFREG,Kill A0 A1 in REFREG }	REFREG _ LRot1 REFREG,			c2;	{Rotate left twice}	REFREG _ LRot1 REFREG,			c3;		Noop,					c1;		REFREG _ REFREG LRot8,			c2;	{Swap H and L byte}	REFREG _ TEMREG or REFREG,		c3;	{concatenate TEMREG and REFEREG}		MSKREG _ nFC,				c1;	{Set up mask register}	MSKREG _ MSKREG LRot8,			c2;	{Swap H and L byte}	MSKREG _ MSKREG or nFF,			c3;	{Mask register contains FCFF}			MERGE:	PPort _ OTNCNT,				c1;	{Send test patern to PPort}	Noop,					c2;	{1 cycle delay is needed}	INDATA _ PPort,				c3;	{Read it back}		INDATA _ INDATA and MSKREG,		c1;	{Mask out don't care bits}		INDATA _ INDATA - REFREG,	ZeroBr,	c2;	{Compare the result}		BRANCH[FALSE,TRUE],			c3;	{with the expected value}FALSE:	OTNCNT _ OTNCNT LRot8,			c1;	{If not equal, swap bytes to get the count}	OTNCNT _ OTNCNT + one,	ZeroBr,				c2;	{Increment pattern count}			FLTCNT _ FLTCNT + one,	ZeroBr,	BRANCH[LOOP2,LOOP3],	c3;	{Increment fault count}	LOOP2:	BRANCH[LOOP4,LOOP5],			c1;	{If no overflow on pattern}							{count, check overflow on}							{fault count}				LOOP4:	GOTO[LOOP1],				c2;	{If no overflow on fault count}							{Keep testing}	LOOP5:	FLTCNT _ FLTCNT - 1,	GOTO[LOOP1],	c2;	{If overflow on fault count,}											{decrement fault count}							{Keep testing}	LOOP3:	BRANCH[LOOP6,LOOP7],			c1;	{If overflow on pattern count}							{Check fault count}							LOOP6:	GOTO[DONE],				c2;	{No overflow on fault count, done}							{Done}	LOOP7:	FLTCNT _ FLTCNT - 1,	GOTO[DONE],	c2;	{Else, decrement fault count}					TRUE:	OTNCNT _ OTNCNT LRot8,			c1;	{If no fault, check if finish testing}	OTNCNT _ OTNCNT + one,	ZeroBr,		c2;		BRANCH[LOOPA,DONE1],			c3;	{If not finish, continue}	LOOPA:	Noop,					c1;	GOTO[LOOP1],				c2;DONE1:	Noop,					c1;	Noop,					c2;	DONE:	GOTO[START],				c3;	{Else, go to start}														 						