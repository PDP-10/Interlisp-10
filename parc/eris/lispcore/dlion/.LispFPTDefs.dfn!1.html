<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>dlion>LispFPTDefs.dfn!1</title>
  </head>
  <body>
    <pre>
{File name:  LispFPTDefs.dfnLast edited by cal    14-Nov-83 14:28:09 Last edited by Sturgis  15-Sep-83 16:40:30  Descrition: Floating point code for Lisp {modified from Cedar fpt code}Created by H. Sturgis }RegDef[divisorHigh,		R,	2];   {TT}RegDef[divCount,		R,	3];   {PV}   {must be saved and restored}RegDef[divResult,		R,	4];   {S}  {must be saved and restored}RegDef[divisorLow,		R,	6];   {Rx}RegDef[uHighHalf1	,U,	07]; {FPT temp}RegDef[uExp1	,U,	08]; {FPT temp}RegDef[uLowHalf1	,U,	09]; {FPT temp}	RegDef[uExp2	,U,	0A]; {FPT temp}RegDef[uHighHalf2	,U,	0B]; {FPT temp}RegDef[uLowHalf2	,U,	0C]; {FPT temp}RegDef[uSign1 	,U, 	26]; {FPT temp}RegDef[uSign2	,U,	27]; {FPT temp}RegDef[uDivCount,	U,	30];   {FPT temp}RegDef[uStickyBit	,U,	31]; {FPT temp}RegDef[uDivResult,	U,	42];   {FPT temp}RegDef[uib	,U,	6E]; {FPT temp}RegDef[ufloatplus	,U,	04]; {FPT temp}RegDef[ufloatdiff	,U,	05]; {FPT temp}RegDef[ufloattimes	,U,	030]; {FPT temp}RegDef[ufloatidiff	,U,	06]; {FPT temp}RegDef[ufloat	,U,	042]; {FPT temp}RegDef[uArg2Hi	,U,	057]; {FPT temp}RegDef[uArg2Lo	,U,	058]; {FPT temp}RegDef[uStickyReg	,U,	24];          {** rA = TT} {part of processor state, [0] is non zero if fpt micro code should trap on inexact result, and [15] is non zero if there has been a non trapped inexact result} {must match corresponding in StartMesa}RegDef[uFLmode, U, 65],{low 4 bits are the Floating Point Mode -- 16 bit is  set to one if an inexact result occurs -- sign bit is set to one if inexact trap is desired}RegDef[uPPsave, U, 4C],{contains the last output to the PPort exclusive of setting it to read}{return points for unpack routines}Set[L0.mult2, 1];Set[L0.mult3, 2];Set[L0.mult4, 3];Set[L0.mult5, 4];Set[L0.add1, 5];Set[L0.sub1, 6];{return points for denorm routine, DeNormRets}Set[L0.rePack1, 2];{Set[L0.add1, 5]; def'd above}{used to distinguish CreateCell opcodes from subr calls}{Set[L3.FptArg1, 04];}{return points for rounding routine, RoundRets}Set[L0.rePack2, 1]; {must be 1 mod 2}{divide loop return points}Set[L0.div2, 1];Set[L0.div3, 2];{returns from FptPrep and used for FLop}Set[L2.Fplus, 10'b];{must be same as L2.plus}Set[L2.Fdiff, 11'b];{must be same as L2.diff}Set[L2.Ftimes, 13'b];Set[L2.Fquot, 14'b];Set[L2.Fgreat, 12'b];{must be same as L2.greaterp}Set[L2.Fidiff, 15'b];Set[L2.Fmax, 16'b];Set[L2.Fmin, 17'b];{	returns relative to FloatItRet}Set[L3.FunSecond, 04];Set[L3.FunUSecond, 05];Set[L3.FunFirst, 06];Set[L3.FunUFirst, 07];Set[L3.btou, 08];{	returns relative to fptQ2ret and fptQdone}Set[L3.UB2Q2, 03];{must be different from L3.FunUSecond and L3.FunUFirst}{	used to distinguish FPT callers at FLExit }Set[L0.Boxed, 01];Set[L0.UnBoxed, 02];{	ib values for LispUnboxed2 }Set[ib.UF2.add, 0],Set[ib.UF2.sub, 1],Set[ib.UF2.isub, 2],Set[ib.UF2.mult, 3],Set[ib.UF2.div, 4],Set[ib.UF2.great, 5],Set[ib.UF2.max, 6],Set[ib.UF2.min, 7],{	ib values for LispUnboxed1 }Set[ib.UF1.utob, 0],Set[ib.UF1.btou, 1],Set[ib.UF1.abs, 2],Set[ib.UF1.neg, 3];	{ E N D }</pre>
  </body>
</html>
