<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>dlion>MoreLisp.mc!1</title>
  </head>
  <body>
    <pre>
{File name NewMoreLisp.mcDescription: DandeLion Interlisp EmulatorAuthor: PurcellCreated: June 8, 1981charnley:     24-Apr-84  9:27:36  added CAR/CDR NIL charnley:     13-Mar-84 15:00:13  moved logout to bank 0 charnley:     1-Mar-84  9:54:06  removed mem tests{ZZZ} charnley:    27-Feb-84 16:40:35  added version Lichtenberg: 1-Jan-84 11:58:35 Changed LOGOUT Subr to work with		Domino 10.0charnley:    21-Dec-83 11:14:56 charnley:    10-Nov-83 12:24:09 added another pgcross charnley:    10-Nov-83 11:06:20 added pgcross to fvar look up old 9099Charnley:    2-Nov-83 14:26:38 modified carcdrufn to be ufnXCharnley:   20-Oct-83 10:36:08Charnley:  25-Jun-83 11:54:56 {fixed FVAR&larr; looping}Purcell: April 12, 1983  6:06 PM ; logout uLispBootMsg=55 to mesaPurcell: April 12, 1983  1:15 PM ; BBlt reentrant by state on stackRCLK writes: March 14, 1983  7:31 PMLast edited: February 24, 1983  5:04 PMfixes BLT exit S ok, Last edited: February 24, 1983  5:04 PMfixes to faultable FVAR, Last edited: February 23, 1983  12:58 PMfaultable BitBlt, Last edited: January 7, 1983  6:14 PMnew SUBR #s, Last edited: December 28, 1982  6:39 PMHard Reset, Last edited: December 15, 1982  11:17 PMMPWait, Last edited: December 9, 1982  12:54 AMsubrs, Last edited: August 1, 1982  4:44 PM}{	contains:	004	@NTYPX	003	@LISTP	005	@TYPEP	006	@DTEST	001	@CAR	002	@CDR	076	@RAID	175	@SUBR	167	@RCLK	143	@FVARg	312	@GBITS	317	@PUTBITS	021	@BIND	023	@DUNBIND	022	@UNBIND	}SetTask[0];{*******************************************************************	CAR 2%, CDR 2%, LISTP 1%, TYPEP 1%, DTEST, NTYPX		%  ? clicks*******************************************************************}{type table unpacked  at 18000, same segment as map}@NTYPX:	opcode[4'b],	MAR &larr; Q &larr; [TOS, TOSH + 0], CALL[typ],	c1;{typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry}ntypex1:	MAR &larr; [rhRx, Rx + 0], L2 &larr; L2.0,	c1, at[4,10, NewTypRet];	TOSH &larr; smallpl, IBDisp, L2 &larr; L2.0,	c2;	TOS &larr; MD and Q,  L2 &larr; L2.0, DISPNI[OpTable],	c3;{*******************************************************************}@LISTP:	opcode[3'b],	TT &larr; 0 - 03'b, CALL[NewTyp],	c1;{		NIL will replace the top-of-stack if tos is not a valid LISP pointer (i.e. if it is larger than a 22 bit number).	ELSE: typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry. }	MAR &larr; [rhRx, Rx], Rx &larr; ListType + 0,	c1, at[3,10, NewTypRet];	PC &larr; PC + 0, GOTO[typep3],	c2;@TYPEP:	opcode[5'b],	TT &larr; 0 - 05'b, CALL[NewTyp],	c1;{		NIL will replace the top-of-stack if tos is not a valid LISP pointer (i.e. if it is larger than a 22 bit number).	ELSE: typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry. }typep1:	MAR &larr; [rhRx, Rx], Rx &larr; ib + 0	c1, at[5,10, NewTypRet];	PC &larr; PC + PC16,	c2;typep3:	Q &larr; MD xor Rx,	c3;	Q &larr; Q - 1, PgCarryBr, L2 &larr; L2.0,	c1;	uTOSH &larr; TOSH, TOSH &larr; 0{nil}, IBDisp, BRANCH[$, noL],	c2;	TOSH &larr; uTOSH, L2 &larr; L2.0, DISPNI[OpTable],	c3;noL:	TOS &larr; 0{nil}, L2 &larr; L2.0, DISPNI[OpTable],	c3;listpretnil:	PC &larr; PC + PC16, L2Disp,	c2;	DISP4[listpdisp],	c3;	makeTosNilC1:	GOTO[makeTosNil],	c1, at[3,10,listpdisp];	PC &larr; PC + PC16, Xbus &larr; ib, GOTO[makeTosNil],	c1, at[5,10,listpdisp];makeTosNil:	TOSH &larr; 0{nil}, IBDisp, L2 &larr; L2.0,	c2;	TOS &larr; 0{nil}, L2 &larr; L2.0, DISPNI[OpTable],	c3;{*******************************************************************}@DTEST:	opcode[6'b],	TT &larr; 06'b, CALL[NewTyp],	c1;{		NewTyp will call ufn[TT] if tos is not a valid LISP pointer (i.e. if it is larger than a 22 bit number).	ELSE: typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry. }	MAR &larr; [rhRx, Rx + 0],	c1, at[6,10, NewTypRet];	Rx &larr; DTDbasePage,	c2;	TT &larr; MD and Q,	c3;	Rx &larr; Rx LRot8,	c1;	Noop,	c2;	Noop,	c3;	TT &larr; TT LRot4,	c1;	TT &larr; Rx + TT, rhTT &larr; DTDspace,	c2;	Rx &larr; ib,	c3;	Map &larr; Q &larr; [rhTT, TT],	c1;	TT &larr; Rx LRot8,	c2;	rhRx &larr; Rx &larr; MD, {XRefBr,}	c3;	MAR &larr; [rhRx, Q + 0], {BRANCH[dtestMap, $],}	c1;	TT{type} &larr; ib or TT,	c2;	Rx  &larr; MD xor TT, L2 &larr; L2.0,	c3;	Ybus &larr; Rx, NZeroBr,	c1;	Rx &larr; 6, BRANCH[$, DtestnotOK], 	c2;	PC &larr; PC + 1, L2 &larr; L2.0,	c3;	Noop, GOTO[IB.nop],	c1;IB.nop:	L2 &larr; L2.0, IBDisp, GOTO[DNI.nop],	c2;DtestnotOK:	IB &larr; TT{type} LRot0,	c3;	PC &larr; PC - PC16, IBPtr&larr;0, GOTO[ufn2],	c1;{*******************************************************************}@CAR:	opcode[1'b],	Ybus &larr; TOS or TOSH, ZeroBr, GOTO[carcdrcomm],	c1;@CDR:	opcode[2'b],	Ybus &larr; TOS or TOSH, ZeroBr, GOTO[carcdrcomm],	c1;carcdrcomm:	Xbus &larr; TOSH LRot12, XDisp, BRANCH[$, carcdrretNIL],	c2;	DISP4[NewTypDisp, 3],	c3;carcdrretNIL:	CANCELBR[$, 0F],	c3;	PC &larr; PC + PC16, GOTO[makeTosNil],	c1;{		NewTyp will call ufn[TT] if tos is not a valid LISP pointer (i.e. if it is larger than a 22 bit number).	ELSE: typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry. }NewTyp:	Xbus &larr; TOSH LRot12, XDisp,	c2;NewTypC3:	Rx &larr; TT, NegBr, DISP4[NewTypDisp, 3],	c3;	MAR &larr; Q &larr; [TOS, TOSH + 0], CANCELBR[$],	c1, at[03,10,NewTypDisp];typ:	Rx &larr; Q, rhRx &larr; MDSTYPEspaceReal, 	c2;	Rx &larr; Rx LRot8, L1 &larr; L1.DecOnly,	c3;	Rx &larr; Rx RShift1, SE&larr;1,	c1;	PC &larr; PC + PC16, L2Disp, 	c2;	Q &larr; 0FF, DISP4[NewTypRet],	c3;	BRANCH[carcdrufn, listpretnil],	c1, at[07,10,NewTypDisp];	BRANCH[carcdrufn, listpretnil],	c1, at[0B,10,NewTypDisp];	BRANCH[carcdrufn, listpretnil],	c1, at[0F,10,NewTypDisp];carcdrufn:	GOTO[ufnX3],	c2;	MAR &larr; [rhRx, Rx], Rx &larr; ListType + 0, L0&larr;L0.xRedoCdr, GOTO[cadr],	c1, at[1,10, NewTypRet];	MAR &larr; [rhRx, Rx], Rx &larr; ListType + 0, L0&larr;L0.xRedoCdr, GOTO[cadr],	c1, at[2,10, NewTypRet];cadr:	rhTT &larr; TOSH LRot0, ZeroBr,	c2;	Q &larr; MD xor Rx, BRANCH[$, cadrN],	c3;	Map &larr; TT &larr; [rhTT, TOS], GOTO[cadr1],	c1;cadrN:	Map &larr; TT &larr; [rhTT, TOS], ZeroBr,	c1;cadr1:	Q &larr; Q - 1, PgCarryBr, BRANCH[$, tosNil],	c2;cadr3:	uTOSH &larr; TOSH, rhRx &larr; Rx &larr; MD, XRefBr, BRANCH[$, cadrUfn],	c3;cadrH:	MAR &larr; Q &larr; [rhRx, TOS], L2Disp, BRANCH[cadrMap, $],	c1, at[L0.xRedoCdr, 10, RxMapFixCaller];	rhTT &larr; Rx LRot0, TT &larr; Q + 1, BRANCH[$, carTail, 0E],	c2;	Rx &larr; ~MD, XHDisp,	c3;{****************cdr cases: cdrLoc, cdrIndLoc, indCell****************}cdrL:	MAR &larr; [rhRx, TT], Rx{~,=} &larr; -Rx-1, CarryBr{0#MDhigh}, BRANCH[cdrInd, cdrDir, 2], LOOPHOLE[pci],	c1;cdrInd:	rhTOSH &larr; Rx LRot0, TOSH &larr; Rx LRot1, BRANCH[indCell, cdrIndLoc, 2],	c2;cdrDir:	TOSH &larr; ~Rx LRot8, CANCELBR[$, 3],	c2;{Regs:	         TOSH{cdr},   uTOSH{tosH}, TOS{tos}	cdrLoc	         TOSH{cdr},   rhTT{rhRx}, TT{Rx}	cdrIndLoc	         rhTOSH{carH}, MD{car}	indCell }cdrLoc:	TOSH &larr; (TOSH and u7F) LShift1, ZeroBr,	c3;	MAR &larr; TOS &larr; [TOS, TOSH + 0], BRANCH[$, makeTosNil, 2],	c1;{rhTOS?%}	TOSH &larr; uTOSH, L2 &larr; L2.0, IBDisp,	c2;	TOSH &larr; TOSH and 0FF, L2 &larr; L2.0, DISPNI[OpTable],	c3;tosNil:	CANCELBR[makeTosNilC1, 3],	c3;cdrIndLoc:	TOSH &larr; ~(TOSH LRot8),	c3;	MAR &larr; Q &larr; [rhTT{rhRx}, TOSH{cdr} or 1],	c1;	TOSH &larr; 0FF , CANCELBR[$, 2],	c2;	TOS &larr; MD,	c3;	MAR &larr; [rhTT, Q - 1], L2 &larr; L2.0, 	c1;	IBDisp, CANCELBR[$, 2],	c2;	TOSH &larr; MD and TOSH, L2 &larr; L2.0, DISPNI[OpTable],	c3;{**************** car cases: indCell, other ****************}carTail:	TOSH &larr; MD, rhTOSH &larr; MD, XHDisp,	c3;carL:	MAR &larr; [rhRx, TOS + 1], BRANCH[$, carDir, 2],	c1;	Ybus &larr; TOSH and ~u0FF, NZeroBr, CANCELBR[$, 2],	c2;indCell:	TOS &larr; MD{car}, BRANCH[$, carIndLoc],	c3;	Map &larr; [rhTOSH, TOS], TOSH &larr; rhTOSH, L0&larr;L0.xRedoCdr,	c1;	rhTT &larr; TOSH LRot0, {{*}TT &larr; Q,{*}}GOTO[cadr3], {L0 still set}	c2;carIndLoc:	TOSH &larr; rhTOSH, GOTO[IB.nop],	c1;{	L2 &larr; L2.0, IBDisp,	c2;	L2 &larr; L2.0, DISPNI[OpTable],	c3;}carDir:	TOSH &larr; rhTOSH, L2 &larr; L2.0, IBDisp, DISP2[dumb],	c2;dumb:	TOS &larr; MD, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0, 4, dumb];	Q &larr; 9'd, GOTO[sink1],	c3, at[2, 4, dumb];{MP9009}{**************** exceptions                   ****************}cadrMap:	TT &larr; TOS, CANCELBR[RLxMapFix, 0F], {returns to cdrH}	c2;cadrUfn:	PC &larr; PC - PC16, CANCELBR[ufnX2],	c1;{*******************************************************************	RAID	? %  ? clicks*******************************************************************}{display function name in MP; wait for right shift}@RAID:	opcode[76'b],	Q &larr; TOS + 0FF + 1,	c1;	Q{TOS + 300'd} &larr; Q + 2C,	c2;	PC &larr; PC + PC16, GOTO[sink1],	c3;{display Q in MP; wait for right shift key; noop}MPWait:	uLispOptions &larr; 0,	c1;MPWait2:	,	c2;	rhRx &larr; Rx &larr; uIOPage,	c3;	MAR &larr; [rhRx, IOPage.MP+0],	c1;	MDR &larr; Q,	c2;	TT{saveMP} &larr; MD,	c3;	MAR &larr; [rhRx, IOPage.key+0],  GOTO[MPWait7],	c1;	{"stop" key hard reset is 0 in bit 15}{"undo" key down is 0 in bit 13}raidLp1:	MAR &larr; [rhRx, IOPage.key+0],  DISP4[raidEnd, 0A]	c1;MPWait7:	Noop ,	c2, at[0F, 10, raidEnd];	Xbus &larr; MD, XDisp, GOTO[raidLp1],	c3;	Q &larr; 1,	c2, at[0E, 10, raidEnd];	uWDC &larr; Q, L2&larr;0,	c3;	MAR &larr; [rhRx, IOPage.MP+0], CANCELBR[$, 0F],	c1;	MDR &larr; TT{saveMP},	c2;	Rx &larr; {TeleRaidFXP}30'b, GOTO[PUNT],	c3;	GOTO[stopEnd],	c2, at[0A, 10, raidEnd];	GOTO[stopEnd],	c2, at[0B, 10, raidEnd];stopEnd:	,	c3;	MAR &larr; [rhRx, IOPage.MP+0],	c1;	MDR &larr; TT{saveMP},	c2;	GOTO[Reset],	c3;{*******************************************************************	SUBRCALL	? %  ? clicks*******************************************************************}{pop "b" items and push 1 item}@SUBR:	opcode[175'b],	TT &larr; ib, L2&larr;L2.0,	c1;	Rx &larr; TT xor 0F, ZeroBr,	c2;	Ybus &larr; TT xor 15'b, ZeroBr, BRANCH[$, RaidS],	c3;WellContinueHere:	Ybus &larr; TT xor 6, ZeroBr, BRANCH[$, logout],	c1;	Ybus &larr; TT xor 9, ZeroBr, BRANCH[$, BackGround],	c2;	TT &larr; TT xor 10, BRANCH[$, DspBout3],	c3;	Ybus &larr; TT, ZeroBr,	c1;	Ybus &larr; TT xor 2, ZeroBr, BRANCH[$, Pup],	c2;	Ybus &larr; TT xor 3, ZeroBr, BRANCH[$, SETSCREENCOLOR],	c3;	Rx &larr; ib, ZeroBr, BRANCH[$, ShowDisplay],	c1;SubrXXX:	PC &larr; PC + 1, BRANCH[SubrXXX1, subrPush],	c2;SubrXXX1:	Rx &larr; (Rx -1) LShift1, SE&larr;0,	c3;Subrs:	S &larr; S - Rx,	c1;	PC &larr; PC + PC16, L2&larr;L2.0,	c2;	Rx &larr; 26,	c3;	Rx &larr; Rx LRot8,	c1;	Rx{9900=26ACh} &larr; Rx +0AC,	c2;	Q &larr; Rx +TT{raid#}, GOTO[MPWait{sink1}],	c3;subrPush:	Noop,	c3;	MAR &larr; S &larr; [rhS, S + 1], GOTO[CopyRet],	c1;RaidS:	Rx &larr; ib, ZeroBr, CANCELBR[$],	c1;	PC &larr; PC + 1, BRANCH[SubrXXX1, subrPush],	c2;Pup:	CANCELBR[SETSCREENCOLOR],	c3;SETSCREENCOLOR: Rx &larr; ib, ZeroBr, CANCELBR[NoopS2],	c1;DspBout3:	Rx &larr; ib, ZeroBr, GOTO[NoopS2],	c1;NoopS2:	PC &larr; PC + 1, BRANCH[$, subrPush3],	c2;	Rx &larr; (Rx -1) LShift1, SE&larr;0,	c3;subrEnd:	S &larr; S - Rx, GOTO[IB.pc1],	c1;subrPush3:	Noop,	c3;	MAR &larr; S &larr; [rhS, S + 1], GOTO[CopyRet],	c1;{*******************************************************************}BackGround:	CANCELBR[SETSCREENCOLOR],	c3;{*******************************************************************}ShowDisplay:	rhRx &larr; Rx &larr; uIOPage, CANCELBR[$, 1],	c2;	S &larr; S - 2{(2 args -1)*2},	c3;	TT &larr; 88,	c1;	PC &larr; 1 + PC + PC16,	c2;	Q &larr; 41,	c3;	MAR &larr; [rhRx, 0EC+0],	c1;	MDR &larr; 0,	c2;	TT &larr; TT LRot8,	c3;	MAR &larr; [rhRx, 0ED{0EF}+0],	c1;	MDR &larr; TT{8800} or 22, L2 &larr; L2.0,	c2;	DCtl&larr;Q LRot0, L2 &larr; L2.0, DISPNI[OpTable],	c3;{*******************************************************************}@RCLK:	opcode[167'b],	uTOSH &larr; TOSH,	c1;	rhTT &larr; TOSH LRot0,	c2;	,	c3;	Map &larr; TT &larr; [rhTT, TOS], L0 &larr; L0.RedoClk,	c1;	PC &larr; PC + PC16, L1 &larr; L1.DecOnly,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;		at[L0.RedoClk,10,WMapFixCaller],	Q &larr; uClockHigh, DISP2[ClkMap],	c1;	TOSH &larr; RShift1 uClockBits, SE&larr;0,	c2, at[1, 4, ClkMap];	TT &larr; uClockLow,	c3;	MAR &larr; [rhRx, TOS+1], L2 &larr; L2.0,	c1;	MDR &larr; TOSH +TT, CANCELBR[$, 2], WriteOK,	c2;	Ybus &larr; TOSH +TT, CarryBr,	c3;	MAR &larr; [rhRx, TOS+0], BRANCH[ClkNoCar, ClkCar],	c1;ClkNoCar:	MDR &larr; Q, IBDisp, GOTO[reTosh],	c2;ClkCar:	MDR &larr; Q+1, IBDisp, GOTO[reTosh],	c2;reTosh:	TOSH &larr; uTOSH, L2 &larr; L2.0, DISPNI[OpTable],	c3;	CALL[WLMapFix]{will return at RedoClk},	c2, at[0, 4, ClkMap];	CALL[WLMapFix]{will return at RedoClk},	c2, at[2, 4, ClkMap];	CALL[WLMapFix]{will return at RedoClk},	c2, at[3, 4, ClkMap];{*******************************************************************	FVAR		? %  ? clicks*******************************************************************}	uTOS &larr; TOS, TT &larr; MD, XLDisp, {L1 &larr; L1.PopOnly,} CANCELBR[$, 1],	c3, at[6, 8, IVar3];{checks for stack overflow later}{(Bh) binding pointer high}	MAR &larr; Q{chain} &larr; [rhRx, Rx + 1],  BRANCH[$, FVunfilled, 2],	c1;	{uPV &larr; PV,} CANCELBR[$, 2],	c2;	{Q &larr;} rhTT &larr; MD, {L1 &larr; L1.PopOnly,}	c3;{(MV) map bound val}fvFilled:	Map &larr; [rhTT, TT], L1 &larr; L1.PopOnly, CANCELBR[$, 7],	c1, at[L3.FVAR,10, fvCaller];	TOS &larr; uTOS, L0 &larr; L0.xRedoFV0,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;{(V) fetch bound val}RedoFV0:	MAR &larr; [rhRx, TT + 1],  BRANCH[fvMap0, $],	c1, at[L0.xRedoFV0,10, RxMapFixCaller];	[] &larr; S xor uStkLimO, ZeroBranch, CANCELBR[$,2],	c2;	TOS &larr; MD, BRANCH[$, StkOvr2], L2Disp,	c3;{Var4:}	MAR &larr; [rhRx, TT + 0], BRANCH[fvPC1, fvPC2, 2],	c1;fvPC1:	PC &larr; PC + PC16, IBDisp, GOTO[fvEnd], L2 &larr; L2.0,	c2;fvPC2:	PC &larr; PC + 1, IBDisp, GOTO[fvEnd], L2 &larr; L2.0,	c2;fvEnd:	TOSH &larr; MD, L2 &larr; L2.0, DISPNI[OpTable],	c3;StkOvr2:	MAR &larr; [rhRx, TT + 0], BRANCH[fvPC1ov, fvPC2ov, 2],	c1;fvPC1ov:	PC &larr; PC + PC16, GOTO[fvEndov], L2 &larr; L2.0,	c2;fvPC2ov:	PC &larr; PC + 1, GOTO[fvEndov], L2 &larr; L2.0,	c2;fvEndov:	TOSH &larr; MD, GOTO[StackOverflow],	c3;FVunfilled:	TT &larr; UvCL, L3 &larr; L3.FVAR, CANCELBR[$,2],	c2;	rhTT &larr; UvChighL, CALL[FVLookUp],	c3;fvMap0:	TOSH &larr; uTOSH, CANCELBR[RLxMapFix, 3]{will return to RedoFV0},	c2;{*******************************************************************	FREE VAR LOOKUP		? %  ? clicks*******************************************************************}{	look up variable in current frame; fill in binding pointer	(chaining not implemented)This code assumes that NAMETABLE is contiguous in real memory {either it is on the stack, or within a code header which is non-page crossing}on Entry:	c1uTOS	restored to TOS if faultuTOSH	restored to TOSH if faultPV	current frame (point to PV region)Q	{uChain}  (odd) stack pointer to variable to be looked up (Pv + ib + 1)rhTT, TT	virtual address of name table (usually function header)L3	caller's return link at[L3, 10, fvCaller]uses during subroutine:rhRx, Rx	real address of name tablePV	frame extension pointers (point to PV region)(travel up alinks)uPV	save local PVTOS	useduChain	TOSH{chain}rhTOSH	nRhS {set once at odd time; must be left}{*} used with TOSH{chain}uName	TOSH{name} &larr; [UvCL + T/2 {- UvCL.nlocals} + UvCL.fvaroffset]ntSize, offset, L0, L1on Return:	c1	preserves S, PV, PC, L2, uTOS, uTOSH	smashes TOS, TOSH {but preserved in uTOS, uTOSH}rhTT, TT	virtual address of free value@(chain)	filled in binding pointerL1	binding type{fvStack, fvGlobal, fvUnbound} Dispatch pendingon Fault:	S &larr; S - 2, TOS &larr; uTOS, TOSH &larr; uTOSH}FVLookUp: {map header}	Map &larr; [rhTT, TT], L0 &larr; L0.xRedoFV,	c1;	TOS{name} &larr; RShift1 (Q{chain} - PV - 1), SE&larr;0,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;fvOff: {fvoffset from fn header}	MAR &larr; [rhRx, TT + 7{fnh.nlfv}], BRANCH[fvMap, $],	c1, at[L0.xRedoFV,10, RxMapFixCaller];	TT &larr; TT + TOS{name}, CANCELBR[$, 2],	c2;	TOS{fvoff} &larr; MD{fvoffset},	c3;{(L) correct by nlocals}{should be unnecessary}	uChain &larr; Q{chain},	c1;	TOSH{nlocs} &larr; TOS{fvoff} LRot8,	c2;	Q{fvoff} &larr; TOS{fvoff} - TOSH{nlocs},	c3;fvN: {name from fn header} {*ASSUMES name on same page}	MAR &larr; Rx &larr; [rhRx, TT + Q{fvoff}],	c1;{#}	uPV &larr; PV, CANCELBR[$, 2],	c2;	TOSH{name} &larr; MD{name}, GOTO[newFrame],	c3;{************************************}newFrame: {PV &larr; PV.alink} {TOSH{name}, PV}	MAR &larr; PV &larr; [rhPV, PV - 9],	c1;fvA2:	Q &larr; ~1, BRANCH[$, fvACross, 1],	c2;	uName &larr; TOSH{name}, PV{alink} &larr; MD and Q, {XLDisp,}	c3;fvFF: {check flags for name table valid}	MAR &larr; PV &larr; [rhPV, PV - 0A{flags-pvar}],	c1;fvF2:	Q{PVflags} &larr; PV, ZeroBr, BRANCH[$, fvFCross, 1],	c2;	Rx &larr; MD{flags}, BRANCH[$, endStack],	c3;fvH: {header lo}	MAR &larr; PV &larr; [rhPV, PV + 2{deflo-flags}],	c1;fvH2:	Xbus &larr; Rx LRot8, XDisp, BRANCH[$, fvHCross, 1],	c2;fvH3:	TT &larr; MD{deflo}, BRANCH[fvH1, ntValid, 0D],	c3;ntValid:	MAR &larr; PV &larr; [rhPV, PV + 4{ntlo-deflo}],	c1;	Rx &larr; 0, BRANCH[fvH3, fvHCross, 1],	c2;{fvH1:} {header hi}fvH1:	MAR &larr; [rhPV, PV + 1],	c1;	PV &larr; Q{PVflags} + 0A{pvar-flags}, CANCELBR[$, 2],	c2;	rhTT &larr; MD{defhi},	c3;fvMH: {map header}	TT &larr; TT and ~3{not really necessary},	c1;	,	c2;	TT &larr; TT + 6,	c3;	Map &larr; [rhTT, TT], L0 &larr; L0.xRedoFVN,	c1;	TOS{mask} &larr; ~3, L1 &larr; L1.fixFV{maybe smashed},	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;{fvN: ntSize}{#this click could be eliminated possibly by testing for zero (vs ntSize)}RedoFVN:	MAR &larr; Q &larr; [rhRx, TT + 0{6}], BRANCH[fvMapN, $],	c1, at[L0.xRedoFVN,10, RxMapFixCaller];	Rx &larr; Q + 2, CANCELBR[$, 2],	c2;	TOS{cnt} &larr; TOS{mask} and MD{ntSize}, GOTO[lookFor],	c3;lookFor: {match?}	MAR &larr; Rx &larr; [rhRx, Rx + 0],	c1;	Q{ntSize-1} &larr; TOS{cnt} - 1, {*}rhTOSH &larr; nRhS, GOTO[matJoin],	c2;matLp:	MAR &larr; Rx &larr; [rhRx, Rx + 0],	c1, at[6, 10, Mat];	Ybus &larr; TOS{cnt} - 1, NegBr,	c2;matJoin:	TT &larr; TOSH{name} xor MD, BRANCH[$, newFrame],	c3;{fvM1:  match?}	MAR &larr; Rx &larr; [rhRx, Rx + 1], L0 &larr; 0,	c1;	TT &larr; TT, ZeroBr, CANCELBR[$, 2], 	c2;	TT &larr; TOSH{name} xor MD, BRANCH[$, Val0],	c3;fvM2: {match?}	MAR &larr; Rx &larr; [rhRx, Rx + 1], L0 &larr; 2, 	c1, at[0, 10, Mat];	TT &larr; TT, ZeroBr, CANCELBR[$, 2],	c2;	TT &larr; TOSH{name} xor MD, BRANCH[$, Val1],	c3;{fvM3: match?}	MAR &larr; Rx &larr; [rhRx, Rx + 1], L0 &larr; 4,	c1, at[2, 10, Mat];	TT &larr; TT, ZeroBr, CANCELBR[$, 2],	c2;	TT &larr; TOSH{name} xor MD, BRANCH[$, Val2],	c3;{fvM4: done?}	Rx &larr; Rx + 1,	c1, at[4, 10, Mat];	TT &larr; TT, ZeroBr, L0 &larr; 6,	c2;	TOS{cnt} &larr; TOS - 4, BRANCH[matLp, Val3],	c3;{value; fvfound}  {preserve Rx{realNames}, TOS{cnt}, TOSH{name}, Q{ntSize-1}}Val0:	MAR &larr; [rhRx, Rx + Q{ntSize-1}], GOTO[Vtail],	c1;Val1:	MAR &larr; [rhRx, Rx + Q], GOTO[Vtail],	c1;Val2:	MAR &larr; [rhRx, Rx + Q], GOTO[Vtail],	c1;Val3:	MAR &larr; [rhRx, Rx + Q], GOTO[Vtail],	c1;Vtail:	rhTT &larr; STACKspace, BRANCH[$, VTailFix, 1],	c2;Vtail3:	TT{vtyOffset} &larr; MD, XHDisp, L1 &larr; L1.fvStack,	c3;{##% maybe save a click if offset is words not doublewords}	TOSH{offset} &larr; (TT and 0FF) LShift1, BRANCH[fvIVar, $, 2],	c1;	TOSH{ptrToVal} &larr; PV{pvar} + TOSH, rhTOSH &larr; nRhS,	c2;	Noop,	c3;fvFP: {FVar or PVar}	MAR &larr; [rhTOSH, TOSH{ptrToVal} + 0{TT}], {BRANCH[fvIVar, ${, 2}],}	c1;fvFP2:	Ybus &larr; TT + TT{varType}, NegBr,	c2;	TT &larr;  MD, XLDisp{undefinedF}, BRANCH[fvPvar, fvFvar],	c3;VTailFix:	Rx &larr; Rx + Q,	c3;{used to be MP9099}	MAR &larr; [rhRx, Rx + 0],	c1;	Rx &larr; Rx - Q, GOTO[Vtail3],	c2;{***********************} {rhTT &larr; STACKspace}fvPvar:	Ybus &larr; TT, NegBr{undefP}, CANCELBR[$, 3],	c1;	TT &larr; TOSH{ptrToVal}, BRANCH[$, lookMore], L0Disp,	c2;	TOSH{chain} &larr; uChain, XLDisp, CANCELBR[donefv, 0F],	c3;{preserved Rx{realNames}, TOS{cnt}, Q{ntSize-1}}lookMore:	{TT#0} TOSH{name} &larr; uName, DISP4[Mat],{back}	c3;{***********************} {free to smash Rx and TOS below here}fvFvar:	MAR &larr; [rhTOSH, TOSH{ptrToVal} + 1], BRANCH[$, fvUnbF, 2],	c1;	TOSH{chain} &larr; uChain, CANCELBR[$, 2],	c2;	rhTT &larr; MD, 	c3;	Q &larr; STACKspace,	c1;	Ybus &larr; Q xor rhTT, ZeroBr,	c2;fvFcon:	Ybus &larr; TOSH{chain}, YDisp, BRANCH[$, donefvX],	c3;	CANCELBR[$, 0F],	c1;	L1 &larr; L1.fvGlobal,	c2;	Ybus &larr; TOSH{chain}, YDisp, GOTO[donefvX],	c3;fvUnbF:	Noop, CANCELBR[$, 2],	c2;	TOSH{name} &larr; uName, GOTO[newFrame],	c3;{***********************} fvIVar:	{rhTT &larr; uSTACKspace}	TOS{offset} &larr; (TT and 0FF) LShift1, CANCELBR[$, 2],	c2;	PV &larr; PV - 0B{ivar-pvar},	c3;	MAR &larr; [rhPV, PV + 0],	c1;	TOSH{chain} &larr; uChain,	c2;	TT &larr; MD{ivar}, Ybus &larr; TOSH{chain}, YDisp,	c3;	MAR &larr; [rhTOSH, TOSH{chain} - 1], BRANCH[fvRet2, $, 0E],	c1;	MDR &larr; TT &larr; TT + TOS{offset}, CANCELBR[donefv3, 2], WriteOK,	c2;fvRet2:	TT &larr; TT + TOS, L3Disp, CANCELBR[fvRet3, 2],	c2;	{***********************}endStack:	TT &larr; uName, L1 &larr; L1.fvGlobal, GOTO[endStk2],	c1;endStk1:	TT &larr; uName, L1 &larr; L1.fvGlobal,	c1;endStk2:	TT &larr; TT + TT, rhTT &larr; VALspace,	c2;	TOSH{chain} &larr; uChain, XLDisp, GOTO[donefv]	c3;{***********************}{	TOSH{chain} &larr; uChain, YDisp, GOTO[donefv]	c3;}donefvX:	MAR &larr; [rhTOSH, TOSH{chain} - 1], BRANCH[donefvY, donefv2, 0E],	c1;donefv:	MAR &larr; [rhTOSH, TOSH{chain} - 1], BRANCH[donefvY, donefv2, 0E],	c1;donefvY:		L3Disp, CANCELBR[fvRet3, 2],	c2;donefv2:	MDR &larr; TT, CANCELBR[donefv3, 2], WriteOK,	c2;donefv3:	Noop,	c3;fvRet: {donefvlookup}{double up bindptr high}	Q &larr; rhTT,	c1;	Rx &larr; Q,	c2;	Rx{rhTT LRot8} &larr; Rx LRot8,	c3;	MAR &larr; [rhTOSH, TOSH{chain} + 0],	c1;	MDR &larr; rhTT or Rx{rhTT LRot8}, L3Disp,	c2;fvRet3:	PV &larr; uPV, L1Disp, RET[fvCaller],{restore PV}	c3;{**********************  exceptions:  ***********************}{trial faster inner loop?}{	MAR &larr; [rhB, A], B &larr; Q, ZeroBr,	c1;}{	Ybus &larr; name xor Q, ZeroBr, BRANCH[$, done],	c2;}{	Q &larr; MD, BRANCH[$, match],	c3;}{exceptions:}fvMap:	uPV &larr; PV, CANCELBR[RLxMapFix, 3], L1 &larr; L1.fixFV,{return to RedoFV},	c2;fvMapN:	CANCELBR[RLxMapFix, 3], L1 &larr; L1.fixFV,{return to RedoFVN}	c2;fvFCross:	PV &larr; PV - 0FF -1, CANCELBR[$, 1],	c3;	MAR &larr; PV &larr; [rhPV, PV + 0], GOTO[fvF2],	c1;fvACross:	PV &larr; PV - 0FF -1,	c3;	MAR &larr; PV &larr; [rhPV, PV + 0], GOTO[fvA2],	c1;fvHCross:	PV &larr; PV + 0FF + 1, CANCELBR[$, 0F],	c3;	MAR &larr; PV &larr; [rhPV, PV + 0], GOTO[fvH2],	c1;fvFPCross:	PV &larr; PV + 0FF + 1, CANCELBR[$, 0F],	c3;	MAR &larr; PV &larr; [rhPV, PV + 0], GOTO[fvFP2],	c1;fvFix:	TOSH &larr; uTOSH, L3Disp,	c1, at[L1.fixFV,10,Fix];	TOS &larr; uTOS, DISP4[fvfixup],	c2;	PV &larr; uPV,{ GOTO[popFix],}	c3,at[L3.FVAR,10,fvfixup];	S &larr; S - 2, GOTO[NoMoreFix],	c1;	PV &larr; uPV, GOTO[NoFixes],	c3, at[L3.FVARg,10,fvfixup];{*******************************	FVAR&larr;	4 clicks ?%*******************************}@FVARg:		opcode[143'b],	MAR &larr; Q &larr; [rhPV, PV + ibNA + 1], L3 &larr; L3.FVARg,	c1;FVGcont:	Rx &larr; Q, rhRx &larr; nRhS, BRANCH[$, FVGCar,1],	c2;	uTOSH &larr; TOSH, TT &larr; rhTT &larr; MD{address high},	c3;{compliance: using uSTACKspace with duplicated high byte for bind ptr}	MAR &larr; [rhRx, Rx - 1],	c1;	Ybus &larr; TT xor uSTACKspace, NZeroBr, CANCELBR[$, 2],	c2; {% incompatable}	uTOS &larr; TOS, TT &larr; MD{address low},		XLDisp {dispatch if not looked up},		BRANCH[$, fvgStore1] {branch if not on stack},	c3;{TOS and TOSH saved in case freeVarLookup is invoked}fvgStore:	MAR &larr; [rhS, TT], S &larr; S + 0, DISP4[fvType, 2],	c1, at[L3.FVARg,10, fvCaller];fvgStore1:	MAR &larr; [rhS, TT], S &larr; S + 0, DISP4[fvType, 6],	c1;{var bound on stack}	MDR &larr; TOSH &larr; uTOSH,	c2, at[L1.fvStack{2}, 10, fvType];fvgStore3:	rhTT &larr; nRhS,	c3;	MAR &larr; [rhTT, TT + 1], Xbus &larr; ib, L2 &larr; L2.0,	c1;	MDR &larr; TOS &larr; uTOS, IBDisp, CANCELBR[$, 2], WriteOK,	c2;	PC &larr; PC + 1, L2 &larr; L2.0, DISPNI[OpTable],	c3;fvgUnbnd:	TT &larr; UvCL, CANCELBR[fvLook, 3],	c2, at[L1.fvUnbound{3}, 10, fvType];	TT &larr; UvCL, CANCELBR[fvLook, 3],	c2, at[{L1.fvUnbound1}7, 10, fvType];fvLook:	rhTT &larr; UvChighL, CALL[FVLookUp],	c3;fvgGlobal:TOS &larr; uTOS,	c2, at[L1.fvGlobal{6}, 10, fvType];	TOSH &larr; uTOSH,	c3;{real version:}	S&larr; S+1,	c1;	Q&larr; rhTT,	c2;	Rx&larr; AtomSETFVAR {376'b},  	c3;	MAR&larr; [rhS, S + 0],	c1;	MDR&larr; uTOSH, 	c2;	TOSH&larr; Q {address high}, IB&larr; Rx LRot0,	c3;	MAR&larr; S&larr; [rhS, S + 1], IBPtr&larr;0,	c1;	MDR&larr; uTOS, CANCELBR[$, 2], WriteOK,	c2;	TOS&larr; TT {address low}, L3{ib's}&larr;1,	c3;	MAR &larr; Q &larr; [rhS, S + 1], GOTO[FVcall],	c1;FVGCar:	Rx &larr; Q + 0FF +1,	c3;	MAR &larr; Q &larr; [rhRx, Rx + 0], GOTO[FVGcont],	c1;{*******************************************************************	GETBITS.N.FD		? %  5 clicks*******************************************************************}@GBITS:	opcode[312'b],	TT &larr; TOS + ib, CarryBr, L1 &larr; L1.Dec3,	c1;	rhTT &larr; TOSH LRot0, BRANCH[$, GBrhnok],	c2;GBcont:	PC &larr; 1 + PC + PC16,	c3;	Map &larr; [rhTT,TT], L0 &larr; L0.xRedoGF,	c1;	Q{fd.pos} &larr; ibHigh{fd.pos}, L2 &larr; L2.0,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;RedoGF:	MAR &larr; [rhRx, TT + 0], BRANCH[GFMap,$],	c1, at[L0.xRedoGF,10, RxMapFixCaller];	Rx &larr; Q{fd.pos} + ib{fd.size} + 1, rhRx &larr; ib{fd.size},	c2;	Rx &larr; MD{data}, Ybus &larr; Rx{shift}, YDisp, L2 &larr; L2.GFRet,	c3;	TT &larr; LRot1 Rx, DISP4[CycleMask],	c1;	{CycleMask Subroutine Here}GFRet:	TOS &larr; TOS and TT, IBDisp, L2 &larr; L2.0, GOTO[MiscInEnd],	c2, at[L2.GFRet,10,MaskRet];{	TOSH &larr; smallpl, L2 &larr; L2.0, DISPNI[OpTable],	c3;}GBrhnok:	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c3;	rhTT &larr; Q LRot0,	c1;	GOTO[GBcont],	c2;GFMap:	Noop, CANCELBR[RLxMapFix, 3]{will return to RedoGF},	c2;{*******************************************************************	PUTBITS.N.FD (ptr, newval =&gt; ptr)		? %  7 clicks*******************************************************************}@PUTBITS:	opcode[317'b],	MAR &larr; [rhS, S + 0], L1 &larr; L1.fixWF,	c1;	Ybus &larr; TOSH xor smallpl, NZeroBr,	c2;	TT &larr; MD{ptr}, BRANCH[$, ufnWF],	c3;	MAR &larr; [rhS, S - 1], L0&larr; L0.RedoWF,	c1;	TT &larr; TT + ib, CarryBr, CANCELBR[$, 2],	c2;	rhTT &larr; MD{ptrH}, BRANCH[PBrhok, $],	c3;	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c1;	rhTT &larr; Q LRot0,	c2;	c3;PBrhok:	Map &larr; Q &larr; [rhTT, TT], L2 &larr; L2.WFRet{0},	c1;{% segCross}	TOSH{-pos-1} &larr; 0 - ibHigh - 1, YDisp, {L2&larr;0,}	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp}, DISP4[MaskTbl], {L2Disp,}	c3;{MaskTbl:	TT &larr; mask, RET[MaskRet],	c1, at[0, 10, MaskTbl];}RedoWF2:	Ybus{pos+size} &larr; ib{size} - TOSH{-pos-1} - 1, YDisp, 	c2, at[L2.WFRetMapOdd{1}, 10, MaskRet];	TOSH &larr; smallpl, L2&larr;0, DISP4[Mask],	c3;Mask:	TT &larr; ~TT xor u7FFF, L2Disp, GOTO[Left0],{17b}	c*, at[0,10,Mask];	TT &larr; ~TT xor uTT3FFF, L2Disp, GOTO[Left12],{0}	c*, at[1,10,Mask];	TT &larr; ~TT xor u1FFF, L2Disp, GOTO[Left12],	c*, at[2,10,Mask];	TT &larr; ~TT xor u0FFF, L2Disp, GOTO[Left12],	c*, at[3,10,Mask];	TT &larr; ~TT xor u7FF, L2Disp, GOTO[Left12],	c*, at[4,10,Mask];	TT &larr; ~TT xor uTT3FF, L2Disp, GOTO[Left8],	c*, at[5,10,Mask];	TT &larr; ~TT xor u1FF, L2Disp, GOTO[Left8],	c*, at[6,10,Mask];	TT &larr; ~TT xor 0FF, L2Disp, GOTO[Left8],	c*, at[7,10,Mask];	TT &larr; ~TT xor 7F, L2Disp, GOTO[Left8],	c*, at[8,10,Mask];	TT &larr; ~TT xor 3F, L2Disp, GOTO[Left4],	c*, at[9,10,Mask];	TT &larr; ~TT xor 1F, L2Disp, GOTO[Left4],	c*, at[0A,10,Mask];	TT &larr; ~TT xor 0F, L2Disp, GOTO[Left4],	c*, at[0B,10,Mask];	TT &larr; ~TT xor 7, L2Disp, GOTO[Left4],	c*, at[0C,10,Mask];	TT &larr; ~TT xor 3, L2Disp, GOTO[Left0],	c*, at[0D,10,Mask];	TT &larr; ~TT xor 1, L2Disp, GOTO[Left0],	c*, at[0E,10,Mask];	TT &larr; ~TT xor 0, L2Disp, GOTO[Left0],{16b}	c*, at[0F,10,Mask];Left0:	TOS &larr; TOS LRot0, DISP4[FinCycle, 0C],	c2;Left4:	TOS &larr; TOS LRot4, DISP4[FinCycle, 0C],	c2;Left8:	TOS &larr; TOS LRot8, DISP4[FinCycle, 0C],	c2;Left12:	TOS &larr; TOS LRot12, DISP4[FinCycle, 0C],	c2;	TOS &larr; TOS RRot1, GOTO[wfDo],	c3, at[0C, 10, FinCycle];	TOS &larr; TOS + TOS LShift1, GOTO[wfDo],	c3, at[0D, 10, FinCycle];	TOS &larr; TOS LShift1, GOTO[wfDo],	c3, at[0E, 10, FinCycle];	TOS &larr; TOS, GOTO[wfDo],	c3, at[0F, 10, FinCycle];wfDo:	MAR &larr; [rhRx, Q + 0],	c1;	TOS &larr; TOS and ~TT{mask},	c2;	TT &larr; MD and TT{mask},	c3;	MAR &larr; [rhRx, Q + 0],	c1;	MDR &larr; TOS or TT,	c2;	PC &larr; PC + 1, GOTO[POP],	c3;	uTT &larr; TT, TT &larr; Q, CALL[WLMapFix], {will return to RedoWF}	c2, at[0, 10, MaskRet];	uTT &larr; TT, TT &larr; Q, CALL[WLMapFix], {will return to RedoWF}	c2, at[2, 10, MaskRet];	uTT &larr; TT, TT &larr; Q, CALL[WLMapFix], {will return to RedoWF}	c2, at[3, 10, MaskRet];RedoWF:	TT &larr; uTT, DISP2[RedoWF2, 1],	c1, at[L0.RedoWF,10, WMapFixCaller];ufnWF:	Rx &larr; 317'b, GOTO[ufn2],	c1;FixWF:	TOSH &larr; smallpl, GOTO[NoMoreFix],	c1, at[L1.fixWF,10,Fix];{*******************************************************************	CycleMask		? %  1 clicks*******************************************************************}{Entry:	Rx = data to be rotated &amp; masked,	TT = pre-rotated version of Rx	a DISP4 pending which determines left rotation: (0 =&gt; no rotation)	rhRx = value to be dispatched on to determine mask (0=&gt;1, F=&gt;FFFF)Exit:	TT holds the mask,	TOS holds the rotated data,	Rx does not contain the original data,  rhRx is untouched}CycleMask:	Xbus &larr; rhRx, XDisp, GOTO[ShiftOK0],	c*, at[0,10,CycleMask];	Rx &larr; TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK0],	c*, at[1,10,CycleMask];	Rx &larr; LRot1 TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK0],	c*, at[2,10,CycleMask];	Rx &larr; RRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK4],	c*, at[3,10,CycleMask];	Xbus &larr; rhRx, XDisp, GOTO[ShiftOK4],	c*, at[4,10,CycleMask];	Rx &larr; LRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK4],	c*, at[5,10,CycleMask];	Rx &larr; LRot1 TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK4],	c*, at[6,10,CycleMask];	Rx &larr; RRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK8],	c*, at[7,10,CycleMask];	Xbus &larr; rhRx, XDisp, GOTO[ShiftOK8],	c*, at[8,10,CycleMask];	Rx &larr; LRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK8],	c*, at[9,10,CycleMask];	Rx &larr; LRot1 TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK8],	c*, at[0A,10,CycleMask];	Rx &larr; RRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK12],	c*, at[0B,10,CycleMask];	Xbus &larr; rhRx, XDisp, GOTO[ShiftOK12],	c*, at[0C,10,CycleMask];	Rx &larr; LRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK12],	c*, at[0D,10,CycleMask];	Rx &larr; LRot1 TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK12],	c*, at[0E,10,CycleMask];	Rx &larr; RRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK0],	c*, at[0F,10,CycleMask];ShiftOK0:	TOS &larr; Rx, L2Disp, DISP4[MaskTbl],	c*;ShiftOK4:	TOS &larr; Rx LRot4, L2Disp, DISP4[MaskTbl],	c*;ShiftOK8:	TOS &larr; Rx LRot8, L2Disp, DISP4[MaskTbl],	c*;ShiftOK12:	TOS &larr; Rx LRot12, L2Disp, DISP4[MaskTbl],	c*;{*********************************************	MaskTbl  SUBROUTINE	1 cycle*********************************************}{	first cycle = c* , one cycle longThis subroutine generates a right justified mask. of n onesRETURNS THRU MaskRet}MaskTbl:	TT &larr; 1, RET[MaskRet],	c*, at[0,10,MaskTbl];	TT &larr; 3, RET[MaskRet],	c*, at[1,10,MaskTbl];	TT &larr; 7, RET[MaskRet],	c*, at[2,10,MaskTbl];	TT &larr; 0F, RET[MaskRet],	c*, at[3,10,MaskTbl];	TT &larr; 1F, RET[MaskRet],	c*, at[4,10,MaskTbl];	TT &larr; 3F, RET[MaskRet],	c*, at[5,10,MaskTbl];	TT &larr; 7F, RET[MaskRet],	c*, at[6,10,MaskTbl];	TT &larr; 0FF, RET[MaskRet],	c*, at[7,10,MaskTbl];	TT &larr; LShift1 0FF, SE&larr;1, RET[MaskRet] {TT &larr; 1FF},	c*, at[8,10,MaskTbl];	TT &larr; RShift1 u7FF, RET[MaskRet] {TT &larr; 3FF},	c*, at[9,10,MaskTbl];	TT &larr; u7FF, RET[MaskRet] {TT &larr; 7FF},	c*, at[0A,10,MaskTbl];	TT &larr; RShift1 u1FFF, RET[MaskRet] {TT &larr; FFF},	c*, at[0B,10,MaskTbl];	TT &larr; u1FFF, RET[MaskRet] {TT &larr; 1FFF},	c*, at[0C,10,MaskTbl];	TT &larr; uTT3FFF, RET[MaskRet] {TT &larr; 3FFF},	c*, at[0D,10,MaskTbl];	TT &larr; RShift1 (~TT xor TT), RET[MaskRet] {TT &larr; 7FFF},	c*, at[0E,10,MaskTbl];	TT &larr; ~TT xor TT, RET[MaskRet] {TT &larr; FFFF},	c*, at[0F,10,MaskTbl];{*******************************************************************	BIND		%  ? clicks*******************************************************************}{(B) Bind}@BIND:	opcode[21'b],	uPCib &larr; PC, Rx{n1,n2} &larr; ib, ZeroBr, L2&larr;L2.0,	c1;	TT &larr; ibNA LShift1, BRANCH[$, prePush],	c2;	TT &larr; PV + TT + 1, rhTT &larr; nRhS,	c3;	MAR &larr; Q &larr; [rhTT, TT + 0], GOTO[Nloop1],	c1;{(N) bind var to Nil}	{Q odd,  TT odd}Nloop:	MAR &larr; [rhTT, TT + 0],	c1;Nloop1:	MDR &larr; PC{nil} &larr; 0,	c2;	Rx &larr; Rx - 0F - 1, CarryBr, {decr n1, &lt;0?}	c3;	MAR &larr; [rhTT, TT - 1], BRANCH[VarOdd{n1=-1}, $],	c1;	MDR &larr; PC{nil}, Rx &larr; Rx, ZeroBr{n2}, CANCELBR[$, 2], WriteOK,	c2;	TT &larr; TT - 2, BRANCH[Nloop, push],	c3;{(P) push stack if n2=0}push:	MAR &larr; S &larr; [rhS, S + 1],	c1;bindCont:	MDR &larr; TOSH, BRANCH[$, bindCar, 1],	c2;	Noop,	c3;	MAR &larr; S &larr; [rhS, S + 1],	c1;	MDR &larr; TOS, CANCELBR[$, 2], WriteOK,	c2;	PC &larr; uPCib, GOTO[endBind],	c3;{(V) bind var to Val{top of stack}}	{get to VarOdd n1=-1}VarOdd:	MDR &larr; TOSH, Rx{n2-1} &larr; Rx - 1, CANCELBR[VarOdd3, 2], WriteOK,	c2;Vloop:	MAR &larr; [rhTT, TT - 1],	c1;	MDR &larr; TOSH, CANCELBR[VarOdd3, 2], WriteOK,	c2;VarOdd3:	PC &larr; uPCib,	c3;	MAR &larr; [rhTT, TT + 0],	c1;	MDR &larr; TOS, Rx &larr; Rx - 1, NibCarryBr{pos},	c2;	TT &larr; TT - 2, BRANCH[endBind{n2-1&lt;0}, $],	c3;{(P) pop stack}bdP:	MAR &larr; [rhS, S], S &larr; S - 1	c1;	Noop, CANCELBR[$, 2],	c2;	TOS &larr; MD,	c3;{(P) pop stack}	MAR &larr; [rhS, S + 0],	c1;	S &larr; S - 1,	c2;	TOSH &larr; MD, GOTO[Vloop],	c3;{(M) push binding mark}endBind:	TOS &larr; ib LShift1,	c1;	PC &larr; PC + 1 + PC16, IBDisp,	c2;	TOSH &larr; RRot1 (TT - Q - 1), L2&larr;L2.0, DISPNI[OpTable],	c3;{exceptions:}prePush:	Q &larr; TT, GOTO[push],	c3;bindCar:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[bindCont],	c1;{*******************************************************************	UNBIND, DUNBIND*******************************************************************}{n1:Nils   n2:Var   N:last pvar    mark[-(n1+n2)-1,, 2*N]}{check for n1n2=0  ??!!  also N&gt;127}{(M) check TOS for bind mark in sign bit}@DUNBIND:	opcode[23'b],	Rx &larr; TOSH LRot0 xor ~TOSH, XHDisp, L3 &larr; 3,	c1;	TT{cnt} &larr; ~TOSH, ZeroBr, BRANCH[tosNot, tosMark, 2],	c2;tosNot:	CANCELBR[again],	c3;{(M) find bind mark by sign bit}@UNBIND:	opcode[22'b],	MAR &larr; [rhS, S - 1], L3 &larr; 2, GOTO[nomark],	c1;again:	MAR &larr; [rhS, S - 1], BRANCH[nomark, mark, 2],	c1;nomark:	S &larr; S - 2, CANCELBR[$, 2],	c2;	STK &larr; TOS, TT{cnt} &larr; ~MD, XHDisp, GOTO[again],	c3;mark:	TOS &larr; PV, rhTOS &larr; nRhS, CANCELBR[$, 2],	c2;	Rx{allOnes} &larr; Rx xor ~Rx, L2 &larr; L2.0,	c3;{(M) fetch other word of bind mark}	{S even full}	MAR &larr; [rhS, S + 2],	c1;	TT{cnt} &larr; TT, ZeroBr, BRANCH[$, dunCross, 1],	c2;dunCon:	Q{NN} &larr; MD, L3Disp, BRANCH[Uloop1, dunPop1],	c3;{(L) loop making vars unbound=-1}tosMark:	TOS{var} &larr;TOS + PV, rhTOS &larr; nRhS, CANCELBR[$],	c3;	c1;	Ybus &larr; TT, ZeroBr,	c2;	L3Disp, BRANCH[Uloop, dunPop],	c3;Uloop1:	MAR &larr;  TOS &larr; [rhTOS, TOS + Q{NN}], CANCELBR[Uloop2, 3],	c1;Uloop:	CANCELBR[$, 3],	MAR &larr; [rhTOS, TOS + 0],	c1;Uloop2:	MDR &larr; Rx{allOnes}, TT{cnt} &larr; TT - 1, ZeroBr, BRANCH[$, unbCros, 1],	c2;Uloop3:	TOS{var} &larr; TOS - 2, BRANCH[Uloop, $], L3Disp,	c3;{(P) pop stack if dunbind}	{S:odd full}dunPop:	MAR &larr; [rhS, S + 0], BRANCH[unbEnd, Pop2, 2],	c1;dunPop1:	MAR &larr; [rhS, S + 0], BRANCH[unbEnd, Pop2, 2],	c1;Pop2:	PC &larr; PC + PC16, CANCELBR[$, 2],	c2;	TOS &larr; MD,	c3;{(P) pop stack}	MAR &larr; [rhS, S - 1], L2&larr;L2.0, 	c1;	S &larr; S - 2, IBDisp, CANCELBR[$, 2],	c2;	TOSH &larr; MD, L2&larr;L2.0, DISPNI[OpTable],	c3;{(U) don't pop stack if unbind}unbEnd:	PC &larr; PC + PC16, IBDisp, CANCELBR[$, 2],	c2;	TOS &larr; STK, L2&larr;L2.0, DISPNI[OpTable],	c3;{Exceptions:}dunCross:	S &larr; S + 2, CANCELBR[$], 	c3;	MAR &larr; [rhS, S + 0],	c1;	S &larr; S - 2,	c2;	Q{NN} &larr; MD,	c3;	c1;	TT{cnt} &larr; TT, ZeroBr,	c2;	L3Disp, BRANCH[Uloop1, dunPop1],	c3;unbCros:	TOS &larr; TOS + 0FF + 1, CANCELBR[$, 1],	c3;	MAR &larr; [rhTOS, TOS + 0],	c1;	MDR &larr; Rx{allOnes}, TT{cnt} &larr; TT, ZeroBr, GOTO[Uloop3],	c2;	{ E N D }</pre>
  </body>
</html>
