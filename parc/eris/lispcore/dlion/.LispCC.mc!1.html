<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>dlion>LispCC.mc!1</title>
  </head>
  <body>
    <pre>
{File name:  LispCC.mc Last edited by cal  9-Feb-84 17:15:04  fixed for big mem  Descrition: CREATECELL code for Lisp  created by cal  30-Sep-83 12:10:54 }{---------------------------	CREATECELL		tos is smallpos containing Type			if tos not smallpos, goto ufn	    CCSubr entry here:		DTD &larr; DTDSpace + (Type LShift 4)		NewCell &larr; DTD:FREE			if NewCell is NIL, goto ufn		map NewCell			pagefault if NewCell not resident		put zeros to contents of NewCell for  last DTD:SIZE - 2 words		DTD:FREE &larr; contents of (NewCell)			if new DTD:FREE is NIL, signal punt[377]		increment DTD:COUNTER			if DTD:COUNTER goes neg, signal punt[377]		DelRef to NewCell {make RefCnt = 0 }			if gctable overflow entries, signal punt[371]		tos &larr; NewCell			goto punt[377] if appropriate			goto punt[371] if appropriate		next opcode---------------------------}{	This can be used as an opcode or as a subroutine } @CREATECELL:	opcode[37'b],	Ybus &larr; TOSH xor smallpl, ZeroBr, L1 &larr; L1.NoFixes,	c1;	TT &larr; TOS{Type} LRot4, BRANCH[CrCellBadArg, $],	c2;	Q &larr; TT,	c3;	uTOSH &larr; TOSH, L3 &larr; 0{opcode},	c1;	uNewValLo &larr; 0,	c2;	uNewValHi &larr; 0,	c3;		{	CREATECELL SUBROUTINE  --  used at end of floating point opcodes    the following must be setup initially:	initial TOS, TOSH saved in uTOS and uTOSH	uNewValLo and uNewValHi must be loaded with result	Q &larr; (LShift4   Type)	L1 &larr; appropriate map fault fix value {probably L1.fixFV  --  to restore TOS , TOSH}	L3 &larr; 4{fpt} used both here during abnormal exits, and after L1.fixFV	L0 trashed  {set for WLMapFix return}	L2 trashed  {set for GCLookup return}	Subr will page fault if new cell page not resident	TOSH , TOS contain address of new cell at exit	ufn if FreeCell = NIL	uGCPUNT non-zero if CREATECELL has new next cell = NIL or if DTD:COUNTER negative	uGcLov non-zero if GCTableOverflow entries added}CCSubr:{	Q has Type LShift 4 }	rhTT &larr; DTDspace,	c1, at[CCEntry];	TT &larr; DTDbasePage, L0 &larr; L0.RedoMapDTD,	c2;	TT &larr; TT LRot8,	c3; {note: Type may be bigger than 0F }{	Map DTD Page }	Map &larr; TT &larr; [rhTT, TT + Q],	c1;	,	c2;	rhRx &larr; Rx &larr; MD, XwdDisp{XDirtyDisp},	c3;{	fetch DTD:SIZE  FREEhi  FREElo  COUNTER}{	fetch DTD:SIZE}	MAR &larr; [rhRx, Q + DTD.SIZE], DISP2[CCMapDTD],	c1, at[L0.RedoMapDTD,10,WMapFixCaller];	uDtd.RAddr &larr; Rx, CANCELBR[$, CB2],	c2, at[1, 4, CCMapDTD];	TT{DTD.SIZE} &larr; MD,	c3;{	fetch DTD:COUNTER}	MAR &larr; [rhRx, Q + DTD.COUNTER],	c1,;	uDtd.size &larr; TT, CANCELBR[$, CB2],	c2;	TT{DTD.COUNTER} &larr; MD,	c3;{	fetch DTD:FREEhi}	MAR &larr; [rhRx, Q + DTD.FREEhi],	c1,;	uDtd.counter &larr; TT, CANCELBR[$, CB2],	c2;	TT{DTD.FREEhi} &larr; MD,	c3;{	fetch DTD:FREElo}	MAR &larr; [rhRx, Q + DTD.FREElo],	c1,;	uDtd.NewCell.Hi &larr; TT, CANCELBR[$, CB2],	c2;	TT{DTD.FREElo} &larr; MD,	c3;{	BEWARE  --  NewCell may cross a page! {but not 64K} }{	map NewCell }	uDtd.NewCell.Lo &larr; TT,	c1;	UQSave &larr; Q,	c2;	Rx &larr; rhRx,	c3;	urhRx &larr; Rx,	c1;	,	c2;	,	c3;CCMapAgain:	TT &larr; uDtd.NewCell.Lo,	c1;	rhTT &larr; uDtd.NewCell.Hi,	c2;	Ybus &larr; TT or rhTT, ZeroBr,	c3;	Q &larr; uDtd.size, BRANCH[$, CCNewNIL],	c1;	TT &larr; TT + Q,	c2;	TT &larr; TT - 1,	c3; {point TT at last cell word }	Map &larr; [rhTT, TT],	c1;{map cell page}	uGCPUNT &larr; 0, L0 &larr; L0.RedoMapNC,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;{	clear words of cell, starting from highest in case of pgfault during pgcross}	DISP2[DtdMapNC],	c1,at[L0.RedoMapNC,10,WMapFixCaller];	Q &larr; Q - 2,	c2, at[1, 4, DtdMapNC];	Q &larr; Q - 1, NegBr,	c3;	MAR &larr; Rx &larr; [rhRx, TT + 0], BRANCH[CCZloop, CCZdone],	c1  ;NewCellZ:	MAR &larr; Rx &larr; [rhRx, Rx - 1], BRANCH[CCZloop, CCZdone]	c1;CCZloop:	MDR &larr; 0, BRANCH[$, CCZpc, 1], LOOPHOLE[wok],	c2;	Q &larr; Q - 1, NegBr, GOTO[NewCellZ],	c3;CCZpc:	Q &larr; Q + 3,	c3;	,	c1;	GOTO[CCL2pc],	c2;CCL2pc:	uDtd.size &larr; Q, GOTO[CCMapAgain],	c3;CCZdone:{	time to do first two words }	Q &larr; 2, BRANCH[$, CCL2pc, 1],	c2;	Rx &larr; Rx - 1,	c3;{	read and write first two words of cell}{	TOS and TOSH have been unchanged till now }	MAR &larr; Rx &larr; [rhRx, Rx + 0],	c1  ;	MDR &larr; uNewValHi{clear or data},	c2;	TOSH{NewFree.Hi} &larr; MD,	c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1],	c1;	MDR &larr; uNewValLo{clear or data}, CANCELBR[$, CB2], LOOPHOLE[wok],	c2;	TOS{NewFree.Lo} &larr; MD, GOTO[NewCellInitd],	c3;NewCellInitd:{	put old contents of NewCell into DTD:FREE }	Q &larr; UQSave,	c1;	rhRx &larr; urhRx,	c2;	Rx &larr; uDtd.RAddr,	c3;	MAR &larr; [rhRx, Q + DTD.FREEhi],	c1;	MDR &larr; TOSH, CANCELBR[$, CB2], LOOPHOLE[wok],	c2;	uGcLov &larr; 0,	c3;	MAR &larr; [rhRx, Q + DTD.FREElo],	c1,;	MDR &larr; TOS, CANCELBR[$, CB2], LOOPHOLE[wok],	c2;	TT &larr; uDtd.counter,	c3;{	increment DTD.COUNTER }	MAR &larr; [rhRx, Q + DTD.COUNTER],	c1,;	MDR &larr; TT + 1, NegBr, CANCELBR[$, CB2], LOOPHOLE[wok],	c2;	Ybus &larr; TOS or TOSH, ZeroBr, BRANCH[$, Dtd.CounterNeg]	c3;{	prepare for DelRef }Dtd.gcl:	TT &larr; uDtd.NewCell.Lo, BRANCH[$, Dtd.freeNIL],	c1;	{setup for GcLookup:	  Rx &larr; addrHi &amp; 0FF	  TT &larr; addrLo	  uGcLov &larr; 0 {before first call only}	  L2 &larr; subr #	  Q &larr; 0 if addref, 1 if delref, 2 if stkref	  Trashes rhTT and rhRx	  }	Rx &larr; uDtd.NewCell.Hi,	c2;	Rx &larr; Rx and 0FF, L2 &larr; L2.CrCell,	c3;	Q &larr; Q.DelRef, CALL[GcLookup],	c1;	{GcLookup Subroutine here}	TOS &larr; uDtd.NewCell.Lo,	c2,at[L2.CrCell,10,GcLookRet];	TOSH &larr; uDtd.NewCell.Hi,	c3;{	test uGCPUNT and uGcLov here for punts,  uGCPUNT first }	Ybus &larr; uGCPUNT, ZeroBr,	c1;	Ybus &larr; uGcLov, ZeroBr, BRANCH[CrCellGCPunt, $],	c2;	L3Disp, BRANCH[CrCellOvPunt, $],	c3;	PC &larr; PC + PC16, DISP3[ccxit],	c1;CCend:	IBDisp, L2 &larr; L2.0, GOTO[DNI.nop],	c2, at[0, 8, ccxit];FptEnd:	IBDisp, S &larr; S - 2, L2 &larr; L2.0, GOTO[DNI.nop],	c2, at[L3.FptArg1, 8, ccxit];	IBDisp, S &larr; S - 2, L2 &larr; L2.0, GOTO[DNI.nop],	c2, at[L3.FptArg2, 8, ccxit];	IBDisp, L2 &larr; L2.0, GOTO[DNI.nop],	c2, at[L3.Sh, 8, ccxit];{ArithSh}	Xbus &larr; ib,	c2, at[L3.utob, 8, ccxit];{unboxed to boxed}	PC &larr; PC + PC16,	c3;	GOTO[IB.nop],	c1;{	EXCEPTIONS }CrCellBadArg: {only occurs from CREATECELL opcode }	GOTO[ufnX1],	c3;	CANCELBR[WLMapFix, 3],	c2, at[0, 4, CCMapDTD];	CANCELBR[WLMapFix, 3],	c2, at[2, 4, CCMapDTD];	CANCELBR[WLMapFix, 3],	c2, at[3, 4, CCMapDTD];	CANCELBR[WLMapFix, 3],	c2, at[0, 4, DtdMapNC];	CANCELBR[WLMapFix, 3],	c2, at[2, 4, DtdMapNC];	CANCELBR[WLMapFix, 3],	c2, at[3, 4, DtdMapNC];Dtd.CounterNeg: {set uGCPUNT non-zero }	CANCELBR[$],	c1;Dtd.freeNIL: {set uGCPUNT non-zero }	uGCPUNT &larr; S xor ~S,	c2;	GOTO[Dtd.gcl],	c3;CrCellOvPunt:	Rx &larr; AtomGCSCAN {371'b}, L3Disp, CANCELBR[CrCellPunts, 7],	c1;CrCellGCPunt:	CANCELBR[$],	c3;	Rx &larr; AtomGCPUNT {377'b}, L3Disp, GOTO[CrCellPunts],	c1;CrCellPunts:	IB &larr; Rx LRot0, DISP3[CCPuntCases],	c2;CCPuntCC:	L3 &larr; 0{# ib's}, GOTO[CCPuntEnd],	c3, at[0, 8, CCPuntCases];	L3 &larr; 0{# ib's}, GOTO[CCPuntEnd],	c3, at[1, 8, CCPuntCases];	L3 &larr; 0{# ib's}, GOTO[CCPuntEnd],	c3, at[2, 8, CCPuntCases];	L3 &larr; 0{# ib's}, GOTO[CCPuntEnd],	c3, at[3, 8, CCPuntCases];CCPuntFpt:	S &larr; S - 2, L3 &larr; 0{# ib's}, GOTO[CCPuntEnd],	c3, at[L3.FptArg1, 8, CCPuntCases];	S &larr; S - 2, L3 &larr; 0{# ib's}, GOTO[CCPuntEnd],	c3, at[L3.FptArg2, 8, CCPuntCases];	L3 &larr; 0{# ib's}, GOTO[CCPuntEnd],	c3, at[L3.Sh, 8, CCPuntCases];	L3 &larr; 1{# ib's}, GOTO[CCPuntEnd1],	c3, at[L3.utob, 8, CCPuntCases];CCPuntEnd:	MAR &larr; Q &larr; [rhS, S + 1], IBPtr &larr; 0, GOTO[FN1Ext],	c1;CCPuntEnd1:	MAR &larr; Q &larr; [rhS, S + 1], IBPtr &larr; 0, GOTO[FN1Ext],	c1;CCNewNIL:	L3Disp,	c2;	BRANCH[CCnnoc, CCnnfpt, 3],	c3;CCnnoc:	GOTO[ufnX2],	c1;CCnnfpt:	{here only from CCSubr calls  --  not opcode}	GOTO[ufnZ2],	c1;{	before page fault TOS, TOSH restored before here }	GOTO[FptPgFlt],	c3, at[L3.FptArg1,10,fvfixup];	GOTO[FptPgFlt],	c3, at[L3.FptArg2,10,fvfixup];	GOTO[FptPgFlt],	c3, at[L3.Sh,10,fvfixup];	GOTO[FptPgFlt],	c3, at[L3.utob,10,fvfixup];FptPgFlt:	GOTO[NoMoreFix],	c1;	{ E N D }</pre>
  </body>
</html>
