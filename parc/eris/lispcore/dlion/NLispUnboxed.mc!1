{	NLispUnboxed.mc }{	in bank 1@UNBOX1:	opcode[354'b],	Bank _ LUBank, L0 _ L0.UnBoxed,	c1;	uTOS _ TOS,	c2;	uTOSH _ TOSH, CROSS[UB1Start],	c3;@UNBOX2:	opcode[355'b],	Bank _ LUBank, L0 _ L0.UnBoxed,	c1;	uTOS _ TOS,	c2;	uTOSH _ TOSH, CROSS[UB2Start],	c3;	end in bank 1 }	at[UB2Start],	Xbus _ ibNA, XDisp, L3 _ L3.UB2Q2,	c1;	Q _ 0FF, DISP4[ub2op],	c2;	L2 _ L2.Fplus,	c3, at[ib.UF2.add, 10, ub2op];	MAR _ [rhS, S - 1], GOTO[ub2cont],	c1;	L2 _ L2.Fdiff,	c3, at[ib.UF2.sub, 10, ub2op];	MAR _ [rhS, S - 1], GOTO[ub2cont],	c1;	L2 _ L2.Fidiff,	c3, at[ib.UF2.isub, 10, ub2op];	MAR _ [rhS, S - 1], GOTO[ub2cont],	c1;	L2 _ L2.Ftimes,	c3, at[ib.UF2.mult, 10, ub2op];	MAR _ [rhS, S - 1], GOTO[ub2cont],	c1;	TT _ TOSH LRot1, L2 _ L2.Fquot, GOTO[ub2Qcont2]	c3, at[ib.UF2.div, 10, ub2op];	L2 _ L2.Fgreat,	c3, at[ib.UF2.great, 10, ub2op];	MAR _ [rhS, S - 1], GOTO[ub2cont],	c1;	L2 _ L2.Fmax,	c3, at[ib.UF2.max, 10, ub2op];	MAR _ [rhS, S - 1], GOTO[ub2cont],	c1;	L2 _ L2.Fmin,	c3, at[ib.UF2.min, 10, ub2op];	MAR _ [rhS, S - 1], GOTO[ub2cont],	c1;{	MAR _ [rhS, S - 1],	c1; }ub2cont:	uArg2Hi _ TOSH, CANCELBR[$, 2],	c2;	TOSH _ MD,	c3;	MAR _ [rhS, S + 0], L0 _ L0.UnBoxed,	c1;	uArg2Lo _ TOS, CANCELBR[$, 2],	c2;	TOS _ MD,	c3;	Rx _ 0FF + 1, GOTO[fptprep],	c1;	{ quotient stuff }	at[L3.UB2Q2, 10, fptQ2ret],	Rx _ TT LRot8 and Q, {exponent}, GOTO[ub2Qcont1],	c1;	at[L3.FunUFirst, 10, fptQdone],	Xbus _ ib, GOTO[c1.pc2B2],	c3;{	in bank 1@UNBOX1:	opcode[354'b],	Bank _ LUBank, L0 _ L0.UnBoxed,	c1;	uTOS _ TOS,	c2;	uTOSH _ TOSH, CROSS[UB1Start],	c3;	end bank 1 }	at[UB1Start],	Xbus _ ibNA, XDisp,	c1;	DISP4[UB1fn], FloatNop,	c2;		{unboxed to boxed}	at[ib.UF1.utob, 10, UB1fn],	uNewValLo _ TOS, L1 _ L1.fixFV,	c3;	Bank _ EmuBank,	c1;	uNewValHi _ TOSH, L3 _ L3.utob,	c2;	Q _ LS4FptType, CROSS[CCEntry],	c3;		{abs of unboxed}	at[ib.UF1.abs, 10, UB1fn],	Rx _ RShift1 Rx xor ~Rx, SE _ 0,	c3;	TOSH _ TOSH and Rx,	c1;UBSend:	Xbus _ ib,	c2;	GOTO[c1.pc2B2],	c3;		{neg of unboxed}	at[ib.UF1.neg, 10, UB1fn],	Rx _ RShift1 0, SE _ 1,	c3;	TOSH _ TOSH xor Rx, GOTO[UBSend],	c1; 		{boxed to unboxed}	at[ib.UF1.btou, 10, UB1fn],	L3 _ L3.btou, FloatNop,	c3;	FloatNop,	c1;	CALL[FloatIt],	c2;	at[L3.btou, 10, FloatItRet],	Xbus _ ib,	c1;	,	c2;	GOTO[c1.pc2B2].	c3;