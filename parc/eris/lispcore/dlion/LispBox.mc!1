{LispBox.mcLast edit: by don 16-Feb-84 10:35:14 fixed for big memCreated:  29-Nov-83 15:36:28 by don}SetTask[0];{- - - - - - - - - - - - - - - - - - - - - - - - - -  #      name        len-1    stk level effect   UFN table entry366	BOXIPLUS     0        -1                 \BOXIPLUS367	BOXIDIFFERENCE  0     -1                 \BOXIDIFFERENCESame as IPLUS2, IDIFFERENCE, except store result @tos {stack - 1} -- first arg isnumber box (for which optionally check) -- and no overflow check.- - - - - - - - - - - - - - - - - - - - - - - - - -}@BOXIPLUS:	opcode[366'b],	MAR _ [rhS, S + 0], L2 _ L2.boxiplus,	c1;	uTOSH _ TOSH, GOTO[BoxComStart],	c2;	TOS _ Rx + TOS, CarryBr,	c3, at[L2.boxiplus, 10, ArithDOp]; {boxplus}	L3Disp, BRANCH[$, ArithBoxAddCar],	c1;	TOSH _ TT + TOSH, DISP4[ArithBoxCom],	c2;ArithBoxAddCar:	TOSH _ TT + TOSH + 1, DISP4[ArithBoxCom],	c2;@BOXIDIFFERENCE:	opcode[367'b],	MAR _ [rhS, S + 0], L2 _ L2.boxidiff,	c1;	uTOSH _ TOSH, GOTO[BoxComStart],	c2;BoxComStart:	Rx _ MD, uTOS _ TOS, L3 _ L3.FptArg1,	c3;	Q _ TOSH and 0FF,	c1;	Ybus _ Q xor smallpl, ZeroBr,	c2;	Ybus _ Q xor smallneg, ZeroBr, BRANCH[$, ArithBoxPos],	c3;	BRANCH[ArithBoxnotsmall, ArithBoxNeg],	c1;ArithBoxPos:	TOSH _ 0, CANCELBR[$],	c1;	,	c2;	GOTO[ArithA1done],	c3;ArithBoxNeg:	TOSH _ TOSH xor ~TOSH,	c2;	GOTO[ArithA1done],	c3;ArithBoxnotsmall:	,	c2;	GOTO[ArithBoxE],	c3;	TOS _ Rx - TOS, CarryBr,	c3, at[L2.boxidiff, 10, ArithDOp]; {boxdiff}	L3Disp, BRANCH[$, ArithBoxSubCar],	c1;	TOSH _ TT - TOSH - 1, DISP4[ArithBoxCom],	c2;ArithBoxSubCar:	TOSH _ TT - TOSH, DISP4[ArithBoxCom],	c2;	GOTO[ufnZ1],	c3, at[L3.FptArg1, 10, ArithBoxCom];	TT _ uChain,	c3, at[L3.FptArg2, 10, ArithBoxCom];	Map _ [rhTT, TT], L0 _ L0.RedoBox,	c1;	Q _ rhTT,	c2;	rhRx _ Rx _ MD, XwdDisp{XDirtyDisp},	c3;	MAR _ [rhRx, TT + 0], DISP2[ArithBoxMap],	c1, at[L0.RedoBox, 10, WMapFixCaller];	MDR _ TOSH,	c2, at[1, 4, ArithBoxMap];	TOSH _ Q,	c3;	MAR _ [rhRx, TT + 1],	c1;	MDR _ TOS, CANCELBR[$, CB2], LOOPHOLE[wok],	c2;	TOS _ TT,	c3;	S _ S - 2, GOTO[IB.pc1],	c1;	GOTO[WLMapFix],	c2, at[0, 4, ArithBoxMap];	GOTO[WLMapFix],	c2, at[2, 4, ArithBoxMap];	GOTO[WLMapFix],	c2, at[3, 4, ArithBoxMap];	{ E N D }