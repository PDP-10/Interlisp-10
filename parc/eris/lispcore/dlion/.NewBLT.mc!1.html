<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>dlion>NewBLT.mc!1</title>
  </head>
  <body>
    <pre>
{File name NewBLT.mcDescription: new BLT codeAuthor: CharnleyCreated:  9-Jun-83 11:01:00Last edit by Charnley:    20-Jul-83 10:44:09}SetTask[0];{*******************************************************************	BLT {daddr, saddr, nwords}********************************************************************}{	this code uses a two click inner loop to transfer words.	the loop is exited when either the source or the dest	cross a page boundary {and require remapping}	or the required number of words has been moved.	a test for pending interrupts is performed whenever	the source is remapped {care must be taken to 	ignore uPCCrossL}	AT ENTRY	tos  :  number of words	tos-1:  virtual address of first source word	tos-2:  virtual address of first dest word	AT INTERRUPT EXIT	tos  :  number of words remaining	tos-1:  virtual address of first source word	tos-2:  virtual address of first dest word	AT COMPLETION EXIT	stkcnt &larr; stkcnt - 2}{	REGISTER USAGE	Within Inner Loop:	  Q		cnt of words to go	  TOSH	Src Real Address	  TOS	Dst Real Address	  TT		Move Data	  rhTOSH	High Src Real Address	  rhTOS	High Dst Real Address}{	BLTInnerLoop }BLTS1:	MAR &larr; {SrcRA}TOSH &larr; [rhTOSH,TOSH - 1], BRANCH[BLTdone, $],	c1;BLTS2:	BRANCH[$, BLTSrcRemap, 1],	c2;BLTS3:	{Data}TT &larr; MD,	c3;BLTD1:	MAR &larr; {DstRA}TOS &larr; [rhTOS, TOS - 1],	c1;BLTD2:	uSaveTT &larr; MDR &larr; {Data}TT, BRANCH[$, BLTDstRemap, 1],	c2;BLTD3:	Q{BLTcnt} &larr; Q - 1, CarryBr, GOTO[BLTS1],	c3;{	Loop Exits}BLTSrcRemap:	{restore state first}	uSaveTOS &larr; TOS, L2 &larr; 1,	c3;{save DstRA, set L2 for Src Remap}{	test for interrupt}	TOS &larr; Q + 1, L1 &larr; L1.NoFixes,	c1;{restore TOS}	Ybus &larr; Q and ~0F, ZeroBr,	c2;{small counts don't interrupt}	TOSH &larr; smallpl, MesaIntBr, BRANCH[$, BLTnoint0],	c3;{restore TOSH}	Ybus &larr; uWDC, NZeroBr, BRANCH[BLTnoint1, $],	c1;	Ybus &larr; uWP, ZeroBr, BRANCH[$, BLTnoint2],	c2;	uWP &larr; 0, BRANCH[BLTIntNow, BLTnoint3],	c3;BLTIntNow:	ClrIntErr, Rx &larr; 1,	c1;	uWDC &larr; Rx,{off interrupts}	c2;	Rx &larr;  KbdFXP, L2 &larr; 0, GOTO[PUNT],	c3;BLTnoint1:	CANCELBR[$],	c2;BLTnoint2:	CANCELBR[BLTRemap],	c3;BLTSrc:	{BLTRemap returns here}	Rx &larr; rhRx &larr; MD, XRefBr,	c3;	Q &larr; rhRx, BRANCH[BLTSMap, $],	c1,at[L0.RedoBLT,10,RxMapFixCaller];{move rhRx,,Rx to rhTOSH,,TOSH}	rhTOSH &larr; Q LRot0,	c2;	TOSH &larr; Rx,	c3;	Q &larr; TOS - 1,	c1;{restore loop count}	TOS &larr; uSaveTOS,	c2;{restore DstRA}	c3;	MAR &larr; {SrcRA}TOSH &larr; [rhTOSH, TT + 0], GOTO[BLTS2],	c1;BLTSMap:	CALL[RLxMapFix],	c2;BLTDstRemap:{	restore state, prepare for Remap}	uSaveTOSH &larr; TOSH, L2 &larr; 3,	c3;{save SrcRA, set L2 for Dst Remap}	TOS &larr; Q + 1, L1 &larr; L1.PushOnly,	c1;{restore TOS}	TOSH &larr; smallpl,	c2;{restore TOSH}	S &larr; S - 2, GOTO[BLTRemap],	c3;{point stack at Dest}	BLTDst:	{BLTRemap returns here}	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;	Q &larr; rhRx, DISP2[BLTDMap],	c1,at[L0.RedoBLT,10,WMapFixCaller];	rhTOS &larr; Q LRot0,	c2, at[1, 4, BLTDMap];{move rhRx,,Rx to rhTOS,,TOS}	Q &larr; TOS - 1,	c3;{restore loop count}	TOS &larr; Rx,	c1;	TOSH &larr; uSaveTOSH,	c2;{restore SrcRA}	S &larr; S + 2,	c3;{restore stack}	MAR &larr; {DstRA}TOS &larr; [rhTOS, TT + 0],	c1;	MDR &larr; uSaveTT, GOTO[BLTD3],	c2;{store saved data}BLTDMap:	CALL[WLMapFix],	c2, at[0, 4, BLTDMap];	CALL[WLMapFix],	c2, at[2, 4, BLTDMap];	CALL[WLMapFix],	c2, at[3, 4, BLTDMap];{****************************************************}BLTnoint0:	MAR &larr; [rhS, S + 0], L0 &larr; L0.RedoBLT, CANCELBR[BLTReX],	c1;BLTnoint3:	MAR &larr; [rhS, S + 0], L0 &larr; L0.RedoBLT, CANCELBR[BLTReX],	c1;{	Remap Subroutine }BLTRemap:	MAR &larr; [rhS, S + 0], L0 &larr; L0.RedoBLT,	c1;BLTReX:	TOS &larr; TOS - 1, CarryBr,	c2;	TT &larr; MD{addr}, L2Disp, BRANCH[BLTdone1, $],	c3;	MAR &larr; [rhS, S - 1], BRANCH[$, BLTsavedest, 1],	c1;	TT &larr; TT + TOS, CarryBr, CANCELBR[$, 2],	c2;	rhTT &larr; MD{addrH}, BRANCH[BLT64NoCross, BLT64Cross],	c3;BLTsavedest:	uTOS &larr; TT, CANCELBR[$, 2],	c2;	Q &larr; rhTT &larr; MD,	c3;	uTOSH &larr; Q,	c1;	TT &larr; TT + TOS, CarryBr,	c2;	BRANCH[BLT64NoCross, BLT64Cross],	c3;BLT64Cross:	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c1;	rhTT &larr; Q LRot0,	c2;	GOTO[BLT64NoCross],	c3;BLT64NoCross:	Map &larr; [rhTT,TT], L2Disp,	c1;	TOS &larr; TOS + 1, BRANCH[BLTSrc, BLTDst, 1],	c2;{restore count}{****************************************************}BLTdone1:	CANCELBR[$, 3],	c1;	TOSH &larr; uTOSH, GOTO[BLTdone2],	c2;BLTdone:	TOSH &larr; uTOSH, CANCELBR[$, 2],	c2;BLTdone2:	TOS &larr; uTOS,	c3;	PC &larr; PC + PC16,  MesaIntRq,	c1;	S &larr; S - 4, IBDisp, L2 &larr; L2.0, GOTO[DISPNIonly],	c2;BLTufn:	 Rx &larr; 304'b, GOTO[ufn2],	c1;@BLT:	uSaveTOS &larr; 0, L2 &larr; 1,	c1, opcode[304'b];	Ybus &larr; TOSH xor smallpl, ZeroBr, L1 &larr; L1.NoFixes,	c2;	rhTOS &larr; 0, BRANCH[BLTufn, BLTRemap],	c3;	{ E N D }</pre>
  </body>
</html>
