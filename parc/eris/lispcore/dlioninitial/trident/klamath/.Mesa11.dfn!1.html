<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DlionInitial>Trident>Klamath>Mesa11.dfn!1</title>
  </head>
  <body>
    <pre>
{File name:  Mesa.dfn Description: Non-Register Definitions for Dandelion Mesa Emulator Microcode, Created: November 18, 1980, Last Edited:Daniels 27-Sep-83 14:28:59: Added L0.IOCopy for DicentraGrundler 20-Sep-83 20:47:45: Renamed to .dfnDaniels 14-Sep-83 16:18:01: Change L0.CLRead for XferAmy Fasnacht 18-Jul-83 14:52:58: Change L0 constants for WLMFRetDaniels 27-Jun-83 11:18:05: Changed defs for 32-bit control links and Klamath instruction set shuffle.Amy Fasnacht 22-Dec-82 10:50:59: Add BLTLR constant definitionFay July 6, 1982  3:47 PM: Added SrcMap return point MapSrcBandBLT for BandBLTBBInit.Jim Sandman October 14, 1981  3:59 PM: Change for new instruction setJim Frandeen March 11, 1981  2:56 PM: Change BLDest and BLDestR for ChecksumJim Frandeen March 4, 1981  4:55 PM: Add entry to RMapFixCallerJim Frandeen February 17, 1981  5:02 AM: changes to RMapFixCaller, WMapFixCaller, RFixForTrap, WFixForTrap for new BlockSandman, February 2, 1981  1:11 PMSandman, January 20, 1981  4:48 PMJim Frandeen January 8, 1981  10:41 AM}{Mesa SD offsets (from SDDefs.mesa)}Set[sBreak, 0'b];Set[sBoot, 1'b];  {@SD[sBoot] MOD 4 = 2!!!}Set[sStackError, 2'b];Set[sRescheduleError, 3'b];Set[sXferTrap, 4'b];Set[sOpcodeTrap, 5'b];Set[sControlTrap, 6'b];Set[sCodeTrap, 7'b];Set[sHardwareError, 10'b];Set[sUnbound, 11'b];Set[sDivZeroTrap, 12'b];Set[sDivCheckTrap, 13'b];Set[sInterruptError, 14'b];Set[sProcessTrap, 15'b];Set[sBoundsTrap, 16'b];Set[sPointerTrap, 17'b];{Fault queue pointers used for Faults}Set[qFrameFault, 60'b];Set[qPageFault, 62'b];Set[qWriteProtect, 64'b];{Xfer value used for Traps}Set[L2.TRAPSpc,0A];{flag value used for Interrupts and Faults}Set[pInt, 47]; {also in Process}Set[pFault, 3]; {also in Process}{StateVector definition}Set[State.word, 16'b];Set[State.frame, 17'b];Set[State.data, 20'b];Set[State.datam1, 17'b];Set[cSS, 16'b];Set[cSSm1, 15'b];Set[cSSm2, 14'b];Set[cSSp1, 17'b];{Local Frame definition}Set[LF.word, 4];Set[LF.returnLink, 3];Set[LF.globalLink, 2];Set[LF.pc, 1];{Global Frame definition}Set[GF.word, 3];Set[GF.codeLow, 2];Set[GF.codeHi, 1];{Link Codes for Common Subroutines}{L0	RMFRtn}MacroDef[RMFRet, at[#1,10,RMFRtn]];Set[L0.R, 0];{must be even}Set[L0.XRead, 1];Set[L0.RD, 2];{must be even}Set[L0.RD, 4];{must be even}Set[L0.DBS, 5];Set[L0.LGCRead, 6];{must be even; paired with L0.LGCSameG}Set[L0.LGCSameG, 7];{must be odd; paired with L0.LGCRead}Set[L0.ERefill, 8];  {must be even} Set[L0.XPRead, 0C];{must be even, Same as RLMFRtn}Set[L0.NERefill, 0A];  {must end with 01}	Set[L0.NERefill.Set, 8];  {must end with 00}	Set[WhichFixType, 0B];  {used to distinquish between Refill &amp; JRemap}Set[L0.XCode, 0E];{must be even}Set[L0.JRemap, 0F]; {must be 0F}{L0	RLMFRtn}MacroDef[RLMFRet, at[#1,10,RLMFRtn]];Set[L0.RL, 0];{must be even}Set[L0.RF, 1];Set[L0.RS, 2];{must be even}Set[L0.RLFS, 3];Set[L0.BLSource, 5]; Set[L0.RDL0, 6];{must be even}Set[L0.RDL1, 8];{must be even}Set[L0.JI, 0B];Set[L0.CLRead, 0C];{must be even; Same as RMFRtn}Set[L0.BLDestR, 0E]; {must be E}{L0	WMFRtn}MacroDef[WMFRet, at[#1,10,WMFRtn]];Set[L0.WS, 0];Set[L0.W, 1];{1 MOD 4}Set[L0.PO, 2];Set[L0.PI, 3];Set[L0.FF, 4];Set[L0.WL, 5];{1 MOD 4}Set[L0.XWrite, 6];Set[L0.Alloc1, 7];Set[L0.Alloc2, 8];Set[L0.WD, 9];{1 MOD 4}Set[L0.Xfer, 0C];{must be 0C}Set[L0.Free, 0D];{1 MOD 4}{L0	WLMFRtn}MacroDef[WLMFRet, at[#1,10,WLMFRtn]];Set[L0.WDB, 0]; {0 MOD 2}Set[L0.WLS, 1]; {1 MOD 4}Set[L0.WLFS, 3]; {1 MOD 2}Set[L0.WF, 5]; {1 MOD 4}Set[L0.ME, 7]; {1 MOD 2}Set[L0.WL, 9]; {1 MOD 4}Set[L0.WDL, 0D]; {1 MOD 4}Set[L0.IOCopy, 0E]; {for Dicentra}Set[L0.BLDest, 0F]; {must be same as L0.BLDest for RMapFixCaller, must = F}{L1	Common TrapFix}Set[L1.None, 0];	{JIB,JIW,PLD0,PSDLB,WLDILP}Set[L1.Restore, 1];	{must be 1 mod 2, Block.mc}Set[L1.Xfer, 2];	{Xfer.mc}Set[L1.Dec, 3];		{SLn,Rn,RDLn,R0F,W0F,WS0F,LLOB,RKIB,RKDIB}Set[L1.Dec2, 4];	{SLB,SGB,RB,RDLB,RF,WF,PSB,WLIP,DBS,FF,DSK}Set[L1.PopDec2, 5];	{LLB,LGB,PLB,PLDB,RDB,RxIP,RxILP,RLIPF,RLILPF,LGMap}Set[L1.PopDec, 6];	{LLn,LGn,RLI0n,RD0,PS0F}Set[L1.Pop2Dec, 7];	{LLDn,LGDn,RLDI00,PSF,PSLF}{L1	RTrapFix}Set[L1.Pop2Dec2, 8];	{0 mod 2; = L2.RDL; also RLTrapFix; LxGB,RLDIP,RKDIB}Set[L1.Refill, 9];	{Refill.mc}{L1	RLTrapFix}{Set[L1.Pop2Dec2, 8];	{also RTrapFix; RLDILP,RKDIB}}Set[L1.Push2, 9];	{also WTrapFix; RLS,RLFS}Set[L1.PushDec, 0A];	{also WTrapFix; RL0,RL0F,RCFS}Set[L1.PushDec2, 0B];	{also WTrapFix; RLB,RLF}Set[L1.Push, 0C];	{also WTrapFix; RS}Set[L1.Dec3, 0D];	{RC,ROB}{L1	WTrapFix}Set[L1.PushInc, 8];	{PSD0}{Set[L1.Push2, 9];	{also RLTrapFix; WLS,WLFS,WDB,WDLB}}{Set[L1.PushDec, 0A];	{also RLTrapFix; SLDn,WL0F,W0}}{Set[L1.PushDec2, 0B];	{also RLTrapFix; SLDB,SGDB,WLF,WB}}{Set[L1.Push, 0C];	{also RLTrapFix; SLDn,SLDB,SGDB,WS,WLB,PSDB}}Set[L1.Pop, 0D];	{PSLB,WLILP}Set[L1.PushDec3, 0E];	{WOB}{L2	MaskRet}{Stack}Set[L2.SSBInv, 0 ];Set[L2.SSBNorm, 1 ];Set[L2.Rotate, 2 ];{TextBlt}Set[maskRet.flags,3];{Field}Set[L2.RF, 4 ];Set[L2.WF0, 5 ];Set[L2.WF1, 6 ];{BitBlt}Set[maskRet.fQ, 9 ],Set[maskRet.f1, 0E],Set[maskRet.f2, 0D],Set[maskRet.bQ, 0C],Set[maskRet.b1, 0B],Set[maskRet.b2, 0A],{L0	IPRtn}MacroDef[IPRet, at[#1,10,IPRtn]];Set[L0.RLIPF, 4];Set[L0.RLIP, 5];Set[L0.RLDIP, 6];Set[L0.RGIP, 7];Set[L0.WLIP, 8];{L0	ILPRtn}MacroDef[ILPRet, at[#1,10,ILPRtn]];Set[L0.RLILPF, 9];Set[L0.RLILP, 0A];Set[L0.RLDILP, 0B];Set[L0.RGILP, 0C];Set[L0.WLILP, 0D];Set[L0.WLDILP, 0E];{L2	LGMRtn}MacroDef[LGMRet, at[#1,10,LGMRtn]];Set[L2.LIP, 1];  Set[L2.LIPx, Or[L2.LIP, 2]];Set[L2.LILP0, 5];  Set[L2.LILP0x, Or[L2.LILP0, 2]];Set[L2.LILP1, 8]; {must be 0 mod 2}Set[L2.LILP1x, 9]; {must be L2.LILP1 or 1}Set[L2.GILP0, 0D];  Set[L2.GILP0x, Or[L2.GILP0, 2]];{L2	VAHiInc}MacroDef[VAHiRet, at[#1,10,VAHiRtn]];Set[L2.WDL, 0]; {must be 0; must be even, someone in odd pair}Set[L2.RDL, 8]; {Same as L1.Pop2Dec2; must be even, someone in odd pair}Set[L2.WL, 4]; {must be even, someone in odd pair}Set[L2.WLF, 6]; {must be even, someone in odd pair}Set[L2.xSL, 0E]; {must be even, someone in odd pair}Set[L2.RLF, 0A]; {must be even, someone in odd pair}Set[L2.RLFS, 0C]; {must be even, someone in odd pair}Set[L2.WLFS, 2]; {must be even, someone in odd pair}{L3	Holds VA location for faults	Bit 0: 0 =&gt; Q,     1 =&gt; TT	Bit 1: 0 =&gt; rhMDS, 1 =&gt; rhTT}Set[L3.rhMDS.Q, 0];Set[L3.rhMDS.TT, 1];Set[L3.rhTT.Q, 2];Set[L3.rhTT.TT, 3]; {must be 3 for IBEmptyTrap}Set[OpcodeBase, 500];MacroDef[opcode, at[Add[#1, OpcodeBase]]];MacroDef[alpha.left, ibHigh];MacroDef[fd.pos, ibHigh];MacroDef[alpha.right, ibLow];MacroDef[fd.size, ibLow];MacroDef[AlwaysIBDisp, (IBDisp, IBPtr&larr;1)];{XFER stuff}{StashPC returns - Link 2}MacroDef[SPCr, at[#1,10,SpcRtn]];Set[L2.EFCnSpc,0];Set[L2.EFCBSpc,1];Set[L2.LFCSpc,2];Set[L2.KFCBSpc,3];Set[L2.SFCSpc,4];Set[L2.POSpc,5]; {also XWr}Set[L2.XSpc,7];Set[L2.BRKSpc,8];Set[L2.RSSpc,9];Set[L2.TRAPSpc,0A];  {0 MOD 2}Set[L2.FAULTSpc,0B]; {1 MOD 2; paired with L2.TRAPSpc and L3.XFault}Set[L2.ESCSpc,0C];{XferType}Set[XferType.ret,0];Set[XferType.call,1];Set[XferType.lfc,2];Set[XferType.port,3];Set[XferType.xfer,4];Set[XferType.trap,5];Set[XferType.pSwitch,6];{rhT encoding:	Bit	Meaning	8	stack must be pushed twice	9-10	amount to backup PC if trap occurs	11	PC saved in UreturnPC if need to backup PC	13	indirect xfer	14	0: trap, 1: LSTF/RET/Call/SFC/PO/pswitch	15	free frame}Set[xtTrap, Or[Lshift[0,5],Lshift[0,1]]];Set[xtX, Or[Lshift[3,5],Lshift[1,1]]];Set[xtFC0, 2 {Or[Lshift[0,5],Lshift[1,1]]}];Set[xtFC1, Or[Lshift[1,5],Lshift[1,1]]];Set[xtFC2, Or[Lshift[2,5],Lshift[1,1]]];Set[xtFC3, Or[Lshift[3,5],Lshift[1,1]]];Set[xtXF, Or[Lshift[3,5],Lshift[1,1], 1]];Set[xtRET, Or[Lshift[0,5],Lshift[1,1], 11]];Set[xtSFC1, Or[Lshift[1,5],Lshift[1,1], 80]];Set[xtSFC2, Or[Lshift[2,5],Lshift[1,1], 80]];Set[xtAF, 07F];Set[xtPSwitch, Lshift[1,1]];{Block and BitBlt stuff}{constant and macro definitions for BitBlt}		{gray (gr) values}Set[gr.gray,1],Set[gr.notgray,5],Set[gr.mask,1],Set[grM,8],		{source function (sf) values}Set[sf.true,4],Set[sf.comp,5],Set[sf.mask,4],Set[sfM,8],		{direction (dir) values}Set[dir.forward,6],Set[dir.backwards,0E],Set[dirM,10],		{dest function (df) values}Set[df.null,8],Set[df.and,0A],Set[df.or,0C],Set[df.xor,0E],Set[dfM,10],		{srcdst function (sd) values}Set[sd.src,0],Set[sd.dst,1],Set[sd.spec,2],Set[sdM,4],{Return points for RestoreRandRHRegs}MacroDef[RestoreBlockRegsRet,at[#1,10,RestoreCallers]];Set[restore.term, Sub[grM,1] ],{MUST BE Sub[grM,1]}Set[restore.int, 0 ],{restore if interrupt }Set[restore.pf, 2 ],{restore if page fault}Set[restore.trap,3]; {used by Block if trap}Set[restore.BandBLT, 6]{used by BandBLT for at BandBLT's point of return to emulator};Set[BLTfini,0F]; {used by Block, must = F}Set[BLEQfini,0E]; {used by Block, must = E}{Return points for DstVAMod}MacroDef[DstVAModRet,at[#1,4,DstVAModRet]];Set[sdWidth, 2 ],{for DstVAMod and SrcVAMod}Set[sdBpl, 1 ],{ DstVAMod and SrcVAMod}Set[Dest,3], {for TextBlt to call DstVAMod}{Return points for SrcMap}MacroDef[SrcMapSpecRet,at[#1,10,SrcMapRet]];Set[sdMap, 0 ],{for SrcMap and DstMap}Set[argMap, 1 ],{for mapping BitBltArg}Set[MapOne, 2 ],{for SrcMap and DstMap}Set[MapArg, 3 ], {for TextBlt to map TextBltArg}Set[MapSrcBandBLT, 4 ], {for BandBLTBBInit SrcMap}Set[Fetch, 5 ], {for TextBlt FetchVS subroutine}Set[MapFont, 7 ], {for TextBlt to map FontBody pointer, must be 7}{Return points for SaveRandRHRegs}MacroDef[SaveBlockRegsRet,at[#1,10,SavebbRegsRet]];MacroDef[SavebbRegsRet,at[#1,10,SavebbRegsRet]];Set[Savebb.BitBlt,0]; {Return from SavebbRegs for BitBlt, must = 0}Set[BLT,3]; { Block Transfer, must = 3}Set[BLTL,7]; {Block Transfer Long, must = 7}Set[BLEL,6]; {Block Equal Long, must = 6}Set[BLTLR,5]; {Block Transfer Long Reverse, must = 5}Set[BLECL,0E]; {Block Equal Code Long, must = E}Set[BLTC,0B]; {Block Transfer Code, must = 0B}Set[BLTCL,0F]; {Block Transfer Code Long, must = 0F}Set[CKSUM,4]; {Checksum  must = 4}Set[Savebb.BLT,BLT]; {Return from SavebbRegs for BLEQ (Block Transfer), must = 3}Set[Savebb.BLTL,BLTL]; {Return from SavebbRegs for BLTL (Block Transfer Long), must = 7}Set[Savebb.BLEL,BLEL]; {Return from SavebbRegs for BLEL (Block Equal Long), must = 6}Set[Savebb.BLECL,BLECL]; {Return from SavebbRegs for BLECL (Block Equal Code Long), must = E}Set[Savebb.BLTC,BLTC]; {Return from SavebbRegs for BLTC (Block Transfer Code), must = 0B}Set[Savebb.BLTCL,BLTCL]; {Return from SavebbRegs for BLTCL (Block Transfer Code Long), must = 0F}Set[Savebb.CKSUM,CKSUM]; {Return from SavebbRegs for CKSUM (Checksum)  must = 4}Set[Savebb.BANDBLT,0C]; {Return from SavebbRegs for BandBlt}Set[Savebb.TXTBLT,0D]; {Return from SavebbRegs for TextBlt}Set[hbs.0, Or[ Xor[0F, 0] , 6 ] ];Set[hbs.1, Or[ Xor[0F, 1] , 6 ] ];Set[hbs.2, Or[ Xor[0F, 2] , 6 ] ];Set[hbs.A, Or[ Xor[0F, 0A] , 6 ] ];Set[hbs.B, Or[ Xor[0F, 0B] , 6 ] ];Set[hbs.C, Or[ Xor[0F, 0C] , 6 ] ];Set[hbs.D, Or[ Xor[0F, 0D] , 6 ] ];MacroDef[scDisp,L0Disp],MacroDef[dfDisp,L1Disp],MacroDef[dirDisp,L1Disp],MacroDef[sdDisp,L2Disp];MacroDef[sfDisp,L3Disp],MacroDef[grDisp,L3Disp];MacroDef[sc1DISP,DISP4[#1,0E]],MacroDef[sc2DISP,DISP4[#1,03]],MacroDef[sc3DISP,DISP4[#1,0D]],MacroDef[dirDISP,DISP4[#1,6]],MacroDef[dfDISP,DISP4[#1,8]],MacroDef[sfDISP,DISP3[#1,sf.mask]],MacroDef[grDISP,DISP3[#1,gr.mask]];MacroDef[sdDISP,DISP2[#1]];Set[SRaRet, 2 ],{rhRet value for SrcLRemap}Set[SRcRet, 3 ],{rhRet value for SrcLRemap}Set[DRaRet, 02 ],{rhRet value for DstLRemap}Set[DRbRet, 03 ],{rhRet value for DstLRemap}Set[ret.L1pcr, 08 ],{rhRet value for DstLRemap}Set[ret.L2pcr, 09 ],{rhRet value for DstLRemap}Set[ret.L1Tpcr, 0A ],{rhRet value for DstLRemap}Set[StkSize.normal, 1 ],{used for HowBigStack}Set[StkSize.interrupt, 7 ],{used for HowBigStack}Set[Type.normal, 0 ],{value in rhType}Set[Type.LSEP, 1 ],{value in rhType}Set[Type.TextBlt,4], {value in rhType tells what to do if page fault}Set[type.notsmall,7],Set[type.small,5],Set[typeM,8],Set[dtRet.L0, 0 ],{constant value for dT}Set[dtRet.L1, 1 ],{constant value for dT}Set[dtRet.L3, 3 ],{constant value for dT}Set[dtRet.L4, 4]{used by BandBLT for dT};Set[VAaRet, 0 ],{rhRet value for VAModSub}{even, &lt; 8}Set[VAbRet, 2 ],{rhRet value for VAModSub}{even, &lt; 8}Set[srcTP, 4 ],{rhRet value for VAModSub}{even, &lt; 8}Set[dstTP, 6 ],{rhRet value for VAModSub}{even, &lt; 8}Set[NoPgCr, 0 ],Set[PgCr, 2 ],Set[LCeq0, 1 ],Set[dbsb0, 0 ],Set[sbneq0, 1 ],Set[dbneq0, 3 ],;</pre>
  </body>
</html>
