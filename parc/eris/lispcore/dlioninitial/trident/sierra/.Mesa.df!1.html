<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;LispCore>DlionInitial>Trident>Sierra>Mesa.df!1</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 8pt serif">{File name:  Mesa.df<br> Description: Non-Register Definitions for Dandelion Mesa Emulator Microcode,<br> Created: November 18, 1980,<br> Last Edited:<br>Fay July 6, 1982  3:47 PM: Added SrcMap return point MapSrcBandBLT for BandBLTBBInit.<br>Jim Sandman October 14, 1981  3:59 PM: Change for new instruction set<br>Jim Frandeen March 11, 1981  2:56 PM: Change BLDest and BLDestR for Checksum<br>Jim Frandeen March 4, 1981  4:55 PM: Add entry to RMapFixCaller<br>Jim Frandeen February 17, 1981  5:02 AM: changes to RMapFixCaller, WMapFixCaller, RFixForTrap, WFixForTrap for new Block<br>Sandman, February 2, 1981  1:11 PM<br>Sandman, January 20, 1981  4:48 PM<br>Jim Frandeen January 8, 1981  10:41 AM<br>}<br><br><br>{Mesa SD offsets (from SDDefs.mesa)}<br>Set[sBreak, 0&rsquo;b];<br>Set[sStackError, 1&rsquo;b];<br>Set[sBoot, 2&rsquo;b];<br>Set[sRescheduleError, 3&rsquo;b];<br>Set[sXferTrap, 4&rsquo;b];<br>Set[sOpcodeTrap, 5&rsquo;b];<br>Set[sControlTrap, 6&rsquo;b];<br>Set[sCodeTrap, 7&rsquo;b];<br>Set[sHardwareError, 10&rsquo;b];<br>Set[sUnboundTrap, 11&rsquo;b];<br>Set[sDivZeroTrap, 12&rsquo;b];<br>Set[sDivCheckTrap, 13&rsquo;b];<br>Set[sInterruptError, 14&rsquo;b];<br>Set[sProcessTrap, 15&rsquo;b];<br>Set[sBoundsTrap, 16&rsquo;b];<br>Set[sPointerTrap, 17&rsquo;b];<br><br>{Fault queue pointers used for Faults}<br>Set[qFrameFault, 60&rsquo;b];<br>Set[qPageFault, 62&rsquo;b];<br>Set[qWriteProtect, 64&rsquo;b];<br><br>{Xfer value used for Traps}<br>Set[L2.TRAPSpc,0A];<br><br>{flag value used for Interrupts and Faults}<br>Set[pInt, 47]; {also in Process}<br>Set[pFault, 3]; {also in Process}<br><br>{StateVector definition}<br>Set[State.word, 16&rsquo;b];<br>Set[State.frame, 17&rsquo;b];<br>Set[State.data, 20&rsquo;b];<br>Set[State.datam1, 17&rsquo;b];<br>Set[cSS, 16&rsquo;b];<br>Set[cSSm1, 15&rsquo;b];<br>Set[cSSm2, 14&rsquo;b];<br>Set[cSSp1, 17&rsquo;b];<br><br>{Local Frame definition}<br>Set[LF.word, 4];<br>Set[LF.returnLink, 3];<br>Set[LF.globalLink, 2];<br>Set[LF.pc, 1];<br><br>{Global Frame definition}<br>Set[GF.word, 3];<br>Set[GF.codeLow, 2];<br>Set[GF.codeHi, 1];<br><br>{Link Codes for Common Subroutines}<br><br>{L0</span><span class="tab" val="67"></span><span style="font: 8pt serif">RMFRtn}<br><br>MacroDef[RMFRet, at[#1,10,RMFRtn]];<br><br>Set[L0.R, 0];{must be even}<br>Set[L0.XRead, 1];<br>Set[L0.RD, 2];{must be even}<br>Set[L0.RD, 4];{must be even}<br>Set[L0.DBS, 5];<br>Set[L0.LGCRead, 6];{must be even; paired with L0.LGCSameG}<br>Set[L0.LGCSameG, 7];{must be odd; paired with L0.LGCRead}<br>Set[L0.ERefill, 8];  {must be even} <br>Set[L0.XPRead, 0C];{must be even}<br>Set[L0.NERefill, 0A];  {must end with 01}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Set[L0.NERefill.Set, 8];  {must end with 00}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Set[WhichFixType, 0B];  {used to distinquish between Refill & JRemap}<br>Set[L0.XCode, 0E];{must be even}<br>Set[L0.JRemap, 0F]; {must be 0F}<br><br>{L0</span><span class="tab" val="67"></span><span style="font: 8pt serif">RLMFRtn}<br><br>MacroDef[RLMFRet, at[#1,10,RLMFRtn]];<br><br>Set[L0.RL, 0];{must be even}<br>Set[L0.RF, 1];<br>Set[L0.RS, 2];{must be even}<br>Set[L0.RLFS, 3];<br>Set[L0.EV1, 4];{must be even}<br>Set[L0.BLSource, 5]; <br>Set[L0.RDL0, 6];{must be even}<br>Set[L0.CLRead, 7];<br>Set[L0.RDL1, 8];{must be even}<br>Set[L0.EV0, 0A];{must be even}<br>Set[L0.JI, 0B];<br>Set[L0.Checksum, 0C]; {used by Checksum Misc opcode, must be even}<br>Set[L0.BLDestR, 0E]; {must be E}<br><br><br>{L0</span><span class="tab" val="67"></span><span style="font: 8pt serif">WMFRtn}<br><br>MacroDef[WMFRet, at[#1,10,WMFRtn]];<br><br>Set[L0.WS, 0];<br>Set[L0.W, 1];{1 MOD 4}<br>Set[L0.PO, 2];<br>Set[L0.PI, 3];<br>Set[L0.FF, 4];<br>Set[L0.WL, 5];{1 MOD 4}<br>Set[L0.Free, 6];<br>Set[L0.Alloc1, 7];<br>Set[L0.Alloc2, 8];<br>Set[L0.WD, 9];{1 MOD 4}<br>Set[L0.XWrite, 0A];<br>Set[L0.Xfer, 0C];{must be 0C}<br><br>{L0</span><span class="tab" val="67"></span><span style="font: 8pt serif">WLMFRtn}<br><br>MacroDef[WLMFRet, at[#1,10,WLMFRtn]];<br><br>Set[L0.WLFS, 0];<br>Set[L0.WSL, 1];{1 MOD 4}<br>Set[L0.WF, 5];{1 MOD 4}<br>Set[L0.WL, 9];{1 MOD 4}<br>Set[L0.WDL, 0D];{1 MOD 4}<br>Set[L0.BLDest, 0F]; {must be same as L0.BLDest for RMapFixCaller, must = F}<br><br>{L1</span><span class="tab" val="67"></span><span style="font: 8pt serif">Common TrapFix}<br><br>Set[L1.None, 0];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{JIB,JIW,PLD0,PSDLB,WLDILP}<br>Set[L1.Restore, 1];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{must be 1 mod 2, Block.mc}<br>Set[L1.Xfer, 2];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{Xfer.mc}<br>Set[L1.Dec, 3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">{SLn,Rn,RDLn,R0F,W0F,WS0F,LLOB,RKIB,RKDIB}<br>Set[L1.Dec2, 4];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{SLB,SGB,RB,RDLB,RF,WF,PSB,WLIP,DBS,FF,DSK}<br>Set[L1.PopDec2, 5];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{LLB,LGB,PLB,PLDB,RDB,RxIP,RxILP,RLIPF,RLILPF,LGMap}<br>Set[L1.PopDec, 6];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{LLn,LGn,RLI0n,RD0,PS0F}<br>Set[L1.Pop2Dec, 7];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{LLDn,LGDn,RLDI00,PSF,PSLF}<br><br>{L1</span><span class="tab" val="67"></span><span style="font: 8pt serif">RTrapFix}<br><br>Set[L1.Pop2Dec2, 8];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{0 mod 2; = L2.RDL; also RLTrapFix; LxGB,RLDIP,RKDIB}<br>Set[L1.Refill, 9];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{Refill.mc}<br><br>{L1</span><span class="tab" val="67"></span><span style="font: 8pt serif">RLTrapFix}<br><br>{Set[L1.Pop2Dec2, 8];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{also RTrapFix; RLDILP,RKDIB}}<br>Set[L1.Push2, 9];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{also WTrapFix; RSL,RLFS}<br>Set[L1.PushDec, 0A];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{also WTrapFix; RL0,RL0F,RCFS}<br>Set[L1.PushDec2, 0B];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{also WTrapFix; RLB,RLF}<br>Set[L1.Push, 0C];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{also WTrapFix; RS}<br>Set[L1.Dec3, 0D];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{RC,ROB}<br><br>{L1</span><span class="tab" val="67"></span><span style="font: 8pt serif">WTrapFix}<br><br>Set[L1.PushInc, 8];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{PSD0}<br>{Set[L1.Push2, 9];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{also RLTrapFix; WSL,WLFS,WDB,WDLB}}<br>{Set[L1.PushDec, 0A];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{also RLTrapFix; SLDn,WL0F,W0}}<br>{Set[L1.PushDec2, 0B];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{also RLTrapFix; SLDB,SGDB,WLF,WB}}<br>{Set[L1.Push, 0C];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{also RLTrapFix; SLDn,SLDB,SGDB,WS,WLB,PSDB}}<br>Set[L1.Pop, 0D];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{PSLB,WLILP}<br>Set[L1.PushDec3, 0E];</span><span class="tab" val="67"></span><span style="font: 8pt serif">{WOB}<br><br><br>{L2</span><span class="tab" val="67"></span><span style="font: 8pt serif">MaskRet}<br><br>{Stack}<br>Set[L2.SSBInv, 0 ];<br>Set[L2.SSBNorm, 1 ];<br>Set[L2.Rotate, 2 ];<br>{TextBlt}<br>Set[maskRet.flags,3];<br>{Field}<br>Set[L2.RF, 4 ];<br>Set[L2.WF0, 5 ];<br>Set[L2.WF1, 6 ];<br>{BitBlt}<br>Set[maskRet.fQ, 9 ],<br>Set[maskRet.f1, 0E],<br>Set[maskRet.f2, 0D],<br>Set[maskRet.bQ, 0C],<br>Set[maskRet.b1, 0B],<br>Set[maskRet.b2, 0A],<br><br>{L0</span><span class="tab" val="67"></span><span style="font: 8pt serif">IPRtn}<br><br>MacroDef[IPRet, at[#1,10,IPRtn]];<br><br>Set[L0.RLIPF, 4];<br>Set[L0.RLIP, 5];<br>Set[L0.RLDIP, 6];<br>Set[L0.RGIP, 7];<br>Set[L0.WLIP, 8];<br><br>{L0</span><span class="tab" val="67"></span><span style="font: 8pt serif">ILPRtn}<br><br>MacroDef[ILPRet, at[#1,10,ILPRtn]];<br><br>Set[L0.RLILPF, 9];<br>Set[L0.RLILP, 0A];<br>Set[L0.RLDILP, 0B];<br>Set[L0.RGILP, 0C];<br>Set[L0.WLILP, 0D];<br>Set[L0.WLDILP, 0E];<br><br>{L2</span><span class="tab" val="67"></span><span style="font: 8pt serif">LGMRtn}<br><br>MacroDef[LGMRet, at[#1,10,LGMRtn]];<br><br>Set[L2.LIP, 1];  Set[L2.LIPx, Or[L2.LIP, 2]];<br>Set[L2.LILP0, 5];  Set[L2.LILP0x, Or[L2.LILP0, 2]];<br>Set[L2.LILP1, 8]; {must be 0 mod 2}<br>Set[L2.LILP1x, 9]; {must be L2.LILP1 or 1}<br>Set[L2.GILP0, 0D];  Set[L2.GILP0x, Or[L2.GILP0, 2]];<br><br>{L2</span><span class="tab" val="67"></span><span style="font: 8pt serif">VAHiInc}<br><br>MacroDef[VAHiRet, at[#1,10,VAHiRtn]];<br><br>Set[L2.WDL, 0]; {must be 0; must be even, someone in odd pair}<br>Set[L2.RDL, 8]; {Same as L1.Pop2Dec2; must be even, someone in odd pair}<br>Set[L2.WL, 4]; {must be even, someone in odd pair}<br>Set[L2.WLF, 6]; {must be even, someone in odd pair}<br>Set[L2.xSL, 0E]; {must be even, someone in odd pair}<br>Set[L2.RLF, 0A]; {must be even, someone in odd pair}<br>Set[L2.RLFS, 0C]; {must be even, someone in odd pair}<br>Set[L2.WLFS, 2]; {must be even, someone in odd pair}<br><br>{L3</span><span class="tab" val="67"></span><span style="font: 8pt serif">Holds VA location for faults<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Bit 0: 0 =&gt; Q,     1 =&gt; TT<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Bit 1: 0 =&gt; rhMDS, 1 =&gt; rhTT}<br><br>Set[L3.rhMDS.Q, 0];<br>Set[L3.rhMDS.TT, 1];<br>Set[L3.rhTT.Q, 2];<br>Set[L3.rhTT.TT, 3]; {must be 3 for IBEmptyTrap}<br><br>Set[OpcodeBase, 500];<br><br>MacroDef[opcode, at[Add[#1, OpcodeBase]]];<br>MacroDef[alpha.left, ibHigh];<br>MacroDef[fd.pos, ibHigh];<br>MacroDef[alpha.right, ibLow];<br>MacroDef[fd.size, ibLow];<br>MacroDef[AlwaysIBDisp, (IBDisp, IBPtr&larr;1)];<br><br><br>{Block and BitBlt stuff}<br><br>{constant and macro definitions for BitBlt}<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">{gray (gr) values}<br>Set[gr.gray,1],Set[gr.notgray,5],Set[gr.mask,1],Set[grM,8],<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">{source function (sf) values}<br>Set[sf.true,4],Set[sf.comp,5],Set[sf.mask,4],Set[sfM,8],<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">{direction (dir) values}<br>Set[dir.forward,6],Set[dir.backwards,0E],Set[dirM,10],<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">{dest function (df) values}<br>Set[df.null,8],Set[df.and,0A],Set[df.or,0C],Set[df.xor,0E],Set[dfM,10],<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">{srcdst function (sd) values}<br>Set[sd.src,0],Set[sd.dst,1],Set[sd.spec,2],Set[sdM,4],<br><br>{Return points for RestoreRandRHRegs}<br>MacroDef[RestoreBlockRegsRet,at[#1,10,RestoreCallers]];<br>Set[restore.term, Sub[grM,1] ],{MUST BE Sub[grM,1]}<br>Set[restore.int, 0 ],{restore if interrupt }<br>Set[restore.pf, 2 ],{restore if page fault}<br>Set[restore.trap,3]; {used by Block if trap}<br>Set[restore.BandBLT, 6]{used by BandBLT for at </span><span style="font: italic 8pt serif">BandBLT</span><span style="font: 8pt serif">&rsquo;s point of return to emulator};<br>Set[BLTfini,0F]; {used by Block, must = F}<br>Set[BLEQfini,0E]; {used by Block, must = E}<br><br>{Return points for DstVAMod}<br>MacroDef[DstVAModRet,at[#1,4,DstVAModRet]];<br>Set[sdWidth, 2 ],{for DstVAMod and SrcVAMod}<br>Set[sdBpl, 1 ],{ DstVAMod and SrcVAMod}<br>Set[Dest,3], {for TextBlt to call DstVAMod}<br><br>{Return points for SrcMap}<br>MacroDef[SrcMapSpecRet,at[#1,10,SrcMapRet]];<br>Set[sdMap, 0 ],{for SrcMap and DstMap}<br>Set[argMap, 1 ],{for mapping BitBltArg}<br>Set[MapOne, 2 ],{for SrcMap and DstMap}<br>Set[MapArg, 3 ], {for TextBlt to map TextBltArg}<br>Set[MapSrcBandBLT, 4 ], {for BandBLTBBInit SrcMap}<br>Set[Fetch, 5 ], {for TextBlt FetchVS subroutine}<br>Set[MapFont, 7 ], {for TextBlt to map FontBody pointer, must be 7}<br><br>{Return points for SaveRandRHRegs}<br>MacroDef[SaveBlockRegsRet,at[#1,10,SavebbRegsRet]];<br>MacroDef[SavebbRegsRet,at[#1,10,SavebbRegsRet]];<br>Set[Savebb.BitBlt,0]; {Return from SavebbRegs for BitBlt, must = 0}<br>Set[BLT,3]; { Block Transfer, must = 3}<br>Set[BLTL,7]; {Block Transfer Long, must = 7}<br>Set[BLEL,6]; {Block Equal Long, must = 6}<br>Set[BLECL,0E]; {Block Equal Code Long, must = E}<br>Set[BLTC,0B]; {Block Transfer Code, must = 0B}<br>Set[BLTCL,0F]; {Block Transfer Code Long, must = 0F}<br>Set[CKSUM,4]; {Checksum  must = 4}<br>Set[Savebb.BLT,BLT]; {Return from SavebbRegs for BLEQ (Block Transfer), must = 3}<br>Set[Savebb.BLTL,BLTL]; {Return from SavebbRegs for BLTL (Block Transfer Long), must = 7}<br>Set[Savebb.BLEL,BLEL]; {Return from SavebbRegs for BLEL (Block Equal Long), must = 6}<br>Set[Savebb.BLECL,BLECL]; {Return from SavebbRegs for BLECL (Block Equal Code Long), must = E}<br>Set[Savebb.BLTC,BLTC]; {Return from SavebbRegs for BLTC (Block Transfer Code), must = 0B}<br>Set[Savebb.BLTCL,BLTCL]; {Return from SavebbRegs for BLTCL (Block Transfer Code Long), must = 0F}<br>Set[Savebb.CKSUM,CKSUM]; {Return from SavebbRegs for CKSUM (Checksum)  must = 4}<br>Set[Savebb.BANDBLT,0C]; {Return from SavebbRegs for BandBlt}<br>Set[Savebb.TXTBLT,0D]; {Return from SavebbRegs for TextBlt}<br><br><br>Set[hbs.0, Or[ Xor[0F, 0] , 6 ] ];<br>Set[hbs.1, Or[ Xor[0F, 1] , 6 ] ];<br>Set[hbs.2, Or[ Xor[0F, 2] , 6 ] ];<br>Set[hbs.A, Or[ Xor[0F, 0A] , 6 ] ];<br>Set[hbs.B, Or[ Xor[0F, 0B] , 6 ] ];<br>Set[hbs.C, Or[ Xor[0F, 0C] , 6 ] ];<br>Set[hbs.D, Or[ Xor[0F, 0D] , 6 ] ];<br><br>MacroDef[scDisp,L0Disp],<br>MacroDef[dfDisp,L1Disp],<br>MacroDef[dirDisp,L1Disp],<br>MacroDef[sdDisp,L2Disp];<br>MacroDef[sfDisp,L3Disp],<br>MacroDef[grDisp,L3Disp];<br><br>MacroDef[sc1DISP,DISP4[#1,0E]],<br>MacroDef[sc2DISP,DISP4[#1,03]],<br>MacroDef[sc3DISP,DISP4[#1,0D]],<br>MacroDef[dirDISP,DISP4[#1,6]],<br>MacroDef[dfDISP,DISP4[#1,8]],<br>MacroDef[sfDISP,DISP3[#1,sf.mask]],<br>MacroDef[grDISP,DISP3[#1,gr.mask]];<br>MacroDef[sdDISP,DISP2[#1]];<br><br>Set[SRaRet, 2 ],{rhRet value for SrcLRemap}<br>Set[SRcRet, 3 ],{rhRet value for SrcLRemap}<br><br>Set[DRaRet, 02 ],{rhRet value for DstLRemap}<br>Set[DRbRet, 03 ],{rhRet value for DstLRemap}<br>Set[ret.L1pcr, 08 ],{rhRet value for DstLRemap}<br>Set[ret.L2pcr, 09 ],{rhRet value for DstLRemap}<br>Set[ret.L1Tpcr, 0A ],{rhRet value for DstLRemap}<br><br>Set[StkSize.normal, 1 ],{used for HowBigStack}<br>Set[StkSize.interrupt, 7 ],{used for HowBigStack}<br><br>Set[Type.normal, 0 ],{value in rhType}<br>Set[Type.LSEP, 1 ],{value in rhType}<br>Set[Type.TextBlt,4], {value in rhType tells what to do if page fault}<br>Set[type.notsmall,7],Set[type.small,5],Set[typeM,8],<br><br>Set[dtRet.L0, 0 ],{constant value for dT}<br>Set[dtRet.L1, 1 ],{constant value for dT}<br>Set[dtRet.L3, 3 ],{constant value for dT}<br>Set[dtRet.L4, 4]{used by BandBLT for dT};<br><br>Set[VAaRet, 0 ],{rhRet value for VAModSub}{even, &lt; 8}<br>Set[VAbRet, 2 ],{rhRet value for VAModSub}{even, &lt; 8}<br>Set[srcTP, 4 ],{rhRet value for VAModSub}{even, &lt; 8}<br>Set[dstTP, 6 ],{rhRet value for VAModSub}{even, &lt; 8}<br><br>Set[NoPgCr, 0 ],<br>Set[PgCr, 2 ],<br>Set[LCeq0, 1 ],<br><br>Set[dbsb0, 0 ],<br>Set[sbneq0, 1 ],<br>Set[dbneq0, 3 ],<br>;<br><br><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
