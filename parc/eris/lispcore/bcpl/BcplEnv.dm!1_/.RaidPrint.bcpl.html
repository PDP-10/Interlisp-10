<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;LispCore>bcpl>BcplEnv.dm!1>RaidPrint.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">// RaidPrint.bcpl. Raid printing routines for Lisp objects.<br>// Changed August 26, 1981 by Bill van Melle<br>// Allegro change August 4, 1981  4:27 PM by Beau Sheil<br>// Last change July 20, 1981  8:01 PM by Beau Sheil<br>// Last change May 9, 1981  12:29 AM by Beau Sheil<br>// Last change April 14, 1981  8:07 PM by Beau Sheil<br>// Tone change March 17, 1981  5:21 PM by Beau Sheil<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Raid.decl"<br><br>external [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures & statics defined<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Lprint; PrintName; PrintPtr;  Wo; Wn; Wb; uradix; uprintlevel; ulistlength<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dsp; keys; @lvNIL; @lvVPtr; @VPtr0; @VPtr1<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RaidReset; Negate; Divide; Usc; Min; CRLF; ReadKeys; Wc; Ws<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EqNIL; VP; Gets; UCase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@BGetBasePtr; @XGetBasePtr; @XGetBase32; IGetBase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@SGetBase; @XSetBR; @RRead; @BGetBase; @XGetBase; @XGetBase1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GetLmarg; SetLmarg; GetBitPos<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>manifest maxdigits = 32<br><br>static [ uradix = 8; uprintlevel = 5; ulistlength = 8 ]<br><br>let Lprint(w ;numargs n) be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// only recursion is from PrintList<br>  [ let savedLM = GetLmarg(dsp)<br>    // second arg is used to suppress CRLF and hence LMarg adjusmtment<br>    if n eq 1 then SetLmarg(dsp, GetBitPos(dsp))<br>    switchon Type(w) into<br>      [ case ATOMTYPE:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     if selecton w&gt;&gt;AtomNumber-2 into<br>                  [ // One char atoms have atom numbers = 2+their char code<br>                    case $. : case $( : case $) : case $*s : true<br>                    default : false ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">         then Wc($%)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// % indicates special atoms<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintName(w&gt;&gt;AtomNumber)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case LISTTYPE:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintList(w, uprintlevel)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case SMALLTYPE:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintNum(w&gt;&gt;VA.vahi eq SMALLPOSspace ? 0, -1, w&gt;&gt;VA.valo, uradix)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     if (uradix eq 8) then Wc($Q)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case INTEGERTYPE:<br>             XGetBase32(w)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintNum(VPtr0, VPtr1, uradix)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     if (uradix eq 8) then Wc($Q)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case FLTPTTYPE:<br>             Ws("FLOATP with bits: ")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     XGetBase32(w)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintNum(VPtr0, VPtr1, 8); Wc($Q)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// always octal<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case STRINGPTRTYPE:<br>             Wc($"); PrintStr(w); Wc($"); endcase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">case ARRAYPTRTYPE:<br>             PrintArray(w); endcase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">default:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">//print pointer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintPtr(w!0, w!1)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     if (Type(w) ne 0)&(VP(w) ge FirstMDSPage) then<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">[ Ws(" -&gt;"); PrintPtr(XGetBase(w), XGetBase1(w)) ]<br>      ]</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">//ends switchon<br>    if n eq 1 then [ CRLF(); SetLmarg(dsp, savedLM) ]<br>  ]<br><br>and PrintArray(lvAPtr) be<br> [ XSetBR(lvAPtr)<br>   let w = RRead(offset Styp/16)<br>// Flags and type are stored in the same word of the descriptor<br>   Wc($[); Wc(w&lt;&lt;Sorig ? $1, $0); Wc($-)<br>   Wn(RRead(offset Slength/16) - (w&lt;&lt;Sorig ? 0, 1), uradix); Ws("] ")<br>   if w&lt;&lt;Sro then Ws("read only, ")<br>   if w&lt;&lt;Salgn then Ws("aligned, ")<br>   Ws(selecton w&lt;&lt;Styp into<br>         [ case 0:  "BYTE"<br>           case 1:  "POS16"<br>           case 2:  "FIXP"<br>           case 3:  "HASH"<br>           case 4:  "CCODE"<br>           case 5:  "BITMAP"<br>           case 6:  "POINTER"<br>           case 11: "DOUBLE POINTER"<br>           default: valof [ Ws("(type ="); Wn(w&lt;&lt;Styp, uradix);<br>                            resultis ") INVALID" ] ] )<br>   Ws(" array @ ")<br>   w = RRead(offset Soffst/16)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// save offset lest lvAPtr be lvVPtr<br>   XGetBasePtr(lvAPtr)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// knows that base ptr is in first word!!<br>   PrintPtr(VPtr0, VPtr1)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// prints base address as a ptr<br>   Ws(" offset "); Wn(w, 8)<br> ]<br> <br>and PrintChars(charPtr, offst, n) be<br> [ let w = nil<br>   let hibyteflg = (offst & 1) eq 0<br>   XSetBR(charPtr)<br>   for i = offst to offst+Min(n, 100)-1 do<br>     [ w = RRead(i rshift 1)<br>       Wc(hibyteflg ? w&lt;&lt;HiByte, w&lt;&lt;LoByte)<br>       hibyteflg = not hibyteflg<br>     ]<br>   unless n le 100 do Ws(" &")</span><span class="tab" val="67"></span><span style="font: 10pt serif">// indicate tail suppression<br> ]<br> <br>and PrintList(w, depth) be<br>  [<br>   if depth le 0 then [ Wc($&); return ]<br>   Wc($()<br>   let len = ulistlength<br>   [ if len le 0 then [ Ws(" --"); break ]<br>     test Type(w) eq LISTTYPE<br>       ifso  [ let saved = vec 1<br>               MoveAddr(saved, w)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// saves w for later cdr<br>               let car = CAR(w)<br>               test Type(car) eq LISTTYPE<br>                 ifso  PrintList(car, depth-1)<br>                 ifnot Lprint(car, true)<br>               w = CDR(saved); len=len-1<br>               test EqNIL(w) ifso break ifnot Wc($*S)<br>             ]<br>       ifnot [ Ws(" . "); Lprint(w, true); break ]<br>   ] repeat<br>   Ws(")")<br>  ]<br><br>and CAR(lvX) = valof</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// lvX is known to be LISTP<br>  [<br>    XGetBase32(lvX)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// 32 bits into VPPtr0 and 1<br>    compileif CDRCODING then [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless lvVPtr&gt;&gt;ConsCell.Qfield</span><span class="tab" val="67"></span><span style="font: 10pt serif">// indirect cell. Take 1 level of<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    do XGetBase32(lvVPtr)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// indirection, to the correct cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lvVPtr&gt;&gt;ConsCell.Qfield = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Turn off the CDR bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>    resultis lvVPtr<br>  ]<br><br>and CDR(lvX) = valof</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// lvX is known to be LISTP # lvVPtr <br>  [<br>    compiletest CDRCODING<br>      ifso [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XGetBase32(lvX)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// 32 bits into VPPtr0 and 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless lvVPtr&gt;&gt;ConsCell.Qfield</span><span class="tab" val="67"></span><span style="font: 10pt serif">// indirect cell. Save its address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   do [ MoveAddr(lvX, lvVPtr)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// for later offset, then indirect<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">XGetBase32(lvVPtr)</span><span class="tab" val="67"></span><span style="font: 10pt serif">]</span><span class="tab" val="67"></span><span style="font: 10pt serif">// to it<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let D = lvVPtr&gt;&gt;ConsCell.dfield<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless D then resultis lvNIL<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let F = lvVPtr&gt;&gt;ConsCell.ibit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MoveAddr(lvVPtr, lvX)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// address is in same page as lvX<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lvVPtr&gt;&gt;VA.wordN = D lshift 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless F do XGetBasePtr(lvVPtr)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// indirection for CDR<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>      ifnot [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MoveAddr(lvVPtr, lvX)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// address is in same page as lvX<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lvVPtr&gt;&gt;VA.valo = lvVPtr&gt;&gt;VA.valo + 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XGetBasePtr(lvVPtr)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>    resultis lvVPtr<br>  ]<br><br>and PrintName(name) be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// takes an atom number<br> [ BGetBasePtr(PNPspace, PNPbase + (name lshift 1))</span><span class="tab" val="67"></span><span style="font: 10pt serif">// pname ptr into VPtr<br>   PrintChars(lvVPtr, 1, XGetBase(lvVPtr)&lt;&lt;HiByte)<br> ]<br><br>and PrintNum(A,B,R) be<br>//  A and B are hi and lo parts of the same number.  This procedure depends<br>//  on them being put into AC0 and AC1 for double word Divide. Hence, 2 args.<br>  [ let L, P = vec maxdigits, maxdigits<br>    if A ls 0 then [ Wc($-); Negate(lv A) ]<br>    [ L!P = Divide(lv A, R)+$0<br>      P = P-1<br>    ] repeatwhile (A ne 0) % (B ne 0)<br>    while P ls maxdigits do [ P = P+1; Wc(L!P) ]<br>  ]<br><br>and PrintPtr(hi, lo) be [ Wc(${); Wo(hi, true); Wc($,); Wo(lo, true); Wc($}) ]<br><br>and PrintStr(lvstrPtr) be<br> [ XSetBR(lvstrPtr)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// point base at string descriptor<br>   PrintChars(XGetBasePtr(lvstrPtr),</span><span class="tab" val="67"></span><span style="font: 10pt serif">// assumes base addr in first 2 words<br>              RRead(offset Soffst/16),</span><span class="tab" val="67"></span><span style="font: 10pt serif">// offset of first byte<br>              RRead(offset Slength/16))</span><span class="tab" val="67"></span><span style="font: 10pt serif">// string length<br> ]<br><br>and Wo(n, nopad; numargs na) be<br>  [ let pad = (na ls 2) % (nopad eq 0)<br>    for i = 15 to 3 by -3 do<br>      [ let d = n rshift i<br>        test d ne 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso Wc((d&7)+$0)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifnot if pad then Wc($*S)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// pad number to fixed width (6)<br>      ]<br>    Wc((n&7)+$0)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// ensures at least one digit<br>  ]<br><br>and Wn(n, rad) be PrintNum(0, n, rad)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// n is assumed +ve; rad is radix<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and Wb(n) be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Write a byte<br>  [ Wc($0 + ((n rshift 6) & 3))<br>    Wc($0 + ((n rshift 3) & 7))<br>    Wc($0 + (n & 7))<br>  ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and MoveAddr(tgt, src) = valof<br>  [ tgt!0 = src!0<br>    tgt!1 = src!1<br>    resultis tgt<br>  ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif"><br>and Type(ptr) = valof<br>  [ // Type is only valid for ptrs in the data zone, below PNPspace<br>    unless ptr&gt;&gt;VA.segment ls PNPspace do resultis 0<br>    let MDSbyte = VP(ptr) rshift 1<br>    let W = BGetBase(MDSTYPEspace, MDSTYPEbase + MDSbyte rshift 1)<br>    resultis ((MDSbyte&1) eq 0 ? W&lt;&lt;HiByte, W&lt;&lt;LoByte)<br>  ]<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
