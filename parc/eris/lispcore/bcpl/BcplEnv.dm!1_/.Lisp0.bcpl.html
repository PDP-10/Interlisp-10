<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>bcpl>BcplEnv.dm!1>Lisp0.bcpl</title>
  </head>
  <body>
    <pre>
// Lisp0.bcpl  Inital entry point is StartLisp// Last change September 27, 1981  10:56 PM by Bill van Melle// Tone change March 17, 1981  4:56 PM by Beau Sheil// Last change February 24, 1981  1:55 PM by Beau Sheil// Phrase change November 24, 1980  12:13 PM by Beau Sheil	get "LispBcpl.decl"	get "SysDefs.D"external [	SavedUFP; SavedSCP; @ContextQ; TopLevelFrame	@lvNIL; @lvKT; @lvVPtr; @VPtr0; @VPtr1; @RMSK	// useful values	BcplDisplay; MkSmallPos			// procedures used	Iresume; RAIDCode; CloseStats; uPCTracing	AllocVec; MainInit; ShortStack		// from maininit.bcpl	AllocPtr				// allocater static	StartPup				// Lisp Pup	Enqueue; Max; MyFrame; Junta; Block	// OS procs	InitializeContext; CallContextList	lvUserFinishProc; lvSwatContextProc	// Statics used	@SubrArgsOffset; SubrArgsVector; @uPCTraceAddr				// statics defined	LispStackLength	PupZoneLength	LispStackStart	PupZoneStart	LispFinish; SysErr		// procedures defined	]static [	@TopLevelFrame; @ContextQ; SubrArgsVector	@lvNIL; @lvKT; @lvVPtr; @VPtr0; @VPtr1; @RMSK = #377	LispStackLength	PupZoneLength	LispStackStart	PupZoneStart	]manifest ScreenScanLines = 808	// vertical screen size let StartLisp() be Junta(levStreams,InitLisp)		// main entryand InitLisp() be   [// EventualEndOfStack is an estimate of how much stack space we will need// after the call to MainInit.  MainInit assigns the rest (including its// own stack) to the display, which we turn on.   [ let EventualEndOfStack=ShortStack(256)     MainInit(EventualEndOfStack)     @StackEnd=EventualEndOfStack		// sets end of stack   ]   BcplDisplay(ScreenScanLines-15)	// give Bcpl dsp all the screen space save					// a few lines to protect against overscan   StartPup(PupZoneStart, PupZoneLength)	// Start the Pup world   // Init the TopLevel context and put it on ContextQ   Enqueue(ContextQ,	InitializeContext(LispStackStart,LispStackLength,TopLevel))   CallContextList(ContextQ!0) repeat		// Start the contexts running   ]and TopLevel() be   [   TopLevelFrame = MyFrame()   SubrArgsOffset = (SubrArgsVector-1)-TopLevelFrame  // -1 adjusts indx orig   Iresume(lvKT)				// never returns - T=&gt;startup   ]and SysErr(p1, eCode) be    RAIDCode(selecton eCode into               [ case 1101: "Hard disk error"                 case 1102: "Disk full"                 case 1103:  case 1104: "Bad disk command"                 default:   "SysErr" ],             MkSmallPos(eCode))and LispFinish() be   [   @lvSwatContextProc = SavedSCP	// restore Swat proc   @lvUserFinishProc = SavedUFP		// restore finish proc   if uPCTraceAddr then uPCTracing(false)	// turn off any uPc logging   CloseStats()				// turn off stats   BcplDisplay(0)			// turn off any displays   finish   ]</pre>
  </body>
</html>
