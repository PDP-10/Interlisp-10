<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;LispCore>bcpl>BcplEnv.dm!1>MainInit.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">// MainInit.bcpl.  Bulk of the initialization code.<br>// Last change September 27, 1981  10:56 PM by Bill van Melle<br>// Last change September 5, 1981  12:39 PM by Bill van Melle<br>// Allegro change August 2, 1981  6:01 PM by Beau Sheil<br>// Last change July 20, 1981  6:59 PM by Beau Sheil<br>// Last change May 12, 1981  1:34 AM by Beau Sheil<br>// Last change March 26, 1981  12:20 AM by Beau Sheil<br>// Tone change March 17, 1981  5:35 PM by Beau Sheil<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "AltoFileSys.d"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "LispBcpl.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Stats.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Streams.d"<br><br>external [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// defined here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocVec; MainInit; ShortStack; SavedUFP; SavedSCP<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// O.S. procedures<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Resets; Closes; MoveBlock; ReadBlock; CreateDiskStream; FileLength<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">InitializeZone; MyFrame; CallSwat; SysErr; Zero; Usc; Max<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// OS statics <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dsp; sysZone; sysFont; fpSysDir; fpComCm; fpSysFont; sysDisk<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UserName; lvSysZone; lvSysErr; lvUserFinishProc; lvSwatContextProc<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// other library procedures<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LookupEntries; SetupReadParam; ReadParam; EvalParam<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// utilities<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MachineType; Version; LispFinish; LispSwatContext<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// SUBR base<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">uCodeCheck<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// initialization only<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocPtr; AllocEnd; AllocInFirstBlock; StartOfAllocBlock<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GetRamVersion; SetupLispMem; KBDinit; RemoteInitVmem<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@SubrBase; @lvNIL; @lvKT; @lvVPtr; @VPtr0; SubrArgsVector<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@Bcpl; @ContextQ; LogPagingFlag <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@dspStartAddr; @dspArea; @dlispDsp; @DLispDCB<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EmulatorSpace; @MoveWordsBBT; @MoveWordsBBTAddr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LispStackLength<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PupZoneLength<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LispStackStart<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PupZoneStart<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>static [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocPtr</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// set in InitLisp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocEnd</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// end of fixed alloc region<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocInFirstBlock</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// true when in fixed block<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SavedUFP; SavedSCP</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// used to save OS procs<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>manifest [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NILNum = #0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// atom # for NIL<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TNum = #114</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// atom # for T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SubrArgsPtr = #210</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// addr where ucode puts args<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MaxSubrArgs = 12</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// maximum nargs for any subr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lEDCB = 6</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// extended DCB length<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lFileName = 80</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// file name length in words<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MinPupZoneLength = 8000</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// space for pup zone<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DefaultLispStackLength = 2400</span><span class="tab" val="67"></span><span style="font: 10pt serif">// ~10 pages for bcpl/lisp stack <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>structure Vers:<br>        [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Microcode Version word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">machType bit 4</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// machine type<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">emulType bit 4</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// emulators supported<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">blank byte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>structure String: [ length byte; char&uarr;1,255 byte ]<br><br>// The address of AllocVec is used as the base of the initialization code in<br>// InitLisp (which allocates run time storage starting here). Do not move<br>// within the file or change order of file load without being careful.<br><br>let AllocVec(n, align; numargs nargs) = valof<br><br>// AllocPtr is initialized to the first address that can be used to allocate<br>// permanent data structures (AllocVec). The first two allocations (the<br>// Pup zone and the Bcpl/Lisp run time stack) are made over the top of the<br>// initialization code and are not written into until the initialization is<br>// complete.<br><br>   [<br>// If align is specified, the allocation is align word aligned, for align a power of 2.<br>   if nargs eq 2 then [ let mask=align-1<br>                        AllocPtr=(AllocPtr+mask) & (not mask)<br>                      ]<br>   let addr=AllocPtr</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Save existing pointer for result<br>   AllocPtr=AllocPtr+n</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Move to after this allocation<br>   test AllocInFirstBlock<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso if Usc(AllocPtr, AllocEnd) gr 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">then CallSwat ("Not enough initial allocation space")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot if Usc (AllocPtr, @StackEnd) gr 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">then @StackEnd=AllocPtr</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Reset end of stack to after allocation<br>   resultis addr<br>   ]<br><br>and MainInit(EventualEndOfStack) be<br>   [<br>   dsp = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// turn off any display<br>   unless Version()&lt;&lt;Vers.emulType eq 4</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Lisp emul = 4<br>       do CallSwat("No Lisp microcode!")<br><br>   AllocPtr = StartOfAllocBlock<br>   AllocEnd = AllocVec<br>   AllocInFirstBlock = true</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// do some initial alloc in fixed block reserved by loader<br><br>// Initialize new keyboard driver.  Done quickly so typeahead is not lost<br>   KBDinit()<br><br>// We will need space for the single disk stream that can be open at<br>// once (either stats or initialization) plus some extra space for other<br>// diverse allocations. Here we create a SysZone of approx. the right size.<br><br>// This could later be merged into the PupZone by InitSystem<br>   [<br>   let szl=2*(lKS+WordsPerPage)+WordsPerPage</span><span class="tab" val="67"></span><span style="font: 10pt serif">// stream+buffer*2 plus 1 page<br>   sysZone = InitializeZone(AllocVec(szl),szl)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// for us<br>   @lvSysZone = sysZone</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// for Os<br>   ]<br><br>// Set up ucoce/bcpl communication area in locations #200-#277<br>   @StatsPtr = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// no stats initially<br>   @#206 = #2000 % lv Bcpl</span><span class="tab" val="67"></span><span style="font: 10pt serif">// = JMP @Bcpl <br>   @#207 = #77400</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// CallSwat in case #206 gets clobbered<br>// Subr argument passing structures. SubrArgsPtr = #210<br>   SubrArgsVector = AllocVec(MaxSubrArgs)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Bcpl args vector<br>   for i = 0 to MaxSubrArgs-1 do SubrArgsVector!i=SubrArgsPtr+2*i<br><br>// Binding various atom pointers which go back to Lisp.<br>// The atom numbers of T and NIL used to come from the IPage, now constants<br>   lvNIL = MakeAtomPtr(NILNum)<br>   lvKT = MakeAtomPtr(TNum)<br><br>// Bind various statics<br>   lvVPtr = lv VPtr0<br>   SubrBase = lv uCodeCheck</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// First SUBR<br><br>// Rebind OS procedures for errors, swat and exit. Restored at finish<br>   SavedUFP = @lvUserFinishProc<br>   @lvUserFinishProc = LispFinish<br>   SavedSCP = @lvSwatContextProc<br>   @lvSwatContextProc = LispSwatContext<br>   @lvSysErr = SysErr</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Not the OS SysErr<br><br>// Open the sysfont file, get the file length and allocate space for the font<br>   [ let s = CreateDiskStream(fpSysFont, ksTypeReadOnly, wordItem)<br>     let sl = (FileLength(s) + 1) rshift 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">// in words<br>     let fontblk = AllocVec(sl)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// space for sysFont<br>     Resets(s)<br>     ReadBlock(s, fontblk, sl)<br>     Closes(s)<br>     // The sysFont static is set to the third word of the font, which is<br>     // what is wanted by the character display routines.<br>     sysFont=fontblk+2<br>   ]<br><br>// Set up context structures for Pup package<br>   ContextQ=AllocVec(2);  ContextQ!0=0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Allocate and empty ContextQ<br><br>// Read command line - decides whether sysin or resume<br>   let SysinName = vec lFileName<br>   SysinName!0 = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// empty until one is specified<br><br>   [<br>   let COMstream = CreateDiskStream(fpComCm, ksTypeReadOnly, charItem)<br>   let param, SW = vec lFileName, vec 10<br>   SetupReadParam(param, SW, COMstream)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// get switches<br>   for i = 1 to @SW do<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">switchon SW!i into<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      [ case $I: case $i: SysinName = "LISP.SYSOUT."; endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">case $P: case $p: LogPagingFlag = true; endcase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      ]<br><br>// check for parameters in the command line<br>   [ let P = ReadParam(0,-1)<br>     if (P eq -1) then break</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// No more switches<br>     switchon (@SW ge 1? SW!1, 0) into<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">[ case $I: case $i: case 0: // SYSIN file<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   MoveBlock(SysinName, EvalParam(param,$P), lFileName)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   endcase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  case $N: case $n:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// set UserName<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   P = param!0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   unless P gr (((UserName!-1) lshift 1) - 1) do<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">for i = 1 to P do UserName&gt;&gt;String.char&uarr;i = param!i<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   UserName&gt;&gt;String.length = P<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   endcase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  default: break</span><span class="tab" val="67"></span><span style="font: 10pt serif">// unrecognized switch; so exit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// End of switch on switches <br>   ] repeat</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Loop back for another switch<br>   Closes(COMstream)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// close and discard COMstream<br>   ]<br><br>   [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// look up the lisp system files<br>   let VMEMid, SYSINid = nil, nil<br>   let RemoteP = false<br>   let dev = vec 2*lDV</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// lDV = len dir entry<br>   let SysDir = CreateDiskStream(fpSysDir, ksTypeReadWrite, wordItem)<br>   let namev = vec 2<br>   namev!0 = "LISP.VIRTUALMEM."<br>   namev!1 = SysinName!0 ? SysinName, 0<br>   if SysinName!0 <br>      then [ let i = 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     [  let ch = nil<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ch = SysinName&gt;&gt;String.char&uarr;i<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if ch eq ${ % ch eq $[</span><span class="tab" val="67"></span><span style="font: 10pt serif">// if remote name, don&rsquo;t lookup now]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [ namev!1 = 0; RemoteP = true; break ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if ch ne $*S<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then break<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">i = i+1 ] repeatuntil i gr SysinName&gt;&gt;String.length<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>   LookupEntries(SysDir, namev, dev, 2, true)<br>   VMEMid = dev+1</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// +1 turns dir entries into fileptrs<br>   // dont create vmem file - it should exist (contiguously!) already<br>   unless @dev do CallSwat("Cant find ", namev!0)<br>   dev = dev+lDV</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// move on to sysin file<br>   SYSINid = @dev ? dev+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// ok if found; else better not ask<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">namev!1 ? CallSwat("Cant find SYSIN file", namev!1), 0<br>   Closes(SysDir)<br><br>// we now know what kind of sysin, if any, to do<br>   if RemoteP<br>      then [ RemoteInitVmem (SysinName, VMEMid)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     SYSINid = -1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>   @StackEnd = RemoteInitVmem</span><span class="tab" val="67"></span><span style="font: 10pt serif">// free up some space<br>   AllocInFirstBlock = false<br>   AllocPtr=AllocVec</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// next alloc will be overlaid on init code<br>   LispStackStart=AllocVec(DefaultLispStackLength)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// space for lisp stack<br>   LispStackLength = DefaultLispStackLength<br>   PupZoneLength=Max(MinPupZoneLength, @StackEnd-AllocPtr)<br>   PupZoneStart=AllocVec(PupZoneLength)<br><br>// We allocate at least MinPupZoneLength words for the Pup zone, but we<br>// make sure that it extends at least to the end of the initialization code.<br>// This is because the pup zone is not touched during main initialization,<br>// whereas subsequent allocations are.  The Pup initialization code hides<br>// under the LispStack allocation (after Maininit) so it doesn&rsquo;t zorch itself.<br><br><br>   SetupLispMem(SYSINid, VMEMid)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Inits VMem<br>   ]<br><br>// MoveWords BBT tables. This code knows way too much about XBBTs<br>   MoveWordsBBT = AllocVec(20, 2);  Zero(MoveWordsBBT, 20)<br>   MoveWordsBBT!0 = #100000; MoveWordsBBT!3 = #10000</span><span class="tab" val="67"></span><span style="font: 10pt serif">// fn; width<br>   MoveWordsBBT!7 = #1; MoveWordsBBT!9 = #10000</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// height; width<br>   MoveWordsBBTAddr = AllocVec(2, 2)<br>   MoveWordsBBTAddr!0 = EmulatorSpace;  MoveWordsBBTAddr!1 = MoveWordsBBT<br><br>// Allocate the display, but do not open the TTY stream yet<br>   dlispDsp = AllocVec(2)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// lisp display<br>   // dlispDsp is a fake. All it has are pointers to a single display block<br>   // which is manipulated from Lisp. We allocate that now.<br>   DLispDCB =  AllocVec(lEDCB, 2)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// single dcb; 2word aligned<br>   Zero(DLispDCB, lEDCB)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// must be empty<br>   dlispDsp&gt;&gt;DS.fdcb = DLispDCB<br>   dlispDsp&gt;&gt;DS.ldcb = DLispDCB<br>// Now set the display start address. We will eventually give all of<br>// memory from this point on to the display bitmap.<br>   dspStartAddr = AllocVec(0, WordsPerPage)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// page align display<br>   dspArea = EventualEndOfStack - dspStartAddr<br>   unless dspArea ge WordsPerPage then CallSwat("No space for dsp")<br><br>// The display will be given whatever space remains between the end of the<br>// last AllocVec (rounded up to a page boundary) and the bottom of the stack<br>// frame for InitSystem (plus a small amount needed for it to start the rest<br>// of the system). The latter quantity is EventualEndOfStack. We do this so<br>// the (substantial) stack frame for MainInit can be reclaimed.<br>// Display is actually turned on in InitLisp after we exit<br><br> ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and MakeAtomPtr(atomNum) = valof<br>   [<br>   let ap = AllocVec(2, 2)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Dolphin wants these 2-word aligned<br>   ap!0 = ATOMspace;  ap!1 = atomNum<br>   resultis ap<br>   ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and ShortStack(n) = (MyFrame()-n) & not (WordsPerPage-1)<br><br>// Figures out where to end the stack a specified distance from here. Allows<br>// at least n words and rounds down (i.e. more stack) to the nearest page<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
