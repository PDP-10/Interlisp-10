(DEFINE-FILE-INFO §PACKAGE "INTERLISP" §READTABLE "XCL" §BASE 10)(filecreated "25-Nov-86 17:29:05" ("compiled on " {eris}<lispcore>library>conditiongraph.\;11) "25-Nov-86 00:46:57" |recompiled| |changes:| |nothing| |in| "Xerox Lisp 25-Nov-86 ..." |dated| "25-Nov-86 01:18:01")(filecreated "25-Nov-86 17:28:06" {eris}<lispcore>library>conditiongraph.\;11 7763 |changes| |to:| (functions recompute-condition-graph-sexpr count-condition-types-recursion graph-conditions condition-subgraph count-condition-types) (vars conditiongraphcoms) (props (conditiongraph filechanges)) (variables *condition-graph-window* *condition-graph-sexpr*) |previous| |date:| "24-Nov-86 15:41:01" {eris}<lispcore>library>conditiongraph.\;10)(rpaqq conditiongraphcoms ((variables *condition-graph-window* *condition-graph-sexpr*) (functions graph-conditions condition-subgraph condition-subgraph-recursion recompute-condition-graph-sexpr count-condition-types count-condition-types-recursion) (prop filechanges conditiongraph)))(cl:defvar *condition-graph-window* nil "Window in which to display the condition hierarchy graph.")(cl:defvar *condition-graph-sexpr* nil "Tree structure representing last calculated condition type graph.")(cl:defun graph-conditions (&optional (root (quote condition)) (recompute (null *condition-graph-sexpr*)) w) (let ((neww (showgraph (layoutsexpr (condition-subgraph root recompute) (quote (horizontal))) (or w *condition-graph-window* (cl:format nil "Condition type graph from: ~S" root)) nil nil t))) (windowprop neww (quote title) (cl:format nil "Condition type graph from: ~S" root)) (or w *condition-graph-window* (cl:setf *condition-graph-window* neww))))(cl:defun condition-subgraph (root recompute &aux (once nil) result) (cl:unless (cl:subtypep root (quote condition)) (cl:error "~S is not a condition type.")) (cl:loop (cl:when recompute (recompute-condition-graph-sexpr)) (cl:setf result (condition-subgraph-recursion root *condition-graph-sexpr*)) (cl:when (or once result) (cl:return-from condition-subgraph result)) (cl:format *error-output* "Couldn't find ~S in current graph.") (cl:setq once t recompute t)))(cl:defun condition-subgraph-recursion (target tree) (cond ((null tree) nil) ((eq target (car tree)) tree) (t (cl:do* (temp (tail (cdr tree) (cdr tail)) (subtree (car tail) (car tail))) ((setq temp (condition-subgraph-recursion target subtree)) temp)))))(cl:defun recompute-condition-graph-sexpr nil (let ((cghash (cl:make-hash-table))) (cl:format *error-output* " Computing condition hierarchy graph.") (mapcar (datatypes) (cl:function (cl:lambda (symbol) (block) (cl:when (and (not (cl:gethash symbol cghash)) (cl:subtypep symbol (quote condition))) (cl:do ((type symbol (condition-parent type)) (chain nil)) ((cond ((null type) (cl:setf *condition-graph-sexpr* chain)) ((cl:gethash type cghash) (nconc (cl:gethash type cghash) (list chain))) (t nil))) (cl:princ ".") (cl:setf (cl:gethash type cghash) (cl:setf chain (cl:if (null chain) (list type) (list type chain)))))))))))(cl:defun count-condition-types nil (count-condition-types-recursion (condition-subgraph (quote condition) nil)))(cl:defun count-condition-types-recursion (tree) (cond ((null tree) 0) ((cl:symbolp tree) 1) (t (for subtree in tree sum (count-condition-types-recursion subtree)))))(putprops conditiongraph filechanges ((functions recompute-condition-graph-sexpr count-condition-types-recursion graph-conditions condition-subgraph count-condition-types) (vars conditiongraphcoms) (props (conditiongraph filechanges)) (variables *condition-graph-window* *condition-graph-sexpr*)))(putprops conditiongraph copyright ("Xerox Corporation" 1986))nil