<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>INTERNAL>DOC>Addarith.tty!1</title>
  </head>
  <body>
    <pre>
There are a few additional arithmetic functions:(MASK.1'S &lt;position&gt; &lt;size&gt;)  returns a number equivalent to       (llsh (sub1 (expt 2 size)) position), but faster, and without consing.      Currently, the sume of  &lt;position&gt; and &lt;size&gt; cannot exceed 32.(MASK.0'S &lt;position&gt; &lt;size&gt;) is basically (logxor -1 (mask.1's position size))These two functions use a diagonal array of pre-computed masks, which is accessed by \getbaseptr's over a 32-cell index array (this is to substitutefor "fast" elt, since ELT isn't yet in microcode).  Macro definitions for bothfuns cause all calls to MASK.1'S to turn into these "fast" elts.(POWEROFTWOP &lt;x&gt;) where &lt;x&gt; is an integer, quickly returns its result.(INTEGERLENGTH &lt;x&gt;) is basically log2 of n; that is how long the integer    representation of &lt;x&gt; is when expressed in base 2.    For example,    (haulong 13) = 4; &lt;x&gt; must be an integer, and for negative arguments,     the result is the same as that of the absolute value.(HAIPART &lt;x&gt; &lt;n&gt;) gets the high-order &lt;n&gt; bits of the two's complement      representation of the integer &lt;x&gt;; for negative &lt;n&gt;, it gets the low-order      &lt;-n&gt; bits.  Note that "high-order" is not dependent on word size, but      is derived from (HAULONG &lt;x&gt;).(IMOD &lt;x&gt; &lt;modulus&gt;)  returns &lt;a&gt; where &lt;a&gt; is in the closed interval     [0, 1, ... &lt; modulus-1&gt;]  and &lt;x&gt; = m*&lt;modulus&gt;+&lt;a&gt;.   NoteWell:     this is *not* the same as the REMAINDER function, since &lt;a&gt; is always     non-negative.    The argument &lt;modulus&gt;  may  also be CELL or WORD,    in which case the appropriate size is substituted to truncate to a cell-sized     or word-sized integer.   A macro definition for mod optimizes the case for     compilation where &lt;n&gt; is constant and is a power of two.(EVENP &lt;x&gt; &lt;n&gt;) is true iff &lt;x&gt; is 0 mod &lt;n&gt;;  &lt;n&gt; defaults to two if not       supplied.  Currently both arguments must be integers.  A macro      definition also does some compile-time optimization, particularly      for the case where &lt;n&gt; is a power of two.(ODDP &lt;x&gt;  &lt;n&gt;) is just (not (evenp &lt;x&gt; &lt;n&gt;));  has both expr and macro      definition.(IMODLESSP &lt;x&gt; &lt;y&gt; &lt;modulus&gt; &lt;equal?&gt;)  This function is inspired by      the need to use "wrap-around" counters.  It is not possible to define a      "perfect" ordering function on the integers [0, 1, ... &lt;modulus-1&gt;], but      this function takes the view that it is better to limit the "diameter"      of the applicable domain, than to "bump" into the singularity at the      endpoints of the interval.  So MODLESSP will return "true" iff      &lt;y&gt;-&lt;x&gt; mod &lt;modulus&gt; is less than 1/2*&lt;modulus&gt;.  The optional      argument &lt;equal?&gt;, if non-null, says to do a "less than or equal"      test rather than a "lessp" test.  Generally the &lt;modulus&gt; should be      a power of two (for faster running speed), but this isn't necessary.      Two exceptional arguments are also admitted -- if &lt;modulus&gt; is       'WORD, then the appropriate value is taken for word-sized arithmetic;      if it is 'CELL, then the appropriate value is taken for double-word,      or cell, sized arithmetic.  In Interlisp-D, WORD sized is 16-bit, and      CELL-sized is 32-bit.(TIMEREXPIRED? &lt;x&gt; &lt;y&gt;)   Basically, this function just calls MODLESSP with    &lt;x&gt; and &lt;y&gt; and a modulus argument derived from the size of the clock    behind the CLOCK function; however, if &lt;y&gt; is omitted (or is NIL), it    defaults to the value of (CLOCK 0), but without doing any consing.    Typical usage is in implementing an "alarmclock".    One will set some    variable, say TIMEOUT, to (MODPLUS (CLOCK 0) &lt;duration&gt;), and    then frequently test (TIMELESSP TIMEOUT); when this test first    becomes false, the timer,  or "alarmclock",  has expired.(IMODPLUS &lt;x&gt; &lt;y&gt; &lt;modulus&gt;)(IMODDIFFERENCE &lt;x&gt; &lt;y&gt; &lt;modulus&gt;)    These two functions are essentially (MOD (&lt;operation&gt; &lt;x&gt; &lt;y&gt;) &lt;modulus&gt;),    except no overflow is permitted to occur during the intermediate &lt;operation&gt;.    A macro produces some slightly-optimized code for the case where &lt;modulus&gt;    is CELL.   A current limitation  is that an arithmetic overflow occurring when    &lt;modulus&gt; is not a power of two (or CELL or WORD) causes an error.(BITTEST &lt;n&gt; &lt;mask&gt;)  is the CommonLisp function defined as    (NEQ 0 (LOGAND &lt;n&gt; &lt;mask&gt;)).(ROT &lt;x&gt; &lt;n&gt; &lt;wordsize&gt;)  is a slight extension of the CommonLisp ROT    function;  it performs a bitwise-rotation of the integer &lt;x&gt;, by &lt;n&gt; places,      within a field of &lt;wordsize&gt; bits wide.   The optional argument &lt;wordsize&gt;     defaults to CELL, and must either be an  integer in the range 1 to     &lt;bitspercell&gt;, or else be one of the litatoms CELL or WORD; in the latter     two cases the quantities &lt;bitspercell&gt; and &lt;bitsperword&gt; are respectively    substituted.  A macro optimizes the case where &lt;wordsize&gt; is WORD and &lt;n&gt;     is 1; this is to help with the 16-bit rotate found in checksumming algorithms.***** The remaining documentation is about \-named functions ******The following two functions are essentially the CommonLisp functionsLOAD-BYTE and DEPOSIT-BYTE, but without any error or consistencychecking.  There are versions with the checking, under similar, non-\ names, in another file (to be released at a later date).(\XLOADBYTE &lt;x&gt; &lt;position&gt; &lt;size&gt;) is derived from the PDP-10 LDB      instruction;  it takes a byte of length &lt;size&gt; out of the integer &lt;x&gt;       which byte has &lt;position&gt; bits to the right of it when &lt;x&gt; is viewed      in binary notation.(\XDEPOSITBYTE &lt;x&gt; &lt;position&gt; &lt;size&gt; &lt;newval&gt;) is derived from the PDP-10       DPB instruction; it does not "modify memory" however, but returns      an integer obtained by replaceing the byte of &lt;x&gt; as specified under      LOADBYTE with the low-order &lt;size&gt; bits of &lt;newval&gt;.The following four functions implement a feature that Ron asked for a longtime ago, and probably should not be documented for random users, unlessall the \-functions will be so documented:(\GETBASEBITS &lt;addr&gt; &lt;bit-offset&gt; &lt;n&gt;) returns a integer obtained by      starting at the word address &lt;addr&gt;, skipping over &lt;bit-offset&gt; bits,      and getting the next &lt;n&gt; bits from memory.   In this scenario, bits      are numbered with 0 being the high-order position in the word, and      with incresing bit-addresses leading to increasing word address.  Thus      bit address 15 is the low-order bit of some  word, and bit address 16 is      the high-order bit of the next word.   The low-order bit of the result      is obtained from the bit found at &lt;bit-offset&gt;+&lt;n&gt;-1 bits after bit 0 of      the word at &lt;addr&gt;.  This ordering of bits and bytes within a memor</pre>
  </body>
</html>
