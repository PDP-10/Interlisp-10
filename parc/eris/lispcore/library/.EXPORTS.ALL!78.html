<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>LIBRARY>EXPORTS.ALL!78</title>
  </head>
  <body>
    <pre>
(LISPXPRIN1 "EXPORTS GATHERED FROM {ERIS}&lt;LISPCORE&gt;SOURCES&gt; ON 10-Oct-86 22:45:08"  T)(LISPXTERPRI T)(RPAQQ FILESETS (0LISPSET 1LISPSET 2LISPSET 3LISPSET 4LISPSET 5LISPSET 6LISPSET 7LISPSET 8LISPSET 9LISPSET))(RPAQQ 0LISPSET (LLFAULT LLSUBRS LLBFS LLNEW FILEIO IMAGEIO LLBASIC LLGC LLINTERP LLMVS LLARRAYELT LLARITH LLFLOAT LLBIGNUM LLREAD LLCHAR LLSTK LLDATATYPE LLKEY LLTIMER))(RPAQQ 1LISPSET (ASTACK DTDECLARE ATBL LLCODE IOCHAR COREIO AOFD ADIR PMAP VANILLADISK MOD44IO ATERM APRINT ABASIC AERROR AINTERRUPT MISC BOOTSTRAP PROC LLETHER PUP LEAF PASSWORDS FONT LLDISPLAY APUTDQ COMPATIBILITY DMISC CMLMACROS CMLLIST CMLARRAY LLSYMBOL LLPACKAGE))(RPAQQ 2LISPSET (ACODE MACHINEINDEPENDENT POSTLOADUP))(RPAQQ 3LISPSET (MACROS DLAP BYTECOMPILER COMPILE))(RPAQQ 4LISPSET (EDIT WEDIT HELPDL PRETTY COMMENT BREAK ADVISE LOADFNS FILEPKG DFILE DMISC))(RPAQQ 5LISPSET (HIST UNDO SPELL DWIM WTFIX CLISP DWIMIFY CLISPIFY RECORD ASSIST))(RPAQQ 6LISPSET (MSANALYZE MSPARSE MASTERSCOPE HPRINT BRKDWN MATCH))(RPAQQ 7LISPSET (ADISPLAY DEXEC AARITH AFONT HARDCOPY PRESS PUPPRINT HLDISPLAY MENU WINDOW WBREAK INSPECT BSP CHAT TRSERVER 10MBDRIVER LLNS DISKDLION SPP COURIER NSPRINT CLEARINGHOUSE NSFILING INTERPRESS ADDARITH MACROAUX DEDIT DSPRINTDEF NEWPRINTDEF TTYIN DPUPFTP FLOPPY))(RPAQQ 8LISPSET (MAKEINIT MEM RENAMEFNS))(RPAQQ 9LISPSET (LLFCOMPILE VMEM READSYS APS PCALLSTATS UPCSTATS REMOTEVMEM))(PUTPROP (QUOTE FILESETS) (QUOTE IMPORTDATE) (IDATE " 5-Oct-86 17:01:30"))(RPAQQ MODARITHMACROS (CEIL FLOOR FOLDHI FOLDLO MODUP UNFOLD MOD))(PUTPROPS CEIL MACRO ((X N) (FLOOR (IPLUS X (CONSTANT (SUB1 N))) N)))(PUTPROPS FLOOR MACRO ((X N) (LOGAND X (CONSTANT (LOGXOR (SUB1 N) -1)))))(PUTPROPS FOLDHI MACRO (X (PROG ((FORM (CAR X)) (DIVISOR (CAR (CONSTANTEXPRESSIONP (CADR X))))) (OR (AND DIVISOR (POWEROFTWOP DIVISOR)) (\ILLEGAL.ARG (CADR X))) (RETURN (LIST (QUOTE LRSH) (LIST (QUOTE IPLUS) FORM (SUB1 DIVISOR)) (SUB1 (INTEGERLENGTH DIVISOR)))))))(PUTPROPS FOLDLO MACRO (X (PROG ((FORM (CAR X)) (DIVISOR (CAR (CONSTANTEXPRESSIONP (CADR X))))) (OR (AND DIVISOR (POWEROFTWOP DIVISOR)) (\ILLEGAL.ARG (CADR X))) (RETURN (LIST (QUOTE LRSH) FORM (SUB1 (INTEGERLENGTH DIVISOR)))))))(PUTPROPS MODUP MACRO (OPENLAMBDA (X N) (IDIFFERENCE (SUB1 N) (IMOD (SUB1 X) N))))(PUTPROPS UNFOLD MACRO (X (PROG ((FORM (CAR X)) (DIVISOR (CAR (CONSTANTEXPRESSIONP (CADR X))))) (OR (AND DIVISOR (POWEROFTWOP DIVISOR)) (\ILLEGAL.ARG (CADR X))) (RETURN (LIST (QUOTE LLSH) FORM (SUB1 (INTEGERLENGTH DIVISOR)))))))(PUTPROPS MOD MACRO (= . IMOD))(RPAQQ BITSPERNIBBLE 4)(RPAQQ NIBBLESPERBYTE 2)(RPAQQ BITSPERBYTE 8)(RPAQQ BITSPERCELL 32)(RPAQQ BITSPERWORD 16)(RPAQQ BYTESPERCELL 4)(RPAQQ BYTESPERPAGE 512)(RPAQQ BYTESPERWORD 2)(RPAQQ CELLSPERPAGE 128)(RPAQQ CELLSPERSEGMENT 32768)(RPAQQ PAGESPERSEGMENT 256)(RPAQQ WORDSPERCELL 2)(RPAQQ WORDSPERPAGE 256)(RPAQQ WORDSPERSEGMENT 65536)(RPAQQ WORDSPERQUAD 4)(RPAQQ CELLSPERQUAD 2)(RPAQQ BYTESPERQUAD 8)(CONSTANTS BITSPERNIBBLE NIBBLESPERBYTE BITSPERBYTE BITSPERCELL BITSPERWORD BYTESPERCELL BYTESPERPAGE BYTESPERWORD CELLSPERPAGE CELLSPERSEGMENT PAGESPERSEGMENT WORDSPERCELL WORDSPERPAGE WORDSPERSEGMENT WORDSPERQUAD CELLSPERQUAD BYTESPERQUAD)(RPAQQ INTEGERSIZECONSTANTS ((BITS.PER.SMALLP (ADD1 BITSPERWORD)) (SMALLP.LENGTH (SUB1 BITS.PER.SMALLP)) (MAX.SMALLP (LOGOR (LSH 1 (SUB1 SMALLP.LENGTH)) (SUB1 (LSH 1 (SUB1 SMALLP.LENGTH))))) (MIN.SMALLP (IDIFFERENCE -1 MAX.SMALLP)) (BITS.PER.FIXP BITSPERCELL) (FIXP.LENGTH (SUB1 BITS.PER.FIXP)) (MAX.FIXP (LOGOR (LSH 1 (SUB1 FIXP.LENGTH)) (SUB1 (LSH 1 (SUB1 FIXP.LENGTH))))) (MIN.FIXP (IDIFFERENCE -1 MAX.FIXP))))(RPAQ BITS.PER.SMALLP (ADD1 BITSPERWORD))(RPAQ SMALLP.LENGTH (SUB1 BITS.PER.SMALLP))(RPAQ MAX.SMALLP (LOGOR (LSH 1 (SUB1 SMALLP.LENGTH)) (SUB1 (LSH 1 (SUB1 SMALLP.LENGTH)))))(RPAQ MIN.SMALLP (IDIFFERENCE -1 MAX.SMALLP))(RPAQ BITS.PER.FIXP BITSPERCELL)(RPAQ FIXP.LENGTH (SUB1 BITS.PER.FIXP))(RPAQ MAX.FIXP (LOGOR (LSH 1 (SUB1 FIXP.LENGTH)) (SUB1 (LSH 1 (SUB1 FIXP.LENGTH)))))(RPAQ MIN.FIXP (IDIFFERENCE -1 MAX.FIXP))(CONSTANTS (BITS.PER.SMALLP (ADD1 BITSPERWORD)) (SMALLP.LENGTH (SUB1 BITS.PER.SMALLP)) (MAX.SMALLP (LOGOR (LSH 1 (SUB1 SMALLP.LENGTH)) (SUB1 (LSH 1 (SUB1 SMALLP.LENGTH))))) (MIN.SMALLP (IDIFFERENCE -1 MAX.SMALLP)) (BITS.PER.FIXP BITSPERCELL) (FIXP.LENGTH (SUB1 BITS.PER.FIXP)) (MAX.FIXP (LOGOR (LSH 1 (SUB1 FIXP.LENGTH)) (SUB1 (LSH 1 (SUB1 FIXP.LENGTH))))) (MIN.FIXP (IDIFFERENCE -1 MAX.FIXP)))(PUTPROP (QUOTE MODARITH) (QUOTE IMPORTDATE) (IDATE "30-Dec-84 04:01:08"))(RPAQQ WINDFLG T)(CONSTANTS (WINDFLG T))(RPAQQ INITCONSTANTS ((* ;;; "(LISPNAME VALUE BCPLNAME UCODENAME)") (CDRCODING 1 T T) (* ; "IF CDRCODING=0, CDR CODING IS OFF, OTHERWISE ON") (* ;; "type numbers -- repeated on LLBASIC too") (\SMALLP 1 SMALLTYPE SmallType) (\FIXP 2 INTEGERTYPE FixpType) (\FLOATP 3 FLTPTTYPE FloatpType) (\LITATOM 4 ATOMTYPE AtomType) (\LISTP 5 LISTTYPE ListType) (\ARRAYP 6 ARRAYPTRTYPE ArrayType) (\STRINGP 7 STRINGPTRTYPE) (\STACKP 8) (\CHARACTERP 9) (\VMEMPAGEP 10 NIL VMemPagePType) (\STREAM 11 NIL STREAMTYPE) (* ;; "TYPE TABLE CONSTANTS") (\TT.TYPEMASK 2047 TTTypeMask T) (\TT.NOREF 32768 NIL T) (\TT.LISPREF 16384 NIL T) (\TT.FIXP 8192) (\TT.NUMBERP 4096) (\TT.ATOM 2048) (* ;; "page map") (\PMblockSize 32 PMBLOCKSIZE) (\STATSsize 8 T) (\NumPMTpages 8) (\EmptyPMTEntry 65535 T) (\FirstVmemBlock 2 T) (\MAXVMPAGE 65533) (\MAXVMSEGMENT 255) (* ;; "interface page") (\IFPValidKey 5603 T) (* ;; "MDS") (\FirstMDSPage 16382) (\MaxMDSPage 65533) (\DefaultSecondMDSPage 65532) (\MDSIncrement 512) (\PagesPerMDSUnit 2) (* ; "(FOLDLO \MDSIncrement WORDSPERPAGE)") (* ;; "arrays") (\ARRAYSPACE (19 0)) (\FirstArraySegment 19) (\FirstArrayPage 4864) (\ARRAYSPACE2 (64 0)) (\DefaultSecondArrayPage 16384) (* ;; "stack block constants") (\StackMask 57344 T T) (\FxtnBlock 49152 T T) (\GuardBlock 57344 T T) (\BFBlock 32768 T T) (\FreeStackBlock 40960 T T) (\NotStackBlock 0) (* ; "none of the above") (\MinExtraStackWords 32 T T) (* ;; "backspace kludge") (ERASECHARCODE 0 T) (* ;; "GC constants") (\HT1CNT 1024 NIL T) (\HTSTKBIT 512 NIL T) (\HTCNTMASK 64512 NIL T) (\HTMAINSIZE 32768 NIL T) (\HTCOLLSIZE 65528 NIL T) (\HTENDFREE 1 NIL T) (\HTFREEPTR 0 NIL T) (* ;; "pointers and lengths of various data spaces") (\ATOMSPACE (0 0) (ATOMspace NIL) (atomHiVal NIL)) (\AtomHI 0) (\CHARHI 7) (* ; "overlap character space and the atom hash table space") (\AtomHashTable (7 0) (AHTspace AHTbase)) (\AtomHTpages 256 AHTSIZE) (\LastAtomPage 255) (\MaxAtomFrLst 65535) (\SMALLPOSPSPACE (14 0)) (\SmallPosHi 14 SMALLPOSspace smallpl) (\SMALLNEGSPACE (15 0)) (\SmallNegHi 15 SMALLNEGspace smallneg) (\NumSmallPages 512) (\PNPSPACE (8 0) (PNPspace PNPbase)) (\PNAME.HI 8) (\DEFSPACE (10 0) (DEFspace DEFbase) (DEFspace DEFbase)) (\DEF.HI 10) (\VALSPACE (12 0) (TOPVALspace TOPVALbase) (VALspace VALbase)) (\VAL.HI 12) (\PLISTSPACE (2 0) (PLISTspace PLISTbase)) (\PLIST.HI 2) (\PAGEMAP (5 0) (PAGEMAPspace PAGEMAPbase)) (\NumPageMapPages 256) (\PageMapTBL (6 512) (PMTspace PMTbase)) (\InterfacePage (6 0) (INTERFACEspace INTERFACEbase) (INTERFACEspace INTERFACEbase)) (\IOPAGE (0 65280)) (\DoveIORegion (0 16384)) (\IOCBPAGE (0 256)) (\FPTOVP (4 0)) (\MDSTypeTable (6 32768) (MDSTYPEspace MDSTYPEbase) (MDSTYPEspace MDSTYPEbase)) (\MDSTTsize 128 T) (\MISCSTATS (6 2560) (STATSspace MISCSTATSbase)) (\UFNTable (6 3072) NIL (STATSspace UFNTablebase)) (\UFNTableSize 2) (\DTDSpaceBase (6 4096) (DTDspace DTDbase) (DTDspace DTDbase)) (\DTDSize 16 T) (\LISTPDTD (6 4176)) (\EndTypeNumber 2047) (\LOCKEDPAGETABLE (6 28672)) (\NumLPTPages 16) (\STACKSPACE (1 0) (STACKspace NIL) (STACKspace NIL)) (\GuardStackAddr 61440) (\LastStackAddr 65534) (\STACKHI 1 T T) (\HTMAIN (16 0) (HTMAINspace HTMAINbase) (HTMAINspace HTMAINbase)) (\HTMAINnpages 129 T) (\HTOVERFLOW (16 32768) NIL (NIL HTOVERFLOWbase)) (\HTBIGCOUNT (16 33024)) (\HTCOLL (17 0) NIL (HTCOLLspace HTCOLLbase)) (\DISPLAYREGION (18 0)) (\D1BCPLspace 0 T LEmubrHiVal) (\D0BCPLspace 0 T) (* ;; "Interface Page locations") (\CurrentFXP 0 T T) (\ResetFXP 1 T T) (\SubovFXP 2 T T) (\KbdFXP 3 T T) (\HardReturnFXP 4 T T) (\GCFXP 5) (\FAULTFXP 6 T T) (\MiscFXP 14 T T) (\TeleRaidFXP 24 T T) (* ;; "emulator segment locations") (DCB.EM 272) (DISPINTERRUPT.EM 273) (CURSORBITMAP.EM 281) (KBDAD0.EM 65052) (KBDAD1.EM 65053) (KBDAD2.EM 65054) (KBDAD3.EM 65055) (UTILIN.EM 65048) (CURSORX.EM 278) (CURSORY.EM 279) (MOUSEX.EM 276) (MOUSEY.EM 277) (\LispKeyMask 8192 T T) (\BcplKeyMask 4352 T T) (* ; "Machine types") (\DOLPHIN 4) (\DORADO 5) (\DANDELION 6) (\DAYBREAK 8) (* ;; "FOR DLION (AND DAYBREAK)") (\VP.DISPLAY 4608) (\NP.DISPLAY 202) (* ; "for Dorado display 1024x808 pixels / (16 pixels/word x 256 words/page)") (\NP.WIDEDOVEDISPLAY 243) (* ; "Wide Dove display 1152x864 pixels") (\WIDEDOVEDISPLAYWIDTH 1152) (\RP.AFTERDISPLAY 206) (* ; "Includes 4 pages for cursor") (\RP.AFTERDOVEDISPLAY 243) (* ; "if big screen") (\RP.DISPLAY 0) (\RP.TEMPDISPLAY 1537) (\RP.MISCLOCKED 1780) (* ; "(+ \RP.TEMPDISPLAY \NP.WIDEDOVEDISPLAY)") (\RP.STACK 768) (\VP.STACK 256) (\RP.MAP 256) (\NP.MAP 256) (\RP.IOPAGE 512) (* ; "The DOVE IOCBPAGE can go anywhere, but should be under the 1mbyte range") (\RP.DOVEIOCBPAGE 543) (\RP.DOVEIORGN 544) (\VP.DOVEIORGN 64) (\DOVEIORGNSIZE 64) (\VP.IOPAGE 255) (\VP.IFPAGE 1536) (\VP.FPTOVP 1024) (\NP.FPTOVP 256) (\RP.FPTOVP 1024) (\RP.STARTBUFFERS 640) (\VP.TYPETABLE 1664) (\NP.TYPETABLE 128) (\RP.TYPETABLE 1280) (\VP.GCTABLE 4096) (\NP.GCTABLE 128) (\RP.GCTABLE 1408) (\VP.GCOVERFLOW 4224) (\NP.GCOVERFLOW 1) (\RP.GCOVERFLOW 1536) (\FP.IFPAGE 2) (\VP.IOCBS 1) (\VP.PRIMARYMAP 1538) (\VP.SECONDARYMAP 1280) (\VP.LPT 1648) (\VP.INITSCRATCH 8) (\VP.RPT 128) (\VP.BUFFERS 218) (* ; "DLion processor commands") (\DL.PROCESSORBUSY 32768) (\DL.SETTOD 32769) (\DL.READTOD 32770) (\DL.READPID 32771) (\DL.BOOTBUTTON 32772)))(RPAQQ \INITSUBRS (\uCodeCheck was\StackOverflow \NWWInterrupt was\PageFault \StatsOverflow NOOPSUBR \BACKGROUNDSUBR \CHECKBCPLPASSWORD DISKPARTITION DSPBOUT \DSPRATE \GATHERSTATS \GETPACKETBUFFER \LISPFINISH \MOREVMEMFILE RAID \READRAWPBI \WRITERAWPBI SETSCREENCOLOR SHOWDISPLAY \PUPLEVEL1STATE \WRITESTATS \CONTEXTSWITCH \COPYSYS0SUBR \WRITEMAP))(RPAQQ MISCSTATSLAYOUT ((STARTTIME FIXP MSstrtTime) (TOTALTIME FIXP) (SWAPWAITTIME FIXP T) (PAGEFAULTS FIXP T) (SWAPWRITES FIXP T) (DISKIOTIME FIXP T) (DISKOPS FIXP T) (KEYBOARDWAITTIME FIXP T) (GCTIME FIXP T) (NETIOTIME FIXP T) (NETIOOPS FIXP T) (SWAPTEMP0 FIXP) (SWAPTEMP1 FIXP) (RCLKSECOND FIXP) (SECONDSCLOCK FIXP) (MILLISECONDSCLOCK FIXP) (BASECLOCK FIXP) (RCLKTEMP0 FIXP) (SECONDSTMP FIXP) (MILLISECONDSTMP FIXP) (BASETMP FIXP) (EXCESSTIMETMP FIXP) (CLOCKTEMP0 FIXP) (DISKTEMP0 FIXP) (DISKTEMP1 FIXP) (TELERAIDTEMP1 FIXP) (TELERAIDTEMP2 FIXP) (TELERAIDTEMP3 FIXP) (LASTUSERACTION FIXP) (DLMOUSETIMER FIXP) (DLMOUSETEMP FIXP)))(RPAQQ IFPAGELAYOUT ((CurrentFXP WORD) (ResetFXP WORD) (SubovFXP WORD) (KbdFXP WORD) (HardReturnFXP WORD) (GCFXP WORD) (FAULTFXP WORD) (EndOfStack WORD) (LVersion WORD) (MinRVersion WORD) (MinBVersion WORD) (RVersion WORD) (BVersion WORD) (MachineType WORD) (MiscFXP WORD) (Key WORD) (SerialNumber WORD) (EmulatorSpace WORD) (ScreenWidth WORD) (NxtPMAddr WORD) (NActivePages WORD) (NDirtyPages WORD) (filePnPMP0 WORD) (filePnPMT0 WORD) (TELERAIDFXP WORD) (NIL WORD) (NIL WORD) (NIL WORD) (UserNameAddr WORD) (UserPswdAddr WORD) (StackBase WORD) (FAULTHI WORD) (FAULTLO WORD) (wasREALPAGETABLE WORD) (RPTSIZE WORD) (RPOFFSET WORD) (wasRPTLAST WORD) (EMBUFVP WORD) (NSHost0 WORD) (NSHost1 WORD) (NSHost2 WORD) (MDSZone WORD) (MDSZoneLength WORD) (EMUBUFFERS WORD) (EMUBUFLENGTH WORD) (LASTNUMCHARS WORD) (SYSDISK WORD) (ISFMAP WORD) (* ;; "These are for \MISCAPPLY* -- note that they are not ref counted, so don't pass the only pointer to something this way!") (MISCSTACKFN FULLXPOINTER) (MISCSTACKARG1 FULLXPOINTER) (MISCSTACKARG2 FULLXPOINTER) (MISCSTACKRESULT FULLXPOINTER) (NRealPages WORD) (LastLockedFilePage WORD) (LastDominoFilePage WORD) (FPTOVPStart WORD) (FAKEMOUSEBITS WORD) (DL24BitAddressable WORD) (REALPAGETABLEPTR FULLXPOINTER) (DLLastVmemPage WORD) (FullSpaceUsed WORD) (FAKEKBDAD4 WORD) (FAKEKBDAD5 WORD)))(RPAQQ IOPAGELAYOUT ((NIL 18 WORD) (DLMAINTPANEL WORD NIL T) (DLFLOPPYCMD WORD) (DLTTYPORTCMD WORD) (DLPROCESSORCMD WORD) (NEWMOUSESTATE WORD) (DLBEEPCMD WORD) (DLRS232CMISCCOMMAND WORD) (DLRS232CPUTFLAG WORD) (DLRS232CGETFLAG WORD) (NIL 6 WORD) (DLFLOPPY WORD) (DLTTYOUT WORD) (NIL 1 WORD) (DLTTYIN WORD) (NIL 1 WORD) (DLPROCESSOR2 WORD) (DLPROCESSOR1 WORD) (DLPROCESSOR0 WORD) (NEWMOUSEX WORD) (NEWMOUSEY WORD) (DLBEEPFREQ WORD) (DLRS232CPARAMETERCSBLO WORD) (DLRS232CPARAMETERCSBHI WORD) (DLRS232CSETRS366STATUS 3 WORD) (DLRS232CPUTCSBLO WORD) (DLRS232CPUTCSBHI WORD) (DLRS232CGETCSBLO WORD) (DLRS232CGETCSBHI WORD) (DLRS232CDEVICESTATUS WORD) (DLRS232CPARAMETEROUTCOME WORD) (DLTODVALID WORD) (DLTODLO WORD NIL T) (DLTODHI WORD) (DLTODLO2 WORD) (DLMOUSEX WORD NIL T) (DLMOUSEY WORD NIL T) (DLUTILIN WORD NIL T) (DLKBDAD0 WORD NIL T) (DLKBDAD1 WORD NIL T) (DLKBDAD2 WORD NIL T) (DLKBDAD3 WORD NIL T) (DLKBDAD4 WORD NIL T) (DLKBDAD5 WORD NIL T) (DLLSEPIMAGECSB 32 WORD) (DLIOPHARDWARECONFIG WORD) (NIL 11 WORD) (DLRS232CPARAMETERCSBLO.11 WORD) (DLRS232CPARAMETERCSBHI.11 WORD) (DLRS232CSETRS366STATUS.11 14 WORD) (NIL 60 WORD) (DLMAGTAPE 4 WORD) (DLETHERNET 12 WORD NIL T) (NIL 31 WORD) (DLDISPINTERRUPT WORD NIL T) (DLDISPCONTROL WORD) (DLDISPBORDER WORD) (DLCURSORX WORD NIL T) (DLCURSORY WORD NIL T) (DLCURSORBITMAP 16 WORD NIL T)))(RPAQQ \INITSUBRS (\uCodeCheck was\StackOverflow \NWWInterrupt was\PageFault \StatsOverflow NOOPSUBR \BACKGROUNDSUBR \CHECKBCPLPASSWORD DISKPARTITION DSPBOUT \DSPRATE \GATHERSTATS \GETPACKETBUFFER \LISPFINISH \MOREVMEMFILE RAID \READRAWPBI \WRITERAWPBI SETSCREENCOLOR SHOWDISPLAY \PUPLEVEL1STATE \WRITESTATS \CONTEXTSWITCH \COPYSYS0SUBR \WRITEMAP))(PUTPROPS \uCodeCheck ARGNAMES (DUMMY))(PUTPROPS was\StackOverflow ARGNAMES (DUMMY))(PUTPROPS \NWWInterrupt ARGNAMES (DUMMY))(PUTPROPS \StatsOverflow ARGNAMES (DUMMY))(PUTPROPS NOOPSUBR ARGNAMES (DUMMY))(PUTPROPS \BACKGROUNDSUBR ARGNAMES (DUMMY))(PUTPROPS \CHECKBCPLPASSWORD ARGNAMES (PASS VECTOR))(PUTPROPS DISKPARTITION ARGNAMES NIL)(PUTPROPS DSPBOUT ARGNAMES (CHARCODE))(PUTPROPS \DSPRATE ARGNAMES (AC0 AC1 AC2))(PUTPROPS \GATHERSTATS ARGNAMES (FID))(PUTPROPS \GETPACKETBUFFER ARGNAMES NIL)(PUTPROPS \LISPFINISH ARGNAMES (DUMMY))(PUTPROPS \MOREVMEMFILE ARGNAMES (FILEPAGE))(PUTPROPS RAID ARGNAMES (MESS1 MESS2 FLG))(PUTPROPS \READRAWPBI ARGNAMES NIL)(PUTPROPS \WRITERAWPBI ARGNAMES (PBI))(PUTPROPS SETSCREENCOLOR ARGNAMES (FLG))(PUTPROPS SHOWDISPLAY ARGNAMES (BASE RASTERWIDTH))(PUTPROPS \PUPLEVEL1STATE ARGNAMES (FLG))(PUTPROPS \WRITESTATS ARGNAMES (TYPE X1 X2 X3 X4 X5 X6 X7 X8 X9 X10))(PUTPROPS \CONTEXTSWITCH ARGNAMES (DUMMY))(PUTPROPS \COPYSYS0SUBR ARGNAMES (FID))(PUTPROPS \WRITEMAP ARGNAMES (VP RP FLAGS))(RPAQQ CDRCODING 1)(RPAQQ \SMALLP 1)(RPAQQ \FIXP 2)(RPAQQ \FLOATP 3)(RPAQQ \LITATOM 4)(RPAQQ \LISTP 5)(RPAQQ \ARRAYP 6)(RPAQQ \STRINGP 7)(RPAQQ \STACKP 8)(RPAQQ \CHARACTERP 9)(RPAQQ \VMEMPAGEP 10)(RPAQQ \STREAM 11)(RPAQQ \TT.TYPEMASK 2047)(RPAQQ \TT.NOREF 32768)(RPAQQ \TT.LISPREF 16384)(RPAQQ \TT.FIXP 8192)(RPAQQ \TT.NUMBERP 4096)(RPAQQ \TT.ATOM 2048)(RPAQQ \PMblockSize 32)(RPAQQ \STATSsize 8)(RPAQQ \NumPMTpages 8)(RPAQQ \EmptyPMTEntry 65535)(RPAQQ \FirstVmemBlock 2)(RPAQQ \MAXVMPAGE 65533)(RPAQQ \MAXVMSEGMENT 255)(RPAQQ \IFPValidKey 5603)(RPAQQ \FirstMDSPage 16382)(RPAQQ \MaxMDSPage 65533)(RPAQQ \DefaultSecondMDSPage 65532)(RPAQQ \MDSIncrement 512)(RPAQQ \PagesPerMDSUnit 2)(RPAQQ \FirstArraySegment 19)(RPAQQ \FirstArrayPage 4864)(RPAQQ \DefaultSecondArrayPage 16384)(RPAQQ \StackMask 57344)(RPAQQ \FxtnBlock 49152)(RPAQQ \GuardBlock 57344)(RPAQQ \BFBlock 32768)(RPAQQ \FreeStackBlock 40960)(RPAQQ \NotStackBlock 0)(RPAQQ \MinExtraStackWords 32)(RPAQQ ERASECHARCODE 0)(RPAQQ \HT1CNT 1024)(RPAQQ \HTSTKBIT 512)(RPAQQ \HTCNTMASK 64512)(RPAQQ \HTMAINSIZE 32768)(RPAQQ \HTCOLLSIZE 65528)(RPAQQ \HTENDFREE 1)(RPAQQ \HTFREEPTR 0)(RPAQQ \AtomHI 0)(RPAQQ \CHARHI 7)(RPAQQ \AtomHTpages 256)(RPAQQ \LastAtomPage 255)(RPAQQ \MaxAtomFrLst 65535)(RPAQQ \SmallPosHi 14)(RPAQQ \SmallNegHi 15)(RPAQQ \NumSmallPages 512)(RPAQQ \PNAME.HI 8)(RPAQQ \DEF.HI 10)(RPAQQ \VAL.HI 12)(RPAQQ \PLIST.HI 2)(RPAQQ \NumPageMapPages 256)(RPAQQ \MDSTTsize 128)(RPAQQ \UFNTableSize 2)(RPAQQ \DTDSize 16)(RPAQQ \EndTypeNumber 2047)(RPAQQ \NumLPTPages 16)(RPAQQ \GuardStackAddr 61440)(RPAQQ \LastStackAddr 65534)(RPAQQ \STACKHI 1)(RPAQQ \HTMAINnpages 129)(RPAQQ \D1BCPLspace 0)(RPAQQ \D0BCPLspace 0)(RPAQQ \CurrentFXP 0)(RPAQQ \ResetFXP 1)(RPAQQ \SubovFXP 2)(RPAQQ \KbdFXP 3)(RPAQQ \HardReturnFXP 4)(RPAQQ \GCFXP 5)(RPAQQ \FAULTFXP 6)(RPAQQ \MiscFXP 14)(RPAQQ \TeleRaidFXP 24)(RPAQQ DCB.EM 272)(RPAQQ DISPINTERRUPT.EM 273)(RPAQQ CURSORBITMAP.EM 281)(RPAQQ KBDAD0.EM 65052)(RPAQQ KBDAD1.EM 65053)(RPAQQ KBDAD2.EM 65054)(RPAQQ KBDAD3.EM 65055)(RPAQQ UTILIN.EM 65048)(RPAQQ CURSORX.EM 278)(RPAQQ CURSORY.EM 279)(RPAQQ MOUSEX.EM 276)(RPAQQ MOUSEY.EM 277)(RPAQQ \LispKeyMask 8192)(RPAQQ \BcplKeyMask 4352)(RPAQQ \DOLPHIN 4)(RPAQQ \DORADO 5)(RPAQQ \DANDELION 6)(RPAQQ \DAYBREAK 8)(RPAQQ \VP.DISPLAY 4608)(RPAQQ \NP.DISPLAY 202)(RPAQQ \NP.WIDEDOVEDISPLAY 243)(RPAQQ \WIDEDOVEDISPLAYWIDTH 1152)(RPAQQ \RP.AFTERDISPLAY 206)(RPAQQ \RP.AFTERDOVEDISPLAY 243)(RPAQQ \RP.DISPLAY 0)(RPAQQ \RP.TEMPDISPLAY 1537)(RPAQQ \RP.MISCLOCKED 1780)(RPAQQ \RP.STACK 768)(RPAQQ \VP.STACK 256)(RPAQQ \RP.MAP 256)(RPAQQ \NP.MAP 256)(RPAQQ \RP.IOPAGE 512)(RPAQQ \RP.DOVEIOCBPAGE 543)(RPAQQ \RP.DOVEIORGN 544)(RPAQQ \VP.DOVEIORGN 64)(RPAQQ \DOVEIORGNSIZE 64)(RPAQQ \VP.IOPAGE 255)(RPAQQ \VP.IFPAGE 1536)(RPAQQ \VP.FPTOVP 1024)(RPAQQ \NP.FPTOVP 256)(RPAQQ \RP.FPTOVP 1024)(RPAQQ \RP.STARTBUFFERS 640)(RPAQQ \VP.TYPETABLE 1664)(RPAQQ \NP.TYPETABLE 128)(RPAQQ \RP.TYPETABLE 1280)(RPAQQ \VP.GCTABLE 4096)(RPAQQ \NP.GCTABLE 128)(RPAQQ \RP.GCTABLE 1408)(RPAQQ \VP.GCOVERFLOW 4224)(RPAQQ \NP.GCOVERFLOW 1)(RPAQQ \RP.GCOVERFLOW 1536)(RPAQQ \FP.IFPAGE 2)(RPAQQ \VP.IOCBS 1)(RPAQQ \VP.PRIMARYMAP 1538)(RPAQQ \VP.SECONDARYMAP 1280)(RPAQQ \VP.LPT 1648)(RPAQQ \VP.INITSCRATCH 8)(RPAQQ \VP.RPT 128)(RPAQQ \VP.BUFFERS 218)(RPAQQ \DL.PROCESSORBUSY 32768)(RPAQQ \DL.SETTOD 32769)(RPAQQ \DL.READTOD 32770)(RPAQQ \DL.READPID 32771)(RPAQQ \DL.BOOTBUTTON 32772)(CONSTANTS (CDRCODING 1) (\SMALLP 1) (\FIXP 2) (\FLOATP 3) (\LITATOM 4) (\LISTP 5) (\ARRAYP 6) (\STRINGP 7) (\STACKP 8) (\CHARACTERP 9) (\VMEMPAGEP 10) (\STREAM 11) (\TT.TYPEMASK 2047) (\TT.NOREF 32768) (\TT.LISPREF 16384) (\TT.FIXP 8192) (\TT.NUMBERP 4096) (\TT.ATOM 2048) (\PMblockSize 32) (\STATSsize 8) (\NumPMTpages 8) (\EmptyPMTEntry 65535) (\FirstVmemBlock 2) (\MAXVMPAGE 65533) (\MAXVMSEGMENT 255) (\IFPValidKey 5603) (\FirstMDSPage 16382) (\MaxMDSPage 65533) (\DefaultSecondMDSPage 65532) (\MDSIncrement 512) (\PagesPerMDSUnit 2) (\FirstArraySegment 19) (\FirstArrayPage 4864) (\DefaultSecondArrayPage 16384) (\StackMask 57344) (\FxtnBlock 49152) (\GuardBlock 57344) (\BFBlock 32768) (\FreeStackBlock 40960) (\NotStackBlock 0) (\MinExtraStackWords 32) (ERASECHARCODE 0) (\HT1CNT 1024) (\HTSTKBIT 512) (\HTCNTMASK 64512) (\HTMAINSIZE 32768) (\HTCOLLSIZE 65528) (\HTENDFREE 1) (\HTFREEPTR 0) (\AtomHI 0) (\CHARHI 7) (\AtomHTpages 256) (\LastAtomPage 255) (\MaxAtomFrLst 65535) (\SmallPosHi 14) (\SmallNegHi 15) (\NumSmallPages 512) (\PNAME.HI 8) (\DEF.HI 10) (\VAL.HI 12) (\PLIST.HI 2) (\NumPageMapPages 256) (\MDSTTsize 128) (\UFNTableSize 2) (\DTDSize 16) (\EndTypeNumber 2047) (\NumLPTPages 16) (\GuardStackAddr 61440) (\LastStackAddr 65534) (\STACKHI 1) (\HTMAINnpages 129) (\D1BCPLspace 0) (\D0BCPLspace 0) (\CurrentFXP 0) (\ResetFXP 1) (\SubovFXP 2) (\KbdFXP 3) (\HardReturnFXP 4) (\GCFXP 5) (\FAULTFXP 6) (\MiscFXP 14) (\TeleRaidFXP 24) (DCB.EM 272) (DISPINTERRUPT.EM 273) (CURSORBITMAP.EM 281) (KBDAD0.EM 65052) (KBDAD1.EM 65053) (KBDAD2.EM 65054) (KBDAD3.EM 65055) (UTILIN.EM 65048) (CURSORX.EM 278) (CURSORY.EM 279) (MOUSEX.EM 276) (MOUSEY.EM 277) (\LispKeyMask 8192) (\BcplKeyMask 4352) (\DOLPHIN 4) (\DORADO 5) (\DANDELION 6) (\DAYBREAK 8) (\VP.DISPLAY 4608) (\NP.DISPLAY 202) (\NP.WIDEDOVEDISPLAY 243) (\WIDEDOVEDISPLAYWIDTH 1152) (\RP.AFTERDISPLAY 206) (\RP.AFTERDOVEDISPLAY 243) (\RP.DISPLAY 0) (\RP.TEMPDISPLAY 1537) (\RP.MISCLOCKED 1780) (\RP.STACK 768) (\VP.STACK 256) (\RP.MAP 256) (\NP.MAP 256) (\RP.IOPAGE 512) (\RP.DOVEIOCBPAGE 543) (\RP.DOVEIORGN 544) (\VP.DOVEIORGN 64) (\DOVEIORGNSIZE 64) (\VP.IOPAGE 255) (\VP.IFPAGE 1536) (\VP.FPTOVP 1024) (\NP.FPTOVP 256) (\RP.FPTOVP 1024) (\RP.STARTBUFFERS 640) (\VP.TYPETABLE 1664) (\NP.TYPETABLE 128) (\RP.TYPETABLE 1280) (\VP.GCTABLE 4096) (\NP.GCTABLE 128) (\RP.GCTABLE 1408) (\VP.GCOVERFLOW 4224) (\NP.GCOVERFLOW 1) (\RP.GCOVERFLOW 1536) (\FP.IFPAGE 2) (\VP.IOCBS 1) (\VP.PRIMARYMAP 1538) (\VP.SECONDARYMAP 1280) (\VP.LPT 1648) (\VP.INITSCRATCH 8) (\VP.RPT 128) (\VP.BUFFERS 218) (\DL.PROCESSORBUSY 32768) (\DL.SETTOD 32769) (\DL.READTOD 32770) (\DL.READPID 32771) (\DL.BOOTBUTTON 32772))(RPAQQ \MPERRORS ((\MP.OBSOLETEVMEM 1) (\MP.INVALIDVMEM 2 "Vmem inconsistent at startup") (\MP.IOCBPAGE 3 "No place for IOCB page at startup") (\MP.MOB 4 "Map out of bounds") (\MP.INVALIDADDR 5) (\MP.INVALIDVP 6) (\MP.CHAIN.UNAVAIL 7 "Unavailable page on real page table chain") (\MP.SELECTLOOP 8 "Loop in \SELECTREALPAGE") (\MP.NEWPAGE 9 "Attempt to allocate already existing page") (\MP.NEWMAPPAGE 10 "\DONEWPAGE failed to allocate new map page") (\MP.BADLOCKED 11 "Locked page occupies a file page needed to lock another") (\MP.CLOCK0 12 "Arg to CLOCK0 not an integer box") (\MP.RESIDENT 13 "Fault on resident page") (\MP.STACKFAULT 14 "Fault on stack") (\MP.VMEMTOOLONG 16 "Attempt to extend Vmem File beyond fixed limit (8mb)") (\MP.WRITING.LOCKED.PAGE 17 "Writing a locked page with UPDATEKEY = T") (\MP.UNINTERRUPTABLE 18 "Error in uninterruptable system code") (\MP.STACKFULL 19) (\MP.MDSFULL 20) (\MP.UNKNOWN.UFN 21) (\MP.ATOMSFULL 22) (\MP.PNAMESFULL 23) (\MP.USECOUNTOVERFLOW 24) (\MP.MDSFULLWARNING 25) (\MP.BADMDSFREELIST 26) (\MP.BADARRAYBLOCK 27) (\MP.BADDELETEBLOCK 28) (\MP.BADARRAYRECLAIM 29) (\MP.BIGREFCNTMISSING 30 "PTR refcnt previously overflowed, but not found in table.") (\MP.BIGREFCNTALREADYPRESENT 31 "PTR already in overflow table") (\MP.DELREF0 32) (\MP.PROCERROR 33) (\MP.PROCNOFRAME 34 "Failed to build frame for PROCESS use") (\MP.32MBINUSE 35) (\MP.TOPUNWOUND 36 "Unexpected (RETTO T)") (\MP.STACKRELEASED 37) (\MP.FLUSHLOCKED 38) (\MP.MAPNOTLOCKED 39) (\MP.UNLOCKINGMAP 40) (\MP.SWAPDISKERROR 41 "Hard Disk Error in swapper") (\MP.BADRUNTABLE 42 "Malformed run table for vmem file")))(RPAQQ \MP.OBSOLETEVMEM 1)(RPAQ \MP.INVALIDVMEM 2 "Vmem inconsistent at startup")(RPAQ \MP.IOCBPAGE 3 "No place for IOCB page at startup")(RPAQ \MP.MOB 4 "Map out of bounds")(RPAQQ \MP.INVALIDADDR 5)(RPAQQ \MP.INVALIDVP 6)(RPAQ \MP.CHAIN.UNAVAIL 7 "Unavailable page on real page table chain")(RPAQ \MP.SELECTLOOP 8 "Loop in \SELECTREALPAGE")(RPAQ \MP.NEWPAGE 9 "Attempt to allocate already existing page")(RPAQ \MP.NEWMAPPAGE 10 "\DONEWPAGE failed to allocate new map page")(RPAQ \MP.BADLOCKED 11 "Locked page occupies a file page needed to lock another")(RPAQ \MP.CLOCK0 12 "Arg to CLOCK0 not an integer box")(RPAQ \MP.RESIDENT 13 "Fault on resident page")(RPAQ \MP.STACKFAULT 14 "Fault on stack")(RPAQ \MP.VMEMTOOLONG 16 "Attempt to extend Vmem File beyond fixed limit (8mb)")(RPAQ \MP.WRITING.LOCKED.PAGE 17 "Writing a locked page with UPDATEKEY = T")(RPAQ \MP.UNINTERRUPTABLE 18 "Error in uninterruptable system code")(RPAQQ \MP.STACKFULL 19)(RPAQQ \MP.MDSFULL 20)(RPAQQ \MP.UNKNOWN.UFN 21)(RPAQQ \MP.ATOMSFULL 22)(RPAQQ \MP.PNAMESFULL 23)(RPAQQ \MP.USECOUNTOVERFLOW 24)(RPAQQ \MP.MDSFULLWARNING 25)(RPAQQ \MP.BADMDSFREELIST 26)(RPAQQ \MP.BADARRAYBLOCK 27)(RPAQQ \MP.BADDELETEBLOCK 28)(RPAQQ \MP.BADARRAYRECLAIM 29)(RPAQ \MP.BIGREFCNTMISSING 30 "PTR refcnt previously overflowed, but not found in table.")(RPAQ \MP.BIGREFCNTALREADYPRESENT 31 "PTR already in overflow table")(RPAQQ \MP.DELREF0 32)(RPAQQ \MP.PROCERROR 33)(RPAQ \MP.PROCNOFRAME 34 "Failed to build frame for PROCESS use")(RPAQQ \MP.32MBINUSE 35)(RPAQ \MP.TOPUNWOUND 36 "Unexpected (RETTO T)")(RPAQQ \MP.STACKRELEASED 37)(RPAQQ \MP.FLUSHLOCKED 38)(RPAQQ \MP.MAPNOTLOCKED 39)(RPAQQ \MP.UNLOCKINGMAP 40)(RPAQ \MP.SWAPDISKERROR 41 "Hard Disk Error in swapper")(RPAQ \MP.BADRUNTABLE 42 "Malformed run table for vmem file")(CONSTANTS (\MP.OBSOLETEVMEM 1) (\MP.INVALIDVMEM 2 "Vmem inconsistent at startup") (\MP.IOCBPAGE 3 "No place for IOCB page at startup") (\MP.MOB 4 "Map out of bounds") (\MP.INVALIDADDR 5) (\MP.INVALIDVP 6) (\MP.CHAIN.UNAVAIL 7 "Unavailable page on real page table chain") (\MP.SELECTLOOP 8 "Loop in \SELECTREALPAGE") (\MP.NEWPAGE 9 "Attempt to allocate already existing page") (\MP.NEWMAPPAGE 10 "\DONEWPAGE failed to allocate new map page") (\MP.BADLOCKED 11 "Locked page occupies a file page needed to lock another") (\MP.CLOCK0 12 "Arg to CLOCK0 not an integer box") (\MP.RESIDENT 13 "Fault on resident page") (\MP.STACKFAULT 14 "Fault on stack") (\MP.VMEMTOOLONG 16 "Attempt to extend Vmem File beyond fixed limit (8mb)") (\MP.WRITING.LOCKED.PAGE 17 "Writing a locked page with UPDATEKEY = T") (\MP.UNINTERRUPTABLE 18 "Error in uninterruptable system code") (\MP.STACKFULL 19) (\MP.MDSFULL 20) (\MP.UNKNOWN.UFN 21) (\MP.ATOMSFULL 22) (\MP.PNAMESFULL 23) (\MP.USECOUNTOVERFLOW 24) (\MP.MDSFULLWARNING 25) (\MP.BADMDSFREELIST 26) (\MP.BADARRAYBLOCK 27) (\MP.BADDELETEBLOCK 28) (\MP.BADARRAYRECLAIM 29) (\MP.BIGREFCNTMISSING 30 "PTR refcnt previously overflowed, but not found in table.") (\MP.BIGREFCNTALREADYPRESENT 31 "PTR already in overflow table") (\MP.DELREF0 32) (\MP.PROCERROR 33) (\MP.PROCNOFRAME 34 "Failed to build frame for PROCESS use") (\MP.32MBINUSE 35) (\MP.TOPUNWOUND 36 "Unexpected (RETTO T)") (\MP.STACKRELEASED 37) (\MP.FLUSHLOCKED 38) (\MP.MAPNOTLOCKED 39) (\MP.UNLOCKINGMAP 40) (\MP.SWAPDISKERROR 41 "Hard Disk Error in swapper") (\MP.BADRUNTABLE 42 "Malformed run table for vmem file"))(GLOBALVARS \ARRAYSPACE \ARRAYSPACE2 \ATOMSPACE \AtomHashTable \SMALLPOSPSPACE \SMALLNEGSPACE \PNPSPACE \DEFSPACE \VALSPACE \PLISTSPACE \PAGEMAP \PageMapTBL \InterfacePage \IOPAGE \DoveIORegion \IOCBPAGE \FPTOVP \MDSTypeTable \MISCSTATS \UFNTable \DTDSpaceBase \LISTPDTD \LOCKEDPAGETABLE \STACKSPACE \HTMAIN \HTOVERFLOW \HTBIGCOUNT \HTCOLL \DISPLAYREGION)(BLOCKRECORD MISCSTATS ((STARTTIME FIXP) (TOTALTIME FIXP) (SWAPWAITTIME FIXP) (PAGEFAULTS FIXP) (SWAPWRITES FIXP) (DISKIOTIME FIXP) (DISKOPS FIXP) (KEYBOARDWAITTIME FIXP) (GCTIME FIXP) (NETIOTIME FIXP) (NETIOOPS FIXP) (SWAPTEMP0 FIXP) (SWAPTEMP1 FIXP) (RCLKSECOND FIXP) (SECONDSCLOCK FIXP) (MILLISECONDSCLOCK FIXP) (BASECLOCK FIXP) (RCLKTEMP0 FIXP) (SECONDSTMP FIXP) (MILLISECONDSTMP FIXP) (BASETMP FIXP) (EXCESSTIMETMP FIXP) (CLOCKTEMP0 FIXP) (DISKTEMP0 FIXP) (DISKTEMP1 FIXP) (TELERAIDTEMP1 FIXP) (TELERAIDTEMP2 FIXP) (TELERAIDTEMP3 FIXP) (LASTUSERACTION FIXP) (DLMOUSETIMER FIXP) (DLMOUSETEMP FIXP)) (CREATE (\ALLOCBLOCK 31)))(BLOCKRECORD IFPAGE ((CurrentFXP WORD) (ResetFXP WORD) (SubovFXP WORD) (KbdFXP WORD) (HardReturnFXP WORD) (GCFXP WORD) (FAULTFXP WORD) (EndOfStack WORD) (LVersion WORD) (MinRVersion WORD) (MinBVersion WORD) (RVersion WORD) (BVersion WORD) (MachineType WORD) (MiscFXP WORD) (Key WORD) (SerialNumber WORD) (EmulatorSpace WORD) (ScreenWidth WORD) (NxtPMAddr WORD) (NActivePages WORD) (NDirtyPages WORD) (filePnPMP0 WORD) (filePnPMT0 WORD) (TELERAIDFXP WORD) (NIL WORD) (NIL WORD) (NIL WORD) (UserNameAddr WORD) (UserPswdAddr WORD) (StackBase WORD) (FAULTHI WORD) (FAULTLO WORD) (wasREALPAGETABLE WORD) (RPTSIZE WORD) (RPOFFSET WORD) (wasRPTLAST WORD) (EMBUFVP WORD) (NSHost0 WORD) (NSHost1 WORD) (NSHost2 WORD) (MDSZone WORD) (MDSZoneLength WORD) (EMUBUFFERS WORD) (EMUBUFLENGTH WORD) (LASTNUMCHARS WORD) (SYSDISK WORD) (ISFMAP WORD) (* ;; "These are for \MISCAPPLY* -- note that they are not ref counted, so don't pass the only pointer to something this way!") (MISCSTACKFN FULLXPOINTER) (MISCSTACKARG1 FULLXPOINTER) (MISCSTACKARG2 FULLXPOINTER) (MISCSTACKRESULT FULLXPOINTER) (NRealPages WORD) (LastLockedFilePage WORD) (LastDominoFilePage WORD) (FPTOVPStart WORD) (FAKEMOUSEBITS WORD) (DL24BitAddressable WORD) (REALPAGETABLEPTR FULLXPOINTER) (DLLastVmemPage WORD) (FullSpaceUsed WORD) (FAKEKBDAD4 WORD) (FAKEKBDAD5 WORD)) (CREATE (\ALLOCBLOCK 34)))(BLOCKRECORD IOPAGE ((NIL 18 WORD) (DLMAINTPANEL WORD) (DLFLOPPYCMD WORD) (DLTTYPORTCMD WORD) (DLPROCESSORCMD WORD) (NEWMOUSESTATE WORD) (DLBEEPCMD WORD) (DLRS232CMISCCOMMAND WORD) (DLRS232CPUTFLAG WORD) (DLRS232CGETFLAG WORD) (NIL 6 WORD) (DLFLOPPY WORD) (DLTTYOUT WORD) (NIL 1 WORD) (DLTTYIN WORD) (NIL 1 WORD) (DLPROCESSOR2 WORD) (DLPROCESSOR1 WORD) (DLPROCESSOR0 WORD) (NEWMOUSEX WORD) (NEWMOUSEY WORD) (DLBEEPFREQ WORD) (DLRS232CPARAMETERCSBLO WORD) (DLRS232CPARAMETERCSBHI WORD) (DLRS232CSETRS366STATUS 3 WORD) (DLRS232CPUTCSBLO WORD) (DLRS232CPUTCSBHI WORD) (DLRS232CGETCSBLO WORD) (DLRS232CGETCSBHI WORD) (DLRS232CDEVICESTATUS WORD) (DLRS232CPARAMETEROUTCOME WORD) (DLTODVALID WORD) (DLTODLO WORD) (DLTODHI WORD) (DLTODLO2 WORD) (DLMOUSEX WORD) (DLMOUSEY WORD) (DLUTILIN WORD) (DLKBDAD0 WORD) (DLKBDAD1 WORD) (DLKBDAD2 WORD) (DLKBDAD3 WORD) (DLKBDAD4 WORD) (DLKBDAD5 WORD) (DLLSEPIMAGECSB 32 WORD) (DLIOPHARDWARECONFIG WORD) (NIL 11 WORD) (DLRS232CPARAMETERCSBLO.11 WORD) (DLRS232CPARAMETERCSBHI.11 WORD) (DLRS232CSETRS366STATUS.11 14 WORD) (NIL 60 WORD) (DLMAGTAPE 4 WORD) (DLETHERNET 12 WORD) (NIL 31 WORD) (DLDISPINTERRUPT WORD) (DLDISPCONTROL WORD) (DLDISPBORDER WORD) (DLCURSORX WORD) (DLCURSORY WORD) (DLCURSORBITMAP 16 WORD)) (ACCESSFNS IOPAGE ((DLCURSORBITMAPPTR (\ADDBASE DATUM 240)) (DLCURSORYPTR (\ADDBASE DATUM 239)) (DLCURSORXPTR (\ADDBASE DATUM 238)) (DLDISPINTERRUPTPTR (\ADDBASE DATUM 235)) (DLETHERNETPTR (\ADDBASE DATUM 192)) (DLKBDAD5PTR (\ADDBASE DATUM 67)) (DLKBDAD4PTR (\ADDBASE DATUM 66)) (DLKBDAD3PTR (\ADDBASE DATUM 65)) (DLKBDAD2PTR (\ADDBASE DATUM 64)) (DLKBDAD1PTR (\ADDBASE DATUM 63)) (DLKBDAD0PTR (\ADDBASE DATUM 62)) (DLUTILINPTR (\ADDBASE DATUM 61)) (DLMOUSEYPTR (\ADDBASE DATUM 60)) (DLMOUSEXPTR (\ADDBASE DATUM 59)) (DLTODLOPTR (\ADDBASE DATUM 56)) (DLMAINTPANELPTR (\ADDBASE DATUM 18)))) (CREATE (\ALLOCBLOCK 128)))(PUTPROPS EMADDRESS MACRO (ARGS ((LAMBDA (ADDR) (COND ((EQ \D1BCPLspace \D0BCPLspace) (LIST (LIST (QUOTE OPCODES) (QUOTE GCONST) 0 (LRSH ADDR 8) (LOGAND ADDR 255)))) (T (BQUOTE (\VAG2 (fetch EmulatorSpace of \InterfacePage) , ADDR))))) (EVAL (CAR ARGS)))))(PUTPROPS EMGETBASE MACRO ((OFFSET) (\GETBASE (EMADDRESS OFFSET) 0)))(PUTPROPS EMPUTBASE MACRO ((OFFSET VAL) (\PUTBASE (EMADDRESS OFFSET) 0 VAL)))(PUTPROPS EMULATORSEGMENT MACRO (NIL (fetch EmulatorSpace of \InterfacePage)))(PUTPROPS EMPOINTER MACRO (X (COND ((NEQ \D1BCPLspace \D0BCPLspace) (LIST (QUOTE \VAG2) (QUOTE (fetch (IFPAGE EmulatorSpace) of \InterfacePage)) (CAR X))) ((ZEROP (CAR X)) NIL) (T (LIST (QUOTE \VAG2) \D0BCPLspace (CAR X))))))(PUTPROPS EMADDRESSP MACRO (X (LIST (QUOTE EQ) (LIST (QUOTE \HILOC) (CAR X)) (COND ((EQ \D1BCPLspace \D0BCPLspace) \D0BCPLspace) (T (QUOTE (fetch (IFPAGE EmulatorSpace) of \InterfacePage)))))))(PUTPROP (QUOTE LLPARAMS) (QUOTE IMPORTDATE) (IDATE "10-Oct-86 22:28:40"))(DATATYPE COMPILED-CLOSURE (FNHEADER ENVIRONMENT))(/DECLAREDATATYPE (QUOTE COMPILED-CLOSURE) (QUOTE (POINTER POINTER)) (QUOTE ((COMPILED-CLOSURE 0 POINTER) (COMPILED-CLOSURE 2 POINTER))) (QUOTE 4))(RPAQQ \COMPILED-CLOSURE 13)(CONSTANTS \COMPILED-CLOSURE)(PUTPROPS \EXTENDED.EQP MACRO (OPENLAMBDA (X Y) (COND ((EQ (NTYPX X) (NTYPX Y)) (SELECTC (NTYPX X) (\STACKP (EQ (fetch (STACKP EDFXP) of X) (fetch (STACKP EDFXP) of Y))) (\COMPILED-CLOSURE (EQDEFP X Y)) NIL)))))(PUTPROPS DPUTCODE MACRO ((FN CA SIZE) (SELECTQ (SYSTEMTYPE) (D (DEFC FN CA)) (/PUTPROP FN (QUOTE DCODE) CA))))(PUTPROPS MCODEP MACRO ((X) (OR (ARRAYP X) (AND (LITATOM X) (ARRAYP (SELECTQ (SYSTEMTYPE) (D (GETD X)) (GETPROP X (QUOTE DCODE))))))))(PUTPROPS CODELT MACRO ((CA N) (\BYTELT CA N)))(PUTPROPS CODELT2 MACRO (OPENLAMBDA (DEF LC) (LOGOR (LLSH (CODELT DEF LC) BITSPERBYTE) (CODELT DEF (ADD1 LC)))))(PUTPROPS CODESETA2 MACRO (OPENLAMBDA (DEF LC VALUE) (CODESETA DEF LC (LRSH VALUE BITSPERBYTE)) (CODESETA DEF (ADD1 LC) (IMOD VALUE (CONSTANT (LLSH 1 BITSPERBYTE))))))(PUTPROPS CODESETA MACRO ((CA N NV) (\BYTESETA CA N NV)))(ACCESSFNS CODEARRAY ((STKMIN (CODELT2 DATUM 0) (CODESETA2 DATUM 0 NEWVALUE)) (NA (SIGNED (CODELT2 DATUM 2) BITSPERWORD) (CODESETA2 DATUM 2 (UNSIGNED NEWVALUE BITSPERWORD))) (PV (SIGNED (CODELT2 DATUM 4) BITSPERWORD) (CODESETA2 DATUM 4 (UNSIGNED NEWVALUE BITSPERWORD))) (STARTPC (CODELT2 DATUM 6) (CODESETA2 DATUM 6 NEWVALUE)) (ARGTYPE (LOGAND (LRSH (CODELT DATUM 8) 4) 3) (CODESETA DATUM 8 (LOGOR (LOGAND (CODELT DATUM 8) 65487) (LLSH (LOGAND NEWVALUE 3) 4)))) (FRAMENAME (\VAG2 (CODELT DATUM 9) (CODELT2 DATUM 10)) (\FIXCODEPTR DATUM 11 (EVQ NEWVALUE))) (NTSIZE (CODELT2 DATUM 12) (CODESETA2 DATUM 12 NEWVALUE)) (NLOCALS (CODELT DATUM 14) (CODESETA DATUM 14 NEWVALUE)) (FVAROFFSET (CODELT DATUM 15) (CODESETA DATUM 15 NEWVALUE))) (ACCESSFNS CODEARRAY ((LSTARP (ILESSP (fetch (CODEARRAY NA) of DATUM) 0)) (OVERHEADWORDS (PROGN 8)) (ALIGNED (IPLUS (fetch (CODEARRAY NTSIZE) of DATUM) (fetch (CODEARRAY OVERHEADWORDS) of T))) (FIXED NIL (replace (CODEARRAY STKMIN) of DATUM with (IPLUS (UNFOLD (IPLUS (IMAX (fetch (CODEARRAY NA) of DATUM) 0) (UNFOLD (ADD1 (fetch (CODEARRAY PV) of DATUM)) CELLSPERQUAD)) WORDSPERCELL) 12 32))) (FRAMENAME# (PROGN 8)))))(RECORD OPCODE (OP# OPCODENAME OPNARGS OPPRINT LEVADJ UFNFN UNIMPL))(GLOBALVARS \OPCODES)(RPAQQ PVARCODE 32768)(RPAQQ FVARCODE 49152)(RPAQQ IVARCODE 0)(RPAQQ VARCODEMASK 49152)(CONSTANTS PVARCODE FVARCODE IVARCODE VARCODEMASK)(PUTPROP (QUOTE LLCODE) (QUOTE IMPORTDATE) (IDATE " 2-Oct-86 23:23:03"))(RPAQQ \ERRORMESSAGELIST ("SYSTEM ERROR" " " "STACK OVERFLOW" "ILLEGAL RETURN" "ARG NOT LIST" "HARD DISK ERROR" "ATTEMPT TO SET NIL OR T" "ATTEMPT TO RPLAC NIL" "UNDEFINED OR ILLEGAL GO" "FILE WON'T OPEN" "NON-NUMERIC ARG" "ATOM TOO LONG" "ATOM HASH TABLE FULL" "FILE NOT OPEN" "ARG NOT LITATOM" "! too many files open" "END OF FILE" "ERROR" "BREAK" "ILLEGAL STACK ARG" "FAULT IN EVAL" "ARRAYS FULL" "FILE SYSTEM RESOURCES EXCEEDED" "FILE NOT FOUND" "BAD SYSOUT FILE" "UNUSUAL CDR ARG LIST" "HASH TABLE FULL" "ILLEGAL ARG" "ARG NOT ARRAY" "ILLEGAL OR IMPOSSIBLE BLOCK" "STACK PTR HAS BEEN RELEASED" "STORAGE FULL" "ATTEMPT TO USE ITEM OF INCORRECT TYPE" "ILLEGAL DATA TYPE NUMBER" "DATA TYPES FULL" "ATTEMPT TO BIND NIL OR T" "! too many user interrupt characters" "! read-macro context error" "ILLEGAL READTABLE" "ILLEGAL TERMINAL TABLE" "! swapblock too big for buffer" "PROTECTION VIOLATION" "BAD FILE NAME" "USER BREAK" "UNBOUND ATOM" "UNDEFINED CAR OF FORM" "UNDEFINED FUNCTION" "CONTROL-E" "FLOATING UNDERFLOW" "FLOATING OVERFLOW" "OVERFLOW" "ARG NOT HARRAY" "TOO MANY ARGUMENTS"))(DEFOPTIMIZER LISPERROR (MESSAGE ARG) (BQUOTE (\LISPERROR (\, ARG) (\, (CL:IF (CL:STRINGP MESSAGE) (FOR X IN \ERRORMESSAGELIST AS I FROM 0 WHEN (CL:EQUAL X MESSAGE) DO (RETURN I) FINALLY (RETURN (HELP "Unknown error message" (LIST MESSAGE ARG)))) MESSAGE)))))(PUTPROP (QUOTE AERROR) (QUOTE IMPORTDATE) (IDATE "15-Sep-86 18:17:01"))(RECORD BASEBYTESTREAM STREAM (SUBRECORD STREAM) (ACCESSFNS ((BIASOFFST (fetch (STREAM FW6) of DATUM) (replace (STREAM FW6) of DATUM with NEWVALUE)) (BBSNCHARS (fetch (STREAM FW7) of DATUM) (replace (STREAM FW7) of DATUM with NEWVALUE)) (WRITEXTENSIONFN (fetch (STREAM F1) of DATUM) (replace (STREAM F1) of DATUM with NEWVALUE)))))(PUTPROPS \INSTREAMARG MACRO ((STRM NOERRORFLG) (\GETSTREAM STRM (QUOTE INPUT) NOERRORFLG)))(PUTPROPS \OUTSTREAMARG MACRO ((STRM NOERRORFLG) (\GETSTREAM STRM (QUOTE OUTPUT) NOERRORFLG)))(PUTPROPS \STREAMARG MACRO (OPENLAMBDA (STRM NOERRORFLG) (COND (NOERRORFLG (\GETSTREAM STRM NIL T)) (T (\DTEST STRM (QUOTE STREAM))))))(PUTPROP (QUOTE AOFD) (QUOTE IMPORTDATE) (IDATE "29-Sep-86 17:47:41"))(PUTPROPS .SPACECHECK. MACRO ((STRM N) (AND \THISFILELINELENGTH (IGREATERP (IPLUS N (fetch CHARPOSITION of STRM)) \THISFILELINELENGTH) (FRESHLINE STRM))))(PUTPROPS \CHECKRADIX MACRO (LAMBDA (R) (COND ((OR (NOT (SMALLP R)) (ILESSP R 1) (IGREATERP R 36)) (\INVALID.RADIX R)) (T R))))(PUTPROP (QUOTE APRINT) (QUOTE IMPORTDATE) (IDATE "30-Sep-86 12:08:52"))(GLOBALVARS \BCPLDISPLAY)(ACCESSFNS LINEBUFFER ((LPARCOUNT (fetch FW6 of DATUM) (replace FW6 of DATUM with NEWVALUE)) (LBRKCOUNT (fetch FW7 of DATUM) (replace FW7 of DATUM with NEWVALUE)) (LINEBUFSTATE (fetch F5 of DATUM) (replace F5 of DATUM with NEWVALUE)) (* F4 is free. EJS, %7/8/85) (KEYBOARDSTREAM (fetch F2 of DATUM) (replace F2 of DATUM with NEWVALUE)) (PEEKEDCHAR (fetch F3 of DATUM) (replace F3 of DATUM with NEWVALUE)) (* Character read by PEEKC) (LBFLAGS (fetch FW9 of DATUM) (replace FW9 of DATUM with NEWVALUE)) (* True if peeked char was echoed when peeked. Could use this to determine whether to echo later or not, but that would be incompatible with Interlisp-10, so this field not used)) (ACCESSFNS LINEBUFFER ((LBFLAGBASE (LOCF (fetch LBFLAGS of DATUM)))) (BLOCKRECORD LBFLAGBASE ((PEEKEDECHOFLG FLAG) (INSTRINGP FLAG)))))(RPAQQ LINEBUFFERSTATES (FILLING.LBS READING.LBS RETYPING.LBS))(RPAQQ FILLING.LBS 0)(RPAQQ READING.LBS 1)(RPAQQ RETYPING.LBS 2)(CONSTANTS FILLING.LBS READING.LBS RETYPING.LBS)(PUTPROPS \INTERMP MACRO ((OFD) (EQ OFD \LINEBUF.OFD)))(PUTPROPS \OUTTERMP MACRO ((OFD) (EQ OFD \TERM.OFD)))(GLOBALVARS \DEFAULTLINEBUF)(PUTPROP (QUOTE ATERM) (QUOTE IMPORTDATE) (IDATE "19-Sep-86 18:18:56"))(DATATYPE HARRAYP ((NULLSLOTS WORD) (* Number of NIL-NIL slots, which break chains) (LASTINDEX WORD) (* Slot offset of last slot. Used in probe computations computations. Microcode support for \ADDBASE4 would help) (HARRAYPBASE POINTER) (RECLAIMABLE FLAG) (* True if keys can go away when no other refs) (OVERFLOWACTION POINTER) (NUMSLOTS WORD) (* The maximum number of logical slots--returned by HARRAYSIZE) (NUMKEYS WORD) (* The number of distinct keys in the array) (HASHBITSFN POINTER) (EQUIVFN POINTER) (HASHUSERDATA POINTER)))(/DECLAREDATATYPE (QUOTE HARRAYP) (QUOTE (WORD WORD POINTER FLAG POINTER WORD WORD POINTER POINTER POINTER)) (QUOTE ((HARRAYP 0 (BITS . 15)) (HARRAYP 1 (BITS . 15)) (HARRAYP 2 POINTER) (HARRAYP 2 (FLAGBITS . 0)) (HARRAYP 4 POINTER) (HARRAYP 6 (BITS . 15)) (HARRAYP 7 (BITS . 15)) (HARRAYP 8 POINTER) (HARRAYP 10 POINTER) (HARRAYP 12 POINTER))) (QUOTE 14))(PUTPROPS \ADDBASE2 MACRO (OPENLAMBDA (BASE N) (\ADDBASE (\ADDBASE BASE N) N)))(PUTPROPS \ADDBASE4 MACRO (OPENLAMBDA (BASE N) (\ADDBASE2 (\ADDBASE2 BASE N) N)))(PUTPROPS HUNKSIZEFROMNUMBER MACRO ((NTYPX) (FOLDLO (fetch DTDSIZE of (\GETDTD NTYPX)) WORDSPERCELL)))(PUTPROPS \BYTELT DMACRO (OPENLAMBDA (A J) (\GETBASEBYTE (fetch (ARRAYP BASE) of A) (IPLUS (fetch (ARRAYP OFFST) of A) J))))(PUTPROPS \BYTESETA DMACRO (OPENLAMBDA (A J V) (\PUTBASEBYTE (fetch (ARRAYP BASE) of A) (IPLUS (fetch (ARRAYP OFFST) of A) J) V)))(PUTPROPS \WORDELT DMACRO (OPENLAMBDA (A J) (CHECK (AND (ARRAYP A) (EQ 0 (fetch (ARRAYP ORIG) of A)) (EQ \ST.POS16 (fetch (ARRAYP TYP) of A)))) (CHECK (IGREATERP (fetch (ARRAYP LENGTH) of A) J)) (\GETBASE (fetch (ARRAYP BASE) of A) (IPLUS (fetch (ARRAYP OFFST) of A) J))))(RPAQQ BLOCKGCTYPECONSTANTS ((CODEBLOCK.GCT 2) (PTRBLOCK.GCT 1) (UNBOXEDBLOCK.GCT 0)))(RPAQQ CODEBLOCK.GCT 2)(RPAQQ PTRBLOCK.GCT 1)(RPAQQ UNBOXEDBLOCK.GCT 0)(CONSTANTS (CODEBLOCK.GCT 2) (PTRBLOCK.GCT 1) (UNBOXEDBLOCK.GCT 0))(RPAQQ ARRAYCONSTANTS (\ArrayBlockHeaderCells \ArrayBlockHeaderWords \ArrayBlockTrailerCells \ArrayBlockTrailerWords (\ArrayBlockOverheadCells (IPLUS \ArrayBlockHeaderCells \ArrayBlockTrailerCells)) (\ArrayBlockOverheadWords (IPLUS \ArrayBlockHeaderWords \ArrayBlockTrailerWords)) \ArrayBlockLinkingCells (\MinArrayBlockSize (IPLUS \ArrayBlockOverheadCells \ArrayBlockLinkingCells)) (\MaxArrayBlockSize 65535) (\MaxArrayNCells (IDIFFERENCE \MaxArrayBlockSize \ArrayBlockOverheadCells)) \MaxArrayLen (\ABPASSWORDSHIFT 3) (\ArrayBlockPassword (LRSH 43690 \ABPASSWORDSHIFT)) (\FreeArrayFlagWord (LOGOR (LLSH \ArrayBlockPassword \ABPASSWORDSHIFT) (LLSH UNBOXEDBLOCK.GCT 1))) (\UsedArrayFlagWord (LOGOR (LLSH \ArrayBlockPassword \ABPASSWORDSHIFT) 1)) (\CodeArrayFlagWord (LOGOR (LLSH \ArrayBlockPassword \ABPASSWORDSHIFT) (LLSH CODEBLOCK.GCT 1) 1))))(RPAQQ \ArrayBlockHeaderCells 1)(RPAQQ \ArrayBlockHeaderWords 2)(RPAQQ \ArrayBlockTrailerCells 1)(RPAQQ \ArrayBlockTrailerWords 2)(RPAQ \ArrayBlockOverheadCells (IPLUS \ArrayBlockHeaderCells \ArrayBlockTrailerCells))(RPAQ \ArrayBlockOverheadWords (IPLUS \ArrayBlockHeaderWords \ArrayBlockTrailerWords))(RPAQQ \ArrayBlockLinkingCells 2)(RPAQ \MinArrayBlockSize (IPLUS \ArrayBlockOverheadCells \ArrayBlockLinkingCells))(RPAQQ \MaxArrayBlockSize 65535)(RPAQ \MaxArrayNCells (IDIFFERENCE \MaxArrayBlockSize \ArrayBlockOverheadCells))(RPAQQ \MaxArrayLen 65535)(RPAQQ \ABPASSWORDSHIFT 3)(RPAQ \ArrayBlockPassword (LRSH 43690 \ABPASSWORDSHIFT))(RPAQ \FreeArrayFlagWord (LOGOR (LLSH \ArrayBlockPassword \ABPASSWORDSHIFT) (LLSH UNBOXEDBLOCK.GCT 1)))(RPAQ \UsedArrayFlagWord (LOGOR (LLSH \ArrayBlockPassword \ABPASSWORDSHIFT) 1))(RPAQ \CodeArrayFlagWord (LOGOR (LLSH \ArrayBlockPassword \ABPASSWORDSHIFT) (LLSH CODEBLOCK.GCT 1) 1))(CONSTANTS \ArrayBlockHeaderCells \ArrayBlockHeaderWords \ArrayBlockTrailerCells \ArrayBlockTrailerWords (\ArrayBlockOverheadCells (IPLUS \ArrayBlockHeaderCells \ArrayBlockTrailerCells)) (\ArrayBlockOverheadWords (IPLUS \ArrayBlockHeaderWords \ArrayBlockTrailerWords)) \ArrayBlockLinkingCells (\MinArrayBlockSize (IPLUS \ArrayBlockOverheadCells \ArrayBlockLinkingCells)) (\MaxArrayBlockSize 65535) (\MaxArrayNCells (IDIFFERENCE \MaxArrayBlockSize \ArrayBlockOverheadCells)) \MaxArrayLen (\ABPASSWORDSHIFT 3) (\ArrayBlockPassword (LRSH 43690 \ABPASSWORDSHIFT)) (\FreeArrayFlagWord (LOGOR (LLSH \ArrayBlockPassword \ABPASSWORDSHIFT) (LLSH UNBOXEDBLOCK.GCT 1))) (\UsedArrayFlagWord (LOGOR (LLSH \ArrayBlockPassword \ABPASSWORDSHIFT) 1)) (\CodeArrayFlagWord (LOGOR (LLSH \ArrayBlockPassword \ABPASSWORDSHIFT) (LLSH CODEBLOCK.GCT 1) 1)))(RPAQQ ARRAYTYPES ((\ST.BYTE 0) (\ST.POS16 1) (\ST.INT32 2) (\ST.CODE 4) (\ST.PTR 6) (\ST.FLOAT 7) (\ST.BIT 8) (\ST.PTR2 11)))(RPAQQ \ST.BYTE 0)(RPAQQ \ST.POS16 1)(RPAQQ \ST.INT32 2)(RPAQQ \ST.CODE 4)(RPAQQ \ST.PTR 6)(RPAQQ \ST.FLOAT 7)(RPAQQ \ST.BIT 8)(RPAQQ \ST.PTR2 11)(CONSTANTS (\ST.BYTE 0) (\ST.POS16 1) (\ST.INT32 2) (\ST.CODE 4) (\ST.PTR 6) (\ST.FLOAT 7) (\ST.BIT 8) (\ST.PTR2 11))(RPAQQ \MAX.CELLSPERHUNK 64)(CONSTANTS \MAX.CELLSPERHUNK)(RPAQQ \IN.MAKEINIT NIL)(CONSTANTS (\IN.MAKEINIT))(BLOCKRECORD SEQUENCEDESCRIPTOR ((ORIG BITS 1) (NIL BITS 1) (READONLY FLAG) (NIL BITS 1) (TYP BITS 4) (BASE POINTER) (LENGTH WORD) (OFFST WORD)))(DATATYPE ARRAYP ((ORIG BITS 1) (NIL BITS 1) (READONLY FLAG) (* probably no READONLY arrays now) (NIL BITS 1) (TYP BITS 4) (BASE POINTER) (LENGTH WORD) (OFFST WORD)) (* note that while ARRAYP is a DATATYPE, the allocation of it actually happens at MAKEINIT time under INITDATATYPE{NAMES}))(BLOCKRECORD ARRAYBLOCK ((PASSWORD BITS 13) (GCTYPE BITS 2) (* Unboxed, Pointers, Code, ?) (INUSE FLAG) (ARLEN WORD) (FWD FULLXPOINTER) (* Only when on free list) (BKWD FULLXPOINTER)) (BLOCKRECORD ARRAYBLOCK ((ABFLAGS WORD) (* Used for header and trailer))) (ACCESSFNS ARRAYBLOCK ((DAT (\ADDBASE DATUM \ArrayBlockHeaderWords)) (TRAILER (\ADDBASE2 DATUM (IDIFFERENCE (fetch (ARRAYBLOCK ARLEN) of DATUM) \ArrayBlockTrailerCells))))) (TYPE? (AND (EQ 0 (NTYPX DATUM)) (IGEQ (\HILOC DATUM) \FirstArraySegment))))(/DECLAREDATATYPE (QUOTE ARRAYP) (QUOTE ((BITS 1) (BITS 1) FLAG (BITS 1) (BITS 4) POINTER WORD WORD)) (QUOTE ((ARRAYP 0 (BITS . 0)) (ARRAYP 0 (BITS . 16)) (ARRAYP 0 (FLAGBITS . 32)) (ARRAYP 0 (BITS . 48)) (ARRAYP 0 (BITS . 67)) (ARRAYP 0 POINTER) (ARRAYP 2 (BITS . 15)) (ARRAYP 3 (BITS . 15)))) (QUOTE 4))(GLOBALVARS \NxtArrayPage \FREEBLOCKBUCKETS \HUNKING?)(PUTPROPS HUNKSIZEFROMNUMBER MACRO ((NTYPX) (FOLDLO (fetch DTDSIZE of (\GETDTD NTYPX)) WORDSPERCELL)))(PUTPROP (QUOTE LLARRAYELT) (QUOTE IMPORTDATE) (IDATE "22-Aug-86 16:59:44"))(DEFOPTIMIZER TYPENAMEP (&amp;BODY BODY) (COND ((AND (EQ (CAADR BODY) (QUOTE QUOTE)) (SYMBOLP (CADR (CADR BODY)))) (BQUOTE ((OPCODES INSTANCEP 0 (ATOM \, (CADR (CADR BODY)))) (\, (CAR BODY))))) (T (QUOTE IGNOREMACRO))))(DEFOPTIMIZER \INSTANCE-P (&amp;BODY BODY) (COND ((AND (EQ (CAADR BODY) (QUOTE QUOTE)) (SYMBOLP (CADR (CADR BODY)))) (BQUOTE ((OPCODES INSTANCEP 0 (ATOM \, (CADR (CADR BODY)))) (\, (CAR BODY))))) (T (QUOTE IGNOREMACRO))))(DEFOPTIMIZER PUTBASEPTRX (&amp;REST ARGS) (CONS (QUOTE (OPENLAMBDA (DATUM OFFSET NEWVALUE) (UNINTERRUPTABLY (\PUTBASEBYTE DATUM (ADD1 (LLSH OFFSET 1)) (LOGAND (\HILOC NEWVALUE) 255)) (\PUTBASE DATUM (ADD1 OFFSET) (\LOLOC NEWVALUE)) NEWVALUE))) ARGS))(RPAQQ \SMALLP 1)(RPAQQ \FIXP 2)(RPAQQ \FLOATP 3)(RPAQQ \LITATOM 4)(RPAQQ \LISTP 5)(RPAQQ \ARRAYP 6)(RPAQQ \STRINGP 7)(RPAQQ \STACKP 8)(RPAQQ \VMEMPAGEP 10)(RPAQQ \STREAM 11)(CONSTANTS \SMALLP \FIXP \FLOATP \LITATOM \LISTP \ARRAYP \STRINGP \STACKP \VMEMPAGEP \STREAM)(RPAQQ \BUILT-IN-SYSTEM-TYPES ((SMALLP) (FIXP 2) (FLOATP 2) (LITATOM) (LISTP 4 0 2) (ARRAYP 4 0) (STRINGP 4 0) (STACKP 2) (CHARACTER) (VMEMPAGEP 256) (STREAM) (BITMAP) (COMPILED-CLOSURE 4 0 2) (ONED-ARRAY) (TWOD-ARRAY) (GENERAL-ARRAY)))(BLOCKRECORD DTD ((DTDNAME WORD) (* "Type name -- a symbol") (DTDSIZE WORD) (* "Length of datum in words") (DTDFREE FULLXPOINTER) (* "Pointer to first object on free chain, or NIL.  Not used for LISTP") (NIL BITS 2) (DTDOBSOLETE FLAG) (* "True for type of a redeclared datatype--not allowed to allocate more of these") (DTDFINALIZABLE FLAG) (* "True if finalization exists for this type") (DTDLOCKEDP FLAG) (* "True if objects of this type must be locked down (not pagefault)") (DTDHUNKP FLAG) (* "True if this type is used as an array hunk type") (DTDGCTYPE BITS 2) (* "For hunk datatypes, is analogous to arrayblock's GCTYPE") (DTDDESCRS POINTER) (DTDTYPESPECS POINTER) (DTDPTRS POINTER) (* "List of word offsets inside datum where reference-counted pointers are stored -- used by GC") (DTDOLDCNT FIXP) (* "'Box count' -- number of objects of this type ever allocated") (DTDCNT0 WORD) (* "Incremental box count -- this plus DTDOLDCNT is the true box count") (DTDNEXTPAGE WORD) (* "Currently only for LISTP pages -- page number of next page on chain of non-full cons pages") (DTDTYPEENTRY WORD) (* "The word stored in the type table for objects of this type.  Hi bits have numberp tags, ref countable, etc.") (DTDSUPERTYPE WORD) (* "Type number of immediate supertype, or zero if none")) (ACCESSFNS DTD ((DTDCNTLOC (\ADDBASE DATUM 10)) (DTDCNT (IPLUS (fetch DTDOLDCNT DATUM) (fetch DTDCNT0 DATUM)) (UNINTERRUPTABLY (replace DTDOLDCNT of DATUM with NEWVALUE) (replace DTDCNT0 of DATUM with 0))))))(PUTPROPS \GETDTD MACRO ((typeNum) (ADDBASE \DTDSpaceBase (LLSH typeNum 4))))(PUTPROPS \TYPEMASK.UFN DMACRO (X (LET ((CE (CONSTANTEXPRESSIONP (CADR X)))) (if CE then (BQUOTE ((OPCODES TYPEMASK.N , (CAR CE)) , (CAR X))) else (QUOTE IGNOREMACRO)))))(RPAQQ \GUARDSTORAGEFULL 128)(RPAQQ \GUARD1STORAGEFULL 64)(CONSTANTS \GUARDSTORAGEFULL \GUARD1STORAGEFULL)(GLOBALVARS \NxtMDSPage \LeastMDSPage \SecondArrayPage \SecondMDSPage \MDSFREELISTPAGE \MaxSysTypeNum \MaxTypeNumber \STORAGEFULL \INTERRUPTSTATE \PENDINGINTERRUPT)(PUTPROP (QUOTE LLDATATYPE) (QUOTE IMPORTDATE) (IDATE " 3-Oct-86 18:06:09"))(ACCESSFNS POINTER ((PAGE# (IPLUS (LLSH (\HILOC DATUM) 8) (LRSH (\LOLOC DATUM) 8))) (WORDINPAGE (LOGAND (\LOLOC DATUM) 255)) (CELLINPAGE (LRSH (fetch WORDINPAGE of DATUM) 1)) (BYTEINPAGE (LLSH (fetch WORDINPAGE of DATUM) 1)) (SEGMENT# (\HILOC DATUM)) (WORDINSEGMENT (\LOLOC DATUM)) (CELLINSEGMENT (LRSH (fetch WORDINSEGMENT of DATUM) 1)) (WORD# (fetch WORDINPAGE of DATUM)) (DBLWORD# (fetch CELLINPAGE of DATUM)) (PAGEBASE (\VAG2 (\HILOC DATUM) (LOGAND (\LOLOC DATUM) 65280)))) (CREATE (\VAG2 (LRSH PAGE# 8) (LLSH (LOGAND PAGE# 255) 8))))(ACCESSFNS WORD ((HIBYTE (LRSH DATUM 8)) (LOBYTE (LOGAND DATUM 255))) (CREATE (IPLUS (LLSH HIBYTE 8) LOBYTE)))(PUTPROPS PTRGTP MACRO (OPENLAMBDA (X Y) (OR (IGREATERP (\HILOC X) (\HILOC Y)) (AND (EQ (\HILOC X) (\HILOC Y)) (IGREATERP (\LOLOC X) (\LOLOC Y))))))(PUTPROPS .COERCE.TO.SMALLPOSP. DMACRO (OPENLAMBDA (X) (COND ((SMALLPOSP X) X) (T (\ILLEGAL.ARG X)))))(PUTPROPS .COERCE.TO.BYTE. DMACRO (OPENLAMBDA (X) (COND ((AND (SMALLPOSP X) (ILESSP X (CONSTANT (LLSH 1 BITSPERBYTE)))) X) (T (\ILLEGAL.ARG X)))))(BLOCKRECORD LISTP ((CAR POINTER) (CDR POINTER)) (CREATE (CREATECELL \LISTP)) (* FOLLOWING ARE CDR-CODE FIELDS) (BLOCKRECORD LISTP ((CDRCODE BYTE) (CARFIELD XPOINTER))) (ACCESSFNS LISTP ((FULLCARFIELD NIL (\PUTBASEPTR DATUM 0 NEWVALUE)))) (* because replace of XPOINTER is slow, the CAR field is stored with PUTBASEPTR, even though that smashes the hi byte))(BLOCKRECORD CONSPAGE ((CNT BYTE) (NEXTCELL BYTE) (NEXTPAGE WORD)))(RPAQQ CONSCONSTANTS (\CDR.ONPAGE \CDR.NIL \CDR.INDIRECT \CDR.MAXINDIRECT \CONSPAGE.LAST))(RPAQQ \CDR.ONPAGE 128)(RPAQQ \CDR.NIL 128)(RPAQQ \CDR.INDIRECT 0)(RPAQQ \CDR.MAXINDIRECT 127)(RPAQQ \CONSPAGE.LAST 65535)(CONSTANTS \CDR.ONPAGE \CDR.NIL \CDR.INDIRECT \CDR.MAXINDIRECT \CONSPAGE.LAST)(PUTPROPS LOCAL MACRO ((X) X))(PUTPROPS ALLOCAL MACRO ((X) X))(PUTPROP (QUOTE LLNEW) (QUOTE IMPORTDATE) (IDATE " 8-Sep-86 14:40:01"))(PUTPROPS CHECK MACRO (ARGS (COND ((AND (BOUNDP (QUOTE CHECK)) CHECK) (CONS (QUOTE PROGN) (for I in ARGS collect (LIST (QUOTE OR) I (LIST (QUOTE RAID) (KWOTE (LIST (QUOTE Check-failure:) I))))))) (T (CONS COMMENTFLG ARGS)))))(PUTPROPS \StatsZero BYTEMACRO (OPENLAMBDA (N) (\PUTBASE N 0 0) (\PUTBASE N 1 0)))(PUTPROPS \StatsAdd1 DMACRO (OPENLAMBDA (A) (PROG ((LO (IPLUS16 (\GETBASE A 1) 1))) (DECLARE (LOCALVARS LO)) (* Increment double word at A by 1) (\PUTBASE A 1 LO) (COND ((EQ LO 0) (\PUTBASE A 0 (ADD1 (\GETBASE A 0))))))))(PUTPROPS IPLUS16 MACRO ((X Y) (* Kludge to do 16-bit plus) (\LOLOC (\ADDBASE X Y))))(PUTPROPS SMALLPOSP MACRO (OPENLAMBDA (X) (AND (SMALLP X) (IGEQ X 0))))(PROGN (PUTPROPS SETXVAR MACRO (X (BQUOTE (SETQ.NOREF , (CADAR X) , (CADR X))))) (PUTPROPS SETXVAR DMACRO (X (OR (AND (EQ (CAAR X) (QUOTE QUOTE)) (LITATOM (CADAR X))) (SHOULDNT)) (GLOBALVARS \VALSPACE) (LIST (QUOTE SETQ.NOREF) (CADAR X) (CADR X)))))(PUTPROPS SETQ.NOREF DMACRO ((VAR VAL) (\PUTBASEPTR (LOCF (fetch (LITATOM VALUE) of (QUOTE VAR))) 0 VAL)))(PROGN (PUTPROPS IEQ MACRO ((X Y) (IEQP X Y))) (PUTPROPS IEQ DMACRO (= . EQ)))(SETTEMPLATE (QUOTE SPREADAPPLY*) (QUOTE (FUNCTIONAL .. EVAL)))(SETTEMPLATE (QUOTE SPREADAPPLY) (QUOTE (FUNCTIONAL EVAL . PPE)))(SETTEMPLATE (QUOTE SETQ.NOREF) (QUOTE (SET EVAL . PPE)))(RPAQQ WordsPerPage 256)(CONSTANTS WordsPerPage)(ACCESSFNS LITATOM ((DEFINITIONCELL (\DEFCELL DATUM)) (PROPCELL (\PROPCELL DATUM)) (VCELL (\VALCELL DATUM)) (PNAMECELL (\PNAMECELL DATUM))) (* * VCELL can also be accessed directly from a value index via the record VALINDEX (as in \SETGLOBALVAL.UFN) - Similarly, PNAMEINDEX accesses PNAMECELL for use by \MKATOM and UNCOPYATOM) (TYPE? (LITATOM DATUM)) (BLOCKRECORD PROPCELL ((NIL BITS 1) (GENSYMP FLAG) (FATPNAMEP FLAG) (NIL BITS 5) (PROPLIST POINTER))))(SYNONYM SYMBOL (LITATOM))(ACCESSFNS VALINDEX ((VCELL (\ADDBASE2 \VALSPACE DATUM))))(BLOCKRECORD VCELL ((VALUE FULLPOINTER)))(BLOCKRECORD DEFINITIONCELL ((CCODEP FLAG) (FASTP FLAG) (ARGTYPE BITS 2) (PSEUDOCODEP FLAG) (NIL BITS 3) (DEFPOINTER POINTER)) (BLOCKRECORD DEFINITIONCELL ((DEFCELLFLAGS BYTE) (NIL POINTER))))(BLOCKRECORD FNHEADER ((STKMIN WORD) (NA SIGNEDWORD) (PV SIGNEDWORD) (STARTPC WORD) (NIL FLAG) (NIL FLAG) (ARGTYPE BITS 2) (NIL BITS 3) (CLOSUREP FLAG) (#FRAMENAME XPOINTER) (NTSIZE WORD) (NLOCALS BYTE) (FVAROFFSET BYTE)) (ACCESSFNS FNHEADER ((LSTARP (ILESSP (fetch (FNHEADER NA) of DATUM) 0)) (OVERHEADWORDS (PROGN 8)) (ALIGNED (IPLUS (fetch (FNHEADER NTSIZE) of DATUM) (fetch (FNHEADER OVERHEADWORDS) of T))) (FIXED NIL (replace (FNHEADER STKMIN) of DATUM with (IPLUS (UNFOLD (IPLUS (fetch (FNHEADER NA) of DATUM) (UNFOLD (ADD1 (fetch (FNHEADER PV) of DATUM)) CELLSPERQUAD)) WORDSPERCELL) 12 32))) (NPVARWORDS (UNFOLD (ADD1 (fetch (FNHEADER PV) of DATUM)) WORDSPERQUAD)) (FRAMENAME (fetch (FNHEADER #FRAMENAME) of DATUM) (UNINTERRUPTABLY (CHECK (NEQ (\HILOC DATUM) \STACKHI)) (\DELREF (fetch (FNHEADER #FRAMENAME) of DATUM)) (\ADDREF NEWVALUE) (replace (FNHEADER #FRAMENAME) of DATUM with NEWVALUE))))))(BLOCKRECORD PNAMECELL ((PACKAGEINDEX BYTE) (PNAMEBASE XPOINTER)) (BLOCKRECORD PNAMECELL ((FULLPNAMEBASE FULLXPOINTER) (* "Replacing this smashes PACKAGEINDEX to 0"))) (ACCESSFNS PNAMECELL ((PACKAGE (AREF *PACKAGE-FROM-INDEX* (FETCH (PNAMECELL PACKAGEINDEX) OF DATUM)) (REPLACE (PNAMECELL PACKAGEINDEX) OF DATUM WITH (IF (NULL NEWVALUE) THEN *UNINTERNED-PACKAGE-INDEX* ELSE (PACKAGE-INDEX NEWVALUE)))))))(ACCESSFNS PACKAGEINDEX ((PACKAGE (AREF *PACKAGE-FROM-INDEX* DATUM))))(BLOCKRECORD PNAMEBASE ((PNAMELENGTH BYTE) (* Length is always here, be the pname thin or fat) (PNAMEFATPADDINGBYTE BYTE) (* This byte is zero for fat pnames so that the pname chars are word-aligned)))(ACCESSFNS PNAMEINDEX ((PNAMECELL (\ADDBASE (\VAG2 \PNAME.HI (\LOLOC DATUM)) (\LOLOC DATUM)))))(PUTPROPS \DEFCELL MACRO ((ATOM) (\ATOMCELL ATOM \DEF.HI)))(PUTPROPS \VALCELL MACRO ((ATOM) (\ATOMCELL ATOM \VAL.HI)))(PUTPROPS \PNAMECELL MACRO ((ATOM) (\ATOMCELL ATOM \PNAME.HI)))(PUTPROPS \ATOMVALINDEX DMACRO ((X) (\LOLOC (\DTEST X (QUOTE LITATOM)))))(PUTPROPS \ATOMDEFINDEX DMACRO ((X) (\LOLOC (\DTEST X (QUOTE LITATOM)))))(PUTPROPS \ATOMPNAMEINDEX DMACRO ((X) (\LOLOC (\DTEST X (QUOTE LITATOM)))))(PUTPROPS \ATOMPROPINDEX DMACRO ((X) (\LOLOC (\DTEST X (QUOTE LITATOM)))))(PUTPROPS \INDEXATOMPNAME DMACRO ((X) (\VAG2 \AtomHI X)))(PUTPROPS \INDEXATOMVAL DMACRO ((X) (\VAG2 \AtomHI X)))(PUTPROPS \INDEXATOMDEF DMACRO ((X) (\VAG2 \AtomHI X)))(GLOBALVARS \NxtPnByte \CurPnPage \NxtAtomPage \AtomFrLst \OneCharAtomBase \PNAMES.IN.BLOCKS? \SCRATCHSTRING COMPILEATPUTDFLG *PACKAGE-FROM-INDEX*)(RPAQQ \PNAMELIMIT 255)(RPAQQ \CharsPerPnPage 512)(CONSTANTS (\PNAMELIMIT 255) (\CharsPerPnPage 512))(PUTPROPS \MOVEWORDS MACRO (OPENLAMBDA (SBASE SOFFSET DBASE DOFFSET NWORDS) (\BLT (\ADDBASE DBASE DOFFSET) (\ADDBASE SBASE SOFFSET) NWORDS)))(PUTPROP (QUOTE LLBASIC) (QUOTE IMPORTDATE) (IDATE " 6-Oct-86 21:57:54"))(DATATYPE STRINGP ((ORIG BITS 1) (* ORIG is always 1) (SUBSTRINGED FLAG) (XREADONLY FLAG) (NIL BITS 1) (TYP BITS 4) (* TYP is \ST.BYTE for thin strings, \ST.POS16 for fat ones, \ST.INDIRECT if XBASE is an indirect to another STRINGP) (XBASE POINTER) (LENGTH WORD) (OFFST WORD)) (ACCESSFNS STRINGP ((BASE (ffetch (STRINGP XBASE) of DATUM) (freplace (STRINGP XBASE) of DATUM with NEWVALUE)) (READONLY (ffetch (STRINGP XREADONLY) of DATUM) (freplace (STRINGP XREADONLY) of DATUM with NEWVALUE)) (FATSTRINGP (SELECTC (ffetch (STRINGP TYP) of DATUM) (\ST.BYTE NIL) T) (freplace (STRINGP TYP) of DATUM with (if NEWVALUE then \ST.POS16 else \ST.BYTE))))) TYP &larr; \ST.BYTE ORIG &larr; 1 SUBSTRINGED &larr; NIL (* while STRINGP is declared as a declaration, the initialization really happens at MAKEINIT time under INITDATATYPES using the DTDECLS list))(/DECLAREDATATYPE (QUOTE STRINGP) (QUOTE ((BITS 1) FLAG FLAG (BITS 1) (BITS 4) POINTER WORD WORD)) (QUOTE ((STRINGP 0 (BITS . 0)) (STRINGP 0 (FLAGBITS . 16)) (STRINGP 0 (FLAGBITS . 32)) (STRINGP 0 (BITS . 48)) (STRINGP 0 (BITS . 67)) (STRINGP 0 POINTER) (STRINGP 2 (BITS . 15)) (STRINGP 3 (BITS . 15)))) (QUOTE 4))(GLOBALVARS \OneCharAtomBase)(PUTDEF (QUOTE \NUMSTR) (QUOTE RESOURCES) (QUOTE (NEW (ALLOCSTRING 38))))(PUTDEF (QUOTE \NUMSTR1) (QUOTE RESOURCES) (QUOTE (NEW (CONCAT))))(PUTDEF (QUOTE \PNAMESTRING) (QUOTE RESOURCES) (QUOTE (NEW (ALLOCSTRING \PNAMELIMIT NIL NIL \FATPNAMESTRINGP))))(RPAQQ \FATPNAMESTRINGP T)(CONSTANTS (\FATPNAMESTRINGP T))(PUTPROPS \PNAMESTRINGPUTCHAR MACRO ((BASE OFFSET CODE) (* For stuffing chars into resource \PNAMESTRING) (\PUTBASECHAR \FATPNAMESTRINGP BASE OFFSET CODE)))(PUTPROPS FCHARACTER DMACRO (OPENLAMBDA (N) (COND ((IGREATERP N \MAXTHINCHAR) (* The character we're getting is NOT a thin character -- do it the hard way) (CHARACTER N)) ((IGREATERP N (CHARCODE 9)) (\ADDBASE \OneCharAtomBase (IDIFFERENCE N 10))) ((IGEQ N (CHARCODE 0)) (IDIFFERENCE N (CHARCODE 0))) (T (* The common case -- just add on the one-atom base.) (\ADDBASE \OneCharAtomBase N)))))(I.S.OPR (QUOTE inpname) NIL (QUOTE (SUBPAIR (QUOTE ($$END $$BODY $$FATP $$BASE $$OFFSET)) (LIST (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR)) (BQUOTE (bind $$OFFSET &larr; 0 $$BODY &larr; BODY $$BASE $$END $$FATP declare (LOCALVARS $$END $$BODY $$FATP $$BASE $$OFFSET) first (PROG NIL $$RETRY (SELECTC (NTYPX $$BODY) (\STRINGP (SETQ $$BASE (ffetch (STRINGP BASE) of $$BODY)) (SETQ $$OFFSET (SUB1 (ffetch (STRINGP OFFST) of $$BODY))) (SETQ $$END (IPLUS $$OFFSET (ffetch (STRINGP LENGTH) of $$BODY))) (SETQ $$FATP (ffetch (STRINGP FATSTRINGP) of $$BODY))) (\LITATOM (SETQ $$BASE (ffetch (LITATOM PNAMEBASE) of $$BODY)) (SETQ $$END (ffetch (PNAMEBASE PNAMELENGTH) of $$BASE)) (SETQ $$FATP (ffetch (LITATOM FATPNAMEP) of $$BODY))) (PROGN (SETQ $$BODY (MKSTRING $$BODY)) (GO $$RETRY)))) eachtime (SETQ $$OFFSET (ADD1 $$OFFSET)) (AND (IGREATERP $$OFFSET $$END) (GO $$OUT)) (SETQ I.V. (COND ($$FATP (\GETBASEFAT $$BASE $$OFFSET)) (T (\GETBASETHIN $$BASE $$OFFSET)))))))) T)(I.S.OPR (QUOTE inatom) NIL (QUOTE (SUBPAIR (QUOTE ($$OFFSET $$BODY $$BASE $$END $$FATP)) (LIST (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR)) (QUOTE (bind $$OFFSET &larr; 0 $$BODY &larr; BODY $$BASE $$END $$FATP declare (LOCALVARS $$OFFSET $$BODY $$BASE $$END $$FATP) first (SETQ $$BASE (ffetch (LITATOM PNAMEBASE) of $$BODY)) (SETQ $$END (ffetch (PNAMEBASE PNAMELENGTH) of $$BASE)) (SETQ $$FATP (ffetch (LITATOM FATPNAMEP) of $$BODY)) eachtime (SETQ $$OFFSET (ADD1 $$OFFSET)) (AND (IGREATERP $$OFFSET $$END) (GO $$OUT)) (SETQ I.V. (COND ($$FATP (\GETBASEFAT $$BASE $$OFFSET)) (T (\GETBASETHIN $$BASE $$OFFSET)))))))) T)(I.S.OPR (QUOTE instring) NIL (QUOTE (SUBPAIR (QUOTE ($$BODY $$END $$OFFSET $$BASE $$FATP)) (LIST (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR)) (QUOTE (bind $$BODY &larr; BODY $$END $$OFFSET $$BASE $$FATP declare (LOCALVARS $$BODY $$END $$OFFSET $$BASE $$FATP) first (SETQ $$OFFSET (SUB1 (ffetch (STRINGP OFFST) of $$BODY))) (SETQ $$BASE (ffetch (STRINGP BASE) of $$BODY)) (SETQ $$END (IPLUS $$OFFSET (ffetch (STRINGP LENGTH) of $$BODY))) (SETQ $$FATP (ffetch (STRINGP FATSTRINGP) of $$BODY)) eachtime (SETQ $$OFFSET (ADD1 $$OFFSET)) (AND (IGREATERP $$OFFSET $$END) (GO $$OUT)) (SETQ I.V. (COND ($$FATP (\GETBASEFAT $$BASE $$OFFSET)) (T (\GETBASETHIN $$BASE $$OFFSET)))))))) T)(I.S.OPR (QUOTE infatatom) NIL (QUOTE (SUBPAIR (QUOTE ($$OFFSET $$BODY $$BASE $$END)) (LIST (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR)) (QUOTE (bind $$OFFSET &larr; 0 $$BODY &larr; BODY $$BASE $$END declare (LOCALVARS $$OFFSET $$BODY $$BASE $$END) first (SETQ $$BASE (ffetch (LITATOM PNAMEBASE) of $$BODY)) (SETQ $$END (ffetch (PNAMEBASE PNAMELENGTH) of $$BASE)) eachtime (SETQ $$OFFSET (ADD1 $$OFFSET)) (AND (IGREATERP $$OFFSET $$END) (GO $$OUT)) (SETQ I.V. (\GETBASEFAT $$BASE $$OFFSET)))))) T)(I.S.OPR (QUOTE inthinatom) NIL (QUOTE (SUBPAIR (QUOTE ($$OFFSET $$BODY $$BASE $$END)) (LIST (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR)) (QUOTE (bind $$OFFSET &larr; 0 $$BODY &larr; BODY $$BASE $$END declare (LOCALVARS $$OFFSET $$BODY $$BASE $$END) first (SETQ $$BASE (ffetch (LITATOM PNAMEBASE) of $$BODY)) (SETQ $$END (ffetch (PNAMEBASE PNAMELENGTH) of $$BASE)) eachtime (SETQ $$OFFSET (ADD1 $$OFFSET)) (AND (IGREATERP $$OFFSET $$END) (GO $$OUT)) (SETQ I.V. (\GETBASETHIN $$BASE $$OFFSET)))))) T)(I.S.OPR (QUOTE infatstring) NIL (QUOTE (SUBPAIR (QUOTE ($$BODY $$END $$OFFSET $$BASE)) (LIST (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR)) (QUOTE (bind $$BODY &larr; BODY $$END $$OFFSET $$BASE declare (LOCALVARS $$BODY $$END $$OFFSET $$BASE) first (SETQ $$OFFSET (SUB1 (ffetch (STRINGP OFFST) of $$BODY))) (SETQ $$BASE (ffetch (STRINGP BASE) of $$BODY)) (SETQ $$END (IPLUS $$OFFSET (ffetch (STRINGP LENGTH) of $$BODY))) eachtime (SETQ $$OFFSET (ADD1 $$OFFSET)) (AND (IGREATERP $$OFFSET $$END) (GO $$OUT)) (SETQ I.V. (\GETBASEFAT $$BASE $$OFFSET)))))) T)(I.S.OPR (QUOTE inthinstring) NIL (QUOTE (SUBPAIR (QUOTE ($$BODY $$END $$OFFSET $$BASE)) (LIST (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR) (GETDUMMYVAR)) (QUOTE (bind $$BODY &larr; BODY $$END $$OFFSET $$BASE declare (LOCALVARS $$BODY $$END $$OFFSET $$BASE) first (SETQ $$OFFSET (SUB1 (ffetch (STRINGP OFFST) of $$BODY))) (SETQ $$BASE (ffetch (STRINGP BASE) of $$BODY)) (SETQ $$END (IPLUS $$OFFSET (ffetch (STRINGP LENGTH) of $$BODY))) eachtime (SETQ $$OFFSET (ADD1 $$OFFSET)) (AND (IGREATERP $$OFFSET $$END) (GO $$OUT)) (SETQ I.V. (\GETBASETHIN $$BASE $$OFFSET)))))) T)(PUTPROPS \CHARCODEP DMACRO (OPENLAMBDA (X) (* used to also say (ILEQ X \MAXFATCHAR) , but that's implied by the first two clauses) (AND (SMALLP X) (IGEQ X 0))))(PUTPROPS \FATCHARCODEP DMACRO (OPENLAMBDA (X) (* Used to also say (ILEQ X \MAXFATCHAR) , but that's implied by the first two clauses) (AND (SMALLP X) (IGREATERP X \MAXTHINCHAR))))(PUTPROPS \THINCHARCODEP DMACRO (OPENLAMBDA (X) (AND (SMALLP X) (IGEQ X 0) (ILEQ X \MAXTHINCHAR))))(PUTPROPS \GETBASEFAT MACRO (= . \GETBASE))(PUTPROPS \GETBASETHIN MACRO (= . \GETBASEBYTE))(PUTPROPS \PUTBASEFAT MACRO (= . \PUTBASE))(PUTPROPS \PUTBASETHIN MACRO (= . \PUTBASEBYTE))(PUTPROPS \PUTBASECHAR MACRO (OPENLAMBDA (FATP BASE OFFSET CODE) (COND (FATP (\PUTBASEFAT BASE OFFSET CODE)) (T (\PUTBASETHIN BASE OFFSET CODE)))))(PUTPROPS \GETBASECHAR MACRO ((FATP BASE N) (COND (FATP (\GETBASEFAT BASE N)) (T (\GETBASETHIN BASE N)))))(PUTPROPS \CHARSET MACRO ((CHARCODE) (LRSH CHARCODE 8)))(PUTPROPS \CHAR8CODE MACRO ((CHARCODE) (LOGAND CHARCODE 255)))(RPAQQ \ST.INDIRECT 3)(RPAQQ \CHARMASK 255)(RPAQQ \MAXCHAR 255)(RPAQQ \MAXTHINCHAR 255)(RPAQQ \MAXFATCHAR 65535)(RPAQQ \MAXCHARSET 255)(RPAQQ NSCHARSETSHIFT 255)(RPAQQ #STRINGPWORDS 4)(CONSTANTS (\ST.INDIRECT 3) (\CHARMASK 255) (\MAXCHAR 255) (\MAXTHINCHAR 255) (\MAXFATCHAR 65535) (\MAXCHARSET 255) (NSCHARSETSHIFT 255) (#STRINGPWORDS 4))(PUTPROPS \NATOMCHARS DMACRO ((AT) (fetch (LITATOM PNAMELENGTH) of AT)))(PUTPROPS \NSTRINGCHARS DMACRO ((S) (fetch (STRINGP LENGTH) of S)))(PUTPROP (QUOTE LLCHAR) (QUOTE IMPORTDATE) (IDATE " 1-Oct-86 16:51:34"))(ACCESSFNS BF ((BFBLOCK (ADDSTACKBASE DATUM))) (* ; "basic frame pointer") (BLOCKRECORD BFBLOCK ((FLAGS BITS 3) (NIL BITS 3) (RESIDUAL FLAG) (* ; "true if this is not a full BF") (PADDING BITS 1) (USECNT BITS 8) (IVAR WORD))) (TYPE? (IEQ (fetch (BF FLAGS) of DATUM) \STK.BF)) (ACCESSFNS BF ((NARGS (IDIFFERENCE (FOLDLO (IDIFFERENCE DATUM (fetch (BF IVAR) of DATUM)) WORDSPERCELL) (fetch (BF PADDING) of DATUM))) (SIZE (IPLUS 2 (IDIFFERENCE DATUM (fetch (BF IVAR) of DATUM)))) (CHECKED (AND (type? BF DATUM) (for I from (fetch (BF IVAR) of DATUM) to (IDIFFERENCE DATUM 2) by 2 always (IEQ \STK.NOTFLAG (fetch (BF FLAGS) of I))))))))(ACCESSFNS FX ((FXBLOCK (ADDSTACKBASE DATUM))) (* ; "frame extension index") (BLOCKRECORD FXBLOCK ((FLAGS BITS 3) (* ; "= \STK.FX") (FAST FLAG) (NIL FLAG) (INCALL FLAG) (* ; "set when fncall microcode has to punt") (VALIDNAMETABLE FLAG) (* ; "if on, NAMETABLE field is filled in.  If off, is same as FNHEADER") (NOPUSH FLAG) (* ; "when returning to this frame, don't push a value.  Set by interrupt code") (USECNT BITS 8) (#ALINK WORD) (* ; "low bit is SLOWP") (FNHEADLO WORD) (* ; "pointer in swapped order with HILOC duplicated") (FNHEADHI1 BYTE) (FNHEADHI2 BYTE) (NEXTBLOCK WORD) (PC WORD) (NAMETABLO WORD) (NAMETABHI1 BYTE) (NAMETABHI2 BYTE) (#BLINK WORD) (#CLINK WORD))) (BLOCKRECORD FXBLOCK ((FLAGBYTE BYTE) (NIL BYTE) (NIL BITS 15) (* ; "most of the bits of #ALINK") (SLOWP FLAG) (* ; "if on, then BLINK and CLINK fields are valid.  If off, they are implicit"))) (TYPE? (IEQ (fetch (FX FLAGS) of DATUM) \STK.FX)) (ACCESSFNS FX ((FNHEADER (\VAG2 (fetch (FX FNHEADHI) of DATUM) (fetch (FX FNHEADLO) of DATUM)) (PROGN (replace (FX FNHEADHI) of DATUM with (\HILOC NEWVALUE)) (replace (FX FNHEADLO) of DATUM with (\LOLOC NEWVALUE)))) (FNHEADHI (fetch (FX FNHEADHI2) of DATUM) (PROGN (replace (FX FNHEADHI1) of DATUM with NEWVALUE) (replace (FX FNHEADHI2) of DATUM with NEWVALUE))) (NAMETABLE# (\VAG2 (fetch (FX NAMETABHI) of DATUM) (fetch (FX NAMETABLO) of DATUM)) (PROGN (replace (FX NAMETABHI) of DATUM with (\HILOC NEWVALUE)) (replace (FX NAMETABLO) of DATUM with (\LOLOC NEWVALUE)))) (NAMETABLE (COND ((fetch (FX VALIDNAMETABLE) of DATUM) (fetch (FX NAMETABLE#) of DATUM)) (T (fetch (FX FNHEADER) of DATUM))) (PROGN (replace (FX FAST) of DATUM with NIL) (replace (FX NAMETABLE#) of DATUM with NEWVALUE) (replace (FX VALIDNAMETABLE) of DATUM with T))) (NAMETABHI (fetch (FX NAMETABHI2) of DATUM) (PROGN (replace (FX NAMETABHI1) of DATUM with NEWVALUE) (replace (FX NAMETABHI2) of DATUM with NEWVALUE))) (FRAMENAME (fetch (FNHEADER FRAMENAME) of (fetch (FX NAMETABLE) of DATUM))) (INVALIDP (EQ DATUM 0)) (* ; "true when A/CLink points at nobody, i.e. FX is bottom of stack") (FASTP (NOT (fetch (FX SLOWP) of DATUM)) (PROGN (CHECK (NULL NEWVALUE)) (COND ((fetch (FX FASTP) of DATUM) (replace (FX #BLINK) of DATUM with (fetch (FX DUMMYBF) of DATUM)) (replace (FX #CLINK) of DATUM with (fetch (FX #ALINK) of DATUM)) (replace (FX SLOWP) of DATUM with T))))) (BLINK (COND ((fetch (FX FASTP) of DATUM) (fetch (FX DUMMYBF) of DATUM)) (T (fetch (FX #BLINK) of DATUM))) (PROGN (replace (FX #BLINK) of DATUM with NEWVALUE) (COND ((fetch (FX FASTP) of DATUM) (replace (FX #CLINK) of DATUM with (fetch (FX #ALINK) of DATUM)) (replace (FX SLOWP) of DATUM with T))))) (CLINK (IDIFFERENCE (COND ((fetch (FX FASTP) of DATUM) (fetch (FX #ALINK) of DATUM)) (T (fetch (FX #CLINK) of DATUM))) \#ALINK.OFFSET) (PROGN (replace (FX #CLINK) of DATUM with (IPLUS NEWVALUE \#ALINK.OFFSET)) (COND ((fetch (FX FASTP) of DATUM) (replace (FX #BLINK) of DATUM with (fetch (FX DUMMYBF) of DATUM)) (replace (FX SLOWP) of DATUM with T))))) (ALINK (IDIFFERENCE (FLOOR (fetch (FX #ALINK) of DATUM) WORDSPERCELL) \#ALINK.OFFSET) (PROGN (COND ((fetch (FX FASTP) of DATUM) (replace (FX #BLINK) of DATUM with (fetch (FX DUMMYBF) of DATUM)) (replace (FX #CLINK) of DATUM with (fetch (FX #ALINK) of DATUM)))) (replace (FX #ALINK) of DATUM with (IPLUS NEWVALUE \#ALINK.OFFSET (SUB1 WORDSPERCELL))))) (ACLINK (SHOULDNT) (PROGN (COND ((fetch (FX FASTP) of DATUM) (replace (FX #BLINK) of DATUM with (fetch (FX DUMMYBF) of DATUM)))) (replace (FX #CLINK) of DATUM with (IPLUS NEWVALUE \#ALINK.OFFSET)) (replace (FX #ALINK) of DATUM with (IPLUS NEWVALUE \#ALINK.OFFSET (SUB1 WORDSPERCELL))))) (* ; "replaces A &amp; C Links at once more efficiently than separately") (DUMMYBF (IDIFFERENCE DATUM WORDSPERCELL)) (* ;; "This is either an actual BF or %"residual%" BF that provides enough BF to find its IVAR slot.  This means that when a FX is copied, the cell preceding the FX is copied too.") (IVAR (fetch (BF IVAR) of (fetch (FX DUMMYBF) of DATUM))) (CHECKED (AND (type? FX DATUM) (OR (IEQ (fetch (FX DUMMYBF) of DATUM) (fetch (FX BLINK) of DATUM)) (AND (fetch (BF RESIDUAL) of (fetch (FX DUMMYBF) of DATUM)) (IEQ (fetch (BF IVAR) of (fetch (FX DUMMYBF) of DATUM)) (fetch (BF IVAR) of (fetch (FX BLINK) of DATUM))))))) (FIRSTPVAR (IPLUS DATUM (fetch (FX FXSIZE) of T))) (* ; "stack offset of PVAR0") (FXSIZE (PROGN 10)) (* ; "fixed overhead from flags thru clink") (PADDING (PROGN 4)) (* ; "doublecell of garbage for microcode use") (FIRSTTEMP (IPLUS (fetch (FX FIRSTPVAR) of DATUM) (fetch (FX NPVARWORDS) of DATUM) (fetch (FX PADDING) of DATUM))) (* ; "note that NPVARWORDS is obtained from the FNHEADER") (SIZE (IDIFFERENCE (fetch (FX NEXTBLOCK) of DATUM) DATUM)))))(ACCESSFNS FSB ((FSBBLOCK (ADDSTACKBASE DATUM)) (CHECKED (IEQ (fetch (FSB FLAGWORD) of DATUM) \STK.FSB.WORD))) (BLOCKRECORD FSBBLOCK ((FLAGS BITS 3) (DUMMY BITS 13) (SIZE WORD))) (BLOCKRECORD FSBBLOCK ((FLAGWORD WORD) (SIZE WORD))) (* ; "free stack block") (TYPE? (IEQ (fetch (FSB FLAGS) of DATUM) \STK.FSB)))(ACCESSFNS STK ((STKBLOCK (ADDSTACKBASE DATUM))) (* ; "unspecified stack block") (BLOCKRECORD STKBLOCK ((FLAGS BITS 3))) (BLOCKRECORD STKBLOCK ((FLAGWORD WORD))))(RPAQQ \#ALINK.OFFSET 10)(CONSTANTS \#ALINK.OFFSET)(GLOBALVARS \PENDINGINTERRUPT \KBDSTACKBASE \MISCSTACKBASE \STACKOVERFLOW)(PUTPROPS \MYALINK DMACRO (NIL ((OPCODES MYALINK))))(PUTPROPS ADDSTACKBASE DMACRO (= . STACKADDBASE))(PUTPROPS STACKADDBASE DMACRO ((N) (VAG2 \STACKHI N)))(PUTPROPS STACKGETBASE DMACRO ((N) (\GETBASE (STACKADDBASE N) 0)))(PUTPROPS STACKGETBASEPTR DMACRO ((N) (\GETBASEPTR (STACKADDBASE N) 0)))(PUTPROPS STACKPUTBASE DMACRO ((N V) (\PUTBASE (STACKADDBASE N) 0 V)))(PUTPROPS STACKPUTBASEPTR DMACRO ((N V) (\PUTBASEPTR (STACKADDBASE N) 0 V)))(PUTPROPS \MISCAPPLY* MACRO ((FN ARG1 ARG2) (UNINTERRUPTABLY (replace (IFPAGE MISCSTACKFN) of \InterfacePage with FN) (replace (IFPAGE MISCSTACKARG1) of \InterfacePage with ARG1) (replace (IFPAGE MISCSTACKARG2) of \InterfacePage with ARG2) (\CONTEXTSWITCH \MiscFXP) (fetch (IFPAGE MISCSTACKRESULT) of \InterfacePage))))(BLOCKRECORD STACKP ((STACKP0 WORD) (EDFXP WORD)) (BLOCKRECORD STACKP ((STACKPOINTER FULLXPOINTER))) (TYPE? (STACKP DATUM)))(RPAQQ STACKTYPES (\STK.GUARD \STK.FX \STK.BF \STK.NOTFLAG \STK.FSB \STK.FLAGS.SHIFT (\STK.FSB.WORD (LLSH \STK.FSB \STK.FLAGS.SHIFT)) (\STK.GUARD.WORD (LLSH \STK.GUARD \STK.FLAGS.SHIFT)) (\STK.BF.WORD (LLSH \STK.BF \STK.FLAGS.SHIFT))))(RPAQQ \STK.GUARD 7)(RPAQQ \STK.FX 6)(RPAQQ \STK.BF 4)(RPAQQ \STK.NOTFLAG 0)(RPAQQ \STK.FSB 5)(RPAQQ \STK.FLAGS.SHIFT 13)(RPAQ \STK.FSB.WORD (LLSH \STK.FSB \STK.FLAGS.SHIFT))(RPAQ \STK.GUARD.WORD (LLSH \STK.GUARD \STK.FLAGS.SHIFT))(RPAQ \STK.BF.WORD (LLSH \STK.BF \STK.FLAGS.SHIFT))(CONSTANTS \STK.GUARD \STK.FX \STK.BF \STK.NOTFLAG \STK.FSB \STK.FLAGS.SHIFT (\STK.FSB.WORD (LLSH \STK.FSB \STK.FLAGS.SHIFT)) (\STK.GUARD.WORD (LLSH \STK.GUARD \STK.FLAGS.SHIFT)) (\STK.BF.WORD (LLSH \STK.BF \STK.FLAGS.SHIFT)))(RPAQQ \StackAreaSize 768)(RPAQ \InitStackSize (ITIMES \StackAreaSize 12))(CONSTANTS \StackAreaSize (\InitStackSize (ITIMES \StackAreaSize 12)))(RPAQQ \MAXSAFEUSECOUNT 200)(CONSTANTS \MAXSAFEUSECOUNT)(BLOCKRECORD NAMETABLESLOT ((VARTYPE BYTE) (VAROFFSET BYTE)))(BLOCKRECORD FVARSLOT ((BINDLO WORD) (BINDHI1 BYTE) (BINDHI2 BYTE)) (ACCESSFNS FVARSLOT ((LOOKEDUP (EVENP (fetch BINDLO of DATUM))) (BINDINGPTR (\VAG2 (fetch BINDHI1 of DATUM) (fetch BINDLO of DATUM)) (PROGN (replace BINDLO of DATUM with (\LOLOC NEWVALUE)) (replace BINDHI1 of DATUM with (replace BINDHI2 of DATUM with (\HILOC NEWVALUE))))))))(BLOCKRECORD PVARSLOT ((PVHI BYTE) (PVVALUE XPOINTER)) (ACCESSFNS PVARSLOT ((BOUND (EQ (fetch (PVARSLOT PVHI) of DATUM) 0) (if (NULL NEWVALUE) then (replace (PVARSLOT PVHI) of DATUM with 255) else (ERROR "Illegal replace" NEWVALUE))))))(BLOCKRECORD STKTEMPSLOT ((STKTMPHI BYTE) (VALUE XPOINTER)) (ACCESSFNS STKTEMPSLOT ((BINDINGPTRP (NEQ (fetch STKTMPHI of DATUM) 0)))))(BLOCKRECORD BINDMARKSLOT ((BINDMARKP FLAG) (NIL BITS 15)) (BLOCKRECORD BINDMARKSLOT ((BINDNEGVALUES WORD) (BINDLASTPVAR WORD))) (ACCESSFNS BINDMARKSLOT ((BINDNVALUES (PROGN (* ; "Value stored in high half is one's complement of number of values bound") (LOGXOR (fetch BINDNEGVALUES of DATUM) 65535))))))(RPAQQ \NT.IVAR 0)(RPAQQ \NT.PVAR 128)(RPAQQ \NT.FVAR 192)(CONSTANTS \NT.IVAR \NT.PVAR \NT.FVAR)(PUTPROP (QUOTE LLSTK) (QUOTE IMPORTDATE) (IDATE "10-Oct-86 22:16:39"))(PUTPROPS WORDCONTENTS BYTEMACRO ((PTR) (\GETBASE PTR 0)))(PUTPROPS SETWORDCONTENTS BYTEMACRO ((PTR N) (\PUTBASE PTR 0 N)))(PUTPROPS WORDOFFSET BYTEMACRO ((PTR N) (\ADDBASE PTR N)))(PUTPROPS \RELEASECPAGE MACRO ((STREAM) (PROGN (* Must be under an UNINTERRUPTABLY !) (COND ((fetch CBUFDIRTY of STREAM) (\SETIODIRTY STREAM (fetch CPAGE of STREAM)) (replace CBUFDIRTY of STREAM with NIL))) (replace CBUFSIZE of STREAM with 0) (replace CBUFPTR of STREAM with NIL))))(PUTPROP (QUOTE PMAP) (QUOTE IMPORTDATE) (IDATE " 7-Oct-86 20:45:05"))(PUTPROPS ADDREF MACRO (OPENLAMBDA (PTR) (PROG1 PTR (\ADDREF PTR))))(PUTPROPS \ADDREF DMACRO ((X) ((OPCODES GCREF 0) X)))(PUTPROPS DELETEREF MACRO (OPENLAMBDA (PTR) (PROG1 PTR (\DELREF PTR))))(PUTPROPS \DELREF DMACRO ((X) ((OPCODES GCREF 1) X)))(PUTPROPS SCANREF MACRO (= . \STKREF))(PUTPROPS \STKREF DMACRO ((X) ((OPCODES GCREF 2) X)))(PUTPROPS UNSCANREF MACRO ((PTR) (\HTFIND PTR 3)))(PUTPROPS CREATEREF MACRO (= . \CREATEREF))(PUTPROPS \CREATEREF MACRO (OPENLAMBDA (PTR) (PROG1 (\DELREF PTR) (.INCREMENT.ALLOCATION.COUNT. 1))))(PUTPROPS .INCREMENT.ALLOCATION.COUNT. MACRO (OPENLAMBDA (N) (DECLARE (GLOBALVARS \RECLAIM.COUNTDOWN)) (AND \RECLAIM.COUNTDOWN (COND ((IGREATERP \RECLAIM.COUNTDOWN N) (SETQ \RECLAIM.COUNTDOWN (IDIFFERENCE \RECLAIM.COUNTDOWN N))) (T (SETQ \RECLAIM.COUNTDOWN) (\DORECLAIM))))))(PUTPROPS \GCDISABLED MACRO (NIL (PROGN (DECLARE (GLOBALVARS \GCDISABLED)) \GCDISABLED)))(BLOCKRECORD HTOVERFLOW ((CASE BYTE) (PTR XPOINTER)) (ACCESSFNS HTOVERFLOW ((CLEAR NIL (\PUTBASEPTR DATUM 0 NIL)))))(BLOCKRECORD GC ((CNT BITS 6) (STKBIT FLAG) (HIBITS BITS 8) (LINKP FLAG) (NXTPTR WORD)) (BLOCKRECORD GC ((STKCNT BITS 7))) (ACCESSFNS GC ((EMPTY (EQ 0 (\GETBASE DATUM 0)) (\PUTBASE DATUM 0 0)) (CONTENTS (\GETBASE DATUM 0) (\PUTBASE DATUM 0 NEWVALUE)) (LINKPTR (LOGAND (\GETBASE DATUM 0) 65534) (\PUTBASE DATUM 0 (LOGOR NEWVALUE 1))))))(BLOCKRECORD HTCOLL ((FREEPTR WORD) (NEXTFREE WORD)))(PUTPROP (QUOTE LLGC) (QUOTE IMPORTDATE) (IDATE " 3-Jun-86 14:00:39"))(PUTPROPS \SYNCODE DMACRO (OPENLAMBDA (TABLE CHAR) (CHECK (type? CHARTABLE TABLE)) (* 0 is either NONE.TC, REAL.CCE, or OTHER.RC) (COND ((IGREATERP CHAR \MAXTHINCHAR) (OR (AND (fetch (CHARTABLE NSCHARHASH) of TABLE) (GETHASH CHAR (fetch (CHARTABLE NSCHARHASH) of TABLE))) 0)) (T (\GETBASEBYTE TABLE CHAR)))))(PUTPROPS \SETSYNCODE DMACRO (LAMBDA (TABLE CHAR CODE) (CHECK (type? CHARTABLE TABLE)) (* 0 is REAL.CCE, NONE.TC, OTHER.RC) (COND ((ILEQ CHAR \MAXTHINCHAR) (\PUTBASEBYTE TABLE CHAR CODE)) (T (\SETFATSYNCODE TABLE CHAR CODE)))))(DATATYPE CHARTABLE ((CHARSET0 256 BYTE) (NSCHARHASH FULLPOINTER)))(/DECLAREDATATYPE (QUOTE CHARTABLE) (QUOTE (BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE BYTE FULLPOINTER)) (QUOTE ((CHARTABLE 0 (BITS . 7)) (CHARTABLE 0 (BITS . 135)) (CHARTABLE 1 (BITS . 7)) (CHARTABLE 1 (BITS . 135)) (CHARTABLE 2 (BITS . 7)) (CHARTABLE 2 (BITS . 135)) (CHARTABLE 3 (BITS . 7)) (CHARTABLE 3 (BITS . 135)) (CHARTABLE 4 (BITS . 7)) (CHARTABLE 4 (BITS . 135)) (CHARTABLE 5 (BITS . 7)) (CHARTABLE 5 (BITS . 135)) (CHARTABLE 6 (BITS . 7)) (CHARTABLE 6 (BITS . 135)) (CHARTABLE 7 (BITS . 7)) (CHARTABLE 7 (BITS . 135)) (CHARTABLE 8 (BITS . 7)) (CHARTABLE 8 (BITS . 135)) (CHARTABLE 9 (BITS . 7)) (CHARTABLE 9 (BITS . 135)) (CHARTABLE 10 (BITS . 7)) (CHARTABLE 10 (BITS . 135)) (CHARTABLE 11 (BITS . 7)) (CHARTABLE 11 (BITS . 135)) (CHARTABLE 12 (BITS . 7)) (CHARTABLE 12 (BITS . 135)) (CHARTABLE 13 (BITS . 7)) (CHARTABLE 13 (BITS . 135)) (CHARTABLE 14 (BITS . 7)) (CHARTABLE 14 (BITS . 135)) (CHARTABLE 15 (BITS . 7)) (CHARTABLE 15 (BITS . 135)) (CHARTABLE 16 (BITS . 7)) (CHARTABLE 16 (BITS . 135)) (CHARTABLE 17 (BITS . 7)) (CHARTABLE 17 (BITS . 135)) (CHARTABLE 18 (BITS . 7)) (CHARTABLE 18 (BITS . 135)) (CHARTABLE 19 (BITS . 7)) (CHARTABLE 19 (BITS . 135)) (CHARTABLE 20 (BITS . 7)) (CHARTABLE 20 (BITS . 135)) (CHARTABLE 21 (BITS . 7)) (CHARTABLE 21 (BITS . 135)) (CHARTABLE 22 (BITS . 7)) (CHARTABLE 22 (BITS . 135)) (CHARTABLE 23 (BITS . 7)) (CHARTABLE 23 (BITS . 135)) (CHARTABLE 24 (BITS . 7)) (CHARTABLE 24 (BITS . 135)) (CHARTABLE 25 (BITS . 7)) (CHARTABLE 25 (BITS . 135)) (CHARTABLE 26 (BITS . 7)) (CHARTABLE 26 (BITS . 135)) (CHARTABLE 27 (BITS . 7)) (CHARTABLE 27 (BITS . 135)) (CHARTABLE 28 (BITS . 7)) (CHARTABLE 28 (BITS . 135)) (CHARTABLE 29 (BITS . 7)) (CHARTABLE 29 (BITS . 135)) (CHARTABLE 30 (BITS . 7)) (CHARTABLE 30 (BITS . 135)) (CHARTABLE 31 (BITS . 7)) (CHARTABLE 31 (BITS . 135)) (CHARTABLE 32 (BITS . 7)) (CHARTABLE 32 (BITS . 135)) (CHARTABLE 33 (BITS . 7)) (CHARTABLE 33 (BITS . 135)) (CHARTABLE 34 (BITS . 7)) (CHARTABLE 34 (BITS . 135)) (CHARTABLE 35 (BITS . 7)) (CHARTABLE 35 (BITS . 135)) (CHARTABLE 36 (BITS . 7)) (CHARTABLE 36 (BITS . 135)) (CHARTABLE 37 (BITS . 7)) (CHARTABLE 37 (BITS . 135)) (CHARTABLE 38 (BITS . 7)) (CHARTABLE 38 (BITS . 135)) (CHARTABLE 39 (BITS . 7)) (CHARTABLE 39 (BITS . 135)) (CHARTABLE 40 (BITS . 7)) (CHARTABLE 40 (BITS . 135)) (CHARTABLE 41 (BITS . 7)) (CHARTABLE 41 (BITS . 135)) (CHARTABLE 42 (BITS . 7)) (CHARTABLE 42 (BITS . 135)) (CHARTABLE 43 (BITS . 7)) (CHARTABLE 43 (BITS . 135)) (CHARTABLE 44 (BITS . 7)) (CHARTABLE 44 (BITS . 135)) (CHARTABLE 45 (BITS . 7)) (CHARTABLE 45 (BITS . 135)) (CHARTABLE 46 (BITS . 7)) (CHARTABLE 46 (BITS . 135)) (CHARTABLE 47 (BITS . 7)) (CHARTABLE 47 (BITS . 135)) (CHARTABLE 48 (BITS . 7)) (CHARTABLE 48 (BITS . 135)) (CHARTABLE 49 (BITS . 7)) (CHARTABLE 49 (BITS . 135)) (CHARTABLE 50 (BITS . 7)) (CHARTABLE 50 (BITS . 135)) (CHARTABLE 51 (BITS . 7)) (CHARTABLE 51 (BITS . 135)) (CHARTABLE 52 (BITS . 7)) (CHARTABLE 52 (BITS . 135)) (CHARTABLE 53 (BITS . 7)) (CHARTABLE 53 (BITS . 135)) (CHARTABLE 54 (BITS . 7)) (CHARTABLE 54 (BITS . 135)) (CHARTABLE 55 (BITS . 7)) (CHARTABLE 55 (BITS . 135)) (CHARTABLE 56 (BITS . 7)) (CHARTABLE 56 (BITS . 135)) (CHARTABLE 57 (BITS . 7)) (CHARTABLE 57 (BITS . 135)) (CHARTABLE 58 (BITS . 7)) (CHARTABLE 58 (BITS . 135)) (CHARTABLE 59 (BITS . 7)) (CHARTABLE 59 (BITS . 135)) (CHARTABLE 60 (BITS . 7)) (CHARTABLE 60 (BITS . 135)) (CHARTABLE 61 (BITS . 7)) (CHARTABLE 61 (BITS . 135)) (CHARTABLE 62 (BITS . 7)) (CHARTABLE 62 (BITS . 135)) (CHARTABLE 63 (BITS . 7)) (CHARTABLE 63 (BITS . 135)) (CHARTABLE 64 (BITS . 7)) (CHARTABLE 64 (BITS . 135)) (CHARTABLE 65 (BITS . 7)) (CHARTABLE 65 (BITS . 135)) (CHARTABLE 66 (BITS . 7)) (CHARTABLE 66 (BITS . 135)) (CHARTABLE 67 (BITS . 7)) (CHARTABLE 67 (BITS . 135)) (CHARTABLE 68 (BITS . 7)) (CHARTABLE 68 (BITS . 135)) (CHARTABLE 69 (BITS . 7)) (CHARTABLE 69 (BITS . 135)) (CHARTABLE 70 (BITS . 7)) (CHARTABLE 70 (BITS . 135)) (CHARTABLE 71 (BITS . 7)) (CHARTABLE 71 (BITS . 135)) (CHARTABLE 72 (BITS . 7)) (CHARTABLE 72 (BITS . 135)) (CHARTABLE 73 (BITS . 7)) (CHARTABLE 73 (BITS . 135)) (CHARTABLE 74 (BITS . 7)) (CHARTABLE 74 (BITS . 135)) (CHARTABLE 75 (BITS . 7)) (CHARTABLE 75 (BITS . 135)) (CHARTABLE 76 (BITS . 7)) (CHARTABLE 76 (BITS . 135)) (CHARTABLE 77 (BITS . 7)) (CHARTABLE 77 (BITS . 135)) (CHARTABLE 78 (BITS . 7)) (CHARTABLE 78 (BITS . 135)) (CHARTABLE 79 (BITS . 7)) (CHARTABLE 79 (BITS . 135)) (CHARTABLE 80 (BITS . 7)) (CHARTABLE 80 (BITS . 135)) (CHARTABLE 81 (BITS . 7)) (CHARTABLE 81 (BITS . 135)) (CHARTABLE 82 (BITS . 7)) (CHARTABLE 82 (BITS . 135)) (CHARTABLE 83 (BITS . 7)) (CHARTABLE 83 (BITS . 135)) (CHARTABLE 84 (BITS . 7)) (CHARTABLE 84 (BITS . 135)) (CHARTABLE 85 (BITS . 7)) (CHARTABLE 85 (BITS . 135)) (CHARTABLE 86 (BITS . 7)) (CHARTABLE 86 (BITS . 135)) (CHARTABLE 87 (BITS . 7)) (CHARTABLE 87 (BITS . 135)) (CHARTABLE 88 (BITS . 7)) (CHARTABLE 88 (BITS . 135)) (CHARTABLE 89 (BITS . 7)) (CHARTABLE 89 (BITS . 135)) (CHARTABLE 90 (BITS . 7)) (CHARTABLE 90 (BITS . 135)) (CHARTABLE 91 (BITS . 7)) (CHARTABLE 91 (BITS . 135)) (CHARTABLE 92 (BITS . 7)) (CHARTABLE 92 (BITS . 135)) (CHARTABLE 93 (BITS . 7)) (CHARTABLE 93 (BITS . 135)) (CHARTABLE 94 (BITS . 7)) (CHARTABLE 94 (BITS . 135)) (CHARTABLE 95 (BITS . 7)) (CHARTABLE 95 (BITS . 135)) (CHARTABLE 96 (BITS . 7)) (CHARTABLE 96 (BITS . 135)) (CHARTABLE 97 (BITS . 7)) (CHARTABLE 97 (BITS . 135)) (CHARTABLE 98 (BITS . 7)) (CHARTABLE 98 (BITS . 135)) (CHARTABLE 99 (BITS . 7)) (CHARTABLE 99 (BITS . 135)) (CHARTABLE 100 (BITS . 7)) (CHARTABLE 100 (BITS . 135)) (CHARTABLE 101 (BITS . 7)) (CHARTABLE 101 (BITS . 135)) (CHARTABLE 102 (BITS . 7)) (CHARTABLE 102 (BITS . 135)) (CHARTABLE 103 (BITS . 7)) (CHARTABLE 103 (BITS . 135)) (CHARTABLE 104 (BITS . 7)) (CHARTABLE 104 (BITS . 135)) (CHARTABLE 105 (BITS . 7)) (CHARTABLE 105 (BITS . 135)) (CHARTABLE 106 (BITS . 7)) (CHARTABLE 106 (BITS . 135)) (CHARTABLE 107 (BITS . 7)) (CHARTABLE 107 (BITS . 135)) (CHARTABLE 108 (BITS . 7)) (CHARTABLE 108 (BITS . 135)) (CHARTABLE 109 (BITS . 7)) (CHARTABLE 109 (BITS . 135)) (CHARTABLE 110 (BITS . 7)) (CHARTABLE 110 (BITS . 135)) (CHARTABLE 111 (BITS . 7)) (CHARTABLE 111 (BITS . 135)) (CHARTABLE 112 (BITS . 7)) (CHARTABLE 112 (BITS . 135)) (CHARTABLE 113 (BITS . 7)) (CHARTABLE 113 (BITS . 135)) (CHARTABLE 114 (BITS . 7)) (CHARTABLE 114 (BITS . 135)) (CHARTABLE 115 (BITS . 7)) (CHARTABLE 115 (BITS . 135)) (CHARTABLE 116 (BITS . 7)) (CHARTABLE 116 (BITS . 135)) (CHARTABLE 117 (BITS . 7)) (CHARTABLE 117 (BITS . 135)) (CHARTABLE 118 (BITS . 7)) (CHARTABLE 118 (BITS . 135)) (CHARTABLE 119 (BITS . 7)) (CHARTABLE 119 (BITS . 135)) (CHARTABLE 120 (BITS . 7)) (CHARTABLE 120 (BITS . 135)) (CHARTABLE 121 (BITS . 7)) (CHARTABLE 121 (BITS . 135)) (CHARTABLE 122 (BITS . 7)) (CHARTABLE 122 (BITS . 135)) (CHARTABLE 123 (BITS . 7)) (CHARTABLE 123 (BITS . 135)) (CHARTABLE 124 (BITS . 7)) (CHARTABLE 124 (BITS . 135)) (CHARTABLE 125 (BITS . 7)) (CHARTABLE 125 (BITS . 135)) (CHARTABLE 126 (BITS . 7)) (CHARTABLE 126 (BITS . 135)) (CHARTABLE 127 (BITS . 7)) (CHARTABLE 127 (BITS . 135)) (CHARTABLE 128 FULLPOINTER))) (QUOTE 130))(RPAQQ CCECHOMODES (REAL.CCE IGNORE.CCE SIMULATE.CCE INDICATE.CCE))(RPAQQ REAL.CCE 0)(RPAQQ IGNORE.CCE 8)(RPAQQ SIMULATE.CCE 16)(RPAQQ INDICATE.CCE 24)(CONSTANTS REAL.CCE IGNORE.CCE SIMULATE.CCE INDICATE.CCE)(RPAQQ TERMCLASSES (NONE.TC EOL.TC CHARDELETE.TC WORDDELETE.TC WORDSEPR.TC LINEDELETE.TC RETYPE.TC CTRLV.TC))(RPAQQ NONE.TC 0)(RPAQQ EOL.TC 1)(RPAQQ CHARDELETE.TC 2)(RPAQQ WORDDELETE.TC 6)(RPAQQ WORDSEPR.TC 7)(RPAQQ LINEDELETE.TC 3)(RPAQQ RETYPE.TC 4)(RPAQQ CTRLV.TC 5)(CONSTANTS NONE.TC EOL.TC CHARDELETE.TC WORDDELETE.TC WORDSEPR.TC LINEDELETE.TC RETYPE.TC CTRLV.TC)(ACCESSFNS TERMCODE ((CCECHO (LOGAND DATUM 24)) (TERMCLASS (LOGAND DATUM 7))) (* We assume that values are appropriately shifted) (CREATE (LOGOR CCECHO TERMCLASS)))(DATATYPE TERMTABLEP (TERMSA RAISEFLG DELCHARECHO LINEDELETE 1STCHDEL NTHCHDEL POSTCHDEL EMPTYCHDEL (CONTROLFLG FLAG) (ECHOFLG FLAG)) TERMSA &larr; (create CHARTABLE))(/DECLAREDATATYPE (QUOTE TERMTABLEP) (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG FLAG)) (QUOTE ((TERMTABLEP 0 POINTER) (TERMTABLEP 2 POINTER) (TERMTABLEP 4 POINTER) (TERMTABLEP 6 POINTER) (TERMTABLEP 8 POINTER) (TERMTABLEP 10 POINTER) (TERMTABLEP 12 POINTER) (TERMTABLEP 14 POINTER) (TERMTABLEP 14 (FLAGBITS . 0)) (TERMTABLEP 14 (FLAGBITS . 16)))) (QUOTE 16))(PUTPROPS \GETREADMACRODEF MACRO ((C TBL) (GETHASH C (fetch READMACRODEFS of TBL))))(PUTPROPS \GTREADTABLE MACRO (ARGS (COND ((LITATOM (CAR ARGS)) (SUBPAIR (QUOTE (X . FLG)) ARGS (QUOTE (SELECTQ X ((NIL T) (\DTEST *READTABLE* (QUOTE READTABLEP))) (\GTREADTABLE1 X . FLG))))) (T (QUOTE IGNOREMACRO)))))(PUTPROPS \GTREADTABLE1 DMACRO (ARGS (COND ((NULL (CDR ARGS)) (LIST (QUOTE \DTEST) (CAR ARGS) (QUOTE (QUOTE READTABLEP)))) (T (QUOTE IGNOREMACRO)))))(RPAQQ MACROBIT 8)(RPAQQ BREAKBIT 16)(RPAQQ STOPATOMBIT 32)(RPAQQ ESCAPEBIT 64)(RPAQQ INNERESCAPEBIT 4)(CONSTANTS MACROBIT BREAKBIT STOPATOMBIT ESCAPEBIT INNERESCAPEBIT)(RPAQQ READCODEMASKS ((CONTEXTMASK (LOGOR MACROBIT STOPATOMBIT BREAKBIT 1)) (WAKEUPMASK (LOGOR MACROBIT 2))))(RPAQ CONTEXTMASK (LOGOR MACROBIT STOPATOMBIT BREAKBIT 1))(RPAQ WAKEUPMASK (LOGOR MACROBIT 2))(CONSTANTS (CONTEXTMASK (LOGOR MACROBIT STOPATOMBIT BREAKBIT 1)) (WAKEUPMASK (LOGOR MACROBIT 2)))(RPAQQ READMACROCONTEXTS ((ALWAYS.RMC (LOGOR MACROBIT STOPATOMBIT BREAKBIT 0)) (FIRST.RMC (LOGOR MACROBIT 0)) (ALONE.RMC (LOGOR MACROBIT 1))))(RPAQ ALWAYS.RMC (LOGOR MACROBIT STOPATOMBIT BREAKBIT 0))(RPAQ FIRST.RMC (LOGOR MACROBIT 0))(RPAQ ALONE.RMC (LOGOR MACROBIT 1))(CONSTANTS (ALWAYS.RMC (LOGOR MACROBIT STOPATOMBIT BREAKBIT 0)) (FIRST.RMC (LOGOR MACROBIT 0)) (ALONE.RMC (LOGOR MACROBIT 1)))(RPAQQ READCLASSES ((OTHER.RC 0) (SEPRCHAR.RC (LOGOR ESCAPEBIT STOPATOMBIT 0)) (BREAKCHAR.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 0)) (STRINGDELIM.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 1)) (LEFTPAREN.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 2)) (RIGHTPAREN.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 3)) (LEFTBRACKET.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 4)) (RIGHTBRACKET.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 5)) (ESCAPE.RC (LOGOR ESCAPEBIT INNERESCAPEBIT 6)) (MULTIPLE-ESCAPE.RC (LOGOR ESCAPEBIT INNERESCAPEBIT 7)) (PACKAGEDELIM.RC (LOGOR ESCAPEBIT INNERESCAPEBIT 1))))(RPAQQ OTHER.RC 0)(RPAQ SEPRCHAR.RC (LOGOR ESCAPEBIT STOPATOMBIT 0))(RPAQ BREAKCHAR.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 0))(RPAQ STRINGDELIM.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 1))(RPAQ LEFTPAREN.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 2))(RPAQ RIGHTPAREN.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 3))(RPAQ LEFTBRACKET.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 4))(RPAQ RIGHTBRACKET.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 5))(RPAQ ESCAPE.RC (LOGOR ESCAPEBIT INNERESCAPEBIT 6))(RPAQ MULTIPLE-ESCAPE.RC (LOGOR ESCAPEBIT INNERESCAPEBIT 7))(RPAQ PACKAGEDELIM.RC (LOGOR ESCAPEBIT INNERESCAPEBIT 1))(CONSTANTS (OTHER.RC 0) (SEPRCHAR.RC (LOGOR ESCAPEBIT STOPATOMBIT 0)) (BREAKCHAR.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 0)) (STRINGDELIM.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 1)) (LEFTPAREN.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 2)) (RIGHTPAREN.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 3)) (LEFTBRACKET.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 4)) (RIGHTBRACKET.RC (LOGOR ESCAPEBIT STOPATOMBIT BREAKBIT 5)) (ESCAPE.RC (LOGOR ESCAPEBIT INNERESCAPEBIT 6)) (MULTIPLE-ESCAPE.RC (LOGOR ESCAPEBIT INNERESCAPEBIT 7)) (PACKAGEDELIM.RC (LOGOR ESCAPEBIT INNERESCAPEBIT 1)))(RPAQQ READMACROWAKEUPS ((IMMEDIATE.RMW (LOGOR MACROBIT 2)) (NONIMMEDIATE.RMW (LOGOR MACROBIT 0))))(RPAQ IMMEDIATE.RMW (LOGOR MACROBIT 2))(RPAQ NONIMMEDIATE.RMW (LOGOR MACROBIT 0))(CONSTANTS (IMMEDIATE.RMW (LOGOR MACROBIT 2)) (NONIMMEDIATE.RMW (LOGOR MACROBIT 0)))(RPAQQ READMACROESCAPES ((ESC.RME ESCAPEBIT) (NOESC.RME 0)))(RPAQ ESC.RME ESCAPEBIT)(RPAQQ NOESC.RME 0)(CONSTANTS (ESC.RME ESCAPEBIT) (NOESC.RME 0))(ACCESSFNS READCODE ((ESCAPE (LOGAND DATUM ESCAPEBIT)) (ESCQUOTE (BITTEST DATUM ESCAPEBIT)) (STOPATOM (BITTEST DATUM STOPATOMBIT)) (INNERESCQUOTE (BITTEST DATUM (LOGOR STOPATOMBIT INNERESCAPEBIT))) (MACROCONTEXT (LOGAND DATUM CONTEXTMASK)) (MACROP (BITTEST DATUM MACROBIT)) (WAKEUP (LOGAND DATUM WAKEUPMASK)) (BREAK (BITTEST DATUM BREAKBIT))))(RECORD READMACRODEF (MACROTYPE . MACROFN))(DATATYPE READTABLEP ((READSA POINTER) (* "A CHARTABLE defining syntax of each char") (READMACRODEFS POINTER) (* "A hash table associating macro chars with macro definitions") (READMACROFLG FLAG) (* "True if read macros are enabled (turned off by Interlisp's crufty READMACROS function)") (ESCAPEFLG FLAG) (* "True if the char(s) with escape syntax are enabled (turned off by Interlisp's crufty ESCAPE function)") (COMMONLISP FLAG) (* "True if table is a Common Lisp read table and hence must obey Common Lisp syntax rules") (NUMBERBASE BITS 5) (* "Not used") (CASEINSENSITIVE FLAG) (* "If true, unescaped lowercase chars are converted to uppercase in symbols") (COMMONNUMSYNTAX FLAG) (* "True if number notation includes Common Lisp numbers: rationals as a/b, and the dfls exponent markers") (USESILPACKAGE FLAG) (* "If true, IL:READ ignores *PACKAGE* and reads in the IL package") (NIL 5 FLAG) (DISPATCHMACRODEFS POINTER) (* "An a-list of dispatching macro char and its dispatch definitions") (HASHMACROCHAR BYTE) (* "The character code used in this read table for the # dispatch macro") (ESCAPECHAR BYTE) (* "The character code used in this read table for single escape") (MULTESCAPECHAR BYTE) (* "The character code used in this read table for multiple escape") (PACKAGECHAR BYTE) (* "The character code used in this read table for package delimiter") (READTBLNAME POINTER) (* "The canonical 'name' of this read table")) READSA &larr; (create CHARTABLE))(/DECLAREDATATYPE (QUOTE READTABLEP) (QUOTE (POINTER POINTER FLAG FLAG FLAG (BITS 5) FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG POINTER BYTE BYTE BYTE BYTE POINTER)) (QUOTE ((READTABLEP 0 POINTER) (READTABLEP 2 POINTER) (READTABLEP 2 (FLAGBITS . 0)) (READTABLEP 2 (FLAGBITS . 16)) (READTABLEP 2 (FLAGBITS . 32)) (READTABLEP 2 (BITS . 52)) (READTABLEP 0 (FLAGBITS . 0)) (READTABLEP 0 (FLAGBITS . 16)) (READTABLEP 0 (FLAGBITS . 32)) (READTABLEP 0 (FLAGBITS . 48)) (READTABLEP 0 (FLAGBITS . 64)) (READTABLEP 0 (FLAGBITS . 80)) (READTABLEP 0 (FLAGBITS . 96)) (READTABLEP 0 (FLAGBITS . 112)) (READTABLEP 4 POINTER) (READTABLEP 4 (BITS . 7)) (READTABLEP 6 (BITS . 7)) (READTABLEP 6 (BITS . 135)) (READTABLEP 7 (BITS . 7)) (READTABLEP 8 POINTER))) (QUOTE 10))(PUTPROP (QUOTE ATBL) (QUOTE IMPORTDATE) (IDATE "28-Aug-86 18:59:05"))(DATATYPE STREAM ((* First 4 words are fixed for BIN, BOUT opcodes. Length of whole datatype is multiple of 4, so quad-aligned) (COFFSET WORD) (* Offset in CPPTR of next bin or bout) (CBUFSIZE WORD) (* Offset past last byte in that buffer) (BINABLE FLAG) (* BIN punts unless this bit on) (BOUTABLE FLAG) (* BOUT punts unless this bit on) (EXTENDABLE FLAG) (* BOUT punts when COFFSET ge CBUFFSIZE unless this bit set and COFFSET lt 512) (NIL BITS 5) (CBUFPTR POINTER) (* Pointer to current buffer) (NONDEFAULTDATEFLG FLAG) (REVALIDATEFLG FLAG) (MULTIBUFFERHINT FLAG) (* True if stream likes to read and write more than one buffer at a time) (USERCLOSEABLE FLAG) (* Can be closed by CLOSEF; NIL for terminal, dribble...) (USERVISIBLE FLAG) (* Listed by OPENP; NIL for terminal, dribble ...) (ACCESSBITS BITS 3) (* What kind of access file is open for (read, write, append)) (FULLFILENAME POINTER) (* Name by which file is known to user) (DEVICE POINTER) (* FDEV of this guy) (VALIDATION POINTER) (* A number somehow identifying file, used to determine if file has changed in our absence) (EPAGE WORD) (EOFFSET WORD) (* Page, byte offset of eof) (* Following are device-specific fields) (F1 POINTER) (F2 POINTER) (F3 POINTER) (F4 POINTER) (F5 POINTER) (FW6 WORD) (FW7 WORD) (* Following only filled in for open streams) (BYTESIZE BYTE) (BUFFS POINTER) (CPAGE WORD) (FW8 WORD) (MAXBUFFERS WORD) (CHARPOSITION WORD) (* Used by POSITION etc.) (DIRTYBITS WORD) (LINELENGTH WORD) (EOLCONVENTION BITS 2) (* End-of-line convention) (CBUFDIRTY FLAG) (NIL BITS 5) (OUTCHARFN POINTER) (ENDOFSTREAMOP POINTER) (* For use of applications programs, not devices) (OTHERPROPS POINTER) (IMAGEOPS POINTER) (* Image operations vector) (IMAGEDATA POINTER) (* Image instance variables--format depends on IMAGEOPS value) (EXTRASTREAMOP POINTER) (STRMBINFN POINTER) (* Either the BIN fn from the FDEV, or a trap) (STRMBOUTFN POINTER) (* Either the BIN fn from the FDEV, or a trap) (CBUFMAXSIZE WORD) (FW9 WORD) (F10 POINTER) (* the current character set for this stream. gbn %4-2-85) (CHARSET BYTE)) (BLOCKRECORD STREAM ((NIL 2 WORD) (UCODEFLAGS BYTE) (NIL POINTER))) (ACCESSFNS STREAM ((ACCESS \GETACCESS \SETACCESS) (FULLNAME (OR (fetch (STREAM FULLFILENAME) of DATUM) DATUM)) (NAMEDP (AND (fetch (STREAM FULLFILENAME) of DATUM) T)))) (SYNONYM CBUFPTR (CPPTR)) USERCLOSEABLE &larr; T USERVISIBLE &larr; T ACCESSBITS &larr; NoBits BUFFS &larr; NIL BYTESIZE &larr; 8 CBUFPTR &larr; NIL MAXBUFFERS &larr; (PROGN (DECLARE (GLOBALVARS \STREAM.DEFAULT.MAXBUFFERS)) \STREAM.DEFAULT.MAXBUFFERS) CHARPOSITION &larr; 0 LINELENGTH &larr; (PROGN (DECLARE (GLOBALVARS FILELINELENGTH)) FILELINELENGTH) OUTCHARFN &larr; (FUNCTION \FILEOUTCHARFN) ENDOFSTREAMOP &larr; (FUNCTION \EOSERROR) IMAGEOPS &larr; \NOIMAGEOPS EOLCONVENTION &larr; (SELECTQ (SYSTEMTYPE) (D CR.EOLC) (VAX LF.EOLC) (JERICHO CRLF.EOLC) CR.EOLC) STRMBINFN &larr; (FUNCTION \STREAM.NOT.OPEN) STRMBOUTFN &larr; (FUNCTION \STREAM.NOT.OPEN))(/DECLAREDATATYPE (QUOTE STREAM) (QUOTE (WORD WORD FLAG FLAG FLAG (BITS 5) POINTER FLAG FLAG FLAG FLAG FLAG (BITS 3) POINTER POINTER POINTER WORD WORD POINTER POINTER POINTER POINTER POINTER WORD WORD BYTE POINTER WORD WORD WORD WORD WORD WORD (BITS 2) FLAG (BITS 5) POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER WORD WORD POINTER BYTE)) (QUOTE ((STREAM 0 (BITS . 15)) (STREAM 1 (BITS . 15)) (STREAM 2 (FLAGBITS . 0)) (STREAM 2 (FLAGBITS . 16)) (STREAM 2 (FLAGBITS . 32)) (STREAM 2 (BITS . 52)) (STREAM 2 POINTER) (STREAM 4 (FLAGBITS . 0)) (STREAM 4 (FLAGBITS . 16)) (STREAM 4 (FLAGBITS . 32)) (STREAM 4 (FLAGBITS . 48)) (STREAM 4 (FLAGBITS . 64)) (STREAM 4 (BITS . 82)) (STREAM 4 POINTER) (STREAM 6 POINTER) (STREAM 8 POINTER) (STREAM 10 (BITS . 15)) (STREAM 11 (BITS . 15)) (STREAM 12 POINTER) (STREAM 14 POINTER) (STREAM 16 POINTER) (STREAM 18 POINTER) (STREAM 20 POINTER) (STREAM 22 (BITS . 15)) (STREAM 23 (BITS . 15)) (STREAM 20 (BITS . 7)) (STREAM 24 POINTER) (STREAM 26 (BITS . 15)) (STREAM 27 (BITS . 15)) (STREAM 28 (BITS . 15)) (STREAM 29 (BITS . 15)) (STREAM 30 (BITS . 15)) (STREAM 31 (BITS . 15)) (STREAM 24 (BITS . 1)) (STREAM 24 (FLAGBITS . 32)) (STREAM 24 (BITS . 52)) (STREAM 32 POINTER) (STREAM 34 POINTER) (STREAM 36 POINTER) (STREAM 38 POINTER) (STREAM 40 POINTER) (STREAM 42 POINTER) (STREAM 44 POINTER) (STREAM 46 POINTER) (STREAM 48 (BITS . 15)) (STREAM 49 (BITS . 15)) (STREAM 50 POINTER) (STREAM 50 (BITS . 7)))) (QUOTE 52))(PUTPROPS STREAMOP MACRO (ARGS (CONS (QUOTE SPREADAPPLY*) (CONS (COND ((EQ (CAR (LISTP (CAR ARGS))) (QUOTE QUOTE)) (LIST (QUOTE fetch) (CADAR ARGS) (QUOTE of) (CADR ARGS))) (T (HELP "STREAMOP - OPNAME not quoted:" ARGS))) (CDDR ARGS)))))(RPAQQ AppendBit 2)(RPAQQ NoBits 0)(RPAQQ ReadBit 1)(RPAQQ WriteBit 4)(RPAQ OutputBits (LOGOR AppendBit WriteBit))(RPAQ BothBits (LOGOR ReadBit OutputBits))(RPAQQ \NORUNCODE 255)(CONSTANTS AppendBit NoBits ReadBit WriteBit (OutputBits (LOGOR AppendBit WriteBit)) (BothBits (LOGOR ReadBit OutputBits)) \NORUNCODE)(PUTPROPS APPENDABLE MACRO ((STREAM) (TestMasked (fetch ACCESSBITS of STREAM) AppendBit)))(PUTPROPS APPENDONLY MACRO ((STREAM) (EQ (fetch ACCESSBITS of STREAM) AppendBit)))(PUTPROPS DIRTYABLE MACRO ((STREAM) (TestMasked (fetch ACCESSBITS of STREAM) (CONSTANT (LOGOR AppendBit WriteBit)))))(PUTPROPS OPENED MACRO ((STREAM) (NEQ (fetch ACCESSBITS of STREAM) NoBits)))(PUTPROPS OVERWRITEABLE MACRO ((STREAM) (TestMasked (fetch ACCESSBITS of STREAM) WriteBit)))(PUTPROPS READABLE MACRO ((STREAM) (TestMasked (fetch ACCESSBITS of STREAM) ReadBit)))(PUTPROPS READONLY MACRO ((STREAM) (EQ (fetch ACCESSBITS of STREAM) ReadBit)))(PUTPROPS WRITEABLE MACRO ((STREAM) (OR (OVERWRITEABLE STREAM) (AND (APPENDABLE STREAM) (\EOFP STREAM)))))(PUTPROPS TestMasked MACRO ((BITS MASK) (NEQ (LOGAND BITS MASK) 0)))(PUTPROPS \RUNCODED MACRO (OPENLAMBDA (STREAM) (* returns NIL is the stream is not runcoded, that is, if the stream has 16 bit bytes explicitly represented) (* note that neq is ok since charsets are known to be SMALLP's) (NEQ (fetch CHARSET of STREAM) \NORUNCODE)))(RPAQQ EOLCONVENTIONS ((CR.EOLC 0) (LF.EOLC 1) (CRLF.EOLC 2)))(RPAQQ CR.EOLC 0)(RPAQQ LF.EOLC 1)(RPAQQ CRLF.EOLC 2)(CONSTANTS (CR.EOLC 0) (LF.EOLC 1) (CRLF.EOLC 2))(PUTPROPS FDEVOP DMACRO (ARGS (LET ((OPNAME (CAR ARGS)) (METHOD-DEVICE (CADR ARGS)) (TAIL (CDDR ARGS))) (COND ((AND (LISTP OPNAME) (EQ (CAR OPNAME) (QUOTE QUOTE))) (BQUOTE (SPREADAPPLY* (fetch (FDEV (\, (CADR OPNAME))) of (\, METHOD-DEVICE)) (\,@ TAIL)))) (T (ERROR "OPNAME not quoted: " OPNAME))))))(PUTPROPS \RECOGNIZE-HACK DMACRO (ARGS (LET ((NAME (CAR ARGS)) (RECOG (CADR ARGS)) (DEVICE (CADDR ARGS))) (BQUOTE (if (type? STREAM (\, NAME)) then (\, NAME) else (FDEVOP (QUOTE GETFILENAME) (\, DEVICE) (\, NAME) (\, RECOG) (\, DEVICE)))))))(DATATYPE FDEV ((DEVICENAME POINTER) (RESETABLE FLAG) (RANDOMACCESSP FLAG) (NODIRECTORIES FLAG) (PAGEMAPPED FLAG) (* ; "True if i/o handled by pmap routines") (FDBINABLE FLAG) (* ; "Copied as a microcode flag for INPUT streams formed on this device") (FDBOUTABLE FLAG) (FDEXTENDABLE FLAG) (BUFFERED FLAG) (* ;; "True implies that the device supports the BIN &amp; BOUT uCode conventions, and implements the GETNEXTBUFFER method") (* ; "Device operations:") (REMOTEP FLAG) (* ; "true if device not local to machine") (SUBDIRECTORIES FLAG) (* ; "true if device has real subdirectories") (NIL 6 FLAG) (CLOSEFILE POINTER) (* ; "(stream) =&gt; closes stream, returns it") (DELETEFILE POINTER) (* ; "(name) =&gt; deletes file so named, returning name, or NIL on failure.  RECOG=OLDEST") (DIRECTORYNAMEP POINTER) (* ; "(host/dir) =&gt; true if directory exists on host") (EVENTFN POINTER) (* ; "(device event), called before/after logout, sysout, makesys") (GENERATEFILES POINTER) (* ;; "(device pattern) =&gt; generator object for files matching pattern.  Car of object is generator function, cdr is arbitrary state.  Generator fn returns next file, or NIL when finished") (GETFILEINFO POINTER) (* ; "(stream/name attribute device) =&gt; value of attribute for open stream or name of closed file") (GETFILENAME POINTER) (* ; "(name recog device) =&gt; full file name") (HOSTNAMEP POINTER) (* ;; "(hostname {device}) =&gt; T if hostname is valid.  If device is given, return a FDEV for this {new} host, or T to use existing device") (OPENFILE POINTER) (* ; "(name access recog otherinfo device) =&gt; new stream open on this device, or NIL if name not found") (READPAGES POINTER) (* ;; "(stream firstpage# buflist) =&gt; # of bytes read, starting at firstpage#, reading into buflist, a list of buffers or a single buffer (the usual case)") (REOPENFILE POINTER) (* ;; "(name access recog otherinfo device stream) like openfile, but called after logout to revalidate file, so optionally uses info in old stream to keep this opening like the previous") (SETFILEINFO POINTER) (* ; "(stream/name attribute newvalue device) sets attribute of open stream or closed file of given name") (TRUNCATEFILE POINTER) (* ; "(stream page offset) make stream's eof be at page,offset, discarding anything after it") (WRITEPAGES POINTER) (* ; "(stream firstpage# buflist) writes from buflist to stream starting at firstpage# of stream") (BIN POINTER) (* ; "(stream) =&gt; next byte of input") (BOUT POINTER) (* ; "(stream byte) output byte to stream") (PEEKBIN POINTER) (* ; "(stream) =&gt; next byte without advancing position in stream") (READP POINTER) (* ; "(stream flag) =&gt; T if there is input available from stream") (BACKFILEPTR POINTER) (* ;; "(stream) backs up `fileptr' by one.  Stream is only required to be able to do this once, i.e.  one-character buffer suffices") (DEVICEINFO POINTER) (* ; "arbitrary device-specific info stored here") (FORCEOUTPUT POINTER) (* ; "(stream waitForFinish) flushes out to device anything that is buffered awaiting transmission") (LASTC POINTER) (* ; "Should be possible only if RANDOMACCESSP") (SETFILEPTR POINTER) (GETFILEPTR POINTER) (GETEOFPTR POINTER) (EOFP POINTER) (BLOCKIN POINTER) (* ; "(stream buffer byteoffset nbytes)") (BLOCKOUT POINTER) (* ; "(stream buffer byteoffset nbytes)") (RENAMEFILE POINTER) (* ; "oldfile newfile device") (RELEASEBUFFER POINTER) (* ; "(stream) =&gt; Does whatever appropriate when CBUFPTR is released") (GETNEXTBUFFER POINTER) (* ;; "(stream whatfor noerrorflg) =&gt; Disposes of current buffer and optionally reads next.  whatfor is READ or WRITE.  Can cause EOF error unless noerrorflg") (SETEOFPTR POINTER) (* ; "(stream length) =&gt; truncates or lengthens stream to indicated length") (FREEPAGECOUNT POINTER) (* ; "(host/dir dev) =&gt; # of free pages on host/dir") (MAKEDIRECTORY POINTER) (* ; "(host/dir dev)") (WINDOWOPS POINTER) (* ; "window system operations") (WINDOWDATA POINTER) (* ; "data for window systems") (CHECKFILENAME POINTER) (* ; "(name dev) =&gt; name if it is well-formed file name for dev") (HOSTALIVEP POINTER) (* ; "(host dev) =&gt; true if host is alive, i.e., responsive;  only defined if REMOTEP is true") (OPENP POINTER) (* ; "(name access dev) =&gt; stream if name is open for access, or all open streams if name = NIL") (OPENFILELST POINTER) (* ; "Default place to keep list of streams open on this device") (REGISTERFILE POINTER) (* ; "(stream dev) =&gt; registers stream on its device") (UNREGISTERFILE POINTER) (* ; "(stream dev) =&gt; unregisters a stream from its device")) DIRECTORYNAMEP &larr; (FUNCTION NILL) HOSTNAMEP &larr; (FUNCTION NILL) READP &larr; (FUNCTION \GENERIC.READP) SETFILEPTR &larr; (FUNCTION \IS.NOT.RANDACCESSP) GETFILEPTR &larr; (FUNCTION \ILLEGAL.DEVICEOP) GETEOFPTR &larr; (FUNCTION \IS.NOT.RANDACCESSP) EOFP &larr; (FUNCTION \ILLEGAL.DEVICEOP) BLOCKIN &larr; (FUNCTION \GENERIC.BINS) BLOCKOUT &larr; (FUNCTION \GENERIC.BOUTS) RENAMEFILE &larr; (FUNCTION \GENERIC.RENAMEFILE) FORCEOUTPUT &larr; (FUNCTION NILL) REGISTERFILE &larr; (FUNCTION NILL) OPENP &larr; (FUNCTION NILL) UNREGISTERFILE &larr; (FUNCTION NILL))(RECORD FILEGENOBJ (NEXTFILEFN FILEINFOFN . GENFILESTATE))(/DECLAREDATATYPE (QUOTE FDEV) (QUOTE (POINTER FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER)) (QUOTE ((FDEV 0 POINTER) (FDEV 0 (FLAGBITS . 0)) (FDEV 0 (FLAGBITS . 16)) (FDEV 0 (FLAGBITS . 32)) (FDEV 0 (FLAGBITS . 48)) (FDEV 0 (FLAGBITS . 64)) (FDEV 0 (FLAGBITS . 80)) (FDEV 0 (FLAGBITS . 96)) (FDEV 0 (FLAGBITS . 112)) (FDEV 2 (FLAGBITS . 0)) (FDEV 2 (FLAGBITS . 16)) (FDEV 2 (FLAGBITS . 32)) (FDEV 2 (FLAGBITS . 48)) (FDEV 2 (FLAGBITS . 64)) (FDEV 2 (FLAGBITS . 80)) (FDEV 2 (FLAGBITS . 96)) (FDEV 2 (FLAGBITS . 112)) (FDEV 2 POINTER) (FDEV 4 POINTER) (FDEV 6 POINTER) (FDEV 8 POINTER) (FDEV 10 POINTER) (FDEV 12 POINTER) (FDEV 14 POINTER) (FDEV 16 POINTER) (FDEV 18 POINTER) (FDEV 20 POINTER) (FDEV 22 POINTER) (FDEV 24 POINTER) (FDEV 26 POINTER) (FDEV 28 POINTER) (FDEV 30 POINTER) (FDEV 32 POINTER) (FDEV 34 POINTER) (FDEV 36 POINTER) (FDEV 38 POINTER) (FDEV 40 POINTER) (FDEV 42 POINTER) (FDEV 44 POINTER) (FDEV 46 POINTER) (FDEV 48 POINTER) (FDEV 50 POINTER) (FDEV 52 POINTER) (FDEV 54 POINTER) (FDEV 56 POINTER) (FDEV 58 POINTER) (FDEV 60 POINTER) (FDEV 62 POINTER) (FDEV 64 POINTER) (FDEV 66 POINTER) (FDEV 68 POINTER) (FDEV 70 POINTER) (FDEV 72 POINTER) (FDEV 74 POINTER) (FDEV 76 POINTER) (FDEV 78 POINTER) (FDEV 80 POINTER) (FDEV 82 POINTER) (FDEV 84 POINTER))) (QUOTE 86))(PUTPROPS \OUTCHAR DMACRO (OPENLAMBDA (STREAM CHARCODE) (STREAMOP (QUOTE OUTCHARFN) STREAM STREAM CHARCODE)))(PUTPROPS \DEVICE-OPEN-STREAMS MACRO (ARGS (LET ((DEVICE (CAR ARGS))) (BQUOTE (FDEVOP (QUOTE OPENP) (\, DEVICE) NIL NIL (\, DEVICE))))))(PUTPROPS \CONVERT-PATHNAME DMACRO (OPENLAMBDA (PATHNAME?) (* ;; "Coerce pathnames to Interlisp strings, for the benefit of antediluvian Interlisp-D file fns") (TYPECASE PATHNAME? (PATHNAME (INTERLISP-NAMESTRING PATHNAME?)) (T PATHNAME?))))(PUTPROPS \DECFILEPTR MACRO ((STREAM X) (\INCFILEPTR STREAM (IMINUS X))))(PUTPROPS \GETFILEPTR MACRO (OPENLAMBDA (STRM) (FDEVOP (QUOTE GETFILEPTR) (fetch DEVICE of STRM) STRM)))(PUTPROPS \SIGNEDWIN MACRO ((STREAM) (SIGNED (\WIN STREAM) BITSPERWORD)))(PUTPROPS \SIGNEDWOUT MACRO ((STREAM N) (\WOUT STREAM (UNSIGNED N BITSPERWORD))))(PUTPROPS \WIN MACRO (OPENLAMBDA (STREAM) (create WORD HIBYTE &larr; (\BIN STREAM) LOBYTE &larr; (\BIN STREAM))))(PUTPROPS \WOUT MACRO (OPENLAMBDA (STREAM W) (\BOUT STREAM (fetch HIBYTE of W)) (\BOUT STREAM (fetch LOBYTE of W))))(PUTPROPS \BINS BYTEMACRO (OPENLAMBDA (STRM BASE OFF NBYTES) (FDEVOP (QUOTE BLOCKIN) (fetch (STREAM DEVICE) of STRM) STRM BASE OFF NBYTES)))(PUTPROPS \BOUTS BYTEMACRO (OPENLAMBDA (STRM BASE OFF NBYTES) (FDEVOP (QUOTE BLOCKOUT) (fetch (STREAM DEVICE) of STRM) STRM BASE OFF NBYTES)))(PUTPROPS \EOFP BYTEMACRO (OPENLAMBDA (STRM) (FDEVOP (QUOTE EOFP) (fetch (STREAM DEVICE) of STRM) STRM)))(RPAQQ BitsPerByte 8)(RPAQ ByteOffsetSize (SELECTQ (SYSTEMTYPE) (VAX 10) 9))(RPAQQ WordsPerPage 256)(CONSTANTS BitsPerByte (ByteOffsetSize (SELECTQ (SYSTEMTYPE) (VAX 10) 9)) WordsPerPage)(RPAQ \MAXFILEPTR (SUB1 (LLSH 1 24)))(CONSTANTS (\MAXFILEPTR (SUB1 (LLSH 1 24))))(ACCESSFNS BYTEPTR ((PAGE (FOLDLO DATUM BYTESPERPAGE)) (OFFSET (MOD DATUM BYTESPERPAGE))) (TYPE? (AND (FIXP DATUM) (IGEQ DATUM 0) (ILEQ DATUM \MAXFILEPTR))) (CREATE (IPLUS (UNFOLD PAGE BYTESPERPAGE) OFFSET)))(PUTPROP (QUOTE FILEIO) (QUOTE IMPORTDATE) (IDATE "10-Oct-86 14:07:18"))(BLOCKRECORD FIXP ((HINUM WORD) (LONUM WORD)) (CREATE (CREATECELL \FIXP)) (TYPE? (EQ (NTYPX DATUM) \FIXP)))(RPAQQ MAX.SMALL.INTEGER 65535)(RPAQQ MAX.POS.HINUM 32767)(CONSTANTS (MAX.SMALL.INTEGER 65535) (MAX.POS.HINUM 32767))(PUTPROPS .UNBOX. MACRO ((V HV LV BIGNUMFORM) (PROG NIL UBLP (SELECTC (NTYPX V) (\FIXP (SETQ HV (ffetch (FIXP HINUM) of V)) (SETQ LV (ffetch (FIXP LONUM) of V))) (\SMALLP (COND ((ILEQ 0 V) (SETQ HV 0) (SETQ LV V)) (T (SETQ HV 65535) (SETQ LV (\LOLOC V))))) (\FLOATP (SETQ V (\FIXP.FROM.FLOATP V)) (GO UBLP)) (if (TYPENAMEP V (QUOTE BIGNUM)) then (if (QUOTE BIGNUMFORM) then BIGNUMFORM else (SETQ V (\LISPERROR V "ARG NOT FIXP" T)) (GO UBLP)) else (SETQ V (LISPERROR "NON-NUMERIC ARG" V T)) (GO UBLP))))))(PUTPROPS .NEGATE. MACRO ((HY LY) (COND ((EQ 0 LY) (AND (NEQ HY 0) (SETQ HY (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER HY))))) (T (SETQ HY (IDIFFERENCE MAX.SMALL.INTEGER HY)) (SETQ LY (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER LY)))))))(PUTPROPS .LLSH1. MACRO ((HI LO) (* shift the pair left one, assuming no overflow) (SETQ HI (LLSH HI 1)) (SETQ LO (LLSH (COND ((IGREATERP LO MAX.POS.HINUM) (add HI 1) (LOGAND LO MAX.POS.HINUM)) (T LO)) 1))))(PUTPROPS .LRSH1. MACRO ((HI LO) (SETQ LO (LRSH LO 1)) (COND ((NEQ (LOGAND HI 1) 0) (SETQ LO (IPLUS LO \SIGNBIT)))) (SETQ HI (LRSH HI 1))))(PUTPROPS .BOXIPLUS. MACRO (OPENLAMBDA (X Y) (PROG ((HX (\GETBASE X 0)) (LX (\GETBASE X 1)) HY LY) (.UNBOX. Y HY LY) (SETQ HX (COND ((IGREATERP HX (IDIFFERENCE MAX.SMALL.INTEGER HY)) (IDIFFERENCE HX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER HY)))) (T (IPLUS HX HY)))) (* Add high parts) (\PUTBASE X 1 (COND ((IGREATERP LX (IDIFFERENCE MAX.SMALL.INTEGER LY)) (* Carry into high part.) (SETQ HX (COND ((EQ HX MAX.SMALL.INTEGER) 0) (T (ADD1 HX)))) (IDIFFERENCE LX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER LY)))) (T (IPLUS LX LY)))) (\PUTBASE X 0 HX) (RETURN X))))(PUTPROPS PutUnboxed DMACRO (= . \PUTFIXP))(PUTPROP (QUOTE LLARITH) (QUOTE IMPORTDATE) (IDATE " 6-Oct-86 22:14:04"))(PUTPROPS POLYEVAL DMACRO ((X COEFFS DEGREE) (* ; "execute the POLYEVAL opcode on the value X, the array COEFFS with degree DEGREE") (\FLOATBOX ((OPCODES UBFLOAT3 0) (\FLOATUNBOX X) (fetch (ARRAYP BASE) of COEFFS) DEGREE))))(BLOCKRECORD FLOATP ((SIGNBIT BITS 1) (EXPONENT BITS 8) (HIFRACTION BITS 7) (LOFRACTION BITS 16)) (BLOCKRECORD FLOATP ((HIWORD WORD) (LOWORD WORD))) (BLOCKRECORD FLOATP ((NIL BITS 9) (LONGFRACTION BITS 23))) (BLOCKRECORD FLOATP ((FLOATCONTENTS BITS 32))) (BLOCKRECORD FLOATP ((NIL BITS 1) (HIWORDNOSIGNBIT BITS 15))) (CREATE (\FLOATBOX (\VAG2 (LOGOR (LLSH SIGNBIT (PLUS 7 8)) (LLSH EXPONENT 7) HIFRACTION) LOFRACTION))) LOFRACTION &larr; 0 HIFRACTION &larr; 0 EXPONENT &larr; 0 SIGNBIT &larr; 0 (ACCESSFNS FLOATP ((EXP (LOGAND (LRSH (\HILOC (\FLOATUNBOX DATUM)) 7) 255)) (HIFRAC (LOGAND (\HILOC (\FLOATUNBOX DATUM)) 127)))))(RPAQQ MAX.DIGITS.ACCURACY 9)(CONSTANTS (MAX.DIGITS.ACCURACY 9))(PUTPROPS \CALLER.ARGS MACRO (X (LET ((ARGS (CAR X)) (FORMS (CDR X))) (BQUOTE (PROGN (\SLOWRETURN) (LET ((AL (\MYALINK)) NEXT (\,@ (for VAR in ARGS collect (if (LISTP VAR) then (LIST (CAR VAR) 0) else VAR)))) (DECLARE (\,@ (for VAR in ARGS when (LISTP VAR) collect (BQUOTE (TYPE (\, (SELECTQ (CADR VAR) ((FLOATING FLOATP) (CADR VAR)) (HELP))) (\, (CAR VAR))))))) (SETQ NEXT (fetch (FX NEXTBLOCK) of AL)) (\,@ (for X in (REVERSE ARGS) collect (LET ((FORMS (BQUOTE (\.GETBASE32 \STACKSPACE (SETQ NEXT (IDIFFERENCE NEXT WORDSPERCELL)))))) (if (LISTP X) then (BQUOTE (SETQ (\, (CAR X)) (\FLOATBOX (\, FORMS)))) else (BQUOTE (SETQ (\, X) (\, FORMS))))))) (\MAKEFREEBLOCK NEXT (TIMES (\, (LENGTH ARGS)) WORDSPERCELL)) (replace (FX NEXTBLOCK) of AL with NEXT) (PROGN (\,@ FORMS))))))))(PUTPROP (QUOTE LLFLOAT) (QUOTE IMPORTDATE) (IDATE " 6-Oct-86 21:54:30"))(DEFOPTIMIZER FONTPROP (&amp;REST ARGS) (SELECTQ (AND (EQ (CAADR ARGS) (QUOTE QUOTE)) (CADADR ARGS)) (ASCENT (LIST (QUOTE FONTASCENT) (CAR ARGS))) (DESCENT (LIST (QUOTE FONTDESCENT) (CAR ARGS))) (HEIGHT (LIST (QUOTE FONTHEIGHT) (CAR ARGS))) (QUOTE IGNOREMACRO)))(DATATYPE FONTCLASS ((PRETTYFONT# BYTE) DISPLAYFD PRESSFD INTERPRESSFD OTHERFDS FONTCLASSNAME))(DATATYPE FONTDESCRIPTOR ((FONTDEVICE POINTER) (\SFObsolete1 POINTER) (* WAS CHARACTERBITMAP) (* Bitmap containing the character images, indexed by \SFOffsets) (FONTFAMILY POINTER) (FONTSIZE POINTER) (FONTFACE POINTER) (\SFObsolete2 POINTER) (* Was \SFWidths) (* The advance-width of each character, an array indexed by charcode. Usually the same as the imagewidth, but can differ for accents, kerns kerns. This is what should be used for stringwidth calculations.) (\SFObsolete3 POINTER) (* WAS \SFOffsets) (* Offset of each character into the image bitmap; X value of left edge) (\SFObsolete4 POINTER) (* Was \SFWidthsY) (\SFObsolete5 WORD) (* WAS FIRSTCHAR) (* Charcode of the first character that exists in the font) (\SFObsolete6 WORD) (* WAS LASTCHAR) (* Charcode of the last character that exists in the font) (\SFAscent WORD) (\SFDescent WORD) (\SFHeight WORD) (ROTATION WORD) (FBBOX SIGNEDWORD) (FBBOY SIGNEDWORD) (FBBDX SIGNEDWORD) (FBBDY SIGNEDWORD) (\SFFACECODE BITS 8) (\SFLKerns POINTER) (\SFRWidths POINTER) (FONTDEVICESPEC POINTER) (* Holds the spec by which the font is known to the printing device, if coercion has been done) (OTHERDEVICEFONTPROPS POINTER) (* For individual devices to hang special information) (FONTSCALE POINTER) (FONTAVGCHARWIDTH WORD) (* Set in FONTCREATE, used to fix up the linelength when DSPFONT is called) (FONTIMAGEWIDTHS POINTER) (* This is the image width, as opposed to the advanced width; initial hack for accents, kerning. Fields is referenced by FONTCREATE.) (FONTCHARSETVECTOR POINTER) (* A 256-pointer block, with one pointer per "character set" --each group of 256 character codes. Each pointer is either NIL if there's no info for that charset, or is a CHARSETINFO, containing widths, char bitmap, etc for the characters in that charset.) (FONTEXTRAFIELD2 POINTER)) FONTCHARSETVECTOR &larr; (\CREATEFONTCHARSETVECTOR))(RECORD FONTFACE (WEIGHT SLOPE EXPANSION) (ACCESSFNS ((COLOR (CDDDR DATUM) (RPLACD (CDDR DATUM) NEWVALUE)) (BACKCOLOR (COND ((CDDDR DATUM) (CAR (CDDDR DATUM)))) (PROGN (COND ((NULL (CDDDR DATUM)) (RPLACD (CDDR DATUM) (LIST NIL NIL)))) (RPLACA (CDDDR DATUM) NEWVALUE))) (FORECOLOR (COND ((CDDDR DATUM) (CADR (CDDDR DATUM)))) (PROGN (COND ((NULL (CDDDR DATUM)) (RPLACD (CDDR DATUM) (LIST NIL NIL)))) (RPLACA (CDR (CDDDR DATUM)) NEWVALUE))))) WEIGHT &larr; (QUOTE MEDIUM) SLOPE &larr; (QUOTE REGULAR) EXPANSION &larr; (QUOTE REGULAR) (TYPE? LISTP))(DATATYPE CHARSETINFO (WIDTHS (* The advance-width of each character, an array indexed by charcode. Usually the same as the imagewidth, but can differ for accents, kerns kerns. This is what should be used for stringwidth calculations.) OFFSETS (* Offset of each character into the image bitmap; X value of left edge) IMAGEWIDTHS (* imagewidths is not automagically allocated since it is not always needed) CHARSETBITMAP (* Bitmap containing the character images, indexed by OFFSETS) YWIDTHS (CHARSETASCENT WORD) (* Max ascent for all characters in this CHARSET) (CHARSETDESCENT WORD) (* Max descent for all characters in this CHARSET)) WIDTHS &larr; (\CREATECSINFOELEMENT) OFFSETS &larr; (\CREATECSINFOELEMENT))(/DECLAREDATATYPE (QUOTE FONTCLASS) (QUOTE (BYTE POINTER POINTER POINTER POINTER POINTER)) (QUOTE ((FONTCLASS 0 (BITS . 7)) (FONTCLASS 0 POINTER) (FONTCLASS 2 POINTER) (FONTCLASS 4 POINTER) (FONTCLASS 6 POINTER) (FONTCLASS 8 POINTER))) (QUOTE 10))(/DECLAREDATATYPE (QUOTE FONTDESCRIPTOR) (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER WORD WORD WORD WORD WORD WORD SIGNEDWORD SIGNEDWORD SIGNEDWORD SIGNEDWORD (BITS 8) POINTER POINTER POINTER POINTER POINTER WORD POINTER POINTER POINTER)) (QUOTE ((FONTDESCRIPTOR 0 POINTER) (FONTDESCRIPTOR 2 POINTER) (FONTDESCRIPTOR 4 POINTER) (FONTDESCRIPTOR 6 POINTER) (FONTDESCRIPTOR 8 POINTER) (FONTDESCRIPTOR 10 POINTER) (FONTDESCRIPTOR 12 POINTER) (FONTDESCRIPTOR 14 POINTER) (FONTDESCRIPTOR 16 (BITS . 15)) (FONTDESCRIPTOR 17 (BITS . 15)) (FONTDESCRIPTOR 18 (BITS . 15)) (FONTDESCRIPTOR 19 (BITS . 15)) (FONTDESCRIPTOR 20 (BITS . 15)) (FONTDESCRIPTOR 21 (BITS . 15)) (FONTDESCRIPTOR 22 (SIGNEDBITS . 15)) (FONTDESCRIPTOR 23 (SIGNEDBITS . 15)) (FONTDESCRIPTOR 24 (SIGNEDBITS . 15)) (FONTDESCRIPTOR 25 (SIGNEDBITS . 15)) (FONTDESCRIPTOR 14 (BITS . 7)) (FONTDESCRIPTOR 26 POINTER) (FONTDESCRIPTOR 28 POINTER) (FONTDESCRIPTOR 30 POINTER) (FONTDESCRIPTOR 32 POINTER) (FONTDESCRIPTOR 34 POINTER) (FONTDESCRIPTOR 36 (BITS . 15)) (FONTDESCRIPTOR 38 POINTER) (FONTDESCRIPTOR 40 POINTER) (FONTDESCRIPTOR 42 POINTER))) (QUOTE 44))(/DECLAREDATATYPE (QUOTE CHARSETINFO) (QUOTE (POINTER POINTER POINTER POINTER POINTER WORD WORD)) (QUOTE ((CHARSETINFO 0 POINTER) (CHARSETINFO 2 POINTER) (CHARSETINFO 4 POINTER) (CHARSETINFO 6 POINTER) (CHARSETINFO 8 POINTER) (CHARSETINFO 10 (BITS . 15)) (CHARSETINFO 11 (BITS . 15)))) (QUOTE 12))(PUTPROPS FONTASCENT MACRO ((FONTSPEC) (ffetch \SFAscent of (\GETFONTDESC FONTSPEC))))(PUTPROPS FONTDESCENT MACRO ((FONTSPEC) (ffetch \SFDescent of (\GETFONTDESC FONTSPEC))))(PUTPROPS FONTHEIGHT MACRO ((FONTSPEC) (ffetch \SFHeight of (\GETFONTDESC FONTSPEC))))(PUTPROPS \FGETOFFSET DMACRO ((OFFSETSBLOCK CHAR8CODE) (\GETBASE OFFSETSBLOCK CHAR8CODE)))(PUTPROPS \FSETOFFSET DMACRO ((OFFSETSBLOCK CHAR8CODE OFFSET) (\PUTBASE OFFSETSBLOCK CHAR8CODE OFFSET)))(PUTPROPS \FGETWIDTH DMACRO ((WIDTHSBLOCK CHAR8CODE) (\GETBASE WIDTHSBLOCK CHAR8CODE)))(PUTPROPS \FSETWIDTH DMACRO ((WIDTHSBLOCK INDEX WIDTH) (\PUTBASE WIDTHSBLOCK INDEX WIDTH)))(PUTPROPS \FGETCHARWIDTH MACRO (OPENLAMBDA (FONTDESC CHARCODE) (\FGETWIDTH (ffetch (CHARSETINFO WIDTHS) of (\GETCHARSETINFO (\CHARSET CHARCODE) FONTDESC)) (\CHAR8CODE CHARCODE))))(PUTPROPS \FGETIMAGEWIDTH MACRO ((IMAGEWIDTHSBLOCK CHAR8CODE) (\GETBASE IMAGEWIDTHSBLOCK CHAR8CODE)))(PUTPROPS \FSETIMAGEWIDTH DMACRO ((WIDTHSBLOCK INDEX WIDTH) (\PUTBASE WIDTHSBLOCK INDEX WIDTH)))(PUTPROPS \GETCHARSETINFO MACRO ((CHARSET FONTDESC NOSLUG?) (* * fetches the charsetinfo for charset CHARSET in fontdescriptor FONTDESC. If NIL, then creates the required charset.) (* * NOSLUG? means don't create an empty (slug) csinfo if the charset is not found, just return NIL) (OR (\GETBASEPTR (ffetch FONTCHARSETVECTOR of FONTDESC) (UNFOLD CHARSET 2)) (\CREATECHARSET CHARSET FONTDESC NOSLUG?))))(PUTPROPS \CREATECSINFOELEMENT MACRO (NIL (\ALLOCBLOCK (FOLDHI (IPLUS \MAXTHINCHAR 3) WORDSPERCELL))))(PUTPROPS \CREATEFONTCHARSETVECTOR MACRO (NIL (* Allocates a block for the character set records) (\ALLOCBLOCK (ADD1 \MAXCHARSET) T)))(RPAQQ \MAXNSCHAR 65535)(CONSTANTS (\MAXNSCHAR 65535))(PUTPROP (QUOTE FONT) (QUOTE IMPORTDATE) (IDATE "24-Sep-86 17:50:01"))(BLOCKRECORD KEYACTION (FLAGS CODES SHIFTCODES ARMED INTERRUPTLIST) FLAGS &larr; (\ALLOCBLOCK (FOLDHI (IPLUS \NKEYS \NKEYS) BYTESPERCELL)) CODES &larr; (\ALLOCBLOCK (FOLDHI (PLUS \NKEYS \NKEYS) WORDSPERCELL)) SHIFTCODES &larr; (\ALLOCBLOCK (FOLDHI (PLUS \NKEYS \NKEYS) WORDSPERCELL)) ARMED &larr; (\ALLOCBLOCK (FOLDHI (ADD1 \MAXTHINCHAR) BITSPERCELL)) (CREATE (\ALLOCBLOCK 5 PTRBLOCK.GCT)) (TYPE? (AND (\BLOCKDATAP DATUM) (EQ (\#BLOCKDATACELLS DATUM) 5) (OR (NULL (FETCH (KEYACTION INTERRUPTLIST) OF DATUM)) (LISTP (FETCH INTERRUPTLIST OF DATUM))) (\BLOCKDATAP (FETCH (KEYACTION FLAGS) DATUM)) (\BLOCKDATAP (FETCH (KEYACTION CODES) DATUM)) (\BLOCKDATAP (FETCH (KEYACTION ARMED) DATUM)))))(RPAQQ \NKEYS 112)(CONSTANTS \NKEYS)(DEFOPTIMIZER KEYDOWNP (KEYNAME) (BQUOTE (\NEWKEYDOWNP (\KEYNAMETONUMBER (\, KEYNAME)))))(PUTPROPS XKEYDOWNP MACRO ((KEYNAME) (KEYDOWNP1 (\KEYNAMETONUMBER KEYNAME))))(PUTPROPS KEYDOWNP1 MACRO (OPENLAMBDA (KEYNUMBER) (DECLARE (GLOBALVARS \EM.KBDAD0 \EM.KBDAD1 \EM.KBDAD2 \EM.KBDAD3 \EM.UTILIN \EM.KBDAD4 \EM.KBDAD5)) (PROG NIL (RETURN (EQ 0 (LOGAND (LRSH (LLSH 1 15) (PROGN (* (IMOD KEYNUMBER BITSPERWORD) - GETD cause IMOD and BITSPERWORD not exported to user) (LOGAND KEYNUMBER 15))) (\GETBASE (SELECTQ (PROGN (* (FOLDLO KEYNUMBER BITSPERWORD) GETD follows since FOLDLO and BITSPERWORD not exported to user) (LRSH KEYNUMBER 4)) (0 \EM.KBDAD0) (1 \EM.KBDAD1) (2 \EM.KBDAD2) (3 \EM.KBDAD3) (4 \EM.UTILIN) (5 (OR \EM.KBDAD4 (RETURN))) (6 (OR \EM.KBDAD5 (RETURN))) (RETURN)) 0)))))))(PUTPROPS \NEWKEYDOWNP MACRO ((KEYNUMBER) (EQ 0 (\GETBASEBIT \LASTKEYSTATE KEYNUMBER))))(GLOBALVARS \KEYBOARD.DEVICE \KEYBOARD.STREAM)(RPAQQ HARDCURSORHEIGHT 16)(RPAQQ HARDCURSORWIDTH 16)(CONSTANTS (HARDCURSORHEIGHT 16) (HARDCURSORWIDTH 16))(ADDTOVAR GLOBALVARS LASTMOUSEX LASTMOUSEY LASTSCREEN LASTMOUSEBUTTONS LASTMOUSETIME LASTKEYBOARD)(PUTPROPS \SETMOUSEXY MACRO ((XPOS YPOS) (PROGN (SELECTC \MACHINETYPE (\DANDELION (do (PROGN (replace (IOPAGE NEWMOUSEX) of \IOPAGE with XPOS) (replace (IOPAGE NEWMOUSEY) of \IOPAGE with YPOS)) repeatuntil (ILESSP (fetch (IOPAGE NEWMOUSESTATE) of \IOPAGE) 32768)) (* smash position until mouse says it is not busy) (replace (IOPAGE NEWMOUSEX) of \IOPAGE with XPOS) (replace (IOPAGE NEWMOUSEY) of \IOPAGE with YPOS) (replace (IOPAGE NEWMOUSESTATE) of \IOPAGE with 32768)) (\DAYBREAK (\DoveMisc.SetMousePosition XPOS YPOS)) NIL) (PROGN (\PUTBASE \EM.MOUSEX 0 XPOS) (\PUTBASE \EM.MOUSEY 0 YPOS)))))(GLOBALVARS \EM.MOUSEX \EM.MOUSEY \EM.CURSORX \EM.CURSORY \EM.UTILIN \EM.REALUTILIN \EM.KBDAD0 \EM.KBDAD1 \EM.KBDAD2 \EM.KBDAD3 \EM.KBDAD4 \EM.KBDAD5 \EM.DISPINTERRUPT \EM.DISPLAYHEAD \EM.CURSORBITMAP \MACHINETYPE \DEFAULTKEYACTION \CURRENTKEYACTION \PERIODIC.INTERRUPT \PERIODIC.INTERRUPT.FREQUENCY)(PUTPROP (QUOTE LLKEY) (QUOTE IMPORTDATE) (IDATE "23-Sep-86 19:12:42"))(DATATYPE PILOTBBT ((PBTDESTLO WORD) (PBTDESTHI WORD) (PBTDESTBIT WORD) (* Destination bit address) (PBTDESTBPL SIGNEDWORD) (* Destination bits per line -- distance in bits to move between items) (PBTSOURCELO WORD) (PBTSOURCEHI WORD) (PBTSOURCEBIT WORD) (* Source bit address) (PBTSOURCEBPL SIGNEDWORD) (* Source bits per line) (PBTWIDTH WORD) (* Width of an item in bits) (PBTHEIGHT WORD) (* Number of items -- height in scanlines) (PBTFLAGS WORD) (NIL 5 WORD) (* Unused, needed to make 16-alignment)) (BLOCKRECORD PILOTBBT ((NIL 7 WORD) (NIL BITS 4) (* Overlay on PBTSOURCEBPL when PBTUSEGRAY) (PBTGRAYOFFSET BITS 4) (* Offset in gray block where BITBLT should start) (PBTGRAYWIDTHLESSONE BITS 4) (* Width-1 of gray block in words) (PBTGRAYHEIGHTLESSONE BITS 4) (* Height-1 of gray block) (NIL 2 WORD) (* Overlay on PBTFLAGS ...) (PBTBACKWARD FLAG) (PBTDISJOINT FLAG) (PBTDISJOINTITEMS FLAG) (PBTUSEGRAY FLAG) (PBTSOURCETYPE BITS 1) (PBTOPERATION BITS 2) (NIL BITS 9))) (ACCESSFNS PILOTBBT ((PBTSOURCE (\VAG2 (fetch PBTSOURCEHI of DATUM) (fetch PBTSOURCELO of DATUM)) (PROGN (replace PBTSOURCEHI of DATUM with (\HILOC NEWVALUE)) (replace PBTSOURCELO of DATUM with (\LOLOC NEWVALUE)))) (PBTDEST (\VAG2 (fetch PBTDESTHI of DATUM) (fetch PBTDESTLO of DATUM)) (PROGN (replace PBTDESTHI of DATUM with (\HILOC NEWVALUE)) (replace PBTDESTLO of DATUM with (\LOLOC NEWVALUE)))))) (SYSTEM))(DATATYPE \DISPLAYDATA (DDXPOSITION DDYPOSITION DDXOFFSET DDYOFFSET DDDestination DDClippingRegion DDFONT DDSlowPrintingCase DDWIDTHSCACHE (* array of the distance to be moved in X when each character is printed.) DDOFFSETSCACHE DDCOLOR DDLINEFEED DDRightMargin DDLeftMargin DDScroll DDOPERATION DDSOURCETYPE (DDClippingLeft WORD) (DDClippingRight WORD) (DDClippingBottom WORD) (DDClippingTop WORD) (DDobsoletefield WORD) (* this used to be the DDtexture field and was left in so that world doesn't have to be recompiled) (DDHELDFLG FLAG) (XWINDOWHINT XPOINTER) (DDPILOTBBT POINTER) DDXSCALE DDYSCALE DDCHARIMAGEWIDTHS (* array of image widths for each character) DDEOLFN DDPAGEFULLFN DDTexture DDMICAXPOS DDMICAYPOS DDMICARIGHTMARGIN DDCHARSET (DDCHARSETASCENT WORD) (DDCHARSETDESCENT WORD) DDCHARHEIGHTDELTA (DDSPACEWIDTH WORD)) DDPILOTBBT &larr; (create PILOTBBT PBTDISJOINT &larr; T) DDLeftMargin &larr; 0 DDRightMargin &larr; SCREENWIDTH DDXPOSITION &larr; 0 DDYPOSITION &larr; 0 DDXOFFSET &larr; 0 DDYOFFSET &larr; 0 DDClippingRegion &larr; (create REGION) DDDestination &larr; ScreenBitMap DDXSCALE &larr; 1 DDYSCALE &larr; 1 DDTexture &larr; 0 (ACCESSFNS ((DDFOREGROUNDCOLOR (OR (CAR (fetch (\DISPLAYDATA DDCOLOR) of DATUM)) (MAXIMUMCOLOR (BITSPERPIXEL (fetch (\DISPLAYDATA DDDestination) of DATUM))))) (DDBACKGROUNDCOLOR (OR (CDR (fetch (\DISPLAYDATA DDCOLOR) of DATUM)) 0)))) (SYSTEM))(RECORD DISPLAYSTATE (ONOFF))(RECORD DISPLAYINFO (DITYPE DIWIDTH DIHEIGHT DIBITSPERPIXEL DIWSOPS))(/DECLAREDATATYPE (QUOTE PILOTBBT) (QUOTE (WORD WORD WORD SIGNEDWORD WORD WORD WORD SIGNEDWORD WORD WORD WORD WORD WORD WORD WORD WORD)) (QUOTE ((PILOTBBT 0 (BITS . 15)) (PILOTBBT 1 (BITS . 15)) (PILOTBBT 2 (BITS . 15)) (PILOTBBT 3 (SIGNEDBITS . 15)) (PILOTBBT 4 (BITS . 15)) (PILOTBBT 5 (BITS . 15)) (PILOTBBT 6 (BITS . 15)) (PILOTBBT 7 (SIGNEDBITS . 15)) (PILOTBBT 8 (BITS . 15)) (PILOTBBT 9 (BITS . 15)) (PILOTBBT 10 (BITS . 15)) (PILOTBBT 11 (BITS . 15)) (PILOTBBT 12 (BITS . 15)) (PILOTBBT 13 (BITS . 15)) (PILOTBBT 14 (BITS . 15)) (PILOTBBT 15 (BITS . 15)))) (QUOTE 16))(/DECLAREDATATYPE (QUOTE \DISPLAYDATA) (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER WORD WORD WORD WORD WORD FLAG XPOINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER WORD WORD POINTER WORD)) (QUOTE ((\DISPLAYDATA 0 POINTER) (\DISPLAYDATA 2 POINTER) (\DISPLAYDATA 4 POINTER) (\DISPLAYDATA 6 POINTER) (\DISPLAYDATA 8 POINTER) (\DISPLAYDATA 10 POINTER) (\DISPLAYDATA 12 POINTER) (\DISPLAYDATA 14 POINTER) (\DISPLAYDATA 16 POINTER) (\DISPLAYDATA 18 POINTER) (\DISPLAYDATA 20 POINTER) (\DISPLAYDATA 22 POINTER) (\DISPLAYDATA 24 POINTER) (\DISPLAYDATA 26 POINTER) (\DISPLAYDATA 28 POINTER) (\DISPLAYDATA 30 POINTER) (\DISPLAYDATA 32 POINTER) (\DISPLAYDATA 34 (BITS . 15)) (\DISPLAYDATA 35 (BITS . 15)) (\DISPLAYDATA 36 (BITS . 15)) (\DISPLAYDATA 37 (BITS . 15)) (\DISPLAYDATA 38 (BITS . 15)) (\DISPLAYDATA 32 (FLAGBITS . 0)) (\DISPLAYDATA 40 XPOINTER) (\DISPLAYDATA 42 POINTER) (\DISPLAYDATA 44 POINTER) (\DISPLAYDATA 46 POINTER) (\DISPLAYDATA 48 POINTER) (\DISPLAYDATA 50 POINTER) (\DISPLAYDATA 52 POINTER) (\DISPLAYDATA 54 POINTER) (\DISPLAYDATA 56 POINTER) (\DISPLAYDATA 58 POINTER) (\DISPLAYDATA 60 POINTER) (\DISPLAYDATA 62 POINTER) (\DISPLAYDATA 39 (BITS . 15)) (\DISPLAYDATA 64 (BITS . 15)) (\DISPLAYDATA 66 POINTER) (\DISPLAYDATA 65 (BITS . 15)))) (QUOTE 68))(PUTPROPS \GETDISPLAYDATA MACRO (ARGS (COND ((CADR ARGS) (SUBPAIR (QUOTE (STRM STRMVAR)) ARGS (QUOTE (\DTEST (fetch (STREAM IMAGEDATA) of (SETQ STRMVAR (\OUTSTREAMARG STRM))) (QUOTE \DISPLAYDATA))))) (T (SUBST (CAR ARGS) (QUOTE STRM) (QUOTE (\DTEST (fetch (STREAM IMAGEDATA) of (\OUTSTREAMARG STRM)) (QUOTE \DISPLAYDATA))))))))(PUTPROPS \BITMASK MACRO ((N) (\WORDELT BITMASKARRAY (LOGAND N 15))))(PUTPROPS \4BITMASK MACRO ((N) (\WORDELT 4BITMASKARRAY (LOGAND N 3))))(PUTPROPS \NOTBITMASK MACRO ((N) (DECLARE (GLOBALVARS NOTBITMASKARRAY)) (\WORDELT NOTBITMASKARRAY (LOGAND N 15))))(PUTPROPS \NOT4BITMASK MACRO ((N) (\WORDELT NOT4BITMASKARRAY (LOGAND N 3))))(GLOBALVARS BITMASKARRAY NOTBITMASKARRAY 4BITMASKARRAY NOT4BITMASKARRAY)(RPAQQ WORDMASK 65535)(CONSTANTS (WORDMASK 65535))(PUTPROPS \DSPGETCHARWIDTH MACRO ((CHARCODE DD) (\FGETWIDTH (ffetch (\DISPLAYDATA DDWIDTHSCACHE) of DD) CHARCODE)))(PUTPROPS \DSPGETCHARIMAGEWIDTH MACRO ((CHARCODE DD) (\FGETIMAGEWIDTH (ffetch (\DISPLAYDATA DDCHARIMAGEWIDTHS) of DD) CHARCODE)))(PUTPROPS \DSPGETCHAROFFSET MACRO ((CHARCODE DD) (\GETBASE (ffetch (\DISPLAYDATA DDOFFSETSCACHE) of DD) CHARCODE)))(PUTPROPS \CONVERTOP MACRO ((OP) (* rrb "14-NOV-80 11:14") (* Only for alto bitblt !!) (SELECTQ OP (replace 0 of NIL with NIL) (PAINT 1) (INVERT 2) (ERASE 3) 0)))(PUTPROPS \SFInvert MACRO ((BitMap y) (* corrects for the fact that alto bitmaps are stored with 0,0 as upper left while lisp bitmaps have 0,0 as lower left. The correction is actually off by one (greater) because a majority of the places that it is called actually need one more than corrected Y value.) (IDIFFERENCE (fetch (BITMAP BITMAPHEIGHT) of BitMap) y)))(PUTPROPS \SFReplicate MACRO (LAMBDA (pattern) (LOGOR pattern (LLSH pattern 8) (SETQ pattern (LLSH pattern 4)) (LLSH pattern 8))))(PUTPROPS \SETPBTFUNCTION MACRO (OPENLAMBDA (BBT SourceType Operation) (PROGN (replace (PILOTBBT PBTOPERATION) of BBT with (SELECTQ Operation (ERASE 1) (PAINT 2) (INVERT 3) 0)) (replace (PILOTBBT PBTSOURCETYPE) of BBT with (COND ((EQ (EQ SourceType (QUOTE INVERT)) (EQ Operation (QUOTE ERASE))) 0) (T 1))))))(PUTPROPS \BITBLT1 MACRO ((bbt) (BitBltSUBR bbt)))(PUTPROP (QUOTE BITBLT) (QUOTE MACRO) (QUOTE (= . BKBITBLT)))(PROGN (PUTPROPS \INSURETOPWDS DMACRO (OPENLAMBDA (DS) (OR (EQ DS \TOPWDS) (COND ((FMEMB (DSPDESTINATION NIL DS) \SCREENBITMAPS) (\TOTOPWDS DS)))))) (PUTPROPS \INSURETOPWDS MACRO ((DS) (* For non-window implementations) (PROGN))))(PUTPROPS .WHILE.TOP.DS. MACRO ((FIRST . REST) (PROG (DISPINTERRUPT SOFTCURSORUP) (* FIRST should be a displaystream and a variable. This macro may also take a soft cursor down, similar to the way .WHILE.CURSOR.DOWN. does, but only if FIRST's destination is the same as the soft cursor's destination. *) (COND (\SOFTCURSORP (SETQ SOFTCURSORUP (AND \SOFTCURSORUPP (EQ (DSPDESTINATION NIL FIRST) \CURSORDESTINATION))) (COND (SOFTCURSORUP (SETQ DISPINTERRUPT (\GETBASE \EM.DISPINTERRUPT 0)) (\PUTBASE \EM.DISPINTERRUPT 0 0) (\SOFTCURSORDOWN))))) (\INSURETOPWDS FIRST) (PROGN . REST) (COND (SOFTCURSORUP (\SOFTCURSORUPCURRENT) (\PUTBASE \EM.DISPINTERRUPT 0 DISPINTERRUPT))))))(PUTPROPS .WHILE.CURSOR.DOWN. MACRO ((FIRST . REST) (PROG (DISPINTERRUPT SOFTCURSORUP) (* This macro should wrap around any code that draws or bitblts directly from or to a screen bitmap. E.g. DRAWGRAYBOX in HLDISPLAY which puts up a shadow box during GETREGION. The purpose of this macro is that a soft (e.g. color) cursor's bits not be taken to be screen bits while FIRST &amp; REST are done. *) (COND (\SOFTCURSORP (SETQ SOFTCURSORUP \SOFTCURSORUPP) (COND (SOFTCURSORUP (SETQ DISPINTERRUPT (\GETBASE \EM.DISPINTERRUPT 0)) (\PUTBASE \EM.DISPINTERRUPT 0 0) (\SOFTCURSORDOWN))))) (PROGN FIRST . REST) (COND (SOFTCURSORUP (\SOFTCURSORUPCURRENT) (\PUTBASE \EM.DISPINTERRUPT 0 DISPINTERRUPT))))))(ADDTOVAR GLOBALVARS \TOPWDS)(DEFOPTIMIZER TTYDISPLAYSTREAM (&amp;REST X) (COND ((NULL (CAR X)) (QUOTE \TERM.OFD)) (T (QUOTE IGNOREMACRO))))(GLOBALVARS BELLCNT BELLRATE TTYBACKGROUNDFNS \DisplayStoppedForLogout \CARET.UP)(PUTPROPS \CHECKCARET MACRO ((X) (AND \CARET.UP (\CARET.DOWN X))))(PUTPROPS \DSPTRANSFORMX MACRO ((X DD) (* transforms an x coordinate into the destination coordinate.) (IPLUS X (fetch (\DISPLAYDATA DDXOFFSET) of DD))))(PUTPROPS \DSPTRANSFORMY MACRO ((Y DD) (* transforms an y coordinate into the destination coordinate.) (IPLUS Y (fetch (\DISPLAYDATA DDYOFFSET) of DD))))(PUTPROPS \OFFSETBOTTOM MACRO ((X) (* gives the destination coordinate address of the origin.) (fetch (\DISPLAYDATA DDYOFFSET) of X)))(PUTPROPS \OFFSETLEFT MACRO ((DD) (* returns the x origin of display data destination coordinates.) (fetch (\DISPLAYDATA DDXOFFSET) of DD)))(PUTPROPS DISPLAYINITIALIZEDP MACRO (NIL (* always initialized now) T))(PUTPROPS DISPLAYSTARTEDP MACRO (NIL \DisplayStarted))(GLOBALVARS \DisplayStarted \DisplayStreamsInitialized \DisplayInitialed WHOLEDISPLAY WHOLESCREEN SCREENWIDTH SCREENHEIGHT)(PUTPROP (QUOTE LLDISPLAY) (QUOTE IMPORTDATE) (IDATE "10-Oct-86 16:38:21"))(RECORD REGION (LEFT BOTTOM WIDTH HEIGHT) LEFT &larr; -16383 BOTTOM &larr; -16383 WIDTH &larr; 32767 HEIGHT &larr; 32767 (ACCESSFNS ((TOP (IPLUS (fetch (REGION BOTTOM) of DATUM) (fetch (REGION HEIGHT) of DATUM) -1)) (PTOP (IPLUS (fetch (REGION BOTTOM) of DATUM) (fetch (REGION HEIGHT) of DATUM))) (RIGHT (IPLUS (fetch (REGION LEFT) of DATUM) (fetch (REGION WIDTH) of DATUM) -1)) (PRIGHT (IPLUS (fetch (REGION LEFT) of DATUM) (fetch (REGION WIDTH) of DATUM))))) (TYPE? (AND (EQLENGTH DATUM 4) (EVERY DATUM (FUNCTION NUMBERP)))) (SYSTEM))(DATATYPE BITMAP ((BITMAPBASE POINTER) (BITMAPRASTERWIDTH WORD) (BITMAPHEIGHT WORD) (BITMAPWIDTH WORD) (BITMAPBITSPERPIXEL WORD)) BITMAPBITSPERPIXEL &larr; 1 (BLOCKRECORD BITMAP ((BitMapHiLoc WORD) (BitMapLoLoc WORD)) (* overlay inital pointer)) (SYSTEM))(BLOCKRECORD BITMAPWORD ((BITS WORD)) (SYSTEM))(RECORD POSITION (XCOORD . YCOORD) (TYPE? (AND (LISTP DATUM) (NUMBERP (CAR DATUM)) (NUMBERP (CDR DATUM)))) (SYSTEM))(DATATYPE CURSOR (CUIMAGE CUMASK CUHOTSPOTX CUHOTSPOTY CUDATA) (ACCESSFNS ((CUBITSPERPIXEL (fetch (BITMAP BITMAPBITSPERPIXEL) of (fetch (CURSOR CUIMAGE) of DATUM))))) (SYSTEM))(RECORD MOUSEEVENT (MOUSEX MOUSEY MOUSEBUTTONS KEYBOARD MOUSETIME) (SYSTEM))(RECORD SCREENREGION (SCREEN . REGION) (SUBRECORD REGION) (TYPE? (AND (LISTP DATUM) (type? SCREEN (CAR DATUM)) (type? REGION (CDR DATUM)))) (SYSTEM))(RECORD SCREENPOSITION (SCREEN . POSITION) (SUBRECORD POSITION) (TYPE? (AND (LISTP DATUM) (type? SCREEN (CAR DATUM)) (type? POSITION (CDR DATUM)))) (SYSTEM))(/DECLAREDATATYPE (QUOTE BITMAP) (QUOTE (POINTER WORD WORD WORD WORD)) (QUOTE ((BITMAP 0 POINTER) (BITMAP 2 (BITS . 15)) (BITMAP 3 (BITS . 15)) (BITMAP 4 (BITS . 15)) (BITMAP 5 (BITS . 15)))) (QUOTE 6))(/DECLAREDATATYPE (QUOTE CURSOR) (QUOTE (POINTER POINTER POINTER POINTER POINTER)) (QUOTE ((CURSOR 0 POINTER) (CURSOR 2 POINTER) (CURSOR 4 POINTER) (CURSOR 6 POINTER) (CURSOR 8 POINTER))) (QUOTE 10))(PUTPROPS CURSORBITMAP MACRO (NIL CursorBitMap))(RPAQQ HARDCURSORHEIGHT 16)(RPAQQ HARDCURSORWIDTH 16)(CONSTANTS (HARDCURSORHEIGHT 16) (HARDCURSORWIDTH 16))(ADDTOVAR GLOBALVARS CursorBitMap)(ARRAYRECORD POLYNOMIAL (A B C D) (CREATE (ARRAY 4 (QUOTE FLOATP))) (SYSTEM))(RECORD SPLINE (#KNOTS SPLINEX SPLINEY SPLINEDX SPLINEDY SPLINEDDX SPLINEDDY SPLINEDDDX SPLINEDDDY))(PUTPROPS HALF MACRO ((X) (LRSH X 1)))(PUTPROPS \FILLCIRCLEBLT MACRO (OPENLAMBDA (CX CY X Y) (* calls bitblt twice to fill in one line of the circle.) (\LINEBLT FCBBT (IDIFFERENCE CX X) (IPLUS CY Y) (IPLUS CX X) DESTINATIONBASE RASTERWIDTH LEFT RIGHT BOTTOM TOP GRAYWIDTH GRAYHEIGHT GRAYBASE NBITS) (\LINEBLT FCBBT (IDIFFERENCE CX X) (IDIFFERENCE CY Y) (IPLUS CX X) DESTINATIONBASE RASTERWIDTH LEFT RIGHT BOTTOM TOP GRAYWIDTH GRAYHEIGHT GRAYBASE NBITS)))(PUTDEF (QUOTE BITMAPS) (QUOTE FILEPKGCOMS) (QUOTE ((COM MACRO (X (VARS . X))))))(PUTDEF (QUOTE CURSORS) (QUOTE FILEPKGCOMS) (QUOTE ((COM MACRO (X (E (MAPC (QUOTE X) (QUOTE PRINTCURSOR))))))))(PUTPROPS BITMAPP DMACRO (OPENLAMBDA (X) (AND (type? BITMAP X) X)))(ADDTOVAR GLOBALVARS SCREENHEIGHT SCREENWIDTH ScreenBitMap)(RPAQQ BLACKSHADE 65535)(RPAQQ WHITESHADE 0)(CONSTANTS (BLACKSHADE 65535) (WHITESHADE 0))(RPAQQ GRAYSHADE 43605)(ADDTOVAR GLOBALVARS GRAYSHADE)(RECORD HLS (HUE LIGHTNESS SATURATION))(RECORD RGB (RED GREEN BLUE))(PUTPROP (QUOTE ADISPLAY) (QUOTE IMPORTDATE) (IDATE " 6-Oct-86 22:45:48"))(ADDTOVAR SYSSPECVARS \INTERRUPTABLE)(PUTPROPS UNINTERRUPTABLY INFO EVAL)(PUTPROPS UNINTERRUPTABLY DMACRO ((X . Y) ((LAMBDA (\INTERRUPTABLE) (PROGN X . Y)) NIL)))(ADDTOVAR PRETTYPRINTMACROS (UNINTERRUPTABLY LAMBDA (FORM) (PROG ((POS (IPLUS 4 (POSITION)))) (PRIN1 "(") (PRIN2 (CAR FORM)) (OR (EQ COMMENTFLG (CAAR (SETQ FORM (CDR FORM)))) (TAB POS 0)) (PRINTDEF FORM POS T T FNSLST) (PRIN1 ")"))))(BLOCKRECORD INTERRUPTSTATE ((NIL BITS 3) (GCDISABLED FLAG) (VMEMFULL FLAG) (STACKOVERFLOW FLAG) (STORAGEFULL FLAG) (WAITINGINTERRUPT FLAG) (NIL BITS 8) (INTCHARCODE WORD)))(PUTPROPS \TAKEINTERRUPT DMACRO ((PREFORM POSTFORM) (DECLARE (GLOBALVARS \PENDINGINTERRUPT)) (COND ((AND \PENDINGINTERRUPT (INTERRUPTABLE~=NILUPTHESTACK)) PREFORM ((LAMBDA (\INTERRUPTABLE) (\CALLINTERRUPTED)) T) POSTFORM))))(PUTPROP (QUOTE AINTERRUPT) (QUOTE IMPORTDATE) (IDATE "28-Feb-86 12:07:34"))(ACCESSFNS PUP ((PUPBASE (LOCF (fetch (ETHERPACKET EPBODY) of DATUM)))) (BLOCKRECORD PUPBASE ((PUPLENGTH WORD) (PUPTCONTROL BYTE) (PUPTYPE BYTE) (PUPID FIXP) (PUPDEST WORD) (PUPDESTSOCKET FIXP) (PUPSOURCE WORD) (PUPSOURCESOCKET FIXP) (PUPDATASTART 266 WORD)) (BLOCKRECORD PUPBASE ((NIL WORD) (TYPEWORD WORD) (PUPIDHI WORD) (PUPIDLO WORD) (PUPDESTNET BYTE) (PUPDESTHOST BYTE) (PUPDESTSOCKETHI WORD) (PUPDESTSOCKETLO WORD) (PUPSOURCENET BYTE) (PUPSOURCEHOST BYTE) (PUPSOURCESOCKETHI WORD) (PUPSOURCESOCKETLO WORD)) (* Temporary extra synonyms) (SYNONYM PUPDESTNET (DESTNET)) (SYNONYM PUPDESTHOST (DESTHOST)) (SYNONYM PUPDESTSOCKETHI (DESTSKTHI)) (SYNONYM PUPDESTSOCKETLO (DESTSKTLO)) (SYNONYM PUPSOURCENET (SOURCENET)) (SYNONYM PUPSOURCEHOST (SOURCEHOST)) (SYNONYM PUPSOURCESOCKETHI (SOURCESKTHI)) (SYNONYM PUPSOURCESOCKETLO (SOURCESKTLO))) (SYNONYM PUPDEST (DEST)) (SYNONYM PUPDESTSOCKET (DESTSKT)) (SYNONYM PUPSOURCE (SOURCE)) (SYNONYM PUPSOURCESOCKET (SOURCESKT)) (ACCESSFNS PUPDATASTART ((PUPCONTENTS (LOCF DATUM))))) (ACCESSFNS PUP ((PUPCHECKSUMBASE (fetch PUPBASE of DATUM)) (PUPCHECKSUMLOC (\ADDBASE (fetch PUPBASE of DATUM) (FOLDLO (SUB1 (fetch PUPLENGTH of DATUM)) BYTESPERWORD)))) (BLOCKRECORD PUPCHECKSUMLOC ((PUPCHECKSUM WORD)))) (TYPE? (type? ETHERPACKET DATUM)))(ACCESSFNS PUPADDRESS ((PUPNET# (LRSH DATUM 8)) (PUPHOST# (LOGAND DATUM 255))) (CREATE (IPLUS (LLSH PUPNET# 8) PUPHOST#)))(PUTPROPS \LOCALPUPADDRESS MACRO (NIL \LOCALPUPNETHOST))(PUTPROPS \LOCALPUPHOSTNUMBER MACRO (NIL (fetch PUPHOST# of \LOCALPUPNETHOST)))(PUTPROPS \LOCALPUPNETNUMBER MACRO (NIL (fetch PUPNET# of \LOCALPUPNETHOST)))(ACCESSFNS ERRORPUP ((ERRORPUPBASE (fetch PUPCONTENTS of DATUM))) (BLOCKRECORD ERRORPUPBASE ((ERRORPUPCOPY 10 WORD) (* Copy of pup header) (ERRORPUPCODE WORD) (ERRORPUPARG WORD) (* Usually zero) (ERRORPUPSTRINGBASE WORD) (* Human readable message))))(RPAQQ PUPERRORCODES ((\PUPE.CHECKSUM 1) (\PUPE.NOSOCKET 2) (\PUPE.SOCKETFULL 3) (\PUPE.GATEWAY.BADPUP 513) (\PUPE.NOROUTE 514) (\PUPE.NOHOST 515) (\PUPE.LOOPED 516) (\PUPE.TOOLARGE 517) (\PUPE.WRONG.GATEWAY 518) (\PUPE.GATEWAYFULL 519)))(RPAQQ \PUPE.CHECKSUM 1)(RPAQQ \PUPE.NOSOCKET 2)(RPAQQ \PUPE.SOCKETFULL 3)(RPAQQ \PUPE.GATEWAY.BADPUP 513)(RPAQQ \PUPE.NOROUTE 514)(RPAQQ \PUPE.NOHOST 515)(RPAQQ \PUPE.LOOPED 516)(RPAQQ \PUPE.TOOLARGE 517)(RPAQQ \PUPE.WRONG.GATEWAY 518)(RPAQQ \PUPE.GATEWAYFULL 519)(CONSTANTS (\PUPE.CHECKSUM 1) (\PUPE.NOSOCKET 2) (\PUPE.SOCKETFULL 3) (\PUPE.GATEWAY.BADPUP 513) (\PUPE.NOROUTE 514) (\PUPE.NOHOST 515) (\PUPE.LOOPED 516) (\PUPE.TOOLARGE 517) (\PUPE.WRONG.GATEWAY 518) (\PUPE.GATEWAYFULL 519))(PUTPROPS BINDPUPS MACRO (X (CONS (LIST (QUOTE LAMBDA) (CAR X) (CONS (QUOTE PROGN) (CDR X))) (in (CAR X) collect (LIST (QUOTE ALLOCATE.PUP))))))(PUTPROPS BINDPUPS INFO BINDS)(ADDTOVAR PRETTYPRINTMACROS (BINDPUPS LAMBDA (FORM) (PROG ((POS (IPLUS 2 (POSITION)))) (PRIN1 "(") (PRIN2 (CAR FORM)) (SPACES 1) (PRINTDEF (CADR FORM) (POSITION)) (OR (EQ COMMENTFLG (CAAR (SETQ FORM (CDDR FORM)))) (TAB POS 0)) (PRINTDEF FORM POS T T FNSLST) (PRIN1 ")"))))(BLOCKRECORD PORT ((NETHOST WORD) (SOCKET FIXP)) (BLOCKRECORD PORT ((NET BYTE) (HOST BYTE) (SOCKETHI WORD) (SOCKETLO WORD))))(ACCESSFNS ERRORPUP ((ERRORPUPBASE (fetch PUPCONTENTS of DATUM))) (BLOCKRECORD ERRORPUPBASE ((ERRORPUPCOPY 10 WORD) (* Copy of pup header) (ERRORPUPCODE WORD) (ERRORPUPARG WORD) (* Usually zero) (ERRORPUPSTRINGBASE WORD) (* Human readable message))))(GLOBALVARS \ETHERWAIT1 \ETHERTIMEOUT \MAXETHERTRIES PUPTRACEFLG LOGINPASSWORDS)(GLOBALVARS PUPTRACEFILE PUPONLYTYPES PUPIGNORETYPES PUPPRINTMACROS)(RPAQQ \PUPOVLEN 22)(RPAQQ \MAX.PUPLENGTH 532)(RPAQQ \TIME.GETPUP 5)(CONSTANTS (\PUPOVLEN 22) (\MAX.PUPLENGTH 532) (\TIME.GETPUP 5))(PUTPROPS PUPPRINTMACROS VARTYPE ALIST)(PUTPROPS \GETPUPWORD DMACRO ((PUP WORD#) (\GETBASE (fetch PUPCONTENTS of PUP) WORD#)))(PUTPROPS \PUTPUPWORD DMACRO ((PUP WORD# VALUE) (\PUTBASE (fetch PUPCONTENTS of PUP) WORD# VALUE)))(PUTPROPS \GETPUPBYTE DMACRO ((PUP BYTE#) (\GETBASEBYTE (fetch PUPCONTENTS of PUP) BYTE#)))(PUTPROPS \PUTPUPBYTE DMACRO ((PUP BYTE# VALUE) (\PUTBASEBYTE (fetch PUPCONTENTS of PUP) BYTE# VALUE)))(RPAQQ RAWPUPTYPES ((\PT.ECHOME 1) (\PT.IAMECHO 2) (\PT.IAMBADECHO 3) (\PT.ERROR 4) (\PT.RFC 8) (\PT.ABORT 9) (\PT.END 10) (\PT.ENDREPLY 11) (\PT.DATA 16) (\PT.ADATA 17) (\PT.ACK 18) (\PT.MARK 19) (\PT.INTERRUPT 20) (\PT.INTERRUPTREPLY 21) (\PT.AMARK 22) (\PT.GATEWAYREQUEST 128) (\PT.GATEWAYRESPONSE 129) (\PT.ALTOTIMEREQUEST 134) (\PT.ALTOTIMERESPONSE 135) (\PT.MSGCHECK 136) (\PT.NEWMAIL 137) (\PT.NONEWMAIL 138) (\PT.NOMAILBOX 139) (\PT.LAURELCHECK 140) (\PT.NAMELOOKUP 144) (\PT.NAMERESPONSE 145) (\PT.NAME/ADDRERROR 146) (\PT.ADDRLOOKUP 147) (\PT.ADDRRESPONSE 148) (\PT.PRINTERSTATUS 128) (\PT.STATUSRESPONSE 129) (\PT.PRINTERCAPABILITY 130) (\PT.CAPABILITYRESPONSE 131) (\PT.PRINTJOBSTATUS 132) (\PT.PRINTJOBRESPONSE 133)))(RPAQQ \PT.ECHOME 1)(RPAQQ \PT.IAMECHO 2)(RPAQQ \PT.IAMBADECHO 3)(RPAQQ \PT.ERROR 4)(RPAQQ \PT.RFC 8)(RPAQQ \PT.ABORT 9)(RPAQQ \PT.END 10)(RPAQQ \PT.ENDREPLY 11)(RPAQQ \PT.DATA 16)(RPAQQ \PT.ADATA 17)(RPAQQ \PT.ACK 18)(RPAQQ \PT.MARK 19)(RPAQQ \PT.INTERRUPT 20)(RPAQQ \PT.INTERRUPTREPLY 21)(RPAQQ \PT.AMARK 22)(RPAQQ \PT.GATEWAYREQUEST 128)(RPAQQ \PT.GATEWAYRESPONSE 129)(RPAQQ \PT.ALTOTIMEREQUEST 134)(RPAQQ \PT.ALTOTIMERESPONSE 135)(RPAQQ \PT.MSGCHECK 136)(RPAQQ \PT.NEWMAIL 137)(RPAQQ \PT.NONEWMAIL 138)(RPAQQ \PT.NOMAILBOX 139)(RPAQQ \PT.LAURELCHECK 140)(RPAQQ \PT.NAMELOOKUP 144)(RPAQQ \PT.NAMERESPONSE 145)(RPAQQ \PT.NAME/ADDRERROR 146)(RPAQQ \PT.ADDRLOOKUP 147)(RPAQQ \PT.ADDRRESPONSE 148)(RPAQQ \PT.PRINTERSTATUS 128)(RPAQQ \PT.STATUSRESPONSE 129)(RPAQQ \PT.PRINTERCAPABILITY 130)(RPAQQ \PT.CAPABILITYRESPONSE 131)(RPAQQ \PT.PRINTJOBSTATUS 132)(RPAQQ \PT.PRINTJOBRESPONSE 133)(CONSTANTS (\PT.ECHOME 1) (\PT.IAMECHO 2) (\PT.IAMBADECHO 3) (\PT.ERROR 4) (\PT.RFC 8) (\PT.ABORT 9) (\PT.END 10) (\PT.ENDREPLY 11) (\PT.DATA 16) (\PT.ADATA 17) (\PT.ACK 18) (\PT.MARK 19) (\PT.INTERRUPT 20) (\PT.INTERRUPTREPLY 21) (\PT.AMARK 22) (\PT.GATEWAYREQUEST 128) (\PT.GATEWAYRESPONSE 129) (\PT.ALTOTIMEREQUEST 134) (\PT.ALTOTIMERESPONSE 135) (\PT.MSGCHECK 136) (\PT.NEWMAIL 137) (\PT.NONEWMAIL 138) (\PT.NOMAILBOX 139) (\PT.LAURELCHECK 140) (\PT.NAMELOOKUP 144) (\PT.NAMERESPONSE 145) (\PT.NAME/ADDRERROR 146) (\PT.ADDRLOOKUP 147) (\PT.ADDRRESPONSE 148) (\PT.PRINTERSTATUS 128) (\PT.STATUSRESPONSE 129) (\PT.PRINTERCAPABILITY 130) (\PT.CAPABILITYRESPONSE 131) (\PT.PRINTJOBSTATUS 132) (\PT.PRINTJOBRESPONSE 133))(RPAQ? PUPTYPES RAWPUPTYPES)(RPAQQ WELLKNOWNPUPSOCKETS ((\PUPSOCKET.TELNET 1) (\PUPSOCKET.ROUTING 2) (\PUPSOCKET.FTP 3) (\PUPSOCKET.MISCSERVICES 4) (\PUPSOCKET.ECHO 5) (\PUPSOCKET.EFTP 16) (\PUPSOCKET.PRINTERSTATUS 17) (\PUPSOCKET.LEAF 35)))(RPAQQ \PUPSOCKET.TELNET 1)(RPAQQ \PUPSOCKET.ROUTING 2)(RPAQQ \PUPSOCKET.FTP 3)(RPAQQ \PUPSOCKET.MISCSERVICES 4)(RPAQQ \PUPSOCKET.ECHO 5)(RPAQQ \PUPSOCKET.EFTP 16)(RPAQQ \PUPSOCKET.PRINTERSTATUS 17)(RPAQQ \PUPSOCKET.LEAF 35)(CONSTANTS (\PUPSOCKET.TELNET 1) (\PUPSOCKET.ROUTING 2) (\PUPSOCKET.FTP 3) (\PUPSOCKET.MISCSERVICES 4) (\PUPSOCKET.ECHO 5) (\PUPSOCKET.EFTP 16) (\PUPSOCKET.PRINTERSTATUS 17) (\PUPSOCKET.LEAF 35))(PUTPROP (QUOTE PUP) (QUOTE IMPORTDATE) (IDATE " 6-Oct-86 14:33:36"))(PUTPROPS UNLESSRDSYS MACRO ((NORMAL RDSYS) NORMAL))(PUTPROPS 1ST MACRO ((A . B) A))(PUTPROPS 2ND MACRO ((A B . C) B))(PUTPROPS LOCAL MACRO ((X) X))(PUTPROPS ALLOCAL MACRO ((X) X))(PUTPROPS ADDBASE DMACRO (= . \ADDBASE))(PUTPROPS GETBASE DMACRO (= . \GETBASE))(PUTPROPS GETBASEBYTE DMACRO (= . \GETBASEBYTE))(PUTPROPS GETBASEPTR DMACRO (= . \GETBASEPTR))(PUTPROPS HILOC DMACRO (= . \HILOC))(PUTPROPS LOLOC DMACRO (= . \LOLOC))(PUTPROPS PUTBASE DMACRO (= . \PUTBASE))(PUTPROPS PUTBASEBYTE DMACRO (= . \PUTBASEBYTE))(PUTPROPS PUTBASEPTR DMACRO (= . \PUTBASEPTR))(PUTPROPS REPLACEPTRFIELD DMACRO (= . \RPLPTR))(PUTPROPS VAG2 DMACRO (= . \VAG2))(PUTPROPS PAGEBASE MACRO ((PTR) (fetch (POINTER PAGEBASE) of PTR)))(PUTPROPS PAGELOC MACRO (OPENLAMBDA (PTR) (IPLUS (LLSH (\HILOC PTR) 8) (LRSH (\LOLOC PTR) 8))))(PUTPROP (QUOTE RENAMEMACROS) (QUOTE IMPORTDATE) (IDATE " 5-Jan-85 21:42:58"))(PUTPROPS MOUSESTATE MACRO (ARGS (LIST (QUOTE PROGN) (QUOTE (GETMOUSESTATE)) (MOUSESTATE-EXPR (CAR ARGS) T))))(PUTPROPS LASTMOUSESTATE MACRO (ARGS (MOUSESTATE-EXPR (CAR ARGS) T)))(PUTPROPS UNTILMOUSESTATE MACRO (ARGS (COND ((AND (CDR ARGS) (CADR ARGS) (NEQ (CADR ARGS) T)) (* time argument is given and is not T or NIL; compile in time keeping loop.) (LIST (QUOTE PROG) (LIST (LIST (QUOTE TIMEOUT) (LIST (QUOTE IPLUS) (QUOTE (CLOCK 0)) (LIST (QUOTE OR) (LIST (QUOTE NUMBERP) (CADR ARGS)) 100))) (QUOTE (NOWTIME (CLOCK 0)))) (QUOTE LP) (LIST (QUOTE COND) (LIST (CONS (QUOTE MOUSESTATE) (LIST (CAR ARGS) T)) (QUOTE (RETURN T)))) (QUOTE (COND ((IGREATERP (CLOCK0 NOWTIME) TIMEOUT) (RETURN NIL)) (T (\BACKGROUND)))) (QUOTE (GO LP)))) (T (LIST (QUOTE PROG) NIL (QUOTE LP) (LIST (QUOTE COND) (LIST (CONS (QUOTE MOUSESTATE) (LIST (CAR ARGS) T)) (QUOTE (RETURN T)))) (QUOTE (\BACKGROUND)) (QUOTE (GO LP)))))))(PUTPROPS KEYSETSTATE MACRO (ARGS (LIST (QUOTE PROGN) (QUOTE (GETMOUSESTATE)) (MOUSESTATE-EXPR (CAR ARGS)))))(PUTPROPS LASTKEYSETSTATE MACRO (ARGS (MOUSESTATE-EXPR (CAR ARGS))))(PUTPROPS WITHIN MACRO ((A B C) (AND (IGEQ A B) (ILESSP A (IPLUS B C)))))(ADDTOVAR GLOBALVARS LASTMOUSEX LASTMOUSEY LASTMOUSEBUTTONS)(PUTPROPS IABS MACRO (OPENLAMBDA (A) (COND ((IGEQ A 0) A) (T (IMINUS A)))))(PUTPROP (QUOTE HLDISPLAY) (QUOTE IMPORTDATE) (IDATE "19-Sep-86 17:08:15"))(PUTPROP (QUOTE MENU) (QUOTE IMPORTDATE) (IDATE " 7-Oct-86 12:52:30"))(PUTPROPS .COPYKEYDOWNP. MACRO (NIL (OR (KEYDOWNP (QUOTE LSHIFT)) (KEYDOWNP (QUOTE RSHIFT)) (KEYDOWNP (QUOTE COPY)))))(PUTPROPS WSOP MACRO (ARGS (LET ((METHOD (CADR (CAR ARGS))) (DISPLAY (CADR ARGS)) (OTHERARGS (CDDR ARGS))) (BQUOTE (SPREADAPPLY* (fetch (WSOPS (\, METHOD)) of (fetch (FDEV WINDOWOPS) of (\, DISPLAY))) (\, DISPLAY) (\,@ OTHERARGS))))))(PUTPROPS \COERCETODS MACRO (OPENLAMBDA (X) (COND ((type? WINDOW X) (fetch (WINDOW DSP) of X)) (T (\ILLEGAL.ARG X)))))(PUTPROPS .WHILE.ON.TOP. MACRO ((FIRST . REST) (UNINTERRUPTABLY (\INTERNALTOTOPW FIRST) . REST)))(RPAQQ MinWindowWidth 26)(RPAQQ MinWindowHeight 16)(CONSTANTS (MinWindowWidth 26) (MinWindowHeight 16))(DATATYPE WINDOW (DSP NEXTW SAVE REG BUTTONEVENTFN RIGHTBUTTONFN CURSORINFN CURSOROUTFN CURSORMOVEDFN REPAINTFN RESHAPEFN EXTENT USERDATA VERTSCROLLREG HORIZSCROLLREG SCROLLFN VERTSCROLLWINDOW HORIZSCROLLWINDOW CLOSEFN MOVEFN WTITLE NEWREGIONFN WBORDER PROCESS WINDOWENTRYFN SCREEN) BUTTONEVENTFN &larr; (FUNCTION TOTOPW) WBORDER &larr; WBorder WINDOWENTRYFN &larr; (FUNCTION GIVE.TTY.PROCESS) (SYSTEM))(DATATYPE SCREEN (SCONOFF SCDESTINATION SCWIDTH SCHEIGHT SCTOPW SCTOPWDS SCTITLEDS SCFDEV SCDS SCDATA) SCONOFF &larr; (QUOTE OFF) (ACCESSFNS ((SCBITSPERPIXEL (fetch (BITMAP BITMAPBITSPERPIXEL) of (fetch (SCREEN SCDESTINATION) of DATUM))) (SCREGION (create REGION LEFT &larr; 0 BOTTOM &larr; 0 WIDTH &larr; (fetch (SCREEN SCWIDTH) of DATUM) HEIGHT &larr; (fetch (SCREEN SCHEIGHT) of DATUM))))) (SYSTEM))(/DECLAREDATATYPE (QUOTE WINDOW) (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER)) (QUOTE ((WINDOW 0 POINTER) (WINDOW 2 POINTER) (WINDOW 4 POINTER) (WINDOW 6 POINTER) (WINDOW 8 POINTER) (WINDOW 10 POINTER) (WINDOW 12 POINTER) (WINDOW 14 POINTER) (WINDOW 16 POINTER) (WINDOW 18 POINTER) (WINDOW 20 POINTER) (WINDOW 22 POINTER) (WINDOW 24 POINTER) (WINDOW 26 POINTER) (WINDOW 28 POINTER) (WINDOW 30 POINTER) (WINDOW 32 POINTER) (WINDOW 34 POINTER) (WINDOW 36 POINTER) (WINDOW 38 POINTER) (WINDOW 40 POINTER) (WINDOW 42 POINTER) (WINDOW 44 POINTER) (WINDOW 46 POINTER) (WINDOW 48 POINTER) (WINDOW 50 POINTER))) (QUOTE 52))(/DECLAREDATATYPE (QUOTE SCREEN) (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER)) (QUOTE ((SCREEN 0 POINTER) (SCREEN 2 POINTER) (SCREEN 4 POINTER) (SCREEN 6 POINTER) (SCREEN 8 POINTER) (SCREEN 10 POINTER) (SCREEN 12 POINTER) (SCREEN 14 POINTER) (SCREEN 16 POINTER) (SCREEN 18 POINTER))) (QUOTE 20))(GLOBALVARS WINDOWUSERFORMS ENDOFWINDOWUSERFORMS PROMPTWINDOW)(PUTPROP (QUOTE WINDOW) (QUOTE IMPORTDATE) (IDATE "17-Sep-86 12:28:56"))(PUTPROPS NNLITATOM MACRO (OPENLAMBDA (X) (AND X (LITATOM X))))(PUTPROPS \NULL.OR.FIXP MACRO (OPENLAMBDA (X) (OR (NULL X) (FIXP X))))(PUTPROPS \CHECKTYPE MACRO (X (PROG ((VAR (CAR X)) (PRED (CADR X))) (if (AND (LISTP PRED) (MEMB (CAR PRED) (QUOTE (QUOTE FUNCTION)))) then (SETQ PRED (LIST (CADR PRED) VAR))) (RETURN (SUBPAIR (QUOTE (MSG VAR PRED)) (LIST (CONCAT " is not a suitable value for the variable:  " VAR) VAR PRED) (QUOTE (until PRED do (SETQ VAR (ERROR VAR MSG)))))))))(PUTPROPS CANONICAL.TIMERUNITS MACRO (OPENLAMBDA (X) (* Checks for common abbreviations before calling \CanonicalizeTimerUnits) (SELECTQ X ((TICKS MILLISECONDS SECONDS) (* These are the canonical forms) X) (NIL (QUOTE MILLISECONDS)) (\CanonicalizeTimerUnits X))))(PUTPROPS \MACRO.EVAL DMACRO (Z (PROG ((X (EXPANDMACRO (CAR Z) T))) (if (EQ X (CAR Z)) then (ERROR "No macro property -- \MACRO.EVAL" X) else (RETURN (EVAL X))))))(DEFOPTIMIZER \MACRO.MX (FORM) FORM)(PUTPROP (QUOTE MACROAUX) (QUOTE IMPORTDATE) (IDATE " 6-Oct-86 23:25:56"))(RPAQQ MASK0WORD1'S 32767)(RPAQQ MASK1WORD0'S 32768)(RPAQQ MASKWORD1'S 65535)(RPAQQ MASKHALFWORD1'S 255)(RPAQQ BITSPERHALFWORD 8)(CONSTANTS MASK0WORD1'S MASK1WORD0'S MASKWORD1'S MASKHALFWORD1'S BITSPERHALFWORD)(PUTPROPS EQZEROP MACRO ((X) (EQ 0 X)))(PUTPROPS \MOVETOBOX DMACRO (OPENLAMBDA (N D) (SELECTC (NTYPX N) (\SMALLP (replace (FIXP HINUM) of D with 0) (replace (FIXP LONUM) of D with N)) (\FIXP (replace (FIXP HINUM) of D with (fetch (FIXP HINUM) of N)) (replace (FIXP LONUM) of D with (fetch (FIXP LONUM) of N))) (\ILLEGAL.ARG N))))(PUTPROPS .XUNBOX. MACRO ((X HX LX) (until (SETQ LX (SELECTC (NTYPX X) (\SMALLP (COND ((IGEQ X 0) (SETQ HX 0) X) (T (SETQ HX MASKWORD1'S) (\LOLOC X)))) (\FIXP (SETQ HX (fetch (FIXP HINUM) of X)) (fetch (FIXP LONUM) of X)) NIL)) do (SETQ X (LISPERROR "ILLEGAL ARG" X T)))))(PUTPROPS .XLLSH. MACRO ((HI LO N) (if (IGEQ N BITSPERWORD) then (* Jump 16 bits in a single bound!) (SETQ HI LO) (SETQ LO 0) (SETQ N (IDIFFERENCE N BITSPERWORD))) (if (IGEQ N BITSPERHALFWORD) then (* Jump 8 bits in a single bound!) (SETQ HI (LOGOR (.LOHALFWORDHI. HI) (.HIHALFWORDLO. LO))) (SETQ LO (.LOHALFWORDHI. LO)) (SETQ N (IDIFFERENCE N BITSPERHALFWORD))) (if (IGEQ N 4) then (* Jump 4 bits in a single bound!) (SETQ HI (LOGOR (LRSH LO (CONSTANT (IDIFFERENCE BITSPERWORD 4))) (LLSH (LOGAND HI (CONSTANT (MASK.1'S 0 (IDIFFERENCE BITSPERWORD 4)))) 4))) (SETQ LO (LLSH (LOGAND LO (CONSTANT (MASK.1'S 0 (IDIFFERENCE BITSPERWORD 4)))) 4)) (SETQ N (IDIFFERENCE N 4))) (* MASK0WORD1'S should be same as (SUB1 (LSH 1 (SUB1 BITSPERWORD)))) (FRPTQ N (SETQ HI (LLSH (LOGAND HI MASK0WORD1'S) 1)) (SETQ LO (LLSH (if (IGEQ LO MASK1WORD0'S) then (add HI 1) (LOGAND LO MASK0WORD1'S) else LO) 1)))))(PUTPROPS .XLLSH1. MACRO ((HI LO) (SETQ HI (LLSH (LOGAND HI MASK0WORD1'S) 1)) (SETQ LO (LSH (COND ((IGEQ LO MASK1WORD0'S) (SETQ HI (LOGOR HI 1)) (LOGAND LO MASK0WORD1'S)) (T LO)) 1))))(PUTPROPS .XLRSH. MACRO ((HI LO N) (if (IGEQ N BITSPERWORD) then (* Jump 10 bits in a single bound!) (SETQ LO HI) (SETQ HI 0) (SETQ N (IDIFFERENCE N BITSPERWORD))) (if (IGEQ N BITSPERHALFWORD) then (* Jump 8 bits in a single bound!) (SETQ LO (LOGOR (.HIHALFWORDLO. LO) (.LOHALFWORDHI. HI))) (SETQ HI (.HIHALFWORDLO. HI)) (SETQ N (IDIFFERENCE N BITSPERHALFWORD))) (if (IGEQ N 4) then (* Jump 4 bits in a single bound!) (SETQ LO (LOGOR (LLSH (LOGAND HI (CONSTANT (MASK.1'S 0 4))) (CONSTANT (IDIFFERENCE BITSPERWORD 4))) (LRSH LO 4))) (SETQ HI (LRSH HI 4)) (SETQ N (IDIFFERENCE N 4))) (* MASK1WORD0'S should be same as \SIGNBIT) (FRPTQ N (SETQ LO (if (ODDP HI) then (LOGOR (LRSH LO 1) MASK1WORD0'S) else (LRSH LO 1))) (SETQ HI (LRSH HI 1)))))(PUTPROPS .ADD.2WORD.INTEGERS. MACRO ((HX LX HY LY) (* Ignores carry out of high-order word) (SETQ HX (.SUMSMALLMOD. HX HY)) (SETQ LX (.SUMSMALLMOD. LX LY (SETQ HX (if (EQ HX MAX.SMALL.INTEGER) then 0 else (ADD1 HX)))))))(PUTPROPS .SUB.2WORD.INTEGERS. MACRO ((HX LX HY LY) (* Ignores carry out of high-order word) (SETQ HX (.DIFFERENCESMALLMOD. HX HY)) (SETQ LX (.DIFFERENCESMALLMOD. LX LY (SETQ HX (if (EQ HX 0) then MAX.SMALL.INTEGER else (SUB1 HX)))))))(PUTPROPS .32BITMUL. MACRO ((HR LR X Y) (PROG (HX LX HY LY) (if (ILESSP X Y) then (swap X Y)) (* Y is the lesser of the two now) (.XUNBOX. X HX LX) (.XUNBOX. Y HY LY) LP (if (ODDP LY) then (.ADD.2WORD.INTEGERS. HR LR HX LX)) (if (EQ HY 0) then (SETQ LY (LRSH LY 1)) (if (EQ LY 0) then (RETURN)) else (.LRSH1. HY LY)) (* Trim off highest bits, so that left-shifting doesn't generate FIXPs) (SETQ HX (LOGAND HX MASK0WORD1'S)) (.LLSH1. HX LX) (GO LP))))(PUTPROPS .SUMSMALLMOD. MACRO ((X Y OVERFLOWFORM) ((LAMBDA (\SumSmallModVar) (DECLARE (LOCALVARS \SumSmallModVar)) (IF (ILEQ X \SumSmallModVar) THEN (IPLUS X Y) ELSE OVERFLOWFORM (IDIFFERENCE X (ADD1 \SumSmallModVar)))) (IDIFFERENCE MAX.SMALL.INTEGER Y))))(PUTPROPS .DIFFERENCESMALLMOD. MACRO ((X Y BORROWFORM) (IF (NOT (IGREATERP Y X)) THEN (IDIFFERENCE X Y) ELSE BORROWFORM (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER (IDIFFERENCE Y X))))))(PUTPROP (QUOTE ADDARITH) (QUOTE IMPORTDATE) (IDATE " 7-Oct-86 15:48:52"))(RPAQQ \MAXFILEPAGE 65534)(CONSTANTS \MAXFILEPAGE)(PUTPROP (QUOTE LLFAULT) (QUOTE IMPORTDATE) (IDATE "24-Sep-86 12:53:32"))(PUTPROPS \UPDATETIMERS MACRO (NIL (* * Moves excess time from the processor clock to our software clocks. Needs to be run often, uninterruptably, preferably from the vertical retrace interrupt) (* Get processor clock) (PROG ((EXCESS (\BOXIDIFFERENCE (\RCLK (LOCF (fetch RCLKTEMP0 of \MISCSTATS))) (LOCF (fetch BASECLOCK of \MISCSTATS))))) (RETURN (COND ((OR (IGEQ EXCESS \RCLKSECOND) (ILESSP EXCESS 0)) (* More than one second has elapsed since we updated clocks) (\BOXIPLUS (LOCF (fetch BASECLOCK of \MISCSTATS)) \RCLKSECOND) (* Increment base by one second) (\BOXIPLUS (LOCF (fetch MILLISECONDSCLOCK of \MISCSTATS)) 1000) (* Increment clocks by 1 second) (\BOXIPLUS (LOCF (fetch SECONDSCLOCK of \MISCSTATS)) 1) T))))))(RPAQQ \RTCSECONDS 378)(RPAQQ \RTCMILLISECONDS 380)(RPAQQ \RTCBASE 382)(RPAQQ \OFFSET.SECONDS 0)(RPAQQ \OFFSET.MILLISECONDS 2)(RPAQQ \OFFSET.BASE 4)(RPAQQ \ALTO.RCLKSECOND 1680000)(RPAQQ \ALTO.RCLKMILLISECOND 1680)(RPAQQ \DLION.RCLKMILLISECOND 35)(RPAQQ \DLION.RCLKSECOND 34746)(RPAQQ \DOVE.RCLKMILLISECOND 63)(RPAQQ \DOVE.RCLKSECOND 62500)(CONSTANTS (\RTCSECONDS 378) (\RTCMILLISECONDS 380) (\RTCBASE 382) (\OFFSET.SECONDS 0) (\OFFSET.MILLISECONDS 2) (\OFFSET.BASE 4) (\ALTO.RCLKSECOND 1680000) (\ALTO.RCLKMILLISECOND 1680) (\DLION.RCLKMILLISECOND 35) (\DLION.RCLKSECOND 34746) (\DOVE.RCLKMILLISECOND 63) (\DOVE.RCLKSECOND 62500))(PUTPROPS ALTO.TO.LISP.DATE MACRO ((DATE) (LOGXOR DATE -2147483648)))(PUTPROPS LISP.TO.ALTO.DATE MACRO ((DATE) (LOGXOR DATE -2147483648)))(PUTPROP (QUOTE LLTIMER) (QUOTE IMPORTDATE) (IDATE " 6-Oct-86 21:47:11"))(DATATYPE SYSQUEUE ((NIL BYTE) (SYSQUEUEHEAD POINTER) (NIL BYTE) (SYSQUEUETAIL POINTER)))(BLOCKRECORD QABLEITEM ((NIL BYTE) (QLINK POINTER) (* Link to next thing in queue always in first pointer of datum, independent of what the datum is)) (BLOCKRECORD QABLEITEM ((NIL BYTE) (LINK POINTER) (* Let's also be able to call it a LINK))))(/DECLAREDATATYPE (QUOTE SYSQUEUE) (QUOTE (BYTE POINTER BYTE POINTER)) (QUOTE ((SYSQUEUE 0 (BITS . 7)) (SYSQUEUE 0 POINTER) (SYSQUEUE 2 (BITS . 7)) (SYSQUEUE 2 POINTER))) (QUOTE 4))(PUTPROPS \QUEUEHEAD MACRO ((Q) (fetch (SYSQUEUE SYSQUEUEHEAD) of Q)))(PUTPROPS \DETCONC MACRO (OPENLAMBDA (TQ) (PROG1 (\PEEKTCONC TQ) (if (NULL (CAR (RPLACA TQ (CDAR TQ)))) then (RPLACD TQ)))))(PUTPROPS \ENTCONC MACRO (= . TCONC))(PUTPROPS \PEEKTCONC MACRO (= . CAAR))(DATATYPE ETHERPACKET ((NIL BYTE) (EPLINK POINTER) (* For queue maintenence) (EPFLAGS BYTE) (* optional flags for some applications) (EPUSERFIELD POINTER) (* Arbitrary pointer for applications) (NIL BYTE) (EPPLIST POINTER) (* Extra field for use as an A-list for properties) (EPTRANSMITTING FLAG) (* True while packet is being transmitted and hence cannot be reused) (EPRECEIVING FLAG) (* True when a packet has been seen at the head of the network's input queue at least once) (NIL BITS 6) (EPREQUEUE POINTER) (* Where to requeue this packet after transmission) (NIL BYTE) (EPSOCKET POINTER) (NIL BYTE) (EPNETWORK POINTER) (EPTYPE WORD) (* Type of packet to be encapsulated (PUP or XIP or 10TO3)) (NIL WORD) (EPTIMESTAMP FIXP) (* Gets RCLK value when transmitted/received) (EPREQUEUEFN POINTER) (* FN to perform requeueing) (NIL 4 WORD) (* Space for expansion) (* Note: This next field wants to be quad+2 aligned so that the 10mb packet is quad+3 aligned) (EPENCAPSULATION 8 WORD) (* 10mb encapsulation, or 3mb encapsulation with padding) (EPBODY 289 WORD) (* Body of packet, header up to 16 words plus data up to 546 bytes)))(ACCESSFNS ETHERAUX ((AUXPTR (CDR (ASSOC (QUOTE AUXPTR) (fetch EPPLIST of DATUM))) (\EP.PUT.AUX DATUM (QUOTE AUXPTR) NEWVALUE)) (AUXWORD (OR (CDR (ASSOC (QUOTE AUXWORD) (fetch EPPLIST of DATUM))) 0) (\EP.PUT.AUX DATUM (QUOTE AUXWORD) NEWVALUE)) (AUXBYTE (OR (CDR (ASSOC (QUOTE AUXBYTE) (fetch EPPLIST of DATUM))) 0) (\EP.PUT.AUX DATUM (QUOTE AUXBYTE) NEWVALUE))))(/DECLAREDATATYPE (QUOTE ETHERPACKET) (QUOTE (BYTE POINTER BYTE POINTER BYTE POINTER FLAG FLAG (BITS 6) POINTER BYTE POINTER BYTE POINTER WORD WORD FIXP POINTER WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD WORD)) (QUOTE ((ETHERPACKET 0 (BITS . 7)) (ETHERPACKET 0 POINTER) (ETHERPACKET 2 (BITS . 7)) (ETHERPACKET 2 POINTER) (ETHERPACKET 4 (BITS . 7)) (ETHERPACKET 4 POINTER) (ETHERPACKET 6 (FLAGBITS . 0)) (ETHERPACKET 6 (FLAGBITS . 16)) (ETHERPACKET 6 (BITS . 37)) (ETHERPACKET 6 POINTER) (ETHERPACKET 8 (BITS . 7)) (ETHERPACKET 8 POINTER) (ETHERPACKET 10 (BITS . 7)) (ETHERPACKET 10 POINTER) (ETHERPACKET 12 (BITS . 15)) (ETHERPACKET 13 (BITS . 15)) (ETHERPACKET 14 FIXP) (ETHERPACKET 16 POINTER) (ETHERPACKET 18 (BITS . 15)) (ETHERPACKET 19 (BITS . 15)) (ETHERPACKET 20 (BITS . 15)) (ETHERPACKET 21 (BITS . 15)) (ETHERPACKET 22 (BITS . 15)) (ETHERPACKET 23 (BITS . 15)) (ETHERPACKET 24 (BITS . 15)) (ETHERPACKET 25 (BITS . 15)) (ETHERPACKET 26 (BITS . 15)) (ETHERPACKET 27 (BITS . 15)) (ETHERPACKET 28 (BITS . 15)) (ETHERPACKET 29 (BITS . 15)) (ETHERPACKET 30 (BITS . 15)) (ETHERPACKET 31 (BITS . 15)) (ETHERPACKET 32 (BITS . 15)) (ETHERPACKET 33 (BITS . 15)) (ETHERPACKET 34 (BITS . 15)) (ETHERPACKET 35 (BITS . 15)) (ETHERPACKET 36 (BITS . 15)) (ETHERPACKET 37 (BITS . 15)) (ETHERPACKET 38 (BITS . 15)) (ETHERPACKET 39 (BITS . 15)) (ETHERPACKET 40 (BITS . 15)) (ETHERPACKET 41 (BITS . 15)) (ETHERPACKET 42 (BITS . 15)) (ETHERPACKET 43 (BITS . 15)) (ETHERPACKET 44 (BITS . 15)) (ETHERPACKET 45 (BITS . 15)) (ETHERPACKET 46 (BITS . 15)) (ETHERPACKET 47 (BITS . 15)) (ETHERPACKET 48 (BITS . 15)) (ETHERPACKET 49 (BITS . 15)) (ETHERPACKET 50 (BITS . 15)) (ETHERPACKET 51 (BITS . 15)) (ETHERPACKET 52 (BITS . 15)) (ETHERPACKET 53 (BITS . 15)) (ETHERPACKET 54 (BITS . 15)) (ETHERPACKET 55 (BITS . 15)) (ETHERPACKET 56 (BITS . 15)) (ETHERPACKET 57 (BITS . 15)) (ETHERPACKET 58 (BITS . 15)) (ETHERPACKET 59 (BITS . 15)) (ETHERPACKET 60 (BITS . 15)) (ETHERPACKET 61 (BITS . 15)) (ETHERPACKET 62 (BITS . 15)) (ETHERPACKET 63 (BITS . 15)) (ETHERPACKET 64 (BITS . 15)) (ETHERPACKET 65 (BITS . 15)) (ETHERPACKET 66 (BITS . 15)) (ETHERPACKET 67 (BITS . 15)) (ETHERPACKET 68 (BITS . 15)) (ETHERPACKET 69 (BITS . 15)) (ETHERPACKET 70 (BITS . 15)) (ETHERPACKET 71 (BITS . 15)) (ETHERPACKET 72 (BITS . 15)) (ETHERPACKET 73 (BITS . 15)) (ETHERPACKET 74 (BITS . 15)) (ETHERPACKET 75 (BITS . 15)) (ETHERPACKET 76 (BITS . 15)) (ETHERPACKET 77 (BITS . 15)) (ETHERPACKET 78 (BITS . 15)) (ETHERPACKET 79 (BITS . 15)) (ETHERPACKET 80 (BITS . 15)) (ETHERPACKET 81 (BITS . 15)) (ETHERPACKET 82 (BITS . 15)) (ETHERPACKET 83 (BITS . 15)) (ETHERPACKET 84 (BITS . 15)) (ETHERPACKET 85 (BITS . 15)) (ETHERPACKET 86 (BITS . 15)) (ETHERPACKET 87 (BITS . 15)) (ETHERPACKET 88 (BITS . 15)) (ETHERPACKET 89 (BITS . 15)) (ETHERPACKET 90 (BITS . 15)) (ETHERPACKET 91 (BITS . 15)) (ETHERPACKET 92 (BITS . 15)) (ETHERPACKET 93 (BITS . 15)) (ETHERPACKET 94 (BITS . 15)) (ETHERPACKET 95 (BITS . 15)) (ETHERPACKET 96 (BITS . 15)) (ETHERPACKET 97 (BITS . 15)) (ETHERPACKET 98 (BITS . 15)) (ETHERPACKET 99 (BITS . 15)) (ETHERPACKET 100 (BITS . 15)) (ETHERPACKET 101 (BITS . 15)) (ETHERPACKET 102 (BITS . 15)) (ETHERPACKET 103 (BITS . 15)) (ETHERPACKET 104 (BITS . 15)) (ETHERPACKET 105 (BITS . 15)) (ETHERPACKET 106 (BITS . 15)) (ETHERPACKET 107 (BITS . 15)) (ETHERPACKET 108 (BITS . 15)) (ETHERPACKET 109 (BITS . 15)) (ETHERPACKET 110 (BITS . 15)) (ETHERPACKET 111 (BITS . 15)) (ETHERPACKET 112 (BITS . 15)) (ETHERPACKET 113 (BITS . 15)) (ETHERPACKET 114 (BITS . 15)) (ETHERPACKET 115 (BITS . 15)) (ETHERPACKET 116 (BITS . 15)) (ETHERPACKET 117 (BITS . 15)) (ETHERPACKET 118 (BITS . 15)) (ETHERPACKET 119 (BITS . 15)) (ETHERPACKET 120 (BITS . 15)) (ETHERPACKET 121 (BITS . 15)) (ETHERPACKET 122 (BITS . 15)) (ETHERPACKET 123 (BITS . 15)) (ETHERPACKET 124 (BITS . 15)) (ETHERPACKET 125 (BITS . 15)) (ETHERPACKET 126 (BITS . 15)) (ETHERPACKET 127 (BITS . 15)) (ETHERPACKET 128 (BITS . 15)) (ETHERPACKET 129 (BITS . 15)) (ETHERPACKET 130 (BITS . 15)) (ETHERPACKET 131 (BITS . 15)) (ETHERPACKET 132 (BITS . 15)) (ETHERPACKET 133 (BITS . 15)) (ETHERPACKET 134 (BITS . 15)) (ETHERPACKET 135 (BITS . 15)) (ETHERPACKET 136 (BITS . 15)) (ETHERPACKET 137 (BITS . 15)) (ETHERPACKET 138 (BITS . 15)) (ETHERPACKET 139 (BITS . 15)) (ETHERPACKET 140 (BITS . 15)) (ETHERPACKET 141 (BITS . 15)) (ETHERPACKET 142 (BITS . 15)) (ETHERPACKET 143 (BITS . 15)) (ETHERPACKET 144 (BITS . 15)) (ETHERPACKET 145 (BITS . 15)) (ETHERPACKET 146 (BITS . 15)) (ETHERPACKET 147 (BITS . 15)) (ETHERPACKET 148 (BITS . 15)) (ETHERPACKET 149 (BITS . 15)) (ETHERPACKET 150 (BITS . 15)) (ETHERPACKET 151 (BITS . 15)) (ETHERPACKET 152 (BITS . 15)) (ETHERPACKET 153 (BITS . 15)) (ETHERPACKET 154 (BITS . 15)) (ETHERPACKET 155 (BITS . 15)) (ETHERPACKET 156 (BITS . 15)) (ETHERPACKET 157 (BITS . 15)) (ETHERPACKET 158 (BITS . 15)) (ETHERPACKET 159 (BITS . 15)) (ETHERPACKET 160 (BITS . 15)) (ETHERPACKET 161 (BITS . 15)) (ETHERPACKET 162 (BITS . 15)) (ETHERPACKET 163 (BITS . 15)) (ETHERPACKET 164 (BITS . 15)) (ETHERPACKET 165 (BITS . 15)) (ETHERPACKET 166 (BITS . 15)) (ETHERPACKET 167 (BITS . 15)) (ETHERPACKET 168 (BITS . 15)) (ETHERPACKET 169 (BITS . 15)) (ETHERPACKET 170 (BITS . 15)) (ETHERPACKET 171 (BITS . 15)) (ETHERPACKET 172 (BITS . 15)) (ETHERPACKET 173 (BITS . 15)) (ETHERPACKET 174 (BITS . 15)) (ETHERPACKET 175 (BITS . 15)) (ETHERPACKET 176 (BITS . 15)) (ETHERPACKET 177 (BITS . 15)) (ETHERPACKET 178 (BITS . 15)) (ETHERPACKET 179 (BITS . 15)) (ETHERPACKET 180 (BITS . 15)) (ETHERPACKET 181 (BITS . 15)) (ETHERPACKET 182 (BITS . 15)) (ETHERPACKET 183 (BITS . 15)) (ETHERPACKET 184 (BITS . 15)) (ETHERPACKET 185 (BITS . 15)) (ETHERPACKET 186 (BITS . 15)) (ETHERPACKET 187 (BITS . 15)) (ETHERPACKET 188 (BITS . 15)) (ETHERPACKET 189 (BITS . 15)) (ETHERPACKET 190 (BITS . 15)) (ETHERPACKET 191 (BITS . 15)) (ETHERPACKET 192 (BITS . 15)) (ETHERPACKET 193 (BITS . 15)) (ETHERPACKET 194 (BITS . 15)) (ETHERPACKET 195 (BITS . 15)) (ETHERPACKET 196 (BITS . 15)) (ETHERPACKET 197 (BITS . 15)) (ETHERPACKET 198 (BITS . 15)) (ETHERPACKET 199 (BITS . 15)) (ETHERPACKET 200 (BITS . 15)) (ETHERPACKET 201 (BITS . 15)) (ETHERPACKET 202 (BITS . 15)) (ETHERPACKET 203 (BITS . 15)) (ETHERPACKET 204 (BITS . 15)) (ETHERPACKET 205 (BITS . 15)) (ETHERPACKET 206 (BITS . 15)) (ETHERPACKET 207 (BITS . 15)) (ETHERPACKET 208 (BITS . 15)) (ETHERPACKET 209 (BITS . 15)) (ETHERPACKET 210 (BITS . 15)) (ETHERPACKET 211 (BITS . 15)) (ETHERPACKET 212 (BITS . 15)) (ETHERPACKET 213 (BITS . 15)) (ETHERPACKET 214 (BITS . 15)) (ETHERPACKET 215 (BITS . 15)) (ETHERPACKET 216 (BITS . 15)) (ETHERPACKET 217 (BITS . 15)) (ETHERPACKET 218 (BITS . 15)) (ETHERPACKET 219 (BITS . 15)) (ETHERPACKET 220 (BITS . 15)) (ETHERPACKET 221 (BITS . 15)) (ETHERPACKET 222 (BITS . 15)) (ETHERPACKET 223 (BITS . 15)) (ETHERPACKET 224 (BITS . 15)) (ETHERPACKET 225 (BITS . 15)) (ETHERPACKET 226 (BITS . 15)) (ETHERPACKET 227 (BITS . 15)) (ETHERPACKET 228 (BITS . 15)) (ETHERPACKET 229 (BITS . 15)) (ETHERPACKET 230 (BITS . 15)) (ETHERPACKET 231 (BITS . 15)) (ETHERPACKET 232 (BITS . 15)) (ETHERPACKET 233 (BITS . 15)) (ETHERPACKET 234 (BITS . 15)) (ETHERPACKET 235 (BITS . 15)) (ETHERPACKET 236 (BITS . 15)) (ETHERPACKET 237 (BITS . 15)) (ETHERPACKET 238 (BITS . 15)) (ETHERPACKET 239 (BITS . 15)) (ETHERPACKET 240 (BITS . 15)) (ETHERPACKET 241 (BITS . 15)) (ETHERPACKET 242 (BITS . 15)) (ETHERPACKET 243 (BITS . 15)) (ETHERPACKET 244 (BITS . 15)) (ETHERPACKET 245 (BITS . 15)) (ETHERPACKET 246 (BITS . 15)) (ETHERPACKET 247 (BITS . 15)) (ETHERPACKET 248 (BITS . 15)) (ETHERPACKET 249 (BITS . 15)) (ETHERPACKET 250 (BITS . 15)) (ETHERPACKET 251 (BITS . 15)) (ETHERPACKET 252 (BITS . 15)) (ETHERPACKET 253 (BITS . 15)) (ETHERPACKET 254 (BITS . 15)) (ETHERPACKET 255 (BITS . 15)) (ETHERPACKET 256 (BITS . 15)) (ETHERPACKET 257 (BITS . 15)) (ETHERPACKET 258 (BITS . 15)) (ETHERPACKET 259 (BITS . 15)) (ETHERPACKET 260 (BITS . 15)) (ETHERPACKET 261 (BITS . 15)) (ETHERPACKET 262 (BITS . 15)) (ETHERPACKET 263 (BITS . 15)) (ETHERPACKET 264 (BITS . 15)) (ETHERPACKET 265 (BITS . 15)) (ETHERPACKET 266 (BITS . 15)) (ETHERPACKET 267 (BITS . 15)) (ETHERPACKET 268 (BITS . 15)) (ETHERPACKET 269 (BITS . 15)) (ETHERPACKET 270 (BITS . 15)) (ETHERPACKET 271 (BITS . 15)) (ETHERPACKET 272 (BITS . 15)) (ETHERPACKET 273 (BITS . 15)) (ETHERPACKET 274 (BITS . 15)) (ETHERPACKET 275 (BITS . 15)) (ETHERPACKET 276 (BITS . 15)) (ETHERPACKET 277 (BITS . 15)) (ETHERPACKET 278 (BITS . 15)) (ETHERPACKET 279 (BITS . 15)) (ETHERPACKET 280 (BITS . 15)) (ETHERPACKET 281 (BITS . 15)) (ETHERPACKET 282 (BITS . 15)) (ETHERPACKET 283 (BITS . 15)) (ETHERPACKET 284 (BITS . 15)) (ETHERPACKET 285 (BITS . 15)) (ETHERPACKET 286 (BITS . 15)) (ETHERPACKET 287 (BITS . 15)) (ETHERPACKET 288 (BITS . 15)) (ETHERPACKET 289 (BITS . 15)) (ETHERPACKET 290 (BITS . 15)) (ETHERPACKET 291 (BITS . 15)) (ETHERPACKET 292 (BITS . 15)) (ETHERPACKET 293 (BITS . 15)) (ETHERPACKET 294 (BITS . 15)) (ETHERPACKET 295 (BITS . 15)) (ETHERPACKET 296 (BITS . 15)) (ETHERPACKET 297 (BITS . 15)) (ETHERPACKET 298 (BITS . 15)) (ETHERPACKET 299 (BITS . 15)) (ETHERPACKET 300 (BITS . 15)) (ETHERPACKET 301 (BITS . 15)) (ETHERPACKET 302 (BITS . 15)) (ETHERPACKET 303 (BITS . 15)) (ETHERPACKET 304 (BITS . 15)) (ETHERPACKET 305 (BITS . 15)) (ETHERPACKET 306 (BITS . 15)) (ETHERPACKET 307 (BITS . 15)) (ETHERPACKET 308 (BITS . 15)) (ETHERPACKET 309 (BITS . 15)) (ETHERPACKET 310 (BITS . 15)) (ETHERPACKET 311 (BITS . 15)) (ETHERPACKET 312 (BITS . 15)) (ETHERPACKET 313 (BITS . 15)) (ETHERPACKET 314 (BITS . 15)) (ETHERPACKET 315 (BITS . 15)) (ETHERPACKET 316 (BITS . 15)) (ETHERPACKET 317 (BITS . 15)) (ETHERPACKET 318 (BITS . 15)))) (QUOTE 320))(RPAQQ \EPT.PUP 512)(RPAQQ \EPT.XIP 1536)(RPAQQ \3MBTYPE.XIP 1536)(RPAQQ \10MBTYPE.XIP 1536)(RPAQQ \EPT.10TO3 1537)(RPAQQ \3MBTYPE.10TO3 1537)(RPAQQ \EPT.UNKNOWN 255)(CONSTANTS \EPT.PUP \EPT.XIP \3MBTYPE.XIP \10MBTYPE.XIP \EPT.10TO3 \3MBTYPE.10TO3 \EPT.UNKNOWN)(RPAQQ \NULLCHECKSUM 65535)(CONSTANTS (\NULLCHECKSUM 65535))(DATATYPE NDB ((NETTYPE BYTE) (* 10 or 3 for now) (NDBNEXT POINTER) (* Link to next NDB) (NDBPUPNET# BYTE) (* Pup number of this net. May be different from NS net number, though not in Xerox world) (NDBNSNET# POINTER) (* Can be 32-bits, so might as well leave its box around) (NDBTASK# BYTE) (* Task # of this network) (NDBBROADCASTP POINTER) (* Function that returns true if packet is of broadcast type) (NDBPUPHOST# BYTE) (* My pup address on this net. NS address is global to all nets, so not needed here) (NDBTRANSMITTER POINTER) (* Routine to send a raw packet on this net - args NDB PACKET returns NIL on failure) (NIL BYTE) (NDBENCAPSULATOR POINTER) (* Routine to encapsulate and send a higher-level packet on this net - args NDB PACKET HOST LENGTH TYPE) (NDBCSB POINTER) (* Pointer to CSB for this network) (NDBIQLENGTH BYTE) (NDBIQ POINTER) (* Queue of empty packets for receiver) (NDBTQ POINTER) (* Queue of packets to transmit) (NDBTRANSLATIONS POINTER) (* Cache of translations, 3:10 or 10:3 according to network) (NDBETHERFLUSHER POINTER) (* Turns off this ether. Args NDB) (NDBWATCHER POINTER) (NDBCANHEARSELF POINTER) (* True if receiver can hear packets sent by transmitter) (NDBIPNET# POINTER) (NDBIPHOST# POINTER) (NDBPUPTYPE WORD) (* The packet encapsulation of PUP on this net) (NIL WORD) (NIL POINTER) (* Spares)))(RECORD ROUTING (RTNET# RTHOPCOUNT RTGATEWAY# RTNDB RTTIMER RTRECENT))(/DECLAREDATATYPE (QUOTE NDB) (QUOTE (BYTE POINTER BYTE POINTER BYTE POINTER BYTE POINTER BYTE POINTER POINTER BYTE POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER WORD WORD POINTER)) (QUOTE ((NDB 0 (BITS . 7)) (NDB 0 POINTER) (NDB 2 (BITS . 7)) (NDB 2 POINTER) (NDB 4 (BITS . 7)) (NDB 4 POINTER) (NDB 6 (BITS . 7)) (NDB 6 POINTER) (NDB 8 (BITS . 7)) (NDB 8 POINTER) (NDB 10 POINTER) (NDB 10 (BITS . 7)) (NDB 12 POINTER) (NDB 14 POINTER) (NDB 16 POINTER) (NDB 18 POINTER) (NDB 20 POINTER) (NDB 22 POINTER) (NDB 24 POINTER) (NDB 26 POINTER) (NDB 28 (BITS . 15)) (NDB 29 (BITS . 15)) (NDB 30 POINTER))) (QUOTE 32))(PUTPROPS \SERIALNUMBER MACRO (NIL (fetch (IFPAGE SerialNumber) of \InterfacePage)))(PUTPROPS \DEVICE.INPUT DOPVAL (1 MISC1 1))(PUTPROPS \DEVICE.OUTPUT DOPVAL (2 MISC2 2))(PUTPROPS \D0.STARTIO DOPVAL (1 MISC1 0))(PUTPROP (QUOTE LLETHER) (QUOTE IMPORTDATE) (IDATE " 6-May-86 11:53:18"))(RECORD BRUSH (BRUSHSHAPE BRUSHSIZE BRUSHCOLOR) BRUSHSHAPE &larr; (QUOTE ROUND) BRUSHSIZE &larr; 1)(PUTPROPS IMAGEOP MACRO (ARGS (CONS (QUOTE SPREADAPPLY*) (CONS (COND ((EQ (CAR (LISTP (CAR ARGS))) (QUOTE QUOTE)) (LIST (QUOTE fetch) (LIST (QUOTE IMAGEOPS) (CADAR ARGS)) (QUOTE of) (LIST (QUOTE fetch) (QUOTE (STREAM IMAGEOPS)) (QUOTE of) (CADR ARGS)))) (T (HELP "IMAGEOP - OPNAME not quoted:" ARGS))) (CDDR ARGS)))))(DATATYPE IMAGEOPS (IMAGETYPE IMCLOSEFN IMXPOSITION IMYPOSITION IMFONT IMLEFTMARGIN IMRIGHTMARGIN IMLINEFEED IMDRAWLINE IMDRAWCURVE IMDRAWCIRCLE IMDRAWELLIPSE IMFILLCIRCLE IMBLTSHADE IMBITBLT IMNEWPAGE IMMOVETO IMSCALE IMTERPRI IMTOPMARGIN IMBOTTOMMARGIN IMSPACEFACTOR IMFONTCREATE IMOPERATION IMCOLOR IMSTRINGWIDTH IMCHARWIDTH IMCHARWIDTHY IMBACKCOLOR IMBITMAPSIZE IMCLIPPINGREGION IMRESET IMDRAWPOLYGON IMFILLPOLYGON IMSCALEDBITBLT IMWRITEPIXEL IMCHARSET IMROTATE IMDRAWARC IMTRANSLATE IMSCALE2 IMPUSHSTATE IMPOPSTATE IMDEFAULTSTATE IMDRAWPOINT) IMCLOSEFN &larr; (FUNCTION NILL) IMTERPRI &larr; (FUNCTION (LAMBDA (STREAM) (\OUTCHAR STREAM (CHARCODE EOL)))) IMNEWPAGE &larr; (FUNCTION (LAMBDA (STREAM) (\OUTCHAR STREAM (CHARCODE &uarr;L)))) IMOPERATION &larr; (FUNCTION NILL) IMCOLOR &larr; (FUNCTION NILL) IMCLIPPINGREGION &larr; (FUNCTION NILL) IMRESET &larr; (FUNCTION NILL) IMBACKCOLOR &larr; (FUNCTION NILL) IMSTRINGWIDTH &larr; (FUNCTION (LAMBDA (STREAM STR RDTBL) (STRINGWIDTH STR (DSPFONT NIL STREAM) RDTBL RDTBL))) IMCHARWIDTH &larr; (FUNCTION (LAMBDA (STREAM CHARCODE) (CHARWIDTH CHARCODE (DSPFONT NIL STREAM)))) IMMOVETO &larr; (FUNCTION (LAMBDA (STREAM X Y) (IMAGEOP (QUOTE IMXPOSITION) STREAM STREAM X) (IMAGEOP (QUOTE IMYPOSITION) STREAM STREAM Y))) IMBITMAPSIZE &larr; (FUNCTION (LAMBDA (STREAM BITMAP DIMENSION) (SELECTQ DIMENSION (WIDTH (TIMES (DSPSCALE NIL STREAM) (BITMAPWIDTH BITMAP))) (HEIGHT (TIMES (DSPSCALE NIL STREAM) (BITMAPHEIGHT BITMAP))) (NIL (CONS (TIMES (DSPSCALE NIL STREAM) (BITMAPWIDTH BITMAP)) (TIMES (DSPSCALE NIL STREAM) (BITMAPHEIGHT BITMAP)))) (\ILLEGAL.ARG DIMENSION)))) IMWRITEPIXEL &larr; (FUNCTION NILL) IMCHARSET &larr; (FUNCTION NILL) IMXPOSITION &larr; (FUNCTION NILL) IMYPOSITION &larr; (FUNCTION NILL) IMFONT &larr; (FUNCTION NILL) IMLEFTMARGIN &larr; (FUNCTION NILL) IMRIGHTMARGIN &larr; (FUNCTION NILL) IMLINEFEED &larr; (FUNCTION NILL) IMDRAWLINE &larr; (FUNCTION NILL) IMDRAWCURVE &larr; (FUNCTION NILL) IMDRAWCIRCLE &larr; (FUNCTION NILL) IMDRAWELLIPSE &larr; (FUNCTION NILL) IMFILLCIRCLE &larr; (FUNCTION NILL) IMBLTSHADE &larr; (FUNCTION NILL) IMBITBLT &larr; (FUNCTION NILL) IMSCALE &larr; (FUNCTION NILL) IMTOPMARGIN &larr; (FUNCTION NILL) IMBOTTOMMARGIN &larr; (FUNCTION NILL) IMSPACEFACTOR &larr; (FUNCTION NILL) IMFONTCREATE &larr; (FUNCTION NILL) IMCHARWIDTHY &larr; (FUNCTION NILL) IMDRAWPOLYGON &larr; (FUNCTION \DRAWPOLYGON.GENERIC) IMDRAWPOINT &larr; (FUNCTION \DRAWPOINT.GENERIC) IMFILLPOLYGON &larr; (FUNCTION NILL) IMSCALEDBITBLT &larr; (FUNCTION NILL) IMROTATE &larr; (FUNCTION NILL) IMDRAWARC &larr; (FUNCTION NILL) IMTRANSLATE &larr; (FUNCTION NILL) IMPUSHSTATE &larr; (FUNCTION NILL) IMPOPSTATE &larr; (FUNCTION NILL) IMSCALE2 &larr; (FUNCTION NILL) IMDEFAULTSTATE &larr; (FUNCTION NILL))(/DECLAREDATATYPE (QUOTE IMAGEOPS) (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER)) (QUOTE ((IMAGEOPS 0 POINTER) (IMAGEOPS 2 POINTER) (IMAGEOPS 4 POINTER) (IMAGEOPS 6 POINTER) (IMAGEOPS 8 POINTER) (IMAGEOPS 10 POINTER) (IMAGEOPS 12 POINTER) (IMAGEOPS 14 POINTER) (IMAGEOPS 16 POINTER) (IMAGEOPS 18 POINTER) (IMAGEOPS 20 POINTER) (IMAGEOPS 22 POINTER) (IMAGEOPS 24 POINTER) (IMAGEOPS 26 POINTER) (IMAGEOPS 28 POINTER) (IMAGEOPS 30 POINTER) (IMAGEOPS 32 POINTER) (IMAGEOPS 34 POINTER) (IMAGEOPS 36 POINTER) (IMAGEOPS 38 POINTER) (IMAGEOPS 40 POINTER) (IMAGEOPS 42 POINTER) (IMAGEOPS 44 POINTER) (IMAGEOPS 46 POINTER) (IMAGEOPS 48 POINTER) (IMAGEOPS 50 POINTER) (IMAGEOPS 52 POINTER) (IMAGEOPS 54 POINTER) (IMAGEOPS 56 POINTER) (IMAGEOPS 58 POINTER) (IMAGEOPS 60 POINTER) (IMAGEOPS 62 POINTER) (IMAGEOPS 64 POINTER) (IMAGEOPS 66 POINTER) (IMAGEOPS 68 POINTER) (IMAGEOPS 70 POINTER) (IMAGEOPS 72 POINTER) (IMAGEOPS 74 POINTER) (IMAGEOPS 76 POINTER) (IMAGEOPS 78 POINTER) (IMAGEOPS 80 POINTER) (IMAGEOPS 82 POINTER) (IMAGEOPS 84 POINTER) (IMAGEOPS 86 POINTER) (IMAGEOPS 88 POINTER))) (QUOTE 90))(GLOBALVARS \NOIMAGEOPS)(PUTPROP (QUOTE IMAGEIO) (QUOTE IMPORTDATE) (IDATE "17-Sep-86 15:50:13"))(DATATYPE PROCESS ((PROCFX0 WORD) (* ; "= \STACKHI to make this look like a STACKP") (PROCFX WORD) (* ; "Stack pointer to this context when it is asleep") (PROCSTATUS BYTE) (* ; "Running or waiting") (PROCNAME POINTER) (* ; "Name for convenience in type-in reference") (PROCPRIORITY BYTE) (* ; "Priority level, 0-4.  Not currently used.") (PROCQUEUE POINTER) (* ; "Queue of processes at the same priority") (NIL BYTE) (NEXTPROCHANDLE POINTER) (* ; "Pointer to next one") (PROCTIMERSET FLAG) (* ; "True if PROCWAKEUPTIMER has an interesting value") (PROCBEINGDELETED FLAG) (* ; "True if proc was deleted, but hasn't been removed from \PROCESSES yet") (PROCDELETED FLAG) (PROCSYSTEMP FLAG) (PROCNEVERSTARTED FLAG) (NIL FLAG) (NIL FLAG) (NIL FLAG) (PROCWAKEUPTIMER POINTER) (* ; "a largep recording the time this proc last went to sleep") (PROCTIMERLINK POINTER) (* ; "For linking proc in timer queue") (PROCTIMERBOX POINTER) (* ; "Scratch box to use for PROCWAKEUPTIMER when user does not give one explicitly") (WAKEREASON POINTER) (* ; "Reason process is being run.  From WAKE.PROCESS or timer or event wakeup;  T from simple BLOCK") (PROCEVENTORLOCK POINTER) (* ; "EVENT or MONITOR lock that this proc is waiting for") (PROCFORM POINTER) (* ; "Form to EVAL to start it going") (RESTARTABLE POINTER) (* ; "T = autorestart on error, HARDRESET = restart only on hard reset, NIL = never restart") (PROCWINDOW POINTER) (* ; "Window this process lives in, if any") (PROCFINISHED POINTER) (* ; "True if proc finished.  Value is indication of how: NORMAL, DELETED, ERROR") (PROCRESULT POINTER) (* ; "Value it returned if it finished normally") (PROCFINISHEVENT POINTER) (* ; "Optional EVENT to be notified when proc finishes") (PROCMAILBOX POINTER) (* ; "Message queue") (PROCRESETVARSLST POINTER) (* ; "Binding for RESETVARSLST in this process") (PROCINFOHOOK POINTER) (* ; "Optional user fn that displays info about process") (PROCTYPEAHEAD POINTER) (* ; "Buffer of typeahead destined for this proc") (PROCREMOTEINFO POINTER) (* ; "For Enterprise") (PROCUSERDATA POINTER) (* ; "For PROCESSPROP") (PROCEVENTLINK POINTER) (* ; "Used to maintain EVENT queues") (PROCAFTEREXIT POINTER) (* ; "What to do with this process when coming back from a LOGOUT, etc") (PROCBEFOREEXIT POINTER) (* ; "If DON'T, can't logout") (PROCOWNEDLOCKS POINTER) (* ; "Pointer to first lock I currently own") (PROCEVAPPLYRESULT POINTER) (* ; "For PROCESS.EVAL and PROCESS.APPLY when WAITFORRESULT is true") (PROCTTYENTRYFN POINTER) (* ; "Is applied to a process when it becomes the tty process") (PROCTTYEXITFN POINTER) (* ; "Is applied to a process when it ceases to be the tty process") (PROCHARDRESETINFO POINTER) (* ; "HARDRESET stores info about unwind-protect cleanups here") (PROCRESTARTFORM POINTER) (* ; "use this instead of PROCFORM when restarting") (NIL POINTER) (NIL POINTER) (* ; "For expansion")) PROCTIMERBOX &larr; (CREATECELL \FIXP) PROCFX0 &larr; \STACKHI)(/DECLAREDATATYPE (QUOTE PROCESS) (QUOTE (WORD WORD BYTE POINTER BYTE POINTER BYTE POINTER FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER)) (QUOTE ((PROCESS 0 (BITS . 15)) (PROCESS 1 (BITS . 15)) (PROCESS 2 (BITS . 7)) (PROCESS 2 POINTER) (PROCESS 4 (BITS . 7)) (PROCESS 4 POINTER) (PROCESS 6 (BITS . 7)) (PROCESS 6 POINTER) (PROCESS 8 (FLAGBITS . 0)) (PROCESS 8 (FLAGBITS . 16)) (PROCESS 8 (FLAGBITS . 32)) (PROCESS 8 (FLAGBITS . 48)) (PROCESS 8 (FLAGBITS . 64)) (PROCESS 8 (FLAGBITS . 80)) (PROCESS 8 (FLAGBITS . 96)) (PROCESS 8 (FLAGBITS . 112)) (PROCESS 8 POINTER) (PROCESS 10 POINTER) (PROCESS 12 POINTER) (PROCESS 14 POINTER) (PROCESS 16 POINTER) (PROCESS 18 POINTER) (PROCESS 20 POINTER) (PROCESS 22 POINTER) (PROCESS 24 POINTER) (PROCESS 26 POINTER) (PROCESS 28 POINTER) (PROCESS 30 POINTER) (PROCESS 32 POINTER) (PROCESS 34 POINTER) (PROCESS 36 POINTER) (PROCESS 38 POINTER) (PROCESS 40 POINTER) (PROCESS 42 POINTER) (PROCESS 44 POINTER) (PROCESS 46 POINTER) (PROCESS 48 POINTER) (PROCESS 50 POINTER) (PROCESS 52 POINTER) (PROCESS 54 POINTER) (PROCESS 56 POINTER) (PROCESS 58 POINTER) (PROCESS 60 POINTER) (PROCESS 62 POINTER))) (QUOTE 64))(PUTPROPS THIS.PROCESS MACRO (NIL \RUNNING.PROCESS))(PUTPROPS TTY.PROCESS MACRO (X (COND ((CAR X) (QUOTE IGNOREMACRO)) (T (QUOTE \TTY.PROCESS)))))(PUTPROPS TTY.PROCESSP MACRO (X (COND ((CAR X) (QUOTE IGNOREMACRO)) (T (QUOTE (OR (NULL (THIS.PROCESS)) (EQ (THIS.PROCESS) (TTY.PROCESS))))))))(GLOBALVARS \RUNNING.PROCESS \TTY.PROCESS \PROC.RESTARTME \PROC.RESETME)(PUTPROP (QUOTE PROC) (QUOTE IMPORTDATE) (IDATE " 6-Oct-86 14:24:03"))(PUTPROPS \BACKCHAR MACRO (OPENLAMBDA (STREAM) (* ; "Backs up over an NS character") (\BACKNSCHAR STREAM (UNFOLD (ffetch CHARSET of STREAM) 256))))(PUTPROPS \BACKNSCHAR MACRO ((STREAM SHIFTEDCHARSET COUNTERVAR) (AND (\BACKFILEPTR STREAM) (COND ((COND (SHIFTEDCHARSET (EQ SHIFTEDCHARSET (UNFOLD \NORUNCODE 256))) (T (EQ \NORUNCODE (ffetch CHARSET of STREAM)))) (COND ((\BACKFILEPTR STREAM) (AND (QUOTE COUNTERVAR) (add COUNTERVAR 2)) T) ((QUOTE COUNTERVAR) (add COUNTERVAR 1)))) ((QUOTE COUNTERVAR) (add COUNTERVAR 1))))))(PUTPROPS \CHECKEOLC MACRO (OPENLAMBDA (CH EOLC STREAM PEEKBINFLG COUNTERVAR) (* ;; "Subtracts number of bytes read from COUNTERVAR, which may be NIL.  In fact, should be NIL if PEEKBINFLG is T.") (SELCHARQ CH (CR (SELECTC EOLC (CR.EOLC (CHARCODE EOL)) (CRLF.EOLC (COND (PEEKBINFLG (* ;; "T from PEEKC, compile-time constant.  In this case, must leave the fileptr where it was, except for possibly advancing over character set shifts") (COND ((EQ (CHARCODE LF) (UNINTERRUPTABLY (\NSIN STREAM (UNFOLD (ffetch CHARSET of STREAM) 256)) (* ;; "Read the NS CR.  We know that there aren't any font-shift characters in front of the CR, because they would have already been read by the \NSPEEK that got the CR character.  Since we are going to NS back the CR character, we don't need to update the counter variable") (PROG1 (\PEEKBIN STREAM T) (* ;; "LF must be in next BYTE after NS CR, regardless of coding.  Character-set shifting bytes can't intervene.  Then we back up over the CR that was \NSINed above.") (\BACKNSCHAR STREAM)))) (CHARCODE EOL)) (T (CHARCODE CR)))) ((EQ (CHARCODE LF) (\PEEKBIN STREAM T)) (\BIN STREAM) (AND (QUOTE COUNTERVAR) (SETQ COUNTERVAR (SUB1 COUNTERVAR))) (CHARCODE EOL)) (T (CHARCODE CR)))) (CHARCODE CR))) (LF (COND ((EQ EOLC LF.EOLC) (CHARCODE EOL)) (T (CHARCODE LF)))) CH)))(PUTPROPS \INCHAR MACRO (OPENLAMBDA (STREAM COUNTERVAR) (* ; "returns a 16 bit character code") (\CHECKEOLC (\NSIN STREAM (UNFOLD (ffetch CHARSET of STREAM) 256) NIL COUNTERVAR) (ffetch EOLCONVENTION of STREAM) STREAM NIL COUNTERVAR)))(PUTPROPS \INCCODE MACRO (OPENLAMBDA (STREAM COUNTERVAR) (* ; "returns a 16 bit character code") (\CHECKEOLC (\NSIN STREAM (UNFOLD (ffetch CHARSET of STREAM) 256) NIL COUNTERVAR) (ffetch EOLCONVENTION of STREAM) STREAM NIL COUNTERVAR)))(PUTPROPS \PEEKCCODE MACRO (OPENLAMBDA (STREAM NOERROR) (\CHECKEOLC (\NSPEEK STREAM (UNFOLD (ffetch CHARSET of STREAM) 256) NIL NOERROR) (ffetch EOLCONVENTION of STREAM) STREAM T)))(PUTPROPS \NSIN MACRO ((STREAM SHIFTEDCSET SHIFTEDCSETVAR COUNTERVAR) (* ;;; "returns a 16 bit character code.  SHIFTEDCSET is STREAM's char set left shifted 8, SHIFTEDCSETVAR if non-NIL is the variable to set if char set changes.  COUNTERVAR if non-NIL is decremented by number of bytes read.  Doesn't do EOL conversion -- \INCHAR does that.") (LET ((CHAR (\BIN STREAM)) SCSET) (COND ((EQ CHAR NSCHARSETSHIFT) (* ; "Shifting character sets") (freplace CHARSET of STREAM with (SETQ SCSET (COND ((NEQ NSCHARSETSHIFT (SETQ CHAR (\BIN STREAM))) (AND (QUOTE COUNTERVAR) (SETQ COUNTERVAR (IDIFFERENCE COUNTERVAR 2))) CHAR) ((PROGN (* ; "2 shift-bytes means not run-encoded") (AND (QUOTE COUNTERVAR) (SETQ COUNTERVAR (IDIFFERENCE COUNTERVAR 3))) (EQ 0 (\BIN STREAM))) \NORUNCODE) (T (\NSIN.24BITENCODING.ERROR STREAM))))) (SETQ CHAR (\BIN STREAM)) (SETQ SCSET (COND ((QUOTE SHIFTEDCSETVAR) (* ; "CHARSETVAR=NIL means don't set") (SETQ SHIFTEDCSETVAR (UNFOLD SCSET 256))) (T (UNFOLD SCSET 256))))) (T (SETQ SCSET SHIFTEDCSET))) (COND ((EQ SCSET (UNFOLD \NORUNCODE 256)) (* ; "just read two bytes and combine them to a 16 bit value") (AND (QUOTE COUNTERVAR) (SETQ COUNTERVAR (IDIFFERENCE COUNTERVAR 2))) (LOGOR (UNFOLD CHAR 256) (\BIN STREAM))) (CHAR (AND (QUOTE COUNTERVAR) (SETQ COUNTERVAR (IDIFFERENCE COUNTERVAR 1))) (AND CHAR (LOGOR SCSET CHAR)))))))(PUTPROPS \NSPEEK MACRO ((STREAM SHIFTEDCSET SHIFTEDCSETVAR NOERROR COUNTERVAR) (* ;; "returns a 16 bit character code.  Doesn't do EOL conversion--\INCHAR does that.  May actually read the character-set shift, storing the result in the stream.  COUNTERVAR, if given, is updated to reflect any such bytes that are actually read") (PROG ((CHAR (\PEEKBIN STREAM NOERROR)) SCSET) (COND ((NULL CHAR) (RETURN NIL)) ((EQ CHAR NSCHARSETSHIFT) (* ; "CHARSETVAR=NIL means don't set") (\BIN STREAM) (* ; "Consume the char shift byte") (freplace CHARSET of STREAM with (SETQ SCSET (COND ((NEQ NSCHARSETSHIFT (SETQ CHAR (\BIN STREAM))) (* ; "Note: no eof error check on this \BIN -- an eof in the middle of a charset shift is an error") (AND (QUOTE COUNTERVAR) (SETQ COUNTERVAR (IDIFFERENCE COUNTERVAR 2))) CHAR) ((PROGN (* ; "2 shift-bytes means not run-encoded") (AND (QUOTE COUNTERVAR) (SETQ COUNTERVAR (IDIFFERENCE COUNTERVAR 3))) (EQ 0 (\BIN STREAM))) \NORUNCODE) (T (\NSIN.24BITENCODING.ERROR STREAM))))) (SETQ SCSET (COND ((QUOTE SHIFTEDCSETVAR) (* ; "CHARSETVAR=NIL means don't set") (SETQ SHIFTEDCSETVAR (UNFOLD SCSET 256))) (T (UNFOLD SCSET 256)))) (COND ((NULL (SETQ CHAR (\PEEKBIN STREAM NOERROR))) (RETURN NIL)))) (T (SETQ SCSET SHIFTEDCSET))) (RETURN (COND ((EQ SCSET (UNFOLD \NORUNCODE 256)) (* ;; "just peek two bytes and combine them to a 16 bit value.  Again, is an error if we hit eof in mid-character") (\BIN STREAM) (PROG1 (LOGOR (UNFOLD CHAR 256) (\PEEKBIN STREAM NOERROR)) (\BACKFILEPTR STREAM))) (T (LOGOR SHIFTEDCSET CHAR)))))))(PUTPROP (QUOTE LLREAD) (QUOTE IMPORTDATE) (IDATE "10-Oct-86 22:42:07"))(PUTPROPS EMPASSWORDLOC DMACRO (LAMBDA NIL (* lmm "24-MAR-83 06:46") (fetch (IFPAGE UserPswdAddr) of \InterfacePage)))(PUTPROPS \DECRYPT.PWD.CHAR MACRO ((CHAR) (LOGXOR CHAR 73)))(PUTPROP (QUOTE PASSWORDS) (QUOTE IMPORTDATE) (IDATE "27-Feb-86 14:25:50"))(RPAQQ MICASPERINCH 2540)(CONSTANTS (MICASPERINCH 2540))(PUTPROP (QUOTE INTERPRESS) (QUOTE IMPORTDATE) (IDATE "22-Sep-86 14:04:17"))(RPAQ MICASPERPT (FQUOTIENT 2540 72))(RPAQQ IHALFMICASPERPT 17)(RPAQQ IMICASPERPT 35)(CONSTANTS (MICASPERPT (FQUOTIENT 2540 72)) (IHALFMICASPERPT 17) (IMICASPERPT 35))(PUTPROP (QUOTE HARDCOPY) (QUOTE IMPORTDATE) (IDATE "21-Aug-86 17:18:18"))(BLOCKRECORD ARRAY-HEADER ((* * "Describes common slots of all array headers") (* "First 8 bits are unused") (BASE POINTER) (* "24 bits of pointer. Points at raw storage or, in the indirect case, at another array header") (* "8 bits of flags") (READ-ONLY-P FLAG) (* "Used for headers pointing at symbols pnames") (INDIRECT-P FLAG) (* "Points at an array header rather than a raw storage block") (BIT-P FLAG) (* "Is a bit array") (STRING-P FLAG) (* "Is a string (implies is a vector)") (* "If any of the following flags are set, the array in non-simple") (ADJUSTABLE-P FLAG) (DISPLACED-P FLAG) (FILL-POINTER-P FLAG) (EXTENDABLE-P FLAG) (TYPE-NUMBER BITS 8) (* "8 bits of type + size") (OFFSET WORD) (* "For oned and general arrays") (FILL-POINTER WORD) (* "For oned and general arrays") (TOTAL-SIZE WORD)) (BLOCKRECORD ARRAY-HEADER ((NIL POINTER) (FLAGS BITS 8) (TYPE BITS 4) (SIZE BITS 4))) (ACCESSFNS (SIMPLE-P (EQ 0 (LOGAND (fetch (ARRAY-HEADER FLAGS) of DATUM) 15)))) (SYSTEM))(DATATYPE GENERAL-ARRAY ((NIL BITS 8) (* "For alignment") (STORAGE POINTER) (* "24 bits of pointer") (READ-ONLY-P FLAG) (* "8 bits of flags") (INDIRECT-P FLAG) (BIT-P FLAG) (STRING-P FLAG) (ADJUSTABLE-P FLAG) (DISPLACED-P FLAG) (FILL-POINTER-P FLAG) (EXTENDABLE-P FLAG) (TYPE-NUMBER BITS 8) (* "8 bits of typenumber") (OFFSET WORD) (FILL-POINTER WORD) (TOTAL-SIZE WORD) (DIMS POINTER)))(DATATYPE ONED-ARRAY ((NIL BITS 8) (* "Don't use high 8 bits") (BASE POINTER) (* "The raw storage base") (READ-ONLY-P FLAG) (* "8 bits worth of flags") (NIL BITS 1) (* "Oned array's cann't be indirect") (BIT-P FLAG) (STRING-P FLAG) (NIL BITS 1) (* "Oned-array's cann't be adjustable") (DISPLACED-P FLAG) (FILL-POINTER-P FLAG) (EXTENDABLE-P FLAG) (TYPE-NUMBER BITS 8) (* "4 bits of type and 4 bits of size") (OFFSET WORD) (* "For displaced arrays") (FILL-POINTER WORD) (* "For filled arrays") (TOTAL-SIZE WORD) (* "Total number of elements")))(DATATYPE TWOD-ARRAY ((NIL BITS 8) (* "For alignmnet") (BASE POINTER) (* "Raw storage pointer") (READ-ONLY-P FLAG) (* "8 bits of flags") (NIL BITS 1) (* "Twod arrays cann't be indirect") (BIT-P FLAG) (NIL BITS 4) (* "Twod arrays cann't be strings, nor can they be adjustable, displaced, or have fill pointers") (EXTENDABLE-P FLAG) (TYPE-NUMBER BITS 8) (BOUND0 WORD) (* "Zero dimension bound") (BOUND1 WORD) (* "One dimension bound") (TOTAL-SIZE WORD)))(/DECLAREDATATYPE (QUOTE GENERAL-ARRAY) (QUOTE ((BITS 8) POINTER FLAG FLAG FLAG FLAG FLAG FLAG FLAG FLAG (BITS 8) WORD WORD WORD POINTER)) (QUOTE ((GENERAL-ARRAY 0 (BITS . 7)) (GENERAL-ARRAY 0 POINTER) (GENERAL-ARRAY 2 (FLAGBITS . 0)) (GENERAL-ARRAY 2 (FLAGBITS . 16)) (GENERAL-ARRAY 2 (FLAGBITS . 32)) (GENERAL-ARRAY 2 (FLAGBITS . 48)) (GENERAL-ARRAY 2 (FLAGBITS . 64)) (GENERAL-ARRAY 2 (FLAGBITS . 80)) (GENERAL-ARRAY 2 (FLAGBITS . 96)) (GENERAL-ARRAY 2 (FLAGBITS . 112)) (GENERAL-ARRAY 2 (BITS . 135)) (GENERAL-ARRAY 3 (BITS . 15)) (GENERAL-ARRAY 4 (BITS . 15)) (GENERAL-ARRAY 5 (BITS . 15)) (GENERAL-ARRAY 6 POINTER))) (QUOTE 8))(/DECLAREDATATYPE (QUOTE ONED-ARRAY) (QUOTE ((BITS 8) POINTER FLAG (BITS 1) FLAG FLAG (BITS 1) FLAG FLAG FLAG (BITS 8) WORD WORD WORD)) (QUOTE ((ONED-ARRAY 0 (BITS . 7)) (ONED-ARRAY 0 POINTER) (ONED-ARRAY 2 (FLAGBITS . 0)) (ONED-ARRAY 2 (BITS . 16)) (ONED-ARRAY 2 (FLAGBITS . 32)) (ONED-ARRAY 2 (FLAGBITS . 48)) (ONED-ARRAY 2 (BITS . 64)) (ONED-ARRAY 2 (FLAGBITS . 80)) (ONED-ARRAY 2 (FLAGBITS . 96)) (ONED-ARRAY 2 (FLAGBITS . 112)) (ONED-ARRAY 2 (BITS . 135)) (ONED-ARRAY 3 (BITS . 15)) (ONED-ARRAY 4 (BITS . 15)) (ONED-ARRAY 5 (BITS . 15)))) (QUOTE 6))(/DECLAREDATATYPE (QUOTE TWOD-ARRAY) (QUOTE ((BITS 8) POINTER FLAG (BITS 1) FLAG (BITS 4) FLAG (BITS 8) WORD WORD WORD)) (QUOTE ((TWOD-ARRAY 0 (BITS . 7)) (TWOD-ARRAY 0 POINTER) (TWOD-ARRAY 2 (FLAGBITS . 0)) (TWOD-ARRAY 2 (BITS . 16)) (TWOD-ARRAY 2 (FLAGBITS . 32)) (TWOD-ARRAY 2 (BITS . 51)) (TWOD-ARRAY 2 (FLAGBITS . 112)) (TWOD-ARRAY 2 (BITS . 135)) (TWOD-ARRAY 3 (BITS . 15)) (TWOD-ARRAY 4 (BITS . 15)) (TWOD-ARRAY 5 (BITS . 15)))) (QUOTE 6))(PUTPROP (QUOTE CMLARRAY) (QUOTE IMPORTDATE) (IDATE " 9-Oct-86 13:11:52"))(DEFCONSTANT MAX.SMALLFIXP (1- (EXPT 2 15)))(DEFCONSTANT MIN.SMALLFIXP (- (EXPT 2 15)))(DEFCONSTANT %%CHAR-TYPE (%%LIT-TYPE-TO-TYPE (QUOTE STRING-CHAR)))(DEFCONSTANT %%BIT-TYPE (%%TYPE-SIZE-TO-TYPENUMBER (QUOTE UNSIGNED-BYTE) (QUOTE 1BIT)))(DEFCONSTANT %%THIN-CHAR-TYPENUMBER (%%TYPE-SIZE-TO-TYPENUMBER (QUOTE STRING-CHAR) (QUOTE 8BIT)))(DEFCONSTANT %%FAT-CHAR-TYPENUMBER (%%TYPE-SIZE-TO-TYPENUMBER (QUOTE STRING-CHAR) (QUOTE 16BIT)))(DEFCONSTANT %%MAXTHINCHAR (1- (EXPT 2 8)))(DEFCONSTANT %%GENERAL-ARRAY 16 "General-array-type-number")(DEFCONSTANT %%ONED-ARRAY 14 "ONED-ARRAY type number")(DEFCONSTANT %%TWOD-ARRAY 15 "TWOD-ARRAY type number")(PUTPROP (QUOTE CMLARRAY-SUPPORT) (QUOTE IMPORTDATE) (IDATE "21-Sep-86 19:45:01"))STOP</pre>
  </body>
</html>
