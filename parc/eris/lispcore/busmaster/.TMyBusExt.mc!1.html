<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>busmaster>TMyBusExt.mc!1</title>
  </head>
  <body>
    <pre>
{File name &lt;tajo&gt;TMyBusExt.mcDescription: DandeLion Interlisp Emulator Bus ExtensionAuthor: PurcellCreated: 31-May-84 16:45:34}{	purcell  3-Jun-85 23:03:10 add long delays in bus}{	by don 24-Mar-85 11:40:24	deleted spurious output at tail of input/writes	added extra arg for BusCtl command	added u for mBusAddrM {fZ = 3}	added u for orig alpha	changed stack reads to STK	saved L {instead of PV}	fixed page fault exits	fixed normal exits	reallocated u regs	changed loading of rhTT from uVirtH}{INPUT:	TOSH &larr; smallpl, DISP4[MiscIn],	c1, at[0D,10, MiscDisp];}{(\PCBLT (alpha op) VIRTUALADDR PCADDRH PCADDRL COUNT)L3Disp values initialized to alpha byte1,2 bit data size: 0=word, 1=byte, 2=reversed bytes, 3=nibble4 bit	0=output, 1=input8 bit	extra states0	read/output word1,9	read/output bytes2,A	read/output bytes reversed3,7,B,F read/output nibbles4	input/write word5,D	input/write bytes6,E	input/write bytes reversed}{L}		RegDef[rAddr, R, 3]; {pc bus address low 16 bits}{TOSH}	RegDef[rDataIn, R, 1]; {TT}	RegDef[rDataOut, R, 2]; {rDataOut not needed during cross so alias with and use TT}{Rx	realTOS	word count remaining (end input/write at 0; end read/output at -1)(fetch from virt+TOS-1)Q	used by mapping routine}RegDef[uPPsave, U, 0CE];{unused u reg}RegDef[uxx3, U, 43];{fZ=3}RegDef[uAlpha, U, 4B];{any temp}RegDef[uVirtL, U, 27];{TT}RegDef[uVirtH, U, 4A];{any temp}RegDef[uBusCtl, U, 52];{fZ=2}RegDef[uAddr, U, 33];{rAddr}{fZ=3}RegDef[uDataOut, U, 42];{fZ=2}{RegDef[UrL,	U,	3B];	{rA = L, fZ = &larr;RH}}{L0	unusedL1	Fix {L1.None}{L2	0=normal, 1=test loop // unused}L3	phase and op}{	orig alpha: == operation	0	read/output word	1	read/output bytes	2	read/output bytes reversed	3	read/output nibbles	4	input/write word	5	input/write bytes	6	input/write bytes reversed	TOS		count{16 bits}	STK-0	bus control word	STK-1	low base address out{16 bits}	STK-2	mBusAddrM{16 bits}	STK-3	virt addr of buffer{24 bits}	STK-5	operation{3 bits}	Regs:	L	saved into UrL	TOS	remaining count	T	temp	Rx	temp	TT	temp	UrL &larr; L	uPPsave	last write to PP	uVirtL	buffer addr lo	uAddr	Bus addr	uBusCtl	Control to Bus	uDataOut	data out}{	in new version of Misc.mc@ESC:	Xbus &larr; ibHigh, XDisp,				c1, opcode[370'b];ESCx:	TT &larr; ib, XDisp, push, DISP4[ESCHi],			c2;	PC &larr; PC + 1, STK &larr; TOS, pop, DISP4[ESC8n],	c3, at[8,10,ESCHi];}{	this replaces  @BANDBLT }PCBKW:	at[3,10,ESC8n],	FloatNop,	L1 &larr; L1.None,		c1;	UrL &larr; L, L2 &larr; 0,		c2;	Rx &larr; 0FF + 1,	c3;	Q &larr; uPPsave,	c1;	PPort &larr; Q and ~Rx,	c2;	FloatNop,	c3;	{seventh arg in TOS}	Rx &larr; STK, pop,	c1;{sixth arg}	uBusCtl &larr; Rx,	c2;	,	c3;	rAddr &larr; STK, pop,	c1;{fifth arg}	Rx &larr; STK, pop,	c2;{fourth arg}	uxx3 &larr; Rx,	c3;	Rx &larr; STK, pop,	c1;{third arg}	uVirtH &larr; Rx,	c2;	Rx &larr; STK, pop,	c3;{second arg}	uVirtL &larr; Rx,	c1;	Rx &larr; STK, pop,	c2;{first arg}	uAlpha &larr; Rx,	c3;	Rx{2*TOS} &larr; TOS LShift1,	c1;	FLTimes.WA.WB{% fZ=3}, Float.M, Xbus{mBusAddrM} &larr; uxx3,	c2;	,	c3;{TT=rDataOut=virtL}	pcA4:	Xbus &larr; uAlpha, XDisp,	c1;	rDataIn{4*TOS} &larr; Rx LShift1, DISP4[pcAdd, 0C],	c2;	rAddr &larr; rAddr + TOS, GOTO[pcArg],	c3, at[0C, 10, pcAdd];{word addressing}	rAddr &larr; rAddr + Rx{2*TOS}, GOTO[pcArg],	c3, at[0D, 10, pcAdd];{byte addressing}	rAddr &larr; rAddr + Rx{2*TOS}, GOTO[pcArg],	c3, at[0E, 10, pcAdd];{byte reversed}	rAddr &larr; rAddr + rDataIn{4*TOS}, GOTO[pcArg],	c3, at[0F, 10, pcAdd];{nibble addressing}pcArg:	rAddr &larr; rAddr -1,	c1;	uAddr &larr; rAddr, Rx &larr; 0{force remap}, 		c2;	Xbus &larr; uAlpha, XDisp,	c3;	pcBCtl:	Float.L, Xbus{mBusAddrL} &larr; uAddr, BRANCH[pcBOut, pcBIn, 0B],	c1;pcBIn:	{T{TOSH} &larr; T{TOSH} or 1, }GOTO[pcCtlj],	c2; {set mBusCtl for reads}pcBOut:	{T{TOSH} &larr; T{TOSH} or 2, }GOTO[pcCtlj],	c2; {set mBusCtl for writes}pcCtlj: {uBusCtl &larr; T{TOSH}},		c3;	Xbus &larr; uAlpha, XDisp,	c1;	Float.M, Xbus{mBusCtl} &larr; uBusCtl, L3 &larr; 0, {L3 &larr; alpha} DISP4[pcBlk],	c2;{pcRead subroutine; return to pcReadRet+L3, use uAddr, update uAddr, read virt+TOS-1}	pcRead:	MAR &larr; Rx &larr; [rhRx, Rx-1], BRANCH[$, pcDn2],	c1;	rAddr &larr; rAddr -1, Float.L, Xbus{mBusAddrL} &larr; uAddr, L3Disp, BRANCH[$, pcRcr, 1],	c2;pcRead3:	uAddr &larr; rAddr, rDataOut &larr; MD, RET[pcReadRet],		c3;	{pcBus subroutine: return to pcBusRet+L3, used both for input and output; rDataIn ignored on output}pcBus2:	Noop, c2;pcBus3:	uAddr &larr; rAddr,	c3;	uDataOut &larr; rDataOut,	c1;{% good for 5; ok others ?}	Xbus &larr; FloatResult{mBusIData}, FLFloatA{fZ=2}, Float.L,	c2;pcBus:	Noop,	c3;pcBus1:	Noop, CANCELBR[$, 3],	c1;	Noop,	c2;{%P  3-Jun-85 23:02:25}	{	Noop,	c3;	Noop,	c1;	Noop,	c2;		Noop,	c3;	Noop,	c1;	Noop,	c2;		Noop,	c3;	Noop,	c1;	Noop,	c2;		Noop,	c3;	Noop,	c1;	Noop,	c2;		Noop,	c3;	Noop,	c1;	Noop,	c2;		Noop,	c3;	Noop,	c1;	Noop,	c2;}	Ybus &larr; rDataIn, Xbus &larr; PPort, XwdDisp{9(,10)},	c3;	Q &larr; rDataIn or FloatResult, L3Disp, BRANCH[$, pcWait, 1],	c1;	rDataIn &larr; Q, Float.L, Xbus{mBusOData} &larr; uDataOut, {RET[pcBusRet{%T}],} BRANCH[pcBRo, pcBRi, 0B],	c2;pcWait: Xbus &larr; FloatResult{mBusIData}, FLFloatA{fZ=2}, Float.L, CANCELBR[pcBus, 0F],	c2;pcBus3CH:	uAddr &larr; rAddr,	c3;	uDataOut &larr; rDataOut,	c1;{% good for 5; ok others ?}	Xbus &larr; FloatResult{mBusIData}, FLFloatA{fZ=2}, Float.L,	c2;{%P  3-Jun-85 23:02:25}pcBusCH:	Noop,	c3;{	Noop,	c1;	Noop,	c2;	Noop,	c3;		Noop,	c1;	Noop,	c2;	Noop,	c3;	Noop,	c1;	Noop,	c2;	Noop,	c3;		Noop,	c1;	Noop,	c2;	Noop,	c3;	Noop,	c1;	Noop,	c2;	Noop,	c3;	Noop,	c1;	Noop,	c2;	Noop,	c3;}pcBus1CH:	Ybus &larr; TOS - 1, ZeroBr, CANCELBR[$, 3],	c1;	BRANCH[$, pcskipit],	c2;	Ybus &larr; rDataIn, Xbus &larr; PPort, XwdDisp{9(,10)},	c3;	Q &larr; rDataIn or FloatResult, L3Disp, BRANCH[$, pcWaitCH, 1],	c1;	rDataIn &larr; Q, Float.L, Xbus{mBusOData} &larr; uDataOut, {RET[pcBusRet{%T}],} BRANCH[pcBRo, pcBRi, 0B],	c2;	pcBRo:	Ybus &larr; 2, YDisp, L3Disp, GOTO[pcBR]	c3;pcBRi:	Ybus &larr; rDataIn and 2, YDisp, L3Disp, GOTO[pcBR]	c3;pcBR:	L3Disp, BRANCH[zBit1, $, 0D],	c1;	Noop, RET[pcBusRet],	c2;zBit1:	Xbus &larr; TIData,{%T} RET[pcBusRet],	c2;pcWaitCH: Xbus &larr; FloatResult{mBusIData}, FLFloatA{fZ=2}, Float.L, CANCELBR[pcBusCH, 0F],	c2;pcskipit:	Ybus &larr; rDataIn, Xbus &larr; PPort, XwdDisp{9(,10)},	c3;	Q &larr; rDataIn or FloatResult, L3Disp, BRANCH[$, pcWaitCHs, 1],	c1;	rDataIn &larr; Q, FloatNop{turn off mBusIData}, {RET[pcBusRet{%T}],} BRANCH[pcBRo, pcBRi, 0B],	c2;pcWaitCHs: Xbus &larr; FloatResult{mBusIData}, FLFloatA{fZ=2}, Float.L, CANCELBR[pcBusCH, 0F],	c2;		{0: Block Read/Output Words}{uAddr=rAddr=last, TOS=cnt}	CALL[pcRead],	c3, at[0, 10, pcBlk];pcOW:	TOS &larr; TOS -1, CarryBr, c1, at[0, 10, pcReadRet];	uDataOut &larr; rDataOut, BRANCH[pcDn, pcBus, 0E], c2;	Noop, CALL[pcRead], c3, at[0, 10, pcBusRet], c3;{1: Block Read/Output Bytes}	CALL[pcRead],	c3, at[1, 10, pcBlk];	pcOB:	TOS &larr; TOS -1, CarryBr, L3 &larr; 9, c1, at[1, 10, pcReadRet];	uDataOut &larr; rDataOut, BRANCH[pcDn, pcBus, 0E], c2;		rDataOut &larr; rDataOut LRot8, L3 &larr; 1, c3, at[9, 10, pcBusRet];pcOBB:	rAddr &larr; rAddr -1, Float.L, Xbus{mBusAddrL} &larr; uAddr, GOTO[pcBus2], c1;	CALL[pcRead], c3, at[1, 10, pcBusRet], c3;{2: Block Read/Output Bytes Reversed}	Ybus &larr; TOS, ZeroBr, CALL[pcRead],	c3, at[2, 10, pcBlk];	pcOBr:	rDataOut &larr; rDataOut LRot8,	c1, at[2, 10, pcReadRet];	uDataOut &larr; rDataOut, L3 &larr; 0A, c2;	TOS &larr; TOS-1, Xbus &larr; PPort, XwdDisp{9(,10)}, GOTO[pcBus1], c3;{TOS was tested for zero at Read}			rDataOut &larr; rDataOut LRot8, L3 &larr; 2, c3, at[0A, 10, pcBusRet];pcOBBr:	rAddr &larr; rAddr -1, Float.L, Xbus{mBusAddrL} &larr; uAddr, GOTO[pcBus2], c1;	Ybus &larr; TOS, ZeroBr, , CALL[pcRead], c3, at[2, 10, pcBusRet], c3;{3: Block Read/Output Nibbles}	CALL[pcRead],	c3, at[3, 10, pcBlk];	pcON:	TOS &larr; TOS -1, CarryBr, L3 &larr; 7, c1, at[3, 10, pcReadRet];	uDataOut &larr; rDataOut, BRANCH[pcDn, pcBus, 0E], c2;		rDataOut &larr; rDataOut LRot12, L3 &larr; 0B, c3, at[7, 10, pcBusRet];pcONN:	rAddr &larr; rAddr -1, Float.L, Xbus{mBusAddrL} &larr; uAddr, GOTO[pcBus2], c1;	rDataOut &larr; rDataOut LRot12, L3 &larr; 0F, c3, at[0B, 10, pcBusRet];pcONNN:	rAddr &larr; rAddr -1, Float.L, Xbus{mBusAddrL} &larr; uAddr, GOTO[pcBus2], c1;	rDataOut &larr; rDataOut LRot12, L3 &larr; 3, c3, at[0F, 10, pcBusRet];pcONNNN: rAddr &larr; rAddr -1, Float.L, Xbus{mBusAddrL} &larr; uAddr, GOTO[pcBus2], c1;	Noop, CALL[pcRead], c3, at[3, 10, pcBusRet], c3;	pcInPipeStart:	uAddr &larr; rAddr, c1;	Float.L, Xbus{mBusOData} &larr; uDataOut,	c2;	Float.L, Xbus{mBusAddrL} &larr; uAddr, 	c3;	rAddr &larr; rAddr -1, Xbus &larr; FloatResult{mBusIData}, FLFloatA{fZ=2}, Float.L,	c1;	uAddr &larr; rAddr, rDataIn &larr; 0, GOTO[pcBus], c2; 	{4: Block Input/Write Words}	rAddr &larr; rAddr -1,	c3, at[4, 10, pcBlk];pcInPipeStartCH:	uAddr &larr; rAddr, c1;	Float.L, Xbus{mBusOData} &larr; uDataOut,	c2;	Float.L, Xbus{mBusAddrL} &larr; uAddr, 	c3;	rAddr &larr; rAddr -1, Xbus &larr; FloatResult{mBusIData}, FLFloatA{fZ=2}, Float.L,	c1;	uAddr &larr; rAddr, rDataIn &larr; 0, GOTO[pcBusCH], c2; pcIW:	TOS &larr; TOS -1, NZeroBr, c1, at[4, 10, pcWriteRet];	uAddr &larr; rAddr, rDataIn &larr; 0, BRANCH[pcDnCH, pcBusCH, 0E], c2;		rDataIn &larr; rDataIn, CALL[pcWrite], c3, at[4, 10, pcBusRet];	pcWrite:{% T test bit 1}	Ybus &larr; rDataIn, YDisp, c1;	BRANCH[zeroBit1, $, 0D], c2;	Noop, GOTO[pcWrite1],	c3;zeroBit1:	Xbus &larr; TStatus, GOTO[pcWrite1],	c3;pcWrite1: MAR &larr; Rx &larr; [rhRx, Rx-1],	c1;pcWrite2: MDR &larr; rDataIn, Float.L, Xbus{mBusAddrL} &larr; uAddr, L3Disp, BRANCH[$, pcWcr, 1],	c2;	rAddr &larr; rAddr -1, Xbus &larr; FloatResult{mBusIData}, FLFloatA{fZ=2}, Float.L, RET[pcWriteRet],	c3;		{5: Block Input/Write Bytes}		rAddr &larr; rAddr -1, GOTO[pcInPipeStart],	c3, at[5, 10, pcBlk];	rDataIn &larr; rDataIn {and 0F}, L3 &larr; 0D, c3, at[5, 10, pcBusRet];pcIBB:	rAddr &larr; rAddr -1, Float.L, Xbus{mBusAddrL} &larr; uAddr,  c1;	rDataIn &larr; rDataIn LRot8,  GOTO[pcBus3CH], c2;	rDataIn &larr; rDataIn LRot8, CALL[pcWrite], c3, at[0D, 10, pcBusRet];pcIB:	TOS &larr; TOS -1, NZeroBr, L3 &larr; 5, c1, at[0D, 10, pcWriteRet];	uAddr &larr; rAddr, rDataIn &larr; 0, BRANCH[pcDn, pcBus, 0E], c2;		{6: Block Input/Write Bytes Reversed}		rAddr &larr; rAddr -1, GOTO[pcInPipeStart],	c3, at[6, 10, pcBlk];	rDataIn &larr; rDataIn {and 0F}, L3 &larr; 0E, c3, at[6, 10, pcBusRet];pcIBBr:	rAddr &larr; rAddr -1, Float.L, Xbus{mBusAddrL} &larr; uAddr,  c1;	rDataIn &larr; rDataIn LRot8,  GOTO[pcBus3CH], c2;		rDataIn &larr; rDataIn LRot0, CALL[pcWrite], c3, at[0E, 10, pcBusRet];pcIBr:	TOS &larr; TOS -1, NZeroBr, L3 &larr; 6, c1, at[0E, 10, pcWriteRet];	uAddr &larr; rAddr, rDataIn &larr; 0, BRANCH[pcDn, pcBus, 0E], c2;		{Exceptions}{Remap to Virt+TOS-1}{don't fault if TOS=0}	pcWcr:	Noop, CANCELBR[pcCr, 0F],	c3;pcRcr:	rAddr &larr; rAddr +1, CANCELBR[pcCr, 0F],	c3;pcCr:	TOS &larr; TOS -1, CarryBr,	c1;	TT &larr; uVirtL, BRANCH[pcCz, pcCnz],	c2;pcCz:	rhTT &larr; uVirtH, GOTO[pcMp],	c3;pcCnz:	TT &larr; TT + TOS, CarryBr,	c3;		rhTT &larr; uVirtH, BRANCH[pcnoInc, pcInc],	c1;pcnoInc:	,	c2;	GOTO[pcMp],	c3;pcInc:	Q &larr; rhTT+1, 	LOOPHOLE[byteTiming], c2;	rhTT &larr; Q LRot0, GOTO[pcMp],	c3;pcMp:	Map &larr; Q &larr; [rhTT, TT],	c1;	TOS &larr; TOS + 1,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp,	c3;		Map &larr; Q &larr; [rhTT, TT], DISP2[pcFault],	c1;	MDR &larr; Rx or 0B0, GOTO[beWMapb],	c2, at[0,4,pcFault];	MDR &larr; Rx or 0B0, GOTO[beWMapb],	c2, at[1,4,pcFault];beWMapb:	L3Disp,		c3;pcMpD:	MAR &larr; Rx &larr; [rhRx, TT+0], BRANCH[pcRead2, pcWrite2, 0B],	c1;pcRead2: rAddr &larr; rAddr -1, Float.L, Xbus{mBusAddrL} &larr; uAddr, L3Disp, GOTO[pcRead3],	c2;		{% fix ups}pcFault:	T &larr; qWriteProtect, GOTO[beWMapX],	c2, at[2,4,pcFault];	T &larr; qPageFault, GOTO[beWMapX],	c2, at[3,4,pcFault];beWMapX:	{push stack back = 6 push's}	Q &larr; uPPsave, push,	c3;	PPort &larr; Q, push,	c1;	L &larr; UrL, push, c2;	PC &larr; PC - 1, push,	c3;	push,	c1;	L1Disp, push, GOTO[WTrap],	c2;	{exits}pcDnCH:	GOTO[pcDn1],	c3;pcDn2:	, CANCELBR[$, 2],	c2;pcDn:	,	c3;pcDn1:		L &larr; UrL, CANCELBR[$, 3],	c1;	Rx &larr; uPPsave, IBDisp, c2;	PPort &larr; Rx, DISPNI[OpTable],	c3;	{ E N D }</pre>
  </body>
</html>
