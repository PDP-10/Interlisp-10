<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>busmaster>TESTBLT!1</title>
  </head>
  <body>
    <pre>
(FILECREATED "15-Apr-85 08:24:44" {DSK}&lt;LISPFILES&gt;HTHOMPSON&gt;DSL&gt;TESTBLT.;13 25668        changes to:  (FNS FastTestBltIn StartBltTest BMTChangeDirection DoTB MakeBusmasterTest)		   (VARS TESTBLTCOMS BusmasterIcon)		   (PROPS (\BUSBLTCHECKSWAPBYTES DOPVAL)			  (\BUSBLTCHECKBYTES DOPVAL)			  (\BUSBLTCHECK DOPVAL))      previous date: "12-Apr-85 14:13:36" {DSK}&lt;LISPFILES&gt;HTHOMPSON&gt;DSL&gt;TESTBLT.;10)(* Copyright (c) 1985 by Speech Input Project, Univ. of Edinburgh. All rights reserved.)(PRETTYCOMPRINT TESTBLTCOMS)(RPAQQ TESTBLTCOMS [(FNS BMTChangeDirection BMTSetValue DoTB RecordError SetupTestArray ShowErrors 			 ShowResults ShowWords StartBltTest StopBltTest TestBltIn TestBltOut 			 FastTestBltIn)		    (FNS MakeBusmasterTest BMTRead)		    [VARS (BMTArray1)			  (BMTArray2)			  [BMTInPatternSpecs '((zeros 0)					       (ones 65535)					       (alt0 NIL NIL 					"fixed pattern of alternating 0s and 1s, starting with 0")					       (alt1 NIL NIL 					"fixed pattern of alternating 0s and 1s, starting with 1")					       (rand NIL NIL "random words")					       ((TogMenuValue)						(BMTRead "Pattern")						NIL "will prompt and read" Other))]			  [BMTOutPatternSpecs '((zeros 0)						(ones 65535)						(alt0 NIL NIL 					"fixed pattern of alternating 0s and 1s, starting with 0")						(alt1 NIL NIL 					"fixed pattern of alternating 0s and 1s, starting with 1")						(alt NIL NIL 					    "0 -1 ... alternating every other pass with -1 0 ...")						(altAll NIL NIL 						   "zeros alternating every other pass with ones")						(newRand NIL NIL "random words, new each pass")						(fixedRand NIL NIL "random words, same each pass")						((TogMenuValue)						 (BMTRead "Pattern")						 NIL "will prompt and read" Other))]			  (BMTestTogMenuSpecs '(["Direction" (In (BMTChangeDirection 'In))							     (Out (BMTChangeDirection 'Out))							     (FastIn (BMTChangeDirection								       'FastIn))							     (FastOut (BMTChangeDirection									'FastOut]						("Mode" (Straight (NILL))							(Swapped SWAP))						(Pattern)						("Save results" (No (BMTSetValue 'save										 NIL))								(Yes (BMTSetValue 'save										  T)))						("Show every error" (No (BMTSetValue 'show										     NIL))								    (Yes (BMTSetValue 'show										      T)))						("Summarize every" (1 (BMTSetValue 'sumEvery										   1))								   (10 (BMTSetValue 'sumEvery										    10))								   ((TogMenuValue)								    (BMTSetValue 'sumEvery										 (BMTRead 										"Summarize every"))								    NIL "will prompt and read" Other))						["Type of summary" (%. (BMTSetValue 'sumType										    '%.))								   (Full (BMTSetValue 'sumType										      'Full]						("# passes" (Forever 2147483647)							    ((TogMenuValue)							     (BMTRead "# passes")							     NIL "will prompt and read" Other))						("Size of block" 100 1000 5000 10000 32768								 ((TogMenuValue)								  (BMTRead "Size of block")								  NIL "will prompt and read" Other))						("Dismiss" (Yes (BMTSetValue 'block?									     T))							   (No (BMTSetValue 'block?									    NIL)							       NIL 						     "Enable/disable blocking - No is dangerous!")))]		    (FILES BUSUTIL)		    (P (PUTASSOC 'Pattern				 BMTInPatternSpecs BMTestTogMenuSpecs))		    (BITMAPS BusmasterIcon)		    (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS				(NLAMA)				(NLAML DoTB)				(LAMA])(DEFINEQ(BMTChangeDirection  [LAMBDA (direction)                                        (* ht: "14-Apr-85 16:31")    [if (BOUNDP '$$TogWindow$$)	then (TogMenuReset (WINDOWPROP (MAINWINDOW $$TogWindow$$ T)				       'PatternMenu)			   NIL			   (SELECTQ direction				    ((In FastIn)				      BMTInPatternSpecs)				    ((Out FastOut)				      BMTOutPatternSpecs)				    (SHOULDNT]    direction])(BMTSetValue  [LAMBDA (var value)                                        (* edited: "12-Apr-85 10:48")    [if (BOUNDP '$$TogWindow$$)	then (let (proc)		  (proc&larr;(WINDOWPROP (MAINWINDOW $$TogWindow$$ T)				    'PROCESS))		  (if (AND proc (PROCESS.APPLY proc (FUNCTION BOUNDP)					       (LIST var)					       T))		      then (PROCESS.APPLY proc (FUNCTION SET)					  (LIST var value]    value])(DoTB  [NLAMBDA (fn args)                                         (* ht: "14-Apr-85 16:26")    (RESETFORM (TTYDISPLAYSTREAM (PROCESSPROP (THIS.PROCESS)					      'WINDOW))	       (APPLY fn args))    (TogMenuReset (WINDOWPROP (PROCESSPROP (THIS.PROCESS)					   'WINDOW)			      'ControlMenu])(RecordError  [LAMBDA (aList value firstIndex secondIndex)               (* ht: " 7-Apr-85 15:47")    (let ((topEntry (CDR (ASSOC firstIndex aList)))	  subEntry)	 (if (NOT topEntry)	     then (PUTASSOC firstIndex topEntry&larr;(LIST NIL)			    aList))	 (if subEntry&larr;(CDR (ASSOC secondIndex topEntry))	     then (if (NOT (FMEMB value subEntry))		      then (NCONC1 subEntry value))	   else (PUTASSOC secondIndex (LIST value)			  topEntry])(SetupTestArray  [LAMBDA (array1 pattern n)                                 (* ht: " 7-Apr-85 09:31")    (for i from 1 to n do (SETA array1 i (SELECTQ pattern						  (0 0)						  ((NIL rand)						    (RAND 0 65535))						  (alt0 (if (EVENP i)							    then 65535							  else 0))						  (alt1 (if (EVENP i)							    then 0							  else 65535))						  (if (NUMBERP pattern)						      then pattern						    else (SHOULDNT "not a valid pattern" pattern])(ShowErrors  [LAMBDA (aList)                                            (* ht: " 7-Apr-85 14:47")    (RESETFORM (RADIX 16)	       (for topEntry in aList		  do (printout NIL 20 .I4.16 topEntry:1 #			       (for subEntry in topEntry::2				  do (printout NIL 25 .I4.16 subEntry:1 , .PARA 30 50 (SORT 										      subEntry::1])(ShowResults  [LAMBDA (j n pattern mode c1 c2 c3 ln lp mn mp sn sp out?)                                                             (* ht: "12-Apr-85 14:05")    (printout T T j " passes * " n " words = " (j*n)	      (if out?		  then " writes"		else " reads")	      " of pattern " # (RESETFORM (RADIX 16)					  (PRIN1 pattern))	      " in "	      (OR mode 'STRAIGHT)	      " mode." T)    (if (OR lp mp)	then (printout T 20 c1 25 c2 30 c3 T))    (printout T ln # (if (NOT (ZEROP ln))			 then (printout NIL " (" (FQUOTIENT ln (FQUOTIENT j*n 1000.0))					" per thousand)"))	      (if lp		  then " read errors: "		else " read errors,"))    (if lp	then (ShowErrors lp))    (printout T T mn # (if (NOT (ZEROP mn))			   then (printout NIL " (" (FQUOTIENT mn (FQUOTIENT j*n 1000.0))					  " per thousand)"))	      (if mp		  then (if out?			   then " write errors: "			 else " memory decays: ")		else (if out?			 then " write errors,"		       else " memory decays,")))    (if mp	then (ShowErrors mp))    (if sp	then (printout T T 20 "1st" 25 "2nd" 30 "addrs"))    (printout T T sn # (if (NOT (ZEROP sn))			   then (printout NIL " (" (FQUOTIENT sn (FQUOTIENT ln+mn 1000.0))					  " per thousand)"))	      (if sp		  then " slow faults: "		else " slow faults."))    (if sp	then (ShowErrors sp))    (TERPRI T])(ShowWords  [LAMBDA (inRadix outRadix offset)                          (* ht: " 7-Apr-85 10:04")    (RESETFORM (RADIX (OR outRadix 16))	       (bind addr		  until (PEEKC T)= 's do (printout T (BUS.READWORD 1 (OR offset -1)+(TrueRadixRead								     (OR inRadix 16)))						   T)		  finally (READC T])(StartBltTest  [LAMBDA NIL                                                (* ht: "14-Apr-85 16:28")    (LET* [(mw (MAINWINDOW $$TogWindow$$ T))       (menus (WINDOWPROP mw 'BMTMenus]      (WINDOWPROP mw 'PROCESS		  (ADD.PROCESS [LIST 'DoTB				     (SELECTQ (TogMenuValue menus:1)					      (In 'TestBltIn)					      (Out 'TestBltOut)					      (FastIn 'FastTestBltIn)					      (FastOut 'FastTestBltOut)					      (SHOULDNT))				     (NCONC (for m in menus::1 collect (TogMenuValue m))					    (WINDOWPROP mw 'BMTArrays]			       'WINDOW			       mw])(StopBltTest  [LAMBDA NIL                                                (* ht: "10-Apr-85 15:21")    (LET* [(mw (MAINWINDOW $$TogWindow$$ T))       (proc (WINDOWPROP mw 'PROCESS]      (printout mw T "Stopping...")      (PROCESS.EVAL proc '(SETQ $Stop$ T)])(TestBltIn  [LAMBDA (mode pattern save show sumEvery sumType numPasses n block? array1 array2)                                                             (* ht: "12-Apr-85 11:50")    (DECLARE (SPECVARS save show sumEvery sumType block?))    (if (NOT n)	then n&larr;(ARRAYSIZE array1))    (SetupTestArray array1 pattern n)    (if block?	then (BLOCK))    (BUSDMA.INIT)    (StoreArray array1 0 n mode)    (if block?	then (BLOCK))    (printout T "Pattern stored, " (for i from 1 to n				      unless (BUS.READWORD 1 i-1 mode)=(ELT array1 i)				      count (BUS.WRITEWORD 1 i-1 (ELT array1 i)							   mode))	      " errors," T "starting test." T)    (bind ((losses &larr; 0)	   (memFaults &larr; 0)	   (slowFaults &larr; 0)	   (lossPairs &larr;(LIST NIL))	   (memPairs &larr;(LIST NIL))	   (slowPairs &larr;(LIST NIL))	   type $Stop$ true)       declare (SPECVARS $Stop$) for j from 1 to (OR numPasses MAX.SMALLP)       until (OR $Stop$ (KEYDOWNP 'STOP))       do (FetchArray array2 0 n mode)	  (if block?	      then (BLOCK))	  [for i from 1 to n	     unless (ELT array1 i)=(ELT array2 i)	     do (bind prev do true&larr;(BUS.READWORD 1 i-1 mode)		   repeatuntil (if true=(ELT array1 i)				   then (type&larr; 'r)					[if save					    then (SELECTQ pattern							  (rand (RecordError lossPairs									     (ELT array2 i)									     i									     (ELT array1 i)))							  (RecordError lossPairs i (ELT array1 i)								       (ELT array2 i]					(add losses 1)				 elseif prev				   then (if prev=true					    then (type&larr; 'm)						 (add memFaults 1)						 [if save						     then (SELECTQ pattern								   (rand (RecordError memPairs										      (ELT array1 i)										      i										      (ELT array2 i)))								   (RecordError memPairs i										(ELT array1 i)										(ELT array2 i]						 (BUS.WRITEWORD 1 i-1 (ELT array1 i))					  else (add slowFaults 1)					       (if save						   then (RecordError slowPairs i prev true))					       (if show						   then (RESETFORM (RADIX 16)								   (printout T "s" i 6 prev , true T))						   )					       (prev&larr;true)					       NIL)				 else (prev&larr;true)				      NIL))		(if show		    then (RESETFORM (RADIX 16)				    (printout T type i 6 (ELT array1 i)					      12					      (ELT array2 i)					      18 true T]	  (if block?	      then (BLOCK))	  (if (IMOD j (OR sumEvery 10))=0	      then (SELECTQ sumType			    (%. (PRIN1 "." T))			    (printout T losses , "read errors, " memFaults " memory decays, " 				      slowFaults " slow faults." T)))       finally (SELECTQ pattern			(rand (ShowResults j-1 n pattern mode "addr" "val" "errs" losses					   (SORT lossPairs::1 T)					   memFaults					   (SORT memPairs::1 T)					   slowFaults slowPairs::1))			(ShowResults j-1 n pattern mode "val" "err" "addrs" losses lossPairs::1 				     memFaults memPairs::1 slowFaults slowPairs::1])(TestBltOut  [LAMBDA (mode pattern save show sumEvery sumType numPasses n block? array1 array2)                                                             (* ht: "12-Apr-85 13:41")    (DECLARE (SPECVARS save show sumEvery sumType block?))    (if (NOT n)	then n&larr;(ARRAYSIZE array1))    (SELECTQ pattern	     ((alt altAll newRand))	     (fixedRand (SetupTestArray array1 'rand					n))	     (SetupTestArray array1 pattern n))    (if block?	then (BLOCK))    (printout T "Pattern initialized, starting test." T)    (bind ((losses &larr; 0)	   (memFaults &larr; 0)	   (slowFaults &larr; 0)	   (lossPairs &larr;(LIST NIL))	   (memPairs &larr;(LIST NIL))	   (slowPairs &larr;(LIST NIL))	   type $Stop$ true)       declare (SPECVARS $Stop$) for j from 1 to (OR numPasses MAX.SMALLP)       until (OR $Stop$ (KEYDOWNP 'STOP))       do (SELECTQ pattern		   (newRand (SetupTestArray array1 pattern n))		   (alt (SetupTestArray array1 (if (EVENP j)						   then 'alt0						 else 'alt1)					n))		   (altAll (SetupTestArray array1 (if (EVENP j)						      then 0						    else 65535)					   n))		   NIL)	  (if block?	      then (BLOCK))	  (StoreArray array1 0 n)	  (if block?	      then (BLOCK))	  (FetchArray array2 0 n)	  (if block?	      then (BLOCK))	  [for i from 1 to n	     unless (ELT array1 i)=(ELT array2 i)	     do (bind prev do true&larr;(BUS.READWORD 1 i-1 mode)		   repeatuntil (if true=(ELT array1 i)				   then (type&larr; 'r)					[if save					    then (SELECTQ pattern							  (rand (RecordError lossPairs									     (ELT array2 i)									     i									     (ELT array1 i)))							  (RecordError lossPairs i (ELT array1 i)								       (ELT array2 i]					(add losses 1)				 elseif prev				   then (if prev=true					    then (type&larr; 'w)						 (add memFaults 1)						 [if save						     then (SELECTQ pattern								   (rand (RecordError memPairs										      (ELT array1 i)										      i										      (ELT array2 i)))								   (RecordError memPairs i										(ELT array1 i)										(ELT array2 i]						 (BUS.WRITEWORD 1 i-1 (ELT array1 i))					  else (add slowFaults 1)					       (if save						   then (RecordError slowPairs i prev true))					       (if show						   then (RESETFORM (RADIX 16)								   (printout T "s" i 6 prev , true T))						   )					       (prev&larr;true)					       NIL)				 else (prev&larr;true)				      NIL))		(if show		    then (RESETFORM (RADIX 16)				    (printout T type i 6 (ELT array1 i)					      12					      (ELT array2 i)					      18 true T]	  (if block?	      then (BLOCK))	  (if (IMOD j (OR sumEvery 10))=0	      then (SELECTQ sumType			    (%. (PRIN1 "." T))			    (printout T losses , "read errors, " memFaults " write errors, " 				      slowFaults " slow faults." T)))       finally (SELECTQ pattern			(rand (ShowResults j-1 n pattern mode "addr" "val" "errs" losses					   (SORT lossPairs::1 T)					   memFaults					   (SORT memPairs::1 T)					   slowFaults slowPairs::1 T))			(ShowResults j-1 n pattern mode "val" "err" "addrs" losses lossPairs::1 				     memFaults memPairs::1 slowFaults slowPairs::1 T])(FastTestBltIn  [LAMBDA (mode pattern save show sumEvery sumType numPasses n block? array1 array2)                                                             (* ht: "14-Apr-85 17:57")    (DECLARE (SPECVARS save show sumEvery sumType block?))    (if (NOT n)	then (SETQ n (ARRAYSIZE array1)))    (SetupTestArray array1 pattern n)    (BUSDMA.INIT)    (StoreArray array1 0 n mode)    (printout T "Pattern stored, " (for i from 1 to n unless (EQ (BUS.READWORD 1 (DIFFERENCE i 1)									       mode)								 (ELT array1 i))				      count (BUS.WRITEWORD 1 (DIFFERENCE i 1)							   (ELT array1 i)							   mode))	      " errors," T "starting test." T)    (bind ((losses &larr; 0)	   (memFaults &larr; 0)	   (slowFaults &larr; 0)	   (lossPairs &larr;(LIST NIL))	   (memPairs &larr;(LIST NIL))	   (slowPairs &larr;(LIST NIL))	   type true)       declare for j from 1 to (OR numPasses MAX.SMALLP) until (KEYDOWNP 'STOP)       do (bind (top &larr; n)		firstBad until [OR (ZEROP top)				   (ZEROP (SETQ firstBad (TestArray array1 0 top mode]	     do (bind prev do (SETQ true (BUS.READWORD 1 (SUB1 firstBad)						       mode))		   repeatuntil (if (EQ true (ELT array1 firstBad))				   then (SETQ type 'r)					(if save					    then (SELECTQ pattern							  (rand (RecordError lossPairs NIL firstBad									     (ELT array1 firstBad)))							  (RecordError lossPairs firstBad								       (ELT array1 firstBad)								       NIL)))					(add losses 1)				 elseif prev				   then (if (EQ prev true)					    then (SETQ type 'm)						 (add memFaults 1)						 (if save						     then (SELECTQ pattern								   (rand (RecordError memPairs										      (ELT array1 											 firstBad)										      firstBad NIL))								   (RecordError memPairs firstBad										(ELT array1 firstBad)										NIL)))						 (BUS.WRITEWORD 1 (DIFFERENCE firstBad 1)								(ELT array1 firstBad))					  else (add slowFaults 1)					       (if save						   then (RecordError slowPairs firstBad prev true))					       (if show						   then (RESETFORM (RADIX 16)								   (printout T "s" firstBad 6 prev , 									     true T)))					       (SETQ prev true)					       NIL)				 else (SETQ prev true)				      NIL))		(if show		    then (RESETFORM (RADIX 16)				    (printout T type firstBad 6 (ELT array1 firstBad)					      12 true T)))		(SETQ top (SUB1 firstBad)))	  (if (EQ (IMOD j (OR sumEvery 10))		  0)	      then (SELECTQ sumType			    (%. (PRIN1 "." T))			    (printout T losses , "read errors, " memFaults " memory decays, " 				      slowFaults " slow faults." T)))       finally (SELECTQ pattern			(rand (ShowResults (DIFFERENCE j 1)					   n pattern mode "addr" "val" "errs" losses					   (SORT (CDR lossPairs)						 T)					   memFaults					   (SORT (CDR memPairs)						 T)					   slowFaults					   (CDR slowPairs)))			(ShowResults (DIFFERENCE j 1)				     n pattern mode "val" "err" "addrs" losses (CDR lossPairs)				     memFaults				     (CDR memPairs)				     slowFaults				     (CDR slowPairs]))(DEFINEQ(MakeBusmasterTest  [LAMBDA (array1 array2)                                    (* edited: "14-Apr-85 14:35")    (let ((mw (CREATEW NIL "Busmaster Test Window"))	  mwRight controlW controlM)	 [mwRight&larr;(IPLUS (fetch LEFT of (WINDOWPROP mw 'REGION))			 (fetch WIDTH of (WINDOWPROP mw 'REGION]	 [WINDOWPROP mw 'BMTArrays		     (LIST (OR array1 BMTArray1 BMTArray1&larr;(ARRAY 32768 'WORD))			   (OR array2 BMTArray2 BMTArray2&larr;(ARRAY 32768 'WORD]	 (DSPSCROLL 'ON		    mw)	 (WINDOWPROP mw 'ICON		     BusmasterIcon)	 (WINDOWPROP mw 'BMTMenus		     (bind (nw &larr; mw)			   tm aw tw ttw for tms in BMTestTogMenuSpecs			collect (ttw&larr;(TogMenu tm&larr;(MakeTogMenu tms::1)					      tms:1 NIL 0 0 T))				(if tms:1= 'Pattern				    then (WINDOWPROP mw 'PatternMenu						     tm))				(if (OR aw=NIL (AND tw (IGREATERP [IPLUS (fetch LEFT									    of (WINDOWPROP										 tw										 'REGION))									 (fetch WIDTH									    of (WINDOWPROP										 tw										 'REGION))									 (fetch WIDTH									    of (WINDOWPROP										 ttw										 'REGION]								  mwRight)))				    then (aw&larr;nw)					 (tw&larr;NIL)					 (nw&larr;ttw))				(if tw				    then (ATTACHWINDOW ttw tw 'RIGHT)				  else (ATTACHWINDOW ttw aw 'TOP						     'LEFT))				(tw&larr;ttw)				(REDISPLAYW ttw)				tm))	 (ATTACHWINDOW controlW&larr;(TogMenu controlM&larr;[MakeTogMenu '((Start NIL (StartBltTest))								 (Stop NIL (StopBltTest)))]					 "Control" NIL 0 0 T)		       mw		       'RIGHT		       'TOP)	 (WINDOWPROP mw 'ControlMenu		     controlM)	 (REDISPLAYW controlW)	 mw])(BMTRead  [LAMBDA (message)                                          (* edited: "12-Apr-85 11:05")    (RESETFORM (TTYDISPLAYSTREAM (GETPROMPTWINDOW (MAINWINDOW $$TogWindow$$ T)))	       (printout NIL message ": ")	       (PROG1 (READ)		      (CLOSEW (GETPROMPTWINDOW (MAINWINDOW $$TogWindow$$ T]))(RPAQQ BMTArray1 NIL)(RPAQQ BMTArray2 NIL)(RPAQQ BMTInPatternSpecs ((zeros 0)			  (ones 65535)			  (alt0 NIL NIL "fixed pattern of alternating 0s and 1s, starting with 0")			  (alt1 NIL NIL "fixed pattern of alternating 0s and 1s, starting with 1")			  (rand NIL NIL "random words")			  ((TogMenuValue)			   (BMTRead "Pattern")			   NIL "will prompt and read" Other)))(RPAQQ BMTOutPatternSpecs ((zeros 0)			   (ones 65535)			   (alt0 NIL NIL "fixed pattern of alternating 0s and 1s, starting with 0")			   (alt1 NIL NIL "fixed pattern of alternating 0s and 1s, starting with 1")			   (alt NIL NIL "0 -1 ... alternating every other pass with -1 0 ...")			   (altAll NIL NIL "zeros alternating every other pass with ones")			   (newRand NIL NIL "random words, new each pass")			   (fixedRand NIL NIL "random words, same each pass")			   ((TogMenuValue)			    (BMTRead "Pattern")			    NIL "will prompt and read" Other)))(RPAQQ BMTestTogMenuSpecs (["Direction" (In (BMTChangeDirection 'In))					(Out (BMTChangeDirection 'Out))					(FastIn (BMTChangeDirection 'FastIn))					(FastOut (BMTChangeDirection 'FastOut]			   ("Mode" (Straight (NILL))				   (Swapped SWAP))			   (Pattern)			   ("Save results" (No (BMTSetValue 'save							    NIL))					   (Yes (BMTSetValue 'save							     T)))			   ("Show every error" (No (BMTSetValue 'show								NIL))					       (Yes (BMTSetValue 'show								 T)))			   ("Summarize every" (1 (BMTSetValue 'sumEvery							      1))					      (10 (BMTSetValue 'sumEvery							       10))					      ((TogMenuValue)					       (BMTSetValue 'sumEvery							    (BMTRead "Summarize every"))					       NIL "will prompt and read" Other))			   ["Type of summary" (%. (BMTSetValue 'sumType							       '%.))					      (Full (BMTSetValue 'sumType								 'Full]			   ("# passes" (Forever 2147483647)				       ((TogMenuValue)					(BMTRead "# passes")					NIL "will prompt and read" Other))			   ("Size of block" 100 1000 5000 10000 32768 ((TogMenuValue)					     (BMTRead "Size of block")					     NIL "will prompt and read" Other))			   ("Dismiss" (Yes (BMTSetValue 'block?							T))				      (No (BMTSetValue 'block?						       NIL)					  NIL "Enable/disable blocking - No is dangerous!"))))(FILESLOAD BUSUTIL)(PUTASSOC 'Pattern	  BMTInPatternSpecs BMTestTogMenuSpecs)(RPAQ BusmasterIcon (READBITMAP))(64 64"OOOOOOOOOOOOOOOO""OOOOOOOOOOOOOOOO""LBBBBBBBBBBBBB@C""LBBBBBBNCOOOOOHC""L@HHHHHLKOOOOOHC""L@HLIHHLKOOOOOHC""LBBNCJBNCOOOOOHC""LBBNCJBNCOOOOOHC""L@HLIHHLKOOOOOHC""L@HNKHHLKOOOOOHC""LBBOOJBNCOOOOOHC""LBBGOBBNCOOOOOHC""L@HKNHHLHHIOHHHC""L@HILHHLHHIOHHHC""LBBCNBBNBBCOBB@C""LBBCNBBNBBCOJB@C""L@HKLHHLHHIOHHHC""L@HILHHLHHIOHHHC""LBBCNBBNBBCOBB@C""LBBCNBBNBBCOBB@C""L@HILHHLHHIOHHHC""L@HILHHLHHIOHHHC""LBBCNBBNBBCOBB@C""LBBCNBBNBBCOBB@C""L@HILHHLHHIOHHHC""L@HILHHLHHIOHHHC""LBBCNBBNBBCOBB@C""LBBCNBBNBBCOBB@C""L@HILHHLHHIOHHHC""L@HILHHLHHIOHHHC""LBBCNBBNBBCOBB@C""LBBCNBBNBBCOBB@C""L@HILHHLHHIOHHHC""L@HILHINHHIOHHHC""LBBCNBCOBBCOBB@C""LBBCNBGOJBCOBB@C""L@HILHOOHHIOHHHC""L@HILHOOHHIOHHHC""LBBCNBGOJBCOBB@C""LBBCNBGOJBCOBB@C""L@HILHOOHHIOHHHC""L@HKNHOOHHIOHHHC""LBBCOBGOJBCOBB@C""LBBOOJGOJBCOBB@C""L@HOOHOOHHIOHHHC""L@HNKHOOHHIOHHHC""LBBNCJGOJBCOBB@C""LBBNCJGOJBCOBB@C""L@HLIHKOHHIOHHHC""L@HLIHINHHHHHHHC""L@@@@@@@@@@@@@@C""L@@@@@@@@@@@@@@C""L@@@@@@@@@@@@@@C""L@@@@@@@@@@@@@@C""LGH@@@@@@@A@@@@C""LDDIAMFLFAOIHJ@C""LGHIBAKDIBABDN@C""LDDIAIBDGAICLH@C""LDDK@EBDI@EB@H@C""LGHMCIBDNKIILH@C""L@@@@@@@@@@@@@@C""L@@@@@@@@@@@@@@C""L@@@@@@@@@@@@@@C""OOOOOOOOOOOOOOOO")(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML DoTB)(ADDTOVAR LAMA ))(PUTPROPS TESTBLT COPYRIGHT ("Speech Input Project, Univ. of Edinburgh" 1985))(DECLARE: DONTCOPY  (FILEMAP (NIL (3484 19650 (BMTChangeDirection 3494 . 3931) (BMTSetValue 3933 . 4403) (DoTB 4405 . 4747) (RecordError 4749 . 5281) (SetupTestArray 5283 . 5839) (ShowErrors 5841 . 6226) (ShowResults 6228 . 7833) (ShowWords 7835 . 8202) (StartBltTest 8204 . 8834) (StopBltTest 8836 . 9122) (TestBltIn 9124 . 12485) (TestBltOut 12487 . 16112) (FastTestBltIn 16114 . 19648)) (19651 21794 (MakeBusmasterTest 19661 . 21441) (BMTRead 21443 . 21792)))))STOP</pre>
  </body>
</html>
