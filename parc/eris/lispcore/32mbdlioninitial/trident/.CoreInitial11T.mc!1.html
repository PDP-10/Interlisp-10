<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>32mbdlioninitial>trident>CoreInitial11T.mc!1</title>
  </head>
  <body>
    <pre>
{File name:  xCoreInitial11.mc Last Edited:  9-Jan-85  8:52:57 Lichtenberg - Remove junk  Description: 2MB Purcell Core of the initial microcode booting sequence, Last Edited: Lichtenberg 19-Jul-84  0:21:27 4mb mem stuff for Mesa 11 Last Edited: Purcell    2-Jul-84  2:38:37 Mesa 11 upgrades to 27-Sep-83 Last Edited: Purcell   2-Mar-84  5:16:02 remove Bank &larr; 4Last Edited: Purcell 15-Feb-84  1:29:59 recognize 4mb Last Edited: Purcell February 6, 1984  12:29 PM MCtl &larr; 8002h or xx Last Edited: Purcell January 19, 1984  7:25 PM Mesa ignore xtra mem Last Edited: Purcell January 16, 1984  6:35 PM test for 4MB Last Edited: Purcell January 4, 1984  6:46 PM Bank &larr; 4{21 bit real mem} Last Edited: Purcell December 30, 1983  11:17 AM MCtl &larr; 2.  Last Edited: Purcell December 29, 1983  5:00 PM 3-8MB mem.  Last Edited: Purcell December 27, 1983  9:14 PM 2MB mem.  Last Edited: Neely, April 2, 1982  6:28 PM @ TridentInit elim use of U0400. Last Edited: Neely, December 11, 1981  9:59 AM Eliminated mapZap subr. Last Edited: Neely, November 13, 1981  3:47 PM Added Trident Switch. Last Edited: Jarvis, March 21, 1981  8:39 AM Created: Jarvis, November 12, 1980}Reserve[ProtectStart, ProtectFence], Reserve[0FE0, 0FFF];	{save room for boot kernel}{IO page offsets}Set[DPYCtlWord, 0EC];  {8000=&gt; turn display off}Set[realBankCnt, 090];Set[realBankCntM1, Sub[realBankCnt, 1]];SetTask[0], StartAddress[go];go:	{MCtl &larr;} rB{&larr; 8002h} &larr;  RRot1 5, CANCELBR[$, 0F],	c1;	IOPCtl&larr; 0,	c2;IfGreater[Config,1,SkipTo[TridentInit],];	KCtl&larr; 0,	c3;  {SAx000}SkipTo[NoTridentInit];TridentInit!	RCnt &larr; 0F,	c3;  {Trident}	KCtl &larr; RCnt LRot12,	c1;  {Trident}	acR &larr; 4,	c2;  {Trident}	KCmd &larr; acR LRot8,	c3;  {Trident}NoTridentInit!	DCtl&larr; 3,	c1; {display black, enable task}	PCtl&larr; 0,	c2;	EICtl&larr; 0,	c3;	EOCtl&larr; 0,	c1;	acR&larr; 40,	c2;	acR&larr; acR LRot8,	c3;	,	c1;	MCtl{&larr; 8002h} &larr; rB, rB &larr; 4{21 bit real mem},	c2;	Noop{Bank &larr; rB}, 	c3;	acR&larr; uDiagnostic,	c1;	[]&larr; acR{uDiagnostic} - 1, ZeroBr,	c2;	Q &larr; 55{Mesa}, BRANCH[qMBoot, qLBoot],	c3;qLBoot:	[]&larr; Q xor uLispBootMsg, ZeroBr,	c1;	Noop, BRANCH[rLBoot, rMBoot],	c2;rMBoot:	uDiagnostic&larr; 0, GOTO[qMBoot],	c3;rLBoot:	Noop,	c3;qMBoot:	rB &larr; 0AA{Lisp},	c1;	uLispBootMsg &larr; rB,	c2;	Noop, GOTO[mapInit],	c3;{map initialization goes on during this interval}mapRet:{clear all but the first two pages of bank 0}	acR&larr; 0,	c2;	passTraps&larr; acR,	c3;	rD&larr; 2,	c1;	rD&larr; rD LRot8,	c2;	rDrh&larr; 0,	c3;clear:	MAR&larr; [rDrh, rD+0],	c1;	MDR&larr; acR, rD&larr; rD+1, ZeroBr,	c2;	BRANCH[clear, $],	c3;	Noop,	c1;	acR&larr; 0FF+1,	c2;	uBootStart&larr; acR, GOTO[OnceOnlyInit],{%}	c3;trapIt:	Noop, GOTO[trapIt],	c*;{OnceOnlyInit transfers control to DoneOnceOnlyInit.  DoneOnceOnlyInit lives in the device specific initial microcode.  When that finishes, control passes to exitToEmulator.}exitToEmulator:	Noop,	c1, at[0F, 10, subrRet];	rErh &larr; IOPageHigh,	c2;{make sure the display is off when the germ starts}DPYOff:	acR&larr; RShift1 0, SE&larr; 1,	c3; {acR&larr; 8000}	rE&larr; uIOPage,	c1; {IOPage real address}	rB&larr; 0,	c2;	rBrh&larr; 0,	c3;	MAR&larr; [rErh, IOPage.DSCB.syncCmd+0],	c1;	MDR&larr; acR,	c2;enableIOP:	Noop,	c3;	MAR&larr; [rBrh, 0+0],	c1;	MDR&larr; 0FF,	c2;	Noop,	c3;	MAR&larr; [rBrh, 0+1],	c1;	MDR&larr; uBootStart, CANCELBR[$, 0],	c2;	IOPCtl&larr; IOPInMode, GOTOABS[IdleLoc],	c3;{subroutines and end matter}{Map initialization -- Sets up map and leaves next available page in topPage.  Start looking for pages before 768K, i.e., below bank 0C.  Does not map any pages in bank 0.Beware -- clobbers the first word of each page in bank 0 even though you don't mean it!!!!!!!!!!!!!!!!!!!!!!!!Write page number in the first word of each page.  Go through memory top down to give lower addresses precedenceRegister usageacR	page numberrB	memory address registerrC	temporaryrD	temporaryrE	next available page}	mapInit:	rBrh&larr; realBankCnt{C}, {start in bank 90{B}}	c1;	rB{0}&larr; 0,	c2; {address within bank}	passTraps&larr; acR xor ~acR,	c3; {catch faults}	acR&larr; realBankCnt,{start in bank 90{0F}{B}}	c1;	acR&larr; acR LRot8, GOTO[mark1],	c2; {page counter}{mark the first word of each page with its page number}markPages:	MAR&larr; [rBrh, rB+0],	c1;	MDR&larr; acR, ZeroBr,	c2;mark1:	acR&larr; acR-1, {NegBr,} BRANCH[$, mapBuild1],	c3; {written all pages?}	rC&larr; 0FF+1, {BRANCH[$, mapBuild],}	c1;	rC&larr; rB-rC, CarryBr,	c2;	rB&larr; rC, BRANCH[$, markPages],	c3;	rB&larr; rBrh,	c1;	rB&larr; rB-1,	c2;	rBrh&larr; rB LRot0,	c3;	rB&larr; rC,	c1;	Noop,	c2;	GOTO[markPages],	c3;mapBuild:	Noop,	c2;	Noop,	c3;mapBuild1:	rBrh&larr; 1,	c1;	rC&larr; rCrh&larr; 1,	c2;	rB&larr; 0,	c3;{make all pages vacant}	MAR&larr; [rBrh, rB+0],	c1;	MDR&larr; vacant,	c2;	acR&larr; mapPages,	c3;	acR&larr; acR LRot8, L0&larr; 0A,	c1;	acR&larr; acR-1, CALL[BLT3],	c2;	{Mesa 11:}{Set up the rE pair with the real address of the virtual memory map and the rB pair with the real address of the first location to be mapped.  acR must contain the page number of the first real page to be mapped.}	rErh &larr; MapRealAddrHigh,				c1, at[0A, 10, subrRet];	rE &larr; MapRealAddrLow,				c2;	rBrh &larr; rB &larr; FirstRealPageToMapHigh, 		c3; 		acR &larr; rB LRot8, {construct page number in acR}	c1;	rC &larr; FirstRealPageToMap, 			c2;	rB &larr; rC LRot8,					c3;		Q &larr; uDiagnostic, c1;  	[] &larr; Q - 1, ZeroBr, {uD=1/Lisp} c2;	rD &larr; 0C{smallMem}, BRANCH[Smallmem,Bigmem], c3;	Smallmem:acR &larr; acR or rC,				c1;	GOTO[mapLoop3],					c2;Bigmem: acR &larr; acR or rC, c1;	rD &larr; realBankCnt,GOTO[mapLoop3], c2;{Check if the page has its own page number in the first location of the page.}mapLoop3:	Noop,						c3;	mapLoop1:	MAR&larr; [rBrh, rB+0],				c1;	Noop,						c2;	rC &larr; MD, {double bit error possible here}	c3;		[] &larr; rC xor acR, ZeroBr,			c1;	rC &larr; IOPageHigh, BRANCH[nextReal3, $],		c2;{Check if this is the page number of the IOPage.  If so, then do not map this real page yet.  Go on to the next real page.}	rC &larr; rC LRot8,					c3;		rC &larr; rC or IOPage,				c1;	[] &larr; rC xor acR, ZeroBr,			c2;	rC &larr; IOPageVirtual, BRANCH[NotIOPageReal, IsIOPageReal],	c3;	IsIOPageReal:	Noop,						c1;	GOTO[nextReal3],					c2;{Check if this is the virtual map entry for the IOPage.  If so, map the IOPage to this map entry.  Do not increment the real page number.}NotIOPageReal:	[] &larr; rC xor rE, NZeroBr,			c1;	Noop, BRANCH[$, NotIOPageVirt],			c2;			MapIOPage:	rC &larr; IOPage,					c3;	rC &larr; IOPage,					c1;	rC &larr; rC LRot8,					c2;	rC &larr; rC or IOPageHigh,				c3;	MAR&larr; [rErh, rE + 0],				c1;	MDR&larr; rC or present,				c2;	rE &larr; rE + 1, GOTO[mapLoop1],			c3;	{Map this page in.}NotIOPageVirt:	topPage&larr; rB,					c3;		rB&larr; rB or rBrh,					c1;	rC&larr; rB,						c2;	rB&larr; topPage,					c3;		MAR&larr; [rErh, rE + 0],				c1;	MDR&larr; rC or present,				c2;	rE &larr; rE + 1, GOTO[nextReal1],			c3;nextReal3:	Noop,						c3;nextReal1:	acR &larr; acR + 1, GOTO[IncReal],			c1;nextReal:	Noop,						c1;IncReal:	rC &larr; 0FF + 1,					c2;	rC&larr; rB+rC, CarryBr,				c3;		rB&larr; rBrh, BRANCH[$, nextBank],			c1;	rB&larr; rC, GOTO[mapLoop3],				c2;	nextBank:	rB&larr; rB+1,					c2;	[]&larr; rB xor rD{maxbanktocheck}, ZeroBr,	c3;		rBrh&larr; rB LRot0, BRANCH[$, clearMem2],		c1;	rB&larr; rC, GOTO[mapLoop3],				c2;	{clear all mapped pages}clearMem2:	Noop,	c2;clearMem3:	Noop,	c3;clearMem:	topPage&larr; rE,	c1; {save away}	rE&larr; 0,	c2; {word offset}	rD&larr; 0,	c3; {source of zero}	passTraps&larr; rD, {die on double bit errors}	c1;	Noop,	c2;	Noop,	c3;clearLoop:	MAR&larr; [rErh, rE+0],	c1; {read the map}	rC&larr; 0,	c2;	acR&larr; MD,	c3;	rB&larr; acR {and 0F},	c1;	rBrh&larr; rB LRot0,	c2;	rB&larr; acR and ~0FF,	c3;{write into every word of the page}clearPage:	MAR&larr; [rBrh, rC+0],	c1;	MDR&larr; rD, rC&larr; rC+1, PgCarryBr,	c2;	acR&larr; topPage, BRANCH[clearPage, $],	c3;	rE&larr; rE+1,	c1;	[]&larr; rE xor acR, ZeroBr,	c2; {compare to topPage}	BRANCH[clearLoop, $],	c3;	GOTO[mapRet],	c1;{trap catcher, gets here with rC&larr; RRot1 ErrnIBnStkp}error:	Xbus&larr; rC LRot0, XwdDisp,	c2, at[ErrorHandlerLoc];	DISP2[errorType],	c3;	GOTO[death], {control store parity error}	c1, at[0, 4, errorType];{moved to NewInit for big VM test:	Xbus&larr; MStatus, XLDisp, GOTO[memFault],	c1, at[1, 4, errorType];}	GOTO[death], {stack error}	c1, at[2, 4, errorType];	GOTO[death], {instruction buffer empty}	c1, at[3, 4, errorType];death:	GOTO[death],	c*;memFault:	BRANCH[death, $, 1],	c2; {map out of bound?}	GOTO[nextReal],	c3; {no, double bit error}{block transfer, takes count in acR, from in rB, and to in rC, returns first word past from block in rE}BLT2:	Noop,	c2;BLT3:	Noop,	c3;BLT:	MAR&larr; [rBrh, rB+0],	c1;	[]&larr; acR, ZeroBr,	c2;	rE&larr; MD, BRANCH[$, endBLT],	c3;	MAR&larr; [rCrh, rC+0],	c1;	MDR&larr; rE,	c2;	acR&larr; acR-1,	c3;	rB&larr; rB+1,	c1;	rC&larr; rC+1,	c2;	GOTO[BLT],	c3;endBLT:	Noop,	c1;endBLT1:	pRet0,	c2;endBLT2:	RET[subrRet],	c3;{swaps two locations in memory, takes address in rE and rB, clobbers acR}memSwap2:	Noop,	c2;memSwap3:	Noop,	c3;memSwap:	MAR&larr; [rErh, rE+0],	c1;	Noop,	c2;	acR&larr; MD,	c3;	MAR&larr; [rBrh, rB+0],	c1;	MDR&larr; acR,	c2;	acR&larr; MD,	c3;	MAR&larr; [rErh, rE+0],	c1;	MDR&larr; acR, pRet0,	c2;	RET[subrRet],	c3;	{E N D}</pre>
  </body>
</html>
