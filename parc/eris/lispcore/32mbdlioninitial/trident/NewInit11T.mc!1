{NewInit11T.mcLichtenberg 13-Jul-84 18:42:06 changed to initialize both versions of u1FFFLast modifiedby don:       9-Sep-83  9:51:57Created by don:   2-Sep-83 13:38:39Purcell  1-Jul-84 23:23:09 disabled writes to IOPage which moves from init{2000} to lisp{14000}}{SetTask[0];}RegDef[uLisp1FFF,U,2E];   {Lisp's u1FFF}Set[bigVMrefFlg, 75'b];Set[InitVersion, 5];{	deleted initialization of the following U registers:		uPcBreak		uValHigh  --  reinserted for Intermezzo compatability		unboundPvar		unboundFvar		u3FF  --  reinserted for Intermezzo compatability		u3FFF  --  reinserted for Intermezzo compatability	added initialization of the following U registers:		uSTATE		uDTDbase		uInitVersion	added test of large VM:		result to INTERFACEbasePage + bigVMrefFlg}StartNewInit:	uRx _ Rx,	c1;	UQSave _ Q,	c2;	Q _ rhRx,	c3;	UGsave _ Q,	c1;	Rx _ Rx xor ~Rx,	c2;	uStkLimO _ Rx,	c3;	{can delete these 3 clicks eventually --- for compatability with Intermezzo}	Rx _ VALspace,	c1;	uValHigh _ Rx,	c2;	Rx _ 3,	c3;	Rx _ Rx LRot8,	c1;	Rx _ Rx or 0FF,	c2;	u3FF _ Rx,	c3;	Rx _ Rx LRot4,	c1;	Rx _ Rx or 0F,	c2;	u3FFF _ Rx,	c3;	Rx _ InitVersion,	c1;	uInitVersion _ Rx,	c2;	,	c3;	Rx _ DTDbasePage,	c1;	Rx _ Rx LRot8,	c2;	uDTDbase _ Rx,	c3;	uSTATE _ 0,	c1;	uWP _ 0,	c2;	uWDC _ 0{uWDC inited by mesaInit},	c3;	Rx _  ~0FD,	c1;	Rx _ Rx LRot8,	c2;	uBfResidualRhmask _ Rx{2FF},	c3;	Rx _  0A0,	c1;	Rx _ Rx LRot8,	c2;	uFreeStackBlock _ Rx{0A000},	c3;	Rx _  0FF + 1,	c1;	uFxNoPushReturn _ Rx{100h},	c2;	Rx _  LShift1(Rx + Rx), SE_0,	c3;	uFxInCall _ Rx{400h},	c1;	Rx _  7F,	c2;	u7F _ Rx{7F},	c3;	Rx _  ~0FF,	c1;{OK}	u0FF _ ~Rx{~0FF},	c2;	uFF00 _  Q _ Rx{~0FF},	c3;	Rx _ Q{0FF00} or 1,	c1;	Rx _ Rx LRot8,	c2;	u1FF _ Rx{1FF},	c3;	Rx _ Q{0FF00} or 3,	c1;	Rx _ Rx LRot8,	c2;	uTT3FF _ Rx{3FF},	c3;	Rx _ Q{0FF00} or 0F,	c1;	Rx _ Rx LRot8,	c2;	u0FFF _ Rx{0FFF},	c3;	Rx _ Q{0FF00} or 1F,	c1;	Rx _ Rx LRot8,	c2;	u1FFF _ Rx{1FFF},	c3;	uLisp1FFF {called u1FFF in lisp code} _ Rx, c1;	, c2;	, c3;	Rx _ Q{0FF00} or 3F,	c1;	Rx _ Rx LRot8,	c2;	uTT3FFF _ Rx{3FFF},	c3;	Rx _ Q{0FF00} or 7F,	c1;	Rx _ Rx LRot8,	c2;	u7FFF _ Rx{7FFF},	c3;	Rx _ Q{0FF00} or 7,	c1;	Rx _ Rx LRot8,	c2;	u7FF _ Rx{7FF},	c3;	uLispOptions _ 0,	c1;	Rx _ Rx xor 1,	c2;	u7FE _ Rx{7FE},	c3;	Rx _ 80,	c1;	Rx _  Rx LRot8,	c2;	uBFmark _ Rx{8000},	c3;{compliance: using uSTACKspace with duplicated high byte for bind ptr}	Rx _ STACKspace,	c1;	Rx _ Rx LRot8 or Rx,	c2;	uSTACKspace _ Rx,	c3;	Rx _ 0C0,	c1;	Rx _  Rx LRot8,	c2;	uFXmark _ Rx{C000},	c3;	Set[UFNTablePageHalf, Rshift[UFNTablebase, 9]];	Rx _  UFNTablePageHalf,	c1;	Rx _  Rx LRot8,	c2;	uUFNTableBaseHalf _ Rx,	c3;bigVMtest:	Rx _ 5,	c1;	passTraps _ Rx,	c2;	Rx _ rhRx _ 0FF,	c3;	Map _ [rhRx,Rx],	c1;{cause trap if bigVM not supported}	,	c2;	Rx _ MD, GOTO[bigVMok],	c3;bigVMok:	rhRx _ INTERFACEspace,	c1;	Rx _ INTERFACEbasePage,	c2;	Rx _ Rx LRot8,	c3;		Map{InterfacePage} _ [rhRx, Rx],	c1;	passTraps _ 0,	c2;	rhRx _ Rx _ MD,	c3;	MAR _ [rhRx, bigVMrefFlg  + 0], c1;	MDR _ 1 {true}, c2;	GOTO[uInitdone], c3;{	in case of map fault come here }	at[1, 4, errorType],	Rx _ passTraps,	c1;	Ybus _ Rx xor 5, ZeroBr,	c2;	BRANCH[notmytrap, uInitdone],	c3;notmytrap:	Xbus_ MStatus, XLDisp, GOTO[memFault],	c1;uInitdone:	Rx _ uRx,	c1;	Q _ UQSave,	c2;	rhRx _ UGsave, GOTO[BackFromNewInit],	c3;	{ E N D }