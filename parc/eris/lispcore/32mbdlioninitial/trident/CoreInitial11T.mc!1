{File name:  xCoreInitial11.mc Last Edited:  9-Jan-85  8:52:57 Lichtenberg - Remove junk  Description: 2MB Purcell Core of the initial microcode booting sequence, Last Edited: Lichtenberg 19-Jul-84  0:21:27 4mb mem stuff for Mesa 11 Last Edited: Purcell    2-Jul-84  2:38:37 Mesa 11 upgrades to 27-Sep-83 Last Edited: Purcell   2-Mar-84  5:16:02 remove Bank _ 4Last Edited: Purcell 15-Feb-84  1:29:59 recognize 4mb Last Edited: Purcell February 6, 1984  12:29 PM MCtl _ 8002h or xx Last Edited: Purcell January 19, 1984  7:25 PM Mesa ignore xtra mem Last Edited: Purcell January 16, 1984  6:35 PM test for 4MB Last Edited: Purcell January 4, 1984  6:46 PM Bank _ 4{21 bit real mem} Last Edited: Purcell December 30, 1983  11:17 AM MCtl _ 2.  Last Edited: Purcell December 29, 1983  5:00 PM 3-8MB mem.  Last Edited: Purcell December 27, 1983  9:14 PM 2MB mem.  Last Edited: Neely, April 2, 1982  6:28 PM @ TridentInit elim use of U0400. Last Edited: Neely, December 11, 1981  9:59 AM Eliminated mapZap subr. Last Edited: Neely, November 13, 1981  3:47 PM Added Trident Switch. Last Edited: Jarvis, March 21, 1981  8:39 AM Created: Jarvis, November 12, 1980}Reserve[ProtectStart, ProtectFence], Reserve[0FE0, 0FFF];	{save room for boot kernel}{IO page offsets}Set[DPYCtlWord, 0EC];  {8000=> turn display off}Set[realBankCnt, 090];Set[realBankCntM1, Sub[realBankCnt, 1]];SetTask[0], StartAddress[go];go:	{MCtl _} rB{_ 8002h} _  RRot1 5, CANCELBR[$, 0F],	c1;	IOPCtl_ 0,	c2;IfGreater[Config,1,SkipTo[TridentInit],];	KCtl_ 0,	c3;  {SAx000}SkipTo[NoTridentInit];TridentInit!	RCnt _ 0F,	c3;  {Trident}	KCtl _ RCnt LRot12,	c1;  {Trident}	acR _ 4,	c2;  {Trident}	KCmd _ acR LRot8,	c3;  {Trident}NoTridentInit!	DCtl_ 3,	c1; {display black, enable task}	PCtl_ 0,	c2;	EICtl_ 0,	c3;	EOCtl_ 0,	c1;	acR_ 40,	c2;	acR_ acR LRot8,	c3;	,	c1;	MCtl{_ 8002h} _ rB, rB _ 4{21 bit real mem},	c2;	Noop{Bank _ rB}, 	c3;	acR_ uDiagnostic,	c1;	[]_ acR{uDiagnostic} - 1, ZeroBr,	c2;	Q _ 55{Mesa}, BRANCH[qMBoot, qLBoot],	c3;qLBoot:	[]_ Q xor uLispBootMsg, ZeroBr,	c1;	Noop, BRANCH[rLBoot, rMBoot],	c2;rMBoot:	uDiagnostic_ 0, GOTO[qMBoot],	c3;rLBoot:	Noop,	c3;qMBoot:	rB _ 0AA{Lisp},	c1;	uLispBootMsg _ rB,	c2;	Noop, GOTO[mapInit],	c3;{map initialization goes on during this interval}mapRet:{clear all but the first two pages of bank 0}	acR_ 0,	c2;	passTraps_ acR,	c3;	rD_ 2,	c1;	rD_ rD LRot8,	c2;	rDrh_ 0,	c3;clear:	MAR_ [rDrh, rD+0],	c1;	MDR_ acR, rD_ rD+1, ZeroBr,	c2;	BRANCH[clear, $],	c3;	Noop,	c1;	acR_ 0FF+1,	c2;	uBootStart_ acR, GOTO[OnceOnlyInit],{%}	c3;trapIt:	Noop, GOTO[trapIt],	c*;{OnceOnlyInit transfers control to DoneOnceOnlyInit.  DoneOnceOnlyInit lives in the device specific initial microcode.  When that finishes, control passes to exitToEmulator.}exitToEmulator:	Noop,	c1, at[0F, 10, subrRet];	rErh _ IOPageHigh,	c2;{make sure the display is off when the germ starts}DPYOff:	acR_ RShift1 0, SE_ 1,	c3; {acR_ 8000}	rE_ uIOPage,	c1; {IOPage real address}	rB_ 0,	c2;	rBrh_ 0,	c3;	MAR_ [rErh, IOPage.DSCB.syncCmd+0],	c1;	MDR_ acR,	c2;enableIOP:	Noop,	c3;	MAR_ [rBrh, 0+0],	c1;	MDR_ 0FF,	c2;	Noop,	c3;	MAR_ [rBrh, 0+1],	c1;	MDR_ uBootStart, CANCELBR[$, 0],	c2;	IOPCtl_ IOPInMode, GOTOABS[IdleLoc],	c3;{subroutines and end matter}{Map initialization -- Sets up map and leaves next available page in topPage.  Start looking for pages before 768K, i.e., below bank 0C.  Does not map any pages in bank 0.Beware -- clobbers the first word of each page in bank 0 even though you don't mean it!!!!!!!!!!!!!!!!!!!!!!!!Write page number in the first word of each page.  Go through memory top down to give lower addresses precedenceRegister usageacR	page numberrB	memory address registerrC	temporaryrD	temporaryrE	next available page}	mapInit:	rBrh_ realBankCnt{C}, {start in bank 90{B}}	c1;	rB{0}_ 0,	c2; {address within bank}	passTraps_ acR xor ~acR,	c3; {catch faults}	acR_ realBankCnt,{start in bank 90{0F}{B}}	c1;	acR_ acR LRot8, GOTO[mark1],	c2; {page counter}{mark the first word of each page with its page number}markPages:	MAR_ [rBrh, rB+0],	c1;	MDR_ acR, ZeroBr,	c2;mark1:	acR_ acR-1, {NegBr,} BRANCH[$, mapBuild1],	c3; {written all pages?}	rC_ 0FF+1, {BRANCH[$, mapBuild],}	c1;	rC_ rB-rC, CarryBr,	c2;	rB_ rC, BRANCH[$, markPages],	c3;	rB_ rBrh,	c1;	rB_ rB-1,	c2;	rBrh_ rB LRot0,	c3;	rB_ rC,	c1;	Noop,	c2;	GOTO[markPages],	c3;mapBuild:	Noop,	c2;	Noop,	c3;mapBuild1:	rBrh_ 1,	c1;	rC_ rCrh_ 1,	c2;	rB_ 0,	c3;{make all pages vacant}	MAR_ [rBrh, rB+0],	c1;	MDR_ vacant,	c2;	acR_ mapPages,	c3;	acR_ acR LRot8, L0_ 0A,	c1;	acR_ acR-1, CALL[BLT3],	c2;	{Mesa 11:}{Set up the rE pair with the real address of the virtual memory map and the rB pair with the real address of the first location to be mapped.  acR must contain the page number of the first real page to be mapped.}	rErh _ MapRealAddrHigh,				c1, at[0A, 10, subrRet];	rE _ MapRealAddrLow,				c2;	rBrh _ rB _ FirstRealPageToMapHigh, 		c3; 		acR _ rB LRot8, {construct page number in acR}	c1;	rC _ FirstRealPageToMap, 			c2;	rB _ rC LRot8,					c3;		Q _ uDiagnostic, c1;  	[] _ Q - 1, ZeroBr, {uD=1/Lisp} c2;	rD _ 0C{smallMem}, BRANCH[Smallmem,Bigmem], c3;	Smallmem:acR _ acR or rC,				c1;	GOTO[mapLoop3],					c2;Bigmem: acR _ acR or rC, c1;	rD _ realBankCnt,GOTO[mapLoop3], c2;{Check if the page has its own page number in the first location of the page.}mapLoop3:	Noop,						c3;	mapLoop1:	MAR_ [rBrh, rB+0],				c1;	Noop,						c2;	rC _ MD, {double bit error possible here}	c3;		[] _ rC xor acR, ZeroBr,			c1;	rC _ IOPageHigh, BRANCH[nextReal3, $],		c2;{Check if this is the page number of the IOPage.  If so, then do not map this real page yet.  Go on to the next real page.}	rC _ rC LRot8,					c3;		rC _ rC or IOPage,				c1;	[] _ rC xor acR, ZeroBr,			c2;	rC _ IOPageVirtual, BRANCH[NotIOPageReal, IsIOPageReal],	c3;	IsIOPageReal:	Noop,						c1;	GOTO[nextReal3],					c2;{Check if this is the virtual map entry for the IOPage.  If so, map the IOPage to this map entry.  Do not increment the real page number.}NotIOPageReal:	[] _ rC xor rE, NZeroBr,			c1;	Noop, BRANCH[$, NotIOPageVirt],			c2;			MapIOPage:	rC _ IOPage,					c3;	rC _ IOPage,					c1;	rC _ rC LRot8,					c2;	rC _ rC or IOPageHigh,				c3;	MAR_ [rErh, rE + 0],				c1;	MDR_ rC or present,				c2;	rE _ rE + 1, GOTO[mapLoop1],			c3;	{Map this page in.}NotIOPageVirt:	topPage_ rB,					c3;		rB_ rB or rBrh,					c1;	rC_ rB,						c2;	rB_ topPage,					c3;		MAR_ [rErh, rE + 0],				c1;	MDR_ rC or present,				c2;	rE _ rE + 1, GOTO[nextReal1],			c3;nextReal3:	Noop,						c3;nextReal1:	acR _ acR + 1, GOTO[IncReal],			c1;nextReal:	Noop,						c1;IncReal:	rC _ 0FF + 1,					c2;	rC_ rB+rC, CarryBr,				c3;		rB_ rBrh, BRANCH[$, nextBank],			c1;	rB_ rC, GOTO[mapLoop3],				c2;	nextBank:	rB_ rB+1,					c2;	[]_ rB xor rD{maxbanktocheck}, ZeroBr,	c3;		rBrh_ rB LRot0, BRANCH[$, clearMem2],		c1;	rB_ rC, GOTO[mapLoop3],				c2;	{clear all mapped pages}clearMem2:	Noop,	c2;clearMem3:	Noop,	c3;clearMem:	topPage_ rE,	c1; {save away}	rE_ 0,	c2; {word offset}	rD_ 0,	c3; {source of zero}	passTraps_ rD, {die on double bit errors}	c1;	Noop,	c2;	Noop,	c3;clearLoop:	MAR_ [rErh, rE+0],	c1; {read the map}	rC_ 0,	c2;	acR_ MD,	c3;	rB_ acR {and 0F},	c1;	rBrh_ rB LRot0,	c2;	rB_ acR and ~0FF,	c3;{write into every word of the page}clearPage:	MAR_ [rBrh, rC+0],	c1;	MDR_ rD, rC_ rC+1, PgCarryBr,	c2;	acR_ topPage, BRANCH[clearPage, $],	c3;	rE_ rE+1,	c1;	[]_ rE xor acR, ZeroBr,	c2; {compare to topPage}	BRANCH[clearLoop, $],	c3;	GOTO[mapRet],	c1;{trap catcher, gets here with rC_ RRot1 ErrnIBnStkp}error:	Xbus_ rC LRot0, XwdDisp,	c2, at[ErrorHandlerLoc];	DISP2[errorType],	c3;	GOTO[death], {control store parity error}	c1, at[0, 4, errorType];{moved to NewInit for big VM test:	Xbus_ MStatus, XLDisp, GOTO[memFault],	c1, at[1, 4, errorType];}	GOTO[death], {stack error}	c1, at[2, 4, errorType];	GOTO[death], {instruction buffer empty}	c1, at[3, 4, errorType];death:	GOTO[death],	c*;memFault:	BRANCH[death, $, 1],	c2; {map out of bound?}	GOTO[nextReal],	c3; {no, double bit error}{block transfer, takes count in acR, from in rB, and to in rC, returns first word past from block in rE}BLT2:	Noop,	c2;BLT3:	Noop,	c3;BLT:	MAR_ [rBrh, rB+0],	c1;	[]_ acR, ZeroBr,	c2;	rE_ MD, BRANCH[$, endBLT],	c3;	MAR_ [rCrh, rC+0],	c1;	MDR_ rE,	c2;	acR_ acR-1,	c3;	rB_ rB+1,	c1;	rC_ rC+1,	c2;	GOTO[BLT],	c3;endBLT:	Noop,	c1;endBLT1:	pRet0,	c2;endBLT2:	RET[subrRet],	c3;{swaps two locations in memory, takes address in rE and rB, clobbers acR}memSwap2:	Noop,	c2;memSwap3:	Noop,	c3;memSwap:	MAR_ [rErh, rE+0],	c1;	Noop,	c2;	acR_ MD,	c3;	MAR_ [rBrh, rB+0],	c1;	MDR_ acR,	c2;	acR_ MD,	c3;	MAR_ [rErh, rE+0],	c1;	MDR_ acR, pRet0,	c2;	RET[subrRet],	c3;	{E N D}