<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;LispCore>32mbdlioninitial>trident>TridentDlion11T.mc!1</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 8pt serif">{File name: TridentDLion11T.mc<br><br>Edited Lichtenberg 20-Jul-84 21:11:55 Big memory mods<br><br><br> Description: Large Disk Controller microcode, Version 1.0<br> Author:   S. Furman, J. Furst<br> Created: November 24, 1980  11:03 AM<br> Edited: Amy Fasnacht 11-Oct-83 15:26:53: Change IOPage references for moving of the IOPage<br> Edited: December 4, 1980  9:35 AM<br> Edited:  J. Furst,  December 6, 1980  1:46 PM<br> Edited:  J. Furst,  December 16, 1980  6:06 PM<br> Edited:  J. Furst, January 13, 1981  8:28 AM<br> Edited:  J. Furst, March 20, 1981  8:24 AM<br> Edited:  J. Furst,  May 19, 1981  9:32 AM<br> Edited: E. Neely December 8, 1981  7:24 AM - Make inProgress bit last change to IOCB<br>- Last IOCB bit added instead of Next IOCB Ptr = 0 if end of chain.<br>- Client Label field update aded after the data field is processed succsessfully (ULblWd5 register holds the value to bo updated.<br>- U0100 register was eliminated<br>Last Edited:  J. Furst,  June 1, 1981  5:34 PM<br>-The IOCB Operation Block changed to match the Operation portion of the Face.<br>The following changes were implemented in ucode:<br> - U-registers reassigned to match the Operation Block<br> - Initial IOCB displacement for IOCB xfer added (CDisplIOCB=1)<br> - Displacements within the Operation block changed to match the format<br> - ECC Syndrom moved to location IOCBPtr+3E  (CDisplECC changed to 3E)<br> - Pointer for Hdr Rd operation changed to IOCBPtr+CDisplDHdr (CDisplDHdr=0A0<br>The Trident Head is required to copy initially the Client Header into Disk Header locations.  <br>The Increment Data Pointer bit has to be copied into Data Ptr High bit position 7.<br>Last Edited:  J. Furst,  June 9, 1981  10:43 AM<br>  - Data xfer routines changed to accomodate 30 sectors.<br>Last Edited:  J. Furst,    July 20, 1981  8:16 AM<br>  - Last IOCB bit deleted (the Next IOCB Ptr = 0 indicates the last IOCB in the chain).<br>Last Edited:  J. Furst,  August 17, 1981  3:55 PM<br>  - ZeroPgCntTest changed from after memory UpdIOCBSec to before UpdIOCBSec.<br>  - Last word write into memory fixed.<br>Last Edited:  J. Furst,  August 19, 1981  9:01 AM<br>  - Clean-up: some unneeded statments in microcode deleted (RAdr &larr; RAdr +CDisplCCyl) in Hdr routines;<br>                       front and tail end of the data transfer routines rearranged.<br>  - Unnneded constants (CDisplCCyl and CECCRst) deleted from *.df.<br>  - TermIn signal to the disk is not required and as the consequence some of the U register values will change:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">from U1C00  to  U0C00<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">from U1400  to  U0400<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">from U1C04  to  U0C04<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">from U3C04  to  U2C04<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">from U3C05  to  U2C05<br>  This change effects the *.df and the initialization microcode.<br>Last Edited:  J. Furst,  August 19, 1981  5:11 PM<br>  - Problem with controller status update fixed.<br>Last Edited:  J. Furst,  August 22, 1981  10:38 AM<br>  - Reorientation on index added (if sector address =0 set WU: IndxFound, if sectror address not 0 set WU: SecFnd).<br>  - A new loop specially used for data field transfer is added.  This saves two microinstructions.<br>Last Edited:  J. Furst,  August 26, 1981  10:10 PM<br>  - Changed location of the  I* bit in IOCB.<br>  - Data Ptr Lo and Hi locations swapped in the IOCB.<br>Last Edited:  J. Furst,  September 1, 1981  8:15 PM<br>  - Delay added before transferring ECC.<br>Last Edited:  J. Furst,  September 6, 1981  10:21 AM<br>  - Corrected marginal head advance timing.<br>  - In FirstIOCBTst  routine  NZeroBr replaced with XRefBr to save microintructions.  As  a consequence CTstFirstIOCB is deleted.<br>Last Edited:  J. Furst,  September 15, 1981  1:56 PM<br>  - Shutting down the read and write circuitry after sector is done is changed.<br>Last Edited:  J. Furst,  December 8, 1981  2:12 PM<br>  - Corrected problem with RCnt rot by 12 in AnySIP +1 instruction.<br>Edited:  E Neely,  March 24, 1982  7:53 AM <br>  - Changed comments about value of CRetry and URetry to 90 headers <br>     before header not found.<br>Edited:  E Neely,  March 29, 1982  7:33 PM <br>  - Swapped HeadAdv + 3 and +4 to allow more time for KCmd. <br>  - @DskCheck changed GOTO[UpdUCStat] to GOTO[UpdUCStatDC]. <br>  - Near UpdUCStat: added UpdUCStatDC: RCnt &larr;6, GOTO[SetUCStat] . <br>Edited:  Forrest and J. Furst,  27-Apr-82 15:31:52 <br>  - Changed CANCELBR[$, 2] to CANCELBR[$, 1] IN XferHdrEr. <br>  - Increase delay between read-reset and write-set for lbl and data fields. <br>Edited:  Amy Fasnacht,  August 4, 1982August 4, 1982  1:52 PM  1:52 PM <br>  - Moved all references to IOPage into Dandelion.df. <br>Edited:  Neely,  31-Mar-83 12:21:03 <br>  - Added check for notReady after setHead because changing offset<br>    causes notReady. <br>Edited:  Neely,  11-May-83 13:46:57 <br>  - SetHead must be done AFTER seek in offset cases; so do it after seek always. <br>  <br><br>This microcode will not run properly without first beeing initialized.  The following U and Output registers have to be initialized by FileServerInit microcode: UStatMask (1E07), U0C00, U4000, UF001, U0400, U0100, U0C04, U2C04, U2C05, KCtl, and KCmd.<br>Initially, the microcode is in the dormant state.  Upon awakening, it constructs the pointer to the CSB array (table) and gets from there the virtual pointer of the first IOCB for Device 0. Validity of the IOCB is checked: if the IOCB pointed at by the designated pointer is a valid one; if not a new CSB address is constructed to poll the following device, etc.<br><br>----------------------------------------------------------------------------------------------------------------------------------------------------------------<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">                                                          Initilization<br>----------------------------------------------------------------------------------------------------------------------------------------------------------------<br>----------------------------------------------------------------Start of Code  -------------------------------------------------------------------------}<br><br>{The microcode starts at location CSBStart.  Upon this entry the indexing within the CSB array (in RCnt register) is set for device 0. There are two other entries into this section of code.  CSBNextDev: an entry after a Nill IOCB is found in CSB.  Upon this entry the pointer in CSB array is moved to next device.  The third entry CSBDevN is used after seek or recalibrate operation is issued to the disk.  It loads UDskAdr { 4*(disk address)}  into RCnt register to index the next device in CSB.  All this entries utilize a common section of code starting at locatin CSBStartC3, which sets the CSB real address for device 0 into RHAdr,,RAdr registers (RHAdr, RAdr &larr; 14001)  and then adds to this value the contents of RCnt register.<br>After the seek operation for a particular disk has been completed (attention from the disk) the physical disk address times 4 is loaded into RCnt register to fetch the IOCB again to start the data transfer operation for that device (SIP bit is equal to 1).}<br><br><br>CSBDevN:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UDskAdr, GOTO[CSBNextDevC2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br><br>CSBNextDev:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CLastDev</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>CSBNextDevC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt+CNextDev, GOTO[CSBStartC3]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br><br>CSBStart:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CLastDev, SetTask[4], StartAddress[CSBStart]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0F,10];<br>CSBStartC3:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; uIOPage</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{RAdr gets the low 16 bits of the real CSB address, then the value used to index the CSB array is added to it.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; IOPageHigh</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr+RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Test for last device (device# 4) in CSB array.  If not last device go into CSB array to get the IOCB virtual pointer for that device; if last device (it means first seeks to all devices have been issued) go to to test if any seek operations has been completed (AnySIP).}<br><br>CSBLastDevTest:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; RCnt xor RHCnt, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; U0C00, BRANCH[CSBNLastDev, CSBLastDev]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>CSBNLastDev:</span><span class="tab" val="77"></span><span style="font: 8pt serif">GOTO[GetIOCBPtr] </span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,CSBLastDev];<br>CSBLastDev:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0F, GOTO[AnySIP]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,CSBNLastDev];<br><br><br><br>{Load low 16 bits of the IOCB virtual pointer  from  the CSB array into RAdr register; set upper bits in RHAdr register to zero (IOCBs in first 64k of virtual space).}<br><br>GetIOCBPtr:</span><span class="tab" val="77"></span><span style="font: 8pt serif">MAR &larr; [RHAdr, RAdr + DiskCSBOffsetIOCB]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; 0, CANCELBR[$, 2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr&larr;MD</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{If NilI IOCB procced to the next device in CSB array (CSBNextDev); upon this entry load into RCnt the value to index the next device.  If good IOCB call MapVirt subroutine to get the real IOCB address for further use.}<br><br> </span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; RAdr, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">BRANCH[GoodIOCB, NilIOCB], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>GoodIOCB:</span><span class="tab" val="77"></span><span style="font: 8pt serif">CALL[MapVirt]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,10,NilIOCB];<br>NilIOCB:</span><span class="tab" val="77"></span><span style="font: 8pt serif">GOTO[CSBNextDev]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10,GoodIOCB];<br><br><br><br>{After return from MapVirt subroutine the real pointer is in RHAdr,,RAdr registers.  Store low 16 bits of IOCB address to USvAdrLo register for use in xfer and error processing routines.}<br><br>IOCBStart:</span><span class="tab" val="77"></span><span style="font: 8pt serif">USvAdrLo &larr; RAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,10,RetMap];<br><br><br><br>{Save high 2 bits of the IOCB real address in USvAdrHi register.  Reset the memory controller before starting the IOCB fetch operation.}<br><br>IOCBStartC1:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RHAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">USvAdrHi &larr; RAdr, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo, CALL[IOCBLoad]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,10];<br><br><br><br>{This routine is entered from CSB processing after recalibrate or seek operations to all disks have been issued, and after an operation defined by IOCB has been completed.  It tests for SIP for any disk.  If there is no SIP it resets FirmwareEn bit and goes to sleep.  If there is some seek in progress it prepares for any attention test for those disks which have SIP bits on (after seek or recal operation but not after reset offset has been issued).}<br><br>AnySIP:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USIP, NZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0,2,ChainedIOCB];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UF000, BRANCH[NoSIP, SomeSIP]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>NoSIP:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; U0400, GOTO[CSBStart]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,SomeSIP];<br>SomeSIP:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; ~KStatus and RAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,NoSIP];<br><br><br><br>{Determine which disks with SIP bit on has Attention active.  If none set WU: AnnyAtention and after WU go to take a new snapshot of disk status.   If there is an Attention then go to refetch the IOCB for that particular disk.   For multiple Attentions disk with lower address has higher priority.}<br><br>AttenTest:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; RAdr LRot8, XDisp</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CWUAnyAtt or RCnt, DISP4[Attention]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; RCnt LRot0, GOTO[AnySIP]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CDsk3, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CDsk2, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[2,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CDsk2, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[3,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CDsk1, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[4,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CDsk1, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[5,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CDsk1, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[6,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CDsk1, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[7,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[8,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[9,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0A,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0B,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0C,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0D,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0E,10,Attention];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0, GOTO[EndAtten]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0F,10,Attention];<br><br><br><br>{Set WU: FirmwareEn then go to CSB array to refetch the IOCB.}<br><br>EndAtten:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UF000</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CLastDev, GOTO[CSBStartC3]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br><br><br><br>{This is the return point from IOCB fetch in case of double memory error. Set memoryError bit in CStatus word.}<br><br>IOCBMemError:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CMemError, CANCELBR[DtMemErrorC3, 2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,10,RetMemEr];<br><br><br><br>{Here the opeation starts.  First select the disk; inProgress and goodCompletion bits will be set in IOCB in memory by the device Head and then copied into UCStat register.  Prepare to test for diskReady (onLine)}<br><br>OperStart:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UBitSignAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,10,RetNoMemEr];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CNotRdy</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Test for diskReady.  If not set both status words and then  flush the operation.  If yes proceed with operation.}<br><br>TestDskRdy:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; ~KStatus and RCnt, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">BRANCH[DskNotRdy, DskRdy]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>DskNotRdy:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[UpdUCStat]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,DskRdy];<br>DskRdy:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,DskNotRdy];<br><br><br><br>{Prepare to reset the Attention from the selected disk.  Attention is reset by setting the read circuitry: CntlTag and read bit (CRstAtt = read).}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; U0C00</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or CRstAtt, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; CCtlTag, CALL[TagSetRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,10];<br><br><br><br>{Set unconditionally WU: DskRdy in KCtl register.  If disk not ready the microcode will get dormant until disk goes ready.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UBitSignAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0,10,RetTagSetRst];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RAdr or CWURdy</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; RCnt LRot0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Load the bit significant disk address into the RAdr register (the ms nibble and the ls bit must be reset) in order to set and test the SIP bit of the selected disk.  Switch back to WU: FirmwareEn in c3.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~UF001</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr and RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UBitSignAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Test for SIP and set SIP bit for the selected disk.  In either case prepare to test for need to issue recalibrate.}<br><br>SIPTest:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; RAdr and USIP, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr or USIP, BRANCH[SkInProg, SkNotInProg]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>SkInProg:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UBitSignAdr, GOTO[SIPTstRecal]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,SkNotInProg];<br>SkNotInProg:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UBitSignAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,SkInProg];<br><br><br><br>{If SIP bit is 0 and the Recal bit is 1 issue recalibrate; if Recal bit is 0 go to issue a Seek, set SIP in c2.}<br><br>NotSIPTstRecal:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; RCnt and CTstRecal, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">USIP &larr; RAdr, BRANCH[NotSIPRecal, NotSIPNoRecal],</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>NotSIPRecal:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[RecalStart]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,NotSIPNoRecal];<br>NotSIPNoRecal:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CTstRecalEr, GOTO[SeekStart]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,NotSIPRecal];<br><br><br><br>{If SIP bit is a 1 and Recal bit is also 1 prepare for to test for Recal error and then go to issue Seek; if Recal bit is 0 (it gets reset in Seek routine) prepare to test for Seek error and then go to data xfer.}<br><br>SIPTstRecal:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; RCnt and CTstRecal, ZeroBr</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">USIP &larr; RAdr, BRANCH[SIPRecal, SIPNoRecal] ,c2;<br>SIPRecal:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CTstRecalEr, GOTO[SeekStart]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,SIPNoRecal];<br>SIPNoRecal:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CTstSkEr, GOTO[SetHead]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,SIPRecal];<br><br><br><br>{The recalibrate operation starts here.  It utilizes the TagSetRst subroutine with CtlTag and recal bit active.  It returns to FirstIOCBTest.}<br><br>RecalStart:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; U0C00</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or CRecal, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; CCtlTag, CALL[TagSetRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10];<br><br><br><br>{The seek operation starts here.  First test for recalibrate error.}<br><br>SeekStart:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; ~KStatus and RCnt, ZeroBr</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">BRANCH[RecalError, RecalOK], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>RecalError:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CRecalError, GOTO[UpdUCStatN]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br>RecalOK:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br>{Prepare CylAddr in RCnt and CylTag constant in RAdr for TagSetRst subroutine use and then call the TagSetRst subroutine to transfer this value to the disk.  Also switch KCtl.WU back to FirmwareEn.}<br><br>SeekIssue:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UCylAdr</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; CCylTag, pCall4</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UBitSignAdr, CALL[TagSetRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[4,10];<br><br><br><br>{After SetCylTag the microcode returns here.  Prepare to reset the Recalibrate bit in IOCB (memory only) and then go to BSAdrUpdate subroutine to do the actual writting.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UBitSignAdr</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[4,10,RetTagSetRst];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~CTstRecal, pCall4</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt and RAdr, CALL[BSAdrUpdate]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,10];<br><br><br><br>{Test if recalibrate had been issued before this seek operation. If yes go directly to test for Any Attention.  If no prepare to test for first IOCB in chain.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; UBitSignAdr and RCnt, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0,10,RetStatUpd];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UF001, BRANCH[RclBefSk, NoRclBefSk] </span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>RclBefSk:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr;0F, GOTO[AnySIP]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,NoRclBefSk];<br>NoRclBefSk:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,RclBefSk];<br><br><br><br>{If seek was not preceeded with a recalibrate then if this is the first IOCB in chain go to CSB processing [CSBDevN] to issue seeks for for all remaining disks in that particular queue; go to any Attention test otherwise.}<br><br>FirstIOCBTst:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Xbus &larr; UHdrOp, XRefBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[1,10,RetTagSetRst];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, BRANCH[NotFirstIOCB, FirstIOCB] </span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>NotFirstIOCB:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr;0F, GOTO[AnySIP]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,FirstIOCB];<br>FirstIOCB:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr;CLastDev, GOTO[CSBDevN]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,NotFirstIOCB];<br><br><br><br>{Here because SIP bit = 1 and Recal bit = 0.  First test for error after seek operation.  If error go to update the status words and flush the operation for this disk.  If OK , then call TagSetRst subroutine (RCnt &larr; HeadAddr+Offset, RAdr &larr; CHdTag constant for use in subroutine) to transfer head address and offset value (if any) to the disk.}<br><br>SetHead:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; ~KStatus and RCnt, ZeroBr</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UHdOffset, BRANCH[SeekError, SeekOK], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>SeekError:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CTstSkEr, GOTO[UpdUCStat]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[2,10];<br>SeekOK:</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; CHdTag, CALL[TagSetRst]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[3,10];<br><br><br>{After setHead the microcode returns here.  If setHead caused a change in the offset status, the disk goes not ready within approx 100ns for approx 2.5ms; otherwise it stays ready.  Set KCtl.WU to DskRdy so that after this click the microcode will remain dormant as long as the disk is notReady.  RHCnt gets the sector wake-up constant needed by xfer routines.}<br><br>{Note: TagSetRst returns with RAdr = UBitSignAdr.}<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RAdr or CWURdy</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[3,10,RetTagSetRst];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; RCnt LRot0, pCall4</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CWUSecFnd, CALL[XferSecStart]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10];<br><br><br>{Set the HdSel line for the disk in c1.  Transfer sector starts here with setting the disk Bus with head select constant.  RHAdr gets high 16 bits of IOCB real pointer in c2, and in c3 the CntlTag is set.}<br><br>XferSecStart:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; U0C04</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; USvAdrHi</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>XferSecStartC3:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; U2C04</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{After finishing a sector the microcode returns to this point.  Prepare to set WU: SectorFound/IndxFnd into KCtl (RHCnt is loaded with proper constant upon entry or in LastSecTest routine).}<br><br>XferSecLp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RHCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UBitSignAdr or RCnt, pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Set WU: SectorFound into KCtl and then return from the XferSecStart subroutine.  First time in the microcode returns to XferHdrPass1 to perform a 16-way dispatch on Hdr operation.  Reset SectorFnd and IdxFnd latches before exiting this click.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; RCnt LRot0, RET[RetSecStart]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br><br>XferHdrPass1:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Xbus &larr; UHdrOp, XDisp</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,10,RetSecStart];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">ClrKFlags, DISP4[Operation], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{First time in all unoriented operations (Hdr Noop, Wr, and Rd) call the FindHdr subroutine to get oriented on client address.    For verify operation call SecZrTest subroutine to set the proper wake-up.  Readjust the address for each operation, and after return from FindHdr set the sequencer into proper routine.  The HdrVrf operation in a case of an error will be retried 90 times before setting HdrNotFnd (URetry contains 90 at this point).  For Noop, Rd, and Vrf operation set a delay constant to raise the read gate in the drive.  For Wr operation write gate gets set immediatelly.}<br><br>HdrNoopPass1:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, CALL[FindHdr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[4,10,Operation];<br>HdrWrPass1:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, CALL[FindHdr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[5,10,Operation];<br>HdrRdPass1:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr+CDisplDHdr, CALL[FindHdr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[6,10,Operation];<br>HdrVrfPass1:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; UCurHdSec, CALL[SecZrTest]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[7,10,Operation];<br><br>HdrNoopRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UHCntl, pCall4, GOTO[HdrNoopRdVrf]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[4,10,RetFindHdr];<br>HdrWrRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UHCntl, pCall4, GOTO[HdrWrCont]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[5,10,RetFindHdr];<br>HdrRdRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UHCntl, pCall4, GOTO[HdrNoopRdVrf]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[6,10,RetFindHdr];<br>HdrVrfRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UHCntl, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[7,10,RetSecZrTest];<br><br>HdrNoopRdVrf:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CHDelRdSet, CALL[DelSetRd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10];<br>HdrWrCont:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CHDelWrSet, CALL[DelSetRd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10];<br><br><br><br>{NextHdrOp and NextHdrOpC3 are return points from XferSecStart subroutine after Hdr retry and after the data field has been processed (if PgCnt not 0).  The microcode performes a 4-way dispatch on HdrOp.  The only diferrence between this section of the code, and XferHdrPass1 is that at this time the operation is already oriented and the FindHdr subroutine is bypassed.}<br><br>NextHdrOp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Xbus &larr; UHdrOp, XDisp</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[2,10,RetSecStart];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">ClrKFlags, DISP4[HdrOper, 0C]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{The 4-way dispatch is performed here.  The microcode then merges with the "IOCB first pass" microroutines.}<br><br>HdrNoop:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[HdrNoopRet]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0C,10,HdrOper];<br>HdrWr:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[HdrWrRet]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0D,10,HdrOper];<br>HdrRd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr+CDisplDHdr, GOTO[HdrRdRet]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0E,10,HdrOper];<br>HdrVrf:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[HdrRdRet]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0F,10,HdrOper];<br><br><br><br>{Set the CtlTag and bus for all Hdr operations here. Prepare to set the DataReq WU in next click (RCnt was set with proper constant in the subroutine.}<br><br>HdrSetRdRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; UHCmd</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,10,RetDelSetRd];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UHCntl or RCnt, GOTO[HdrLoopDisp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Dispatch again on Hdr operation to determine which of the data Xfer loops to call.  Set the word count into RCnt register (2 for Hdr op) and the call the loop.  The sequencer generates always WordCount+1 DataReqs in order to exit the loop.}<br><br>HdrLoopDisp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Xbus &larr; UHdrOp, XDisp, GOTO[LoopDisp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>LblLoopDisp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Xbus &larr; ULblOp, XDisp, GOTO[LoopDisp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>DtLoopDisp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Xbus &larr; UDtOp, XDisp, GOTO[LoopDisp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br><br>LoopDisp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; RCnt LRot0, DISP4[CallLoop], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br><br>CallHdrNoop:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 2, CALL[NoopLp], ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[4,10,CallLoop];<br>CallHdrWrt:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 2, CALL[WrVrfLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[5,10,CallLoop];<br>CallHdrRd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 2, CALL[RdLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[6,10,CallLoop];<br>CallHdrVrf:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 2, CALL[WrVrfLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[7,10,CallLoop];<br><br><br><br>{This are the return points from loops.  The ClientLabel is starts at IOCBPtr+20, the DiskLabel starts at location IOCBPtr+30.  RCnt is loaded with a delay constant for use in DelRdRst subroutine, which control the read circuitry reset.  In c2 and c3 the IOCB pointer is set into RHAdr,, RAdr register pair to address one of the label areas in the IOCB.}<br><br>HdrNLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CHNRDelRdRst, GOTO[GetLblAdr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[4,10,RetXfrLp];<br>HdrWLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CHWVDelRdRst, GOTO[GetLblAdr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[5,10,RetXfrLp];<br>HdrRLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CHNRDelRdRst, GOTO[GetLblAdr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[6,10,RetXfrLp];<br>HdrVLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CHWVDelRdRst, GOTO[GetLblAdr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[7,10,RetXfrLp];<br><br>GetLblAdr:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; USvAdrHi, CALL[DelRdRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,10];<br><br><br><br>{Set the Hdr mask into RCnt for later use.  Perform a dispatch on label operation. RAdr gets the client label pointer.}<br><br>LblOpDISP:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UHMask</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0,10,RetDelRdRst];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Xbus &larr; ULblOp, XDisp</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr + CDisplClntLbl, DISP4[Operation]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{These are the dispatch points after the DISP on Lbl opeartion.  The sequencer had been set with proper Function code and in the case of disk read type of operations (OL code in IOCB = LblNoop, LblRd, LblVrf) RCnt gets the constant for delay set read.  The write is set immediatelly.  In case of LblRd operation the relative displacement (from client label) is added to RAdr to point to DskLbl area of the IOCB.  Test for header operation OK for label read operation if OK call DelSetRd subroutine in next click.}<br><br>LblNoop:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[LblNRVCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[08,10,Operation];<br>LblWr:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~KTest and RCnt, NZeroBr,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">  GOTO[LblWrCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[09,10,Operation];<br>LblRd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr + CRelDisplDskLbl,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">  GOTO[LblNRVCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0A,10,Operation];<br>LblVrf:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[LblNRVCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0B,10,Operation];<br><br>LblNRVCont:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~KTest and RCnt, NZeroBr</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; ULCntl,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">  BRANCH[HdrOpOKRd, HdrOpErrRd], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Call DelSetRd subroutine to raise the disk read circuitry.}<br><br>HdrOpOKRd:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CLDelRdSet, ZeroBr,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">  CALL[DelSetRdC2]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0,10,HdrOpErrRd];<br><br><br><br>{Test for header operation OK for label write operation.  If OK go to raise disk write circuitry without a delay.}<br><br>LblWrCont:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; ULCntl,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">  BRANCH[HdrOpOKWr, HdrOpErrWr], L4 &larr; 0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>HdrOpOKWr:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; ULCmd, L4Disp, CALL[EndDelSetRd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,HdrOpErrWr];<br>HdrOpErrWr:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO [HdrOpErrWrCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,HdrOpOKWr];<br><br><br>{In case of any header operation error store the controller status in UCStat register (this is needed because the laches are reset by LdSequencer signal).}<br><br>HdrOpErrRd:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or 2, GOTO[HdrErrC2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[1,10,HdrOpOKRd];<br>HdrOpErrWrCont:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or 2</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif"><br>HdrErrC2:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UCStat &larr; RCnt</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{RCnt register gets &rsquo;F&rsquo; to strip the FirstIOCB bit in UHdrOp register and go to test for verify.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0F</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UHdrOp and RCnt, GOTO[TestForVrf],c2;<br><br><br><br>{This is the end of delay.  Set the CtlTag and Bus for Lbl operation.  Prepare to set DataReq WU for Lbl loops and then go to do the DISP for Noop, Rd, WrVrf loops.}<br><br>LblSetRd:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; ULCmd</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,10,RetDelSetRd];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ULCntl or RCnt, GOTO[LblLoopDisp],c3;<br><br><br><br>{This are the dispatch points to call the loops for Lbl operation.  Set hte Lbl Word Count into RCnt register.}<br><br>CallLblNoop:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0A, CALL[NoopLp], ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[8,10,CallLoop];<br>CallLblWrt:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0A, CALL[WrVrfLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[9,10,CallLoop];<br>CallLblRd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0A, CALL[RdLp],   ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0A,10,CallLoop];<br>CallLblVrf:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0A, CALL[WrVrfLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0B,10,CallLoop];<br><br><br><br>{This are the return points from loops.  RHCnt reegister is loaded with constant to delay the disk read circuitry after label operations.  In c2 and c3 load the RHAdr,, RAdr register pair with virtual data pointer for use in MapVirt subroutine.}<br><br>LblNLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[GetDtAdrNR]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[8,10,RetXfrLp];<br>LblWLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CLWVDelRdRst,<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">  GOTO[GetDtAdrWrV]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[9,10,RetXfrLp];<br>LblRLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[GetDtAdrNR]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0A,10,RetXfrLp];<br>LblVLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CLWVDelRdRst,<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">  GOTO[GetDtAdrWrV]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0B,10,RetXfrLp];<br><br>GetDtAdrNR:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UDtPtrLo, pCall4</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; UDtPtrHi, CALL[MapVirt]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10];<br><br><br>GetDtAdrWrV:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UDtPtrLo, pCall4</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; UDtPtrHi, CALL[MapVirt]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[2,10];<br><br><br><br>{Call DelRdRst subroutine to reset the read gate if any.}<br><br>DtMapRetNR:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RHCnt, CALL[RdGateRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10,RetMap];<br><br>DtMapRetWrV:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RHCnt, CALL[DelRdRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[2,10,RetMap];<br><br><br><br>{Prepare label mask into RCnt register to test the label operation.  Dispatch on data opcode.}<br><br>DtOpDISPNR:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ULMask, GOTO[DtOpDISP]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[1,10,RetDelRdRst];<br>DtOpDISPWrV:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ULMask</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[2,10,RetDelRdRst];<br>DtOpDISP:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Xbus &larr; UDtOp, XDisp</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">DISP4[Operation]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{These are the dispatch points after the DISP on data operation.  The sequencer is loaded with proper Function code and in case of disk read type of operations (OD code in IOCB = Noop, Read, Verify) RCnt will get the constant for delayed set of read circuitry.  The write will be set immediatelly.}<br><br>DtNoop:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[DtNRVCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0C,10,Operation];<br>DtWr:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~KTest and RCnt, NZeroBr,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">  GOTO[DtWrCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0D,10,Operation];<br>DtRd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[DtNRVCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0E,10,Operation];<br>DtVrf:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[DtNRVCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0F,10,Operation];<br><br>DtNRVCont:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~KTest and RCnt, NZeroBr</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UDCntl,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">  BRANCH[LblOpOKRd, LblOpErrRd], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Call DelSetRd subroutine to raise the disk read circuitry if read type of label operation was OK.}<br><br>LblOpOKRd:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CDDelRdSet, ZeroBr,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">  CALL[DelSetRdC2]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[2,10,LblOpErrRd];<br><br>DtWrCont:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UDCntl,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">  BRANCH[LblOpOKWr, LblOpErrWr], L4 &larr; 2</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>LblOpOKWr:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; UDCmd, L4Disp, CALL[EndDelSetRd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,LblOpErrWr];<br>LblOpErrWr:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[LblOpErrCont]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,LblOpOKWr];<br><br><br>{n case of any label operation error store the controller status in UCStat register (this is needed because the laches are reset by LdSequencer signal).}<br><br>LblOpErrRd:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or 4, GOTO[LblErrC2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1 ,at[3,10,LblOpOKRd];<br>LblOpErrCont:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or 4</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br><br>LblErrC2:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UCStat &larr; RCnt</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[UpdUCStat]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This is the end of delay.  Set the CtlTag and Bus for Dt operation.  Prepare to set WU DataReq for data xfer loops and then go to do the DISP for Noop, Rd, WrVrf loops.}<br><br>DtSetRd:<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; UDCmd</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[2,10,RetDelSetRd];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UDCntl or RCnt, GOTO[DtLoopDisp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This are the dispatch points to call the loops for Dt operation.  Set proper word counts into RCnt register for loops (RHCnt got FE in DelSetRd subroutine).}<br><br>CallDtNoop:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; U0100, ZeroBr, CALL[NoopLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0C,10,CallLoop];<br>CallDtWrt:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0FF + 1, CALL[WrVrfLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0D,10,CallLoop];<br>CallDtRd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0 + 0, PgCarryBr, CALL[DtRdLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0E,10,CallLoop];<br>CallDtVrf:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0FF + 1, CALL[WrVrfLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0F,10,CallLoop];<br><br><br><br>{This are the return points from loops after Dt operations.  The sector data xfer is completed here.  Start housekeeping after the data field.  First decrement the PgCnt in UPgCnt register.}<br><br>DtNLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UPgCnt, GOTO[DtXferFin]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0C,10,RetXfrLp];<br>DtWLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UPgCnt, GOTO[DtXferFin]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0D,10,RetXfrLp];<br>DtRLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UPgCnt, GOTO[DtXferFin]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0E,10,RetXfrLp];<br>DtVLpRet:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UPgCnt, GOTO[DtXferFin]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0F,10,RetXfrLp];<br><br>DtXferFin:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr - 1</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UPgCnt &larr; RAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Increment client label word 5 in ULblWd5 register for the next sector operation.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ULblWd5</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt + 1</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">ULblWd5 &larr; RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Conditionally increment DtPtrLo in UDtPtrLo if I bit in IOCB is =1 (bit7 in UHdrOp register).  First load the I bit (value = 256) into RCnt register to extract the I*, and then load RAdr with UDtPtrLo.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0FF + 1</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UHdrOp and RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UDtPtrLo</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Now add the value of I* (I* is 0 or 256 - set by device Head) to UDtPtrLo, which is already in RAdr and then load this value into UDtPtrLo, thus UDtPtrLo is incremented conditionally by 256 as a function of I*.  Prepare to test for disk check.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RAdr+RCnt </span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UDtPtrLo &larr; RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; ~KStatus xor 0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Test for disk check.  If DiskCheck save controller status in UCStat register and on flush the opration.  If OK call the memory error test subroutine.  Set RCnt to 0 for subroutine use.  This will ensure that URetry will have 0 contents after exit from subroutine.}<br><br>DskCheckTest:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; RAdr and CDskCheck, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; ~KTest xor 0, BRANCH[DskCheck, DskOK], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;</span><span class="tab" val="77"></span><span style="font: 8pt serif"><br>DskCheck:</span><span class="tab" val="77"></span><span style="font: 8pt serif">UCStat &larr; RAdr, GOTO[UpdUCStatDC]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,10,DskOK];<br>DskOK:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0, CALL[MemErTest]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10,DskCheck];<br><br><br><br>{This is the return point from memory error test subroutine in case there is no double bit errror.  Prepare to test for data check.  This test is done late on purpose because of delay in ECCError detection.}<br><br>MemTestOK:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UDMask</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,10,RetNoMemEr];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~KTest and RCnt, GOTO[DtCheckTest], ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{If double bit memory error this is the return point from test memory error subroutine.   Save controller status in UCStat register.}<br><br>DtMemError:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; ~KTest xor 0, CANCELBR[$, 2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,10,RetMemEr];<br>DtMemErrorC3:</span><span class="tab" val="77"></span><span style="font: 8pt serif">UCStat &larr; RAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Set MemoryError bit in RCnt to terminate the operation.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CMemError, GOTO[SetUCStat]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br><br><br><br>{This is the test for data check.  The proper mask from the IOCB is applied in this test.  If data check prepare to save controller status in UCStat register and then go to transfer the ECC syndrom.  If OK reset the read and write bits and the CNTLTAG for potential HDADV in c1 and in c3.  In c2 load the CMaxSec into RCnt to test for last sector (sector address = 28) on the track.}<br><br>DtCheckTest:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; U2C04, BRANCH[DtCheck, DtOpOK]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>DtCheck:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or 6, GOTO[ECCXfer]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,2,DtOpOK];<br>DtOpOK:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CMaxSec</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,2,DtCheck];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; RAdr &larr; U0C04</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Test for PgCnt = 0.  If yes go to EndProc; if no test for the last sector (sector address = 28).  RHAdr gets the high 2 bits of the IOCB pointer for future IOCB update.}<br><br>ZrPgCntTest:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Ybus &larr; UPgCnt, NZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>ZrPgCntTestC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; UCurHdSec, BRANCH[ZrPgCnt, NotZrPgCnt]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>ZrPgCnt:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; USvAdrHi, GOTO[EndProc]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,NotZrPgCnt];<br>NotZrPgCnt:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Ybus &larr; RCnt xor RHCnt, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,ZrPgCnt];<br><br><br><br>{This is the test for last sector (sector address = 28).  If not last sector increment the sector number in RCnt register.  RHCnt gets the sector wake-up constant for use in transfer routines.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UCurHdSec, BRANCH[NotLastSec, HeadAdv]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>NotLastSec:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt + 1</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,2,HeadAdv];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CWUSecFnd</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br>{Go to update the IOCB after this sector is processed.  Load RAdr with U0C04 for use in UpdIOCBSec routine.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; U0C04, GOTO[UpdIOCBSec]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br><br><br><br>{If last sector advance the head (by issueing head advance), first reset sector address and then increment head address.  Or the HdAdv constant into RAdr register to set the disk bus in c3.}<br><br>HeadAdv:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr or CHdAdv</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,2,NotLastSec];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; RAdr LRot0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br>{Reset the sector number bits in RCnt register in c1.  In c2 increment hte head address.  The CNLTTAG and BUS gets set in c3 (with HdSel and HdAdv bits on the bus).}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RHCnt xor RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; U2C05</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt + 0FF+1</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{RHCnt gets the index wake-up logic for next sector operation in c1.  Reset the CNTLTAG in c2.  Load RAdr registers with IOCB physical address to update the IOCB for next sector transfer (RHAdr is loaded @ EndLoops) and reset the ECC logic for next sector operation (set sequencer to Idle) in c3.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CWUIndxFnd</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>UpdIOCBSec:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; RAdr LRot0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo, ClrKFlags</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Update the current Head/Sector address in IOCB and also load UCurHdSec register with this updated value.  Reset CNTLTAG for next sector operation.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">MAR &larr; [RHAdr, RAdr+CDisplCHdSec]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">MDR &larr; UCurHdSec &larr; RCnt, CANCELBR[$, 2], LOOPHOLE[wok]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; U0C04</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Write the updated client label word 5 into the IOCB location (IOCBPtr + 25).  Prepare to set the ECC logic into Reset sequence.  Set CNTLTAG and HdSel bits in KCmd for next sector operation and then call XferSecLp for next Hdr operation.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">MAR &larr; [RHAdr, RAdr + CDisplLblWd5], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">MDR &larr; ULblWd5, LOOPHOLE[wok],<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">CANCELBR[XferSecStartC3, 2], CALL[XferSecStartC3]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[2,10];<br><br><br><br>{The ECC transfer is entered only in case the there is a data check, even the reason might be something else then ECC error.  First restore the current IOCB physical Address in RHAdr,,RAdr register pair....}<br><br>ECCXfer:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{... load RCnt with delay constant and call DelRdRst for delay before loadinfg the sequencer into ECCXfer routine....}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UCStat &larr; RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[3,10];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 48, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">CALL[DelRdRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[3,10];<br><br><br><br>{... and then add the proper dislacement to this address for syndrom transfer and prepare to set the sequencer into ECCXfer routine.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr +CDisplECC</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[3,10,RetDelRdRst];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; USvAdrHi</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UBitSignAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br><br>{Set the word sequencer into ECC Xfer routine and set the number of words being transfered in RdLp to 2.  The sequencer will generate 3 DataReqs the third one to exit from the loop.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or CECCXfer</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; RCnt LRot0, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 2, CALL[RdLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[3,10];<br><br><br><br>{In case of HdrErr test for Vrf operation.  RCnt has UHdrOp (with the FirstIOCB bit masked off) in it.}<br><br>TestForVrf:</span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr; RCnt xor CTestForVrf, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{If it is not a Vrf operation then we have a HdrError condition.  Then go to eror processing.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; URetry, BRANCH[XferHdrEr, VrfOper], ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>XferHdrEr:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; U2C04, CANCELBR[$, 1]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,2,VrfOper];<br>XferHdrErC3:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[UpdUCStat]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{If it is a Vrf operation test number of remaining retries.  if 0 then it means one of two things; number of retries was exasted (for unoriented operation) or this is not the first pass (oriented opearation).  For either case it is a Hdr error and HdrNotFound status is posted into controller status word and then go to error processing.  if not 0 then call XferSecStart subroutine to retry the header compare.}<br><br>VrfOper:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt-1, BRANCH[HdrRetry, HdrError]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,2,XferHdrEr];<br>HdrRetry:</span><span class="tab" val="77"></span><span style="font: 8pt serif">URetry &larr; RCnt, GOTO[RestoreUCStat]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,HdrError];<br>HdrError:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CHdrNotFnd, GOTO[UpdUCStatN]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,HdrRetry];<br><br><br><br>{Restore UCStat with GoodCompl status.}<br><br>RestoreUCStat:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0C0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt LRot8, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UCStat &larr; RCnt, CALL[XferSecStart]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[2,10];<br><br><br><br>{This is the beginning of error processing routine.  It updates both controller and disk status words.  UpdUCStatN is used by those error exits they set some of the controller status bits (RecalError, MemError, HdrNotFound).  UpdUCStat is also the exit from ECCXfer routine.  Then the controller status mask is applied to reset unused bits. It also will reset InProgress and GoodCompletion bit in UCStat register....}<br><br>UpdUCStatDC:  RCnt &larr;6, GOTO[SetUCStat]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>UpdUCStat:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr;0, GOTO[SetUCStat]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[3,10,RetXfrLp];<br>UpdUCStatN:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br><br>SetUCStat:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UCStat</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr or RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{... and actually reset goodCompletion bit in UCStat register and then call subroutine to write UCStat into IOCB.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~U4000 xor 0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UCStat &larr; RAdr and RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; USvAdrHi</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br>{Update UDStat, then reset read and write lines and call subroutine to write it into the proper IOCB location}<br><br>EndProc:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~KStatus xor 0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UDStat &larr; RCnt, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; U2C04, CALL[DStatUpdate]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,10];<br><br><br><br>{Reset CtlTag, reset memory controller for task 4, and call TagSetRst subroutine to reset track offset if any.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; RCnt &larr; U0C00</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[1,10,RetStatUpd];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; CHdTag, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">MCtl &larr; U8C02, CALL[TagSetRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[5,10];<br><br><br><br>{Reset the SIP bit for the current disk in USIP register.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; ~UBitSignAdr xor 0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[5,10,RetTagSetRst];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USIP and RAdr, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">USIP &larr; RAdr, CALL[PgCntUpdate]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[3,10];<br><br><br><br>{Issue Naked Notify and request Mesa Interrupt.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; uWP</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[3,10,RetStatUpd];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UIntMask or RCnt, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">uWP &larr; RCnt, MesaIntRq, CALL[DtPtrUpdate]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[4,10];<br><br><br><br>{Reset inProgress bit in UCStat register and call subroutine to update that IOCB location in memory.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UCStatMask</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[4,10,RetStatUpd];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UCStat and RAdr, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UCStat &larr; RCnt &larr; RAdr, CALL[CStatUpdate]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[2,10];<br><br><br><br>{Test for IOCB  good completion}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; CGoodCompl</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[2,10,RetStatUpd];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr LRot8</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Ybus &larr; UCStat and RAdr, NZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Deselect the disk.  In case of good completion test for chaining, if not chained (the next IOCBLink = 0) or if bad completion go to AnySIP to test if there is naything else to do for the current IOCB queue.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UF001, BRANCH[BadCompl, GoodCompl]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>BadCompl:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Ybus &larr; 0, NZeroBr, GOTO[GoodComplC3]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,2,GoodCompl];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif"><br>GoodCompl:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Ybus &larr; UIOCBLink, NZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,2,BadCompl];<br>GoodComplC3:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; 0F, BRANCH[AnySIP, ChainedIOCB]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Here the chained IOCB processing starts.  If good completion and chained (not the last IOCB) IOCB get the IOCB real pointer.  Set-up the pointer to CSB&rsquo;s IOCB pointer in RHAdr,,RAdr register pair in this and c1 of the next click.}<br><br>ChainedIOCB:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; uIOPage</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[1,2,AnySIP];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; IOPageHigh</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr or UDskAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Update the CSB&rsquo;s IOCB pointer to point to the next IOCB (first in RCnt register and then in memory.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr or DiskCSBOffsetIOCB</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UIOCBLink, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">CALL[StatWrite]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[5,10];<br><br><br><br>{Get the real IOCB pointer and start the next IOCB (return to IOCBStart).}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; 0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[5,10,RetStatUpd];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UIOCBLink, pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">CALL[MapVirt]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,10];<br><br><br><br>{---------------------------------------------------------------------------------------------------------------------------------------------------------------</span><span class="tab" val="77"></span><span style="font: 8pt serif">             SUBROUTINES<br>---------------------------------------------------------------------------------------------------------------------------------------------------------------}<br><br><br>{This is a subroutine which maps the virtual address to physical address.  It is used to map the IOCB address, the Client Label address, and the Data address.  The map look-up table is in 10000 - 13FFF of physical memory.  Upon entry the virtual address is in RHAdr,,RAdr register pair; upon exit the real address is in the same register pair.  Then low 16 address bits are saved in RCnt for re-assembly in next click.}<br><br>MapVirt: </span><span class="tab" val="77"></span><span style="font: 8pt serif">Map &larr; [RHAdr, RAdr+0]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt&larr; RAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; MD, RAdr &larr; MD</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Here the 8 lsbs of the real address are re-assembled and stored in RAdr register.  The sbroutine then returns  returns to the caller.  In c2 a pCall4 is executed to call (after return) the DelRdRst subroutine before the date field operation.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr  &larr; MAR &larr; [RHAdr, RCnt+0], pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RET[RetMap], pCall4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br><br><br><br>{This is a subroutine to load an IOCB into the U registers.  At this point RHAdr,,RAdr registers contain the proper real address of the block to be xfered from memory.  This loop xfers a block of 12 words from the IOCB to 75 -7F U registers and then to 70 U-reg.}<br><br>IOCBLoad:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; MAR &larr; [RHAdr, RAdr+CDisplIOCB]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">MCtl &larr; U8C02, CANCELBR[IOCBLpC3, 2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br><br>IOCBLp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; MAR &larr; [RHAdr, RAdr+1], AltUaddr, NibCarryBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>IOCBLpC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">URAdrBlk &larr; RCnt, BRANCH[IOCBLpC3, IOCBLpFin],<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">CANCELBR[$, 2], LOOPHOLE[wok]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>IOCBLpC3:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; MD, GOTO[IOCBLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,IOCBLpFin];<br>IOCBLpFin:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; MD, GOTO[IOCBParLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,IOCBLpC3];<br><br><br><br>{Upon exit from the previous loop the 4 LSBs of RAdr are = 0.  This loop xfers the next 16 word block from the IOCB in memory to 8X U registes.  First registers 81 - 8F and then register 80 is loaded. It also prepares to load the URetry register with proper constant=90.  This value will then be saved in URetry register in memory error test subroutine (which follows IOCB Load) for use in Hdr verification routine.}<br><br>IOCBParLp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">MAR &larr; [RHAdr, RAdr+1], RAdr &larr; RAdr+1, AltUaddr, NibCarryBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">URCntBlk &larr; RCnt, BRANCH[IOCBParLpC3, ParLpFin],<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">CANCELBR[$, 2], LOOPHOLE[wok]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>IOCBParLpC3:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; MD, GOTO[IOCBParLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,ParLpFin];<br>ParLpFin:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CRetry, GOTO[MemErTest]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,IOCBParLpC3];<br><br><br><br>{This subroutine checks for double memory error.  It is entered from IOCB Load subroutine and after data transfer for any sector is completed.}<br><br>MemErTest:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; 0FF + 1</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">[] &larr;MStatus and RAdr, NZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">BRANCH[NoMemEr, MemEr], pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This are the exits from MemErTest subroutine.  If Ok it stores RCnt into URetry register.  Upon entry from IOCB Load subroutine RCnt contains the retry constant; upon enty from DtXferFin it contains 0.  If error RAdr gets UCStat register for use in IOCB error processing routine.}<br><br>NoMemEr:</span><span class="tab" val="77"></span><span style="font: 8pt serif">URetry &larr; RCnt, RET[RetNoMemEr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0,2,MemEr]; <br>MemEr:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UCStat, RET[RetMemEr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[1,2,NoMemEr];<br><br><br><br>{This subroutine is used to transfer commands to the selected disk.  Upon entry RCnt has the Bus value and RAdr the Tag constant shifted right by 8.  Subroutine sets the Bus in c1 and the Tag in c3 of click1.}<br><br>TagSetRst:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; RCnt LRot0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr LRot8</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; (RCnt or RAdr) LRot0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{In c3 of click2 the tag is reset.  Before return RCnt is loaded with CTstFirstIOCB constant for use in seek routine if entered from Recal routine.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; UBitSignAdr{used some ret points}, pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2; <br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr;  RCnt LRot0, RET[RetTagSetRst]</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This subroutine is used to find the header (first time in) for all non-oriented header operations.   The subroutine starts with loading the sector number into RHCnt and the CWUSecFnd into RCnt register.}<br><br>FindHdr:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt&larr; UCurHdSec </span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CWUIndxFnd</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{The subroutine then test for client sector = 0 and resets SecFound and IdxFound latches.  If client 0 the subroutine sets WU: IdxFound and then returns.  If not 0 it orients on index by setting WU: IdxFound and and then counts SecFnd wake-ups.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Ybus &larr; RHCnt, NZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or UBitSignAdr, BRANCH[IndxOrient, SecOrient],</span><span class="tab" val="77"></span><span style="font: 8pt serif"><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">ClrKFlags</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>IndxOrient:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; RCnt LRot0, pRet4, GOTO[FindHdrEnd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,SecOrient];<br>SecOrient:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; RCnt LRot0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,IndxOrient];<br><br><br><br>{UScratch gets the sector WU constant and RCnt gets client sector address for use in next click.}<br><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt or CWUSecFnd</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">UScratch &larr; RCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RHCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Decrement RCnt, clear SecFound latch and count number of sector wake-ups equal to client sector address.  If sector is found exit, if not go to the FindHdrLp and try again.  In either case set SecFnd wake-up...}<br><br>FindHdrLp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt-1, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">ClrKFlags, BRANCH[SecNotFnd, SecFnd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>SecNotFnd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UScratch, GOTO[FindHdrLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,SecFnd];<br>SecFnd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UScratch, pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,SecNotFnd];<br><br><br><br>{... and return to Hdr routines.}<br><br>FindHdrEnd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RET[RetFindHdr]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br><br><br><br>{Test for sector address = 0.  If 0 set WU IndxFnd into RHCnt; if not 0 set Set CWUSecFnd into RHCnt register and then return.}<br><br>SecZrTest:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Ybus &larr; RHCnt, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">BRANCH[SecNotZero, SecZero], pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br>SecNotZero:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CWUSecFnd, RET[RetSecZrTest]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0,2,SecZero];<br>SecZero:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHCnt &larr; CWUIndxFnd, RET[RetSecZrTest]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[1,2,SecNotZero];<br><br><br><br>{This is the entry point of the write/verify main loop. RAdr contains the physical memory address; RCnt the word count for that particular field.  The loop transfers one word/click from memory to either KODataA or KODataB register respectively.  KStrobe serves as na early indicator that either of the KOData registers willbe serviced in click3.}<br><br>WrVrfLp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">MAR &larr; [RHAdr, RAdr], RAdr &larr; RAdr+1, KStrobe</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0,2,EndWrVrf];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt-1, ZeroBr, CANCELBR[$, 2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KOData &larr; MD, BRANCH[WrVrfLp, EndWrVrf]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This is the entry point of the read loop for Hdr, Lbl and ECC syndrom.  It transfers one word/click from KIData registers to the main memory.  KStrobe is again used as an early service indicator.  Upon entering this routine the word count is equal to number of words transferred.}<br><br>RdLp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">MAR &larr; [RHAdr, RAdr], RAdr &larr; RAdr+1, KStrobe,<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">BRANCH[RdLpC2, EndRdC2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>RdLpC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">MDR &larr; KIData, CANCELBR[$, 2], LOOPHOLE[wok]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,2,EndRdC2];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt - 1, ZeroBr, GOTO[RdLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This is the special loop, which transferes the datafield from the controller to memory.  The buffer has to start on the word boundary for this loop to work properely.}<br><br>DtRdLp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">MAR &larr; [RHAdr, RAdr  + 0], BRANCH[DtRdLpC2, DtRdEndC2],</span><span class="tab" val="77"></span><span style="font: 8pt serif"><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KStrobe</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>DtRdLpC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">MDR &larr; KIData, CANCELBR[$, 2],  LOOPHOLE[wok]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,2,DtRdEndC2];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr + 1, PgCarryBr, GOTO[DtRdLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This is the entry point of the Noop loop.  It is used to clock over a particular field in order to sustian orientation.  KOData registers are loaded with 0 for use in Hdr Wr only operation.  KStrobe is used to reset Data Requests.}<br><br>NoopLp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KStrobe, BRANCH[NoopLpC2, EndNoopC2]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>NoopLpC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KOData &larr; Xbus &larr; 0</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[0,2,EndNoopC2];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt-1, ZeroBr, GOTO[NoopLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This are the exits and return points of write/verify, read, and noop loops.  RHCnt will save a constant to delay the CRC test after Hdr and Lbl fields.  These constants have differrent value for Rd(or Noop) and Vrf operation.  There are n+1 WUs generated by hardware for each field in order to exit the loop into this section of code.  Then WU condition is set to FirmwareEn in order to do the housekeeping and the last KStrobe is issued.  Upon exit RHAdr is loaded with IOCB PtrHi for use in Lbl and after Dt operations (in Dt operations RHAdr is reloaded in GetDtAdr routines).}<br><br>EndRdC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UBitSignAdr, CANCELBR[EndLoops, 2],</span><span class="tab" val="77"></span><span style="font: 8pt serif"><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">pRet4, LOOPHOLE[wok]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,2,RdLpC2];<br>DtRdEndC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UBitSignAdr, CANCELBR[EndLoops, 2],</span><span class="tab" val="77"></span><span style="font: 8pt serif"><br></span><span class="tab" val="77"></span><span style="font: 8pt serif">pRet4, LOOPHOLE[wok]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,2,DtRdLpC2];<br>EndNoopC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UBitSignAdr, CANCELBR[EndLoops, 2], pRet4,</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2, at[1,2,NoopLpC2];<br><br><br>EndWrVrf:</span><span class="tab" val="77"></span><span style="font: 8pt serif">KStrobe</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[1,2,WrVrfLp];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCtl &larr; UBitSignAdr, pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>EndLoops:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RHAdr &larr; USvAdrHi, RET[RetXfrLp]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This loop delays the CRC testing after Hdr and Lbl fields have been transfered.  It also prepares to reset the read gate in next click.  The constant is designed to reset the read gate and also strobe early/late if any.}<br><br>DelRdRst:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[0,2,RdGateRst];<br>DelRdRstC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt - 1, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">BRANCH[DelRdRst, RdGateRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This is the end of delay.  This section of the code resets unconditionally read gate only (if any) and then returns to data xfer routines.  (It does not reset strobe early/late bits.) }<br><br>RdGateRst:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; ~CRead</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1, at[1,2,DelRdRst];<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UHCmd and RCnt, pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">KCmd &larr; RCnt LRot0, RET[RetDelRdRst]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{This is the delay loop to set the disk read circuitry before label and data Noop, Rd, and Vrf operations.}<br><br>DelSetRd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; RCnt - 1, ZeroBr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br>DelSetRdC2:</span><span class="tab" val="77"></span><span style="font: 8pt serif">BRANCH[DelSetRdLp, DelSetRdEnd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br>DelSetRdLp:</span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[DelSetRd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[0,2,DelSetRdEnd];<br>DelSetRdEnd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3, at[1,2,DelSetRdLp];<br><br><br><br>{Set constant into RCnt to set WU: DataRq after exit, before starting data xfer.}<br><br>EndDelSetRd:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CWUDtReq, RET[RetDelSetRd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br><br><br><br>{Update BSAdr in the memory location IOCBPtr+CDisplBSAdr.}<br><br>BSAdrUpdate:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr + CDisplBSAdr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">Noop, GOTO[StatWrite]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Update disk status in the memory location IOCBPtr+CDislDStat.}<br><br>DStatUpdate:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr + CDisplDStat</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UDStat, GOTO[StatWrite]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Update UCStat register in the memory location IOCBPtr+CDislCStat.}<br><br>CStatUpdate:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr + CDisplCStat</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UCStat, GOTO[StatWrite]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br>{Write the updated PgCnt into proper IOCB location after the operation is terminated.}<br><br>PgCntUpdate:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr + CDisplPgCnt</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UPgCnt, GOTO[StatWrite]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{Write the updated DtPtrLo into proper IOCB location (DtPtrHi is never updated because the virtual data pointer must not cross 64k virtual boundary) after the operation is terminated.}<br><br>DtPtrUpdate:</span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; USvAdrLo</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RAdr &larr; RAdr + CDisplDtPtr</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; UDtPtrLo, GOTO[StatWrite]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br><br>{... and do the actual writting.}<br><br>StatWrite:</span><span class="tab" val="77"></span><span style="font: 8pt serif">MAR &larr; [RHAdr, RAdr+0]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c1;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">MDR &larr; RCnt, CANCELBR[$, 2], LOOPHOLE[wok], pRet4</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c2;<br></span><span class="tab" val="77"></span><span style="font: 8pt serif">RCnt &larr; CTstRecal, RET[RetStatUpd]</span><span class="tab" val="77"></span><span style="font: 8pt serif">,c3;<br><br><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
