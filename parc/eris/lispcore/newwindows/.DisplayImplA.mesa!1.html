<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>NEWWINDOWS>DisplayImplA.mesa!1</title>
  </head>
  <body>
    <pre>
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- DisplayImplA.mesa - last edited by -- Rick	        12-Nov-83 14:49:19  -- Bruce	25-Feb-83 10:12:40  -- Mark		12-Feb-83 22:11:52  -- Daniels	 7-Jun-84 14:37:54  DIRECTORY  BitBlt USING [BITBLT, BitBltFlags],  Display USING [bitFlags, paintGrayFlags],  DisplayOps USING [    AbsPlace, Color, DIVMOD, HasUnder, LogError, FillList, FillObject, Intersect,    Shade],  Environment USING [BitAddress],  Inline USING [DIVMOD, LongDivMod, LongMult, LowHalf],  SpecialDisplay USING [DashCnt, defaultContext, LineStyle, solid, Special],  Window USING [Box, BoxHandle, Place],  WindowOps USING [    AbsoluteBox, AbsoluteBoxHandle, bbPtr, bitmapAddress,    DisplayList, GetContext, lock, nullGray, Object, RecList, ScanLine, ScreenBox,    SpecialTimesWpl];DisplayImplA: MONITOR LOCKS WindowOps.lock  IMPORTS BitBlt, DisplayOps, Inline, SpecialDisplay, WindowOps  EXPORTS Display, SpecialDisplay, Window =  BEGIN  -- exported types  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = WindowOps.Object;  FillHandle: TYPE = LONG POINTER TO FillObject;  FillObject: PUBLIC TYPE = DisplayOps.FillObject;  -- copied types because John doesn't like them  LineStyle: TYPE = SpecialDisplay.LineStyle;  Special: TYPE = SpecialDisplay.Special;  black: CARDINAL &larr; LAST[CARDINAL];  blackSrc: Environment.BitAddress = [word: @black, bit: 0];  Point: PUBLIC ENTRY PROC [window: Handle, point: Window.Place] = {    -- This routine assumes that point is in 8000 box.    ENABLE UNWIND =&gt; NULL;    -- switch to screen coords    abs: Window.Place = DisplayOps.AbsPlace[window, point];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link UNTIL r = NIL      DO      IF abs.x ~IN [r.box.left..r.box.right] OR         abs.y ~IN [r.box.top..r.box.bottom]        THEN LOOP;      -- abs.y must be positive here      IF DisplayOps.HasUnder[r] THEN        SpPointInternal[r, abs, black, SpecialDisplay.defaultContext]      ELSE {        bitAddress: WindowOps.ScanLine =          WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[abs.y];        bitAddress[abs.x] &larr; TRUE};  -- set a bit      RETURN;  -- rectangles never overlap      ENDLOOP};  SpPoint: PUBLIC ENTRY PROC [    window: Handle, point: Window.Place, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    ENABLE UNWIND =&gt; NULL;    IF window.inTree THEN {      rec: WindowOps.RecList = DisplayOps.FillList[window, context.alloc # NIL];      abs: Window.Place = DisplayOps.AbsPlace[window, point];      color: DisplayOps.Color = DisplayOps.Shade[flags];      SpPointInternal[rec, abs, color, context]}};  SpPointInternal: INTERNAL PROC [    rec: WindowOps.RecList, abs: Window.Place, color: DisplayOps.Color,    context: Special] = {    FOR r: WindowOps.RecList &larr; rec, r.link UNTIL r = NIL DO      IF abs.x IN [r.box.left..r.box.right] AND abs.y IN [r.box.top..r.box.bottom]        THEN {  -- abs.y must be positvie here        ctx: Special = WindowOps.GetContext[r, context];        bitAddress: WindowOps.ScanLine =          ctx.bmAddress + WindowOps.SpecialTimesWpl[abs.y, ctx];        SELECT color FROM          white =&gt; bitAddress[abs.x] &larr; FALSE;          black =&gt; bitAddress[abs.x] &larr; TRUE;          ENDCASE =&gt; bitAddress[abs.x] &larr; ~bitAddress[abs.x];        RETURN};  -- rectangles never overlap      ENDLOOP};  -- lines  OrthogonalLine: PUBLIC ENTRY PROC [window: Handle, line: Window.Box] = {    -- This routine assumes that the bounding box of any line displayed intersects    -- with the Display.clip.box.    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBox[window, line];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link UNTIL r = NIL      DO      left: INTEGER = MAX[absBounds.left, r.box.left];      width: INTEGER = MIN[absBounds.right, r.box.right] - left;      top: INTEGER = MAX[absBounds.top, r.box.top];      height: INTEGER = MIN[absBounds.bottom, r.box.bottom] - top;      offset, bit: INTEGER;      IF DisplayOps.HasUnder[r] THEN {        SpOrthoInternal[          window, absBounds, SpecialDisplay.solid, Display.paintGrayFlags,          SpecialDisplay.defaultContext];        RETURN};      IF height &lt;= 0 OR width &lt;= 0 THEN LOOP;      -- At this point, we know that       --  left and left + width IN [r.box.left..r.box.right]      --  top and top + height IN [r.box.top..r.box.bottom]      [quotient: offset, remainder: bit] &larr; Inline.DIVMOD[left, 16];      WindowOps.bbPtr&uarr; &larr; [        dst: [        word: WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[top] + offset,        bit: bit], dstBpl: SpecialDisplay.defaultContext.bpl, src: blackSrc,        srcDesc: WindowOps.nullGray, width: width, height: height,        flags: Display.bitFlags];      BitBlt.BITBLT[WindowOps.bbPtr];      ENDLOOP};  SpOrthoLine: PUBLIC ENTRY PROC [    window: Handle, line: Window.Box, dashes: LineStyle, flags:BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    ENABLE UNWIND =&gt; NULL;    IF window.inTree THEN {      absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBox[window, line];      SpOrthoInternal[window, absBounds, dashes, flags, context]}};  SpOrthoInternal: INTERNAL PROC [    window: Handle, absBounds: WindowOps.ScreenBox, dashes: LineStyle,    flags: BitBlt.BitBltFlags, context: Special] = {    filled: BOOLEAN = context.alloc # NIL;    flags.gray &larr; TRUE;    FOR r: WindowOps.RecList &larr; DisplayOps.FillList[window, context.alloc # NIL],      r.link UNTIL r = NIL DO      ctx: Special = WindowOps.GetContext[r, context];      clipLeft: INTEGER = r.box.left;      left: INTEGER &larr; MAX[absBounds.left, clipLeft];      width: INTEGER = MIN[absBounds.right, r.box.right] - left;      clipTop: INTEGER = r.box.top;  -- this is positive      top: INTEGER = MAX[absBounds.top, clipTop];      height: INTEGER = MIN[absBounds.bottom, r.box.bottom] - top;      visible: BOOLEAN &larr; TRUE;      dashIndex: [0..SpecialDisplay.DashCnt) &larr; 0;      offset, bit: INTEGER;      mark: INTEGER &larr; dashes.widths[0];      dashLeft: INTEGER &larr; 0;      dashSum: CARDINAL &larr; 0;      IF height &lt;= 0 OR width &lt;= 0 THEN LOOP;      FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO        dashSum &larr; dashSum + dashes.widths[i]; ENDLOOP;      IF height &lt;= width AND ~filled THEN        BEGIN        startBmAddr: LONG POINTER &larr;          ctx.bmAddress + WindowOps.SpecialTimesWpl[top, ctx];        IF clipLeft &gt; absBounds.left THEN {          dashSum &larr; (clipLeft - absBounds.left) MOD dashSum;          FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO            IF dashSum &lt; dashes.widths[i] THEN EXIT;            dashSum &larr; dashSum - dashes.widths[i];            dashIndex &larr; dashIndex + 1;            visible &larr; ~visible;            ENDLOOP;          mark &larr; dashes.widths[dashIndex] - dashSum};        WindowOps.bbPtr&uarr; &larr; [          dst:, dstBpl: ctx.bpl, src: blackSrc, srcDesc: WindowOps.nullGray,          width:, height: height, flags: flags];        WHILE dashLeft &lt; width DO          IF visible THEN {            IF width - dashLeft &lt; mark THEN mark &larr; width - dashLeft;            [quotient: offset, remainder: bit] &larr; DisplayOps.DIVMOD[              dashLeft + left, 16];            WindowOps.bbPtr.dst &larr; [word: startBmAddr + offset, bit: bit];            WindowOps.bbPtr.width &larr; mark;            BitBlt.BITBLT[WindowOps.bbPtr]};          dashLeft &larr; dashLeft + mark;          visible &larr; ~visible;          dashIndex &larr; (dashIndex + 1) MOD SpecialDisplay.DashCnt;          mark &larr; dashes.widths[dashIndex];          ENDLOOP;        END      ELSE        BEGIN        dashTop: INTEGER &larr; 0;        IF filled THEN {          fill: FillHandle &larr; ctx.alloc[window, top, height];	  left &larr; MAX[0, left];          FOR i: INTEGER IN [0..height - 1] DO fill.xs[i] &larr; left; ENDLOOP}        ELSE {          IF clipTop &gt; absBounds.top THEN {            dashSum &larr; (clipTop - absBounds.top) MOD dashSum;            FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO              IF dashSum &lt; dashes.widths[i] THEN EXIT;              dashSum &larr; dashSum - dashes.widths[i];              dashIndex &larr; dashIndex + 1;              visible &larr; ~visible;              ENDLOOP;            mark &larr; dashes.widths[dashIndex] - dashSum};          WindowOps.bbPtr&uarr; &larr; [            dst:, dstBpl: ctx.bpl, src: blackSrc, srcDesc: WindowOps.nullGray,            width: width, height:, flags: flags];          WHILE dashTop &lt; height DO            IF visible THEN {              IF height - dashTop &lt; mark THEN mark &larr; height - dashTop;              [quotient: offset, remainder: bit] &larr; Inline.DIVMOD[left, 16];              WindowOps.bbPtr.dst &larr; [                word: ctx.bmAddress +		   WindowOps.SpecialTimesWpl[INTEGER[top + dashTop], ctx]+offset,	        bit: bit];              WindowOps.bbPtr.height &larr; mark;              BitBlt.BITBLT[WindowOps.bbPtr]};            dashTop &larr; dashTop + mark;            visible &larr; ~visible;            dashIndex &larr; (dashIndex + 1) MOD SpecialDisplay.DashCnt;            mark &larr; dashes.widths[dashIndex];            ENDLOOP};        END;      ENDLOOP};  PositiveSteepLine: PUBLIC ENTRY PROC [    window: Handle, start, stop: Window.Place, bounds: Window.BoxHandle] = {    -- because it's positive and steep, we know:    --  start.x &lt; stop.x    --  start.y &gt; stop.y    --  stop.x - start.x &lt; start.y - stop.y    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &lt;= r.box.right    -- stop.x &gt;= r.box.left    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window, bounds];    -- switch to screen coords    absStart: Window.Place = DisplayOps.AbsPlace[window, start];    absStop: Window.Place = DisplayOps.AbsPlace[window, stop];    startError: INTEGER = absStart.y - absStop.y;    twoy: INTEGER = startError*2;  -- positive    twox: CARDINAL = (absStop.x - absStart.x)*2;  -- positive    bitIndex: INTEGER;    startAddress: WindowOps.ScanLine =      WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[INTEGER[absStart.y]];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link UNTIL r = NIL      DO      IF DisplayOps.Intersect[r, absBounds] THEN {        wpl: CARDINAL = SpecialDisplay.defaultContext.wpl;        bitAddress: WindowOps.ScanLine &larr; startAddress;        left: INTEGER = r.box.left;        top: INTEGER = r.box.top;        right: INTEGER = r.box.right;        bottom: INTEGER = r.box.bottom;        error: INTEGER &larr; startError;        IF DisplayOps.HasUnder[r] THEN {          SpPStInternal[            window, absStart, absStop, absBounds, SpecialDisplay.solid,            Display.paintGrayFlags, SpecialDisplay.defaultContext];          RETURN};        start &larr; absStart;        stop &larr; absStop;        IF bottom - 1 &lt; start.y THEN {          netError: LONG INTEGER &larr;            error - Inline.LongMult[twox, start.y - bottom + 1];          difx: INTEGER;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[start.y-bottom+1]];          start.y &larr; bottom - 1;          IF netError &lt; 0 THEN {            netError &larr; -netError;            [difx, error] &larr; Inline.LongDivMod[netError, twoy];            IF error # 0 THEN {difx &larr; difx + 1; error &larr; twoy - error};            start.x &larr; difx + start.x}          ELSE error &larr; Inline.LowHalf[netError]};        IF left &gt; start.x THEN {          difx: CARDINAL;          netError: LONG CARDINAL &larr;            Inline.LongMult[twoy, left - start.x - 1] + error;          start.x &larr; left;          [difx, error] &larr; Inline.LongDivMod[netError, twox];          error &larr; error + twoy - twox;          start.y &larr; start.y - difx - 1;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[difx + 1]]};        IF right - 1 &lt; stop.x THEN {          netError: LONG INTEGER;          difx, errorTemp: CARDINAL;          IF right - 1 &lt; start.x THEN LOOP;          netError &larr; Inline.LongMult[twoy, right - start.x - 1] + error;          [difx, errorTemp] &larr; Inline.LongDivMod[netError, twox];          stop.y &larr; start.y - difx};        IF top &gt; stop.y THEN stop.y &larr; top;        bitIndex &larr; start.x;        THROUGH [stop.y..start.y] DO          bitAddress[bitIndex] &larr; TRUE;  -- set a bit          error &larr; error - twox;          IF error &lt; 0 THEN {bitIndex &larr; bitIndex + 1; error &larr; error + twoy};          bitAddress &larr; bitAddress - wpl;          ENDLOOP};      ENDLOOP};  SpPositiveSteepLine: PUBLIC ENTRY PROC [    window: Handle, start, stop: Window.Place, bounds: Window.BoxHandle,    dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    -- because it's positive and steep, we know:    --  start.x &lt; stop.x    --  start.y &gt; stop.y    --  stop.x - start.x &lt; start.y - stop.y    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- the specific type of line being delt with here it is assumed that:    -- start.x &lt;= r.box.right    -- stop.x &gt;= r.box.left    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails    ENABLE UNWIND =&gt; NULL;    IF window.inTree THEN {      absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window,bounds];      -- switch to screen coords      absStart: Window.Place = DisplayOps.AbsPlace[window, start];      absStop: Window.Place = DisplayOps.AbsPlace[window, stop];      SpPStInternal[        window, absStart, absStop, absBounds, dashes, flags, context]}};  SpPStInternal: INTERNAL PROC [    window: Handle, absStart, absStop: Window.Place,    absBounds: WindowOps.ScreenBox, dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special] = {    startError: INTEGER = absStart.y - absStop.y;    twoy: CARDINAL = startError*2;  -- positive    twox: CARDINAL = (absStop.x - absStart.x)*2;  -- positive    dashCnt, dashSum: CARDINAL;    filled: BOOLEAN = context.alloc # NIL;    widths: ARRAY [0..SpecialDisplay.DashCnt) OF CARDINAL;    inc1, inc2, inc3, inc4, inc5, inc6: CARDINAL;    low: INTEGER = absStart.x - dashes.thickness/2;    initStopX: INTEGER &larr; absStop.x - dashes.thickness/2 - 1;    high: INTEGER = low + dashes.thickness;    fill: FillHandle &larr; NIL;    fillcnt, fillLength, bitIndex: INTEGER;    dashstretch: CARDINAL =      SELECT twoy FROM        &gt; twox*15/4 =&gt; 13,  -- 0 to 15 degrees        &gt; twox*7/4 =&gt; 12,  -- 15 to 30 degrees        ENDCASE =&gt; 11;  -- 30 to 45 degrees    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      widths[i] &larr; dashes.widths[i]*dashstretch/14; ENDLOOP;    inc1 &larr; 0;    inc2 &larr; widths[0];    inc3 &larr; inc2 + widths[1];    inc4 &larr; inc3 + widths[2];    inc5 &larr; inc4 + widths[3];    inc6 &larr; inc5 + widths[4];    dashSum &larr; 0;    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      dashSum &larr; dashSum + widths[i]; ENDLOOP;    FOR r: WindowOps.RecList &larr; DisplayOps.FillList[window, filled], r.link UNTIL r      = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN        BEGIN        ctx: Special = WindowOps.GetContext[r, context];        left: INTEGER &larr; MAX[r.box.left, absBounds.left];        top: INTEGER = MAX[r.box.top, absBounds.top];        right: INTEGER &larr; MIN[r.box.right, absBounds.right];        bottom: INTEGER = MIN[r.box.bottom, absBounds.bottom];	stopX: INTEGER &larr; initStopX;	IF top = bottom THEN GOTO nextRectangle;	IF filled THEN {	  left &larr; MAX[0, left];	  right &larr; absBounds.right;	  fillLength &larr; bottom - top;	  fill &larr; ctx.alloc[window, top, fillLength];	  fill.xs[0] &larr; left};        FOR loopx: INTEGER IN [low..high) DO          startX: INTEGER &larr; loopx;          startY: INTEGER &larr; absStart.y;          error: INTEGER &larr; startError;          stopY: INTEGER &larr; absStop.y;          bitAddress: WindowOps.ScanLine &larr;            ctx.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[startY], ctx];          stopX &larr; stopX + 1;          dashCnt &larr; 0;          IF bottom - 1 &lt; startY THEN {            netError: LONG INTEGER &larr;              error - Inline.LongMult[twox, startY - bottom + 1];            difx: INTEGER;            bitAddress &larr;              bitAddress-WindowOps.SpecialTimesWpl[INTEGER[startY-bottom+1],ctx];            dashCnt &larr; (startY - bottom + 1) MOD dashSum;            startY &larr; bottom - 1;            IF netError &lt; 0 THEN {              netError &larr; -netError;              [difx, error] &larr; Inline.LongDivMod[netError, twoy];              IF error # 0 THEN {difx &larr; difx + 1; error &larr; twoy - error};              startX &larr; difx + startX}            ELSE error &larr; Inline.LowHalf[netError]};          IF left &gt; startX THEN {            difx: CARDINAL;            netError: LONG CARDINAL &larr;              Inline.LongMult[twoy, left - startX - 1] + error;            startX &larr; left;            [difx, error] &larr; Inline.LongDivMod[netError, twox];            error &larr; error + twoy - twox;            startY &larr; startY - difx - 1;            dashCnt &larr; (difx + 1 + dashCnt) MOD dashSum;            bitAddress&larr;bitAddress-WindowOps.SpecialTimesWpl[INTEGER[difx+1],ctx]};          IF right - 1 &lt; stopX THEN {            netError: LONG INTEGER;            difx, errorTemp: CARDINAL;            IF right - 1 &lt; startX THEN GOTO nextRectangle;            netError &larr; Inline.LongMult[twoy, right - startX - 1] + error;            [difx, errorTemp] &larr; Inline.LongDivMod[netError, twox];            stopY &larr; startY - difx;            stopX &larr; right - 1};          IF top &gt; stopY THEN stopY &larr; top;          bitIndex &larr; startX;          IF startY - stopY &lt; 0 THEN GOTO nextRectangle;          IF filled THEN {            fillcnt &larr; startY - top;            fill.xs[fillcnt] &larr; MAX[startX, 0];	    fill.xs[0] &larr; MAX[stopX, 0]};          THROUGH [stopY..startY] DO            IF filled THEN {	      IF fillcnt ~IN [0..fillLength) THEN DisplayOps.LogError[];              fill.xs[fillcnt] &larr; bitIndex;              fillcnt &larr; fillcnt - 1}            ELSE {              IF dashCnt IN [inc1..inc2) OR dashCnt IN [inc3..inc4)                OR dashCnt IN [inc5..inc6) THEN                bitAddress[bitIndex] &larr;                  (SELECT DisplayOps.Shade[flags] FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~bitAddress[bitIndex]);              bitAddress &larr; bitAddress - ctx.wpl;              dashCnt &larr; (dashCnt + 1) MOD dashSum};            error &larr; error - twox;            IF error &lt; 0 THEN {bitIndex &larr; bitIndex + 1; error &larr; error + twoy};            ENDLOOP;          ENDLOOP;        EXITS nextRectangle =&gt; NULL;        END;      ENDLOOP};  NegativeSteepLine: PUBLIC ENTRY PROC [    window: Handle, start, stop: Window.Place, bounds: Window.BoxHandle] = {    -- because it's negative and steep, we know:    --  start.x &gt; stop.x    --  start.y &gt; stop.y    --  start.x - stop.x &lt; start.y - stop.y    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &gt;= r.box.left    -- stop.x &lt;= r.box.right    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window, bounds];    -- switch to screen coords    absStart: Window.Place = DisplayOps.AbsPlace[window, start];    absStop: Window.Place = DisplayOps.AbsPlace[window, stop];    startError: INTEGER = absStart.y - absStop.y;    twoy: INTEGER = startError*2;  -- positive    twox: CARDINAL = (absStart.x - absStop.x)*2;  -- positive    startAddress: WindowOps.ScanLine =      WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[INTEGER[absStart.y]];    bitIndex: INTEGER;    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link UNTIL r = NIL      DO      IF DisplayOps.Intersect[r, absBounds] THEN {        wpl: CARDINAL = SpecialDisplay.defaultContext.wpl;        bitAddress: WindowOps.ScanLine &larr; startAddress;        left: INTEGER = r.box.left;        top: INTEGER = r.box.top;        right: INTEGER = r.box.right;        bottom: INTEGER = r.box.bottom;        error: INTEGER &larr; startError;        IF DisplayOps.HasUnder[r] THEN {          SpNStInternal[            window, absStart, absStop, absBounds, SpecialDisplay.solid,            Display.paintGrayFlags, SpecialDisplay.defaultContext];          RETURN};        start &larr; absStart;        stop &larr; absStop;        IF bottom - 1 &lt; start.y THEN {          netError: LONG INTEGER &larr;            error - Inline.LongMult[twox, start.y - bottom + 1];          difx: INTEGER;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[start.y-bottom+1]];          start.y &larr; bottom - 1;          IF netError &lt; 0 THEN {            netError &larr; -netError;            [difx, error] &larr; Inline.LongDivMod[netError, twoy];            IF error # 0 THEN {difx &larr; difx + 1; error &larr; twoy - error};            start.x &larr; start.x - difx}          ELSE error &larr; Inline.LowHalf[netError]};        IF right - 1 &lt; start.x THEN {          difx: CARDINAL;          netError: LONG CARDINAL &larr; Inline.LongMult[twoy, start.x - right]+error;          start.x &larr; right - 1;          [difx, error] &larr; Inline.LongDivMod[netError, twox];          error &larr; error + twoy - twox;          start.y &larr; start.y - difx - 1;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[difx + 1]]};        IF left &gt; stop.x THEN {          difx, errorTemp: CARDINAL;          netError: LONG INTEGER;          IF start.x &lt; left THEN LOOP;          netError &larr; Inline.LongMult[twoy, start.x - left] + error;          [difx, errorTemp] &larr; Inline.LongDivMod[netError, twox];          stop.y &larr; start.y - difx};        IF top &gt; stop.y THEN stop.y &larr; top;        bitIndex &larr; start.x;        THROUGH [stop.y..start.y] DO          bitAddress[bitIndex] &larr; TRUE;  -- set a bit          error &larr; error - twox;          IF error &lt; 0 THEN {bitIndex &larr; bitIndex - 1; error &larr; error + twoy};          bitAddress &larr; bitAddress - wpl;          ENDLOOP};      ENDLOOP};  SpNegativeSteepLine: PUBLIC ENTRY PROC [    window: Handle, start, stop: Window.Place, bounds: Window.BoxHandle,    dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    -- because it's negative and steep, we know:    --  start.x &gt; stop.x    --  start.y &gt; stop.y    --  start.x - stop.x &lt; start.y - stop.y    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &gt;= r.box.left    -- stop.x &lt;= r.box.right    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    IF window.inTree THEN {      absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window,bounds];      -- switch to screen coords      absStart: Window.Place = DisplayOps.AbsPlace[window, start];      absStop: Window.Place = DisplayOps.AbsPlace[window, stop];      SpNStInternal[        window, absStart, absStop, absBounds, dashes, flags, context]}};  SpNStInternal: INTERNAL PROC [    window: Handle, absStart, absStop: Window.Place,    absBounds: WindowOps.ScreenBox, dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special] = {    startError: INTEGER = absStart.y - absStop.y;    twoy: INTEGER = startError*2;  -- positive    twox: CARDINAL = (absStart.x - absStop.x)*2;  -- positive    dashCnt, dashSum: CARDINAL;    filled: BOOLEAN = context.alloc # NIL;    widths: ARRAY [0..SpecialDisplay.DashCnt) OF CARDINAL;    inc1, inc2, inc3, inc4, inc5, inc6: CARDINAL;    low: INTEGER = absStart.x - dashes.thickness/2;    high: INTEGER = low + dashes.thickness;    initStopX: INTEGER &larr; absStop.x - dashes.thickness/2 - 1;    fill: FillHandle &larr; NIL;    fillcnt, fillLength, bitIndex: INTEGER;    dashstretch: CARDINAL =      SELECT twoy FROM        &gt; twoy*15/4 =&gt; 13,  -- 0 to 15 degrees        &gt; twoy*7/4 =&gt; 12,  -- 15 to 30 degrees        ENDCASE =&gt; 11;  -- 30 to 45 degrees    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      widths[i] &larr; dashes.widths[i]*dashstretch/14; ENDLOOP;    inc1 &larr; 0;    inc2 &larr; widths[0];    inc3 &larr; inc2 + widths[1];    inc4 &larr; inc3 + widths[2];    inc5 &larr; inc4 + widths[3];    inc6 &larr; inc5 + widths[4];    dashSum &larr; 0;    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      dashSum &larr; dashSum + widths[i]; ENDLOOP;    FOR r: WindowOps.RecList &larr; DisplayOps.FillList[window, filled], r.link      UNTIL r = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN        BEGIN        ctx: Special = WindowOps.GetContext[r, context];        left: INTEGER &larr; MAX[r.box.left, absBounds.left];        top: INTEGER = MAX[r.box.top, absBounds.top];        right: INTEGER &larr; MIN[r.box.right, absBounds.right];        bottom: INTEGER = MIN[r.box.bottom, absBounds.bottom];	stopX: INTEGER &larr; initStopX;	IF top = bottom THEN GOTO nextRectangle;	IF filled THEN {	  left &larr; MAX[0, left];	  right &larr; absBounds.right;	  fillLength &larr; bottom - top;	  fill &larr; ctx.alloc[window, top, fillLength];	  fill.xs[0] &larr; left};        FOR loopx: INTEGER IN [low..high) DO          startX: INTEGER &larr; loopx;          startY: INTEGER &larr; absStart.y;          error: INTEGER &larr; startError;          stopY: INTEGER &larr; absStop.y;          bitAddress: WindowOps.ScanLine &larr;            ctx.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[startY], ctx];          stopX &larr; stopX + 1;          dashCnt &larr; 0;          IF bottom - 1 &lt; startY THEN {            netError: LONG INTEGER &larr;              error - Inline.LongMult[twox, startY - bottom + 1];            difx: INTEGER;            bitAddress &larr;              bitAddress-WindowOps.SpecialTimesWpl[INTEGER[startY-bottom+1],ctx];            dashCnt &larr; (startY - bottom + 1) MOD dashSum;            startY &larr; bottom - 1;            IF netError &lt; 0 THEN {              netError &larr; -netError;              [difx, error] &larr; Inline.LongDivMod[netError, twoy];              IF error # 0 THEN {difx &larr; difx + 1; error &larr; twoy - error};              startX &larr; startX - difx}            ELSE error &larr; Inline.LowHalf[netError]};          IF right - 1 &lt; startX THEN {            difx: CARDINAL;            netError: LONG CARDINAL &larr;              Inline.LongMult[twoy, startX - right] + error;            startX &larr; right - 1;            [difx, error] &larr; Inline.LongDivMod[netError, twox];            error &larr; error + twoy - twox;            startY &larr; startY - difx - 1;            dashCnt &larr; (difx + 1 + dashCnt) MOD dashSum;            bitAddress&larr;bitAddress-WindowOps.SpecialTimesWpl[INTEGER[difx+1],ctx]};          IF left &gt; stopX THEN {            difx, errorTemp: CARDINAL;            netError: LONG INTEGER;            IF startX &lt; left THEN GOTO nextRectangle;            netError &larr; Inline.LongMult[twoy, startX - left] + error;            [difx, errorTemp] &larr; Inline.LongDivMod[netError, twox];            stopY &larr; startY - difx};          IF top &gt; stopY THEN stopY &larr; top;          bitIndex &larr; startX;          IF startY - stopY &lt; 0 THEN GOTO nextRectangle;          IF filled THEN {            fillcnt &larr; startY - top;            fill.xs[fillcnt] &larr; MAX[startX, 0];	    fill.xs[0] &larr; MAX[stopX, 0]};          THROUGH [stopY..startY] DO            IF filled THEN {	      IF fillcnt ~IN [0..fillLength) THEN DisplayOps.LogError[];              fill.xs[fillcnt] &larr; bitIndex;              fillcnt &larr; fillcnt - 1}            ELSE {              IF dashCnt IN [inc1..inc2) OR dashCnt IN [inc3..inc4)                OR dashCnt IN [inc5..inc6) THEN                bitAddress[bitIndex] &larr;                  (SELECT DisplayOps.Shade[flags] FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~bitAddress[bitIndex]);              bitAddress &larr; bitAddress - ctx.wpl;              dashCnt &larr; (dashCnt + 1) MOD dashSum};            error &larr; error - twox;            IF error &lt; 0 THEN {bitIndex &larr; bitIndex - 1; error &larr; error + twoy};            ENDLOOP;          ENDLOOP        EXITS nextRectangle =&gt; NULL;        END;      ENDLOOP};  END.</pre>
  </body>
</html>
