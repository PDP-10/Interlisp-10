<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>NEWWINDOWS>DisplayImplE.mesa!1</title>
  </head>
  <body>
    <pre>
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- DisplayImplE.mesa - last edited by -- S. Schiller       7-Mar-83 13:55:16-- Rick             22-Nov-83 16:49:41-- Bruce	     6-Feb-83 21:13:09-- Daniels	     7-Jun-84 14:58:00DIRECTORY  BitBlt USING [BitBltFlags],  Display USING [paintGrayFlags],  DisplayOps USING [AbsPlace, FillList, FillObject, HasUnder, Intersect, Shade],  SpecialDisplay USING [defaultContext, LineStyle, solid, Special],  Window USING [Place, BoxHandle],  WindowOps USING [    AbsoluteBoxHandle, bitmapAddress, Bounds, DisplayList, GetContext,    lock, Object, RecList, ScanLine, ScreenBox, SpecialTimesWpl];DisplayImplE: MONITOR LOCKS WindowOps.lock  IMPORTS DisplayOps, SpecialDisplay, WindowOps  EXPORTS Display, SpecialDisplay, Window =  BEGIN  -- exported types  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = WindowOps.Object;  FillHandle: TYPE = LONG POINTER TO FillObject;  FillObject: PUBLIC TYPE = DisplayOps.FillObject;  -- copied types because John doesn't like them  LineStyle: TYPE = SpecialDisplay.LineStyle;  Special: TYPE = SpecialDisplay.Special;  Ellipse: PUBLIC ENTRY PROC [    window: Handle, center: Window.Place, xRadius, yRadius: INTEGER,    bounds: Window.BoxHandle &larr; NIL] = {    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox =      IF bounds = NIL THEN WindowOps.Bounds[window]      ELSE WindowOps.AbsoluteBoxHandle[window, bounds];    -- switch to screen coords    absCenter: Window.Place = DisplayOps.AbsPlace[window, center];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link UNTIL r = NIL      DO      IF DisplayOps.Intersect[r, absBounds] THEN {        wpl: CARDINAL = SpecialDisplay.defaultContext.wpl;        error: LONG INTEGER &larr; 0;        xerror, yerror, xyerror: LONG INTEGER;        a, b, dx, dy, dxdx, dydy: LONG INTEGER;        xRight: INTEGER &larr; absCenter.x;        xLeft: INTEGER &larr; absCenter.x;        yLow: WindowOps.ScanLine &larr; WindowOps.bitmapAddress +	  WindowOps.SpecialTimesWpl[INTEGER[absCenter.y-yRadius]];        yHigh: WindowOps.ScanLine &larr; WindowOps.bitmapAddress +	  WindowOps.SpecialTimesWpl[INTEGER[absCenter.y + yRadius]];        safetyCount: INTEGER &larr; 0;        IF absCenter.x - xRadius &lt; r.box.left OR absCenter.x + xRadius &gt;= r.box.right          OR absCenter.y + yRadius &gt;= r.box.bottom          OR absCenter.y - yRadius &lt; r.box.top OR DisplayOps.HasUnder[r] THEN {          SpEllipseInternal[            r, FALSE, window, center, xRadius, yRadius, bounds,            SpecialDisplay.solid, Display.paintGrayFlags];          RETURN};        a &larr; LONG[yRadius]*LONG[yRadius];        dxdx &larr; 2*a;        b &larr; LONG[xRadius]*LONG[xRadius];        dydy &larr; 2*b;        dx &larr; a;        dy &larr; b*(1 - 2*yRadius);        -- Inner Loop        UNTIL yLow &gt;= yHigh OR safetyCount &gt; xRadius DO          yLow[xRight] &larr; TRUE;  -- set bit          yHigh[xRight] &larr; TRUE;          yLow[xLeft] &larr; TRUE;          yHigh[xLeft] &larr; TRUE;          xerror &larr; error + dx;          xyerror &larr; xerror + dy;          safetyCount &larr; safetyCount + 1;          IF ABS[xyerror] &lt; ABS[xerror] THEN {            IF ABS[error + dy] &lt; ABS[xyerror] THEN {              error &larr; error + dy;              yLow &larr; yLow + wpl;              yHigh &larr; yHigh - wpl;              dy &larr; dy + dydy;              -- Y varies more quickly now              -- stay in this loop until done              UNTIL yLow &gt;= yHigh DO                yLow[xRight] &larr; TRUE;                yHigh[xRight] &larr; TRUE;                yLow[xLeft] &larr; TRUE;                yHigh[xLeft] &larr; TRUE;                yerror &larr; error + dy;                xyerror &larr; yerror + dx;                IF ABS[xyerror] &lt; ABS[yerror] THEN {                  error &larr; xyerror;                  yLow &larr; yLow + wpl;                  yHigh &larr; yHigh - wpl;                  xRight &larr; xRight + 1;                  xLeft &larr; xLeft - 1;                  safetyCount &larr; safetyCount + 1;                  dx &larr; dx + dxdx;                  dy &larr; dy + dydy}                ELSE {                  error &larr; yerror;                  yLow &larr; yLow + wpl;                  yHigh &larr; yHigh - wpl;                  dy &larr; dy + dydy};                ENDLOOP;              EXIT};            error &larr; xyerror;            yLow &larr; yLow + wpl;            yHigh &larr; yHigh - wpl;            xRight &larr; xRight + 1;            xLeft &larr; xLeft - 1;            dx &larr; dx + dxdx;            dy &larr; dy + dydy}          ELSE {            error &larr; xerror;            xRight &larr; xRight + 1;            xLeft &larr; xLeft - 1;            dx &larr; dx + dxdx};          ENDLOOP;        yLow[xRight] &larr; TRUE;        yLow[xLeft] &larr; TRUE;        -- don't need to set yHigh cause its equal to yLow now        -- loop below fills out long skinny ellipses        UNTIL safetyCount &gt;= xRadius DO          xRight &larr; xRight + 1;          xLeft &larr; xLeft - 1;          yLow[xLeft] &larr; TRUE;          yLow[xRight] &larr; TRUE;          safetyCount &larr; safetyCount + 1          ENDLOOP};      ENDLOOP};  SpEllipse: PUBLIC ENTRY PROC [    window: Handle, center: Window.Place, xRadius, yRadius: INTEGER,    bounds: Window.BoxHandle, dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    ENABLE UNWIND =&gt; NULL;    filled: BOOLEAN = context.alloc # NIL;    firstRec: WindowOps.RecList = DisplayOps.FillList[window, filled];    SpEllipseInternal[      firstRec, filled, window, center, xRadius, yRadius, bounds, dashes, flags,      context]};  SpEllipseInternal: INTERNAL PROC [    firstRec: WindowOps.RecList, filled: BOOLEAN, window: Handle,    center: Window.Place, xRadius, yRadius: INTEGER, bounds: Window.BoxHandle,    dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    absBounds: WindowOps.ScreenBox =      IF bounds = NIL THEN WindowOps.Bounds[window]      ELSE WindowOps.AbsoluteBoxHandle[window, bounds];    -- switch to screen coords    absCenter: Window.Place = DisplayOps.AbsPlace[window, center];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; firstRec, r.link UNTIL r = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN {        ctx: Special = WindowOps.GetContext[r, context];        error: LONG INTEGER &larr; 0;        xerror, yerror, xyerror: LONG INTEGER;        a, b, dx, dy, dxdx, dydy: LONG INTEGER;        xRight: INTEGER &larr; absCenter.x;        xLeft: INTEGER &larr; absCenter.x;        yHighSL: WindowOps.ScanLine &larr; ctx.bmAddress +	  WindowOps.SpecialTimesWpl[INTEGER[absCenter.y - yRadius], ctx];        yLowSL: WindowOps.ScanLine &larr; ctx.bmAddress +	  WindowOps.SpecialTimesWpl[INTEGER[absCenter.y + yRadius], ctx];        yHigh: INTEGER &larr; absCenter.y - yRadius;        yLow: INTEGER &larr; absCenter.y + yRadius;        xTravel: INTEGER &larr; 0;        start1: CARDINAL = 0;        dOrtho: CARDINAL = 5;        dDiag: CARDINAL = 7;        stop1: CARDINAL = dashes.widths[0]*dOrtho;        start2: CARDINAL = stop1 + dashes.widths[1]*dOrtho;        stop2: CARDINAL = start2 + dashes.widths[2]*dOrtho;        start3: CARDINAL = stop2 + dashes.widths[3]*dOrtho;        stop3: CARDINAL = start3 + dashes.widths[4]*dOrtho;        dashSum: CARDINAL = stop3 + dashes.widths[5]*dOrtho;        dashCnt: CARDINAL &larr; 0;        thickness: CARDINAL = dashes.thickness;        left: INTEGER = r.box.left;        right: INTEGER = r.box.right;        top: INTEGER = r.box.top;        bottom: INTEGER = r.box.bottom;        yMin, yLen: INTEGER;  -- used for filing        fillLeft, fillRight: FillHandle;        PaintDot: PROC [x, y: INTEGER, ySL: WindowOps.ScanLine] = INLINE {          IF x IN [left..right) AND y IN [top..bottom) THEN            ySL[x] &larr;              (SELECT DisplayOps.Shade[flags] FROM                 white =&gt; FALSE,                 black =&gt; TRUE,                 ENDCASE =&gt; NOT ySL[x])};        FillLine: PROC [xL, xR, ybiz: INTEGER] = INLINE {          IF ybiz IN [top..bottom) THEN {            xL &larr; MAX[xL, left];            xR &larr; MIN[xR, right];            ybiz &larr; ybiz - yMin;            fillLeft.xs[ybiz] &larr; xL;            fillRight.xs[ybiz] &larr; xR}};        ShallowEllipsePart: PROC[] = {          UNTIL yHighSL &gt;= yLowSL DO            IF NOT filled THEN {              IF                (dashCnt IN [start1..stop1) OR dashCnt IN [start2..stop2)                  OR dashCnt IN [start3..stop3)) THEN {                PaintDot[xRight, yHigh, yHighSL];                PaintDot[xRight, yLow, yLowSL];                PaintDot[xLeft, yHigh, yHighSL];                PaintDot[xLeft, yLow, yLowSL];                IF thickness &gt; 1 THEN {		  quotiet: INTEGER = thickness/2;		  remainder: INTEGER = thickness MOD 2;		  FOR i: INTEGER IN [1..quotiet] DO                    xl: INTEGER = xLeft + i;                    xr: INTEGER = xRight - i;                    PaintDot[xr, yHigh, yHighSL];                    PaintDot[xr, yLow, yLowSL];                    PaintDot[xl, yHigh, yHighSL];                    PaintDot[xl, yLow, yLowSL];                    IF i &lt; quotiet OR remainder = 1 THEN {                      xl: INTEGER = xLeft - i;                      xr: INTEGER = xRight + i;                      PaintDot[xr, yHigh, yHighSL];                      PaintDot[xr, yLow, yLowSL];                      PaintDot[xl, yHigh, yHighSL];                      PaintDot[xl, yLow, yLowSL]};		    ENDLOOP}}}            ELSE {FillLine[xLeft, xRight, yLow]; FillLine[xLeft, xRight, yHigh]};            yerror &larr; error + dy;            xyerror &larr; yerror + dx;            IF ABS[xyerror] &lt; ABS[yerror] THEN {              error &larr; xyerror;              yHighSL &larr; yHighSL + ctx.wpl;              yLowSL &larr; yLowSL - ctx.wpl;              yHigh &larr; yHigh + 1;              yLow &larr; yLow - 1;              xRight &larr; xRight + 1;              xLeft &larr; xLeft - 1;              xTravel &larr; xTravel + 1;              dx &larr; dx + dxdx;              dy &larr; dy + dydy;              dashCnt &larr; dashCnt + dDiag}            ELSE {              error &larr; yerror;              yHighSL &larr; yHighSL + ctx.wpl;              yLowSL &larr; yLowSL - ctx.wpl;              yHigh &larr; yHigh + 1;              yLow &larr; yLow - 1;              dy &larr; dy + dydy;              dashCnt &larr; dashCnt + dOrtho};            UNTIL dashCnt &lt; dashSum DO dashCnt &larr; dashCnt - dashSum ENDLOOP            ENDLOOP;          IF NOT filled THEN {            IF              (dashCnt IN [start1..stop1) OR dashCnt IN [start2..stop2)                OR dashCnt IN [start3..stop3)) THEN {              PaintDot[xRight, yHigh, yHighSL];              PaintDot[xLeft, yHigh, yHighSL];              IF thickness &gt; 1 THEN {	        quotiet: INTEGER = thickness/2;		remainder: INTEGER = thickness MOD 2;	        FOR i: INTEGER IN [1..quotiet] DO                  xl: INTEGER = xLeft + i;                  xr: INTEGER = xRight - i;                  PaintDot[xr, yHigh, yHighSL];                  PaintDot[xl, yHigh, yHighSL];                  IF i &lt; quotiet OR remainder = 1 THEN {                    xl: INTEGER = xLeft - i;                    xr: INTEGER = xRight + i;                    PaintDot[xr, yHigh, yHighSL];                    PaintDot[xl, yHigh, yHighSL]}		  ENDLOOP}}}          ELSE {FillLine[xLeft, xRight, yLow]; FillLine[xLeft, xRight, yHigh]}};        -- start of code        IF filled THEN {          yMin &larr; MAX[r.box.top, absCenter.y - yRadius];          yLen &larr; MIN[r.box.bottom, absCenter.y + yRadius] - yMin + 2;          fillLeft &larr; ctx.alloc[window, yMin, yLen];          fillRight &larr; ctx.alloc[window, yMin, yLen]};        a &larr; LONG[yRadius]*LONG[yRadius];        dxdx &larr; 2*a;        b &larr; LONG[xRadius]*LONG[xRadius];        dydy &larr; 2*b;        dx &larr; a;        dy &larr; b*(1 - 2*yRadius);        -- right up        UNTIL yHighSL &gt;= yLowSL OR xTravel &gt; xRadius DO          IF NOT filled THEN {            IF              (dashCnt IN [start1..stop1) OR dashCnt IN [start2..stop2)                OR dashCnt IN [start3..stop3)) THEN {              PaintDot[xRight, yLow, yLowSL];  -- set bit              PaintDot[xRight, yHigh, yHighSL];              PaintDot[xLeft, yLow, yLowSL];              PaintDot[xLeft, yHigh, yHighSL];              IF thickness &gt; 1 THEN {	        quotiet: INTEGER = thickness/2;		remainder: INTEGER = thickness MOD 2;	        FOR i: INTEGER IN [1..quotiet] DO                  yl: INTEGER = yLow - i;                  yh: INTEGER = yHigh + i;                  yLSL: WindowOps.ScanLine = yLowSL - i*ctx.wpl;                  yHSL: WindowOps.ScanLine = yHighSL + i*ctx.wpl;                  PaintDot[xRight, yl, yLSL];  -- set inside bit                  PaintDot[xRight, yh, yHSL];                  PaintDot[xLeft, yl, yLSL];                  PaintDot[xLeft, yh, yHSL];                  IF i &lt; quotiet OR remainder = 1 THEN {                    yl: INTEGER = yLow + i;                    yh: INTEGER = yHigh - i;                    yLSL: WindowOps.ScanLine = yLowSL + i*ctx.wpl;                    yHSL: WindowOps.ScanLine = yHighSL - i*ctx.wpl;                    PaintDot[xRight, yl, yLSL];  -- set inside bit                    PaintDot[xRight, yh, yHSL];                    PaintDot[xLeft, yl, yLSL];                    PaintDot[xLeft, yh, yHSL]}		  ENDLOOP}}}          ELSE {FillLine[xLeft, xRight, yLow]; FillLine[xLeft, xRight, yHigh]};          xerror &larr; error + dx;          xyerror &larr; xerror + dy;          xTravel &larr; xTravel + 1;          IF ABS[xyerror] &lt; ABS[xerror] THEN {            IF ABS[error + dy] &lt; ABS[xyerror] THEN {              error &larr; error + dy;              yHighSL &larr; yHighSL + ctx.wpl;              yLowSL &larr; yLowSL - ctx.wpl;              yLow &larr; yLow - 1;              yHigh &larr; yHigh + 1;              dy &larr; dy + dydy;              -- Y varies more quickly now              ShallowEllipsePart[];              EXIT};            error &larr; xyerror;            yHighSL &larr; yHighSL + ctx.wpl;            yLowSL &larr; yLowSL - ctx.wpl;            yLow &larr; yLow - 1;            yHigh &larr; yHigh + 1;            xRight &larr; xRight + 1;            xLeft &larr; xLeft - 1;            dx &larr; dx + dxdx;            dy &larr; dy + dydy;            dashCnt &larr; dashCnt + dDiag}          ELSE {            error &larr; xerror;            xRight &larr; xRight + 1;            xLeft &larr; xLeft - 1;            dx &larr; dx + dxdx;            dashCnt &larr; dashCnt + dOrtho};          UNTIL dashCnt &lt; dashSum DO dashCnt &larr; dashCnt - dashSum ENDLOOP;          REPEAT            FINISHED =&gt; {              IF NOT filled THEN {                IF                  (dashCnt IN [start1..stop1) OR dashCnt IN [start2..stop2)                    OR dashCnt IN [start3..stop3)) THEN {                  PaintDot[xLeft, yHigh, yHighSL];                  PaintDot[xRight, yHigh, yHighSL];                  IF thickness &gt; 1 THEN {		    quotiet: INTEGER = thickness/2;		    remainder: INTEGER = thickness MOD 2;		    FOR i: INTEGER IN [1..quotiet] DO                      yh: INTEGER = yHigh + i;                      yHSL: WindowOps.ScanLine = yHighSL + i*ctx.wpl;                      PaintDot[xRight, yh, yHSL];                      PaintDot[xLeft, yh, yHSL];                      IF i &lt; quotiet OR remainder = 1 THEN {                        yh: INTEGER = yHigh - i;                        yHSL: WindowOps.ScanLine = yHighSL - i*ctx.wpl;                        PaintDot[xRight, yh, yHSL];                        PaintDot[xLeft, yh, yHSL]}		      ENDLOOP}}}              ELSE {FillLine[xLeft, xRight, yLow]; FillLine[xLeft, xRight, yHigh]}}          ENDLOOP;        -- don't need to set yLowSL cause its equal to yLowSL now        -- loop below fills out long skinny ellipses        UNTIL xTravel &gt;= xRadius DO          IF NOT filled THEN {            IF              (dashCnt IN [start1..stop1) OR dashCnt IN [start2..stop2)                OR dashCnt IN [start3..stop3)) THEN {              PaintDot[xLeft, yHigh, yHighSL];              PaintDot[xRight, yHigh, yHighSL];              IF thickness &gt; 1 THEN {	        quotiet: INTEGER = thickness/2;	        remainder: INTEGER = thickness MOD 2;	        FOR i: INTEGER IN [1..quotiet] DO                  yh: INTEGER = yHigh + i;                  yHSL: WindowOps.ScanLine = yHighSL + i*ctx.wpl;                  PaintDot[xRight, yh, yHSL];                  PaintDot[xLeft, yh, yHSL];                  IF i &lt; quotiet OR remainder = 1 THEN {                    yh: INTEGER = yHigh - i;                    yHSL: WindowOps.ScanLine = yHighSL - i*ctx.wpl;                    PaintDot[xRight, yh, yHSL];                    PaintDot[xLeft, yh, yHSL]}		  ENDLOOP}}}          ELSE {            diff: INTEGER = xRadius - xTravel;            FillLine[xRight + diff, xLeft - diff, yHigh];            xTravel &larr; xRadius};          xRight &larr; xRight + 1;          xLeft &larr; xLeft - 1;          xTravel &larr; xTravel + 1;          dashCnt &larr; dashCnt + dOrtho;          UNTIL dashCnt &lt; dashSum DO dashCnt &larr; dashCnt - dashSum ENDLOOP;          ENDLOOP};      ENDLOOP};  END.</pre>
  </body>
</html>
