<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>NEWWINDOWS>WindowImplD.mesa!1</title>
  </head>
  <body>
    <pre>
-- Copyright (C) 1982, 1984  by Xerox Corporation. All rights reserved. -- WindowImplD.mesa - last edited by-- Daniels,	18-Jul-84 16:41:19-- Bruce,	15-Oct-82 20:50:46DIRECTORY  BitBlt USING [BBptr],  Display USING [Brick, Gray],  RecOps USING [Convert, RecList],  SpecialDisplay USING [    Handle, LineStyle, LineStyleObject, Special, SpecialContext],  SpecialWindow USING [],  UserTerminal USING [BitmapIsDisconnected, GetBitBltTable],  Window USING [Box, ValidateTree],  WindowOps USING [    bbPtr, Handle, InvalidateTree, lock, Object, WhitenRecList];WindowImplD: MONITOR LOCKS WindowOps.lock  IMPORTS Display, RecOps, UserTerminal, Window, WindowOps  EXPORTS SpecialDisplay, SpecialWindow, Window, WindowOps =    BEGIN  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = WindowOps.Object;  lock: PUBLIC MONITORLOCK;  rootWindow: PUBLIC Handle &larr; NIL;  defaultContext: PUBLIC SpecialDisplay.Special &larr; @mySpecial;  mySpecial: SpecialDisplay.SpecialContext &larr; [    bmAddress: NIL, wpl: TRASH, bpl: TRASH, alloc: NIL, free: NIL];  solid: PUBLIC SpecialDisplay.LineStyle &larr; @mySolid;  mySolid: SpecialDisplay.LineStyleObject &larr; [    widths: [NAT.LAST, 0, 0, 0, 0, 0], thickness: 1];  bitmapAddress: PUBLIC LONG ORDERED POINTER &larr; NIL;  bitmapHeight: PUBLIC CARDINAL;  rootGray: ARRAY [0..4) OF CARDINAL;  Recalculate: PUBLIC PROC [Handle] = {};  -- boo hiss!!  DefineRoot: PUBLIC PROC [    window: Handle, gray: ARRAY [0..4) OF CARDINAL, bitmapExists: BOOLEAN] = {    haveBitmap: BOOLEAN &larr; bitmapExists;    LockedDefine: ENTRY PROC = {      ENABLE UNWIND =&gt; NULL;      IF bitmapExists THEN {        bbt: BitBlt.BBptr &larr; WindowOps.bbPtr;        bbt&uarr; &larr; UserTerminal.GetBitBltTable[          ! UserTerminal.BitmapIsDisconnected =&gt; {	    bitmapExists &larr; FALSE; CONTINUE}]};      IF bitmapExists THEN {        recList: RecOps.RecList;        mySpecial.bmAddress &larr; bitmapAddress &larr; LOOPHOLE[WindowOps.bbPtr.dst.word];	mySpecial.bpl &larr; CARDINAL[WindowOps.bbPtr.dstBpl];	mySpecial.wpl &larr; mySpecial.bpl/16;	bitmapHeight &larr; WindowOps.bbPtr.height;        rootWindow &larr; window;        rootWindow.beingDisplayed &larr; FALSE;        rootWindow.clearingRequired &larr; FALSE;        rootWindow.inTree &larr; TRUE;        rootWindow.parent &larr; NIL;        rootWindow.place &larr; [0, 0];        rootWindow.display &larr; DisplayRootWindow;        rootWindow.invalid &larr; NIL;        rootWindow.badPhosphor &larr; NIL;        rootGray &larr; gray;	WindowOps.WhitenRecList[recList &larr; RecOps.Convert[rootWindow]];        WindowOps.InvalidateTree[rootWindow, rootWindow.child, recList]}      ELSE {        rootWindow &larr; window;        rootWindow.parent &larr; NIL;        rootWindow.display &larr; NIL;        rootWindow.inTree &larr; FALSE}};    LockedDefine[];    IF bitmapExists THEN Window.ValidateTree[rootWindow]};  DisplayRootWindow: PROC [window: Handle] = {    gray: Display.Brick = DESCRIPTOR[rootGray];    Display.Gray[window, window.box, gray]};  END.</pre>
  </body>
</html>
