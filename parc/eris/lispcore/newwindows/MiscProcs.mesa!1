--MiscProcs.mesa--Frank 	6-Jun-84 18:20:59--Lu	19-Dec-84 15:39:07DIRECTORY  Heap,  String;MiscProcs: PROGRAM IMPORTS Heap, String =  BEGIN  ArraySize: CARDINAL = 12;  A: ARRAY [0..ArraySize] OF CARDINAL ¬ ALL[0];  Node: TYPE = RECORD [str: LONG STRING ¬ NIL, next: NodePtr ¬ NIL];  NodePtr: TYPE = LONG POINTER TO Node;  headNode: NodePtr ¬ NIL;  z: UNCOUNTED ZONE = Heap.Create[initial: 1];  Interchange: PROC [thisOne, thatOne: CARDINAL] =    BEGIN    --interchange the two elements whose address in array are "thisOne" & "thatOne"    temp: CARDINAL ¬ A[thisOne];    A[thisOne] ¬ A[thatOne];    A[thatOne] ¬ temp;    END;  Factorial: PROC [number: CARDINAL] RETURNS [j: CARDINAL] =    BEGIN    factorialOfZero: CARDINAL = 1;    inputTooBig: CARDINAL = 0;    SELECT number FROM      0 => RETURN[factorialOfZero];      IN [1..12] => RETURN[number * Factorial[number - 1]];      ENDCASE => RETURN[inputTooBig];    END;  MakeLinkedList: PROC [howManyNodes: CARDINAL] =    BEGIN    ptr1, ptr2: NodePtr;    char: CHAR ¬ 'A;    FreeOldNodes[@headNode];  --destroy old linked list    FOR i: CARDINAL IN [0..howManyNodes) DO      ptr1 ¬ z.NEW[Node ¬ [str: String.MakeString[z: z, maxlength: 1]]];      String.AppendChar[ptr1.str, char];  --Store char in record (ptr1^)      char ¬ SUCC[char];  --If char = 'A THEN char ¬ 'B, etc.      ptr2 ¬ headNode;      headNode ¬ ptr1;      headNode.next ¬ ptr2;      ptr1 ¬ NIL;      ENDLOOP;    END;  FreeOldNodes: PROC [node: LONG POINTER TO NodePtr] =    BEGIN    IF node^ = NIL THEN RETURN;    IF node.next = NIL THEN z.FREE[node] ELSE FreeOldNodes[@node.next];    END;  END.