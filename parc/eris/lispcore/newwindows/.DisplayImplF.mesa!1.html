<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>NEWWINDOWS>DisplayImplF.mesa!1</title>
  </head>
  <body>
    <pre>
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- DisplayImplF.mesa - last edited by -- S. Schiller		 8-Mar-83 18:06:34-- Rick			22-Nov-83 17:37:12-- Bruce		24-Feb-83 16:08:51-- Poskanzer		20-May-83  9:04:41DIRECTORY  BitBlt USING [BitBltFlags],  Display USING [],  DisplayOps USING [    AbsPlace, Color, LogError, FillList, FillObject, Intersect, Shade],  DisplayInternal USING [],  IVector USING [IPoint, IVec],  SpecialDisplay USING [defaultContext, LineStyle, solid, Special],  Window USING [BoxHandle, Place],  WindowOps USING [    AbsoluteBoxHandle, Bounds, DisplayList, GetContext, lock, Object, RecList,    ScanLine, ScreenBox, SpecialTimesWpl];DisplayImplF: MONITOR LOCKS WindowOps.lock  IMPORTS DisplayOps, SpecialDisplay, WindowOps  EXPORTS DisplayInternal, SpecialDisplay, Window =  BEGIN  -- exported types  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = WindowOps.Object;  FillHandle: TYPE = LONG POINTER TO FillObject;  FillObject: PUBLIC TYPE = DisplayOps.FillObject;  -- copied types because John doesn't like them  LineStyle: TYPE = SpecialDisplay.LineStyle;  Special: TYPE = SpecialDisplay.Special;  yMin, yLen: INTEGER;  -- used for filing  fillLeft, fillRight: FillHandle;  gA, gB, gC: LONG INTEGER;  -- global coefficients for conic  gD, gE: LONG INTEGER;  gF: REAL;  gStop: IVector.IPoint;  -- global stop place  gOrg: Window.Place;  -- origin for coeffs  clip: WindowOps.RecList;  globeContext: Special;  globeShade: DisplayOps.Color;  StoreGlobalCoeffs: PROC [    a, b, c, d, e, errorTerm: LONG INTEGER, start: IVector.IPoint] = {    gA &larr; a; gB &larr; b; gC &larr; c; gD &larr; d; gE &larr; e; gF &larr; errorTerm - ConicEval[start]};  ConicEval: PROC [p: IVector.IPoint] RETURNS [REAL] = {    x: REAL = p.x - gOrg.x;    y: REAL = p.y - gOrg.y;    RETURN[gA*x*x + y*y*gB + x*y*gC + gD*x + gE*y]};  DxDyToSlopeDir: PUBLIC PROC [dx, dy: LONG INTEGER]    RETURNS [xDir, yDir: INTEGER] = {    SELECT dx FROM  -- Note, position goes up as y decreases      &lt; 0 =&gt; IF dy &gt;= 0 THEN {xDir &larr; -1; yDir &larr; 1} ELSE {xDir &larr; -1; yDir &larr; -1};      &gt; 0 =&gt; IF dy &gt; 0 THEN {xDir &larr; 1; yDir &larr; 1} ELSE {xDir &larr; 1; yDir &larr; -1};      ENDCASE =&gt;        IF dy &gt; 0 THEN {xDir &larr; 1; yDir &larr; 1} ELSE {xDir &larr; -1; yDir &larr; -1}};  DxConic: PROC [place: IVector.IPoint] RETURNS [LONG INTEGER] = {    RETURN[2*gA*(place.x - gOrg.x) + gC*(place.y - gOrg.y) + gD]};  DyConic: PROC [place: IVector.IPoint] RETURNS [LONG INTEGER] = {    RETURN[2*gB*(place.y - gOrg.y) + gC*(place.x - gOrg.x) + gE]};  Conic: PUBLIC ENTRY PROC [    window: Handle, a, b, c, d, e, errorTerm: LONG INTEGER,    start, stop, origin: Window.Place, sharpCornered: BOOLEAN,    bounds: Window.BoxHandle &larr; NIL] = {    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox =      IF bounds = NIL THEN WindowOps.Bounds[window]      ELSE WindowOps.AbsoluteBoxHandle[window, bounds];    absStart: Window.Place = DisplayOps.AbsPlace[window, start];    absStop: Window.Place = DisplayOps.AbsPlace[window, stop];    gOrg &larr; DisplayOps.AbsPlace[window, origin];    globeShade &larr; black;    IF ~window.inTree THEN RETURN;    StoreGlobalCoeffs[a, b, c, d, e, errorTerm, absStart];    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link UNTIL r =      NIL DO      clip &larr; r;      IF DisplayOps.Intersect[r, absBounds] THEN {        globeContext &larr; SpecialDisplay.defaultContext;        DDAStartUp[          start: absStart, stop: absStop, startError: errorTerm,          selected: FALSE, filled: FALSE, sharp: sharpCornered,          dashes: SpecialDisplay.solid]};      ENDLOOP};  SpecialConic: PUBLIC ENTRY PROC [    window: Handle, a, b, c, d, e, errorTerm: LONG INTEGER,    start, stop, origin: Window.Place, sharpCornered: BOOLEAN,    bounds: Window.BoxHandle, dashes: SpecialDisplay.LineStyle,    flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox =      IF bounds = NIL THEN WindowOps.Bounds[window]      ELSE WindowOps.AbsoluteBoxHandle[window, bounds];    absStart: Window.Place = DisplayOps.AbsPlace[window, start];    absStop: Window.Place = DisplayOps.AbsPlace[window, stop];    filled: BOOLEAN = context.alloc # NIL;    gOrg &larr; DisplayOps.AbsPlace[window, origin];    globeShade &larr; DisplayOps.Shade[flags];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; DisplayOps.FillList[window, filled], r.link UNTIL      r = NIL DO      globeContext &larr; WindowOps.GetContext[r, context];      clip &larr; r;      IF DisplayOps.Intersect[r, absBounds] THEN {        StoreGlobalCoeffs[a, b, c, d, e, errorTerm, absStart];        IF filled THEN {          yMin &larr; MAX[r.box.top, absBounds.top] - 1;  -- add saftey bit below          yLen &larr; MIN[r.box.bottom, absBounds.bottom] - yMin + 1;  -- and above          fillLeft &larr; globeContext.alloc[window, yMin, yLen];          fillRight &larr; globeContext.alloc[window, yMin, yLen]};        DDAStartUp[          absStart, absStop, errorTerm, TRUE, filled, sharpCornered, dashes];        IF filled THEN {  -- clip fill arrays to window          FOR i: INTEGER IN [0..yLen) DO            fillLeft.xs[i] &larr; MIN[              MAX[fillLeft.xs[i], r.box.left], r.box.right];            fillRight.xs[i] &larr; MIN[              MAX[fillRight.xs[i], r.box.left], r.box.right];            ENDLOOP}};      ENDLOOP};  -- variables below are initalized by DDAStartUp and used by DDA routines.  -- DDALoopCount, dot, xDot, yDot, xyDot and inBox are also updated   -- by DDA routines.  stopInRightUpDDA, stopInLeftUpDDA, stopInLeftDownDDA, stopInRightDownDDA:    BOOLEAN;  -- informs apprpriate DDA to check if it is passing stop point  DDALoopMax, DDALoopCount: CARDINAL;  -- used make sure we dont stop too soon  dx, dy, dxdy, dxdx, dydy: LONG INTEGER;  dot, xDot, yDot, xyDot, newXyDot: INTEGER;  --used to corerce sharp corned curves  dotVec: IVector.IVec;  dotFudge: INTEGER = -1;  -- more sharp cornered stuff  inBox: BOOLEAN;  -- true if point currently maintained in DDA in visible  oldX, oldY: INTEGER;  gSelected: BOOLEAN &larr; FALSE;  -- global selected  gFilled: BOOLEAN;  -- global filled  gSharp: BOOLEAN;  -- global sharp flag  -- dashed lines stuff below  dOrtho: CARDINAL = 5;  dDiag: CARDINAL = 7;  start1: CARDINAL = 0;  stop1, start2, stop2, start3, stop3: CARDINAL;  dashSum, dashCnt: CARDINAL;  thickness: CARDINAL;  -- line thickness  dotVisible: BOOLEAN;  DotVisible: PROC [x, y: INTEGER] RETURNS [BOOLEAN] = INLINE {    RETURN[      x IN [clip.box.left..clip.box.right)        AND y IN [clip.box.top..clip.box.bottom)]};  DDAStartUp: PROC [    start, stop: IVector.IPoint, startError: LONG INTEGER, selected: BOOLEAN,    filled: BOOLEAN, sharp: BOOLEAN, dashes: LineStyle] = {    dxStart: LONG INTEGER &larr; DyConic[start];    dyStart: LONG INTEGER &larr; -DxConic[start];    dxStop: LONG INTEGER &larr; DyConic[stop];    dyStop: LONG INTEGER &larr; -DxConic[stop];    startXDir, startYDir, stopXDir, stopYDir: INTEGER;    Slope: TYPE = RECORD [xDir, yDir: INTEGER];    x: INTEGER = start.x;    y: INTEGER = start.y;    -- Returns true if we have to loop around the curve to get from start    -- to stop, note start = stop returns TRUE.    StartAfterStop: PROC [xDir, yDir: INTEGER] RETURNS [BOOLEAN] = INLINE {      RETURN[        xDir*(start.x - stop.x) &gt; 0 OR yDir*(start.y - stop.y) &gt; 0          OR (start.x = stop.x AND start.y = stop.y -- for ellipses -- )]};    -- set up global variables    gStop &larr; stop;    gFilled &larr; filled;    gSharp &larr; sharp;    gSelected &larr; selected;    -- set up line style parameters    thickness &larr; dashes.thickness;    stop1 &larr; dashes.widths[0]*dOrtho;    start2 &larr; stop1 + dashes.widths[1]*dOrtho;    stop2 &larr; start2 + dashes.widths[2]*dOrtho;    start3 &larr; stop2 + dashes.widths[3]*dOrtho;    stop3 &larr; start3 + dashes.widths[4]*dOrtho;    dashSum &larr; stop3 + dashes.widths[5]*dOrtho;    dashCnt &larr; 0;    -- set up loop monitoring and stop detection    DDALoopCount &larr; 0;    DDALoopMax &larr; 0;    stopInRightUpDDA &larr; stopInLeftUpDDA &larr; stopInLeftDownDDA &larr; stopInRightDownDDA      &larr; FALSE;    -- set up DDA parameters    dxdy &larr; gC;    dxdx &larr; gA*2;    dydy &larr; gB*2;    -- inBox used to for fill projections stuff    inBox &larr; DotVisible[start.x, start.y];    IF sharp THEN {      -- set up parameters for keeping conic on right side of line      xDif: INTEGER = stop.x - start.x;      yDif: INTEGER = stop.y - start.y;      tan45: INTEGER = 1;  -- tangent of 45 degrees, rotation angle      -- below does a psuedo rotation by arctan[tan45];      dxStart &larr; xDif/tan45 - yDif;      dyStart &larr; xDif + yDif/tan45;      dxStop &larr; xDif/tan45 + yDif;      dyStop &larr; -xDif + yDif/tan45;      dotVec &larr; [-yDif, xDif];      dot &larr; 0};    [xDir: stopXDir, yDir: stopYDir] &larr; DxDyToSlopeDir[dxStop, dyStop];    SELECT Slope[xDir: stopXDir, yDir: stopYDir] FROM      [1, -1] =&gt; stopInRightUpDDA &larr; TRUE;      [-1, -1] =&gt; stopInLeftUpDDA &larr; TRUE;      [-1, 1] =&gt; stopInLeftDownDDA &larr; TRUE;      [1, 1] =&gt; stopInRightDownDDA &larr; TRUE;      ENDCASE;    [xDir: startXDir, yDir: startYDir] &larr; DxDyToSlopeDir[dxStart, dyStart];    SELECT Slope[xDir: startXDir, yDir: startYDir] FROM      [1, -1] =&gt; {        IF stopInRightUpDDA AND StartAfterStop[xDir: startXDir, yDir: startYDir]          THEN DDALoopMax &larr; 2;        RightUpORLeftDown[start: start, error: startError, isRightUp: TRUE]};      [-1, -1] =&gt; {        IF stopInLeftUpDDA AND StartAfterStop[xDir: startXDir, yDir: startYDir]          THEN DDALoopMax &larr; 2;        LeftUpORRightDown[start: start, error: startError, isLeftUp: TRUE]};      [-1, 1] =&gt; {        IF stopInLeftDownDDA          AND StartAfterStop[xDir: startXDir, yDir: startYDir] THEN          DDALoopMax &larr; 2;        RightUpORLeftDown[start: start, error: startError, isRightUp: FALSE]};      [1, 1] =&gt; {        IF stopInRightDownDDA          AND StartAfterStop[xDir: startXDir, yDir: startYDir] THEN          DDALoopMax &larr; 2;        LeftUpORRightDown[start: start, error: startError, isLeftUp: FALSE]};      ENDCASE};  -- Below are two DDA routines.  -- They are pretty much the same, the difference being that one  -- is optimized to handle the right-up and left-down directions   -- while the other handles the left-up and right-down directions.  -- IMPORTANT NOTE FOR MODIFICATIONS:  -- If you fix a bug in one  of the DDA routines, most likely you need to  -- fix it in the other.  In this case note the following symetry  -- in the code of the routines. Each DDA routine consists of two parts,  -- a steep DDA and a shalow DDA.  In one the shallow DDA is first and  -- in the other the steep DDA is first. The difference between a steep DDA  -- and a shalow DDA is that x and y are interchanged.  The difference  -- between  first and second DDAs is that different variables are  -- maintained and used to determine the direction of the next move.  -- (in particluar, newXyerror is used in place of xyerror in the second DDA.)  -- The only other differences in the routines are 1) they have different   -- names, 2) the declarations of the constants checkYstop and checkXstop and the  -- INLINE procedures  xDir and yDir and  the StartFillSeg EndFillSeg INLINES, 3)  -- The DDA's they call when done with their section of the curve are  -- different. There is one other important asymetry: RightUpORLeftDown  -- increments the variable DDALoopCount, while the other one doesn't.  RightUpORLeftDown: PROC [    start: IVector.IPoint, error: LONG INTEGER, isRightUp: BOOLEAN] = {    xDir: PROC [i: INTEGER] RETURNS [INTEGER] = INLINE {      RETURN[IF isRightUp THEN i ELSE -i]};    yDir: PROC [i: INTEGER] RETURNS [INTEGER] = INLINE {      RETURN[IF isRightUp THEN -i ELSE i]};    xDirL: PROC [i: LONG INTEGER] RETURNS [LONG INTEGER] = INLINE {      RETURN[IF isRightUp THEN i ELSE -i]};    yDirL: PROC [i: LONG INTEGER] RETURNS [LONG INTEGER] = INLINE {      RETURN[IF isRightUp THEN -i ELSE i]};    newDy, newDx: LONG INTEGER;    xerror, yerror, xyerror, newXyerror: LONG INTEGER;    x: INTEGER &larr; start.x;    y: INTEGER &larr; start.y;    ySL: WindowOps.ScanLine &larr;      globeContext.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[start.y],      globeContext];    checkYstop: BOOLEAN =      IF isRightUp THEN (stopInRightUpDDA OR stopInLeftUpDDA)      AND DDALoopMax &lt;= DDALoopCount      ELSE (stopInLeftDownDDA OR stopInRightDownDDA)        AND DDALoopMax &lt;= DDALoopCount;    checkXstop: BOOLEAN =      IF isRightUp THEN stopInRightUpDDA AND DDALoopMax &lt;= DDALoopCount      ELSE stopInLeftDownDDA AND DDALoopMax &lt;= DDALoopCount;    StartFillSegment: PROC [x, y: INTEGER] = INLINE {      IF gFilled AND y IN [clip.box.top..clip.box.bottom) THEN {        y &larr; y - yMin;        IF y &lt; 0 OR y &gt;= yLen THEN DisplayOps.LogError[];        IF isRightUp THEN fillRight.xs[y] &larr; x ELSE fillLeft.xs[y] &larr; x}};    EndFillSegment: PROC [x, y: INTEGER] = INLINE {      IF gFilled AND y IN [clip.box.top..clip.box.bottom) THEN {        y &larr; y - yMin;        IF y &lt; 0 OR y &gt;= yLen THEN DisplayOps.LogError[];        IF isRightUp THEN fillRight.xs[y] &larr; x ELSE fillLeft.xs[y] &larr; x}};    IncDDALoopCount: PROC = {      DDALoopCount &larr; DDALoopCount + 1;      IF DDALoopCount &gt; 2 THEN DisplayOps.LogError[infiniteConicDDALoop]};    --    StartFillSegment[x, y];    dx &larr; DxConic[start] + xDirL[gA];    dy &larr; DyConic[start] + yDirL[gB];    oldX &larr; x;    oldY &larr; y;    -- shallow part    UNTIL checkXstop AND xDir[x - gStop.x] &gt;= 0      OR checkYstop AND yDir[y - gStop.y] &gt; 0 DO      -- x varies more quickly      xerror &larr; error + xDirL[dx];      newDy &larr; dy + xDirL[dxdy];      xyerror &larr; xerror + yDirL[newDy];      yerror &larr; error + yDirL[dy];      IF gSharp THEN {        xDot &larr; dot + xDir[dotVec.x];        xyDot &larr; xDot + yDir[dotVec.y];        yDot &larr; dot + yDir[dotVec.y]};      IF xerror &lt;= 0 OR (xyerror &lt;= 0 AND xerror &lt;= -xyerror)        OR (gSharp AND xyDot &lt;= dotFudge) THEN {  -- inc x only        error &larr; xerror;        x &larr; x + xDir[1];        dx &larr; dx + xDirL[dxdx];        dy &larr; newDy;        dot &larr; xDot;        dashCnt &larr; dashCnt + dOrtho}      ELSE        IF xyerror &lt;= 0 OR (yerror &lt;= 0 AND xyerror &lt;= -yerror)          OR (gSharp AND yDot &lt;= dotFudge) THEN {  -- both x and y change          error &larr; xyerror;          ySL &larr; ySL + yDir[globeContext.wpl];          y &larr; y + yDir[1];          x &larr; x + xDir[1];          dx &larr; dx + xDirL[dxdx] + yDirL[dxdy];          dy &larr; newDy + yDirL[dydy];          dot &larr; xyDot;          dashCnt &larr; dashCnt + dDiag;          EndFillSegment[oldX, oldY];          StartFillSegment[x, y]}        ELSE EXIT;      -- "paint dot"      dotVisible &larr; DotVisible[x, y];      UNTIL dashCnt &lt; dashSum DO dashCnt &larr; dashCnt - dashSum ENDLOOP;      IF NOT gFilled        AND          (dashCnt IN [start1..stop1) OR dashCnt IN [start2..stop2)            OR dashCnt IN [start3..stop3)) THEN {        IF dotVisible THEN          ySL[x] &larr;            (SELECT globeShade FROM               white =&gt; FALSE,               black =&gt; TRUE,               ENDCASE =&gt; ~ySL[x]);        IF thickness &gt; 1 THEN {  -- shalow part, interior above	  quotiet: INTEGER = thickness/2;	  remainder: INTEGER = thickness MOD 2;	  FOR i: INTEGER IN [1..quotiet] DO            thickY: INTEGER &larr; y + yDir[i];            thickYSL: WindowOps.ScanLine &larr; ySL + yDir[i*globeContext.wpl];            IF DotVisible[x, thickY] THEN              thickYSL[x] &larr;                (SELECT globeShade FROM                   white =&gt; FALSE,                   black =&gt; TRUE,                   ENDCASE =&gt; ~thickYSL[x]);            IF i &lt; quotiet OR remainder = 1 THEN {              thickY &larr; y - yDir[i];              thickYSL &larr; ySL - yDir[i*globeContext.wpl];              IF DotVisible[x, thickY] THEN                thickYSL[x] &larr;                  (SELECT globeShade FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~thickYSL[x])};	     ENDLOOP}};      oldX &larr; x;      oldY &larr; y;      REPEAT FINISHED =&gt; {EndFillSegment[x, y]; RETURN}      ENDLOOP;    EndFillSegment[x, y];    -- steep part    UNTIL checkXstop AND xDir[x - gStop.x] &gt; 0      OR checkYstop AND yDir[y - gStop.y] &gt;= 0 DO      yerror &larr; error + yDirL[dy];      newDx &larr; dx + yDirL[dxdy];      xyerror &larr; yerror + xDirL[newDx];      newXyerror &larr; yerror - xDirL[newDx] + dxdx;      IF gSharp THEN {        yDot &larr; dot + yDir[dotVec.y];        xyDot &larr; yDot + xDir[dotVec.x];        newXyDot &larr; yDot - xDir[dotVec.x]};      IF xyerror &lt;= 0 OR (yerror &lt;= 0 AND xyerror &lt;= -yerror)        OR (gSharp AND yDot &lt;= dotFudge) THEN {  -- both change        error &larr; xyerror;        ySL &larr; ySL + yDir[globeContext.wpl];        y &larr; y + yDir[1];        x &larr; x + xDir[1];        dx &larr; newDx + xDirL[dxdx];        dy &larr; dy + yDirL[dydy] + xDirL[dxdy];        dot &larr; xyDot;        dashCnt &larr; dashCnt + dDiag}      ELSE        IF yerror &lt;= 0 OR (newXyerror &lt;= 0 AND yerror &lt;= -newXyerror)          OR (gSharp AND newXyDot &lt;= dotFudge) THEN {  -- only y changes          error &larr; yerror;          ySL &larr; ySL + yDir[globeContext.wpl];          y &larr; y + yDir[1];          dx &larr; newDx;          dy &larr; dy + yDirL[dydy];          dot &larr; yDot;          dashCnt &larr; dashCnt + dOrtho}        ELSE EXIT;      dotVisible &larr; DotVisible[x, y];      UNTIL dashCnt &lt; dashSum DO dashCnt &larr; dashCnt - dashSum ENDLOOP;      IF NOT gFilled        AND          (dashCnt IN [start1..stop1) OR dashCnt IN [start2..stop2)            OR dashCnt IN [start3..stop3)) THEN {        IF dotVisible THEN          ySL[x] &larr;            (SELECT globeShade FROM               white =&gt; FALSE,               black =&gt; TRUE,               ENDCASE =&gt; ~ySL[x]);        IF thickness &gt; 1 THEN {  -- steep part, interior to the left	  quotiet: INTEGER = thickness/2;	  remainder: INTEGER = thickness MOD 2;	  FOR i: INTEGER IN [1..quotiet] DO             thickX: INTEGER &larr; x - xDir[i];            IF DotVisible[thickX, y] THEN              ySL[thickX] &larr;                (SELECT globeShade FROM                   white =&gt; FALSE,                   black =&gt; TRUE,                   ENDCASE =&gt; ~ySL[thickX]);            IF i &lt; quotiet OR remainder = 1 THEN {              thickX &larr; x + xDir[i];              IF DotVisible[thickX, y] THEN                ySL[thickX] &larr;                  (SELECT globeShade FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~ySL[thickX])};	     ENDLOOP}};      StartFillSegment[x, y];      EndFillSegment[x, y];      oldX &larr; x;      oldY &larr; y;      REPEAT FINISHED =&gt; {RETURN}      ENDLOOP;    IncDDALoopCount[];    LeftUpORRightDown[start: [x, y], error: error, isLeftUp: isRightUp]};  LeftUpORRightDown: PROC [    start: IVector.IPoint, error: LONG INTEGER, isLeftUp: BOOLEAN] = {    xDir: PROC [i: INTEGER] RETURNS [INTEGER] = INLINE {      RETURN[IF isLeftUp THEN -i ELSE i]};    yDir: PROC [i: INTEGER] RETURNS [INTEGER] = INLINE {      RETURN[IF isLeftUp THEN -i ELSE i]};    xDirL: PROC [i: LONG INTEGER] RETURNS [LONG INTEGER] = INLINE {      RETURN[IF isLeftUp THEN -i ELSE i]};    yDirL: PROC [i: LONG INTEGER] RETURNS [LONG INTEGER] = INLINE {      RETURN[IF isLeftUp THEN -i ELSE i]};    newDy, newDx: LONG INTEGER;    xerror, yerror, xyerror, newXyerror: LONG INTEGER;    x: INTEGER &larr; start.x;    y: INTEGER &larr; start.y;    ySL: WindowOps.ScanLine &larr;      globeContext.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[start.y],      globeContext];    checkXstop: BOOLEAN =      IF isLeftUp THEN (stopInLeftUpDDA OR stopInLeftDownDDA)      AND DDALoopMax &lt;= DDALoopCount      ELSE (stopInRightDownDDA OR stopInRightUpDDA)        AND DDALoopMax &lt;= DDALoopCount;    checkYstop: BOOLEAN =      IF isLeftUp THEN stopInLeftUpDDA AND DDALoopMax &lt;= DDALoopCount      ELSE stopInRightDownDDA AND DDALoopMax &lt;= DDALoopCount;    StartFillSegment: PROC [x, y: INTEGER] = INLINE {      IF gFilled AND y IN [clip.box.top..clip.box.bottom) THEN {        y &larr; y - yMin;        IF y &lt; 0 OR y &gt;= yLen THEN DisplayOps.LogError[];        IF isLeftUp THEN fillRight.xs[y] &larr; x ELSE fillLeft.xs[y] &larr; x}};    EndFillSegment: PROC [x, y: INTEGER] = INLINE {      IF gFilled AND y IN [clip.box.top..clip.box.bottom) THEN {        y &larr; y - yMin;        IF y &lt; 0 OR y &gt;= yLen THEN DisplayOps.LogError[];        IF isLeftUp THEN fillRight.xs[y] &larr; x ELSE fillLeft.xs[y] &larr; x}};    --    StartFillSegment[x, y];    EndFillSegment[x, y];    dx &larr; DxConic[start] + xDirL[gA];    dy &larr; DyConic[start] + yDirL[gB];    oldX &larr; x;    oldY &larr; y;    -- steep part    UNTIL checkXstop AND xDir[x - gStop.x] &gt; 0      OR checkYstop AND yDir[y - gStop.y] &gt;= 0 DO      -- y varies more quickly      yerror &larr; error + yDirL[dy];      newDx &larr; dx + yDirL[dxdy];      xyerror &larr; yerror + xDirL[newDx];      xerror &larr; error + xDirL[dx];      IF gSharp THEN {        xDot &larr; dot + xDir[dotVec.x];        xyDot &larr; xDot + yDir[dotVec.y];        yDot &larr; dot + yDir[dotVec.y]};      IF yerror &lt;= 0 OR (xyerror &lt;= 0 AND yerror &lt;= -xyerror)        OR (gSharp AND xyDot &lt;= dotFudge) THEN {  -- only y changes        error &larr; yerror;        ySL &larr; ySL + yDir[globeContext.wpl];        y &larr; y + yDir[1];        dx &larr; newDx;        dy &larr; dy + yDirL[dydy];        dot &larr; yDot;        dashCnt &larr; dashCnt + dOrtho}      ELSE        IF xyerror &lt;= 0 OR (xerror &lt;= 0 AND xyerror &lt;= -xerror)          OR (gSharp AND xDot &lt;= dotFudge) THEN {  -- both change          error &larr; xyerror;          ySL &larr; ySL + yDir[globeContext.wpl];          y &larr; y + yDir[1];          x &larr; x + xDir[1];          dx &larr; newDx + xDirL[dxdx];          dy &larr; dy + yDirL[dydy] + xDirL[dxdy];          dot &larr; xyDot;          dashCnt &larr; dashCnt + dDiag}        ELSE EXIT;      dotVisible &larr; DotVisible[x, y];      UNTIL dashCnt &lt; dashSum DO dashCnt &larr; dashCnt - dashSum ENDLOOP;      IF NOT gFilled        AND          (dashCnt IN [start1..stop1) OR dashCnt IN [start2..stop2)            OR dashCnt IN [start3..stop3)) THEN {        IF dotVisible THEN          ySL[x] &larr;            (SELECT globeShade FROM               white =&gt; FALSE,               black =&gt; TRUE,               ENDCASE =&gt; ~ySL[x]);        IF thickness &gt; 1 THEN {  -- steep part, interior to the left 	  quotiet: INTEGER = thickness/2;	  remainder: INTEGER = thickness MOD 2;	  FOR i: INTEGER IN [1..quotiet] DO            thickX: INTEGER &larr; x + xDir[i];            IF DotVisible[thickX, y] THEN              ySL[thickX] &larr;                (SELECT globeShade FROM                   white =&gt; FALSE,                   black =&gt; TRUE,                   ENDCASE =&gt; ~ySL[thickX]);            IF i &lt; quotiet OR remainder = 1 THEN {              thickX &larr; x - xDir[i];              IF DotVisible[thickX, y] THEN                ySL[thickX] &larr;                  (SELECT globeShade FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~ySL[thickX])};	     ENDLOOP}};      StartFillSegment[x, y];      EndFillSegment[x, y];      oldX &larr; x;      oldY &larr; y;      REPEAT FINISHED =&gt; {RETURN}      ENDLOOP;    -- shallow part    oldX &larr; x;    oldY &larr; y;    StartFillSegment[x, y];    UNTIL checkXstop AND xDir[x - gStop.x] &gt;= 0      OR checkYstop AND yDir[y - gStop.y] &gt; 0 DO      xerror &larr; error + xDirL[dx];      newDy &larr; dy + xDirL[dxdy];      xyerror &larr; xerror + yDirL[newDy];      newXyerror &larr; xerror - yDirL[newDy] + dydy;      IF gSharp THEN {        xDot &larr; dot + xDir[dotVec.x];        xyDot &larr; xDot + yDir[dotVec.y];        newXyDot &larr; xDot - yDir[dotVec.y]};      IF xyerror &lt;= 0 OR (xerror &lt;= 0 AND xyerror &lt;= -xerror)        OR (gSharp AND xDot &lt;= dotFudge) THEN {  -- both change        error &larr; xyerror;        ySL &larr; ySL + yDir[globeContext.wpl];        y &larr; y + yDir[1];        x &larr; x + xDir[1];        dx &larr; dx + xDirL[dxdx] + yDirL[dxdy];        dy &larr; newDy + yDirL[dydy];        dot &larr; xyDot;        dashCnt &larr; dashCnt + dDiag;        EndFillSegment[oldX, oldY];        StartFillSegment[x, y]}      ELSE        IF xerror &lt;= 0 OR (newXyerror &lt;= 0 AND xerror &lt;= -newXyerror)          OR (gSharp AND newXyDot &lt;= dotFudge) THEN {  -- only x changes          error &larr; xerror;          x &larr; x + xDir[1];          dx &larr; dx + xDirL[dxdx];          dy &larr; newDy;          dashCnt &larr; dashCnt + dOrtho;          dot &larr; xDot}        ELSE EXIT;      dotVisible &larr; DotVisible[x, y];      UNTIL dashCnt &lt; dashSum DO dashCnt &larr; dashCnt - dashSum ENDLOOP;      IF NOT gFilled        AND          (dashCnt IN [start1..stop1) OR dashCnt IN [start2..stop2)            OR dashCnt IN [start3..stop3)) THEN {        IF dotVisible THEN          ySL[x] &larr;            (SELECT globeShade FROM               white =&gt; FALSE,               black =&gt; TRUE,               ENDCASE =&gt; ~ySL[x]);        IF thickness &gt; 1 THEN {  -- shalow part, interior below	  quotiet: INTEGER = thickness/2;	  remainder: INTEGER = thickness MOD 2;	  FOR i: INTEGER IN [1..quotiet] DO            thickY: INTEGER &larr; y - yDir[i];            thickYSL: WindowOps.ScanLine &larr; ySL - yDir[i*globeContext.wpl];            IF DotVisible[x, thickY] THEN              thickYSL[x] &larr;                (SELECT globeShade FROM                   white =&gt; FALSE,                   black =&gt; TRUE,                   ENDCASE =&gt; ~thickYSL[x]);            IF i &lt; quotiet OR remainder = 1 THEN {              thickY &larr; y + yDir[i];              thickYSL &larr; ySL + yDir[i*globeContext.wpl];              IF DotVisible[x, thickY] THEN                thickYSL[x] &larr;                  (SELECT globeShade FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~thickYSL[x])};	     ENDLOOP}};      oldX &larr; x;      oldY &larr; y;      REPEAT FINISHED =&gt; {EndFillSegment[x, y]; RETURN}      ENDLOOP;    EndFillSegment[x, y];    RightUpORLeftDown[start: [x, y], error: error, isRightUp: NOT isLeftUp]};  END.</pre>
  </body>
</html>
