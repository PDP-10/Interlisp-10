<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>NEWWINDOWS>RectangleImpl.mesa!1</title>
  </head>
  <body>
    <pre>
-- Copyright (C) 1982, 1984  by Xerox Corporation. All rights reserved. -- RectangleImpl.mesa - last edited by--  Bruce	20-Dec-82 17:37:23--  Daniels	 6-Jun-84 14:20:18--  Karlton	30-Dec-82 14:50:19DIRECTORY  BitBlt: TYPE USING [BITBLT, BitBltFlags],  Environment: TYPE USING [wordsPerPage],  Inline: TYPE USING [LongMult],  RecOps: TYPE USING [What],  SpecialDisplay: TYPE USING [defaultContext, SpecialContext],  SpecialWindow: TYPE USING [GetPages],  Window: TYPE USING [Box, EnumerateTree, GetBitmapUnder, Place],  WindowOps: TYPE USING [    bbPtr, DIVMOD16, Object, RecList, Rectangle, rootWindow, ScreenBox,    SpecialTimesWpl];RectangleImpl: MONITOR  IMPORTS BitBlt, Inline, SpecialDisplay, SpecialWindow, Window, WindowOps  EXPORTS RecOps, Window =  BEGIN  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = WindowOps.Object;  RecList: TYPE = WindowOps.RecList;  ErrorCode: TYPE = {ambiguous, nilWindow, notInTree};  ClientBug: SIGNAL [code: ErrorCode] = CODE;  -- conversion  WindowToScreenBox: PUBLIC PROC [wb: Window.Box]    RETURNS [b: WindowOps.ScreenBox] = {    b.left &larr; wb.place.x;    b.right &larr; b.left + wb.dims.w;    b.top &larr; wb.place.y;    b.bottom &larr; b.top + wb.dims.h};  ScreenToWindowBox: PUBLIC PROC [b: WindowOps.ScreenBox]    RETURNS [wb: Window.Box] = {    wb.place.x &larr; b.left;    wb.place.y &larr; b.top;    wb.dims.w &larr; b.right - b.left;    wb.dims.h &larr; b.bottom - b.top};  Convert: PUBLIC PROC [w: Handle] RETURNS [r: RecList] = {    r &larr; Alloc[];    r&uarr; &larr; [link: NIL, box: WindowToScreenBox[[w.place, w.box.dims]]]};  ConvertBox: PUBLIC PROC [w: Handle, box: Window.Box] RETURNS [r: RecList] = {    box.place.x &larr; w.place.x + box.place.x;    box.place.y &larr; w.place.y + box.place.y;    r &larr; Alloc[];    r&uarr; &larr; [link: NIL, box: WindowToScreenBox[box]]};  -- operations  Append: PUBLIC PROC [list1, list2: RecList] RETURNS [list3: RecList] = {    next: RecList;    IF list1 = NIL THEN RETURN[list2];    IF list2 = NIL THEN RETURN[list1];    list1 &larr; Bite[list: list1, biter: Copy[list2]];    IF list1 = NIL THEN RETURN[list2];    FOR r: RecList &larr; list1, next DO      next &larr; r.link; IF next = NIL THEN {r.link &larr; list2; RETURN[list1]}; ENDLOOP};  Copy: PUBLIC PROC [old: RecList] RETURNS [new: RecList &larr; NIL] = {    FOR r: RecList &larr; old, r.link UNTIL r = NIL DO      copy: RecList = Alloc[];      copy&uarr; &larr; r&uarr;;      copy.link &larr; new; new &larr; copy;      ENDLOOP};  CleanInvalid: PUBLIC PROC [window: Handle] RETURNS [invalid: RecList &larr; NIL] = {    -- This is where boxesCount logic can be hidden...    this: RecList;    FOR this &larr; window.invalid, window.invalid UNTIL this = NIL DO      window.invalid &larr; this.link;      this.link &larr; NIL;      this.src &larr; this.dst &larr; NIL;      invalid &larr; Append[invalid, this];      ENDLOOP;    RETURN[window.invalid &larr; invalid]};        ClipBox: PUBLIC PROC [window: Handle, box: RecList]    RETURNS [clippedBox: RecList, lastParent: Handle] = {    next: Handle;    IF window = NIL THEN {SIGNAL ClientBug[nilWindow]; RETURN[box, NIL]};    IF ~window.inTree THEN {SIGNAL ClientBug[notInTree]; RETURN[box, NIL]};    IF window = WindowOps.rootWindow THEN RETURN[box, NIL];    IF (next &larr; window.parent) = WindowOps.rootWindow THEN RETURN[box, window];    clippedBox &larr; box;    FOR lastParent &larr; next, next UNTIL lastParent = NIL DO      box: RecList = Convert[lastParent];      temp: RecList = Intersect[box, clippedBox];      FreeRecList[box];      FreeRecList[clippedBox];      clippedBox &larr; temp;      IF (next &larr; lastParent.parent) = WindowOps.rootWindow THEN RETURN;      ENDLOOP;    SIGNAL ClientBug[notInTree]};    Disjoint: PUBLIC PROC [list1, list2: RecList] RETURNS [BOOLEAN] = {    IF list1 = NIL OR list2 = NIL THEN RETURN[TRUE];    FOR r1: RecList &larr; list1, r1.link UNTIL r1 = NIL DO      FOR r2: RecList &larr; list2, r2.link UNTIL r2 = NIL DO        box: WindowOps.ScreenBox;        box.left &larr; MAX[r1.box.left, r2.box.left];        box.top &larr; MAX[r1.box.top, r2.box.top];        box.right &larr; MIN[r1.box.right, r2.box.right];        box.bottom &larr; MIN[r1.box.bottom, r2.box.bottom];        IF box.left &lt; box.right AND box.top &lt; box.bottom THEN RETURN[FALSE];	ENDLOOP;      REPEAT FINISHED =&gt; RETURN[TRUE]      ENDLOOP};  Intersect: PUBLIC PROC [list1, list2: RecList]    RETURNS [list3: RecList &larr; NIL] = {    FOR r1: RecList &larr; list1, r1.link UNTIL r1 = NIL DO      FOR r2: RecList &larr; list2, r2.link UNTIL r2 = NIL DO        box: WindowOps.ScreenBox;        box.left &larr; MAX[r1.box.left, r2.box.left];        box.top &larr; MAX[r1.box.top, r2.box.top];        box.right &larr; MIN[r1.box.right, r2.box.right];        box.bottom &larr; MIN[r1.box.bottom, r2.box.bottom];        IF box.left &lt; box.right AND box.top &lt; box.bottom THEN {          new: RecList = Alloc[];          new&uarr; &larr; [	    box: box, link: list3, src: SetUnder[r1.src, r2.src], 	    dst: SetUnder[r1.dst, r2.dst]];          list3 &larr; new};        ENDLOOP;      ENDLOOP};  SetUnder: PROC [w1, w2: Handle] RETURNS [Handle] = INLINE {    IF w1 = NIL THEN RETURN[w2];    IF w2 # NIL AND w1 # w2 THEN SIGNAL ClientBug[ambiguous];    RETURN[w1]};    	  Shift: PUBLIC PROC [list: RecList, dx, dy: INTEGER] RETURNS [r: RecList] = {    -- This used to clip to bitmap bounds.  Should it?    FOR r: RecList &larr; list, r.link UNTIL r = NIL DO      r.box.left &larr; r.box.left + dx;      r.box.top &larr; r.box.top + dy;      r.box.right &larr; r.box.right + dx;      r.box.bottom &larr; r.box.bottom + dy;      ENDLOOP;    RETURN[list]};	  Blt: PUBLIC PROC [list: RecList, dx, dy: INTEGER] = {    disjointItems: BOOLEAN = dy # 0;    south: BOOLEAN = dy &gt; 0;    east: BOOLEAN = dx &gt; 0;    dir: {nw, ne, se, sw} =      IF east THEN IF south THEN se ELSE ne ELSE IF south THEN sw ELSE nw;    flags: BitBlt.BitBltFlags &larr; [      direction: IF south OR (~disjointItems AND east) THEN backward ELSE forward,      disjoint: FALSE, disjointItems: disjointItems, gray: FALSE, srcFunc: null,      dstFunc: null, reserved: 0];    WHILE list # NIL DO      prev: RecList &larr; NIL;      didSomething: BOOLEAN &larr; FALSE;      next: RecList;      FOR r: RecList &larr; list, next UNTIL r = NIL DO        left: INTEGER = r.box.left;        top: INTEGER = r.box.top;        bottom: INTEGER = r.box.bottom;        right: INTEGER = r.box.right;        next &larr; r.link;        FOR spoiler: RecList &larr; list, spoiler.link UNTIL spoiler = NIL DO          IF spoiler = r THEN LOOP;          SELECT dir FROM            nw =&gt;              IF spoiler.box.left &lt; right AND spoiler.box.top &lt; bottom THEN {                prev &larr; r; EXIT};            ne =&gt;              IF spoiler.box.right &gt; left AND spoiler.box.top &lt; bottom THEN {                prev &larr; r; EXIT};            sw =&gt;              IF spoiler.box.left &lt; right AND spoiler.box.bottom &gt; top THEN {                prev &larr; r; EXIT};            se =&gt;              IF spoiler.box.right &gt; left AND spoiler.box.bottom &gt; top THEN {                prev &larr; r; EXIT};            ENDCASE;          REPEAT            FINISHED =&gt; {              width: INTEGER = right - left;              height: INTEGER = bottom - top;	      src, dst: LONG POINTER;              srcOffset, srcBit, dstOffset, dstBit, srcBpl, dstBpl: INTEGER;	      	      Calc: PROC [w: Handle, offset, dy: INTEGER] 	        RETURNS [LONG POINTER, INTEGER] = INLINE {		ctx: SpecialDisplay.SpecialContext;		IF w = NIL THEN ctx &larr; SpecialDisplay.defaultContext&uarr;		ELSE {		  ctx.wpl &larr; (CARDINAL[w.box.dims.w] + 31)/16;		  ctx.bpl &larr; ctx.wpl*16;		  ctx.bmAddress &larr; LOOPHOLE[		    Window.GetBitmapUnder[w] - w.place.x/16 		    - Inline.LongMult[ctx.wpl, w.place.y]];		  ctx.alloc &larr; NIL; ctx.free &larr; NIL};		IF flags.disjoint OR flags.direction = forward THEN 		  RETURN[		    ctx.bmAddress + offset +		      WindowOps.SpecialTimesWpl[top+dy, @ctx],		    ctx.bpl];		RETURN[		  ctx.bmAddress + offset +		    WindowOps.SpecialTimesWpl[bottom+dy-1, @ctx],		  -ctx.bpl]};		              [srcOffset, srcBit] &larr; WindowOps.DIVMOD16[CARDINAL[left]];              [dstOffset, dstBit] &larr; WindowOps.DIVMOD16[CARDINAL[left + dx]];              flags.disjoint &larr; 	        ABS[dy] &gt; height OR ABS[dx] &gt; width 		OR ((r.dst # NIL OR r.src # NIL) AND r.dst # r.src);	      [src, srcBpl] &larr; Calc[r.src, srcOffset, 0];	      [dst, dstBpl] &larr; Calc[r.dst, dstOffset, dy];              WindowOps.bbPtr&uarr; &larr; [                dst: [word: dst, bit: dstBit], dstBpl: dstBpl,                 src: [word: src, bit: srcBit], srcDesc: [srcBpl[srcBpl]], 		flags: flags, height: height, width: width];              BitBlt.BITBLT[WindowOps.bbPtr];              didSomething &larr; TRUE;              IF prev = NIL THEN list &larr; next ELSE prev.link &larr; next;              Free[r]};          ENDLOOP;        REPEAT          FINISHED =&gt; {            CouldntBlt: SIGNAL = CODE; IF ~didSomething THEN SIGNAL CouldntBlt};        ENDLOOP;      ENDLOOP};  Coalesce: PUBLIC PROC [r: RecList] RETURNS [new: RecList] = {    changesMade: BOOLEAN &larr; TRUE;    dummy: RecList; -- sort    IF r = NIL OR r.link = NIL THEN RETURN[r];    dummy &larr; Alloc[];    dummy&uarr; &larr; [box: [0, 0, 0, 0], link: NIL];    new &larr; dummy;    -- first, sort by upper left corner    UNTIL r = NIL DO      cur: RecList = r;      candidate: RecList &larr; new;      r &larr; cur.link;      FOR this: RecList &larr; new, this.link UNTIL this = NIL DO	IF cur.box.top &gt;= this.box.top AND cur.box.left &gt;= this.box.left THEN	  candidate &larr; this;	ENDLOOP;      cur.link &larr; candidate.link;      candidate.link &larr; cur;      ENDLOOP;    IF new = dummy THEN {new &larr; dummy.link; Free[dummy]}    ELSE {BadSort: ERROR = CODE; ERROR BadSort};    -- ASSERT[rectangles below and to the right of r come after it in the list]    &lt;&lt; A heuristic for merging rectangles: try to merge down first, since the    biting algorithms produce more breakage in the y-axis. &gt;&gt;    WHILE changesMade DO      that, pred: RecList;      changesMade &larr; FALSE;      FOR this: RecList &larr; new, this.link UNTIL this = NIL DO {	-- try to merge down	FOR pred &larr; this, pred.link UNTIL pred = NIL DO	  IF (that &larr; pred.link) = NIL THEN EXIT;	  IF this.box.bottom = that.box.top AND this.box.left = that.box.left	    AND this.box.right = that.box.right AND this.src = that.src 	    AND this.dst = that.dst THEN {	    this.box.bottom &larr; that.box.bottom;	    GOTO FreeThat};	  ENDLOOP;        -- try to merge right	FOR pred &larr; this, pred.link UNTIL pred = NIL DO	  IF (that &larr; pred.link) = NIL THEN EXIT;	  IF this.box.right = that.box.left AND this.box.top = that.box.top	    AND this.box.bottom = that.box.bottom 	    AND this.src = that.src AND this.dst = that.dst THEN {	    this.box.right &larr; that.box.right;	    GOTO FreeThat};	  ENDLOOP;	EXITS 	  FreeThat =&gt; {	    changesMade &larr; TRUE;	    pred.link &larr; that.link;	    Free[that]}};	ENDLOOP;      ENDLOOP};  -- things that bite out rectangles    Bite: PUBLIC PROC [list, biter: RecList] RETURNS [newList: RecList &larr; NIL] = {    prev: RecList &larr; NIL;    next: RecList;    FOR l: RecList &larr; list, next UNTIL l = NIL DO      lRemaining: BOOLEAN &larr; TRUE;      boxes: RecList &larr; NIL;      next &larr; l.link;      FOR b: RecList &larr; biter, b.link UNTIL b = NIL DO        thisBox: WindowOps.Rectangle &larr; b&uarr;;	thisBox.link &larr; NIL;        CheckOldBites[@boxes, @thisBox];        IF lRemaining AND BiteOut[l, @thisBox, @boxes] THEN {          IF l = list THEN list &larr; next ELSE prev.link &larr; next;	  Free[l];	  lRemaining &larr; FALSE};        REPEAT FINISHED =&gt; IF lRemaining THEN prev &larr; l;        ENDLOOP;      newList &larr; SimpleAppend[newList, boxes];      ENDLOOP;    FreeRecList[biter];    RETURN[SimpleAppend[newList, list]]};    BiteOutSiblings: PROC [    sib, me: Handle, list, under: RecList, what: RecOps.What]    RETURNS [newList, newUnder: RecList &larr; NIL] = {    &lt;&lt; Constructs a RecList that consists of the sibling boxes, then calls Bite    to do the work.  If one of the siblings has a BMU, escape to the hard case.     Easy case doesn't touch under. &gt;&gt;    sibList: RecList &larr; NIL;    IF list = NIL THEN RETURN[list, under];    FOR w: Handle &larr; sib, w.sibling UNTIL w = me DO      thisSib: RecList;      IF w.underNow AND what # null THEN {        FreeRecList[sibList];        RETURN BiteOutSiblingsTheHardWay[sib, me, list, under, what]};      -- sibList &larr; SimpleAppend[Convert[w], sibList]...      thisSib &larr; Convert[w];      thisSib.link &larr; sibList;      sibList &larr; thisSib;      ENDLOOP;    RETURN[Bite[list, sibList], under]};      BiteOutSiblingsTheHardWay: PROC [    sib, me: Handle, list, under: RecList, what: RecOps.What]    RETURNS [newList, newUnder: RecList &larr; NIL] = {    &lt;&lt; Recursively calls itself until it reaches me, then unwinds the call stack.      The effect of this is that the sibling leading to me is processed in      reverse order.  The bite-out code is a clone of BiteOut that also      saves the intersection in newUnder if sib is a BMU.      Consumes list and under &gt;&gt;    saveUnder: BOOLEAN;    biter: WindowOps.ScreenBox;    AddBox: PROC [left, top, right, bottom: INTEGER, from: RecList] = {      b: RecList = Alloc[];      b&uarr; &larr; [        link: newList, box: [left, top, right, bottom],	src: from.src, dst: from.dst];      newList &larr; b};    AddUnderBox: PROC [left, top, right, bottom: INTEGER, from: RecList] = {      b: RecList = Alloc[];      b&uarr; &larr; [        link: newUnder, box: [left, top, right, bottom],	src: IF what = src THEN sib ELSE from.src,	dst: IF what = dst THEN sib ELSE from.dst];      newUnder &larr; b};    SELECT TRUE FROM      sib = me =&gt; RETURN[list, under];      sib = NIL =&gt; {        WrongSiblings: SIGNAL = CODE; SIGNAL WrongSiblings; RETURN[list, under]};      list = NIL =&gt; RETURN[list, under]; -- optimization      ENDCASE;    -- call self recursively for list traversal...    [list, newUnder] &larr; BiteOutSiblingsTheHardWay[      sib: sib.sibling, me: me, list: list, under: under, what: what];    -- bite out sib from list, saving bitten pieces on newUnder if saveUnder    saveUnder &larr; sib.underNow AND what # null;    biter &larr; WindowToScreenBox[[sib.place, sib.box.dims]];    FOR r: RecList &larr; list, r.link UNTIL r = NIL DO      lIn: CARDINAL =        SELECT TRUE FROM          biter.left &gt;= r.box.right =&gt; DisjointBoxes,          biter.right &lt;= r.box.left =&gt; DisjointBoxes,          biter.left &lt;= r.box.left =&gt; 0,          ENDCASE =&gt; LeftIn;      rIn: CARDINAL = IF biter.right &lt; r.box.right THEN RightIn ELSE 0;      tIn: CARDINAL =        SELECT TRUE FROM          biter.top &gt;= r.box.bottom =&gt; DisjointBoxes,          biter.bottom &lt;= r.box.top =&gt; DisjointBoxes,          biter.top &lt;= r.box.top =&gt; 0,          ENDCASE =&gt; TopIn;      bIn: CARDINAL = IF biter.bottom &lt; r.box.bottom THEN BottomIn ELSE 0;      SELECT lIn + rIn + tIn + bIn FROM -- what's obscured?        0 =&gt; -- everything	  IF saveUnder THEN AddUnderBox[	    r.box.left, r.box.top, r.box.right, r.box.bottom, r];	LeftIn =&gt; { -- right	  AddBox[r.box.left, r.box.top, biter.left, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    biter.left, r.box.top, r.box.right, r.box.bottom, r]};	BottomIn =&gt; { -- top	  AddBox[r.box.left, biter.bottom, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    r.box.left, r.box.top, r.box.right, biter.bottom, r]};	TopIn =&gt; { -- bottom	  AddBox[r.box.left, r.box.top, r.box.right, biter.top, r];	  IF saveUnder THEN AddUnderBox[	    r.box.left, biter.top, r.box.right, r.box.bottom, r]};	RightIn =&gt; { -- left	  AddBox[biter.right, r.box.top, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    r.box.left, r.box.top, biter.right, r.box.bottom, r]};	LeftIn + RightIn =&gt; { -- vertical strip	  AddBox[r.box.left, r.box.top, biter.left, r.box.bottom, r];	  AddBox[biter.right, r.box.top, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    biter.left, r.box.top, biter.right, r.box.bottom, r]};	TopIn + BottomIn =&gt; { -- horizontal strip	  AddBox[r.box.left, r.box.top, r.box.right, biter.top, r];	  AddBox[r.box.left, biter.bottom, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    r.box.left, biter.top, r.box.right, biter.bottom, r]};	RightIn + BottomIn =&gt; { -- top left	  AddBox[biter.right, r.box.top, r.box.right, biter.bottom, r];	  AddBox[r.box.left, biter.bottom, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    r.box.left, r.box.top, biter.right, biter.bottom, r]};	LeftIn + BottomIn =&gt; { -- top right	  AddBox[r.box.left, r.box.top, biter.left, biter.bottom, r];	  AddBox[r.box.left, biter.bottom, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    biter.left, r.box.top, r.box.right, biter.bottom, r]};	RightIn + TopIn =&gt; { -- bottom left	  AddBox[r.box.left, r.box.top, r.box.right, biter.top, r];	  AddBox[biter.right, biter.top, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    r.box.left, biter.top, biter.right, r.box.bottom, r]};	LeftIn + TopIn =&gt; { -- bottom right	  AddBox[r.box.left, r.box.top, r.box.right, biter.top, r];	  AddBox[r.box.left, biter.top, biter.left, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    biter.left, biter.top, r.box.right, r.box.bottom, r]};	RightIn + BottomIn + TopIn =&gt; { -- left edge	  AddBox[r.box.left, r.box.top, r.box.right, biter.top, r];	  AddBox[biter.right, biter.top, r.box.right, biter.bottom, r];	  AddBox[r.box.left, biter.bottom, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    r.box.left, biter.top, biter.right, biter.bottom, r]};	LeftIn + BottomIn + TopIn =&gt; { -- right edge	  AddBox[r.box.left, r.box.top, r.box.right, biter.top, r];	  AddBox[r.box.left, biter.top, biter.left, biter.bottom, r];	  AddBox[r.box.left, biter.bottom, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    biter.left, biter.top, r.box.right, biter.bottom, r]};	RightIn + LeftIn + TopIn =&gt; { -- bottom edge	  AddBox[r.box.left, r.box.top, r.box.right, biter.top, r];	  AddBox[r.box.left, biter.top, biter.left, r.box.bottom, r];	  AddBox[biter.right, biter.top, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    biter.left, biter.top, biter.right, r.box.bottom, r]};	RightIn + LeftIn + BottomIn =&gt; { -- top edge	  AddBox[r.box.left, r.box.top, biter.left, biter.bottom, r];	  AddBox[biter.right, r.box.top, r.box.right, biter.bottom, r];	  AddBox[r.box.left, biter.bottom, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    biter.left, r.box.top, biter.right, biter.bottom, r]};	RightIn + TopIn + BottomIn + LeftIn =&gt; { -- center	  AddBox[r.box.left, r.box.top, r.box.right, biter.top, r];	  AddBox[r.box.left, biter.top, biter.left, biter.bottom, r];	  AddBox[biter.right, biter.top, r.box.right, biter.bottom, r];	  AddBox[r.box.left, biter.bottom, r.box.right, r.box.bottom, r];	  IF saveUnder THEN AddUnderBox[	    biter.left, biter.top, biter.right, biter.bottom, r]};	ENDCASE =&gt; -- disjoint	  AddBox[r.box.left, r.box.top, r.box.right, r.box.bottom, r];      ENDLOOP;    FreeRecList[list]};    Visible: PUBLIC PROC [    w: Handle, list: RecList, what: RecOps.What, biteChildren: BOOLEAN &larr; FALSE]    RETURNS [newList: RecList] = {    abs: RecList &larr; Convert[w];    underList: RecList &larr; NIL;    newList &larr; Intersect[list, abs];    FreeRecList[list];    IF biteChildren AND w.child # NIL THEN       [newList, underList] &larr; BiteOutSiblings[        sib: w.child, me: NIL, list: newList, under: underList, what: what];    IF w.parent # NIL THEN {      [newList, underList] &larr; BiteOutSiblings[        sib: w.parent.child, me: w, list: newList, under: underList, what: what];      FOR p: Handle &larr; w.parent, p.parent DO        temp: RecList;        -- Trim box to parent        Free[abs];	abs &larr; Convert[p];        temp &larr; Intersect[abs, newList];	FreeRecList[newList];	newList &larr; temp;	temp &larr; Intersect[abs, underList];	FreeRecList[underList];	underList &larr; temp;	-- Bite out uncles	IF p.parent = NIL THEN EXIT;	[newList, underList] &larr; BiteOutSiblings[	  sib: p.parent.child, me: p, list: newList, under: underList,	  what: what];	ENDLOOP};    Free[abs];    RETURN[SimpleAppend[underList, newList]]};      CheckOldBites: PROC [boxes: POINTER TO RecList, biter: RecList] = {    &lt;&lt; we have to check the biter against all the rectangles created by the     previous bites.  They are on the boxes list. &gt;&gt;    prev: RecList &larr; NIL;    next: RecList;    FOR r: RecList &larr; boxes&uarr;, next UNTIL r = NIL DO      next &larr; r.link;      IF BiteOut[r, biter, boxes] THEN {        IF prev = NIL THEN boxes&uarr; &larr; next ELSE prev.link &larr; next; Free[r]}      ELSE prev &larr; r;      ENDLOOP};  SimpleAppend: PUBLIC PROC [list1, list2: RecList] RETURNS [list3: RecList] = {    next: RecList;    IF list1 = NIL THEN RETURN[list2];    IF list2 = NIL THEN RETURN[list1];    FOR r: RecList &larr; list1, next DO      next &larr; r.link; IF next = NIL THEN {r.link &larr; list2; RETURN[list1]}; ENDLOOP};    LeftIn: CARDINAL = 1;  RightIn: CARDINAL = 2;  TopIn: CARDINAL = 4;  BottomIn: CARDINAL = 8;  DisjointBoxes: CARDINAL = 100B;  BiteOut: PROC [list: RecList, clip: RecList, boxes: POINTER TO RecList]    RETURNS [delete: BOOLEAN] = {    &lt;&lt; Bites out the clip box from a single rectangle (list).  Any new boxes are        prepeneded to boxes&uarr;.  If delete is true, the rectangle       passed in has been completely clipped.  BiteOut changes list.box but does       not touch the link. &gt;&gt;    NewRect: PROC RETURNS [r: RecList] = {      r &larr; Alloc[]; r&uarr; &larr; list&uarr;; r.link &larr; boxes&uarr;; boxes&uarr; &larr; r};    lIn: CARDINAL =      SELECT TRUE FROM        clip.box.left &gt;= list.box.right =&gt; DisjointBoxes,        clip.box.right &lt;= list.box.left =&gt; DisjointBoxes,        clip.box.left &lt;= list.box.left =&gt; 0,        ENDCASE =&gt; LeftIn;    rIn: CARDINAL = IF clip.box.right &lt; list.box.right THEN RightIn ELSE 0;    tIn: CARDINAL =      SELECT TRUE FROM        clip.box.top &gt;= list.box.bottom =&gt; DisjointBoxes,        clip.box.bottom &lt;= list.box.top =&gt; DisjointBoxes,        clip.box.top &lt;= list.box.top =&gt; 0,        ENDCASE =&gt; TopIn;    bIn: CARDINAL = IF clip.box.bottom &lt; list.box.bottom THEN BottomIn ELSE 0;    SELECT lIn + rIn + tIn + bIn FROM      0 =&gt; RETURN[TRUE];  -- all of w was in clip       LeftIn =&gt; list.box.right &larr; clip.box.left;  -- clipped on right      BottomIn =&gt; list.box.top &larr; clip.box.bottom;  -- clipped on top      TopIn =&gt; list.box.bottom &larr; clip.box.top;  -- clipped on bottom      RightIn =&gt; list.box.left &larr; clip.box.right;  -- clipped on left      LeftIn + RightIn =&gt; {  -- vertical strip from middle        n: RecList = NewRect[]; 	list.box.right &larr; clip.box.left;        n.box.left &larr; clip.box.right};      TopIn + BottomIn =&gt; {  -- horizontal strip from middle        n: RecList = NewRect[]; 	list.box.bottom &larr; clip.box.top; 	n.box.top &larr; clip.box.bottom};      RightIn + BottomIn =&gt; {  -- upper left-hand corner        n: RecList = NewRect[];        list.box.top &larr; clip.box.bottom;        n.box.bottom &larr; clip.box.bottom;        n.box.left &larr; clip.box.right};      LeftIn + BottomIn =&gt; {  -- upper right-hand corner        n: RecList = NewRect[];        list.box.top &larr; clip.box.bottom;        n.box.bottom &larr; clip.box.bottom;        n.box.right &larr; clip.box.left};      RightIn + TopIn =&gt; {  -- lower left-hand corner        n: RecList = NewRect[];        list.box.bottom &larr; clip.box.top;        n.box.top &larr; clip.box.top;        n.box.left &larr; clip.box.right};      LeftIn + TopIn =&gt; {  -- lower right-hand corner        n: RecList = NewRect[];        list.box.bottom &larr; clip.box.top;        n.box.top &larr; clip.box.top;        n.box.right &larr; clip.box.left};      RightIn + BottomIn + TopIn =&gt; {  -- left edge        n: RecList = NewRect[];        m: RecList = NewRect[];        list.box.left &larr; clip.box.right;        n.box.bottom &larr; clip.box.top;        n.box.right &larr; clip.box.right;        m.box.top &larr; clip.box.bottom;        m.box.right &larr; clip.box.right};      LeftIn + BottomIn + TopIn =&gt; {  -- right edge        n: RecList = NewRect[];        m: RecList = NewRect[];        list.box.right &larr; clip.box.left;        n.box.bottom &larr; clip.box.top;        n.box.left &larr; clip.box.left;        m.box.top &larr; clip.box.bottom;        m.box.left &larr; clip.box.left};      RightIn + LeftIn + TopIn =&gt; {  -- bottom edge        n: RecList = NewRect[];        m: RecList = NewRect[];        list.box.bottom &larr; clip.box.top;        n.box.right &larr; clip.box.left;        n.box.top &larr; clip.box.top;        m.box.left &larr; clip.box.right;        m.box.top &larr; clip.box.top};      RightIn + LeftIn + BottomIn =&gt; {  -- top edge        n: RecList = NewRect[];        m: RecList = NewRect[];        list.box.top &larr; clip.box.bottom;        n.box.right &larr; clip.box.left;        n.box.bottom &larr; clip.box.bottom;        m.box.left &larr; clip.box.right;        m.box.bottom &larr; clip.box.bottom};      RightIn + TopIn + BottomIn + LeftIn =&gt; {  -- center        n: RecList = NewRect[];        m: RecList = NewRect[];        l: RecList = NewRect[];        list.box.bottom &larr; clip.box.top;        n.box.top &larr; clip.box.bottom;        m.box.top &larr; clip.box.top;        m.box.bottom &larr; clip.box.bottom;        m.box.right &larr; clip.box.left;        l.box.top &larr; clip.box.top;        l.box.bottom &larr; clip.box.bottom;        l.box.left &larr; clip.box.right};      ENDCASE;  -- left w alone    RETURN[FALSE]};  -- allocator  FreeHandle: TYPE = LONG POINTER TO FreeObject;  FreeObject: TYPE = RECORD [link: FreeHandle];  Header: TYPE = LONG POINTER TO HeaderObject;  HeaderObject: TYPE = RECORD [    link: Header, cnt: CARDINAL, list: ARRAY [0..0) OF WindowOps.Rectangle &larr; NULL];  Max: CARDINAL = WordsAvailable/WindowOps.Rectangle.SIZE;  TileSize: CARDINAL = 4;  WordsAvailable: CARDINAL =    Environment.wordsPerPage*TileSize - HeaderObject.SIZE;  allocHead: Header &larr; SpecialWindow.GetPages[TileSize];  freeList: FreeHandle &larr; NIL;  Alloc: PUBLIC ENTRY PROC RETURNS [lp: RecList] = {    ENABLE UNWIND =&gt; NULL;    IF freeList # NIL THEN {      lp &larr; LOOPHOLE[freeList]; freeList &larr; freeList.link; RETURN};    IF allocHead.cnt = Max THEN {      new: Header &larr; SpecialWindow.GetPages[TileSize];      new&uarr; &larr; [link: allocHead, cnt: 0];      allocHead &larr; new};    lp &larr; @allocHead.list[allocHead.cnt];    allocHead.cnt &larr; allocHead.cnt + 1;    RETURN[lp]};  Free: PUBLIC ENTRY PROC [lp: RecList] = {    ENABLE UNWIND =&gt; NULL;    LOOPHOLE[lp, FreeHandle].link &larr; freeList;    freeList &larr; LOOPHOLE[lp]};  FreeRecList: PUBLIC ENTRY PROC [list: RecList] = {    ENABLE UNWIND =&gt; NULL;    next: RecList;    FOR nil: RecList &larr; list, next UNTIL nil = NIL DO      next &larr; nil.link;      LOOPHOLE[nil, FreeHandle].link &larr; freeList;      freeList &larr; LOOPHOLE[nil];      ENDLOOP};  debug: BOOLEAN = FALSE;  CheckForLeaks: PUBLIC ENTRY PROC [useTree: BOOLEAN, cache: RecList] = {    ENABLE UNWIND =&gt; NULL;    Leak: SIGNAL = CODE;    IF debug THEN {      allocated, returned, busy, cached: CARDINAL &larr; 0;      FOR h: Header &larr; allocHead, h.link UNTIL h = NIL DO        allocated &larr; allocated + h.cnt; ENDLOOP;      FOR f: FreeHandle &larr; freeList, f.link UNTIL f = NIL DO        returned &larr; returned + 1; ENDLOOP;      FOR r: RecList &larr; cache, r.link UNTIL r = NIL DO cached &larr; cached + 1; ENDLOOP;      IF useTree THEN {        CountBusy: PROC [w: Handle] = {          FOR r: RecList &larr; w.invalid, r.link UNTIL r = NIL DO            busy &larr; busy + 1; ENDLOOP;          FOR r: RecList &larr; w.badPhosphor, r.link UNTIL r = NIL DO            busy &larr; busy + 1; ENDLOOP};        Window.EnumerateTree[WindowOps.rootWindow, CountBusy]};      IF allocated # busy + returned + cached THEN SIGNAL Leak;      useTree &larr; FALSE -- for Ed -- }};  allocHead&uarr; &larr; [link: NIL, cnt: 0];  END.</pre>
  </body>
</html>
