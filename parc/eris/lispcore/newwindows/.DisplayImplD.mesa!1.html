<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>NEWWINDOWS>DisplayImplD.mesa!1</title>
  </head>
  <body>
    <pre>
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- DisplayImplD.mesa - last edited by -- Rick	        12-Nov-83 14:51:57  -- Bruce	24-Feb-83 16:08:25  -- Daniels	 7-Jun-84 14:56:02  DIRECTORY  BitBlt USING [BitBltFlags],  DisplayFormat USING [CircleType],  Display USING [paintGrayFlags],  DisplayOps USING [    AbsPlace, Color, HasUnder, LogError, FillList, FillObject, Intersect, Shade],  DisplayInternal USING [],  SpecialDisplay USING [DashCnt, defaultContext, LineStyle, solid, Special],  Window USING [BoxHandle, Place],  WindowOps USING [    AbsoluteBoxHandle, bitmapAddress, Bounds, DisplayList, GetContext,    lock, Object, RecList, ScanLine, ScreenBox, SpecialTimesWpl];DisplayImplD: MONITOR LOCKS WindowOps.lock  IMPORTS DisplayOps, SpecialDisplay, WindowOps  EXPORTS DisplayInternal, SpecialDisplay, Window =  BEGIN  -- exported types  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = WindowOps.Object;  FillHandle: TYPE = LONG POINTER TO FillObject;  FillObject: PUBLIC TYPE = DisplayOps.FillObject;  -- copied types because John doesn't like them  LineStyle: TYPE = SpecialDisplay.LineStyle;  Special: TYPE = SpecialDisplay.Special;  -- circles  Circle: PUBLIC ENTRY PROC [    window: Handle, place: Window.Place, radius: INTEGER,    circleType: DisplayFormat.CircleType, bounds: Window.BoxHandle &larr; NIL] = {    -- This routine observes that:    -- radius IN [0..8000]    -- place.x, place.y IN [-8000.. 8000]    -- Also the circle bouding box intersects each reclist and before any integer    -- math is done, the circle is in each reclist. Four scanlines and four    -- bitIndexes are maintained to determine xys in all eight octants.  Scanlines    -- start top, middle, middle, bottom.  BitIndexes start left, middle, middle,    -- right.  All end on the 45s.    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox =      IF bounds = NIL THEN WindowOps.Bounds[window]      ELSE WindowOps.AbsoluteBoxHandle[window, bounds];    startTwoxma: INTEGER &larr; 1;    startTwoymb: INTEGER &larr; 2*radius - 1;    abs: Window.Place = DisplayOps.AbsPlace[window, place];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link       UNTIL r = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN {        IF abs.x - radius &lt; r.box.left OR  --  clipped?          abs.x + radius &gt; r.box.right OR abs.y + radius &gt; r.box.bottom OR          abs.y - radius &lt; r.box.top OR DisplayOps.HasUnder[r] THEN {          [] &larr; SpCircleInternal[            r, FALSE, window, place, radius, circleType, bounds,            SpecialDisplay.solid, Display.paintGrayFlags];          RETURN};        {		-- not clipped, so these values can't be negative	wpl: CARDINAL = SpecialDisplay.defaultContext.wpl;        bitAddress1: WindowOps.ScanLine &larr;          WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[abs.y - radius];        bitAddress2: WindowOps.ScanLine &larr;          WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[abs.y];        bitAddress3: WindowOps.ScanLine &larr; bitAddress2;        bitAddress4: WindowOps.ScanLine &larr;          WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[abs.y + radius];        bitIndex1: INTEGER &larr; abs.x - radius;        bitIndex2, bitIndex3: INTEGER &larr; abs.x;        bitIndex4: INTEGER &larr; abs.x + radius;        newError: INTEGER;        twoxma: INTEGER &larr; startTwoxma;        twoymb: INTEGER &larr; startTwoymb;        error: INTEGER &larr; (radius - 1)/2;        IF circleType[0] THEN {	    bitIndex1 &larr; bitIndex1 + 1; bitIndex2 &larr; bitIndex2 + 1};	  IF circleType[1] THEN {	    bitIndex1 &larr; bitIndex1 - 1; bitIndex2 &larr; bitIndex2 - 1};	  IF circleType[2] THEN {	    bitIndex3 &larr; bitIndex3 - 1; bitIndex4 &larr; bitIndex4 - 1};	  IF circleType[3] THEN {	    bitIndex3 &larr; bitIndex3 + 1; bitIndex4 &larr; bitIndex4 + 1};	  IF circleType[4] THEN {	    bitAddress1 &larr; bitAddress1 + wpl;	    bitAddress2 &larr; bitAddress2 + wpl};	  IF circleType[5] THEN {	    bitAddress1 &larr; bitAddress1 - wpl;	    bitAddress2 &larr; bitAddress2 - wpl};	  IF circleType[6] THEN {	    bitAddress3 &larr; bitAddress3 - wpl; 	    bitAddress4 &larr; bitAddress4 - wpl};	  IF circleType[7] THEN {	    bitAddress3 &larr; bitAddress3 + wpl;	    bitAddress4 &larr; bitAddress4 + wpl};        -- Provided this loop quits when it's supposed to, less thanradius/2times,        -- twoxma IN [0..radius]        -- twoymb IN [0..2*radius]        -- error starts at [0..radius/2],  and stays IN [-twoymb..twoymb]         -- as twoymb goes to zero.        UNTIL bitIndex3 &gt; bitIndex4 DO          bitAddress1[bitIndex2] &larr; TRUE;  -- set a bit          bitAddress1[bitIndex3] &larr; TRUE;          bitAddress2[bitIndex1] &larr; TRUE;          bitAddress2[bitIndex4] &larr; TRUE;          bitAddress3[bitIndex1] &larr; TRUE;          bitAddress3[bitIndex4] &larr; TRUE;          bitAddress4[bitIndex2] &larr; TRUE;          bitAddress4[bitIndex3] &larr; TRUE;          bitIndex2 &larr; bitIndex2 - 1;          bitIndex3 &larr; bitIndex3 + 1;          bitAddress2 &larr; bitAddress2 - wpl;          bitAddress3 &larr; bitAddress3 + wpl;          error &larr; error + twoxma;          IF ABS[newError &larr; error - twoymb] &lt; ABS[error] THEN {            error &larr; newError;            bitIndex1 &larr; bitIndex1 + 1;            bitIndex4 &larr; bitIndex4 - 1;            bitAddress1 &larr; bitAddress1 + wpl;            bitAddress4 &larr; bitAddress4 - wpl;            twoymb &larr; twoymb - 2};          twoxma &larr; twoxma + 2;          ENDLOOP}};      ENDLOOP};  SpecialCircle: PUBLIC ENTRY PROC [    window: Handle, place: Window.Place, radius: INTEGER,    circleType: DisplayFormat.CircleType, bounds: Window.BoxHandle,    dashes: SpecialDisplay.LineStyle, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    ENABLE UNWIND =&gt; NULL;    filled: BOOLEAN = context.alloc # NIL;    firstRec: WindowOps.RecList = DisplayOps.FillList[window, filled];    SpCircleInternal[      firstRec, filled, window, place, radius, circleType, bounds, dashes, flags,      context]};  SpCircleInternal: INTERNAL PROC [    firstRec: WindowOps.RecList, filled: BOOLEAN, window: Handle,    place: Window.Place, radius: INTEGER, circleType: DisplayFormat.CircleType,    bounds: Window.BoxHandle, dashes: SpecialDisplay.LineStyle,    flags: BitBlt.BitBltFlags, context: Special &larr; SpecialDisplay.defaultContext]={    -- This routine observes that:    -- radius IN [0..8000]    -- place.x, place.y IN [-8000.. 8000]    -- Also the circle bouding box intersects Display.clip.box.    -- Display.clip.box.left, right IN [0.. 1000]    -- Display.clip.box.top, bottom IN [0..800]    -- Four scanlines and four bitIndexes are maintained to determine xys in    -- all eight octants.  Scanlines start top, middle, middle, bottom. BitIndexes    -- start left, middle, middle, right.  All end on the 45s.    L: PROCEDURE [l: LONG POINTER] RETURNS [LONG ORDERED POINTER] = INLINE {      RETURN[LOOPHOLE[l]]};    absBounds: WindowOps.ScreenBox =      IF bounds = NIL THEN WindowOps.Bounds[window]      ELSE WindowOps.AbsoluteBoxHandle[window, bounds];    abs: Window.Place = DisplayOps.AbsPlace[window, place];    newError: INTEGER;    bitIndex2, bitIndex3: INTEGER &larr; abs.x;    dashCnt, dashSum: CARDINAL;    widths: ARRAY [0..SpecialDisplay.DashCnt) OF CARDINAL;    inc1, inc2, inc3, inc4, inc5, inc6: CARDINAL;    paint: DisplayOps.Color = DisplayOps.Shade[flags];    fillLength: INTEGER;    fillcnt1,fillcnt2,fillFudge1,fillFudge2,fillFudge3,fillFudge4,index: INTEGER;    fill: FillHandle;    inLeft, outLeft, inRight, outRight, inTop, outTop, inBottom,       outBottom: BOOLEAN &larr; FALSE;    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      widths[i] &larr; dashes.widths[i]; ENDLOOP;    inc1 &larr; 0;    inc2 &larr; widths[0]*10;    inc3 &larr; inc2 + widths[1]*10;    inc4 &larr; inc3 + widths[2]*10;    inc5 &larr; inc4 + widths[3]*10;    inc6 &larr; inc5 + widths[4]*10;    FOR r: WindowOps.RecList &larr; firstRec, r.link UNTIL r = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN {        int: WindowOps.ScreenBox = [	  left: MAX[r.box.left, absBounds.left],	  right: MIN[r.box.right, absBounds.right],	  top: MAX[r.box.top, absBounds.top],	  bottom: MIN[r.box.bottom, absBounds.bottom]];	ctx: Special = WindowOps.GetContext[r, context];        minBitAddress: LONG ORDERED POINTER = LOOPHOLE[ 	  ctx.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[int.top], ctx]];        maxBitAddress: LONG ORDERED POINTER = LOOPHOLE[	  ctx.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[int.bottom - 1],ctx]];        minBitIndex: INTEGER &larr; MAX[0, int.left];        maxBitIndex: INTEGER &larr; int.right - 1;	IF int.top = int.bottom THEN LOOP;	IF filled THEN {	  minBitIndex &larr; MAX[0, minBitIndex];	  maxBitIndex &larr; absBounds.right;          fillcnt1 &larr; fillcnt2 &larr; 0;          fillFudge1 &larr; abs.y - int.top - radius; -- bA1 in fill place	  fillFudge2 &larr; fillFudge3 &larr; abs.y - int.top; -- bA2, bA3 in fill place	  fillFudge4 &larr; abs.y - int.top + radius; -- bA4 in fill place	  fillLength &larr; int.bottom - int.top;	  fill &larr; ctx.alloc[window, int.top, fillLength];	  fill.xs[0] &larr; minBitIndex};        FOR i: CARDINAL IN [0..dashes.thickness) DO  -- for thicking          error: INTEGER &larr; (radius - 1)/2;          twoxma: INTEGER &larr; 1;          twoymb: INTEGER &larr; 2*radius - 1;          bitAddress1: WindowOps.ScanLine &larr;            LOOPHOLE[ctx.bmAddress + WindowOps.SpecialTimesWpl[                       INTEGER[abs.y - radius + i], ctx]];          bitAddress2: WindowOps.ScanLine &larr; LOOPHOLE[	    ctx.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[abs.y], ctx]];          bitAddress3: WindowOps.ScanLine &larr; bitAddress2;          bitAddress4: WindowOps.ScanLine &larr;            LOOPHOLE[ctx.bmAddress + WindowOps.SpecialTimesWpl[                       INTEGER[abs.y + radius - i], ctx]];          bitIndex1: INTEGER &larr; abs.x - radius + i;          bitIndex4: INTEGER &larr; abs.x + radius - i;          bitIndex2 &larr; bitIndex3 &larr; abs.x;	  IF circleType[0] THEN {	    bitIndex1 &larr; bitIndex1 + 1; bitIndex2 &larr; bitIndex2 + 1};	  IF circleType[1] THEN {	    bitIndex1 &larr; bitIndex1 - 1; bitIndex2 &larr; bitIndex2 - 1};	  IF circleType[2] THEN {	    bitIndex3 &larr; bitIndex3 - 1; bitIndex4 &larr; bitIndex4 - 1};	  IF circleType[3] THEN {	    bitIndex3 &larr; bitIndex3 + 1; bitIndex4 &larr; bitIndex4 + 1};	  IF circleType[4] THEN {	    bitAddress1 &larr; bitAddress1 + ctx.wpl;	    bitAddress2 &larr; bitAddress2 + ctx.wpl;	    fillFudge1 &larr; fillFudge1 + 1;	    fillFudge2 &larr; fillFudge2 + 1};	  IF circleType[5] THEN {	    bitAddress1 &larr; bitAddress1 - ctx.wpl;	    bitAddress2 &larr; bitAddress2 - ctx.wpl;	    fillFudge1 &larr; fillFudge1 - 1;	    fillFudge2 &larr; fillFudge2 - 1};	  IF circleType[6] THEN {	    bitAddress3 &larr; bitAddress3 - ctx.wpl; 	    bitAddress4 &larr; bitAddress4 - ctx.wpl;	    fillFudge3 &larr; fillFudge3 - 1;	    fillFudge4 &larr; fillFudge4 - 1};	  IF circleType[7] THEN {	    bitAddress3 &larr; bitAddress3 + ctx.wpl;	    bitAddress4 &larr; bitAddress4 + ctx.wpl;	    fillFudge3 &larr; fillFudge3 + 1;	    fillFudge4 &larr; fillFudge4 + 1};          dashSum &larr; inc6 + widths[5]*10;          dashCnt &larr; inc2/2;          UNTIL bitIndex3 &gt; bitIndex4 DO            IF dashCnt IN [inc1..inc2) OR dashCnt IN [inc3..inc4)  -- dashes              OR dashCnt IN [inc5..inc6) THEN {              inL1: BOOLEAN = L[bitAddress1] IN [minBitAddress..maxBitAddress];              inL2: BOOLEAN = L[bitAddress2] IN [minBitAddress..maxBitAddress];              inL3: BOOLEAN = L[bitAddress3] IN [minBitAddress..maxBitAddress];              inL4: BOOLEAN = L[bitAddress4] IN [minBitAddress..maxBitAddress];              inC1: BOOLEAN = bitIndex1 IN [minBitIndex..maxBitIndex];              inC2: BOOLEAN = bitIndex2 IN [minBitIndex..maxBitIndex];              inC3: BOOLEAN = bitIndex3 IN [minBitIndex..maxBitIndex];              inC4: BOOLEAN = bitIndex4 IN [minBitIndex..maxBitIndex];              IF inL1 AND inC2 THEN -- sector 8	        IF filled THEN {	          index &larr; fillcnt2 + fillFudge1;		  IF index ~IN [0..fillLength) THEN DisplayOps.LogError[];		  fill.xs[index] &larr; bitIndex2}                ELSE bitAddress1[bitIndex2] &larr;                  (SELECT paint FROM white =&gt; FALSE, black =&gt; TRUE,                    ENDCASE =&gt; ~bitAddress1[bitIndex2]);              IF inL1 AND inC3 THEN -- sector 1	        IF filled THEN {		  index &larr; fillcnt2 + fillFudge1;		  IF index ~IN [0..fillLength) THEN DisplayOps.LogError[];		  fill.xs[index] &larr; bitIndex3}                ELSE bitAddress1[bitIndex3] &larr;                  (SELECT paint FROM white =&gt; FALSE, black =&gt; TRUE,                    ENDCASE =&gt; ~bitAddress1[bitIndex3]);              IF inL2 AND inC1 THEN -- sector 7	        IF filled THEN {		  index &larr; fillFudge2 - fillcnt1;		  IF index ~IN [0..fillLength) THEN DisplayOps.LogError[];		  fill.xs[index] &larr; bitIndex1}                ELSE bitAddress2[bitIndex1] &larr;                  (SELECT paint FROM white =&gt; FALSE, black =&gt; TRUE,                    ENDCASE =&gt; ~bitAddress2[bitIndex1]);              IF inL2 AND inC4 THEN -- sector 2	        IF filled THEN {		  index &larr; fillFudge2 - fillcnt1;		  IF index ~IN [0..fillLength) THEN DisplayOps.LogError[];		  fill.xs[index] &larr; bitIndex4}                ELSE bitAddress2[bitIndex4] &larr;                  (SELECT paint FROM white =&gt; FALSE, black =&gt; TRUE,                    ENDCASE =&gt; ~bitAddress2[bitIndex4]);              IF inL3 AND inC1 THEN  -- sector 6	        IF filled THEN {		  index &larr; fillFudge3 + fillcnt1;		  IF index ~IN [0..fillLength) THEN DisplayOps.LogError[];		  fill.xs[index] &larr; bitIndex1}                ELSE bitAddress3[bitIndex1] &larr;                  (SELECT paint FROM white =&gt; FALSE, black =&gt; TRUE,                    ENDCASE =&gt; ~bitAddress3[bitIndex1]);              IF inL3 AND inC4 THEN -- secter 3	        IF filled THEN {		  index &larr; fillFudge3 + fillcnt1;		  IF index ~IN [0..fillLength) THEN DisplayOps.LogError[];	          fill.xs[index] &larr; bitIndex4}                ELSE bitAddress3[bitIndex4] &larr;                  (SELECT paint FROM white =&gt; FALSE, black =&gt; TRUE,                    ENDCASE =&gt; ~bitAddress3[bitIndex4]);              IF inL4 AND inC2 THEN -- secter 5	        IF filled THEN {		  index &larr; fillFudge4 - fillcnt2;		  IF index ~IN [0..fillLength) THEN DisplayOps.LogError[];		  fill.xs[index] &larr; bitIndex2}                ELSE bitAddress4[bitIndex2] &larr;                  (SELECT paint FROM white =&gt; FALSE, black =&gt; TRUE,                    ENDCASE =&gt; ~bitAddress4[bitIndex2]);              IF inL4 AND inC3 THEN -- sector 4	        IF filled THEN {		  index &larr; fillFudge4 - fillcnt2;		  IF index ~IN [0..fillLength) THEN DisplayOps.LogError[];		  fill.xs[index] &larr; bitIndex3}                ELSE bitAddress4[bitIndex3] &larr;                  (SELECT paint FROM white =&gt; FALSE, black =&gt; TRUE,                    ENDCASE =&gt; ~bitAddress4[bitIndex3])};	    IF filled THEN  fillcnt1 &larr; fillcnt1 + 1;            bitIndex2 &larr; bitIndex2 - 1;            bitIndex3 &larr; bitIndex3 + 1;            bitAddress2 &larr; bitAddress2 - ctx.wpl;            bitAddress3 &larr; bitAddress3 + ctx.wpl;            error &larr; error + twoxma;            dashCnt &larr; (dashCnt + 10) MOD dashSum;            IF ABS[newError &larr; error - twoymb] &lt; ABS[error] THEN {              IF filled THEN fillcnt2 &larr; fillcnt2 + 1;              error &larr; newError;              bitIndex1 &larr; bitIndex1 + 1;              bitIndex4 &larr; bitIndex4 - 1;              bitAddress1 &larr; bitAddress1 + ctx.wpl;              bitAddress4 &larr; bitAddress4 - ctx.wpl;              twoymb &larr; twoymb - 2;              dashCnt &larr; (dashCnt + 4) MOD dashSum};            twoxma &larr; twoxma + 2;            ENDLOOP;          ENDLOOP};      ENDLOOP};  END.</pre>
  </body>
</html>
