-- Copyright (C) 1982, 1984  by Xerox Corporation. All rights reserved. -- WindowImplD.mesa - last edited by-- Daniels,	18-Jul-84 16:41:19-- Bruce,	15-Oct-82 20:50:46DIRECTORY  BitBlt USING [BBptr],  Display USING [Brick, Gray],  RecOps USING [Convert, RecList],  SpecialDisplay USING [    Handle, LineStyle, LineStyleObject, Special, SpecialContext],  SpecialWindow USING [],  UserTerminal USING [BitmapIsDisconnected, GetBitBltTable],  Window USING [Box, ValidateTree],  WindowOps USING [    bbPtr, Handle, InvalidateTree, lock, Object, WhitenRecList];WindowImplD: MONITOR LOCKS WindowOps.lock  IMPORTS Display, RecOps, UserTerminal, Window, WindowOps  EXPORTS SpecialDisplay, SpecialWindow, Window, WindowOps =    BEGIN  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = WindowOps.Object;  lock: PUBLIC MONITORLOCK;  rootWindow: PUBLIC Handle ¬ NIL;  defaultContext: PUBLIC SpecialDisplay.Special ¬ @mySpecial;  mySpecial: SpecialDisplay.SpecialContext ¬ [    bmAddress: NIL, wpl: TRASH, bpl: TRASH, alloc: NIL, free: NIL];  solid: PUBLIC SpecialDisplay.LineStyle ¬ @mySolid;  mySolid: SpecialDisplay.LineStyleObject ¬ [    widths: [NAT.LAST, 0, 0, 0, 0, 0], thickness: 1];  bitmapAddress: PUBLIC LONG ORDERED POINTER ¬ NIL;  bitmapHeight: PUBLIC CARDINAL;  rootGray: ARRAY [0..4) OF CARDINAL;  Recalculate: PUBLIC PROC [Handle] = {};  -- boo hiss!!  DefineRoot: PUBLIC PROC [    window: Handle, gray: ARRAY [0..4) OF CARDINAL, bitmapExists: BOOLEAN] = {    haveBitmap: BOOLEAN ¬ bitmapExists;    LockedDefine: ENTRY PROC = {      ENABLE UNWIND => NULL;      IF bitmapExists THEN {        bbt: BitBlt.BBptr ¬ WindowOps.bbPtr;        bbt­ ¬ UserTerminal.GetBitBltTable[          ! UserTerminal.BitmapIsDisconnected => {	    bitmapExists ¬ FALSE; CONTINUE}]};      IF bitmapExists THEN {        recList: RecOps.RecList;        mySpecial.bmAddress ¬ bitmapAddress ¬ LOOPHOLE[WindowOps.bbPtr.dst.word];	mySpecial.bpl ¬ CARDINAL[WindowOps.bbPtr.dstBpl];	mySpecial.wpl ¬ mySpecial.bpl/16;	bitmapHeight ¬ WindowOps.bbPtr.height;        rootWindow ¬ window;        rootWindow.beingDisplayed ¬ FALSE;        rootWindow.clearingRequired ¬ FALSE;        rootWindow.inTree ¬ TRUE;        rootWindow.parent ¬ NIL;        rootWindow.place ¬ [0, 0];        rootWindow.display ¬ DisplayRootWindow;        rootWindow.invalid ¬ NIL;        rootWindow.badPhosphor ¬ NIL;        rootGray ¬ gray;	WindowOps.WhitenRecList[recList ¬ RecOps.Convert[rootWindow]];        WindowOps.InvalidateTree[rootWindow, rootWindow.child, recList]}      ELSE {        rootWindow ¬ window;        rootWindow.parent ¬ NIL;        rootWindow.display ¬ NIL;        rootWindow.inTree ¬ FALSE}};    LockedDefine[];    IF bitmapExists THEN Window.ValidateTree[rootWindow]};  DisplayRootWindow: PROC [window: Handle] = {    gray: Display.Brick = DESCRIPTOR[rootGray];    Display.Gray[window, window.box, gray]};  END.