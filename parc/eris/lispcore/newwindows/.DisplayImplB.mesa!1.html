<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>NEWWINDOWS>DisplayImplB.mesa!1</title>
  </head>
  <body>
    <pre>
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- DisplayImplB.mesa - last edited by -- Rick	        12-Nov-83 14:44:30  -- Bruce	15-Feb-83 10:14:37  -- Daniels	 7-Jun-84 15:19:02  DIRECTORY  BitBlt USING [BitBltFlags],  Display USING [paintGrayFlags],  DisplayOps USING [    AbsPlace, HasUnder, LogError, FillList, FillObject, Intersect, Shade],  SpecialDisplay USING [DashCnt, defaultContext, LineStyle, solid, Special],  Window USING [BoxHandle, Place],  WindowOps USING [    AbsoluteBoxHandle, bitmapAddress, DisplayList, GetContext, lock,    Object, RecList, ScanLine, ScreenBox, SpecialTimesWpl];DisplayImplB: MONITOR LOCKS WindowOps.lock  IMPORTS DisplayOps, SpecialDisplay, WindowOps EXPORTS SpecialDisplay, Window =  BEGIN  -- exported types  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = WindowOps.Object;  FillHandle: TYPE = LONG POINTER TO FillObject;  FillObject: PUBLIC TYPE = DisplayOps.FillObject;  -- copied types because John doesn't like them  LineStyle: TYPE = SpecialDisplay.LineStyle;  Special: TYPE = SpecialDisplay.Special;  -- lines  Positive45Line: PUBLIC ENTRY PROC [    window: Handle, place: Window.Place, stopX: INTEGER,    bounds: Window.BoxHandle] = {    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist. Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &lt;= r.box.right    -- stop.x &gt;= r.box.left    -- start.y &gt;= r.box.top     -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window, bounds];    -- switch to screen coords    abs: Window.Place = DisplayOps.AbsPlace[window, place];    absX: INTEGER = stopX + window.place.x;    startAddress: WindowOps.ScanLine =      WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[INTEGER[abs.y]];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link UNTIL r = NIL      DO      IF DisplayOps.Intersect[r, absBounds] THEN {        bitAddress: WindowOps.ScanLine &larr; startAddress;        left: INTEGER = r.box.left;        top: INTEGER = r.box.top;        right: INTEGER = r.box.right;        bottom: INTEGER = r.box.bottom;	IF top = bottom THEN LOOP;        IF DisplayOps.HasUnder[r] THEN {          SpP45Internal[            window, abs, absX, absBounds, SpecialDisplay.solid,            Display.paintGrayFlags, SpecialDisplay.defaultContext];          RETURN};        place &larr; abs;        stopX &larr; absX;        IF bottom - 1 &lt; place.y THEN {          place.x &larr; place.x + place.y - bottom + 1;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[place.y-bottom+1]];          place.y &larr; bottom - 1};        IF left &gt; place.x THEN {          IF left &gt; place.y + place.x THEN LOOP;          place.y &larr; place.y + place.x - left;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[left-place.x]];          place.x &larr; left};        IF top &gt; place.y - stopX + place.x THEN stopX &larr; place.y + place.x - top;        IF right &lt; stopX THEN stopX &larr; right - 1;        FOR bitIndex: INTEGER IN [place.x..stopX] DO          bitAddress[bitIndex] &larr; TRUE;  -- set a bit          bitAddress &larr; bitAddress - SpecialDisplay.defaultContext.wpl;          ENDLOOP};      ENDLOOP};  SpPositive45Line: PUBLIC ENTRY PROC [    window: Handle, place: Window.Place, stopX: INTEGER, bounds: Window.BoxHandle,    dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist. Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &lt;= r.box.right    -- stop.x &gt;= r.box.left    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    IF window.inTree THEN {      absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window,bounds];      -- switch to screen coords      abs: Window.Place = DisplayOps.AbsPlace[window, place];      absX: INTEGER = stopX + window.place.x;      SpP45Internal[window, abs, absX, absBounds, dashes, flags, context]}};  SpP45Internal: INTERNAL PROC [    window: Handle, abs: Window.Place, absX: INTEGER,    absBounds: WindowOps.ScreenBox, dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special] = {    dashCnt, dashSum: CARDINAL;    filled: BOOLEAN = context.alloc # NIL;    widths: ARRAY [0..SpecialDisplay.DashCnt) OF CARDINAL;    inc1, inc2, inc3, inc4, inc5, inc6: CARDINAL;    low: INTEGER = abs.y - dashes.thickness/2;    high: INTEGER = low + dashes.thickness;    fillcnt, fillLength: INTEGER;    fill: FillHandle &larr; NIL;    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      widths[i] &larr; dashes.widths[i]*5/7; ENDLOOP;    inc1 &larr; 0;    inc2 &larr; widths[0];    inc3 &larr; inc2 + widths[1];    inc4 &larr; inc3 + widths[2];    inc5 &larr; inc4 + widths[3];    inc6 &larr; inc5 + widths[4];    dashSum &larr; inc6 + widths[5];    FOR r: WindowOps.RecList &larr; DisplayOps.FillList[window, filled], r.link       UNTIL r = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN {        ctx: Special = WindowOps.GetContext[r, context];        left: INTEGER &larr; MAX[r.box.left, absBounds.left];        top: INTEGER = MAX[r.box.top, absBounds.top];        right: INTEGER &larr; MIN[r.box.right, absBounds.right];        bottom: INTEGER = MIN[r.box.bottom, absBounds.bottom];	IF top = bottom THEN GOTO nextRectangle;	IF filled THEN {	  left &larr; MAX[0, left];	  right &larr; absBounds.right;	  fillLength &larr; bottom - top;	  fill &larr; ctx.alloc[window, top, fillLength];	  fill.xs[0] &larr; left};        FOR loopy: INTEGER IN [low..high) DO          placey: INTEGER &larr; loopy;          placex: INTEGER &larr; abs.x;          tempX: INTEGER &larr; absX;          bitAddress: WindowOps.ScanLine &larr;            ctx.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[placey], ctx];          dashCnt &larr; 0;          IF bottom - 1 &lt; placey THEN {            dashCnt &larr; (placey - bottom + 1) MOD dashSum;            placex &larr; placex + placey - bottom + 1;            bitAddress &larr;              bitAddress-WindowOps.SpecialTimesWpl[INTEGER[placey-bottom+1],ctx];            placey &larr; bottom - 1};          IF left &gt; placex THEN {            dashCnt &larr; (left - placex + dashCnt) MOD dashSum;            IF left &gt; placey + placex THEN GOTO nextRectangle;            placey &larr; placey + placex - left;            bitAddress &larr;              bitAddress - WindowOps.SpecialTimesWpl[INTEGER[left - placex], ctx];            placex &larr; left};          IF top &gt; placey - tempX + placex THEN {            IF top &gt; placey + placex THEN GOTO nextRectangle;            tempX &larr; placey + placex - top};          IF right &lt; tempX THEN tempX &larr; right - 1;          IF tempX - placex &lt;= 0 THEN LOOP;          IF filled THEN fillcnt &larr; placey - top;          FOR bitIndex: INTEGER IN [placex..tempX] DO            IF filled THEN {	      IF fillcnt ~IN [0..fillLength) THEN DisplayOps.LogError[];	      fill.xs[fillcnt] &larr; bitIndex;              fillcnt &larr; fillcnt - 1}            ELSE {              IF dashCnt IN [inc1..inc2) OR dashCnt IN [inc3..inc4)                OR dashCnt IN [inc5..inc6) THEN {                bitAddress[bitIndex] &larr;                  (SELECT DisplayOps.Shade[flags] FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~bitAddress[bitIndex])};              dashCnt &larr; (dashCnt + 1) MOD dashSum;              bitAddress &larr; bitAddress - ctx.wpl};            ENDLOOP;          ENDLOOP;        EXITS nextRectangle =&gt; NULL};      ENDLOOP};  Negative45Line: PUBLIC ENTRY PROC [    window: Handle, place: Window.Place, stopX: INTEGER,    bounds: Window.BoxHandle] = {    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &gt;= r.box.left    -- stop.x &lt;= r.box.right    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window, bounds];    -- switch to screen coords    abs: Window.Place = DisplayOps.AbsPlace[window, place];    absX: INTEGER = stopX + window.place.x;    startAddress: WindowOps.ScanLine =      WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[INTEGER[abs.y]];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link UNTIL r = NIL      DO      IF DisplayOps.Intersect[r, absBounds] THEN {        bitAddress: WindowOps.ScanLine &larr; startAddress;        left: INTEGER = r.box.left;        top: INTEGER = r.box.top;        right: INTEGER = r.box.right;        bottom: INTEGER = r.box.bottom;	IF top = bottom THEN LOOP;        IF DisplayOps.HasUnder[r] THEN {          SpN45Internal[            window, abs, absX, absBounds, SpecialDisplay.solid,            Display.paintGrayFlags, SpecialDisplay.defaultContext];          RETURN};        place &larr; abs;        stopX &larr; absX;        IF bottom - 1 &lt; place.y THEN {          IF place.y &gt; place.x + bottom - 1 THEN LOOP;          place.x &larr; place.x + bottom - 1 - place.y;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[place.y-bottom+1]];          place.y &larr; bottom - 1};        IF right - 1 &lt; place.x THEN {          IF place.x &gt; place.y + right - 1 THEN LOOP;          place.y &larr; place.y + right - 1 - place.x;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[place.x-right+1]];          place.x &larr; right - 1};        IF top &gt; place.y + stopX - place.x THEN stopX &larr; place.x - place.y + top;        IF left &gt; stopX THEN stopX &larr; left;        FOR bitIndex: INTEGER DECREASING IN [stopX..place.x] DO          bitAddress[bitIndex] &larr; TRUE;  -- set a bit          bitAddress &larr; bitAddress - SpecialDisplay.defaultContext.wpl;          ENDLOOP};      ENDLOOP};  SpNegative45Line: PUBLIC ENTRY PROC [    window: Handle, place: Window.Place, stopX: INTEGER, bounds: Window.BoxHandle,    dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &gt;= r.box.left    -- stop.x &lt;= r.box.right    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    IF window.inTree THEN {      absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window,bounds];      -- switch to screen coords      abs: Window.Place = DisplayOps.AbsPlace[window, place];      absX: INTEGER = stopX + window.place.x;      SpN45Internal[window, abs, absX, absBounds, dashes, flags, context]}};  SpN45Internal: INTERNAL PROC [    window: Handle, abs: Window.Place, absX: INTEGER,    absBounds: WindowOps.ScreenBox, dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special] = {    dashCnt, dashSum: CARDINAL;    filled: BOOLEAN = context.alloc # NIL;    widths: ARRAY [0..SpecialDisplay.DashCnt) OF CARDINAL;    inc1, inc2, inc3, inc4, inc5, inc6: CARDINAL;    low: INTEGER = abs.y - dashes.thickness/2;    high: INTEGER = low + dashes.thickness;    fillcnt, fillLength: INTEGER;    fill: FillHandle &larr; NIL;    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      widths[i] &larr; dashes.widths[i]*5/7; ENDLOOP;    inc1 &larr; 0;    inc2 &larr; widths[0];    inc3 &larr; inc2 + widths[1];    inc4 &larr; inc3 + widths[2];    inc5 &larr; inc4 + widths[3];    inc6 &larr; inc5 + widths[4];    dashSum &larr; inc6 + widths[5];    FOR r: WindowOps.RecList &larr; DisplayOps.FillList[window, filled], r.link UNTIL r      = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN {        ctx: Special = WindowOps.GetContext[r, context];        left: INTEGER &larr; MAX[r.box.left, absBounds.left];        top: INTEGER = MAX[r.box.top, absBounds.top];        right: INTEGER &larr; MIN[r.box.right, absBounds.right];        bottom: INTEGER = MIN[r.box.bottom, absBounds.bottom];	IF top = bottom THEN GOTO nextRectangle;	IF filled THEN {	  left &larr; MAX[0, left];	  right &larr; absBounds.right;	  fillLength &larr; bottom - top;          fill &larr; ctx.alloc[window, top, fillLength];	  fill.xs[0] &larr; left};        FOR loopy: INTEGER IN [low..high) DO          placey: INTEGER &larr; loopy;          placex: INTEGER &larr; abs.x;          tempX: INTEGER &larr; absX;          bitAddress: WindowOps.ScanLine &larr;            ctx.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[placey], ctx];          dashCnt &larr; 0;          IF bottom - 1 &lt; placey THEN {            dashCnt &larr; (placey - bottom + 1) MOD dashSum;            IF placey &gt; placex + bottom - 1 THEN GOTO nextRectangle;            placex &larr; placex + bottom - 1 - placey;            bitAddress &larr;              bitAddress-WindowOps.SpecialTimesWpl[INTEGER[placey-bottom+1],ctx];            placey &larr; bottom - 1};          IF right - 1 &lt; placex THEN {            dashCnt &larr; (placex - right + 1 + dashCnt) MOD dashSum;            IF placex &gt; placey + right - 1 THEN GOTO nextRectangle;            placey &larr; placey + right - 1 - placex;            bitAddress &larr;              bitAddress - WindowOps.SpecialTimesWpl[INTEGER[placex-right+1],ctx];            placex &larr; right - 1};          IF top &gt; placey + tempX - placex THEN tempX &larr; placex - placey + top;          IF left &gt; tempX THEN tempX &larr; left;          IF placex - tempX &lt;= 0 THEN GOTO nextRectangle;          IF filled THEN fillcnt &larr; placey - top;          FOR bitIndex: INTEGER DECREASING IN [tempX..placex] DO            IF filled THEN {	      IF fillcnt ~IN [0..fillLength) THEN DisplayOps.LogError[];              fill.xs[fillcnt] &larr; bitIndex;              fillcnt &larr; fillcnt - 1}            ELSE {              IF dashCnt IN [inc1..inc2) OR dashCnt IN [inc3..inc4)                OR dashCnt IN [inc5..inc6) THEN {                bitAddress[bitIndex] &larr;                  (SELECT DisplayOps.Shade[flags] FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~bitAddress[bitIndex])};              dashCnt &larr; (dashCnt + 1) MOD dashSum;              bitAddress &larr; bitAddress - ctx.wpl};            ENDLOOP;          ENDLOOP;        EXITS nextRectangle =&gt; NULL};      ENDLOOP};  PositiveShallowLine: PUBLIC ENTRY PROC [    window: Handle, start, stop: Window.Place, bounds: Window.BoxHandle] = {    -- because it's positive and shallow, we know:    --  start.x &lt; stop.x    --  start.y &gt; stop.y    --  stop.x - start.x &gt; start.y - stop.y    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &lt;= r.box.right    -- stop.x &gt;= r.box.left    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window, bounds];    -- switch to screen coords    absStart: Window.Place = DisplayOps.AbsPlace[window, start];    absStop: Window.Place = DisplayOps.AbsPlace[window, stop];    startError: INTEGER = absStop.x - absStart.x;    twox: INTEGER = startError*2;  -- positive    twoy: CARDINAL = (absStart.y - absStop.y)*2;  -- positive    startAddress: WindowOps.ScanLine =      WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[INTEGER[absStart.y]];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link UNTIL r = NIL      DO      IF DisplayOps.Intersect[r, absBounds] THEN {        bitAddress: WindowOps.ScanLine &larr; startAddress;        left: INTEGER = r.box.left;        top: INTEGER = r.box.top;        right: INTEGER = r.box.right;        bottom: INTEGER = r.box.bottom;        error: INTEGER &larr; startError;	IF top = bottom THEN LOOP;        IF DisplayOps.HasUnder[r] THEN {          SpPShInternal[            window, absStart, absStop, absBounds, SpecialDisplay.solid,            Display.paintGrayFlags, SpecialDisplay.defaultContext];          RETURN};        start &larr; absStart;        stop &larr; absStop;        IF bottom - 1 &lt; start.y THEN {          netError: LONG CARDINAL =            Inline.LongMult[twox, start.y - bottom] + error;          difx: INTEGER;          [difx, error] &larr; Inline.LongDivMod[netError, twoy];          error &larr; error + twox - twoy;          start.x &larr; difx + start.x + 1;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[start.y-bottom+1]];          start.y &larr; bottom - 1};        IF left &gt; start.x THEN {          difx: NATURAL;          netError: LONG INTEGER &larr; error - Inline.LongMult[twoy, left - start.x];          start.x &larr; left;          IF netError &lt; 0 THEN {            netError &larr; -netError;            [difx, error] &larr; Inline.LongDivMod[netError, twox];            IF error # 0 THEN {difx &larr; difx + 1; error &larr; twox - error};            start.y &larr; start.y - difx;            bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[difx]}          ELSE error &larr; Inline.LowHalf[netError]};        IF top &gt; stop.y THEN {          netError: LONG CARDINAL;          difx, errorTemp: INTEGER;          IF start.y &lt; top THEN LOOP;          netError &larr; Inline.LongMult[twox, start.y - top] + error;          [difx, errorTemp] &larr; Inline.LongDivMod[netError, twoy];          stop.x &larr; difx + start.x};        IF right - 1 &lt; stop.x THEN stop.x &larr; right - 1;        FOR bitIndex: INTEGER IN [start.x..stop.x] DO          bitAddress[bitIndex] &larr; TRUE;  -- invert a bit          error &larr; error - twoy;          IF error &lt; 0 THEN {            bitAddress &larr; bitAddress - SpecialDisplay.defaultContext.wpl; error &larr; error + twox};          ENDLOOP};      ENDLOOP};  SpPositiveShallowLine: PUBLIC ENTRY PROC [    window: Handle, start, stop: Window.Place, bounds: Window.BoxHandle,    dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    -- because it's positive and shallow, we know:    --  start.x &lt; stop.x    --  start.y &gt; stop.y    --  stop.x - start.x &gt; start.y - stop.y    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &lt;= r.box.right    -- stop.x &gt;= r.box.left    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    IF window.inTree THEN {      absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window,bounds];      -- switch to screen coords      absStart: Window.Place = DisplayOps.AbsPlace[window, start];      absStop: Window.Place = DisplayOps.AbsPlace[window, stop];      SpPShInternal[        window, absStart, absStop, absBounds, dashes, flags, context]}};  SpPShInternal: INTERNAL PROC [    window: Handle, absStart, absStop: Window.Place,    absBounds: WindowOps.ScreenBox, dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special] = {    startError: INTEGER = absStop.x - absStart.x;    twox: INTEGER = startError*2;  -- positive    twoy: CARDINAL = (absStart.y - absStop.y)*2;  -- positive    dashCnt, dashSum: CARDINAL;    filled: BOOLEAN = context.alloc # NIL;    widths: ARRAY [0..SpecialDisplay.DashCnt) OF CARDINAL;    inc1, inc2, inc3, inc4, inc5, inc6: CARDINAL;    low: INTEGER = absStart.y - dashes.thickness/2;    high: INTEGER = low + dashes.thickness;    difY: INTEGER &larr; absStop.y - absStart.y;    fill: FillHandle &larr; NIL;    fillcnt, fillLength: INTEGER;    dashstretch: CARDINAL =      SELECT twox FROM        &gt; twoy*15/4 =&gt; 13,  -- 0 to 15 degrees        &gt; twoy*7/4 =&gt; 12,  -- 15 to 30 degrees        ENDCASE =&gt; 11;  -- 30 to 45 degrees    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      widths[i] &larr; dashes.widths[i]*dashstretch/14; ENDLOOP;    inc1 &larr; 0;    inc2 &larr; widths[0];    inc3 &larr; inc2 + widths[1];    inc4 &larr; inc3 + widths[2];    inc5 &larr; inc4 + widths[3];    inc6 &larr; inc5 + widths[4];    dashSum &larr; 0;    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      dashSum &larr; dashSum + widths[i]; ENDLOOP;    FOR r: WindowOps.RecList &larr; DisplayOps.FillList[window, filled], r.link       UNTIL r = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN {        ctx: Special = WindowOps.GetContext[r, context];        left: INTEGER &larr; MAX[r.box.left, absBounds.left];        top: INTEGER = MAX[r.box.top, absBounds.top];        right: INTEGER &larr; MIN[r.box.right, absBounds.right];        bottom: INTEGER = MIN[r.box.bottom, absBounds.bottom];	IF top = bottom THEN GOTO nextRectangle;	IF filled THEN {	  left &larr; MAX[0, left];	  right &larr; absBounds.right;	  fillLength &larr; bottom - top;	  fill &larr; ctx.alloc[window, top, fillLength];	  fill.xs[0] &larr; left};        FOR loopy: INTEGER IN [low..high) DO          startX: INTEGER &larr; absStart.x;          startY: INTEGER &larr; loopy;          stopX: INTEGER &larr; absStop.x;          stopY: INTEGER &larr; startY + difY;          error: INTEGER &larr; startError;          bitAddress: WindowOps.ScanLine &larr;            ctx.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[startY], ctx];          dashCnt &larr; 0;          IF bottom - 1 &lt; startY THEN {            netError: LONG CARDINAL =              Inline.LongMult[twox, startY - bottom] + error;            difx: INTEGER;            [difx, error] &larr; Inline.LongDivMod[netError, twoy];            error &larr; error + twox - twoy;            startX &larr; difx + startX + 1;            dashCnt &larr; (difx + 1) MOD dashSum;            bitAddress &larr;              bitAddress-WindowOps.SpecialTimesWpl[INTEGER[startY-bottom+1],ctx];            startY &larr; bottom - 1};          IF left &gt; startX THEN {            difx: NATURAL;            netError: LONG INTEGER &larr; error - Inline.LongMult[twoy, left - startX];            dashCnt &larr; (left - startX + dashCnt) MOD dashSum;            startX &larr; left;            IF netError &lt; 0 THEN {              netError &larr; -netError;              [difx, error] &larr; Inline.LongDivMod[netError, twox];              IF error # 0 THEN {difx &larr; difx + 1; error &larr; twox - error};              startY &larr; startY - difx;              bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[difx, ctx]}            ELSE error &larr; Inline.LowHalf[netError]};          IF top &gt; stopY THEN {            netError: LONG CARDINAL;            difx, errorTemp: INTEGER;            IF startY &lt; top THEN GOTO nextRectangle;            netError &larr; Inline.LongMult[twox, startY - top] + error;            [difx, errorTemp] &larr; Inline.LongDivMod[netError, twoy];            stopX &larr; difx + startX;            stopY &larr; top};          IF right - 1 &lt; stopX THEN {            IF filled THEN {              difx: CARDINAL;              errorTemp: INTEGER;              netError: LONG INTEGER;              IF right &lt;= startX + 1 THEN GOTO nextRectangle;              netError &larr; error - Inline.LongMult[twoy, right - 1 - startX];              IF netError &lt; 0 THEN {                netError &larr; -netError;                [difx, errorTemp] &larr; Inline.LongDivMod[netError, twox];                IF errorTemp # 0 THEN difx &larr; difx + 1;                stopY &larr; startY - difx}};            stopX &larr; right - 1};          IF startY - stopY &lt; 0 THEN GOTO nextRectangle;          IF filled THEN {	    fillcnt &larr; startY - top;	    fill.xs[fillcnt] &larr; MAX[startX, 0];	    fill.xs[0] &larr; MAX[stopX, 0]};          FOR bitIndex: INTEGER IN [startX..stopX] DO            IF ~filled THEN {              IF dashCnt IN [inc1..inc2) OR dashCnt IN [inc3..inc4)                OR dashCnt IN [inc5..inc6) THEN                bitAddress[bitIndex] &larr;                  (SELECT DisplayOps.Shade[flags] FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~bitAddress[bitIndex]);              dashCnt &larr; (dashCnt + 1) MOD dashSum};            error &larr; error - twoy;            IF error &lt; 0 THEN {              IF filled THEN {                IF fillcnt ~IN [0..fillLength) THEN DisplayOps.LogError[];		fill.xs[fillcnt] &larr; bitIndex;		fillcnt &larr; fillcnt - 1}              ELSE bitAddress &larr; bitAddress - ctx.wpl;              error &larr; error + twox};            ENDLOOP;          ENDLOOP;        EXITS nextRectangle =&gt; NULL};      ENDLOOP};  NegativeShallowLine: PUBLIC ENTRY PROC [    window: Handle, start, stop: Window.Place, bounds: Window.BoxHandle] = {    -- because it's positive and shallow, we know:    --  start.x &gt; stop.x    --  start.y &gt; stop.y    --  start.x - stop.x &gt; start.y - stop.y    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &gt;= r.box.left    -- stop.x &lt;= r.box.right    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window, bounds];    -- switch to screen coords    absStart: Window.Place = DisplayOps.AbsPlace[window, start];    absStop: Window.Place = DisplayOps.AbsPlace[window, stop];    startError: INTEGER = absStart.x - absStop.x;    twox: INTEGER = startError*2;  -- positive    twoy: CARDINAL = (absStart.y - absStop.y)*2;  -- positive    startAddress: WindowOps.ScanLine =      WindowOps.bitmapAddress + WindowOps.SpecialTimesWpl[INTEGER[absStart.y]];    IF ~window.inTree THEN RETURN;    FOR r: WindowOps.RecList &larr; WindowOps.DisplayList[window], r.link      UNTIL r = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN {        bitAddress: WindowOps.ScanLine &larr; startAddress;        left: INTEGER = r.box.left;        top: INTEGER = r.box.top;        right: INTEGER = r.box.right;        bottom: INTEGER = r.box.bottom;        error: INTEGER &larr; startError;	IF top = bottom THEN LOOP;        IF DisplayOps.HasUnder[r] THEN {          SpNShInternal[            window, absStart, absStop, absBounds, SpecialDisplay.solid,            Display.paintGrayFlags, SpecialDisplay.defaultContext];          RETURN};        start &larr; absStart;        stop &larr; absStop;        IF bottom - 1 &lt; start.y THEN {          netError: LONG CARDINAL =            Inline.LongMult[twox, start.y - bottom] + error;          difx: INTEGER;          [difx, error] &larr; Inline.LongDivMod[netError, twoy];          error &larr; error + twox - twoy;          start.x &larr; start.x - difx - 1;          bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[INTEGER[start.y-bottom+1]];          start.y &larr; bottom - 1};        IF right - 1 &lt; start.x THEN {          difx: NATURAL;          netError: LONG INTEGER &larr;            error - Inline.LongMult[twoy, start.x - right + 1];          start.x &larr; right - 1;          IF netError &lt; 0 THEN {            netError &larr; -netError;            [difx, error] &larr; Inline.LongDivMod[netError, twox];            IF error # 0 THEN {difx &larr; difx + 1; error &larr; twox - error};            start.y &larr; start.y - difx;            bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[difx]}          ELSE error &larr; Inline.LowHalf[netError]};        IF top &gt; stop.y THEN {          netError: LONG CARDINAL;          difx, errorTemp: INTEGER;          IF start.y &lt; top THEN LOOP;          netError &larr; Inline.LongMult[twox, start.y - top] + error;          [difx, errorTemp] &larr; Inline.LongDivMod[netError, twoy];          stop.x &larr; start.x - difx};        IF left &gt; stop.x THEN stop.x &larr; left;        FOR bitIndex: INTEGER DECREASING IN [stop.x..start.x] DO          bitAddress[bitIndex] &larr; TRUE;  -- set a bit          error &larr; error - twoy;          IF error &lt; 0 THEN {            bitAddress &larr; bitAddress - SpecialDisplay.defaultContext.wpl; error &larr; error + twox};          ENDLOOP};      ENDLOOP};  SpNegativeShallowLine: PUBLIC ENTRY PROC [    window: Handle, start, stop: Window.Place, bounds: Window.BoxHandle,    dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special &larr; SpecialDisplay.defaultContext] = {    -- because it's positive and shallow, we know:    --  start.x &gt; stop.x    --  start.y &gt; stop.y    --  start.x - stop.x &gt; start.y - stop.y    -- This routine intersects the bounding box of any line displayed with the    -- bounding box of each reclist.  Given this, the fact that start.y &gt;= stop.y,    -- and the specific type of line being delt with here it is assumed that:    -- start.x &gt;= r.box.left    -- stop.x &lt;= r.box.right    -- start.y &gt;= r.box.top    -- stop.y &lt;= r.box.bottom or else DisplayOps.Intersect fails.    ENABLE UNWIND =&gt; NULL;    IF window.inTree THEN {      absBounds: WindowOps.ScreenBox = WindowOps.AbsoluteBoxHandle[window,bounds];      -- switch to screen coords      absStart: Window.Place = DisplayOps.AbsPlace[window, start];      absStop: Window.Place = DisplayOps.AbsPlace[window, stop];      SpNShInternal[        window, absStart, absStop, absBounds, dashes, flags, context]}};  SpNShInternal: INTERNAL PROC [    window: Handle, absStart, absStop: Window.Place,    absBounds: WindowOps.ScreenBox, dashes: LineStyle, flags: BitBlt.BitBltFlags,    context: Special] = {    startError: INTEGER = absStart.x - absStop.x;    twox: INTEGER = startError*2;  -- positive    twoy: CARDINAL = (absStart.y - absStop.y)*2;  -- positive    dashCnt, dashSum: CARDINAL;    filled: BOOLEAN = context.alloc # NIL;    widths: ARRAY [0..SpecialDisplay.DashCnt) OF CARDINAL;    inc1, inc2, inc3, inc4, inc5, inc6: CARDINAL;    low: INTEGER = absStart.y - dashes.thickness/2;    high: INTEGER = low + dashes.thickness;    difY: INTEGER &larr; absStop.y - absStart.y;    fill: FillHandle &larr; NIL;    fillcnt, fillLength: INTEGER;    dashstretch: CARDINAL =      SELECT twox FROM        &gt; twoy*15/4 =&gt; 13,  -- 0 to 15 degrees        &gt; twoy*7/4 =&gt; 12,  -- 15 to 30 degrees        ENDCASE =&gt; 11;  -- 30 to 45 degrees    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      widths[i] &larr; dashes.widths[i]*dashstretch/14; ENDLOOP;    inc1 &larr; 0;    inc2 &larr; widths[0];    inc3 &larr; inc2 + widths[1];    inc4 &larr; inc3 + widths[2];    inc5 &larr; inc4 + widths[3];    inc6 &larr; inc5 + widths[4];    dashSum &larr; 0;    FOR i: CARDINAL IN [0..SpecialDisplay.DashCnt) DO      dashSum &larr; dashSum + widths[i]; ENDLOOP;    FOR r: WindowOps.RecList &larr; DisplayOps.FillList[window, filled], r.link       UNTIL r = NIL DO      IF DisplayOps.Intersect[r, absBounds] THEN {        ctx: Special = WindowOps.GetContext[r, context];        left: INTEGER &larr; MAX[r.box.left, absBounds.left];        top: INTEGER = MAX[r.box.top, absBounds.top];        right: INTEGER &larr; MIN[r.box.right, absBounds.right];        bottom: INTEGER = MIN[r.box.bottom, absBounds.bottom];	IF top = bottom THEN GOTO nextRectangle;	IF filled THEN {	  left &larr; MAX[0, left];	  right &larr; absBounds.right;	  fillLength &larr; bottom - top;          fill &larr; ctx.alloc[window, top, fillLength];	  fill.xs[0] &larr; left};        FOR loopy: INTEGER IN [low..high) DO          startX: INTEGER &larr; absStart.x;          startY: INTEGER &larr; loopy;          stopX: INTEGER &larr; absStop.x;          stopY: INTEGER &larr; startY + difY;          error: INTEGER &larr; startError;          bitAddress: WindowOps.ScanLine &larr;            ctx.bmAddress + WindowOps.SpecialTimesWpl[INTEGER[startY], ctx];          dashCnt &larr; 0;          IF bottom - 1 &lt; startY THEN {            netError: LONG CARDINAL =              Inline.LongMult[twox, startY - bottom] + error;            difx: INTEGER;            [difx, error] &larr; Inline.LongDivMod[netError, twoy];            error &larr; error + twox - twoy;            startX &larr; startX - difx - 1;            dashCnt &larr; (difx + 1) MOD dashSum;            bitAddress &larr;              bitAddress-WindowOps.SpecialTimesWpl[INTEGER[startY-bottom+1],ctx];            startY &larr; bottom - 1};          IF right - 1 &lt; startX THEN {            difx: NATURAL;            netError: LONG INTEGER &larr;              error - Inline.LongMult[twoy, startX - right + 1];            dashCnt &larr; (startX - right + 1 + dashCnt) MOD dashSum;            startX &larr; right - 1;            IF netError &lt; 0 THEN {              netError &larr; -netError;              [difx, error] &larr; Inline.LongDivMod[netError, twox];              IF error # 0 THEN {difx &larr; difx + 1; error &larr; twox - error};              startY &larr; startY - difx;              bitAddress &larr; bitAddress - WindowOps.SpecialTimesWpl[difx, ctx]}            ELSE error &larr; Inline.LowHalf[netError]};          IF top &gt; stopY THEN {            netError: LONG CARDINAL;            difx, errorTemp: INTEGER;            IF startY &lt; top THEN GOTO nextRectangle;            netError &larr; Inline.LongMult[twox, startY - top] + error;            [difx, errorTemp] &larr; Inline.LongDivMod[netError, twoy];            stopX &larr; startX - difx;            stopY &larr; top};          IF left &gt; stopX THEN {            IF filled THEN {              difx: CARDINAL;              errorTemp: INTEGER;              netError: LONG INTEGER;              IF startX &lt;= left THEN GOTO nextRectangle;              netError &larr; error - Inline.LongMult[twoy, startX - left];              IF netError &lt; 0 THEN {                netError &larr; -netError;                [difx, errorTemp] &larr; Inline.LongDivMod[netError, twox];                IF errorTemp # 0 THEN difx &larr; difx + 1;                stopY &larr; startY - difx}};            stopX &larr; left};          IF startY - stopY &lt; 0 THEN GOTO nextRectangle;          IF filled THEN {            fillcnt &larr; startY - top;	    fill.xs[fillcnt] &larr; MAX[startX, 0];	    fill.xs[0] &larr; MAX[stopX, 0]};          FOR bitIndex: INTEGER DECREASING IN [stopX..startX] DO            IF ~filled THEN {              IF dashCnt IN [inc1..inc2) OR dashCnt IN [inc3..inc4)                OR dashCnt IN [inc5..inc6) THEN                bitAddress[bitIndex] &larr;                  (SELECT DisplayOps.Shade[flags] FROM                     white =&gt; FALSE,                     black =&gt; TRUE,                     ENDCASE =&gt; ~bitAddress[bitIndex]);              dashCnt &larr; (dashCnt + 1) MOD dashSum};            error &larr; error - twoy;            IF error &lt; 0 THEN {              IF filled THEN {	        IF fillcnt ~IN [0..fillLength) THEN DisplayOps.LogError[];	        fill.xs[fillcnt] &larr; bitIndex;                fillcnt &larr; fillcnt - 1}              ELSE bitAddress &larr; bitAddress - ctx.wpl;              error &larr; error + twox};            ENDLOOP;          ENDLOOP;        EXITS nextRectangle =&gt; NULL};      ENDLOOP};  END.</pre>
  </body>
</html>
