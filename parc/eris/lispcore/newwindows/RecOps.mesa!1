-- Copyright (C) 1982, 1984  by Xerox Corporation. All rights reserved. -- RecOps.mesa - last edited by  --  Bruce	15-Dec-82 11:49:42  --  Daniels,	16-Mar-84 14:11:55  DIRECTORY  Window USING [Box, Handle],  WindowOps USING [RecList, ScreenBox];RecOps: DEFINITIONS =  BEGIN    What: TYPE = {null, src, dst};    RecList: TYPE = WindowOps.RecList;    << ClipBox adjusts the box to fit within all its parents.  It returns the last   parent below the root window.  The box passed in is consumed. >>  ClipBox: PROC [window: Window.Handle, box: RecList]     RETURNS [clippedBox: RecList, lastParent: Window.Handle];  Convert: PROC [Window.Handle] RETURNS [RecList];  ConvertBox: PROC [Window.Handle, Window.Box] RETURNS [RecList];    WindowToScreenBox: PROC [Window.Box] RETURNS [WindowOps.ScreenBox];    ScreenToWindowBox: PROC [WindowOps.ScreenBox] RETURNS [Window.Box];    -- Append links list2 on the end of list1 and returns the result.  Append: PROC [list1, list2: RecList] RETURNS [RecList];    << Bite bites every box on biter out of every box on list, preserving the  source and destination fields of list. It consumes the both lists. >>  Bite: PROC [list, biter: RecList] RETURNS [newList: RecList ¬ NIL];  << Blt blts the reclist by dx and dy using the algorithm from Guibas and Yao.  It consumes the list passed in. >>  Blt: PROC [list: RecList, dx, dy: INTEGER];  -- Coalesces adjacent boxes on the reclist.  It consumes the list passed in.  Coalesce: PROC [RecList] RETURNS [RecList];    Copy: PROC [old: RecList] RETURNS [new: RecList ¬ NIL];    << Disjoint decides (quickly) whether or not two RecLists intersect.  Does not consume either list. >>  Disjoint: PROC [list1, list2: RecList] RETURNS [BOOLEAN];  << Intersect returns all the boxes that result from intersecting every   box on list2 with every box on list1.  If src or dst of intersecting  rectangles don't match, it will raise ClientError[ambigious].  It does NOT consume either list. >>  Intersect: PROC [list1, list2: RecList] RETURNS [list3: RecList];    << Shift returns the reclist passed in with every box shifted by dx, dy.  It  consumes the list passed in. >>  Shift: PROC [list: RecList, dx, dy: INTEGER] RETURNS [r: RecList];    << Simple append pastes two reclists together.  This should only be used for  invalid lists or when the two reclists are known to be disjoint. >>  SimpleAppend: PROC [RecList, RecList] RETURNS [RecList];  << Visible bites out the part of the boxes on the list that are covered  by another window.  If what # null then boxes that logically belong to a  window with a bitmap under will have the appropriate field set to the new  window.  Otherwise, the value of the src or dst field in the original  rectangle is preserved.  It consumes the list passed in. >>  Visible: PROC [    w: Window.Handle, list: RecList, what: What, biteChildren: BOOLEAN ¬ FALSE]     RETURNS [newList: RecList];    Alloc: PROC RETURNS [RecList];  Free: PROC [RecList];  FreeRecList: PROC [RecList];    CheckForLeaks: PROC [useTree: BOOLEAN, cache: RecList];     <<CleanInvalid fixes up a window's invalid list to be a real reclist, i.e.,  rectangles are disjoint and src = dst = NIL.  It returns the new window.invalid  for convenience. >>  CleanInvalid: PROC [Window.Handle] RETURNS [RecList];    END.