<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;LispCore>BVM>ZNewHeaders>LispBcplFiles.dm!1>DspStreamsB.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">// DspStreamsB.bcpl -- Companion file is DspStreamsA.asm<br>// Copyright Xerox Corporation 1979, 1980<br>// Alto BitBlt removed January 21, 1985  1:15 PM by van Melle<br>// Last modified November 26, 1980  3:29 PM by Taft<br><br>// Definition of DS in Streams.d publishes only the generic stream<br>// stuff + fdcb, ldcb, scroll, compact, cdcb<br><br>get "Streams.d"<br>get "AltoDefs.d"<br><br>external<br>[<br>// outgoing procedures<br>CreateDisplayStream</span><span class="tab" val="67"></span><span style="font: 10pt serif">// (nlines, pBlock, lBlock, Font [sysFont]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// wWidth [38], options [left+right}, zone<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// [sysZone]) -&gt; ds<br>ShowDisplayStream</span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds, how [, otherS])<br>GetFont</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds) -&gt; font<br>SetFont</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds, font)<br>GetBitPos</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds) -&gt; pos<br>SetBitPos</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds, pos)<br>GetLinePos</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds) -&gt; lpos<br>SetLinePos</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds, lpos) -&gt; true/false<br>InvertLine</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds, lpos) -&gt; 0/1<br>EraseBits</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds, nbits[, flag])<br>CharWidth</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (fontorstream, charorstring) -&gt; width<br>GetLmarg</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds) -&gt; pos<br>SetLmarg</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds, pos)<br>GetRmarg</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds) -&gt; pos<br>SetRmarg</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds, pos)<br>Scroll</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds[, char])<br>ResetLine</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds)<br>FontHeight</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (font) -&gt; height<br><br>// incoming procedures<br>MoveBlock; SetBlock; Zero; BitBlt; Max; Min; Usc<br>DefaultArgs; CallSwat; SysErr<br>Allocate; Free<br>DisplayPut</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// (ds, char), in DspStreamsA.asm<br>Puts<br><br>// incoming statics<br>dsp; sysFont; sysZone<br>]<br><br>// error codes<br>manifest<br>[<br>ecNotEnoughRoom = 1700<br>ecBadHowCommand = 1701<br>]<br><br>// Display stream (published part is in Streams.D)<br>// numbered entries used by assembly code<br>// starred entries may be modified after initialization<br><br>structure DSS:<br>[<br>@DS</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// 12 + 2 words ( scroll=12)<br>lmarg word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// * left margin<br>rmarg word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// * right margin<br>options word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// option flags<br>blksz word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// block size for text line<br>nwrds word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// words per full scan line<br>pfont word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// *19 pointer to font<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Following 2 are in order for CONVRT instruction<br>bwrds word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// *20 words per scan line<br>dba word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// *21, destination bit address<br>bstop word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// *22, bit where to stop writing<br>bsofar word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// *23, bits so far in this line<br>wad word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// *24, dest. word address<br>savac2 word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// *25, temp for AC2<br>fmp word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// pointer to full text line of bitmap<br>bda word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// beginning of bitmap data area<br>tdcb word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// * top DCB with data<br>mwp word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// * bitmap writer pointer<br>nl word</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// number of lines user has<br>zone word</span><span class="tab" val="67"></span><span style="font: 10pt serif">// zone allocated from<br>]<br>manifest lDSS = (size DSS)/16<br><br><br>manifest<br>[<br>displayheight = 808<br>displaywidth = 606<br>leftmargin = 8<br>]<br><br>structure STRING [ length byte; char &uarr;1,255 byte ]<br><br>//----------------------------------------------------------------------------<br>let CreateDisplayStream(nl, ssa, esa, font, wWidth, options,<br> zone; numargs na) = valof<br>//----------------------------------------------------------------------------<br>[<br>DefaultArgs(lv na, -3, sysFont, ((displaywidth+31)/16)&(-2),<br> DScompactleft+DScompactright, sysZone)<br>compileif lDSS gr lDS then [ foo = nil ]<br>esa = ssa + esa<br>ssa = (ssa+1) & (not 1)<br>esa = (esa) & (not 1)<br>let ds = Allocate(zone, lDSS)<br>ds&gt;&gt;DSS.zone = zone<br>ds&gt;&gt;DSS.nl = nl<br>ds&gt;&gt;DSS.pfont = font<br>ds&gt;&gt;DSS.type = stTypeDisplay<br>ds&gt;&gt;DSS.nwrds = wWidth<br>let ht = (xfont(font)!(-2)+1) rshift 1<br>let bsz = wWidth*ht*2<br>if Usc(esa-ssa, nl*lDCB+bsz) ls 0 then SysErr(ds, ecNotEnoughRoom)<br>ds&gt;&gt;DSS.puts = DisplayPut<br>ds&gt;&gt;DSS.close = ReleaseDs<br>ds&gt;&gt;DSS.reset = ClearDs<br>ds&gt;&gt;DSS.scroll = Scroll<br>ds&gt;&gt;DSS.compact = Compact<br>let edcb = ssa + nl*lDCB<br>let ldcb = edcb - lDCB<br>ds&gt;&gt;DSS.fdcb, ds&gt;&gt;DSS.ldcb = ssa, ldcb<br>ds&gt;&gt;DSS.blksz = bsz<br>let bda = edcb<br>ds&gt;&gt;DSS.fmp = esa - bsz<br>ds&gt;&gt;DSS.bda = bda<br>let p = ssa<br>for i = 1 to nl do<br>   [<br>   p&gt;&gt;DCB.next, p&gt;&gt;DCB.height = p+lDCB, ht<br>   p = p +lDCB<br>   ]<br>ldcb&gt;&gt;DCB.next = 0<br>let rightmargin = wWidth*16<br>if rightmargin gr displaywidth then rightmargin = displaywidth<br>ds&gt;&gt;DSS.lmarg, ds&gt;&gt;DSS.rmarg = leftmargin, rightmargin<br>ds&gt;&gt;DSS.options = options<br>SetFont(ds, font)<br>ClearDs(ds)<br>resultis ds<br>]<br><br>//----------------------------------------------------------------------------<br>and CharWidth(font, char) = valof<br>//----------------------------------------------------------------------------<br>[<br>let w, cw = 0, nil<br>if (char & 177400b) ne 0 then<br>   [<br>   for i = 1 to char&gt;&gt;STRING.length do<br>      w = w + CharWidth(font, char&gt;&gt;STRING.char&uarr;i)<br>   resultis w<br>   ]<br>if font&gt;&gt;DSS.type eq stTypeDisplay then font = font&gt;&gt;DSS.pfont<br>if font!-2 ls 0 then font, w = font!-1, 1<br>   [<br>   cw = font!(font!char+char)<br>   if (cw & 1) ne 0 then break<br>   w, char = w+16, cw rshift 1<br>   ] repeat<br>resultis w + cw rshift 1<br>]<br><br>//----------------------------------------------------------------------------<br>and ResetLine(ds) be<br>//----------------------------------------------------------------------------<br>[<br>SetBitPos(ds, ds&gt;&gt;DSS.rmarg)<br>EraseBits(ds, ds&gt;&gt;DSS.lmarg-ds&gt;&gt;DSS.rmarg)<br>]<br><br>//----------------------------------------------------------------------------<br>and FontHeight(font) = xfont(font)!-2<br>//----------------------------------------------------------------------------<br><br>//----------------------------------------------------------------------------<br>and xfont(font) = (font!-2 ls 0? font!-1, font)<br>//----------------------------------------------------------------------------<br><br>//----------------------------------------------------------------------------<br>and ClearDs(ds) be<br>//----------------------------------------------------------------------------<br>[<br>let fdcb, fmp = ds&gt;&gt;DSS.fdcb, ds&gt;&gt;DSS.fmp<br>let dcb = fdcb<br>for i = 1 to ds&gt;&gt;DSS.nl do<br>   [<br>   dcb&gt;&gt;DCB.parwd = 0<br>   dcb&gt;&gt;DCB.bitmap = fmp<br>   dcb = dcb +lDCB<br>   ]<br>ds&gt;&gt;DSS.cdcb = fdcb<br>ds&gt;&gt;DSS.tdcb = fdcb<br>fdcb&gt;&gt;DCB.width = ds&gt;&gt;DSS.nwrds<br>ds&gt;&gt;DSS.mwp = ds&gt;&gt;DSS.bda<br>ClearMap(ds)<br>]<br><br>//----------------------------------------------------------------------------<br>and ClearMap(ds) be<br>//----------------------------------------------------------------------------<br>[<br>ds&gt;&gt;DSS.cdcb&gt;&gt;DCB.indwidth = ds&gt;&gt;DSS.nwrds<br>Zero(ds&gt;&gt;DSS.fmp, ds&gt;&gt;DSS.blksz)<br>SetBitPos(ds, ds&gt;&gt;DSS.lmarg)<br>]<br><br>//----------------------------------------------------------------------------<br>and ReleaseDs(ds) = valof<br>//----------------------------------------------------------------------------<br>[<br>ShowDisplayStream(ds, DSdelete)<br>Free(ds&gt;&gt;DSS.zone, ds)<br>resultis 0<br>]<br><br>//----------------------------------------------------------------------------<br>and ShowDisplayStream(ds, how, otherDs; numargs na) be<br>//----------------------------------------------------------------------------<br>// fdcb and ldcb must be first two elements of DSS structure -- this<br>// is so that other people can simulate "streams" easily for the<br>// purposes of using this routine<br>[<br>compileif offset DSS.fdcb ne 0 % offset DSS.ldcb ne 16 then [ foo = nil ]<br>DefaultArgs(lv na, -1, DSbelow, dsp)<br>let p = nil<br>switchon how into<br>   [<br>   case DSdelete:<br>      [<br>      p = PrevDCB(ds!0)<br>      if p then p&gt;&gt;DCB.next = (ds!1)&gt;&gt;DCB.next<br>      endcase<br>      ]<br>   case DSbelow:<br>      [<br>      (ds!1)&gt;&gt;DCB.next = (otherDs!1)&gt;&gt;DCB.next<br>      (otherDs!1)&gt;&gt;DCB.next = ds!0<br>      endcase<br>      ]<br>   case DSabove:<br>      [<br>      p = PrevDCB(otherDs!0)<br>      if p then <br>         [<br>         (ds!1)&gt;&gt;DCB.next = otherDs!0<br>         p&gt;&gt;DCB.next = ds!0<br>         ]<br>      endcase<br>      ]<br>   case DSalone:<br>      [<br>      (ds!1)&gt;&gt;DCB.next = 0<br>      @displayListHead = ds!0<br>      endcase<br>      ]<br>   default: SysErr(ds, ecBadHowCommand)<br>   ]<br>]<br><br>//----------------------------------------------------------------------------<br>and PrevDCB(dcb) = valof<br>//----------------------------------------------------------------------------<br>[<br>let org = displayListHead-(offset DCB.next/16)<br>while org&gt;&gt;DCB.next ne dcb do<br>   [<br>   if org eq 0 then resultis 0<br>   org = org&gt;&gt;DCB.next<br>   ]<br>resultis org<br>]<br><br>//----------------------------------------------------------------------------<br>and GetFont(ds) = ds&gt;&gt;DSS.pfont<br>//----------------------------------------------------------------------------<br><br>//----------------------------------------------------------------------------<br>and SetFont(ds, pfont) = valof<br>//----------------------------------------------------------------------------<br>[<br>let ht = (xfont(pfont)!(-2)+1) rshift 1<br>ds&gt;&gt;DSS.pfont = pfont<br>SetRmarg(ds, ds&gt;&gt;DSS.rmarg)<br>resultis ht le ds&gt;&gt;DSS.cdcb&gt;&gt;DCB.height<br>]<br><br>//----------------------------------------------------------------------------<br>and GetBitPos(ds) = ds&gt;&gt;DSS.bsofar<br>//----------------------------------------------------------------------------<br><br>//----------------------------------------------------------------------------<br>and SetBitPos(ds, pos) = valof<br>//----------------------------------------------------------------------------<br>[<br>ds&gt;&gt;DSS.bsofar = pos<br>ds&gt;&gt;DSS.dba = (not pos) & 17b<br>let cdcb = ds&gt;&gt;DSS.cdcb<br>ds&gt;&gt;DSS.bwrds = cdcb&gt;&gt;DCB.width<br>ds&gt;&gt;DSS.wad = cdcb&gt;&gt;DCB.bitmap-cdcb&gt;&gt;DCB.width+pos rshift 4<br>resultis pos le ds&gt;&gt;DSS.bstop<br>]<br><br>//----------------------------------------------------------------------------<br>and GetLmarg(ds) = ds&gt;&gt;DSS.lmarg<br>//----------------------------------------------------------------------------<br><br>//----------------------------------------------------------------------------<br>and SetLmarg(ds, pos) be<br>//----------------------------------------------------------------------------<br>[<br>ds&gt;&gt;DSS.lmarg = pos<br>SetBitPos(ds, pos)<br>]<br><br>//----------------------------------------------------------------------------<br>and GetRmarg(ds) = ds&gt;&gt;DSS.rmarg<br>//----------------------------------------------------------------------------<br><br>//----------------------------------------------------------------------------<br>and SetRmarg(ds, pos) be<br>//----------------------------------------------------------------------------<br>[<br>ds&gt;&gt;DSS.rmarg = pos<br>let d, font = 0, ds&gt;&gt;DSS.pfont<br>if font!-2 ls 0 then d, font = 1, font!-1<br>ds&gt;&gt;DSS.bstop = pos-(font!(-1) & 377b)-d<br>]<br><br>//----------------------------------------------------------------------------<br>and GetLinePos(ds) = (ds&gt;&gt;DSS.cdcb-ds&gt;&gt;DSS.fdcb)/lDCB<br>//----------------------------------------------------------------------------<br><br>//----------------------------------------------------------------------------<br>and SetLinePos(ds, lpos) = valof<br>//----------------------------------------------------------------------------<br>[<br>let dcb = ds&gt;&gt;DSS.fdcb+lpos*lDCB<br>if lpos ge ds&gt;&gt;DSS.nl resultis false<br>if dcb&gt;&gt;DCB.indentation ne 0 resultis false<br>if dcb&gt;&gt;DCB.width eq 0 resultis false<br>ds&gt;&gt;DSS.cdcb = dcb<br>ds&gt;&gt;DSS.bwrds = dcb&gt;&gt;DCB.width<br>SetBitPos(ds, ds&gt;&gt;DSS.bsofar)<br>resultis true<br>]<br><br>//----------------------------------------------------------------------------<br>and InvertLine(ds, lpos) = valof<br>//----------------------------------------------------------------------------<br>[<br>let dcb = ds&gt;&gt;DSS.fdcb+lpos*lDCB<br>let b = dcb&gt;&gt;DCB.background<br>dcb&gt;&gt;DCB.background = b+1<br>resultis b<br>]<br><br>//----------------------------------------------------------------------------<br>and Scroll(ds, char; numargs na) = valof<br>//----------------------------------------------------------------------------<br>[<br>if na ge 2 switchon char into<br>   [<br>   case $*N: endcase  // cr<br>   case $*T:</span><span class="tab" val="67"></span><span style="font: 10pt serif">// tab<br>      [<br>      let sp8 = CharWidth(ds, $*S)*8<br>      let lm=ds&gt;&gt;DSS.lmarg<br>      unless SetBitPos(ds, ((ds&gt;&gt;DSS.bsofar-lm)/sp8+1)*sp8+lm) then<br>         Puts(ds, $*S)<br>      resultis char<br>      ]<br>   case $*L: case 0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">// null, lf<br>      resultis char<br>   case -1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">// about to burp lines up one<br>   case -2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">// about to lose data off top of screen<br>      resultis true<br>   default:<br>      [<br>      test char ls 40b<br>         ifso [ Puts(ds, $&uarr;); Puts(ds, char+100b) ]<br>         ifnot<br>            [<br>            // If a character with width=0 causes Scroll to be called,<br>            // it can only be because the character doesn&rsquo;t exist in the font.<br>            let w = CharWidth(ds, char)<br>            let rpos = w+ds&gt;&gt;DSS.bsofar<br>            // Check inside machine code is only for whether<br>            // currentpos+max width will exceed bstop.<br>            // This check is more careful.<br>            if w ne 0 then test rpos gr ds&gt;&gt;DSS.rmarg<br>               ifso if (ds&gt;&gt;DSS.options&DSstopright) eq 0 endcase<br>               ifnot<br>                  [ <br>                  let ostop = ds&gt;&gt;DSS.bstop<br>                  ds&gt;&gt;DSS.bstop = rpos+20<br>                  Puts(ds, char)</span><span class="tab" val="67"></span><span style="font: 10pt serif">//always succeeds<br>                  ds&gt;&gt;DSS.bstop = ostop<br>                  ]<br>             ]<br>      resultis char<br>      ]<br>   ]<br>let scrolled = false<br>let cdcb, ldcb = ds&gt;&gt;DSS.cdcb, ds&gt;&gt;DSS.ldcb<br>test cdcb eq ldcb<br>   ifnot<br>      [<br>      unless Compact(ds) resultis char<br>      cdcb = cdcb&gt;&gt;DCB.next<br>      ds&gt;&gt;DSS.cdcb = cdcb<br>      ]<br>   ifso<br>      [<br>      let dcb = ds&gt;&gt;DSS.fdcb<br>      if dcb eq ds&gt;&gt;DSS.tdcb then<br>         [<br>         unless ScrollOK(ds) resultis char<br>         unless FreeBitMap(ds) goto one<br>         ]<br>      unless Compact(ds) resultis char<br>      // We are about to scroll. Do NOT call user scroll routine here to<br>      // tell him of it, because if he does anything with the stream,<br>      // the world will die, as the stream is temporarily in a bad state.<br>      scrolled = true<br>      while dcb ne ldcb do<br>         [<br>         MoveBlock(dcb+1, dcb+(lDCB+1), lDCB-1)  // assumes next in word 0<br>         dcb = dcb+lDCB<br>         ]<br>      ds&gt;&gt;DSS.tdcb = ds&gt;&gt;DSS.tdcb-lDCB<br>one:  cdcb&gt;&gt;DCB.indwidth = ds&gt;&gt;DSS.nwrds<br>      cdcb&gt;&gt;DCB.bitmap = ds&gt;&gt;DSS.fmp<br>      ]<br>test cdcb&gt;&gt;DCB.bitmap eq ds&gt;&gt;DSS.fmp<br>   ifso ClearMap(ds)<br>   ifnot ResetLine(ds)<br>if scrolled then (ds&gt;&gt;DSS.scroll)(ds, -1)<br>if char ne $*N then Puts(ds, char)<br>resultis char<br>]<br><br>//----------------------------------------------------------------------------<br>and Compact(ds) = valof<br>//----------------------------------------------------------------------------<br>[<br>let dcb = ds&gt;&gt;DSS.cdcb<br>let ht = dcb&gt;&gt;DCB.height*2<br>let onw = dcb&gt;&gt;DCB.width<br>let nw = ((ds&gt;&gt;DSS.options&DScompactright) ne 0? (ds&gt;&gt;DSS.bsofar+15) rshift 4, onw)<br>let old = dcb&gt;&gt;DCB.bitmap</span><span class="tab" val="67"></span><span style="font: 10pt serif">// = ds&gt;&gt;DSS.fmp<br>let d = 0<br>if (ds&gt;&gt;DSS.options&DScompactleft) ne 0 then<br>   [<br>   while d ne nw do<br>      [<br>      let p = old+ds&gt;&gt;DSS.blksz+d<br>      for i = 1 to ht do<br>         [<br>         p = p-onw<br>         if @p ne 0 then goto used<br>         ]<br>      d = d+1<br>      ]<br>   used: ]<br>// unless (nw eq onw) & (d eq 1) do<br>   nw, old = (nw-d+1)&(-2), old+d<br>let p = GetMapSpace(ds, nw*ht)<br>test p eq 0<br>   ifso</span><span class="tab" val="67"></span><span style="font: 10pt serif">dcb&gt;&gt;DCB.indwidth = 0 // not enough room<br>   ifnot test p eq -1<br>      ifso resultis false // don&rsquo;t scroll<br>      ifnot<br>         [<br>         let new = p<br>         if nw ne 0 then for i = 1 to ht do<br>            [<br>            MoveBlock(new, old, nw)<br>            old, new = old+onw, new+nw<br>            ]<br>         dcb&gt;&gt;DCB.width = nw<br>         dcb&gt;&gt;DCB.indentation = d<br>         ]<br>dcb&gt;&gt;DCB.bitmap = p<br>resultis true<br>]<br><br>//----------------------------------------------------------------------------<br>and GetMapSpace(ds, nw) = valof<br>//----------------------------------------------------------------------------<br>[<br>let wp = nil<br>let bda = ds&gt;&gt;DSS.bda<br>   [<br>   wp = ds&gt;&gt;DSS.mwp<br>   let rp = ds&gt;&gt;DSS.tdcb&gt;&gt;DCB.bitmap<br>   let fmp = ds&gt;&gt;DSS.fmp<br>   if rp eq fmp then wp = bda<br>   test wp-bda gr rp-bda  //Subtractions try to keep &lt; 15 bit nums<br>      ifso<br>         [<br>         if fmp-wp ge nw break  //u/b gr<br>         ds&gt;&gt;DSS.mwp = ds&gt;&gt;DSS.bda<br>         if rp eq ds&gt;&gt;DSS.bda then<br>            [<br>            unless ScrollOK(ds) resultis -1<br>            FreeBitMap(ds)<br>            ]<br>         ]<br>      ifnot<br>         [<br>         if rp-wp ge nw break  //u/b gr<br>         unless ScrollOK(ds) resultis -1<br>         unless FreeBitMap(ds) resultis 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// not enough room<br>         ]<br>   ] repeat<br>ds&gt;&gt;DSS.mwp = wp+nw<br>resultis wp<br>]<br><br>//----------------------------------------------------------------------------<br>and ScrollOK(ds) = valof<br>//----------------------------------------------------------------------------<br>[<br>if (ds&gt;&gt;DSS.options & DSstopbottom) ne 0 resultis false<br>resultis (ds&gt;&gt;DSS.scroll)(ds, -2)<br>]<br><br>//----------------------------------------------------------------------------<br>and FreeBitMap(ds) = valof<br>//----------------------------------------------------------------------------<br>[<br>let dcb = ds&gt;&gt;DSS.tdcb<br>if dcb&gt;&gt;DCB.bitmap eq ds&gt;&gt;DSS.fmp resultis false<br>ds&gt;&gt;DSS.tdcb = dcb +lDCB<br>dcb&gt;&gt;DCB.indwidth = 0<br>resultis true<br>]<br><br>//----------------------------------------------------------------------------<br>and EraseBits(ds, nBits, flag; numargs na) = valof<br>//----------------------------------------------------------------------------<br>[</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// replacement for OS EraseBits absent Alto bitblt<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// ignores third arg flag<br>let newPos = Max(ds&gt;&gt;DSS.bsofar+nBits, 0)<br>let bm = ds&gt;&gt;DSS.cdcb&gt;&gt;DCB.bitmap<br>let rasterwidth = ds&gt;&gt;DSS.cdcb&gt;&gt;DCB.width<br>let dlx = Max(0, ds&gt;&gt;DSS.bsofar + Min(nBits, 0))<br>let dw = newPos eq 0? ds&gt;&gt;DSS.bsofar,<br> newPos gr ds&gt;&gt;DSS.cdcb&gt;&gt;DCB.width*16?<br> ds&gt;&gt;DSS.cdcb&gt;&gt;DCB.width*16 - ds&gt;&gt;DSS.bsofar, Max(nBits, -nBits)<br>let dh = ds&gt;&gt;DSS.cdcb&gt;&gt;DCB.height*2<br>let masks = table [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">#000000; #100000; #140000; #160000;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">#170000; #174000; #176000; #177000;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">#177400; #177600; #177700; #177740;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">#177760; #177770; #177774; #177776<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>let lmask = @(masks + (dlx & 15))<br>let firstword = dlx rshift 4<br>let rmask = @(masks + ((dlx + dw) & 15)) xor -1<br>let nwords = ((dlx + dw) rshift 4) - firstword<br>if nwords eq 0<br>   then lmask = lmask % rmask<br>let base = bm+firstword<br>for i = 0 to dh-1<br>   do </span><span class="tab" val="67"></span><span style="font: 10pt serif">[<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let addr = base<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@addr = @addr & lmask<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if nwords<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">for j = 2 to nwords<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  do [ addr = addr+1; @addr = 0 ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">addr = addr+1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">@addr = @addr & rmask<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">base = base+rasterwidth<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>SetBitPos(ds, newPos)<br>resultis newPos<br>]<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
