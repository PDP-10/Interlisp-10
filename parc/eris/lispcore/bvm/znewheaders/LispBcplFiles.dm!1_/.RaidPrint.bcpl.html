<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;LispCore>BVM>ZNewHeaders>LispBcplFiles.dm!1>RaidPrint.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">// RaidPrint.bcpl. Raid printing routines for Lisp objects.<br>// Changed October 8, 1986 by van Melle -- added package printing<br>// Changed October 6, 1986 by van Melle -- added ONEDARRAY<br>// Changed May 21, 1984  3:44 PM by van Melle<br>// Changed November 16, 1982  4:39 PM by van Melle<br>// Changed March 8, 1982  11:38 PM by van Melle<br>// Changed February 2, 1982  6:29 PM by van Melle: listpage headers wrong<br>// Changed January 11, 1982  12:36 PM by Masinter: listpage headers wrong<br>// Changed December 30, 1981  10:50 PM by Bill van Melle<br>// Changed August 26, 1981 by Bill van Melle<br>// Allegro change August 4, 1981  4:27 PM by Beau Sheil<br>// Last change July 20, 1981  8:01 PM by Beau Sheil<br>// Last change May 9, 1981  12:29 AM by Beau Sheil<br>// Last change April 14, 1981  8:07 PM by Beau Sheil<br>// Tone change March 17, 1981  5:21 PM by Beau Sheil<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Raid.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "VMem.decl"<br><br>external [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures defined<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SpaceCheck; CRLF; Lprint; PrintName; ReadStrng; PrintPtr; Confirm<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wo; Wn; Wb; Type; PrintStr; PrintBytes<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics defined<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">uradix; uprintlevel; ulistlength; defaultPackage; packagesOn<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dsp; keys; @lvNIL; @lvVPtr; @VPtr0; @VPtr1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">typeDecoding; crMax; crCount<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rmargBitPos; sysFontCharWidth; stringLimit<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RaidReset; ReadKeys; ReadNum; Wc; Ws; FetchAtomComponent<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EqNIL; VP; UCase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@BGetBasePtr; @XGetBasePtr; @XGetBase32; IGetBase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@SGetBase; @XSetReadBR; @RRead; @BGetBase; @XGetBase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// OS procs<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GetLmarg; SetLmarg; GetBitPos; EraseBits; CharWidth<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Negate; Divide; Usc; Min; Gets; FlashScreen; Resets<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetScreenColor <br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>manifest maxdigits = 32<br><br>static [ uradix = 8; uprintlevel = 5; ulistlength = 8 <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">defaultPackage = 1</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// default is IL<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">scratchPkg</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// string for unknown packages</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">packagesOn = false<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>structure String: [ length byte; char&uarr;1,255 byte ]<br> <br><br>let Lprint(w, internal; numargs n) be<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// print lisp object w using current position as left margin.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// second arg is supplied on recursive call from PrintList,<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// to suppress margin adjustment<br>  [ let savedLM = GetLmarg(dsp)<br>    if n eq 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then SetLmarg(dsp, GetBitPos(dsp))<br>    let typ = Type(w)<br>    switchon typ into<br>      [ case ATOMTYPE:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintName(w&gt;&gt;AtomNumber)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case LISTTYPE:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintList(w, uprintlevel)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case SMALLTYPE:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintNum(w&gt;&gt;VA.vahi eq SMALLPOSspace ? 0, -1, w&gt;&gt;VA.valo, uradix)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case INTEGERTYPE:<br>             XGetBase32(w)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintNum(VPtr0, VPtr1, uradix)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case FLTPTTYPE:<br>             WsX("{FLOATP with bits: ")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     XGetBase32(w)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     PrintNum(VPtr0, VPtr1, 8)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// always octal<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     WsX("}")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br>        case STRINGPTRTYPE:<br>             PrintStr(w)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">case ARRAYPTRTYPE:<br>             PrintArray(w)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     endcase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">case ONEDARRAYTYPE:<br>             if PrintOneDArray(w) then endcase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">default:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">//print pointer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     [  let saved = vec 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">MoveAddr(saved, w)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// saves w for later test<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrintPtr(w!0, w!1, typ)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if typ ne 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [ WsX("-&gt;")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  XGetBase32(saved)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PrintPtr(VPtr0, VPtr1) ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     ]<br>      ]</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">//ends switchon<br>    if n eq 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then [ CRLF(); SetLmarg(dsp, savedLM) ]<br>  ]<br><br>and PrintArray(lvAPtr) be<br> [ XSetReadBR(lvAPtr)<br>   let w = RRead(offset Styp/16)<br>// Flags and type are stored in the same word of the descriptor<br>   WsX("{["); WcX(w&lt;&lt;Sorig ? $1, $0); WcX($-)<br>   Wn(RRead(offset Slength/16) - (w&lt;&lt;Sorig ? 0, 1), uradix); Ws("] ")<br>   if w&lt;&lt;Sro then WsX("read only, ")<br>   if w&lt;&lt;Salgn then WsX("aligned, ")<br>   WsX(selecton w&lt;&lt;Styp into<br>         [ case 0:  "BYTE"<br>           case 1:  "POS16"<br>           case 2:  "FIXP"<br>           case 3:  "HASH"<br>           case 4:  "CCODE"<br>           case 5:  "BITMAP"<br>           case 6:  "POINTER"<br>           case 11: "DOUBLE POINTER"<br>           default: valof [ WsX("(type ="); Wn(w&lt;&lt;Styp, uradix);<br>                            resultis ") INVALID" ] ] )<br>   WsX(" array @ ")<br>   w = RRead(offset Soffst/16)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// save offset lest lvAPtr be lvVPtr<br>   XGetBasePtr(lvAPtr)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// knows that base ptr is in first word!!<br>   PrintPtr(VPtr0, VPtr1)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// prints base address as a ptr<br>   WsX(" offset "); Wn(w, 8)<br>   WcX($})<br> ]<br> <br>and PrintChars(charPtr, offst, n, limit; numargs na) be<br> [ let w = nil<br>   let hibyteflg = (offst & 1) eq 0<br>   XSetReadBR(charPtr)<br>   let last = n<br>   if na gr 3 & limit gr 0 & n gr limit<br>      then last = limit<br>   for i = offst to offst+last-1<br>     do</span><span class="tab" val="67"></span><span style="font: 10pt serif">[<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">w = RRead(i rshift 1)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let b = hibyteflg ? w&lt;&lt;HiByte, w&lt;&lt;LoByte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">test (b ge $*S) & (b ls #177)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifso Wc(b)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> ifnot [ Wc($[); Wb(b); Wc($]) ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">hibyteflg = not hibyteflg<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>   if last ne n then Ws(" &")</span><span class="tab" val="67"></span><span style="font: 10pt serif">// indicate tail suppression<br> ]<br> <br>and PrintList(w, depth) be<br>  [<br>   if depth le 0<br>      then [ WcX($&); return ]<br>   compileif CDRCODING then <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">[ if w&gt;&gt;VA.wordN eq 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     then [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// not really a cons<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">WsX("{list page header @ ")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    </span><span class="tab" val="67"></span><span style="font: 10pt serif">PrintPtr (w&gt;&gt;VA.vahi, w&gt;&gt;VA.valo)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">WcX($})<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">return<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>   if (w&gt;&gt;VA.valo & 1) eq 1<br>      then [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// odd pointer??<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    WsX("{bogus cons @ ")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    PrintPtr (w&gt;&gt;VA.vahi, w&gt;&gt;VA.valo)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    WcX($})<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    return<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>   WcX($()<br>   let len = ulistlength<br>   [ test len le 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso  [ WsX("--")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">break ]<br>      ifnot test Type(w) eq LISTTYPE<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso  [ let saved = vec 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">MoveAddr(saved, w)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// saves w for later cdr<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">let car = CAR(w)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">test Type(car) eq LISTTYPE<br>                   ifso  PrintList(car, depth-1)<br>                   ifnot Lprint(car, true)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">w = CDR(saved)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">len=len-1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">test EqNIL(w)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso break<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifnot if SpaceCheck(1) then Wc($*S)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot [ WsX(". ")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Lprint(w, true)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">break<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      ]<br>   ] repeat<br>   WcX($))<br>  ]<br><br>and CAR(lvX) = valof</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// lvX is known to be LISTP<br>  [<br>    XGetBase32(lvX)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// 32 bits into VPtr0 and 1<br>    compileif CDRCODING then [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless lvVPtr&gt;&gt;ConsCell.Qfield</span><span class="tab" val="67"></span><span style="font: 10pt serif">// indirect cell. Take 1 level of<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    do XGetBase32(lvVPtr)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// indirection, to the correct cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lvVPtr&gt;&gt;ConsCell.Qfield = 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Turn off the CDR bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>    resultis lvVPtr<br>  ]<br><br>and CDR(lvX) = valof</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// lvX is known to be LISTP # lvVPtr <br>  [<br>    compiletest CDRCODING<br>      ifso [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XGetBase32(lvX)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// 32 bits into VPPtr0 and 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless lvVPtr&gt;&gt;ConsCell.Qfield</span><span class="tab" val="67"></span><span style="font: 10pt serif">// indirect cell. Save its address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   do [ MoveAddr(lvX, lvVPtr)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// for later offset, then indirect<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">XGetBase32(lvVPtr)</span><span class="tab" val="67"></span><span style="font: 10pt serif">]</span><span class="tab" val="67"></span><span style="font: 10pt serif">// to it<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let D = lvVPtr&gt;&gt;ConsCell.dfield<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless D then resultis lvNIL<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let F = lvVPtr&gt;&gt;ConsCell.ibit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MoveAddr(lvVPtr, lvX)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// address is in same page as lvX<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lvVPtr&gt;&gt;VA.wordN = D lshift 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless F do XGetBasePtr(lvVPtr)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// indirection for CDR<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>      ifnot [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MoveAddr(lvVPtr, lvX)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// address is in same page as lvX<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lvVPtr&gt;&gt;VA.valo = lvVPtr&gt;&gt;VA.valo + 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XGetBasePtr(lvVPtr)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>    resultis lvVPtr<br>  ]<br><br>and PrintName(atomnum) be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// print pname of atom<br> [ FetchAtomComponent(PNPspace, atomnum)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// pname ptr into VPtr<br>   let nchars = XGetBase(lvVPtr)&lt;&lt;HiByte<br>   let prefix = valof [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">test packagesOn<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot resultis 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifso</span><span class="tab" val="67"></span><span style="font: 10pt serif">[<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">let pkgno = BGetBase(PNPspace+(atomnum rshift 15),<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">atomnum lshift 1)&lt;&lt;HiByte<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">resultis (pkgno eq defaultPackage)? 0,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> selecton pkgno into [<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 0: "#:"</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// uninterned<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 1: "IL:"<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 2: "CL:"<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 3: "XCL:"<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 4: "SI:"<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 5: "USER:"<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 6: ":"</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// keyword<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   default: valof [ scratchPkg = "0:"<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">    scratchPkg&gt;&gt;String.char&uarr;1 = pkgno + $0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">    resultis scratchPkg ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]]<br>   SpaceCheck (nchars + prefix? 0, prefix&gt;&gt;String.length)<br>   if prefix<br>      then Ws(prefix)<br>   PrintChars(lvVPtr, 1, nchars, stringLimit)<br> ]<br><br>and PrintNum(A,B,radx) be<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">//  A and B are hi and lo parts of the same number.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// This procedure depends on them being put into AC0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// and AC1 for double word Divide. Hence, 2 args.<br>  [ <br>    let doQ = (radx eq 8) & (A eq 0? (B gr 7 % B ls 0),<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> A eq -1? (B gr 0 % B ls -7), true)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// will add "Q" when radix 8 and |number| &gt; 7<br>    let L, P = vec maxdigits, maxdigits<br>    let sgn = 0<br>    if A ls 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then [ sgn = 1; Negate(lv A) ]<br>    [ L!P = Divide(lv A, radx)+$0<br>      P = P-1<br>    ] repeatwhile (A ne 0) % (B ne 0)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// fill L backwards<br>    SpaceCheck (maxdigits-P+sgn+(doQ? 1, 0))<br>    if sgn then Wc($-)<br>    while P ls maxdigits do [ P = P+1; Wc(L!P) ]<br>    if doQ<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then Wc($Q)<br>  ]<br><br>and PrintPtr(hi, lo, typ; numargs na) be</span><span class="tab" val="67"></span><span style="font: 10pt serif">// print ptr as {hi,lo}<br> [ let name = (na gr 2) & typ ? TypeName (typ), 0<br>   if name</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// pointer has an interesting type name<br>      then [ FetchAtomComponent(PNPspace, name)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// pname ptr into VPtr (see PrintName)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     name = XGetBase(lvVPtr)&lt;&lt;HiByte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>   SpaceCheck (11+(name ? name+2, 0))<br>   Wc(${)<br>   if name then [ PrintChars (lvVPtr, 1, name, stringLimit); Ws(": ") ]<br>   Wo(hi, true); Wc($,)<br>   Wo(lo, true); Wc($})<br> ]<br><br>and PrintStr(lvstrPtr, noquotes; numargs na) be<br> [ XSetReadBR(lvstrPtr)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// point base at string descriptor<br>   let nchars = RRead(offset Slength/16)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// string length<br>   SpaceCheck (nchars+2)<br>   let quoted = (na eq 1) % (not noquotes)<br>   if quoted then Wc ($")<br>   PrintChars(XGetBasePtr(lvstrPtr),</span><span class="tab" val="67"></span><span style="font: 10pt serif">// assumes base addr in first 2 words<br>              RRead(offset Soffst/16),</span><span class="tab" val="67"></span><span style="font: 10pt serif">// offset of first byte<br>              nchars, quoted? stringLimit, -1)<br>   if quoted then Wc ($")<br> ]<br><br>and PrintOneDArray(lvstrPtr, noquotes; numargs na) = valof<br> [ XSetReadBR(lvstrPtr)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// point base at array descriptor<br>   test RRead(offset ODFlagWord/16)&lt;&lt;ODStringP<br>      ifso [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   let nchars = RRead(offset ODFillPointer/16)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// string length<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   SpaceCheck (nchars+2)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   let quoted = (na eq 1) % (not noquotes)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   if quoted then Wc ($")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   PrintChars(XGetBasePtr(lvstrPtr),</span><span class="tab" val="67"></span><span style="font: 10pt serif">// assumes base in first cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">              RRead(offset ODOffset/16),  // offset of first byte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">              nchars, quoted? stringLimit, -1)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   if quoted then Wc ($")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   resultis true<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>    ifnot resultis false<br> ]<br><br>and Wo(n, nopad; numargs na) be<br>  [ let pad = (na ls 2) % (nopad eq 0)<br>    for i = 15 to 3 by -3 do<br>      [ let d = n rshift i<br>        test d ne 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso Wc((d&7)+$0)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifnot if pad then Wc($*S)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// pad number to fixed width (6)<br>      ]<br>    Wc((n&7)+$0)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// ensures at least one digit<br>  ]<br><br>and Wn(n, rad) be PrintNum(0, n, rad)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// n is assumed +ve; rad is radix<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and Wb(n) be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Write a byte<br>  [ Wc($0 + ((n rshift 6) & 3))<br>    Wc($0 + ((n rshift 3) & 7))<br>    Wc($0 + (n & 7))<br>  ]<br><br>and WcX (char) be<br>  [ SpaceCheck(1)<br>    Wc(char)<br>  ]<br><br>and WsX (str) be<br>  [ SpaceCheck (str&gt;&gt;String.length)<br>    Ws (str)<br>  ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and MoveAddr(tgt, src) = valof<br>  [ tgt!0 = src!0<br>    tgt!1 = src!1<br>    resultis tgt<br>  ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and Type(ptr) = <br>    BGetBase(MDSTYPEspace, MDSTYPEbase + VP(ptr) rshift 1)&lt;&lt;LoByte<br><br>and TypeName (type) =</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// returns an atom number<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">typeDecoding? BGetBase(DTDspace, DTDbase + (type lshift 4)), 0</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif"><br>and ReadStrng(str, maxlen, inited, noecho; numargs na) = valof<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Read string (up to space or cr) into str, return 0 if DEL typed<br> [ if na ls 4 then noecho = false<br>   if na ls 3 then inited = false<br>   if na ls 2 then maxlen = 99<br>   if inited & (not noecho)<br>     then Ws (str)<br>   let index = inited ? str&gt;&gt;String.length , 0<br>   [ let ch=Gets(keys)<br>     if ch eq DEL then resultis 0<br>     test (ch eq 1) % (ch eq #10)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// &uarr;A or BS<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso test index gr 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso  [ unless noecho <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  do EraseBits(dsp, -CharWidth(dsp, str&gt;&gt;String.char&uarr;index))<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">index = index - 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot FlashScreen()<br>      ifnot test ch eq $*s<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso  [ if index eq 0 then loop // flush leading space<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless noecho do Wc(ch)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">break ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot [<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if ch eq $*N<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [ Wc (ch); break ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if inited % (ch eq #27) % (ch eq #21)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// &uarr;W or &uarr;Q<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// overwriting/erasing init string<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless noecho<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   do [ let width = 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">for i = 1 to index<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> </span><span class="tab" val="67"></span><span style="font: 10pt serif">  do width = width + CharWidth(dsp, str&gt;&gt;String.char&uarr;i)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">EraseBits (dsp, -width)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">index = 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">inited = false<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if (ch eq #27) % (ch eq #21)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then loop<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless noecho do Wc(ch)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if index ge maxlen<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [ FlashScreen(); loop ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">index = index+1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">str&gt;&gt;String.char&uarr;index = ch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>     ] repeat<br>   unless (index&1) ne 0<br>      do str&gt;&gt;String.char&uarr;(index+1) = 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// null last byte<br>   str&gt;&gt;String.length = index<br>   resultis str<br> ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and Confirm(s ;numargs n) = valof<br>  [ Resets(keys)<br>    if n gr 0 then Ws(s)<br>    Ws(" [Confirm] ")<br>    let val = (Gets(keys) eq $*N)<br>    unless val do Ws("XXX")<br>    Wc($*N)<br>    resultis val<br>  ]<br><br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and CRLF() be<br>  [ <br>    test crCount gr crMax<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso  [ crCount = 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetScreenColor(true)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// flash screen<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">let c = Gets(keys)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// wait for keystroke<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetScreenColor(false)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// restore screen<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if c eq DEL then RaidReset()<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot crCount = crCount + 1<br>    Wc($*N)<br>  ]<br> <br>and SpaceCheck (n) = valof</span><span class="tab" val="67"></span><span style="font: 10pt serif">// see if there is room to print n chars<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// if so, return true; else do CRLF() and return false<br> [<br>   test (GetBitPos(dsp) + (n*sysFontCharWidth) gr rmargBitPos) &<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">(n*sysFontCharWidth ls rmargBitPos-GetLmarg(dsp))<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso [ CRLF(); resultis false ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot resultis true<br> ] <br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and PrintBytes(asCharP) be<br>  [ <br>    let hi = ReadNum(8); let lo = ReadNum(8)<br>    Ws(" showing "); let N = ReadNum(8)<br>    Wn(N, 8); Ws(" words, as bytes, starting at ")<br>    PrintPtr(hi, lo); CRLF()<br>    let end = lo+N-1<br>    for i = 1 to 7 do Wc($*S)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// print labeling line<br>    for i = 0 to 7 do [ Ws("   "); Wo(i) ]<br>    for i = (lo & #177770) to end<br>     do</span><span class="tab" val="67"></span><span style="font: 10pt serif">[<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if (i&7) eq 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [ CRLF(); Wo(i); Ws(": ") ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wc($*S)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">test i ls lo<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso Ws ("        ")</span><span class="tab" val="67"></span><span style="font: 10pt serif">// don&rsquo;t print data yet<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot</span><span class="tab" val="67"></span><span style="font: 10pt serif">[<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">let w = BGetBase(hi, i)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wc($*S); Wbc(w&lt;&lt;HiByte, asCharP)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wc($*S); Wbc(w&lt;&lt;LoByte, asCharP)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>      ]<br>    CRLF()<br>  ]<br><br>and Wbc (n, asCharP) be<br>  [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// write byte or character<br>  test asCharP & (n ge $*S) & (n ls #177)<br>    ifso [ Wc($*S); Wc(n); Wc($*S) ]<br>   ifnot Wb(n)<br>  ]<br><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
