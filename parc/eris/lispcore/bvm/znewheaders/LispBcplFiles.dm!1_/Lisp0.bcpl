// Lisp0.bcpl  Inital entry point is StartLisp// Last change December 16, 1982  10:34 PM by Bill van Melle// Last change October 6, 1982  6:12 PM by Bill van Melle// Last change July 20, 1982  10:42 PM by Bill van Melle// Last change March 23, 1982  9:30 PM by Bill van Melle// Last change September 27, 1981  10:56 PM by Bill van Melle// Tone change March 17, 1981  4:56 PM by Beau Sheil// Last change February 24, 1981  1:55 PM by Beau Sheil// Phrase change November 24, 1980  12:13 PM by Beau Sheil	get "LispBcpl.decl"	get "SysDefs.D"external [	SavedUFP; SavedSCP; @ContextQ; TopLevelFrame	@lvNIL; @lvKT; @lvVPtr; @VPtr0; @VPtr1; @RMSK	// useful values	BcplDisplay; MkSmallPos; RemapMemory		// procedures used	Iresume; RAIDCode; CloseStats; Serial	AllocVec; MainInit; ShortStack		// from maininit.bcpl	AllocPtr				// allocater static	StartPup				// Lisp Pup	Enqueue; Max; MyFrame; Junta; Block	// OS procs	InitializeContext; CallContextList	lvUserFinishProc	// Statics used	lvAbortFlag	@SubrArgsOffset; SubrArgsVector; @uPCTraceAddr	insideRaid; callRaid				// statics defined	LispStackLength	PupZoneLength	LispStackStart	PupZoneStart	lispStarted	LispFinishProc; LispCleanup; SysErr		// procedures defined	]static [	@TopLevelFrame; @ContextQ; SubrArgsVector	@lvNIL; @lvKT; @lvVPtr; @VPtr0; @VPtr1; @RMSK = #377	lispStarted = false	LispStackLength	PupZoneLength	LispStackStart	PupZoneStart	]manifest ScreenScanLines = 808	// vertical screen size let StartLisp() be Junta(levStreams,InitLisp)		// main entryand InitLisp() be   [// EventualEndOfStack is an estimate of how much stack space we will need// after the call to MainInit.  MainInit assigns the rest (including its// own stack) to the display, which we turn on.   [ let EventualEndOfStack=ShortStack(256)     MainInit(EventualEndOfStack)     @StackEnd=EventualEndOfStack		// sets end of stack   ]   BcplDisplay(ScreenScanLines-15)	// give Bcpl dsp all the screen space			// save a few lines to protect against overscan   StartPup(PupZoneStart, PupZoneLength)			// Start the Pup world if there is a 3mb ethernet   // Init the TopLevel context and put it on ContextQ   Enqueue(ContextQ,	InitializeContext(LispStackStart,LispStackLength,TopLevel))   CallContextList(ContextQ!0) repeat		// Start the contexts running   ]and TopLevel() be   [   TopLevelFrame = MyFrame()   lispStarted = true   insideRaid = false   @lvAbortFlag = 1				// disable shift-swat   if callRaid      then RAIDCode("Starting Lisp", lvNIL)   SubrArgsOffset = (SubrArgsVector-1)-TopLevelFrame  // -1 adjusts indx orig   Iresume(lvKT)				// never returns; T=>startup   ]and SysErr(p1, eCode) be    RAIDCode(selecton eCode into               [ case 1101: "Hard disk error"                 case 1102: "Disk full"                 case 1103:  case 1104: "Bad disk command"                 default:   "SysErr" ],             MkSmallPos(eCode))and LispCleanup() be   [//   if (SavedSCP+1) then @lvSwatContextProc = SavedSCP	// restore Swat proc   if (SavedUFP+1) then @lvUserFinishProc = SavedUFP	// restore finish proc//   if uPCTraceAddr then uPCTracing(false)	// turn off any uPc logging   CloseStats()				// turn off stats   BcplDisplay(0)			// turn off any displays   RemapMemory()			// restore map   ]and LispFinishProc() be   [   LispCleanup()   finish   ]