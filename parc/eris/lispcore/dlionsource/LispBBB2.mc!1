{File name LispBBB2.mcDescription: BitBlt op-codeAuthor: don charnleyLast edited: October 8, 1980  6:35 PMCreated: October 1983}{*****************************************************************************	BITBLT*****************************************************************************}{OLD: {CAUTION: there is a delicate sharing of .u+D by uTOS and UWidth; during faults UWidth is stored in TOS; at restart {BBpart} it is tested for nonZero and restorted}}{.u+2 thru .u+C must be preserved accross faults; in particular no bitBlt by fault handler}{TOS=0 if virgin BB call;  else suspended with saved state on stack under TOS}{2 args one usually 0 in TOS; S points to ptr to BBtable}	MAR _ [rhS, S+0],	c1, at[BBEntry];	{UWidth}Ybus _ TOS, NZeroBr,	c2;	TOS _ MD, BRANCH[$, BBpart],	c3;	MAR _ S _ [rhS, S - 1],	c1;	S_S-1, CANCELBR[$, 2],	c2;	TOSH _ MD,	c3;{S points to some stack entry that has nothing to do with BB}{BBInit vs BBInit1 differ on advacing PC}	PC _ PC + 1{PC16}{1}{%?}{saveRegs does PC_PC-1},	c1;	stackP _ 2,	c2;	,	c3;	,	c1;	STK{UBitBltArg} _ TOS, pop,	c2;	rhMDS _ TOSH LRot0, GOTO[@BITBLT],	c3;{@BITBLT returns directly to IBDispOnly; saves and restores L, G, PC}BBpart:	{Q _ 166'b, GOTO[sink2],	c1;}	,	c1;	PC _ PC + 1{PC16}{1}{%?}{undone by saveRegs},	c2;	stackP _ 0C{vestigial}, {GOTO[@BITBLT],}	c3;{restore 12 uRegs from memory stack: u2 thru u0D } 	stackP _ 0D,	c1;	Rx _ 0C,	c2;BBLp:	Noop,	c3;{Stack pointer points to full odd word } 	MAR _ S _ [rhS, S +0], 	c1;	S _ S - 2,	c2;	TT _ MD,	c3;	Rx _ Rx - 1, ZeroBr,	c1;	STK _ TT, pop, BRANCH[BBLp, BBLpD],	c2;BBLpD:	stackP _ 0C{not vestigial}, GOTO[@BITBLT],	c3;{@BITBLT returns  to IBDispOnly normally or to SaveRegs if fault {or interrupt}}{interupts are temporarily disabled in BB}{S points to some stack entry that has nothing to do with BB}{if faulting save 12 uRegs to memory stack: u2 thru u0D } {then set TOSH,TOS to nonzero to indicate BB suspended (PFault saves TOS)} {at PFault TOS is nonzero and under that is saved regs } SaveRegs: {come here on pageFault}{{state held in stack (faults can't bitblt)}}	rhTT _ uFaultParm1, 	c2;	TT _ uFaultParm0,	c3;{Stack pointer points to full odd word } {save 12 uRegs from memory stack: u2 thru u0D } 	stackP _ 02,	c1;	Rx _ 0C,	c2;BBsLp:	S{even empty} _ S{odd full} + 1,	c3;	MAR _ S _ [rhS, S +0], 	c1;	MDR _ smallpl,	c2;	S _ S + 1,	c3;	MAR _ S _ [rhS, S +0], 	c1;	MDR _ STK, push,	c2;	Noop,	c3;	Rx _ Rx - 1, ZeroBr,	c1;	BRANCH[BBsLp, BBsLpD],	c2;BBsLpD:	TOSH _ smallpl, L1 _ L1.NoFixes,	c3;	TOS _ 1, L0Disp,	c1;	stackP _ 0, DISP4[bbabn],	c2;	,	c3, at[restore.pf, 10, bbabn];	Bank _ EmuBank,	c1;	,	c2;	CROSS[BBFault],	c3;	uWP _ 0,	c3, at[restore.int, 10, bbabn];	Bank _ EmuBank,	c1;	,	c2;	CROSS[EmuInt],	c3;{S points to some stack entry that has nothing to do with BB}{Normal BB returns undefined : set TOSH, TOS to any valid object (use smallpl)}{@BITBLT returns directly to IBDispOnly; saves and restores L{PV}, G{S}, PC}{stackP was set to zero by BB as we return here; any thing below .u+D is ok}BBThru:	Bank _ EmuBank,	c1;	,	c2;	CROSS[BBExit],	c3;{*********************************************	MaskTbl  SUBROUTINE	1 cycle*********************************************}{	first cycle = c* , one cycle longThis subroutine generates a right justified mask. of n onesRETURNS THRU MaskRet}MaskTblB2:	TT _ 1, RET[MaskRet],	c*, at[0,10,MaskTbl];	TT _ 3, RET[MaskRet],	c*, at[1,10,MaskTbl];	TT _ 7, RET[MaskRet],	c*, at[2,10,MaskTbl];	TT _ 0F, RET[MaskRet],	c*, at[3,10,MaskTbl];	TT _ 1F, RET[MaskRet],	c*, at[4,10,MaskTbl];	TT _ 3F, RET[MaskRet],	c*, at[5,10,MaskTbl];	TT _ 7F, RET[MaskRet],	c*, at[6,10,MaskTbl];	TT _ 0FF, RET[MaskRet],	c*, at[7,10,MaskTbl];	TT _ LShift1 0FF, SE_1, RET[MaskRet] {TT _ 1FF},	c*, at[8,10,MaskTbl];	TT _ RShift1 u7FF, RET[MaskRet] {TT _ 3FF},	c*, at[9,10,MaskTbl];	TT _ u7FF, RET[MaskRet] {TT _ 7FF},	c*, at[0A,10,MaskTbl];	TT _ RShift1 u1FFF, RET[MaskRet] {TT _ FFF},	c*, at[0B,10,MaskTbl];	TT _ u1FFF, RET[MaskRet] {TT _ 1FFF},	c*, at[0C,10,MaskTbl];	TT _ uTT3FFF, RET[MaskRet] {TT _ 3FFF},	c*, at[0D,10,MaskTbl];	TT _ RShift1 (~TT xor TT), RET[MaskRet] {TT _ 7FFF},	c*, at[0E,10,MaskTbl];	TT _ ~TT xor TT, RET[MaskRet] {TT _ FFFF},	c*, at[0F,10,MaskTbl];	{ E N D }