<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>NewLFAB2.mc!1</title>
  </head>
  <body>
    <pre>
{File name NewLFAB2.mcDescription:  DandeLion InterLisp Emulator LispFloatArrayAuthor: CharnleyLast modified: Charnley                11-Jul-84 15:42:40Created:   8-Jun-84 10:04:55}{- - - - - - - - - - - - - - - - - - - - - - - - - -372      FLOATARRAY1	called with      Source  Dest  Count	all operations performed for n = 0 to Count-1	  0  EXP   dest[n] &larr; Exp[Source[n]] {3 clicks per}	  1  MAG  Dest[i] &larr; #Source[2*n]&uarr;2 + #Source[(2*n)+1]&uarr;2 {10 clicks per}{pipe}	  2  FLOAT  Dest[i] &larr; Float[source[n]] {5 clicks per}	  3  COMPLEX  #Dest[2 * n] &larr; Source[n], #Dest[(2 * n) + 1] &larr; 0.0 {6 clicks per}	 return[Count = 0]		# means quadword alligned {actually, a complex array}		Source means 32 bit quantity, source means 16 bit quantity		Dest means 32 bit quantity, dest means 16 bit quantity 373      FLOATARRAY2	called with      Source2  Source1  Dest  Count	all operations performed for n = 0 to Count-1	  0  TIMES   Dest[n] &larr; Source1[n] * Source2[n] {7 clicks per}	  1  PERM  dest[n] &larr; source2[source1[n] ] {6 clicks per}	  2  PLUS   Dest[n] &larr; Source1[n] + Source2[n] {7 clicks per}	  3  DIFFERENCE   Dest[n] &larr; Source1[n] - Source2[n] {7 clicks per}	 return[Count = 0]	  4  MAGIC    {16 clicks per}  all numbers below are floating point		D(n.0)  &larr;  S1(n.0) + S2(-n.0)  {alpha + beta}		D(n.1)  &larr;  S1(n.1) - S2(-n.1)    {gamma - delta}		D(n.2)  &larr;  S1(n.1) + S2(-n.1)  {gamma + delta}		D(n.3)  &larr;  S1(n.0) - S2(-n.0)    {alpha - beta}- - - - - - - - - - - - - - - - - - - - - - - - - -}@NOLABEL:{@FLOATARRAY1:	{opcode[372'b],}	Bank &larr; FAOPBank, L1 &larr; 4{L1.LFA1prep},,	c1;	uTOS &larr; TOS,	c2;	uTOSH &larr; TOSH, CROSS[FOP1],	c3;}	at[FOP1],	Xbus &larr; ibNA, XDisp,	c1;	DISP4[FOP1Disp],	c2;		L2 &larr; 08,			c3, at[0, 10, FOP1Disp];{EXP}		GOTO[FLOATARRAYPREP1],		c1;		L2 &larr; 0B,			c3, at[3, 10, FOP1Disp];{COMPLEX}		GOTO[FLOATARRAYPREP1],		c1;	L2 &larr; 0A,			c3, at[2, 10, FOP1Disp];{FLOAT}		GOTO[FLOATARRAYPREP1],		c1;	L2 &larr; 09,			c3, at[1, 10, FOP1Disp];{MAG}		GOTO[FLOATARRAYPREP1],		c1;{@FLOATARRAY2:	opcode[373'b],	Bank &larr; FAOPBank, L1 &larr; 3{L1.LFA2prep},	c1;	uTOS &larr; TOS,	c2;	uTOSH &larr; TOSH, CROSS[FOP2],	c3;}	at[FOP2],	Xbus &larr; ibNA, XDisp,	c1;	DISP4[FOP2Disp], L2 &larr; 0,	c2;	GOTO[FLOATARRAYPREP],	c3, at[L2.perm, 10, FOP2Disp];{PERM}	GOTO[FLOATARRAYPREP],	c3, at[L2.Xplus, 10, FOP2Disp];{PLUS}	GOTO[FLOATARRAYPREP],	c3, at[L2.minus, 10, FOP2Disp];{MINUS}	GOTO[FLOATARRAYPREP],	c3, at[L2.Xtimes, 10, FOP2Disp];{TIMES}FLOATufn:	GOTO[ufnX22],	c1;FLOATARRAYPREP:	,	c1;	{save regs}FLOATARRAYPREP1:	CALL[LFASaveRegsHere],	c2;LFASaveRegsHere:	uS &larr; S, S &larr; rhS,	c*;{c3}	urhS &larr; S,	c*;{c1}	uPVx &larr; PV, PV &larr; rhPV,	c*;{c2}	urhPV &larr; PV,	c*;{c3}	uPC &larr; PC,	c*;{c1}	S &larr; uS, L1Disp,	c2;	S &larr; S - 4, DISP4[LFASaveRegsRet]	c3;	{fetch second source addr}	MAR &larr; [rhS, S + 0],	c1, at[L1.LFA2prep, 10, LFASaveRegsRet];	,	c2;	Stemp{S2Lo} &larr; MD,	c3;	MAR &larr; [rhS, S - 1],	c1;	uS2Lo &larr; Stemp, CANCELBR[$ ,2]	c2;	Stemp{S2Hi} &larr; MD,	c3;	{fetch first source addr}	MAR &larr; S &larr; [rhS, S + 2],	c1, at[L1.LFA1prep, 10, LFASaveRegsRet];fixSAret:	uS2Hi &larr; Stemp, BRANCH[$, fixSA, 1],	c2;	Stemp{S1Lo} &larr; MD,	c3;	MAR &larr; [rhS, S - 1],	c1;	uS1Lo{S1Lo} &larr; Stemp, CANCELBR[$, 2],	c2;	Stemp{S1Hi} &larr; MD,	c3;	{fetch dest addr}	MAR &larr; S &larr; [rhS, S + 2],	c1;fixSBret:	uS1Hi{S1Hi} &larr; Stemp, BRANCH[$, fixSB, 1],	c2;	Stemp{DLo} &larr; MD,	c3;	MAR &larr; [rhS, S - 1],	c1;	uDLo{DLo} &larr; Stemp, CANCELBR[$, 2],	c2;	Stemp{DHi} &larr; MD,	c3;	uDHi{DHi} &larr; Stemp,	c1;	L2Disp, FloatNop,	c2;{clear any pending floating unloads}	DISP4[LFAop], FloatNop,	c3;fixSA:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[fixSAret],	c1;fixSB:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[fixSBret],	c1;{	TIMES}	at[L2.Xtimes, 10, LFAop],{FOP2 = TIMES}	GOTO[LFA2genl],	c1;	at[L2.Xplus, 10, LFAop],{FOP2 = PLUS}	GOTO[LFA2genl],	c1;	at[L2.minus, 10, LFAop],{FOP2 = MINUS}	GOTO[LFA2genl],	c1;LFA2genl:	D &larr; 0{cause immediate remap}, L0 &larr; L0.S1init2,	c2;	{map S1}	{S1 even, init at Kount}	Zimph &larr; LShift1 (Kount - 1), SE &larr; 0, CALL[LFAremapS1],	c3;	at[L0.S1init2, 10, LFAremapS1ret],	FloatMode.RN.AI.FAST, FloatFLOW, 	c2;	FloatAB{S1Hi} &larr; MD,	c3;	MAR &larr; [rhS1, S1 + 1], 	c1;	S2 &larr; 0{cause immediate remap}, CANCELBR[$, 2], L2Disp,	c2;	FloatAB{S1Lo} &larr; MD, DISP2[TIMESop],	c3;{TIMESloop:}	at[L2.Xtimes, 4, TIMESop],	MAR &larr; S2 &larr; [rhS2, S2 - Q{2}], L0 &larr; L0.S2timeslooptimes, LOOPHOLE[pci],	c1;	BRANCH[TIMEStimesS2Remap, $, 1],	c2;TIMEStimesS2cont:	FloatA{S2Hi} &larr; MD, FLTimes.A.B, GOTO[TIMESnext],	c3;	at[L2.Xplus, 4, TIMESop],	MAR &larr; S2 &larr; [rhS2, S2 - Q{2}], L0 &larr; L0.S2timesloopplus, LOOPHOLE[pci],	c1;	BRANCH[TIMESplusS2Remap, $, 1],	c2;TIMESplusS2cont:	FloatA{S2Hi} &larr; MD, FLPlus, GOTO[TIMESnext],	c3;	at[L2.minus, 4, TIMESop],	MAR &larr; S2 &larr; [rhS2, S2 - Q{2}], L0 &larr; L0.S2timesloopminus, LOOPHOLE[pci],	c1;	BRANCH[TIMESminusS2Remap, $, 1],	c2;TIMESminusS2cont:	FloatA{S2Hi} &larr; MD, FLAMinusB, GOTO[TIMESnext],	c3;TIMESnext:	MAR &larr; [rhS2, S2 + 1],	c1;	CANCELBR[$, 2],  L0 &larr; L0.S1timesloop,	c2;	FloatA{S2Lo} &larr; MD,	c3;	MAR &larr; S1 &larr; [rhS1, S1 - Q{2}], FloatStartFlow, LOOPHOLE[pci],	c1;	BRANCH[TIMESS1Remap, $, 1], 	c2;TIMESS1cont:	Stemp{S1Hi} &larr; MD, L2Disp,	c3;	MAR &larr; [rhS1, S1 + 1], DISP2[TIMESunload],	c1;	uStemp{S1Hi} &larr; Stemp, CANCELBR[$, 2],	c2, at[L2.Xtimes, 4, TIMESunload];	Stemp{S1Lo} &larr; MD, FloatUnloadP, Float.M, L0 &larr; L0.Dtimesloop,	c3;	uXdisp &larr; Stemp{S1Lo},	c1;	,	c2;	FloatUnloadP, Float.L, GOTO[BOTHnext],	c3;	uStemp{S1Hi} &larr; Stemp, CANCELBR[TIMESpluscomm, 2],	c2, at[L2.minus, 4, TIMESunload];	uStemp{S1Hi} &larr; Stemp, CANCELBR[TIMESpluscomm, 2],	c2, at[L2.Xplus, 4, TIMESunload];TIMESpluscomm:	Stemp{S1Lo} &larr; MD, FloatUnloadS, Float.M, L0 &larr; L0.Dtimesloop,	c3;	uXdisp &larr; Stemp{S1Lo},	c1;	,	c2;	FloatUnloadS, Float.L, GOTO[BOTHnext],	c3;BOTHnext:	MAR &larr; D &larr; [rhD, D - 2], 	c1;	MDR &larr; Stemp &larr; FloatResult{DHi}, BRANCH[$, TIMESDRemap, 1],	c2;TIMESDcont:	,	c3;	MAR &larr; [rhD, D + 1],	c1;	MDR &larr; FloatResult{DLo}, CANCELBR[$, 2], LOOPHOLE[wok],	c2;	FloatAB{S1Hi} &larr; uStemp,	c3;	Kount &larr; Kount - 1, ZeroBr,	c1;	{uStemp{S1Lo} &larr; Stemp, }BRANCH[$, TIMESend], L2Disp,	c2;	FloatAB{S1Lo} &larr; uXdisp{uStemp}, DISP2[TIMESop],	c3;TIMEStimesS2Remap:	{S2 even, at Kount}	Zimph &larr; LShift1 Kount - 1, SE &larr; 0, CALL[LFAremapS2],	c3;	GOTO[TIMEStimesS2cont],	c2, at[L0.S2timeslooptimes, 10, LFAremapS2ret];TIMESplusS2Remap:	{S2 even, at Kount}	Zimph &larr; LShift1 Kount - 1, SE &larr; 0, CALL[LFAremapS2],	c3;	GOTO[TIMESplusS2cont],	c2, at[L0.S2timesloopplus, 10, LFAremapS2ret];TIMESminusS2Remap:	{S2 even, at Kount}	Zimph &larr; LShift1 Kount - 1, SE &larr; 0, CALL[LFAremapS2],	c3;	GOTO[TIMESminusS2cont],	c2, at[L0.S2timesloopminus, 10, LFAremapS2ret];TIMESS1Remap:	{S1 even, at Kount - 1}	,	c3;	Zimph &larr; Kount - 2, CarryBr, L0 &larr; L0.S1timesloop,	c1;	Zimph &larr; LShift1 Zimph, BRANCH[TIMESS1dontremap, $],	c2;	CALL[LFAremapS1],	c3;TIMESS1dontremap:	Q &larr; 2,	c3;	MAR &larr; S1 &larr; [rhS1, 8 + 0],	c1;{redo mem ref and smash S1}	GOTO[TIMESS1cont],	c2;	GOTO[TIMESS1cont],	c2, at[L0.S1timesloop, 10, LFAremapS1ret];TIMESDRemap:	{D even, at Kount}	Zimph &larr; LShift1 Kount - 1, SE &larr; 0, CALL[LFAremapD],	c3;	MDR &larr; Stemp{FloatResult{DHi}}, GOTO[TIMESDcont],	c2, at[L0.Dtimesloop, 10, LFAremapDret];TIMESend:	Q &larr; 6,{ L1 = L1.LFAexit,} CANCELBR[$, 3],	c3;	GOTO[LFACommonExit],	c1;LFACommonExit:	{restore regs}	rhS &larr; urhS, GOTO[RestoreRegsHere1],	c2;RestoreRegsHere:	rhS &larr; urhS,	c*;{c2}RestoreRegsHere1:	rhPV &larr; urhPV,	c*;{c3}	PV &larr; uPVx,	c*;{c1}	S &larr;uS,	c*;{c2}	PC &larr; uPC,	c*;{c3}	{fix stack depth}	S &larr; S - Q, L1Disp,	c*;{c1}	TOSH &larr; uTOSH, DISP4[RestoreRegsRet],	c*;{c2}	{remove ib byte}	Xbus &larr; ib,	c3, at[L1.LFAexit, 10, RestoreRegsRet];	{instruction dispatch}	Bank &larr; EmuBank,	c1;	PC &larr; PC + 1, L2 &larr; L2.0, IBDisp,	c2;	L2 &larr; L2.0, DISPNI[OpTableB2],	c3;LFApagefault:	Q &larr; 0, L1 &larr; L1.LFApf, CALL[RestoreRegsHere],	c3;	at[L1.LFApf, 10, RestoreRegsRet],	GOTO[TrapFixesDoneB2c3],	c2;{	end TIMES }{	start PERM}PERMc1:	at[L2.perm, 10, LFAop],{FOP2 = PERM}	S1 &larr; 0{cause immediate remap}, L0 &larr; L0.PERM,	c1;	D &larr; 0{cause immediate remap}, L1 &larr; L1.LFAexit,	c2;	,	c3;{	PERM INNER LOOP}	{fetch offset}PERMloop:	MAR &larr; S1 &larr; [rhS1, S1 - 1], BRANCH[$, endPERM],	c1;	BRANCH[$, PERMS1Remap, 1],	c2;PERMS1cont:	Zimph &larr; MD, CALL[LFAremapS2],	c3;	,	c2, at[L0.PERM, 10, LFAremapS2ret];	Stemp{data} &larr; MD,	c3;	{store to dest}	MAR &larr; D &larr; [rhD, D - 1],	c1;	MDR &larr; Stemp, BRANCH[$, PERMDRemap, 1],	c2;PERMDcont:	Kount &larr; Kount - 1, ZeroBr, GOTO[PERMloop],	c3;	{end PERM INNER LOOP }PERMS1Remap:	Zimph &larr; Kount - 1, SE &larr; 0, CALL[LFAremapS1],	c3;	GOTO[PERMS1cont],	c2, at[L0.PERM, 10, LFAremapS1ret];PERMDRemap:	Zimph &larr; Kount - 1, SE &larr; 0, CALL[LFAremapD],	c3;	MDR &larr; Stemp, GOTO[PERMDcont],	c2, at[L0.PERM, 10, LFAremapDret];endPERM:	CANCELBR[$, 3],	c2;	Q &larr; 6,	c3;	GOTO[LFACommonExit],	c1;{	start EXP}EXPc1:	at[L2.exp, 10, LFAop],{FOP1 = EXP}	S1 &larr; 0{cause immediate remap}, L0 &larr; L0.EXP,	c1;	D &larr; 0{cause immediate remap}, L1 &larr; L1.LFAexit,	c2;	Q &larr; 2,	c3;{	EXP INNER LOOP}	{fetch source Hi and save}EXPloop:	MAR &larr; S1 &larr; [rhS1, S1 - Q{2}], BRANCH[$, EXPend], LOOPHOLE[pci],	c1;	BRANCH[EXPS1Remap, $, 1],	c2;EXPS1cont:	Stemp{SHi} &larr; MD,	c3;	Stemp &larr; LShift1 Stemp,	c1;	Stemp &larr; Stemp LRot8,	c2;	Stemp &larr; Stemp and 0FF,	c3;	{store value}	MAR &larr; D &larr; [rhD, D - 1],	c1;	MDR &larr; Stemp, BRANCH[$, EXPDRemap, 1], LOOPHOLE[natc],	c2, at[L0.EXP, 10, LFAremapDret];	Kount &larr; Kount - 1, ZeroBr, GOTO[EXPloop],	c3;	{end EXP INNER LOOP}EXPS1Remap:	Zimph &larr; LShift1 Kount - 1, SE &larr; 0, CALL[LFAremapS1],	c3;	GOTO[EXPS1cont],	c2, at[L0.EXP, 10, LFAremapS1ret];EXPDRemap:	Zimph &larr; Kount - 1, SE &larr; 0, CALL[LFAremapD],	c3;EXPend:	CANCELBR[$, 3],	c2;	Q &larr; 4,	c3;	GOTO[LFACommonExit],	c1;{	start COMPLEX}COMPLEXc1:	at[L2.complex, 10, LFAop],{FOP1 = COMPLEX}	S1 &larr; 0{cause immediate remap}, L0 &larr; L0.COMPLEX,	c1;	D &larr; 0{cause immediate remap}, L1 &larr; L1.LFAexit,	c2;	Q &larr; 2,	c3;{	COMPLEX INNER LOOP}	{fetch source and save}COMPLEXloop:	MAR &larr; S1 &larr; [rhS1, S1 - Q{2}], BRANCH[$, COMPLEXend], LOOPHOLE[pci],	c1;	BRANCH[COMPLEXS1Remap, $, 1],	c2;COMPLEXS1cont:	Stemp{SHi} &larr; MD,	c3;	MAR &larr; [rhS1, S1 + 1],	c1;	uStemp &larr; Stemp, CANCELBR[$, 2],	c2;	Stemp{SLo} &larr; MD,	c3;	{store into dest imaginary}	MAR &larr; D &larr; [rhD, D - 2],	c1;	MDR &larr; 0, BRANCH[$, COMPLEXDRemap, 1],	c2;COMPLEXDcont:	,	c3;	MAR &larr; [rhD, D + 1], L0 &larr; L0.COMPLEXx,	c1;	MDR &larr; 0, CANCELBR[$, 2], LOOPHOLE[wok],	c2;	,	c3;	{store into dest real}	MAR &larr; D &larr; [rhD, D - 2],	c1;	MDR &larr; uStemp, BRANCH[$, COMPLEXDxRemap, 1],	c2;COMPLEXDxcont:	,	c3;	MAR &larr; [rhD, D + 1], L0 &larr; L0.COMPLEX,	c1;	MDR &larr; Stemp, CANCELBR[$, 2], LOOPHOLE[wok],	c2;	Kount &larr; Kount - 1, ZeroBr, GOTO[COMPLEXloop],	c3;	{end COMPLEX INNER LOOP}COMPLEXS1Remap:	Zimph &larr; LShift1 Kount - 1, SE &larr; 0, CALL[LFAremapS1],	c3;	GOTO[COMPLEXS1cont],	c2, at[L0.COMPLEX, 10, LFAremapS1ret];COMPLEXDRemap:	Zimph &larr; LShift1 Kount, SE &larr; 0,	c3;	Zimph &larr; LShift1 Zimph - 1, SE &larr; 0,	c1;	,	c2;	CALL[LFAremapD],	c3;	MDR &larr; 0, GOTO[COMPLEXDcont],	c2, at[L0.COMPLEX, 10, LFAremapDret];	{only necessary if array not quad alligned!!}COMPLEXDxRemap:	Zimph &larr; LShift1 Kount - 1, SE &larr; 0,	c3;	Zimph &larr; LShift1 Zimph, SE &larr; 0,	c1;	,	c2;	CALL[LFAremapD],	c3;	MDR &larr; uStemp, GOTO[COMPLEXDxcont],	c2, at[L0.COMPLEXx, 10, LFAremapDret];COMPLEXend:	CANCELBR[$, 3],	c2;	Q &larr; 4,	c3;	GOTO[LFACommonExit],	c1;{	start MAG}MAGc1:	at[L2.mag, 10, LFAop],{FOP1 = MAG}	L0 &larr; L0.MAGx, FloatMode.RN.AI.FAST, FloatPIPE,	c1;	Zimph &larr; LShift1 Kount, SE &larr; 0,	c2;	Zimph &larr; LShift1 Zimph - 1, SE &larr; 0, CALL[LFAremapS1],	c3;	L1 &larr; L1.LFAexit,	c2, at[L0.MAGx, 10, LFAremapS1ret];	FloatAB{IHi} &larr; MD, FLTimes.A.B,	c3;	MAR &larr; [rhS1, S1 + 1],	c1;	CANCELBR[$, 2],	c2;	FloatAB{ILo} &larr; MD,	c3;	MAR &larr; S1 &larr; [rhS1, S1 - Q{2}], LOOPHOLE[pci],	c1;	CANCELBR[$, 2],	c2;	FloatAB{RHi} &larr; MD, FLTimes.A.B,	c3;	MAR &larr; [rhS1, S1 + 1],	c1;	CANCELBR[$, 2],	c2;	FloatAB{RLo} &larr; MD,	c3;	D &larr; 0, FloatPump,	c1;	L0 &larr; L0.MAG, FloatPump,	c2;	FloatPump,	c3;	FloatPump,	c1;	FloatPump, FloatUnloadP, Float.M, GOTO[MAGstart],	c2;{	MAG INNER LOOP}MAGloop:	{get imaginary and put to chip}	MAR &larr; S1 &larr; [rhS1, S1 - Q{2}], BRANCH[$, MAGend], LOOPHOLE[pci],	c1;	Stemp &larr; FloatResult, BRANCH[MAGS1Remap, $, 1],	c2;MAGS1cont:	FloatAB{IHi} &larr; MD, FLTimes.A.B,	c3;	MAR &larr; [rhS1, S1 + 1],	c1;	CANCELBR[$, 2],	c2;	FloatAB{ILo} &larr; MD, 	c3;	{get real and put to chip}	MAR &larr; S1 &larr; [rhS1, S1 - Q{2}], LOOPHOLE[pci],	c1;	CANCELBR[$, 2],	c2;	FloatAB{RHi} &larr; MD, FLTimes.A.B,	c3;	MAR &larr; [rhS1, S1 + 1],	c1;	CANCELBR[$, 2],	c2;	FloatAB{RLo} &larr; MD,	c3;	,	c1;	,	c2;	FloatPump,	c3;	MAR &larr;D &larr; [rhD, D - 2],	c1;	MDR &larr; uStemp, BRANCH[$, MAGDRemap, 1], FloatPump,	c2;MAGDcont:	FloatPump,	c3;	MAR &larr; [rhD, D + 1], FloatPump,	c1;	MDR &larr; Stemp, CANCELBR[$, 2], LOOPHOLE[wok], FloatPump, FloatUnloadP, Float.M,	c2;MAGstart:	FloatPump, FloatUnloadP, Float.L,	c3;	FloatAB &larr; FloatResult, FloatUnloadP, Float.M,	c1;	FloatAB &larr; FloatResult, FloatUnloadP, Float.L,	c2;	FloatA &larr; FloatResult, FLPlus,	c3;	FloatA &larr; FloatResult,	c1;	FloatPump,	c2;	FloatPump,	c3;	FloatPump,	c1;	FloatPump,	c2;	FloatPump,	c3;	FloatPump,	c1;	FloatUnloadS, Float.M,	c2;	FloatUnloadS, Float.L,	c3;	Stemp &larr; FloatResult,	c1;	uStemp &larr; Stemp,	c2;	Kount &larr; Kount - 1, ZeroBr, GOTO[MAGloop],	c3;	{end MAG INNER LOOP}MAGS1Remap:	Zimph &larr; LShift1 Kount,	c3;	Zimph &larr; LShift1 Zimph - 1,	c1;	,	c2;	CALL[LFAremapS1],	c3;	GOTO[MAGS1cont],	c2, at[L0.MAG, 10, LFAremapS1ret];MAGDRemap:	Zimph &larr; LShift1 Kount, SE &larr; 0, CALL[LFAremapD],	c3;	MDR &larr; uStemp, GOTO[MAGDcont],	c2, at[L0.MAG, 10, LFAremapDret];MAGDxRemap:	{D even, at Kount}	Zimph &larr; 0, SE &larr; 0, CALL[LFAremapD],	c3;	MDR &larr; uStemp, GOTO[MAGDxcont],	c2, at[L0.MAGx, 10, LFAremapDret];MAGend:	Stemp &larr; FloatResult, CANCELBR[$, 3],	c2;	L0 &larr; L0.MAGx,	c3;	MAR &larr; D &larr; [rhD, D - 2],	c1;	MDR &larr; uStemp, BRANCH[$, MAGDxRemap, 1],	c2;MAGDxcont:	,	c3;	MAR &larr; [rhD, D + 1],	c1;	MDR &larr; Stemp, CANCELBR[$, 2], LOOPHOLE[wok],	c2;	,	c3;	Q &larr; 4, GOTO[LFACommonExit],	c1;{	start FLOAT}FLOATc1:	at[L2.float, 10, LFAop],{FOP1 = FLOAT}	L0 &larr; L0.FLOATx, FloatMode.RN.AI.FAST, FloatFLOW,	c1;	ufloat &larr; 0, L1 &larr; L1.LFAexit,	c2;	Zimph &larr; Kount - 1, SE &larr; 0, CALL[LFAremapS1],	c3;	FloatAB{Hi} &larr; ufloat, FLFloatA,	c2, at[L0.FLOATx, 10, LFAremapS1ret];	FloatAB{Lo} &larr; MD,	c3;	FloatStartFlow,	c1;	D &larr; 0,	c2;	L0 &larr; L0.FLOAT,	c3;	,	c1;{pause to allow chips to calc}	,	c2;	,	c3;{	FLOAT INNER LOOP}FLOATloop:	FloatUnloadS, Float.M, BRANCH[$, FLOATend],	c1;	FloatUnloadS, Float.L,	c2;	Stemp &larr; FloatResult,	c3;	uS2Hi &larr; Stemp,	c1;	Stemp &larr; FloatResult,	c2;	uS2Lo &larr; Stemp, 	c3;	MAR &larr; S1 &larr; [rhS1, S1 - 1],	c1;	FloatAB &larr; ufloat, FLFloatA, BRANCH[$, FLOATS1Remap, 1],	c2;FLOATS1cont:	FloatAB{Lo} &larr; MD,	c3;	MAR &larr; D &larr; [rhD, D - 2],	c1;	MDR &larr; uS2Hi, BRANCH[$, FLOATDRemap, 1],	c2;FLOATDcont:	FloatStartFlow,	c3;	MAR &larr; [rhD, D + 1],	c1;	MDR &larr; uS2Lo, CANCELBR[$, 2], LOOPHOLE[wok],	c2;	Kount &larr; Kount - 1, ZeroBr, GOTO[FLOATloop],	c3;	{end FLOAT INNER LOOP}FLOATS1Remap:	,	c3;	Zimph &larr; Kount - 2, CarryBr,	c1;	BRANCH[FLOATS1dontremap, $],	c2;	CALL[LFAremapS1],	c3;FLOATS1dontremap:	Q &larr; 2,	c3;	MAR &larr; S1 &larr; [rhS1, 8 + 0],	c1;{redo mem ref and smash S1}	GOTO[FLOATS1cont],	c2;	GOTO[FLOATS1cont],	c2, at[L0.FLOAT, 10, LFAremapS1ret];FLOATDRemap:	Zimph &larr; LShift1 Kount - 1, SE &larr; 0, CALL[LFAremapD],	c3;	MDR &larr; uS2Hi, GOTO[FLOATDcont],	c2, at[L0.FLOAT, 10, LFAremapDret];FLOATend:	Q &larr; 4, CANCELBR[$, 3],	c2;	,	c3;	GOTO[LFACommonExit],	c1;	{remapping common code}	{	assumes offset in Zimph	trashes Zorch, rhZorch,	sets Q to 2	loads appropriate r and rh	goes to pagefault if need be	returns through L0	}{----	S2 REMAP   ----}LFAremapS2:	Zorch &larr; uS2Lo,	c1;	Zorch &larr; Zorch + Zimph, CarryBr,	c2;	rhZorch &larr; uS2Hi, BRANCH[LFAS2nocar, LFAS2car],	c3;LFAS2car:	Q &larr; rhZorch,	c1;	Q &larr; Q + 1,	c2;	rhZorch &larr; Q LRot0,	c3;LFAS2nocar:	{map S2}	Map &larr; [rhZorch, Zorch],	c1;lfa.S2map:	,	c2;	rhS2 &larr; S2 &larr; MD, XwdDisp,	c3;	Map &larr; [rhZorch, Zorch], DISP2[LFAmapS2],	c1;	MDR &larr; S2 or 10, GOTO[LFAS2ok],	c2, at[0, 4, LFAmapS2];	MDR &larr; S2 or 10, GOTO[LFAS2ok],	c2, at[1, 4, LFAmapS2];	MDR &larr; S2 or 10, GOTO[LFAS2ok],	c2, at[2, 4, LFAmapS2];	Rx &larr; S2, GOTO[LFApagefault],	c2, at[3, 4, LFAmapS2];LFAS2ok:	Q &larr; 2, L0Disp,	c3;	MAR &larr; S2 &larr; [rhS2, Zorch + 0], RET[LFAremapS2ret]	c1;{----	S1 REMAP   ----}LFAremapS1:	Zorch &larr; uS1Lo,	c1;	Zorch &larr; Zorch + Zimph, CarryBr,	c2;	rhZorch &larr; uS1Hi, BRANCH[LFAS1nocar, LFAS1car],	c3;LFAS1car:	Q &larr; rhZorch,	c1;	Q &larr; Q + 1,	c2;	rhZorch &larr; Q LRot0,	c3;LFAS1nocar:	{map S1}	Map &larr; [rhZorch, Zorch],	c1;	,	c2;	rhS1 &larr; S1 &larr; MD, XwdDisp,	c3;	Map &larr; [rhZorch, Zorch], DISP2[LFAmapS1],	c1;	MDR &larr; S1 or 10, GOTO[LFAS1ok],	c2, at[0, 4, LFAmapS1];	MDR &larr; S1 or 10, GOTO[LFAS1ok],	c2, at[1, 4, LFAmapS1];	MDR &larr; S1 or 10, GOTO[LFAS1ok],	c2, at[2, 4, LFAmapS1];	Rx &larr; S1, GOTO[LFApagefault],	c2, at[3, 4, LFAmapS1];LFAS1ok:	Q &larr; 2, L0Disp,	c3;	MAR &larr; S1 &larr; [rhS1, Zorch + 0], DISP4[LFAremapS1ret]	c1;{----	D REMAP   ----}LFAremapD:	Zorch &larr; uDLo,	c1;	Zorch &larr; Zorch + Zimph, CarryBr,	c2;	rhZorch &larr; uDHi, BRANCH[LFADnocar, LFADcar],	c3;LFADcar:	Q &larr; rhZorch,	c1;	Q &larr; Q + 1,	c2;	rhZorch &larr; Q LRot0,	c3;LFADnocar:	{map D}	Map &larr; [rhZorch, Zorch],	c1;	,	c2;	rhD &larr; D &larr; MD, XwdDisp,	c3;	Map &larr; [rhZorch, Zorch], DISP2[LFAmapD],	c1;	MDR &larr; D or 30, GOTO[LFADok],	c2, at[0, 4, LFAmapD];	MDR &larr; D or 30, GOTO[LFADok],	c2, at[1, 4, LFAmapD];	Rx &larr; D, GOTO[LFApagefault],	c2, at[2, 4, LFAmapD];	Rx &larr; D, GOTO[LFApagefault],	c2, at[3, 4, LFAmapD];LFADok:	Q &larr; 2, L0Disp,	c3;	MAR &larr; D &larr; [rhD, Zorch + 0], DISP4[LFAremapDret]	c1;	{ E N D }</pre>
  </body>
</html>
