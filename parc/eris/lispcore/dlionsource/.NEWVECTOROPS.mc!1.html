<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>NEWVECTOROPS.mc!1</title>
  </head>
  <body>
    <pre>
{File : NEWVECTOROPS.mcAuthor : Gwan SantosaDate :  2-Aug-85 14:11:37This program does the following vector operations :1. Get a pointer to a maximum value of a vector, alpha byte 04.2. Get a pointer to a minimum value of a vector, alpha byte 05.3. Get a pointer to an absolute minimum value of a vector, alpha byte 06.4. Get a pointer to an absolute maximum value of a vector, alpha byte 07.opcode[372'b],Stack parameters :	S - 2 : Pointer to vector base address.	S - 0 : Pointer of latest index.	TOS   : Count.	Must work backward, start from the tail of the array.	Algorithm (for 1 to 4) :Inner loop :		Call comparison subroutine.	If TOS is 0, done.	Else :	Update current position	Fetch next element.	Back to Inner loop	Comparison subroutine :	Check if to find absolute extreme.	If yes, convert sign bit to +.	Else :	Compare 2 numbers.	If new extreme is found, update index and reference register.	Return	}Set[L1.VO.NR.0E, 0E];Set[L1.VO.NR.0D, 0D];Set[L0.VO.RO.04, 04];Set[L0.VO.RO.05, 05];Set[L0.VO.RO.09, 09];Set[L0.VO.RO.0A, 0A];Set[L0.VO.RO.0B, 0B];RegDef[rCOUNT, R, 03]; {=PV}RegDef[rRESMN, R, 05]; {=PC}RegDef[uINDEX, U, 42];RegDef[uINDEX1, U, 47];RegDef[uNEWL, U, 44];RegDef[uNEWH, U, 45];RegDef[uMAXH, U, 05];RegDef[uMAXL, U, 59];RegDef[urbaseL, U, 35];RegDef[urbaseH, U, 30];RegDef[urhRx1, U, 37];	Ybus &larr; TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[04, 10, FOP1Disp]; {Check if size = NIL}	Ybus &larr; TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[05, 10, FOP1Disp]; {Check if size = NIL}	Ybus &larr; TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[06, 10, FOP1Disp]; {Check if size = NIL}		Ybus &larr; TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[07, 10, FOP1Disp]; {Check if size = NIL}	VOBK1:	TT &larr; 0FF + 1, BRANCH[VOER1, $],	 	c1; {set PPort to read}	Q &larr; uPPsave, L1 &larr; L1.FS.NR.0C,		c2;	PPort &larr; Q and ~TT, CALL[SaveAllRegsB2],	c3; {Save all registers}			MAR &larr; [rhS, S + 0],			c1, at[L1.FS.NR.0C, 10, SaveRegsB2Ret];	S &larr; S - 2,				c2;	Rx &larr; MD,				c3; {Get index of latest extreme}		MAR &larr; [rhS, S - 1],			c1; {Fetch base address of the array}	Ybus &larr; TOS, ZeroBr, CANCELBR[$, 2],	c2; {Check if size = 0}	Q &larr; MD, BRANCH[$, VOER0],		c3; {If 0, error}		MAR &larr; [rhS, S + 0],			c1;	S &larr; uS,					c2; {Restore S}	TT &larr; MD, 				c3;		urbaseL &larr; TT,	L0 &larr; L0.VO.RO.04,	c1;	rCOUNT &larr; TOS - 1,			c2; {rCOUNT = current position}	uINDEX1 &larr; Rx,				c3; {Save latest index}		uINDEX &larr; Rx, ZeroBr,				c1; {initialize index}	Rx &larr; Rx LShift1, SE &larr; 0, BRANCH[VONST, VOST],	c2; {If 0, first time}	VOST:	Rx &larr; rCOUNT, ZeroBr,				c3; {If current position is 0, exit}	uINDEX &larr; Rx, BRANCH[$, VOEX0],		c1;			Rx &larr; Rx LShift1, SE &larr; 0,		c2; {Multiply index by 2}	rCOUNT &larr; rCOUNT - 1,			c3; {Point to second entry from the tail}		TOS &larr; TOS - 1,				c1; {Decrement count}	Noop,					c2;VONST:	TT &larr; TT + Rx, CarryBr,			c3; {Get V address of latest extreme}		urbaseH &larr; Q, BRANCH[VONC00, VOC00],	c1;	VONC00:	GOTO[VOM000],				c2;VOC00:	Q &larr; Q + 1,				c2;VOM000:	rhTT &larr; Q LRot0,				c3;		TS101:	Map &larr; [rhTT, TT + 0], L1 &larr; L1.VO.NR.0E, c1;	Noop, 					c2;	rhRx &larr; Rx &larr; MD, XRefBr,			c3; {# of subtractions = count - 1}	TS202:	MAR &larr; Q &larr; [rhRx, TT + 0], BRANCH[VOCH0, $],	c1, at[L0.VO.RO.04, 10, NRMapFixCallerB2];	Rx &larr; Q,						c2;	TOSH &larr; MD,					c3;	TS303:	MAR &larr; Rx &larr; [rhRx, Rx + 1], L2 &larr; 00,	c1; {Get an element and initialize as MAX}	uMAXH &larr; TOSH, BRANCH[$, FXVO0, 1],	c2;	Q &larr; MD,					c3;		TT &larr; urbaseL,				c1, at[00, 10, FETCHRET];	uMAXL &larr; Q, L1 &larr; L1.VO.NR.0E,		c2;	Rx &larr; rCOUNT,				c3; {Calculate V address of next element}				Rx &larr; Rx LShift1, SE &larr; 0,		c1;	FloatNop,				c2;	TT &larr; TT + Rx, CarryBr,			c3;		Q &larr; urbaseH, BRANCH[VONC10, VOC10],	c1;	VONC10:	GOTO[VOM111],				c2;VOC10:	Q &larr; Q + 1,				c2;VOM111:	rhTT &larr; Q LRot0,				c3;	Map &larr; [rhTT, TT + 0], L0 &larr; L0.VO.RO.0A,	c1;	FloatNop,				c2;	rhRx &larr; Rx &larr; MD, XRefBr,			c3;		MAR &larr; Q &larr; [rhRx, TT + 0], BRANCH[VOCH11, $],	c1, at[L0.VO.RO.0A, 10, NRMapFixCallerB2];	urhRx1 &larr; Rx,					c2; {Save rhRx}	TOSH &larr; MD,					c3;		Rx &larr; Q,					c1;	uRx &larr; Rx,				c2;	FloatMode.RN.AI.IEEE, FloatFLOW,	c3;			TS505:	MAR &larr; Rx &larr; [rhRx, Rx + 1], L2 &larr; 02,	c1;	uTT &larr; TT, BRANCH[$, FXVO2, 1],		c2;	Q &larr; MD,					c3; {Get second element and initialize as NEW}	TS606:	Rx &larr; uRx, L2 &larr; 03,			c1, at[02, 10, FETCHRET];	rhRx &larr; urhRx1,				c2;	uNEWL &larr; Q, CALL[VOCP],			c3; {Call comparison subroutine}{========================================================================================================Inner loop========================================================================================================}		uTOS &larr; TOS, ZeroBr,				c1, at[0, 10, COMPRET]; {TOS is the count down counter}	TOS &larr; TOS - 1, ZeroBr, BRANCH[$, VOEX3],	c2; {If TOS = 0, done}	rCOUNT &larr; rCOUNT - 1, BRANCH[$, VOEX1],		c3; {Current position (rCOUNT) is updated}		MAR &larr; Rx &larr; [rhRx, Rx - 1],  NibCarryBr,	c1; {Fetch next element}	TOSH &larr; uTOSH, DISP2[VOIC],		c2; {Restore TOSH for interrupt only}	Q &larr; MD,  				c3, at[1, 4, VOIC];ICRET:	MAR &larr; Rx &larr; [rhRx, Rx - 1], L2 &larr; 04,	c1, at[03, 10, FETCHRET];	uNEWL &larr; Q, BRANCH[$, FXVO4, 1],		c2;	TOSH &larr; MD, CALL[VOCP],			c3;		,					c1, at[04, 10, FETCHRET];	TOSH &larr; Q,				c2; {If page cross, return here}	CALL[VOCP],				c3;	{==========================================================================================Compare subroutine==========================================================================================This subroutine handles 4 comparisons.The low 2 bits of ib determines which operation.00 : Find index of max. value.01 : Find index of min. value.10 : Find index of absolute max. value.11 : Find index of absolute min. value.If a new extreme value is found, it will update the index and the new extreme value isloaded into a reference register uMAX}VOCP:	Xbus &larr; ibNA, XDisp,		c1;	Q &larr; uMAXH, DISP4[MAXMIN, 0D],	c2;		uNEWH &larr; TOSH, GOTO[VCOM],	c3, at[0D, 10, MAXMIN];		TT &larr; ~TT xor TT,		c3, at[0F, 10, MAXMIN];		TT &larr; RShift1 TT, SE &larr; 0,	c1; {This section convert the sign bit to +}	Q  &larr; TT and Q,			c2;	uMAXH &larr; Q,			c3;		Noop,				c1;	TOSH &larr; TT and TOSH,		c2;	uNEWH &larr; TOSH, GOTO[VCOM],	c3;		VCOM:	FloatAB &larr; uNEWH,		c1;		FloatAB &larr; uNEWL,		c2;	FloatA &larr; uMAXH,	FLAMinusB,	c3;		FloatA &larr; uMAXL,			c1;			FloatNop,			c2;	Noop,				c3;		L3 &larr; 0,				c1;		Noop,				c2;	FloatUnloadS,	Float.M,	c3;		FloatUnloadS,	Float.L,	c1;		Q &larr; PPort,			c2;	rRESMN &larr; FloatResult,		c3;		Q &larr; FloatResult,		c1;	rRESMN &larr; rRESMN LRot8,		c2;		rRESMN &larr; rRESMN and 80, 	c3;		Xbus &larr; ibNA, XDisp,		c1;	DISP4[VOMAXMIN, 0E],		c2;			Ybus &larr; rRESMN, ZeroBr,		c3, at[0E, 10, VOMAXMIN]; {Determine max. value}			BRANCH[FNMAX1, SMMAX],		c1;	FNMAX1:	uMAXH &larr; TOSH, 			c2; {B&gt;A, New max. is found}	Q &larr; uNEWL,			c3; {Update uMAXH and uMAXL}			uMAXL &larr; Q,			c1; {They now contain the new extreme value}	uINDEX &larr; rCOUNT, L3Disp,	c2;	RET[COMPRET],			c3;	SMMAX:	L3Disp,				c2;	RET[COMPRET],			c3;	Ybus &larr; rRESMN, ZeroBr,		c3, at[0F, 10, VOMAXMIN]; {Determine min. value}	BRANCH[SMMIN, FNMIN1],		c1;	FNMIN1:	uMAXH &larr; TOSH, 			c2; {New min. is found}	Q &larr; uNEWL,			c3; {Update uMAXH and uMAXL}			uMAXL &larr; Q, 			c1; {They now contain the new extreme value}	uINDEX &larr; rCOUNT, L3Disp,	c2;	RET[COMPRET],			c3;	SMMIN:	L3Disp,				c2;	RET[COMPRET],			c3;	{==========================================================================================Remap==========================================================================================}VOCH0:	CALL[NRLMapFixB2],		c2;VOCH1:	CALL[NRLMapFixB2],		c2;VOCH11:	CALL[NRLMapFixB2],		c2;VOCH5:	CALL[NRLMapFixB2],		c2;FXVO0:	GOTO[VOFX],		c3;FXVO2:	GOTO[VOFX],		c3;		VOFX:	Q &larr; 0FF + 1,			c1;	TT &larr; TT + Q, CarryBr,		c2;	Q &larr; rhTT, BRANCH[VONC0, VOC0],	c3;	VONC0:	GOTO[VOMG0],			c1;	VOC0:	Q &larr; Q + 1,			c1;VOMG0:	rhTT &larr; Q LRot0,			c2;	uTT &larr; TT,			c3;	Map &larr; [rhTT, TT + 0], L0 &larr; L0.VO.RO.05,	c1;	Q &larr; Rx, L1 &larr; L1.VO.NR.0E,		c2;	rhRx &larr; Rx &larr; MD, XRefBr,			c3;		MAR &larr; Q &larr; [rhRx, Q + 0], BRANCH[VOCH1, $],	c1, at[L0.VO.RO.05, 10, NRMapFixCallerB2];	Rx &larr; Q, L2Disp,					c2;	Q &larr; MD, DISP4[FETCHRET],			c3;	TT &larr; uTT, L2 &larr; 03, GOTO[VOFX88],		c3, at[2, 4, VOIC];		TT &larr; uTT, L2 &larr; 03, GOTO[VOFX88],		c3, at[3, 4, VOIC];FXVO4:	TT &larr; uTT, GOTO[VOFX88],		c3;FXVO5:	TT &larr; uTT, GOTO[VOFX88],		c3;VOFX88:	Q &larr; 0FF + 1,			c1;	TT &larr; TT - Q, CarryBr,		c2;	Q &larr; rhTT, BRANCH[VOC4, VONC4],	c3;	VONC4:	GOTO[MGVO1],			c1;		VOC4:	Q &larr; Q - 1,			c1;MGVO1:	rhTT &larr; Q LRot0,			c2;	Q &larr; Rx,				c3;	Map &larr; [rhTT, TT + 0], L1 &larr; L1.VO.NR.0D,	c1;	uTT &larr; TT, L0 &larr; L0.VO.RO.09,		c2;	rhRx &larr; Rx &larr; MD, XRefBr,			c3;		MAR &larr; Q &larr; [rhRx, Q + 0], BRANCH[VOCH5, $],	c1, at[L0.VO.RO.09, 10, NRMapFixCallerB2];	Rx &larr; Q, L2Disp,					c2;	Q &larr; MD, DISP4[FETCHRET],			c3;		MAR &larr; [rhS, S + 0],		c1, at[L1.VO.NR.0E, 10, NTrapFixesB2];	MDR &larr; uINDEX1, GOTO[PF11],	c2;			MAR &larr; [rhS, S + 0],		c1, at[L1.VO.NR.0D, 10, NTrapFixesB2];	MDR &larr; uINDEX,			c2;PF11:	Noop,				c3;		Q &larr; 0, GOTO[RestoreAllRegsAndPFB2],	c1;	{==========================================================================================Interrupts check==========================================================================================}	Q &larr; MD, MesaIntBr,			c3, at[0, 4, VOIC];	BP000:	Ybus &larr; uWDC, NZeroBr, BRANCH[VONI1, $],	c1;	Ybus &larr; uWP, ZeroBr, BRANCH[$, VONI2],	c2;	uWP &larr; 0, BRANCH[VOINT, ICRE1],		c3;	VONI1:	CANCELBR[$],				c2;VONI2:	CANCELBR[$],				c3;ICRE1:	MAR &larr; Rx &larr; [rhRx, Rx - 1], L2 &larr; 04,	c1;	uNEWL &larr; Q, BRANCH[$, FXVO5, 1],		c2;	TOSH &larr; MD, CALL[VOCP],			c3;VOINT:	MAR &larr; [rhS, S + 0],			c1;	MDR &larr; uINDEX,				c2;	TOS &larr; uTOS, GOTO[FTGIN],		c3;			{==========================================================================================Exit points==========================================================================================}VOEX0:	PV &larr; uPVx,				c2;	uINDEX &larr; 0, GOTO[VOEX2],		c3;VOEX3:	CANCELBR[$],				c3;VOEX1:	TOSH &larr; uTOSH,				c1;	PV &larr; uPVx,				c2;	PC &larr; uPC,				c3;	VOEX2:	S &larr; S - 4, L1 &larr; L1.RestoreAndExit,	c1;	Xbus &larr; ib, L1Disp,			c2;		TOS &larr; uINDEX, DISP4[RestoreRegsB2Ret], 	c3;		{==========================================================================================Error cases==========================================================================================}VOER0:	S &larr; uS,		c1;VOER1:	GOTO[ufnX3],	c2;	{END}</pre>
  </body>
</html>
