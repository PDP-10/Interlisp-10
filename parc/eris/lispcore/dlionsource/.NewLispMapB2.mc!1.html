<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>NewLispMapB2.mc!1</title>
  </head>
  <body>
    <pre>
{File name NewLispMapB2.mcCreated: 24-Apr-84 10:00:25 }SetTask[0];Set[L1.RestoreAndExit, 5],Set[L1.RestoreAndPF, 6],{*************************	Read Map Update Subroutine **************************}{Timing: 4 cycles}{Enter at cycle 3, returns to cycle1}{returns thru L0 if map fixed ok}{returns thru L1 if wants to trap}RLMapFixB2:	Xbus &larr; Rx LRot0, XwdDisp,	c3;	Map &larr; [rhTT,TT], DISP2[RFixRFlagsB2],	c1;	MDR &larr; Rx or 10, L0Disp, GOTO[ReReadB2],	c2, at[0, 4, RFixRFlagsB2];	MDR &larr; Rx or 10, L0Disp, GOTO[ReReadB2],	c2, at[1, 4, RFixRFlagsB2];	MDR &larr; Rx or 10, L0Disp, GOTO[ReReadB2],	c2, at[2, 4, RFixRFlagsB2];	L1Disp, GOTO[RWTrapB2],	c2, at[3, 4, RFixRFlagsB2];ReReadB2:	Xbus &larr; 1, XDisp, RET[RMapFixCallerB2],	c3;{*************************	Write Map Update Subroutine **************************}{Timing: 4 cycles}{Enter at cycle 3, returns to cycle1}{returns thru L0 if map fixed ok}{returns thru L1 if wants to trap}WLMapFixB2:	Xbus &larr; Rx LRot0, XwdDisp,	c3;	Map &larr; [rhTT, TT], DISP2[FixWFlagsB2],	c1;	MDR &larr; Rx or 030, L0Disp, GOTO[ReWriteB2],	c2, at[0, 4, FixWFlagsB2];	MDR &larr; Rx or 030, L0Disp, GOTO[ReWriteB2],	c2, at[1, 4, FixWFlagsB2];	L1Disp, GOTO[RWTrapB2],	c2, at[2, 4, FixWFlagsB2];	L1Disp, GOTO[RWTrapB2],	c2, at[3, 4, FixWFlagsB2];ReWriteB2:	Xbus &larr; 1, XDisp, RET[WMapFixCallerB2],	c3;RWTrapB2:	DISP4[TrapFixesB2],	c3;	GOTO[TrapFixesDoneB2c2],	c1, at[L1.NoFixesB2, 10, TrapFixesB2];	TOS &larr; uTOS,	c1, at[L1.RestoreTosB2, 10, TrapFixesB2];	TOSH &larr; uTOSH, GOTO[TrapFixesDoneB2c3],	c2;{	GOTO[DLFix],	c1, at[L1.DLFixesB2, 10, TrapFixesB2];}{	GOTO[FFTFix],	c1, at[L1.FFTFixesB2, 10, TrapFixesB2];}ufnZ32:	,	c3;ufnZ12:	,	c1;ufnZ22:	TOS &larr; uTOS,	c2;	TOSH &larr; uTOSH, GOTO[ufnX12],	c3;ufnX22:	,	c2;ufnX32:	,	c3;ufnX12:	Bank &larr; EmuBank,	c1;	,	c2;	S &larr; S + 1, CROSS[ufnB1],	c3;OpTableB2:	Bank &larr; EmuBank,	c1, at[OpcodeBase];	,	c2;	CROSS[OpcodeBase],	c3;SaveAllRegsB2:	,	c*;SaveAllRegsSh:	uTOS &larr; TOS,	c*;	uTOSH &larr; TOSH,	c*;SaveSomeRegsB2:	uS &larr; S,	c*;{c1}	uPVx &larr; PV, L1Disp,	c*;{c2}	uPC &larr; PC, DISP4[SaveRegsB2Ret]	c*;{c3}RestoreAllRegsAndExitB2:	TOS &larr; uTOS, L1 &larr; L1.RestoreAndExit,	c2;	TOSH &larr; uTOSH, GOTO[RestoreSomeRegsB2],	c3;RestoreAllRegsAndPFB2:	TOS &larr; uTOS, L1 &larr; L1.RestoreAndPF,	c2;	TOSH &larr; uTOSH, GOTO[RestoreSomeRegsB2],	c3;RestoreAllRegsB2:	TOS &larr; uTOS,	c*;{c2}RestoreMostRegsB2:	TOSH &larr; uTOSH,	c*;{c3}RestoreSomeRegsB2:	rhS &larr; nRhS,	c*;{c1}	rhPV &larr; nRhS,	c*;{c2}	PV &larr; uPVx,	c*;{c3}	S &larr;uS,	c*;{c1}	{fix stack depth}	S &larr; S - Q, L1Disp,	c*;{c2}	PC &larr; uPC, DISP4[RestoreRegsB2Ret],	c*;{c3}	Bank &larr; EmuBank,	c1, at[L1.RestoreAndExit, 10, RestoreRegsB2Ret];	PC &larr; PC + 1, L2 &larr; L2.0, IBDisp,	c2;	L2 &larr; L2.0, DISPNI[OpTableB2],	c3;TrapFixesDoneB2c2:	,	c2;TrapFixesDoneB2c3:	,	c3;B2CrossToPFaultc1:	Bank &larr; EmuBank,	c1, at[L1.RestoreAndPF, 10, RestoreRegsB2Ret];	L1 &larr; L1.NoFixes,	c2;	CROSS[PFaultB1],	c3;	{ E N D }</pre>
  </body>
</html>
