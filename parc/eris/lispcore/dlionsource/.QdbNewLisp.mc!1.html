<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>QdbNewLisp.mc!1</title>
  </head>
  <body>
    <pre>
{File name QdbNewLisp.mc}SetTask[0];{******************************************************************	READFLAGS*******************************************************************}READFLAGS:	Xbus &larr; TOSH xor smallpl, NZeroBr,	c1, opcode[161'b]; {71}	rhTT &larr; TT &larr; TOS LRot8, BRANCH[$, rdfUfn],	c2;	TOSH &larr; smallpl,	c3;	Map &larr; [rhTT, TT],	c1;	TOS &larr; 0E0,	c2;	TOS &larr; MD and TOS,	c3;	TOS &larr; TOS LRot12,	c1;	Ybus &larr; TOS and 0F, YDisp,	c2;	DISP4[CvtFlags,1], c3;	TOS &larr; 00, GOTO[RFExit], c1, at[01,10,CvtFlags];	TOS &larr; 02, GOTO[RFExit], c1, at[03,10,CvtFlags];	TOS &larr; 01, GOTO[RFExit], c1, at[05,10,CvtFlags];	TOS &larr; 03, GOTO[RFExit], c1, at[07,10,CvtFlags];	TOS &larr; 08, GOTO[RFExit], c1, at[09,10,CvtFlags];	TOS &larr; 0A, GOTO[RFExit], c1, at[0B,10,CvtFlags];	TOS &larr; 09, GOTO[RFExit], c1, at[0D,10,CvtFlags];	TOS &larr; 0D, GOTO[RFExit], c1, at[0F,10,CvtFlags];RFExit:	TOS &larr; TOS LRot12, IBDisp, L2 &larr; L2.0, GOTO[DNI.pc1],	c2;rdfUfn:	Rx &larr; 161'b, GOTO[ufn1],	c3;{******************************************************************	READRP*******************************************************************}READRP:	Xbus &larr; TOSH xor smallpl, NZeroBr,	c1, opcode[162'b];	rhTT &larr; TT &larr; TOS LRot8, BRANCH[$, rdrpUfn],	c2;	TOSH &larr; smallpl,	c3;	Map &larr; [rhTT, TT],	c1;	TOS &larr; ~0E0, L2 &larr; L2.0,	c2;	TOS &larr; MD and TOS, c3;	Ybus &larr; TOS - 1, PgCarryBr,	c1;	BRANCH[rsect0, rsectN0],	c2;rsect0:	GOTO[readrpend],	c3;rsectN0:	TOS &larr; TOS - 3, GOTO[readrpend],	c3;readrpend:	PC &larr; PC + PC16,	c1;	IBDisp,	c2;	TOS &larr; TOS LRot8, L2 &larr; L2.0, DISPNI[OpTable],	c3;rdrpUfn:	Rx &larr; 162'b, GOTO[ufn1],	c3; {******************************************************************	WRITEMAP*******************************************************************}WRITEMAP:   {vp, rp, flag =&gt; vp}	MAR &larr; [rhS, S], S &larr; S -1,	c1, opcode[163'b];{73}	Ybus &larr; TOSH xor smallpl, NZeroBr, CANCELBR[$, 2],	c2;	Rx &larr; MD{rp}, BRANCH[$, ufnWM0],	c3;{ Test to see if the rp is in the display bank. If so, leave it alone else bump pg# by 300}	TT &larr; Rx and ~0FF, c1;	Ybus &larr; TT + 0, ZeroBr, c2;	TT &larr; 3, BRANCH[notDB, isDB], c3;notDB:	TT &larr; TT LRot8, c1;	Rx &larr; Rx + TT, c2;  {add 3 segs}	, c3;	MAR &larr; [rhS, S + 0],	c1;	S &larr; S -1, 	c2;	Q &larr; MD{rpH},	c3;	MAR &larr; [rhS, S], S &larr; S -1,	c1;	Ybus &larr; Q xor smallpl, NZeroBr, CANCELBR[$,2],	c2;	TT &larr; MD{vp}, BRANCH[$, ufnWM1],	c3;	MAR &larr; [rhS, S+0], L2 &larr; L2.0,	c1;	Rx &larr; Rx LRot8,			c2;	Q &larr; MD{vpH},			c3;	, 				c1;	Ybus &larr; Q xor smallpl, NZeroBr,	c2;	rhTT &larr; TT &larr; TT LRot8, BRANCH[$, ufnWM2],	c3;	S &larr; S -1, Xbus &larr; TOS LRot4, XDisp,	c1;	Rx &larr; Rx and ~0E0, DISP4[wmf, 4],	c2;	Rx &larr; Rx or 0, GOTO[wMap],	c3, at[4, 10, wmf];	Rx &larr; Rx or 80, GOTO[wMap],	c3, at[0C,10,wmf];	Rx &larr; Rx or 040, GOTO[wMap], 	c3, at[5, 10, wmf];	Rx &larr; Rx or 0C0, GOTO[wMap],	c3, at[0D,10,wmf];	Rx &larr; Rx or 20, GOTO[wMap],	c3, at[6, 10, wmf];		Rx &larr; Rx or 0A0, GOTO[wMap],	c3, at[0E,10,wmf];	Rx &larr; Rx or 060, GOTO[wMap],	c3, at[7, 10, wmf];	Rx &larr; Rx or 0E0, GOTO[wMap],	c3, at[0F,10,wmf];wMap:	Map &larr; [rhTT, TT],	c1;	MDR &larr; Rx, PC &larr; PC + PC16, IBDisp,	c2;	TOS &larr; TT LRot8, L2 &larr; L2.0, DISPNI[OpTable],	c3;ufnWM0:	S &larr; S+1, GOTO[ufnX2],	c1;ufnWM1:	S &larr; S+3, GOTO[ufnX2],	c1;ufnWM2:	S &larr; S+3, GOTO[ufnX2],	c1;{******************************************************************}AnotherFault:	Noop, GOTO[PFault], c3, at[PFaultB0];BBFault:PFault:	rhRx &larr;  INTERFACEspace, 	c1;	Rx &larr; INTERFACEbasePage{20'b}{INTERFACEbase=10000'b},	c2;	Rx &larr; Rx LRot8, GOTO[PFaultcont],	c3;{******************************************************************}{% SHOULD CHECK IF ANY PENDING INTERRUPTS - CURRENTLY MAY MISS KEYSTROKES }opcode[176'b],{7E}	Ybus &larr; TOS xor ResetFXP, ZeroBr{faultExit}, L2&larr; 0{NotInCall},	c1;	Rx&larr; TOS, BRANCH[$,  SwReset],	c2;	TOSH &larr; 0, CANCELBR[ConJn],	c3;SwReset: ClrIntErr,TOSH &larr; 1{Resetting},	c3;	rhRio &larr; oldIOPageHigh, c1;	Rio &larr; oldIOPageLow, c2;	uWP &larr; 0, c3;	MAR &larr; [rhRio, Rio + PeriodicInterruptOffset],c1;	MDR &larr; 0, CANCELBR[$,2], LOOPHOLE[wok], c2;	, c3;ConJn:	uWDC &larr; TOSH, PC&larr; PC + PC16 {advance PC}, GOTO[PuntFor2],	c1;{note that this code winds up storing the context number on the stack and thensetting the no-push bit in the frame. This is not exactly the same as the Dorado, but no code relies on the value returned "to" a context}{******************************************************************}MidPuntmar:	MAR &larr; [rhTT, Q + 0],	c1;	,	c2;	Rx &larr; MD,	c3;	MAR &larr; [rhTT, Q + 0],	c1;	MDR{next} &larr; PV,	c2;	PV &larr; Rx, GOTO[RTN2],	c3;{******************************************************************}	{ E N D }</pre>
  </body>
</html>
