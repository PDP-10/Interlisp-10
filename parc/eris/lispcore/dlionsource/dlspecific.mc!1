{File name dlspecific.mcDescription:  DandeLion InterLisp EmulatorAuthor: Purcell //  CharnleyLast mod on 28-Aug-85 11:46:34}ErrLoop:	Xbus _ Rx LRot0, XwdDisp,	c2;	Xbus _ MStatus, XLDisp, DISP2[CSParErr],	c3;CSParErr:	{MP9001}	Q _ 0+1, KCtl _ 0, CANCELBR[sink2, 3],	c1, at[0,4,CSParErr];	{LMemErr:	Noop, BRANCH[VirtAddrErr, EmuMemErr, 1],	c1, at[1,4,CSParErr];moved to InitLisp}{*************************	SWAP**************************}SWAP:	MAR _ [rhS, S - 1],	c1, opcode[375'b];{FD}	PC _ PC + PC16, MDR _ TOSH, CANCELBR[$, 2], WriteOK,	c2;	TOSH _ MD,	c3;	MAR _ [rhS, S + 0],	c1;	MDR _ TOS, IBDisp, L2 _ L2.0, GOTO[DNI.TOSg],	c2;MPWait:	rhRx _ Rx _ uIOPage,	c3;	MAR _ [rhRx, IOPage.MP+0],	c1;	MDR _ Q,	c2;	TT{saveMP} _ MD,	c3;	MAR _ [rhRx, IOPage.key+0],  GOTO[MPWait7],	c1;{"stop" key hard reset is 0 in bit 15}{"undo" key down is 0 in bit 13}raidLp1:	MAR _ [rhRx, IOPage.key+0],  DISP4[raidEnd, 0A]	c1;MPWait7:	uLispOptions _ 0,	c2, at[0F, 10, raidEnd];	Xbus _ MD, XDisp, GOTO[raidLp1],	c3;	Q _ 1,	c2, at[0E, 10, raidEnd];	uWDC _ Q, L2_0,	c3;	MAR _ [rhRx, IOPage.MP+0], CANCELBR[$, 0F],	c1;	MDR _ TT{saveMP},	c2;	Rx _ {TeleRaidFXP}30'b, GOTO[PUNT],	c3;stopEnd:	,	c3;	MAR _ [rhRx, IOPage.MP+0],	c1;	MDR _ TT{saveMP},	c2;	GOTO[Reset],	c3;@RCLK:	opcode[167'b],	uTOSH _ TOSH,	c1;	rhTT _ TOSH LRot0,	c2;	,	c3;	Map _ TT _ [rhTT, TOS], L0 _ L0.RedoClk,	c1;	PC _ PC + PC16, L1 _ L1.DecOnly,	c2;	Rx _ rhRx _ MD, XwdDisp{XDirtyDisp},	c3;		at[L0.RedoClk,10,WMapFixCaller],	Q _ uClockHigh, DISP2[ClkMap],	c1;	TOSH _ RShift1 uClockBits, SE_0,	c2, at[1, 4, ClkMap];	TT _ uClockLow,	c3;	MAR _ [rhRx, TOS+1], L2 _ L2.0,	c1;	MDR _ TOSH +TT, CANCELBR[$, 2], WriteOK,	c2;	Ybus _ TOSH +TT, CarryBr,	c3;	MAR _ [rhRx, TOS+0], BRANCH[ClkNoCar, ClkCar],	c1;ClkNoCar:	MDR _ Q, IBDisp, GOTO[reTosh],	c2;ClkCar:	MDR _ Q+1, IBDisp, GOTO[reTosh],	c2;reTosh:	TOSH _ uTOSH, L2 _ L2.0, DISPNI[OpTable],	c3;	CALL[WLMapFix]{will return at RedoClk},	c2, at[0, 4, ClkMap];	CALL[WLMapFix]{will return at RedoClk},	c2, at[2, 4, ClkMap];	CALL[WLMapFix]{will return at RedoClk},	c2, at[3, 4, ClkMap];{*************************	Interrupt Processing**************************}MInt0:			 at[600],	TT _ 0{buffer empty}, Xbus _ uPCCrossL, XRefBr, GOTO[MInt],	c1;MInt1:			 at[700],	TT _ TT xor ~TT{not empty}, Xbus _ uPCCrossL, XRefBr, GOTO[MInt],	c1;MInt:	Ybus _ uWDC, NZeroBr, BRANCH[$, Crossing],	c2;	TT _ uWP, ClrIntErr, BRANCH[Interuption, IgnoreInt],	c3;IgnoreInt:	Noop,	c1;IBDispOnlyL: IBDisp, L2 _ L2.0, GOTO[DISPNIonly],	c2;DISPNIonly:	L2 _ L2.0, DISPNI[OpTable],	c3;Interuption: Ybus _ TT, ZeroBr,	c1;	BRANCH[Wakeups, NoWakeups],	c2;NoWakeups:	GOTO[IgnoreInt],	c3;Wakeups:		uWP _ 0,	c3;	Rx _ 1,	c1;	uWDC _ Rx,{off interrupts}	c2;	Rx _ KbdFXP, L2 _ 0{NotInCall}, GOTO[PuntFor],	c3;