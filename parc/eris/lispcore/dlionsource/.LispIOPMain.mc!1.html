<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>LispIOPMain.mc!1</title>
  </head>
  <body>
    <pre>
{File name:  LispIOPMain.mc Purcell 28-Dec-83 18:02:57  Last Edited by Amy Fasnacht:  4-Mar-83 11:26:19: Make uBufMax a two-word quantity to fix gateway freeze problem Last Edited by Jim Frandeen: May 25, 1982  11:40 AM: Add virtual addressing and page crossing. Written by Jim Frandeen: March 11, 1982  10:47 AM}SetTask[IOPTask], StartAddress[IOPIdle];{This is the module that communicates with the IOP (the 8085). We start in IOPInMode, which means we wake up when the IOP is trying to tell us something. We read 8 bits from the IOP each wakeup. We read:low address (10:17) middle address (2:9) high address (0:1) count in bytes for write and read, or mask for naked notify.command is last:	0 - Do Naked Notify	1 - Read Memory Block	2 - Write Memory Block}	IOPIdle:	rIOP &larr; IOPIData, L7 &larr; 0F, CANCELBR[$,0F], 		c1;	rIOP &larr; rIOP LRot8, {low, xxx}, L7Disp, CALL[IOPNoop],		c2;{	Noop,								c3;}	rIOP &larr; rIOP or IOPIData {Middle address (2:9)}, L7 &larr; 4, 	c1, at[0F,10,IOPSub]; 	rIOP &larr; rIOP LRot8, {High, Low} L7Disp, CALL[IOPNoop],		c2;{	Noop, 								c3;}	uIOPVirtLow &larr; rIOP,  						c1, at[4,10,IOPSub];	rhIOP &larr; rIOP &larr; IOPIData {high address (0:1)},		       	c2;	L7 &larr; 5, uIOPVirtHigh &larr; rIOP,					c3;{Next comes the parameter.  It is count-2 for write and read and mask for naked notify.}	rTmp &larr; IOPIData, CALL[rTmpLRot8], 				c1;{	rTmp &larr; rTmp LRot8, {Left justify}				c2;}{	Noop,								c3;}	rTmp &larr; rTmp or IOPIData, L7 &larr; 6, CALL[rTmpLRot8],  		c1, at[5,10,IOPSub];{	rTmp &larr; rTmp LRot8, 						c2;}{	Noop,								c3;}	Xbus &larr; IOPIData, XDisp,						c1, at[6,10,IOPSub];	rIOP &larr; uIOPVirtLow, L7 &larr; 0 {Put command in L7}, DISP2[IOPCmd],	c2;{**************************************************************************	Do Naked Notify.	IOP Control is in InMode	mask is in rTmp.	L7 = 0	Set control to Always Wakeup so we can do another click.**************************************************************************}	IOPCtl &larr; IOPAWMode,						c3, at[0,4,IOPCmd];{OR into wakeup U-register.  This must be done in one click.}	rIOP &larr; uWP, MesaIntRq,						c1;	rTmp &larr; rTmp or rIOP, IOPCtl &larr; IOPInMode,			c2;	uWP &larr; rTmp, GOTO [IOPIdle],					c3;{**************************************************************************	Read or Write memory block.	IOP Control is in InMode	Bytes come in the order high byte, low byte	uIOPVirtHigh and rhIOP contain the virtual address high	uIOPVirtLow and rIOP contain the virtual address low	rTmp = count in bytes. 	L7 = 1 (read) or 2 (Write)	First, compute the last virtual address**************************************************************************}{Come here if Write Command. For a Write Command, the last address must point to the last word transferred, so we subtract 2 from the byte count.}	rTmp &larr; rTmp-2, GOTO[CalculateLast],				c3, at[2,4,IOPCmd];{Come here if Read Command. For a read command, the last address must point to one word past the last word actually read. We will wakeup at CalculateLast since the data register is empty, and the port is in OutMode.  The IOP task will continue to wakeup until a byte is output to the port.}	 IOPCtl &larr; IOPOutMode, GOTO[CalculateLast],			c3, at[1,4,IOPCmd];{For Write, we will wakeup here since the data register is empty, and the port is in OutMode.  The IOP task will continue to wakeup until a byte is output to the port. }CalculateLast:	rTmp &larr; RShift1 rTmp,						c1;	rTmp &larr; rTmp + rIOP, CarryBr,					c2;TestCarry:	uData &larr; rTmp, rIOP &larr; rTmp, BRANCH[MapLast, $],			c3;	rIOP &larr; rhIOP+1, LOOPHOLE[byteTiming],				c1;	rhIOP &larr; rIOP LRot0, GOTO[TestCarry], 				c2;{**************************************************************************	Map last virtual address.	On entry, last virtual address low is in uData, rIOP,  and rTmp	last virtual address high is in rhIOP	Return with last real address low in uBufMaxLow and uBufMaxHigh**************************************************************************}MapLast:	Map &larr; [rhIOP, rIOP], 						c1;	rTmp &larr; ~0FF,							c2;	rhIOP &larr; MD, rIOP &larr; MD and rTmp {FF00},				c3;{Now we have the real page number in rhIOP and rIOP[0..7].Set up rIOP to contain the low 16 bits of the last real address.}	rTmp &larr; uData {Saved virtual address low},			c1;	rTmp &larr; rTmp and 0FF,  						c2;	uBufMaxLow &larr; rIOP or rTmp,				  	c3; 	rIOP &larr; rhIOP,							c1;	uBufMaxHigh &larr; rIOP,						c2;	Noop, {0 disp} CALL[IOPNoop],					c3;{**************************************************************************	Set the virtual address to point to word 0 of the next page.	uIOPVirtHigh contains the virtual address high	uIOPVirtLow contains the virtual address low	Save rTmp in uData for ReadBlock**************************************************************************}MapNextPage:	uData &larr; rTmp,							c1, at[2,10,IOPSub];	rIOP &larr; 0FF,							c2;	rTmp &larr; uIOPVirtLow,						c3;{Calculate next virtual address as old virtual address + 256.  Then set rIOP to point to the first word of the page.}	rIOP &larr; rIOP {0FF} + rTmp {old virtual address} + 1, CarryBr,	c1;	rIOP &larr; rIOP and ~0FF, BRANCH[MapVirt3, $],			c2;	rTmp &larr; uIOPVirtHigh,						c3;	rTmp &larr; rTmp + 1,						c1;	uIOPVirtHigh &larr; rTmp, GOTO[MapVirt3],				c2;{**************************************************************************	Map virtual address.	On entry, virtual address is in uIOPVirtHigh and uIOPVirtLow	Return with real address in rhIOP,,rIOP**************************************************************************}MapVirtual:	rIOP &larr; uIOPVirtLow,						c2, at[0,10,IOPSub];MapVirt3:	rhIOP &larr; uIOPVirtHigh,						c3;{Save virtual address. If we came here from MapNextPage, then rIOP points to the first word of a new page; otherwise rIOP map point to any word in the page.}	Map &larr; [rhIOP, rIOP], uIOPVirtLow &larr; rIOP, 			c1;	rTmp &larr; ~0FF,							c2;	rhIOP &larr; MD, rIOP &larr; MD and rTmp {FF00},				c3;{Now we have the real page number in rhIOP and rIOP[0..7].Set up rIOP to contain the low 16 bits of the real address.}	rTmp &larr; uIOPVirtLow,						c1;	rTmp &larr; rTmp and 0FF, L7Disp, 					c2;	rIOP &larr; rIOP or rTmp, DISP2[IOPMapRet], 				c3; {**************************************************************************	Begin WriteBlock loop.	On entry, real address is in rhIOP,,rIOP	L7 = 2**************************************************************************}WriteBlock:	[] &larr; rIOP xor uBufMaxLow, ZeroBr,				c1, at[2,4,IOPMapRet];	rTmp &larr; IOPIData {00, High},BRANCH[$, CheckForLastByte], 	c2;	rTmp &larr; rTmp LRot8 {High, 00},					c3;	WriteBlockLoop:	MAR&larr; [rhIOP, rIOP], rIOP&larr;rIOP+1,				c1; 	rTmp &larr; MDR &larr; rTmp or IOPIData, BRANCH [$, WritePageCross, 1],	c2; 	Noop, GOTO[WriteBlock],						c3;{This byte is the last byte.  There will be no page crossing, so do the memory reference and then go back to top of the loop}CheckForLastByte:	rIOP &larr; rhIOP,							c3; 		Ybus &larr; rIOP xor uBufMaxHigh, ZeroBr,				c1; 	rIOP &larr; uBufMaxLow, BRANCH[ContinueLoop, $],			c2; 	rTmp &larr; rTmp LRot8,						c3; 	MAR&larr; [rhIOP, rIOP+0],						c1; 	MDR &larr; rTmp or IOPIData, 					c2; IOPDone:	IOPCtl &larr; IOPInMode, GOTO [IOPIdle],				c3;{Here the low address bits match those of the last real address (uBufMaxLow), but the high address bits (uBufMaxHigh) don't.  Go back to the loop and continue.}ContinueLoop:	rTmp &larr; rTmp LRot8 {High, 00}, GOTO[WriteBlockLoop],		c3;{The previous MAR&larr; instruction generated a page cross branch.  The data was not written.  The Data to be written is saved in rTmp, and it was not the last data byte, so we will get at least one more wakeup.  Don't read in new data until we are finished with this data.  rIOP is now pointing to the beginning of this page, not at the beginning of the next page.  We still have to write the last word of this page. }WritePageCross:	Noop,								c3; {No page cross is possible on next instruction. Store the saved byte in the last location of the page. }	MAR &larr; [rhIOP, rIOP + 0FF],					c1; 	MDR &larr; rTmp, L7Disp, CANCELBR[IOPNoop,0],			c2; {	Noop, GOTO[MapNextPage],					c3;} {**************************************************************************	Begin ReadBlock loop.	On entry, real address is in rhIOP,,rIOP	The last address+1 is in uBufMax	Data is sent to the port high byte first, then low byte.	L7 = 1	Change L7 to 3 so we can have another return point from IOPMapRet.**************************************************************************}	MAR &larr; [rhIOP, rIOP], rIOP &larr; rIOP + 1, L7 &larr; 3,			c1, at[1,4,IOPMapRet]; 	Noop, BRANCH[NoReadCross, ReadCross, 1],			c2; SendHighByte:	IOPOData &larr; rTmp LRot8 {Output High byte},			c2, at[3,10,IOPSub]; 	Ybus &larr; rIOP xor uBufMaxLow, ZeroBr,				c3;SendLowByte:	MAR &larr; [rhIOP, rIOP], rIOP&larr;rIOP+1, BRANCH[$,CheckForSendLastByte],	c1; 	IOPOData &larr; rTmp LRot0, BRANCH[NoReadCross, ReadCross, 1],	c2;NoReadCross:	rTmp &larr; MD, L7Disp, CALL[IOPNoop],				c3;{	Noop, GOTO[SendHighByte],					c1;}{This may be the last byte.  The next address might have generated a page crossing, but we don't need to worry about it.  Just cancel it, and then go back to top of the loop.}CheckForSendLastByte:	rIOP &larr; rhIOP, CANCELBR [$, 2],					c2; 	Ybus &larr; rIOP xor uBufMaxHigh, ZeroBr,				c3;	 	rIOP &larr; uBufMaxLow, BRANCH[ContinueSendLoop, $],			c1; 	IOPOData &larr; rTmp LRot0, GOTO[IOPDone],				c2; ContinueSendLoop:	Noop,								c2; 	GOTO[SendLowByte],						c3; {The previous MAR&larr; instruction generated a page cross branch.  rIOP is now pointing to the begining of this page, instead at the beginning of the next page.  Catch the last memory data, fix up rIOP to the correct address and continue. }ReadCross:	rTmp &larr;  MD, CALL [MapNextPage],					c3; {Return here from MapNextPage. rTmp, which contains the next word, was saved in uData.}	rTmp &larr; uData, GOTO[SendHighByte],				c1, at[3,4,IOPMapRet];rTmpLRot8:	rTmp &larr; rTmp LRot8, L7Disp, 					c2;IOPNoop:	Noop, RET[IOPSub]						c*;	</pre>
  </body>
</html>
