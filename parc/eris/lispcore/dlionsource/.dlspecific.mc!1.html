<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>dlspecific.mc!1</title>
  </head>
  <body>
    <pre>
{File name dlspecific.mcDescription:  DandeLion InterLisp EmulatorAuthor: Purcell //  CharnleyLast mod on 28-Aug-85 11:46:34}ErrLoop:	Xbus &larr; Rx LRot0, XwdDisp,	c2;	Xbus &larr; MStatus, XLDisp, DISP2[CSParErr],	c3;CSParErr:	{MP9001}	Q &larr; 0+1, KCtl &larr; 0, CANCELBR[sink2, 3],	c1, at[0,4,CSParErr];	{LMemErr:	Noop, BRANCH[VirtAddrErr, EmuMemErr, 1],	c1, at[1,4,CSParErr];moved to InitLisp}{*************************	SWAP**************************}SWAP:	MAR &larr; [rhS, S - 1],	c1, opcode[375'b];{FD}	PC &larr; PC + PC16, MDR &larr; TOSH, CANCELBR[$, 2], WriteOK,	c2;	TOSH &larr; MD,	c3;	MAR &larr; [rhS, S + 0],	c1;	MDR &larr; TOS, IBDisp, L2 &larr; L2.0, GOTO[DNI.TOSg],	c2;MPWait:	rhRx &larr; Rx &larr; uIOPage,	c3;	MAR &larr; [rhRx, IOPage.MP+0],	c1;	MDR &larr; Q,	c2;	TT{saveMP} &larr; MD,	c3;	MAR &larr; [rhRx, IOPage.key+0],  GOTO[MPWait7],	c1;{"stop" key hard reset is 0 in bit 15}{"undo" key down is 0 in bit 13}raidLp1:	MAR &larr; [rhRx, IOPage.key+0],  DISP4[raidEnd, 0A]	c1;MPWait7:	uLispOptions &larr; 0,	c2, at[0F, 10, raidEnd];	Xbus &larr; MD, XDisp, GOTO[raidLp1],	c3;	Q &larr; 1,	c2, at[0E, 10, raidEnd];	uWDC &larr; Q, L2&larr;0,	c3;	MAR &larr; [rhRx, IOPage.MP+0], CANCELBR[$, 0F],	c1;	MDR &larr; TT{saveMP},	c2;	Rx &larr; {TeleRaidFXP}30'b, GOTO[PUNT],	c3;stopEnd:	,	c3;	MAR &larr; [rhRx, IOPage.MP+0],	c1;	MDR &larr; TT{saveMP},	c2;	GOTO[Reset],	c3;@RCLK:	opcode[167'b],	uTOSH &larr; TOSH,	c1;	rhTT &larr; TOSH LRot0,	c2;	,	c3;	Map &larr; TT &larr; [rhTT, TOS], L0 &larr; L0.RedoClk,	c1;	PC &larr; PC + PC16, L1 &larr; L1.DecOnly,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;		at[L0.RedoClk,10,WMapFixCaller],	Q &larr; uClockHigh, DISP2[ClkMap],	c1;	TOSH &larr; RShift1 uClockBits, SE&larr;0,	c2, at[1, 4, ClkMap];	TT &larr; uClockLow,	c3;	MAR &larr; [rhRx, TOS+1], L2 &larr; L2.0,	c1;	MDR &larr; TOSH +TT, CANCELBR[$, 2], WriteOK,	c2;	Ybus &larr; TOSH +TT, CarryBr,	c3;	MAR &larr; [rhRx, TOS+0], BRANCH[ClkNoCar, ClkCar],	c1;ClkNoCar:	MDR &larr; Q, IBDisp, GOTO[reTosh],	c2;ClkCar:	MDR &larr; Q+1, IBDisp, GOTO[reTosh],	c2;reTosh:	TOSH &larr; uTOSH, L2 &larr; L2.0, DISPNI[OpTable],	c3;	CALL[WLMapFix]{will return at RedoClk},	c2, at[0, 4, ClkMap];	CALL[WLMapFix]{will return at RedoClk},	c2, at[2, 4, ClkMap];	CALL[WLMapFix]{will return at RedoClk},	c2, at[3, 4, ClkMap];{*************************	Interrupt Processing**************************}MInt0:			 at[600],	TT &larr; 0{buffer empty}, Xbus &larr; uPCCrossL, XRefBr, GOTO[MInt],	c1;MInt1:			 at[700],	TT &larr; TT xor ~TT{not empty}, Xbus &larr; uPCCrossL, XRefBr, GOTO[MInt],	c1;MInt:	Ybus &larr; uWDC, NZeroBr, BRANCH[$, Crossing],	c2;	TT &larr; uWP, ClrIntErr, BRANCH[Interuption, IgnoreInt],	c3;IgnoreInt:	Noop,	c1;IBDispOnlyL: IBDisp, L2 &larr; L2.0, GOTO[DISPNIonly],	c2;DISPNIonly:	L2 &larr; L2.0, DISPNI[OpTable],	c3;Interuption: Ybus &larr; TT, ZeroBr,	c1;	BRANCH[Wakeups, NoWakeups],	c2;NoWakeups:	GOTO[IgnoreInt],	c3;Wakeups:		uWP &larr; 0,	c3;	Rx &larr; 1,	c1;	uWDC &larr; Rx,{off interrupts}	c2;	Rx &larr; KbdFXP, L2 &larr; 0{NotInCall}, GOTO[PuntFor],	c3;</pre>
  </body>
</html>
