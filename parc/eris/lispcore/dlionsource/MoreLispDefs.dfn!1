{File name:  MoreLispDefs.dfn Description: Definitions for Dandelion Lisp Microcode, Created: 24-Apr-84 11:45:51 Last Edited:     24-Apr-84 11:45:58 - charnley}{	L0  return values for WLMapFixB2 }Set[L0.DLMap, 1];{DrawLine}Set[L0.RedoFtARG, 2];{FFT}Set[L0.RedoFtAB, 3];{FFT}Set[L0.RedoFtCD, 4];{FFT}{	L0  return values for RLMapFixB2 }Set[L0.xRedoFtFF, 1];{FFT}Set[L0.RedofptGet, 2];{GetFPT}Set[L0.RedoCreate, 5];{FloatIt subr}Set[L0.RedoFLFix, 6];{FloatIt subr}Set[L0.RedoPOLY0,	3];{polynomial}Set[L0.RedoPOLY1,	4];{polynomial}{	L1  fix values for RWTrap }Set[L1.DLFixesB2, 1];{DrawLine}Set[L1.NoFixesB2, 2];{FFT}Set[L1.RestoreTosB2, 3];Set[L1.FFTFixesB2, 4];{FFT}{	LispMatrix stuff}RegDef[rA, R, 6],{Rx}RegDef[rB, R, 0],{TOS}RegDef[rC, R, 1],{TOSH}RegDef[rhrA, RH, 6],{Rx}RegDef[rhrB, RH, 0],{TOS}RegDef[rhrC, RH, 1],{TOSH}RegDef[urAVlo, U, 002],	{Low VA of matrix A}RegDef[urAVhi, U, 003],	{High VA of matrix A}RegDef[urBVlo, U, 060],	{Low VA of matrix B}RegDef[urBVhi, U, 005],	{High VA of matrix B}RegDef[urCVlo, U, 006],	{Low VA of matrix C}RegDef[urCVhi, U, 007],	{High VA of matrix C}RegDef[uNinit, U, 008],	{Initial value of nCOUNT}RegDef[uKinit, U, 00A],	{Initial value of kCOUNT}RegDef[umCOUNT, U, 00B], {Current value of mCOUNT}RegDef[ukCOUNT, U, 00C], {Current value of kCOUNT}RegDef[unCOUNT, U, 041], {Current value of nCOUNT, when saved}RegDef[udeltaA1, U, 031],	{-2(N-1)}RegDef[udeltaB0, U, 033],	{+2K}RegDef[udeltaB1, U, 035],	{-2(N-1)(K)+2}RegDef[udeltaB2, U, 037],	{-2(N)(K)+2}Set[L0.delta0, 0],Set[L0.delta1, 1],Set[L0.delta2, 2],Set[L0.deltaI, 3],Set[L1.mxnotfirst, 1],Set[L1.mxfirst, 2],{Set[L1.matufn, 7],}Set[ib.poly, 0],Set[ib.333, 1],Set[ib.444, 2],Set[ib.133, 3],Set[ib.331, 4],Set[ib.144, 5],Set[ib.441, 6];{	DRAWLINE stuff}RegDef[umXX0,	U,	02];{move to fZ=0 before using} {TWiddle factor 4 word complex float}RegDef[ulXX,	U,	03];RegDef[umYY0,	U,	04];{move to fZ=0 before using; STK points here}RegDef[ulYY0,	U,	05];{fp chip doesn't like ulYY here for some STRANGE reason}RegDef[uFFvH,	U,	06];{Virtual Address of source (From) array base.}RegDef[uFFvL,	U,	07];RegDef[uABvH,	U,	08];{Virtual Address of destination array base.}RegDef[uABvL,	U,	09];RegDef[uCDvH,	U,	0A];{Virtual Address of midpoint in destination array base.}RegDef[uCDvL,	U,	0B];RegDef[uTCnt,	U,	0C];{count of butterflies with same twiddle (x4)}RegDef[uHCnt,	U,	0D];{high portion of count of butterflies remaining (x4)}Set[ft.twiddle.offset, 4 ];Set[ft.twiddle.delta.offset, 20'd ];{Twiddle Delta(8 words): address of complex zero followed by packed complex root of unity to change twiddle}Set[ft.HCnt.offset, 11'd ];RegDef[umXX,	U,	50];	{umXX,FTimes{0}}RegDef[umYY,	U,	60];{uRx}	{umYY,FTimes{0}}RegDef[ulYY,	U,	51];{alternate home for ulYY see ulYY0}RegDef[uArgH,	U,	68];{virtual address of argument record}RegDef[uArgL,	U,	69];{rA=Rx}RegDef[ulCC,	U, 	4];	{ulCC, STK{FPlus}}RegDef[umYW,	U, 	4];	{umYW, STK{FPlus}}RegDef[FF,	R,	3];{PV}  {Real address in "From" array. Equal to Source + 2*(HCnt + RCnt) }RegDef[rhFF,	RH,	3];RegDef[AB,	R,	4];{S} {Real address in destination array. Equal to Dest + HCnt + WCnt) } RegDef[rhAB,	RH,	4];RegDef[CD,	R,	1];{TOSH}{Real address in destination array. Equal to Dest + HCnt + WCnt) }RegDef[rhCD,	RH,	1];RegDef[rmAW,	R,	2];{TT}RegDef[rlBW2,	R,	2];{TT}RegDef[rTCnt,	R,	2];{TT}RegDef[rmBW,	R,	6];{Rx}RegDef[rlDY,	R,	6];{Rx}{RegDef[rmCY,	R,	6];{Rx}{remove eventually}}RegDef[rRCnt,	R,	2];{TT}{uRCnt, rRCnt, FMinus} RegDef[uRCnt,	U,	26];{uPV}{low portion of count of butterflies remaining to Read(x4)}RegDef[uWCnt,	U,	47];{low portion of count of butterflies remaining to Write(x4)}RegDef[ulDY,	U,	54];{RegDef[TOS,	R,	0];}{RegDef[rmDY,	R,	0];}{RegDef[rlCY,	R,	0];{remove eventually}}RegDef[rmYW,	R, 	0];RegDef[rmAA,	R,	0];RegDef[rlDW,	R,	0];RegDef[rmDW,	R,	0];RegDef[rlCW2,	R,	0];{RegDef[PC,	R, 	5];}RegDef[rlDD,	R, 	5];RegDef[rlBW,	R, 	5];RegDef[rmCW,	R, 	5];RegDef[umCW,	U, 	58];	{rmCW,umCW}RegDef[rlCC,	R, 	5];RegDef[rlCW,	R, 	5];RegDef[ulCW,	U, 	52];	{rlCW,ulCW}RegDef[rHCnt,	R, 	5];RegDef[rlAW,	R, 	5];RegDef[rmDY,	R, 	5];	{rmDY,umDY}RegDef[umDY,	U, 	56];	{umDY,FMinus{6}}{RegDef[rlDY,	R, 	5];}{moved to 6=Rx}RegDef[rlBB,	R, 	5];RegDef[ulBB,	U, 	53];RegDef[rlYW,	R, 	5];RegDef[rlAA,	R, 	5];RegDef[ulAA,	U, 	55];	{rlAA,ulAA,FMinusB{5}}{	reg defs for polynomial}RegDef[uAinitH,	U,	57];	{A(0) H}RegDef[uAinitL,	U,	58];	{A(0) L}RegDef[uXHi,	U,	30];	{X H}RegDef[uXLo,	U,	05];	{X L}RegDef[uDegree,	U,	42];	{The degree of polynomial}RegDef[uTTtmp,	U,	43];	{Virtual address, tmp}RegDef[uAnxtH,	U,	38];	{New A, H word, tmp}MacroDef[fpUMS, FloatUMS];MacroDef[fpULS, FloatULS];MacroDef[fpUMP, FloatUMP];MacroDef[fpULP, FloatULP];MacroDef[FloatR, FloatResult];MacroDef[FTimes, FLTimes.A.B];MacroDef[FPlus, FLPlus];MacroDef[FMinus, FLBMinusA];MacroDef[FMinusB, FLAMinusB];RegDef[uBlock0, UY, 0];Set[L2.init, 3 ];Set[L2.start, 7{2} ];Set[L2.middle, 1 ];Set[L2.finish, 0 ];{	for LISP FLOAT ARRAY}RegDef[Kount, R, 0],{TOS}RegDef[S1, R, 1],{TOSH}RegDef[rhS1, RH, 1],RegDef[Zorch, R, 2],{TT}RegDef[rhZorch, RH, 2],RegDef[S2, R, 3],{PV}; {init to 0 to force remap}RegDef[rhS2, RH, 3],RegDef[uStemp, U, 53];RegDef[D, R, 4],{S}  {init to 0 to force remap}RegDef[rhD, RH, 4],RegDef[Stemp, R, 5],{PC}RegDef[Stemp2, R, 6],{Rx}RegDef[Zimph, R, 6],RegDef[uDLo, U, 02],RegDef[uDHi, U, 03],RegDef[uS1Lo, U, 30],RegDef[uS1Hi, U, 35],RegDef[uS2Lo, U, 38],RegDef[uS2Hi, U, 07],  {RegDef[uTOS, U, 0D],}  {RegDef[uTOSH, U, 1D],}RegDef[uS, U, 04B],RegDef[urhS, U, 051],RegDef[uPVx, U, 03B],RegDef[urhPV, U, 034],  {RegDef[uPC, U, 05B],}  {RegDef[ufloat, U, 042],{fZ value for Float}}RegDef[uXdisp, U, 041],{LMG}RegDef[uWidth, U, 042],{LMG}RegDef[uICount, U, 043],{LMG}RegDef[uNBits, U, 044],{LMG}RegDef[umask, U, 045],{LMG}RegDef[uShiftedPattLo, U, 03A],{LMG}RegDef[uShiftedPattHi, U, 037],{LMG}{	from LispMakeGraph}RegDef[umaskrealLo, U, 045],RegDef[umaskrealHi, U, 046];{	from LFAM.mc}RegDef[uFLAmB, U, 35];{     RestoreRegsRet}Set[L1.LFApf, 1],Set[L1.LFAexit, 3],Set[L1.LFGexit, 4],Set[L1.matufn, 7],{because of CANCELBR's}Set[L1.matexit, 0A];{LispMatrix}{     LFASaveRegsRet}Set[L1.LFA2prep, 3],Set[L1.LFA1prep, 4],Set[L1.LMGprep, 5],Set[L1.lm, 9];{LispMatrix}  {RegDef[TOS, R, 0],{TOS}   RegDef[TOSH, R, 1],{TOSH}   RegDef[TT, R, 2],{TT}   RegDef[PV, R, 3],{PV}   RegDef[rhPV, R, 3],{PV}   RegDef[S, R, 4],{S}   RegDef[rhS, RH, 4],{S}   RegDef[PC, R, 5],{PC}   RegDef[Rx, R, 6],{Rx} }   {S2 remap returns}Set[L0.S2timeslooptimes, 01],{uses 3 also}Set[L0.S2timesloopplus, 05],{uses 7 also}Set[L0.S2timesloopminus, 09],{uses 0B also}Set[L0.PERM, 04],Set[L0.lfam.s2a, 02],Set[L0.S2mag0, 06],   {S1 remap returns}Set[L0.S1init2, 1],Set[L0.S1timesloop, 2],{Set[L0.PERM, 4],{uses 5 also} }Set[L0.EXP, 6],Set[L0.COMPLEX, 7],Set[L0.FLOAT, 8],Set[L0.MAGx, 9],Set[L0.FLOATx, 03],Set[L0.lfam.s1a, 0C],Set[L0.S1mag0, 0D],{Set[L0.MAGD2, 0A],}Set[L0.MAG, 0B],   {D remap returns}Set[L0.Dtimesloop, 1],{Set[L0.PERM, 4],}{Set[L0.EXP, 6],}{Set[L0.COMPLEX, 7],}{Set[L0.FLOAT, 8],}Set[L0.MAGD1, 9],Set[L0.MAGD2, 0A],Set[L0.MAGD3, 0],Set[L0.COMPLEXx, 3],Set[L0.lfam.di, 05],Set[L0.lfam.da, 0C],Set[L0.lfam.db, 0D],Set[L0.lfam.dd, 0E],Set[L0.lfam.df, 02],{Set[L0.MAG, 0B],}Set[L2.Xtimes, 0],Set[L2.perm, 1],Set[L2.Xplus, 2],Set[L2.minus, 3],Set[L2.magic, 04],Set[L2.Triple, 5];{TripleCheck}Set[L2.exp, 08],Set[L2.mag, 09],Set[L2.float, 0A],Set[L2.complex, 0B],	{for TripleCheck}Set[L0.trS2i, 1];Set[L0.trS1i, 2];Set[L0.trDi, 3];Set[L0.trS2, 4];Set[L0.trS1, 5];Set[L0.trD, 6];	{for LispMakeGraph} {    LMGremapDret}Set[L0.LMGDinit, 4],Set[L0.LMGD1, 2],Set[L0.LMGD2, 3],Set[L0.LMGD3, 5],{     LMGremapS1ret}Set[L0.LMGS1init, 4],Set[L0.LMGS1S2, 6],{     LMGremapS2ret}{Set[L0.LMGS1S2, 6],}{     AllignRet}{Set[L0.LMGS1S2, 6],}   {GetFPT remap returns}Set[L2.btou, 1],	;{ E N D }