{File : NEWLSH.mcAuthor : Gwan SantosaDate :   5-Nov-85  9:47:30(LSH A B)Performs left shift A by B position,where A and B are smallplProcedure :After preliminary checking for valid arguments, rotate A by 8 position (swap h and l byte),For B between 0 and 7, check h byte to see if it is ok to shift.For B between 8 and 15, as long as h byte is 00, it is ok to shift 8 position first, thendo the remainder by going to subroutine that process shifting between 0 and 7 positions.}	@LSHOP:	Ybus _ TOSH xor smallpl, ZeroBr,	c1, opcode[347'b];  {Check if B is smallpl}	Rx _ 10, BRANCH[LSHER1, $],		c2;	Q _ 0FF,				c3; {Q contains mask for B>=8}		MAR _ [rhS, S - 1], 				c1;	Ybus _ TOS - Rx, CarryBr, CANCELBR[$, 2],	c2; {Check if B>15}	TT _ MD, BRANCH[$, LSHER3]			c3; {Fetch A Hi}		MAR _ [rhS, S + 0], 			c1;	Ybus _ TT xor smallpl, ZeroBr,		c2; {Check if A is smallpl}	Rx _ MD, BRANCH[LSHER2, $],		c3; {Fetch A Lo}	TT _ Rx LRot8,				c1; {Rotate A by 8}	uTOS _ TOS, YDisp,			c2; {Select how many shifting}	TOS _ TOS and 07, DISP4[SHSEL],		c3; L0SH:	TOS _ Rx, GOTO[LSHF4],			c1, at[0, 10, SHSEL];			L1SH:	Q _ 80,						c1, at[1, 10, SHSEL];	TT _ TT and Q, ZeroBr,				c2;		TT _ Rx LShift1, SE _ 0, BRANCH[LSER0, $],	c3;			TOS _ TT, GOTO[LSHF3],				c1;	L2SH:	Q _ 0C0,					c1, at[2, 10, SHSEL];			TT _ TT and Q, ZeroBr,				c2;		TT _ Rx LShift1, SE _ 0, BRANCH[LSER1, $],	c3;			TOS _ TT LShift1, SE _ 0, GOTO[LSHF3],		c1;	L3SH:	Q _ 0E0,				c1, at[3, 10, SHSEL];	TT _ TT and Q, ZeroBr,			c2;		TT _ Rx LRot4, BRANCH[LSER2, $],	c3;			TOS _ TT RShift1, SE _ 0, GOTO[LSHF3],	c1;	L4SH:	Q _ 0F0,				c1, at[4, 10, SHSEL];	TT _ TT and Q, ZeroBr,			c2;		TT _ Rx LRot4, BRANCH[LSER3, $],	c3;			TOS _ TT, GOTO[LSHF3],			c1;L5SH:	Q _ 0F8,				c1, at[5, 10, SHSEL];	TT _ TT and Q, ZeroBr,			c2;		TT _ Rx LRot4, BRANCH[LSER4, $],	c3;			TOS _ TT LShift1, SE _ 0, GOTO[LSHF3],	c1;L6SH:	Q _ 0FC,				c1, at[6, 10, SHSEL];	TT _ TT and Q, ZeroBr,			c2;		TT _ Rx LRot4, BRANCH[LSER5, $],	c3;			TT _ TT LShift1, SE _ 0, 		c1;	TT _ TT LShift1, SE _ 0, GOTO[LSHF5],	c2;L7SH:	Q _ 0FE,				c1, at[7, 10, SHSEL];	Ybus _ TT and Q, ZeroBr,		c2;		BRANCH[LSER6, $],			c3;			TOS _ TT RShift1,SE _ 0,  GOTO[LSHF3],	c1;	L8SH:	Ybus _ TT and Q, ZeroBr, GOTO[CNR8],	c1, at[8, 10, SHSEL]; 									L9SH:	Ybus _ TT and Q, ZeroBr, GOTO[CNR8],	c1, at[9, 10, SHSEL];LASH:	Ybus _ TT and Q, ZeroBr, GOTO[CNR8], 	c1, at[0A, 10, SHSEL];	LBSH:	Ybus _ TT and Q, ZeroBr, GOTO[CNR8], 	c1, at[0B, 10, SHSEL];		LCSH:	Ybus _ TT and Q, ZeroBr, GOTO[CNR8],	c1, at[0C, 10, SHSEL];		LDSH:	Ybus _ TT and Q, ZeroBr, GOTO[CNR8],	c1, at[0D, 10, SHSEL];		LESH:	Ybus _ TT and Q, ZeroBr, GOTO[CNR8], 	c1, at[0E, 10, SHSEL];			Ybus _ Rx xor 1, ZeroBr,	c1, at[0F, 10, SHSEL];	BRANCH[LSER7, $],		c2; {Can only shift 15 position if A=1}	TOS _ Rx RRot1,			c3;		S _ S - 2, GOTO[IB.pc1],	c1;	CNR8:	BRANCH[LSER8, $],	c2;	Q _ Rx,			c3; {Exchange Rx and TT}		Rx _ TT,		c1;	Ybus _ TOS, YDisp,	c2; {Process the remainding shifting}		TT _ Q, DISP4[SHSEL],	c3;	LSHER1:	GOTO[ufnX1],	c3;LSHER3: GOTO[ufnX2],	c1;LSHER2:	GOTO[ufnX2],	c1;LSER7:	uTOSH _ TOSH, GOTO[ufnZ1],	c3;LSER0:	uTOSH _ TOSH, GOTO[ufnZ2],	c1;LSER1:	uTOSH _ TOSH, GOTO[ufnZ2],	c1;LSER2:	uTOSH _ TOSH, GOTO[ufnZ2],	c1;LSER3:	uTOSH _ TOSH, GOTO[ufnZ2],	c1;LSER6:	uTOSH _ TOSH, GOTO[ufnZ2],	c1;LSER8:	uTOSH _ TOSH, GOTO[ufnZ1],	c3;LSER4:	uTOSH _ TOSH, GOTO[ufnZ2],	c1;LSER5:	uTOSH _ TOSH, GOTO[ufnZ2],	c1;LSHF5:	TOS _ TT, GOTO[B2FN],	c3;LSHF4:	S _ S - 2,		c2;	GOTO[B1FN],		c3;	B2FN:	S _ S - 2, GOTO[IB.pc1],	c1;	LSHF3:	S _ S - 2, 			c2;	Noop,				c3;		B1FN:	GOTO[IB.pc1],			c1;	