{NewLispMatrix.mcby cal 13-Dec-84 10:31:52		(MATRIXMPY  M  N  K  A.MATRIX  B.MATRIX  C.MATRIX)	    performs C.MATRIX _ A.MATRIX  *  B.MATRIX		where A.MATRIX is a matrix of M rows by N columns		and  B.MATRIX is a matrix of N rows by K columns		and  C.MATRIX is a matrix of M rows by K columns	the contents of A.MATRIX is A[m=0, n=0]	the contents of A.MATRIX + 1 is A[m=0, n=1]	.	.	the contents of A.MATRIX + N - 1 is A[m=0, n=N - 1]	the contents of A.MATRIX + N is A[m=1, n=0]	etc.	has the following builtin 'sizes'	alpha	size	1		A[3,3]  B[3,3]  C[3,3]  M = 3, N = 3, K = 3	2		A[4,4]  B[4,4]  C[4,4]  M = 4, N = 4, K = 4	3		A[1,3]  B[3,3]  C[1,3]  M = 1, N = 3, K = 3	4		A[3,3]  B[3,1]  C[3,1]  M = 3, N = 3, K = 1	5		A[1,4]  B[4,4]  C[1,4]  M = 1, N = 4, K = 4	6		A[4,4]  B[4,1]  C[4,1]  M = 4, N = 4, K = 1 -- basically	FOR m = 0 to M - 1		FOR k = 0 to K - 1			sum _ 0			FOR n = 0 to N - 1				sum _ sum + A[m, n] * B[n, k]			NEXT n		C[m, k] _ sum		NEXT k	NEXT m	timing:	{ 25 + 1 * N + 10 * N^2 + 8 * N^3}	3 x 3 x 3  ==  334 clicks  ~~  6000 per second	4 x 4 x 4  ==  701 clicks  ~~  2850 per second}{	defs moved to MoreLispDefs.dfnRegDef[rA, R, 6],{Rx}RegDef[rB, R, 0],{TOS}RegDef[rC, R, 1],{TOSH}RegDef[rhrA, RH, 6],{Rx}RegDef[rhrB, RH, 0],{TOS}RegDef[rhrC, RH, 1],{TOSH}RegDef[urAVlo, U, 02],	{Low VA of matrix A}RegDef[urAVhi, U, 03],	{High VA of matrix A}RegDef[urBVlo, U, 60],	{Low VA of matrix B}RegDef[urBVhi, U, 05],	{High VA of matrix B}RegDef[urCVlo, U, 06],	{Low VA of matrix C}RegDef[urCVhi, U, 07],	{High VA of matrix C}RegDef[uNinit, U, 08],	{Initial value of nCOUNT}RegDef[uKinit, U, 0A],	{Initial value of kCOUNT}RegDef[umCOUNT, U, 0B], {Current value of mCOUNT}RegDef[ukCOUNT, U, 0C], {Current value of kCOUNT}RegDef[unCOUNT, U, 36], {Current value of nCOUNT, when saved}RegDef[udeltaA1, U, 31],	{-2(N-1)}RegDef[udeltaB0, U, 33],	{+2K}RegDef[udeltaB1, U, 35],	{-2(N-1)(K)+2}RegDef[udeltaB2, U, 37],	{-2(N)(K)+2}{RegDef[uTOSH, U, 1D],}{RegDef[uTOS, U, 0D],}Set[L0.delta0, 0],Set[L0.delta1, 1],Set[L0.delta2, 2],Set[L0.deltaI, 3],Set[L1.mxnotfirst, 1],Set[L1.mxfirst, 2],{Set[L1.matufn, 7],}Set[ib.333, 1],Set[ib.444, 2],Set[ib.133, 3],Set[ib.331, 4],Set[ib.144, 5],Set[ib.441, 6];Set[L1.lm, 9];Set[L1.matexit, 0A];}	{@MATRIXMPY:	Bank _ PolyBank,			c1;	,					c2;	CROSS[POLYcode],			c3;	uTOS _ TOS,				c1, at[POLYcode];	Ybus _ Q, YDisp,			c2;	uTOSH _ TOSH, DISP4[misc3disp],		c3;		end in bank 1 & 2}				at[ib.333, 10, misc3disp]:	MAR _ [rhS, S - 1], GOTO[mxmgo],	c1;	{For 3X3X3}	at[ib.444, 10, misc3disp]:	MAR _ [rhS, S - 1], GOTO[mxmgo],	c1;	{For 4X4X4}	at[ib.133, 10, misc3disp]:	MAR _ [rhS, S - 1], GOTO[mxmgo],	c1;	{For 3X1X3}	at[ib.331, 10, misc3disp]:	MAR _ [rhS, S - 1], GOTO[mxmgo],	c1;	{For 3X3X1}	at[ib.144, 10, misc3disp]:	MAR _ [rhS, S - 1], GOTO[mxmgo],	c1;	{For 4X1X4}	at[ib.441, 10, misc3disp]:	MAR _ [rhS, S - 1], GOTO[mxmgo],	c1;	{For 4X4X1}		mxmgo:	FloatNop, CANCELBR[$, 2],	c2;	TT{Bhi} _ MD,			c3;	{Bhi is high VA of matrix B}	urCVlo _ TOS,	L1 _ L1.lm,	c1;	{Save Clo in urCVlo}	CALL[LFASaveRegsHere],		c2;	S _ S + 4,			c1, at[L1.lm, 10, LFASaveRegsRet];	urCVhi _ TOSH,			c2;	{Save Chi in urCVhi}	urBVhi _ TT, 			c3;	{Save Bhi in urBVhi}	MAR _ [rhS, S + 0],		c1;	{Point to BLo}	S _ S - 2,			c2;	Rx{Blo} _ MD,			c3;	{Blo is low VA of matrix B}	MAR _ [rhS, S - 1],		c1;	{Point to Ahi}	urBVlo _ Rx, CANCELBR[$, 2],	c2;	{Save Blo in urBVlo}	TT{Ahi} _ MD,			c3;	{Ahi is high VA of matrix A}	MAR _ [rhS, S + 0],		c1;	{Point to Alo}	urAVhi _ TT,			c2;	{Save Ahi in urAVhi}	TT{Alo} _ MD,			c3;	{Alo is low VA of matrix A}	S _ S + 2, L1 _ L1.mxfirst,	c1;	urAVlo _ TT,			c2;	{Save Alo in urAVlo}		TT _ 0FF + 1,		 	c3;	{set PPort to read}		Q _ uPPsave,			c1;	PPort _ Q and ~TT,		c2;	Xbus _ ibNA, XDisp,		c3;	DISP4[mxwhich, 0],		c1;	{===================================================================	  setup for 3 x 3 x 3 =================================================================== }	at[ib.333, 10, mxwhich], 	Q _ 3,				c2;		uNinit _ Q,			c3;	{uNinit=3}	,			c1;		uKinit _ Q,			c2;	{uKini=3}	umCOUNT _ Q,			c3;	{umCount=3}	ukCOUNT _ Q,			c1;	{ukCount=3}	unCOUNT _ Q,			c2;	{unCount=3}	Q _ 4,				c3;	{2(N-1)}	udeltaA1 _ Q,			c1;	{udeltaA1=4}	Q _ 6,				c2;	{2K}		udeltaB0 _ Q,			c3;	{udeltaB0=6}	Q _ 10'd,			c1;	{2(N-1)(K)-2}	udeltaB1 _ Q,			c2;	{udeltaB1=10}	Q _ 16'd,			c3;	{2(N)(K)-2}	udeltaB2 _ Q, GOTO[mxmaps],	c1;	{udeltaB2=16}		{===================================================================	  setup for 4 x 4 x 4 =================================================================== }		at[ib.444, 10, mxwhich], 	Q _ 4,				c2;	uNinit _ Q,			c3;	{uNinit=4}		,			c1;	uKinit _ Q,			c2;	{uKinit=4}	umCOUNT _ Q,			c3;	{umCOUNT=4}	ukCOUNT _ Q,			c1;	{ukCOUNT=4}		unCOUNT _ Q,			c2;	{unCOUNT=4}	Q _ 6,				c3;	{2(N-1)}	udeltaA1 _ Q,			c1;	{udeltaA1=6}	Q _ 8,				c2;	{2K}	udeltaB0 _ Q,			c3;	{udeltaB0=8}	Q _ 22'd,			c1;	{2(N-1)(K)-2}	udeltaB1 _ Q,			c2;	{udeltaB1=22}	Q _ 30'd,			c3;	{2(N)(K)-2}	udeltaB2 _ Q, GOTO[mxmaps],	c1;	{udeltaB2=30}	{===================================================================	  setup for 3x1x3 =================================================================== }			at[ib.133, 10, mxwhich], 	Q _ 3,				c2;	uNinit _ Q,			c3;	uKinit _ Q,			c1;	unCOUNT _ Q,			c2;	ukCOUNT _ Q,			c3;	Q _ 1,				c1;	umCOUNT _ Q,			c2;	Q _ 4,				c3;	udeltaA1 _ Q,			c1;	{udeltaA1 _ 2(N-1)}	Q _ 6,				c2;	udeltaB0 _ Q,			c3;	{udeltaB0 _ 2K}	Q _ 10'd,			c1;	udeltaB1 _ Q,			c2;	{udeltaB1 _ 2(N-1)(K)-2}	Q _ 16'd,			c3;	udeltaB2 _ Q, GOTO[mxmaps],	c1;	{udeltaB2 _ 2(N)(K)-2}	{===================================================================	  setup for 3x3x1 =================================================================== }			at[ib.331, 10, mxwhich], 	Q _ 3,				c2;	uNinit _ Q,			c3;	,			c1;	umCOUNT _ Q,			c2;	unCOUNT _ Q,			c3;	Q _ 1,				c1;	ukCOUNT _ Q,			c2;	uKinit _ Q,			c3;	Q _ 4,				c1;	udeltaB2 _ Q,			c2;	{udeltaB2 _ 2(N)(K)-2}	udeltaA1 _ Q,			c3;	{udeltaA1 _ 2(N-1)}	Q _ 2,				c1;	udeltaB0 _ Q,			c2;	{udeltaB0 _ 2K}	Q _ 2'd,			c3;	udeltaB1 _ Q, GOTO[mxmaps],		c1;	{udeltaB1 _ 2(N-1)(K)-2}	{===================================================================	  setup for 4x1x4 =================================================================== }			at[ib.144, 10, mxwhich], 	Q _ 4,				c2;	uNinit _ Q,			c3;	uKinit _ Q,			c1;	unCOUNT _ Q,			c2;	ukCOUNT _ Q,			c3;	Q _ 1,				c1;	umCOUNT _ Q,		c2;	Q _ 6{2(N-1)},			c3;	udeltaA1 _ Q,			c1;	{udeltaA1 _ 2(N-1)}	Q _ 8{2K},			c2;	udeltaB0 _ Q,			c3;	{udeltaB0 _ 2K}	Q _ 22'd{2(N-1)(K)},		c1;	udeltaB1 _ Q,			c2;	{udeltaB1 _ 2(N-1)(K)-2}	Q _ 30'd{2(N)(K)-2},		c3;	udeltaB2 _ Q, GOTO[mxmaps],	c1;	{udeltaB2 _ 2(N)(K)-2}	{===================================================================	  setup for 4x4x1 =================================================================== }			at[ib.441, 10, mxwhich], 	Q _ 4,				c2;	uNinit _ Q,			c3;	{uMinit _ Q},			c1;	unCOUNT _ Q,			c2;	umCOUNT _ Q,		c3;	Q _ 1,				c1;	ukCOUNT _ Q,			c2;	uKinit _ Q,			c3;	Q _ 6,				c1;	udeltaA1 _ Q,			c2;	{udeltaA1 _ 2(M-1)}	udeltaB2 _ Q,			c3;	{udeltaB2 _ 2(N)(K)-2}	Q _ 2,				c1;	udeltaB0 _ Q,			c2;	{udeltaB0 _ 2K}	Q _ 4'd,			c3;	udeltaB1 _ Q, GOTO[mxmaps],	c1;	{udeltaB1 _ 2(N-1)(K)-2}	{=====================================================================}{=====================================================================}		mxmaps:	rA _ urAVlo, L0 _ L0.deltaI,				c2;	{Store low VA of A into rA}	TT _ urAVlo, GOTO[fixrAI],				c3;	{Move it into TT, goto fixrAI}	at[L0.deltaI, 4, rAfixed],	rB _ urBVlo,						c2;	{Store low VA of B into rB}		TT _ urBVlo, GOTO[fixrBI],				c3;	{Move it into TT, goto fixrBI}	at[L0.deltaI, 4, rBfixed],	rC _ urCVlo,						c2;	{Store low VA of C into rC}	TT _ urCVlo, GOTO[fixrCI],				c3;	{Move it into TT, goto fixrCI}	at[L0.deltaI, 4, rCfixed],	FloatNop,						c2;	FloatMode.RN.AI.IEEE, FloatPIPE, 			c3;mxinit:	ufloatplus _ 0, L0 _ L0.delta0,				c1;	{Initialize to 0}	FloatAB _ ufloatplus, FLPlus,				c2;	{Load AB of FPT chip with 0}	FloatAB _ ufloatplus,					c3;	{Perform addition}	MAR _ [rhrA, rA + 0],					c1;	{Point to first element of A}	Q{nCOUNT} _ uNinit,					c2;	{Initialize column count}	FloatAB{Ahi} _ MD,					c3;	{Load A H into AB of FPT chip}		MAR _ [rhrA, rA + 1],					c1;	{Point to A L}	TT _ udeltaB0, CANCELBR[$, 2],				c2;	FloatAB{Alo} _ MD,					c3;	{Load A L into AB of FPT chip}	MAR _ rB _ [rhrB, rB + 0],				c1;	{Point to first element of B}	,							c2;	FloatA{Bhi} _ MD, FLTimes.A.B, GOTO[mxstart],		c3;	{Load B H into A of FPT chip}mxloop:	MAR _ rA _ [rhrA, rA + 2], DISP4[mxcheck2, 3],		c1;	{Point to next column of A}	FloatA{prodlo} _ FloatResult, BRANCH[$, fixrA0, 1],	c2, at[0F, 10, mxcheck2];	{Load Prod L}mxrAret:	FloatAB _ MD,						c3;	{Load A H into AB}	MAR _ [rhrA, rA + 1],					c1;	{Point to A L}	CANCELBR[$, 2],						c2;	FloatAB _ MD,						c3;	{Load A L into AB of FPT chip}	MAR _ rB _ [rhrB, rB + TT{2K}],				c1;	{Point to element of matrix B}	BRANCH[$, fixrB0, 1],					c2;	{Check for page carry}mxrBret:	FloatA{Bhi} _ MD, FLTimes.A.B,				c3;	{Load B H into A of FPT chip}mxstart:	MAR _ [rhrB, rB + 1],					c1;	{Point to B L}	CANCELBR[$, 2],						c2;	FloatA{Blo} _ MD,					c3;	{Load B L into A of FPT chip}									{Perform multiplication} 	FloatPump,						c1;	FloatPump,						c2;	FloatPump, FloatUnloadS, Float.M,			c3;	FloatPump, FloatUnloadS, Float.L,			c1;	FloatAB{sumhi} _ FloatResult,				c2;	{Load Sum H into AB of FPT chip}	Xbus _ PPort, XDisp,					c3;	{Get status, and test}	FloatAB{sumlo} _ FloatResult, DISP4[mxcheck1, 3],	c1;	{Load Sum L into AB of FPT chip}	FloatPump, FloatUnloadP, Float.M,			c2, at[0F, 10, mxcheck1];	{If OK}	FloatPump, FloatUnloadP, Float.L,			c3;	FloatA{prodhi} _ FloatResult, FLPlus,			c1;	{Load Prod H into A of FPT chip}	Q{nCOUNT} _ Q{nCOUNT} - 1, ZeroBr,			c2;	{Decrement count}	Xbus _ PPort, XDisp, BRANCH[mxloop, mxterm],		c3;	{Get status, and test}mxterm:	FloatA{prodlo} _ FloatResult, DISP4[mxcheck3, 3],	c1;	FloatPump,						c2, at[0F, 10, mxcheck3];	FloatPump,						c3;	FloatPump,						c1;	FloatPump,						c2;	FloatPump,						c3;	FloatPump,						c1;	FloatPump, FloatUnloadS, Float.M,			c2;	FloatPump, FloatUnloadS, Float.L,			c3;	Q _ FloatResult,					c1;	L1Disp,							c2;	DISP4[mx?first],					c3;		MAR _ rC _ [rhrC, rC + 0], L1 _ L1.mxnotfirst,		c1, at[L1.mxfirst, 10, mx?first];	MDR{sumhi} _  Q, LOOPHOLE[wok], GOTO[mxrCcont],		c2;		{Store result H}	MAR _ rC _ [rhrC, rC + 2],				c1, at[L1.mxnotfirst, 10, mx?first];	MDR{sumhi} _  Q, LOOPHOLE[wok], BRANCH[$, fixrC, 1],	c2;	{Store result H}	mxrCcont:	Xbus _ PPort, XDisp,					c3;	{Get status, and test}	MAR _ [rhrC, rC + 1], DISP4[mxcheck4, 3], 			c1;	{Point to C L}	MDR{sumlo} _ FloatResult, LOOPHOLE[wok], CANCELBR[$, 2],	c2, at[0F, 10, mxcheck4];	{Store result L}									Q _ ukCOUNT,							c3;	Q _ Q - 1, ZeroBr,					c1;	{Decrement K count}	ukCOUNT _ Q, BRANCH[mxmoreK, mxKdone],			c2;	{and test}mxmoreK:{	set nCOUNT to N {done in mxinit}	set rA to A[m, 0]  {was A[m, N-1] + 1}{delta = -2(N-1)}	set rB to B[0, k]  {was B[N-1, k-1] + 1}{delta = -2(N-1)*(K)+2}	GOTO[mxinit]}	Q _ udeltaA1, L0 _ L0.delta1,				c3;	rA _ rA - Q, PgCarryBr,					c1;	{Adjust pointer for matrix A}	BRANCH[fixrA1, lmrAdn],					c2;	GOTO[lmrAdn],					c2, at[L0.delta1, 4, rAfixed];lmrAdn:	Q _ udeltaB1,						c3;	rB _ rB - Q, PgCarryBr,					c1;	{Adjust pointer for matrix B}	BRANCH[fixrB1, lmrBdn],					c2;	GOTO[lmrBdn],					c2, at[L0.delta1, 4, rBfixed];lmrBdn:	GOTO[mxinit],						c3;mxKdone:{	decrement mCOUNT, exit if done	set kCOUNT to K	set nCOUNT to N {done in mxinit}	set rA to A[m, 0]  {was A[m-1, N-1] + 1}{delta = +2}	set rB to B[0, 0]  {was B[n-1, k-1] + 1}{delta = -2(N*K)+2}	GOTO[mxinit]}	Q _ umCOUNT, L0 _ L0.delta2,				c3;		Q _ Q - 1, ZeroBr, L1 _ L1.matexit,			c1;	{Decrement M count}	umCOUNT _ Q, BRANCH[$, mxfinished],			c2;	{Check if multiplication is finished}	Q _ uKinit, L1 _ L1.mxnotfirst,				c3;	rA _ rA + 2, PgCarryBr,					c1;	{Adjust pointer for matrix A}		ukCOUNT _ Q, BRANCH[$, fixrA2],				c2, at[L0.delta2, 4, rAfixed];	{Restore ukCOUNT}	Q _ udeltaB2,						c3;   	rB _ rB - Q, PgCarryBr,					c1;	{Adjust pointer for matrix B}	BRANCH[fixrB2, lmrBdn2],					c2;	GOTO[lmrBdn2],					c2, at[L0.delta2, 4, rBfixed];lmrBdn2:	GOTO[mxinit],						c3;		{============================================================================ EXIT POINT ============================================================================}	 mxfinished:	,							c3;	,							c1;	Xbus _ ib,						c2;	Q _ 4, CALL[RestoreRegsHere],				c3;	at[L1.matexit, 10, RestoreRegsRet],	TOSH _ uTOSH,						c2;	TOS _ uTOS, GOTO[c1.pc2B2],				c3;{******** small mpy  8 bits by 8 bits ******** 	{	TT _  Rx * Q	}	TT _ 0,							c3;		Ybus _ Rx and 1, NZeroBr, GOTO[firstmore],		c1;firstmore:	BRANCH[ftimes0, ftimes1],				c2;ftimes1:	TT _ TT + Q, GOTO[loop],				c3;ftimes0:	Ybus _ Rx, ZeroBr, GOTO[loop],				c3;	loop:	Rx _ RShift1 Rx, SE _ 0, YDisp, BRANCH[more, thru],	c1;more:	Q _ Q + Q, BRANCH[times0, times1, 0D],			c2;times1:	TT _ TT + Q, GOTO[loop],				c3;times0:	Ybus _ Rx, ZeroBr, GOTO[loop],				c3;thru:	,							c2;			inner loop registers:	rA -- Rx	rB -- TOS	rC -- TOSH	nCOUNT -- Q	deltaB0 {+2K} -- TT	remapping routines:	fixrA {+2}	fixrB {+2K}	fixrC {+2}	rB {-2(N-1)(K)+2}	rB {-2(N)(K)+2}	rA for {-2(N-1)}}{******** rA remapping ***********************************}fixrA0:	unCOUNT _ Q, GOTO[fixrAplus],				c3;fixrA1:	GOTO[fixrAminus],					c3;fixrA2:	GOTO[fixrAplus],					c3;rAok:	TT _ udeltaB0, L0Disp,					c3;	ma10:	MAR _ rA _ [rhrA, Q + 0], DISP2[rAfixed],		c1;	{Point to element of matrix A}	Q _ unCOUNT, GOTO[mxrAret], LOOPHOLE[natc],		c2, at[L0.delta0, 4, rAfixed];fixrAplus:	TT _ urAVlo,						c1;	{Load low VA of A into TT}	Q _ 0FF + 1,						c2;	{Prepare to add 1 page}	TT _ TT + Q, CarryBr,					c3;	{Add 1 page, check for carry}fixrAI:	Q _ urAVhi, BRANCH[rAno64p, rA64p],			c1;	{Move high VA of A into Q}rAno64p:	urAVlo _ TT, GOTO[rArhok],				c2;	{No carry, save new low VA of A}rArhok:	rhTT _ Q LRot0,						c3;	{rhTT contains urAVhi}	Map _ [rhTT, TT],					c1;		Q _ rA,							c2;	{Q now contains urAVlo}	rhrA _ rA _ MD, XwdDisp,				c3;	Map _ [rhTT, TT], DISP2[rAfixFlags],			c1;	MDR _ rA or 10, GOTO[rAok],				c2, at[0,4,rAfixFlags];	MDR _ rA or 10, GOTO[rAok],				c2, at[1,4,rAfixFlags];	MDR _ rA or 10, GOTO[rAok],				c2, at[2,4,rAfixFlags];	GOTO[MATpagefault],					c2, at[3,4,rAfixFlags];rA64p:	Q _ Q + 1, GOTO[rA64ch],				c2;	{Propagate carry to H word}									{Q now contains high VA of A}rA64ch:	urAVhi _ Q,						c3;	{Update urAVhi}		GOTO[rAno64p],						c1;fixrAminus:	TT _ urAVlo,						c1;	{Store low VA of A in TT}	Q _ 0FF + 1,						c2;	{Prepare to subtract 1 page}	TT _ TT - Q, CarryBr,					c3;	{Subtract, check for borrow}	Q _ urAVhi, BRANCH[rA64m, rAno64m],			c1;	{Load High VA of A into Q}	rAno64m:	urAVlo _ TT, GOTO[rArhok],				c2;	{No borrow, save new low VA of A}rA64m:	Q _ Q - 1, GOTO[rA64ch],				c2;	{Borrow, subtract high VA of A}	{******* rB remapping ***********************************}fixrB0:	unCOUNT _ Q, GOTO[fixrBplus],				c3;fixrB1:	GOTO[fixrBminus],					c3;fixrB2:	GOTO[fixrBminus],					c3;rBok:	TT _ udeltaB0, L0Disp,					c3;		MAR _ rB _ [rhrB, Q + 0], DISP2[rBfixed],		c1;	Q _ unCOUNT, GOTO[mxrBret], LOOPHOLE[natc],		c2, at[L0.delta0, 4, rBfixed];fixrBplus:	TT _ urBVlo,						c1;	{Load low VA of B into TT}	Q _ 0FF + 1,						c2;	{Prepare to add 1 page}	TT _ TT + Q, CarryBr,					c3;	{Add 1 page, check for carry}fixrBI:	Q _ urBVhi, BRANCH[rBno64p, rB64p],			c1;	{Move high VA of B into Q}rBno64p:	urBVlo _ TT, GOTO[rBrhok],				c2;	{No carry, save new low VA of B}rBrhok:	rhTT _ Q LRot0,						c3;	{rhTT contains urBVhi}	Map _ [rhTT, TT],					c1;	Q _ rB,							c2;	{Q now contains urBVlo}	rhrB _ rB _ MD, XwdDisp,				c3;	Map _ [rhTT, TT], DISP2[rBfixFlags],			c1;	MDR _ rB or 10, GOTO[rBok],				c2, at[0,4,rBfixFlags];	MDR _ rB or 10, GOTO[rBok],				c2, at[1,4,rBfixFlags];	MDR _ rB or 10, GOTO[rBok],				c2, at[2,4,rBfixFlags];	GOTO[MATpagefault],					c2, at[3,4,rBfixFlags];	rB64p:	Q _ Q + 1, GOTO[rB64ch],				c2;	{Propagate carry to H word}								{Q now contains high VA of B}rB64ch:	urBVhi _ Q,						c3;	{Update urBVhi}		GOTO[rBno64p],						c1;fixrBminus:	TT _ urBVlo,						c1;	{Store low VA of B in TT}	Q _ 0FF + 1,						c2;	{Prepare to subtract 1 page}	TT _ TT - Q, CarryBr,					c3;	{Subtract, check for borrow}	Q _ urBVhi, BRANCH[rB64m, rBno64m],			c1;	{Load High VA of B into Q}rBno64m:	urBVlo _ TT, GOTO[rBrhok],				c2;	{No borrow, save new low VA of B}rB64m:	Q _ Q - 1, GOTO[rB64ch],				c2;	{Borrow, subtract high VA of B}	{******* rC remapping ***********************************}fixrC:	unCOUNT{not really} _ Q, GOTO[fixrCplus],		c3;rCok:	L0Disp, 						c3;		MAR _ rC _ [rhrC, Q + 0], DISP2[rCfixed],		c1;	MDR _ unCOUNT, GOTO[mxrCcont],				c2, at[L0.delta0, 4, rCfixed];fixrCplus:	TT _ urCVlo,						c1;	{Load low VA of C into TT}	Q _ 0FF + 1,						c2;	{Prepare to add 1 page}	TT _ TT + Q, CarryBr,					c3;	{Add 1 page, check for carry}fixrCI:	Q _ urCVhi, BRANCH[rCno64p, rC64p],			c1;	{Move high VA of C into Q}rCno64p:	urCVlo _ TT, GOTO[rCrhok],				c2;	{No carry, save new low VA of C}rCrhok:	rhTT _ Q LRot0,						c3;	{rhTT contains urCVhi}	Map _ [rhTT, TT],					c1;	Q _ rC,							c2;	{Q now contains urBVlo}	rhrC _ rC _ MD, XwdDisp,				c3;	Map _ [rhTT, TT], DISP2[rCfixFlags, 1],			c1;	MDR _ rC or 30, GOTO[rCok],				c2, at[1,4,rCfixFlags];	Rx _ rC, GOTO[MATpagefault],				c2, at[3,4,rCfixFlags];rC64p:	Q _ Q + 1, GOTO[rC64ch],				c2;	{Propagate carry to H word}									{Q now contains high VA of C}rC64ch:	urCVhi _ Q,						c3;	{Update urCVhi}	GOTO[rCno64p],						c1;	GOTO[MatUfn], L1 _ L1.matufn,      			c2, at[03, 10, mxcheck1];	GOTO[MatUfn], L1 _ L1.matufn,				c2, at[07, 10, mxcheck1];	GOTO[MatUfn], L1 _ L1.matufn,				c2, at[0B, 10, mxcheck1];	CANCELBR[MatUfn, 7], L1 _ L1.matufn,			c2, at[03, 10, mxcheck2];	CANCELBR[MatUfn, 7], L1 _ L1.matufn,			c2, at[07, 10, mxcheck2];	CANCELBR[MatUfn, 7], L1 _ L1.matufn,			c2, at[0B, 10, mxcheck2];	GOTO[MatUfn], L1 _ L1.matufn,				c2, at[03, 10, mxcheck3];	GOTO[MatUfn], L1 _ L1.matufn,				c2, at[07, 10, mxcheck3];	GOTO[MatUfn], L1 _ L1.matufn,				c2, at[0B, 10, mxcheck3];	CANCELBR[MatUfn, 7], L1 _ L1.matufn,			c2, at[03, 10, mxcheck4];	CANCELBR[MatUfn, 7], L1 _ L1.matufn,			c2, at[07, 10, mxcheck4];	CANCELBR[MatUfn, 7], L1 _ L1.matufn,			c2, at[0B, 10, mxcheck4];MATpagefault:	TOS _ uTOS,						c3;	TOSH _ uTOSH,						c1;	L1 _ L1.LFApf,						c2;	Q _ 0, CALL[RestoreRegsHere],				c3;MatUfn:	,							c3;ufnstop:	TOS _ uTOS,						c1;	TOSH _ uTOSH,						c2;	Q _ 0, CALL[RestoreRegsHere],				c3;	at[L1.matufn, 10, RestoreRegsRet],	GOTO[ufnX32],						c2;	{ E N D }