<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;LispCore>DLionSource>DiskDlionB.mc!1</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 8pt serif">{File name: DiskDlionB.mc<br> Description: Dandelion Disk Controller microcode, Version 2.0<br> Author: D. Davies<br> Created: October 30, 1979<br> Last Edited: November 19, 1979  4:19 PM<br> Last Edited: November 19, 1979  9:09 PM<br> Last Edited: November 21, 1979  2:55 PM, "minimum code" version completed<br> Last Edited: January 9, 1980  8:09 PM, create "transfer run of pages command"<br> Last Edited: February 1, 1980  10:48 AM, complies with standard Dandelion register assignments in Dandelion.df<br> Last Edited: March 14, 1980  11:14 AM, renamed to SA4DiskDlion from DiskDlion so a new version of the<br></span><span class="tab" val="79"></span><span style="font: 8pt serif">microcode may be produced for the SA1000/SA4000 controller.<br> Last Edited: March 18, 1980  10:07 AM, update to Rev D CP board which cancels MDR&larr; following an automatic<br></span><span class="tab" val="79"></span><span style="font: 8pt serif">PgCrossBr.  Extra code now inserted to make sure last word in page is stored anyway.<br> Last Edited: April 11, 1980  1:50 PM, to comply with the new standards for the composite SA1000/SA4000 controller which<br></span><span class="tab" val="79"></span><span style="font: 8pt serif">has longer label fields (code overhead reduced).</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 8pt serif"> Last Edited: April 18, 1980  3:07 PM, take out features that depend on IgnorePgCr.<br> Last Edited: April 30, 1980  11:06 AM, perform combined test on Header Field.<br> Last Edited: May 16, 1980  4:19 PM, add extra delay before Read or Verify on SA1000 drive to account for extra delay<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">after writing a field on that drive.<br> Last Edited: May 22, 1980  3:27 PM, add extra two pattern words for SA1000 drive to account for extra delay added above.<br> Last Edited: June 11, 1980  7:13 PM add extra word to sync pattern for SA4000 drive to try to decrease intermitent errors.<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Decrease length of sync pattern on SA1000 byone word to make room for 10 word labels eventually.<br> Last Edited: June 18, 1980  8:19 PM, modify to work with SA4000HeadDLion.<br> Last Edited: June 25, 1980  12:48 PM, fix ancient Inr bug and delete absolute starting address.<br> Last Edited: June 27, 1980  2:29 PM, fix ancient bug in FinishIOCB.<br> Last Edited: June 30, 1980  4:40 PM, reduce code overhead in an attempt to allow 10 word labels.<br> Last Edited: June 30, 1980  10:29 PM, reduce code overhead further and ensure that read headers and labels are not incremented.<br> Last Edited: July 1, 1980  1:12 AM, show final Sector Count after a transfer command. <br> Last Edited: July 1, 1980  12:46 PM, detect memory error in midst of run of pages.<br> Last Edited: July 2, 1980  9:34 AM, complement KStatus for new HSIO board.<br> Last Edited: July 1, 1980  4:51 PM, split into DiskDlionA.mc and DiskDlionB.mc<br> Last Edited: July 2, 1980  5:30 PM, fix allocation bug in FinishIOCB that might go crazy if 2 IOCBs on chain.<br> Last Edited: July 8, 1980  10:41 PM, turn off interrupts as an experiment.<br> Last Edited: July 9, 1980  12:46 PM, turn them back on, had no effect.<br> Last Edited: July 15, 1980  5:08 PM, increase sync pattern len for SA1000 to try to correct errors with new (Shugart) clock.<br> Last Edited: July 28, 1980  2:47 PM, decrease sync pattern len to try and fit 12 word labels.<br> Last Edited: September 12, 1980  11:03 AM, fix ancient bug than caused "sector count" to be updated during non-transfer<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">commands.<br> Last Edited: October 7, 1980  5:17 PM, tighten code, discard code to detect page cross in an IOCB.<br> Last Edited: October 22, 1980  5:54 PM, take out MDR&larr; not preceeded by MAR&larr;.<br> Last Edited: November 4, 1980  10:57 AM, Trap illegal instructions.<br>Last edited by Jim August 20, 1981  2:20 PM: Fix for new assembler. <br>}<br>{ </span><span style="font: bold 8pt serif">THIS CODE WILL NOT RUN PROPERLY UNLESS DiskDlionInit HAS INITIALIZED REGISTERS U0C00, UMaxSectTst, UStatusMsk and USyncAddrMk!!</span><span style="font: 8pt serif">}<br><br>{ First commands and main body of the TransferRun command in DiskDlionA.mc. }<br><br>{---------------------------  Subroutine used to process a field of a sector  -----------------------------------<br>This subroutine is used to read, write or verify a field in a sector.  Its arguments are:<br> 1) Word Count (~= length of field, definition may change depending on the operation) in UWdCount<br> 2) Control word - the word sent to control the hardware when processing the CRC wd, in RAdr and<br> 3) Buffer address - the location in physical memory of the first word of the buffer for the field to be transferred, in RHRCnt and RCnt.<br>The least significant two bits of the control word define the operation.  These bits are WakeupControl.1 and WriteEnable for the controller, WriteEnable is the LSB.  00 =&gt; Read operation, 10 =&gt; Verify operation, 11 =&gt; Write operation.  The initialization section of the code primes the data word with 0 in case this is a write op, saves the control word used to process the CRC residue and creates the transfer control word (the WriteCRC bit is off).  After this, two branches are taken, one for write, the other for read and verify.  The write code starts writing the PLL synchronization pattern (zeros) immediately, followed by the synchronization word (all ones) or address mark and the data.  A sync word of all ones is used for an SA4000 drive.  The address mark 50A1 is used for the SA1000 Header field, 50A3 is used for the Label and Data fields.  The read and verify code waits until the PLL synchronization pattern is under the read head, then issues the transfer control word to start things up.  The verify operation requires that the first word in the buffer be sent to the hardware before starting so this is done.  The verfiy command uses the inner loop of the write code to write data to the controller to be verified.  The read command has its own inner loop.  When all data has been processed in all three commands, the wait command is sent to cause the CRC word to be processed, then the Freeze command is sent to stop the hardware and the next command is fetched from the IOCB.}<br>TransferField: RAdr &larr; RAdr or UFreezeCmd,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {create the real command word}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UWaitCmd &larr; RAdr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {save control word used for CRC residue}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr and ~CWrCRC,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {create the transfer command}<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UXferCmd &larr; RAdr, YDisp,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {save transfer command, is this a write op?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UFreezeCmd, DISP4[SetupRdVer,0E],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {either start PLO sync pattern or prime for verify.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      make sure microcode wakeup=FirmwareEnable<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      so we can clear the error flags (if Wakeup =<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      SectorFound, ClrKFlags wil abort the Wakeup!).<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      Clear the error flags so a delayed verify error<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      flag from the CRC word of a previously verified<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      field will not give a spurious error indication here}<br><br>{Setup the read and verify operations.  The data separator on the SA4000 requires that the read head be enabled after the beginning of the synchronization pattern.  The controller data separtor for the SA1000 does not care when it is enabled.  The Read and Write microcode process in the same amount of time, so we may derive the position of the read head relative to the sector mark using the current location in the code.  After the branch above, the write routine immediately begins writing the synchronization pattern and determining the address mark or sync word to be written.  One might think delaying one click here would ensure the read head was over the synchronization pattern.  Unfortunately, the position of the read head relative to the executing code is only known to within one click, so a delay of one click gives a real delay of zero to two clicks.  By delaying two clicks here, we guarantee at least a one click delay.  During the delay, the address of the data buffer and the word count are loaded.  Since the verify operation needs to have the first data word ready as soon as the hardware finds the sync word, it is sent to the hardware here.  This action has no effect if this is a read operation.  Finally, the operation is chosen and starts.  The read code adjusts the buffer pointer to point to the first word in the buffer so the first data word will be written properly.  Note the value of word count depends of the operation performed.  For the verify operation, it equals the number of words in the field minus one.  For the Read operation, it equals the number of words in the field.}<br>SetupRdVer:</span><span class="tab" val="67"></span><span style="font: 8pt serif">ClrKFlags,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0E,10,SetupWrt]; {clear error flags (see<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      above)}<br><br>{Wait for the read head to be in position while fetching the word count and adjusting the address so we can subtract in the MAR&larr; below so Cin=0 so we can read a U register.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Noop,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1;<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; UWdCount,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {get word count for read or verify}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {adjust the address now<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      so it will be set up after priming the<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      controller for the verify op,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      yet allows us to subtract below.}<br><br>{Now have waited two clicks, decide what this operation is (read or verify) and prime the controller with the first data word if it&rsquo;s a verify.  Note the start command is sent before the first data word.  This is necessary because the the controller&rsquo;s WriteData register is cleared as long as TransferEnable is lo.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRCnt, RCnt-1], Xbus &larr; UXferCmd, XDisp,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start pre-load and see whether this is a read<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      (X.14=0) or verify (X.14=1).  Note the only<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      legal values for RCnt here are xx15, xx17 and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      xx01.  RCnt will not generate a PgCross for<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      any of these.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UXferCmd, DISP4[StartRd, 0D],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {start the operation and chose the operation}<br><br>{Start the verify operation.  Since the first word hs already been sent, send the control word and test to see if there is any thing to verify}<br>StartVer:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KOData &larr; MD, GOTO[WrtVerLp],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0F,10, StartRd]; {prime controller with first<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      word to be verified AFTER WriteData clear input<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      has been released above.  Start verifying}<br><br>{Start the Read operation.  We sent the control word in this click and will start the next click with a memory reference using the restored buffer pointer.  The controller is frozen with the status a of the CRC word after the buffer is filled.}<br>StartRd:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr-1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0D,10,StartVer]; {do not incr word count<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      to account for sync word read}<br><br>{start the ref to bring in the first data word}<br>StartRdC1:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRCnt, RCnt-1], RCnt &larr; RCnt-1, GOTO[ReadLpC2],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2]; {start read into 1st loc in buffer<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      point to first loc so first data word is<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      written over the sync word or addr mk.}<br><br>{--------  Read Command Inner Loop  -------------}<br>{During each click, a word is read from the disk and written into main memory.  The word count is decremented and if greater than zero, reading continues.  When it reaches zero, we jump to freeze the controller with the final status.  The last MAR&larr; is not used as it is begun in response to the CRC word being read in.}<br>ReadLp:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRCnt, RCnt], RCnt &larr; RCnt+1, BRANCH[ReadLpC2,FinRead], c1; {start mem write cycle}<br>ReadLpC2:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MDR &larr; KIData, WriteOK, CANCELBR[ReadLpC3, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[0,2,FinRead]; {write disk data to mem}<br>ReadLpC3:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr-1, ZeroBr, GOTO[ReadLp],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {dcr word cnt, go start memory cycle,  note<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the WriteOK allows the MDR&larr; to proceed<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       even though the assembler fears a PgCross<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       might be generated.  In fact, this cannot happen<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      because we jump out of the loop before the<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      final increment that would cause the PgCross}<br><br>{Here the controller has the second to last word ready.  The address now points to the last word, so there could not have been a<br>PageCross on the last MAR&larr; so this MDR&larr; will work.  This is all incredibly ugly.}<br>FinRead:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MDR &larr; KIData, WriteOK, CANCELBR[FinReadC3, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[1,2,ReadLpC2]; {store the second to last<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      word in the field}<br>FinReadC3:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; 1, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {set up for branch below}<br><br>{Store the last word using a special MAR&larr; that does not generate a page carry.  This is done so the MDR&larr; will not be cancelled.  This is also used to freeze the controller after the last word.}<br>FinReadLp:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRCnt, RCnt+0], BRANCH[RdLastWd, FreezeRead],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start store of last word}<br>RdLastWd:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MDR &larr; KIData,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[0,2,FreezeRead]; {store field&rsquo;s last word}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr xor RAdr, ZeroBr, GOTO[FinReadLp],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {set up ZeroBr to write last word}<br><br>{Now the controller has just read and checked the CRCword.  Freeze the controller now.}<br>FreezeRead:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UFreezeCmd, pRet4, GOTO[SndFreeze],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[1,2,RdLastWd]; {stop the controller with the<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      proper status and return}<br><br>{-------  Set up Write Command  --------------------}<br>{Each field in a sector begins with 6 words of zeros used by the disk&rsquo;s data separator to lock its PLL, a word of ones or an address mark to define the word boundry, the field&rsquo;s data and a CRC residue word. the first thing this routine does is begin writing the PLL sync pattern.  The controller automatically begins writing a word of zeros.  Because of the controller design, the second word of zeros will actually be being written when the first service request arrives.  Thus to write 6 words of zeros, we send sync words 4 times.  While sending the Sync words, we calculate the address mark or synchronization word to be sent to define the word boundry.  The SA4000 requires a synchronization word of all ones.  The Header field of an SA1000 disk requires an address mark of 50A1 hex.  The Label and data fields of the SA1000 drive need an address mark of 50A3 hex.  After writing the proper sync word or addres mark, we load the word count and start the inner loop to transfer data.  At the end of the transfer, the Wait Command is sent out, causing the CRC word to be written, we wait one click for it to be written, then freeze the hardware.  Finally, the IOCB pointer is reloaded and execution proceeds to fetch the next command.}<br>SetupWrt:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UXferCmd,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0F,10,SetupRdVer]; {send control wd}<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">ClrKFlags, RAdr &larr; 4, GOTO[SyncLpC2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1;  {Clear error flags left over from previous<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      fields (see comment just after TransferField).}<br><br>{loop to write initial word of synchronization pattern, all zeros.  Note the branch cannot be in C1 as that would mean the test would be in C3, but that conflicts with the KOData&larr; there.}<br>SyncLp:</span><span class="tab" val="67"></span><span style="font: 8pt serif">Noop,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,FinSync];<br>SyncLpC2:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr-1, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {dcr sync count}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">KOData &larr; 0, BRANCH[SyncLp,FinSync],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {send sync word, done yet?}<br><br>{Now calculate the sync word or addres mark in the time remaining.  A sync word is used for SA4000 drives and is composed of all 1s.  An address mark is used on SA1000 drives.  The Header field address mark is 51A1&rsquo;X.  An address mark for the Label or Data field is 50A3&rsquo;X.  USyncAdrMk contains either FFFF or 50A1, depending on the drive type.  If the field is Label or Data, this is ORed with a "2".  The result is sent to the controller at the right time, the Word Count is loaded and the inner loop entered.}<br>FinSync:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; UField,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,SyncLp]; {UField=40 =&gt; Header,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      =80 =&gt; Label, =C0 =&gt; Data}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">[] &larr; RAdr+RAdr, PgCarryBr, SuppressTimingWarning,</span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {carry =&gt; Label or Data field being written, so<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      turn on the tag bit}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">KOData&larr;0, BRANCH[SetupHd, SetupLabDat],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {continue sending sync pattern and decide<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      about tag bit}<br><br>{Sending Header Field, so don&rsquo;t insert the "Label or Data" tag}<br>SetupHd:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; 0, GOTO[MakeSyncAdrMk],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,SetupLabDat];<br>{Sending Label or Data field, do insert the "Label or Data" tag bit}<br>SetupLabDat: RAdr &larr; CLabDatTag,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,SetupHd];<br>{Form the Sync word or Address mark by ORing the tag bit in.  Obviously, this has no effect on the Sync word, only on the address mark}<br>MakeSyncAdrMk: RAdr &larr; RAdr or USyncAdrMk,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {compose the sycn wd or addr mark}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">KOData &larr; RAdr LRot0,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {Lo and behold, now its time to send it, so<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      do so}<br><br>{Start the first memory reference and load the word count before jumping into the inner loop}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRCnt, RCnt], RCnt &larr; RCnt+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start read of first word from memory}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; UWdCount, CANCELBR[InitWrtC3, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {get word count}<br>InitWrtC3:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KOData &larr; MD, RAdr &larr; RAdr-1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {decrement it for the word just sent to the<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      disk and enter the inner loop}<br><br>{--------------  inner loop for write and verify operations  ------------------ }<br>{In each cycle, read a word fromthe buffer and write it to the disk. }<br>WrtVerLp:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRCnt, RCnt], RCnt &larr; RCnt+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,FinWrtVer]; {start mem read}<br>WrtVerLpC2:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr-1, ZeroBr, CANCELBR[WrtVerLpC3, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2;  {dcr word ct, done yet?}<br>WrtVerLpC3:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KOData &larr; MD, BRANCH[WrtVerLp, FinWrtVer],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {send data to controller, quit if done}<br><br>{Done writing or verifying data, send wait command.  Either 2 or 3 repetitions of the Wait command are to be sent.  Two repititions are sufficient if the SA4000 drive is connected or a verify operation is in progress.  The controller has hardware to hold the write enable signal whilel the SA4000data separator grinds out the CRC word.  It does not seem to be effective when using lthe SA1000 drive.  Un fortuately, there is no time to wait the extra word when using the SA4000 drive, so thecases cannot be consistent.  One should not wait when executing a verify operation as the CRC word would pass by and its status would be lost.  Hence, we test to see if both this is a write operations and we are connected to the SA1000 disk before delaying an extra click.}<br>FinWrtVer:</span><span class="tab" val="67"></span><span style="font: 8pt serif">Xbus &larr; UWaitCmd, XDisp,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,WrtVerLp]; { Is this a write operation?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr+1, Xbus &larr; KStatus, XwdDisp, BRANCH[FinVerify, FinWrite, 0E], c2; {loop ctr &larr; 1, is the SA1000 connected?}<br><br>FinVerify:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UWaitCmd, CANCELBR[SndWait, 0F],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0, 2, FinWrite]; {Verify op, process the CRC<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       word and start waiting}<br>FinWrite:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UWaitCmd, BRANCH[SA1Wait, SA4Wait, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[1,2, FinVerify]; {Write op, process the CRC<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      word and decide whether to wait an extra click}<br><br>SA1Wait:</span><span class="tab" val="67"></span><span style="font: 8pt serif">GOTO[SndWaitC2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2, SA4Wait]; {connected to SA1000, wait<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      an extra clock by not decrementing loop ctr}<br>SA4Wait:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr-1, NegBr, GOTO[SndWaitC2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2, SA1Wait]; {connected to SA4000, loop<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       ctr  &larr; 0 so executes SndWaitC3 only once.}<br><br>SndWait:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr-1, NegBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0F,10]; {have enough clicks passed yet?}<br>SndWaitC2:</span><span class="tab" val="67"></span><span style="font: 8pt serif">BRANCH[SndWaitC3, SndFreeze], pRet4,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {set up return in case and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">     decide whether to stop controller now}<br>SndWaitC3:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UWaitCmd, CANCELBR[SndWait, 0F],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[2,4,SndFreeze];  {have controller  verify<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      or write CRC word or wait until it is done.}<br><br>{Now stop the hardware and return.  The Read routine joins the flow here with a CANCELBR[SndFreeze,2]}<br>SndFreeze:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UFreezeCmd, RET[HeaderRet],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[3,4,SndWaitC3]; {stop the hardware and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      return.   Note that during a write operation the<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      last 4 bits of the CRC may still be in the SA4000&rsquo;s<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      data separator.  They will not be lost because<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the WriteEnable seen by the disk is delayed<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      by 5 bit times.}<br><br><br>{</span><span style="font: italic 8pt serif">Finish IOCB<br></span><span style="font: 8pt serif">This command is used to finish up an IOCB.  It posts the final status, interrupts a Mesa process and either goes to the dormant state or continues processing with the next IOCB.  The command word is followed by the 16 bit virtual address link to the next IOCB in the chain (the link is 0 if this is the last IOCB), a 16 bit mask used to interrupt a Mesa process ,the command used to turn off the hardware if IOCB processing is to stop now and the address (lo 16 bits thereof) of the status location in the IOCB.  The first action taken is to fetch and store the arguments to the command.  Then we replace the HeadSelected field in the status received from the hardware with the Field number now in UField.  This allows the Mesa processing to determine the number of the last field processed.  The error bits from the hardware are then replaced with the error bits left from the last Test Status command or those fro the last Transfer Run of Pages command, whichever came last.  The Sector Found bit is left from the original device status if the controller is connected to an SA4000.  If connected to an SA1000, this bit is masked off as it would be set only if a Header field was sought but not found.  It is assumed the SA4000HeadDLion head will have preceeded the Finish IOCB command with either a Test Status , Transfer or Initializer Registers command so as to eliminate irrelevant error flags.  Next, three conditions are tested.  If either there was a memory error during the IOCB, any errors were detected or the link to the next IOCB is nil, the FirmwareBusy flag is cleared in the final status.  If none of these conditions are true, is is set there.  This is used by the Device Head to decide whether the microcode will continue or stop.  If a new IOCB was added to the chain, the Device Head can determine whether the microcode saw it and if not, the Head can restart the microcode.  After the final IOCB status has been posted, the interrupt mask is used to set the interrupt flags, causing the Head to receive an interrupt from the emulator.  Finally, based on whether the FirmwareBusy flag was set or not, the microcode either issues the stop control word found as the second to last argument to this command and goes to the dormant state or it goes to map the virtual IOCB address given to a real IOCB address and continue with the next IOCB.}<br>{fetch the Mesa interrupt mask from the argument list}<br>FinishIOCB:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr], RAdr &larr; RAdr+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0E,10,Inr]; {start fet and point to stop<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      command}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UNxtIOCBLnk &larr; RCnt, CANCELBR[$, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {save link to next IOCB, was fetched as<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      part of command fetch.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; MD,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get mesa interrupt mask}<br><br>{fetch the stop command from the argument list}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr], RAdr &larr; RAdr+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {Start fet and point to status addr}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UInterruptMsk &larr; RCnt, CANCELBR[$, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {save Mesa interrupt mask}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; MD,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get stop command}<br><br>{finally, fetch the address of the IOCB status word}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr+0],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start fet of last word in IOCB}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UFreezeCmd &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {Save stop command}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; MD,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get phys addr of status, hold in RAdr}<br><br>{Decide whether to store the final sector count.  this should be done only if there was a transfer operation in the IOCB.  If not, trust the Head to put an "Initialize" op in the IOCB.  Hence, UField will be CIOCBDone &lt;=&gt; There was no transfer.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; CIOCBDone,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {get valuse used to test}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">[] &larr; RCnt xor UField, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {did a transfer? Zero =&gt; no}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; USectorCntAddr, BRANCH[StoSectCnt, ComposeStat],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get addr of sector count in case and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      decide.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif"><br>{Store the final count of sectors left to process.  This will be zero if there were no errors.}<br>StoSectCnt:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RCnt+0],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,ComposeStat]; {Start store of final<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      sector count, note it&rsquo;s on same page as<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      final status since all in same IOCB.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MDR &larr; USectorCount,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {store it}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Noop,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3;<br><br>{clear spurious error flags from the current status and combine it with the masked status.  This will make up a major portion of the final status word.}<br>ComposeStat: RCnt &larr; ~UStatusMsk,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,StoSectCnt]; { get raw hardware status}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt and ~KStatus,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {clear the HeadSelected field so the number of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the current field may be inserted there. also clear<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the FirmwareBusy bit and the SA1000/SA4000<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      bit.  If this is an SA1000, clear the HeaderTag bit.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt or UStatus,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {combine hardware and masked status to form<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      most of proper status word.}<br>{now fetch the current Field number so it can be OR&rsquo;ed in.  It contains the number of the current field being processed in the sector.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt LRot8,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {swap bytes to get at HeadSelected field}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt or UField,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {insert field number in to status}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt LRot8,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {Re-align the hardware status}<br> <br>{There are three tests that must be passed for FirmwareBusy to be set in the status word, there must have been no memory error, no processing errors and the Next IOCB link may not be null.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Xbus&larr;MStatus, XDisp,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {test for memory error}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Ybus &larr;  UStatus , NZeroBr, DISP4[MemOK,7],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {Test status word, was there a memory error?}<br><br>MemError:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt or CMemError, CANCELBR[LastIOCB, 1],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0F, 10, MemOK]; {mem failed, set flag,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      make sure Branch at AnotherICOB goes to <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      ResetFirmwareBusy and quit}<br>MemOk:</span><span class="tab" val="67"></span><span style="font: 8pt serif">Ybus &larr; UNxtIOCBLnk, ZeroBr,BRANCH[AnotherIOCB, LastIOCB],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[7,10,MemError]; { test the next ICOB link<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       and decide whether ther were processing errors}<br><br>{There was either a memory or processing error so just start the memory cycle for the write of the status, leave FirmwareBusy cleared.}<br>LastIOCB:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr+0], CANCELBR[ResetFirmwareBusy,1],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,AnotherIOCB]; {start store of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      final Status, no more IOCBs to be executed.}<br>{Had no memory or processing errors, may not be another ICOB though.  Start the memory write cycle to set the IOCB status decide whether to set FirmwareBusy or not..}<br>AnotherIOCB: MAR &larr; [RHRAdr, RAdr+0], BRANCH[SetFirmwareBusy, ResetFirmwareBusy], c1, at[0,2,LastIOCB];<br><br>ResetFirmwareBusy: MDR &larr; RCnt, RHRAdr &larr; 0, GOTO[GetIntrMask],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[1,2,SetFirmwareBusy]; {this is the Last<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      IOCB to be done now,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      update final status andsave totest later}<br>SetFirmwareBusy: MDR &larr; RCnt +0FF+1, RHRAdr &larr; 0FF,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[0,2,ResetFirmwareBusy]; {Continue on after<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      this ICOB with the next one -  set Firmware Busy<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      in the saved status and in a bit to be tested<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      below.}<br><br>{In either case, write the final status to the IOCB and save it so we can test it after sending the Mesa Interrupt}<br>GetIntrMask:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UInterruptMsk,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get mesa interrupt mask}<br><br>{In one </span><span style="font: italic 8pt serif">atomic</span><span style="font: 8pt serif"> operation, set the interrupt mask}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr&larr; uWP,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {get the emulator&rsquo;s mask}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr or RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {or in the new interrupt flags}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">uWP &larr; RAdr, MesaIntRq,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {Update the mask for the emulator and notify<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       emulator its been changed}<br><br>{Will another IOCB be processed or do we quit now?  If FirmwareBusy (now in RHRAdr.7) is 0, quit.  Otherwise proceed.  Quitting is done by writing the control word following the Mesa interrupt mask to the controller and jumping to the Dormant state.  Proceeding is done by loading the virtual link address into RAdr and going to map it to a real address.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">[] &larr; RHRAdr, XDisp,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {Test FirmwareBusy}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RHRAdr &larr; 0, DISP4[QuitNow,0E],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {IOCB virt addr has high bits=0}<br><br>{Quit after this IOCB}<br>QuitNow:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UFreezeCmd, GOTO[GetCSB],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0E,10,QuitNow]; {stop hardware and go<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      dormant}<br><br>{Proceed with next IOCB in the chain}<br>GetNextIOCB: RAdr &larr; UNxtIOCBLnk, GOTO[NewIOCB],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0F,10,QuitNow]; {get virtual addr of new IOCB<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      and go map it}<br><br>{this is a command used to set  the UStatus register with the current status and the UField register to a known value (CIOCBDone).  This command is used to ensure a valid, non-zero status when a tranfer operation was not performed.}<br>InitRegs:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt and ~KStatus,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0F,10, Inr];<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UStatus &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2;<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; CIOCBDone,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3;<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UField &larr; RAdr, GOTO[FinLdReg],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {This also load CIOCBDone into<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      UHeaderQuitMsk, but that should be ok.}<br><br><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
