{File name QdlNewLisp.mc}SetTask[0];{******************************************************************	READFLAGS*******************************************************************}READFLAGS:	Xbus _ TOSH xor smallpl, NZeroBr,	c1, opcode[161'b]; {71}	rhTT _ TT _ TOS LRot8, BRANCH[$, rdfUfn],	c2;	TOSH _ smallpl,	c3;	Map _ [rhTT, TT],	c1;	TOS _ 60, L2 _ L2.0,	c2;	TOS _ MD and TOS, XRefBr,	c3;	TOS _ TOS LRot8, BRANCH[rmNoRef, rmRef],	c1;rmNoRef:	TOS _ TOS RShift1, SE_0, IBDisp, GOTO[DNI.pc1],	c2;rmRef:	TOS _ TOS RShift1, SE_1, IBDisp, GOTO[DNI.pc1],	c2;rdfUfn:	Rx _ 161'b, GOTO[ufn1],	c3;{******************************************************************	READRP*******************************************************************}READRP:	Xbus _ TOSH xor smallpl, NZeroBr,	c1, opcode[162'b];	rhTT _ TT _ TOS LRot8, BRANCH[$, rdrpUfn],	c2;	TOSH _ smallpl,	c3;	Map _ [rhTT, TT],	c1;	TOS _ ~0F0, L2 _ L2.0,	c2;	TOS _ MD and TOS,	XDirtyDisp, c3;	PC _ PC + PC16, BRANCH[$, rrpi, 1],	c1;	IBDisp, GOTO[rrpj],	c2;rrpi:	TOS _ TOS + 0F + 1, IBDisp, GOTO[rrpj],	c2;rrpj:	TOS _ TOS LRot8, L2 _ L2.0, DISPNI[OpTable],	c3;rdrpUfn:	Rx _ 162'b, GOTO[ufn1],	c3; {******************************************************************	WRITEMAP*******************************************************************}WRITEMAP:   {vp, rp, flag => vp}	MAR _ [rhS, S], S _ S -1,	c1, opcode[163'b];{73}	Ybus _ TOSH xor smallpl, NZeroBr, CANCELBR[$, 2],	c2;	Rx _ MD{rp}, BRANCH[$, ufnWM0],	c3;	MAR _ [rhS, S + 0],	c1;	S _ S -1, 	c2;	Q _ MD{rpH},	c3;	MAR _ [rhS, S], S _ S -1,	c1;	Ybus _ Q xor smallpl, NZeroBr, CANCELBR[$,2],	c2;	TT _ MD{vp}, BRANCH[$, ufnWM1],	c3;	MAR _ [rhS, S+0], L2 _ L2.0,	c1;	Rx _ Rx LRot8,	 XRefBr{>2mb}, c2;	Q _ MD{vpH},	BRANCH[$, wmi], c3;		Noop, GOTO[wmj],	c1;wmi:	Rx _ Rx or 80, GOTO[wmj],	c1;wmj:	Ybus _ Q xor smallpl, NZeroBr,	c2;	rhTT _ TT _ TT LRot8, BRANCH[$, ufnWM2],	c3;	S _ S -1, Xbus _ TOS LRot4, XDisp,	c1;	Rx _ Rx and ~070, DISP4[wmf, 4],	c2;	Rx _ Rx or 0, GOTO[wMap],	c3, at[4, 10, wmf];	Rx _ Rx or 10, GOTO[wMap],	c3, at[0C,10,wmf];	Rx _ Rx or 20, GOTO[wMap], 	c3, at[5, 10, wmf];	Rx _ Rx or 30, GOTO[wMap],	c3, at[0D,10,wmf];	Rx _ Rx or 40, GOTO[wMap],	c3, at[6, 10, wmf];	Rx _ Rx or 50, GOTO[wMap],	c3, at[0E,10,wmf];	Rx _ Rx or 60, GOTO[wMap],	c3, at[7, 10, wmf];	Rx _ Rx or 70, GOTO[wMap], {reserved}	c3, at[0F,10,wmf];wMap:	Map _ [rhTT, TT],	c1;	MDR _ Rx, PC _ PC + PC16, IBDisp,	c2;	TOS _ TT LRot8, L2 _ L2.0, DISPNI[OpTable],	c3;ufnWM0:	S _ S+1, GOTO[ufnX2],	c1;ufnWM1:	S _ S+3, GOTO[ufnX2],	c1;ufnWM2:	S _ S+3, GOTO[ufnX2],	c1;{******************************************************************}PFault:	, at[BBFault],	rhRx _  INTERFACEspace, 	c1;	Rx _ INTERFACEbasePage{20'b}{INTERFACEbase=10000'b},	c2;	Rx _ Rx LRot8, GOTO[PFaultcont],	c3;{******************************************************************}{% SHOULD CHECK IF ANY PENDING INTERRUPTS - CURRENTLY MAY MISS KEYSTROKES }opcode[176'b],{7E}	Ybus _ TOS xor FAULTFXP, ZeroBr{faultExit}, L2_ 0{NotInCall},	c1;	Rx_ TOS, BRANCH[$,  SwFault],	c2;	TOSH _ 0, CANCELBR[ConJn],	c3;SwFault:	TOSH _ 0,	c3;ConJn:	uWDC _ TOSH, PC_ PC + PC16 {advance PC}, GOTO[PuntFor2],	c1;{note that this code winds up storing the context number on the stack and thensetting the no-push bit in the frame. This is not exactly the same as the Dorado, but no code relies on the value returned "to" a context}{******************************************************************}MidPuntmar:	MAR _ [rhTT, Q + 0],	c1;	MDR{next} _ PV, Rx _ Rx{punt}-1, ZeroBr{KeyFXP},	c2;	PV _ MD, BRANCH[RTN2, RTN2K],	c3;{******************************************************************}	{ E N D }