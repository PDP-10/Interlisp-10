<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>PixelBltB0.mc!1</title>
  </head>
  <body>
    <pre>
{File name : PixelBltB0.mcAuthor : Gwan Santosa &amp; Don CharnleyDate : 20-Sep-85 10:37:24Original design by : Don CharnleyDate : 18-Mar-85 11:58:22	combine the source and dest pixel-maps together	using the Combine Array as follows:		It is page alligned!		The Combine Array is 256 entries of 4 nibl's each		It is addressed by the source nibl value		concatenated with the dest nibl value		the dest nibl is replaced with the following nibl:			(dstX even, dstY even) &larr; entry[0]			(dstX odd, dstY even) &larr; entry[1]			(dstX even, dstY odd) &larr; entry[2]			(dstX odd, dstY odd) &larr; entry[3]	This allows texturing, which increases the effective	number of "colors" beyond 16.	called with the following parameters:		S-16	Combine Array:  {pointer - page alligned!!}		S-14	Source BitMap: {BitMap}		S-12	Source X: {of "transfer area" upper left pixel}		S-10	Source Y: {of "transfer area" upper left pixel}		S-8	Dest BitMap: {BitMap}		S-6	Dest X: {of "transfer area" upper left pixel}		S-4	Dest Y: {of "transfer area" upper left pixel}		S-2	Transfer width: {smallp - pixels}		S-0	Untransfered width: {smallp - pixels / 0 on initial call}		tos	Transfer height: {smallp - lines}	"BitMap" is a six word record of the following format:	0:	BitMapBaseHi -- High word of Virtual Addr of [X = 0, Y = Height - 1] of BitMap {upper left screen corner}	1:	BitMapBaseLo -- Low word of Virtual Addr of [X = 0, Y = Height - 1] of BitMap {upper left screen corner}	2:	BitMapRasterWidth {words}	3:	BitMapHeight {lines}	4:	BitMapWidth {bits}	5:	BitMapBitsPerPixel {1 or 4 or 8} 4 = nibl	inner loop looks like the following:	for each dest nibl:		get next source nibl{4 bits}		get next dest nibl{4 bits}		Vals &larr; CombineArray[srcnibl,,dstnibl]{16 bits}		newDstNibl &larr; Vals[2*(dstY mod 2) + (dstX mod 2)]{4 bits}		replace dest nibl with newDstNibl	registers and links	Srclink -- {0, 1, 2, 3} which src nibl, used to know when to refill	Dstlink -- {0, 1, 2, 3} which dst nibl, used to know when to refill	Loclink -- {0, 1, 2, 3} which nibl of entry desired	Share Dstlink and Loclink using three bits [dY mod 2, which dst nibl]	SrcReg -- holds unprocessed src nibls	DstReg -- holds partially processed dst nibls {old and new}	DN -- temp dst nibl for lookup {=Q, in the inner loop}	rSAddr -- address of current src word	rDAddr -- address of current dst word	rArray -- real address of array	entry -- temp for array index and value {=Rx, in the inner loop}	pixelcount -- number of pixels remaining	Perform the operation from the bottom up, so that only the number of lines	and tos-1 need to be updated in case of page fault or interrupt	if page fault from within a line, save pixel count in tos-1	initialize:		read stack parameters		save regs		calculate links: src start nibl, dst start nibl, (dst Y mod 2)		calculate number of dest pixelsLINE:	fetch first dest word, and allign in DstReg		fetch first source word and allign in SrcReg	enter loop		loop till line finished		write last dest word	refill:		update number of lines remaining, exit if done		test for interrupts		update src and dest virtual addresses		reload src start nibl, dst start nibl, (dst Y mod 2)		GOTO[LINE]RegDef[SrcReg, R, 3]; {=PV}RegDef[DstReg, R, 5]; {=PC}RegDef[rSAddr, R, 0]; {=TOS}RegDef[rhSAddr, RH, 0]; {=rhTOS}RegDef[rDAddr, R, 1]; {=TOSH}RegDef[rhDAddr, RH, 1]; {=rhTOSH}RegDef[rArray, R, 4]; {=S}RegDef[rhArray, RH, 4]; {=rhS}Stored in NewFuncDef.dfn}{==============================================================================================Fetch stack parameters==============================================================================================@PIXELOP:	opcode[305'b],	Bank &larr; PIXELBank, 			c1; This section is stored in LispPixelBltB1.mc	uTOS &larr; TOS,				c2;	uTOSH &larr; TOSH, CROSS[PIXEL],		c3;	at[PIXEL],	Xbus &larr; ibNA, XDisp,			c1; This section is stored in LispPixelBltB0.mc	DISP4[PIXELDISP], 			c2;}	uS &larr; S,					c3, at[00, 10, PIXELDISP];	NNBOP:	MAR &larr; [rhS, S - 1],					c1; {Point to UnTrnWidthHi}	Ybus &larr; TOSH xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check if transfer height not NIL}	Q &larr; MD,	BRANCH[NBTE3, $],				c3;		MAR &larr; [rhS, S + 0],				c1; {Point to UnTrnWidthLo}	S &larr; S - 2, L1 &larr; L1.NoFixesB0,			c2;	TT &larr; MD,					c3;	MAR &larr; [rhS, S -1],				c1; {Point to TrnWidthHi}	Ybus &larr; Q xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check if UnTrnWidth not NIL}	Q &larr; MD,	BRANCH[NBTE1, $],			c3;		MAR &larr; [rhS, S + 0],				c1; {Point to TrnWidthLo}	S &larr; S - 2, 					c2;	Rx &larr; MD,					c3;		Ybus &larr; Q xor smallpl, ZeroBr,			c1; {Check if transfer width not NIL}	uUnTrnWidthLo &larr; TT, ZeroBr, BRANCH[NBTE2, $],	c2;	uTrnWidthLo &larr; Rx, ZeroBr, BRANCH[WNZ, WZ],	c3; {Check TrnWidth}	WZ:	BRANCH[GOTR1, NOTR1],				c1; {In between lines case}GOTR1:	upixelcount &larr; Rx,				c2; {Load number of pixel per line}	uXoffset &larr; 0, GOTO[NFM],			c3; {X offset = 0}				WNZ:	upixelcount &larr; TT, BRANCH[GOTR2, NOTR2],		c1; {Load number of pixel left}GOTR2:	Rx &larr; Rx - TT, CarryBr,				c2; {Calculate X offset}	uXoffset &larr; Rx, BRANCH[NOTR4, $],      		c3; 	NFM:	MAR &larr; [rhS, S -1],				c1; {Point to DstYHi}	uTrnHeightLo &larr; TOS, CANCELBR[$, 2], ZeroBr,	c2; {Check if transfer height is 0}	Q &larr; MD, BRANCH[$, NOTR3],			c3;		MAR &larr; [rhS, S + 0],				c1; {Point to DstYLo}	S &larr; S - 2, L3 &larr; 1,				c2;	Rx &larr; MD,  					c3;		MAR &larr; [rhS, S -1], 				c1; {Point to DstXHi}	Ybus &larr; Q xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check if Dst Y not NIL}	Q &larr; MD,	BRANCH[NBYE1, $],			c3;		MAR &larr; [rhS, S + 0], 				c1; {Point to DstXLo}	Ybus &larr; Q xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check if Dst X not NIL}	TT &larr; MD, BRANCH[NBXE1, $],			c3;		L2 &larr; L2.FETCHBM.01,				c1;	S &larr; S - 2,					c2;	uDstXLo &larr; TT,					c3;		MAR &larr; [rhS, S -1], 				c1; {Point to DstBITMAPHi}	uDstYLo &larr; Rx, CANCELBR[$, 2],			c2;	Rx &larr; MD,					c3;		MAR &larr; [rhS, S + 0],				c1; {Point to DstBITMAPLo}	S &larr; S + 8, 					c2;	TT &larr; MD, CALL[GetTestBMParamsB0],		c3;		S &larr; S - 10'd, 					c3, at[L2.FETCHBM.01, 10, GetTestBMParamsB0Ret];	PXBK1:	MAR &larr; [rhS, S -1], 				c1; {Point to SrcYHi}	Ybus &larr; Q xor 4, CANCELBR[$, 2], ZeroBr,		c2; {Check if 4 bits per pixel bitmap}	Q &larr; MD,	BRANCH[NBPXE1, $],			c3;		MAR &larr; [rhS, S + 0],				c1; {Point to SrcYLo}	S &larr; S - 2, L1 &larr; L1.NoFixesB0,			c2;	TT &larr; MD,					c3;		MAR &larr; [rhS, S -1], 				c1; {Point to SrcXHi}	Ybus &larr; Q xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check if Src Y not NIL}	Q &larr; MD,	BRANCH[NBYE2, $],			c3;		MAR &larr; [rhS, S + 0], L3 &larr; 0,			c1; {Point to SrcXLo}	Ybus &larr; Q xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check if Src X not NIL}	Rx &larr; MD, BRANCH[NBXE2, $],			c3;		S &larr; S - 2,					c1;	uSrcXLo &larr; Rx,					c2;	uSrcYLo &larr; TT,					c3;		MAR &larr; [rhS, S -1], 				c1; {Point to SrcBITMAPHi}	CANCELBR[$, 2],					c2;	Rx &larr; MD,					c3;		MAR &larr; [rhS, S + 0], L2 &larr; L2.FETCHBM.00, 	c1; {Point to SrcBITMAPLo}	S &larr; S + 14'd, 					c2;	TT &larr; MD, CALL[GetTestBMParamsB0],		c3;		S &larr; S - 16'd,					c3, at[L2.FETCHBM.00, 10, GetTestBMParamsB0Ret];	PXBK2:	MAR &larr; [rhS, S -1], 				c1; {Point to CmbARRAYHi}	Ybus &larr; Q xor 4, CANCELBR[$, 2], ZeroBr,		c2; {Check if 4 bits per pixel bitmap}	Q &larr; MD,	 BRANCH[NBPXE2, $],			c3;		MAR &larr; [rhS, S + 0],				c1; {Point to CmbARRAYLo}	rhTT &larr; Q LRot0, 				c2; {Set up high VA of color table}	TT &larr; MD,					c3; {Set up low VA of color table}		Map &larr; [rhTT, TT + 0], L1 &larr; L1.NoFixesB0,	c1;	S &larr; S + 16'd, L0 &larr; L0.RMAPB0.1,			c2;	rhRx &larr; Rx &larr; MD, XRefBr,				c3;	PXBK4:	BRANCH[NBCH3, $],				c1, at[L0.RMAPB0.1, 10, RMapFixCallerB0];	Q &larr; uBITMAPHEIGHT, L1 &larr; L1.RegSaveRet.1,	c2; {Save registers}		rhArray &larr; Rx LRot0, CALL[SaveAllRegsB0],	c3; {Load the real address of color table}{==============================================================================================Check boundaries==============================================================================================}PXBK3:	rArray &larr; Rx,				c1, at[L1.RegSaveRet.1, 10, SaveRegsB0Ret];	TT &larr; uSrcYLo, 				c2; {Check 1st Y of Src}		Ybus &larr; Q - TT - 1, CarryBr,		c3;PXBKE:	TT &larr; TOS + TT, BRANCH[NBE1, $],		c1; {TOS = TrnHeight}	Ybus &larr; Q - TT, CarryBr,			c2; {Check 2nd Y of Src}	TT &larr; uDstYLo, BRANCH[NBE2, $],		c3; {Load Y Dst}		Q &larr; uDBitMapHeight,			c1;	Ybus &larr; Q - TT - 1, CarryBr,		c2; {Check 1st Y of Dst}	TT &larr; TOS + TT, BRANCH[NBE3, $],		c3;		Ybus &larr; Q - TT, CarryBr,			c1; {Check 2nd Y of Dst}	Q &larr; uSrcXLo, BRANCH[NBE4, $],		c2; {Load X Src}	TT &larr; RShift1 uBITMAPWIDTH, SE &larr; 0, 	c3; {Divide Src Bitmapwidth by 4}		TT &larr; RShift1 TT, SE &larr; 0,		c1;	Ybus &larr; TT - Q - 1, CarryBr,		c2; {Check 1st X of Src}	Rx &larr; uTrnWidthLo, BRANCH[NBE5, $],	c3;		Q &larr; Q + Rx,						c1;	Ybus &larr; TT - Q, CarryBr,					c2; {Check 2nd X of Src}	TT &larr; RShift1 uDBitMapWidth, SE &larr; 0, BRANCH[NBE6, $],	c3; {Divide Dst Bitmapwidth by 4}		TT &larr; RShift1 TT, SE &larr; 0,		c1;	Q &larr; uDstXLo,				c2;	Ybus &larr; TT - Q - 1, CarryBr,		c3; {Check 1st X of Dst}		Rx &larr; Q + Rx, BRANCH[NBE7, $],		c1;	Ybus &larr; TT - Rx, CarryBr,		c2; {Check 2nd X of Dst}	Q &larr; uDstYLo, BRANCH[NBE8, $],		c3;		LINE:	Q &larr; Q + TOS, L0 &larr; L0.MUL.02,		c1;	Rx &larr; uDBitMapHeight,			c2;	Q &larr; Rx - Q,				c3;		TOS &larr; uDBRasterWidth, CALL[MTPLB0],	c1; {Calculate Y*Bitmaprasterwidth of Dst}	Rx &larr; uDstYLo,			c3, at[L0.MUL.02, 10, MULCALLERB0];		TOS &larr; uTrnHeightLo,		c1;	TOS &larr; TOS - 1,			c2;	TOS &larr; TOS + Rx,			c3;		TOS &larr; TOS LShift1, SE &larr; 0,	c1;		PV &larr; TOS LShift1, SE &larr; 0,	c2; {Multiply Y by 4}	Rx &larr; uDstXLo,			c3;		Noop,				c1;	TOS &larr; uXoffset,			c2;	Rx &larr; Rx + TOS,			c3; {Calculate the starting X for Dst}		Rx &larr; Rx and 03,			c1;	Noop,				c2;		PV &larr; PV + Rx, YDisp,		c3;			Rx &larr; uDstXLo, DISP4[L3VAL, 8],	c1; 		Rx &larr; Rx + TOS, L3 &larr; 00,		c2, at[08, 10, L3VAL];		GOTO[DSCO],			c3; {Current YXX = 000}		Rx &larr; Rx + TOS, L3 &larr; 01,		c2, at[09, 10, L3VAL];		GOTO[DSCO],			c3; {Current YXX = 001}	Rx &larr; Rx + TOS, L3 &larr; 02,		c2, at[0A, 10, L3VAL];		GOTO[DSCO],			c3; {Current YXX = 010}	Rx &larr; Rx + TOS, L3 &larr; 03,		c2, at[0B, 10, L3VAL];		GOTO[DSCO],			c3; {Current YXX = 011}	Rx &larr; Rx + TOS, L3 &larr; 04,		c2, at[0C, 10, L3VAL];		GOTO[DSCO],			c3; {Current YXX = 100}	Rx &larr; Rx + TOS, L3 &larr; 05,		c2, at[0D, 10, L3VAL];		GOTO[DSCO],			c3; {Current YXX = 101}	Rx &larr; Rx + TOS, L3 &larr; 06,		c2, at[0E, 10, L3VAL];		GOTO[DSCO],			c3; {Current YXX = 110}	Rx &larr; Rx + TOS, L3 &larr; 07,		c2, at[0F, 10, L3VAL];		GOTO[DSCO],			c3; {Current YXX = 111}	DSCO:	Rx &larr; RShift1 Rx, SE &larr; 0,		c1; {Divide X by 4}	Rx &larr; RShift1 Rx, SE &larr; 0,		c2;		Q &larr; Rx + Q, CarryBr,			c3;				Rx &larr; uDBMBaseLo, BRANCH[NBNA1, NBA1],	c1; {Load low word of base VA of Dst bitmap}	NBA1:	TT &larr; TT + 1, GOTO[NBCM1],		c2; {Propagate carry to high word}NBNA1:	Noop,					c2;NBCM1:	Rx &larr; Rx + Q, CarryBr,			c3; {Set up low word of VA of Dst bitmap}    	Q &larr; uDBMBaseHi, BRANCH[NBNA2, NBA2],	c1; {Load high word of base VA of Dst bitmap}	NBA2:	TT &larr; TT + 1, GOTO[NBCM2],		c2; {Propagate carry to high word}NBNA2:	Noop,					c2;NBCM2:	Q &larr; TT + Q, 				c3;	rhTT &larr; Q LRot0,				c1; {Set up high word of VA of Dst bitmap}		urhDAddr &larr; Q,				c2; {Save it}	urDAddr &larr; Rx,				c3;	PXBK5:	Map &larr; TT &larr; [rhTT, Rx], L1 &larr; L1.TrapFixesB0.3,	c1;	TOS &larr; uBITMAPRASTERWIDTH, L0 &larr; L0.WMAPB0.0,	c2; {Save low word of VA for remapping}	rhRx &larr; Rx &larr; MD, XwdDisp,			c3;	PXBK6:	MAR &larr; Q &larr; [rhRx, TT + 0], DISP2[NBCH1],	c1, at[L0.WMAPB0.0, 10, WMapFixCallerB0];	rDAddr &larr; Q,				c2, at[1, 4, NBCH1]; {Save the low word of real address}	DstReg &larr; MD,				c3; {Fetch Dst}		rhDAddr &larr; Rx LRot0,		c1; {Save the high word of real address}		Q &larr; uSrcYLo, L0 &larr; L0.MUL.01,	c2;	TT &larr; uTrnHeightLo, 		c3;		Rx &larr; uBITMAPHEIGHT,		c1;	Q &larr; TT + Q,			c2;	Q &larr; Rx - Q,			c3;		CALL[MTPLB0],			c1; {Calculate Y*Bitmaprasterwidth of Src}		TOS &larr; uSrcXLo,			c3, at[L0.MUL.01, 10, MULCALLERB0];			Rx &larr; uXoffset,			c1;	Rx &larr; TOS + Rx, YDisp,		c2; {Calculate initial X of Src}		DISP4[L2VAL, 0C],		c3;		L2 &larr; 0C,			c1, at[0C, 10, L2VAL];	GOTO[SRCO],			c2; {Current XX = 00}	L2 &larr; 0D,			c1, at[0D, 10, L2VAL];	GOTO[SRCO],			c2; {Current XX = 01}	L2 &larr; 0E,			c1, at[0E, 10, L2VAL];	GOTO[SRCO],			c2; {Current XX = 10}	L2 &larr; 0F,			c1, at[0F, 10, L2VAL];	GOTO[SRCO],			c2; {Current XX = 11}	SRCO:	Rx &larr; RShift1 Rx, SE &larr; 0, 	c3; {Divide X by 4}		Rx &larr; RShift1 Rx, SE &larr; 0, 	c1;	Q &larr; Rx + Q, CarryBr, 		c2;		Rx &larr; uBITMAPBASELO, BRANCH[NBNA3, NBA3],	c3;	NBA3:	TT &larr; TT + 1, GOTO[NBCM3],		c1;NBNA3:	Noop,					c1;NBCM3:	Rx &larr; Rx + Q, CarryBr,			c2;    	Q &larr; uBITMAPBASEHI, BRANCH[NBNA4, NBA4],	c3;	NBA4:	TT &larr; TT + 1, GOTO[NBCM4],		c1;NBNA4:	Noop,				c1;NBCM4:	Q &larr; TT + Q, 			c2;	rhTT &larr; Q LRot0,			c3;			urhSAddr &larr; Q,			c1; {Save the high word of VA of Src for remapping}	urSAddr &larr; Rx, 			c2;	L1 &larr; L1.TrapFixesB0.3,		c3; 	PXBK7:	Map &larr; TT &larr; [rhTT, Rx],		c1;	L0 &larr; L0.WMAPB0.1,		c2; {Save the low word of VA of Src for remapping}	rhRx &larr; Rx &larr; MD, XwdDisp,	c3;	PXBK8:	MAR &larr; Q &larr; [rhRx, TT + 0], DISP2[NBCH2],	c1, at[L0.WMAPB0.1, 10, WMapFixCallerB0];	rhSAddr &larr; Rx LRot0,			c2, at[1, 4, NBCH2]; 	SrcReg &larr; MD,				c3; {Fetch Src}		rSAddr &larr; Q, L2Disp,			c1; {Save the high word of real address of Src}	DISP4[srcSel, 0C],			c2;		GOTO[SCO0],				c3, at[0C, 10, srcSel]; {XX = 00}		GOTO[SCO1],				c3, at[0F, 10, srcSel]; {XX = 11}	SrcReg &larr; SrcReg LRot12, GOTO[SCO2],	c3, at[0E, 10, srcSel]; {XX = 10}		SrcReg &larr; SrcReg LRot8, GOTO[SCO3],	c3, at[0D, 10, srcSel]; {XX = 01}{==============================================================================================Inner loop==============================================================================================}{Case 1 : already have src nibl in SrcReg}SCO1:	SrcReg &larr; SrcReg LRot4, L2 &larr; 0C, 		c1, at[0F, 10, srcNext]; {allign for curr nibl}							    {Current XX = 11, Next = 00}	Rx &larr; SrcReg and 0F0, GOTO[GotSrcNibl], L3Disp,	c2; {get nibl in bits 8-11}SCO2:	SrcReg &larr; SrcReg LRot4, L2 &larr; 0F, 		c1, at[0E, 10, srcNext]; {allign for curr nibl}							    {Current XX = 10, Next = 11}	Rx &larr; SrcReg and 0F0, GOTO[GotSrcNibl], L3Disp,	c2; {get nibl in bits 8-11}SCO3:	SrcReg &larr; SrcReg LRot4, L2 &larr; 0E, 		c1, at[0D, 10, srcNext];{allign for curr nibl}							    {Current XX = 01, Next = 10}	Rx &larr; SrcReg and 0F0, GOTO[GotSrcNibl], L3Disp,	c2; {get nibl in bits 8-11}{Case 2: need to read next src word}	MAR &larr; rSAddr &larr;  [rhSAddr, rSAddr + 1],		c1, at[0C, 10, srcNext];		    	BRANCH[$, fixSAddr, 1],				c2;SCONT:	SrcReg &larr; MD,					c3;SCO0:	SrcReg &larr; SrcReg LRot8, L2 &larr; 0D,			c1; {Current XX = 00, Next = 01}	Rx &larr; SrcReg and 0F0, GOTO[GotSrcNibl], L3Disp,	c2; {get src nibl in bits 8-11}GotSrcNibl:	DISP4[dstNext, 04],				c3;{First pass}	DCO0:	DstReg &larr; DstReg LRot4, 	 		c1, at[04, 10, dstNext]; {allign for curr nibl}	                			    {Current XX = 00, Next = 01}	Q &larr; DstReg and 0F, GOTO[GotDstNibl],	c2; {get nibl in bits 12-15}DCO1:	DstReg &larr; DstReg LRot8,  		c1, at[05, 10, dstNext]; {allign for curr nibl}						    {Current XX = 01, Next = 10}	Q &larr; DstReg and 0F, GOTO[GotDstNibl],	c2; {get nibl in bits 12-15}DCO2:	DstReg &larr; DstReg LRot12,  		c1, at[06, 10, dstNext]; {allign for curr nibl}						    {Current XX = 10, Next = 11}	Q &larr; DstReg and 0F, GOTO[GotDstNibl],	c2; {get nibl in bits 12-15}	DCO3:	DstReg &larr; DstReg LRot0, 			c1, at[07, 10, dstNext]; 						    {Position the right nibble at bits 12 - 15}	Q &larr; DstReg and 0F, GOTO[GotDstNibl],	c2; {get dst nibl in bits 12-15}	{Case 1: already have dst nibl in DstReg}DCO00:	DstReg &larr; DstReg LRot4, 	 		c1, at[0C, 10, dstNext]; {allign for curr nibl}	                			    {Current XX = 00, Next = 01}	Q &larr; DstReg and 0F, GOTO[GotDstNibl],	c2; {get nibl in bits 12-15}DCO01:	DstReg &larr; DstReg LRot4,  		c1, at[0D, 10, dstNext]; {allign for curr nibl}						    {Current XX = 01, Next = 10}	Q &larr; DstReg and 0F, GOTO[GotDstNibl],	c2; {get nibl in bits 12-15}DCO03:	DstReg &larr; DstReg LRot4,  		c1, at[0E, 10, dstNext]; {allign for curr nibl}						    {Current XX = 10, Next = 11}	Q &larr; DstReg and 0F, GOTO[GotDstNibl],	c2; {get nibl in bits 12-15}{Case 2: need next dest word}DCO02:	DstReg &larr; DstReg LRot4,  		c1, at[0F, 10, dstNext]; {allign for curr nibl}						    {Current XX = 10, Next = 11}	Q &larr; DstReg and 0F, GOTO[GotDstNibl],	c2; {get nibl in bits 12-15}{DCO03:	MAR &larr; [rhDAddr, rDAddr + 0],		c1, at[0F, 10, dstNext]; {write last value}	MDR &larr; DstReg,				c2;	,					c3;	MAR &larr; rDAddr &larr; [rhDAddr, rDAddr + 1],	c1; {read next value}	BRANCH[$, fixDAddr, 1],			c2;	DstReg &larr; MD,				c3;DCONT:	DstReg &larr; DstReg LRot4, 			c1; {Position the right nibble at bits 12 - 15}	Q &larr; DstReg and 0F, GOTO[GotDstNibl],	c2; {get dst nibl in bits 12-15}}GotDstNibl:	Rx &larr; Rx or Q,				c3; {Concatenate Src and Dst}	MAR &larr; [rhArray, Rx{src,,dst} + 0],	c1; {Fetch entry from color table}	DstReg &larr; DstReg and ~0F, L3Disp,	c2; {erase orig value of Dst nibble}	Rx{val} &larr; MD, DISP4[loc, 8],		c3;CLY0:	Rx &larr; Rx LRot4, L3 &larr; 09,			c1, at[08, 10, loc];	Rx &larr; Rx and 0F, 			c2; {Current YXX = 000, Entry 0, Next: YXX = 001, Entry 1}	DstReg &larr; DstReg or Rx, GOTO[entryready],	c3;CLY1:	Rx &larr; Rx LRot8, L3 &larr; 0A,			c1, at[09, 10, loc];	Rx &larr; Rx and 0F, 			c2; {Current YXX = 001, Entry 1, Next: YXX = 010, Entry 0}	DstReg &larr; DstReg or Rx, GOTO[entryready],	c3;	CLY2:	Rx &larr; Rx LRot4, L3 &larr; 0B,			c1, at[0A, 10, loc];	Rx &larr; Rx and 0F, 			c2; {Current YXX = 010, Entry 0, Next: YXX = 011, Entry 1}	DstReg &larr; DstReg or Rx, GOTO[entryready],	c3;CLY3:	Rx &larr; Rx LRot8, L3 &larr; 08,			c1, at[0B, 10, loc];	Rx &larr; Rx and 0F, 			c2; {Current YXX = 011, Entry 1, Next: YXX = 000, Entry 0}	DstReg &larr; DstReg or Rx, 			c3;		MAR &larr; [rhDAddr, rDAddr + 0],		c1; {write}	MDR &larr; DstReg,				c2;	,					c3;	MAR &larr; rDAddr &larr; [rhDAddr, rDAddr + 1],	c1; {read next value}	BRANCH[$, fixDAddr1, 1],		c2;	DstReg &larr; MD, GOTO[entryready],		c3;CLY4:	Rx &larr; Rx LRot12, L3 &larr; 0D,		c1, at[0C, 10, loc];	Rx &larr; Rx and 0F, 			c2; {Current YXX = 100, Entry 2, Next: YXX = 101, Entry 3}	DstReg &larr; DstReg or Rx, GOTO[entryready],	c3;CLY5:	Rx &larr; Rx LRot0, L3 &larr; 0E,			c1, at[0D, 10, loc];	Rx &larr; Rx and 0F, 			c2; {Current YXX = 101, Entry 3, Next: YXX = 110, Entry 2}	DstReg &larr; DstReg or Rx, GOTO[entryready],	c3;CLY6:	Rx &larr; Rx LRot12, L3 &larr; 0F,		c1, at[0E, 10, loc];	Rx &larr; Rx and 0F, 			c2; {Current YXX = 110, Entry 2, Next: YXX = 111, Entry 3}	DstReg &larr; DstReg or Rx, GOTO[entryready],	c3;CLY7:	Rx &larr; Rx LRot0, L3 &larr; 0C,			c1, at[0F, 10, loc];	Rx &larr; Rx and 0F, 			c2; {Current YXX = 111, Entry 3, Next: YXX = 100, Entry 2}	DstReg &larr; DstReg or Rx,			c3; {insert new value}		MAR &larr; [rhDAddr, rDAddr + 0],		c1; {write}	MDR &larr; DstReg,				c2;	,					c3;	MAR &larr; rDAddr &larr; [rhDAddr, rDAddr + 1],	c1; {read next value}	BRANCH[$, fixDAddr2, 1],		c2;	DstReg &larr; MD, GOTO[entryready],		c3;entryready:	Q &larr; upixelcount, 			c1;		Q &larr; Q - 1, ZeroBr,			c2; {Decrement pixel count}	BRANCH[$, LNFN],			c3; 	PXBKB:	Noop ,					c1;	L2Disp,					c2;	upixelcount &larr; Q, DISP4[srcNext, 0C],	c3; {loop back}	{==============================================================================================Update # of lines==============================================================================================}		LNFN:	Q &larr; uTrnWidthLo, L3Disp,		c1;	upixelcount &larr; Q, DISP4[DstAllign, 0C],	c2; {Initialize pixel count}		DstReg &larr; DstReg LRot0,	GOTO[PXBKC],	c3, at[0C, 10, DstAllign];		DstReg &larr; DstReg LRot4,	GOTO[PXBKC],	c3, at[0F, 10, DstAllign];	DstReg &larr; DstReg LRot8,	GOTO[PXBKC],	c3, at[0E, 10, DstAllign];		DstReg &larr; DstReg LRot12,	GOTO[PXBKC],	c3, at[0D, 10, DstAllign];PXBKC:	MAR &larr; [rhDAddr, rDAddr + 0],		c1; {Write the last value}	MDR &larr; DstReg,				c2;	Q &larr; uTrnHeightLo, 			c3;		Q &larr; Q - 1, ZeroBr,			c1;	uTrnHeightLo &larr; Q, BRANCH[$, NBEX],	c2;{==============================================================================================Handle Interrupts==============================================================================================}	uXoffset &larr; 0, MesaIntBr, 		c3;		Ybus &larr; uWDC, NZeroBr, BRANCH[NBNI1, $],	c1;	Ybus &larr; uWP, ZeroBr, BRANCH[$, NBNI2],	c2;		uWP &larr; 0, BRANCH[NBIN, NBNI3],		c3;NBIN:	TOS &larr; uTrnHeightLo,			c1;	TOSH &larr; uTOSH,				c2;	rhS &larr; nRhS, 				c3;		Noop,					c1;			S &larr; uS,					c2;		Q &larr; 0,					c3;		MAR &larr; [rhS, S + 0],			c1;		       	MDR &larr; Q, 				c2;	PV &larr; uPVx,				c3;		Bank &larr; EmuBank,				c1;	rhPV &larr; nRhS,				c2;	PC &larr; uPC, CROSS[EmuInt],		c3;	{		ClrIntErr, Rx &larr; 1,			c1, at[EmuInt];	uWDC &larr; Rx,				c2;	Rx &larr; KbdFXP, L2 &larr; 0, GOTO[PUNT],	c3;}					NBNI1:	Q &larr; uDstYLo, CANCELBR[$],		c2;		TOS &larr; uTrnHeightLo, GOTO[LINE],		c3;	NBNI2:	CANCELBR[$],				c3;NBNI3:	Q &larr; uDstYLo,  				c1;	TOS &larr; uTrnHeightLo,			c2;	GOTO[LINE],				c3;{==============================================================================================Remap==============================================================================================}fixDAddr1:		uRx &larr; Rx,				c3;	PXS0:	TT &larr; urDAddr,				c1; {Retrieve original rDAddr}		Q &larr; 0FF + 1,				c2; {Load Q with 100}	TT &larr; TT + Q, CarryBr,			c3; {Add rDAddr with 100}		Q &larr; urhDAddr, BRANCH[NBND1, NBAD1],	c1;	NBAD1:	Q &larr; Q + 1,				c2;	Noop,					c3;		Noop,					c1;	NBND1:	rhTT &larr; Q LRot0,				c2;	urhDAddr &larr; Q,				c3;		NBMP1:	Map &larr; [rhTT, TT + 0], L1 &larr; L1.TrapFixesB0.4,	c1;	urDAddr &larr; TT, L0 &larr; L0.WMAPB0.3,			c2;	rhRx &larr; Rx &larr; MD, XwdDisp,			c3;		MAR &larr; Q &larr; [rhRx, rDAddr + 0], DISP2[NBMAP1],	c1, at[L0.WMAPB0.3, 10, WMapFixCallerB0];	rDAddr &larr; Q, 					c2, at[1, 4, NBMAP1];	DstReg &larr; MD,					c3;		Q &larr; rhRx,				c1;	rhDAddr &larr; Q LRot0,			c2;	Rx &larr; uRx, GOTO[entryready],		c3;fixDAddr2:		uRx &larr; Rx,				c3;	PXS1:	TT &larr; urDAddr,				c1; {Retrieve original rDAddr}		Q &larr; 0FF + 1,				c2; {Load Q with 100}	TT &larr; TT + Q, CarryBr,			c3; {Add rDAddr with 100}		Q &larr; urhDAddr, BRANCH[NBND10, NBAD10],	c1;	NBAD10:	Q &larr; Q + 1,				c2;	Noop,					c3;		Noop,					c1;	NBND10:	rhTT &larr; Q LRot0,				c2;	urhDAddr &larr; Q,				c3;		NBMP10:	Map &larr; [rhTT, TT + 0], L1 &larr; L1.TrapFixesB0.4,	c1;	urDAddr &larr; TT, L0 &larr; L0.WMAPB0.4,			c2;	rhRx &larr; Rx &larr; MD, XwdDisp,			c3;		MAR &larr; Q &larr; [rhRx, rDAddr + 0], DISP2[NBMAP3],	c1, at[L0.WMAPB0.4, 10, WMapFixCallerB0];	rDAddr &larr; Q, 					c2, at[1, 4, NBMAP3];	DstReg &larr; MD,					c3;		Q &larr; rhRx,					c1;	rhDAddr &larr; Q LRot0,			c2;	Rx &larr; uRx, GOTO[entryready],		c3;	{=================================================================================Set up registers and memories=================================================================================}fixSAddr:	TT &larr; urSAddr,				c3; {Retrieve original rSAddr}		Q &larr; 0FF + 1,				c1; {Load Q with 100}	TT &larr; TT + Q, CarryBr,			c2; {Add rSAddr with 100}	Q &larr; urhSAddr, BRANCH[NBNS1, NBAS1],	c3;	NBAS1:	Q &larr; Q + 1,				c1;	rhTT &larr; Q LRot0,				c2;	urhDAddr &larr; Q, GOTO[NBMP2],		c3;	NBNS1:	rhTT &larr; Q LRot0,				c1;	Noop,					c2;	Noop,					c3;		NBMP2:	Map &larr; [rhTT, TT + 0], L1 &larr; L1.TrapFixesB0.3,	c1;	urSAddr &larr; TT, L0 &larr; L0.WMAPB0.2,			c2;	rhRx &larr; Rx &larr; MD, XwdDisp,			c3;		MAR &larr; Q &larr; [rhRx, rSAddr + 0], DISP2[NBMAP2],	c1, at[L0.WMAPB0.2, 10, WMapFixCallerB0];	rSAddr &larr; Q, 					c2, at[1, 4, NBMAP2];	SrcReg &larr; MD,					c3;		Q &larr; rhRx,			c1;	rhSAddr &larr; Q LRot0, 		c2;	GOTO[SCO0],			c3;{=================================================================================Set up registers and memories=================================================================================}	PXSTR:	S &larr; uS,				c1, at[L1.TrapFixesB0.3, 10, TrapFixesB0];	rhS &larr; nRhS,			c2;	Q &larr; upixelcount,		c3;		MAR &larr; [rhS, S + 0],		c1;	MDR &larr; Q,			c2;	Q &larr; 0,				c3;		GOTO[RestoreAllRegsAndPFB0],	c1;		S &larr; uS,				c1, at[L1.TrapFixesB0.4, 10, TrapFixesB0];	rhS &larr; nRhS,			c2;	Q &larr; upixelcount,		c3;		MAR &larr; [rhS, S + 0],		c1;	MDR &larr; Q - 1,			c2;	Q &larr; 0,				c3;		GOTO[RestoreAllRegsAndPFB0],	c1;NBCH3:	CALL[RLMapFixB0],	c2;	GOTO[WLMapFixB0],	c2, at[0, 4, NBCH1];	GOTO[WLMapFixB0],	c2, at[2, 4, NBCH1];	GOTO[WLMapFixB0],	c2, at[3, 4, NBCH1];	GOTO[WLMapFixB0],	c2, at[0, 4, NBCH2];	GOTO[WLMapFixB0],	c2, at[2, 4, NBCH2];	GOTO[WLMapFixB0],	c2, at[3, 4, NBCH2];	GOTO[WLMapFixB0],	c2, at[0, 4, NBMAP1];	GOTO[WLMapFixB0],	c2, at[2, 4, NBMAP1];	GOTO[WLMapFixB0],	c2, at[3, 4, NBMAP1];		GOTO[WLMapFixB0],	c2, at[0, 4, NBMAP3];	GOTO[WLMapFixB0],	c2, at[2, 4, NBMAP3];	GOTO[WLMapFixB0],	c2, at[3, 4, NBMAP3];		GOTO[WLMapFixB0],	c2, at[0, 4, NBMAP2];	GOTO[WLMapFixB0],	c2, at[2, 4, NBMAP2];	GOTO[WLMapFixB0],	c2, at[3, 4, NBMAP2];	{==================================================================================Error cases==================================================================================}NBYE1:	S &larr; uS, GOTO[ufnX20],	c1; NBYE2:	S &larr; uS, GOTO[ufnX20],	c1; NBXE1:	S &larr; uS, GOTO[ufnX20],	c1; NBXE2:	S &larr; uS, GOTO[ufnX20],	c1; NBPXE1:	S &larr; uS, GOTO[ufnX20],	c1; NBPXE2:	S &larr; uS, GOTO[ufnX20],	c1; NBTE1:	S &larr; uS, GOTO[ufnX20],		c1; NBTE2:	S &larr; uS, CANCELBR[ufnX10, 3],	c3; NBTE3:	S &larr; uS, GOTO[ufnX20],		c1; NBE1:	S &larr; uS, 			c2; 	rhS &larr; nRhS, GOTO[ufnX10],	c3;	NBE2:	S &larr; uS,	GOTO[NBE09],		c1; 	{rhS &larr; nRhS, GOTO[ufnX30],	c2;}	NBE3:	S &larr; uS, GOTO[NBE09],		c1; 	{rhS &larr; nRhS, GOTO[ufnX30],	c2;}	NBE7:	Noop,				c2;	{S &larr; uS, 			c2; 	rhS &larr; nRhS, GOTO[ufnX10],	c3;}		NBE4:	S &larr; uS, 			c3;	rhS &larr; nRhS, GOTO[ufnX20],	c1;		NBE5:	S &larr; uS, GOTO[NBE09],		c1; 	{rhS &larr; nRhS, GOTO[ufnX30],	c2;}	NBE6:	S &larr; uS,  GOTO[NBE09],		c1; 	{rhS &larr; nRhS, GOTO[ufnX30],	c2;}		NBE8:	S &larr; uS, 			c1; NBE09:	rhS &larr; nRhS, GOTO[ufnX30],	c2;NOTR3:	Noop,			c1;NOTR1:	S &larr; uS, GOTO[ufnX30],	c2;NOTR4:	Noop,			c1;NOTR2:	S &larr; uS, GOTO[ufnX30],	c2;{	NOTR1:	S &larr; uS, GOTO[ufnX30],	c2;NOTR2:	S &larr; uS, GOTO[ufnX30],	c2;NOTR3:	S &larr; uS, GOTO[ufnX20],	c1;NOTR4:	S &larr; uS, GOTO[ufnX20],	c1;}{==================================================================================Exit==================================================================================}NBEX:	Q &larr; 18'd, 					c3;	Xbus &larr; ib, GOTO[RestoreAllRegsAndExitB0],	c1;{=======================================================================Test type of Bitmap and fetch record of Bitmap=======================================================================	subroutine to check BitMap type and get BitMap parameters	Rx, TT have VA of BitMapTable	L3 &larr; 0{Src}/1{Dst}  has six or'd in at exit	L2 used for return	uses NoFixes if PageFault	trashes L0, L1, TT, Rx, Q, rhTT, rhRx	values from table are placed into:	if Src then : 	uBITMAPBASEHI		if Dst then :	uDBMBaseHi			uBITMAPBASELO				uDBMBaseLo			uBITMAPRASTERWIDTH			uDRasterWidth			uBITMAPHEIGHT				uDBitMapHeight			uBITMAPWIDTH				uDBitMapWidth			uBITMAPBITSPERPIXEL			uDBitsPerPixel			Set[L0.GBMP, 09];{must be odd!  uses even also} Stored in NewFuncDef.dfn}GetTestBMParamsB0:	MAR &larr; Q &larr; [TT, Rx + 0],			c1;{not mem ref, byte merge}	rhTT &larr; Rx LRot0, 			c2;	Rx &larr; Q, rhRx &larr; crhTypeTable,		c3;	Rx &larr; Rx LRot8,				c1;	Rx &larr; Rx RShift1, getTypemsBit, 		c2;	Q &larr; 0FF,				c3;	MAR &larr; [rhRx, Rx + 0],			c1;	Rx &larr; BitMapType,			c2;	Rx &larr; MD xor Rx,				c3;GetBMParsB0:	Map &larr; [rhTT, TT], L1 &larr; L1.NoFixesB0,		c1;	Ybus &larr; Q and Rx, ZeroBr, L0 &larr; L0.RMAPB0.9,	c2;	Rx &larr; rhRx &larr; MD, XRefBr, BRANCH[notBMufn, $],	c3;	MAR &larr; Q &larr; [rhRx, TT + 0], BRANCH[GBMremapit0, $],	c1, at[L0.RMAPB0.9, 10, RMapFixCallerB0];	Rx &larr; Q, L3Disp,						c2;	Q &larr; MD, L3Disp, DISP3[GBMfixitret0, 1]			c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest10],	c1, at[1, 8, GBMfixitret0];	uBITMAPBASEHI &larr; Q, CANCELBR[$, 2],			c2;	GBMdest1ret0:	Q &larr; MD, L3Disp,						c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest20],		c1;	uBITMAPBASELO &larr; Q, BRANCH[$, GBMfixitA0, 1],		c2;	GBMdest2ret0:	Q &larr; MD, L3Disp,						c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest30, 2],	c1, at[3, 8, GBMfixitret0];	uBITMAPRASTERWIDTH &larr; Q, CANCELBR[$, 2],			c2;	GBMdest3ret0:	Q &larr; MD, L3Disp,						c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest40, 6], L3 &larr; 6,	c1;	uBITMAPHEIGHT &larr; Q, BRANCH[$, GBMfixitB0, 1],			c2;	GBMdest4ret0:	Q &larr; MD, L3Disp,							c3;	MAR &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest50, 6],			c1, at[7, 8, GBMfixitret0];	uBITMAPWIDTH &larr; Q, CANCELBR[$, 2],				c2;	GBMdest5ret0:	Q &larr; MD, L3Disp,							c3;	BRANCH[$, GBMdest60, 6], L2Disp,					c1;	uBITMAPBITSPERPIXEL &larr; Q, DISP4[GetTestBMParamsB0Ret],		c2;GBMdest10:	uDBMBaseHi &larr; Q, CANCELBR[GBMdest1ret0, 2],			c2;GBMdest20:	uDBMBaseLo &larr; Q, BRANCH[GBMdest2ret0, GBMfixitA0, 1],		c2;GBMdest30:	uDBRasterWidth &larr; Q, CANCELBR[GBMdest3ret0, 2],			c2;GBMdest40:	uDBitMapHeight &larr; Q, BRANCH[GBMdest4ret0, GBMfixitB0, 1],	c2;GBMdest50:	uDBitMapWidth &larr; Q, CANCELBR[GBMdest5ret0, 2],			c2;GBMdest60:	uDBitsPerPixel &larr; Q, DISP4[GetTestBMParamsB0Ret],		c2;GBMremapit0:	CALL[RLMapFixB0],						c2;GBMfixitA0:	TT &larr; TT and ~0FF, GOTO[GBMallfixit0],				c3;GBMfixitB0:	TT &larr; TT and ~0FF, GOTO[GBMallfixit0],				c3;GBMallfixit0:	Q &larr; 0FF + 1,							c1;	TT &larr; TT + Q, CarryBr,						c2;	Rx &larr; 0, BRANCH[GetBMParsB0, GBMfixrh0],				c3;GBMfixrh0:	Q &larr; rhTT,							c1;	Q &larr; Q + 1,							c2;	rhTT &larr; Q LRot0,	GOTO[GetBMParsB0],				c3;					notBMufn:	CANCELBR[ufnX20, 3],						c1;			{ E N D }</pre>
  </body>
</html>
