{File name QdbNewLisp.mc}SetTask[0];{******************************************************************	READFLAGS*******************************************************************}READFLAGS:	Xbus _ TOSH xor smallpl, NZeroBr,	c1, opcode[161'b]; {71}	rhTT _ TT _ TOS LRot8, BRANCH[$, rdfUfn],	c2;	TOSH _ smallpl,	c3;	Map _ [rhTT, TT],	c1;	TOS _ 0E0,	c2;	TOS _ MD and TOS,	c3;	TOS _ TOS LRot12,	c1;	Ybus _ TOS and 0F, YDisp,	c2;	DISP4[CvtFlags,1], c3;	TOS _ 00, GOTO[RFExit], c1, at[01,10,CvtFlags];	TOS _ 02, GOTO[RFExit], c1, at[03,10,CvtFlags];	TOS _ 01, GOTO[RFExit], c1, at[05,10,CvtFlags];	TOS _ 03, GOTO[RFExit], c1, at[07,10,CvtFlags];	TOS _ 08, GOTO[RFExit], c1, at[09,10,CvtFlags];	TOS _ 0A, GOTO[RFExit], c1, at[0B,10,CvtFlags];	TOS _ 09, GOTO[RFExit], c1, at[0D,10,CvtFlags];	TOS _ 0D, GOTO[RFExit], c1, at[0F,10,CvtFlags];RFExit:	TOS _ TOS LRot12, IBDisp, L2 _ L2.0, GOTO[DNI.pc1],	c2;rdfUfn:	Rx _ 161'b, GOTO[ufn1],	c3;{******************************************************************	READRP*******************************************************************}READRP:	Xbus _ TOSH xor smallpl, NZeroBr,	c1, opcode[162'b];	rhTT _ TT _ TOS LRot8, BRANCH[$, rdrpUfn],	c2;	TOSH _ smallpl,	c3;	Map _ [rhTT, TT],	c1;	TOS _ ~0E0, L2 _ L2.0,	c2;	TOS _ MD and TOS, c3;	Ybus _ TOS - 1, PgCarryBr,	c1;	BRANCH[rsect0, rsectN0],	c2;rsect0:	GOTO[readrpend],	c3;rsectN0:	TOS _ TOS - 3, GOTO[readrpend],	c3;readrpend:	PC _ PC + PC16,	c1;	IBDisp,	c2;	TOS _ TOS LRot8, L2 _ L2.0, DISPNI[OpTable],	c3;rdrpUfn:	Rx _ 162'b, GOTO[ufn1],	c3; {******************************************************************	WRITEMAP*******************************************************************}WRITEMAP:   {vp, rp, flag => vp}	MAR _ [rhS, S], S _ S -1,	c1, opcode[163'b];{73}	Ybus _ TOSH xor smallpl, NZeroBr, CANCELBR[$, 2],	c2;	Rx _ MD{rp}, BRANCH[$, ufnWM0],	c3;{ Test to see if the rp is in the display bank. If so, leave it alone else bump pg# by 300}	TT _ Rx and ~0FF, c1;	Ybus _ TT + 0, ZeroBr, c2;	TT _ 3, BRANCH[notDB, isDB], c3;notDB:	TT _ TT LRot8, c1;	Rx _ Rx + TT, c2;  {add 3 segs}	, c3;	MAR _ [rhS, S + 0],	c1;	S _ S -1, 	c2;	Q _ MD{rpH},	c3;	MAR _ [rhS, S], S _ S -1,	c1;	Ybus _ Q xor smallpl, NZeroBr, CANCELBR[$,2],	c2;	TT _ MD{vp}, BRANCH[$, ufnWM1],	c3;	MAR _ [rhS, S+0], L2 _ L2.0,	c1;	Rx _ Rx LRot8,			c2;	Q _ MD{vpH},			c3;	, 				c1;	Ybus _ Q xor smallpl, NZeroBr,	c2;	rhTT _ TT _ TT LRot8, BRANCH[$, ufnWM2],	c3;	S _ S -1, Xbus _ TOS LRot4, XDisp,	c1;	Rx _ Rx and ~0E0, DISP4[wmf, 4],	c2;	Rx _ Rx or 0, GOTO[wMap],	c3, at[4, 10, wmf];	Rx _ Rx or 80, GOTO[wMap],	c3, at[0C,10,wmf];	Rx _ Rx or 040, GOTO[wMap], 	c3, at[5, 10, wmf];	Rx _ Rx or 0C0, GOTO[wMap],	c3, at[0D,10,wmf];	Rx _ Rx or 20, GOTO[wMap],	c3, at[6, 10, wmf];		Rx _ Rx or 0A0, GOTO[wMap],	c3, at[0E,10,wmf];	Rx _ Rx or 060, GOTO[wMap],	c3, at[7, 10, wmf];	Rx _ Rx or 0E0, GOTO[wMap],	c3, at[0F,10,wmf];wMap:	Map _ [rhTT, TT],	c1;	MDR _ Rx, PC _ PC + PC16, IBDisp,	c2;	TOS _ TT LRot8, L2 _ L2.0, DISPNI[OpTable],	c3;ufnWM0:	S _ S+1, GOTO[ufnX2],	c1;ufnWM1:	S _ S+3, GOTO[ufnX2],	c1;ufnWM2:	S _ S+3, GOTO[ufnX2],	c1;{******************************************************************}AnotherFault:	Noop, GOTO[PFault], c3, at[PFaultB0];BBFault:PFault:	rhRx _  INTERFACEspace, 	c1;	Rx _ INTERFACEbasePage{20'b}{INTERFACEbase=10000'b},	c2;	Rx _ Rx LRot8, GOTO[PFaultcont],	c3;{******************************************************************}{% SHOULD CHECK IF ANY PENDING INTERRUPTS - CURRENTLY MAY MISS KEYSTROKES }opcode[176'b],{7E}	Ybus _ TOS xor ResetFXP, ZeroBr{faultExit}, L2_ 0{NotInCall},	c1;	Rx_ TOS, BRANCH[$,  SwReset],	c2;	TOSH _ 0, CANCELBR[ConJn],	c3;SwReset: ClrIntErr,TOSH _ 1{Resetting},	c3;	rhRio _ oldIOPageHigh, c1;	Rio _ oldIOPageLow, c2;	uWP _ 0, c3;	MAR _ [rhRio, Rio + PeriodicInterruptOffset],c1;	MDR _ 0, CANCELBR[$,2], LOOPHOLE[wok], c2;	, c3;ConJn:	uWDC _ TOSH, PC_ PC + PC16 {advance PC}, GOTO[PuntFor2],	c1;{note that this code winds up storing the context number on the stack and thensetting the no-push bit in the frame. This is not exactly the same as the Dorado, but no code relies on the value returned "to" a context}{******************************************************************}MidPuntmar:	MAR _ [rhTT, Q + 0],	c1;	,	c2;	Rx _ MD,	c3;	MAR _ [rhTT, Q + 0],	c1;	MDR{next} _ PV,	c2;	PV _ Rx, GOTO[RTN2],	c3;{******************************************************************}	{ E N D }