<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>NewLispMakeGraph.mc!1</title>
  </head>
  <body>
    <pre>
{File name NewLispMakeGraph.mcDescription:  DandeLion InterLisp Emulator LispFloatArrayAuthor: CharnleyLast modified: Charnley               5-Mar-85  9:59:08Created:   8-Jun-84 10:04:55}{RegDef[umaskrealLo, U, 045],RegDef[umaskrealHi, U, 046];}{	MAKEGRAPH 337	Args:	S-12  Ptr to list of Kount values:  value in [0..255]	S-10  Ptr to list of 256 patterns:  pattern[i] used to display value = i	S-8  X:  x-displacement of first bit in target bitmap	S-6  Addr of target map:  first word of target bitmap {left edge}	S-4  Target map width:  words wide of target bitmap:  in [0..255]	S-2  Pattern height:  number of bits high {repeated} of pattern: in [1..16]	S-0  Pattern width:  number of bits wide of pattern: in [1..16]	TOS  Kount}{	u regs	uS2Hi, uS2Lo ptr to patterns	uS1Hi, uS1Lo ptr to values	uXdisp value of x-displacement	uDHi, uDLo ptr to leftmost top dest address	uWidth map width in words {width-1 if two dest words}	uICount pattern height	uNBits  pattern width in bits	umaskrealLo  saves mask for source into dest low word	umaskrealHi  saves mask for source into dest high word	uShiftedPattLo  bits to be ored into first dest word	uShiftedPattHi  bits to be ored into second dest word}{	r regs	S1  real address of next value	S2  real address of pattern, and temp	D  real address of next dest	Zorch  remap temp and Shift and Mask temp	Zimph  remap temp	Stemp  general temp	Kount  outer loop count}{	link regsL0     LMGremapDret	Set[L0.LMGDinit, 4],	Set[L0.LMGD1, 2],	Set[L0.LMGD2, 3],	Set[L0.LMGD3, 5],     LMGremapS1ret	Set[L0.LMGS1init, 4],	Set[L0.LMGS1S2, 6],     LMGremapS2ret	Set[L0.LMGS1S2, 6],     AllignRet	Set[L0.LMGS1S2, 6],L1	return link for reg saving     LFASaveRegsRet	Set[L1.LMGprep, 5],	amount to left shift sourceL2	0  --  plot each value	1  --  plot every other valueL3	0  first inner loop, one dest word	1  first inner loop, two dest words	2  other inner loop, one dest word	3  other inner loop, two dest words}{	{init}	  {generate: 1st target word mask, 2nd target word mask, Shift count for pattern}	  {for OCount in [0..Kount - 1]}	    {get next value}	    {get pattern[value]}	    {shift pattern}	    {mask pattern}{not needed for 'or'  --  assumes pattern is zero filled}	    {for ICount in [0..Pattern height - 1]}	      {merge pattern into target word(s)}	      {next ICount}	    {next OCount}}LMG:	at[IBLT],	Xbus &larr; ibNA, XDisp,	c1;	L2 &larr; 0, DISP4[iblt],	c2;{put ib into L2}	GOTO[ibltstart],	c3, at[0, 10, iblt];	GOTO[ibltstart],	c3, at[1, 10, iblt];ibltstart:	L1 &larr; L1.LMGprep,	c1;	CALL[LFASaveRegsHere],	c2;{this does S &larr; S - 4}	MAR &larr; S &larr; [rhS, S - 8],	c1, at[L1.LMGprep, 10, LFASaveRegsRet];LMGS1ret:	BRANCH[$, LMGS1, 1],	c2;	Stemp{S1Lo} &larr; MD,	c3;{S-12}	MAR &larr; [rhS, S - 1],	c1;	uS1Lo &larr; Stemp, CANCELBR[$, 2],	c2;	Stemp{S1Hi} &larr; MD,	c3;	MAR &larr; S &larr; [rhS, S + 2],	c1;LMGS2ret:	uS1Hi &larr; Stemp, BRANCH[$, LMGS2, 1],	c2;	Stemp {S2Lo}&larr; MD,	c3;{S-10}	MAR &larr; [rhS, S - 1],	c1;	uS2Lo &larr; Stemp, CANCELBR[$, 2],	c2;	Stemp{S2Hi} &larr; MD,	c3;	MAR &larr; S &larr; [rhS, S + 2],	c1;LMGS3ret:	uS2Hi &larr; Stemp, BRANCH[$, LMGS3, 1],	c2;	Stemp {Xdisp}&larr; MD,	c3;{S-8}	MAR &larr; S &larr; [rhS, S + 2],	c1;LMGS4ret:	uXdisp &larr; Stemp, BRANCH[$, LMGS4, 1],	c2;	Stemp{DLo} &larr; MD,	c3;{S-6}	MAR &larr; [rhS, S - 1],	c1;	uDLo &larr; Stemp, CANCELBR[$, 2],	c2;	Stemp{DHi} &larr; MD,	c3;	MAR &larr; S &larr; [rhS, S + 2],	c1;LMGS5ret:	uDHi &larr; Stemp, BRANCH[$, LMGS5, 1],	c2;	Stemp{Width} &larr; MD,	c3;{S-4}	MAR &larr; S &larr; [rhS, S + 2],	c1;LMGS6ret:	uWidth &larr; Stemp, BRANCH[$, LMGS6, 1],	c2;	Stemp{ICount} &larr; MD,	c3;{S-2}	MAR &larr; S &larr; [rhS, S + 2],	c1;LMGS7ret:	uICount &larr; Stemp, BRANCH[$, LMGS7, 1],	c2;	Stemp{NBits} &larr; MD,	c3;{S-0}	uNBits &larr; Stemp, GOTO[LMGprep],	c1;LMGS1:	S &larr; S - 0FF - 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[LMGS1ret],	c1;LMGS2:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[LMGS2ret],	c1;LMGS3:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[LMGS3ret],	c1;LMGS4:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[LMGS4ret],	c1;LMGS5:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[LMGS5ret],	c1;LMGS6:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[LMGS6ret],	c1;LMGS7:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[LMGS7ret],	c1;LMGprep:	S2 &larr; uXdisp,	c2;	Zimph &larr; S2 and ~0F,	c3;	Zimph &larr; Zimph LRot12,	c1;{Zimph set to dest word offset from Xdisp}	Ybus &larr; S2, YDisp,	c2;	Xbus &larr; 1, XDisp, DISP4[Mask],	c3;	{build a mask of left zero's, with one's starting at first bit}	{one cycle subroutine returns mask in Zorch} {c1}	umaskrealLo &larr; Zorch,	c2, at[1, 10, MaskRet];	Q &larr; uNBits,	c3;	Ybus &larr; S2 + Q,  YDisp,	c1;	Xbus &larr; 3, XDisp, DISP4[Mask],	c2;	{build a mask of left one's, with zero's starting past last bit}	{one cycle subroutine returns mask in Zorch} {c3}	Ybus &larr; ~Zorch, ZeroBr,	c1, at[3, 10, MaskRet];{mask is wrong for position 0; test and fix}	S1 &larr; 0 - S2, BRANCH[Tmask, Fmask],	c2;Tmask:	umaskrealHi &larr; ~Zorch, GOTO[LMGz],	c3;Fmask:	umaskrealHi &larr; Zorch, GOTO[LMGz],	c3;LMGz:	D &larr; uNBits,	c1;	Ybus &larr; S1 - D, YDisp,	c2;{left shift amount = - NBits - Xdisp}	Xbus &larr; 2, XDisp, DISP4[Mask], L1 &larr; 0,	c3;{place left cycle amount in L1}	{one cycle subroutine returns garbage in Zorch}{c1}	D &larr; D - 1,	c2, at[2, 10, MaskRet];	Ybus &larr; D + S2, NibCarryBr,	c3;	S2 &larr; uWidth, L3 &larr; 0, BRANCH[oneDW, twoDW],	c1;{place oneDW{0} / twoDW{1} into L3}oneDW:	Q &larr; umaskrealLo,	c2;	Q &larr; Q and umaskrealHi,	c3;	umaskrealLo &larr; Q,	c1;	GOTO[anyDW],	c2;twoDW:	S2 &larr; S2 - 1, GOTO[anyDW],	c2;{sub one from width if two dest words}anyDW:	,	c3;	uWidth &larr; S2,	c1;{now in words or words - 1}	L0 &larr; L0.LMGDinit, Zorch &larr; uDLo,	c2;	Q &larr; rhZorch &larr; uDHi, CALL[LMGremapDinit],	c3;	{Zimph set up with word offset}	rhZorch &larr; Q &larr; uS1Hi,	c2, at[L0.LMGDinit, 10, LMGremapDret];	Zorch &larr; uS1Lo, CALL[LMGremapS1init],	c3;	L0 &larr; L0.LMGS1S2,	c2, at[L0.LMGDinit, 10, LMGremapS1ret];	Zimph &larr; MD, CALL[LMGremapS2],	c3;LMGdoubleouter:	MAR &larr; S1 &larr; [rhS1, S1 - 2], BRANCH[LMGout, LMGend],	c1;LMGouterloop:	{get next value}	MAR &larr; S1 &larr; [rhS1, S1 - 1], BRANCH[LMGout, LMGend],	c1;LMGout:	BRANCH[$, LMGremapS1, 1],	c2, at[L0.LMGS1S2, 10, LMGremapS1ret];;	Zimph &larr; MD, CALL[LMGremapS2],	c3;	{use value as index into pattern table}	S2 &larr; umaskrealLo, L1Disp,	c2, at[L0.LMGS1S2, 10, LMGremapS2ret];	Zorch &larr; MD, DISP4[Allign],	c3;LMGpause:	uShiftedPattLo &larr; Zorch and S2,	c1, at[L0.LMGS1S2, 10, AllignRet];	S2 &larr; umaskrealHi,	c2;	uShiftedPattHi &larr; Zorch and S2,	c3;	Q &larr; ~umaskrealLo,	c1;	S2 &larr; uWidth, L3Disp,	c2;	Stemp &larr; uICount, DISP2[Innerloop],	c3;	MAR &larr; [rhD, D + 0], GOTO[SInner], L3 &larr; 2,	c1, at[0, 4, Innerloop];	MAR &larr; D &larr; [rhD, D + S2{Width}], GOTO[SInner], L0 &larr; L0.LMGD1,	c1, at[2, 4, Innerloop];SInner:	Stemp{ICount} &larr; Stemp - 1, ZeroBr, BRANCH[$, LMGremapD1, 1],	c2;remapD1ret:	Q &larr; MD and Q, BRANCH[Smoreinner, Snomoreinner],	c3;Smoreinner:	MAR &larr; [rhD, D + 0],	c1;	MDR &larr; Q or uShiftedPattLo, L3Disp,	c2;	Q &larr; ~umaskrealLo, DISP2[Innerloop],	c3;Snomoreinner:	MAR &larr; [rhD, D + 0], L0 &larr; L0.LMGS1S2,	c1;	MDR &larr; Q or uShiftedPattLo, L2Disp,	c2;	Kount{OCount} &larr; Kount - 1, ZeroBr, BRANCH[LMGouterloop, LMGdoubleouter],	c3;	MAR &larr; [rhD, D + 0], GOTO[DInner], L3 &larr; 3,	c1, at[1, 4, Innerloop];	MAR &larr; D &larr; [rhD, D + S2{Width - 1}], GOTO[DInner], L0 &larr; L0.LMGD2,	c1, at[3, 4, Innerloop];DInner:	BRANCH[$, LMGremapD2, 1],	c2;remapD2ret:	Q &larr; MD and Q,	c3;	MAR &larr; [rhD, D + 0],	c1;	MDR &larr; Q or uShiftedPattLo,	c2;	Q &larr; ~umaskrealHi,	c3;	MAR &larr; D &larr; [rhD, D + 1], L0 &larr; L0.LMGD3,	c1;	Stemp{ICount} &larr; Stemp - 1, ZeroBr, BRANCH[$, LMGremapD3, 1],	c2;remapD3ret:	Q &larr; MD and Q, BRANCH[Dmoreinner, Dnomoreinner],	c3;Dmoreinner:	MAR &larr; [rhD, D + 0],	c1;	MDR &larr; Q or uShiftedPattHi, L3Disp,	c2;	Q &larr; ~umaskrealLo, DISP2[Innerloop],	c3;Dnomoreinner:	MAR &larr; [rhD, D + 0], L0 &larr; L0.LMGS1S2	c1;	MDR &larr; Q or uShiftedPattHi, L2Disp,	c2;	Kount{OCount} &larr; Kount - 1, ZeroBr, BRANCH[LMGouterloop, LMGdoubleouter],	c3;LMGend:	Q &larr; 14'd, CANCELBR[$, 3],	c2;	L1 &larr; L1.LFAexit,	c3;	GOTO[LFACommonExit],	c1;{	,	c3, at[L1.LFGexit, 10, RestoreRegsRet];	{instruction dispatch}	Bank &larr; EmuBank,	c1;	PC &larr; PC + PC16, L2 &larr; L2.0, IBDisp,	c2;	L2 &larr; L2.0, DISPNI[OpTableB2],	c3;}LMGremapD1:	Zorch &larr; uDLo, CANCELBR[LMGremapD],	c3;	Ybus &larr; Stemp, ZeroBr, GOTO[remapD1ret],	c2, at[L0.LMGD1, 10, LMGremapDret];LMGremapD2:	Zorch &larr; uDLo, GOTO[LMGremapD],	c3;	GOTO[remapD2ret],	c2, at[L0.LMGD2, 10, LMGremapDret];LMGremapD3:	Zorch &larr; uDLo, CANCELBR[LMGremapD],	c3;	Ybus &larr; Stemp, ZeroBr, GOTO[remapD3ret],	c2, at[L0.LMGD3, 10, LMGremapDret];LMGremapD:	MAR &larr; Zorch &larr; [Zorch, D + 0],	c1;{byte merge only}	Zimph &larr; 0FF + 1,	c2;	rhZorch &larr; uDHi,	c3;LMGremapDinit:	Zorch &larr; Zorch + Zimph, CarryBr,	c1;	uDLo &larr; Zorch, BRANCH[LMGDnocar, LMGDcar],	c2;LMGDcar:	Zimph &larr; Zorch,	c3;	Zorch &larr; rhZorch + 1, LOOPHOLE[byteTiming],	c1;	rhZorch &larr; Zorch LRot0,	c2;	Zorch &larr; Zimph,	c3;	uDHi &larr; Zorch,	c1;	,	c2;	GOTO[LMGDmap],	c3;LMGDnocar:	,	c3;LMGDmap:	Map &larr; [rhZorch, Zorch],	c1;	,	c2;	rhD &larr; D &larr; MD, XwdDisp,	c3;	Map &larr; [rhZorch, Zorch], DISP2[LMGmapD, 1],	c1;	MDR &larr; D or 30, GOTO[LMGDok],	c2, at[1, 4, LMGmapD];	Rx &larr; D, GOTO[LMGpagefault],	c2, at[3, 4, LMGmapD];LMGDok:	L0Disp,	c3;	MAR &larr; D &larr; [rhD, Zorch + 0], DISP4[LMGremapDret],	c1;LMGremapS1init:	Zimph &larr; Kount - 1, L2Disp,	c1;	Zorch &larr; Zorch + Zimph, CarryBr, BRANCH[LMGsingleS1, LMGdoubleS1],	c2;LMGdoubleS1:	Zorch &larr; Zorch - Zimph, CANCELBR[$],	c3;	Zimph &larr; Zimph + Zimph,	c1;	Zorch &larr; Zorch + Zimph, CarryBr,	c2;LMGsingleS1:	uS1Lo &larr; Zorch, BRANCH[LMGremapS1map, LMGS1initS1car],	c3;LMGS1initS1car:	Q &larr; Q + 1,	c1;	rhZorch &larr; Q LRot0,	c2;	GOTO[LMGremapS1map],	c3;LMGremapS1:	Zorch &larr; uS1Lo, GOTO[LMGremapS1sub],	c3;LMGremapS1sub:	MAR &larr; Zorch &larr; [Zorch, S1 + 0],	c1;{byte merge only}	Zimph &larr; 0FF + 1,	c2;	Q &larr; rhZorch &larr; uS1Hi,	c3;	Zorch &larr; Zorch - Zimph, CarryBr,	c1;	uS1Lo &larr; Zorch, BRANCH[LMGS1car, LMGS1nocar],	c2;LMGS1car:	Q &larr; Q - 1,	c3;	rhZorch &larr; Q LRot0,	c1;	,	c2;LMGS1nocar:	,	c3;LMGremapS1map:	Map &larr; [rhZorch, Zorch],	c1;	uS1Hi &larr; Q,	c2;	rhS1 &larr; S1 &larr; MD, XwdDisp,	c3;	Map &larr; [rhZorch, Zorch], DISP2[LMGmapS1],	c1;	MDR &larr; S1 or 10, GOTO[LMGS1ok],	c2, at[0, 4, LMGmapS1];	MDR &larr; S1 or 10, GOTO[LMGS1ok],	c2, at[1, 4, LMGmapS1];	MDR &larr; S1 or 10, GOTO[LMGS1ok],	c2, at[2, 4, LMGmapS1];	Rx &larr; S1, GOTO[LMGpagefault],	c2, at[3, 4, LMGmapS1];LMGS1ok:	L0Disp,	c3;	MAR &larr; S1 &larr; [rhS1, Zorch + 0], DISP4[LMGremapS1ret]	c1;{----	S2 REMAP   ----}LMGremapS2:	Zorch &larr; uS2Lo,	c1;	Zorch &larr; Zorch + Zimph, CarryBr,	c2;	rhZorch &larr; uS2Hi, BRANCH[LMGS2nocar, LMGS2car],	c3;LMGS2car:	Q &larr; rhZorch,	c1;	Q &larr; Q + 1,	c2;	rhZorch &larr; Q LRot0,	c3;LMGS2nocar:	{map S2}	Map &larr; [rhZorch, Zorch],	c1;	,	c2;	rhS2 &larr; S2 &larr; MD, XwdDisp,	c3;	Map &larr; [rhZorch, Zorch], DISP2[LMGmapS2],	c1;	MDR &larr; S2 or 10, GOTO[LMGS2ok],	c2, at[0, 4, LMGmapS2];	MDR &larr; S2 or 10, GOTO[LMGS2ok],	c2, at[1, 4, LMGmapS2];	MDR &larr; S2 or 10, GOTO[LMGS2ok],	c2, at[2, 4, LMGmapS2];	Rx &larr; S2, GOTO[LMGpagefault],	c2, at[3, 4, LMGmapS2];LMGS2ok:	L0Disp,	c3;	MAR &larr; S2 &larr; [rhS2, Zorch + 0], RET[LMGremapS2ret]	c1;LMGpagefault:	TOS &larr; uTOS,	c3;LMGfault:	,	c1;	GOTO[LFApagefault],	c2;{	Left Allign by dispatched amount, return thru L0}	TT &larr; TT LRot0, GOTO[SHzero],	c*, at[00, 10, Allign];	TT &larr; TT LRot0, GOTO[SHone],	c*, at[01, 10, Allign];	TT &larr; TT LRot0, GOTO[SHtwo],	c*, at[02, 10, Allign];	TT &larr; TT LRot4, GOTO[SHmin1],	c*, at[03, 10, Allign];	TT &larr; TT LRot4, GOTO[SHzero],	c*, at[04, 10, Allign];	TT &larr; TT LRot4, GOTO[SHone],	c*, at[05, 10, Allign];	TT &larr; TT LRot4, GOTO[SHtwo],	c*, at[06, 10, Allign];	TT &larr; TT LRot8, GOTO[SHmin1],	c*, at[07, 10, Allign];	TT &larr; TT LRot8, GOTO[SHzero],	c*, at[08, 10, Allign];	TT &larr; TT LRot8, GOTO[SHone],	c*, at[09, 10, Allign];	TT &larr; TT LRot8, GOTO[SHtwo],	c*, at[0A, 10, Allign];	TT &larr; TT LRot12, GOTO[SHmin1],	c*, at[0B, 10, Allign];	TT &larr; TT LRot12, GOTO[SHzero],	c*, at[0C, 10, Allign];	TT &larr; TT LRot12, GOTO[SHone],	c*, at[0D, 10, Allign];	TT &larr; TT LRot12, GOTO[SHtwo],	c*, at[0E, 10, Allign];	TT &larr; TT LRot0, GOTO[SHmin1],	c*, at[0F, 10, Allign];SHzero:	TT &larr; TT, L0Disp, GOTO[SHF0],	c*;SHone:	TT &larr; LRot1 TT, L0Disp, GOTO[SHF0],	c*;SHtwo:	TT &larr; LRot1 TT, L0Disp, GOTO[SHF1],	c*;SHmin1:	TT &larr; RRot1 TT, L0Disp, GOTO[SHF0],	c*;SHF0:	TT &larr; TT, RET[AllignRet],	c*;SHF1:	TT &larr; LRot1 TT, RET[AllignRet],	c*;	{Mask generation subroutine}	TT &larr; 1, RET[MaskRet],	c*, at[0F, 10, Mask];	TT &larr; 3, RET[MaskRet],	c*, at[0E, 10, Mask];	TT &larr; 7, RET[MaskRet],	c*, at[0D, 10, Mask];	TT &larr; 0F, RET[MaskRet],	c*, at[0C, 10, Mask];	TT &larr; 1F, RET[MaskRet],	c*, at[0B, 10, Mask];	TT &larr; 3F, RET[MaskRet],	c*, at[0A, 10, Mask];	TT &larr; 7F, RET[MaskRet],	c*, at[09, 10, Mask];	TT &larr; 0FF, RET[MaskRet],	c*, at[08, 10, Mask];	TT &larr; LShift1 0FF, SE&larr;1, RET[MaskRet],	c*, at[07, 10, Mask];	TT &larr; RShift1 u7FF, RET[MaskRet],	c*, at[06, 10, Mask];	TT &larr; u7FF, RET[MaskRet],	c*, at[05, 10, Mask];	TT &larr; RShift1 u1FFF, RET[MaskRet],	c*, at[04, 10, Mask];	TT &larr; u1FFF, RET[MaskRet],	c*, at[03, 10, Mask];	TT &larr; uTT3FFF, RET[MaskRet],	c*, at[02, 10, Mask];	TT &larr; RShift1 (TT xor ~TT), RET[MaskRet],	c*, at[01, 10, Mask];	TT &larr; TT xor ~TT, RET[MaskRet],	c*, at[00, 10, Mask];	{ E N D }</pre>
  </body>
</html>
