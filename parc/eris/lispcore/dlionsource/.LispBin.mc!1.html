<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>LispBin.mc!1</title>
  </head>
  <body>
    <pre>
{LispBin.mcLast edit:  by don 23-Mar-84 11:33:57 Last edit:  by don 16-Feb-84 10:41:14 fixed for big memCreated:  29-Nov-83 10:17:04 by don}SetTask[0];{- - - - - - - - - - - - - - - - - - - - - - - - - -  #      name        len-1    stk level effect   UFN table entry 40      BIN         0        0                  \BINIf TOS is not of type STREAM (13q), PUNTFetch quadword pointed to by TOS.  Format is:	word 0: CCOFF	; a byte offset from BUFFER	word 1: NCCHARS	; size of buffer in bytes	word 2, 3: flags [byte] = READABLE(bit 0), WRITABLE(bit 1),					 EXTENDABLE(bit 2)		BUFFER [24-bits]If CCOFF &gt;= NCCHARS, PUNT  [buffer overflow]If READABLE is off, PUNTFetch and remember the byte at BUFFER + CCOFF[byte offset]	Note that this address is guaranteed to be valid at this point,	but it could pagefault.Update the CCOFF word:  CCOFF &larr; CCOFF + 1, and store back in the streamReturn the remembered byte as a small positive number.[not required; in Dorado, D0]- - - - - - - - - - - - - - - - - - - - - - - - - -  #      name        len-1    stk level effect   UFN table entry 41      BOUT        0        -1                 \BOUTIf TOS-1 is not of type STREAM (13q), PUNT.If TOS is not a small positive number (&lt; 400Q), PUNT.Fetch quadword pointed to by TOS.  (see format under BIN)if WRITABLE is off, PUNTif CCOFF &gt;= NCCHARS then:	if EXTENDABLE is off, PUNT	if NCCHARS &gt;= 512, PUNT	increment &amp; remember NCCHARSdeposit byte from TOS at BUFFER + CCOFF[byte offset]Update the stream:	store CCOFF &larr; CCOFF + 1	store NCCHARS if incrementedreturn the smallposp one (1)[not required; not implemented yet]- - - - - - - - - - - - - - - - - - - - - - - - - -}@BIN:		opcode[40'b],	rhTT &larr; TOSH LRot0,	c1;	,	c2;	Rx &larr; TOS, rhRx &larr; crhTypeTable,	c3;	MAR &larr; Q &larr; [TOS, TOSH + 0],	c1; {not mem req }	TT &larr; TOS, L1 &larr; L1.NoFixes, 	c2;	,	c3;	Rx &larr; Q,	c1;	Rx &larr; Rx LRot8, 	c2;	Rx &larr; Rx RShift1, getTypemsBit,	c3;	{get type table entry}	MAR &larr; [rhRx, Rx + 0],	c1;	Q &larr; 0FF,	c2;	Rx{entry} &larr; MD and Q{0FF},	c3;	{test if type stream}	,	c1;	Ybus &larr; Rx xor STREAMTYPE, ZeroBr,	c2;	BRANCH[TTEnotStream, $],	c3;	{map the address}	Map &larr; [rhTT, TT], L0 &larr; L0.RedoBin,	c1;	,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;	{get 4 word contents of address}	MAR &larr; Q &larr; [rhRx, TT + 0], DISP2[BinRemap],	c1,at[L0.RedoBin,10,WMapFixCaller];	Rx &larr; uSavAddr &larr; Q,	c2, at[1, 4, BinRemap];	Q{CCOFF} &larr; MD,	c3;	MAR &larr; [rhRx, Rx + 1],	c1;	CANCELBR[$, 2],	c2;	TT{NCCHARS} &larr; MD,	c3;	MAR &larr; [rhRx, Rx + 3],	c1;	Ybus &larr; Q - TT, CarryBr, BRANCH[$, lbCant, 1],	c2;	TT{Buff.Lo} &larr; MD, BRANCH[$, BinFull],	c3;	MAR &larr; [rhRx, Rx + 2],	c1;	uGcLlo &larr; TT, CANCELBR[$, 2],	c2;	rhTT &larr; TT{Buff.Hi} &larr; MD,	c3;	Rx &larr; Q + 1,	c1;	uGcLTem &larr; Rx,	c2;	Ybus &larr; TT, NegBr,	c3;	Q &larr; rhRx, BRANCH[BinNoRead, $],	c1;	Ybus &larr; Rx and 1, YDisp,	c2;	TT &larr; uGcLlo, L2 &larr; 0, BRANCH[BinO, BinE],	c3;{L2 &larr; Odd/Even}BinO:	Rx &larr; RShift1 (Rx - 1), SE &larr; 0, GOTO[BinEO],	c1;BinE:	Rx &larr; RShift1 (Rx - 1), SE &larr; 0, GOTO[BinEO],	c1;BinEO:	TT &larr; TT + Rx, CarryBr,	c2;	urhRx &larr; Q, BRANCH[BinNoC,$],	c3;	Q &larr; rhTT,	c1;	Q &larr; Q + 1,	c2;	rhTT &larr; Q LRot0,	c3;BinNoC:	Map &larr; [rhTT, TT], L0 &larr; L0.RedoBinA,	c1;	,	c2;	Rx &larr; rhRx &larr; MD, XRefBr, GOTO[BinGet],	c3;BinGet:	{get contents of address}	MAR &larr; Q &larr; [rhRx, TT + 0], BRANCH[BinRemapA, $],	c1,at[L0.RedoBinA,10,RMapFixCaller];	L2Disp,	c2;	TT{BinWord} &larr; MD, BRANCH[BinOdd, BinEven],	c3;BinOdd:	TT &larr; TT, GOTO[BinMask],	c1;BinEven:	TT &larr; TT LRot8, GOTO[BinMask],	c1;BinMask:	TOS &larr; TT and 0FF,	c2;	TOSH &larr; smallpl,	c3;	rhRx  &larr; urhRx,	c1;	Rx &larr; uSavAddr,	c2;	,	c3;	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; uGcLTem, L2 &larr; L2.0, IBDisp, GOTO[DNI.pc1],	c2;	CALL[WLMapFix],	c2, at[0, 4, BinRemap];	CALL[WLMapFix],	c2, at[2, 4, BinRemap];	CALL[WLMapFix],	c2, at[3, 4, BinRemap];BinRemapA:	CALL[RLMapFix],	c2;TTEnotStream:	GOTO[ufnX2],	c1;BinFull:	GOTO[ufnX2],	c1;BinNoRead:	GOTO[ufnX3],	c2;lbCant:	CANCELBR[ufnX1],	c3;	{ E N D }</pre>
  </body>
</html>
