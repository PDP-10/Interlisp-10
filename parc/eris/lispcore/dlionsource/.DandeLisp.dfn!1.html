<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>DandeLisp.dfn!1</title>
  </head>
  <body>
    <pre>
{File name:  &lt;tajo&gt;DandeLisp.dfn Description: Definitions for Dandelion Lisp Microcode, Created: April 6, 1982 by Purcell charnley: 22-Mar-85 10:21:10 moved reg defs here from BusExt Purcell: 13-Jan-85 11:16:23 make DiskCSBOffsetIOCB page rel{%1} Last Edited:     16-Apr-84 11:36:56 - added DrawLine regs - charnley Last Edited:   20-Jul-83 10:47:17 charnley {nStkLimOffset} Last Edited: April 6, 1983  6:11 PM FUGATO Last Edited: August 1, 1982  12:57 PM nStkLimOffset Last Edited: March 24, 1983  8:48 PM start merging with Mesa 10 Last Edited: March 24, 1983  9:26 PM DiskCSBOffsetIOCBPurcell 25-Mar-84 12:10:35 comments only to reserve L3 sub fixups under L1.fixFV for FloatBlt and fft}{for using old dandelion.df with new diskDlion}{DISK CSB (Trident/Shugart/Quantum) - from 14000 to 1400F hex}  Set[DiskCSBOffsetIOCB, 1{0}];{make page rel {%1}}{Parameter Settings}Set[DEFspaceHi, Add[1{for now}, DEFspace]],{i}Set[VALspaceHi, Add[1{for now}, VALspace]],{i}Set[OpTable, 500],    {lisp constant KT}Set[KTval, 114'b],    {lisp constant KT}Set[AtomEVALFORM, 370'b],Set[AtomGCSCAN, 371'b],Set[AtomMAKENUMBER, 374'b],Set[AtomSETFVAR, 376'b],Set[AtomGCPUNT, 377'b];Set[AtomINTERPRETER, 400'b],Set[nRhS, 3],{i}{Real StackSpace}Set[nStkLimOffset, 7],{%}{Set[STATSspaceReal, 5],{i}??}Set[MDSTYPEspaceReal, 5];{i}Set[INTERFACEbasePage, Rshift[INTERFACEbase, 8]];Set[DTDbasePage, Rshift[DTDbase, 8]];Set[ListpDTD.Counter, 14'b],Set[ListpDTD.NextPage, 15'b],Set[ConsNxtPg,  Add[Lshift[ListType, 4], ListpDTD.NextPage]],Set[ConsCnt,  Add[Lshift[ListType, 4], ListpDTD.Counter]],Set[crhHashTable,5];{i} { Real Page = 2600'b = 580'x}Set[crhTypeTable,5],{i}{Real Page = 2400'b = 500'x}Set[LS4FptType, Lshift[FloatpType, 4]];Set[LS4FixpType, Lshift[FixpType, 4]];Set[UFNTablePage, Rshift[UFNTablebase, 8]];{R AND RH REGISTER DEFINITIONSSince there are no task specific registers in the machine, task identifiers are not bound to the register numbers with which they are shown.Q is reserved for the Emulator Task.Also, the stackP, STK, ib, and pc16 registers are reserved for the Emulator task.}{REGISTERS 0 - 6: EMULATOR}  {RegDef[TOS, R,	0];} {Top item of Stack (low word)}RegDef[CurBit,R,0];		{used by DrawLine (really TOS) current bit mask}RegDef[rhTOS, RH,	0];	{temporary}RegDef[TOSH, R,	1]; {Top item of Stack (high word)}RegDef[Delta,R,1];		{used by DrawLine (really TOSH)}RegDef[rhTOSH, RH,	1];	{temporary}  {RegDef[TT, R,	2];} {temporary}  {RegDef[rhTT, RH,	2];}{temporary}RegDef[PV, R,	3]; {base reg for prog vars}RegDef[rhPV, RH,	3];RegDef[S, R, 	4];    {Stack pointer points to full odd word {best for jump}}RegDef[rhS, RH,	4];  {RegDef[PC, R,	5];}  {real address of program counter (PC16 selects byte)}  {RegDef[rhPC, RH,	5];} {program counter high}  {RegDef[Rx, R,	6];}{temporary}  {RegDef[rhRx, RH,	6];}{temporary}  {RegDef[rCount, R,	7];}{instruction counter}{U REGISTER BLOCK 7,8 -- DISK(x000) &amp; TRIDENT}  {RegDef[uLimit,	U,	80];{rA=8}}  {RegDef[uDelta,	U,	81];}  {RegDef[uLimitH,	U,	70];{rA=7}}{U REGISTER BLOCK C,D -- ETHER}RegDef[rCountL,  R, 0C];   {Ether - debugging count}RegDef[rhCountL,  RH, 0C];   {Ether - debugging count}RegDef[rCountH,  R, 0D];   {Ether - debugging count}RegDef[rhCountH,  RH, 0D];   {Ether - debugging count}RegDef[uLispBootMsg, U, 0DE];	{also in nLispSAx000Initial.mc}{The allocation of Link registers:#    task0    Emulator1    Emulator2    Emulator3    Emulator4    Disk5    Display/LSEP6    Ethernet7    IOP}{U REGISTER DEFINITIONSRegisters indicated by ** contain Emulator state and must not be modified.}{U REGISTER BLOCK 0 -- EMULATOR STACK  TOS}RegDef[uValHigh,	U,	1]:{*** rA=TOS}{val space high virtual==22'b}  {RegDef[UBitBltArg,	U,	2];	{BitBlt}}RegDef[uYIncLo,U,2];		{ DrawLine temp Y direction/bm width}RegDef[uBusCtl, U, 2];{fZ=2}		{BusExt}  {RegDef[UHeight,	U,	3];	{BitBlt}}RegDef[uYIncHi,U,3];		{DrawLine temp Y direction/bm width hi part}  {RegDef[UDstVALo,	U,	4];	{BitBlt}}RegDef[uXCount,U,4];		{DrawLine temp X count value}  {RegDef[UDstBit,	U,	5];	{BitBlt}}  {RegDef[USrcVALo,	U,	6];	{BitBlt}}  {RegDef[USrcBit,	U,	7];	{BitBlt}}RegDef[uXT,U,7];		{DrawLine temp ABS value of X displacement}  {RegDef[UGray,	U,	8];	{BitBlt -- shares with USrcBpl}}RegDef[uYT,U,8];		{DrawLine temp ABS value of Y displacement}  {RegDef[UDstBpl,	U,	9];	{BitBlt}}RegDef[uYCount,U,9];		{DrawLine temp Number of pixels to draw}  {RegDef[UrhVS,	U,	0A];	{BitBlt}}  {RegDef[UrhVD,	U,	0B];	{BitBlt}}  {RegDef[UFlags,	U,	0C];	{BitBlt}}RegDef[uVirtH, U, 0C];{TOS}{ibNA}	{BusExt}  {RegDef[UWidth,	U,	0D];	{BitBlt}}RegDef[uTOS,	U,	0D];	{rA=TOS}{fZ=D=&larr;ib}{BitBlt}RegDef[uFF00,	U,	0E]: {*** rA=TOS}{FF00 to not use fY field}  {RegDef[uValHigh,	U,	0F]:}{*** rA=TOS}{val space high virtual==22'b}{U REGISTER BLOCK 1 -- EMULATOR   TOSH}  {RegDef[uWP,	U,	10];}	{** wakeups pending}RegDef[u0FF,	U,	13];	{** rA = TOSH}RegDef[uName,	U,	17];	{rA=TOSH}{name used by free var lookup}  {RegDef[uWDC,	U,	18];}	{** wakeup disable counter}  {RegDef[UGsave,	U,	19];}	{}{BitBlt}RegDef[uSTATE, U, 1A]; {reserved for uCODE TEST}RegDef[uIVar,	U,	1B];	{*** rA = TOSH}{fZ= &larr;RH}{stk addr IVARs}RegDef[uTOSH,	U,	1D];	{rA = T, fZ = &larr;ib{GCONST}}  {RegDef[UrhMDSsave,	U,	1E];} {BitBlt}RegDef[u7F,	U,	1F];{***}{U REGISTER BLOCK 2 -- EMULATOR   rA=TT}RegDef[uSTACKspace,	U,	20];	{** rA = TT}RegDef[u0FFF,	U,	21];	{** rA = TT}RegDef[UvPCpageL,	U,	22];	{** rA = TT, (PC page address)}RegDef[u1FF,	U,	23];	{** rA = TT}RegDef[uTT3FF,	U,	25];	{}{*** rA = TT}  {RegDef[uFaultParm0	,U,	26];	{** rA = TT; fault parameter}}RegDef[uPV,	U,	26];	{** rA #PV}{save PV}{BitBlt writes}RegDef[uTT,	U,	27];	{rA = TT}{** A,Z=TT,&larr;ibNA code base low v}RegDef[uVirtL, U, 27];{TT}{uTT}{BusExt}RegDef[u7FFF,	U,	28];	{** rA = TT}RegDef[u7FE,	U,	29];	{**}{rA=TT}RegDef[uTT3FFF	,U,	2A];	{** rA = TT;}RegDef[uPCCrossL,	U,	2B];	{** rA = TT; }{}RegDef[UvCL,	U,	2C];	{** A,Z=TT,&larr;ibNA code base low v}RegDef[UvChighL, U, 2D];	{** A,Z=TT,&larr;ib code base high v}  {RegDef[u1FFF,	U,	2E];}	{** constant}  {RegDef[u7FF,	U,	2F];}	{** constant}{U REGISTER BLOCK 3 -- EMULATOR  rA=PV}RegDef[uuPV,	U,	30];	{}	  {RegDef[UQSave,	U,	31];}	{BitBlt temp}	RegDef[uFxNoPushReturn,	U,	32];	{**==100}{%}{??RegDef[uU33,	U,	33]	{}}RegDef[uAddr, U, 33];{rAddr}{fZ=3}	{BusExt}  {RegDef[UWidthM1,	U,	34];}	{BitBlt temp}	RegDef[uCARhi,	U,	34];	{used in FMEMB}{LispBin}{ReclaimCell temp}{RegDef[Umask1,	U,	35];}	{BitBlt temp}	RegDef[uNxtCell,	U,	35];	{ReclaimCell temp}	{??RegDef[U36,	U,	36]	{}}RegDef[uCARlo, U, 37];{used in FMEMB}{ReclaimCell temp}  {RegDef[uFaultParm1,	U,	37];}	{fault parameter}  {RegDef[Umask2,	U,	37];}	{BitBlt temp}	{RegDef[UmaskL,	U,	38];}	{BitBlt temp}	RegDef[uFxInCall,	U,	39];	{**==400 }{%}RegDef[uGCPUNT, U, 03A]; {CREATECELL temp}  {RegDef[ULsave,	U,	3A];}	{BitBlt temp}  {RegDef[UrhLsave,	U,	3B];}	{BitBlt temp}RegDef[uGcZero,	U,	3B];	{GcRef temp}RegDef[uhiVA,	U,	3B];	{CADR temp}{U REGISTER BLOCK 4 -- EMULATOR  rA=S}RegDef[uStkLimO,	U,	40];	{**}{==FFFFh}RegDef[uDtd.size, U, 41]; {CREATECELL temp}RegDef[uDtd.NewCell.Hi, U, 42]; {CREATECELL temp}  {RegDef[UXsave,	U,	42];}	{BitBlt temp}RegDef[uDataOut, U, 42];{fZ=2}	{BusExt}RegDef[uDtd.NewCell.Lo, U, 43]; {CREATECELL temp}  {RegDef[UVSsave,	U,	43];}	{BitBlt temp}RegDef[uDtd.counter, U, 44]; {CREATECELL temp}  {RegDef[USrcVALoSav,	U,	44];}	{BitBlt temp}RegDef[uDtd.RAddr, U, 45]; {CREATECELL temp}RegDef[uTOSm1, U, 45]; {RPLX temp}RegDef[uNewValLo, U, 46]; {CREATECELL temp}RegDef[uTOSHm1, U, 46]; {RPLX temp}RegDef[uNewValHi, U, 47]; {CREATECELL temp}RegDef[urhRx, U, 4B]; {CREATECELL temp}  {RegDef[UrhGsave,	U,	4B];}	{rA = G, fZ = &larr;RH}{BitBLT}  {RegDef[uPPsave, U, 4C]} {LispFPTDefs}{U REGISTER BLOCK 5 -- EMULATOR  rA=PC}{??RegDef[uU50	,U,	50];	{}}RegDef[uSavOldHi,U,51],	{RplPtr temp}RegDef[uSaveTOS,U,51],	{BLT temp}RegDef[uNewCount,U,51],	{Cons temp}RegDef[uAddrNewCellLo,U,52],	{Cons temp}RegDef[uSavOldLo,U,52],	{RplPtr temp}RegDef[uSaveTT,U,52],	{BLT temp}RegDef[uCARsavlo, U, 52];{used in FMEMB}RegDef[uConsTemp,U,53],	{Cons temp}RegDef[uSaveTOSH,U,53],	{BLT temp}RegDef[uCARsavhi, U, 53];{used in FMEMB}RegDef[uGcLlo,U,55],	{GcLookup temp}RegDef[uGcLhi,U,56],	{GcLookup temp}RegDef[uCDRlo, U, 56];{used in FMEMB}RegDef[uGcLTem,U,57],	{GcLookup temp}RegDef[uCDRhi, U, 57];{used in FMEMB}RegDef[uGcLov,U,58],	{GcLookup temp}RegDef[uSavAddr,U,59],	{RplPtr temp}  {RegDef[UrhPCsave	,U,	5B];	{rA = PC, fZ = &larr;RH}{BitBlt temp} }RegDef[uPC	,U,	5B];	{rA = PC, fZ = &larr;RH}  {RegDef[UDstVALoSav	,U,	5C];	{BitBlt temp} }  {RegDef[UWidthW	,U,	5D];	{BitBlt temp} }{U REGISTER BLOCK 6 -- EMULATOR  rA=Rx} {lots of params for BandBLT &amp; Xfer}  {RegDef[ULcntsav,	U,	60];}	{BitBlt temp rA = Lcount}  {RegDef[uRx,	U,	60];	{Lisp temp rA = Rx} }RegDef[uFXmark,	U,	61];	{** rA = Rx; Frame Extension mark C000h}RegDef[uBFmark,	U,	62];	{** Basic Frame mark==8001h}RegDef[uUFNTableBaseHalf,	U,	63];	{** rA = T/Rx; }RegDef[uFreeStackBlock,	U,	64];	{** rA = T/Rx; }{==0A000}  {RegDef[uFLmode, U, 65]} {LispFPTDefs}RegDef[uBfResidualRhmask,	U,	66];	{** rA = T/Rx; }{==2FFh}RegDef[uESP,	U,	67];	{***}RegDef[uFunDef,	U,	68];	{}{last fun'n called to debug}RegDef[uChain,	U,	69];	{**}{chain;  free var lookup}RegDef[uuRx,	U,	6D];	{rA=Rx}{fZ=D=&larr;ib}RegDef[uLispOptions,	U,	6F];	{DO NOT DISTURB -- LISP ONLY}RegDef[uDTDbase,	U,	093];RegDef[uInitVersion,	U,	094];RegDef[uBBTime, U, 99];{var.display uses to hold number of blank lines at the bottom of the display} {initialized to be 14'd for normal screen, change to 142'd for videotaping}Set[CB2, 2];{	DTD table constants }Set[DTD.SIZE, 01'b]; {one word}Set[DTD.FREE, 02'b]; {two words}Set[DTD.FREEhi, 02'b]; {one word}Set[DTD.FREElo, 03'b]; {one word}Set[DTD.COUNTER, 14'b]; {one word}Set[DTD.NEXTPAGE, 15'b]; {one word}{new defs for GC things}Set[Q.AddRef,0],{setup for GcLookup}Set[Q.DelRef,1],{setup for GcLookup}{GcLookup links  return thru GcLookRet}Set[L2.gcref,1],{GcRef}Set[L2.RplDel,2],{RplPtr}Set[L2.RplAdd,3],{RplPtr}Set[L2.ConsAdd,4],{Cons}Set[L2.ConsDel,5],{Cons}Set[L2.ConsListAdd,6],{Cons}Set[L2.CrCell, 7];{CrCell}Set[L2.Recl1, 8];{ReclaimCell}Set[L2.Recl2, 9];{ReclaimCell}Set[L2.rplx1, 0A];{RPLACD}Set[L2.rplx2, 0B];{RPLACD}Set[L3.TTFGcL,1],{return points for unpack routine, FptUnpackRet}{also used by CreateCell}{also used as returns from ArithGetFixp}{also used after pagefaults}Set[L3.FptArg1, 04];Set[L3.FptArg2, 05];Set[L3.Sh, 06];Set[L3.utob, 07];{Link Codes for Common Subroutines}{Set[qPageFault, 62'b];set twice in init}    {page fault}{Set[qWriteProtect, 64'b];set twice in init}    {}Set[NWWInterrupt, 4'b];    {}Set[L2.0, 0 ];{L0  MaskRet}Set[L2.WFRet, 2];{must be 2 for WF}{MaskRet}Set[L2.WFRetOdd, 3];{must be 3 for WF}{MaskRet}Set[L2.WFRetMap, 0];{must be 0 for WF}Set[L2.WFRetMapOdd, 1];{must be 1 for WF}{conflict with TextBlt}Set[L2.GFRet, 04];{L0  RxMapFixCaller}Set[L0.RedoCADR, 0],Set[L0.xRedoGF, 1],Set[L0.xRedoFV, 2],Set[L0.xRedoFV0, 3],Set[L0.RedoRplX, 4];{MUST be even  --  uses 5 also}Set[L0.xRedoFVN, 6 ],Set[L0.xRedoCdr, 08],{MUST be even  --  uses 9 also}Set[L0.xRedoArith, 0C],{Set[L0.RedoBLT, 0D];{BLT} def'd at WMapFix}{L0  RLMapFix returns thru RMapFixCaller}Set[L0.RefillFNX, 0 ];Set[L0.RetRedo, 1 ];{}Set[L0.RedoBinA, 2 ];{}Set[L0.RedoEval, 3];{Eval}Set[L0.RedoGV, 4 ];{}Set[L0.RedoGBN, 5 ];{}Set[L0.RedoBP, 6 ];{}Set[L0.RedoGC, 7 ];{}Set[L0.ERefill,8];  {must be even}Set[L0.NERefill,0A];  {must end with 01}	Set[L0.NERefill.Set,8];  {must end with 00}	Set[WhichFixType,0B];  {used to distinquish between Refill &amp; JRemap}Set[L0.FCRedo, 0B ];{must be even}Set[L0.BYRedoE, 0C ];{must be even}Set[L0.BYRedoO, 0D ];{must be odd}Set[L0.FCHRedo, 0E ];{2 or 3 mod 4}Set[L0.JRemap,0F]; {must be 0F}  {Set[L0.ji,7];}{L3  FixForTrap}Set[L3.rhTT.Q, 1 ];Set[L3.rhTT.TT, 2 ];Set[L3.rhMDS.Q, 3 ];{L2  typ returns thru NewTypRet}{  1 used by CAR}{  2 used by CDR}{  3 used by LISTP}{  4 used by NTYPX}{  5 used by TYPEP}{  6 used by DTEST}Set[L2.ConsList, 7 ];{Cons}{Set[L2.ArithTyp, 8 ];{Arith}??}Set[L2.Recl, 9 ];{ReclaimCell}Set[L2.Eval, 8];{Eval}{L2  jn}Set[L2.ok, 0 ];{Set[L2.STK, 1 ];Set[L2.TOS, 2 ];}{L1  FixForTrap}{Fix routine to preserve Rx{context}}Set[L1.Dec3, 0]; {*GBITS}{Clock}Set[L1.TrapGC, 1 ]; {**GCONST}Set[L1.FCH, 2 ]; {**even}Set[L1.FC, 3 ]; {**funct call}Set[L1.DecOnly, 4]; {*Cadr}{RCLK}Set[L1.Ret, 5 ]; {*Return}Set[L1.PushOnly, 6 ]; {*PUTBASEPTRN (PUTBASEBYTE)}Set[L1.PopOnly, 7]; {=7 FVAR}{*GVAR FVAR}Set[L1.NoFixes, 8 ];{*GCONST}Set[L1.fixWF, 9 ]; {*PUTBITS}Set[L1.PushDec2,0A]; {*PUTBASEN}Set[L1.DecDec,0B]; {*GETBASE.N}Set[L1.Push2OK, 0C ]; {*PUTBASEBYTE}Set[L1.Refill, 0D ];	{**1-Refill}Set[L1.FNX, 0E ]; {must = 0E}{**FNX}Set[L1.fixFV, 0F]; {*fvLookup}{will restore TOSH, and TOS then L3Disp}{WMapFixCaller}Set[L0.RedoBox, 0];Set[L0.RedoW, 1 ];Set[L0.RedoBin, 2 ];Set[L0.RedoWF, 3 ];Set[L0.WBYRedoE, 4 ];{must be even}Set[L0.WBYRedoO, 5 ];{}Set[L0.RedoBoxArith, 6 ],Set[L0.RedoRecl, 7 ],{ReclaimCell}Set[L0.RedoClk, 8 ],Set[L0.RedoPBP, 9 ],Set[L0.RedoRpl, 0A ],{RplPtr}Set[L0.RedoCons1, 0B ],{Cons}Set[L0.RedoCons2, 0C ],{Cons}Set[L0.RedoBLT, 0D];{BLT}Set[L0.RedoMapNC, 0E];{CrCell}Set[L0.RedoMapDTD, 0F];{CrCell}{L3  fvLookUp returns thru fvCaller}Set[L3.FVAR, 2 ];{2 or 3 mod 4}Set[L3.FVARg, 0 ]; {must be even}Set[L3.fixFpt, 4]; {used after L1.fixFV}{Set[L3.FPALU, 04 ];{extended fixup from L1.fixFV}}{Set[L3.FPMul, 05 ];}{Set[L3.fixFFT, 06 ];{extended fixup from L1.fixFV}}Set[L3.Eval, 3];Set[L3.StkScan, 8];{L3 values for RPLPTR exits via RplEnd}Set[L3.RplGvar, 02];{these should all have the 2 bit on}Set[L3.RplPtr, 03];Set[L3.RPLACA, 06];{additional values used in RplX and CONS}Set[L3.RPLACD, 07];Set[L3.RPLCONS, 0A];Set[L3.CONS, 05];{return values for CADR subroutine through CADRret}Set[L3.fmemb, 3];{used in FMEMB}Set[L3.fassoc1, 4];{used in FMEMB}Set[L3.fassoc2, 5];{used in FMEMB}Set[L3.fprop1, 6];{used in FMEMB}Set[L3.fprop2, 7];{used in FMEMB}Set[L3.fprop3, 2];{used in FMEMB}{L2  ConsMapDTD returns thru ConsMapDTDRet}Set[L2.ConsNil, 8];{Set[L2.ConsDel, 5];}{L2  ConsMakeCell returns thru ConsCMCRet}{Set[L2.ConsNil, 8];}{Set[L2.ConsDel, 5];}{Set[L2.ConsList, 7];}{L3  used with L1.fixFV before fix returns thru fvfixup}{Set[L3.Eval, 3];}{Set[L3.StkScan, 8];}{L3  EvalGet returns thru EvalGetRet}{Set[L3.Eval, 3];}{	L2 values for arithmetics}Set[L2.plus, 10'b];Set[L2.iplus, 00'b];Set[L2.or, 04'b];Set[L2.and, 05'b];Set[L2.xor, 06'b];Set[L2.vag2, 01'b];Set[L2.diff, 11'b];Set[L2.idiff, 03'b];Set[L2.greaterp, 12'b];Set[L2.igreaterp, 7'b];Set[L2.times, 02'b];Set[L2.boxiplus, 13'b];Set[L2.boxidiff, 14'b];{L1  fvLookUp 2 bit on for XLDisp}Set[L1.fvStack, 2];Set[L1.fvUnbound, 3];Set[L1.fvGlobal, 6];{stack push ops}Set[L3.atm1, 0];Set[L3.atm3, Add[08,0]];Set[L3.pls1, 2];Set[L3.pls3, Add[08,2]];Set[L3.pls2, 4];Set[L3.neg2, 6];  {Set[OpcodeBase, 500];}  {MacroDef[WriteOK, LOOPHOLE[wok]];}  {MacroDef[opcode, at[Add[#1, OpcodeBase]]];}  {MacroDef[AlwaysIBDisp, (IBDisp, IBPtr&larr;1)];}MacroDef[ufn,  (  Rx &larr; #1'b, GOTO[ufn2], c1, at[Add[#1'b, OpcodeBase]])];MacroDef[ZeroBranch, ZeroBr]; {NZeroBR would force stack overflows}Set[IOPage.keyBitsm1, 3C];Set[IOPage.ProcessorCommand,15 {was 5A}];Set[IOPage.key, 41{3E}];Set[FinalMPCode, 1108'd];Set[LH.FMP, Rshift[FinalMPCode, 8] ];Set[RH.FMP, And[FinalMPCode, 0FF] ];Set[IOPage.MP, 12'x];	{ E N D }</pre>
  </body>
</html>
