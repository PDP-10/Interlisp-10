<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>LispBBB2.mc!1</title>
  </head>
  <body>
    <pre>
{File name LispBBB2.mcDescription: BitBlt op-codeAuthor: don charnleyLast edited: October 8, 1980  6:35 PMCreated: October 1983}{*****************************************************************************	BITBLT*****************************************************************************}{OLD: {CAUTION: there is a delicate sharing of .u+D by uTOS and UWidth; during faults UWidth is stored in TOS; at restart {BBpart} it is tested for nonZero and restorted}}{.u+2 thru .u+C must be preserved accross faults; in particular no bitBlt by fault handler}{TOS=0 if virgin BB call;  else suspended with saved state on stack under TOS}{2 args one usually 0 in TOS; S points to ptr to BBtable}	MAR &larr; [rhS, S+0],	c1, at[BBEntry];	{UWidth}Ybus &larr; TOS, NZeroBr,	c2;	TOS &larr; MD, BRANCH[$, BBpart],	c3;	MAR &larr; S &larr; [rhS, S - 1],	c1;	S&larr;S-1, CANCELBR[$, 2],	c2;	TOSH &larr; MD,	c3;{S points to some stack entry that has nothing to do with BB}{BBInit vs BBInit1 differ on advacing PC}	PC &larr; PC + 1{PC16}{1}{%?}{saveRegs does PC&larr;PC-1},	c1;	stackP &larr; 2,	c2;	,	c3;	,	c1;	STK{UBitBltArg} &larr; TOS, pop,	c2;	rhMDS &larr; TOSH LRot0, GOTO[@BITBLT],	c3;{@BITBLT returns directly to IBDispOnly; saves and restores L, G, PC}BBpart:	{Q &larr; 166'b, GOTO[sink2],	c1;}	,	c1;	PC &larr; PC + 1{PC16}{1}{%?}{undone by saveRegs},	c2;	stackP &larr; 0C{vestigial}, {GOTO[@BITBLT],}	c3;{restore 12 uRegs from memory stack: u2 thru u0D } 	stackP &larr; 0D,	c1;	Rx &larr; 0C,	c2;BBLp:	Noop,	c3;{Stack pointer points to full odd word } 	MAR &larr; S &larr; [rhS, S +0], 	c1;	S &larr; S - 2,	c2;	TT &larr; MD,	c3;	Rx &larr; Rx - 1, ZeroBr,	c1;	STK &larr; TT, pop, BRANCH[BBLp, BBLpD],	c2;BBLpD:	stackP &larr; 0C{not vestigial}, GOTO[@BITBLT],	c3;{@BITBLT returns  to IBDispOnly normally or to SaveRegs if fault {or interrupt}}{interupts are temporarily disabled in BB}{S points to some stack entry that has nothing to do with BB}{if faulting save 12 uRegs to memory stack: u2 thru u0D } {then set TOSH,TOS to nonzero to indicate BB suspended (PFault saves TOS)} {at PFault TOS is nonzero and under that is saved regs } SaveRegs: {come here on pageFault}{{state held in stack (faults can't bitblt)}}	rhTT &larr; uFaultParm1, 	c2;	TT &larr; uFaultParm0,	c3;{Stack pointer points to full odd word } {save 12 uRegs from memory stack: u2 thru u0D } 	stackP &larr; 02,	c1;	Rx &larr; 0C,	c2;BBsLp:	S{even empty} &larr; S{odd full} + 1,	c3;	MAR &larr; S &larr; [rhS, S +0], 	c1;	MDR &larr; smallpl,	c2;	S &larr; S + 1,	c3;	MAR &larr; S &larr; [rhS, S +0], 	c1;	MDR &larr; STK, push,	c2;	Noop,	c3;	Rx &larr; Rx - 1, ZeroBr,	c1;	BRANCH[BBsLp, BBsLpD],	c2;BBsLpD:	TOSH &larr; smallpl, L1 &larr; L1.NoFixes,	c3;	TOS &larr; 1, L0Disp,	c1;	stackP &larr; 0, DISP4[bbabn],	c2;	,	c3, at[restore.pf, 10, bbabn];	Bank &larr; EmuBank,	c1;	,	c2;	CROSS[BBFault],	c3;	uWP &larr; 0,	c3, at[restore.int, 10, bbabn];	Bank &larr; EmuBank,	c1;	,	c2;	CROSS[EmuInt],	c3;{S points to some stack entry that has nothing to do with BB}{Normal BB returns undefined : set TOSH, TOS to any valid object (use smallpl)}{@BITBLT returns directly to IBDispOnly; saves and restores L{PV}, G{S}, PC}{stackP was set to zero by BB as we return here; any thing below .u+D is ok}BBThru:	Bank &larr; EmuBank,	c1;	,	c2;	CROSS[BBExit],	c3;{*********************************************	MaskTbl  SUBROUTINE	1 cycle*********************************************}{	first cycle = c* , one cycle longThis subroutine generates a right justified mask. of n onesRETURNS THRU MaskRet}MaskTblB2:	TT &larr; 1, RET[MaskRet],	c*, at[0,10,MaskTbl];	TT &larr; 3, RET[MaskRet],	c*, at[1,10,MaskTbl];	TT &larr; 7, RET[MaskRet],	c*, at[2,10,MaskTbl];	TT &larr; 0F, RET[MaskRet],	c*, at[3,10,MaskTbl];	TT &larr; 1F, RET[MaskRet],	c*, at[4,10,MaskTbl];	TT &larr; 3F, RET[MaskRet],	c*, at[5,10,MaskTbl];	TT &larr; 7F, RET[MaskRet],	c*, at[6,10,MaskTbl];	TT &larr; 0FF, RET[MaskRet],	c*, at[7,10,MaskTbl];	TT &larr; LShift1 0FF, SE&larr;1, RET[MaskRet] {TT &larr; 1FF},	c*, at[8,10,MaskTbl];	TT &larr; RShift1 u7FF, RET[MaskRet] {TT &larr; 3FF},	c*, at[9,10,MaskTbl];	TT &larr; u7FF, RET[MaskRet] {TT &larr; 7FF},	c*, at[0A,10,MaskTbl];	TT &larr; RShift1 u1FFF, RET[MaskRet] {TT &larr; FFF},	c*, at[0B,10,MaskTbl];	TT &larr; u1FFF, RET[MaskRet] {TT &larr; 1FFF},	c*, at[0C,10,MaskTbl];	TT &larr; uTT3FFF, RET[MaskRet] {TT &larr; 3FFF},	c*, at[0D,10,MaskTbl];	TT &larr; RShift1 (~TT xor TT), RET[MaskRet] {TT &larr; 7FFF},	c*, at[0E,10,MaskTbl];	TT &larr; ~TT xor TT, RET[MaskRet] {TT &larr; FFFF},	c*, at[0F,10,MaskTbl];	{ E N D }</pre>
  </body>
</html>
