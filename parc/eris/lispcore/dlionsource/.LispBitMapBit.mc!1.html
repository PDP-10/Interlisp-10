<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DLionSource>LispBitMapBit.mc!1</title>
  </head>
  <body>
    <pre>
{File : LispBitMapBit.mcAuthor : Gunawan SantosaCreated : 26-Feb-85 14:05:34================================================================================================(BITMAPBIT BitMap X Y NewValue)================================================================================================	if 0 =&lt; NewValue =&lt; max value for a pixel		then:	 Pixel(X, Y) &larr; NewValue			 return old Pixel(X, Y)			 	if NewValue = NIL		then:	 return Pixel(X, Y)			else ERROR {UFN}	in case (X, Y) outside BitMap		then return 0 (and no mods)			NOTE:   BitMap can also be a window		UFN in this case!			"BitMap" is a six word record of the following format:	0:	BitMapBaseHi -- High word of Virtual Addr of [0, 0] of BitMap {upper left screen corner}	1:	BitMapBaseLo -- Low word of Virtual Addr of [0, 0] of BitMap {upper left screen corner}	2:	BitMapRasterWidth (words)	3:	BitMapHeight (lines)	4:	BitMapWidth (Pixels)	5:	BitMapBitsPerPixel ({1 or 4 or 8})	fetch stack parameters:	S - 4:	BitMap		S - 2:	X	S - 0:	Y	TOS:	NewValue	Test that the TYPE of BitMap = BitMapType	fetch BitMap parameters:	BitMapBaseHi -- High word of Virtual Addr of [0, 0] of BitMap {upper left screen corner}	BitMapBaseLo -- Low word of Virtual Addr of [0, 0] of BitMap {upper left screen corner}	BitMapRasterWidth (words)	BitMapHeight (lines)	BitMapWidth (Pixels)	BitMapBitsPerPixel ({1 or 4 or 8})	calculate word-address of pixel, and pixel-mask	read old pixel value	store new pixel value if appropriate}Set[BitMapType, 35'd]; {For BitMapBit}Set[L0.BMMULT0, 5]; {For BitMapBit}Set[L0.BMMULT1, 6]; {For BitMapBit}Set[L0.BMB.NR.0B, 0B]; {For BitMapBit}Set[L0.GBMP, 9]; {For BitMapBit} RegDef[uBITMAPLO, U, 3A]; {For BitMapBit, low VA of Bitmap, tmp}RegDef[uBITMAPHI, U,3B]; {For BitMapBit, high VA of Bitmap, tmp}RegDef[uYLo, U, 57]; {For BitMapBit, low word of Y, tmp}RegDef[uBITMAPBASELO, U, 42]; {For BitMapBit, low VA of Bitmapbase, tmp}RegDef[uBITMAPBASEHI, U, 44]; {For BitMapBit, high VA of Bitmapbase, tmp}RegDef[uBITMAPRASTERWIDTH, U, 2]; {For BitMapBit, Bitmaprasterwidth, tmp}RegDef[uBITMAPHEIGHT, U, 3]; {For BitMapBit, Bitmapheight, tmp}RegDef[uBITMAPWIDTH, U, 34]; {For BitMapBit, Bitmapwidth, tmp}RegDef[uBITMAPBITSPERPIXEL, U, 7]; {For BitMapBit, Bitmapbitsperpixel, tmp}RegDef[uDBMBaseLo, U, 30]; {For BitMapBit, low VA of Bitmapbase, tmp}RegDef[uDBMBaseHi, U, 51]; {For BitMapBit, high VA of Bitmapbase, tmp}RegDef[uDBRasterWidth, U, 53]; {For BitMapBit, Bitmaprasterwidth, tmp}RegDef[uDBitMapHeight, U, 56]; {For BitMapBit, Bitmapheight, tmp}RegDef[uDBitMapWidth, U, 55]; {For BitMapBit, Bitmapwidth, tmp}RegDef[uDBitsPerPixel, U, 59]; {For BitMapBit, Bitmapbitsperpixel, tmp}RegDef[uTT1, U, 47]; {For BitMapBit, tmp}RegDef[uMASKL, U, 45]; {For BitMapBit, tmp}RegDef[uZ, U, 35]; {For BitMapBit, tmp}{=======================================================================Fetch BitMap, X, Y, and NewValue=======================================================================@FLOATARRAY2:	opcode[373'b],	Bank &larr; FAOPBank, L1 &larr; 3{L1.LFA2prep},	c1;	uTOS &larr; TOS,				c2;	uTOSH &larr; TOSH, CROSS[FOP2],		c3;	at[FOP2],	Xbus &larr; ibNA, XDisp,			c1;	DISP4[FOP2Disp], L2 &larr; 0,		c2;}	TT &larr; S, rhTT &larr; nRhS,			c3, at[06, 10, FOP2Disp];						    {Link value for Bitmap parameters fetch}						    BR000:	MAR &larr; [rhS, S-1], L1 &larr; L1.NoFixesB2,	c1; {Point to high word of Y}	TT &larr; TT - 2, CANCELBR[$, 2],		c2; {Prepare TT to fetch X}	Q &larr; MD,					c3; 			MAR &larr; [rhS, S+0], L3 &larr; 0,		c1; {Point to low word of Y}	Ybus &larr; Q xor smallpl, ZeroBr,		c2;	Q &larr; MD,	BRANCH[YNOK, $],		c3;	MAR &larr; [rhTT, TT-1],			c1; {Point to high word of X}	uYLo &larr; Q, CANCELBR[$, 2],		c2; {uYLo is low word of Y}	Rx &larr; MD,				c3;		MAR &larr; [rhTT, TT+0],			c1; {Point to low word of X}	TT &larr; TT-2, L2 &larr; 6, 			c2; {Prepare TT to fetch BitMap}	Q &larr; MD,	 				c3;	MAR &larr; [rhTT, TT-1],				c1;	Ybus &larr; Rx xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {uXLo is low word of X}	Rx &larr; MD, BRANCH[XNOK, $],			c3; {Rx is high VA of BitMap}	MAR &larr; [rhTT, TT+0],			c1;	uXLo &larr; Q,  				c2; {uXHi is high word of X}	TT &larr; MD, CALL[GetandTestBitMapParams],	c3; {TT is low VA of BitMap}						    {Check Type of Bitmap and fetch Record}		Ybus &larr; Q - 1, ZeroBr,			c3, at[6, 10, GetBitMapParamsRet];					   	    {Q contains value of Bitsperpixel}	{======================================================Determine bits per pixel value ======================================================}	Ybus &larr; Q xor 4, ZeroBr, BRANCH[$, OneBitperPixel],			c1;	Ybus &larr; Q xor 8, ZeroBr, BRANCH[$, FourBitsperPixel],			c2;	TT &larr; RRot1 uXLo, BRANCH[IllegalBitsperPixel, EightBitsperPixel],	c3; {Divide X by 2}OneBitperPixel:	uMASKL &larr; Q, CANCELBR[$],	c2; {Load initial mask value (=1)}	TT &larr; uXLo, GOTO[bmbvalchk],	c3; {Load X into TT}FourBitsperPixel:	Q &larr; 0F, CANCELBR[$],		c3; {Load initial mask value (=0000000000001111)}	uMASKL &larr; Q,					c1;	TT &larr; LShift1 uXLo, SE &larr; 0,			c2; {Divide X by 4}	TT &larr; LShift1 TT, SE &larr; 0, GOTO[bmbvalchk],	c3; {Load the result into TT}EightBitsperPixel:	Q &larr; 0FF,			c1; {Load initial mask value (=0000000011111111)}	uMASKL &larr; Q,			c2;	TT &larr; TT LRot4, GOTO[bmbvalchk],	c3; {Multiply TT by 16}bmbvalchk:	Rx &larr; uBITMAPWIDTH,		c1; {Check if X inside Bitmap}	Ybus &larr; Rx - TT - 1, CarryBr,	c2;	uZ &larr; TT, BRANCH[XValTooBig, $],	c3; {uZ = X * Bits per pixel}		TT &larr; TT and ~0F,		c1; {Divide TT by 16}	TT &larr; TT LRot12,			c2;	uXLo &larr; TT,			c3; {uXLo = X * Bits per pixel / 16}		Ybus &larr; Q - TOS, CarryBr,			c1; {Check if NewValue doesn't exceed max value} 	Rx &larr; uYLo, BRANCH[PixelValueTooBig, $],	c2;		TT &larr; uBITMAPHEIGHT, L0 &larr; L0.BMMULT0,	c3;		Q &larr; TT - Rx - 1, CarryBr,				c1;{Calculate the Y offset}	TOS &larr; uBITMAPRASTERWIDTH, BRANCH[YValTooBig, $],	c2;	CALL[MTPL],						c3; {Y*Bitmaprasterwidth}			{================================================================================Calculate address of pixel(X,Y)================================================================================Address = (Y*BITMAPRASTERWIDTH + (X*BITMAPBITSPERPIXEL)/16)+BITMAPBASE}	Rx &larr; uXLo, L1 &larr; L1.RestoreTosB2,  		c2, at[L0.BMMULT0, 10, MULCALLER];	Rx &larr; Rx + Q, CarryBr,				c3; {Start adding}		Q &larr; uBITMAPBASELO, BRANCH[RXNC1, RXCR1],	c1; {Load low word of base address}RXNC1:	GOTO[ADCL],					c2; {No carry to high order word}RXCR1:	TT &larr; TT + 1, 					c2; {Propagate carry to high order word}ADCL:	Rx &larr; Rx + Q, CarryBr, 				c3; {Set up low word of address}AD11:	Q &larr; uBITMAPBASEHI, BRANCH[RXNC2, RXC2],		c1; {Load high word of base address}RXNC2:	TT &larr; TT + Q, GOTO[HINC1],			c2;RXC2:	TT &larr; TT + Q + 1, 				c2; {Propagate carry to high word}HINC1:	rhTT &larr; TT LRot0, GOTO[HINC2],			c3;  {Set up high word of address}			{================================================================================Read pixel(X,Y)================================================================================}HINC2:	Map &larr; TT &larr; [rhTT, Rx],			c1;	L0 &larr; L0.BMB.NR.0B,			c2;	rhRx &larr; Rx &larr; MD, XwdDisp,		c3;	MAR &larr; Q &larr; [rhRx, TT + 0], DISP2[BMCHCK],	c1, at[L0.BMB.NR.0B, 10, NRWMapFixCallerB2];	uRx &larr; Q,					c2, at[1, 4, BMCHCK];	TT &larr; MD, 					c3; {Store it in TT}	Rx &larr; uBITMAPBITSPERPIXEL ,	c1; 	Q &larr; uZ, L0 &larr; 0A,		c2; {Retrieve X*Bits per pixel}	Rx &larr; Q + Rx, YDisp, 		c3;						{==========================================================================	Allign old pixels values==========================================================================	Rotate left by : (((X*Bitsperpixel) mod 16) + Bitsperpixel) mod 16)}	Q &larr; uMASKL, DISP4[Allign],	c1; {Allign old pixel value to right hand side}	uTTtmp &larr; TT,			c2, at[0A, 10, AllignRet]; {Save the entire word}	TT &larr; TT and Q, 			c3; {Mask off unwanted bits}		uTT1 &larr; TT, 				c1; {Save the old value}	Ybus &larr; TOSH xor smallpl, ZeroBr,	c2; {Check if TOSH = 0E}	TOS &larr; uTOS, BRANCH[TSQN, TSOK],		c3; {Retrieve new value}{=========================================================================	Allign new pixels values=========================================================================Rotate left by: (16 - Bitsperpixel) - ((X*Bitsperpixel) mod 16)}		TSOK:	Q &larr; uTTtmp,			c1; {Retrieve the old word}	TT &larr; Q - TT,			c2; {Mask off old value}	TT &larr; TT or TOS,	L0 &larr; 0B,	c3; {Put the new value in}	Ybus &larr; 0 - Rx, YDisp,		c1;	Rx &larr; uRx, DISP4[Allign],	c2; {Allign the new word, restore Rx}	S &larr; S - 6, GOTO[WrNV],		c3, at[0B, 10, AllignRet]; {Write new word}	TSQN:	Ybus &larr; TOSH or TOS, ZeroBr,	c1; {Check if new value is NIL}	BRANCH[TSNK, TSN],		c2;TSN:	TOSH &larr; smallpl,			c3; {Set up TOSH}			Xbus &larr; ib,			c1;	TOS &larr; uTT1,			c2; {Return old value of pixel (X,Y)}	S &larr; S - 6, GOTO[c1.pc2B2],	c3; {Exit point when NewValue is NIL}	TSNK:	GOTO[ufnZ1],			c3;	 {=======================================================================Write NewValue into pixel(X, Y)=======================================================================}	WrNV:	MAR &larr; [rhRx, Rx + 0],		c1;	MDR &larr; TT , Xbus &larr; ib,		c2; {Write it}	TOS &larr; uTT1, GOTO[c1.pc2B2],	c3; {Exit point is here}	{==============================================(X,Y) is outside BITMAP or invalid number==============================================If X or Y is outside BITMAP, return 0.}XNOK:	GOTO[ufnX2],			c1;YNOK:	GOTO[ufnX2],			c1;XYER12:	TOS &larr; 0, Xbus &larr; ib,		c1; {If (X,Y) outside bitmap, return 0}	TOSH &larr; smallpl,			c2;	S &larr; S - 6, GOTO[c1.pc2B2],	c3;XYER13:	TOS &larr; 0, Xbus &larr; ib,		c1; {If (X,Y) outside bitmap, return 0}bmbsettosh:	TOSH &larr; smallpl,			c2;	S &larr; S - 6, GOTO[c1.pc2B2],	c3;{======================================================================Bitmapbitsperpixel other than 1, 4 or 8, or NewValue exceeds max value======================================================================}IllegalBitsperPixel:	GOTO[ufnX2],	c1;PixelValueTooBig:	GOTO[ufnX1],	c3;XValTooBig:	TOS &larr; 0, Xbus &larr; ib, GOTO[bmbsettosh],	c1;YValTooBig:	TOS &larr; 0, Xbus &larr; ib, 	c3;		GOTO[bmbsettosh],	c1;{=======================================================================Map check=======================================================================}		GOTO[NRWLMapFixB2],	c2, at[0, 4, BMCHCK];	GOTO[NRWLMapFixB2],	c2, at[2, 4, BMCHCK];	GOTO[NRWLMapFixB2],	c2, at[3, 4, BMCHCK];	{=======================================================================Multiplier subroutine=======================================================================Q = multiplicandTOS = multiplierRx = counter(TT Q) contains the result, Q is least significant word.}MTPL:	Rx &larr; 10,					c*{c1};	TT &larr; 0,						c*{c2};MLLP:	Ybus &larr; Q and 1, NZeroBr, 			c*{c3};	Rx &larr; Rx - 1, ZeroBr, BRANCH[MPL0, MPL1],	c*{c1};	MPL0:	TT &larr; DARShift1 (TT + 0), BRANCH[MLLP, MLPE],	c*{c2};MPL1:	TT &larr; DARShift1 (TT + TOS), BRANCH[MLLP, MLPE],	c*{c2};MLPE:	Q &larr; ~Q, L0Disp,					c*{c3};	RET[MULCALLER],					c*{c1};{=======================================================================Test type of Bitmap and fetch record of Bitmap=======================================================================	subroutine to check BitMap type and get BitMap parameters	Rx, TT have VA of BitMapTable	L3 &larr; 0{Src}/1{Dst}  has six or'd in at exit	L2 used for return	uses NoFixes if PageFault	trashes L0, L1, TT, Rx, Q, rhTT, rhRx	values from table are placed into:	if Src then : 	uBITMAPBASEHI		if Dst then :	uDBMBaseHi			uBITMAPBASELO				uDBMBaseLo			uBITMAPRASTERWIDTH			uDRasterWidth			uBITMAPHEIGHT				uDBitMapHeight			uBITMAPWIDTH				uDBitMapWidth			uBITMAPBITSPERPIXEL			uDBitsPerPixel			Set[L0.GBMP, 09];{must be odd!  uses even also}}GetandTestBitMapParams:	MAR &larr; Q &larr; [TT, Rx + 0],			c1;{not mem ref, byte merge}	rhTT &larr; Rx LRot0, 			c2;	Rx &larr; Q, rhRx &larr; crhTypeTable,		c3;	Rx &larr; Rx LRot8,				c1;	Rx &larr; Rx RShift1, getTypemsBit, 		c2;	Q &larr; 0FF,				c3;	MAR &larr; [rhRx, Rx + 0],			c1;	Rx &larr; BitMapType,			c2;	Rx &larr; MD xor Rx,				c3;GetBitMapParams:	Map &larr; [rhTT, TT], L1 &larr; L1.NoFixesB2,			c1;	Ybus &larr; Q and Rx, ZeroBr, L0 &larr; L0.GBMP,			c2;	Rx &larr; rhRx &larr; MD, XRefBr, BRANCH[notBitMapufn, $],	c3;	MAR &larr; Q &larr; [rhRx, TT + 0], BRANCH[GBMremapit, $],	c1, at[L0.GBMP, 10, RMapFixCallerB2];	Rx &larr; Q, L3Disp,						c2;	Q &larr; MD, L3Disp, DISP3[GBMfixitret, 1]			c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest1],		c1, at[1, 8, GBMfixitret];	uBITMAPBASEHI &larr; Q, CANCELBR[$, 2],			c2;GBMdest1ret:	Q &larr; MD, L3Disp,						c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest2],		c1;	uBITMAPBASELO &larr; Q, BRANCH[$, GBMfixitA, 1],		c2;GBMdest2ret:	Q &larr; MD, L3Disp,						c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest3, 2],	c1, at[3, 8, GBMfixitret];	uBITMAPRASTERWIDTH &larr; Q, CANCELBR[$, 2],			c2;GBMdest3ret:	Q &larr; MD, L3Disp,						c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest4, 6], L3 &larr; 6,	c1;	uBITMAPHEIGHT &larr; Q, BRANCH[$, GBMfixitB, 1],			c2;GBMdest4ret:	Q &larr; MD, L3Disp,							c3;	MAR &larr; [rhRx, Rx + 1], BRANCH[$, GBMdest5, 6],			c1, at[7, 8, GBMfixitret];	uBITMAPWIDTH &larr; Q, CANCELBR[$, 2],				c2;GBMdest5ret:	Q &larr; MD, L3Disp,							c3;	BRANCH[$, GBMdest6, 6], L2Disp,					c1;	uBITMAPBITSPERPIXEL &larr; Q, DISP4[GetBitMapParamsRet],		c2;GBMdest1:	uDBMBaseHi &larr; Q, CANCELBR[GBMdest1ret, 2],			c2;GBMdest2:	uDBMBaseLo &larr; Q, BRANCH[GBMdest2ret, GBMfixitA, 1],		c2;GBMdest3:	uDBRasterWidth &larr; Q, CANCELBR[GBMdest3ret, 2],			c2;GBMdest4:	uDBitMapHeight &larr; Q, BRANCH[GBMdest4ret, GBMfixitB, 1],		c2;GBMdest5:	uDBitMapWidth &larr; Q, CANCELBR[GBMdest5ret, 2],			c2;GBMdest6:	uDBitsPerPixel &larr; Q, DISP4[GetBitMapParamsRet],			c2;GBMremapit:	CALL[RLMapFixB2],						c2;GBMfixitA:	TT &larr; TT and ~0FF, GOTO[GBMallfixit],				c3;GBMfixitB:	TT &larr; TT and ~0FF, GOTO[GBMallfixit],				c3;GBMallfixit:	Q &larr; 0FF + 1,							c1;	TT &larr; TT + Q, CarryBr,						c2;	Rx &larr; 0, BRANCH[GetBitMapParams, GBMfixrh],			c3;GBMfixrh:	Q &larr; rhTT,							c1;	Q &larr; Q + 1,							c2;	rhTT &larr; Q LRot0,	GOTO[GetBitMapParams],				c3;					notBitMapufn:	CANCELBR[ufnX2, 3],						c1;	{END}			</pre>
  </body>
</html>
