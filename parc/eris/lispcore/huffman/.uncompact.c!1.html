<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>huffman>uncompact.c!1</title>
  </head>
  <body>
    <pre>
#ifndef lintstatic char sccsid[] = "@(#)uncompact.c	4.7 (Berkeley) 8/25/84";#endif/* *  Uncompact adaptive Huffman code input to output * *  On - line algorithm * *  Input file does not contain decoding tree * *  Written by Colin L. Mc Master (UCB) February 14, 1979 */#include "compact.h"#include &lt;strings.h&gt;union	cio c;union	cio d;char	*infname;			/* input file's name */char	fname[MAXPATHLEN+1];		/* output file's name */struct	stat status;			/* compacted file status */int	verbose = 0;main(argc, argv)	int argc;	char *argv[];{	register short j;	argc--, argv++;	if (argc &gt; 0 &amp;&amp; strcmp(*argv, "-v") == 0) {		verbose++;		argc--, argv++;	}	dir[513].next = NULL;	for (head = dir + (j = 513); j--; ) {		dirp = head--;		head-&gt;next = dirp;	}	bottom = dirp-&gt;pt = dict;	dict[0].sons[LEFT].top = dict[0].sons[RIGHT].top = dirp;	dirq = dirp-&gt;next;	in[EF].flags = FBIT | SEEN;	if (argc == 0)		exit(uncompact("-"));	for (j = 0; j &lt; argc; j++) {		if (uncompact(argv[j]))			exit(1);		if (verbose &amp;&amp; argc &gt; 0)			printf("%s uncompacted to %s\n", argv[j], fname);	}	exit(0);}uncompact(file)	char *file;{	int ignore;	FILE *setup();	bottom-&gt;sons[RIGHT].top-&gt;next = flist;	bottom-&gt;sons[RIGHT].top = dirp;	flist = dirq;	uncfp = cfp = NULL;	if (strcmp(file, "-") != 0) {		char *cp;		strcpy(fname, file);		cp = rindex(fname, '.');		if (cp == 0 || strcmp(cp, ".C") != 0) {			fprintf(stderr,			    "uncompact: %s: File must have .C suffix.\n", file);			goto bad;		}		*cp = '\0';		cfp = fopen(file, "r");		if (cfp == NULL) {			fprintf(stderr, "uncompact: "), perror(file);			goto bad;		}		(void) fstat(fileno(cfp), &amp;status);	} else		cfp = stdin;	infname = file;	uncfp = setup(cfp, &amp;ignore);	if (uncfp == NULL) {		if (ignore)			goto done;		goto bad;	}	decompress(cfp, uncfp);	fflush(uncfp);	if (ferror(uncfp) || ferror(cfp)) {		fprintf(stderr, "uncompact: ");		if (uncfp != stdout) {			if (ferror(uncfp))				perror(fname);			else				perror(infname);			(void) unlink(fname);		} else			fprintf(stderr,	    "Unsuccessful uncompact of standard input to standard output.\n");		goto bad;	}	if (uncfp != stdout &amp;&amp; unlink(infname) &lt; 0)		fprintf(stderr, "uncompact: "), perror(infname);done:	if (uncfp != NULL &amp;&amp; uncfp != stdout)		fclose(uncfp);	if (cfp != NULL)		fclose(cfp);	return (0);bad:	if (cfp != NULL)		fclose(cfp);	return (1);}decompress(cfp, uncfp)	register FILE *cfp, *uncfp;{	register struct node *p;	register short j;	register int m;	register struct cio *dp = &amp;d;	char b;	p = dict;	while ((c.integ = getc (cfp)) != EOF) {		for (m = 0200; m; ) {			b = (m &amp; c.integ ? 1 : 0);			m &gt;&gt;= 1;			if (p-&gt;fath.flags &amp; (b ? RLEAF : LLEAF)) {				dp-&gt;integ = p-&gt;sons[b].sp.ch;				if (dp-&gt;integ == EF)					break;				if (dp-&gt;integ == NC) {					uptree(NC);					dp-&gt;integ = 0;					for (j = 8; j--; m &gt;&gt;= 1) {						if (m == 0) {							c.integ = getc(cfp);							m = 0200;						}						dp-&gt;integ &lt;&lt;= 1;						if (m &amp; c.integ)							dp-&gt;integ++;					}					insert(dp-&gt;integ);				}				uptree(dp-&gt;integ);				putc(dp-&gt;chars.lob, uncfp);				p = dict;			} else				p = p-&gt;sons[b].sp.p;		}	}}FILE *setup(cfp, ignore)	FILE *cfp;	int *ignore;{	FILE *uncfp = NULL;	register union cio *dp = &amp;d;	register union cio *cp = &amp;c;	*ignore = 0;	dp-&gt;integ = getc(cfp);	if (dp-&gt;integ != EOF) {			cp-&gt;integ = getc(cfp);		if (cp-&gt;integ != EOF)			dp-&gt;chars.hib = cp-&gt;integ &amp; 0377;	} else		dp-&gt;integ = 0;	if ((dp-&gt;integ &amp;= 0177777) != COMPACTED) {		fprintf(stderr, "uncompact: ");		if (dp-&gt;integ == PACKED)			fprintf(stderr, "%s: File is packed, use unpack.\n",			    infname);		else			fprintf(stderr, "%s: Not a compacted file.\n", infname);		*ignore = 1;		goto bad;	}	if (strcmp(infname, "-") != 0) {		uncfp = fopen(fname, "w");		if (uncfp == NULL)			goto bad2;		(void) fchmod(fileno(uncfp), status.st&larr;mode);	} else		uncfp = stdout;	cp-&gt;integ = getc(cfp);	if (cp-&gt;integ == EOF)		goto bad2;	putc(cp-&gt;chars.lob, uncfp);	in[NC].fp = in[EF].fp = dict[0].sons[LEFT].sp.p = bottom = dict + 1;	bottom-&gt;sons[LEFT].count = bottom-&gt;sons[RIGHT].count =	    dict[0].sons[RIGHT].count = 1;	dirp-&gt;next = dict[0].sons[RIGHT].top = bottom-&gt;sons[LEFT].top =	    bottom-&gt;sons[RIGHT].top = dirq = NEW;	dirq-&gt;next = NULL;	dict[0].fath.fp = NULL;	dirq-&gt;pt = bottom-&gt;fath.fp = in[cp-&gt;integ].fp = dict;	in[cp-&gt;integ].flags = (FBIT | SEEN);	in[NC].flags = SEEN;	dict[0].fath.flags = RLEAF;	bottom-&gt;fath.flags = (LLEAF | RLEAF);	dict[0].sons[LEFT].count = 2;	dict[0].sons[RIGHT].sp.ch = cp-&gt;integ;	bottom-&gt;sons[LEFT].sp.ch = NC;	bottom-&gt;sons[RIGHT].sp.ch = EF;	return (uncfp);bad2:	fprintf(stderr, "uncompact: ");	perror(fname);bad:	if (uncfp &amp;&amp; uncfp != stdout) {		(void) unlink(fname);		fclose(uncfp);	}	return (NULL);}</pre>
  </body>
</html>
