<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>huffman>compact.c!1</title>
  </head>
  <body>
    <pre>
#ifndef lintstatic char sccsid[] = "@(#)compact.c	4.7 (Berkeley) 8/25/84";#endif/* *  Adaptive Huffman code input to output * *  On - line algorithm * *  Does not prepend decoding tree * *  Written by Colin L. Mc Master (UCB) February 28, 1979 */#include &lt;strings.h&gt;#include "compact.h"union	cio d;union	cio c;int	bits;char	*infname;			/* input file's name */char	fname[MAXPATHLEN+1];		/* output file's name */struct	stat ucfstatus;			/* uncompacted file status */int	verbose = 0;main(argc, argv)	int argc;	char *argv[];{	register short j;	argc--, argv++;	if (argc &gt; 0 &amp;&amp; strcmp(*argv, "-v") == 0) {		verbose++;		argc--, argv++;	}	dir[513].next = NULL;	for (head = dir + (j = 513); j--; ) {		dirp = head--;		head-&gt;next = dirp;	}	bottom = dirp-&gt;pt = dict;	dict[0].sons[LEFT].top = dict[0].sons[RIGHT].top = dirp;	dirq = dirp-&gt;next;	in[EF].flags = FBIT | SEEN;	if (argc == 0)		exit(compact("-"));	for (j = 0; j &lt; argc; j++) {		if (verbose &amp;&amp; argc &gt; 0)			printf("%s: ", argv[j]);		if (compact(argv[j]))			exit(1);	}	exit(0);}/* * Compact a single file ("-" implies stdin). */compact(file)	char *file;{	int j, ignore;	FILE *setup();	for (j = 256; j--; )		in[j].flags = 0;	bottom-&gt;sons[RIGHT].top-&gt;next = flist;	bottom-&gt;sons[RIGHT].top = dirp;	flist = dirq;	cfp = uncfp = NULL;	if (strcmp(file, "-") != 0) {		char *cp, *tp;		/* verify .C suffix fits */		cp = rindex(file, '/');		if (cp == 0)			cp = file;		else			cp++;		tp = index(cp, '\0');		if (tp - cp &gt; MAXNAMLEN || strlen(file) + 2 &gt;= MAXPATHLEN) {			fprintf(stderr, "%s: File name too long\n", file);			goto bad;		}		uncfp = fopen(file, "r");		if (uncfp == NULL) {			fprintf(stderr, "compact: "), perror(file);			goto bad;		}		fstat(fileno(uncfp), &amp;ucfstatus);		if ((ucfstatus.st&larr;mode &amp; S&larr;IFMT) != S&larr;IFREG) {			fprintf(stderr, "%s: Not a regular file.\n", file);			goto bad;		}	} else		uncfp = stdin;	infname = file;	cfp = setup(uncfp, &amp;ignore);	if (cfp == NULL) {		if (ignore)			goto done;		goto bad;	}	if (compress(uncfp, cfp)) {		if (cfp != stdout)			(void) unlink(fname);		goto bad2;	}	encode(EF);	if (bits) {		d.integ &lt;&lt;= 16 - bits;		putc(d.chars.hib, cfp);		if (bits &gt; 8)			putc(d.chars.lob, cfp);		bits = 0;	}	fflush(cfp);	if (ferror(uncfp) || ferror(cfp)) {		if (cfp != stdout) {			fprintf(stderr, "compact: ");			if (ferror(cfp))				perror(fname);			else				perror(infname);			(void) unlink(fname);		}		goto bad;	}	if (cfp != stdout) {		struct stat cfstatus;		longint csize, ucsize;		(void) fstat(fileno(cfp), &amp;cfstatus);		csize = cfstatus.st&larr;size;		ucsize = ucfstatus.st&larr;size;		if (csize &gt;= ucsize) {			fprintf("%s: ", infname);			(void) unlink(fname);			printf("Not compacted, does not save bytes.\n");			goto done;		}		if (verbose) {			FILE *fd;			longint n, m;			while (ucsize - csize &gt; 21474) {				ucsize /= 10;				csize /= 10;			}			n = 100000 * (ucsize - csize) / ucsize + 5;			m = (n % 1000) / 10;			bits = m % 10 + '0';			c.integ = m / 10 + '0';			printf("%ld.%c%c%% compression\n",			    n / 1000, c.chars.lob, bits);		}		if (unlink(infname) &lt; 0)			fprintf(stderr, "compact: "), perror(infname);	}done:	if (cfp != NULL &amp;&amp; cfp != stdout)		fclose(cfp);	if (uncfp != NULL)		fclose(uncfp);	return (0);bad2:	fprintf(stderr, "compact: ");	if (cfp != stdout)		perror(infname);	else		fprintf(stderr,	    "Unsuccessful compact of standard input to standard output.\n");bad:	if (cfp != NULL &amp;&amp; cfp != stdout)		fclose(cfp);	if (uncfp != NULL)		fclose(uncfp);	return (1);}encode(ch)	int ch;{	register struct node *pp;	int stack[17];	register int stbits = 1, *sp = &amp;stack[0], rbits = bits;	register union cio *dp = &amp;d;	union cio c;	c.integ = ch;	*sp = in[ch].flags &amp; FBIT;	pp = in[ch].fp;	while (pp-&gt;fath.fp) {		*sp &lt;&lt;= 1;		if (pp-&gt;fath.flags &amp; FBIT)			(*sp)++;		stbits++;		if ((stbits &amp;= 017) == 0)			sp++;		pp = pp-&gt;fath.fp;	}	/* pop the output stack */	do {		while (stbits-- &gt; 0) {			dp-&gt;integ &lt;&lt;= 1;			if (*sp &amp; 01)				dp-&gt;integ++;			++rbits;			if ((rbits &amp;= 017) == 0) {				putc(dp-&gt;chars.hib, cfp);				putc(dp-&gt;chars.lob, cfp);				if (ferror(cfp))					goto done;			}			*sp &gt;&gt;= 1;		}		stbits = 16;	} while (--sp &gt;= &amp;stack[0]);done:	bits = rbits;}compress(uncfp, cfp)	register FILE *uncfp, *cfp;{	register union cio *dp = &amp;d;	register union cio *cp = &amp;c;	cp-&gt;integ = (dp-&gt;integ &gt;&gt; 8) &amp; 0377;	for (; cp-&gt;integ != EOF; cp-&gt;integ = getc(uncfp)) {		if ((in[cp-&gt;integ].flags &amp; SEEN) == 0) {			register short j, m;			encode(NC);			uptree(NC);			insert(cp-&gt;integ);			m = 0200;			for (j = 8; j--; m &gt;&gt;= 1) {				dp-&gt;integ &lt;&lt;= 1;				if (m &amp; cp-&gt;integ)					dp-&gt;integ++;				++bits;				if ((bits &amp;= 017) == 0) {					putc(dp-&gt;chars.hib, cfp);					putc(dp-&gt;chars.lob, cfp);				}			}		} else			encode(cp-&gt;integ);		if (ferror(cfp)) {			perror(fname);			return (1);		}		uptree(cp-&gt;integ);	}	if (ferror(uncfp)) {		perror(infname);		return (1);	}	return (0);}FILE *setup(uncfp, ignore)	FILE *uncfp;	int *ignore;{	FILE *cfp = NULL;	register union cio *dp = &amp;d;	register union cio *cp = &amp;c;	dp-&gt;integ = getc(uncfp);	if (*ignore = (dp-&gt;integ == EOF))		goto bad;	cp-&gt;integ = getc(uncfp);	if (*ignore = (cp-&gt;integ == EOF))		goto bad;	dp-&gt;chars.hib = cp-&gt;integ &amp; 0377;	if ((dp-&gt;integ &amp;= 0177777) == COMPACTED) {		fprintf(stderr, "%s: Already compacted.\n", infname);		*ignore = 1;		goto bad;	}	if (dp-&gt;integ == PACKED) {		fprintf(stderr,		    "%s: Already packed using pack program, use unpack.\n",		    infname);		*ignore = 1;		goto bad;	}	if (strcmp(infname, "-") != 0) {		sprintf(fname, "%s.C", infname);		cfp = fopen(fname, "w");		if (cfp == NULL)			goto bad2;		(void) fchmod(fileno(cfp), ucfstatus.st&larr;mode);	} else		cfp = stdout;	cp-&gt;integ = COMPACTED;	putc(cp-&gt;chars.lob, cfp);	putc(cp-&gt;chars.hib, cfp);	if (ferror(cfp))		goto bad2;	bits = 8;	cp-&gt;integ = dp-&gt;integ &amp; 0377;	in[NC].fp = in[EF].fp = dict[0].sons[LEFT].sp.p = bottom = dict + 1;	bottom-&gt;sons[LEFT].count = bottom-&gt;sons[RIGHT].count =	    dict[0].sons[RIGHT].count = 1;	dirp-&gt;next = dict[0].sons[RIGHT].top = bottom-&gt;sons[LEFT].top =	    bottom-&gt;sons[RIGHT].top = dirq = NEW;	dirq-&gt;next = NULL;	dict[0].fath.fp = NULL;	dirq-&gt;pt = bottom-&gt;fath.fp = in[cp-&gt;integ].fp = dict;	in[cp-&gt;integ].flags = (FBIT | SEEN);	in[NC].flags = SEEN;	dict[0].fath.flags = RLEAF;	bottom-&gt;fath.flags = (LLEAF | RLEAF);	dict[0].sons[LEFT].count = 2;	dict[0].sons[RIGHT].sp.ch = cp-&gt;integ;	bottom-&gt;sons[LEFT].sp.ch = NC;	bottom-&gt;sons[RIGHT].sp.ch = EF;	return (cfp);bad2:	if (cfp &amp;&amp; cfp != stdout) {		fprintf(stderr, "compact: "), perror(fname);		(void) unlink(fname);	}bad:	if (cfp &amp;&amp; cfp != stdout)		fclose(cfp);	return (NULL);}</pre>
  </body>
</html>
