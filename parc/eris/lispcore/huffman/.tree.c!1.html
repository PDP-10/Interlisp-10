<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>huffman>tree.c!1</title>
  </head>
  <body>
    <pre>
#ifndef lintstatic char sccsid[] = "@(#)tree.c	4.4 (Berkeley) 8/25/84";#endif#include "compact.h"insert(ch)	int ch;{	register struct node *pp;	register struct son *pson, *bson;	union cio d;	register struct index *wt;	wt = NEW;	pp = bottom++;	pson = &amp;pp-&gt;sons[RIGHT];	bson = &amp;bottom-&gt;sons[LEFT];	bottom-&gt;fath.fp = pp;	in[ch].flags = (SEEN | FBIT);	d.integ = bson-&gt;sp.ch = pson-&gt;sp.ch;	in[ch].fp = in[d.integ].fp = pson-&gt;sp.p = wt-&gt;pt = bottom;	bottom-&gt;fath.flags = (LLEAF | RLEAF | FBIT);	pp-&gt;fath.flags &amp;= ~RLEAF;	in[d.integ].flags = SEEN;	bson-&gt;count = pson-&gt;count;	bson-&gt;top = pson-&gt;top;	bson++;	bson-&gt;sp.ch = ch;	bson-&gt;count = 0;	bson-&gt;top = pson-&gt;top-&gt;next = wt;	wt-&gt;next = NULL;}uptree(ch)	int ch;{	register struct node *r;	union treep q, s;	int rs, ts, rflags, tflags;	longint rc, qc, sc;	struct node *t;	register struct son *rson, *tson;	register struct index *rt, *qt, *st;	r = in[ch].fp;	rs = in[ch].flags &amp; FBIT;	do {		rson = &amp;r-&gt;sons[rs];		rc = ++rson-&gt;count;		rt = rson-&gt;top;		for (;;) {			if (rs) {				s.p = r + 1;				if (r == bottom) {					sc = rc - 2;					st = NULL;				} else {					sc = (r+1)-&gt;sons[LEFT].count;					st = (r+1)-&gt;sons[LEFT].top;				}				qc = r-&gt;sons[LEFT].count;				qt = r-&gt;sons[LEFT].top;			} else {				s.p = r;				sc = r-&gt;sons[RIGHT].count;				st = r-&gt;sons[RIGHT].top;				if (r == dict) {					qc = rc + 1;					qt = head;					break;				} else {					qc = (r-1)-&gt;sons[RIGHT].count;					qt = (r-1)-&gt;sons[RIGHT].top;				}			}			if (rc &lt;= qc)				break;			t = qt-&gt;pt;			ts = LEFT;			tson = &amp;t-&gt;sons[LEFT];			if (rc &lt;= tson-&gt;count) {				tson++;				ts++;			}			/* exchange pointers of (t, ts) and (r, rs) */			q.ch = tson-&gt;sp.ch;			s.ch = rson-&gt;sp.ch;			tson-&gt;sp.ch = s.ch;			rson-&gt;sp.ch = q.ch;			exch(t, ts, q.ch, r, rs);			exch(r, rs, s.ch, t, ts);			rflags = (rs ? RLEAF : LLEAF);			tflags = (ts ? RLEAF : LLEAF);			if (((r-&gt;fath.flags &amp; rflags) &lt;&lt; rs) &uarr; ((t-&gt;fath.flags &amp; tflags) &lt;&lt; ts)) {				r-&gt;fath.flags &uarr;= rflags;				t-&gt;fath.flags &uarr;= tflags;			}			tson-&gt;count++;			rson-&gt;count--;			if (ts)				qt-&gt;pt++;			r = t;			rs = ts;			rson = tson;		}		if (rc == qc) {			rson-&gt;top = qt;			if (rc &gt; sc + 1) {				qt-&gt;next = st;				/* dispose of rt */				rt-&gt;next = flist;				flist = rt;			} else				st-&gt;pt = s.p;		} else if (rc == sc + 1) {			/* create new index at rt */			rt = NEW;			rt-&gt;next = st;			rt-&gt;pt = r;			qt-&gt;next = rt;			if (st)				st-&gt;pt = s.p;			rson-&gt;top = rt;		}		rs = r-&gt;fath.flags &amp; FBIT;		r = r-&gt;fath.fp;	} while (r);	dirp = head-&gt;next;	dirq = dirp-&gt;next;}exch(v, vs, x, w, ws)	struct node *v, *w;	union treep x;	int vs, ws;{	if (v-&gt;fath.flags &amp; (vs ? RLEAF : LLEAF)) {		in[x.ch].fp = w;		in[x.ch].flags &amp;= ~01;		if (ws)			in[x.ch].flags |= ws;	} else {		x.p-&gt;fath.fp = w;		x.p-&gt;fath.flags &amp;= ~01;		if (ws)			x.p-&gt;fath.flags |= ws;	}}</pre>
  </body>
</html>
