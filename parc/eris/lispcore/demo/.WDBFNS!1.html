<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DEMO>WDBFNS!1</title>
  </head>
  <body>
    <pre>
(FILECREATED "18-JAN-83 18:34:01" {PHYLUM}&lt;BURTON&gt;ORB&gt;WDBFNS.;9 23602        changes to:  (VARS WDBFNSCOMS)		   (FNS DISPLAYRAWBINMAP DISPLAYRAWBINSEGMENT RAWDATATORAWBINARYDATA 			RAWTOBIN.ONE.SEGMENT \FLIN \FLOUT DISPLAYHEADERBOX DISPLAYMAPBOXES 			DISPLAYSEGMENT SCALEDOWN LONTO31 TOLON DISPLAYMAP DISPLAYNEXTSEGMENTPART 			DISPLAYLLSEG)      previous date: "28-DEC-82 11:08:43" {PHYLUM}&lt;BURTON&gt;ORB&gt;WDBFNS.;4)(* Copyright (c) 1982, 1983 by Xerox Corporation)(PRETTYCOMPRINT WDBFNSCOMS)(RPAQQ WDBFNSCOMS ((FNS DISPLAYMAP DISPLAYSEGMENT SCALEDOWN DISPLAYNEXTSEGMENTPART)		   (RECORDS BOUNDINGBOX HEADER)		   (COMS (* conversion functions for preprocessed data format.)			 (FNS LATTO31 LONTO31 TOLAT TOLON)			 (* misc numeric io functions)			 (FNS INT16 BIN16 BIN31)			 (* debugging functions.)			 (FNS RDSEGHEADER DISPLAYMAPBOXES DISPLAYHEADERBOX DISPLAYLLSEG)			 (* functions for converting the raw data into binary form.)			 (FNS RAWDATATORAWBINARYDATA RAWTOBIN.ONE.SEGMENT \FLIN \FLOUT)			 (FNS DISPLAYRAWBINMAP DISPLAYRAWBINSEGMENT))))(DEFINEQ(DISPLAYMAP  [LAMBDA (HEADERFILE POINTFILE WINDOW BBOX)                 (* rrb "17-JAN-83 19:00")                                                             (* displays the map described in the files in WINDOW.							     BBOX should be in real latitude longitude.)    (PROG ([HEADERSTREAM (\GETOFD (OR (OPENP HEADERFILE)				      (OPENFILE HEADERFILE (QUOTE INPUT]	   [POINTSTREAM (\GETOFD (OR (OPENP POINTFILE)				     (OPENFILE POINTFILE (QUOTE INPUT]	   XFACTOR YFACTOR MINLAT MINLON MAXLAT MAXLON)      (* in case file was already open, set its file pointer 							     to the beginning.)          (SETFILEPTR HEADERSTREAM 0)          (SETFILEPTR POINTSTREAM 0)          [COND	    ((WINDOWP WINDOW))	    (T (SETQ WINDOW (CREATEW NIL (LISTGET (UNPACKFILENAME HEADERFILE)						  (QUOTE NAME]          (SETQ MINLAT (LATTO31 (OR (fetch (BOUNDINGBOX MINLAT) of BBOX)				    -90)))          (SETQ MINLON (LONTO31 (OR (fetch (BOUNDINGBOX MINLON) of BBOX)				    -180)))          (SETQ MAXLAT (LATTO31 (OR (fetch (BOUNDINGBOX MAXLAT) of BBOX)				    90)))          (SETQ MAXLON (LONTO31 (OR (fetch (BOUNDINGBOX MAXLON) of BBOX)				    180)))          (* set the conversion factors to the number of latitude/longitude units (on a 31 bit scale) that each unit of 	  window space gets. The conversion factors are set to reduce the largest boundary to fit inside the window.)          [SETQ YFACTOR (IQUOTIENT (IDIFFERENCE MAXLAT MINLAT)				   (WINDOWPROP WINDOW (QUOTE HEIGHT]          [SETQ XFACTOR (IQUOTIENT (IDIFFERENCE MAXLON MINLON)				   (WINDOWPROP WINDOW (QUOTE WIDTH]          (until (EOFP HEADERSTREAM) do (DISPLAYSEGMENT HEADERSTREAM POINTSTREAM WINDOW XFACTOR 							YFACTOR MINLAT MINLON MAXLAT MAXLON])(DISPLAYSEGMENT  [LAMBDA (HEADERFILE POINTFILE WINDOW XFACTOR YFACTOR BOXMINLAT BOXMINLON BOXMAXLAT BOXMAXLON)                                                             (* rrb "18-JAN-83 14:46")          (* displays one segment from two map files files. Leaves the file pointers in the two files at the end of the 	  segment displayed. NIL)    (PROG ((HEADERBYTELENGTH 28)	   (FILEPOS (GETFILEPTR HEADERFILE)                  (* save file pointer so it can be updated without having							     to read all of the header information)		    )	   (NPTS (BIN16 HEADERFILE))	   (SEGRANK (BIN16 HEADERFILE)                       (* for now this is ignored. Later can be used to 							     indicate thickness or colro or brush.)		    )	   SMINLAT SMINLON SMAXLAT SMAXLON FIRSTLAT FIRSTLON INCRXFACTOR INCRYFACTOR)                                                             (* set up initial point.)          (COND	    ([OR (IGREATERP (SETQ SMINLAT (BIN31 HEADERFILE))			    BOXMAXLAT)		 (IGREATERP (SETQ SMINLON (BIN31 HEADERFILE))			    BOXMAXLON)		 (IGREATERP BOXMINLAT (SETQ SMAXLAT (BIN31 HEADERFILE)))		 (IGREATERP BOXMINLON (SETQ SMAXLON (BIN31 HEADERFILE]	      (DF DISPLAYSEGMENT)	      (SETFILEPTR POINTFILE (IPLUS (GETFILEPTR POINTFILE)					   NPTS))	      (SETFILEPTR HEADERFILE (IPLUS FILEPOS HEADERBYTELENGTH))          (* return the number of points to be skipped in the point file because later we may want to not update its file 	  pointer each line but accumulate them and set it before it is read. This would save updating the file pointer time	  a segment was skipped which MAY be expensive.)	      (RETURN NPTS)))                                (* position window at the beginning of the segment.)          (SETQ FIRSTLAT (BIN31 HEADERFILE))          (MOVETO (SCALEDOWN (SETQ FIRSTLON (BIN31 HEADERFILE))			     BOXMINLON XFACTOR)		  (SCALEDOWN FIRSTLAT BOXMINLAT YFACTOR)		  WINDOW)                                    (* calculate the conversion factor for the increments.)          (SETQ INCRXFACTOR (LRSH (FIX XFACTOR)				  12))          (SETQ INCRYFACTOR (LRSH (FIX YFACTOR)				  12))          (for I from 1 to NPTS do (DISPLAYNEXTSEGMENTPART POINTFILE WINDOW INCRXFACTOR INCRYFACTOR])(SCALEDOWN  [LAMBDA (N ORIGIN CONVFACTOR)                              (* rrb "18-JAN-83 15:18")                                                             (* returns the coordinate that corresponds to the 							     tranformation defined by ORIGIN as the origin and 							     CONVFACTOR units per point.)    (FIX (FTIMES (FDIFFERENCE N ORIGIN)		 CONVFACTOR])(DISPLAYNEXTSEGMENTPART  [LAMBDA (PTFILE W XFACTOR YFACTOR)                         (* rrb "17-JAN-83 18:59")                                                             (* reads a point from PTFILE and draws one piece of the 							     segment in the window W.)    (PROG ((DELTAY (INT16 PTFILE))	   (DELTAX (INT16 PTFILE)))          (RETURN (RELDRAWTO (IQUOTIENT DELTAX XFACTOR)			     (IQUOTIENT DELTAY YFACTOR)			     NIL NIL W]))[DECLARE: EVAL@COMPILE (RECORD BOUNDINGBOX (MINLAT MINLON MAXLAT MAXLON))(RECORD HEADER (#POINTS SEGRANK BOUNDINGBOX INITLAT INITLON))](* conversion functions for preprocessed data format.)(DEFINEQ(LATTO31  [LAMBDA (LAT)                                              (* rrb "26-DEC-82 17:15")                                                             (* converts from a latitude into a 31 bit positive 							     integer.)    (FIX (FTIMES (FPLUS LAT 90.0)		 (CONSTANT (FQUOTIENT (EXPT 2 30)				      90])(LONTO31  [LAMBDA (LON)                                              (* rrb "18-JAN-83 13:07")                                                             (* converts from a longitude into a 31 bit positive 							     integer.)    (COND      [(FGTP LON 180)	(FIX (FTIMES (FDIFFERENCE LON 360.0)		     (CONSTANT (IQUOTIENT (EXPT 2 30)					  180]      (T (FIX (FTIMES LON (CONSTANT (IQUOTIENT (EXPT 2 30)					       180])(TOLAT  [LAMBDA (31BITN)                                           (* rrb "28-DEC-82 10:52")                                                             (* converts a latitude entry in the preprocessed data 							     file into a real latitude.)    (FDIFFERENCE (FQUOTIENT 31BITN (CONSTANT (FQUOTIENT (EXPT 2 30)							90)))		 90.0])(TOLON  [LAMBDA (31BITN)                                           (* rrb "18-JAN-83 13:03")                                                             (* converts a latitude entry in the preprocessed data 							     file into a real longitude.)                                                             (* The constant is 2&uarr;31/360)    (PROG [(LONG (FQUOTIENT 31BITN (CONSTANT (IQUOTIENT (EXPT 2 30)							180]          (RETURN (COND		    ((FGTP LONG 180.0)		      (FDIFFERENCE LONG 360.0))		    (T LONG]))(* misc numeric io functions)(DEFINEQ(INT16  [LAMBDA (OFD)                                              (* rrb "28-DEC-82 10:09")                                                             (* reads a 16 bit signed integer from a file.)    (PROG ((WORD (BIN16 OFD)))          (RETURN (COND		    [(IGREATERP WORD (CONSTANT (EXPT 2 15)))		      (IDIFFERENCE WORD (CONSTANT (EXPT 2 16]		    (T WORD])(BIN16  [LAMBDA (OFD)                                              (* rrb "28-DEC-82 09:54")                                                             (* reads a 16 bit number from an ofd.)    (LOGOR (LLSH (BIN OFD)		 8)	   (BIN OFD])(BIN31  [LAMBDA (OFD)                                              (* rrb "28-DEC-82 10:51")          (* reads a 31 bit integer from a stream. (* this is necessary because the files were written with 32 bit positive 	  integers while Interlisp's number representation is 32 bit SIGNED integers. The right shift brings the number into	  range with an accurracy loss that should not be significant since there is only 20 bits of information in the 	  original WDB.))    (PROG ((FIRSTHALF (BIN16 OFD)))                          (* work with two halves separately to avoid a number 							     box. This may not be necessary.)          (RETURN (\MAKENUMBER (LRSH FIRSTHALF 1)			       (COND				 ((EQ 0 (LOGAND FIRSTHALF 1))                                                             (* bit that would have shifted down is 0)				   (LRSH (BIN16 OFD)					 1))				 (T (LOGOR (CONSTANT (EXPT 2 15))					   (LRSH (BIN16 OFD)						 1]))(* debugging functions.)(DEFINEQ(RDSEGHEADER  [LAMBDA (OFD)                                              (* rrb "28-DEC-82 09:51")                                                             (* test function to read a segment header.							     For checking formats.)    (create HEADER	    #POINTS &larr;(BIN16 OFD)	    SEGRANK &larr;(BIN16 OFD)	    BOUNDINGBOX &larr;(create BOUNDINGBOX				 MINLAT &larr;(TOLAT (BIN31 OFD))				 MINLON &larr;(TOLON (BIN31 OFD))				 MAXLAT &larr;(TOLAT (BIN31 OFD))				 MAXLON &larr;(TOLON (BIN31 OFD)))	    INITLAT &larr;(TOLAT (BIN31 OFD))	    INITLON &larr;(TOLON (BIN31 OFD])(DISPLAYMAPBOXES  [LAMBDA (HEADERFILE POINTFILE WINDOW BBOX)                 (* rrb "18-JAN-83 15:18")                                                             (* displays the map described in the files in WINDOW.							     BBOX should be in real latitude longitude.)    (PROG ([HEADERSTREAM (\GETOFD (OR (OPENP HEADERFILE)				      (OPENFILE HEADERFILE (QUOTE INPUT]	   [POINTSTREAM (\GETOFD (OR (OPENP POINTFILE)				     (OPENFILE POINTFILE (QUOTE INPUT]	   XFACTOR YFACTOR MINLAT MINLON MAXLAT MAXLON)      (* in case file was already open, set its file pointer 							     to the beginning.)          (SETFILEPTR HEADERSTREAM 0)          (SETFILEPTR POINTSTREAM 0)          [COND	    ((WINDOWP WINDOW))	    (T (SETQ WINDOW (CREATEW NIL (LISTGET (UNPACKFILENAME HEADERFILE)						  (QUOTE NAME]          (SETQ MINLAT (LATTO31 (OR (fetch (BOUNDINGBOX MINLAT) of BBOX)				    -90)))          (SETQ MINLON (LONTO31 (OR (fetch (BOUNDINGBOX MINLON) of BBOX)				    -180)))          (SETQ MAXLAT (LATTO31 (OR (fetch (BOUNDINGBOX MAXLAT) of BBOX)				    90)))          (SETQ MAXLON (LONTO31 (OR (fetch (BOUNDINGBOX MAXLON) of BBOX)				    180)))          (* set the conversion factors to the number of latitude/longitude units (on a 31 bit scale) that each unit of 	  window space gets. The conversion factors are set to reduce the largest boundary to fit inside the window.)                                                             (* to get things working the conversion factor is the 							     number of bitmap points per degree of latitude or 							     longitude.)          [SETQ YFACTOR (FQUOTIENT (WINDOWPROP WINDOW (QUOTE HEIGHT))				   (FIX (FTIMES (FDIFFERENCE (OR (fetch (BOUNDINGBOX MAXLAT)								    of BBOX)								 90.0)							     (SETQ MINLAT (OR (fetch (BOUNDINGBOX										       MINLAT)										 of BBOX)									      -90.0)))						(CONSTANT (FQUOTIENT (EXPT 2 30)								     90]          [SETQ XFACTOR (FQUOTIENT (FIX (WINDOWPROP WINDOW (QUOTE WIDTH)))				   (FTIMES (FDIFFERENCE (OR (fetch (BOUNDINGBOX MAXLON) of BBOX)							    180.0)							(SETQ MINLON (OR (fetch (BOUNDINGBOX MINLON)									    of BBOX)									 -180.0)))					   (CONSTANT (FQUOTIENT (EXPT 2 30)								180]          (until (EOFP HEADERSTREAM) do (DISPLAYHEADERBOX HEADERSTREAM POINTSTREAM WINDOW XFACTOR 							  YFACTOR MINLAT MINLON MAXLAT MAXLON])(DISPLAYHEADERBOX  [LAMBDA (HEADERFILE POINTFILE WINDOW XFACTOR YFACTOR BOXMINLAT BOXMINLON BOXMAXLAT BOXMAXLON)                                                             (* rrb "18-JAN-83 15:18")          (* displays one segment from two map files files. Leaves the file pointers in the two files at the end of the 	  segment displayed. NIL)    (PROG ((HEADERBYTELENGTH 28)	   (FILEPOS (GETFILEPTR HEADERFILE)                  (* save file pointer so it can be updated without having							     to read all of the header information)		    )	   (NPTS (BIN16 HEADERFILE))	   (SEGRANK (BIN16 HEADERFILE)                       (* for now this is ignored. Later can be used to 							     indicate thickness or colro or brush.)		    )	   SMINLAT SMINLON SMAXLAT SMAXLON FIRSTLAT FIRSTLON INCRXFACTOR INCRYFACTOR)                                                             (* set up initial point.)          (SETQ SMINLAT (TOLAT (BIN31 HEADERFILE)))          (SETQ SMINLON (TOLON (BIN31 HEADERFILE)))          (SETQ SMAXLAT (TOLAT (BIN31 HEADERFILE)))          (SETQ SMAXLON (TOLON (BIN31 HEADERFILE)))          (* try to get things running without clipping.)          (* (COND ((OR (IGREATERP (SETQ SMINLAT (BIN31 HEADERFILE)) BOXMAXLAT) (IGREATERP (SETQ SMINLON 	  (BIN31 HEADERFILE)) BOXMAXLON) (IGREATERP BOXMINLAT (SETQ SMAXLAT (BIN31 HEADERFILE))) (IGREATERP BOXMINLON 	  (SETQ SMAXLON (BIN31 HEADERFILE)))) (PRIN1 "!" T) (SETFILEPTR HEADERFILE (IPLUS FILEPOS HEADERBYTELENGTH)) 	  (* return the number of points to be skipped in the point file because later we may want to not update its file 	  pointer each line but accumulate them and set it before it is read. This would save updating the file pointer time	  a segment was skipped which MAY be expensive.) (RETURN NPTS))))          (SETQ FIRSTLAT (TOLAT (BIN31 HEADERFILE)))          (SETQ FIRSTLON (TOLON (BIN31 HEADERFILE)))          (BITBLT NIL NIL NIL WINDOW (SCALEDOWN SMINLON BOXMINLON XFACTOR)		  (SCALEDOWN SMINLAT BOXMINLAT YFACTOR)		  (IQUOTIENT (IDIFFERENCE SMAXLON SMINLON)			     XFACTOR)		  (IQUOTIENT (IDIFFERENCE SMAXLAT SMINLAT)			     YFACTOR)		  (QUOTE TEXTURE)		  (QUOTE PAINT)		  BLACKSHADE NIL])(DISPLAYLLSEG  [LAMBDA (FIRSTLAT FIRSTLON SECONDLAT SECONDLON WINDOW BBOX)                                                             (* rrb "17-JAN-83 18:36")                                                             (* displays a line in a window.)    (PROG (XFACTOR YFACTOR BOXMINLAT BOXMINLON BOXMAXLAT BOXMAXLON)          [COND	    ((WINDOWP WINDOW))	    (T (SETQ WINDOW (CREATEW NIL]          (SETQ MINLAT (LATTO31 (OR (fetch (BOUNDINGBOX MINLAT) of BBOX)				    -90)))          (SETQ MINLON (LONTO31 (OR (fetch (BOUNDINGBOX MINLON) of BBOX)				    -180)))          (SETQ MAXLAT (LATTO31 (OR (fetch (BOUNDINGBOX MAXLAT) of BBOX)				    90)))          (SETQ MAXLON (LONTO31 (OR (fetch (BOUNDINGBOX MAXLON) of BBOX)				    180)))          [SETQ XFACTOR (IQUOTIENT (IDIFFERENCE MAXLAT MINLAT)				   (WINDOWPROP WINDOW (QUOTE WIDTH]          [SETQ YFACTOR (IQUOTIENT (IDIFFERENCE MAXLON MINLON)				   (WINDOWPROP WINDOW (QUOTE HEIGHT]          (DRAWLINE (SCALEDOWN (LONTO31 FIRSTLON)			       MINLON YFACTOR)		    (SCALEDOWN (LATTO31 FIRSTLAT)			       MINLAT XFACTOR)		    (SCALEDOWN (LONTO31 SECONDLON)			       MINLON YFACTOR)		    (SCALEDOWN (LATTO31 SECONDLAT)			       MINLAT XFACTOR)		    NIL NIL WINDOW]))(* functions for converting the raw data into binary form.)(DEFINEQ(RAWDATATORAWBINARYDATA  [LAMBDA (RAWDATAFILE OUTPUTFILE)                           (* rrb "18-JAN-83 17:55")          (* converts from a wdbii ascii file to a binary version of the same thing. The binary version has a arbitrary 	  number of segments in the following form: 2 bytes which give the number of points, one byte which gives the rank, 	  followed by the points as latitude, longitude stored as ieee 32 bit floating point format {4 bytes per floating 	  point number}. The latitude ranges from -90.0 {south pole} to 90.0 {north pole}. The longitude ranges from -180.0 	  {180 degrees west} to 180.0 {180 degrees east}.)    (PROG [[INSTREAM (\GETOFD (OR (OPENP RAWDATAFILE)				  (OPENFILE RAWDATAFILE (QUOTE INPUT]	   (OUTSTREAM (OR OUTPUTFILE (PACKFILENAME (CONS (QUOTE EXTENSION)							 (CONS (QUOTE BINMAP)							       (UNPACKFILENAME RAWDATAFILE]          [SETQ OUTSTREAM (\GETOFD (OR (OPENP OUTSTREAM (QUOTE OUTPUT))				       (OPENFILE OUTSTREAM (QUOTE OUTPUT]                                                             (* in case file was already open, set its file pointer 							     to the beginning.)          (SETFILEPTR INSTREAM 0)          (SETFILEPTR OUTSTREAM 0)          (until (PROGN                                      (* skip extra spaces which are at the end of the last 							     piece of data.)			(SKIPSEPRS INSTREAM)			(EOFP INSTREAM))	     do (RAWTOBIN.ONE.SEGMENT INSTREAM OUTSTREAM))          (RETURN (CLOSEF OUTSTREAM])(RAWTOBIN.ONE.SEGMENT  [LAMBDA (INSTRM OUTSTRM)                                   (* rrb "18-JAN-83 17:32")                                                             (* converts one segment read from INSTRM and writes it 							     onto OUTSTRM.)    (PROG ((NPTS (READ INSTRM))	   (RANK (READ INSTRM)))          (COND	    ((AND (SMALLP NPTS)		  (IGREATERP NPTS 0))	      (BOUT OUTSTRM (LRSH NPTS 8))	      (BOUT OUTSTRM (LOGAND NPTS 255)))	    (T (HELP "incorrect number of points in segment" NPTS)))          (COND	    ((AND (SMALLP RANK)		  (IGREATERP RANK 0)		  (IGREATERP 256 RANK))	      (BOUT OUTSTRM RANK))	    (T (HELP "incorrect rank" RANK)))                (* copy over the bounding box {4 values} plus NPTS 							     points {2 values each})          (for I from 1 to (IPLUS 4 (ITIMES NPTS 2)) do (\FLOUT OUTSTRM (READ INSTRM])(\FLIN  [LAMBDA (STRM OLDFLOATBOX)                                 (* rrb "18-JAN-83 16:50")                                                             (* reads a floating pt number from a file.)    [COND      (OLDFLOATBOX (OR (FLOATP OLDFLOATBOX)		       (HELP "not floating point number" OLDFLOATBOX)))      (T (SETQ OLDFLOATBOX (CREATECELL \FLOATP]    (\PUTBASEBYTE OLDFLOATBOX 0 (BIN STRM))    (\PUTBASEBYTE OLDFLOATBOX 1 (BIN STRM))    (\PUTBASEBYTE OLDFLOATBOX 2 (BIN STRM))    (\PUTBASEBYTE OLDFLOATBOX 3 (BIN STRM))    OLDFLOATBOX])(\FLOUT  [LAMBDA (STRM FLN)                                         (* rrb "18-JAN-83 17:31")                                                             (* writes out the binary form of a floating point 							     number.)    (OR (FLOATP FLN)	(HELP "not floating point number" FLN))    (BOUT STRM (\GETBASEBYTE FLN 0))    (BOUT STRM (\GETBASEBYTE FLN 1))    (BOUT STRM (\GETBASEBYTE FLN 2))    (BOUT STRM (\GETBASEBYTE FLN 3))    FLN]))(DEFINEQ(DISPLAYRAWBINMAP  [LAMBDA (BINRAWFILE W BBOX)                                (* rrb "18-JAN-83 18:26")                                                             (* displays a map from a raw binary file)    (PROG ([INSTREAM (\GETOFD (OR (OPENP BINRAWFILE)				  (OPENFILE BINRAWFILE (QUOTE INPUT]	   PIXELSPERLON PIXELSPERLAT MINLAT MINLON MAXLAT MAXLON)                                                             (* in case file was already open, set its file pointer 							     to the beginning.)          (SETFILEPTR INSTREAM 0)          [COND	    ((WINDOWP W))	    (T (SETQ W (CREATEW NIL (LISTGET (UNPACKFILENAME BINRAWFILE)					     (QUOTE NAME]          (SETQ MINLAT (OR (fetch (BOUNDINGBOX MINLAT) of BBOX)			   -90))          (SETQ MINLON (OR (fetch (BOUNDINGBOX MINLON) of BBOX)			   -180))          (SETQ MAXLAT (OR (fetch (BOUNDINGBOX MAXLAT) of BBOX)			   90))          (SETQ MAXLON (OR (fetch (BOUNDINGBOX MAXLON) of BBOX)			   180))          (* set the conversion factors to the number of latitude/longitude units (on a 31 bit scale) that each unit of 	  window space gets. The conversion factors are set to reduce the largest boundary to fit inside the window.)          (SETQ PIXELSPERLAT (FQUOTIENT (WINDOWPROP W (QUOTE HEIGHT))					(FDIFFERENCE MAXLAT MINLAT)))          (SETQ PIXELSPERLON (FQUOTIENT (WINDOWPROP W (QUOTE WIDTH))					(FDIFFERENCE MAXLON MINLON)))          (until (EOFP INSTREAM) do (DISPLAYRAWBINSEGMENT INSTREAM W PIXELSPERLON PIXELSPERLAT MINLAT 							  MINLON MAXLAT MAXLON])(DISPLAYRAWBINSEGMENT  [LAMBDA (INSTRM WINDOW PPLON PPLAT BOXMINLAT BOXMINLON BOXMAXLAT BOXMAXLON)                                                             (* rrb "18-JAN-83 18:31")                                                             (* displays a map segment from a binary raw data file.)    (PROG ((FILEPOS (GETFILEPTR INSTRM)                      (* save file pointer so it can be updated without having							     to read all of the header information)		    )	   (NPTS (BIN16 INSTRM))	   (SEGRANK (BIN INSTRM)                             (* for now this is ignored. Later can be used to 							     indicate thickness or colro or brush.)		    )	   SMINLAT SMINLON SMAXLAT SMAXLON NEXTLAT)          (* set up initial point.)                                                             (* read bounding box but don't do anything with it yet.)          (SETQ SMINLAT (\FLIN INSTRM))          (SETQ SMINLON (\FLIN INSTRM))          (SETQ SMAXLAT (\FLIN INSTRM))          (SETQ SMAXLON (\FLIN INSTRM))                      (* position window at the beginning of the segment.)          (SETQ NEXTLAT (\FLIN INSTRM))          (MOVETO (SCALEDOWN (\FLIN INSTRM)			     BOXMINLON PPLON)		  (SCALEDOWN NEXTLAT BOXMINLAT PPLAT)		  WINDOW)                                    (* calculate the conversion factor for the increments.)          (for I from 1 to (SUB1 NPTS)	     do (SETQ NEXTLAT (\FLIN INSTRM))		(DRAWTO (SCALEDOWN (\FLIN INSTRM)				   BOXMINLON PPLON)			(SCALEDOWN NEXTLAT BOXMINLAT PPLAT)			SEGRANK			(QUOTE PAINT)			WINDOW]))(PUTPROPS WDBFNS COPYRIGHT ("Xerox Corporation" 1982 1983))(DECLARE: DONTCOPY  (FILEMAP (NIL (1074 6150 (DISPLAYMAP 1084 . 2922) (DISPLAYSEGMENT 2924 . 5290) (SCALEDOWN 5292 . 5681) (DISPLAYNEXTSEGMENTPART 5683 . 6148)) (6363 8053 (LATTO31 6373 . 6704) (LONTO31 6706 . 7152) (TOLAT 7154 . 7510) (TOLON 7512 . 8051)) (8092 9737 (INT16 8102 . 8485) (BIN16 8487 . 8740) (BIN31 8742 . 9735)) (9771 16640 (RDSEGHEADER 9781 . 10409) (DISPLAYMAPBOXES 10411 . 12952) (DISPLAYHEADERBOX 12954 . 15299) (DISPLAYLLSEG 15301 . 16638)) (16709 20202 (RAWDATATORAWBINARYDATA 16719 . 18262) (RAWTOBIN.ONE.SEGMENT 18264 . 19169) (\FLIN 19171 . 19735) (\FLOUT 19737 . 20200)) (20203 23520 (DISPLAYRAWBINMAP 20213 . 21834) (DISPLAYRAWBINSEGMENT 21836 . 23518)))))STOP</pre>
  </body>
</html>
