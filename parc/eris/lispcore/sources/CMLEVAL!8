(DEFINE-FILE-INFO §READTABLE "INTERLISP" §PACKAGE "INTERLISP")(FILECREATED "22-Oct-86 12:42:56" {ERIS}<LISPCORE>SOURCES>CMLEVAL.;8 68081        changes to%:  (FNS CL:CONSTANTP CL:EVAL)      previous date%: " 8-Oct-86 12:13:56" {ERIS}<LISPCORE>SOURCES>CMLEVAL.;5)(* "Copyright (c) 1986 by Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT CMLEVALCOMS)(RPAQQ CMLEVALCOMS ((COMS (* ; "Form for definining interpreters of special forms")                          (DEFINE-TYPES SPECIAL-FORMS)                          (FUNCTIONS DEFINE-SPECIAL-FORM)                          (FUNCTIONS CL:SPECIAL-FORM-P))                    (COMS (SPECIAL-FORMS INTERLISP)                          (PROP DMACRO INTERLISP COMMON-LISP)                          (FNS COMMON-LISP))                    (COMS (ADDVARS (LAMBDASPLST CL:LAMBDA))                          (FNS \TRANSLATE-CL%:LAMBDA)                          (VARIABLES *CHECK-ARGUMENT-COUNTS*)                          (PROP DMACRO COMMON-LISP))                    (VARIABLES CL:LAMBDA-LIST-KEYWORDS CL:CALL-ARGUMENTS-LIMIT                            CL:LAMBDA-PARAMETERS-LIMIT)                    (STRUCTURES CLOSURE ENVIRONMENT)                    (COMS (FNS CL:EVAL EVAL-INVOKE-LAMBDA \INTERPRET-ARGUMENTS \INTERPRETER-LAMBDA                                CHECK-BINDABLE CHECK-KEYWORDS)                          (FUNCTIONS ARG-REF)                          (PROP DMACRO .COMPILER-SPREAD-ARGUMENTS.))                    (FNS DECLARED-SPECIAL EVALHOOK)                    (COMS (* ; "FUNCALL and APPLY, not quite same as Interlisp")                          (FNS CL:FUNCALL CL:APPLY)                          (PROP DMACRO CL:APPLY CL:FUNCALL))                    (COMS (* ; "COMPILER-LET needs to work differently compiled and interpreted")                          (FNS CL:COMPILER-LET COMP.COMPILER-LET)                          (PROP DMACRO CL:COMPILER-LET)                          (SPECIAL-FORMS CL:COMPILER-LET))                    (SPECIAL-FORMS QUOTE)                    (COMS (SPECIAL-FORMS THE)                          (PROP DMACRO THE))                    (COMS (PROP DMACRO CL:EVAL-WHEN)                          (FNS CL:EVAL-WHEN)                          (SPECIAL-FORMS CL:EVAL-WHEN))                    (COMS (SPECIAL-FORMS DECLARE)                          (FUNCTIONS CL:LOCALLY))                    (COMS (* ; "Interlisp version on LLINTERP")                          (SPECIAL-FORMS PROGN)                          (FNS EVAL-PROGN))                    (COMS (* ;                 "Confused because currently Interlisp special form, fixing MACRO-FUNCTION is complex"                             )                          (* ; "The Interlisp function is on LLINTERP")                          (SPECIAL-FORMS PROG1)                          (FUNCTIONS PROG1))                    (COMS (SPECIAL-FORMS LET* LET)                          (PROP MACRO LET LET*)                          (FNS EVAL-LET*-RECURSION \LETtran))                    (COMS (SPECIAL-FORMS COND)                          (FUNCTIONS COND))                    (COMS (* ; "consider making CL:IF extended to have Interlisp's features")                          (FNS CL:IF)                          (SPECIAL-FORMS CL:IF)                          (PROP DMACRO CL:IF))                    (COMS (* ; "Interlisp NLAMBDA definitions on LLINTERP")                          (* ; "both special form and macro")                          (FUNCTIONS AND OR)                          (SPECIAL-FORMS AND OR))                    (COMS (* ; "BLOCK and RETURN go together")                          (FNS CL:BLOCK)                          (PROP DMACRO CL:BLOCK)                          (SPECIAL-FORMS CL:BLOCK)                          (FUNCTIONS RETURN)                          (FNS CL:RETURN-FROM)                          (SPECIAL-FORMS CL:RETURN-FROM))                    (COMS (* ; "eventually shouldn't be shadowed but currently *really* different")                          (FNS CL:FUNCTION FUNCTION)                          (PROP DMACRO CL:FUNCTION)                          (SPECIAL-FORMS CL:FUNCTION FUNCTION))                    (SPECIAL-FORMS CL:MULTIPLE-VALUE-CALL)                    (FNS COMP.CL-EVAL)                    (VARIABLES *EVALHOOK* *APPLYHOOK*)                    (INITVARS (*SKIP-EVALHOOK* NIL)                           (*SKIP-APPLYHOOK* NIL))                    (FNS CL:CONSTANTP)                    (COMS (* ; "Interlisp SETQ for Common Lisp and vice versa")                          (SPECIAL-FORMS CL:SETQ SETQ)                          (PROP DMACRO CL:SETQ)                          (PROP MACRO SETQ)                          (FNS SET-SYMBOL)                          (FUNCTIONS CL:PSETQ))                    (COMS (* ; "CommonLisp style CATCH and THROW")                          (SPECIAL-FORMS CL:CATCH CL:THROW)                          (FNS CL:CATCH \CATCH-FUNCALL \CATCH-EVAL \CATCH-CL-EVAL CL:THROW EVAL-THROW                                \DO-THROW)                          (PROP DMACRO CL:CATCH CL:THROW))                    (COMS (FUNCTIONS PROG PROG*)                          (SPECIAL-FORMS GO CL:TAGBODY)                          (FNS CL:TAGBODY))                    (COMS (SPECIAL-FORMS CL:UNWIND-PROTECT)                          (MACROS CL:UNWIND-PROTECT))                    (FILES CMLPROGV)                    (COMS (* ; "hack to get NLSETQs to work on common lisp interpreter")                          (SPECIAL-FORMS .ERRSETQ.)                          (FNS EVAL-ERRORSET))                    (LOCALVARS . T)                    (PROP FILETYPE CMLEVAL)                    (DECLARE%: DONTEVAL@LOAD DOCOPY (P (for X in SYSSPECVARS do (CL:SETF (                                                                          VARIABLE-GLOBALLY-SPECIAL-P                                                                                          X)                                                                                       T))))                    (COMS (* ; "for macro caching")                          (FNS CACHEMACRO)                          (VARIABLES *MACROEXPAND-HOOK*)                          (VARS (*IN-COMPILER-LET* NIL)))                    (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS                           (ADDVARS (NLAMA CL:TAGBODY CL:CATCH CL:BLOCK CL:EVAL-WHEN CL:COMPILER-LET                                            COMMON-LISP)                                  (NLAML CL:THROW FUNCTION CL:FUNCTION CL:RETURN-FROM CL:IF)                                  (LAMA CL:APPLY CL:FUNCALL EVALHOOK)))))(* ; "Form for definining interpreters of special forms")(DEF-DEFINE-TYPE SPECIAL-FORMS "Common Lisp special forms" )(DEFDEFINER DEFINE-SPECIAL-FORM   SPECIAL-FORMS (NAME ARGS &REST BODY)         (COND            ((NULL BODY)             (CL:ASSERT (CL:SYMBOLP BODY))             `(PUTPROPS ,NAME SPECIAL-FORM ,ARGS))            (T (LET ((SF (PACK* "\interpret-" NAME)))                    (CL:MULTIPLE-VALUE-BIND (PARSED-BODY DECLS DOC)                           (PARSE-DEFMACRO ARGS '$$TAIL BODY NAME NIL :PATH '$$TAIL :ENVIRONMENT                                  '$$ENV)                           (SETQ ARGS SF)                           `(PROGN (CL:SETF (CL:SYMBOL-FUNCTION ',SF)                                          #'(CL:LAMBDA ($$TAIL $$ENV)                                                   (CL:BLOCK ,NAME ,@DECLS ,PARSED-BODY)))                                   (PUTPROPS ,NAME SPECIAL-FORM ,SF)))))))(CL:DEFUN CL:SPECIAL-FORM-P (X) (GET X 'SPECIAL-FORM))(DEFINE-SPECIAL-FORM INTERLISP PROGN)(PUTPROPS INTERLISP DMACRO ((X . Y)                            (PROGN X . Y)))(PUTPROPS COMMON-LISP DMACRO ((X)                              X))(DEFINEQ(COMMON-LISP  (NLAMBDA COMMON-LISP-FORMS                                 (* lmm " 6-Jun-86 01:07")    (EVAL-PROGN COMMON-LISP-FORMS NIL))))(ADDTOVAR LAMBDASPLST CL:LAMBDA)(DEFINEQ(\TRANSLATE-CL%:LAMBDA  (LAMBDA (EXPR)                                             (* lmm "16-Jun-86 22:41")    (LET     (VRBLS KEYVARS OPTVARS AUXLIST RESTFORM VARTYP BODY KEYWORDS (CNT 1)            (MIN 0)            (MAX 0)            DECLS            (SIMPLEP T))     (for BINDING VAR in (CAR (CDR EXPR))        do        (SELECTQ BINDING            ((&REST &BODY)                  (SETQ VARTYP '&REST))            (&OPTIONAL (SETQ VARTYP BINDING))            (&AUX (SETQ VARTYP BINDING))            (&ALLOW-OTHER-KEYS                  (OR (EQ VARTYP '&KEY)                     (ERROR "&ALLOW-OTHER-KEYS not in &KEY")))            (&KEY (SETQ VARTYP '&KEY))            (SELECTQ VARTYP                (NIL "required" (push VRBLS BINDING)                           (add CNT 1)                           (add MIN 1)                           (add MAX 1)                           (AND *CHECK-ARGUMENT-COUNTS* (SETQ SIMPLEP NIL)))                (&REST (SETQ RESTFORM `((,BINDING (for I from ,CNT to -args-                                                     collect (ARG -args- I)))))                       (SETQ MAX NIL)                       (SETQ SIMPLEP NIL))                (&AUX (push AUXLIST BINDING))                (&KEY (LET*                       (SVAR (INIT (COND                                      ((LISTP BINDING)                                       (PROG1 (CADR BINDING)                                              (SETQ SVAR (CADDR BINDING))                                              (SETQ BINDING (CAR BINDING))))))                             (KEY (COND                                     ((LISTP BINDING)                                      (PROG1 (CAR BINDING)                                             (SETQ BINDING (CADR BINDING))))                                     (T (MAKE-KEYWORD BINDING)))))                       (COND                          (SVAR (push KEYVARS (LIST SVAR T))))                       (push                        KEYVARS                        (LIST BINDING                              `(for \INDEX from ,CNT to -args- by 2                                  when (EQ (ARG -args- \INDEX)                                           ,KEY) do (RETURN (ARG -args- (ADD1 \INDEX)))                                  finally (RETURN ,(COND                                                      (SVAR `(PROGN (SETQ ,SVAR NIL)                                                                    ,INIT))                                                      (T INIT)))))))                      (SETQ MAX NIL)                      (SETQ SIMPLEP NIL))                (&OPTIONAL (OR (LISTP BINDING)                               (SETQ BINDING (LIST BINDING)))                           (LET ((SVAR (CADDR BINDING)))                                (CL:WHEN SVAR (push OPTVARS SVAR)                                       (SETQ SIMPLEP NIL))                                (CL:WHEN (CADR BINDING)                                       (SETQ SIMPLEP NIL))                                (push OPTVARS                                      `(,(CAR BINDING)                                        (COND                                           ((IGREATERP ,CNT -args-)                                            ,(CADR BINDING))                                           (T ,@(COND                                                   (SVAR `((SETQ ,SVAR T)))) (ARG -args- ,CNT))))))                           (AND MAX (add MAX 1))                           (add CNT 1))                (SHOULDNT))))     (CL:MULTIPLE-VALUE-SETQ (BODY DECLS)            (PARSE-BODY (CDR (CDR EXPR))                   NIL))     (CL:IF SIMPLEP `(LAMBDA (,@(REVERSE VRBLS) ,@(MAPCAR (REVERSE OPTVARS)                                                         (FUNCTION CAR)))                       (DECLARE (LOCALVARS . T))                       ,@DECLS                       (LET* (,@(REVERSE AUXLIST))                             ,@DECLS                             ,@BODY))            `(LAMBDA -args-               (DECLARE (LOCALVARS . T))               ,@(COND                    ((AND *CHECK-ARGUMENT-COUNTS* MIN (NEQ MIN 0))                     `((COND                          ((ILESSP ,'-args- ,MIN)                           (ERROR "Too few args" ,'-args-))))))               ,@(COND                    ((AND *CHECK-ARGUMENT-COUNTS* MAX)                     `((COND                          ((IGREATERP ,'-args- ,MAX)                           (ERROR "Too many args" ,'-args-))))))               (LET* (,@(for VAR in (REVERSE VRBLS) as I from 1                           collect (LIST VAR `(ARG -args- ,I))) ,@(REVERSE OPTVARS)                            ,@(REVERSE KEYVARS)                            ,@RESTFORM                            ,@(REVERSE AUXLIST))                     ,@DECLS                     ,@BODY)))))))(CL:DEFPARAMETER *CHECK-ARGUMENT-COUNTS* NIL)(PUTPROPS COMMON-LISP DMACRO ((X)                              X))(CL:DEFPARAMETER CL:LAMBDA-LIST-KEYWORDS '(&OPTIONAL &REST &KEY &AUX &BODY &WHOLE &ALLOW-OTHER-KEYS                                                  &ENVIRONMENT) )(CL:DEFPARAMETER CL:CALL-ARGUMENTS-LIMIT 512)(CL:DEFPARAMETER CL:LAMBDA-PARAMETERS-LIMIT 512)(DEFSTRUCT CLOSURE "An interpreted lexical closure. Contains the function and an environment object"   FUNCTION ENVIRONMENT)(DEFSTRUCT ENVIRONMENT "An environment used both by interpreter and macro expander" VARS FUNCTIONS                                                                                          BLOCKS TAGS                                                                                          PARENT                                                                                          MACROS)(DEFINEQ(CL:EVAL  (LAMBDA (EXPRESSION ENVIRONMENT)    (DECLARE (LOCALVARS . T))                                (* lmm "22-Oct-86 09:30")    (CL:TYPECASE EXPRESSION (CL:SYMBOL                             (COND                                ((NULL EXPRESSION)                                 NIL)                                ((EQ EXPRESSION T)                                 T)                                ((CL:KEYWORDP EXPRESSION)    (*                                "wouldn't need this if keywords were set to themselves when generated")                                 EXPRESSION)                                (T (while ENVIRONMENT bind LOC VAL                                      do (if (SETQ LOC (ASSOC EXPRESSION (ENVIRONMENT-VARS                                                                                 ENVIRONMENT)))                                             then (RETURN (CDR LOC))                                           else (SETQ ENVIRONMENT (ENVIRONMENT-PARENT ENVIRONMENT)))                                      finally                (*                                                   "copied from \EVALVAR in the Interlisp interpreter")                                            (SETQ LOC (\STKSCAN EXPRESSION))                                            (RETURN (COND                                                       ((AND (EQ (SETQ VAL (\GETBASEPTR LOC 0))                                                                 'NOBIND)                                                             (EQ (CL:FLOOR (\HILOC LOC)                                                                        2)                                                                 (\HILOC \VALSPACE)))                    (* Value is NOBIND and it was found as the top-level value)                                                        (CL:ERROR 'UNBOUND-VARIABLE :NAME EXPRESSION)                                                        )                                                       (T VAL)))))))           (CONS (CL:IF (CL:CONSP (CAR EXPRESSION))                        (LET ((ARGCOUNT 1))                  (* "This is a very very awful hack."                                    ".COMPILER-SPREAD-ARGUMENTS. is handled specially by the compiler"                                                              "it iterates over a list pushing things"                                                              "secondly, the (OPCODES) directly calls"                                                              EVAL-INVOKE-LAMBDA                                   "with more args than are given, blowing away the following APPLYFN")                             (.COMPILER-SPREAD-ARGUMENTS. (CDR EXPRESSION)                                    ARGCOUNT                                    ((OPCODES FN3 0 (FN . EVAL-INVOKE-LAMBDA)                                            RETURN)                                     (CAR EXPRESSION)                                     ENVIRONMENT)                                    ((CL:EVAL ENVIRONMENT))))                        (CASE (ARGTYPE (CAR EXPRESSION))                              ((0 2)                               (LET ((ARGCOUNT 0))                                    (.COMPILER-SPREAD-ARGUMENTS. (CDR EXPRESSION)                                           ARGCOUNT                                           (CAR EXPRESSION)                                           ((CL:EVAL ENVIRONMENT)))))                              (T (LET ((TEMP (GET (CAR EXPRESSION)                                                  'SPECIAL-FORM)))                                      (COND                                         (TEMP (CL:FUNCALL TEMP (CDR EXPRESSION)                                                      ENVIRONMENT))                                         ((SETQ TEMP (CL:MACRO-FUNCTION (CAR EXPRESSION)                                                            ENVIRONMENT))                                          (CL:EVAL (CL:MACROEXPAND-1 EXPRESSION ENVIRONMENT)                                                 ENVIRONMENT))                                         (T (ERROR "Undefined car of form" EXPRESSION))))))))           ((OR CL:NUMBER STRING CL:CHARACTER CL:BIT-VECTOR)            EXPRESSION)           (CL:OTHERWISE (CL:CERROR "return the expression as its own value"                                 "~s invalid form for EVAL." EXPRESSION)                  EXPRESSION))))(EVAL-INVOKE-LAMBDA  (LAMBDA (N LAM ENVIRONMENT)                                (* Pavel " 6-Oct-86 19:48")    (LET ((ARGBLOCK (ADDSTACKBASE (- (fetch (FX NEXTBLOCK) of (\MYALINK))                                     (+ (CL:DECF N)                                        N)))))    (* ;; "First sub-form is a list of (variable initialization) pairs.  Initializes the variables, binding them to new values all at once, then executes the remaining forms as in a PROGN.")         (CL:MULTIPLE-VALUE-BIND (BODY DECLS)                (PARSE-BODY (CDDR LAM)                       ENVIRONMENT)                (\INTERPRET-ARGUMENTS "a LAMBDA as the CAR of a form" (CL:ECASE (CAR LAM)                                                                             ((LAMBDA)                                                                              '&INTERLISP)                                                                             ((CL:LAMBDA)                                                                              '&REQUIRED))                       (CADR LAM)                       DECLS                       (MAKE-ENVIRONMENT :PARENT ENVIRONMENT)                       BODY ARGBLOCK N 0)))))(\INTERPRET-ARGUMENTS  (LAMBDA (\FN-NAME \ARGTYPE \ARGLIST \DECLARATIONS \ENVIRONMENT \BODY \ARGUMENT-BLOCK \LENGTH \INDEX                 )                                           (* Pavel " 6-Oct-86 19:48")                                                  (* ;; "Written in a somewhat arcane style to avoid recursive calls whenever possible, & keep code inline. RECUR does a recursive call if under a PROGV, but otherwise does a GO. ")    (CL:MACROLET     ((RECUR (TAG)             `(GO ,TAG))      (WITH-BINDING       (VAR VAL &REST FORMS)       `(PROGN (CHECK-BINDABLE ,VAR)               (CL:IF (OR (DECLARED-SPECIAL ,VAR \DECLARATIONS)                          (VARIABLE-GLOBALLY-SPECIAL-P ,VAR))                      (CL:MACROLET ((RECUR (TAG)                                           `(\INTERPRET-ARGUMENTS                                             \FN-NAME                                             ,(CL:IF (EQ TAG 'IN-KEYWORDS)                                                     '\ARGTYPE                                                     `',TAG) \ARGLIST \DECLARATIONS \ENVIRONMENT                                              \BODY \ARGUMENT-BLOCK \LENGTH \INDEX)))                             (CL:PROGV (LIST ,VAR)                                    (LIST ,VAL)                                    ,@FORMS))                      (PROGN (CL:PUSH (CONS ,VAR ,VAL)                                    (ENVIRONMENT-VARS \ENVIRONMENT))                             ,@FORMS)))))     (PROG (VAR VAL SVAR SP)                      (* ;; "dispatch on input type. The in-keywords case is special, since it needs to pass down where the beginning of the keywords section is")           (CASE \ARGTYPE (&REQUIRED (GO &REQUIRED))                 (&OPTIONAL (GO &OPTIONAL))                 (&INTERLISP (GO &INTERLISP))                 (&REST (GO &REST))                 (&KEY (GO &KEY))                 (&AUX (GO &AUX))                 (&BODY (GO &BODY))                 (T (GO IN-KEYWORDS)))       &REQUIRED           (RETURN            (COND               ((NULL \ARGLIST)                (CL:IF (< \INDEX \LENGTH)                       (CL:ERROR 'TOO-MANY-ARGUMENTS :CALLEE \FN-NAME :ACTUAL \LENGTH :MAXIMUM \INDEX                              ))                (RECUR &BODY))               (T (CASE (SETQ VAR (pop \ARGLIST))                        (&OPTIONAL (RECUR &OPTIONAL))                        (&REST (RECUR &REST))                        (&AUX (RECUR &AUX))                        (&KEY (RECUR &KEY))                        (T (COND                              ((>= \INDEX \LENGTH)                               (CL:ERROR 'TOO-FEW-ARGUMENTS :CALLEE \FN-NAME :ACTUAL \LENGTH :MINIMUM                                      (+ 1 \INDEX                                         (FOR ARG IN \ARGLIST                                            WHILE (NOT (FMEMB ARG '(&OPTIONAL &REST &AUX &KEY)))                                            SUM 1)))))                           (SETQ VAL (ARG-REF \ARGUMENT-BLOCK (PROG1 \INDEX (CL:INCF \INDEX))))                           (WITH-BINDING VAR VAL (RECUR &REQUIRED)))))))       &OPTIONAL           (RETURN (COND                      ((NULL \ARGLIST)                       (CL:IF (< \INDEX \LENGTH)                              (CL:ERROR 'TOO-MANY-ARGUMENTS :CALLEE \FN-NAME :ACTUAL \LENGTH :MAXIMUM                                      \INDEX))                       (RECUR &BODY))                      (T (CASE (SETQ VAR (pop \ARGLIST))                               (&REST (RECUR &REST))                               (&AUX (RECUR &AUX))                               (&KEY (RECUR &KEY))                               (T (CL:IF (>= \INDEX \LENGTH)                                         (CL:IF (CL:CONSP VAR)                                                (PROGN (SETQ VAL (CL:EVAL (CADR VAR)                                                                        \ENVIRONMENT))                                                       (SETQ SVAR (CADDR VAR))                                                       (SETQ VAR (CAR VAR))                                                       (SETQ SP NIL))                                                (SETQ VAL NIL))                                         (PROGN (COND                                                   ((CL:CONSP VAR)                                                    (SETQ SVAR (CADDR VAR))                                                    (SETQ SP T)                                                    (SETQ VAR (CAR VAR))))                                                (SETQ VAL (ARG-REF \ARGUMENT-BLOCK \INDEX))                                                (CL:INCF \INDEX)))                                  (WITH-BINDING VAR VAL (CL:IF SVAR (WITH-BINDING SVAR SP                                                                           (RECUR &OPTIONAL))                                                               (RECUR &OPTIONAL))))))))       &INTERLISP           (RETURN (COND                      ((NULL \ARGLIST)                       (RECUR &BODY))                      (T (SETQ VAR (pop \ARGLIST))                         (CL:IF (>= \INDEX \LENGTH)                                (SETQ VAL NIL)                                (PROGN (SETQ VAL (ARG-REF \ARGUMENT-BLOCK \INDEX))                                       (CL:INCF \INDEX)))                         (WITH-BINDING VAR VAL (RECUR &INTERLISP)))))       &REST           (SETQ VAR (pop \ARGLIST))           (SETQ VAL (for I from \INDEX while (< I \LENGTH) collect (ARG-REF \ARGUMENT-BLOCK I)))           (RETURN (WITH-BINDING VAR VAL (CL:IF (NULL \ARGLIST)                                                (RECUR &BODY)                                                (CASE (pop \ARGLIST)                                                      (&AUX (RECUR &AUX))                                                      (&KEY (RECUR &KEY))                                                      (T (CL:ERROR 'INVALID-ARGUMENT-LIST :CALLEE                                                                 \FN-NAME))))))       &KEY           (OR (EVENP (- \LENGTH \INDEX))               (CL:ERROR "Not an even number of arguments for &KEY"))           (SETQ \ARGTYPE \ARGLIST)               (* ;                                                  "Type is now the beginning of the keyword arguments")       IN-KEYWORDS           (RETURN            (COND               ((NULL \ARGLIST)                (CHECK-KEYWORDS \ARGTYPE \ARGUMENT-BLOCK \LENGTH \INDEX)                (RECUR &BODY))               (T (CASE (SETQ VAR (pop \ARGLIST))                        (&AUX (CHECK-KEYWORDS \ARGTYPE \ARGUMENT-BLOCK \LENGTH \INDEX)                              (RECUR &AUX))                        (&ALLOW-OTHER-KEYS (CL:IF (NULL \ARGLIST)                                                  (RECUR &BODY)                                                  (CASE (pop \ARGLIST)                                                        (&AUX (RECUR &AUX))                                                        (T (CL:ERROR 'INVALID-ARGUMENT-LIST :CALLEE                                                                   \FN-NAME)))))                        (T (COND                              ((CL:CONSP VAR)                               (SETQ VAL (CADR VAR))                               (SETQ SVAR (CADDR VAR))                               (SETQ VAR (CAR VAR)))                              (T (SETQ SVAR NIL)                                 (SETQ VAL NIL)))                           (LET ((KEY (CL:IF (CL:CONSP VAR)                                             (PROG1 (CAR VAR)                                                    (SETQ VAR (CADR VAR)))                                             (MAKE-KEYWORD VAR))))                                (for I from \INDEX while (< I \LENGTH) by 2                                   do (CL:IF (EQ (ARG-REF \ARGUMENT-BLOCK I)                                                 KEY)                                             (RETURN (PROGN (SETQ VAL (ARG-REF \ARGUMENT-BLOCK                                                                             (+ I 1)))                                                            (SETQ SP T))))                                   finally (SETQ VAL (CL:EVAL VAL \ENVIRONMENT))                                         (SETQ SP NIL)))                           (WITH-BINDING VAR VAL (CL:IF SVAR (WITH-BINDING SVAR SP (RECUR IN-KEYWORDS                                                                                          ))                                                        (RECUR IN-KEYWORDS))))))))       &AUX           (RETURN (COND                      ((NULL \ARGLIST)                       (RECUR &BODY))                      (T (SETQ VAR (pop \ARGLIST))                         (CL:IF (CL:CONSP VAR)                                (PROGN (SETQ VAL (CL:EVAL (CADR VAR)                                                        \ENVIRONMENT))                                       (SETQ VAR (CAR VAR)))                                (SETQ VAL NIL))                         (WITH-BINDING VAR VAL (RECUR &AUX)))))       &BODY           (RETURN (CL:IF (NULL (CDR \BODY))                          (CL:IF (CL:CONSP (SETQ \BODY (CAR \BODY)))                                 (CASE (CAR \BODY)                                       (CL:BLOCK  (* ;; "special case to handle BLOCK to avoid consing two environments just to enter a normal LAMBDA function")                                              (CL:SETF (ENVIRONMENT-BLOCKS \ENVIRONMENT)                                                     (SETQ \BODY (CDR \BODY)))                                              (CL:CATCH \ENVIRONMENT (EVAL-PROGN (CDR \BODY)                                                                            \ENVIRONMENT)))                                       (T (CL:EVAL \BODY \ENVIRONMENT)))                                 (CL:EVAL \BODY \ENVIRONMENT))                          (PROGN (CL:EVAL (pop \BODY)                                        \ENVIRONMENT)                                 (RECUR &BODY))))))))(\INTERPRETER-LAMBDA  (LAMBDA (N DEF ENV FN)                                     (* Pavel " 6-Oct-86 17:21")    (LET ((ARGBLOCK (ADDSTACKBASE (fetch (BF IVAR) of (fetch (FX BLINK) of (\MYALINK))))))         (CL:MULTIPLE-VALUE-BIND (BODY DECLS)                (PARSE-BODY (CDR (CDR DEF))                       NIL)                (\INTERPRET-ARGUMENTS FN '&REQUIRED (CAR (CDR DEF))                       DECLS                       (MAKE-ENVIRONMENT :PARENT ENV)                       BODY ARGBLOCK (- N 1)                       0)))))(CHECK-BINDABLE  (LAMBDA (VAR)                                              (* lmm "20-Jul-86 15:16")                                                             (* "19-Jul-86 15:56")    (CL:UNLESS (CL:SYMBOLP VAR)           (CL:ERROR "attempt to bind a non-symbol: ~A" VAR))    (CL:WHEN (OR (CL:CONSTANTP VAR)                 (FMEMB VAR CL:LAMBDA-LIST-KEYWORDS))           (CL:ERROR (CL:IF (CL:KEYWORDP VAR)                            "attempt to bind a keyword: ~A" "attempt to bind a constant: ~A")                  VAR))    (CL:WHEN (VARIABLE-GLOBAL-P VAR)           (CL:CERROR "Go ahead and bind it anyway" "Attempt to bind a variable proclaimed global"                   VAR))    VAR))(CHECK-KEYWORDS  (LAMBDA (KEY-ARGUMENTS ARGBLOCK LENGTH N)                  (* lmm "20-Jul-86 13:33")                                                             (* "19-Jul-86 22:42")                                                             (* "check to see if any keywords in ARGBLOCK are not in the keys - not called if &ALLOW-OTHER-KEYS was set")    (CL:BLOCK CHECK-KEYS (LET (BADKEYWORD)                              (CL:DO ((I N (+ I 2)))                                     ((>= I LENGTH))                                     (LET ((GIVEN-KEY (ARG-REF ARGBLOCK I)))                                          (CL:IF (EQ GIVEN-KEY :ALLOW-OTHER-KEYS)                                                 (CL:IF (ARG-REF ARGBLOCK (CL:1+ I))                                                        (CL:RETURN-FROM CHECK-KEYS NIL)                                                        NIL)                                                 (CL:DO ((KEYTAIL KEY-ARGUMENTS (CDR KEYTAIL)))                                                        ((OR (NULL KEYTAIL)                                                             (EQ (CAR KEYTAIL)                                                                 '&AUX))                                                             (* "got to end of keyword segment")                                                         (SETQ BADKEYWORD GIVEN-KEY))                                                        (LET ((WANTED-KEY (CAR KEYTAIL)))                                                             (CL:WHEN (CL:CONSP WANTED-KEY)                                                                    (SETQ WANTED-KEY (CAR WANTED-KEY)                                                                     )                                                                    (CL:WHEN (CL:CONSP WANTED-KEY)                                                                           (SETQ WANTED-KEY                                                                            (CAR WANTED-KEY))))                                                             (CL:IF (EQ (MAKE-KEYWORD WANTED-KEY)                                                                        GIVEN-KEY)                                                                    (RETURN NIL)))))))                              (CL:IF BADKEYWORD (CL:ERROR                                        "Keyword argument doesn't match expected list of keywords: ~A"                                                        BADKEYWORD)))))))(DEFMACRO ARG-REF (BLOCK N) `(\GETBASEPTR ,BLOCK (LLSH ,N 1)))(PUTPROPS .COMPILER-SPREAD-ARGUMENTS. DMACRO (APPLY COMP.SPREAD))(DEFINEQ(DECLARED-SPECIAL  (LAMBDA (VAR DECLS)                                        (* lmm "24-May-86 22:27")    (AND DECLS (OR (AND (LISTP (CAR DECLS))                        (EQ (CAAR DECLS)                            'DECLARE)                        (for DEC in (CDAR DECLS) when (AND (EQ (CAR DEC)                                                               'CL:SPECIAL)                                                           (FMEMB VAR (CDR DEC)))                           do (RETURN T)))                   (DECLARED-SPECIAL VAR (CDR DECLS))))))(EVALHOOK  (CL:LAMBDA (FORM EVALHOOKFN APPLYHOOKFN &OPTIONAL ENV)     (* lmm " 2-May-86 22:23")                    (* Evaluates Form with *Evalhook* bound to Evalhookfn and *Applyhook* bound to           applyhookfn. Ignores these hooks once, for the top-level evaluation of Form.          *)         (LET ((*EVALHOOK* EVALHOOKFN)               (*SKIP-EVALHOOK* T)               (*APPLYHOOK* APPLYHOOKFN)               (*SKIP-APPLYHOOK* NIL))              (HOOKED-EVAL FORM)))))(* ; "FUNCALL and APPLY, not quite same as Interlisp")(DEFINEQ(CL:FUNCALL  (CL:LAMBDA (FN &REST ARGS)                                 (* lmm " 2-May-86 21:58")         (CL:APPLY FN ARGS)))(CL:APPLY  (LAMBDA N                                                  (* lmm "29-Apr-86 21:26")    (DECLARE (LOCALVARS . T))                                (* compiles "open")    (SELECTQ N        (0 (ERROR "TOO FEW ARGUMENTS TO APPLY"))        (SPREADAPPLY (ARG N 1)               (LET ((AV (ARG N N)))                    (for I from (SUB1 N) to 2 by -1 do (push AV (ARG N I)))                    AV))))))(PUTPROPS CL:APPLY DMACRO (DEFMACRO (FN &REST ARGS) `(LET ((FN ,FN)                                                           (CNT ,(LENGTH (CDR ARGS))))                                                          (.SPREAD. ((OPCODES)                                                                     %,@ ARGS)                                                                 CNT FN)) ))(PUTPROPS CL:FUNCALL DMACRO (DEFMACRO (FN &REST ARGS) `((OPCODES APPLYFN)                                                        ,@ARGS                                                        ,(LENGTH ARGS)                                                        ,FN) ))(* ; "COMPILER-LET needs to work differently compiled and interpreted")(DEFINEQ(CL:COMPILER-LET  (NLAMBDA TAIL                                              (* lmm "27-May-86 11:19")    (CL:PROGV (for X in (CAR TAIL) collect (COND                                              ((CL:CONSP X)                                               (CAR X))                                              (T X)))           (for X in (CAR TAIL) collect (COND                                           ((CL:CONSP X)                                            (\EVAL (CADR X)))))           (\EVPROGN (CDR TAIL)))))(COMP.COMPILER-LET  (LAMBDA (A)    (DECLARE (LOCALVARS . T))                                (* lmm "27-May-86 12:14")                                                             (* ENTRY POINT INTO BYTECOMPILER)                                                             (* lmm "27-May-86 11:17")    (CL:PROGV (for X in (CAR A) collect (if (CL:CONSP X)                                            then (CAR X)                                          else X))           (for X in (CAR A) collect (COND                                        ((CL:CONSP X)                                         (EVAL (CADR X)))))           (COMP.PROGN (CDR A))))))(PUTPROPS CL:COMPILER-LET DMACRO COMP.COMPILER-LET)(DEFINE-SPECIAL-FORM CL:COMPILER-LET (ARGS &REST BODY &ENVIRONMENT ENV)   (LET ((*IN-COMPILER-LET* T))        (DECLARE (CL:SPECIAL *IN-COMPILER-LET*))             (*         "the *IN-COMPILER-LET* is for macro-caching. It says: don't cache macros under compiler lets")        (CL:PROGV (for X in ARGS collect (if (CL:CONSP X)                                             then (CAR X)                                           else X))               (for X in ARGS collect (if (CL:CONSP X)                                          then (CL:EVAL (CADR X)                                                      ENV)                                        else NIL))               (EVAL-PROGN BODY ENV))))(DEFINE-SPECIAL-FORM QUOTE CAR)(DEFINE-SPECIAL-FORM THE (TYPE-SPEC FORM &ENVIRONMENT ENV)   (CL:IF (EQ (CAR (LISTP TYPE-SPEC))              'CL:VALUES)          (LET ((CL:VALUES (CL:MULTIPLE-VALUE-LIST (CL:EVAL FORM ENV))))               (CL:IF (CL:NOTEVERY #'(CL:LAMBDA (VALUE SPEC)                                            (TYPEP VALUE SPEC)) CL:VALUES (CDR TYPE-SPEC))                      (CHECK-TYPE-FAIL T FORM CL:VALUES TYPE-SPEC NIL)                      (CL:VALUES-LIST CL:VALUES)))          (LET ((VALUE (CL:EVAL FORM ENV)))               (CL:IF (TYPEP VALUE TYPE-SPEC)                      VALUE                      (CHECK-TYPE-FAIL T FORM VALUE TYPE-SPEC NIL)))))(PUTPROPS THE DMACRO ((SPEC FORM)                      FORM))(PUTPROPS CL:EVAL-WHEN DMACRO (DEFMACRO (OPTIONS &BODY BODY) (AND (OR (FMEMB 'COMPILE OPTIONS)                                                                      (FMEMB 'CL:COMPILE OPTIONS))                                                                  (MAPC BODY (FUNCTION CL:EVAL)))                                 (AND (OR (FMEMB 'LOAD OPTIONS)                                          (FMEMB 'CL:LOAD OPTIONS))                                      `(PROGN ,@BODY))))(DEFINEQ(CL:EVAL-WHEN  (NLAMBDA OPTIONS.BODY                                      (* lmm " 1-Jun-86 15:16")    (AND (OR (FMEMB 'CL:EVAL (CAR OPTIONS.BODY))             (FMEMB 'EVAL (CAR OPTIONS.BODY)))         (MAPC (CDR OPTIONS.BODY)               (FUNCTION \EVAL))))))(DEFINE-SPECIAL-FORM CL:EVAL-WHEN (TAGS &REST BODY &ENVIRONMENT ENV)   (AND (OR (FMEMB 'CL:EVAL TAGS)            (FMEMB 'EVAL TAGS))        (EVAL-PROGN BODY ENV)))(DEFINE-SPECIAL-FORM DECLARE FALSE)(DEFMACRO CL:LOCALLY (&BODY BODY) `(LET NIL ,@BODY))(* ; "Interlisp version on LLINTERP")(DEFINE-SPECIAL-FORM PROGN EVAL-PROGN)(DEFINEQ(EVAL-PROGN  (LAMBDA (BODY ENVIRONMENT)                                 (* lmm "22-May-86 23:55")    (if (CDR BODY)        then (CL:EVAL (CAR BODY)                    ENVIRONMENT)             (EVAL-PROGN (CDR BODY)                    ENVIRONMENT)      else (CL:EVAL (CAR BODY)                  ENVIRONMENT)))))(* ; "Confused because currently Interlisp special form, fixing MACRO-FUNCTION is complex")(* ; "The Interlisp function is on LLINTERP")(DEFINE-SPECIAL-FORM PROG1 (FIRST &REST CL:REST &ENVIRONMENT ENV)   (LET ((VAL (CL:EVAL FIRST ENV)))        (CL:TAGBODY PROG1 (CL:IF CL:REST (PROGN (CL:EVAL (CAR CL:REST)                                                       ENV)                                                (SETQ CL:REST (CDR CL:REST)))                                 (CL:RETURN-FROM PROG1 VAL))               (GO PROG1))))(DEFMACRO PROG1 (FIRST &REST CL:REST) (CONS '(LAMBDA (X)                                               X) (CONS FIRST CL:REST)))(DEFINE-SPECIAL-FORM LET* (VARS &REST BODY &ENVIRONMENT ENVIRONMENT)   (CL:MULTIPLE-VALUE-BIND (BODY DECLS)          (PARSE-BODY BODY ENVIRONMENT)          (COND             (VARS (LET ((NEWENV (MAKE-ENVIRONMENT :PARENT ENVIRONMENT)))                        (EVAL-LET*-RECURSION VARS DECLS NEWENV BODY)))             (T (EVAL-PROGN BODY ENVIRONMENT)))))(DEFINE-SPECIAL-FORM LET (VARS &BODY BODY &ENVIRONMENT ENVIRONMENT)                     (* Initializes the variables, binding them to new values all at once, then           executes the remaining forms as in a PROGN.) (CL:MULTIPLE-VALUE-BIND (BODY DECLS)        (PARSE-BODY BODY ENVIRONMENT)        (LET (LEXVARS SPECVARS SPECVALS)             (for VAR in VARS do (LET (VALUE)                                      (if (CL:CONSP VAR)                                          then (SETQ VALUE (CL:EVAL (CADR VAR)                                                                  ENVIRONMENT))                                               (SETQ VAR (CAR VAR)))                                      (CHECK-BINDABLE VAR)                                      (if (OR (DECLARED-SPECIAL VAR DECLS)                                              (VARIABLE-GLOBALLY-SPECIAL-P VAR))                                          then (CL:PUSH VAR SPECVARS)                                               (CL:PUSH VALUE SPECVALS)                                        else (CL:PUSH (CONS VAR VALUE)                                                    LEXVARS))))             (CL:IF SPECVARS (CL:PROGV SPECVARS SPECVALS (EVAL-PROGN BODY                                                                (CL:IF LEXVARS                                                                       (MAKE-ENVIRONMENT :VARS                                                                               LEXVARS :PARENT                                                                               ENVIRONMENT)                                                                       ENVIRONMENT)))                    (EVAL-PROGN BODY (CL:IF LEXVARS (MAKE-ENVIRONMENT :VARS LEXVARS :PARENT                                                            ENVIRONMENT)                                            ENVIRONMENT))))))(PUTPROPS LET MACRO (X (\LETtran X)))(PUTPROPS LET* MACRO (X (\LETtran X T)))(DEFINEQ(EVAL-LET*-RECURSION  (LAMBDA (VARS DECLS ENV BODY)    (DECLARE (LOCALVARS . T))                                (* lmm "20-Jul-86 15:10")                                                             (* "19-Jul-86 15:56")    (PROG NIL      ITERATE          (CL:IF (NOT VARS)                 (RETURN (EVAL-PROGN BODY ENV))                 (LET ((VAR (pop VARS))                       VALUE)                      (CL:WHEN (CL:CONSP VAR)                             (SETQ VALUE (CL:EVAL (CADR VAR)                                                ENV))                             (SETQ VAR (CAR VAR)))                      (CHECK-BINDABLE VAR)                      (CL:IF (OR (DECLARED-SPECIAL VAR DECLS)                                 (VARIABLE-GLOBALLY-SPECIAL-P VAR))                             (RETURN (CL:PROGV (LIST VAR)                                            (LIST VALUE)                                            (EVAL-LET*-RECURSION VARS DECLS ENV BODY)))                             (PROGN (CL:PUSH (CONS VAR VALUE)                                           (ENVIRONMENT-VARS ENV))                                    (GO ITERATE))))))))(\LETtran  (LAMBDA (LETTAIL SEQUENTIALP)                              (* lmm "16-Jul-85 12:52")    (PROG ((VARS (MAPCAR (CAR LETTAIL)                        (FUNCTION (LAMBDA (BINDENTRY)                                    (if (LISTP BINDENTRY)                                        then (CAR BINDENTRY)                                      ELSE BINDENTRY)))))           (VALS (MAPCAR (CAR LETTAIL)                        (FUNCTION (LAMBDA (BINDENTRY)                                    (if (LISTP BINDENTRY)                                        then (if (CDDR BINDENTRY)                                                 then (CONS 'PROG1 (CDR BINDENTRY))                                               else (CADR BINDENTRY))                                      else NIL)))))           (BODY (CDR LETTAIL))           (DECLS NIL)           (COMNTS NIL))          (RETURN (if (NOT SEQUENTIALP)                      then (LIST* (LIST* 'LAMBDA VARS BODY)                                  VALS)                    elseif (NULL (CDR VARS))                      then (SELECTQ SEQUENTIALP                               (PROG* (CONS 'PROG LETTAIL))                               `((LAMBDA %, VARS %,@ BODY)                                 %,@ VALS))                    else                     (* in the sequential case, all declarations must be "pulled up" to the top)                         (if (EQ SEQUENTIALP 'PROG*)                             then (SETQ BODY (LIST (LIST* 'PROG NIL BODY))))                         (for VAR in (REVERSE (CDR VARS)) as VAL in (REVERSE (CDR VALS))                            do (SETQ BODY (LIST (LIST (LIST* 'LAMBDA (LIST VAR)                                                             BODY)                                                      VAL))))                         (LIST (LIST* 'LAMBDA (LIST (CAR VARS))                                      BODY)                               (CAR VALS))))))))(DEFINE-SPECIAL-FORM COND (&REST COND-CLAUSES &ENVIRONMENT ENVIRONMENT)   (PROG NIL     CONDLOOP         (COND            ((NULL COND-CLAUSES)             (RETURN NIL))            ((NULL (CDAR COND-CLAUSES))             (RETURN (OR (CL:EVAL (CAAR COND-CLAUSES)                                ENVIRONMENT)                         (PROGN (SETQ COND-CLAUSES (CDR COND-CLAUSES))                                (GO CONDLOOP)))))            ((CL:EVAL (CAAR COND-CLAUSES)                    ENVIRONMENT)             (RETURN (EVAL-PROGN (CDAR COND-CLAUSES)                            ENVIRONMENT)))            (T (SETQ COND-CLAUSES (CDR COND-CLAUSES))               (GO CONDLOOP)))))(DEFMACRO COND (&REST TAIL)   (CL:IF TAIL (CL:IF (NULL (CDAR TAIL))                      (CL:IF (CDR TAIL)                             (LET ((VAR (CL:GENTEMP)))                                  `(LET ((,VAR ,(CAAR TAIL)))                                        (CL:IF ,VAR ,VAR (COND                                                            ,@(CDR TAIL)))))                             `(CL:VALUES ,(CAAR TAIL)))                      `(CL:IF ,(CAAR TAIL) ,(MKPROGN (CDAR TAIL))                              ,@(CL:IF (CDR TAIL)                                       (LIST (CL:IF (EQ (CAADR TAIL)                                                        T)                                                    (MKPROGN (CDADR TAIL))                                                    `(COND                                                        ,@(CDR TAIL)))))))))(* ; "consider making CL:IF extended to have Interlisp's features")(DEFINEQ(CL:IF  (NLAMBDA (TEST THEN ELSE)    (DECLARE (LOCALVARS . T))                                (* lmm " 1-Jun-86 16:15")    (COND       ((\EVAL TEST)        (\EVAL THEN))       (T (\EVAL ELSE))))))(DEFINE-SPECIAL-FORM CL:IF (TEST THEN &OPTIONAL ELSE &ENVIRONMENT ENVIRONMENT) (COND                                                                                  ((CL:EVAL TEST                                                                                           ENVIRONMENT                                                                                          )                                                                                   (CL:EVAL THEN                                                                                           ENVIRONMENT                                                                                          ))                                                                                  (T (CL:EVAL ELSE                                                                                           ENVIRONMENT                                                                                            ))))(PUTPROPS CL:IF DMACRO COMP.IF)(* ; "Interlisp NLAMBDA definitions on LLINTERP")(* ; "both special form and macro")(DEFMACRO AND (&REST FORMS) (CL:IF (CDR FORMS)                                   `(CL:IF ,(CAR FORMS) (AND ,@(CDR FORMS)))                                   (CL:IF FORMS (CAR FORMS)                                          T)))(DEFMACRO OR (&REST FORMS) (CL:IF (NULL (CDR FORMS))                                  (CAR FORMS)                                  (LET ((VAR (CL:GENTEMP "OR")))                                       `(LET ((,VAR ,(CAR FORMS)))                                             (CL:IF ,VAR ,VAR (OR ,@(CDR FORMS)))))))(DEFINE-SPECIAL-FORM AND (&REST AND-CLAUSES &ENVIRONMENT ENV)   (CL:LOOP (COND               ((NULL AND-CLAUSES)                (RETURN T))               ((NULL (CDR AND-CLAUSES))                (RETURN (CL:EVAL (CAR AND-CLAUSES)                               ENV)))               (T (CL:IF (CL:EVAL (CAR AND-CLAUSES)                                ENV)                         (SETQ AND-CLAUSES (CDR AND-CLAUSES))                         (RETURN NIL))))))(DEFINE-SPECIAL-FORM OR (&REST TAIL &ENVIRONMENT ENV) (PROG (VAL)                                                        ORLOOP                                                            (COND                                                               ((NULL TAIL)                                                                (RETURN NIL))                                                               ((NULL (CDR TAIL))                                                                (RETURN (CL:EVAL (CAR TAIL)                                                                               ENV)))                                                               ((SETQ VAL (CL:EVAL (CAR TAIL)                                                                                 ENV))                                                                (RETURN VAL))                                                               (T (SETQ TAIL (CDR TAIL))                                                                  (GO ORLOOP)))))(* ; "BLOCK and RETURN go together")(DEFINEQ(CL:BLOCK  (NLAMBDA TAIL    (\EVPROGN (CDR TAIL)))))(PUTPROPS CL:BLOCK DMACRO COMP.BLOCK)(DEFINE-SPECIAL-FORM CL:BLOCK (&REST TAIL &ENVIRONMENT ENVIRONMENT)                     (* Syntax is (CL:BLOCK name . body)%. The body is evaluated as a PROGN, but it           is possible to exit the block using (CL:RETURN-FROM name value)%.          The CL:RETURN-FROM must be lexically contained within the block.)                                                             (* make RETURN and CL:RETURN-FROM do                                                              the work) (CL:CATCH (SETQ ENVIRONMENT (MAKE-ENVIRONMENT :BLOCKS TAIL :PARENT ENVIRONMENT))        (EVAL-PROGN (CDR TAIL)               ENVIRONMENT)))(DEFMACRO RETURN (VALUE) `(CL:RETURN-FROM NIL ,VALUE))(DEFINEQ(CL:RETURN-FROM  (NLAMBDA (RETFROM-TAG RETFROM-VALUE)    (DECLARE (LOCALVARS . T))                                (* amd " 2-Jun-86 18:30")    (LET ((RETVALUES (CL:MULTIPLE-VALUE-LIST (\EVAL RETFROM-VALUE))))         (LET ((FRAME (STKNTH 1)))              (while FRAME do (if (OR (AND (NULL RETFROM-TAG)                                           (EQ (STKNAME FRAME)                                               '\PROG0))                                      (AND (EQ (STKNAME FRAME)                                               'CL:BLOCK)                                           (EQ (CAR (STKARG 1 FRAME))                                               RETFROM-TAG)))                                  then (RETVALUES FRAME RETVALUES T)                                else (SETQ FRAME (STKNTH 1 FRAME FRAME)))                 finally (CL:ERROR 'ILLEGAL-RETURN :TAG RETFROM-TAG)))))))(DEFINE-SPECIAL-FORM CL:RETURN-FROM (TAG VALUE &ENVIRONMENT ENVIRONMENT)   (LET ((ENV ENVIRONMENT))        (while ENV do (if (AND (ENVIRONMENT-BLOCKS ENV)                               (EQ (CAR (ENVIRONMENT-BLOCKS ENV))                                   TAG))                          then (RETURN)                        else (SETQ ENV (ENVIRONMENT-PARENT ENV))) finally (CL:ERROR 'ILLEGAL-RETURN                                                                                  :TAG TAG))        (CL:THROW ENV (CL:EVAL VALUE ENVIRONMENT))))(* ; "eventually shouldn't be shadowed but currently *really* different")(DEFINEQ(CL:FUNCTION  (NLAMBDA (FN)                                              (* lmm "24-May-86 21:15")                                                             (* fake CL:FUNCTION for Interlisp -                                                             no lexical closures)    (if (CL:SYMBOLP FN)        then (CL:SYMBOL-FUNCTION FN)      else FN)))(FUNCTION  (NLAMBDA (FN ENV)                                          (* lmm "24-May-86 16:03")                                                             (* wrong, but -- for now)    (COND       (ENV (LIST 'FUNARG FN (STKNTH -1 'FUNCTION)))       (T FN)))))(PUTPROPS CL:FUNCTION DMACRO (DEFMACRO (X ) (if (CL:SYMBOLP X)                                                then                                                `(CL:SYMBOL-FUNCTION ',X) else                                                `(FUNCTION ,X)) ))(DEFINE-SPECIAL-FORM CL:FUNCTION (FN &ENVIRONMENT ENVIRONMENT)   (if (CL:SYMBOLP FN)       then (CL:SYMBOL-FUNCTION FN)     elseif (NULL ENVIRONMENT)       then FN     else (MAKE-CLOSURE :FUNCTION (COND                                     ((EQ (CAR FN)                                          'LAMBDA)                                      `(CL:LAMBDA (&OPTIONAL ,@(CADR FN) &REST IGNORE)                                              ,@(CDDR FN)))                                     (T FN))                 :ENVIRONMENT ENVIRONMENT)))(DEFINE-SPECIAL-FORM FUNCTION (FN &OPTIONAL FUNARGP &ENVIRONMENT ENVIRONMENT)                     (* like CL:FUNCTION except that (FUNCTION FOO) just returns FOO and not its           definition) (COND    (FUNARGP                                                 (* go to the Interlisp definition)           (CL:FUNCALL (FUNCTION FUNCTION)                  FN FUNARGP))    ((CL:SYMBOLP FN)     FN)    ((NULL ENVIRONMENT)     FN)    (T (MAKE-CLOSURE :FUNCTION (COND                                  ((EQ (CAR FN)                                       'LAMBDA)                                   `(CL:LAMBDA (&OPTIONAL ,@(CADR FN) &REST IGNORE)                                           ,@(CDDR FN)))                                  (T FN))              :ENVIRONMENT ENVIRONMENT))))(DEFINE-SPECIAL-FORM CL:MULTIPLE-VALUE-CALL (FN &REST ARGS &ENVIRONMENT ENV)                     (* for interpreted calls only. The macro inserts a \MVLIST call after the           computation of TAIL) (CL:APPLY (CL:EVAL FN ENV)        (for X in ARGS join (\MVLIST (CL:EVAL X ENV)))))(DEFINEQ(COMP.CL-EVAL  (LAMBDA (EXP)                                              (* lmm " 5-Jun-86 00:44")    (COMP.SPREAD `(CDR ,@EXP) '*EVAL-ARGUMENT-COUNT* `(CAR ,@EXP) '((CL:EVAL ENVIRONMENT))))))(CL:DEFVAR *EVALHOOK* NIL)(CL:DEFVAR *APPLYHOOK* NIL)(RPAQ? *SKIP-EVALHOOK* NIL)(RPAQ? *SKIP-APPLYHOOK* NIL)(DEFINEQ(CL:CONSTANTP  (LAMBDA (OBJECT ENVIRONMENT)                               (* lmm "22-Oct-86 12:42")    (CL:TYPECASE OBJECT (CL:NUMBER T)           (CL:CHARACTER T)           (STRING T)           (CL:BIT-VECTOR T)           (CL:SYMBOL (OR (EQ OBJECT NIL)                          (EQ OBJECT T)                          (CL:KEYWORDP OBJECT)                          (AND COMPVARMACROHASH (SETQ OBJECT (GETHASH OBJECT COMPVARMACROHASH))                               (CL:CONSTANTP OBJECT))))           (CONS (CASE (CAR OBJECT)                       'T                       (CONSTANT T)                       (OTHERWISE (COND                                     ((FMEMB (CAR OBJECT)                                             CONSTANTFOLDFNS)                                      (EVERY (CDR OBJECT)                                             (FUNCTION CL:CONSTANTP)))                                     (T (CL:MULTIPLE-VALUE-BIND (NEW-FORM EXPANDED)                                               (CL:MACROEXPAND OBJECT ENVIRONMENT)                                               (AND EXPANDED (CL:CONSTANTP NEW-FORM))))))))))))(* ; "Interlisp SETQ for Common Lisp and vice versa")(DEFINE-SPECIAL-FORM CL:SETQ (&REST TAIL &ENVIRONMENT ENV)   (* lmm "24-May-86 21:38")   (LET (VALUE)        (while TAIL do (SETQ VALUE (SET-SYMBOL (pop TAIL)                                          (CL:EVAL (pop TAIL)                                                 ENV)                                          ENV)))        VALUE))(DEFINE-SPECIAL-FORM SETQ (VAR VALUE &ENVIRONMENT ENV) (SET-SYMBOL VAR (CL:EVAL VALUE ENV)                                                              ENV))(PUTPROPS CL:SETQ DMACRO (DEFMACRO (X Y &REST CL:REST) `(PROGN                                                         (SETQ ,X ,Y)                                                         ,@(AND CL:REST `((CL:SETQ ,@CL:REST))))                            ))(PUTPROPS SETQ MACRO (DEFMACRO (X &REST CL:REST) (CONS 'CL:SETQ (CONS X CL:REST)) ))(DEFINEQ(SET-SYMBOL  (LAMBDA (CL:SYMBOL VALUE ENVIRONMENT)                      (* lmm "24-May-86 21:36")    (if (NULL ENVIRONMENT)        then (SET CL:SYMBOL VALUE)      else (LET ((PAIR (ASSOC CL:SYMBOL (ENVIRONMENT-VARS ENVIRONMENT))))                (if PAIR                    then (CL:SETF (CDR PAIR)                                VALUE)                  else (SET-SYMBOL CL:SYMBOL VALUE (ENVIRONMENT-PARENT ENVIRONMENT))))))))(DEFMACRO CL:PSETQ (&REST TAIL)   (AND TAIL `(PROGN (SETQ ,(pop TAIL) ,(CL:IF (CDR TAIL)                                               `(PROG1 ,(POP TAIL) (CL:PSETQ ,@TAIL))                                               (CAR TAIL)))                     NIL)))(* ; "CommonLisp style CATCH and THROW")(DEFINE-SPECIAL-FORM CL:CATCH (TAG &REST BODY &ENVIRONMENT ENV) (\CATCH-CL-EVAL (CL:EVAL TAG ENV)                                                                       BODY ENV))(DEFINE-SPECIAL-FORM CL:THROW (TAG VALUE &ENVIRONMENT ENV) (\DO-THROW (CL:EVAL TAG ENV)                                                                  (CL:MULTIPLE-VALUE-LIST                                                                   (CL:EVAL VALUE ENV))))(DEFINEQ(CL:CATCH  (NLAMBDA L                                                 (* lmm "23-May-86 14:49")    (\CATCH-EVAL (\EVAL (CAR L))           (CDR L))))(\CATCH-FUNCALL  (LAMBDA (TAG FN)                                           (* lmm "23-May-86 14:52")    (\CALLME '*CATCH*)    (CL:FUNCALL FN)))(\CATCH-EVAL  (LAMBDA (TAG BODY)                                         (* lmm "23-May-86 14:52")    (\CALLME '*CATCH*)    (\EVPROGN BODY)))(\CATCH-CL-EVAL  (LAMBDA (TAG BODY ENV)                                     (* lmm "23-May-86 14:53")    (\CALLME '*CATCH*)    (EVAL-PROGN BODY ENV)))(CL:THROW  (NLAMBDA (THROW-TAG THROW-VALUE)    (DECLARE (LOCALVARS . T))                                (* lmm "30-May-86 00:09")    (\DO-THROW (\EVAL THROW-TAG)           (CL:MULTIPLE-VALUE-LIST (\EVAL THROW-VALUE)))))(EVAL-THROW  (LAMBDA (TAIL ENV)    (DECLARE (LOCALVARS . T))                                (* lmm "30-May-86 00:09")    (\DO-THROW (CL:EVAL (CAR TAIL)                      ENV)           (CL:MULTIPLE-VALUE-LIST (CL:EVAL (CADR TAIL)                                          ENV)))))(\DO-THROW  (LAMBDA (TAG VALS)                                         (* amd " 2-Jun-86 18:33")    (LET ((FRAME (STKNTH 1)))         (while FRAME do (if (AND (EQ (STKNAME FRAME)                                      '*CATCH*)                                  (EQ (STKARG 1 FRAME)                                      TAG))                             then (RETVALUES FRAME VALS T)                           else (SETQ FRAME (STKNTH 1 FRAME FRAME))) finally (CL:ERROR 'ILLEGAL-THROW                                                                                     :TAG TAG))))))(PUTPROPS CL:CATCH DMACRO (DEFMACRO (TAGFORM &BODY BODY) `(\CATCH-FUNCALL ,TAGFORM                                                                 (FUNCTION (LAMBDA NIL ,@BODY)))                             ))(PUTPROPS CL:THROW DMACRO ((TAG VALS)                           (\DO-THROW TAG (CL:MULTIPLE-VALUE-LIST VALS))))(DEFMACRO PROG (VARS &BODY (BODY DECLS)) `(CL:BLOCK NIL (LET ,VARS ,@DECLS (CL:TAGBODY ,@BODY))))(DEFMACRO PROG* (VARS &BODY (BODY DECLS)) `(CL:BLOCK NIL (LET* ,VARS ,@DECLS (CL:TAGBODY ,@BODY))))(DEFINE-SPECIAL-FORM GO (TAG &ENVIRONMENT ENV) (LET (TAIL)                                                    (while ENV                                                       do (if (SETQ TAIL (FMEMB TAG (ENVIRONMENT-TAGS                                                                                     ENV)))                                                              then (CL:THROW ENV TAIL)                                                            else (SETQ ENV (ENVIRONMENT-PARENT ENV)))                                                       finally (CL:ERROR 'ILLEGAL-GO :TAG TAG))))(DEFINE-SPECIAL-FORM CL:TAGBODY (&REST TAGBODY-TAIL &ENVIRONMENT ENV)   (SETQ ENV (MAKE-ENVIRONMENT :TAGS TAGBODY-TAIL :PARENT ENV))   (while (SETQ TAGBODY-TAIL (CL:CATCH ENV (for X in TAGBODY-TAIL unless (CL:SYMBOLP X)                                              do (CL:EVAL X ENV))))))(DEFINEQ(CL:TAGBODY  (NLAMBDA TAIL                                              (* lmm "23-May-86 16:05")                                                             (* like PROG with no variables)    (LET ((TL (CONS NIL TAIL)))         (\PROG0 TL TL)))))(DEFINE-SPECIAL-FORM CL:UNWIND-PROTECT (FORM &REST CLEANUPS &ENVIRONMENT ENV) (CL:UNWIND-PROTECT                                                                               (CL:EVAL FORM ENV)                                                                               (EVAL-PROGN CLEANUPS                                                                                       ENV)))(DECLARE%: EVAL@COMPILE (PUTPROPS CL:UNWIND-PROTECT DMACRO ((FORM . CLEANUPS)                                    (RESETLST (RESETSAVE NIL (LIST (FUNCTION (LAMBDA NIL . CLEANUPS))                                                                   ))                                           FORM))))(FILESLOAD CMLPROGV)(* ; "hack to get NLSETQs to work on common lisp interpreter")(DEFINE-SPECIAL-FORM .ERRSETQ. (U V W &ENVIRONMENT ENV) (EVAL-ERRORSET U V W ENV))(DEFINEQ(EVAL-ERRORSET  (LAMBDA (X Y Z ENV)                                        (* lmm " 6-Jun-86 01:49")    (\CALLME 'ERRORSET)    (LIST (CL:EVAL X ENV)))))(DECLARE%: DOEVAL@COMPILE DONTCOPY(LOCALVARS . T))(PUTPROPS CMLEVAL FILETYPE CL:COMPILE-FILE)(DECLARE%: DONTEVAL@LOAD DOCOPY (for X in SYSSPECVARS do (CL:SETF (VARIABLE-GLOBALLY-SPECIAL-P X)                                T)))(* ; "for macro caching")(DEFINEQ(CACHEMACRO  (LAMBDA (FN BODY ENV)                                      (* Pavel "19-Aug-86 22:34")    (CL:IF (OR *IN-COMPILER-LET* (NOT (TYPEP ENV 'ENVIRONMENT))               (while ENV do (CL:IF (ENVIRONMENT-MACROS ENV)                                    (RETURN NIL)                                    (SETQ ENV (ENVIRONMENT-PARENT ENV)))))           (CL:FUNCALL FN BODY ENV)           (OR (GETHASH BODY CLISPARRAY)               (PUTHASH BODY (CL:FUNCALL FN BODY ENV)                      CLISPARRAY))))))(CL:DEFPARAMETER *MACROEXPAND-HOOK* 'CACHEMACRO )(RPAQQ *IN-COMPILER-LET* NIL)(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA CL:TAGBODY CL:CATCH CL:BLOCK CL:EVAL-WHEN CL:COMPILER-LET COMMON-LISP)(ADDTOVAR NLAML CL:THROW FUNCTION CL:FUNCTION CL:RETURN-FROM CL:IF)(ADDTOVAR LAMA CL:APPLY CL:FUNCALL EVALHOOK))(PUTPROPS CMLEVAL COPYRIGHT ("Xerox Corporation" 1986))(DECLARE%: DONTCOPY  (FILEMAP (NIL (7943 8111 (COMMON-LISP 7953 . 8109)) (8150 13253 (\TRANSLATE-CL%:LAMBDA 8160 . 13251)) (14186 34570 (CL:EVAL 14196 . 18831) (EVAL-INVOKE-LAMBDA 18833 . 20077) (\INTERPRET-ARGUMENTS 20079 . 30662) (\INTERPRETER-LAMBDA 30664 . 31240) (CHECK-BINDABLE 31242 . 31970) (CHECK-KEYWORDS 31972 . 34568)) (34710 35827 (DECLARED-SPECIAL 34720 . 35311) (EVALHOOK 35313 . 35825)) (35891 36510 (CL:FUNCALL 35901 . 36045) (CL:APPLY 36047 . 36508)) (37273 38566 (CL:COMPILER-LET 37283 . 37844) (COMP.COMPILER-LET 37846 . 38564)) (40659 40953 (CL:EVAL-WHEN 40669 . 40951)) (41315 41680 (EVAL-PROGN 41325 . 41678)) (44784 48100 (EVAL-LET*-RECURSION 44794 . 46015) (\LETtran 46017 . 48098)) (49756 49985 (CL:IF 49766 . 49983)) (53218 53287 (CL:BLOCK 53228 . 53285)) (54051 55001 (CL:RETURN-FROM 54061 . 54999)) (55663 56344 (CL:FUNCTION 55673 . 56061) (FUNCTION 56063 . 56342)) (58319 58541 (COMP.CL-EVAL 58329 . 58539)) (58674 59857 (CL:CONSTANTP 58684 . 59855)) (60821 61306 (SET-SYMBOL 60831 . 61304)) (62091 63953 (CL:CATCH 62101 . 62268) (\CATCH-FUNCALL 62270 . 62433) (\CATCH-EVAL 62435 . 62591) (\CATCH-CL-EVAL 62593 . 62762) (CL:THROW 62764 . 63007) (EVAL-THROW 63009 . 63325) (\DO-THROW 63327 . 63951)) (65451 65729 (CL:TAGBODY 65461 . 65727)) (66609 66791 (EVAL-ERRORSET 66619 . 66789)) (67066 67632 (CACHEMACRO 67076 . 67630)))))STOP