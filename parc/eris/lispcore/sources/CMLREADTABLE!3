(DEFINE-FILE-INFO §READTABLE "INTERLISP" §PACKAGE "INTERLISP")(FILECREATED "14-Oct-86 16:03:29" {ERIS}<LISPCORE>SOURCES>CMLREADTABLE.;3 20166        changes to%:  (FNS CMLRDTBL)                    (VARS CMLREADTABLECOMS)      previous date%: "14-Oct-86 14:36:42" {ERIS}<LISPCORE>SOURCES>CMLREADTABLE.;1)(* "Copyright (c) 1986 by Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT CMLREADTABLECOMS)(RPAQQ CMLREADTABLECOMS        ((COMS (* ; "Common Lisp readtable interface functions ")              (FUNCTIONS CL:SET-SYNTAX-FROM-CHAR CL:GET-DISPATCH-MACRO-CHARACTER                      CL:GET-MACRO-CHARACTER CL:MAKE-DISPATCH-MACRO-CHARACTER                      CL:SET-DISPATCH-MACRO-CHARACTER CL:SET-MACRO-CHARACTER)              (FUNCTIONS DO-DISPATCH-MACRO FIND-MACRO-FUNCTION CL-MACRO-WRAPPED-P CL-UNWRAP-MACRO                      CL-WRAP-MACRO IL-MACRO-WRAPPED-P IL-UNWRAP-MACRO IL-WRAP-MACRO))        (COMS (* ; "hash macro sub functions")              (FUNCTIONS HASH-LEFTPAREN HASH-A HASH-B HASH-BACKSLASH HASH-C HASH-COLON HASH-COMMA                      HASH-DOT HASH-DOUBLEQUOTE HASH-ILLEGAL-HASH-CHAR HASH-LEFTANGLE HASH-MINUS                      HASH-NO-PARAMETER-ERROR HASH-O HASH-PLUS HASH-QUOTE HASH-R HASH-S HASH-STAR                      HASH-VBAR HASH-X))        [COMS (* ; "Common Lisp default readtables")              (FNS CMLRDTBL INIT-CML-READTABLES SET-DEFAULT-HASHMACRO-SETTINGS CMLREADSEMI)              (DECLARE%: DONTEVAL@LOAD DOCOPY (P (INIT-CML-READTABLES]        (PROP FILETYPE CMLREADTABLE)))(* ; "Common Lisp readtable interface functions ")(CL:DEFUN CL:SET-SYNTAX-FROM-CHAR (TO-CHAR FROM-CHAR &OPTIONAL (TO-READTABLE *READTABLE*)                                         (FROM-READTABLE CMLRDTBL)) (SETSYNTAX (CL:CHAR-CODE TO-CHAR)                                                                           (GETSYNTAX (CL:CHAR-CODE                                                                                       FROM-CHAR)                                                                                  FROM-READTABLE)                                                                           TO-READTABLE))(CL:DEFUN CL:GET-DISPATCH-MACRO-CHARACTER (DISP-CHAR SUB-CHAR &OPTIONAL (READTABLE *READTABLE*))   (CDR (ASSOC SUB-CHAR (CDR (ASSOC DISP-CHAR (fetch (READTABLEP DISPATCHMACRODEFS) of READTABLE))))))(CL:DEFUN CL:GET-MACRO-CHARACTER (CHAR &OPTIONAL (READTABLE *READTABLE*))                                                   (* ;;; "insures entry is Common Lisp form - (MACRO {FIRST,ALWAYS} (LAMBDA (STREAM READTABLE) (FUNCALL <function> '<char> STREAM))))")   (LET ((TABENTRY (GETSYNTAX (CL:CHAR-CODE CHAR)                          READTABLE)))        (AND (CL:CONSP TABENTRY)             (EQ (CAR TABENTRY)                 'MACRO)             (CL:CONSP (CDR TABENTRY))             (FMEMB (CADR TABENTRY)                    '(ALWAYS FIRST))             (CL:CONSP (SETQ TABENTRY (CDDR TABENTRY)))             (NULL (CDR TABENTRY))             (CL:VALUES (FIND-MACRO-FUNCTION (CAR TABENTRY))                    (NEQ (CADR TABENTRY)                         'ALWAYS)))))(CL:DEFUN CL:MAKE-DISPATCH-MACRO-CHARACTER (CHAR &OPTIONAL NON-TERMINATING (READTABLE *READTABLE*))   (SETSYNTAX (CL:CHAR-CODE CHAR)          `(MACRO ,(CL:IF NON-TERMINATING 'FIRST 'ALWAYS) (LAMBDA (STREAM READTABLE Z)                                                            (DO-DISPATCH-MACRO ,CHAR STREAM READTABLE                                                                   ))) READTABLE)   T)(CL:DEFUN CL:SET-DISPATCH-MACRO-CHARACTER (DISP-CHAR SUB-CHAR FUNCTION &OPTIONAL (READTABLE                                                                                         *READTABLE*))   (CL:IF (CL:DIGIT-CHAR-P SUB-CHAR)          (CL:ERROR "Digit ~S illegal as a sub-character for a dispatching macro" SUB-CHAR))   (SETQ SUB-CHAR (CL:CHAR-UPCASE SUB-CHAR))   (LET ((DISP-TABLE (OR (ASSOC DISP-CHAR (fetch (READTABLEP DISPATCHMACRODEFS) of READTABLE))                         (LET ((NEWTABLE (LIST DISP-CHAR)))                              (push (fetch (READTABLEP DISPATCHMACRODEFS) of READTABLE)                                    NEWTABLE)                              NEWTABLE)))         DISP-CONS)        (if (SETQ DISP-CONS (ASSOC SUB-CHAR (CDR DISP-TABLE)))            then (CL:SETF (CDR DISP-CONS)                        FUNCTION)          else (push (CDR DISP-TABLE)                     (CONS SUB-CHAR FUNCTION)))        T))(CL:DEFUN CL:SET-MACRO-CHARACTER (CHAR FUNCTION &OPTIONAL NON-TERMINATING (READTABLE *READTABLE*))   (SETSYNTAX (CL:CHAR-CODE CHAR)          `(MACRO ,(CL:IF NON-TERMINATING 'FIRST 'ALWAYS) ,(COND                                                              ((IL-MACRO-WRAPPED-P FUNCTION)                                                               (IL-UNWRAP-MACRO FUNCTION))                                                              (T (CL-WRAP-MACRO FUNCTION))))           READTABLE))(CL:DEFUN DO-DISPATCH-MACRO (CHAR STREAM RDTBL)   (LET ((*READTABLE* RDTBL)         (DISP-TABLE (CDR (ASSOC CHAR (fetch (READTABLEP DISPATCHMACRODEFS) of RDTBL))))         INDEX NEXTCHAR)        (COND           ((NOT DISP-TABLE)            (CL:ERROR "~S is not a dispatch macro character" CHAR))           (T                                         (* ; "DISPATCHMACRODEFS is a list of A-lists")              (while (DIGITCHARP (SETQ NEXTCHAR (READCCODE STREAM RDTBL)))                 do                                          (* ; "read the optional numeric arg")                    (SETQ INDEX (+ (TIMES (OR INDEX 0)                                          10)                                   (- NEXTCHAR (CHARCODE 0)))))              (LET* ((DISP-CHARACTER (CL:CHAR-UPCASE (CL:CODE-CHAR NEXTCHAR)))                     (DISP-FUNCTION (CDR (ASSOC DISP-CHARACTER DISP-TABLE))))                    (if DISP-FUNCTION                        then (CL:FUNCALL DISP-FUNCTION STREAM DISP-CHARACTER INDEX)                      else (CL:ERROR                                   "Undefined dispatch character ~S for dispatch macro character ~S"                                   DISP-CHARACTER CHAR)))))))(CL:DEFUN FIND-MACRO-FUNCTION (FORM) (COND                                        ((CL-MACRO-WRAPPED-P FORM)                                         (CL-UNWRAP-MACRO FORM))                                        ((CL:FUNCTIONP FORM)                                         (IL-WRAP-MACRO FORM))))(CL:DEFUN CL-MACRO-WRAPPED-P (FORM)               (* ;;;                                              "Predicate that checks for forms built by CL-WRAP-MACRO")   (AND (CL:CONSP FORM)        (EQ (CAR FORM)            'CL:LAMBDA)        (CL:CONSP (CDR FORM))        (CL:EQUAL (CADR FORM)               '(STREAM READTABLE Z))        (CL:CONSP (CDDR FORM))        (NULL (CDDDR FORM))        (CL:CONSP (CADDR FORM))        (EQ (CAADDR FORM)            'CL:FUNCALL)))(CL:DEFUN CL-UNWRAP-MACRO (FORM)                     (* * "Fetches CL function out wrapped by CL-WRAP-MACRO") (CADR (CADR (CADDR FORM))))(CL:DEFUN CL-WRAP-MACRO (FN CHAR)                 (* ;;;                         "Wraps a form around a CL readmacro to make it acceptable as an IL readmacro")   `(CL:LAMBDA (STREAM READTABLE Z)           (CL:FUNCALL ',FN STREAM ,CHAR)))(CL:DEFUN IL-MACRO-WRAPPED-P (FORM)               (* ;;;                                              "Predicate that checks for forms built by IL-WRAP-MACRO")   (AND (CL:CONSP FORM)        (EQ (CAR FORM)            'CL:LAMBDA)        (CL:CONSP (CDR FORM))        (EQUAL (CADR FORM)               '(STREAM CHAR))        (CL:CONSP (SETQ FORM (CDDR FORM)))        (NULL (CDR FORM))        (CL:CONSP (SETQ FORM (CAR FORM)))        (EQ (CAR FORM)            'CL:FUNCALL)        (EQ (CADDR FORM)            'STREAM)))(CL:DEFUN IL-UNWRAP-MACRO (FORM) (CADR (CADR (CADDR FORM))))(CL:DEFUN IL-WRAP-MACRO (FORM)                    (* ;;;                         "Wraps a form around an IL readmacro to make it acceptable as a CL readmacro")   `(CL:LAMBDA (STREAM CHAR)           (CL:FUNCALL ',FORM STREAM)))(* ; "hash macro sub functions")(CL:DEFUN HASH-LEFTPAREN (STREAM CHAR INDEX)                 (* jrb%: "28-Jul-86 21:50")   (LET ((CONTENTS (CL:READ-DELIMITED-LIST #\) STREAM T)))        (COND           (INDEX (LET ((VEC (CL:MAKE-ARRAY INDEX :INITIAL-ELEMENT (CAR (LAST CONTENTS)))))                       (CL:DOTIMES (I (LENGTH CONTENTS))                              (CL:SETF (CL:AREF VEC I)                                     (POP CONTENTS)))                       VEC))           (T (CL:MAKE-ARRAY (LENGTH CONTENTS)                     :INITIAL-CONTENTS CONTENTS)))))(CL:DEFUN HASH-A (STREAM CHAR PARAM) (LET ((CONTENTS (CL:READ STREAM)))                                          (CL:MAKE-ARRAY (ESTIMATE-DIMENSIONALITY PARAM CONTENTS)                                                 :INITIAL-CONTENTS CONTENTS)))(CL:DEFUN HASH-B (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (READNUMBERINBASE STREAM 2))(CL:DEFUN HASH-BACKSLASH (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                             (CHARACTER.READ STREAM))(CL:DEFUN HASH-C (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (DESTRUCTURING-BIND (NUM DEN)                                            (READ STREAM)                                            (CL:COMPLEX NUM DEN)))(CL:DEFUN HASH-COLON (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                                  (* ;                                                "Uninterned symbol.  This definition may yet be wrong")                                         (CL:MAKE-SYMBOL (READ-EXTENDED-TOKEN STREAM *READTABLE* T)))(CL:DEFUN HASH-COMMA (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                         (LIST 'LOADTIMECONSTANT (READ STREAM)))(CL:DEFUN HASH-DOT (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                       (COND                                          ((fetch (READTABLEP COMMONLISP) of *READTABLE*)                                           (CL:EVAL (READ STREAM)))                                          (T (EVAL (READ STREAM)))))(CL:DEFUN HASH-DOUBLEQUOTE (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                               (RSTRING STREAM *READTABLE* 'SKIP))(CL:DEFUN HASH-ILLEGAL-HASH-CHAR (STREAM CHAR PARAM) (CL:ERROR "Illegal hash macro character ~S" CHAR                                                            ))(CL:DEFUN HASH-LEFTANGLE (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                             (CL:ERROR "Unreadable object #<~A>" (CL:READ STREAM)))(CL:DEFUN HASH-MINUS (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                         (COND                                            ((CMLREAD.FEATURE.PARSER (LET ((*PACKAGE*                                                                                   *KEYWORD-PACKAGE*))                                                                          (CL:READ STREAM)))                                             (CL:READ STREAM)))                                         (CL:VALUES))(CL:DEFUN HASH-NO-PARAMETER-ERROR (CHAR PARAM) (CL:WHEN PARAM (CL:ERROR                                                         "Parameter ~D not allowed with hash macro ~S"                                                                      PARAM CHAR)))(CL:DEFUN HASH-O (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (READNUMBERINBASE STREAM 8))(CL:DEFUN HASH-PLUS (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                                      (* ; "Skip expression if feature not present")                                        (COND                                           ((NOT (CMLREAD.FEATURE.PARSER (LET ((*PACKAGE*                                                                                     *KEYWORD-PACKAGE*                                                                                      ))                                                                              (CL:READ STREAM))))                                            (CL:READ STREAM)))                                        (CL:VALUES))(CL:DEFUN HASH-QUOTE (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                         (LIST 'CL:FUNCTION (CL:READ STREAM)))(CL:DEFUN HASH-R (STREAM CHAR PARAM) (COND                                        (PARAM (READNUMBERINBASE STREAM PARAM))                                        (T (CL:ERROR "No base supplied for #R"))))(CL:DEFUN HASH-S (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (CREATE-STRUCTURE (READ STREAM)))(CL:DEFUN HASH-STAR (STREAM CHAR PARAM)   (LET* ((CONTENTS (READ-EXTENDED-TOKEN STREAM))          (LEN (NCHARS CONTENTS)))         (if (AND (EQ LEN 0)                  PARAM                  (NEQ PARAM 0))             then (CL:ERROR "No contents specified for bit vector #~A*" PARAM)           elseif (AND PARAM (> LEN PARAM))             then (CL:ERROR "Bit vector contents longer than specified length in #~A*~A" PARAM                          CONTENTS)           else (LET ((BITARRAY (CL:MAKE-ARRAY (OR PARAM LEN)                                       :ELEMENT-TYPE                                       'CL:BIT :INITIAL-ELEMENT                                       (if PARAM                                           then (SELCHARQ (NTHCHARCODE CONTENTS -1)                                                     (0 0)                                                     (1 1)                                                     (CL:ERROR "Illegal bit vector element in #~A*~A"                                                             PARAM CONTENTS))                                         else 0))))                     (CL:DOTIMES (I LEN)                            (CL:SETF (CL:AREF BITARRAY I)                                   (SELCHARQ (NTHCHARCODE CONTENTS (CL:1+ I))                                        (0 0)                                        (1 1)                                        (CL:ERROR "Illegal bit vector element in #~A*~A" PARAM                                                CONTENTS))))                     BITARRAY))))(CL:DEFUN HASH-VBAR (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                        (SKIP.HASH.COMMENT STREAM *READTABLE*)                                        (CL:VALUES))(CL:DEFUN HASH-X (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (READNUMBERINBASE STREAM 16))(* ; "Common Lisp default readtables")(DEFINEQ(CMLRDTBL  [LAMBDA NIL                                                (* bvm%: "14-Oct-86 16:01")                                                   (* ;; "Creates a vanilla common-lisp read table")    (PROG [(TBL (COPYREADTABLE 'ORIG]                        (* ;; "First reset the table")          (for I from 0 to \MAXTHINCHAR do (SETSYNTAX I 'OTHER TBL))                                                             (* ;; "Install the goodies")          (SETSEPR (CHARCODE (SPACE CR ^L LF TAB))                 1 TBL)          (SETSYNTAX (CHARCODE "'")                 '(MACRO ALWAYS READQUOTE) TBL)   (* ;; "Note that in cml, most of these macros are terminating, even though it would be nicer for us if they were not")          (SETSYNTAX (CHARCODE ";")                 '(MACRO ALWAYS CMLREADSEMI) TBL)          (SETSYNTAX (CHARCODE ")")                 'RIGHTPAREN TBL)          (SETSYNTAX (CHARCODE "(")                 'LEFTPAREN TBL)          (READTABLEPROP TBL 'CASEINSENSITIVE T)          (READTABLEPROP TBL 'COMMONLISP T)          (READTABLEPROP TBL 'COMMONNUMSYNTAX T)          (READTABLEPROP TBL 'USESILPACKAGE NIL)          (READTABLEPROP TBL 'ESCAPECHAR (CHARCODE "\"))          (READTABLEPROP TBL 'MULTIPLE-ESCAPECHAR (CHARCODE "|"))          (if *PACKAGE*              then (READTABLEPROP TBL 'PACKAGECHAR (CHARCODE ":")))          (SET-DEFAULT-HASHMACRO-SETTINGS TBL)          (SETSYNTAX (CHARCODE %")                 'STRINGDELIM TBL)          (SETSYNTAX (CHARCODE "`")                 '(MACRO ALWAYS READBQUOTE) TBL)          (SETSYNTAX (CHARCODE ",")                 '(MACRO ALWAYS READBQUOTECOMMA) TBL)          (RETURN TBL])(INIT-CML-READTABLES  [LAMBDA NIL                                                (* bvm%: "14-Oct-86 00:05")    (READTABLEPROP (SETQ CMLRDTBL (CMLRDTBL))           'NAME "LISP")    (SETQ *COMMON-LISP-READ-ENVIRONMENT* (MAKE-READER-ENVIRONMENT *LISP-PACKAGE* CMLRDTBL 10))    (LET ((FILETBL (COPYREADTABLE CMLRDTBL)))     (* ;                                                "Make one for files that has font indicators as seprs")         (for I from 1 to 26 do (SETSYNTAX I 'SEPRCHAR FILETBL))         (READTABLEPROP FILETBL 'NAME "XCL"))    (PROGN                                          (* ; "Read table to make READ-LINE work easily")           (SETQ READ-LINE-RDTBL (COPYREADTABLE 'ORIG))           (SETBRK (CHARCODE (EOL))                  NIL READ-LINE-RDTBL)           (SETSEPR NIL NIL READ-LINE-RDTBL])(SET-DEFAULT-HASHMACRO-SETTINGS  [LAMBDA (RDTBL)                                            (* bvm%: "11-Sep-86 14:49")    (READTABLEPROP RDTBL 'HASHMACROCHAR (CHARCODE "#"))    (CL:MAKE-DISPATCH-MACRO-CHARACTER #\# T RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\( 'HASH-LEFTPAREN RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\' 'HASH-QUOTE RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\. 'HASH-DOT RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\, 'HASH-COMMA RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\\ 'HASH-BACKSLASH RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\* 'HASH-STAR RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\: 'HASH-COLON RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\O 'HASH-O RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\B 'HASH-B RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\X 'HASH-X RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\R 'HASH-R RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\A 'HASH-A RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\S 'HASH-S RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\C 'HASH-C RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\+ 'HASH-PLUS RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\- 'HASH-MINUS RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\| 'HASH-VBAR RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\< 'HASH-LEFTANGLE RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\" 'HASH-DOUBLEQUOTE RDTBL)    RDTBL])(CMLREADSEMI  [LAMBDA (STREAM RDTBL)                                     (* bvm%: "13-Oct-86 15:53")                                                      (* ;;; "Read and discard through end of line")    (until (EQ (READCCODE STREAM)               (CHARCODE NEWLINE)) do NIL)    (CL:VALUES]))(DECLARE%: DONTEVAL@LOAD DOCOPY (INIT-CML-READTABLES))(PUTPROPS CMLREADTABLE FILETYPE CL:COMPILE-FILE)(PUTPROPS CMLREADTABLE COPYRIGHT ("Xerox Corporation" 1986))(DECLARE%: DONTCOPY  (FILEMAP (NIL (15553 19971 (CMLRDTBL 15563 . 17312) (INIT-CML-READTABLES 17314 . 18189) (SET-DEFAULT-HASHMACRO-SETTINGS 18191 . 19643) (CMLREADSEMI 19645 . 19969)))))STOP