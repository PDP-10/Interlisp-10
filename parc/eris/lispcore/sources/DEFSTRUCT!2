(DEFINE-FILE-INFO §READTABLE "INTERLISP" §PACKAGE "INTERLISP")(FILECREATED "21-Oct-86 00:36:41" {ERIS}<LISPCORE>SOURCES>DEFSTRUCT.;2 45374        previous date%: "20-Oct-86 15:28:46" {ERIS}<LISPCORE>SOURCES>DEFSTRUCT.;1)(* "Copyright (c) 1986 by Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT DEFSTRUCTCOMS)(RPAQQ DEFSTRUCTCOMS ((* ;;; "Implementation of defstruct")                      (* ;;; "public interface ")                      (FUNCTIONS DEFSTRUCT)                      (DEFINE-TYPES STRUCTURES)                      (* ;;; "top-level ")                      (FILES DEFSTRUCT-RUN-TIME)                      (FUNCTIONS DECLARE-STRUCTURE)                      (* ;;; "parsing code")                      (* ;; "(structures parsed-slot ps) are in defstruct-run-time")                      (FUNCTIONS ASSIGN-SLOT-ACCESSOR REMOVE-DOCUMENTATION RECORD-DOCUMENTATION                              ENSURE-VALID-TYPE PARSE-SLOT DEFSTRUCT-PARSE-OPTIONS                              ENSURE-CONSISTENT-PS PS-NUMBER-OF-SLOTS PS-TYPE-SPECIFIER)                      (VARIABLES %%DEFAULT-DEFSTRUCT-TYPE %%DEFAULT-PRINT-FUNCTION                              %%DEFAULT-SLOT-TYPE %%DEFSTRUCT-OPTIONS %%NO-CONSTRUCTOR                              %%DEFSTRUCT-CONSP-OPTIONS)                      (* ;;; "slot resolution code")                      (FUNCTIONS ASSIGN-SLOT-OFFSET RESOLVE-SLOTS ADD-NAME-SLOT INSERT-INCLUDED-SLOT                              MERGE-SLOTS NAME-SLOT ADD-INITIAL-OFFSET-SLOTS)                      (* ;;; "data layout code")                      (FUNCTIONS PACK-DATATYPE-FIELDSPECS ASSIGN-STRUCTURE-REPRESENTATION                              DEFINE-STRUCTURE-TYPE DEFSTRUCT-SLOT-TO-DATATYPE-FIELDSPEC                              %%STRUCTURE-TYPE-TO-FIELDSPEC ASSIGN-FIELD-DESCRIPTORS)                      (* ;;; "accessors and setfs")                      (FUNCTIONS DEFINE-ACCESSORS PSLOT-INTERNAL-ACCESSOR DEFINE-SETFS SETF-NAME)                      (* ;;; "constructor definition code")                      (FUNCTIONS DEFINE-CONSTRUCTORS RAW-CONSTRUCTOR BUILD-CONSTRUCTOR-ARGLIST                              BUILD-CONSTRUCTOR-SLOT-SETFS BOA-CONSTRUCTOR-P DEFAULT-CONSTRUCTOR-NAME)                      (* ;;; "predicate")                      (FUNCTIONS CONSTRUCT-PREDICATE PS-NAME-SLOT-POSITION DEFAULT-PREDICATE-NAME                              FUNCTION-DEFINING-FORM)                      (* ;;; "copiers")                      (FUNCTIONS DEFINE-COPIERS BUILD-COPIER-SLOT-SETFS BUILD-COPIER-TYPE-CHECK)                      (* ;;; "print functions")                      (FUNCTIONS RECORD-PRINT-FUNCTION)                      (* ;;; "internal stuff.")                      (SETFS FFETCHFIELD)                      (* ;;; "utilities")                      (FUNCTIONS SAFE-TYPE-EXPAND DEFSTRUCT-ASSERT-SUBTYPEP)                      (* ;;; "file properties")                      (PROP FILETYPE DEFSTRUCT)))(* ;;; "Implementation of defstruct")(* ;;; "public interface ")(DEFDEFINER DEFSTRUCT STRUCTURES (NAME &REST SLOT-DESCRIPTIONS)                            (LET* ((PS (DEFSTRUCT-PARSE-OPTIONS NAME))                                   (SLOT-DESCRIPTIONS (REMOVE-DOCUMENTATION PS SLOT-DESCRIPTIONS)))                                  (SETQ NAME (PS-NAME PS))   (* ; "make defdefiner happy")                                  (RESOLVE-SLOTS SLOT-DESCRIPTIONS PS)                                  `(PROGN ,@(DECLARE-STRUCTURE PS) ',NAME)))(DEF-DEFINE-TYPE STRUCTURES "Common Lisp structures" )(* ;;; "top-level ")(FILESLOAD DEFSTRUCT-RUN-TIME)(CL:DEFUN DECLARE-STRUCTURE (PS) "accomplishes all the work of declaring a structure."                                                  (* ;;                                          "maybe should purge some fields of the ps here to be gc'ed?")   `(,@(RECORD-DOCUMENTATION PS) ,@(ASSIGN-STRUCTURE-REPRESENTATION PS) ,@(DEFINE-STRUCTURE-TYPE                                                                           PS) ,@(CONSTRUCT-PREDICATE                                                                                  PS)           ,@(DEFINE-ACCESSORS PS)           ,@(DEFINE-SETFS PS)           ,@(DEFINE-CONSTRUCTORS PS)           ,@(DEFINE-COPIERS PS)           ,@(RECORD-PRINT-FUNCTION PS)           (CL:EVAL-WHEN (EVAL COMPILE LOAD)                  (CL:SETF (PARSED-STRUCTURE ',(PS-NAME PS))                         ',PS))))(* ;;; "parsing code")(* ;; "(structures parsed-slot ps) are in defstruct-run-time")(CL:DEFUN ASSIGN-SLOT-ACCESSOR (SLOT CONC-NAME) "assigns the accessor name to a slot"   (CL:IF (PSLOT-ACCESSOR SLOT)          (CL:SETF (PSLOT-ACCESSOR SLOT)                 (PACK* CONC-NAME (PSLOT-NAME SLOT)))))(CL:DEFUN REMOVE-DOCUMENTATION (PS SLOT-DESCRIPTIONS)                                                    "records it if there is any documentation string."   (LET ((DOC? (CAR SLOT-DESCRIPTIONS)))        (COND           ((STRINGP DOC?)                        (* ;; " save it and return the rest of the slots.")            (CL:SETF (PS-DOCUMENTATION-STRING PS)                   DOC?)            (CL:REST SLOT-DESCRIPTIONS))           (T                                        (* ;; "no doc string, return the whole thing.")              SLOT-DESCRIPTIONS))))(CL:DEFUN RECORD-DOCUMENTATION (PS)                                "returns a form which saves the documentation string for a structure."   (LET ((PARSED-DOCSTRING (PS-DOCUMENTATION-STRING PS)))        (CL:IF PARSED-DOCSTRING `((CL:SETF (CL:DOCUMENTATION ',(PS-NAME PS) 'STRUCTURE)                                         ,PARSED-DOCSTRING)))))(CL:DEFUN ENSURE-VALID-TYPE (TYPE-FORM) "bogus right now" TYPE-FORM)(CL:DEFUN PARSE-SLOT (DESCRIPTION &OPTIONAL (GENERATE-ACCESSOR T))     "takes a slot description from the defstruct body or included slots and returns a parsed version"   (LET* ((DESCRIPTION (MKLIST DESCRIPTION))          (SLOT (MAKE-PARSED-SLOT)))         (DESTRUCTURING-BIND (NAME INITIAL-VALUE . SLOT-OPTIONS)                DESCRIPTION                (CL:IF (CL:SYMBOLP NAME)                       (CL:SETF (PSLOT-NAME SLOT)                              NAME)                       (ERROR "Slot name not symbol: ~S" NAME))                (CL:SETF (PSLOT-INITIAL-VALUE SLOT)                       INITIAL-VALUE)             (* ;; "some variant of PCL's keyword-bind would be easier here, but it's incapable of producing reasonable error msgs for the user.  Maybe later.")                (FOR OPTION-PAIR ON SLOT-OPTIONS BY (CDDR OPTION-PAIR)                   DO (CASE (CAR OPTION-PAIR)                            (:TYPE (CL:SETF (PSLOT-TYPE SLOT)                                          (ENSURE-VALID-TYPE (CADR OPTION-PAIR))))                            (:READ-ONLY (CL:SETF (PSLOT-READ-ONLY SLOT)                                               (AND (CADR OPTION-PAIR)                                                    T)))                            (OTHERWISE (CL:IF (CL:KEYWORDP INITIAL-VALUE)                                              (CL:ERROR                                             "Initial value must be specified to use slot options. ~S"                                                      DESCRIPTION)                                              (CL:ERROR "Illegal slot option ~S in slot ~S"                                                     (CAR OPTION-PAIR)                                                     NAME)))))                (CL:IF GENERATE-ACCESSOR (CL:SETF (PSLOT-ACCESSOR SLOT)                                                T)))         SLOT))(CL:DEFUN DEFSTRUCT-PARSE-OPTIONS (NAME&OPTIONS)                                   "returns a structure representing the options in a defstruct call."   (LET* ((OPTIONS (OR (LISTP NAME&OPTIONS)                       (LIST NAME&OPTIONS)))          (NAME (POP OPTIONS))          (PS (MAKE-PS :NAME NAME)))         (CL:DOLIST (OPTION OPTIONS)                (COND                   ((LISTP OPTION)                    (DESTRUCTURING-BIND                     (OPTION-KEYWORD OPTION-VALUE . FURTHER-ARGUMENTS)                     OPTION                     (LET ((ARGUMENT-PROVIDED (CDR OPTION)))                          (CASE OPTION-KEYWORD (:CONC-NAME                                                   (* ;;     "if the option is specified, but the option value is nil, then use the empty string as conc-name")                                                      (CL:SETF (PS-CONC-NAME PS)                                                             (OR OPTION-VALUE "")))                                (:CONSTRUCTOR     (* ;;                 "multiple constructors are allowed.  If NIL is provided, then define no constructor.")                                       (COND                                          ((AND ARGUMENT-PROVIDED (NOT OPTION-VALUE))                                                  (* ;;                                      "NIL was specified.  Record that no constructor is to be built.")                                           (CL:SETF (PS-CONSTRUCTORS PS)                                                  NIL))                                          ((EQ (PS-CONSTRUCTORS PS)                                               '%%NO-CONSTRUCTOR)                                                  (* ;;                             "this is the first constructor specified.  Make the field be a list now.")                                           (CL:SETF (PS-CONSTRUCTORS PS)                                                  (LIST (CL:IF FURTHER-ARGUMENTS (CDR OPTION)                                                               OPTION-VALUE))))                                          (T      (* ;;                                                  "just push another one on the list of constructors.")                                             (CL:PUSH (CL:IF FURTHER-ARGUMENTS (CDR OPTION)                                                             OPTION-VALUE)                                                    (PS-CONSTRUCTORS PS)))))                                (:COPIER          (* ;; "if the argument is specified (even if it is nil), use it.  Otherwise use the default %"COPY-%" form already in the ps.")                                       (CL:IF ARGUMENT-PROVIDED (CL:SETF (PS-COPIER PS)                                                                       OPTION-VALUE)))                                (:PREDICATE (CL:IF ARGUMENT-PROVIDED (CL:SETF (PS-PREDICATE PS)                                                                            OPTION-VALUE)))                                (:INCLUDE (CL:SETF (PS-INCLUDE PS)                                                 OPTION-VALUE)                                                  (* ;; "if there are any included slots record them")                                       (CL:SETF (PS-INCLUDED-SLOTS PS)                                              (CDDR OPTION)))                                (:PRINT-FUNCTION (CL:SETF (PS-PRINT-FUNCTION PS)                                                        OPTION-VALUE))                                (:TYPE (CL:SETF (PS-TYPE PS)                                              (COND                                                 ((EQ OPTION-VALUE 'LIST)                                                  'LIST)                                                 ((EQ OPTION-VALUE 'CL:VECTOR)                                                             (* ; "default the vector type to t")                                                  (CL:SETF (PS-VECTOR-TYPE PS)                                                         T)                                                  'CL:VECTOR)                                                 ((AND (CL:CONSP OPTION-VALUE)                                                       (EQ (CAR OPTION-VALUE)                                                           'CL:VECTOR))                                                  (CL:SETF (PS-VECTOR-TYPE PS)                                                         (%%GET-CANONICAL-CML-TYPE (CADR OPTION-VALUE                                                                                         )))                                                  'CL:VECTOR)                                                 (T (CL:ERROR                                            "the specified :type is not list or subtype of vector: ~S"                                                            OPTION-VALUE)))))                                (:INITIAL-OFFSET (CL:IF (NOT (OR T                                                              (* ;; "fix typep first!!!")                                                                 (TYPEP OPTION-VALUE                                                                        '(INTEGER 0 *))))                                                        (CL:ERROR                                                    ":initial-offset isn't a non-negative integer: ~S"                                                                OPTION-VALUE))                                       (CL:SETF (PS-INITIAL-OFFSET PS)                                              OPTION-VALUE))                                (OTHERWISE (CL:ERROR "Bad option to defstruct: ~S." OPTION))))))                   (T (CASE OPTION (:NAMED (CL:SETF (PS-NAMED PS)                                                  T))                            (OTHERWISE (CL:IF (MEMBER OPTION %%DEFSTRUCT-CONSP-OPTIONS)                                              (CL:ERROR                                           "defstruct option ~s must be in parentheses with its value"                                                      OPTION)                                              (CL:ERROR "Bad option to defstruct: ~S." OPTION)))))))         (ENSURE-CONSISTENT-PS PS)         PS))(CL:DEFUN ENSURE-CONSISTENT-PS (PS)        "accomplishes the consistency checks that can't occur until all the options have been parsed."   (CL:IF (AND (NEQ (PS-TYPE PS)                    %%DEFAULT-DEFSTRUCT-TYPE)               (NEQ (PS-PRINT-FUNCTION PS)                    %%DEFAULT-PRINT-FUNCTION))          (CL:ERROR "A print-function can't be specified for structures of type ~s" (PS-TYPE PS)))   (COND      ((AND (EQ (PS-TYPE PS)                'CL:VECTOR)            (EQ (PS-NAMED PS)                T))                               (* ;;                      "check that the vector type can actually hold the symbol required for the name.")       (DEFSTRUCT-ASSERT-SUBTYPEP 'CL:SYMBOL (PS-VECTOR-TYPE PS)              ("vector of ~S cannot contain the symbol required for the :named options" (                                                                                       PS-VECTOR-TYPE                                                                                         PS)))))   (COND      ((PS-INCLUDE PS)       (LET* ((INCLUDE (PS-INCLUDE PS))              (INCLUDED-PSTRUCTURE (PARSED-STRUCTURE INCLUDE)))                                                  (* ;; "ensure that the user is not suicidal.  If a structure includes itself, a *very* tight ucode loop will  occur in the \instancep opcode.")             (CL:IF (EQ INCLUDE (PS-NAME PS))                    (CL:ERROR "You probably don't want ~S to include ~S." INCLUDE INCLUDE))                                                  (* ;;                                                   "ensure that the included structure is loaded in.")             (OR (PARSED-STRUCTURE INCLUDE T)                 (CL:ERROR "Included structure ~s is unknown" INCLUDE))                                                  (* ;;                                            "make sure the type of the included structure is the same")             (CL:IF (OR (NEQ (PS-TYPE INCLUDED-PSTRUCTURE)                             (PS-TYPE PS))                        (NEQ (PS-VECTOR-TYPE INCLUDED-PSTRUCTURE)                             (PS-VECTOR-TYPE PS)))                    (CL:ERROR "~s must be same type as included structure ~s" (PS-NAME PS)                           INCLUDE)))))   (COND      ((NOT (PS-PREDICATE PS))                    (* ;;           "there is no predicate.  If this structure is type datatype or named, use the default name")       (COND          ((OR (EQ (PS-TYPE PS)                   'DATATYPE)               (PS-NAMED PS))           (CL:SETF (PS-PREDICATE PS)                  (DEFAULT-PREDICATE-NAME (PS-NAME PS)))))))   (COND      ((EQ (PS-CONSTRUCTORS PS)           %%NO-CONSTRUCTOR)                      (* ;;                                           "There were no constructors specified.  Default the value.")       (CL:SETF (PS-CONSTRUCTORS PS)              `(,(DEFAULT-CONSTRUCTOR-NAME (PS-NAME PS)))))))(CL:DEFUN PS-NUMBER-OF-SLOTS (PS) "the number of slots in an instance of this structure"   (LENGTH (PS-ALL-SLOTS PS)))(CL:DEFUN PS-TYPE-SPECIFIER (PS) "returns list, vector, or (vector foo)"   (CL:ECASE (PS-TYPE PS)          (LIST 'LIST)          (CL:VECTOR (LET ((ELEMENT-TYPE (PS-VECTOR-TYPE PS)))                          (CL:IF (NEQ ELEMENT-TYPE T)                                 `(CL:VECTOR ,ELEMENT-TYPE)                                 'CL:VECTOR)))))(CL:DEFVAR %%DEFAULT-DEFSTRUCT-TYPE 'DATATYPE                                            "The type of structures when no :type option is specified"   )(CL:DEFVAR %%DEFAULT-PRINT-FUNCTION 'DEFAULT-STRUCTURE-PRINTER                                           "print function used when none is specified in a defstruct"   )(CL:DEFVAR %%DEFAULT-SLOT-TYPE 'T "the type of any slot which does not specifiy a :type option"   )(CL:DEFPARAMETER %%DEFSTRUCT-OPTIONS '(:CONC-NAME :CONSTRUCTOR :COPIER :PREDICATE :INCLUDE                                              :PRINT-FUNCTION :TYPE :INITIAL-OFFSET :NAMED) )(CL:DEFCONSTANT %%NO-CONSTRUCTOR ':%:NONE "the value which says that no constructor was specified."   )(CL:DEFPARAMETER %%DEFSTRUCT-CONSP-OPTIONS (CL:REMOVE ':NAMED %%DEFSTRUCT-OPTIONS) )(* ;;; "slot resolution code")(CL:DEFUN ASSIGN-SLOT-OFFSET (PS) "assigns the offsets for each slot for type vector and list."   (LET* ((NAME (PS-NAME PS))          (SLOTS (PS-ALL-SLOTS PS)))         (CL:ECASE (PS-TYPE PS)                ((CL:VECTOR LIST)                  (* ;; "the field descriptor is just the offset.")                 (FOR I FROM 0 AS SLOT IN SLOTS DO (CL:SETF (PSLOT-FIELD-DESCRIPTOR SLOT)                                                          I))))))(CL:DEFUN RESOLVE-SLOTS (LOCAL-SLOT-DESCRIPTIONS PS) "combines the slot descriptions from the defstruct call with the included slot-descriptions from supers and the :includes option, and installs the decription in the parsed-structure"   (CL:SETF (PS-LOCAL-SLOTS PS)          (CL:MAPCAR #'PARSE-SLOT LOCAL-SLOT-DESCRIPTIONS))   (CL:SETF (PS-INCLUDED-SLOTS PS)          (CL:MAPCAR #'PARSE-SLOT (PS-INCLUDED-SLOTS PS)))   (CL:IF (PS-NAMED PS)          (ADD-NAME-SLOT PS))   (CL:IF (NEQ 0 (PS-INITIAL-OFFSET PS))          (ADD-INITIAL-OFFSET-SLOTS PS))          (* ;;      "since adding name and initial offset slots can change local or included slots, bind them here.")   (LET ((LOCAL-SLOTS (PS-LOCAL-SLOTS PS))         (INCLUDED-SLOTS (PS-INCLUDED-SLOTS PS))         (INCLUDES (PS-INCLUDE PS)))        (COND           (INCLUDES (LET ((SUPER-SLOTS (CL:COPY-LIST (PS-ALL-SLOTS (PARSED-STRUCTURE INCLUDES)))))                                                  (* ;; "update the super-slots according to the included-slots, then make all-slots be (append merged-slots local-slots)")                          (CL:SETF (PS-ALL-SLOTS PS)                                 (NCONC (MERGE-SLOTS INCLUDED-SLOTS SUPER-SLOTS PS)                                        LOCAL-SLOTS))))           (T (CL:IF INCLUDED-SLOTS (ERROR "Can't include slots when ~s includes no structure."                                           (PS-NAME PS)))                                                  (* ;;                                                   "no included slots, so the local-slots are it.")              (CL:SETF (PS-ALL-SLOTS PS)                     LOCAL-SLOTS)))        (CL:SETF (PS-LOCAL-SLOTS PS)               LOCAL-SLOTS))                      (* ;; "now that all slots (included, super, local and filler) have been included, we can create accessor names.")   (LET ((CONC-NAME (PS-CONC-NAME PS)))        (CL:DOLIST (SLOT (PS-ALL-SLOTS PS))               (ASSIGN-SLOT-ACCESSOR SLOT CONC-NAME)))                                                  (* ;;                      "we can also record slot-names for the default-structure-printer and inspector.")   (CL:SETF (PS-ALL-SLOT-NAMES PS)          (CL:MAPCAR #'PSLOT-NAME (PS-ALL-SLOTS PS))))(CL:DEFUN ADD-NAME-SLOT (PS) "adds the slot representing the name pseudo-slot." (CL:ASSERT                                                                                 (PS-NAMED PS))                                                                                (CL:PUSH (NAME-SLOT                                                                                          PS)                                                                                       (                                                                                       PS-LOCAL-SLOTS                                                                                        PS)))(CL:DEFUN INSERT-INCLUDED-SLOT (NEW-SLOT SUPER-SLOTS PS)                         "replaces the slot in super-slots that corresponds to new-slot with new-slot"   (CL:FLET ((SAME-SLOT (SLOT1 SLOT2)                    (EQ (PSLOT-NAME SLOT1)                        (PSLOT-NAME SLOT2))))          (LET* ((TAIL (CL:MEMBER NEW-SLOT SUPER-SLOTS :TEST #'SAME-SLOT))                 (OLD-SLOT (CAR TAIL)))                (CL:IF (NOT TAIL)                       (CL:ERROR "included slot ~S not present in included structure ~S" (PSLOT-NAME                                                                                          NEW-SLOT)                              (PS-INCLUDE PS)))              (* ;; " verify the inclusion rules.")                (CL:IF (AND (PSLOT-READ-ONLY OLD-SLOT)                            (NOT (PSLOT-READ-ONLY NEW-SLOT)))                       (CL:ERROR                               "included slot ~s must be read-only.  It is in included structure ~S"                              (PSLOT-NAME NEW-SLOT)                              (PS-INCLUDE PS)))                (DEFSTRUCT-ASSERT-SUBTYPEP (PSLOT-TYPE NEW-SLOT)                       (PSLOT-TYPE OLD-SLOT)                       ("Included slot ~S's type ~s is not a subtype of original slot type ~s"                        (PSLOT-NAME NEW-SLOT)                        (PSLOT-TYPE NEW-SLOT)                        (PSLOT-TYPE OLD-SLOT)))            (* ;; "finally, we can replace the slot")                (RPLACA TAIL NEW-SLOT))))(CL:DEFUN MERGE-SLOTS (INCLUDED-SLOTS SUPER-SLOTS PS) "takes the included-slots, and the local slots, then merges them with the slots from the super that aren't shadowed."                                                  (* ;;   "go through the slots from the super and replace the super's def with the overriding included-slot")   (CL:DOLIST (NEW-SLOT INCLUDED-SLOTS)          (INSERT-INCLUDED-SLOT NEW-SLOT SUPER-SLOTS PS))   SUPER-SLOTS)(CL:DEFUN NAME-SLOT (PS) "returns a parsed-slot representing the 'name' field of a structure"   (PARSE-SLOT `(,(CL:MAKE-SYMBOL "name") ',(PS-NAME PS) :READ-ONLY T) NIL))(CL:DEFUN ADD-INITIAL-OFFSET-SLOTS (PS)                               "adds parsed-slots to the local-slots to represent the initial offset."   (CL:SETF (PS-LOCAL-SLOTS PS)          (NCONC (CL:MAKE-LIST (PS-INITIAL-OFFSET PS)                        :INITIAL-ELEMENT                        (PARSE-SLOT '(NIL NIL :READ-ONLY T) NIL))                 (PS-LOCAL-SLOTS PS))))(* ;;; "data layout code")(CL:DEFUN PACK-DATATYPE-FIELDSPECS (FIELD-SPECS) "dummy" FIELD-SPECS)(CL:DEFUN ASSIGN-STRUCTURE-REPRESENTATION (PS)                   "Determines the descriptors and returns a form to create the datatype at loadtime."   (CASE (PS-TYPE PS)         ((CL:VECTOR LIST)                        (* ;; "just assign the the field descriptors (offsets).  No run-time declaration is needed since the representation is known (list and vector)")          (ASSIGN-SLOT-OFFSET PS))         (DATATYPE (LET* ((LOCAL-FIELD-SPECS (MAPCAR (PS-LOCAL-SLOTS PS)                                                    #'DEFSTRUCT-SLOT-TO-DATATYPE-FIELDSPEC))                          (SUPER-FIELD-SPECS (CL:IF (PS-INCLUDE PS)                                                    (PS-FIELD-SPECIFIERS (PARSED-STRUCTURE                                                                          (PS-INCLUDE PS)))))                          (ALL-FIELD-SPECS (PACK-DATATYPE-FIELDSPECS (APPEND SUPER-FIELD-SPECS                                                                             LOCAL-FIELD-SPECS)))                          (STRUCTURE-NAME (PS-NAME PS)))                         (CL:SETF (PS-FIELD-SPECIFIERS PS)                                ALL-FIELD-SPECS)                         (DESTRUCTURING-BIND (LENGTH . FIELD-DESCRIPTORS)                                (TRANSLATE.DATATYPE STRUCTURE-NAME ALL-FIELD-SPECS)                                (ASSIGN-FIELD-DESCRIPTORS PS FIELD-DESCRIPTORS)                                                  (* ;; "save the descriptors? No, even though the ones in the dtd are for the current world, not the crosscompiling world.  They are recomputed each time by TRANSLATE.DATATYPE")                                `((%%STRUCTURE-DECLARE-DATATYPE ',STRUCTURE-NAME ',ALL-FIELD-SPECS                                         ',FIELD-DESCRIPTORS                                         ,LENGTH                                         ',(PS-INCLUDE PS))))))))(CL:DEFUN DEFINE-STRUCTURE-TYPE (PS)                                     "adds the structure to the common lisp type system with deftype."   (CL:IF (EQ (PS-TYPE PS)              'DATATYPE)          (LET ((NAME (PS-NAME PS)))               `((CL:DEFTYPE (\, NAME) NIL '(DATATYPE ,NAME))))))(CL:DEFUN DEFSTRUCT-SLOT-TO-DATATYPE-FIELDSPEC (SLOT)                              "given a parsed-slot returns a datatype fieldspec that will contain it."   (%%STRUCTURE-TYPE-TO-FIELDSPEC (PSLOT-TYPE SLOT)))(CL:DEFUN %%STRUCTURE-TYPE-TO-FIELDSPEC (ELEMENTTYPE)                                                   (* ;;;                   "Returns the most specific InterLisp type descriptor which will hold a given type.")                                                  (* ;;; "Note: This function accepts only a limited subset of the Common Lisp type specifiers: T FLOAT SINGLE-FLOAT FIXNUM BIT (MOD n) (UNSIGNED-BYTE n) INTEGER (INTEGER low high) XPOINTER DOUBLE-POINTER")   (CASE ELEMENTTYPE ((CL:STRING-CHAR T)                      'POINTER)         (CL:FIXNUM 'SIGNEDWORD)         (INTEGER 'FIXP)         (BIT '(BITS 1))         (XPOINTER ELEMENTTYPE)         ((CL:SINGLE-FLOAT FLOAT)          'FLOATP)         (OTHERWISE (COND                       ((EQ (CAR (LISTP ELEMENTTYPE))                            'DATATYPE)                (* ;; "include the known faves, otherwise t.")                        (CASE (CADR ELEMENTTYPE)                              (FLOATP 'FLOATP)                              (OTHERWISE 'POINTER)))                       ((AND (EQ (CAR (LISTP ELEMENTTYPE))                                 'INTEGER)                             (NULL (CDDDR ELEMENTTYPE))                             (FIXP (CADR ELEMENTTYPE))                             (FIXP (CADDR ELEMENTTYPE))                             (ILESSP (CADR ELEMENTTYPE)                                    (CADDR ELEMENTTYPE)))    (* ; "(INTEGER low high)")                        (LET* ((LOW (CADR ELEMENTTYPE))                               (HIGH (CADDR ELEMENTTYPE))                               (RANGE (IDIFFERENCE HIGH LOW)))                                                  (* ;                                          "Type simplification should probably be done somewhere else")                              (COND                                 ((IEQP LOW 0)               (* ; "(INTEGER 0 high) => (MOD nbits)")                                  (\CMLSTRUCT.CLTYPE.TO.ILTYPE `(MOD %, (ADD1 RANGE))))                                 ((AND (IGEQ LOW MIN.FIXP)                                       (ILEQ HIGH MAX.FIXP))                                                  (* ; "(INTEGER >= MIN.FIXP <= MAX.FIXP) == FIXNUM")                                  'FIXP)                                 (T 'POINTER))))                       ((EQUAL ELEMENTTYPE '(CL:SIMPLE-VECTOR CL:* CL:FIXNUM))                        'POINTER)                       ((FMEMB ELEMENTTYPE (USERDATATYPES))                        'POINTER)                       (T (LET ((EXPANDER (TYPE-EXPANDER ELEMENTTYPE)))                               (CL:IF EXPANDER (%%STRUCTURE-TYPE-TO-FIELDSPEC (TYPE-EXPAND                                                                                      ELEMENTTYPE                                                                                      EXPANDER))                                      'POINTER)))))))(CL:DEFUN ASSIGN-FIELD-DESCRIPTORS (PS FIELD-DESCRIPTORS)                              "assigns the field descriptors for accessing each slot of the structure"   (CL:ASSERT (EQ (PS-TYPE PS)                  'DATATYPE))   (FOR F IN FIELD-DESCRIPTORS AS SLOT IN (PS-ALL-SLOTS PS) DO (CL:SETF (PSLOT-FIELD-DESCRIPTOR                                                                         SLOT)                                                                      F)))(* ;;; "accessors and setfs")(CL:DEFUN DEFINE-ACCESSORS (PS) "returns the forms that when evaluated, define the accessors"   (LET ((ARG-NAME (PS-NAME PS))         (STRUCTURE-TYPE (PS-TYPE PS)))           (* ;;                  "the arg-name must be the structure name, since it is already in the raw-accessors.")        (CL:MAPCAN #'(LAMBDA (SLOT)                       (LET ((ACCESSOR (PSLOT-ACCESSOR SLOT)))                            (CL:IF ACCESSOR `((,(FUNCTION-DEFINING-FORM PS 'ACCESSOR)                                               ,ACCESSOR                                               (,ARG-NAME)                                               ,(PSLOT-INTERNAL-ACCESSOR SLOT ARG-NAME STRUCTURE-TYPE                                                       )))))) (PS-ALL-SLOTS PS))))(CL:DEFUN PSLOT-INTERNAL-ACCESSOR (SLOT ARGUMENT STRUCTURE-TYPE &OPTIONAL (NO-TYPE-CHECK NIL))                                                     "returns a form which fetches slot from argument"   (CL:ECASE STRUCTURE-TYPE (DATATYPE `(,(CL:IF NO-TYPE-CHECK 'FFETCHFIELD 'FETCHFIELD)                                        ',(PSLOT-FIELD-DESCRIPTOR SLOT)                                        ,ARGUMENT))          (LIST `(CL:NTH ,(PSLOT-FIELD-DESCRIPTOR SLOT) ,ARGUMENT))          (CL:VECTOR `(CL:SVREF ,ARGUMENT ,(PSLOT-FIELD-DESCRIPTOR SLOT)))))(CL:DEFUN DEFINE-SETFS (PS) "returns the forms that when evaluated, define the setf's for the slots."   (LET ((ARG-NAME (PS-NAME PS))         (STRUCTURE-TYPE (PS-TYPE PS)))           (* ;; "map over the slots, and for any slot which is not read-only, generate a defsetf and a function definition for the setter.")        (CL:MAPCAN #'(LAMBDA (SLOT)                       (LET* ((ACCESSOR (PSLOT-ACCESSOR SLOT))                              (SETF-FUNCTION (SETF-NAME ACCESSOR)))                                                  (* ;;        "function-defining-form decides whether or not the accessors should be defun, definline, etc.")                             (CL:IF (NOT (PSLOT-READ-ONLY SLOT))                                    `((CL:DEFSETF (\, ACCESSOR) ,SETF-FUNCTION )                                      (,(FUNCTION-DEFINING-FORM PS 'SETFS) ,SETF-FUNCTION                                             (,ARG-NAME VALUE)                                             (CL:SETF ,(PSLOT-INTERNAL-ACCESSOR SLOT ARG-NAME                                                               STRUCTURE-TYPE) VALUE))))))               (PS-ALL-SLOTS PS))))(CL:DEFUN SETF-NAME (ACCESSOR-NAME) "produces the name of the setf function for this accessor"   (XCL:PACK (LIST '%%SETF- ACCESSOR-NAME)))(* ;;; "constructor definition code")(CL:DEFUN DEFINE-CONSTRUCTORS (PS) "returns the forms that when evaluated, define the constructors"   (LET* ((CONSTRUCTORS (PS-CONSTRUCTORS PS))          (SLOTS (PS-ALL-SLOTS PS))          (RESULT-ARG (PS-NAME PS))          (ALL-BOAS? (CL:EVERY #'BOA-CONSTRUCTOR-P CONSTRUCTORS)))         (COND            (ALL-BOAS?                               (* ;; "don't bother building the arglist etc.")                   (MAPCAR #'DEFINE-BOA-CONSTRUCTOR CONSTRUCTORS))            (T (LET ((ARGUMENT-LIST (BUILD-CONSTRUCTOR-ARGLIST SLOTS))                     (SLOT-SETFS (BUILD-CONSTRUCTOR-SLOT-SETFS SLOTS PS)))                    (FOR CONSTRUCTOR IN CONSTRUCTORS                       COLLECT (COND                                  ((BOA-CONSTRUCTOR-P CONSTRUCTOR)                                   (DEFINE-BOA-CONSTRUCTOR CONSTRUCTOR))                                  (T              (* ;;                      "keep the name of a standard constructor, if any, so that the #s form can work.")                                     (CL:SETF (PS-STANDARD-CONSTRUCTOR PS)                                            CONSTRUCTOR)                                                  (* ;;             "since we just built the object we're setting fields of, we don't need to type check it.")                                     `(CL:DEFUN (\, CONSTRUCTOR) (&KEY ,@ARGUMENT-LIST)                                         (LET ((,RESULT-ARG ,(RAW-CONSTRUCTOR PS)))                                              ,@SLOT-SETFS                                              ,RESULT-ARG))))))))))(CL:DEFUN RAW-CONSTRUCTOR (PS)                     "returns a form which will make an instance of this structure w/o initialisation"   (CL:ECASE (PS-TYPE PS)          (DATATYPE `(NCREATE ',(PS-NAME PS)))          (LIST `(CL:MAKE-LIST ,(PS-NUMBER-OF-SLOTS PS)))          (CL:VECTOR `(CL:MAKE-ARRAY '(,(PS-NUMBER-OF-SLOTS PS)) :ELEMENT-TYPE                             ',(PS-VECTOR-TYPE PS)))))(CL:DEFUN BUILD-CONSTRUCTOR-ARGLIST (SLOTS)                                  "gathers the keywords and initial-values for (non BOA) constructors"   (CL:MAPCAN #'(LAMBDA (SLOT)                  (LET ((INIT-FORM (PSLOT-INITIAL-VALUE SLOT))                        (ARG-NAME (PSLOT-NAME SLOT)))                       (COND                          ((NOT (PSLOT-ACCESSOR SLOT))                                                  (* ;;                 "this is an invisible slot (name, initial-offset, etc.) don't generate a keyword arg")                           NIL)                          (INIT-FORM              (* ;;                                                   "specify an initial value for the keyword arg")                                 `((,ARG-NAME ,INIT-FORM)))                          (T `(,ARG-NAME))))) SLOTS))(CL:DEFUN BUILD-CONSTRUCTOR-SLOT-SETFS (SLOTS PS)                                         "builds the setfs that initialize the slots in a constructor"   (LET ((STRUCTURE-TYPE (PS-TYPE PS))         (OBJECT-NAME (PS-NAME PS)))        (CL:MAPCAR #'(CL:LAMBDA (SLOT)                            (COND                               ((NOT (PSLOT-ACCESSOR SLOT))                                                  (* ;;                                            "invisible slot, so generate a setf to it's initial-value")                                `(CL:SETF ,(PSLOT-INTERNAL-ACCESSOR SLOT OBJECT-NAME STRUCTURE-TYPE T                                                  ) ,(PSLOT-INITIAL-VALUE SLOT)))                               (T (LET ((KEYWORD-ARG-NAME (PSLOT-NAME SLOT)))                                                  (* ;;                     " since slots can be read-only, we setf the raw accessor, not the slot accessor.")                                                  (* ;; "Also, since we built the object in which we are setting fields, we use the internal-accessor without typecheck")                                       `(CL:SETF ,(PSLOT-INTERNAL-ACCESSOR SLOT OBJECT-NAME                                                          STRUCTURE-TYPE T) ,KEYWORD-ARG-NAME)))))                SLOTS)))(CL:DEFUN BOA-CONSTRUCTOR-P (CONSTRUCTOR)                                 "returns t if the constructor is a By Order of Arguments constructor"   (CL:CONSP CONSTRUCTOR))(CL:DEFUN DEFAULT-CONSTRUCTOR-NAME (STRUCTURE-NAME) (XCL:PACK (LIST 'MAKE- STRUCTURE-NAME)))(* ;;; "predicate")(CL:DEFUN CONSTRUCT-PREDICATE (PS)                                  "returns a list of the forms (if any) defining the predicate for ps"   (LET ((PREDICATE (PS-PREDICATE PS)))        (CL:IF PREDICATE               (LET ((PREDICATE-BODY                      (CASE (PS-TYPE PS)                            (DATATYPE             (* ;;                                                "for datatypes, always create a predicate.  Use typep")                                   `(TYPEP OBJECT ',(PS-NAME PS)))                            (OTHERWISE            (* ;;                                       "vectors and lists can only have a predicate if they are named")                                   (CL:IF (NOT (PS-NAMED PS))                                          (ERROR                              "The predicate ~s may not be specified for ~s because it is not :name'd"                                                  PREDICATE (PS-NAME PS)))                                   `(AND (TYPEP OBJECT 'SEQUENCE)                                         (EQ (CL:ELT (THE ,(PS-TYPE-SPECIFIER PS) OBJECT)                                                    ,(PS-NAME-SLOT-POSITION PS))                                             ',(PS-NAME PS)))))))                    `((,(FUNCTION-DEFINING-FORM PS 'PREDICATE) ,PREDICATE (OBJECT)                             ,PREDICATE-BODY))))))(CL:DEFUN PS-NAME-SLOT-POSITION (PS) "returns the offset of the name slot for ps."   (LET* ((INCLUDE (PS-INCLUDE PS))          (SUPER-SLOTS (AND INCLUDE (PS-ALL-SLOTS (PARSED-STRUCTURE INCLUDE)))))         (+ (PS-INITIAL-OFFSET PS)            (CL:LENGTH SUPER-SLOTS))))(CL:DEFUN DEFAULT-PREDICATE-NAME (STRUCTURE-NAME) (XCL:PACK (LIST STRUCTURE-NAME '-P)))(CL:DEFUN FUNCTION-DEFINING-FORM (PS CONTEXT)                        "dummy definition for now, for deciding if a function should be inline or not"   'CL:DEFUN)(* ;;; "copiers")(CL:DEFUN DEFINE-COPIERS (PS) "returns the form that when evaluated, defines the copier"   (LET ((COPIER (PS-COPIER PS))         (RESULT-ARG 'NEW)         (FROM-ARG (PS-NAME PS)))        (CL:IF COPIER (CL:MULTIPLE-VALUE-BIND (FROM-ARG-TYPE-CHECK TYPE-CHECK-SLOTS?)                             (BUILD-COPIER-TYPE-CHECK PS FROM-ARG)                             (LET ((SLOT-SETFS (BUILD-COPIER-SLOT-SETFS (PS-ALL-SLOTS PS)                                                      (PS-TYPE PS)                                                      FROM-ARG RESULT-ARG TYPE-CHECK-SLOTS?)))                                                  (* ;;             "Since we just built the object we're setting fields of, we don't need to type check it.")                                  `((CL:DEFUN (\, (PS-COPIER PS)) (,FROM-ARG)                                       ,@FROM-ARG-TYPE-CHECK (LET ((,RESULT-ARG ,(RAW-CONSTRUCTOR                                                                                  PS)))                                                                  ,@SLOT-SETFS                                                                  ,RESULT-ARG))))))))(CL:DEFUN BUILD-COPIER-SLOT-SETFS (SLOTS STRUCTURE-TYPE FROM-ARGUMENT TO-ARGUMENT TYPE-CHECK-SLOTS?)                                                "constructs the forms that copy each individual slot."                                                     (* ;; "build a series of forms that look like")                                                  (* ;;                                            "(setf (structure-slot to-arg) (structure-slot from-arg))")   (CL:MAPCAR #'(CL:LAMBDA (SLOT)                       `(CL:SETF ,(PSLOT-INTERNAL-ACCESSOR SLOT TO-ARGUMENT STRUCTURE-TYPE T)                               ,(PSLOT-INTERNAL-ACCESSOR SLOT FROM-ARGUMENT STRUCTURE-TYPE T))) SLOTS          ))(CL:DEFUN BUILD-COPIER-TYPE-CHECK (PS FROM-ARG) "constructs the type checking form at the beginning of the copier and decides whether individual slots need to be type-checked."   (COND      ((EQ (PS-TYPE PS)           'DATATYPE)                             (* ;; "If something is a datatype type check the from-arg once at the beginning.  Don't check the individual accesses.")       (CL:VALUES `((CL:CHECK-TYPE ,FROM-ARG ,(PS-NAME PS))) NIL))      ((PS-PREDICATE PS)                          (* ;;                                          "if the structure has a predicate ,then call the predicate.")       (SETQ TYPE-CHECK-FORM (CL:VALUES `((OR (,(PS-PREDICATE PS) ,FROM-ARG)                                              (CL:ERROR ,(FORMAT NIL "Arg not ~s: ~~S" (PS-NAME                                                                                        PS))                                                     ,FROM-ARG))) NIL)))      (T                                          (* ;; "Otherwise, just use the type-checked slot access, so that at least the argument is assured to be a vector/list.")         (CL:VALUES NIL T))))(* ;;; "print functions")(CL:DEFUN RECORD-PRINT-FUNCTION (PS)                                  "returns a list of the forms (if any) recording the print-function."   (LET ((PRINT-FUNCTION (PS-PRINT-FUNCTION PS)))        (CL:IF PRINT-FUNCTION `((DEFPRINT ',(PS-NAME PS) ',PRINT-FUNCTION)))))(* ;;; "internal stuff.")(CL:DEFSETF FFETCHFIELD REPLACEFIELD)(* ;;; "utilities")(CL:DEFUN SAFE-TYPE-EXPAND (TYPE-FORM) (LET ((TYPE-EXPANDER (TYPE-EXPANDER TYPE-FORM)))                                            (CL:IF TYPE-EXPANDER (TYPE-EXPAND TYPE-FORM TYPE-EXPANDER                                                                        )                                                   TYPE-FORM)))(DEFMACRO DEFSTRUCT-ASSERT-SUBTYPEP (TYPE1 TYPE2 (ERROR-STRING . ERROR-ARGS) . CERROR-ACTIONS)      "provides an interface for places where the implementor isn't sure that subtypep can be trusted"   (LET ((ERROR-STRING (OR ERROR-STRING "~S is not a subtype of ~S"))         (ERROR-ARGS (OR ERROR-ARGS (LIST TYPE1 TYPE2))))        `(CL:MULTIPLE-VALUE-BIND (SUBTYPE? CERTAIN?)                (CL:SUBTYPEP ,TYPE1 ,TYPE2)                (COND                   (SUBTYPE?                                 (* ; "it's ok, continue")                          T)                   (CERTAIN?                               (* ; "subtypep says it sure, so blow up")                          (CL:FUNCALL #'CL:ERROR ,ERROR-STRING ,@ERROR-ARGS))                   (T                             (* ;                                                   "subtypep isn't sure, so raise a continuable error")                      (CL:FUNCALL #'CL:CERROR "Assume subtypep should return t"                             ,(CONCAT "Perhaps, " ERROR-STRING)                             ,@ERROR-ARGS)                      ,@CERROR-ACTIONS T)))))(* ;;; "file properties")(PUTPROPS DEFSTRUCT FILETYPE CL:COMPILE-FILE)(PUTPROPS DEFSTRUCT COPYRIGHT ("Xerox Corporation" 1986))(DECLARE%: DONTCOPY  (FILEMAP (NIL)))STOP