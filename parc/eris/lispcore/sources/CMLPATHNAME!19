(DEFINE-FILE-INFO §READTABLE "INTERLISP" §PACKAGE "INTERLISP")(FILECREATED "28-Oct-86 22:16:40" {ERIS}<LISPCORE>SOURCES>CMLPATHNAME.;19 37920        changes to%:  (FNS CL:MAKE-PATHNAME)      previous date%: "23-Oct-86 16:45:29" {ERIS}<LISPCORE>SOURCES>CMLPATHNAME.;18)(* "Copyright (c) 1986 by Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT CMLPATHNAMECOMS)(RPAQQ CMLPATHNAMECOMS        ((* ;; "Common Lisp pathname functions")        (PROP FILETYPE CMLPATHNAME)        (COMS (* ;; "useful macros")              (FUNCTIONS %%WILD-NAME %%COMPONENT-STRING %%UNPACKFILE1))        (STRUCTURES PATHNAME)        (FNS %%PRINT-PATHNAME CL:MAKE-PATHNAME CL:PATHNAME-HOST CL:PATHNAME-DEVICE              CL:PATHNAME-DIRECTORY CL:PATHNAME-NAME CL:PATHNAME-TYPE CL:PATHNAME-VERSION)        (FNS PATHNAME CL:MERGE-PATHNAMES FILE-NAME CL:HOST-NAMESTRING CL:ENOUGH-NAMESTRING              %%NUMERIC-STRING-P)        (FUNCTIONS CL:NAMESTRING CL:PARSE-NAMESTRING PARSE-NAMESTRING1 CL:TRUENAME)        (FUNCTIONS %%MAKE-PATHNAME)        (FUNCTIONS INTERLISP-NAMESTRING)        (FUNCTIONS %%PATHNAME-EQUAL)        (FUNCTIONS %%INITIALIZE-DEFAULT-PATHNAME)        (VARIABLES *DEFAULT-PATHNAME-DEFAULTS*)        (COMS (* ;; "Interlisp-D compatibility")              (FUNCTIONS UNPACKPATHNAME.STRING))        (FUNCTIONS CL:FILE-NAMESTRING CL:DIRECTORY-NAMESTRING)        (DECLARE%: DONTEVAL@LOAD DOCOPY (P (%%INITIALIZE-DEFAULT-PATHNAME)))        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS               (ADDVARS (NLAMA)                      (NLAML)                      (LAMA CL:ENOUGH-NAMESTRING CL:HOST-NAMESTRING FILE-NAME CL:MERGE-PATHNAMES                             PATHNAME CL:PATHNAME-VERSION CL:PATHNAME-TYPE CL:PATHNAME-NAME                             CL:PATHNAME-DIRECTORY CL:PATHNAME-DEVICE CL:PATHNAME-HOST                             CL:MAKE-PATHNAME %%PRINT-PATHNAME)))))(* ;; "Common Lisp pathname functions")(PUTPROPS CMLPATHNAME FILETYPE CL:COMPILE-FILE)(* ;; "useful macros")(DEFMACRO %%WILD-NAME (STRING) `(LET ((S ,STRING))                                     (CL:IF (STRING-EQUAL S "*")                                            :WILD S)))(DEFMACRO %%COMPONENT-STRING (COMPONENT) `(OR ,COMPONENT ""))(DEFMACRO %%UNPACKFILE1 (NAM ST END FILE PACKFLG ONEFIELDFLG VAL)   `(if (NOT ,ONEFIELDFLG)        then (SETQ ,VAL (CONS (COND                                 (,PACKFLG (SUBATOM ,FILE ,ST ,END))                                 (T (OR (SUBSTRING ,FILE ,ST ,END)                                        "")))                              (CONS ,NAM ,VAL)))      elseif (EQMEMB ,NAM ,ONEFIELDFLG)        then (RETURN (COND                        (,PACKFLG (SUBATOM ,FILE ,ST ,END))                        (T (OR (SUBSTRING ,FILE ,ST ,END)                               ""))))))(CL:DEFSTRUCT (PATHNAME (:CONC-NAME %%PATHNAME-)                        (:PRINT-FUNCTION %%PRINT-PATHNAME)                        (:CONSTRUCTOR %%%%MAKE-PATHNAME)                        (:PREDICATE CL:PATHNAMEP)) HOST DEVICE DIRECTORY NAME TYPE VERSION)(DEFINEQ(%%PRINT-PATHNAME  (CL:LAMBDA (S STREAM D)                                    (* hdj "19-Sep-86 15:49")         (DECLARE (IGNORE D))         (FORMAT STREAM "#.(PATHNAME ~S)" (CL:NAMESTRING S))))(CL:MAKE-PATHNAME  (CL:LAMBDA (&KEY DEFAULTS (HOST NIL HOSTP)                   (DEVICE NIL DEVICEP)                   (DIRECTORY NIL DIRECTORYP)                   (NAME NIL NAMEP)                   (TYPE NIL TYPEP)                   (VERSION NIL VERSIONP))                   (* hdj "23-Oct-86 16:34")                                                  (* ;; "Create a pathname from host, device, directory, name, type and version.  If any field is omitted, it is obtained from defaults as though by merge-pathnames.")         (CL:IF DEFAULTS (LET ((DEFAULTS (PATHNAME DEFAULTS)))                              (CL:UNLESS HOSTP (SETQ HOST (%%PATHNAME-HOST DEFAULTS)))                              (CL:UNLESS DEVICEP (SETQ DEVICE (%%PATHNAME-DEVICE DEFAULTS)))                              (CL:UNLESS DIRECTORYP (SETQ DIRECTORY (%%PATHNAME-DIRECTORY DEFAULTS)))                              (CL:UNLESS NAMEP (SETQ NAME (%%PATHNAME-NAME DEFAULTS)))                              (CL:UNLESS TYPEP (SETQ TYPE (%%PATHNAME-TYPE DEFAULTS)))                              (CL:UNLESS VERSIONP (SETQ VERSION (%%PATHNAME-VERSION DEFAULTS))))                (CL:UNLESS HOSTP (SETQ HOST (%%PATHNAME-HOST *DEFAULT-PATHNAME-DEFAULTS*))))         (%%MAKE-PATHNAME (CL:IF (STRINGP HOST)                                 (COERCE HOST 'CL:SIMPLE-STRING)                                 HOST)                (CL:IF (STRINGP DEVICE)                       (COERCE DEVICE 'CL:SIMPLE-STRING)                       DEVICE)                DIRECTORY                (CL:IF (STRINGP NAME)                       (COERCE NAME 'CL:SIMPLE-STRING)                       NAME)                (CL:IF (STRINGP TYPE)                       (COERCE TYPE 'CL:SIMPLE-STRING)                       TYPE)                VERSION)))(CL:PATHNAME-HOST  (CL:LAMBDA (PATHNAME)                    (* These can not be done by the accessors because the pathname arg may be a           string or a symbol or etc. *)                    (* Returns the host slot of pathname. Pathname may be a string, symbol, or           stream. *)         (%%PATHNAME-HOST (CL:IF (CL:PATHNAMEP PATHNAME)                                 PATHNAME                                 (PATHNAME PATHNAME)))))(CL:PATHNAME-DEVICE  (CL:LAMBDA (PATHNAME)                                      (* hdj "19-Sep-86 15:50")         (%%PATHNAME-DEVICE (CL:IF (CL:PATHNAMEP PATHNAME)                                   PATHNAME                                   (PATHNAME PATHNAME)))))(CL:PATHNAME-DIRECTORY  (CL:LAMBDA (PATHNAME)                                      (* hdj "19-Sep-86 15:50")         (%%PATHNAME-DIRECTORY (CL:IF (CL:PATHNAMEP PATHNAME)                                      PATHNAME                                      (PATHNAME PATHNAME)))))(CL:PATHNAME-NAME  (CL:LAMBDA (PATHNAME)                                      (* hdj "19-Sep-86 15:50")         (%%PATHNAME-NAME (CL:IF (CL:PATHNAMEP PATHNAME)                                 PATHNAME                                 (PATHNAME PATHNAME)))))(CL:PATHNAME-TYPE  (CL:LAMBDA (PATHNAME)                                      (* hdj "19-Sep-86 15:50")         (%%PATHNAME-TYPE (CL:IF (CL:PATHNAMEP PATHNAME)                                 PATHNAME                                 (PATHNAME PATHNAME)))))(CL:PATHNAME-VERSION  (CL:LAMBDA (PATHNAME)                                      (* hdj "19-Sep-86 15:50")         (%%PATHNAME-VERSION (CL:IF (CL:PATHNAMEP PATHNAME)                                    PATHNAME                                    (PATHNAME PATHNAME))))))(DEFINEQ(PATHNAME  (CL:LAMBDA (THING)                                         (* hdj " 2-Apr-86 11:01")                    (* Turns Thing into a pathname. Thing may be a string, symbol, stream, or           pathname. *)         (CL:VALUES (CL:PARSE-NAMESTRING THING))))(CL:MERGE-PATHNAMES  (CL:LAMBDA (PATHNAME &OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)                    DEFAULT-VERSION)                         (* hdj "20-Jun-86 11:34")                    (* * "Merge-Pathnames -- Public Returns a new pathname whose fields are the same as the fields in PATHNAME except that NIL fields are filled in from defaults.  Type and Version field are only done if name field has to be done (see manual for explanation). Fills in unspecified slots of Pathname from Defaults (defaults to *default-pathname-defaults*).  If the version remains unspecified, gets it from Default-Version.")         (LET* ((PATH (PATHNAME PATHNAME))                (DEFAULT-PATH (PATHNAME DEFAULTS))                (NAME (%%PATHNAME-NAME PATH))                (DEVICE (%%PATHNAME-DEVICE PATH)))               (%%MAKE-PATHNAME (OR (%%PATHNAME-HOST PATH)                                    (%%PATHNAME-HOST DEFAULT-PATH))                      (OR DEVICE (%%PATHNAME-DEVICE DEFAULT-PATH))                      (OR (%%PATHNAME-DIRECTORY PATH)                          (%%PATHNAME-DIRECTORY DEFAULT-PATH))                      (OR NAME (%%PATHNAME-NAME DEFAULT-PATH))                      (OR (%%PATHNAME-TYPE PATH)                          (%%PATHNAME-TYPE DEFAULT-PATH))                      (OR (%%PATHNAME-VERSION PATH)                          (CL:IF NAME DEFAULT-VERSION (OR (%%PATHNAME-VERSION DEFAULT-PATH)                                                          DEFAULT-VERSION)))))))(FILE-NAME  (CL:LAMBDA (FILE)                                          (* hdj " 9-Oct-86 15:12")         (LET ((NAME (FULLNAME FILE)))              (if (STREAMP NAME)                  then ""                else (MKSTRING NAME)))))(CL:HOST-NAMESTRING  (CL:LAMBDA (PATHNAME)                                      (* hdj "11-Jun-86 11:29")                    (* Returns the host part of PATHNAME as a string.          *)         (%%COMPONENT-STRING (%%PATHNAME-HOST (PATHNAME PATHNAME)))))(CL:ENOUGH-NAMESTRING  (CL:LAMBDA (PATHNAME &OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*))                                                             (* hdj "19-Sep-86 15:51")                                                             (* ; "Enough-Namestring")                                                  (* ;                               "Returns a string which uniquely identifies PATHNAME w.r.t.  DEFAULTS.")         (LET* ((PATH (PATHNAME PATHNAME))                (DEFAULT-PATHNAME (PATHNAME DEFAULTS))                (DEVICE (%%PATHNAME-DEVICE PATH))                (DIRECTORY (%%PATHNAME-DIRECTORY PATH))                (NAME (%%PATHNAME-NAME PATH))                (TYPE (%%PATHNAME-TYPE PATH))                (VERSION (%%PATHNAME-VERSION PATH))                (RESULT "")                (NEED-NAME NIL))               (DECLARE (CL:SIMPLE-STRING RESULT))               (CL:WHEN (AND DEVICE (CL:STRING-NOT-EQUAL DEVICE (%%COMPONENT-STRING (                                                                                    %%PATHNAME-DEVICE                                                                                     DEFAULT-PATHNAME                                                                                     ))))                      (SETQ RESULT DEVICE))               (CL:WHEN (AND DIRECTORY (NOT (CL:EQUALP DIRECTORY (%%COMPONENT-STRING (                                                                                 %%PATHNAME-DIRECTORY                                                                                                                                                                           DEFAULT-PATHNAME                                                                                      )))))                      (SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING RESULT "<" (THE CL:SIMPLE-STRING                                                                                      DIRECTORY)                                          ">")))               (CL:WHEN (AND NAME (CL:STRING-NOT-EQUAL NAME (%%COMPONENT-STRING (%%PATHNAME-NAME                                                                                 DEFAULT-PATHNAME))))                      (CL:SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING RESULT (THE CL:SIMPLE-STRING                                                                                     NAME))                             NEED-NAME T))               (CL:WHEN (AND TYPE (OR NEED-NAME (CL:STRING-NOT-EQUAL TYPE (%%COMPONENT-STRING                                                                           (%%PATHNAME-TYPE                                                                                   DEFAULT-PATHNAME)))                                      ))                      (SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING RESULT "." (THE CL:SIMPLE-STRING                                                                                      TYPE))))               (CL:WHEN (AND VERSION (OR NEED-NAME (NOT (EQL VERSION (%%PATHNAME-VERSION                                                                             DEFAULT-PATHNAME)))))                      (SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING RESULT ";" (THE CL:SIMPLE-STRING                                                                                     (                                                                                   %%COMPONENT-STRING                                                                                      VERSION)))))               RESULT)))(%%NUMERIC-STRING-P  (LAMBDA (STRING)                                           (* hdj "28-Jul-86 12:25")    (AND (CL:STRINGP STRING)         (for CHAR instring STRING do (if (OR (ILESSP CHAR (CHARCODE 0))                                              (IGREATERP CHAR (CHARCODE 9)))                                          then (RETURN NIL)) finally (RETURN T))))))(CL:DEFUN CL:NAMESTRING (PATHNAME)                (* ;;;                                                   "Returns the full form of PATHNAME as a string.")   (if (AND (STREAMP PATHNAME)            (NOT (fetch (STREAM NAMEDP) of PATHNAME)))       then (CL:RETURN-FROM CL:NAMESTRING ""))   (SETQ PATHNAME (PATHNAME PATHNAME))   (LET* ((HOST (%%PATHNAME-HOST PATHNAME))          (DEVICE (%%PATHNAME-DEVICE PATHNAME))          (DIRECTORY (%%PATHNAME-DIRECTORY PATHNAME))          (NAME (%%PATHNAME-NAME PATHNAME))          (TYPE (%%PATHNAME-TYPE PATHNAME))          (VERSION (%%PATHNAME-VERSION PATHNAME))          (RESULT NIL))         (DECLARE (CL:SIMPLE-STRING RESULT))         (CL:WHEN HOST (SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING "{" (THE CL:SIMPLE-STRING HOST)                                           "}"))) (* ;;                       "device will have `:' on end because it allows you to have a device called NIL")         (CL:WHEN DEVICE (SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING RESULT (THE CL:SIMPLE-STRING                                                                                     DEVICE))))         (CL:WHEN DIRECTORY (SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING RESULT "<"                                                (CL:IF (EQ DIRECTORY :WILD)                                                       "*"                                                       (THE CL:SIMPLE-STRING DIRECTORY))                                                ">")))         (CL:WHEN NAME (SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING RESULT (CL:IF (EQ NAME :WILD)                                                                                    "*"                                                                                    (THE                                                                                      CL:SIMPLE-STRING                                                                                          NAME)))))         (CL:WHEN TYPE (SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING RESULT "."                                           (CL:IF (EQ TYPE :WILD)                                                  "*"                                                  (THE CL:SIMPLE-STRING TYPE)))))         (CL:WHEN VERSION (SETQ RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING RESULT                                              (CASE VERSION (:WILD ";*")                                                    ((:NEWEST NIL)                                                     "")                                                    (OTHERWISE (CL:CONCATENATE 'CL:SIMPLE-STRING ";"                                                                      (CL:PRINC-TO-STRING VERSION))))                                              )))         RESULT))(CL:DEFUN CL:PARSE-NAMESTRING (THING &OPTIONAL HOST (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)                                     &KEY                                     (START 0)                                     END                                     (JUNK-ALLOWED NIL))                                                   (* ;;; "Parses a string representation of a pathname into a pathname.  For details on the other silly arguments see the manual.  NOTE that this version ignores JUNK-ALLOWED (because UNPACKFILENAME a.k.a. PARSE-NAMESTRING1 will parse anything)")   (CL:UNLESS DEFAULTS (CL:SETQ DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*))   (CL:UNLESS HOST (SETQ HOST (%%PATHNAME-HOST DEFAULTS)))   (CL:TYPECASE THING (STRING (SETQ THING (COERCE THING 'CL:SIMPLE-STRING)))          (PATHNAME (CL:RETURN-FROM CL:PARSE-NAMESTRING (CL:VALUES THING START)))          (STREAM (SETQ THING (FILE-NAME THING)))          (CL:SYMBOL (SETQ THING (CL:SYMBOL-NAME THING)))          (T (CL:ERROR "This is of an inappropriate type for parse-namestring: ~S" THING)))   (CL:UNLESS END (SETQ END (CL:LENGTH (THE CL:SIMPLE-STRING THING))))   (LET* ((RESULT (PARSE-NAMESTRING1 (MKSTRING (CL:SUBSEQ THING START END))))          (PATH-LIST (CDR RESULT)))         (CL:VALUES (CL:MAKE-PATHNAME :HOST (LISTGET PATH-LIST 'HOST)                           :DEVICE                           (LISTGET PATH-LIST 'DEVICE)                           :DIRECTORY                           (%%WILD-NAME (LISTGET PATH-LIST 'DIRECTORY))                           :NAME                           (%%WILD-NAME (LISTGET PATH-LIST 'NAME))                           :TYPE                           (%%WILD-NAME (LISTGET PATH-LIST 'TYPE))                           :VERSION                           (LET ((VERSION (LISTGET PATH-LIST 'VERSION)))                                (CL:IF (OR (NULL VERSION)                                           (CL:EQUAL VERSION ""))                                       :NEWEST                                       (CL:IF (CL:EQUAL VERSION "*")                                              :WILD                                              (MKATOM VERSION)))))                (+ START (CAR RESULT)))))(CL:DEFUN PARSE-NAMESTRING1 (FILE)                (* ;;;            "Given a string or atom representation of a file name, unpack it into its component parts")                                                  (* ;;; "crudely hacked from UNPACKFILENAME.STRING")   (PROG ((POS 1)          TEM TEM2 BEYONDNAME BEYONDEXT VAL CODE HOSTP SUBDIREND PACKFLG DIRFLG ONEFIELDFLG)         (COND            ((NULL FILE)             (RETURN (CONS POS NIL)))            ((OR (LITATOM FILE)                 (CL:STRINGP FILE)                 (NUMBERP FILE)))            ((type? STREAM FILE)                  (* ;                                                  "For streams, use full name.  If anonymous, fake it")             (SETQ FILE (OR (ffetch FULLFILENAME of FILE)                            (RETURN (CONS POS (LIST 'NAME FILE))))))            (T (\ILLEGAL.ARG FILE)))         (COND            ((SELCHARQ (NTHCHARCODE FILE 1)                  ({                                         (* ; "normal use in Interlisp-D")                     (SETQ TEM (SUB1 (OR (\UPF.NEXTPOS (CHARCODE })                                                FILE 2)                                         0))))                  (%[                             (* ;                                                   "some Xerox and Arpanet systems use `[' for host")                      (SETQ TEM (SUB1 (OR (\UPF.NEXTPOS (CHARCODE "]")                                                 FILE 2)                                          0))))                  (%(                             (* ;                                                 "this is the standard for Xerox product file servers")                      (SETQ TEM (SUB1 (OR (\UPF.NEXTPOS (CHARCODE ")")                                                 FILE 2)                                          0))))                  NIL)             (%%UNPACKFILE1 'HOST 2 TEM FILE PACKFLG ONEFIELDFLG VAL)             (COND                ((EQ TEM -1)                 (RETURN (CONS POS (DREVERSE VAL)))))             (SETQ POS (IPLUS TEM 2))             (SETQ HOSTP T)))         (COND            ((SETQ TEM (LASTCHPOS (CHARCODE %:)                              FILE POS))          (* ;                                             "all device returned have : on it so that NIL: will work")             (%%UNPACKFILE1 'DEVICE POS TEM FILE PACKFLG ONEFIELDFLG VAL)             (SETQ POS (ADD1 TEM))             (SETQ HOSTP T)))         (COND            ((EQ DIRFLG 'RETURN)             (LET ((TYPE 'DIRECTORY)                   (START (SELCHARQ (NTHCHARCODE FILE POS)                               (NIL (RETURN (CONS POS (DREVERSE VAL))))                               ((/ <)                                     (ADD1 POS))                               POS))                   END)                  (SETQ END (SELCHARQ (NTHCHARCODE FILE -1)                                 ((/ >)                                       (COND                                         ((AND (EQ START POS)                                               (NOT HOSTP))                                                  (* ;       "Didn't start with a directory delimiter, but it ends with one, so this must be a subdirectory")                                          (SETQ TYPE 'SUBDIRECTORY)))                                      -2)                                 (PROGN -1)))                  (%%UNPACKFILE1 TYPE START END FILE PACKFLG ONEFIELDFLG VAL))             (RETURN (CONS POS (DREVERSE VAL))))            ((SELCHARQ (NTHCHARCODE FILE POS)                  (/                              (* ;                                                   "unix and the `xerox standard' use / for delimiter")                     (SETQ TEM (LASTCHPOS (CHARCODE /)                                      FILE                                      (ADD1 POS))))                  ((< >)                          (* ;                "Interlisp-D and most other Xerox systems, and Tops-20/Tenex use <>.  Jericho uses >>")                       (SETQ TEM (LASTCHPOS (CHARCODE >)                                        FILE                                        (ADD1 POS))))                  NIL)             (%%UNPACKFILE1 'DIRECTORY (ADD1 POS)                    (SUB1 TEM)                    FILE PACKFLG ONEFIELDFLG VAL)             (SETQ POS (ADD1 TEM))             (SETQ HOSTP T)))         (OR (SETQ CODE (NTHCHARCODE FILE (SETQ TEM POS)))             (RETURN (CONS POS (DREVERSE VAL))))     NAMELP         (SELCHARQ CODE              ((%. ! ; NIL)                       (* ;                                           "NAME and SUBDIRECTORY fields definitely terminated by now")                   (COND                      ((AND (EQ CODE (CHARCODE %.))                            (NOT BEYONDNAME)                            (SETQ TEM2 (STRPOS "." FILE (ADD1 TEM)))                            (SETQ TEM2 (NTHCHAR FILE (ADD1 TEM2)))                            (NOT (FIXP TEM2)))    (* ;; "If there's another dot followed by something other than a numeric extension, then ignore this dot, since we'll get another chance")                       (GO NEXTCHAR)))                   (COND                      (SUBDIREND (%%UNPACKFILE1 'SUBDIRECTORY POS (SUB1 SUBDIREND)                                        FILE PACKFLG ONEFIELDFLG VAL)                             (SETQ POS (ADD1 SUBDIREND))                             (SETQ SUBDIREND)                             (COND                                ((AND (NULL CODE)                                      (EQ POS TEM))                                                  (* ;                                         "Nothing follows the subdirectory;  null name is NOT implied")                                 (RETURN (CONS POS (DREVERSE VAL)))))))                   (%%UNPACKFILE1 (COND                                     ((NOT BEYONDNAME)                                      (COND                                         ((NEQ CODE (CHARCODE %.))                                          (SETQQ BEYONDEXT ;)))                                      (SETQQ BEYONDNAME NAME))                                     ((NOT BEYONDEXT)                                      (SETQ BEYONDEXT (COND                                                         ((NEQ CODE (CHARCODE %.))                                                          ';)                                                         (T T)))                                      'TYPE)                                     (T (SELCHARQ (AND (EQ BEYONDEXT ';)                                                       (NTHCHARCODE FILE POS))                                             (P 'PROTECTION)                                             (A (add POS 1)                                                'ACCOUNT)                                             ((T S)                                                   'TEMPORARY)                                             'VERSION)))                          POS                          (SUB1 TEM)                          FILE PACKFLG ONEFIELDFLG VAL)                   (COND                      ((NULL CODE)                           (* ; "End of string")                       (RETURN (CONS POS (DREVERSE VAL)))))                   (SETQ POS (ADD1 TEM)))              (%'                                            (* ; "Quoter")                  (add TEM 1))              ((/ >)                                      (* ; "Subdirectory terminating character")                   (COND                      ((AND (NOT HOSTP)                            (NOT BEYONDNAME)                            DIRFLG)                       (* ; "Ok to treat this as a subdirectory")                       (SETQ SUBDIREND TEM))))              NIL)     NEXTCHAR         (SETQ CODE (NTHCHARCODE FILE (add TEM 1)))         (GO NAMELP)))(CL:DEFUN CL:TRUENAME (PATHNAME)                  (* ;;; "Return the pathname for the actual file described by the pathname.  An error is signaled if no such file exists.  PATHNAME can be a pathname, string, symbol, or stream.")   (if (AND (STREAMP PATHNAME)            (NOT (fetch (STREAM NAMEDP) of PATHNAME)))       then                                       (* ;          "let's catch this case, rather than have the message 'The file %"%" does not exist' appear.")            (CL:ERROR "The stream ~S has no corresponding named file." PATHNAME)     else (LET ((RESULT (CL:PROBE-FILE PATHNAME)))               (CL:UNLESS RESULT (CL:ERROR "The file ~S does not exist." (CL:NAMESTRING PATHNAME)))               RESULT)))(CL:DEFUN %%MAKE-PATHNAME (HOST DEVICE DIRECTORY NAME TYPE VERSION) (%%%%MAKE-PATHNAME :HOST HOST                                                                            :DEVICE DEVICE :DIRECTORY                                                                            DIRECTORY :NAME NAME :TYPE                                                                            TYPE :VERSION VERSION))(CL:DEFUN INTERLISP-NAMESTRING (PATHNAME)         (* ;;;                                           "Returns the full form of PATHNAME as an Interlisp string.")   (if (AND (STREAMP PATHNAME)            (NOT (fetch (STREAM NAMEDP) of PATHNAME)))       then (CL:RETURN-FROM INTERLISP-NAMESTRING ""))   (SETQ PATHNAME (PATHNAME PATHNAME))   (LET ((HOST (%%PATHNAME-HOST PATHNAME))         (DEVICE (%%PATHNAME-DEVICE PATHNAME))         (DIRECTORY (%%PATHNAME-DIRECTORY PATHNAME))         (NAME (%%PATHNAME-NAME PATHNAME))         (TYPE (%%PATHNAME-TYPE PATHNAME))         (VERSION (%%PATHNAME-VERSION PATHNAME))         (RESULT ""))        (DECLARE (CL:SIMPLE-STRING RESULT))        (CL:WHEN HOST (SETQ RESULT (CONCAT "{" (THE CL:SIMPLE-STRING HOST)                                          "}")))  (* ;; "device will have `:' on end because of PARSE-NAMESTRING1 silliness (it allows you to have a device called NIL)")        (CL:WHEN DEVICE (SETQ RESULT (CONCAT RESULT (THE CL:SIMPLE-STRING DEVICE))))        (CL:WHEN DIRECTORY (SETQ RESULT (CONCAT RESULT "<" (CL:IF (EQ DIRECTORY :WILD)                                                                  "*"                                                                  (THE CL:SIMPLE-STRING DIRECTORY))                                               ">")))        (CL:WHEN NAME (SETQ RESULT (CONCAT RESULT (CL:IF (EQ NAME :WILD)                                                         "*"                                                         (THE CL:SIMPLE-STRING NAME)))))        (CL:WHEN TYPE (SETQ RESULT (CONCAT RESULT "." (CL:IF (EQ TYPE :WILD)                                                             "*"                                                             (THE CL:SIMPLE-STRING TYPE)))))        (CL:WHEN VERSION (SETQ RESULT (CONCAT RESULT (CASE VERSION (:WILD ";*")                                                           (:NEWEST ";")                                                           (NIL "")                                                           (OTHERWISE (CONCAT ";" (CL:PRINC-TO-STRING                                                                                   VERSION)))))))        RESULT))(CL:DEFUN %%PATHNAME-EQUAL (PATHNAME1 PATHNAME2) (AND (CL:EQUAL (%%PATHNAME-HOST PATHNAME1)                                                             (%%PATHNAME-HOST PATHNAME2))                                                      (CL:EQUAL (%%PATHNAME-DEVICE PATHNAME1)                                                             (%%PATHNAME-DEVICE PATHNAME2))                                                      (CL:EQUAL (%%PATHNAME-DIRECTORY PATHNAME1)                                                             (%%PATHNAME-DIRECTORY PATHNAME2))                                                      (CL:EQUAL (%%PATHNAME-NAME PATHNAME1)                                                             (%%PATHNAME-NAME PATHNAME2))                                                      (CL:EQUAL (%%PATHNAME-TYPE PATHNAME1)                                                             (%%PATHNAME-TYPE PATHNAME2))                                                      (CL:EQUAL (%%PATHNAME-VERSION PATHNAME1)                                                             (%%PATHNAME-VERSION PATHNAME2))))(CL:DEFUN %%INITIALIZE-DEFAULT-PATHNAME NIL (DECLARE (GLOBALVARS *DEFAULT-PATHNAME-DEFAULTS*                                                             \CONNECTED.DIRECTORY))                                            (if (NOT (BOUNDP '\CONNECTED.DIRECTORY))                                                then (SETQ \CONNECTED.DIRECTORY '{DSK}))                                            (SETQ *DEFAULT-PATHNAME-DEFAULTS*                                             (CL:PARSE-NAMESTRING \CONNECTED.DIRECTORY                                                    (FILENAMEFIELD \CONNECTED.DIRECTORY 'HOST)))                                            (CL:SETF (%%PATHNAME-VERSION *DEFAULT-PATHNAME-DEFAULTS*)                                                   :NEWEST)                                            *DEFAULT-PATHNAME-DEFAULTS*)(DEFGLOBALVAR *DEFAULT-PATHNAME-DEFAULTS* )(* ;; "Interlisp-D compatibility")(CL:DEFUN UNPACKPATHNAME.STRING (FILE &OPTIONAL ONEFIELDFLG DIRFLG ATOMFLG)                                                   (* ;;                                          "Simulate the action of UNPACKFILENAME.STRING on a pathname")                                                             (* ;; "")   (DECLARE (IGNORE DIRFLG))   (if ONEFIELDFLG       then (AND (CL:CONSP ONEFIELDFLG)                 (SETQ ONEFIELDFLG (CAR (CL:INTERSECTION ONEFIELDFLG                                               '(HOST DEVICE DIRECTORY NAME EXTENSION VERSION)))))            (LET ((RESULT (CASE ONEFIELDFLG (HOST (CL:PATHNAME-HOST FILE))                                (DEVICE (CL:PATHNAME-DEVICE FILE))                                (DIRECTORY (CL:PATHNAME-DIRECTORY FILE))                                (NAME (CL:PATHNAME-NAME FILE))                                (EXTENSION (CL:PATHNAME-TYPE FILE))                                (VERSION (CL:PATHNAME-VERSION FILE))                                (OTHERWISE NIL))))                 (if ATOMFLG                     then (MKATOM RESULT)                   else RESULT))     else (LET ((COMPONENT))               (APPEND (if (SETQ COMPONENT (CL:PATHNAME-HOST FILE))                           then (LIST 'HOST (if ATOMFLG                                                then (MKATOM COMPONENT)                                              else COMPONENT)                                      COMPONENT))                      (if (SETQ COMPONENT (CL:PATHNAME-DEVICE FILE))                          then (LIST 'DEVICE (if ATOMFLG                                                 then (MKATOM COMPONENT)                                               else COMPONENT)))                      (if (SETQ COMPONENT (CL:PATHNAME-DIRECTORY FILE))                          then (LIST 'DIRECTORY (if ATOMFLG                                                    then (MKATOM COMPONENT)                                                  else COMPONENT)))                      (if (SETQ COMPONENT (CL:PATHNAME-NAME FILE))                          then (LIST 'NAME (if ATOMFLG                                               then (MKATOM COMPONENT)                                             else COMPONENT)))                      (if (SETQ COMPONENT (CL:PATHNAME-TYPE FILE))                          then (LIST 'EXTENSION (if ATOMFLG                                                    then (MKATOM COMPONENT)                                                  else COMPONENT)))                      (if (SETQ COMPONENT (CL:PATHNAME-VERSION FILE))                          then (LIST 'VERSION (if ATOMFLG                                                  then (MKATOM COMPONENT)                                                else (MKSTRING COMPONENT))))))))(CL:DEFUN CL:FILE-NAMESTRING (PATHNAME) (LET* ((PATH (PATHNAME PATHNAME))                                               (RESULT (CL:CONCATENATE 'CL:SIMPLE-STRING                                                              (%%COMPONENT-STRING (%%PATHNAME-NAME                                                                                   PATH))                                                              "."                                                              (%%COMPONENT-STRING (%%PATHNAME-TYPE                                                                                   PATH))))                                               (VERSION (%%PATHNAME-VERSION PATH)))                                              (CL:WHEN VERSION                                                     (SETQ RESULT                                                      (CL:CONCATENATE                                                       'CL:SIMPLE-STRING RESULT                                                       (CASE VERSION (:WILD ";*")                                                             (:NEWEST ";")                                                             (NIL "")                                                             (OTHERWISE (CL:CONCATENATE '                                                                               CL:SIMPLE-STRING ";"                                                                               (CL:PRINC-TO-STRING                                                                                VERSION)))))))                                              RESULT))(CL:DEFUN CL:DIRECTORY-NAMESTRING (PATHNAME)      (* ;;                                                 "Returns the directory part of PATHNAME as a string.")   (%%COMPONENT-STRING (%%PATHNAME-DIRECTORY (PATHNAME PATHNAME))))(DECLARE%: DONTEVAL@LOAD DOCOPY (%%INITIALIZE-DEFAULT-PATHNAME))(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA CL:ENOUGH-NAMESTRING CL:HOST-NAMESTRING FILE-NAME CL:MERGE-PATHNAMES PATHNAME                      CL:PATHNAME-VERSION CL:PATHNAME-TYPE CL:PATHNAME-NAME CL:PATHNAME-DIRECTORY                      CL:PATHNAME-DEVICE CL:PATHNAME-HOST CL:MAKE-PATHNAME %%PRINT-PATHNAME))(PUTPROPS CMLPATHNAME COPYRIGHT ("Xerox Corporation" 1986))(DECLARE%: DONTCOPY  (FILEMAP (NIL (3191 7185 (%%PRINT-PATHNAME 3201 . 3414) (CL:MAKE-PATHNAME 3416 . 5249) (CL:PATHNAME-HOST 5251 . 5733) (CL:PATHNAME-DEVICE 5735 . 6023) (CL:PATHNAME-DIRECTORY 6025 . 6325) (CL:PATHNAME-NAME 6327 . 6607) (CL:PATHNAME-TYPE 6609 . 6889) (CL:PATHNAME-VERSION 6891 . 7183)) (7186 13637 (PATHNAME 7196 . 7483) (CL:MERGE-PATHNAMES 7485 . 9031) (FILE-NAME 9033 . 9293) (CL:HOST-NAMESTRING 9295 . 9584) (CL:ENOUGH-NAMESTRING 9586 . 13228) (%%NUMERIC-STRING-P 13230 . 13635)))))STOP