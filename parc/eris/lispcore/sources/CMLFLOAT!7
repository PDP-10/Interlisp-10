(DEFINE-FILE-INFO §READTABLE "XCL" §PACKAGE "INTERLISP")(FILECREATED "21-Oct-86 01:01:55" {ERIS}<LISPCORE>SOURCES>CMLFLOAT.\;7 60045        |changes| |to:|  (VARS CMLFLOATCOMS)                       (FNS CL:LOG CL:ASIN CL:ACOS CL:SINH CL:COSH CL:TANH CL:EXP CL:SIN CL:COS                             CL:TAN)      |previous| |date:| "16-Sep-86 13:10:19" {ERIS}<LISPCORE>SOURCES>CMLFLOAT.\;3); Copyright (c) 1986 by Xerox Corporation.  All rights reserved.(PRETTYCOMPRINT CMLFLOATCOMS)(RPAQQ CMLFLOATCOMS        ((* |;;;| "CMLFLOAT -- Covering sections 12.5-12.5.3 irrational, transcendental, exponential, logarithmic, trigonometric, and hyperbolic functions.  Section 12.10, implementation parameters.  -- By Kelly Roach.  *"           )        (DECLARE\: EVAL@COMPILE DONTCOPY (FILES (LOADCOMP)                                                LLFLOAT))        (COMS (* |;;|  "Section 12.10, implementation parameters.  The constants in this COMS are exported to the user.  *"                 )              (* |;;| "%FLOAT allows us to recreate FLOATPs in a way that is independent of the ordinairy reading and printing FLOATPs to files which involves loss of the last couple bits of accuracy due to rounding effects.  *"                 )              (* |;;| "Using INITVARS instead of CONSTANTS in various places here because of problems with the way BYTECOMPILER stores FLOATPs in DCOM files.  References to Harris are actually probably references to Hart."                 )              (FNS %FLOAT)              (CONSTANTS (CL:MOST-POSITIVE-FIXNUM 65535)                     (CL:MOST-NEGATIVE-FIXNUM -65536))              (INITVARS (CL:MOST-POSITIVE-SINGLE-FLOAT (%FLOAT 32639 65535))                     (CL:LEAST-POSITIVE-SINGLE-FLOAT (%FLOAT 128 0))                     (CL:LEAST-NEGATIVE-SINGLE-FLOAT (%FLOAT 32896 0))                     (CL:MOST-NEGATIVE-SINGLE-FLOAT (%FLOAT 65407 65535))                     (CL:MOST-POSITIVE-SHORT-FLOAT CL:MOST-POSITIVE-SINGLE-FLOAT)                     (CL:LEAST-POSITIVE-SHORT-FLOAT CL:LEAST-POSITIVE-SINGLE-FLOAT)                     (CL:LEAST-NEGATIVE-SHORT-FLOAT CL:LEAST-NEGATIVE-SINGLE-FLOAT)                     (CL:MOST-NEGATIVE-SHORT-FLOAT CL:MOST-NEGATIVE-SINGLE-FLOAT)                     (CL:MOST-POSITIVE-DOUBLE-FLOAT CL:MOST-POSITIVE-SINGLE-FLOAT)                     (CL:LEAST-POSITIVE-DOUBLE-FLOAT CL:LEAST-POSITIVE-SINGLE-FLOAT)                     (CL:LEAST-NEGATIVE-DOUBLE-FLOAT CL:LEAST-NEGATIVE-SINGLE-FLOAT)                     (CL:MOST-NEGATIVE-DOUBLE-FLOAT CL:MOST-NEGATIVE-SINGLE-FLOAT)                     (CL:MOST-POSITIVE-LONG-FLOAT CL:MOST-POSITIVE-SINGLE-FLOAT)                     (CL:LEAST-POSITIVE-LONG-FLOAT CL:LEAST-POSITIVE-SINGLE-FLOAT)                     (CL:LEAST-NEGATIVE-LONG-FLOAT CL:LEAST-NEGATIVE-SINGLE-FLOAT)                     (CL:MOST-NEGATIVE-LONG-FLOAT CL:MOST-NEGATIVE-SINGLE-FLOAT))              (* |;;| "EPSILON is the smallest positive floating point number such that (NOT (= (FLOAT 1 EPSILON) (+ (FLOAT 1 EPSILON) EPSILON))) *"                 )              (INITVARS (CL:SINGLE-FLOAT-EPSILON (%FLOAT 13312 0))                     (CL:SHORT-FLOAT-EPSILON CL:SINGLE-FLOAT-EPSILON)                     (CL:DOUBLE-FLOAT-EPSILON CL:SINGLE-FLOAT-EPSILON)                     (CL:LONG-FLOAT-EPSILON CL:SINGLE-FLOAT-EPSILON))              (* |;;| "NEGATIVE-EPSILON is the smallest negative floating point number such that (NOT (= (FLOAT 1 NEGATIVE-EPSILON) (--- (FLOAT 1 NEGATIVE-EPSILON) NEGATIVE-EPSILON))) *"                 )              (INITVARS (CL:SINGLE-FLOAT-NEGATIVE-EPSILON (%FLOAT 13184 0))                     (CL:SHORT-FLOAT-NEGATIVE-EPSILON CL:SINGLE-FLOAT-NEGATIVE-EPSILON)                     (CL:DOUBLE-FLOAT-NEGATIVE-EPSILON CL:SINGLE-FLOAT-NEGATIVE-EPSILON)                     (CL:LONG-FLOAT-NEGATIVE-EPSILON CL:SINGLE-FLOAT-NEGATIVE-EPSILON)))        (COMS (* \; "Miscellaneous.  *")              (DECLARE\: EVAL@COMPILE DONTCOPY (FILES (LOADCOMP)                                                      LLFLOAT))              (INITVARS (CL:PI (%FLOAT 16457 4059)))              (* |;;| "Should be (DECLARE: EVAL@COMPILE DONTCOPY (CONSTANTS ...)) except that compiler does a poor job of compiling FLOATPs.  Use an INITVARS to patch around this situation for now.  *"                 )              (INITVARS (%E (%FLOAT 16429 63572))                     (%2PI (%FLOAT 16585 4059))                     (%PI (%FLOAT 16457 4059))                     (%2PI/3 (%FLOAT 16390 2706))                     (%PI/2 (%FLOAT 16329 4059))                     (%-PI/2 (%FLOAT 49097 4059))                     (%PI/3 (%FLOAT 16262 2706))                     (%PI/4 (%FLOAT 16201 4059))                     (%-PI/4 (%FLOAT 48969 4059))                     (%PI/6 (%FLOAT 16134 2706))                     (%2/PI (%FLOAT 16162 63875)))              (FNS %MAKE-ARRAY))        (COMS (* CL:EXP *)              (COMS (INITVARS (%LOG-BASE2-E (%FLOAT 16312 43579)))                    (* |;;| "%EXP-POLY contains P and Q coefficients of Harris et al EXPB 1103 rational approximation to (EXPT 2 X) in interval (0 .125).  %EXP-TABLE contains values of powers (EXPT 2 (/ N 8))  . *"                       )                    (VARS (%EXP-POLY (%MAKE-ARRAY (LIST (%FLOAT 15549 17659)                                                        (%FLOAT 16256 0)                                                        (%FLOAT 16801 38273)                                                        (%FLOAT 17257 7717)                                                        (%FLOAT 17597 11739)                                                        (%FLOAT 17800 30401))))                          (%EXP-TABLE (%MAKE-ARRAY (LIST (%FLOAT 16256 0)                                                         (%FLOAT 16267 38338)                                                         (%FLOAT 16280 14320)                                                         (%FLOAT 16293 65239)                                                         (%FLOAT 16309 1267)                                                         (%FLOAT 16325 26410)                                                         (%FLOAT 16343 17661)                                                         (%FLOAT 16362 49351))))))              (FNS CL:EXP %EXP-FLOAT %EXP-COMPLEX))        (COMS (* EXPT *)              (FNS CL:EXPT %EXPT-INTEGER %EXPT-FLOAT %EXPT-COMPLEX %EXPT-COMPLEX-POWER))        (COMS (* CL:LOG *)              (COMS (INITVARS (%LOG2 (%FLOAT 16177 29208))                           (%SQRT2 (%FLOAT 16309 1267)))                    (* |;;| "%LOG-PPOLY and %LOG-QPOLY contain P and Q coefficients of Harris et al LOGE 2707 rational approximation to (LOG X) in interval ((SQRT .5) (SQRT 2))  . *"                       )                    (VARS (%LOG-PPOLY (%MAKE-ARRAY (LIST (%FLOAT 16042 22803)                                                         (%FLOAT 49484 23590)                                                         (%FLOAT 17044 17982)                                                         (%FLOAT 49926 37153)                                                         (%FLOAT 17046 5367))))                          (%LOG-QPOLY (%MAKE-ARRAY (LIST (%FLOAT 16256 0)                                                         (%FLOAT 49512 9103)                                                         (%FLOAT 16992 42274)                                                         (%FLOAT 49823 38048)                                                         (%FLOAT 16918 5367))))))              (FNS CL:LOG %LOG-FLOAT %LOG-COMPLEX))        (COMS (* SQRT *)              (FNS CL:SQRT %SQRT-FLOAT %SQRT-COMPLEX))        (COMS (* SIN *)              (COMS (* |;;| "%SIN-EPSILON is sufficiently small that (SIN X) = X for X in interval (0 %SIN-EPSILON).  It suffices to take %SIN-EPSILON a little bit smaller than (SQRT (* 6 SINGLE-FLOAT-EPSILON)) which we get by the Taylor series expansion (SIN X) = (+ X (/ (EXPT X 3) 6) ...) (The relative error caused by ommitting (/ (EXPT X 3) 6) isn't observable.) Comparison against %SIN-EPSILON is used to avoid POLYEVAL microcode underflow when computing SIN.  *"                       )                    (INITVARS (%SIN-EPSILON (%FLOAT 14720 0)))                    (* |;;| "%SIN-PPOLY and %SIN-QPOLY contain adapted P and Q coefficients of Harris et al SIN 3374 rational approximation to (SIN X) in interval (0 (/ PI 2)).  The coefficients for %SIN-PPOLY and %SIN-QPOLY have been computed from Harris using extended precision routines and the relations %SIN-PPOLY = (REVERSE (for I from 0 as ENTRY in PS collect (/ (* (EXPT (/ 2 PI) (1+ (* 2 I))) ENTRY) Q0))) and %SIN-QPOLY = (REVERSE (for I from 0 as ENTRY in QS collect (/ (* (EXPT (/ 2 PI) (* 2 I)) ENTRY) Q0))) *"                       )                    (VARS (%SIN-PPOLY (%MAKE-ARRAY (LIST (%FLOAT 45236 25611)                                                         (%FLOAT 13589 26148)                                                         (%FLOAT 47286 34797)                                                         (%FLOAT 15295 3306)                                                         (%FLOAT 48666 34805)                                                         (%FLOAT 16256 0))))                          (%SIN-QPOLY (%MAKE-ARRAY (LIST (%FLOAT 11384 52865)                                                         (%FLOAT 12553 9550)                                                         (%FLOAT 13604 38385)                                                         (%FLOAT 14593 18841)                                                         (%FLOAT 15489 5549)                                                         (%FLOAT 16256 0))))))              (FNS CL:SIN %SIN-FLOAT %SIN-COMPLEX))        (COMS (* COS *)              (FNS CL:COS %COS-COMPLEX))        (COMS (* TAN *)              (COMS (* |;;| "%TAN-EPSILON is sufficiently small that (TAN X) = X for X in interval (0 %TAN-EPSILON).  It suffices to take %TAN-EPSILON a little bit smaller than (SQRT (* 3 SINGLE-FLOAT-EPSILON)) which we get by the Taylor series expansion (TAN X) = (+ X (/ (EXPT X 3) 3) ...) (The relative error caused by ommitting (/ (EXPT X 3) 3) isn't observable.) Comparison against %TAN-EPSILON is used to avoid POLYEVAL microcode underflow when computing TAN.  *"                       )                    (INITVARS (%TAN-EPSILON (%FLOAT 14720 0)))                    (* |;;| "%TAN-PPOLY and %TAN-QPOLY contain adapted P and Q coefficients of Harris et al TAN 4288 rational approximation to (TAN X) in interval (-PI/4 PI/4).  The coefficients for %TAN-PPOLY and %TAN-QPOLY have been computed from Harris using extended precision routines and the relations %TAN-PPOLY = (REVERSE (for I from 0 as ENTRY in PS collect (/ (* (EXPT (/ 4 PI) (1+ (* 2 I))) ENTRY) Q0))) and %TAN-QPOLY = (REVERSE (for I from 0 as ENTRY in QS collect (/ (* (EXPT (/ 4 PI) (* 2 I)) ENTRY) Q0))) *"                       )                    (VARS (%TAN-PPOLY (%MAKE-ARRAY (LIST (%FLOAT 13237 21090)                                                         (%FLOAT 47141 15825)                                                         (%FLOAT 15246 8785)                                                         (%FLOAT 48655 48761)                                                         (%FLOAT 16256 0))))                          (%TAN-QPOLY (%MAKE-ARRAY (LIST (%FLOAT 45267 36947)                                                         (%FLOAT 13848 46875)                                                         (%FLOAT 47612 53738)                                                         (%FLOAT 15596 52854)                                                         (%FLOAT 48882 35303)                                                         (%FLOAT 16256 0))))))              (FNS CL:TAN %TAN-FLOAT %TAN-COMPLEX))        (COMS (* CL:ASIN *)              (COMS (* |;;| "%ASIN-EPSILON is sufficiently small that (ASIN X) = X for X in interval (0 %ASIN-EPSILON).  It suffices to take %ASIN-EPSILON a little bit smaller than (* 2 SINGLE-FLOAT-EPSILON) which we get by the Taylor series expansion (ASIN X) = (+ X (/ (EXPT X 3) 6) ...) (The relative error caused by ommitting (/ (EXPT X 3) 6) isn't observable.) Comparison against %ASIN-EPSILON is used to avoid POLYEVAL microcode underflow when computing SIN.  *"                       )                    (INITVARS (%ASIN-EPSILON (%FLOAT 14720 0)))                    (* |;;| "%ASIN-PPOLY and %ASIN-QPOLY contain P and Q coefficients of Harris et al ARCSN 4671 rational approximation to (ASIN X) in interval (0 (SQRT .5))  . *"                       )                    (VARS (%ASIN-PPOLY (%MAKE-ARRAY (LIST (%FLOAT 16007 50045)                                                          (%FLOAT 49549 8020)                                                          (%FLOAT 17236 15848)                                                          (%FLOAT 50285 63464)                                                          (%FLOAT 17650 31235)                                                          (%FLOAT 50403 62852)                                                          (%FLOAT 17440 39471))))                          (%ASIN-QPOLY (%MAKE-ARRAY (LIST (%FLOAT 16256 0)                                                          (%FLOAT 49672 25817)                                                          (%FLOAT 17308 55260)                                                          (%FLOAT 50326 38098)                                                          (%FLOAT 17674 22210)                                                          (%FLOAT 50417 22451)                                                          (%FLOAT 17440 39471))))))              (FNS CL:ASIN %ASIN-FLOAT %ASIN-COMPLEX))        (COMS (* CL:ACOS *)              (FNS CL:ACOS %ACOS-COMPLEX))        (COMS (* ATAN *)              (INITVARS (%SQRT3 (%FLOAT 16349 46039))                     (%2-SQRT3 (%FLOAT 16009 12451))                     (%INV-2-SQRT3 (%FLOAT 16494 55788)))              (FNS CL:ATAN %ATAN-FLOAT1 %ATAN-FLOAT2 %ATAN-DOMAIN-CHECK %ATAN-FLOAT %ATAN-COMPLEX))        (COMS (* CL:CIS *)              (FNS CL:CIS))        (COMS (* CL:SINH CL:COSH CL:TANH *)              (FNS CL:SINH CL:COSH CL:TANH))        (COMS (* CL:ASINH CL:ACOSH CL:ATANH *)              (FNS CL:ASINH CL:ACOSH CL:ATANH %ATANH-DOMAIN-CHECK))        (PROP FILETYPE CMLFLOAT)        (DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS               (ADDVARS (NLAMA)                      (NLAML)                      (LAMA %ATANH-DOMAIN-CHECK CL:ATANH CL:ACOSH CL:ASINH CL:TANH CL:COSH CL:SINH                             CL:CIS %ATAN-COMPLEX %ATAN-FLOAT %ATAN-DOMAIN-CHECK %ATAN-FLOAT2                             %ATAN-FLOAT1 CL:ATAN %ACOS-COMPLEX CL:ACOS %ASIN-COMPLEX CL:ASIN                             %TAN-COMPLEX CL:TAN %COS-COMPLEX CL:COS %SIN-COMPLEX CL:SIN CL:SQRT                             %LOG-COMPLEX CL:LOG %EXPT-COMPLEX-POWER %EXPT-COMPLEX %EXPT-INTEGER                             CL:EXPT %EXP-COMPLEX %EXP-FLOAT CL:EXP)))))(* |;;;| "CMLFLOAT -- Covering sections 12.5-12.5.3 irrational, transcendental, exponential, logarithmic, trigonometric, and hyperbolic functions.  Section 12.10, implementation parameters.  -- By Kelly Roach.  *")(DECLARE\: EVAL@COMPILE DONTCOPY (FILESLOAD (LOADCOMP)       LLFLOAT))(* |;;| "Section 12.10, implementation parameters.  The constants in this COMS are exported to the user.  *")(* |;;| "%FLOAT allows us to recreate FLOATPs in a way that is independent of the ordinairy reading and printing FLOATPs to files which involves loss of the last couple bits of accuracy due to rounding effects.  *")(* |;;| "Using INITVARS instead of CONSTANTS in various places here because of problems with the way BYTECOMPILER stores FLOATPs in DCOM files.  References to Harris are actually probably references to Hart.")(DEFINEQ(%FLOAT  (LAMBDA (HIWORD LOWORD)                                    (* |kbr:| "14-May-86 16:43")    (\\FLOATBOX (\\VAG2 HIWORD LOWORD)))))(DECLARE\: EVAL@COMPILE (RPAQQ CL:MOST-POSITIVE-FIXNUM 65535)(RPAQQ CL:MOST-NEGATIVE-FIXNUM -65536)(CONSTANTS (CL:MOST-POSITIVE-FIXNUM 65535)       (CL:MOST-NEGATIVE-FIXNUM -65536)))(RPAQ? CL:MOST-POSITIVE-SINGLE-FLOAT (%FLOAT 32639 65535))(RPAQ? CL:LEAST-POSITIVE-SINGLE-FLOAT (%FLOAT 128 0))(RPAQ? CL:LEAST-NEGATIVE-SINGLE-FLOAT (%FLOAT 32896 0))(RPAQ? CL:MOST-NEGATIVE-SINGLE-FLOAT (%FLOAT 65407 65535))(RPAQ? CL:MOST-POSITIVE-SHORT-FLOAT CL:MOST-POSITIVE-SINGLE-FLOAT)(RPAQ? CL:LEAST-POSITIVE-SHORT-FLOAT CL:LEAST-POSITIVE-SINGLE-FLOAT)(RPAQ? CL:LEAST-NEGATIVE-SHORT-FLOAT CL:LEAST-NEGATIVE-SINGLE-FLOAT)(RPAQ? CL:MOST-NEGATIVE-SHORT-FLOAT CL:MOST-NEGATIVE-SINGLE-FLOAT)(RPAQ? CL:MOST-POSITIVE-DOUBLE-FLOAT CL:MOST-POSITIVE-SINGLE-FLOAT)(RPAQ? CL:LEAST-POSITIVE-DOUBLE-FLOAT CL:LEAST-POSITIVE-SINGLE-FLOAT)(RPAQ? CL:LEAST-NEGATIVE-DOUBLE-FLOAT CL:LEAST-NEGATIVE-SINGLE-FLOAT)(RPAQ? CL:MOST-NEGATIVE-DOUBLE-FLOAT CL:MOST-NEGATIVE-SINGLE-FLOAT)(RPAQ? CL:MOST-POSITIVE-LONG-FLOAT CL:MOST-POSITIVE-SINGLE-FLOAT)(RPAQ? CL:LEAST-POSITIVE-LONG-FLOAT CL:LEAST-POSITIVE-SINGLE-FLOAT)(RPAQ? CL:LEAST-NEGATIVE-LONG-FLOAT CL:LEAST-NEGATIVE-SINGLE-FLOAT)(RPAQ? CL:MOST-NEGATIVE-LONG-FLOAT CL:MOST-NEGATIVE-SINGLE-FLOAT)(* |;;| "EPSILON is the smallest positive floating point number such that (NOT (= (FLOAT 1 EPSILON) (+ (FLOAT 1 EPSILON) EPSILON))) *")(RPAQ? CL:SINGLE-FLOAT-EPSILON (%FLOAT 13312 0))(RPAQ? CL:SHORT-FLOAT-EPSILON CL:SINGLE-FLOAT-EPSILON)(RPAQ? CL:DOUBLE-FLOAT-EPSILON CL:SINGLE-FLOAT-EPSILON)(RPAQ? CL:LONG-FLOAT-EPSILON CL:SINGLE-FLOAT-EPSILON)(* |;;| "NEGATIVE-EPSILON is the smallest negative floating point number such that (NOT (= (FLOAT 1 NEGATIVE-EPSILON) (--- (FLOAT 1 NEGATIVE-EPSILON) NEGATIVE-EPSILON))) *")(RPAQ? CL:SINGLE-FLOAT-NEGATIVE-EPSILON (%FLOAT 13184 0))(RPAQ? CL:SHORT-FLOAT-NEGATIVE-EPSILON CL:SINGLE-FLOAT-NEGATIVE-EPSILON)(RPAQ? CL:DOUBLE-FLOAT-NEGATIVE-EPSILON CL:SINGLE-FLOAT-NEGATIVE-EPSILON)(RPAQ? CL:LONG-FLOAT-NEGATIVE-EPSILON CL:SINGLE-FLOAT-NEGATIVE-EPSILON)(* \; "Miscellaneous.  *")(DECLARE\: EVAL@COMPILE DONTCOPY (FILESLOAD (LOADCOMP)       LLFLOAT))(RPAQ? CL:PI (%FLOAT 16457 4059))(* |;;| "Should be (DECLARE: EVAL@COMPILE DONTCOPY (CONSTANTS ...)) except that compiler does a poor job of compiling FLOATPs.  Use an INITVARS to patch around this situation for now.  *")(RPAQ? %E (%FLOAT 16429 63572))(RPAQ? %2PI (%FLOAT 16585 4059))(RPAQ? %PI (%FLOAT 16457 4059))(RPAQ? %2PI/3 (%FLOAT 16390 2706))(RPAQ? %PI/2 (%FLOAT 16329 4059))(RPAQ? %-PI/2 (%FLOAT 49097 4059))(RPAQ? %PI/3 (%FLOAT 16262 2706))(RPAQ? %PI/4 (%FLOAT 16201 4059))(RPAQ? %-PI/4 (%FLOAT 48969 4059))(RPAQ? %PI/6 (%FLOAT 16134 2706))(RPAQ? %2/PI (%FLOAT 16162 63875))(DEFINEQ(%MAKE-ARRAY  (LAMBDA (LIST)                                             (* |kbr:| "15-May-86 18:09")                    (* |Function| |to| |build| |Interlisp| |arrays.|          I |would| |prefer| |to| |build| |Common| |Lisp| |arrays,| |but| I |don't|           |think| POLYEVAL |opcode| |will| |understand| |them.|          *)    (PROG (ARRAY)          (SETQ ARRAY (ARRAY (LENGTH LIST)                             'FLOATP 0.0 0))          (|for| ELEMENT |in| LIST |as| I |from| 0 |do| (SETA ARRAY I ELEMENT))          (RETURN ARRAY)))))(* CL:EXP *)(RPAQ? %LOG-BASE2-E (%FLOAT 16312 43579))(* |;;| "%EXP-POLY contains P and Q coefficients of Harris et al EXPB 1103 rational approximation to (EXPT 2 X) in interval (0 .125).  %EXP-TABLE contains values of powers (EXPT 2 (/ N 8))  . *")(RPAQ %EXP-POLY (%MAKE-ARRAY (LIST (%FLOAT 15549 17659)                                   (%FLOAT 16256 0)                                   (%FLOAT 16801 38273)                                   (%FLOAT 17257 7717)                                   (%FLOAT 17597 11739)                                   (%FLOAT 17800 30401))))(RPAQ %EXP-TABLE (%MAKE-ARRAY (LIST (%FLOAT 16256 0)                                    (%FLOAT 16267 38338)                                    (%FLOAT 16280 14320)                                    (%FLOAT 16293 65239)                                    (%FLOAT 16309 1267)                                    (%FLOAT 16325 26410)                                    (%FLOAT 16343 17661)                                    (%FLOAT 16362 49351))))(DEFINEQ(CL:EXP  (CL:LAMBDA (NUMBER)                                        (* FS "20-Oct-86 23:17")                                                  (* |;;|                      "Calculates e to the given power, where e is the base of natural logarithms.  *")         (CTYPECASE NUMBER (COMPLEX (%EXP-COMPLEX NUMBER))                (CL:NUMBER (%EXP-FLOAT (FLOAT NUMBER))))))(%EXP-FLOAT  (CL:LAMBDA (X)                                             (* |kbr:| "23-Jul-86 13:45")                    (* * (EXP X) |for| |float| X |calculated| |via| EXPB 1103 |rational|           |approximation| |of| |Harris| |et| |al.|          *)         (PROG (RECIPFLG M N R ANSWER)               (DECLARE (GLOBALVARS %EXP-TABLE %EXP-POLY))                    (* * |First,| |arrange| X |to| |be| |in| |interval|          (0 |infinity|) |via| |identity| (EXP (|minus| X)) =          (/ (EXP X)) *)               (SETQ R X)               (COND                  ((< R 0)                   (SETQ R (- R))                   (SETQ RECIPFLG T)))                    (* * |Next,| |the| |problem| |of| (EXP X) |is| |converted| |into| \a |problem|          (EXPT 2 Y) |where| Y = (CL:* %LOG-BASE2-E X)\.          |Then| |range| |reduction| |is| |accomplished| |via|          (EXPT 2 Y) = (CL:* (EXPT 2 M) (EXPT 2 (/ N 8))          (EXPT 2 R)) |where| M |and| N |are| |integers| |and| R |is| \a |float| |in|           |the| |interval| (0.0 .125) |After| M N R |are| |determined,|          (EXPT 2 M) |is| |effected| |by| |scaling,|          (EXPT 2 (/ N 8)) |is| |found| |by| |table| |lookup,| |and|          (EXPT 2 R) |is| |calculated| |by| |rational| |approximation| EXPB 1103 |of|           |Harris| |et| |al.| *)               (CL:MULTIPLE-VALUE-SETQ (M R)                      (CL:TRUNCATE (CL:* %LOG-BASE2-E R)))               (CL:MULTIPLE-VALUE-SETQ (N R)                      (CL:TRUNCATE R .125))               (SETQ ANSWER (CL:SCALE-FLOAT (CL:* (ELT %EXP-TABLE N)                                                  (/ (POLYEVAL R %EXP-POLY 5)                                                     (POLYEVAL (- R)                                                            %EXP-POLY 5)))                                   M))               (COND                  (RECIPFLG (SETQ ANSWER (/ ANSWER))))               (RETURN ANSWER))))(%EXP-COMPLEX  (CL:LAMBDA (Z)                    (* |compute| |exp| (\z) |where| \z |is| |complex| |is| |called| |by| |exp| *)         (LET* ((X (CL:REALPART Z))                (Y (CL:IMAGPART Z)))               (CL:* (EXP X)                     (CL:CIS Y))))))(* EXPT *)(DEFINEQ(CL:EXPT  (CL:LAMBDA (BASE-NUMBER POWER-NUMBER)                      (* |lmm| "27-Jun-86 22:52")                    (* |This| |function| |calculates| BASE-NUMBER |raised| |to| |the| |nth|           |power.| I\t |separates| |the| |cases| |by| |the| |type| |of| POWER-NUMBER           |for| |efficiency| |reasons,| |as| |powers| |can| |be| |calculated| |more|           |efficiently| |if| POWER-NUMBER |is| \a |positive| |integer,| |Therefore,|           |All| |integer| |values| |of| POWER-NUMBER |are| |calculated| |as| |positive|           |integers,| |and| |inverted| |if| |negative.|          *)         (COND            ((AND (CL:RATIONALP BASE-NUMBER)                  (CL:INTEGERP POWER-NUMBER))             (%EXPT-INTEGER BASE-NUMBER POWER-NUMBER))            ((= BASE-NUMBER 0)             (CL:IF (CL:PLUSP POWER-NUMBER)                    BASE-NUMBER                    (CL:ERROR "~A to a non-positive power ~A." BASE-NUMBER POWER-NUMBER)))            ((AND (CL:COMPLEXP BASE-NUMBER)                  (CL:INTEGERP POWER-NUMBER))             (%EXPT-INTEGER BASE-NUMBER POWER-NUMBER))            ((CL:COMPLEXP POWER-NUMBER)             (CL:IF (OR (CL:COMPLEXP BASE-NUMBER)                        (CL:PLUSP BASE-NUMBER))                    (%EXPT-COMPLEX-POWER BASE-NUMBER POWER-NUMBER)                    (CL:ERROR "~A negative number to a complex power ~A." BASE-NUMBER POWER-NUMBER)))            ((CL:COMPLEXP BASE-NUMBER)             (%EXPT-COMPLEX BASE-NUMBER POWER-NUMBER))            ((AND (NOT (CL:INTEGERP POWER-NUMBER))                  (MINUSP BASE-NUMBER))             (CL:ERROR "Negative number ~A to non-integral power ~A." BASE-NUMBER POWER-NUMBER))            (T (%EXPT-FLOAT (FLOAT BASE-NUMBER)                      (FLOAT POWER-NUMBER))))))(%EXPT-INTEGER  (CL:LAMBDA (BASE POWER)                                    (* |kbr:| "16-Sep-86 13:03")                    (* * (EXPT BASE POWER) |where| BASE |is| |rational| |and| POWER |is| |an|           |integer.| *)         (COND            ((EQ BASE MIN.INTEGER)             (COND                ((CL:INTEGERP POWER)                 (COND                    ((< POWER 0)                     0)                    ((EQ POWER 0)                     1)                    ((EQ POWER MAX.INTEGER)                     (ERROR "Can't raise negative infinity to infinite power."))                    ((EVENP POWER)                     MAX.INTEGER)                    (T                                       (* |Odd| |integer| POWER *)                       MIN.INTEGER)))                (T                                           (* POWER |is| \a |noninteger|                                                              |rational| *)                   (ERROR "Can't raise negative infinity to noninteger power."))))            ((EQ BASE MAX.INTEGER)             (COND                ((EQ POWER 0)                 1)                (T MAX.INTEGER)))            ((EQ POWER MIN.INTEGER)             (COND                ((EQ BASE 0)                 (ERROR "Can't expt 0 to a negative power."))                (T 0)))            ((EQ POWER MAX.INTEGER)             (COND                ((EQ BASE 0)                 0)                ((> BASE 0)                 MAX.INTEGER)                (T                     (* |Undefined| |because| |sign| |oscillates| |as| |you| |take| |the| |limit.|          *)                   (ERROR "Can't expt negative number to infinite power."))))            ((MINUSP POWER)             (/ (%EXPT-INTEGER BASE (- POWER))))            ((AND (CL:RATIONALP BASE)                  (NOT (CL:INTEGERP BASE)))             (%MAKE-RATIO (%EXPT-INTEGER (CL:NUMERATOR BASE)                                 POWER)                    (%EXPT-INTEGER (CL:DENOMINATOR BASE)                           POWER)))            ((AND (CL:INTEGERP BASE)                  (= BASE 2))             (CL:ASH 1 POWER))            (T (CL:DO ((NEXTN (CL:ASH POWER -1)                              (CL:ASH POWER -1))                       (TOTAL (CL:IF (ODDP POWER)                                     BASE 1)                              (CL:IF (ODDP POWER)                                     (CL:* BASE TOTAL)                                     TOTAL)))                      ((ZEROP NEXTN)                       TOTAL)                      (SETQ BASE (CL:* BASE BASE))                      (SETQ POWER NEXTN))))))(%EXPT-FLOAT  (LAMBDA (X Y)                                              (* |kbr:| "29-May-86 00:03")                    (* * (EXPT X Y) |where| X |is| \a |nonnegative| |float| |and| Y |is| \a           |float.| *)    (COND       ((= X 0.0)        0.0)       (T (EXP (CL:* Y (CL:LOG X)))))))(%EXPT-COMPLEX  (CL:LAMBDA (Z N)                    (* |compute| (|complex|) ^\n |where| \n |is| |an| |integer| |some| |round-off|           |error| |if| \n |is| |not| \a |fixnum| *)         (CL:* (CL:EXPT (%COMPLEX-ABS Z)                      N)               (CL:CIS (CL:* N (CL:PHASE Z))))))(%EXPT-COMPLEX-POWER  (CL:LAMBDA (Z W)                    (* |this| |function| |computes| \z ^ \w |where| \w |is| \a |complex| |number|           |it| |can| |also| |be| |used| |for| |any| |positive| |real| |number.|          *)         (EXP (CL:* W (CL:LOG Z))))))(* CL:LOG *)(RPAQ? %LOG2 (%FLOAT 16177 29208))(RPAQ? %SQRT2 (%FLOAT 16309 1267))(* |;;| "%LOG-PPOLY and %LOG-QPOLY contain P and Q coefficients of Harris et al LOGE 2707 rational approximation to (LOG X) in interval ((SQRT .5) (SQRT 2))  . *")(RPAQ %LOG-PPOLY (%MAKE-ARRAY (LIST (%FLOAT 16042 22803)                                    (%FLOAT 49484 23590)                                    (%FLOAT 17044 17982)                                    (%FLOAT 49926 37153)                                    (%FLOAT 17046 5367))))(RPAQ %LOG-QPOLY (%MAKE-ARRAY (LIST (%FLOAT 16256 0)                                    (%FLOAT 49512 9103)                                    (%FLOAT 16992 42274)                                    (%FLOAT 49823 38048)                                    (%FLOAT 16918 5367))))(DEFINEQ(CL:LOG  (CL:LAMBDA (NUMBER &OPTIONAL (BASE NIL BASE-SUPPLIED))     (* FS "21-Oct-86 00:48")         (COND            (BASE-SUPPLIED (/ (CL:LOG NUMBER)                              (CL:LOG BASE)))            (T (CTYPECASE NUMBER (COMPLEX (%LOG-COMPLEX NUMBER))                      (CL:NUMBER (CL:IF (MINUSP NUMBER)                                        (COMPLEX (%LOG-FLOAT (FLOAT (- NUMBER)))                                               %PI)                                        (%LOG-FLOAT (FLOAT NUMBER)))))))))(%LOG-FLOAT  (LAMBDA (X)                                                (* |kbr:| "30-May-86 00:04")                    (* * (EXP X) |for| |float| X |calculated| |via| EXPB 1103 |rational|           |approximation| |of| |Harris| |et| |al.|          *)                    (* * (LOG X) |for| |nonnegative| |float| X.          *)    (PROG (R EXP Z Z2 ANSWER)          (DECLARE (GLOBALVARS %LOG-PPOLY %LOG-QPOLY))                    (* * NOTE\: |Probably| |best| |not| |to| |declare| |type| |of| |variables|           |inside| |this| |routine| |for| |now.| |I've| |found| |that| FLOATP |smashing|           |combined| |with| FLOATP |declarations| |compiles| |wrong.|          *)          (COND             ((NOT (FGREATERP X 0.0))              (ERROR "LOG OF ZERO:" X)))                    (* * |Range| |reduce| |to| |an| R |in| |interval|          ((SQRT .5) (SQRT 2)) |via| |identity| (LOG X) =          (+ (LOG R) (CL:* %LOG-2 EXP)) |for| \a |suitable| |integer| EXP.          |This| |reduction| |depends| |on| |and| |smashes| |the| FLOATP |representation|           |of| R. *)          (SETQ R (\\FLOAT.BOX X))          (SETQ EXP (- (|fetch| (FLOATP EXPONENT) |of| R)                       \\EXPONENT.BIAS))          (|replace| (FLOATP EXPONENT) |of| R |with| \\EXPONENT.BIAS)          (COND             ((> R %SQRT2)              (SETQ EXP (CL:1+ EXP))              (SETQ R (/ R 2.0))))                    (* * (LOG R) |is| |calculated| |by| |rational| |approximation| LOGE 2707 |of|           |Harris| |et| |al.| *)          (SETQ Z (/ (CL:1- R)                     (CL:1+ R)))          (SETQ Z2 (CL:* Z Z))          (SETQ ANSWER (+ (CL:* Z (/ (POLYEVAL Z2 %LOG-PPOLY 4)                                     (POLYEVAL Z2 %LOG-QPOLY 4)))                          (CL:* %LOG2 EXP)))          (RETURN ANSWER))))(%LOG-COMPLEX  (CL:LAMBDA (Z)                                             (* |natural| |log| |of| \a |complex|                                                              |number| *)         (COMPLEX (CL:LOG (%COMPLEX-ABS Z))                (CL:PHASE Z)))))(* SQRT *)(DEFINEQ(CL:SQRT  (CL:LAMBDA (X)                                             (* |kbr:| "28-Jul-86 14:06")         (COND            ((CL:COMPLEXP X)             (%SQRT-COMPLEX X))            ((MINUSP X)                                      (* |Negative| |real| |axis| |maps|                                                              |into| |positive| |imaginary| |axis.|                                                             *)             (COMPLEX 0 (CL:SQRT (- X))))            (T (%SQRT-FLOAT (FLOAT X))))))(%SQRT-FLOAT  (LAMBDA (X)                                                (* |kbr:| "21-Jul-86 16:38")                    (* * (SQRT X) |for| |nonnegative| |float| X.          *)    (PROG (V)          (DECLARE (TYPE FLOATP X V))          (COND             ((NOT (FGREATERP X 0.0))                        (* |Trichotomy| ==> X = 0.0 *)              (RETURN 0.0)))          (SETQ V (|create| FLOATP                         EXPONENT _ (LOGAND (IPLUS \\EXPONENT.BIAS                                                   (LRSH (LOGAND (IDIFFERENCE (|fetch| (FLOATP EXP)                                                                                 |of| X)                                                                        \\EXPONENT.BIAS)                                                                (MASK.1\'S 0 BITSPERWORD))                                                         1))                                           \\MAX.EXPONENT)                         HIFRACTION _ (|fetch| (FLOATP HIFRAC) |of| X)))                    (* |Exponent| |is| |stored| |as| |excess| \\EXPONENT.BIAS |and| |although|           |the| LRSH |doesn't| |really| |do| |division| |by| 2          (|e.g.,| |when| |the| |arg| |is| |negative|) |at| |least| |the| |low-order| 8           |bits| |will| |be| |right.| I\t |doesn't| |even| |matter| |that| |it| |may|           |be| |off-by-one,| |due| |to| |the| |infamous| "Arithmetic Shifting Considered Harmful"           |since| |it| |is| |only| |an| |estimate.|          *)          (FRPTQ 4 (SETQ V (CL:* .5 (+ V (/ X V)))))          (RETURN V))))(%SQRT-COMPLEX  (LAMBDA (X)                                                (* |kbr:| "28-Jul-86 14:04")                    (* * (SQRT X) |for| |complex| X. *)    (PROG (ABS CL:PHASE A B C D E ANSWER)          (DECLARE (TYPE FLOATP ABS CL:PHASE A B C D E))          (SETQ A (FLOAT (CL:REALPART X)))          (SETQ B (FLOAT (CL:IMAGPART X)))                    (* * |Make| |initial| |guess.| *)          (SETQ ABS (CL:SQRT (ABS X)))          (SETQ CL:PHASE (/ (CL:PHASE X)                            2.0))          (SETQ C (CL:* ABS (CL:COS CL:PHASE)))          (SETQ D (CL:* ABS (CL:SIN CL:PHASE)))                    (* * |Newton's| |method.| *)          (|for| I |from| 1 |to| 4 |do| (SETQ E (+ (CL:* C C)                                                   (CL:* D D)))                                        (SETQ C (CL:* .5 (+ C (/ (+ (CL:* A C)                                                                    (CL:* B D))                                                                 E))))                                        (SETQ D (CL:* .5 (+ D (/ (- (CL:* B C)                                                                    (CL:* A D))                                                                 E)))))          (SETQ ANSWER (COMPLEX C D))          (RETURN ANSWER)))))(* SIN *)(* |;;| "%SIN-EPSILON is sufficiently small that (SIN X) = X for X in interval (0 %SIN-EPSILON).  It suffices to take %SIN-EPSILON a little bit smaller than (SQRT (* 6 SINGLE-FLOAT-EPSILON)) which we get by the Taylor series expansion (SIN X) = (+ X (/ (EXPT X 3) 6) ...) (The relative error caused by ommitting (/ (EXPT X 3) 6) isn't observable.) Comparison against %SIN-EPSILON is used to avoid POLYEVAL microcode underflow when computing SIN.  *")(RPAQ? %SIN-EPSILON (%FLOAT 14720 0))(* |;;| "%SIN-PPOLY and %SIN-QPOLY contain adapted P and Q coefficients of Harris et al SIN 3374 rational approximation to (SIN X) in interval (0 (/ PI 2)).  The coefficients for %SIN-PPOLY and %SIN-QPOLY have been computed from Harris using extended precision routines and the relations %SIN-PPOLY = (REVERSE (for I from 0 as ENTRY in PS collect (/ (* (EXPT (/ 2 PI) (1+ (* 2 I))) ENTRY) Q0))) and %SIN-QPOLY = (REVERSE (for I from 0 as ENTRY in QS collect (/ (* (EXPT (/ 2 PI) (* 2 I)) ENTRY) Q0))) *")(RPAQ %SIN-PPOLY (%MAKE-ARRAY (LIST (%FLOAT 45236 25611)                                    (%FLOAT 13589 26148)                                    (%FLOAT 47286 34797)                                    (%FLOAT 15295 3306)                                    (%FLOAT 48666 34805)                                    (%FLOAT 16256 0))))(RPAQ %SIN-QPOLY (%MAKE-ARRAY (LIST (%FLOAT 11384 52865)                                    (%FLOAT 12553 9550)                                    (%FLOAT 13604 38385)                                    (%FLOAT 14593 18841)                                    (%FLOAT 15489 5549)                                    (%FLOAT 16256 0))))(DEFINEQ(CL:SIN  (CL:LAMBDA (RADIANS)                                       (* FS "20-Oct-86 23:37")         (CTYPECASE RADIANS (COMPLEX (%SIN-COMPLEX RADIANS))                (FLOAT (%SIN-FLOAT RADIANS NIL))                (CL:NUMBER (%SIN-FLOAT (FLOAT RADIANS)                                  NIL)))))(%SIN-FLOAT  (LAMBDA (X COS-FLAG)                                       (* |kbr:| "23-Jul-86 15:53")                    (* * SIN |of| \a FLOAT X |calculated| |via| SIN 3374 |rational| |approximation|           |of| |Harris| |et| |al.| *)    (PROG (R SIGN R2 ANSWER)          (DECLARE (GLOBALVARS %SIN-PPOLY %SIN-QPOLY)                 (TYPE FLOATP X R SIGN R2 ANSWER))                    (* * I\f |this| |function| |called| |by| COS |then| |use|          (COS X) = (SIN (|minus| %PI/2 X)) = (SIN          (+ %PI/2 X)) |Case| |out| |on| |sign| |of| X |for| |improved| |numerical|           |stability.| |Avoids| |unnecessary| |rounding| |and| |promotes| |symmetric|           |properties.| (COS X) = (COS (|minus| X)) |is| |guaranteed| |by| |this|           |strategy.| *)          (SETQ R (COND                     ((NOT COS-FLAG)                      X)                     ((> X 0)                      (- %PI/2 X))                     (T (+ %PI/2 X))))                    (* * |First| |range| |reduce| |to| (0 |infinity|) |by|          (SIN (|minus| X)) = (|minus| (SIN X)) |This| |strategy| |guarantees|          (SIN (|minus| X)) = (|minus| (SIN X)) *)          (COND             ((< R 0)              (SETQ SIGN -1.0)              (SETQ R (- R)))             (T (SETQ SIGN 1.0)))                    (* * |Next| |range| |reduce| |to| |interval|          (0 %2PI) |by| (SIN X) = (SIN (MOD X %2PI)) . *)          (SETQ R (CL:REM R %2PI))                    (* * |Next| |range| |reduce| |to| |interval|          (0 CL:PI) |by| (SIN (+ X CL:PI)) = (|minus|          (SIN X)) *)          (COND             ((> R %PI)              (SETQ SIGN (- SIGN))              (SETQ R (- R %PI))))                    (* * |Next| |range| |reduce| |to| |interval|          (0 %PI/2) |by| (SIN (+ X %PI/2)) = (SIN (|minus| %PI/2 X)) *)          (COND             ((> R %PI/2)              (SETQ R (- %PI R))))          (COND             ((< R %SIN-EPSILON)                    (* * I\f R |is| |in| |the| |interval| (0 %SIN-EPSILON) |then|          (SIN R) = R |to| |the| |precision| |that| |we| |can| |offer.|          |Return| R |because| (1) |it| |is| |desirable| |that|          (SIN R) = R |exactly| |for| |small| R |and|          (2) |microcode| POLYEVAL |will| |underflow| |on| |sufficiently| |small|           |positive| R. *)              (RETURN (CL:* SIGN R))))                    (* * |Now| |use| SIN 3374 |rational| |approximation| |of| |Harris| |et| |al.|          |which| |works| |on| |interval| (0 %PI/2) *)          (SETQ R2 (CL:* R R))          (SETQ ANSWER (CL:* SIGN R (/ (POLYEVAL R2 %SIN-PPOLY 5)                                       (POLYEVAL R2 %SIN-QPOLY 5))))          (RETURN ANSWER))))(%SIN-COMPLEX  (CL:LAMBDA (Z)                                             (* |sin| |of| \a |complex| |number| *)         (LET* ((X (CL:REALPART Z))                (Y (CL:IMAGPART Z)))               (COMPLEX (CL:* (CL:SIN X)                              (CL:COSH Y))                      (CL:* (CL:COS X)                            (CL:SINH Y)))))))(* COS *)(DEFINEQ(CL:COS  (CL:LAMBDA (RADIANS)                                       (* FS "20-Oct-86 23:37")         (CTYPECASE RADIANS (FLOAT (%SIN-FLOAT RADIANS T))                (COMPLEX (%COS-COMPLEX RADIANS))                (CL:NUMBER (%SIN-FLOAT (FLOAT RADIANS)                                  T)))))(%COS-COMPLEX  (CL:LAMBDA (Z)                                             (* |cosine| |of| \a |complex| |number|                                                              *)         (LET* ((X (CL:REALPART Z))                (Y (CL:IMAGPART Z)))               (COMPLEX (CL:* (CL:COS X)                              (CL:COSH Y))                      (- (CL:* (CL:SIN X)                               (CL:SINH Y))))))))(* TAN *)(* |;;| "%TAN-EPSILON is sufficiently small that (TAN X) = X for X in interval (0 %TAN-EPSILON).  It suffices to take %TAN-EPSILON a little bit smaller than (SQRT (* 3 SINGLE-FLOAT-EPSILON)) which we get by the Taylor series expansion (TAN X) = (+ X (/ (EXPT X 3) 3) ...) (The relative error caused by ommitting (/ (EXPT X 3) 3) isn't observable.) Comparison against %TAN-EPSILON is used to avoid POLYEVAL microcode underflow when computing TAN.  *")(RPAQ? %TAN-EPSILON (%FLOAT 14720 0))(* |;;| "%TAN-PPOLY and %TAN-QPOLY contain adapted P and Q coefficients of Harris et al TAN 4288 rational approximation to (TAN X) in interval (-PI/4 PI/4).  The coefficients for %TAN-PPOLY and %TAN-QPOLY have been computed from Harris using extended precision routines and the relations %TAN-PPOLY = (REVERSE (for I from 0 as ENTRY in PS collect (/ (* (EXPT (/ 4 PI) (1+ (* 2 I))) ENTRY) Q0))) and %TAN-QPOLY = (REVERSE (for I from 0 as ENTRY in QS collect (/ (* (EXPT (/ 4 PI) (* 2 I)) ENTRY) Q0))) *")(RPAQ %TAN-PPOLY (%MAKE-ARRAY (LIST (%FLOAT 13237 21090)                                    (%FLOAT 47141 15825)                                    (%FLOAT 15246 8785)                                    (%FLOAT 48655 48761)                                    (%FLOAT 16256 0))))(RPAQ %TAN-QPOLY (%MAKE-ARRAY (LIST (%FLOAT 45267 36947)                                    (%FLOAT 13848 46875)                                    (%FLOAT 47612 53738)                                    (%FLOAT 15596 52854)                                    (%FLOAT 48882 35303)                                    (%FLOAT 16256 0))))(DEFINEQ(CL:TAN  (CL:LAMBDA (RADIANS)                                       (* FS "20-Oct-86 23:37")         (CTYPECASE RADIANS (COMPLEX (%TAN-COMPLEX RADIANS))                (CL:NUMBER (%TAN-FLOAT (FLOAT RADIANS))))))(%TAN-FLOAT  (LAMBDA (X)                                                (* |kbr:| "20-Aug-86 20:13")                    (* * TAN |of| \a FLOAT X |calculated| |via| TAN 4288 |rational| |approximation|           |of| |Harris| |et| |al.| *)    (PROG (R SIGN RECIPFLG R2 ANSWER)          (DECLARE (GLOBALVARS %TAN-PPOLY %TAN-QPOLY)                 (TYPE FLOATP X R R2 ANSWER))          (SETQ R X)                    (* * |First| |range| |reduce| |to| (0 |infinity|) |by|          (TAN (|minus| X)) = (|minus| (TAN X)) *)          (COND             ((< R 0)              (SETQ SIGN -1.0)              (SETQ R (- R)))             (T (SETQ SIGN 1.0)))                    (* * |Next| |range| |reduce| |to| (0 CL:PI) *)          (SETQ R (CL:REM R %PI))                    (* * |Next,| |range| |reduce| |to| (-PI/4 PI/4) |using|          (TAN X) = (TAN (|minus| X CL:PI)) |to| |get| |into| |interval|          (-PI/2 PI/2) |and| |then| (TAN X) = (/ (TAN          (|minus| PI/2 X))) |to| |get| |into| |interval|          (-PI/4 PI/4) *)          (COND             ((> R %PI/2)              (SETQ R (- R %PI))              (COND                 ((< R %-PI/4)                  (SETQ RECIPFLG T)                  (SETQ R (- %-PI/2 R)))))             (T (COND                   ((> R %PI/4)                    (SETQ RECIPFLG T)                    (SETQ R (- %PI/2 R))))))          (COND             ((< (ABS R)               %TAN-EPSILON)                    (* * I\f R |is| |in| |the| |interval| (0 %TAN-EPSILON) |then|          (TAN R) = R |to| |the| |precision| |that| |we| |can| |offer.|          |Return| R |because| (1) |it| |is| |desirable| |that|          (TAN R) = R |exactly| |for| |small| R |and|          (2) |microcode| POLYEVAL |will| |underflow| |on| |sufficiently| |small|           |positive| R. *)              (SETQ ANSWER (CL:* SIGN R))              (COND                 (RECIPFLG (SETQ ANSWER (/ ANSWER))))              (RETURN ANSWER)))                    (* * |Now| |use| TAN 4288 |rational| |approximation| |of| |Harris| |et| |al.|          |which| |works| |on| |interval| (0 %PI/4) *)          (SETQ R2 (CL:* R R))          (SETQ ANSWER (CL:* SIGN R (/ (POLYEVAL R2 %TAN-PPOLY 4)                                       (POLYEVAL R2 %TAN-QPOLY 5))))          (COND             (RECIPFLG (SETQ ANSWER (/ ANSWER))))          (RETURN ANSWER))))(%TAN-COMPLEX  (CL:LAMBDA (Z)                    (* |tan| |of| \a |complex| |number| |there| |was| \a |nicer| |algorithm| |but|           |it| |turned| |out| |not| |to| |work| |so| |well.|          *)         (LET* ((NUM (CL:SIN Z))                (DENOM (CL:COS Z)))               (CL:IF (ZEROP DENOM)                      (CL:ERROR "~S undefined tangent." Z)                      (/ NUM DENOM))))))(* CL:ASIN *)(* |;;| "%ASIN-EPSILON is sufficiently small that (ASIN X) = X for X in interval (0 %ASIN-EPSILON).  It suffices to take %ASIN-EPSILON a little bit smaller than (* 2 SINGLE-FLOAT-EPSILON) which we get by the Taylor series expansion (ASIN X) = (+ X (/ (EXPT X 3) 6) ...) (The relative error caused by ommitting (/ (EXPT X 3) 6) isn't observable.) Comparison against %ASIN-EPSILON is used to avoid POLYEVAL microcode underflow when computing SIN.  *")(RPAQ? %ASIN-EPSILON (%FLOAT 14720 0))(* |;;| "%ASIN-PPOLY and %ASIN-QPOLY contain P and Q coefficients of Harris et al ARCSN 4671 rational approximation to (ASIN X) in interval (0 (SQRT .5))  . *")(RPAQ %ASIN-PPOLY (%MAKE-ARRAY (LIST (%FLOAT 16007 50045)                                     (%FLOAT 49549 8020)                                     (%FLOAT 17236 15848)                                     (%FLOAT 50285 63464)                                     (%FLOAT 17650 31235)                                     (%FLOAT 50403 62852)                                     (%FLOAT 17440 39471))))(RPAQ %ASIN-QPOLY (%MAKE-ARRAY (LIST (%FLOAT 16256 0)                                     (%FLOAT 49672 25817)                                     (%FLOAT 17308 55260)                                     (%FLOAT 50326 38098)                                     (%FLOAT 17674 22210)                                     (%FLOAT 50417 22451)                                     (%FLOAT 17440 39471))))(DEFINEQ(CL:ASIN  (CL:LAMBDA (NUMBER)                                        (* FS "21-Oct-86 00:51")         (CTYPECASE NUMBER (FLOAT (%ASIN-FLOAT NUMBER))                (COMPLEX (%ASIN-COMPLEX NUMBER))                (CL:NUMBER (%ASIN-FLOAT (FLOAT NUMBER))))))(%ASIN-FLOAT  (LAMBDA (X ACOS-FLAG)                                      (* |kbr:| "30-May-86 16:46")                    (* * (CL:ASIN X) |for| |float| X |calculated| |via| ARCSN 4671 |rational|           |approximation| |of| |Harris| |et| |al.|          *)    (PROG (NEGATIVE REDUCED R R2 ANSWER)          (DECLARE (GLOBALVARS %ASIN-PPOLY %ASIN-QPOLY))          (SETQ R X)          (COND             ((OR (< R -1.0)                  (> R 1.0))              (ERROR "ARCSIN: arg not in range" R)))          (COND             ((< R 0.0)                    (* * |Range| |reduce| |to| (0 1) |via| |identity|          (CL:ASIN (|minus| X)) = (|minus| (CL:ASIN X)) *)              (SETQ NEGATIVE T)              (SETQ R (- R))))          (COND             ((> R .5)                    (* * |Range| |reduce| |to| (0 .5) |via| |identity|          (CL:ASIN X) = (|minus| %PI/2 (CL:* 2.0 (CL:ASIN          (CL:SQRT (CL:* .5 (|minus| 1.0 R)))))) |Avoids| |numerical| |instability|           |calculating| (CL:ASIN X) |for| X |near| |one.|          SIN |is| |horizontally| |flat| |near| %PI/2 |so| |calculating|          (CL:ASIN X) |by| |rational| |approximation| |wouldn't| |work| |well| |for| X           |near| (SIN %PI/2) = 1 *)              (SETQ REDUCED T)              (SETQ R (CL:SQRT (CL:* .5 (- 1.0 R))))))                    (* * R |is| |now| |in| |range| (0 .5) |Use| ARCSN 4671 |rational|           |approximation| |to| |calculate| (CL:ASIN R) *)          (SETQ ANSWER (COND                          ((< R %ASIN-EPSILON)                    (* * I\f R |is| |in| |the| |interval| (0 %SIN-EPSILON) |then|          (CL:ASIN R) = R |to| |the| |precision| |that| |we| |can| |offer.|          |Return| R |because| (1) |it| |is| |desirable| |that|          (CL:ASIN R) = R |exactly| |for| |small| R |and|          (2) |microcode| POLYEVAL |will| |underflow| |on| |sufficiently| |small|           |positive| R. *)                           R)                          (T (SETQ R2 (CL:* R R))                             (CL:* R (/ (POLYEVAL R2 %ASIN-PPOLY 6)                                        (POLYEVAL R2 %ASIN-QPOLY 6))))))          (COND             (REDUCED (SETQ ANSWER (- %PI/2 (CL:* 2.0 ANSWER)))))          (COND             (NEGATIVE (SETQ ANSWER (- ANSWER))))          (COND             (ACOS-FLAG                     (* * I\n |case| |we| |want| (CL:ACOS X) |then| |use| |identity|          (CL:ACOS X) = (|minus| %PI/2 (CL:ASIN X)) *)                    (SETQ ANSWER (- %PI/2 ANSWER))))          (RETURN ANSWER))))(%ASIN-COMPLEX  (CL:LAMBDA (Z)                                             (* |kbr:| "27-May-86 22:38")         (%COMPLEX-MINUS (%COMPLEX-TIMESI (CL:LOG (+ (%COMPLEX-TIMESI Z)                                                     (CL:SQRT (- 1 (CL:* Z Z))))))))))(* CL:ACOS *)(DEFINEQ(CL:ACOS  (CL:LAMBDA (NUMBER)                                        (* FS "21-Oct-86 00:56")         (CTYPECASE NUMBER (FLOAT (%ASIN-FLOAT NUMBER T))                (COMPLEX (%ACOS-COMPLEX NUMBER))                (CL:NUMBER (%ASIN-FLOAT (FLOAT NUMBER)                                  T)))))(%ACOS-COMPLEX  (CL:LAMBDA (Z)                                             (* |kbr:| "27-May-86 22:31")         (%COMPLEX-MINUS (%COMPLEX-TIMESI (CL:LOG (+ Z (%COMPLEX-TIMESI (CL:SQRT (- 1                                                                                    (CL:* Z Z))))))))         )))(* ATAN *)(RPAQ? %SQRT3 (%FLOAT 16349 46039))(RPAQ? %2-SQRT3 (%FLOAT 16009 12451))(RPAQ? %INV-2-SQRT3 (%FLOAT 16494 55788))(DEFINEQ(CL:ATAN  (CL:LAMBDA (X &OPTIONAL Y)                                 (* |lmm| "27-Jun-86 22:25")         (COND            (Y (%ATAN-FLOAT (FLOAT X)                      (FLOAT Y)))            ((CL:COMPLEXP X)             (%ATAN-COMPLEX X))            (T (%ATAN-FLOAT (FLOAT X))))))(%ATAN-FLOAT1  (CL:LAMBDA (X)                                             (* |kbr:| "23-Jul-86 18:26")         (COND            ((MINUSP X)                                      (* (ATAN (|minus| X)) =                                                             (|minus| (ATAN X)) *)             (- (%ATAN-FLOAT1 (- X))))            ((< X %2-SQRT3)                                  (* (ATAN X) = (|minus| %PI/2                                                             (ATAN (/ X))) *)             (%ATAN-FLOAT2 X))            ((< X 1)             (+ %PI/6 (%ATAN-FLOAT2 (/ (CL:1- (CL:* X %SQRT3))                                       (+ %SQRT3 X)))))            ((< X %INV-2-SQRT3)             (- %PI/3 (%ATAN-FLOAT2 (/ (- %SQRT3 X)                                       (CL:1+ (CL:* X %SQRT3))))))            (T (- %PI/2 (%ATAN-FLOAT2 (/ X)))))))(%ATAN-FLOAT2  (CL:LAMBDA (X)                                             (* |kbr:| "23-Jul-86 18:26")         (CL:DO* ((SQR (- (CL:* X X)))                  (INT 1 (+ 2 INT))                  (OLD 0 VAL)                  (POW X (CL:* POW SQR))                  (VAL POW (+ VAL (/ POW INT))))                ((= OLD VAL)                 VAL))))(%ATAN-DOMAIN-CHECK  (CL:LAMBDA (Z)                                             (* |kbr:| "27-May-86 22:42")                    (* |Return| T |if| Z |is| |in| |the| |domain| |of| ATAN.          ATAN |is| |singular| |at| \i |and| -\i. *)         (NOT (AND (ZEROP (CL:REALPART Z))                   (= (ABS (CL:IMAGPART Z))                      1)))))(%ATAN-FLOAT  (CL:LAMBDA (Y &OPTIONAL X)         (COND            ((NOT X)             (CL:IF (ZEROP Y)                    0.0                    (%ATAN-FLOAT1 Y)))            ((= Y X 0)             (CL:ERROR "Error in double entry atan both 0."))            ((= X 0)             (CL:* (%SIGNUM Y)                   %PI/2))            ((= Y 0)             (CL:IF (CL:PLUSP X)                    0 %PI))            ((AND (CL:PLUSP X)                  (CL:PLUSP Y))             (%ATAN-FLOAT1 (/ Y X)))            ((CL:PLUSP Y)             (- %PI (%ATAN-FLOAT1 (/ (- Y)                                     X))))            ((CL:PLUSP X)             (- (%ATAN-FLOAT1 (/ Y (- X)))))            (T (- (%ATAN-FLOAT1 (/ Y X))                  %PI)))))(%ATAN-COMPLEX  (CL:LAMBDA (Z)         (CL:IF (%ATAN-DOMAIN-CHECK Z)                (LET ((I (%COMPLEX-TIMESI Z)))                     (%COMPLEX-MINUS (%COMPLEX-TIMESI (CL:* .5 (CL:LOG (/ (+ 1 I)                                                                          (- 1 I)))))))                (CL:ERROR "Argument not in domain for atan. ~S" Z)))))(* CL:CIS *)(DEFINEQ(CL:CIS  (CL:LAMBDA (RADIANS)                                       (* |kbr:| "12-Jul-86 18:05")                                                             (* |Return| |cos| (|Theta|) + \i |sin|                                                             (|Theta|)\. *)         (CL:IF (CL:COMPLEXP RADIANS)                (CL:ERROR "Argument to CIS is complex: ~S" RADIANS)                (COMPLEX (CL:COS RADIANS)                       (CL:SIN RADIANS))))))(* CL:SINH CL:COSH CL:TANH *)(DEFINEQ(CL:SINH  (CL:LAMBDA (NUMBER)                                        (* FS "21-Oct-86 01:00")                                                  (* |;;| "Hyperbolic trig functions.  Each of the hyperbolic trig functions is calculated directly from their definition.  Exp (x) is calculated only once for efficiency.  They all work with complex arguments without modification.  *")         (LET ((Z (CL:EXP NUMBER)))              (/ (- Z (/ Z))                 2))))(CL:COSH  (CL:LAMBDA (NUMBER)                                        (* FS "21-Oct-86 01:00")         (LET ((Z (CL:EXP NUMBER)))              (/ (+ Z (/ Z))                 2))))(CL:TANH  (CL:LAMBDA (NUMBER)                                        (* FS "21-Oct-86 01:01")                                                  (* |;;|                                            "Different form than in the manual.  Does much better.  *")         (LET* ((Z (CL:EXP (CL:* 2 NUMBER)))                (Y (/ Z)))               (- (/ (CL:1+ Y))                  (/ (CL:1+ Z)))))))(* CL:ASINH CL:ACOSH CL:ATANH *)(DEFINEQ(CL:ASINH  (CL:LAMBDA (NUMBER)                                        (* |kbr:| "12-Jul-86 18:05")         (CL:LOG (+ NUMBER (CL:SQRT (+ (CL:* NUMBER NUMBER)                                       1))))))(CL:ACOSH  (CL:LAMBDA (NUMBER)                                        (* |kbr:| "12-Jul-86 18:05")         (CL:LOG (+ NUMBER (CL:SQRT (- (CL:* NUMBER NUMBER)                                       1))))))(CL:ATANH  (CL:LAMBDA (NUMBER)                                        (* |kbr:| "12-Jul-86 18:05")         (CL:IF (%ATANH-DOMAIN-CHECK NUMBER)                (CL:* .5 (CL:LOG (/ (CL:1+ NUMBER)                                    (- 1 NUMBER))))                (CL:ERROR "~S argument out of range." NUMBER))))(%ATANH-DOMAIN-CHECK  (CL:LAMBDA (Z)                                             (* |kbr:| "27-May-86 22:49")                    (* |Return| T |if| Z |is| |in| |the| |domain| |of| ATANH.          CL:ATANH |is| |singular| |at| 1 |and| -1.0 *)         (NOT (AND (ZEROP (CL:IMAGPART Z))                   (= (ABS (CL:REALPART Z))                      1))))))(PUTPROPS CMLFLOAT FILETYPE CL:COMPILE-FILE)(DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA           %ATANH-DOMAIN-CHECK CL:ATANH CL:ACOSH CL:ASINH CL:TANH CL:COSH CL:SINH CL:CIS %ATAN-COMPLEX                 %ATAN-FLOAT %ATAN-DOMAIN-CHECK %ATAN-FLOAT2 %ATAN-FLOAT1 CL:ATAN %ACOS-COMPLEX                 CL:ACOS %ASIN-COMPLEX CL:ASIN %TAN-COMPLEX CL:TAN %COS-COMPLEX CL:COS %SIN-COMPLEX                 CL:SIN CL:SQRT %LOG-COMPLEX CL:LOG %EXPT-COMPLEX-POWER %EXPT-COMPLEX %EXPT-INTEGER                 CL:EXPT %EXP-COMPLEX %EXP-FLOAT CL:EXP))(PUTPROPS CMLFLOAT COPYRIGHT ("Xerox Corporation" 1986))(DECLARE\: DONTCOPY  (FILEMAP (NIL (16181 16344 (%FLOAT 16191 . 16342)) (19304 19913 (%MAKE-ARRAY 19314 . 19911)) (20986 23742 (CL:EXP 20996 . 21401) (%EXP-FLOAT 21403 . 23458) (%EXP-COMPLEX 23460 . 23740)) (23762 29306 (CL:EXPT 23772 . 25629) (%EXPT-INTEGER 25631 . 28362) (%EXPT-FLOAT 28364 . 28688) (%EXPT-COMPLEX 28690 . 29012) (%EXPT-COMPLEX-POWER 29014 . 29304)) (30161 32970 (CL:LOG 30171 . 30732) (%LOG-FLOAT 30734 . 32689) (%LOG-COMPLEX 32691 . 32968)) (32990 36624 (CL:SQRT 33000 . 33555) (%SQRT-FLOAT 33557 . 35246) (%SQRT-COMPLEX 35248 . 36622)) (38351 41958 (CL:SIN 38361 . 38686) (%SIN-FLOAT 38688 . 41576) (%SIN-COMPLEX 41578 . 41956)) (41977 42766 (CL:COS 41987 . 42308) (%COS-COMPLEX 42310 . 42764)) (44438 47624 (CL:TAN 44448 . 44682) (%TAN-FLOAT 44684 . 47186) (%TAN-COMPLEX 47188 . 47622)) (49145 52422 (CL:ASIN 49155 . 49438) (%ASIN-FLOAT 49440 . 52135) (%ASIN-COMPLEX 52137 . 52420)) (52445 53104 (CL:ACOS 52455 . 52776) (%ACOS-COMPLEX 52778 . 53102)) (53255 56407 (CL:ATAN 53265 . 53577) (%ATAN-FLOAT1 53579 . 54492) (%ATAN-FLOAT2 54494 . 54862) (%ATAN-DOMAIN-CHECK 54864 . 55241) (%ATAN-FLOAT 55243 . 56034) (%ATAN-COMPLEX 56036 . 56405)) (56429 56934 (CL:CIS 56439 . 56932)) (56973 58102 (CL:SINH 56983 . 57474) (CL:COSH 57476 . 57674) (CL:TANH 57676 . 58100)) (58144 59328 (CL:ASINH 58154 . 58380) (CL:ACOSH 58382 . 58608) (CL:ATANH 58610 . 58942) (%ATANH-DOMAIN-CHECK 58944 . 59326)))))STOP