(FILECREATED "12-Sep-86 22:25:09" {ERIS}<LISPCORE>SOURCES>COMMON.;53 24083        changes to:  (FNS READNUMBERINBASE READQUOTE SKIP.HASH.COMMENT READBQUOTE READBQUOTECOMMA)      previous date: "27-Aug-86 23:17:40" {ERIS}<LISPCORE>SOURCES>COMMON.;52)(* Copyright (c) 1985, 1986 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT COMMONCOMS)(RPAQQ COMMONCOMS ((COMS (* "Read macro for '")                         (FNS READQUOTE))                   (COMS (* "# macro")                         (FNS READVBAR READHASHMACRO DEFMACRO-LAMBDA-LIST-KEYWORD-P DIGITBASEP                               READNUMBERINBASE ESTIMATE-DIMENSIONALITY SKIP.HASH.COMMENT                               CMLREAD.FEATURE.PARSER CREATE-STRUCTURE))                   (COMS (* BQUOTE)                         (FNS READBQUOTE READBQUOTECOMMA \BQUOTE.EXPAND BQ.CONS BQ.PROGN                               \BQUOTE.SPLICE \BQUOTE.STANDARD \UNCOMMA \BQUOTE.BREAKRESET)                         (MACROS BQUOTE)                         (DECLARE: DONTEVAL@LOAD DOCOPY (VARS (\INBQUOTE))                                (ADDVARS (BREAKRESETFORMS (\BQUOTE.BREAKRESET)))))                   (COMS (* "Pretty printing of quote and friends")                         (FNS QUOTE.WRAPPER BQUOTE.WRAPPER FUNCTION.WRAPPER)                         (PROP PRETTYWRAPPER BQUOTE CL:FUNCTION QUOTE \, \,. \,@))                   (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)                                                                                       (NLAML)                                                                                       (LAMA                                                                                      CREATE-STRUCTURE                                                                                             )))))(* "Read macro for '")(DEFINEQ(READQUOTE  (LAMBDA (FILE)                                             (* bvm: "12-Sep-86 21:04")    (LIST (QUOTE QUOTE)          (READ FILE)))))(* "# macro")(DEFINEQ(READVBAR  (LAMBDA (STREAM RDTBL)                                     (* bvm: "14-May-86 17:31")                    (* * Read Interlisp's %| macro. Originally this char was just a sepr in           FILERDTBL but was then extended in various hokey ways, because it was the only           character plausibly available for redefinition.          Today it is extended still further to be Common Lisp # in all the cases not           already taken by some other meaning)    (SELCHARQ (PEEKCCODE STREAM)         ('                                                  (* commonlisp defines "#'X" to mean                                                             (FUNCTION X), but here its BQUOTE)            (READCCODE STREAM)            (READBQUOTE STREAM RDTBL))         ((%( { ^)                                           (* Used by HPRINT)              (HREAD STREAM))         (# (READCCODE STREAM)                               (* "|#" = Common Lisp #)            (READHASHMACRO STREAM RDTBL))         ((EOL TAB SPACE)                                    (* CR or tab, treat as separator)              (VALUES))         (PROGN                                              (* Everything else not already                                                              preempted by old-style %| is                                                              interpreted as Common Lisp)                (READHASHMACRO STREAM RDTBL)))))(READHASHMACRO  (LAMBDA (STREAM RDTBL INDEX)                               (* lmm "26-Jun-86 10:02")                    (* * Implements the standard # macro dispatch --          reads next character to find out what to do.          Can return zero values if we just want to skip something)    (LET ((READFN (COND                     ((fetch (READTABLEP COMMONLISP) of RDTBL)                    (* Kludge: if we have to recursively read something that will not end up as the           resulting list structure, use the reader that passes thru CMLTRANSLATE)                      (FUNCTION CL:READ))                     (T (FUNCTION READ))))          NEXTCHAR READVAL)         (while (DIGITCHARP (SETQ NEXTCHAR (PEEKCCODE STREAM RDTBL)))            do (SETQ INDEX (PLUS (TIMES (OR INDEX 0)                                        10)                                 (DIFFERENCE (READCCODE STREAM RDTBL)                                        (CHARCODE 0)))))         (SELCHARQ NEXTCHAR              ("(" (LET ((CONTENTS (APPLY* READFN STREAM)))                        (COND                           (INDEX (FILL.VECTOR (MAKE-ARRAY INDEX)                                         CONTENTS))                           (T (MAKE-ARRAY (LENGTH CONTENTS)                                     :INITIAL-CONTENTS CONTENTS)))))              (PROGN                                         (* Those cases we left the dispatching                                                              char in buffer for convenience of the                                                              next read. Now eat it)                     (SELCHARQ (READCCODE STREAM RDTBL)                          (' (LIST (QUOTE FUNCTION)                                   (READ STREAM RDTBL)))                          (%. (EVAL (APPLY* READFN STREAM)))                          (, (LIST (QUOTE LOADTIMECONSTANT)                                   (READ STREAM RDTBL)))                          (\ (CHARACTER.READ STREAM))                          ("*"                               (* Read bit vector)                               (LET ((CONTENTS (while (MEMQ (PEEKCCODE STREAM RDTBL)                                                            (CHARCODE (0 1)))                                                  collect (IDIFFERENCE (READCCODE STREAM RDTBL)                                                                 (CHARCODE 0)))))                                    (COND                                       (INDEX (FILL.VECTOR (MAKE-ARRAY INDEX :ELEMENT-TYPE                                                                  (QUOTE BIT))                                                     CONTENTS))                                       (T (MAKE-ARRAY (LENGTH CONTENTS)                                                 :INITIAL-CONTENTS CONTENTS :ELEMENT-TYPE                                                 (QUOTE BIT))))))                          (":"                               (* Uninterned symbol.                                                             This definition is very wrong)                               (RSTRING STREAM RDTBL))                          ((O o)                                (READNUMBERINBASE STREAM 8))                          ((B b)                                (READNUMBERINBASE STREAM 2))                          ((X x)                                (READNUMBERINBASE STREAM 16))                          ((R r)                                (READNUMBERINBASE STREAM INDEX))                          ((A a)                                (LET ((CONTENTS (APPLY* READFN STREAM)))                                    (MAKE-ARRAY (ESTIMATE-DIMENSIONALITY INDEX CONTENTS)                                           :INITIAL-CONTENTS CONTENTS)))                          ((S s)                                (CREATE-STRUCTURE (APPLY* READFN STREAM)))                          ((C c)                                (DESTRUCTURING-BIND (NUM DEN)                                      (APPLY* READFN STREAM)                                      (COMPLEX NUM DEN)))                          (+                                 (* Skip expression if feature not                                                              present)                             (COND                                ((NOT (CMLREAD.FEATURE.PARSER (READ STREAM RDTBL)))                                 (CL:READ STREAM RDTBL)))                             (VALUES))                          (-                                 (* Skip expression if feature IS                                                              present)                             (COND                                ((CMLREAD.FEATURE.PARSER (READ STREAM RDTBL))                                 (CL:READ STREAM RDTBL)))                             (VALUES))                          ("|"                               (* special comment)                               (SKIP.HASH.COMMENT STREAM RDTBL)                               (VALUES))                          (< (READ<))                          ((SPACE TAB NEWLINE PAGE RETURN %))                                (ERROR "Illegal read syntax " (CHARCODE.UNDECODE NEXTCHAR)))                          (%"                                (* An extension -- read string without                                                              cr's and leading spaces)                              (RSTRING STREAM RDTBL (QUOTE SKIP)))                          (APPLY* (OR (GET (CHARACTER NEXTCHAR)                                           (QUOTE HASHREADMACRO))                                      (ERROR "Undefined hashmacro char" NEXTCHAR))                                 STREAM RDTBL)))))))(DEFMACRO-LAMBDA-LIST-KEYWORD-P  (LAMBDA (S)                                                (* raf " 2-Jan-86 17:35")    (MEMBER S (QUOTE (&OPTIONAL &REST &KEY &ALLOW-OTHER-KEYS &AUX &BODY &WHOLE)))))(DIGITBASEP  (LAMBDA (CODE RADIX)                                       (* lmm "11-Jun-85 00:54")    (COND       ((AND (GEQ CODE (CHARCODE 0))             (LESSP CODE (PLUS (CHARCODE 0)                               RADIX)))        (DIFFERENCE CODE (CHARCODE 0)))       ((GREATERP RADIX 10)        (COND           ((AND (GEQ CODE (CHARCODE a))                 (LEQ CODE (CHARCODE z)))            (add CODE (DIFFERENCE (CHARCODE A)                             (CHARCODE a)))))        (COND           ((AND (GEQ CODE (CHARCODE A))                 (LEQ CODE (CHARCODE Z)))            (SETQ CODE (PLUS 10 (DIFFERENCE CODE (CHARCODE A))))            (COND               ((LESSP CODE RADIX)                CODE))))))))(READNUMBERINBASE  (LAMBDA (STREAM RADIX)                                     (* bvm: "12-Sep-86 21:25")    (PROG ((BODY (READ-EXTENDED-TOKEN STREAM))           (I 1)           CH VAL NUMERATOR SIGN BASE)                       (* "First check for leading sign")          (SELCHARQ (SETQ CH (NTHCHARCODE BODY 1))               (+ (GO NEXTCH))               (- (SETQ SIGN T)                  (GO NEXTCH))               NIL)      LP  (if (SETQ BASE (DIGITBASEP CH RADIX))              then (SETQ VAL (+ (TIMES (OR VAL 0)                                       RADIX)                                BASE))            elseif (EQ CH (CHARCODE "/"))              then                                           (* "Ratio marker")                   (if (OR NUMERATOR (NULL VAL))                       then (GO MALFORMED))                   (SETQ NUMERATOR VAL)                   (SETQ VAL NIL)            else                                             (*                                             "Terminated by a character that is not a token delimiter")                 (GO MALFORMED))      NEXTCH          (if (SETQ CH (NTHCHARCODE BODY (add I 1)))              then (GO LP)            else                                             (* ; "end of token, fall thru"))      DONE          (if (NULL VAL)              then (GO MALFORMED))          (if NUMERATOR              then (SETQ VAL (%%/ NUMERATOR VAL)))          (RETURN (if SIGN                      then (- VAL)                    else VAL))      MALFORMED          (RETURN (CL:ERROR "Malformed ratio ~S" BODY)))))(ESTIMATE-DIMENSIONALITY  (LAMBDA (RANK CONTENTS)                                    (* bvm: " 9-May-86 16:06")    (COND       ((NULL RANK)        (ERROR "No rank found while reading array" NIL))       ((EQ RANK 0)        NIL)       (T (to RANK as (D _ CONTENTS) by (CAR D) collect (LENGTH D))))))(SKIP.HASH.COMMENT  (LAMBDA (STREAM RDTBL)                                     (* bvm: "12-Sep-86 21:02")    (PROG NIL                                     (* ;;                               "a tiny fsm that recognizes #| ... |# with possible nestings of itself")      LP  (SELCHARQ (READCCODE STREAM RDTBL)               ("#" (GO SHARP))               ("|" (GO VBAR))               (GO LP))      SHARP          (SELCHARQ (READCCODE STREAM RDTBL)               ("|"                                    (* ; "#| -- recursively skip nested section")                    (SKIP.HASH.COMMENT STREAM RDTBL)                    (GO LP))               ("#" (GO SHARP))               (GO LP))      VBAR          (SELCHARQ (READCCODE STREAM RDTBL)               ("|" (GO VBAR))               ("#"                                          (* ; "found closing |#")                    (RETURN))               (GO LP)))))(CMLREAD.FEATURE.PARSER  (LAMBDA (EXPR)                                             (* bvm: "14-May-86 17:43")    (COND       ((CONSP EXPR)        (CASE (CAR EXPR)              (AND (EVERY (CDR EXPR)                          (FUNCTION CMLREAD.FEATURE.PARSER)))              (OR (SOME (CDR EXPR)                        (FUNCTION CMLREAD.FEATURE.PARSER)))              (NOT (NOT (CMLREAD.FEATURE.PARSER (CADR EXPR))))              (ERROR "Bad feature expression" EXPR)))       ((FMEMB EXPR *FEATURES*)        T))))(CREATE-STRUCTURE  (CL:LAMBDA (STRUCTURE-FORM)                                (* lmm "16-Apr-86 12:56")         (APPLY (PACK* (QUOTE MAKE-)                       (U-CASE (CAR STRUCTURE-FORM)))                (for TAIL on (CDR STRUCTURE-FORM) by (CDDR TAIL)                   join (LIST (MAKE-KEYWORD (CAR TAIL))                              (CADR TAIL)))))))(* BQUOTE)(DEFINEQ(READBQUOTE  (LAMBDA (FILE)                                             (* bvm: "12-Sep-86 21:08")    (LET ((\INBQUOTE T))         (DECLARE (SPECVARS \INBQUOTE))         (LIST (QUOTE BQUOTE)               (READ FILE)))))(READBQUOTECOMMA  (LAMBDA (FILE)    (DECLARE (USEDFREE \INBQUOTE))                           (* bvm: "12-Sep-86 21:10")    (if (OR (fetch (READTABLEP COMMONLISP) of *READTABLE*)            \INBQUOTE)        then                                                 (* ; "Valid context for comma")             (LIST (SELCHARQ (SKIPSEPRCODES FILE)                        (@ (READCCODE FILE)                           (QUOTE \,@))                        (%. (READCCODE FILE)                            (QUOTE \,.))                        (QUOTE \,))                   (READ FILE))      else                                        (* ;; "Comma outside of backquote context is `an error' In Interlisp read table we want to treat it as though it had been escaped, because files written with old FILERDTBL might have had unescaped commas in them.  In Common Lisp, we go ahead and read it as if we were in bquote context, for the benefit of typing subexpressions to DEdit")           (LET ((CH (PEEKCCODE FILE)))                (if (OR (SYNTAXP CH (QUOTE BREAK))                        (SYNTAXP CH (QUOTE SEPR)))                    then (QUOTE ,)                  else (PACK* (QUOTE ,)                              (READ FILE)))))))(\BQUOTE.EXPAND  (LAMBDA (EXPR LEVEL)                                       (* bvm: " 2-Jun-86 15:59")                                                             (* Backquote expanding function *)    (COND       ((ILESSP LEVEL 0)                                     (* Perhaps the user hand constructed a                                                              malformed backquoted form.                                                             *)        (ERROR "Too many commas" EXPR))       ((EQ LEVEL 0)        (COND           ((LISTP EXPR)            (SELECTQ (CAR EXPR)                (BQUOTE (\BQUOTE.EXPAND (CADR EXPR)                               1))                (CONS (\BQUOTE.EXPAND (CAR EXPR)                             0)                      (\BQUOTE.EXPAND (CDR EXPR)                             0))))           (T EXPR)))       ((EQ LEVEL 1)        (COND           ((LISTP EXPR)            (LET ((FN (CAR EXPR)))                 (SELECTQ FN                     (\, (CADR EXPR))                     (\,@ (ERROR ",@ in illegal context" EXPR))                     (\,. (ERROR ",. in illegal context" EXPR))                     (BQUOTE (\BQUOTE.STANDARD EXPR 2))                     (COND                        ((AND (LISTP FN)                              (SELECTQ (CAR FN)                                  ((\., \,@)                 (*     "Written this way so that the prettyprinting of \,@ doesn't lose.  \., is a grody obsolete form.")                                       T)                                  (\,. T)                                  NIL))                         (\BQUOTE.SPLICE EXPR))                        (T (\BQUOTE.STANDARD EXPR 1))))))           (T (KWOTE EXPR))))       (T                                                    (* LEVEL greater than 1%)          (COND             ((LISTP EXPR)              (SELECTQ (CAR EXPR)                  ((\, \,@ \.,)                        (\BQUOTE.STANDARD EXPR (SUB1 LEVEL)))                  (BQUOTE (\BQUOTE.STANDARD EXPR (ADD1 LEVEL)))                  (\BQUOTE.STANDARD EXPR LEVEL)))             (T (KWOTE EXPR)))))))(BQ.CONS  (LAMBDA (XA XD)                                            (* lmm "31-AUG-83 21:58")    (SELECTQ (CAR (LISTP XD))        ((CONS LIST*)              (LIST* (QUOTE LIST*)                    XA                    (CDR XD)))        (LIST (LIST* (QUOTE LIST)                     XA                     (CDR XD)))        (COND           (XD (LIST (QUOTE CONS)                     XA XD))           (T (LIST (QUOTE LIST)                    XA))))))(BQ.PROGN  (LAMBDA (L)                                                (* lmm "31-AUG-83 22:21")    (COND       ((CDR L)        (CONS (QUOTE PROGN)              L))       (T (CAR L)))))(\BQUOTE.SPLICE  (LAMBDA (SEX)                                              (* lmm "10-Jan-86 13:55")                                                             (* Splice-in cases. ",@" uses NCONC &                                                              ",." uses APPEND. *)    (PROG (A A1 A2 D FN ANSWER)          (SETQ A (CAR SEX))          (SETQ A1 (CAR A))          (SETQ A2 (CADR A))          (SETQ D (CDR SEX))          (SETQ D (\BQUOTE.EXPAND D 1))          (COND             ((OR (EQUAL D (QUOTE (QUOTE NIL)))                  (EQ D NIL))                                (* (NCONC X (QUOTE NIL)) => X *)              (SETQ ANSWER A2))             (T (COND                   ((EQ A1 (QUOTE \,@))                    (SETQ FN (QUOTE APPEND)))                   (T                                        (* \DOTCOMMA => Safe for us to NCONC.                                                             *)                      (SETQ FN (QUOTE NCONC))))                (COND                   ((AND (LISTP D)                         (EQ (CAR D)                             FN))                            (* (NCONC X (NCONC . Y)) =>                                                             (NCONC X . Y) *)                    (SETQ ANSWER (CONS FN (CONS A2 (CDR D)))))                   (T (SETQ ANSWER (LIST FN A2 D))))))          (RETURN ANSWER))))(\BQUOTE.STANDARD  (LAMBDA (EXPR LEVEL)                                       (* lmm "14-Jun-85 14:17")                                                             (* Standard case. *)    (LET ((BCAR (\BQUOTE.EXPAND (CAR EXPR)                       LEVEL))          (BCDR (\BQUOTE.EXPAND (CDR EXPR)                       LEVEL))          AV DV)         (COND            ((AND (SETQ AV (CONSTANTEXPRESSIONP BCAR))                  (SETQ DV (CONSTANTEXPRESSIONP BCDR)))             (LIST (QUOTE QUOTE)                   (CONS (CAR AV)                         (CAR DV))))            (T (BQ.CONS BCAR BCDR))))))(\UNCOMMA  (LAMBDA (X)                                                (* bvm: "19-May-86 12:38")                    (* * "Convert an old-style BQUOTE, where the commas were list elements, into the new style, where the commas are wrappers")    (COND       ((NLISTP X)        X)       (T (SELECTQ (CAR X)              ((, ,. ,@ ., ,!)                    (LET ((TAIL (\UNCOMMA (CDR X))))                        (CONS (LIST (SELECTQ (CAR X)                                        (, (QUOTE \,))                                        (,. (QUOTE \,.))                                        (QUOTE \,@))                                    (CAR TAIL))                              (CDR TAIL))))              (LET ((BCAR (\UNCOMMA (CAR X)))                    (BCDR (\UNCOMMA (CDR X))))                   (COND                      ((AND (EQ BCAR (CAR X))                            (EQ BCDR (CDR X)))                       X)                      (T (CONS BCAR BCDR)))))))))(\BQUOTE.BREAKRESET  (LAMBDA (FLG)                                              (* bvm: " 6-Jul-85 23:19")    (PROG1 \INBQUOTE (SETQ \INBQUOTE FLG)))))(DECLARE: EVAL@COMPILE (PUTPROPS BQUOTE MACRO (FORM (\BQUOTE.EXPAND (\UNCOMMA (CAR FORM))                                    1))))(DECLARE: DONTEVAL@LOAD DOCOPY (RPAQQ \INBQUOTE NIL)(ADDTOVAR BREAKRESETFORMS (\BQUOTE.BREAKRESET)))(* "Pretty printing of quote and friends")(DEFINEQ(QUOTE.WRAPPER  (LAMBDA (E FILE)                                           (* bvm: " 4-Jun-86 18:19")    (LET ((SYN (GETSYNTAX (QUOTE '))))         (AND (LISTP SYN)              (EQ (CAR (LAST SYN))                  (QUOTE READQUOTE))              "'"))))(BQUOTE.WRAPPER  (LAMBDA (E FILE)                                           (* bvm: " 4-Jun-86 18:20")                    (* * "To print bquote wrappers in their original syntax")    (AND (MEMB (QUOTE READBQUOTE)               (LISTP (GETSYNTAX (QUOTE `))))         (SELECTQ (CAR E)             (BQUOTE "`")             (\, ",")             (\,. ",.")             (\,@ ",@")             NIL))))(FUNCTION.WRAPPER  (LAMBDA (E FILE)                                           (* bvm: "18-Apr-86 16:36")    (AND (EQ (fetch (READTABLEP HASHMACROCHAR) of (\GTREADTABLE NIL))             (CHARCODE #))         "#'"))))(PUTPROPS BQUOTE PRETTYWRAPPER BQUOTE.WRAPPER)(PUTPROPS CL:FUNCTION PRETTYWRAPPER FUNCTION.WRAPPER)(PUTPROPS QUOTE PRETTYWRAPPER QUOTE.WRAPPER)(PUTPROPS \, PRETTYWRAPPER BQUOTE.WRAPPER)(PUTPROPS \,. PRETTYWRAPPER BQUOTE.WRAPPER)(PUTPROPS \,@ PRETTYWRAPPER BQUOTE.WRAPPER)(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA CREATE-STRUCTURE))(PUTPROPS COMMON COPYRIGHT ("Xerox Corporation" 1985 1986))(DECLARE: DONTCOPY  (FILEMAP (NIL (1917 2088 (READQUOTE 1927 . 2086)) (2111 14516 (READVBAR 2121 . 3646) (READHASHMACRO 3648 . 9596) (DEFMACRO-LAMBDA-LIST-KEYWORD-P 9598 . 9812) (DIGITBASEP 9814 . 10561) (READNUMBERINBASE 10563 . 12275) (ESTIMATE-DIMENSIONALITY 12277 . 12609) (SKIP.HASH.COMMENT 12611 . 13579) (CMLREAD.FEATURE.PARSER 13581 . 14121) (CREATE-STRUCTURE 14123 . 14514)) (14536 22294 (READBQUOTE 14546 . 14787) (READBQUOTECOMMA 14789 . 16093) (\BQUOTE.EXPAND 16095 . 18337) (BQ.CONS 18339 . 18816) (BQ.PROGN 18818 . 19020) (\BQUOTE.SPLICE 19022 . 20454) (\BQUOTE.STANDARD 20456 . 21105) (\UNCOMMA 21107 . 22126) (\BQUOTE.BREAKRESET 22128 . 22292)) (22596 23546 (QUOTE.WRAPPER 22606 . 22879) (BQUOTE.WRAPPER 22881 . 23303) (FUNCTION.WRAPPER 23305 . 23544)))))STOP