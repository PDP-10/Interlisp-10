(DEFINE-FILE-INFO §READTABLE "XCL" §PACKAGE "INTERLISP")(filecreated "17-Oct-86 17:47:42" {eris}<lispcore>sources>cmlarray.\;9 129387       |changes| |to:|  (fns %get-canonical-cml-type)                       (vars cmlarraycoms)                       (functions bit)      |previous| |date:| "14-Oct-86 14:32:13" {eris}<lispcore>sources>cmlarray.\;7); Copyright (c) 1986 by Xerox Corporation.  All rights reserved.(prettycomprint cmlarraycoms)(rpaqq cmlarraycoms        ((* |;;| "Contains table driven macros")        (declare\: dontcopy eval@compile (export (files (sysload from valueof directories)                                                        cmlarray-support)))        (* |;;| "User entry points")        (functions cl:adjust-array cl:adjustable-array-p cl:array-dimension cl:array-dimensions                cl:array-element-type cl:array-has-fill-pointer-p array-needs-indirection-p                cl:array-rank cl:array-total-size bit cl:bit-and cl:bit-andc1 cl:bit-andc2 bit-array-p                cl:bit-eqv cl:bit-ior cl:bit-nand cl:bit-nor cl:bit-not cl:bit-orc1 cl:bit-orc2                cl:bit-vector-p cl:bit-xor char cl:arrayp cl:stringp copy-array displaced-array-p                equal-dimensions-p extendable-array-p fill-array cl:fill-pointer fill-vector                cl:make-array make-vector read-only-array-p cl:sbit cl:schar set-fill-pointer                simple-array-p cl:simple-bit-vector-p cl:simple-string-p cl:simple-vector-p                string-array-p cl:svref vector-length cl:vector-pop cl:vector-push                cl:vector-push-extend cl:vectorp)        (fns %copy-to-new-array cl:aref cl:array-in-bounds-p cl:array-row-major-index aset cl:vector)        (* |;;| "Obsolete but retained to avoid recompilation")        (fns scharset)        (* |;;| "Vars etc")        (* \; "*PRINT-ARRAY* is defined in APRINT")        (variables cl:array-rank-limit cl:array-total-size-limit cl:array-dimension-limit                *default-push-extension-size*)        (* |;;| "Internal stuff")        (fns %alter-as-displaced-array %alter-as-displaced-to-base-array %aref0 %aref1 %aref2              %array-base %array-content-initialize %array-element-initialize %array-offset              %array-type-number %aset0 %aset1 %aset2 %check-sequence-dimensions %do-logical-op              %extend-array %fast-copy-base %fat-string-array-p %fill-array-from-sequence              %flatten-array %make-array-writeable %make-displaced-array %make-general-array              %make-oned-array %make-string-array-fat %make-twod-array %total-size shrink-vector)        (* \; "For Interlisp string hack")        (fns %set-array-offset %set-array-type-number)        (* \; "Faster predicates not including IL:STRINGP's")        (fns %arrayp %simple-array-p %simple-string-p %stringp %vectorp)        (* \; "Low level predicates")        (fns %general-array-p %oned-array-p %thin-string-array-p %twod-array-p)        (* \; "Record def's")        (declare\: dontcopy doeval@compile (export (records array-header general-array oned-array                                                           twod-array)))        (initrecords general-array oned-array twod-array)        (sysrecords general-array oned-array twod-array)        (prop dopval %aref1 %aref2 %aset1 %aset2)        (* |;;| "I/O")        (fns %defprint-array %defprint-bitvector %defprint-generic-array %defprint-vector              %defprint-string %print-array-contents)        (p (defprint 'oned-array '%defprint-vector)           (defprint 'twod-array '%defprint-array)           (defprint 'general-array '%defprint-array))        (* |;;| "Needed at run time. low level functions for accessing, setting, and allocating raw storage. also includes cml type to typenumber converters"           )        (fns %array-read %array-write %cml-type-to-typenumber %get-canonical-cml-type              %get-enclosing-signed-byte %get-enclosing-unsigned-byte %make-array-storage              %reduce-integer %reduce-mod %slow-array-read %slow-array-write)        (* |;;| "Compiler options")        (declare\: donteval@load doeval@compile dontcopy (localvars . t))        (prop filetype cmlarray)        (declare\: donteval@load doeval@compile dontcopy compilervars               (addvars (nlama)                      (nlaml)                      (lama cl:vector aset cl:array-row-major-index cl:array-in-bounds-p cl:aref)))))(* |;;| "Contains table driven macros")(declare\: dontcopy eval@compile (* FOLLOWING DEFINITIONS EXPORTED)(filesload (sysload from valueof directories)       cmlarray-support)(* END EXPORTED DEFINITIONS))(* |;;| "User entry points")(cl:defun cl:adjust-array (adjustable-array dimensions &key (element-type nil element-type-p)                                 (initial-element nil initial-element-p)                                 (initial-contents nil initial-contents-p)                                 (displaced-to nil displaced-to-p)                                 (displaced-to-base nil displaced-to-base-p)                                 (displaced-index-offset 0 displaced-index-offset-p)                                 (cl:fill-pointer nil fill-pointer-p)                                 fatp) "Do something wonderful"                    (* * "Strings are by default thin unless FATP is T")   (cl:if (not (extendable-array-p adjustable-array))          (cl:error "Not an adjustable or extendable array"))   (cl:if (not (cl:listp dimensions))          (setq dimensions (list dimensions)))   (cl:if (cl:dolist (dim dimensions nil)                 (cl:if (or (< dim 0)                            (>= dim cl:array-dimension-limit))                        (return t)))          (cl:error "Dimensions out of bounds ~S" dimensions))   (let ((adjustable-array-element-type (cl:array-element-type adjustable-array))         (nelts (%total-size dimensions))         (rank (length dimensions))         (extendable-p (not (cl:adjustable-array-p adjustable-array))))                    (* * "Consistency checks")        (cl:if (>= rank cl:array-rank-limit)               (cl:error "Too many dimensions: ~A" rank))        (cl:if (>= nelts cl:array-total-size-limit)               (cl:error "Too many elements: ~A" nelts))        (cl:if (not (eql rank (cl:array-rank adjustable-array)))               (cl:error "Rank mismatch ~S" dimensions))        (cl:if element-type-p (cl:if (not (equal element-type adjustable-array-element-type))                                     (cl:error "ADJUSTABLE-ARRAY not of specified element-type: ~A"                                             element-type))               (setq element-type adjustable-array-element-type))        (cl:if (and fill-pointer-p (null cl:fill-pointer)                    (cl:array-has-fill-pointer-p adjustable-array))               (cl:error "ADJUSTABLE-ARRAY has fill pointer"))        (cl:if (or (and displaced-to-p (or initial-element-p initial-contents-p displaced-to-base-p))                   (and displaced-to-base-p (or initial-element-p initial-contents-p displaced-to-p))                   (and fill-pointer-p cl:fill-pointer (not (eql rank 1)))                   (and displaced-index-offset-p (not (or displaced-to-p displaced-to-base-p)))                   (and initial-element-p initial-contents-p))               (cl:error "Inconsistent options to adjust-array"))        (cl:if displaced-to-p (cond                                 ((not (%arrayp displaced-to))                                  (cl:error "Cannot displace to an Interlisp array/string"))                                 ((not (equal adjustable-array-element-type (cl:array-element-type                                                                             displaced-to)))                                  (cl:error "Not displaced to an array of the same element-type:"))                                 ((> (+ displaced-index-offset nelts)                                     (cl:array-total-size displaced-to))                                  (cl:error "More elements than displaced-to array"))))        (cl:if cl:fill-pointer (cond                                  ((eq cl:fill-pointer t)                                   (setq cl:fill-pointer nelts))                                  ((not (and (>= cl:fill-pointer 0)                                             (<= cl:fill-pointer nelts)))                                   (cl:error "Fill pointer out of bounds ~A" cl:fill-pointer)))               (cl:if (cl:array-has-fill-pointer-p adjustable-array)                      (setq cl:fill-pointer (min (cl:fill-pointer adjustable-array)                                                 nelts))))        (cl:if extendable-p (cond                               ((or displaced-to-p displaced-to-base-p)                                (cl:error "Cannot adjust an extendable array to be displaced"))                               ((< nelts (cl:array-total-size adjustable-array))                                (cl:error "Cannot extend an extendable array to have fewer elements")                                )))                    (* * "Specs ready, do the surgury")        (cond           (displaced-to-p (%alter-as-displaced-array adjustable-array dimensions displaced-to                                   displaced-index-offset cl:fill-pointer))           (displaced-to-base-p (%alter-as-displaced-to-base-array adjustable-array dimensions                                        element-type displaced-to-base displaced-index-offset                                        cl:fill-pointer fatp))           (t (cl:if (equal (cl:array-dimensions adjustable-array)                            dimensions)                     (cl:if cl:fill-pointer (set-fill-pointer adjustable-array cl:fill-pointer))                     (let ((new-array (cl:make-array dimensions :element-type element-type :fatp                                             (%fat-string-array-p adjustable-array))))                          (cond                             (initial-contents-p (%array-content-initialize new-array                                                         initial-contents))                             (t (cl:if initial-element-p (%array-element-initialize new-array                                                                 initial-element))                                (%copy-to-new-array (cl:array-dimensions adjustable-array)                                       (%flatten-array adjustable-array)                                       0 dimensions (%flatten-array new-array)                                       0)))                          (%extend-array adjustable-array new-array dimensions cl:fill-pointer)))))                    (* * "Return the adjusted array")        adjustable-array))(cl:defun cl:adjustable-array-p (array)                     (* *) (cond    ((%arrayp array)     (|fetch| (array-header adjustable-p) |of| array))    ((stringp array)     nil)    (t (cl:error "Not an array ~S" array))))(cl:defun cl:array-dimension (array dimension)                     (* *) (cond    ((%oned-array-p array)     (cl:if (eql 0 dimension)            (|fetch| (array-header total-size) |of| array)            (cl:error "Dimension out of bounds: ~A" dimension)))    ((%twod-array-p array)     (case dimension (0 (|ffetch| (twod-array bound0) |of| array))           (1 (|ffetch| (twod-array bound1) |of| array))           (cl:otherwise (cl:error "Dimension out of bounds: ~A" dimension))))    ((%general-array-p array)     (let* ((dims (|ffetch| (general-array dims) |of| array))            (rank (length dims)))           (cl:if (not (< -1 dimension rank))                  (cl:error "Dimension out of bounds: ~A" dimension))           (cl:if (eql rank 1)                  (|fetch| (array-header total-size) |of| array)                  (cl:nth dimension dims))))    ((stringp array)                                         (* "Hack to handle IL:STRINGP's")     (cl:if (eql dimension 0)            (nchars array)            (cl:error "Dimension out of bounds: ~A" dimension)))    (t (cl:error "Not an array ~S" array))))(cl:defun cl:array-dimensions (array)                        (* |jop:| " 5-Sep-86 12:55")                    (* *)   (cond      ((%oned-array-p array)       (list (|ffetch| (oned-array total-size) |of| array)))      ((%twod-array-p array)       (list (|ffetch| (twod-array bound0) |of| array)             (|ffetch| (twod-array bound1) |of| array)))      ((%general-array-p array)       (|ffetch| (general-array dims) |of| array))      ((stringp array)                                       (* "Hack to handle IL:STRINGP's")       (list (nchars array)))      (t (cl:error "Not an array ~S" array))))(cl:defun cl:array-element-type (array)                     (* *) (cond    ((%arrayp array)     (%typenumber-to-cml-type (%array-type-number array)))    ((stringp array)                                         (* "Hack to handle IL:STRINGP's")     'cl:string-char)    (t (cl:error "Not an array ~S" array))))(cl:defun cl:array-has-fill-pointer-p (array)                     (* *) (cond    ((%arrayp array)     (|fetch| (array-header fill-pointer-p) |of| array))    ((stringp array)                                         (* "Hack to handle IL:STRINGP's")     nil)    (t (cl:error "Not an array ~S" array))))(cl:defun array-needs-indirection-p (array)                     (* *) (cond    ((or (%oned-array-p array)         (%twod-array-p array)         (stringp array))     nil)    ((%general-array-p array)     (|fetch| (array-header indirect-p) |of| array))    (t (cl:error "Not an array ~S" array))))(cl:defun cl:array-rank (array)                     (* *) (cond    ((%oned-array-p array)     1)    ((%twod-array-p array)     2)    ((%general-array-p array)     (length (|ffetch| (general-array dims) |of| array)))    ((stringp array)                                         (* "Hack to handle IL:STRINGP's")     1)    (t (cl:error "Not an array ~S" array))))(cl:defun cl:array-total-size (array)                     (* *) (cond    ((%arrayp array)     (|fetch| (array-header total-size) |of| array))    ((stringp array)                                         (* "Hack to handle IL:STRINGP's")     (nchars array))    (t (cl:error "Not an array ~S" array))))(cl:defun bit (bit-array &rest indices) (cl:assert (typep bit-array '(cl:array bit))                                               (bit-array)                                               "Not a bit-array: ~S" bit-array)                                        (cl:apply (function cl:aref)                                               bit-array indices))(cl:defun cl:bit-and (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op and bit-array1 bit-array2 bit-result))(cl:defun cl:bit-andc1 (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op andc1 bit-array1 bit-array2 bit-result))(cl:defun cl:bit-andc2 (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op andc2 bit-array1 bit-array2 bit-result))(cl:defun bit-array-p (array) (and (%arrayp array)                                   (|fetch| (array-header bit-p) |of| array)))(cl:defun cl:bit-eqv (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op eqv bit-array1 bit-array2 bit-result))(cl:defun cl:bit-ior (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op ior bit-array1 bit-array2 bit-result))(cl:defun cl:bit-nand (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op nand bit-array1 bit-array2 bit-result))(cl:defun cl:bit-nor (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op nor bit-array1 bit-array2 bit-result))(cl:defun cl:bit-not (bit-array &optional result-bit-array)  (* |jop:| " 9-Sep-86 17:05")                    (* *)   (cl:if (not (bit-array-p bit-array))          (cl:error "BIT-ARRAY not a bit array"))   (cond      ((null result-bit-array)       (setq result-bit-array (cl:make-array (cl:array-dimensions bit-array)                                     :element-type                                     'bit)))      ((eq result-bit-array t)       (setq result-bit-array bit-array))      ((not (and (bit-array-p result-bit-array)                 (equal-dimensions-p bit-array result-bit-array)))       (cl:error "Illegal result array")))   (%do-logical-op 'not bit-array result-bit-array)   result-bit-array)(cl:defun cl:bit-orc1 (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op orc1 bit-array1 bit-array2 bit-result))(cl:defun cl:bit-orc2 (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op orc2 bit-array1 bit-array2 bit-result))(cl:defun cl:bit-vector-p (cl:vector)                     (* *) (and (%vectorp cl:vector)      (|fetch| (array-header bit-p) |of| cl:vector)))(cl:defun cl:bit-xor (bit-array1 bit-array2 &optional bit-result)                     (* *) (%expand-bit-op xor bit-array1 bit-array2 bit-result))(cl:defun char (string index) (cl:assert (typep string 'string)                                     (string)                                     "Not a string: ~S" string)                              (cl:aref string index))(cl:defun cl:arrayp (array)                                  (* |jop:| " 5-Sep-86 12:53")                    (* *)   (and (or (%arrayp array)            (stringp array))        t))(cl:defun cl:stringp (string) (and (or (%stringp string)                                       (stringp string))                                   t))(cl:defun copy-array (from-array &optional to-array) (cl:if (not (%arrayp from-array))                                                            (cl:error "Not an array: ~S" from-array))                                                     (cond                                                        ((null to-array)                                                         (setq to-array (cl:make-array (                                                                                  cl:array-dimensions                                                                                        from-array)                                                                               :element-type                                                                               (cl:array-element-type                                                                                from-array)                                                                               :fatp                                                                               (%fat-string-array-p                                                                                from-array))))                                                        ((not (equal-dimensions-p from-array to-array                                                                     ))                                                         (cl:error "Dimensionality mismatch")))                                                     (cl:if (|fetch| (array-header read-only-p)                                                               |of| to-array)                                                            (%make-array-writeable to-array))                                                     (let ((from-type-number (%array-type-number                                                                              from-array))                                                           (to-type-number (%array-type-number                                                                                   to-array)))                                                          (cl:when (and (%fat-char-type-p                                                                                from-type-number)                                                                        (%thin-char-type-p                                                                                to-type-number))                                                                 (%make-string-array-fat to-array)                                                                 (setq to-type-number (                                                                                   %array-type-number                                                                                       to-array)))                                                          (cl:if (not (eq from-type-number                                                                           to-type-number))                                                                 (cl:error                                                                  "Arrays have different type numbers"                                                                        ))                                                          (%fast-copy-base (%array-base from-array)                                                                 (%array-offset from-array)                                                                 (%array-base to-array)                                                                 (%array-offset to-array)                                                                 (|fetch| (array-header total-size)                                                                    |of| from-array)                                                                 from-type-number)                                                          to-array))(cl:defun displaced-array-p (array)                     (* *) (cond    ((%arrayp array)     (|fetch| (array-header displaced-p) |of| array))    ((stringp array)     nil)    (t (cl:error "Not an array ~S" array))))(cl:defun equal-dimensions-p (array-1 array-2)   (cond      ((%oned-array-p array-1)       (cond          ((%oned-array-p array-2)           (eql (|fetch| (array-header total-size) |of| array-1)                (|fetch| (array-header total-size) |of| array-2)))          ((%twod-array-p array-2)           nil)          ((%general-array-p array-2)           (and (eq 1 (length (|ffetch| (general-array dims) |of| array-2)))                (eql (|fetch| (array-header total-size) |of| array-1)                     (|fetch| (array-header total-size) |of| array-2))))          (t nil)))      ((%twod-array-p array-1)       (cond          ((%oned-array-p array-2)           nil)          ((%twod-array-p array-2)           (and (eql (|ffetch| (twod-array bound0) |of| array-1)                     (|ffetch| (twod-array bound0) |of| array-2))                (eql (|ffetch| (twod-array bound1) |of| array-1)                     (|ffetch| (twod-array bound1) |of| array-2))))          ((%general-array-p array-2)           (let ((dims (|ffetch| (general-array dims) |of| array-2)))                (and (eq 2 (length dims))                     (and (eql (|ffetch| (twod-array bound0) |of| array-1)                               (car dims))                          (eql (|ffetch| (twod-array bound1) |of| array-1)                               (cadr dims))))))          (t nil)))      ((%general-array-p array-1)       (let ((dims (|ffetch| (general-array dims) |of| array-1)))            (cond               ((%oned-array-p array-2)                (and (eq 1 (length dims))                     (eql (|fetch| (array-header total-size) |of| array-1)                          (|fetch| (array-header total-size) |of| array-2))))               ((%twod-array-p array-2)                (and (eq 2 (length dims))                     (and (eql (car dims)                               (|ffetch| (twod-array bound0) |of| array-2))                          (eql (cadr dims)                               (|ffetch| (twod-array bound1) |of| array-2)))))               ((%general-array-p array-2)                (equal dims (|ffetch| (general-array dims) |of| array-2)))               (t nil))))      (t nil)))(cl:defun extendable-array-p (array)                     (* *) (cond    ((%arrayp array)     (|fetch| (array-header extendable-p) |of| array))    ((stringp array)     nil)    (t (cl:error "Not an array ~S" array))))(cl:defun fill-array (array value) (cl:if (not (%arrayp array))                                          (cl:error "Not an array: ~S" array))                                   (let ((total-size (|fetch| (array-header total-size) |of| array))                                         (type-number (%array-type-number array)))                                        (cl:if (|fetch| (array-header read-only-p) |of| array)                                               (%make-array-writeable array))                                        (cl:when (> total-size 0)                                               (cl:when (and (%thin-char-type-p type-number)                                                             (%fat-string-char-p value))                                                      (%make-string-array-fat array)                                                      (setq type-number (%array-type-number array)))                                               (cl:if (not (%llarray-typep type-number value))                                                      (cl:error                                                          "Value of incorrect type for this array: ~S"                                                              value))                                               (let ((base (%array-base array))                                                     (offset (%array-offset array)))                                                             (* "Start things off")                                                    (%array-write value base type-number offset)                                                             (* "An overlapping blt")                                                    (%fast-copy-base base offset base (cl:1+ offset)                                                           (cl:1- total-size)                                                           type-number)))                                        array))(cl:defun cl:fill-pointer (cl:vector)                     (* *) (cond    ((and (or (%oned-array-p cl:vector)              (%general-array-p cl:vector))          (|fetch| (array-header fill-pointer-p) |of| cl:vector))     (|fetch| (array-header cl:fill-pointer) |of| cl:vector))    ((or (%vectorp cl:vector)         (stringp cl:vector))     (cl:error "vector has no fill pointer"))    (t (cl:error "Not a vector ~S" cl:vector))))(cl:defun fill-vector (cl:vector value &key (start 0)                             end) (cl:if (not (%vectorp cl:vector))                                         (cl:error "Not a vector: ~S" cl:vector))                                  (cl:if (< start 0)                                         (cl:error "Invalid :start arg: ~S" start))                                  (cond                                     ((null end)                                      (setq end (|fetch| (array-header total-size) |of| cl:vector)))                                     ((not (<= 0 end (|fetch| (array-header total-size) |of|                                                                                             cl:vector                                                            )))                                      (cl:error "Invalid :end arg: ~S" end)))                                  (let ((cnt (- end start))                                        (type-number (%array-type-number cl:vector)))                                       (cl:if (|fetch| (array-header read-only-p) |of| cl:vector)                                              (%make-array-writeable cl:vector))                                       (cl:when (> cnt 0)                                              (cl:when (and (%thin-char-type-p type-number)                                                            (%fat-string-char-p value))                                                     (%make-string-array-fat cl:vector)                                                     (setq type-number (%array-type-number cl:vector)                                                      ))                                              (cl:if (not (%llarray-typep type-number value))                                                     (cl:error                                                          "Value of incorrect type for this array: ~S"                                                             value))                                              (let ((base (%array-base cl:vector))                                                    (offset (+ start (%array-offset cl:vector))))                                                             (* "Start things off")                                                   (%array-write value base type-number offset)                                                             (* "An overlapping blt")                                                   (%fast-copy-base base offset base (cl:1+ offset)                                                          (cl:1- cnt)                                                          type-number)))                                       cl:vector))(cl:defun cl:make-array (dimensions &key (element-type t)                               (initial-element nil initial-element-p)                               (initial-contents nil initial-contents-p)                               (displaced-to nil displaced-to-p)                               (displaced-to-base nil displaced-to-base-p)                               (displaced-index-offset 0 displaced-index-offset-p)                               cl:fill-pointer adjustable extendable fatp read-only-p)                                                          "Make an array following the key word specs"                    (* * "String are by default thin unless FATP is T. DISPLACED-TO-BASE indicates displacement to a raw storage block. READ-ONLY-P indicates a read only array")   (cl:if (not (cl:listp dimensions))          (setq dimensions (list dimensions)))   (cl:if (cl:dolist (dim dimensions nil)                 (cl:if (or (< dim 0)                            (>= dim cl:array-dimension-limit))                        (return t)))          (cl:error "Dimensions out of bounds ~S" dimensions))   (let ((rank (length dimensions))         (nelts (%total-size dimensions))         array)                    (* * "Consistency checks")        (cl:if (>= rank cl:array-rank-limit)               (cl:error "Too many dimensions: ~A" rank))        (cl:if (>= nelts cl:array-total-size-limit)               (cl:error "Too many elements: ~A" nelts))        (cl:if (or (and displaced-to-p (or initial-element-p initial-contents-p displaced-to-base-p))                   (and displaced-to-base-p (or initial-element-p initial-contents-p displaced-to-p))                   (and cl:fill-pointer (not (eql rank 1)))                   (and displaced-index-offset-p (not (or displaced-to-p displaced-to-base-p)))                   (and initial-element-p initial-contents-p)                   (and adjustable extendable)                   (and read-only-p (or extendable adjustable)))               (cl:error "Inconsistent options to make-array"))        (cl:if displaced-to-p (cond                                 ((not (%arrayp displaced-to))                                  (cl:error "Cannot displace to an Interlisp array/string"))                                 ((not (equal (%get-canonical-cml-type element-type)                                              (cl:array-element-type displaced-to)))                                  (cl:error "Not displaced to an array of the same element-type"))                                 ((> (+ displaced-index-offset nelts)                                     (cl:array-total-size displaced-to))                                  (cl:error "displaced array out of bounds"))))        (cl:if cl:fill-pointer (cond                                  ((eq cl:fill-pointer t)                                   (setq cl:fill-pointer nelts))                                  ((not (and (>= cl:fill-pointer 0)                                             (<= cl:fill-pointer nelts)))                                   (cl:error "Fill pointer out of bounds ~A" cl:fill-pointer))))                    (* * "Specs ready, make the array by case")        (setq array (cond                       (displaced-to-p (%make-displaced-array nelts dimensions element-type                                               displaced-to displaced-index-offset cl:fill-pointer                                               read-only-p adjustable extendable))                       (displaced-to-base (cl:if (or (> rank 1)                                                     adjustable)                                                 (%make-general-array nelts dimensions element-type                                                         cl:fill-pointer fatp read-only-p adjustable                                                         extendable displaced-to-base                                                         displaced-index-offset)                                                 (%make-oned-array nelts element-type cl:fill-pointer                                                         fatp read-only-p extendable displaced-to-base                                                         displaced-index-offset)))                       ((and (eq rank 1)                             (not adjustable))                        (%make-oned-array nelts element-type cl:fill-pointer fatp read-only-p                                extendable))                       ((and (eq rank 2)                             (not adjustable))                        (%make-twod-array nelts dimensions element-type fatp read-only-p extendable))                       (t (%make-general-array nelts dimensions element-type cl:fill-pointer fatp                                  read-only-p adjustable extendable))))                    (* * "Initialize the storage")        (cond           (initial-contents-p (%array-content-initialize array initial-contents))           (initial-element-p (%array-element-initialize array initial-element)))                    (* * "Return the array")        array))(cl:defun make-vector (size &key (element-type t)                            (initial-element nil initial-element-p)                            fatp) "Make a vector" (cl:if (or (< size 0)                                                             (>= size cl:array-total-size-limit))                                                         (cl:error "Size out of bounds: ~A" size))                                                  (let ((cl:vector (%make-oned-array size                                                                           element-type nil fatp)))                                                       (cl:if initial-element-p (fill-array cl:vector                                                                                       initial-element                                                                                       ))                                                       cl:vector))(cl:defun read-only-array-p (array)                     (* *) (cond    ((%arrayp array)     (|fetch| (array-header read-only-p) |of| array))    ((stringp array)     nil)    (t (cl:error "Not an array ~S" array))))(cl:defun cl:sbit (simple-bit-array &rest indices) (cl:assert (typep simple-bit-array                                                                     '(cl:simple-array bit))                                                          (simple-bit-array)                                                          "Not a bit-array: ~S" simple-bit-array)                                                   (cl:apply (function cl:aref)                                                          simple-bit-array indices))(cl:defun cl:schar (cl:simple-string index) (cl:assert (typep cl:simple-string 'cl:simple-string)                                                   (cl:simple-string)                                                   "Not a simple-string: ~S" cl:simple-string)                                            (cl:aref cl:simple-string index))(cl:defun set-fill-pointer (cl:vector newvalue)              (* |jop:| " 5-Sep-86 12:55")                    (* *)   (cond      ((and (or (%oned-array-p cl:vector)                (%general-array-p cl:vector))            (|fetch| (array-header fill-pointer-p) |of| cl:vector))       (cl:if (not (<= 0 newvalue (|fetch| (array-header total-size) |of| cl:vector)))              (cl:error "Fill pointer out of bounds: ~A" newvalue))       (|replace| (array-header cl:fill-pointer) |of| cl:vector |with| newvalue)       newvalue)      ((or (%vectorp cl:vector)           (stringp cl:vector))       (cl:error "Vector has no fill pointer"))      (t (cl:error "Not a vector ~S" cl:vector))))(cl:defun simple-array-p (array)                     (* *) (and (or (%simple-array-p array)          (stringp array))      t))(cl:defun cl:simple-bit-vector-p (cl:vector)                     (* *) (and (%oned-array-p cl:vector)      (|fetch| (array-header simple-p) |of| cl:vector)      (|fetch| (array-header bit-p) |of| cl:vector)))(cl:defun cl:simple-string-p (string)                     (* *) (and (or (%simple-string-p string)          (stringp string))      t))(cl:defun cl:simple-vector-p (cl:vector)                     (* |jop:| " 5-Sep-86 12:54")                    (* *)   (and (%oned-array-p cl:vector)        (|fetch| (array-header simple-p) |of| cl:vector)        (eq (cl:array-element-type cl:vector)            t)))(cl:defun string-array-p (array)                     (* *) (%char-type-p (%array-type-number array)))(cl:defun cl:svref (cl:simple-vector index) (cl:assert (typep cl:simple-vector 'cl:simple-vector)                                                   (cl:simple-vector)                                                   "Not a simple-vector: ~S" cl:simple-vector)                                            (cl:aref cl:simple-vector index))(cl:defun vector-length (cl:vector)                          (* |jop:| " 5-Sep-86 12:55")   (cond      ((%vectorp cl:vector)       (|fetch| (array-header cl:fill-pointer) |of| cl:vector))      ((stringp cl:vector)       (nchars cl:vector))      (t (cl:error "Not a vector: ~s" cl:vector))))(cl:defun cl:vector-pop (cl:vector)                          (* |jop:| " 5-Sep-86 12:55")                    (* *)   (cond      ((and (or (%oned-array-p cl:vector)                (%general-array-p cl:vector))            (|fetch| (array-header fill-pointer-p) |of| cl:vector))       (let ((cl:fill-pointer (|fetch| (array-header cl:fill-pointer) |of| cl:vector)))            (cl:if (<= cl:fill-pointer 0)                   (cl:error "Can't pop from zero fill pointer"))            (setq cl:fill-pointer (cl:1- cl:fill-pointer))            (|replace| (array-header cl:fill-pointer) |of| cl:vector |with| cl:fill-pointer)            (cl:aref cl:vector cl:fill-pointer)))      ((or (%vectorp cl:vector)           (stringp cl:vector))       (cl:error "Vector has no fill pointer"))      (t (cl:error "Not a vector ~S" cl:vector))))(cl:defun cl:vector-push (new-element cl:vector)             (* |jop:| " 5-Sep-86 12:55")                    (* *)   (cond      ((and (or (%oned-array-p cl:vector)                (%general-array-p cl:vector))            (|fetch| (array-header fill-pointer-p) |of| cl:vector))       (let ((cl:fill-pointer (|fetch| (array-header cl:fill-pointer) |of| cl:vector)))            (cl:when (< cl:fill-pointer (|fetch| (array-header total-size) |of| cl:vector))                   (aset new-element cl:vector cl:fill-pointer)                   (|replace| (array-header cl:fill-pointer) |of| cl:vector |with| (cl:1+                                                                                       cl:fill-pointer                                                                                          ))                   cl:fill-pointer)))      ((or (%vectorp cl:vector)           (stringp cl:vector))       (cl:error "Vector has no fill pointer"))      (t (cl:error "Not a vector ~S" cl:vector))))(cl:defun cl:vector-push-extend (new-element cl:vector &optional (extension-size                                                                         *default-push-extension-size*                                                                        )) "Like VECTOR-PUSH except if VECTOR is adjustable -- in which case a push beyond (array-total-size VECTOR ) will call adjust-array"   (let ((new-index (cl:vector-push new-element cl:vector)))        (cl:if (null new-index)               (cond                  ((> extension-size 0)                   (cl:adjust-array cl:vector (+ (cl:array-total-size cl:vector)                                                 extension-size))                   (cl:vector-push new-element cl:vector))                  (t (cl:error "Extension-size not greater than zero")))               new-index)))(cl:defun cl:vectorp (cl:vector)                             (* |jop:| " 5-Sep-86 12:55")                    (* *)   (and (or (%vectorp cl:vector)            (stringp cl:vector))        t))(defineq(%copy-to-new-array  (lambda (old-dims old-array old-offset new-dims new-array new-offset)                                                             (* |jop:| "21-Sep-86 16:55")                    (* * "It is assumed that OLD-ARRAY and NEW-ARRAY are of the same rank")    (let ((size (min (car old-dims)                     (car new-dims))))         (cl:if (cdr old-dims)                (cl:dotimes (i size)                       (%copy-to-new-array (cdr old-dims)                              old-array                              (cl:* (cadr old-dims)                                    (+ old-offset i))                              (cdr new-dims)                              new-array                              (cl:* (cadr new-dims)                                    (+ new-offset i))))                (let ((old-type-number (%array-type-number old-array))                      (new-type-number (%array-type-number new-array)))                                                             (*                                       "Can only do a fast copy when arrays have the same type number")                     (cl:if (eq old-type-number new-type-number)                            (%fast-copy-base (%array-base old-array)                                   old-offset                                   (%array-base new-array)                                   new-offset size old-type-number)                            (cl:error "Arrays have differing type numbers")))))))(cl:aref  (lambda args                                               (* |jop:| "21-Sep-86 15:00")                    (* *)    (cl:if (< args 1)           (cl:error "Aref takes at least one arg"))    (let ((array (arg args 1)))         (case args (1 (%aref0 array))               (2 (%aref1 array (arg args 2)))               (3 (%aref2 array (arg args 2)                         (arg args 3)))               (cl:otherwise (cond                                ((not (%arrayp array))                                 (cl:error "Not an array ~S" array))                                ((not (eql (cl:array-rank array)                                           (cl:1- args)))                                 (cl:error "Rank mismatch"))                                (t                     (* * "If we've gotten this far ARRAY must be a general array")                                                             (* "Check indices in bounds")                                   (cl:do ((i 2 (cl:1+ i))                                           (dimlist (|ffetch| (general-array dims) |of| array)                                                  (cdr dimlist))                                           index)                                          ((> i args))                                          (setq index (arg args i))                                          (cl:if (not (and (>= index 0)                                                           (< index (car dimlist))))                                                 (cl:error "Index out of bounds: ~A" index)))                                                             (* "Now proceed to extract the element")                                   (let ((row-major-index (cl:do ((i 2 (cl:1+ i))                                                                  (dimlist (cdr (|ffetch|                                                                                 (general-array                                                                                  dims) |of| array))                                                                         (cdr dimlist))                                                                  (total 0))                                                                 ((eql i args)                                                                  (+ total (arg args args)))                                                                 (setq total                                                                  (cl:* (car dimlist)                                                                        (+ total (arg args i))))))                                         (base-array array))                                        (%general-array-adjust-base base-array row-major-index)                                        (%array-read (|fetch| (array-header base) |of| base-array)                                               (|fetch| (array-header type-number) |of| base-array)                                               (+ (%get-array-offset base-array)                                                  row-major-index))))))))))(cl:array-in-bounds-p  (lambda args                                               (* |jop:| " 5-Sep-86 11:22")                    (* *)    (cl:if (< args 1)           (cl:error "Array-in-bounds-p takes at least one arg"))    (let ((array (arg args 1)))         (cond            ((not (cl:arrayp array))             (cl:error "Not an array ~S" array))            ((not (eql (cl:array-rank array)                       (cl:1- args)))             (cl:error "Rank mismatch"))            (t (%check-indices array 2 args))))))(cl:array-row-major-index  (lambda args                                               (* |jop:| " 5-Sep-86 11:23")                    (* *)    (cl:if (< args 1)           (cl:error "Array-row-major-index takes at least one arg"))    (let* ((array (arg args 1))           (rank (cl:array-rank array)))          (cond             ((not (eql rank (cl:1- args)))              (cl:error "Rank mismatch"))             ((not (%check-indices array 2 args))              (cl:error "Index out of bounds"))             (t (cl:do ((i 2 (cl:1+ i))                        (total 0))                       ((eql i args)                        (+ total (arg args args)))                       (setq total (cl:* (cl:array-dimension array (cl:1- i))                                         (+ total (arg args i))))))))))(aset  (lambda args                                               (* |jop:| "21-Sep-86 18:57")                    (* *)    (cl:if (< args 2)           (cl:error "Aset takes at least two args"))    (let ((newvalue (arg args 1))          (array (arg args 2)))         (case args (2 (%aset0 newvalue array))               (3 (%aset1 newvalue array (arg args 3)))               (4 (%aset2 newvalue array (arg args 3)                         (arg args 4)))               (cl:otherwise (cond                                ((not (%arrayp array))                                 (cl:error "Not an array ~S" array))                                ((not (eql (cl:array-rank array)                                           (- args 2)))                                 (cl:error "Rank mismatch"))                                (t                           (*                                              "If we've gotten this far array must be a general array")                                                             (* "Check indices")                                   (cl:do ((i 3 (cl:1+ i))                                           (dimlist (|ffetch| (general-array dims) |of| array)                                                  (cdr dimlist))                                           index)                                          ((> i args))                                          (setq index (arg args i))                                          (cl:if (not (< -1 index (car dimlist)))                                                 (cl:error "Index out of bounds: ~A" index)))                                                             (* "Now proceed to extract the element")                                   (let ((row-major-index (cl:do ((i 3 (cl:1+ i))                                                                  (dimlist (cdr (|ffetch|                                                                                 (general-array                                                                                  dims) |of| array))                                                                         (cdr dimlist))                                                                  (total 0))                                                                 ((eql i args)                                                                  (+ total (arg args args)))                                                                 (setq total                                                                  (cl:* (car dimlist)                                                                        (+ total (arg args i))))))                                         (base-array array))                                        (%general-array-adjust-base base-array row-major-index)                                        (let ((type-number (|fetch| (array-header type-number)                                                              |of| base-array)))                                             (cl:if (%check-not-writeable array type-number newvalue)                                                    (cl:apply 'aset newvalue array                                                           (cl:do ((i args (cl:1- i))                                                                   lst)                                                                  ((< i 1)                                                                   lst)                                                                  (setq lst (cons (arg args i)                                                                                  lst))))                                                    (%array-write newvalue (|fetch| (array-header                                                                                     base)                                                                              |of| base-array)                                                           type-number                                                           (+ (%get-array-offset base-array)                                                              row-major-index))))))))))))(cl:vector  (lambda args                                               (* |jop:| " 4-Sep-86 22:59")                    (* *)    (let ((cl:vector (%make-oned-array args t)))         (cl:dotimes (i args)                (aset (arg args (cl:1+ i))                      cl:vector i))         cl:vector))))(* |;;| "Obsolete but retained to avoid recompilation")(defineq(scharset  (lambda (cl:simple-string index value)                     (* |jop:| "14-Aug-86 16:21")    (aset value (the cl:simple-string cl:simple-string)          index))))(* |;;| "Vars etc")(* \; "*PRINT-ARRAY* is defined in APRINT")(cl:defconstant cl:array-rank-limit (expt 2 7) )(cl:defconstant cl:array-total-size-limit 65534)(cl:defconstant cl:array-dimension-limit cl:array-total-size-limit)(cl:defparameter *default-push-extension-size* 20)(* |;;| "Internal stuff")(defineq(%alter-as-displaced-array  (lambda (adjustable-array dimensions displaced-to displaced-index-offset cl:fill-pointer)                                                             (* |jop:| "21-Sep-86 18:45")                    (* *    "Alter adjustable-array to be displaced to displaced-to. ADJUSTABLE-ARRAY must ba a general array")    (cl:if (null displaced-index-offset)           (setq displaced-index-offset 0))    (let ((displaced-to-read-only-p (|fetch| (array-header read-only-p) |of| displaced-to))          (total-size (%total-size dimensions))          (offset (or displaced-index-offset 0))          base need-indirection-p)         (cond            ((or (%thin-char-type-p (|fetch| (array-header type-number) |of| displaced-to))                 (|fetch| (array-header extendable-p) |of| displaced-to)                 (|fetch| (array-header adjustable-p) |of| displaced-to)                 (and displaced-to-read-only-p (not (|fetch| (array-header indirect-p) |of|                                                                                          displaced-to                                                           ))))                                                             (* "Provide for indirection")             (setq base displaced-to)             (setq need-indirection-p t))            (t                                               (*                                                     "Fold double displacement to single displacement")               (setq base (|fetch| (array-header base) |of| displaced-to))               (setq offset (+ offset (%get-array-offset displaced-to)))               (cl:if (|fetch| (array-header indirect-p) |of| displaced-to)                      (setq need-indirection-p t))))         (*                                           "Don't need to touch the type-number since it can't change")         (uninterruptably             (|freplace| (general-array storage) |of| adjustable-array |with| base)             (|freplace| (general-array read-only-p) |of| adjustable-array |with|                                                                              displaced-to-read-only-p                    )             (|freplace| (general-array indirect-p) |of| adjustable-array |with| need-indirection-p)             (|freplace| (general-array displaced-p) |of| adjustable-array |with| t)             (|freplace| (general-array fill-pointer-p) |of| adjustable-array |with| cl:fill-pointer)             (|freplace| (general-array offset) |of| adjustable-array |with| offset)             (|freplace| (general-array cl:fill-pointer) |of| adjustable-array                |with| (or cl:fill-pointer total-size))             (|freplace| (general-array total-size) |of| adjustable-array |with| total-size)             (|freplace| (general-array dims) |of| adjustable-array |with| dimensions))         adjustable-array)))(%alter-as-displaced-to-base-array  (lambda (adjustable-array dimensions element-type displaced-to-base displaced-index-offset                  cl:fill-pointer fatp)                       (* |jop:| "21-Sep-86 17:01")                    (* * "Alter adjustable-array to be displaced to displaced-to-base ")    (let ((total-size (%total-size dimensions))          (type-number (%cml-type-to-typenumber element-type fatp)))         (uninterruptably             (|freplace| (general-array storage) |of| adjustable-array |with| displaced-to-base)             (|freplace| (general-array indirect-p) |of| adjustable-array |with| nil)             (|freplace| (general-array displaced-p) |of| adjustable-array |with| t)             (|freplace| (general-array fill-pointer-p) |of| adjustable-array |with| cl:fill-pointer)             (|freplace| (general-array type-number) |of| adjustable-array |with| type-number)             (|freplace| (general-array offset) |of| adjustable-array |with| (or                                                                                displaced-index-offset                                                                                  0))             (|freplace| (general-array cl:fill-pointer) |of| adjustable-array                |with| (or cl:fill-pointer total-size))             (|freplace| (general-array total-size) |of| adjustable-array |with| total-size)             (|freplace| (general-array dims) |of| adjustable-array |with| dimensions))         adjustable-array)))(%aref0  (lambda (array)                                            (* |jop:| "21-Sep-86 15:09")                    (* *)    (cond       ((not (%arrayp array))        (cl:error "Not an array ~S" array))       ((not (eql (cl:array-rank array)                  0))        (cl:error "Rank mismatch"))       (t (* * "Must be a general array")          (let ((index 0)                (base-array array))               (%general-array-adjust-base base-array index)               (%array-read (|fetch| (array-header base) |of| base-array)                      (|fetch| (array-header type-number) |of| base-array)                      (+ (%get-array-offset base-array)                         index)))))))(%aref1  (lambda (array index)                                      (* |jop:| "21-Sep-86 19:26")                    (* *)    (cond       ((not (%arrayp array))                                (* "Hack to handle IL:STRINGP's")        (cl:if (stringp array)               (cl:code-char (nthcharcode array (cl:1+ index)))               (cl:error "Not an array ~S" array)))       ((not (eql (cl:array-rank array)                  1))        (cl:error "Rank mismatch"))       ((not (and (>= index 0)                  (< index (|fetch| (array-header total-size) |of| array))))        (cl:error "Index out of bounds: ~A" index))       (t (* * "Now proceed to extract the element")          (let ((base-array array))               (cl:if (|ffetch| (general-array indirect-p) |of| base-array)                      (%general-array-adjust-base base-array index))               (%array-read (|fetch| (array-header base) |of| base-array)                      (|fetch| (array-header type-number) |of| base-array)                      (+ (%get-array-offset base-array)                         index)))))))(%aref2  (lambda (array i j)                                        (* |jop:| "21-Sep-86 15:11")                    (* *)    (cond       ((not (%arrayp array))        (cl:error "Not an array ~S" array))       ((not (eql (cl:array-rank array)                  2))        (cl:error "Rank mismatch"))       (t (* * "If we get here ARRAY must be twod or general")          (let (bound0 bound1 offset)                        (* "Get bounds and offset")               (cond                  ((%twod-array-p array)                     (* "Twod array case")                   (setq bound0 (|ffetch| (twod-array bound0) |of| array))                   (setq bound1 (|ffetch| (twod-array bound1) |of| array))                   (setq offset 0))                  (t                                         (* "General array case")                     (setq bound0 (car (|ffetch| (general-array dims) |of| array)))                     (setq bound1 (cadr (|ffetch| (general-array dims) |of| array)))                     (setq offset (|ffetch| (general-array offset) |of| array))))                                                             (* "Check indices")               (cond                  ((not (and (>= i 0)                             (< i bound0)))                   (cl:error "Index out of bounds: ~A" i))                  ((not (and (>= j 0)                             (< j bound1)))                   (cl:error "Index out of bounds: ~A" j)))  (* "Extract the element")               (let ((row-major-index (+ j (cl:* bound1 i)))                     (base-array array))                    (%general-array-adjust-base base-array row-major-index)                    (%array-read (|fetch| (array-header base) |of| base-array)                           (|fetch| (array-header type-number) |of| base-array)                           (+ (%get-array-offset base-array)                              row-major-index))))))))(%array-base  (lambda (array)                                            (* |jop:| "21-Sep-86 13:13")                    (* * "Get the raw offset for ARRAY")    (cond       ((or (%oned-array-p array)            (%twod-array-p array))        (|fetch| (array-header base) |of| array))       ((%general-array-p array)        (|fetch| (array-header base) |of| (cl:loop (cl:if (not (|fetch| (array-header indirect-p)                                                                  |of| array))                                                          (return array))                                                 (setq array (|fetch| (array-header base)                                                                |of| array)))))       (t (cl:error "Not an array ~S" array)))))(%array-content-initialize  (lambda (array initial-contents)                           (* |jop:| "18-Sep-86 21:37")    (cl:if (eql 0 (cl:array-rank array))           (%array-element-initialize array initial-contents)           (let ((dims (cl:array-dimensions array)))                (cl:if (%check-sequence-dimensions dims initial-contents)                       (%fill-array-from-sequence dims initial-contents (%flatten-array array)                              0)                       (cl:error "Dimensionality mismatch for INITIAL-CONTENTS"))))))(%array-element-initialize  (lambda (array initial-element)                            (* |jop:| "21-Sep-86 15:40")                    (* * "Initialize an array with a value")    (cl:unless (eql initial-element (%typenumber-to-default-value (%array-type-number array)))           (fill-array array initial-element))))(%array-offset  (lambda (array)                                            (* |jop:| " 5-Sep-86 12:55")                    (* * "Get the raw offset for ARRAY")    (cond       ((%oned-array-p array)        (|fetch| (array-header offset) |of| array))       ((%twod-array-p array)        0)       ((%general-array-p array)        (cl:do ((offset (|fetch| (array-header offset) |of| array)                       (+ offset (%get-array-offset array))))               ((not (|fetch| (array-header indirect-p) |of| array))                offset)               (setq array (|fetch| (array-header base) |of| array))))       (t (cl:error "Not an array ~S" array)))))(%array-type-number  (lambda (array)                                            (* |jop:| "21-Sep-86 13:13")                    (* * "Get the raw offset for ARRAY")    (cond       ((or (%oned-array-p array)            (%twod-array-p array))        (|fetch| (array-header type-number) |of| array))       ((%general-array-p array)        (|fetch| (array-header type-number) |of| (cl:loop (cl:if (not (|fetch| (array-header                                                                                       indirect-p)                                                                         |of| array))                                                                 (return array))                                                        (setq array (|fetch| (array-header base)                                                                       |of| array)))))       (t (cl:error "Not an array ~S" array)))))(%aset0  (lambda (newvalue array)                                   (* |jop:| "21-Sep-86 18:57")                    (* *)    (cond       ((not (%arrayp array))        (cl:error "Not an array ~S" array))       ((not (eql (cl:array-rank array)                  0))        (cl:error "Rank mismatch"))       (t (* * "Must be a general array")          (let ((index 0)                (base-array array))               (%general-array-adjust-base base-array index)               (let ((type-number (|fetch| (array-header type-number) |of| base-array)))                    (cl:if (%check-not-writeable array type-number newvalue)                           (%aset0 newvalue array)                           (%array-write newvalue (|fetch| (array-header base) |of| base-array)                                  type-number                                  (+ (%get-array-offset base-array)                                     index)))))))))(%aset1  (lambda (newvalue array index)                             (* |jop:| "21-Sep-86 18:58")                    (* *)    (cond       ((not (%arrayp array))                                (* "Hack to handle IL:STRINGP's")        (cl:if (stringp array)               (progn (rplcharcode array (cl:1+ index)                             (cl:char-code newvalue))                      newvalue)               (cl:error "Not an array" array)))       ((not (eql (cl:array-rank array)                  1))        (cl:error "Rank mismatch"))       ((not (and (>= index 0)                  (< index (|fetch| (array-header total-size) |of| array))))        (cl:error "Index out of bounds: ~A" index))       (t (* * "Now proceed to extract the element")          (let ((row-major-index index)                (base-array array))               (%general-array-adjust-base base-array row-major-index)               (let ((type-number (|fetch| (array-header type-number) |of| base-array)))                    (cl:if (%check-not-writeable array type-number newvalue)                           (%aset1 newvalue array index)                           (%array-write newvalue (|fetch| (array-header base) |of| base-array)                                  type-number                                  (+ (%get-array-offset base-array)                                     row-major-index)))))))))(%aset2  (lambda (newvalue array i j)                               (* |jop:| "21-Sep-86 18:58")                    (* *)    (cond       ((not (%arrayp array))        (cl:error "Not an array ~S" array))       ((not (eql (cl:array-rank array)                  2))        (cl:error "Rank mismatch"))       (t (* * "If we get here ARRAY must be twod or general")          (let (bound0 bound1 offset)                        (* "Get bounds and offset")               (cond                  ((%twod-array-p array)                     (* "Twod case")                   (setq bound0 (|ffetch| (twod-array bound0) |of| array))                   (setq bound1 (|ffetch| (twod-array bound1) |of| array))                   (setq offset 0))                  (t                                         (* "General Case")                     (setq bound0 (car (|ffetch| (general-array dims) |of| array)))                     (setq bound1 (cadr (|ffetch| (general-array dims) |of| array)))                     (setq offset (|ffetch| (general-array offset) |of| array))))                                                             (* "Check indices")               (cond                  ((not (and (>= i 0)                             (< i bound0)))                   (cl:error "Index out of bounds ~A" i))                  ((not (and (>= j 0)                             (< j bound1)))                   (cl:error "Index out of bounds ~A" j)))               (let ((row-major-index (+ j (cl:* bound1 i)))                     (base-array array))                    (%general-array-adjust-base base-array row-major-index)                    (let ((type-number (|fetch| (array-header type-number) |of| base-array)))                         (cl:if (%check-not-writeable array type-number newvalue)                                (%aset2 newvalue array i j)                                (%array-write newvalue (|fetch| (array-header base) |of| base-array)                                       type-number                                       (+ (%get-array-offset base-array)                                          row-major-index))))))))))(%check-sequence-dimensions  (lambda (dim-lst sequence)                                 (* |jop:| "18-Sep-86 18:07")                    (* * "Returns NIL if there is a mismatch")    (cl:if (eql (car dim-lst)                (cl:length sequence))           (or (null (cdr dim-lst))               (cl:dotimes (i (car dim-lst)                              t)                      (cl:if (not (%check-sequence-dimensions (cdr dim-lst)                                         (cl:elt sequence i)))                             (return nil)))))))(%do-logical-op  (lambda (op source dest)                                   (* |jop:| " 4-Sep-86 23:09")                    (* *)    (let ((source-base (%array-base source))          (source-offset (%array-offset source))          (source-size (cl:array-total-size source))          (dest-base (%array-base dest))          (dest-offset (%array-offset dest))          (gbbt (deferredconstant (|create| pilotbbt                                         pbtheight _ 1                                         pbtdisjoint _ t)))          source-op log-op)         (uninterruptably             (|replace| (pilotbbt pbtsource) |of| gbbt |with| source-base)             (|replace| (pilotbbt pbtsourcebit) |of| gbbt |with| source-offset)             (|replace| (pilotbbt pbtdest) |of| gbbt |with| dest-base)             (|replace| (pilotbbt pbtdestbit) |of| gbbt |with| dest-offset)             (|replace| (pilotbbt pbtdestbpl) |of| gbbt |with| source-size)             (|replace| (pilotbbt pbtsourcebpl) |of| gbbt |with| source-size)             (|replace| (pilotbbt pbtwidth) |of| gbbt |with| source-size)             (case op (copy (setq source-op 0)                            (setq log-op 0))                   (not (setq source-op 1)                        (setq log-op 0))                   (and (setq source-op 0)                        (setq log-op 1))                   (cand (setq source-op 1)                         (setq log-op 1))                   (or (setq source-op 0)                       (setq log-op 2))                   (cor (setq source-op 1)                        (setq log-op 2))                   (xor (setq source-op 0)                        (setq log-op 3))                   (cxor (setq source-op 1)                         (setq log-op 3)))             (|replace| (pilotbbt pbtsourcetype) |of| gbbt |with| source-op)             (|replace| (pilotbbt pbtoperation) |of| gbbt |with| log-op)                                                             (* |Execute| |the| blt)             (\\pilotbitblt gbbt 0)             dest))))(%extend-array  (lambda (extendable-array new-array dimensions cl:fill-pointer)                                                             (* |jop:| "22-Sep-86 11:20")                    (* * "Extend ADJUSTABLE-ARRAY, using the base provided by NEW-ARRAY ")    (let ((type-number (|fetch| (array-header type-number) |of| new-array))          (total-size (%total-size dimensions))          (base (|fetch| (array-header base) |of| new-array)))         (uninterruptably             (|replace| (array-header base) |of| extendable-array |with| base)             (|replace| (array-header read-only-p) |of| extendable-array |with| nil)             (|replace| (array-header type-number) |of| extendable-array |with| type-number)             (|replace| (array-header total-size) |of| extendable-array |with| total-size)             (cond                ((%twod-array-p extendable-array)                 (|freplace| (twod-array bound0) |of| extendable-array |with| (car dimensions))                 (|freplace| (twod-array bound1) |of| extendable-array |with| (cadr dimensions)))                (t                                           (* "must be oned or general")                   (|replace| (array-header displaced-p) |of| extendable-array |with| nil)                   (|replace| (array-header fill-pointer-p) |of| extendable-array |with|                                                                                       cl:fill-pointer                          )                   (|replace| (array-header offset) |of| extendable-array |with| 0)                   (|replace| (array-header cl:fill-pointer) |of| extendable-array                      |with| (or cl:fill-pointer total-size))                   (cl:when (%general-array-p extendable-array)                          (|freplace| (general-array indirect-p) |of| extendable-array |with| nil)                          (|freplace| (general-array dims) |of| extendable-array |with| dimensions)))                ))         extendable-array)))(%fast-copy-base  (lambda (from-base from-offset to-base to-offset cnt type-number)                                                             (* |jop:| "17-Sep-86 12:40")                    (* * "Blts one array into another of the same element-type")    (let ((bits-per-element (%typenumber-to-bits-per-element type-number))          (gc-type (%typenumber-to-gc-type type-number)))         (cl:if (not (eq gc-type ptrblock.gct))                (let ((pbbt (deferredconstant (|create| pilotbbt                                                     pbtdisjoint _ t                                                     pbtsourcetype _ 0                                                     pbtoperation _ 0))))                    (* * "Uses \\PILOTBITBLT instead of \\BLT because offsets might not be word aligned, and BITS-PER-ELEMENT may be greater than BITSPERWORD (16).")                     (uninterruptably                         (|replace| (pilotbbt pbtsource) |of| pbbt |with| from-base)                         (|replace| (pilotbbt pbtsourcebit) |of| pbbt |with| (cl:* bits-per-element                                                                                    from-offset))                         (|replace| (pilotbbt pbtdest) |of| pbbt |with| to-base)                         (|replace| (pilotbbt pbtdestbit) |of| pbbt |with| (cl:* bits-per-element                                                                                  to-offset))                         (|replace| (pilotbbt pbtdestbpl) |of| pbbt |with| bits-per-element)                         (|replace| (pilotbbt pbtsourcebpl) |of| pbbt |with| bits-per-element)                         (|replace| (pilotbbt pbtwidth) |of| pbbt |with| bits-per-element)                         (|replace| (pilotbbt pbtheight) |of| pbbt |with| cnt)                         (\\pilotbitblt pbbt 0)))                (cl:do ((i from-offset (cl:1+ i))                        (limit (+ from-offset cnt))                        (j to-offset (cl:1+ j)))                       ((eql i limit))                       (%array-write (%array-read from-base type-number i)                              to-base type-number j)))         nil)))(%fat-string-array-p  (lambda (array)                                            (* |jop:| "21-Sep-86 13:30")                    (* *)    (%fat-char-type-p (%array-type-number array))))(%fill-array-from-sequence  (lambda (dims sequence flattened-array offset)             (* |jop:| "18-Sep-86 20:57")                    (* *)    (cl:if (cdr dims)           (cl:dotimes (i (car dims))                  (%fill-array-from-sequence (cdr dims)                         (cl:elt sequence i)                         flattened-array                         (cl:* (cadr dims)                               (+ offset i))))           (cl:do ((i 0 (cl:1+ i))                   (j offset (cl:1+ j))                   (limit (car dims)))                  ((eql i limit))                  (aset (cl:elt sequence i)                        flattened-array j)))))(%flatten-array  (lambda (array)                                            (* |jop:| " 4-Sep-86 22:28")                    (* *       "Make a oned-array that shares storage with array.  If array is already oned then return array")    (cl:if (eql 1 (cl:array-rank array))           array           (cl:make-array (cl:array-total-size array)                  :element-type                  (cl:array-element-type array)                  :displaced-to array))))(%make-array-writeable  (lambda (array)                                            (* |jop:| "23-Sep-86 21:10")    (cl:if (not (%arrayp array))           (cl:error "Not an array" array))    (let ((base-array array)          new-base offset total-size type-number)                    (* * "Find the base array")         (cl:if (|fetch| (array-header indirect-p) |of| array)                (cl:loop (cl:if (|fetch| (array-header indirect-p) |of| base-array)                                (setq base-array (|fetch| (array-header base) |of| base-array))                                (return nil))))         (cl:when (|fetch| (array-header read-only-p) |of| base-array)                    (* * "Allocate the new storage")                                                             (* "Be careful about offsets")                (setq total-size (|fetch| (array-header total-size) |of| base-array))                (setq offset (%get-array-offset base-array))                (setq type-number (|fetch| (array-header type-number) |of| base-array))                (setq new-base (%make-array-storage (+ total-size offset)                                      type-number))                    (* * "Initialize it")                (%fast-copy-base (|fetch| (array-header base) |of| base-array)                       offset new-base offset total-size type-number)                    (* * "Smash the new base into the array-header")                (uninterruptably                    (|replace| (array-header base) |of| base-array |with| new-base)                    (|replace| (array-header read-only-p) |of| base-array |with| nil)))                    (* * "Declare the array (and all arrays on its access chain) readable")         (uninterruptably             (cl:do ((next-array array (|fetch| (array-header base) |of| next-array)))                    ((not (|fetch| (array-header indirect-p) |of| next-array)))                    (|replace| (array-header read-only-p) |of| next-array |with| nil)))                    (* * "return the original array")         array)))(%make-displaced-array  (lambda (totalsize dimensions element-type displaced-to displaced-index-offset cl:fill-pointer                  read-only-p adjustable extendable)          (* |jop:| "21-Sep-86 18:39")                    (* * "Make a displaced array")    (let ((displaced-to-typenumber (|fetch| (array-header type-number) |of| displaced-to))          (displace-to-read-only-p (|fetch| (array-header read-only-p) |of| displaced-to))          (offset (or displaced-index-offset 0))          base need-indirection-p)         (cond            ((or (%thin-char-type-p displaced-to-typenumber)                 (|fetch| (array-header extendable-p) |of| displaced-to)                 (|fetch| (array-header adjustable-p) |of| displaced-to)                 (and displace-to-read-only-p (not (|fetch| (array-header indirect-p) |of|                                                                                          displaced-to                                                          ))))                                                             (* "Provide for indirection")             (setq base displaced-to)             (setq need-indirection-p t))            (t                                               (*                                                     "Fold double displacement to single displacement")               (setq base (|fetch| (array-header base) |of| displaced-to))               (setq offset (+ offset (%get-array-offset displaced-to)))               (cl:if (|fetch| (array-header indirect-p) |of| displaced-to)                      (setq need-indirection-p t))))         (cond            ((or need-indirection-p adjustable (> (length dimensions)                                                  1))        (*                                                   "Indirect strings always have %FAT-CHAR-TYPENUMBER")             (%make-general-array totalsize dimensions element-type cl:fill-pointer (%char-type-p                                                                                                                                                                   displaced-to-typenumber                                                                                     )                    (or read-only-p displace-to-read-only-p)                    adjustable extendable base offset))            (t (%make-oned-array totalsize element-type cl:fill-pointer (%fat-char-type-p                                                                               displaced-to-typenumber                                                                               )                      (or read-only-p displace-to-read-only-p)                      extendable base offset))))))(%make-general-array  (lambda (total-size dimensions element-type cl:fill-pointer fatp read-only-p adjustable-p                  extendable-p displaced-to displaced-index-offset)                                                             (* |jop:| "19-Sep-86 16:30")                    (* * "General arrays cover all make-array cases, including those requiring indirection.")    (let ((type-number (%cml-type-to-typenumber element-type fatp)))         (|create| general-array                storage _ (or displaced-to (%make-array-storage total-size type-number))                read-only-p _ read-only-p                indirect-p _ (%arrayp displaced-to)                bit-p _ (%bit-type-p type-number)                string-p _ (and (%char-type-p type-number)                                (eql 1 (length dimensions)))                adjustable-p _ adjustable-p                displaced-p _ displaced-to                fill-pointer-p _ cl:fill-pointer                extendable-p _ (or extendable-p adjustable-p)                type-number _ type-number                offset _ (or displaced-index-offset 0)                cl:fill-pointer _ (or cl:fill-pointer total-size)                total-size _ total-size                dims _ dimensions))))(%make-oned-array  (lambda (total-size element-type cl:fill-pointer fatp read-only-p extendable-p displaced-to                  displaced-index-offset)                     (* |jop:| " 5-Sep-86 14:15")                    (* * "Oned-arrays cover all one dimensional cases, except adjustable and displaced-to when indirection is necessary")    (let ((type-number (%cml-type-to-typenumber element-type fatp)))         (|create| oned-array                base _ (or displaced-to (%make-array-storage total-size type-number))                read-only-p _ read-only-p                bit-p _ (%bit-type-p type-number)                string-p _ (%char-type-p type-number)                displaced-p _ displaced-to                fill-pointer-p _ cl:fill-pointer                extendable-p _ extendable-p                type-number _ type-number                offset _ (or displaced-index-offset 0)                cl:fill-pointer _ (or cl:fill-pointer total-size)                total-size _ total-size))))(%make-string-array-fat  (lambda (array)                                            (* |jop:| "21-Sep-86 15:28")                    (* * "Like Adjust-array for the special case of Thin-string arrays")    (cl:if (not (%arrayp array))           (cl:error "Not an array" array))    (let ((base-array array)          new-base offset limit)                    (* * "Find the base array")         (cl:if (|fetch| (array-header indirect-p) |of| array)                (cl:loop (cl:if (|fetch| (array-header indirect-p) |of| base-array)                                (setq base-array (|fetch| (array-header base) |of| base-array))                                (return nil))))                    (* * "Consistency check")         (cl:if (not (%thin-char-type-p (|fetch| (array-header type-number) |of| base-array)))                (cl:error "Not a thin string-char array: ~S" base-array))                    (* * "Allocate the new storage")                                                             (* "Be careful about offsets")         (setq offset (%get-array-offset base-array))         (setq limit (+ (|fetch| (array-header total-size) |of| base-array)                        offset))         (setq new-base (%make-array-storage limit %fat-char-typenumber))                    (* * "Initialize it")                                                             (*                                     "Can't use %fast-copy-base because of the differing type numbers")         (cl:do ((i offset (cl:1+ i))                 (base-array-base (|fetch| (array-header base) |of| base-array)))                ((eql i limit))                (%array-write (%array-read base-array-base %thin-char-typenumber i)                       new-base %fat-char-typenumber i))                    (* * "Smash the new base into the array-header")         (uninterruptably             (|replace| (array-header base) |of| base-array |with| new-base)             (|replace| (array-header type-number) |of| base-array |with| %fat-char-typenumber))                    (* * "return the original array")         array)))(%make-twod-array  (lambda (total-size dimensions element-type fatp read-only-p extendable-p)                                                             (* |jop:| " 5-Sep-86 14:14")                    (* * "Two-d arrays are only simple or extendable twod-arrays")    (let ((bound0 (car dimensions))          (bound1 (cadr dimensions))          (type-number (%cml-type-to-typenumber element-type fatp)))         (|create| twod-array                base _ (%make-array-storage total-size type-number)                read-only-p _ read-only-p                bit-p _ (%bit-type-p type-number)                extendable-p _ extendable-p                type-number _ type-number                bound0 _ bound0                bound1 _ bound1                total-size _ total-size))))(%total-size  (lambda (dims)                                             (* |jop:| "27-Apr-86 17:02")                    (* *)    (cl:do ((dim dims (cdr dim))            (prod 1))           ((null dim)            prod)           (setq prod (cl:* (car dim)                            prod)))))(shrink-vector  (lambda (cl:vector new-size)                               (* |jop:| " 5-Sep-86 12:55")                    (* *)    (cond       ((%vectorp cl:vector)        (cl:if (or (< new-size 0)                   (> new-size (|fetch| (array-header total-size) |of| cl:vector)))               (cl:error "Trying to shrink array ~A to bad size ~A" cl:vector new-size))        (|replace| (array-header fill-pointer-p) |of| cl:vector |with| t)        (|replace| (array-header cl:fill-pointer) |of| cl:vector |with| new-size)        cl:vector)       ((stringp cl:vector)        (substring cl:vector 1 new-size cl:vector))       (t (cl:error "Not a vector ~S" cl:vector))))))(* \; "For Interlisp string hack")(defineq(%set-array-offset  (lambda (array newvalue)                                   (* |jop:| "17-Sep-86 17:54")                    (* * "Set the raw offset for ARRAY")    (cond       ((%oned-array-p array)        (|replace| (array-header offset) |of| array |with| newvalue))       ((%twod-array-p array)        (cl:error "Twod-arrays have no offset"))       ((%general-array-p array)        (|replace| (array-header offset) |of| array |with| (- newvalue                                                              (cl:do* ((base-array                                                                        array                                                                        (|fetch| (array-header base)                                                                           |of| base-array))                                                                       (offset 0 (+ offset                                                                                    (                                                                                    %get-array-offset                                                                                     base-array))))                                                                     ((not (|fetch| (array-header                                                                                     indirect-p)                                                                              |of| base-array))                                                                      offset)))))       (t (cl:error "Not an array ~S" array)))    newvalue))(%set-array-type-number  (lambda (array newvalue)                                   (* |jop:| "18-Sep-86 15:22")                    (* * "Set the type-number for array")    (cond       ((or (%oned-array-p array)            (%twod-array-p array))        (|replace| (array-header type-number) |of| array |with| newvalue))       ((%general-array-p array)        (cl:do ((base-array array (|fetch| (array-header base) |of| base-array)))               ((not (|fetch| (array-header indirect-p) |of| base-array))                (|replace| (array-header type-number) |of| base-array |with| newvalue))))       (t (cl:error "Not an array ~S" array)))    newvalue)))(* \; "Faster predicates not including IL:STRINGP's")(defineq(%arrayp  (lambda (array)                                            (* |jop:| " 5-Sep-86 12:49")                    (* *)    (or (%oned-array-p array)        (%twod-array-p array)        (%general-array-p array))))(%simple-array-p  (lambda (array)                                            (* |jop:| " 5-Sep-86 12:59")                    (* *)    (and (%arrayp array)         (|fetch| (array-header simple-p) |of| array))))(%simple-string-p  (lambda (string)                                           (* |jop:| " 5-Sep-86 12:54")                    (* *)    (and (%oned-array-p string)         (|fetch| (array-header simple-p) |of| string)         (|fetch| (array-header string-p) |of| string))))(%stringp  (lambda (array)                                            (* |jop:| " 5-Sep-86 12:49")                    (* *)    (and (or (%oned-array-p array)             (%general-array-p array))         (|fetch| (array-header string-p) |of| array))))(%vectorp  (lambda (cl:vector)                                        (* |jop:| " 5-Sep-86 12:49")                    (* *)    (or (%oned-array-p cl:vector)        (and (%general-array-p cl:vector)             (eql 1 (length (|ffetch| (general-array dims) |of| cl:vector))))))))(* \; "Low level predicates")(defineq(%general-array-p  (lambda (array)                                            (* |jop:| " 5-Sep-86 13:17")                    (* *)    (eq (ntypx array)        %general-array)))(%oned-array-p  (lambda (array)                                            (* |jop:| " 5-Sep-86 13:18")                    (* *)    (eq (ntypx array)        %oned-array)))(%thin-string-array-p  (lambda (array)                                            (* |jop:| "21-Sep-86 15:55")                    (* *)    (%thin-char-type-p (%array-type-number array))))(%twod-array-p  (lambda (array)                                            (* |jop:| " 5-Sep-86 13:18")                    (* *)    (eq (ntypx array)        %twod-array))))(* \; "Record def's")(declare\: dontcopy doeval@compile (* FOLLOWING DEFINITIONS EXPORTED)(declare\: eval@compile(blockrecord array-header (                    (* * "Describes common slots of all array headers")                                                             (* "First 8 bits are unused")                           (base pointer)                    (*         "24 bits of pointer. Points at raw storage or, in the indirect case, at another array header")                                                             (* "8 bits of flags")                           (read-only-p flag)                (*                                                         "Used for headers pointing at symbols pnames")                           (indirect-p flag)                 (*                                           "Points at an array header rather than a raw storage block")                           (bit-p flag)                      (* "Is a bit array")                           (string-p flag)                   (* "Is a string (implies is a vector)")                                                             (*                                      "If any of the following flags are set, the array in non-simple")                           (adjustable-p flag)                           (displaced-p flag)                           (fill-pointer-p flag)                           (extendable-p flag)                           (type-number bits 8)              (* "8 bits of type + size")                           (offset word)                     (* "For oned and general arrays")                           (cl:fill-pointer word)            (* "For oned and general arrays")                           (total-size word))                          (blockrecord array-header ((nil pointer)                                                     (flags bits 8)                                                     (type bits 4)                                                     (size bits 4)))                          (accessfns (simple-p (eq 0 (logand (|fetch| (array-header flags)                                                                |of| datum)                                                            15))))                          (system))(datatype general-array ((nil bits 8)                        (* "For alignment")                         (storage pointer)                   (* "24 bits of pointer")                         (read-only-p flag)                  (* "8 bits of flags")                         (indirect-p flag)                         (bit-p flag)                         (string-p flag)                         (adjustable-p flag)                         (displaced-p flag)                         (fill-pointer-p flag)                         (extendable-p flag)                         (type-number bits 8)                (* "8 bits of typenumber")                         (offset word)                         (cl:fill-pointer word)                         (total-size word)                         (dims pointer)))(datatype oned-array ((nil bits 8)                           (* "Don't use high 8 bits")                      (base pointer)                         (* "The raw storage base")                      (read-only-p flag)                     (* "8 bits worth of flags")                      (nil bits 1)                           (* "Oned array's cann't be indirect")                      (bit-p flag)                      (string-p flag)                      (nil bits 1)                           (* "Oned-array's cann't be adjustable")                      (displaced-p flag)                      (fill-pointer-p flag)                      (extendable-p flag)                      (type-number bits 8)                   (* "4 bits of type and 4 bits of size")                      (offset word)                          (* "For displaced arrays")                      (cl:fill-pointer word)                 (* "For filled arrays")                      (total-size word)                      (* "Total number of elements")                      ))(datatype twod-array ((nil bits 8)                           (* "For alignmnet")                      (base pointer)                         (* "Raw storage pointer")                      (read-only-p flag)                     (* "8 bits of flags")                      (nil bits 1)                           (* "Twod arrays cann't be indirect")                      (bit-p flag)                      (nil bits 4)                           (*         "Twod arrays cann't be strings, nor can they be adjustable, displaced, or have fill pointers")                      (extendable-p flag)                      (type-number bits 8)                      (bound0 word)                          (* "Zero dimension bound")                      (bound1 word)                          (* "One dimension bound")                      (total-size word))))(/declaredatatype 'general-array '((bits 8)                                   pointer flag flag flag flag flag flag flag flag (bits 8)                                   word word word pointer) '((general-array 0 (bits . 7))                                                             (general-array 0 pointer)                                                             (general-array 2 (flagbits . 0))                                                             (general-array 2 (flagbits . 16))                                                             (general-array 2 (flagbits . 32))                                                             (general-array 2 (flagbits . 48))                                                             (general-array 2 (flagbits . 64))                                                             (general-array 2 (flagbits . 80))                                                             (general-array 2 (flagbits . 96))                                                             (general-array 2 (flagbits . 112))                                                             (general-array 2 (bits . 135))                                                             (general-array 3 (bits . 15))                                                             (general-array 4 (bits . 15))                                                             (general-array 5 (bits . 15))                                                             (general-array 6 pointer)) '8)(/declaredatatype 'oned-array '((bits 8)                                pointer flag (bits 1)                                flag flag (bits 1)                                flag flag flag (bits 8)                                word word word) '((oned-array 0 (bits . 7))                                                  (oned-array 0 pointer)                                                  (oned-array 2 (flagbits . 0))                                                  (oned-array 2 (bits . 16))                                                  (oned-array 2 (flagbits . 32))                                                  (oned-array 2 (flagbits . 48))                                                  (oned-array 2 (bits . 64))                                                  (oned-array 2 (flagbits . 80))                                                  (oned-array 2 (flagbits . 96))                                                  (oned-array 2 (flagbits . 112))                                                  (oned-array 2 (bits . 135))                                                  (oned-array 3 (bits . 15))                                                  (oned-array 4 (bits . 15))                                                  (oned-array 5 (bits . 15))) '6)(/declaredatatype 'twod-array '((bits 8)                                pointer flag (bits 1)                                flag                                (bits 4)                                flag                                (bits 8)                                word word word) '((twod-array 0 (bits . 7))                                                  (twod-array 0 pointer)                                                  (twod-array 2 (flagbits . 0))                                                  (twod-array 2 (bits . 16))                                                  (twod-array 2 (flagbits . 32))                                                  (twod-array 2 (bits . 51))                                                  (twod-array 2 (flagbits . 112))                                                  (twod-array 2 (bits . 135))                                                  (twod-array 3 (bits . 15))                                                  (twod-array 4 (bits . 15))                                                  (twod-array 5 (bits . 15))) '6)(* END EXPORTED DEFINITIONS))(/declaredatatype 'general-array '((bits 8)                                   pointer flag flag flag flag flag flag flag flag (bits 8)                                   word word word pointer) '((general-array 0 (bits . 7))                                                             (general-array 0 pointer)                                                             (general-array 2 (flagbits . 0))                                                             (general-array 2 (flagbits . 16))                                                             (general-array 2 (flagbits . 32))                                                             (general-array 2 (flagbits . 48))                                                             (general-array 2 (flagbits . 64))                                                             (general-array 2 (flagbits . 80))                                                             (general-array 2 (flagbits . 96))                                                             (general-array 2 (flagbits . 112))                                                             (general-array 2 (bits . 135))                                                             (general-array 3 (bits . 15))                                                             (general-array 4 (bits . 15))                                                             (general-array 5 (bits . 15))                                                             (general-array 6 pointer)) '8)(/declaredatatype 'oned-array '((bits 8)                                pointer flag (bits 1)                                flag flag (bits 1)                                flag flag flag (bits 8)                                word word word) '((oned-array 0 (bits . 7))                                                  (oned-array 0 pointer)                                                  (oned-array 2 (flagbits . 0))                                                  (oned-array 2 (bits . 16))                                                  (oned-array 2 (flagbits . 32))                                                  (oned-array 2 (flagbits . 48))                                                  (oned-array 2 (bits . 64))                                                  (oned-array 2 (flagbits . 80))                                                  (oned-array 2 (flagbits . 96))                                                  (oned-array 2 (flagbits . 112))                                                  (oned-array 2 (bits . 135))                                                  (oned-array 3 (bits . 15))                                                  (oned-array 4 (bits . 15))                                                  (oned-array 5 (bits . 15))) '6)(/declaredatatype 'twod-array '((bits 8)                                pointer flag (bits 1)                                flag                                (bits 4)                                flag                                (bits 8)                                word word word) '((twod-array 0 (bits . 7))                                                  (twod-array 0 pointer)                                                  (twod-array 2 (flagbits . 0))                                                  (twod-array 2 (bits . 16))                                                  (twod-array 2 (flagbits . 32))                                                  (twod-array 2 (bits . 51))                                                  (twod-array 2 (flagbits . 112))                                                  (twod-array 2 (bits . 135))                                                  (twod-array 3 (bits . 15))                                                  (twod-array 4 (bits . 15))                                                  (twod-array 5 (bits . 15))) '6)(addtovar systemreclst(datatype general-array ((nil bits 8)                         (storage pointer)                         (read-only-p flag)                         (indirect-p flag)                         (bit-p flag)                         (string-p flag)                         (adjustable-p flag)                         (displaced-p flag)                         (fill-pointer-p flag)                         (extendable-p flag)                         (type-number bits 8)                         (offset word)                         (cl:fill-pointer word)                         (total-size word)                         (dims pointer)))(datatype oned-array ((nil bits 8)                      (base pointer)                      (read-only-p flag)                      (nil bits 1)                      (bit-p flag)                      (string-p flag)                      (nil bits 1)                      (displaced-p flag)                      (fill-pointer-p flag)                      (extendable-p flag)                      (type-number bits 8)                      (offset word)                      (cl:fill-pointer word)                      (total-size word)))(datatype twod-array ((nil bits 8)                      (base pointer)                      (read-only-p flag)                      (nil bits 1)                      (bit-p flag)                      (nil bits 4)                      (extendable-p flag)                      (type-number bits 8)                      (bound0 word)                      (bound1 word)                      (total-size word))))(putprops %aref1 dopval (2 aref1))(putprops %aref2 dopval (3 aref2))(putprops %aset1 dopval (3 aset1))(putprops %aset2 dopval (4 aset2))(* |;;| "I/O")(defineq(%defprint-array  (lambda (array stream)                                     (* |jop:| "10-Sep-86 12:54")                    (* * "This is the defprint for the array type")    (cond       ((cl:stringp array)        (%defprint-string array stream))       ((not *print-array*)        (%defprint-generic-array array stream))       ((and *print-level* (<= *print-level* 0))        (\\elide.print.element stream)        t)       ((cl:vectorp array)        (%defprint-vector array stream))       (t (let ((hash (cl:code-char (|fetch| (readtablep hashmacrochar) |of| *readtable*)))                (rank (cl:array-rank array))                rankstr)               (%check-circle-print array stream (setq rankstr (cl:princ-to-string rank))                                                             (* "Make sure we have room for #na")                      (.spacecheck. stream (+ (vector-length rankstr)                                              2))                      (cl:write-char hash stream)                      (cl:write-string rankstr stream)                      (cl:write-char #\A stream)                      (cl:if (eql rank 0)                             (\\prindatum (cl:aref array)                                    stream)                             (%print-array-contents (%flatten-array array)                                    0                                    (cl:array-dimensions array)                                    stream)))               t)))))(%defprint-bitvector  (lambda (cl:bit-vector stream)                             (* |jop:| " 5-Sep-86 11:19")                    (* * "*Print-level* is handled in \\defprint-vector")    (let ((hash (cl:code-char (|fetch| (readtablep hashmacrochar) |of| *readtable*)))          (size (vector-length cl:bit-vector))          end.index final.index elided sizestr)         (setq end.index (cl:1- size))         (%check-circle-print cl:bit-vector stream                (cl:unless (eql size 0)                       (cl:do ((i (cl:1- end.index)                                  (cl:1- i))                               (last.value (cl:aref cl:bit-vector end.index)))                              ((or (< i 0)                                   (not (eql (cl:aref cl:bit-vector i)                                             last.value))))                              (setq end.index i)))                (setq final.index (cond                                     ((and *print-length* (>= end.index *print-length*))                                      (setq elided t)                                      (cl:1- *print-length*))                                     (t end.index)))                (cl:if (not (eql (cl:1- size)                                 end.index))                       (setq sizestr (cl:princ-to-string size)))                (.spacecheck. stream (+ (progn               (*                                     "#* Plus 1 for final.index being 1 less than number bits printed")                                               3)                                        (cl:if sizestr (vector-length sizestr)                                               0)                                        final.index                                        (cl:if elision (progn                                                              (* "Space for ...")                                                              3)                                               0)))                (cl:write-char hash stream)                (cl:if sizestr (cl:write-string sizestr stream))                (cl:write-char #\* stream)                (cl:do ((i 0 (cl:1+ i)))                       ((> i final.index))                       (\\outchar stream (+ (bit cl:bit-vector i)                                            (cl:char-code #\0))))                (cl:if elided (\\elide.print.tail stream)))         t)))(%defprint-generic-array  (lambda (array stream)                                     (* |jop:| "24-Sep-86 11:09")                    (* * "Invoked when *PRINT-ARRAY* is NIL")    (let ((hash (cl:code-char (|fetch| (readtablep hashmacrochar) |of| *readtable*))))         (%check-circle-print array stream                   (* "Make sure we have room for #<")                (.spacecheck. stream 2)                (cl:write-char hash stream)                (cl:write-char #\< stream)                (cl:write-string "ARRAY" stream)                (cl:write-char #\Space stream)                (cl:write-string (cl:princ-to-string (cl:array-element-type array))                       stream)                (cl:write-char #\Space stream)                (cl:write-string (cl:princ-to-string (cl:array-dimensions array))                       stream)                (cl:write-char #\Space stream)                (cl:write-char #\@ stream)                (cl:write-char #\Space stream)                (\\printaddr array stream)                (cl:write-char #\> stream))         t)))(%defprint-vector  (lambda (cl:vector stream)                                 (* |jop:| "10-Sep-86 12:55")    (cond       ((cl:stringp cl:vector)        (%defprint-string cl:vector stream))       ((not *print-array*)        (%defprint-generic-array cl:vector stream))       ((and *print-level* (<= *print-level* 0))        (\\elide.print.element stream)        t)       ((cl:bit-vector-p cl:vector)        (%defprint-bitvector cl:vector stream))       (t (let ((hash (cl:code-char (|fetch| (readtablep hashmacrochar) |of| *readtable*)))                (size (vector-length cl:vector))                end.index final.index elided sizestr)               (setq end.index (cl:1- size))               (%check-circle-print cl:vector stream                      (cl:unless (eql size 0)                             (cl:do ((i (cl:1- end.index)                                        (cl:1- i))                                     (last.value (cl:aref cl:vector end.index)))                                    ((or (< i 0)                                         (not (eql (cl:aref cl:vector i)                                                   last.value))))                                    (setq end.index i)))                      (setq final.index (cond                                           ((and *print-length* (>= end.index *print-length*))                                            (setq elided t)                                            (cl:1- *print-length*))                                           (t end.index)))                      (cl:if (not (eql (cl:1- size)                                       end.index))                             (setq sizestr (cl:princ-to-string size)))                      (.spacecheck. stream (+ (cl:if sizestr (vector-length sizestr)                                                     0)                                              2))                      (cl:write-char hash stream)                      (cl:if sizestr (cl:write-string sizestr stream))                      (cl:write-char #\( stream)                      (let ((*print-level* (and *print-level* (cl:1- *print-level*))))                           (cl:do ((i 0 (cl:1+ i)))                                  ((> i final.index))                                  (cl:if (> i 0)                                         (cl:write-char #\Space stream))                                  (\\prindatum (cl:aref cl:vector i)                                         stream)))                      (cl:if elided (\\elide.print.tail stream))                      (cl:write-char #\) stream))               t)))))(%defprint-string  (lambda (string stream)                                    (* |jop:| " 5-Sep-86 11:19")                    (* *)    (let ((escapechar (|fetch| (readtablep escapechar) |of| *readtable*))          (clp (|fetch| (readtablep commonlisp) |of| *readtable*))          (size (vector-length string)))         (%check-circle-print string stream (.spacecheck. stream (cl:if clp 2 (+ 2 size)))                (cl:when *print-escape* (\\outchar stream (constant (cl:char-code #\"))))                (cl:do ((i 0 (cl:1+ i))                        ch)                       ((eql i size))                       (setq ch (cl:char-code (char string i)))                       (cl:when (and *print-escape* (or (eq ch (constant (cl:char-code #\")))                                                        (eq ch escapechar)))                              (\\outchar stream escapechar))                       (\\outchar stream ch))                (cl:when *print-escape* (\\outchar stream (constant (cl:char-code #\")))))         t)))(%print-array-contents  (lambda (flat-array offset dimensions stream)              (* |jop:| " 5-Sep-86 11:14")                    (* *)    (let ((nelts (car dimensions))          final.index elided)         (cond            ((and *print-length* (> nelts *print-length*))             (setq elided t)             (setq final.index (cl:1- *print-length*)))            (t (setq final.index (cl:1- nelts))))         (cl:write-char #\( stream)         (cond            ((null (cdr dimensions))                         (*                                                            "Down to bottom level, print the elements")             (cl:do ((i offset (cl:1+ i))                     (end-index (+ offset final.index)))                    ((> i end-index))                    (cl:if (> i offset)                           (cl:write-char #\Space stream))                    (\\prindatum (cl:aref flat-array i)                           stream)))            ((eq *print-level* 1)                            (* "Elide at this level")             (cl:do ((i 0 (cl:1+ i)))                    ((> i final.index))                    (cl:if (> i offset)                           (cl:write-char #\Space stream))                    (\\elide.print.element stream)))            (t (let ((*print-level* (and *print-level* (cl:1- *print-level*))))                    (cl:do ((i 0 (cl:1+ i)))                           ((> i final.index))                           (cl:if (> i 0)                                  (cl:write-char #\Space stream))                           (%print-array-contents flat-array (cl:* (cadr dimensions)                                                                   (+ offset i))                                  (cdr dimensions)                                  stream)))))         (cl:if elided (\\elide.print.tail stream))         (cl:write-char #\) stream)))))(defprint 'oned-array '%defprint-vector)(defprint 'twod-array '%defprint-array)(defprint 'general-array '%defprint-array)(* |;;| "Needed at run time. low level functions for accessing, setting, and allocating raw storage. also includes cml type to typenumber converters")(defineq(%array-read  (lambda (base type-number index)    (%slow-array-read base type-number index)))(%array-write  (lambda (newvalue base type-number index)                  (* |jop:| "17-Sep-86 12:20")    (%slow-array-write newvalue base type-number index)))(%cml-type-to-typenumber  (lambda (element-type fatp)                                (* |jop:| " 5-Sep-86 14:34")                    (* *)    (let ((canonical-type (%get-canonical-cml-type element-type)))         (cl:if (and fatp (eq canonical-type 'cl:string-char))                %fat-char-typenumber                (%cml-type-to-typenumber-expander canonical-type)))))(%get-canonical-cml-type  (lambda (element-type)                                     (* |Pavel| "17-Oct-86 17:27")    (cond       ((cl:consp element-type)        (case (car element-type)              (cl::unsigned-byte (%get-enclosing-unsigned-byte element-type))              (cl::signed-byte (%get-enclosing-signed-byte element-type))              ((mod cl:mod)               (%reduce-mod element-type))              (integer (%reduce-integer element-type))              (cl:otherwise (let ((expander (type-expander (car element-type))))                                 (cl:if expander (%get-canonical-cml-type (type-expand element-type                                                                                  expander))                                        t)))))       (t (case element-type ((t xpointer cl:single-float cl:string-char)                              element-type)                (pointer t)                (float 'cl:single-float)                (cl:fixnum '(signed-byte 32))                ((character cl:character)                 'cl:string-char)                (bit '(unsigned-byte 1))                (cl:otherwise (let ((expander (type-expander element-type)))                                   (cl:if expander (%get-canonical-cml-type (type-expand element-type                                                                                    expander))                                          t))))))))(%get-enclosing-signed-byte  (lambda (element-type)                                     (* |jop:| " 6-Jul-86 12:50")                    (* *)    (let ((nbits (cadr element-type)))         (cond            ((<= nbits 16)             '(signed-byte 16))            ((<= nbits 32)             '(signed-byte 32))            (t t)))))(%get-enclosing-unsigned-byte  (lambda (element-type)                                     (* |jop:| " 6-Jul-86 12:50")                    (* *)    (let ((nbits (cadr element-type)))         (cond            ((<= nbits 1)             '(unsigned-byte 1))            ((<= nbits 8)             '(unsigned-byte 8))            ((<= nbits 16)             '(unsigned-byte 16))            (t t)))))(%make-array-storage  (lambda (nelts typenumber init-on-page alignment)          (* |jop:| " 5-Sep-86 14:18")                    (* *)    (let ((bits-per-element (%typenumber-to-bits-per-element typenumber))          (gc-type (%typenumber-to-gc-type typenumber)))     (* |Initialize| |Strings| |to| #\Space)         (\\allocblock (foldhi (cl:* nelts bits-per-element)                              bitspercell)                gc-type init-on-page alignment))))(%reduce-integer  (lambda (element-type)    (let ((low (cadr element-type))          (high (caddr element-type)))         (cl:if (listp low)                (setq low (cl:1+ (car low))))         (cl:if (listp high)                (setq high (cl:1- (car high))))         (cl:if (< low high)                (cond                   ((>= low 0)                               (* (integer + |high|) =>                                                             (mod (cl:1+ high)))                    (cond                       ((< high 2)                        '(unsigned-byte 1))                       ((< high 256)                        '(unsigned-byte 8))                       ((< high 65536)                        '(unsigned-byte 16))                       (t t)))                   (t (let ((bound (max (abs low)                                        high)))                           (cond                              ((< bound 32768)                               '(signed-byte 16))                              ((<= bound max.fixp)                               '(signed-byte 32))                              (t t)))))))))(%reduce-mod  (lambda (element-type)                                     (* |jop:| " 6-Jul-86 12:50")                    (* *)    (let ((modnum (cadr element-type)))         (cond            ((<= modnum 2)             '(unsigned-byte 1))            ((<= modnum 256)             '(unsigned-byte 8))            ((<= modnum 65536)             '(unsigned-byte 16))            (t t)))))(%slow-array-read  (lambda (base typenumber row-major-index)                  (* |jop:| " 5-Sep-86 14:16")                    (* *)    (%llarray-typed-get base typenumber row-major-index)))(%slow-array-write  (lambda (newvalue base typenumber row-major-index)         (* |jop:| " 5-Sep-86 14:16")                    (* *)    (cl:if (not (%llarray-typep typenumber newvalue))           (cl:error "Illegal value: ~S" newvalue)           (%llarray-typed-put base typenumber row-major-index newvalue))    newvalue)))(* |;;| "Compiler options")(declare\: donteval@load doeval@compile dontcopy (declare\: doeval@compile dontcopy(localvars . t)))(putprops cmlarray filetype cl:compile-file)(declare\: donteval@load doeval@compile dontcopy compilervars (addtovar nlama )(addtovar nlaml )(addtovar lama cl:vector aset cl:array-row-major-index cl:array-in-bounds-p cl:aref))(putprops cmlarray copyright ("Xerox Corporation" 1986))(declare\: dontcopy  (filemap (nil (43220 54113 (%copy-to-new-array 43230 . 44793) (cl:aref 44795 . 48059) (cl:array-in-bounds-p 48061 . 48611) (cl:array-row-major-index 48613 . 49450) (aset 49452 . 53773) (cl:vector 53775 . 54111)) (54178 54380 (scharset 54188 . 54378)) (54732 92241 (%alter-as-displaced-array 54742 . 57876) (%alter-as-displaced-to-base-array 57878 . 59542) (%aref0 59544 . 60303) (%aref1 60305 . 61481) (%aref2 61483 . 63541) (%array-base 63543 . 64396) (%array-content-initialize 64398 . 64986) (%array-element-initialize 64988 . 65331) (%array-offset 65333 . 66064) (%array-type-number 66066 . 67055) (%aset0 67057 . 68056) (%aset1 68058 . 69522) (%aset2 69524 . 71796) (%check-sequence-dimensions 71798 . 72368) (%do-logical-op 72370 . 74612) (%extend-array 74614 . 76837) (%fast-copy-base 76839 . 79190) (%fat-string-array-p 79192 . 79402) (%fill-array-from-sequence 79404 . 80103) (%flatten-array 80105 . 80595) (%make-array-writeable 80597 . 82862) (%make-displaced-array 82864 . 85719) (%make-general-array 85721 . 87029) (%make-oned-array 87031 . 88075) (%make-string-array-fat 88077 . 90350) (%make-twod-array 90352 . 91175) (%total-size 91177 . 91495) (shrink-vector 91497 . 92239)) (92285 94732 (%set-array-offset 92295 . 93992) (%set-array-type-number 93994 . 94730)) (94795 96235 (%arrayp 94805 . 95055) (%simple-array-p 95057 . 95301) (%simple-string-p 95303 . 95619) (%stringp 95621 . 95911) (%vectorp 95913 . 96233)) (96274 97089 (%general-array-p 96284 . 96483) (%oned-array-p 96485 . 96678) (%thin-string-array-p 96680 . 96892) (%twod-array-p 96894 . 97087)) (112065 123018 (%defprint-array 112075 . 113637) (%defprint-bitvector 113639 . 116137) (%defprint-generic-array 116139 . 117265) (%defprint-vector 117267 . 119980) (%defprint-string 119982 . 121065) (%print-array-contents 121067 . 123016)) (123304 128914 (%array-read 123314 . 123417) (%array-write 123419 . 123596) (%cml-type-to-typenumber 123598 . 123997) (%get-canonical-cml-type 123999 . 125500) (%get-enclosing-signed-byte 125502 . 125857) (%get-enclosing-unsigned-byte 125859 . 126277) (%make-array-storage 126279 . 126767) (%reduce-integer 126769 . 127940) (%reduce-mod 127942 . 128352) (%slow-array-read 128354 . 128564) (%slow-array-write 128566 . 128912)))))stop