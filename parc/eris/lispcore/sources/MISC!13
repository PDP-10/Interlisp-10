(FILECREATED "20-Jan-86 20:47:45" {ERIS}<LISPCORE>SOURCES>MISC.;13 36847        changes to:  (FNS CONSTANTEXPRESSIONP)      previous date: " 9-Jan-86 04:00:16" {ERIS}<LISPCORE>SOURCES>MISC.;12)(* Copyright (c) 1982, 1983, 1984, 1985, 1986 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT MISCCOMS)(RPAQQ MISCCOMS [(FNS ADD1VAR ADDTOVAR APPENDTOVAR APPEND \APPEND2 ASSOC ATTACH CHANGEPROP CONCATLIST 		      CONSTANTS CONSTANTEXPRESSIONP COPY DEFINEQ DEFLIST DREMOVE DREVERSE DSUBST 		      EQLENGTH ERSETQ EVERY GENSYM GENSYM? \GS.INITBUF GETLIS INTERSECTION KWOTE LAST 		      LASTN LCONC LDIFF LDIFFERENCE LENGTH LISTGET LISTGET1 LISTPUT LISTPUT1 LSUBST 		      MAP MAP2C MAP2CAR MAPC MAPCAR MAPCON MAPCONC MAPLIST MEMBER NLEFT NLSETQ NOTANY 		      NOTEVERY NTH PUTASSOC RATOMS REMOVE REVERSE RPT RPTQ FRPTQ SASSOC SAVEDEF 		      SAVEDEF1 SELECT SELECT1 SELECTC SETQQ SOME STRMEMB SUB1VAR SUBSET SUBST TAILP 		      TCONC TIME UNION)	(INITVARS (COMPVARMACROHASH NIL))	(ADDVARS (CONSTANTFOLDFNS PLUS IPLUS TIMES ITIMES DIFFERENCE IDIFFERENCE QUOTIENT IQUOTIENT 				  IMIN IMAX IABS LLSH LRSH LOGOR LOGXOR LOGAND OR AND))	(GLOBALVARS COMPVARMACROHASH CONSTANTFOLDFNS)	(DECLARE: EVAL@COMPILE DONTCOPY (CONSTANTS (\GS.BUFSIZE 100)))	(INITVARS (GENNUM 0)		  (\GS.OGENNUM -1)		  (\GS.NUMLEN 0)		  (\GS.BUF NIL)		  (\GS.STR (ALLOCSTRING 0)))	(ALISTS (PRETTYEQUIVLST SELECTC)		(DWIMEQUIVLST SELECTC))	(GLOBALVARS GENNUM \GS.OGENNUM \GS.NUMLEN \GS.BUF \GS.STR)	(LOCALVARS . T)	(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS		  (ADDVARS (NLAMA SELECTC SELECT FRPTQ RPTQ DEFINEQ CONSTANTS APPENDTOVAR ADDTOVAR)			   (NLAML TIME SUB1VAR SETQQ NLSETQ ERSETQ ADD1VAR)			   (LAMA APPEND])(DEFINEQ(ADD1VAR  (NLAMBDA (ADD1X)    (SET ADD1X (ADD1 (EVAL ADD1X)))))(ADDTOVAR  (NLAMBDA X                                                 (* rmk: " 4-JAN-82 15:45")    (RESETVARS ((DFNFLG DFNFLG))	       (COND		 ((EQ DFNFLG (QUOTE ALLPROP))		   (SETQQ DFNFLG PROP)))	       (RETURN (PROG (VAR TEM)			     (SAVESET (SETQ VAR (CAR X))				      (COND					((OR (LISTP (SETQ TEM (GETTOPVAL VAR)))					     (CDR X))					  (UNION (CDR X)						 (LISTP TEM)))					((NEQ TEM (QUOTE NOBIND))					  TEM))				      T)			     (RETURN VAR))))))(APPENDTOVAR  (NLAMBDA X                                                 (* rmk: " 4-JAN-82 15:46")    (RESETVARS ((DFNFLG DFNFLG))	       (COND		 ((EQ DFNFLG (QUOTE ALLPROP))		   (SETQQ DFNFLG PROP)))	       (RETURN (PROG (VAR TEM)			     (SAVESET (SETQ VAR (CAR X))				      (COND					((OR (LISTP (SETQ TEM (GETTOPVAL VAR)))					     (CDR X))					  (UNION (LISTP TEM)						 (CDR X)))					((NEQ TEM (QUOTE NOBIND))					  TEM))				      T)			     (RETURN VAR))))))(APPEND  [LAMBDA L                                                  (* lmm "30-Jun-84 00:37")                                                             (* fixed bug so that (APPEND 							     (QUOTE (A B . C))) was (QUOTE 							     (A B . C)))    (COND      ((EQ L 0)	NIL)      ((EQ L 1)	(\APPEND2 (ARG L 1)		  NIL))      (T (bind (VAL _(ARG L L))	       (N _ L) while (IGREATERP (add N -1)					0)	    do (SETQ VAL (\APPEND2 (ARG L N)				   VAL))	    finally (RETURN VAL])(\APPEND2  [LAMBDA (L1 L2)                                            (* lmm "30-Jun-84 00:30")    (COND      ((LISTP L1)	(PROG ((VAL (CONS (CAR L1)			  L2))	       TAIL)	      (SETQ TAIL VAL)	  LP  [FRPLACD TAIL (SETQ TAIL (LIST (CAR (OR (LISTP (SETQ L1 (CDR L1)))						      (PROGN (FRPLACD TAIL (OR L2 L1))							     (RETURN VAL]	      (GO LP)))      ((NLISTP L2)	L1)      (T L2])(ASSOC  (LAMBDA (KEY ALST)                                         (* bvm: "20-FEB-81 14:58")    (PROG NIL      LP  (COND	    ((NLISTP ALST)	      (RETURN))	    ((AND (LISTP (CAR ALST))		  (EQ (CAAR ALST)		      KEY))	      (RETURN (CAR ALST))))          (SETQ ALST (CDR ALST))          (GO LP))))(ATTACH  (LAMBDA (X L)    (COND      ((LISTP L)	(FRPLACA (FRPLACD L (CONS (CAR L)				  (CDR L)))		 X))      ((NULL L)	(CONS X))      (T (ERRORX (LIST 4 L))))))(CHANGEPROP  (LAMBDA (X PROP1 PROP2)                                    (* wt: "31-MAY-79 22:28")    (PROG ((Z (COND		((LITATOM X)		  (GETPROPLIST X))		(T (ERRORX (LIST 14 X))))))      LP  (RETURN (COND		    ((NLISTP Z)		      NIL)		    ((EQ (CAR Z)			 PROP1)		      (FRPLACA Z PROP2)		      X)		    (T (SETQ Z (CDR (LISTP (CDR Z))))		       (GO LP)))))))(CONCATLIST  [LAMBDA (L)                                                (* rmk: "27-Mar-85 17:23")    (PROG (STR FATP)                                         (* Try to pre-determine FATP, at least for strings and 							     litatoms, where it is easy to tell.)          (SETQ STR (ALLOCSTRING (for X in L				    sum (AND (EQ (SYSTEMTYPE)						 (QUOTE D))					     (OR FATP (SELECTC (NTYPX X)							       (\STRINGP (SETQ FATP									   (ffetch (STRINGP 										       FATSTRINGP)									      of X)))							       (\LITATOM (SETQ FATP									   (ffetch (LITATOM FATPNAMEP)									      of X)))							       NIL)))					(NCHARS X))				 NIL NIL FATP))          (for X in L as I from 1 by (NCHARS X) do (RPLSTRING STR I X))          (RETURN STR])(CONSTANTS  [NLAMBDA VARS                                              (* rmk: " 3-Jan-84 13:20")    (OR COMPVARMACROHASH (SETQ COMPVARMACROHASH (HASHARRAY 100)))    [for X in VARS do (COND			((LISTP X)			  (PUTHASH (CAR X)				   (LIST (QUOTE CONSTANT)					 (CADR X))				   COMPVARMACROHASH))			(T (PUTHASH X (LIST (QUOTE CONSTANT)					    X)				    COMPVARMACROHASH]    VARS])(CONSTANTEXPRESSIONP  [LAMBDA (FORM)                                             (* lmm "20-Jan-86 20:43")    (COND      [(LITATOM FORM)	(COND	  ((OR (NULL FORM)	       (EQ FORM T))	    (LIST FORM))	  ((AND COMPVARMACROHASH (SETQ FORM (GETHASH FORM COMPVARMACROHASH)))	    (CONSTANTEXPRESSIONP FORM]      [(LISTP FORM)	(SELECTQ (CAR FORM)		 (QUOTE (CDR FORM))		 (FUNCTION (AND (LITATOM (CADR FORM))				(NULL (CDDR FORM))				(CDR FORM)))		 [CONSTANT (LIST (EVAL (CADR FORM]		 (COND		   [(FMEMB (CAR FORM)			   CONSTANTFOLDFNS)		     (for X in (CDR FORM) collect (CAR (OR (CONSTANTEXPRESSIONP X)							   (RETURN)))			finally (RETURN (LIST (APPLY (CAR FORM)						     $$VAL]		   ((NOT (GETD (CAR FORM)))		     (PROG ((MAC (GETMACROPROP (CAR FORM)					       COMPILERMACROPROPS)))		           (RETURN (AND MAC [NOT (EQUAL FORM (SETQ FORM (MACROEXPANSION FORM MAC]					(CONSTANTEXPRESSIONP FORM]      ((NUMBERP FORM)	(LIST FORM])(COPY  (LAMBDA (X)                                                (* lmm "16-FEB-82 22:07")    (COND      ((NLISTP X)	X)      (T (PROG (TAIL (VAL (LIST (COPY (CAR X)))))	       (SETQ TAIL VAL)	   LP  (COND		 ((NLISTP (SETQ X (CDR X)))		   (AND X (FRPLACD TAIL X))		   (RETURN VAL)))	       (FRPLACD TAIL (SETQ TAIL (CONS (COPY (CAR X)))))	       (GO LP))))))(DEFINEQ  (NLAMBDA X    (DEFINE X)))(DEFLIST  (LAMBDA (L PROP)    (PROG NIL      LOOP(COND	    ((NLISTP L)	      (RETURN)))          (PUTPROP (CAAR L)		   PROP		   (CADAR L))                                (* NOTE: this call to PUTPROP is changed to /PUTPROP 							     later in the loadup.)          (SETQ L (CDR L))          (GO LOOP))))(DREMOVE  (LAMBDA (X L)    (COND      ((NLISTP L)	NIL)      ((EQ X (CAR L))	(COND	  ((CDR L)	    (FRPLACA L (CADR L))	    (FRPLACD L (CDDR L))	    (DREMOVE X L))))      (T (PROG (Z)	       (DECLARE (LOCALVARS Z))	       (SETQ Z L)	   LP  (COND		 ((NLISTP (CDR L))		   (RETURN Z))		 ((EQ X (CADR L))		   (FRPLACD L (CDDR L)))		 (T (SETQ L (CDR L))))	       (GO LP))))))(DREVERSE  (LAMBDA (L)    (PROG (Y Z)          (DECLARE (LOCALVARS Y Z))      R1  (COND	    ((NLISTP (SETQ Y L))	      (RETURN Z)))          (SETQ L (CDR L))          (SETQ Z (FRPLACD Y Z))          (GO R1))))(DSUBST  (LAMBDA (NEW OLD EXPR)                                     (* lmm "16-FEB-82 22:10")    (PROG (B)          (COND	    ((EQ OLD (SETQ B EXPR))	      (RETURN (COPY NEW))))      LP  (COND	    ((NLISTP EXPR)	      (RETURN B))	    ((EQUAL OLD (CAR EXPR))	      (FRPLACA EXPR (COPY NEW)))	    (T (DSUBST NEW OLD (CAR EXPR))))          (COND	    ((AND OLD (EQ OLD (CDR EXPR)))	      (FRPLACD EXPR (COPY NEW))	      (RETURN B)))          (SETQ EXPR (CDR EXPR))          (GO LP))))(EQLENGTH  [LAMBDA (X N)                                              (* bvm: "14-Feb-85 00:34")          (* Generated by paatern match. INcluded so user can load code that has been dwimified and or compiled into a 	  nonclisp system and run it.)    (COND      ((ILESSP N 0)	NIL)      ((EQ N 0)	(NLISTP X))      (T (AND (LISTP (SETQ X (NTH X N)))	      (NLISTP (CDR X])(ERSETQ  (NLAMBDA (ERSETX)    (ERRORSET ERSETX T)))(EVERY  (LAMBDA (EVERYX EVERYFN1 EVERYFN2)                         (* Note that EVERY does not compile open, although SOME 							     does.)    (PROG NIL      LOOP(COND	    ((NLISTP EVERYX)	      (RETURN T))	    ((NULL (APPLY* EVERYFN1 (CAR EVERYX)			   EVERYX))	      (RETURN NIL)))          (SETQ EVERYX (COND	      (EVERYFN2 (APPLY* EVERYFN2 EVERYX))	      (T (CDR EVERYX))))          (GO LOOP))))(GENSYM  [LAMBDA (PREFIX NUMSUFFIX OSTRBUFFER NEW? CHARCODE)        (* lmm "14-Apr-85 20:39")    (OR (NULL PREFIX)	(STRINGP PREFIX)	(LITATOM PREFIX)	(ERRORX (LIST 27 PREFIX)))    (OR (NULL NUMSUFFIX)	(FIXP NUMSUFFIX)	(ERRORX (LIST 27 NUMSUFFIX)))    (OR (NULL OSTRBUFFER)	(STRINGP OSTRBUFFER)	(ERRORX (LIST 27 OSTRBUFFER)))    (OR (NULL CHARCODE)	(CHARCODEP CHARCODE)	(ERRORX (LIST 27 CHARCODE)))    (PROG ((BUFSIZE \GS.BUFSIZE)	   (NUMLEN \GS.NUMLEN)	   [BUF (OR (STRINGP \GS.BUF)		    (SETQ \GS.BUF (ALLOCSTRING \GS.BUFSIZE]	   (PREFIXLEN 0)	   BEG.I ATOM)          (if (OR (NULL PREFIX)		  (EQ (SETQ PREFIXLEN (NCHARS PREFIX))		      0))	      then (SETQ PREFIX)		   (if (NULL CHARCODE)		       then                                  (* Here's the default case)			    (SETQ CHARCODE (CHARCODE A)))	    elseif (IGREATERP PREFIXLEN (IDIFFERENCE BUFSIZE 10))	      then (ERROR PREFIX "Too long"))          (if (if OSTRBUFFER		  then (if (NULL NUMSUFFIX)			   then (HELP "OSTRBUFFER supplied without NUMSUFFIX")			 elseif (ILESSP (SETQ BUFSIZE (NCHARS OSTRBUFFER))					(IPLUS 12 PREFIXLEN))			   then (ERROR OSTRBUFFER "Too short"))		       T		elseif NUMSUFFIX		  then                                       (* Insulate the normal \GS.BUF from random intrustions)		       [SETQ OSTRBUFFER (ALLOCSTRING (SETQ BUFSIZE (IPLUS PREFIXLEN 12]		       T)	      then (SETQ BUF OSTRBUFFER))      A   (UNINTERRUPTABLY              (if (if OSTRBUFFER		      then                                   (* Use the user-supplied buffer, or a freshly cons'd 							     one if he supplied NUMSUFFIX without OSTRBUFFER)			   T		    elseif (NOT (FIXP GENNUM))		      then                                   (* Disaster recovery)			   (SETQ GENNUM 0)			   T)		  then (SETQ NUMLEN (\GS.INITBUF BUF BUFSIZE (OR NUMSUFFIX GENNUM)))		else           (* In this case, we have kept account of the contents of \GS.BUF so we don't have to call \GS.INITBUF afresh, but 	  rather merely "patch up" the effect of adding 1 to GENNUM)		     (if (if (NOT (IEQP GENNUM \GS.OGENNUM))			     then                            (* User perhaps has reset GENNUM)				  (if (ILESSP GENNUM 0)				      then (SETQ GENNUM 0))				  T			   elseif (IGEQ GENNUM MAX.FIXP)			     then                            (* Sigh, two's complement wrap-around)				  (SETQ GENNUM 0)				  T)			 then (SETQ NUMLEN (\GS.INITBUF BUF BUFSIZE GENNUM)))                                                             (* Increment the GENNUM counter and the string buffer 							     buffer.)		     (if (for CNT C to NUMLEN as I from BUFSIZE by -1			    do                               (* Simulates a BCD type add in the gensym string)			       (SETQ C (NTHCHARCODE \GS.BUF I))			       (if (ILEQ (add C 1)					 (CHARCODE 9))				   then                      (* ha, carry stops here)					(RPLCHARCODE BUF I C)					(RETURN)				 else (RPLCHARCODE BUF I (CHARCODE 0)))			    finally (RETURN T))			 then                                (* Sigh, we have to extend the numerical part)			      (RPLCHARCODE BUF (IDIFFERENCE BUFSIZE NUMLEN)					   (CHARCODE 1))			      (SETQ NUMLEN (add \GS.NUMLEN 1)))		     (SETQ \GS.OGENNUM (add GENNUM 1)))      (* BEG.I will be the beginning index, in the buffer, 							     for the atom)	      (SETQ BEG.I (ADD1 (IDIFFERENCE BUFSIZE NUMLEN)))	      (if CHARCODE		  then (RPLCHARCODE BUF (add BEG.I -1)				    CHARCODE))	      (if PREFIX		  then (RPLSTRING BUF (SETQ BEG.I (IDIFFERENCE BEG.I PREFIXLEN))				  PREFIX))	      (SETQ \GS.STR (SUBSTRING BUF BEG.I BUFSIZE \GS.STR))	      (SETQ ATOM (MKATOM \GS.STR)))          (if (NUMBERP ATOM)	      then (ERRORX (LIST 27 PREFIX)))          (RETURN ATOM])(GENSYM?  (LAMBDA (X)                                                (* lmm " 1-JUN-81 08:30")    (AND (LITATOM X)	 (EQ (NTHCHARCODE X -5)	     (CHARCODE A))	 (FIXP (NTHCHAR X -4))	 (FIXP (NTHCHAR X -3))	 (FIXP (NTHCHAR X -2))	 (FIXP (NTHCHAR X -1))	 T)))(\GS.INITBUF  [LAMBDA (BUF BUFSIZE N)                                    (* lmm "14-Apr-85 20:36")          (* Initializes BUF (which must be a stringp of length BUFSIZE) with the digits of N right-justified and left-0 	  padded up to a minimum of 4 digits. Returns the decimal length of N)    (PROG (NUMLEN)          (RPLSTRING BUF [IDIFFERENCE BUFSIZE (if (ILESSP N 10000)						  then       (* Trick to get leading zeros)						       (SETQ N (IPLUS N 10000))						       (SETQ NUMLEN 4)						else (SUB1 (SETQ NUMLEN (NCHARS N]		     N)          (AND (EQ BUF \GS.BUF)	       (SETQ \GS.NUMLEN NUMLEN))          (RETURN NUMLEN])(GETLIS  (LAMBDA (X PROPS)                                          (* wt: "31-MAY-79 22:25")    (PROG ((Z (COND		((LITATOM X)		  (GETPROPLIST X))		(T X))))      LP  (RETURN (COND		    ((NLISTP Z)		      NIL)		    ((FMEMB (CAR Z)			    PROPS)		      Z)		    (T (SETQ Z (CDR (LISTP (CDR Z))))		       (GO LP)))))))(INTERSECTION  (LAMBDA (X Y)    (PROG ((R (CONS))	   S)          (DECLARE (LOCALVARS R S))      LP  (COND	    ((NLISTP X)	      (RETURN (CAR R)))	    ((COND		((LITATOM (SETQ S (CAR X)))		  (AND (FMEMB S Y)		       (NULL (FMEMB S (CAR R)))))		(T (AND (MEMBER S Y)			(NULL (MEMBER S (CAR R))))))	      (TCONC R S)))          (SETQ X (CDR X))          (GO LP))))(KWOTE  (LAMBDA (X)                                                (* dcl: 15 SEP 75 15:25)    (COND      ((OR (NULL X)	   (EQ X T)	   (NUMBERP X))	X)      (T (LIST (QUOTE QUOTE)	       X)))))(LAST  (LAMBDA (X)    (PROG (XX)          (DECLARE (LOCALVARS XX))      L   (COND	    ((NLISTP X)	      (RETURN XX)))          (SETQ XX X)          (SETQ X (CDR X))          (GO L))))(LASTN  (LAMBDA (L N)    (PROG (X Y)          (DECLARE (LOCALVARS X Y))          (COND	    ((NLISTP L)	      (RETURN NIL))	    ((NULL (SETQ X (FNTH L N)))	      (RETURN)))      LP  (COND	    ((NULL (SETQ X (CDR X)))	      (RETURN (CONS Y L))))          (SETQ Y (NCONC1 Y (CAR L)))          (SETQ L (CDR L))          (GO LP))))(LCONC  (LAMBDA (PTR X)    (PROG (XX)          (DECLARE (LOCALVARS XX))          (RETURN (COND		    ((NULL X)		      PTR)		    ((OR (NLISTP X)			 (CDR (SETQ XX (LAST X))))		      (SETQ XX X)		      (GO ERROR))		    ((NULL PTR)		      (CONS X XX))		    ((NLISTP PTR)		      (SETQ XX PTR)		      (GO ERROR))		    ((NULL (CAR PTR))		      (FRPLACA (FRPLACD PTR XX)			       X))		    (T (FRPLACD (CDR PTR)				X)		       (FRPLACD PTR XX))))      ERROR          (ERROR (QUOTE "bad argument - LCONC")		 XX))))(LDIFF  (LAMBDA (X Y Z)    (COND      ((EQ X Y)	Z)      ((AND (NULL Y)	    (NULL Z))	X)      (T (PROG (V)	       (COND		 (Z (SETQ V (CDR (FRPLACD (SETQ V (FLAST Z))					  (FRPLACD (CONS (CAR X)							 V))))))		 (T (SETQ V (SETQ Z (CONS (CAR X))))))	   LOOP(SETQ X (CDR X))	       (COND		 ((EQ X Y)		   (RETURN Z))		 ((NULL X)		   (RETURN (ERROR (QUOTE "LDIFF: not a tail")				  Y))))	       (SETQ V (CDR (FRPLACD V (FRPLACD (CONS (CAR X)						      V)))))	       (GO LOOP))))))(LDIFFERENCE  [LAMBDA (X Y)                                              (* lmm "27-Mar-84 16:26")    (for Z in X when (NOT (MEMBER Z Y)) collect Z])(LENGTH  (LAMBDA (X)    (PROG ((N 0))          (DECLARE (LOCALVARS N))      LP  (COND	    ((NLISTP X)	      (RETURN N))	    (T (SETN N (ADD1 N))	       (SETQ X (CDR X))	       (GO LP))))))(LISTGET  (LAMBDA (LST PROP)                                         (* like getp but works on lists, searching them two cdrs							     at a time.)    (PROG NIL      LP  (COND	    ((NLISTP LST)	      (RETURN))	    ((EQ (CAR LST)		 PROP)	      (RETURN (CADR LST))))          (SETQ LST (CDR (LISTP (CDR LST))))          (GO LP))))(LISTGET1  (LAMBDA (LST PROP)                                         (* Used to be called GET. Like LISTGET but only searches							     one cdr at a time.)    (PROG NIL      LP  (COND	    ((NLISTP LST)	      (RETURN))	    ((EQ (CAR LST)		 PROP)	      (RETURN (CADR LST))))          (SETQ LST (CDR LST))          (GO LP))))(LISTPUT  (LAMBDA (LST PROP VAL)                                     (* Like PUT but works on lists.							     Inverse of LISTGET)    (PROG ((X (OR (LISTP LST)		  (ERRORX (LIST 4 LST))))	   X0)      LOOP(COND	    ((NLISTP (CDR X))                                (* Odd parity; either (A B C) or 							     (A B C . D) -							     drop thru and add at beginning)	      )	    ((EQ (CAR X)		 PROP)                                       (* found it)	      (FRPLACA (CDR X)		       VAL)	      (RETURN VAL))	    ((LISTP (SETQ X (CDDR (SETQ X0 X))))	      (GO LOOP))	    ((NULL X)          (* Ran out without finding PROP on even parity. add at end If X is not NIL, means ended in a non-list following 	  even parity, e.g. (A B . C) so drop through and add at front.)	      (FRPLACD (CDR X0)		       (LIST PROP VAL))	      (RETURN VAL)))      ADDFRONT          (FRPLNODE LST PROP (CONS VAL (CONS (CAR LST)					     (CDR LST))))          (RETURN VAL))))(LISTPUT1  [LAMBDA (LST PROP VAL)                                     (* lmm "22-Oct-85 16:44")                                                             (* Used to be called PUTL. Like LISTPUT but only 							     searches one cdr at a time.							     Inverse of LISTGET1)    (PROG ((X LST))	LP  (COND	      [(NLISTP X)                                  (* Note no checks for lists ending in dotted pairs.)		(RETURN (NCONC LST (LIST PROP VAL]	      ((EQ (CAR X)		     PROP)		[COND		  ((CDR X)		    (FRPLACA (CDR X)			       VAL))		  (T (FRPLACD X (LIST VAL]		(RETURN LST)))	    (SETQ X (CDR X))	    (GO LP])(LSUBST  (LAMBDA (NEW OLD EXPR)                                     (* lmm "16-FEB-82 22:11")          (* Substitutes X as a segment for Y in Z. E.g. LSUBST ((A B) Y (X Y Z)) is (X A B Z) not meaningful for Y an atom 	  and CDR of a list. if X is NIL, operation effectively deletes Y, i.e. produces a copy without Y in it.)    (COND      ((NULL EXPR)	NIL)      ((NLISTP EXPR)	(COND	  ((EQ OLD EXPR)	    NEW)	  (T EXPR)))      ((EQUAL OLD (CAR EXPR))	(NCONC (COPY NEW)	       (LSUBST NEW OLD (CDR EXPR))))      (T (CONS (LSUBST NEW OLD (CAR EXPR))	       (LSUBST NEW OLD (CDR EXPR)))))))(MAP  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG NIL      LP  (COND	    ((NLISTP MAPX)	      (RETURN)))          (APPLY* MAPFN1 MAPX)          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP))))(MAP2C  (LAMBDA (MAPX MAPY MAPFN1 MAPFN2)    (PROG NIL      LP  (COND	    ((OR (NLISTP MAPX)		 (NLISTP MAPY))	      (RETURN)))          (APPLY* MAPFN1 (CAR MAPX)		  (CAR MAPY))          (COND	    (MAPFN2 (SETQ MAPX (APPLY* MAPFN2 MAPX))		    (SETQ MAPY (APPLY* MAPFN2 MAPY)))	    (T (SETQ MAPX (CDR MAPX))	       (SETQ MAPY (CDR MAPY))))          (GO LP))))(MAP2CAR  (LAMBDA (MAPX MAPY MAPFN1 MAPFN2)    (PROG (MAPL MAPE)      LP  (COND	    ((OR (NLISTP MAPX)		 (NLISTP MAPY))	      (RETURN MAPL)))          (SETQ MAPE (CONS (APPLY* MAPFN1 (CAR MAPX)				   (CAR MAPY))			   MAPE))          (COND	    (MAPL (FRPLACD (CDR MAPE)			   (FRPLACD MAPE)))	    (T (SETQ MAPL MAPE)))          (COND	    (MAPFN2 (SETQ MAPY (APPLY* MAPFN2 MAPY))		    (SETQ MAPX (APPLY* MAPFN2 MAPX)))	    (T (SETQ MAPY (CDR MAPY))	       (SETQ MAPX (CDR MAPX))))          (GO LP))))(MAPC  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG NIL      LP  (COND	    ((NLISTP MAPX)	      (RETURN)))          (APPLY* MAPFN1 (CAR MAPX))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP))))(MAPCAR  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL)))          (SETQ MAPE (CONS (APPLY* MAPFN1 (CAR MAPX))			   MAPE))          (COND	    (MAPL (FRPLACD (CDR MAPE)			   (FRPLACD MAPE)))	    (T (SETQ MAPL MAPE)))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP))))(MAPCON  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE MAPY)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL))	    ((LISTP (SETQ MAPY (APPLY* MAPFN1 MAPX)))	      (COND		(MAPE (FRPLACD MAPE MAPY))		(T (SETQ MAPL (SETQ MAPE MAPY))))	      (PROG NIL		LP  (COND		      ((SETQ MAPY (CDR MAPE))			(SETQ MAPE MAPY)			(GO LP))))))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP))))(MAPCONC  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE MAPY)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL))	    ((LISTP (SETQ MAPY (APPLY* MAPFN1 (CAR MAPX))))	      (COND		(MAPE (FRPLACD MAPE MAPY))		(T (SETQ MAPL (SETQ MAPE MAPY))))	      (PROG NIL		LP  (COND		      ((SETQ MAPY (CDR MAPE))			(SETQ MAPE MAPY)			(GO LP))))))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP))))(MAPLIST  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL)))          (SETQ MAPE (CONS (APPLY* MAPFN1 MAPX)			   MAPE))          (COND	    (MAPL (FRPLACD (CDR MAPE)			   (FRPLACD MAPE)))	    (T (SETQ MAPL MAPE)))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP))))(MEMBER  (LAMBDA (X Y)    (PROG NIL      LP  (RETURN (COND		    ((NLISTP Y)		      NIL)		    ((COND			((LITATOM X)			  (EQ X (CAR Y)))			(T (EQUAL X (CAR Y))))		      Y)		    (T (SETQ Y (CDR Y))		       (GO LP)))))))(NLEFT  [LAMBDA (L N TAIL)                                         (* bvm: "14-Feb-85 00:35")          (* Returns TAIL of L containing N elements more than TAIL, e.g. if TAIL is NIL (the usual case) NLEFT 	  ((A B C D E) 2) is (D E). If FOO is (A B C D E) and FIE is (CDDDR FOO), (NLEFT FOO 1 FIE) is 	  (C D E).)    (PROG ((X L)	   (Y L))      LP  (COND	    ((EQ N 0)	      (GO LP1))	    ((OR (EQ X TAIL)		 (NLISTP X))	      (RETURN NIL)))          (SETQ X (CDR X))          (SUB1VAR N)          (GO LP)      LP1 (COND	    ((OR (EQ X TAIL)		 (NLISTP X))	      (RETURN Y)))          (SETQ X (CDR X))          (SETQ Y (CDR Y))          (GO LP1])(NLSETQ  (NLAMBDA (NLSETX)    (ERRORSET NLSETX NIL)))(NOTANY  (LAMBDA (SOMEX SOMEFN1 SOMEFN2)    (NULL (SOME SOMEX SOMEFN1 SOMEFN2))))(NOTEVERY  (LAMBDA (EVERYX EVERYFN1 EVERYFN2)    (NULL (EVERY EVERYX EVERYFN1 EVERYFN2))))(NTH  (LAMBDA (X N)    (COND      ((IGREATERP 1 N)	(CONS NIL X))      (T (PROG NIL	   LP  (COND		 ((NOT (IGREATERP N 1))		   (RETURN X))		 ((NLISTP X)		   (RETURN NIL)))	       (SETQ X (CDR X))	       (SETQ N (SUB1 N))	       (GO LP))))))(PUTASSOC  (LAMBDA (KEY VAL ALST)                                     (* lmm: 5 SEP 75 119)    (PROG ((X (OR (LISTP ALST)		  (ERRORX (LIST 4 ALST)))))          (DECLARE (LOCALVARS X))      LP  (COND	    ((EQ (CAR (OR (LISTP (CAR X))			  (GO NEXT)))		 KEY)	      (FRPLACD (CAR X)		       VAL)	      (RETURN VAL)))      NEXT(SETQ X (OR (LISTP (CDR X))		      (PROGN (FRPLACD X (LIST (CONS KEY VAL)))			     (RETURN VAL))))          (GO LP))))(RATOMS  (LAMBDA (A FILE RDTBL)    (PROG (L X)      B   (COND	    ((EQ (SETQ X (RATOM FILE RDTBL))		 A)	      (RETURN (CAR L)))	    ((SETQ L (TCONC L X))	      (GO B))))))(REMOVE  (LAMBDA (X L)    (COND      ((NLISTP L)	NIL)      ((EQUAL X (CAR L))	(REMOVE X (CDR L)))      (T (CONS (CAR L)	       (REMOVE X (CDR L)))))))(REVERSE  (LAMBDA (L)    (PROG (U)          (DECLARE (LOCALVARS U))      LOOP(COND	    ((NLISTP L)	      (RETURN U)))          (SETQ U (CONS (CAR L)			U))          (SETQ L (CDR L))          (GO LOOP))))(RPT  (LAMBDA (RPTN RPTF)    (PROG (RPTV)          (DECLARE (LOCALVARS RPTV))      LP  (COND	    ((IGREATERP RPTN 0)	      (SETQ RPTV (EVAL RPTF (QUOTE INTERNAL)))	      (SETQ RPTN (SUB1 RPTN))	      (GO LP))	    (T (RETURN RPTV))))))(RPTQ  (NLAMBDA RPTZ    (PROG ((RPTN (EVAL (CAR RPTZ)		       (QUOTE INTERNAL)))	   RPTV)          (DECLARE (SPECVARS RPTN))      RPTQLOOP          (COND	    ((IGREATERP RPTN 0)	      (SETQ RPTV (APPLY (FUNCTION PROGN)				(CDR RPTZ)				(QUOTE INTERNAL)))	      (SETQ RPTN (SUB1 RPTN))	      (GO RPTQLOOP)))          (RETURN RPTV))))(FRPTQ  (NLAMBDA RPTZ    (DECLARE (LOCALVARS . T))    (PROG ((RPTN (EVAL (CAR RPTZ)		       (QUOTE INTERNAL)))	   RPTV)      RPTQLOOP          (COND	    ((IGREATERP RPTN 0)	      (SETQ RPTV (APPLY (FUNCTION PROGN)				(CDR RPTZ)				(QUOTE INTERNAL)))	      (SETQ RPTN (SUB1 RPTN))	      (GO RPTQLOOP)))          (RETURN RPTV))))(SASSOC  (LAMBDA (KEY ALST)    (PROG NIL      LP  (COND	    ((NLISTP ALST)	      (RETURN NIL))	    ((EQUAL (CAAR ALST)		    KEY)	      (RETURN (CAR ALST))))          (SETQ ALST (CDR ALST))          (GO LP))))(SAVEDEF  (LAMBDA (X)    (COND      ((ATOM X)	(SAVEDEF1 X))      (T (MAPCAR X (FUNCTION SAVEDEF1))))))(SAVEDEF1  (LAMBDA (X)    (PROG ((DF (GETD X)))          (RETURN (COND		    (DF (PUTPROP X (SETQ X (SELECTQ (FNTYP X)						    ((SUBR SUBR* FSUBR FSUBR*)						      (QUOTE SUBR))						    ((EXPR EXPR* FEXPR FEXPR*)						      (QUOTE EXPR))						    ((CEXPR CEXPR* CFEXPR CFEXPR*)						      (QUOTE CODE))						    (COND						      ((EXPRP X)							(QUOTE EXPR))						      (T (QUOTE LIST)))))				 DF)                         (* NOTE: this call to PUTPROP is changed to /PUTPROP 							     later in the loadup.)			X))))))(SELECT  (NLAMBDA .SELEC.    (DECLARE (LOCALVARS . T))                                (* dcl: 12 Dec 78 09:08)    (APPLY (QUOTE PROGN)	   (SELECT1 (EVAL (CAR .SELEC.)			  (QUOTE SELECTQ))		    (CDR .SELEC.))	   (QUOTE SELECTQ))))(SELECT1  (LAMBDA (M L)    (DECLARE (LOCALVARS . T))                                (* edited: 8 Dec 78 13:53)    (PROG (C A)      LP  (SETQ C L)          (COND	    ((NULL (SETQ L (CDR L)))	      (RETURN C))	    ((NLISTP (CAR (SETQ C (CAR C))))	      (AND (EQ M (EVAL (CAR C)			       (QUOTE INTERNAL)))		   (RETURN (CDR C)))	      (GO LP)))          (SETQ A (CAR C))      L2  (COND	    ((EQ M (EVAL (CAR A)			 (QUOTE INTERNAL)))	      (RETURN (CDR C)))	    ((LISTP (SETQ A (CDR A)))	      (GO L2))	    (T (GO LP))))))(SELECTC  (NLAMBDA SELCQ                                             (* lmm "28-FEB-82 16:07")    (DECLARE (LOCALVARS . T))    (APPLY (QUOTE PROGN)	   ((LAMBDA (M L)	       (PROG (C TL)		 LP  (SETQ C L)		     (COND		       ((NULL (SETQ L (CDR L)))			 (RETURN C))		       ((OR (EQ (SETQ TL (EVAL (CAR (SETQ C (CAR C)))					       (QUOTE INTERNAL)))				M)			    (AND (LISTP TL)				 (FMEMB M TL)))			 (RETURN (CDR C))))		     (GO LP)))	     (EVAL (CAR SELCQ)		   (QUOTE SELECTQ))	     (CDR SELCQ))	   (QUOTE SELECTQ))))(SETQQ  (NLAMBDA (X Y)    (SET X Y)))(SOME  (LAMBDA (SOMEX SOMEFN1 SOMEFN2)                            (* SOME compiles open.)    (PROG NIL      LOOP(COND	    ((NLISTP SOMEX)	      (RETURN NIL))	    ((APPLY* SOMEFN1 (CAR SOMEX)		     SOMEX)	      (RETURN SOMEX)))          (SETQ SOMEX (COND	      (SOMEFN2 (APPLY* SOMEFN2 SOMEX))	      (T (CDR SOMEX))))          (GO LOOP))))(STRMEMB  (LAMBDA (X Y)                                              (* rmk: " 6-JUN-82 15:08")    (PROG (C N)          (DECLARE (LOCALVARS C N))          (SETQ Y (SUBSTRING Y 1))      B   (SETQ N 1)      A   (COND	    ((NULL (SETQ C (NTHCHARCODE X N)))	      (RETURN Y)))          (COND	    ((EQ C (NTHCHARCODE Y N))	      (SETQ N (ADD1 N))	      (GO A)))          (COND	    ((NULL (GNC Y))	      (RETURN))	    (T (GO B))))))(SUB1VAR  (NLAMBDA (SUB1X)    (SET SUB1X (SUB1 (EVAL SUB1X)))))(SUBSET  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL))	    ((APPLY* MAPFN1 (CAR MAPX))	      (COND		((NULL MAPL)		  (SETQ MAPL (SETQ MAPE (CONS (CAR MAPX)))))		(T (SETQ MAPE (CDR (FRPLACD MAPE (FRPLACD (CONS (CAR MAPX)								MAPE)))))                                                             (* Eseentially an open TCONC.)		   ))))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP))))(SUBST  (LAMBDA (NEW OLD EXPR)                                     (* lmm "16-FEB-82 22:11")    (COND      ((NULL EXPR)	NIL)      ((NLISTP EXPR)	(COND	  ((EQ OLD EXPR)	    (COPY NEW))	  (T EXPR)))      (T (CONS (COND		 ((EQUAL OLD (CAR EXPR))		   (COPY NEW))		 (T (SUBST NEW OLD (CAR EXPR))))	       (SUBST NEW OLD (CDR EXPR)))))))(TAILP  (LAMBDA (X Y)                                              (* True if X is A tail of Y X and Y non-null.)                                                             (* Included with editor for block compilation purposes.)    (AND X (PROG NIL	     LP  (COND		   ((NLISTP Y)		     (RETURN NIL))		   ((EQ X Y)		     (RETURN X)))	         (SETQ Y (CDR Y))	         (GO LP)))))(TCONC  (LAMBDA (PTR X)    (PROG (XX)          (DECLARE (LOCALVARS XX))          (RETURN (COND		    ((NULL PTR)		      (CONS (SETQ XX (CONS X NIL))			    XX))		    ((NLISTP PTR)		      (ERROR (QUOTE "bad argument - TCONC")			     PTR))		    ((NULL (CDR PTR))		      (FRPLACA PTR (CONS X NIL))		      (FRPLACD PTR (CAR PTR)))		    (T (FRPLACD PTR (CDR (FRPLACD (CDR PTR)						  (FRPLACD (CONS X (CDR PTR))))))))))))(TIME  (NLAMBDA (TIMEX TIMEN TIMETYP)          (* If TIMETYP is 0, also prints real time, i.e. (CLOCK 0) if timetype is 3, does garbage collection time.	  If timetype is T does PAGEFAULTS.)                                                             (* Calls to prin1, terpri, print, and spaces changed to 							     correspoding lispx printing functions later in loadup.)    (PROG (TIMEY TIMECNS TIMEM TIMECLK1 TIMECLK2 TIMEZ)          (COND	    ((NULL TIMEN)	      (SETQ TIMEN 1))	    ((MINUSP TIMEN)	      (RETURN (CONS TIMEN (QUOTE (- ?)))))	    ((NOT (SMALLP TIMEN))	      (RETURN (CONS TIMEN (QUOTE (is too large))))))          (SETQ TIMEM TIMEN)          (SETQ TIMECNS (CONSCOUNT))          (SETQ TIMEZ (SELECTQ TIMETYP			       (0 (CLOCK 0))			       (3 (CLOCK 3))			       (T (PAGEFAULTS))			       NIL))          (SETQ TIMECLK1 (CLOCK 2))      T1  (COND	    ((NEQ TIMEM 0)	      (SETQ TIMEY (EVAL TIMEX))	      (SUB1VAR TIMEM)	      (GO T1)))          (SETQ TIMECLK2 (CLOCK 2))          (AND TIMEZ (SETQ TIMEZ (IDIFFERENCE (SELECTQ TIMETYP						       (0 (CLOCK 0))						       (3 (CLOCK 3))						       (T (PAGEFAULTS))						       (ERROR TIMETYP))					      TIMEZ)))          (SETQ TIMECNS (IDIFFERENCE (CONSCOUNT)				     TIMECNS))          (COND	    ((NEQ TIMEN 1)	      (PRIN1 TIMECNS T)	      (PRIN1 (QUOTE /)		     T)	      (PRIN1 TIMEN T)	      (PRIN1 (QUOTE " = ")		     T)))          (PRIN1 (IQUOTIENT TIMECNS TIMEN)		 T)          (SPACES 1 T)          (PRINT (QUOTE conses)		 T)          (SETQ TIMEM (FQUOTIENT (IPLUS TIMECLK2 (IMINUS TIMECLK1))				 1000))          (COND	    ((NEQ TIMEN 1)	      (PRIN1 TIMEM T)	      (PRIN1 (QUOTE /)		     T)	      (PRIN1 TIMEN T)	      (PRIN1 (QUOTE " = ")		     T)))          (PRIN1 (FQUOTIENT TIMEM TIMEN)		 T)          (SPACES 1 T)          (PRINT (QUOTE seconds)		 T)          (SELECTQ TIMETYP		   (0 (PRIN1 (FQUOTIENT TIMEZ 1000)			     T)		      (PRIN1 (QUOTE " seconds, real time")			     T))		   (3 (PRIN1 (FQUOTIENT TIMEZ 1000)			     T)		      (PRIN1 (QUOTE " seconds, garbage collection time")			     T))		   (T (PRIN1 TIMEZ T)		      (PRIN1 (QUOTE " page faults")			     T))		   NIL)          (RETURN TIMEY))))(UNION  (LAMBDA (X Y)    (DECLARE (LOCALVARS . T))                                (* lmm "31-DEC-78 14:47")    (PROG (VAL)      LP  (COND	    ((NLISTP X)	      (RETURN (ENDCOLLECT VAL Y)))	    ((COND		((LITATOM (CAR X))		  (NOT (FMEMB (CAR X)			      Y)))		(T (NOT (MEMBER (CAR X)				Y))))	      (SETQ VAL (DOCOLLECT (CAR X)				   VAL))))          (SETQ X (CDR X))          (GO LP)))))(RPAQ? COMPVARMACROHASH NIL)(ADDTOVAR CONSTANTFOLDFNS PLUS IPLUS TIMES ITIMES DIFFERENCE IDIFFERENCE QUOTIENT IQUOTIENT IMIN IMAX 			       IABS LLSH LRSH LOGOR LOGXOR LOGAND OR AND)(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS COMPVARMACROHASH CONSTANTFOLDFNS))(DECLARE: EVAL@COMPILE DONTCOPY (DECLARE: EVAL@COMPILE (RPAQQ \GS.BUFSIZE 100)(CONSTANTS (\GS.BUFSIZE 100))))(RPAQ? GENNUM 0)(RPAQ? \GS.OGENNUM -1)(RPAQ? \GS.NUMLEN 0)(RPAQ? \GS.BUF NIL)(RPAQ? \GS.STR (ALLOCSTRING 0))(ADDTOVAR PRETTYEQUIVLST (SELECTC . SELECTQ))(ADDTOVAR DWIMEQUIVLST (SELECTC . SELECTQ))(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS GENNUM \GS.OGENNUM \GS.NUMLEN \GS.BUF \GS.STR))(DECLARE: DOEVAL@COMPILE DONTCOPY(LOCALVARS . T))(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA SELECTC SELECT FRPTQ RPTQ DEFINEQ CONSTANTS APPENDTOVAR ADDTOVAR)(ADDTOVAR NLAML TIME SUB1VAR SETQQ NLSETQ ERSETQ ADD1VAR)(ADDTOVAR LAMA APPEND))(PUTPROPS MISC COPYRIGHT ("Xerox Corporation" 1982 1983 1984 1985 1986))(DECLARE: DONTCOPY  (FILEMAP (NIL (1748 35724 (ADD1VAR 1758 . 1827) (ADDTOVAR 1829 . 2322) (APPENDTOVAR 2324 . 2820) (APPEND 2822 . 3363) (\APPEND2 3365 . 3771) (ASSOC 3773 . 4089) (ATTACH 4091 . 4263) (CHANGEPROP 4265 . 4642) (CONCATLIST 4644 . 5553) (CONSTANTS 5555 . 5964) (CONSTANTEXPRESSIONP 5966 . 7161) (COPY 7163 . 7549) (DEFINEQ 7551 . 7593) (DEFLIST 7595 . 7922) (DREMOVE 7924 . 8324) (DREVERSE 8326 . 8552) (DSUBST 8554 . 9075) (EQLENGTH 9077 . 9515) (ERSETQ 9517 . 9574) (EVERY 9576 . 10002) (GENSYM 10004 . 14409) (GENSYM? 14411 . 14683) (\GS.INITBUF 14685 . 15416) (GETLIS 15418 . 15752) (INTERSECTION 15754 . 16149) (KWOTE 16151 . 16359) (LAST 16361 . 16561) (LASTN 16563 . 16911) (LCONC 16913 . 17451) (LDIFF 17453 . 17957) (LDIFFERENCE 17959 . 18138) (LENGTH 18140 . 18345) (LISTGET 18347 . 18699) (LISTGET1 18701 . 19048) (LISTPUT 19050 . 20064) (LISTPUT1 20066 . 20790) (LSUBST 20792 . 21429) (MAP 21431 . 21678) (MAP2C 21680 . 22055) (MAP2CAR 22057 . 22577) (MAPC 22579 . 22833) (MAPCAR 22835 . 23231) (MAPCON 23233 . 23691) (MAPCONC 23693 . 24158) (MAPLIST 24160 . 24551) (MEMBER 24553 . 24785) (NLEFT 24787 . 25564) (NLSETQ 25566 . 25625) (NOTANY 25627 . 25718) (NOTEVERY 25720 . 25820) (NTH 25822 . 26077) (PUTASSOC 26079 . 26546) (RATOMS 26548 . 26735) (REMOVE 26737 . 26907) (REVERSE 26909 . 27129) (RPT 27131 . 27382) (RPTQ 27384 . 27738) (FRPTQ 27740 . 28089) (SASSOC 28091 . 28313) (SAVEDEF 28315 . 28434) (SAVEDEF1 28436 . 28986) (SELECT 28988 . 29240) (SELECT1 29242 . 29792) (SELECTC 29794 . 30342) (SETQQ 30344 . 30387) (SOME 30389 . 30747) (STRMEMB 30749 . 31203) (SUB1VAR 31205 . 31274) (SUBSET 31276 . 31800) (SUBST 31802 . 32171) (TAILP 32173 . 32576) (TCONC 32578 . 33015) (TIME 33017 . 35304) (UNION 35306 . 35722)))))STOP