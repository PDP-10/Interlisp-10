(DEFINE-FILE-INFO §READTABLE "XCL" §PACKAGE "LISP")(IL:FILECREATED "20-Oct-86 17:28:06" IL:{ERIS}<LISPCORE>SOURCES>CMLSEQMAPPERS.\;8 23314        IL:|changes| IL:|to:|  (IL:VARS IL:CMLSEQMAPPERSCOMS)                             (IL:FUNCTIONS IL:ELT-SLICE IL:MAP-FOR-EFFECT)      IL:|previous| IL:|date:| "12-Oct-86 17:31:06" IL:{ERIS}<LISPCORE>SOURCES>CMLSEQMAPPERS.\;7); Copyright (c) 1986 by Xerox Corporation.  All rights reserved.(IL:PRETTYCOMPRINT IL:CMLSEQMAPPERSCOMS)(IL:RPAQQ IL:CMLSEQMAPPERSCOMS ((IL:DECLARE\: IL:EVAL@COMPILE IL:DONTCOPY (IL:FILES IL:CMLSEQCOMMON))                                (IL:FUNCTIONS IL:ELT-SLICE IL:MAP-FOR-EFFECT IL:%MAP-FOR-EFFECT                                        IL:%MAP-SINGLE-FOR-EFFECT IL:MAP-TO-LIST IL:%MAP-TO-LIST                                        IL:%MAP-SINGLE-TO-LIST IL:MAP-TO-SIMPLE IL:%MAP-TO-SIMPLE                                        IL:%MAP-SINGLE-TO-SIMPLE MAP)                                (IL:OPTIMIZERS IL:%MAP-FOR-EFFECT IL:%MAP-TO-LIST IL:%MAP-TO-SIMPLE                                        MAP)                                (IL:FUNCTIONS IL:%SINGLE-SOME SOME IL:%SINGLE-EVERY EVERY                                        IL:%SINGLE-NOTANY NOTANY IL:%SINGLE-NOTEVERY NOTEVERY)                                (IL:OPTIMIZERS SOME EVERY NOTANY NOTEVERY)                                (IL:FUNCTIONS IL:LIST-REDUCE-FROM-END IL:LIST-REDUCE                                        IL:MUMBLE-REDUCE-FROM-END IL:MUMBLE-REDUCE REDUCE)                                (IL:PROP IL:FILETYPE IL:CMLSEQMAPPERS)))(IL:DECLARE\: IL:EVAL@COMPILE IL:DONTCOPY (IL:FILESLOAD IL:CMLSEQCOMMON))(DEFMACRO IL:ELT-SLICE (IL:SEQUENCES IL:N) `(MAPCAR (IL:FUNCTION (LAMBDA (IL:SEQ)                                                                        (ELT IL:SEQ ,IL:N)))                                                   ,IL:SEQUENCES))(DEFMACRO IL:MAP-FOR-EFFECT NIL `(IF (NULL IL:MORE-SEQUENCES)                                     (IL:SEQ-DISPATCH IL:FIRST-SEQUENCE (IL:MAPC IL:FIRST-SEQUENCE                                                                                IL:FUNCTION)                                            (DOTIMES (IL:I (IL:VECTOR-LENGTH IL:FIRST-SEQUENCE))                                                   (FUNCALL IL:FUNCTION (AREF IL:FIRST-SEQUENCE IL:I)                                                          )))                                     (DO ((IL:SEQS IL:MORE-SEQUENCES (CDR IL:SEQS))                                          (IL:MIN-LENGTH (LENGTH IL:FIRST-SEQUENCE)))                                         ((NULL IL:SEQS)                                          (DO ((IL:INDEX 0 (1+ IL:INDEX)))                                              ((= IL:INDEX IL:MIN-LENGTH)                                               NIL)                                              (APPLY IL:FUNCTION (IL:ELT-SLICE IL:SEQUENCES IL:INDEX)                                                     )))                                         (LET ((IL:LENGTH (LENGTH (CAR IL:SEQS))))                                              (WHEN (< IL:LENGTH IL:MIN-LENGTH)                                                    (IL:SETQ IL:MIN-LENGTH IL:LENGTH))))))(IL:DEFUN IL:%MAP-FOR-EFFECT (IL:FUNCTION IL:FIRST-SEQUENCE &REST IL:MORE-SEQUENCES)       (LET ((IL:SEQUENCES (CONS IL:FIRST-SEQUENCE IL:MORE-SEQUENCES)))            (IL:MAP-FOR-EFFECT)))(IL:DEFUN IL:%MAP-SINGLE-FOR-EFFECT (IL:FUNCTION SEQUENCE)       (IL:SEQ-DISPATCH SEQUENCE (IL:MAPC SEQUENCE IL:FUNCTION)              (DOTIMES (IL:I (IL:VECTOR-LENGTH SEQUENCE))                     (FUNCALL IL:FUNCTION (AREF SEQUENCE IL:I)))))(DEFMACRO IL:MAP-TO-LIST NIL `(IF (NULL IL:MORE-SEQUENCES)                                  (IL:SEQ-DISPATCH IL:FIRST-SEQUENCE (IL:MAPCAR IL:FIRST-SEQUENCE                                                                             IL:FUNCTION)                                         (IL:|for| IL:I IL:|from| 0 IL:|to| (IL:VECTOR-LENGTH                                                                                    IL:FIRST-SEQUENCE)                                            IL:|collect| (FUNCALL IL:FUNCTION (AREF IL:I                                                                                     IL:FIRST-SEQUENCE                                                                                    ))))                                  (DO ((IL:SEQS IL:MORE-SEQUENCES (CDR IL:SEQS))                                       (IL:MIN-LENGTH (LENGTH IL:FIRST-SEQUENCE)))                                      ((NULL IL:SEQS)                                       (IL:FOR IL:INDEX IL:FROM 0 IL:TO (1- IL:MIN-LENGTH)                                          IL:COLLECT (APPLY IL:FUNCTION (IL:ELT-SLICE IL:SEQUENCES                                                                                IL:INDEX))))                                      (LET ((IL:LENGTH (LENGTH (CAR IL:SEQS))))                                           (WHEN (< IL:LENGTH IL:MIN-LENGTH)                                                 (SETF IL:MIN-LENGTH IL:LENGTH))))))(IL:DEFUN IL:%MAP-TO-LIST (IL:FUNCTION IL:FIRST-SEQUENCE &REST IL:MORE-SEQUENCES)       (LET ((IL:SEQUENCES (CONS IL:FIRST-SEQUENCE IL:MORE-SEQUENCES)))            (IL:MAP-TO-LIST)))(IL:DEFUN IL:%MAP-SINGLE-TO-LIST (IL:FUNCTION SEQUENCE)       (IL:SEQ-DISPATCH SEQUENCE (IL:MAPCAR SEQUENCE IL:FUNCTION)              (IL:|for| IL:I IL:|from| 0 IL:|to| (IL:VECTOR-LENGTH SEQUENCE)                     IL:|collect|                     (FUNCALL IL:FUNCTION (AREF IL:I SEQUENCE)))))(DEFMACRO IL:MAP-TO-SIMPLE NIL `(IF (NULL (CDR IL:SEQUENCES))                                    (LET* ((IL:LENGTH (LENGTH IL:FIRST-SEQUENCE))                                           (IL:RESULT (IL:MAKE-SEQUENCE-OF-TYPE IL:RESULT-TYPE                                                              IL:LENGTH)))                                          (IL:SEQ-DISPATCH IL:FIRST-SEQUENCE                                                 (IL:|for| IL:X IL:|in| (THE LIST IL:FIRST-SEQUENCE)                                                    IL:|as| IL:I IL:|from| 0                                                    IL:|do| (SETF (AREF IL:RESULT IL:I)                                                                  (FUNCALL IL:FUNCTION IL:X))                                                    IL:|finally| (RETURN IL:RESULT))                                                 (DOTIMES (IL:I IL:LENGTH IL:RESULT)                                                        (SETF (AREF IL:RESULT IL:I)                                                              (FUNCALL IL:FUNCTION                                                                     (AREF (THE VECTOR                                                                                 IL:FIRST-SEQUENCE)                                                                           IL:I))))))                                    (DO ((IL:SEQS IL:MORE-SEQUENCES (CDR IL:SEQS))                                         (IL:MIN-LENGTH (LENGTH IL:FIRST-SEQUENCE)))                                        ((NULL IL:SEQS)                                         (DO ((IL:INDEX 0 (1+ IL:INDEX))                                              (IL:RESULT (IL:MAKE-SEQUENCE-OF-TYPE IL:RESULT-TYPE                                                                 IL:MIN-LENGTH)))                                             ((= IL:INDEX IL:MIN-LENGTH)                                              IL:RESULT)                                             (SETF (AREF IL:RESULT IL:INDEX)                                                   (APPLY IL:FUNCTION (IL:ELT-SLICE IL:SEQUENCES                                                                              IL:INDEX)))))                                        (LET ((IL:LENGTH (LENGTH (CAR IL:SEQS))))                                             (WHEN (< IL:LENGTH IL:MIN-LENGTH)                                                   (SETF IL:MIN-LENGTH IL:LENGTH))))))(IL:DEFUN IL:%MAP-TO-SIMPLE (IL:RESULT-TYPE IL:FUNCTION IL:FIRST-SEQUENCE &REST IL:MORE-SEQUENCES)       (LET ((IL:SEQUENCES (CONS IL:FIRST-SEQUENCE IL:MORE-SEQUENCES)))            (IL:MAP-TO-SIMPLE)))(IL:DEFUN IL:%MAP-SINGLE-TO-SIMPLE (IL:OUTPUT-TYPE-SPEC IL:FUNCTION SEQUENCE)       (LET* ((IL:LENGTH (LENGTH SEQUENCE))              (IL:RESULT (IL:MAKE-SEQUENCE-OF-TYPE IL:OUTPUT-TYPE-SPEC IL:LENGTH)))             (IL:SEQ-DISPATCH SEQUENCE (IL:|for| IL:X IL:|in| (THE LIST SEQUENCE)                                              IL:|as| IL:I IL:|from| 0 IL:|do|                                              (SETF (AREF IL:RESULT IL:I)                                                    (FUNCALL IL:FUNCTION IL:X))                                              IL:|finally|                                              (RETURN IL:RESULT))                    (DOTIMES (IL:I IL:LENGTH IL:RESULT)                           (SETF (AREF IL:RESULT IL:I)                                 (FUNCALL IL:FUNCTION (AREF (THE VECTOR SEQUENCE)                                                            IL:I)))))))(IL:DEFUN MAP (IL:RESULT-TYPE IL:FUNCTION IL:FIRST-SEQUENCE &REST IL:MORE-SEQUENCES)       "FUNCTION must take as many arguments as there are sequences provided.  The result is a sequence such that element i is the result of applying FUNCTION to element i of each of the argument sequences."       (LET ((IL:SEQUENCES (CONS IL:FIRST-SEQUENCE IL:MORE-SEQUENCES)))            (CASE (IL:TYPE-SPECIFIER IL:RESULT-TYPE)                  (NIL (IL:MAP-FOR-EFFECT))                  (LIST (IL:MAP-TO-LIST))                  ((SIMPLE-VECTOR SIMPLE-STRING VECTOR STRING ARRAY SIMPLE-ARRAY BIT-VECTOR                           SIMPLE-BIT-VECTOR)                   (IL:MAP-TO-SIMPLE))                  (T (ERROR "~S: invalid output type specifier." IL:RESULT-TYPE)))))(IL:DEFOPTIMIZER IL:%MAP-FOR-EFFECT (IL:FUNCTION SEQUENCE &REST IL:MORE-SEQUENCES)   (COND      ((NULL IL:MORE-SEQUENCES)       `(IL:%MAP-SINGLE-FOR-EFFECT ,IL:FUNCTION ,SEQUENCE))      (T 'COMPILER:PASS)))(IL:DEFOPTIMIZER IL:%MAP-TO-LIST (IL:FUNCTION SEQUENCE &REST IL:MORE-SEQUENCES)   (COND      ((NULL IL:MORE-SEQUENCES)       `(IL:%MAP-SINGLE-TO-LIST ,IL:FUNCTION ,SEQUENCE))      (T 'COMPILER:PASS)))(IL:DEFOPTIMIZER IL:%MAP-TO-SIMPLE (IL:OUTPUT-TYPE-SPEC IL:FUNCTION SEQUENCE &REST IL:MORE-SEQUENCES)   (COND      ((NULL IL:MORE-SEQUENCES)       `(IL:%MAP-SINGLE-TO-SIMPLE ,IL:OUTPUT-TYPE-SPEC ,IL:FUNCTION ,SEQUENCE))      (T 'COMPILER:PASS)))(IL:DEFOPTIMIZER MAP (IL:RESULT-TYPE IL:FUNCTION &REST IL:SEQUENCES &CONTEXT IL:CTX &AUX IL:RES-TYPE)   (COND      ((IL:ZEROP (COMPILER:CONTEXT-VALUES-USED IL:CTX))       `(IL:%MAP-FOR-EFFECT ,IL:FUNCTION ,@IL:SEQUENCES))      ((PROG1 (IL:SETQ IL:RES-TYPE (IL:CONSTANTEXPRESSIONP IL:RESULT-TYPE))              (IL:SETQ IL:RES-TYPE (CAR IL:RES-TYPE)))       (CASE IL:RES-TYPE (NIL `(IL:%MAP-FOR-EFFECT ,IL:FUNCTION ,@IL:SEQUENCES))             (LIST `(IL:%MAP-TO-LIST ,IL:FUNCTION ,@IL:SEQUENCES))             (IL:OTHERWISE `(IL:%MAP-TO-SIMPLE ,IL:RES-TYPE ,IL:FUNCTION ,@IL:SEQUENCES))))      (T 'COMPILER:PASS)))(IL:DEFUN IL:%SINGLE-SOME (IL:PREDICATE SEQUENCE)       (IL:SEQ-DISPATCH SEQUENCE (DOLIST (IL:E (THE LIST SEQUENCE)                                               NIL)                                        (LET ((IL:X (FUNCALL IL:PREDICATE IL:E)))                                             (WHEN IL:X (RETURN IL:X))))              (DOTIMES (IL:I (IL:VECTOR-LENGTH SEQUENCE NIL)                             (LET ((IL:X (FUNCALL IL:PREDICATE (AREF (THE VECTOR SEQUENCE)                                                                     IL:I))))                                  (WHEN IL:X (RETURN IL:X)))))))(IL:DEFUN SOME (IL:PREDICATE IL:FIRST-SEQUENCE &REST IL:MORE-SEQUENCES)       "PREDICATE is applied to the elements with index 0 of the sequences, then possibly to those with index 1, and so on.  SOME returns the first non-() value encountered, or () if the end of a sequence is reached."       (IF (NULL IL:MORE-SEQUENCES)           (IL:%SINGLE-SOME IL:PREDICATE IL:FIRST-SEQUENCE)           (DO ((IL:SEQS IL:MORE-SEQUENCES (CDR IL:SEQS))                (IL:LENGTH (LENGTH IL:FIRST-SEQUENCE))                (IL:SEQUENCES (CONS IL:FIRST-SEQUENCE IL:MORE-SEQUENCES)))               ((NULL IL:SEQS)                (DO ((IL:INDEX 0 (1+ IL:INDEX)))                    ((= IL:INDEX IL:LENGTH)                     NIL)                    (LET ((IL:RESULT (APPLY IL:PREDICATE (IL:ELT-SLICE IL:SEQUENCES IL:INDEX))))                         (WHEN IL:RESULT (RETURN IL:RESULT)))))               (LET ((IL:THIS (LENGTH (CAR IL:SEQS))))                    (WHEN (< IL:THIS IL:LENGTH)                          (IL:SETQ IL:LENGTH IL:THIS))))))(IL:DEFUN IL:%SINGLE-EVERY (IL:PREDICATE SEQUENCE)       (IL:SEQ-DISPATCH SEQUENCE (DOLIST (IL:E (THE LIST SEQUENCE)                                               T)                                        (UNLESS (FUNCALL IL:PREDICATE IL:E)                                               (RETURN NIL)))              (DOTIMES (IL:I (IL:VECTOR-LENGTH SEQUENCE)                             T)                     (DECLARE (VECTOR SEQUENCE))                     (UNLESS (FUNCALL IL:PREDICATE (AREF SEQUENCE IL:I))                            (RETURN NIL)))))(IL:DEFUN EVERY (IL:PREDICATE IL:FIRST-SEQUENCE &REST IL:MORE-SEQUENCES)       "PREDICATE is applied to the elements with index 0 of the sequences, then possibly to those with index 1, and so on.  EVERY returns () as soon as any invocation of PREDICATE returns (), or T if every invocation is non-()."       (IF (NULL IL:MORE-SEQUENCES)           (IL:%SINGLE-EVERY IL:PREDICATE IL:FIRST-SEQUENCE)           (DO ((IL:SEQS IL:MORE-SEQUENCES (CDR IL:SEQS))                (IL:LENGTH (LENGTH IL:FIRST-SEQUENCE))                (IL:SEQUENCES (CONS IL:FIRST-SEQUENCE IL:MORE-SEQUENCES)))               ((NULL IL:SEQS)                (DO ((IL:INDEX 0 (1+ IL:INDEX)))                    ((= IL:INDEX IL:LENGTH)                     T)                    (LET ((IL:RESULT (APPLY IL:PREDICATE (IL:ELT-SLICE IL:SEQUENCES IL:INDEX))))                         (UNLESS IL:RESULT (RETURN NIL)))))               (LET ((IL:THIS (LENGTH (CAR IL:SEQS))))                    (WHEN (< IL:THIS IL:LENGTH)                          (IL:SETQ IL:LENGTH IL:THIS))))))(IL:DEFUN IL:%SINGLE-NOTANY (IL:PREDICATE SEQUENCE)       (IL:SEQ-DISPATCH SEQUENCE (DOLIST (IL:E (THE LIST SEQUENCE)                                               T)                                        (WHEN (FUNCALL IL:PREDICATE IL:E)                                              (RETURN NIL)))              (DOTIMES (IL:I (IL:VECTOR-LENGTH SEQUENCE)                             T)                     (DECLARE (VECTOR SEQUENCE))                     (WHEN (FUNCALL IL:PREDICATE (AREF SEQUENCE IL:I))                           (RETURN NIL)))))(IL:DEFUN NOTANY (IL:PREDICATE IL:FIRST-SEQUENCE &REST IL:MORE-SEQUENCES)       "PREDICATE is applied to the elements with index 0 of the sequences, then possibly to those with index 1, and so on.  NOTANY returns () as soon as any invocation of PREDICATE returns a non-() value, or T if the end of a sequence is reached."       (IF (NULL IL:MORE-SEQUENCES)           (IL:%SINGLE-NOTANY IL:PREDICATE IL:FIRST-SEQUENCE)           (DO ((IL:SEQS IL:MORE-SEQUENCES (CDR IL:SEQS))                (IL:LENGTH (LENGTH IL:FIRST-SEQUENCE))                (IL:SEQUENCES (CONS IL:FIRST-SEQUENCE IL:MORE-SEQUENCES)))               ((NULL IL:SEQS)                (DO ((IL:INDEX 0 (1+ IL:INDEX)))                    ((= IL:INDEX IL:LENGTH)                     T)                    (LET ((IL:RESULT (APPLY IL:PREDICATE (IL:ELT-SLICE IL:SEQUENCES IL:INDEX))))                         (WHEN IL:RESULT (RETURN NIL)))))               (LET ((IL:THIS (LENGTH (CAR IL:SEQS))))                    (WHEN (< IL:THIS IL:LENGTH)                          (IL:SETQ IL:LENGTH IL:THIS))))))(IL:DEFUN IL:%SINGLE-NOTEVERY (IL:PREDICATE SEQUENCE)       (IL:SEQ-DISPATCH SEQUENCE (DOLIST (IL:E (THE LIST SEQUENCE)                                               NIL)                                        (LET ((IL:X (FUNCALL IL:PREDICATE IL:E)))                                             (WHEN IL:X (RETURN T))))              (DOTIMES (IL:I (IL:VECTOR-LENGTH SEQUENCE)                             NIL)                     (DECLARE (VECTOR SEQUENCE))                     (LET ((IL:X (FUNCALL IL:PREDICATE (AREF SEQUENCE IL:I))))                          (WHEN IL:X (RETURN T))))))(IL:DEFUN NOTEVERY (IL:PREDICATE IL:FIRST-SEQUENCE &REST IL:MORE-SEQUENCES)       "PREDICATE is applied to the elements with index 0 of the sequences, then possibly to those with index 1, and so on.  NOTEVERY returns T as soon as any invocation of PREDICATE returns (), or () if every invocation is non-()."       (IF (NULL IL:MORE-SEQUENCES)           (IL:%SINGLE-NOTEVERY IL:PREDICATE IL:FIRST-SEQUENCE)           (DO ((IL:SEQS IL:MORE-SEQUENCES (CDR IL:SEQS))                (IL:LENGTH (LENGTH IL:FIRST-SEQUENCE))                (IL:SEQUENCES (CONS IL:FIRST-SEQUENCE IL:MORE-SEQUENCES)))               ((NULL IL:SEQS)                (DO ((IL:INDEX 0 (1+ IL:INDEX)))                    ((= IL:INDEX IL:LENGTH)                     NIL)                    (LET ((IL:RESULT (APPLY IL:PREDICATE (IL:ELT-SLICE IL:SEQUENCES IL:INDEX))))                         (UNLESS IL:RESULT (RETURN T)))))               (LET ((IL:THIS (LENGTH (CAR IL:SEQS))))                    (WHEN (< IL:THIS IL:LENGTH)                          (IL:SETQ IL:LENGTH IL:THIS))))))(IL:DEFOPTIMIZER SOME (IL:PREDICATE SEQUENCE &REST IL:MORE-SEQUENCES) (COND                                                                         ((NULL IL:MORE-SEQUENCES)                                                                          `(IL:%SINGLE-SOME                                                                            ,IL:PREDICATE                                                                            ,SEQUENCE))                                                                         (T 'COMPILER:PASS)))(IL:DEFOPTIMIZER EVERY (IL:PREDICATE SEQUENCE &REST IL:MORE-SEQUENCES) (COND                                                                          ((NULL IL:MORE-SEQUENCES)                                                                           `(IL:%SINGLE-EVERY                                                                             ,IL:PREDICATE                                                                             ,SEQUENCE))                                                                          (T 'COMPILER:PASS)))(IL:DEFOPTIMIZER NOTANY (IL:PREDICATE SEQUENCE &REST IL:MORE-SEQUENCES)   (COND      ((NULL IL:MORE-SEQUENCES)       `(IL:%SINGLE-NOTANY ,IL:PREDICATE ,SEQUENCE))      (T 'COMPILER:PASS)))(IL:DEFOPTIMIZER NOTEVERY (IL:PREDICATE SEQUENCE &REST IL:MORE-SEQUENCES)   (COND      ((NULL IL:MORE-SEQUENCES)       `(IL:%SINGLE-NOTEVERY ,IL:PREDICATE ,SEQUENCE))      (T 'COMPILER:PASS)))(DEFMACRO IL:LIST-REDUCE-FROM-END (IL:FUNCTION SEQUENCE IL:START IL:END IL:INITIAL-VALUE                                          IL:INITIAL-PROVIDED)   `(LET ((SEQUENCE (NTHCDR (- (LENGTH ,SEQUENCE)                               ,IL:END)                           (IL:REVERSE ,SEQUENCE))))         (WHEN ,IL:INITIAL-PROVIDED (PUSH ,IL:INITIAL-VALUE SEQUENCE))         (DO* ((IL:COUNT (- ,IL:END ,IL:START (IF ,IL:INITIAL-PROVIDED 0 1))                      (1- IL:COUNT))               (SEQUENCE SEQUENCE (CDR SEQUENCE))               (IL:VALUE (CAR SEQUENCE)                      (FUNCALL ,IL:FUNCTION (CAR SEQUENCE)                             IL:VALUE)))              ((= IL:COUNT 0)               IL:VALUE))))(DEFMACRO IL:LIST-REDUCE (IL:FUNCTION SEQUENCE IL:START IL:END IL:INITIAL-VALUE IL:INITIAL-PROVIDED)   `(LET ((SEQUENCE (NTHCDR ,IL:START ,SEQUENCE)))         (WHEN ,IL:INITIAL-PROVIDED (PUSH ,IL:INITIAL-VALUE SEQUENCE))         (DO* ((IL:COUNT (- IL:END IL:START (IF ,IL:INITIAL-PROVIDED 0 1))                      (1- IL:COUNT))               (SEQUENCE SEQUENCE (CDR SEQUENCE))               (IL:VALUE (CAR SEQUENCE)                      (FUNCALL ,IL:FUNCTION IL:VALUE (CAR SEQUENCE))))              ((= IL:COUNT 0)               IL:VALUE))))(DEFMACRO IL:MUMBLE-REDUCE-FROM-END (IL:FUNCTION SEQUENCE IL:START IL:END IL:INITIAL-VALUE IL:REF)   `(DO ((IL:INDEX (1- ,IL:END)                (1- IL:INDEX))         (IL:VALUE ,IL:INITIAL-VALUE)         (IL:TERMINUS (1- ,IL:START)))        ((<= IL:INDEX IL:TERMINUS)         IL:VALUE)        (IL:SETQ IL:VALUE (FUNCALL ,IL:FUNCTION (,IL:REF ,SEQUENCE IL:INDEX)                                 IL:VALUE))))(DEFMACRO IL:MUMBLE-REDUCE (IL:FUNCTION SEQUENCE IL:START IL:END IL:INITIAL-VALUE IL:REF)   `(DO ((IL:INDEX ,IL:START (1+ IL:INDEX))         (IL:VALUE ,IL:INITIAL-VALUE))        ((>= IL:INDEX ,IL:END)         IL:VALUE)        (IL:SETQ IL:VALUE (FUNCALL ,IL:FUNCTION IL:VALUE (,IL:REF ,SEQUENCE IL:INDEX)))))(IL:DEFUN REDUCE (IL:FUNCTION SEQUENCE &KEY IL:FROM-END (IL:START 0)                        IL:END                        (IL:INITIAL-VALUE NIL IL:INITIAL-PROVIDED)                        &AUX                        (IL:LENGTH (LENGTH SEQUENCE)))       (UNLESS IL:END (IL:SETQ IL:END IL:LENGTH))       (IL:CHECK-SUBSEQ SEQUENCE IL:START IL:END IL:LENGTH)       (COND ((= IL:END IL:START)              (IF IL:INITIAL-PROVIDED IL:INITIAL-VALUE (FUNCALL IL:FUNCTION)))             ((LISTP SEQUENCE)              (IF IL:FROM-END (IL:LIST-REDUCE-FROM-END IL:FUNCTION SEQUENCE IL:START IL:END                                      IL:INITIAL-VALUE IL:INITIAL-PROVIDED)                  (IL:LIST-REDUCE IL:FUNCTION SEQUENCE IL:START IL:END IL:INITIAL-VALUE                          IL:INITIAL-PROVIDED)))             (T (COND (IL:FROM-END (UNLESS IL:INITIAL-PROVIDED (SETQ IL:END (1- IL:END)                                                                     IL:INITIAL-VALUE                                                                     (AREF SEQUENCE IL:END)))                             (IL:MUMBLE-REDUCE-FROM-END IL:FUNCTION SEQUENCE IL:START IL:END                                     IL:INITIAL-VALUE AREF))                      (T (UNLESS IL:INITIAL-PROVIDED (SETQ IL:INITIAL-VALUE (AREF SEQUENCE IL:START)                                                           IL:START                                                           (1+ IL:START)))                         (IL:MUMBLE-REDUCE IL:FUNCTION SEQUENCE IL:START IL:END IL:INITIAL-VALUE AREF                                ))))))(IL:PUTPROPS IL:CMLSEQMAPPERS IL:FILETYPE COMPILE-FILE)(IL:PUTPROPS IL:CMLSEQMAPPERS IL:COPYRIGHT ("Xerox Corporation" 1986))(IL:DECLARE\: IL:DONTCOPY  (IL:FILEMAP (NIL)))IL:STOP