(DEFINE-FILE-INFO §READTABLE "XCL" §PACKAGE "INTERLISP")(filecreated "18-Oct-86 22:22:49" {eris}<lispcore>sources>cmlcompile.\;14 35578        |previous| |date:| "12-Oct-86 16:03:55" {eris}<lispcore>sources>cmlcompile.\;13); Copyright (c) 1985, 1986 by Xerox Corporation.  All rights reserved.(prettycomprint cmlcompilecoms)(rpaqq cmlcompilecoms        ((coms (functions cl:compile cl:disassemble)              (fns cl:compile-file interlisp-format-p interlisp-nlambda-function-p                    compile-file-expression compile-file-walk-function argtype.state                    compile.check.argtype compile.file.defineq compile-file-setf-symbol-function                    compile-file-ex/import compile.file.apply compile.file.reset compile-in-core)              (vars argtype.vars)              (prop compile-file-expression defineq * setf-symbol-function prettycomprint)              (functions compile-file-declare\:))        (coms (fns newdefc)              (declare\: donteval@load docopy (p (movd 'newdefc 'defc))))        (coms (* \; "Optimizer definitions and environment hacking")              (define-types optimizers)              (functions compiler:optimizer-list)              (functions defoptimizer)              (structures compiler::env compiler:context)              (fns compiler:copy-env-with-function compiler:copy-env-with-variable                    compiler:env-boundp compiler:env-fboundp compiler:make-empty-env))        (prop filetype cmlcompile)        (declare\: donteval@load doeval@compile dontcopy compilervars               (addvars (nlama)                      (nlaml)                      (lama compiler:make-empty-env compiler:env-fboundp compiler:env-boundp                             compiler:copy-env-with-variable compiler:copy-env-with-function                             cl:compile-file)))))(cl:defun cl:compile (name &optional lambda-expr) (let ((new-name (or name '\\clcompiletemp)))                                                       (compile-in-core new-name (or lambda-expr                                                                                     (getd name)))                                                       (and lambda-expr name (/putprop name                                                                                    'expr lambda-expr                                                                                    ))                                                       (or name (getd new-name))))(cl:defun cl:disassemble (name-or-compiled-function &key level-p (radix 8)                                (output *standard-output*)                                first-byte marked-pc)   (printcode (|if| (ccodep name-or-compiled-function)                    |then| name-or-compiled-function |else| (cl:compile nil (|if| (cl:symbolp                                                                             name-or-compiled-function                                                                                         )                                                                                  |then|                                                                                  (cl:symbol-function                                                                                                                                                               name-or-compiled-function                                                                                   )                                                                                  |else|                                                                             name-or-compiled-function                                                                                  )))          level-p radix output first-byte marked-pc))(defineq(cl:compile-file  (cl:lambda (filename &key lap redefine output-file (save-exprs t)                    (compiler-output t)                    (process-entire-file nil pefp))          (* |Pavel| " 6-Oct-86 22:36")         (let (compile.file.after value compile.file.value)              (declare (cl:special compile.file.after compile.file.value))              (resetlst (resetsave nil (list 'resetundo)                               (resetundo))                     (resetsave nlaml nlaml)                     (resetsave nlama nlama)                     (resetsave lams lams)                     (resetsave lama lama)                     (resetsave dfnflg nil)                     (resetsave coutfile compiler-output)                     (resetsave strf redefine)                     (resetsave svflg (and save-exprs redefine 'defer))                     (resetsave lapflg lap)                     (let ((*package* *interlisp-package*)                           (*read-base* 10)                           (localvars syslocalvars)                           (specvars t)                           stream lstfil rootname interlisp-format env form)                          (declare (cl:special *package* *read-base* localvars specvars lstfil))                          (resetsave nil (list (function closef?)                                               (setq stream (openstream filename 'input))))                          (cl:multiple-value-setq (env form)                                 (\\parse-file-header stream 'return t))                          (setq interlisp-format (and env (neq env *common-lisp-read-environment*)))                          (|if| (not pefp)                                |then|                                (setq process-entire-file interlisp-format))                          (|if| lap |then| (setq lstfil coutfile))                          (setq filename (fullname stream))                          (resetsave nil (list (function compile.file.reset)                                               (setq output-file (openstream                                                                  (or output-file (                                                                                  packfilename.string                                                                                   'version nil                                                                                   'extension                                                                                    compile.ext                                                                                   'body filename))                                                                  'output                                                                  'new                                                                  '((type binary))))                                               stream                                               (rootfilename filename)))                          (|if| output-file |then| (resetsave lcfil output-file)                                (print-compile-header (list stream)                                       '("COMPILE-FILEd") env))                          (with-reader-environment                           env                           (prog (deferred.expressions)                                 (declare (cl:special deferred.expressions))                             lp  (compile-file-expression form output-file nil process-entire-file)                                 (skipseprcodes stream)                                 (|if| (eofp stream)                                       |then|                                       (and process-entire-file (|for| exp |in| (reverse                                                                                  deferred.expressions                                                                                       )                                                                       |do|                                                                       (apply* (car exp)                                                                              (cdr exp)                                                                              output-file)))                                       (closef stream)                                       (return))                                 (setq form (let ((expression (read stream)))                                                 (|if| interlisp-format |then| expression |else|                                                       (cmltranslate expression))))                                 (go lp))                           (print nil output-file))                          (setq compile.file.value (closef output-file))))                                                          (* \; "Do these after UNDONLSETQ entered")              (mapc (reverse compile.file.after)                    (function eval))              compile.file.value)))(interlisp-format-p  (lambda (stream)                                           (* |bvm:| " 3-Aug-86 14:01")    (selcharq (peekccode stream)         (\; nil)         ((^f "(")               t)         nil)))(interlisp-nlambda-function-p  (lambda (x)                                                (* |lmm| " 7-May-86 20:12")    (and (litatom x)         (fmemb (argtype x)                '(1 3))         (not (cl:special-form-p x)))))(compile-file-expression  (lambda (form compiled.file compile.time.too defer)        (* |Pavel| "22-Sep-86 14:36")    (declare (cl:special compiled.file))    (and (listp form)         (selectq (car form)             ((declare\:)                   (compile-file-declare\: form compiled.file compile.time.too t defer))             ((progn)                   (|for| x |in| (cdr form)                         |do|                         (compile-file-expression x compiled.file compile.time.too defer)))             ((quote)                                (* \; " ignore top level quoted expression -i")                  nil)             ((cl:compiler-let)                   (* \; " top level compiler-let. bind variables and recursively compile sub-expressions. This is here mainly  for b PCL has top level compiler-lets")                  (let ((vars (cl:mapcar #'(cl:lambda (x)                                                  (|if| (cl:consp x)                                                        |then|                                                        (car x)                                                        |else| x)) (cadr form)))                        (vals (cl:mapcar #'(cl:lambda (x)                                                  (|if| (cl:consp x)                                                        |then|                                                        (cl:eval (cadr x)))) (cadr form))))                       (cl:progv vars vals (cl:mapc #'(cl:lambda (x)                                                             (compile-file-expression x compiled.file                                                                     compile.time.too defer))                                                  (cddr form)))))             ((cl:eval-when)                   (let ((eval.specified (or (fmemb 'eval (cadr form))                                            (fmemb 'cl:eval (cadr form))))                        (load.specified (or (fmemb 'load (cadr form))                                            (fmemb 'cl:load (cadr form))))                        (compile.specified (or (fmemb 'compile (cadr form))                                               (fmemb 'cl:compile (cadr form)))))                       (cond                          ((not load.specified)                           (cond                              ((or compile.specified (and compile.time.too eval.specified))                               (|for| inner-form |in| (cddr form)                                      |do|                                      (eval inner-form)))))                          (t (|for| inner-form |in| (cddr form)                                    |do|                                    (compile-file-expression inner-form compiled.file                                           (or compile.specified (and compile.time.too eval.specified                                                                      ))                                           defer))))))             ((cl:in-package)                     (* \;                "This is special because it has to be dumped to the output BEFORE the package changes")                  (print form compiled.file filerdtbl)                  (eval form))             (let ((prop (or (getprop (car form)                                    'compile-file-expression)                             (getprop (car form)                                    'compile.file.expression))))                  (|if| (and (not prop)                             (not (cl:special-form-p (car form)))                             (not (interlisp-nlambda-function-p (car form)))                             (neq form (setq form (cl:macroexpand-1 form))))                        |then|                        (compile-file-expression form compiled.file compile.time.too defer)                        |else|                        (|if| compile.time.too |then| (eval form))                        (|if| prop |then| (compile.file.apply prop form defer)                              |elseif|                              (not (equal form (setq form (walk-form form :walk-function                                                                 (function compile-file-walk-function                                                                  )))))                              |then|                              (compile-file-expression form compiled.file compile.time.too defer)                              |else|                              (compile.file.apply (function print)                                     form defer))))))))(compile-file-walk-function  (lambda (form)                                             (* |lmm| "26-Jun-86 17:25")    (|if| (nlistp form)          |then| form |else| (cl:values form (interlisp-nlambda-function-p (car form))))))(argtype.state  (lambda nil    (|for| x |in| argtype.vars |do| (printout t x \, (eval (cadr x))                                           t))))(compile.check.argtype  (lambda (x at)                                             (* |lmm| "15-Jun-85 16:58")    (|if| (neq at (let (blkflg)                       (comp.argtype x)))          |then|                                   (* \; "Incorrectly on one of the defining lists")          (|for| atypepair |in| argtype.vars |do|                 (let ((val (fmemb x (evalv (cadr atypepair)))))                      (|if| (eq at (car atypepair))                            |then|                            (|if| val |then| (printout coutfile "Compiler confused: " x " on "                                                    (cadr atypepair)                                                    " but compiler doesn't think its a "                                                    (caddr atypepair)))                            (/settopval (cadr atypepair)                                   (cons x (progn (gettopval (cadr atypepair)))))                            |else|                            (|if| val |then| (printout coutfile "Warning: compiler thought " x " "                                                    (list '\a (or (caddr (assoc at argtype.vars))                                                                  "LAMBDA spread")                                                          '|function|)                                                    " was a "                                                    (caddr atypepair)                                                    " because it was incorrectly on "                                                    (cadr atypepair)                                                    t)                                  (/settopval (cadr atypepair)                                         (remove x (progn (gettopval (cadr atypepair))))))))))))(compile.file.defineq  (lambda (form lcfil)                                       (* |bvm:| "18-Sep-86 14:35")    (|for| def |in| (cdr form)           |unless|           (fmemb (car def)                  dontcompilefns)           |do|           (compile.check.argtype (car def)                  (argtype (cadr def)))           (bytecompile2 (car def)                  (compile1a (car def)                         (cadr def)                         nil)))))(compile-file-setf-symbol-function  (lambda (form lcfil)                                       (* |bvm:| " 8-Sep-86 16:55")    (|if| (and (fmemb (car (listp (cl:third form)))                      '(function cl:function))               (eq (car (listp (cl:second form)))                   'quote)               (cl:consp (cl:second (cl:third form))))          |then|          (bytecompile2 (cadr (cl:second form))                 (cadr (cl:third form)))          |else|          (print (walk-form form :walk-function (function compile-file-walk-function))                 lcfil))))(compile-file-ex/import  (lambda (form lcfil rdtbl)                                 (* |bvm:| " 3-Aug-86 15:05")                    (* * "EXPORT, IMPORT, SHADOW, USE-PACKAGE are all implicitly EVAL@COMPILE, since they have to affect the package being used to read what follows")    (print form lcfil rdtbl)    (eval form)))(compile.file.apply  (lambda (prop form defer)                                  (* |bvm:| " 8-Sep-86 16:55")    (|if| defer |then| (|push| deferred.expressions (cons prop form))          |else|          (apply* prop form compiled.file))))(compile.file.reset  (lambda (compiled.file sourcefile rootname)                (* |bvm:| " 9-Sep-86 15:16")                                                             (* |Cleans| |up| |after| |brecompile|                                                              |and| |bcompl| |have| |finished|                                                              |operating,|)    (|if| (and compiled.file (openp compiled.file))          |then|          (close-and-maybe-delete compiled.file))    (|if| sourcefile |then| (closef? sourcefile))    (|if| (null resetstate)          |then|                                             (* |Finished| |successfully.|)          (/setatomval 'notcompiledfiles (remove rootname notcompiledfiles))                                                             (* |Removes| files |from|                                                              notcompiledfiles.)          )))(compile-in-core  (lambda (|fn-name| |fn-expr| |fn-type| nosave)    (declare (specvars lcfil lapflg strf svflg lstfil specvars localvars dont-transfer-putd))                                                             (* |lmm| " 2-Jun-86 22:04")                    (* |in-core| |compiling| |for| |functions| |and| |forms,| |without| |the|           |interview.| |if| x |is| \a |list,| |we| |assume| |that| |we| |are| |being|           |called| |merely| |to| |display| |the| |lap| |and| |machine| |code.|          |the| |form| |is| |compiled| |as| |the| |definition| |of| foo |but| |the|           |compiled| :code |is| |thrown| |away.| -          |if| x |is| \a |litatom,| |then| |saving,| |redefining,| |and| |printing| |is|           |controlled| |by| |the| |flags.|)    (let ((noredefine nil)          (printlap nil)          (dont-transfer-putd t))         (resetvars ((nlama nlama)                     (nlaml nlaml)                     (lams lams)                     (lama lama)                     (nofixfnslst nofixfnslst)                     (nofixvarslst nofixvarslst)                     (coutfile (cond                                  ((and (boundp 'nullfile)                                        (streamp nullfile)                                        (openp nullfile))                                   nullfile)                                  (t (setq nullfile (openfile '{null} 'output))))))                    (return (resetlst                     (* resetlst |to| |provide| |reset| |context| |for| |macros| |under| compile1           |as| |generated| |e.g.| |by| decl.)                                   (prog ((lcfil)                                          (lapflg (and printlap (cond                                                                   (bytecompflg t)                                                                   (t 2))))                                          (strf (not noredefine))                                          (svflg (|if| (eq |fn-type| 'selector)                                                       |then|                                                       'selector |else| (not nosave)))                                          (lstfil t)                                          (specvars sysspecvars)                                          (localvars t))                                         (return (progn (setq |fn-expr| (compile1a |fn-name|                                                                                |fn-expr| t))                                                        (prog ((freevars freevars))                                                              (return (bytecompile2 |fn-name|                                                                              |fn-expr|)))))))))))))(rpaqq argtype.vars ((1 nlaml "NLAMBDA spread")                     (2 lama "LAMBDA nospread")                     (0 lams "LAMBDA spread")                     (3 nlama "NLAMBDA no-spread")))(putprops defineq compile-file-expression compile.file.defineq)(putprops * compile-file-expression nill)(putprops setf-symbol-function compile-file-expression compile-file-setf-symbol-function)(putprops prettycomprint compile-file-expression nill)(cl:defun compile-file-declare\: (form compiled.file eval@compile docopy defer)   (cl:do ((tail (cdr form)                 (cdr tail)))          ((cl:endp tail))          (cl:if (cl:symbolp (car tail))                 (case (car tail)                       ((eval@load doeval@load donteval@load)                        nil)                       ((eval@loadwhen)                        (cl:pop tail))                       ((eval@compile doeval@compile)                        (setq eval@compile t))                       ((donteval@compile)                        (setq eval@compile nil))                       ((eval@compilewhen)                        (setq eval@compile (eval (car (setq tail (cdr tail))))))                       ((copy docopy)                        (setq docopy t))                       ((dontcopy)                        (setq docopy nil))                       ((copywhen)                        (setq docopy (eval (car (setq tail (cdr tail))))))                       ((first)                        (cl:format coutfile                            "Warning: (DECLARE: -- FIRST -- --) not implemented in COMPILE-FILE: ~S~%"                               (cadr tail)))                       ((notfirst compilervars))                       (cl:otherwise (cl:format coutfile                                             "Warning: Ignoring unrecognized DECLARE: tag: ~S~%"                                            (car tail))))                 (cond                    ((eq 'declare\: (car (car tail)))                     (compile-file-declare\: (car tail)                            compiled.file eval@compile docopy defer))                    (t (cl:when eval@compile (eval (car tail)))                       (cl:when docopy (compile-file-expression (car tail)                                              compiled.file eval@compile defer)))))))(defineq(newdefc  (lambda (nm df)                                            (* |bvm:| "30-Sep-86 23:12")    (cond       ((eq svflg 'defer)        (|push| compile.file.after (list (function newdefc)                                         (kwote nm)                                         (kwote df)                                         t)))       ((or (null dfnflg)            (eq dfnflg t))        (cond           ((getd nm)            (virginfn nm t)            (cond               ((null dfnflg)                (cl:format *error-output* "~&(~S redefined)~%" nm)                (savedef nm)))))        (/putd nm df t))       (t                                         (* |;;| "Save on CODE prop.  Be nice and change it from archaic CCODEP object to modern compiled code object.")          (/putprop nm 'code (|if| (arrayp df)                                   |then|                                   (|create| compiled-closure fnheader _ (|fetch| (arrayp base)                                                                                |of| df))                                   |else| df))))    df)))(declare\: donteval@load docopy (movd 'newdefc 'defc))(* \; "Optimizer definitions and environment hacking")(def-define-type optimizers "COMPILER OPTIMIZERS" )(defmacro compiler:optimizer-list (fn) `(get ,fn 'compiler:optimizer-list))(defdefiner defoptimizer   optimizers (name opt-name &rest arglist-body &environment env)         "define an optimizer for NAME"         (cond            ((not arglist-body)                              (* \; "(defoptimizer name optfn)")             (prog1                               (* |;;| "We purposely use this combination of PUTPROP and UNION here instead of `(PUSHNEW ',OPT-NAME (COMPILER:OPTIMIZER-LIST ',NAME)) in order to avoid generating a LET*.  Files in the INIT can't use that form.  This will all be much easier when the new compiler works...")                    `(putprop ',name 'compiler:optimizer-list (union (getprop ',name '                                                                            compiler:optimizer-list)                                                                     (list ',opt-name)))                    (setq name (xcl:pack (list name "-OPTIMIZED-BY-" opt-name)                                      (cl:symbol-package opt-name)))                                                             (* \; " optimizer name is generated")                    ))            (t (let* ((form-name name)                      (arg-list opt-name)                      (opt-fn-name (|if| (and opt-name (cl:symbolp opt-name)                                              (cdr arglist-body))                                         |then|   (* \;                                                   "(defoptimizer form-name opt-name arglist . body)")                                         (setq name opt-name)(* \; "optimizer name is opt-name")                                         (prog1 opt-name (setq arg-list (pop arglist-body)))                                         |else|   (* \;                                 "(defoptimizer form-name arglist . body) optimizer name is form name")                                         (xcl:pack (list "optimize-" form-name)                                                (cl:symbol-package form-name)))))                     (cl:multiple-value-bind (body decls doc)                            (parse-defmacro arg-list '$$whole arglist-body name env :environment                                   '$$env :context '$$ctx)                            `(progn (cl:defun (\\\, opt-fn-name) ($$whole $$env $$ctx) ,@decls                                                                                       ,body)                                    (putprop ',form-name 'compiler:optimizer-list                                           (union (getprop ',form-name 'compiler:optimizer-list)                                                  (list ',opt-fn-name)))))))))(cl:defstruct (compiler::env (:constructor compiler::make-env)                             (:copier compiler::copy-env)                             (:predicate compiler::env-p)) (venv nil) (fenv nil))(cl:defstruct (compiler:context (:constructor compiler:make-context)                                (:copier compiler::copy-context)                                (:predicate compiler::context-p)) (top-level-p nil) (values-used                                                                                     :unknown)                                                                                    (predicate-p                                                                                     nil))(defineq(compiler:copy-env-with-function  (cl:lambda (env fn &optional (kind :function)                  exp-fn)                                    (* "Pavel" "26-Apr-86 15:13")                                                             (* "Pavel" "25-Apr-86 18:53")         (let ((new-env (cl:if env (compiler::copy-env env)                               (compiler:make-empty-env))))              (cl:push (list fn kind exp-fn)                     (compiler::env-fenv new-env))              new-env)))(compiler:copy-env-with-variable  (cl:lambda (env var &optional (kind :lexical))             (* "Pavel" "26-Apr-86 15:12")                                                             (* "Pavel" "25-Apr-86 18:54")         (let ((new-env (cl:if env (compiler::copy-env env)                               (compiler:make-empty-env))))              (cl:push (cons var kind)                     (compiler::env-venv new-env))              new-env)))(compiler:env-boundp  (cl:lambda (compiler::env compiler::name)         (cl:block compiler:env-boundp                (let ((compiler::lookup (cl:assoc compiler::name (compiler::env-venv compiler::env)))                      )                     (cond                        (compiler::lookup (cl:values-list (cdr compiler::lookup)))                        ((compiler::env-proclaimed-special-p compiler::env compiler::name)                         (compiler::env-bind-variable compiler::env compiler::name :special                                (compiler::make-variable :scope :special :kind :variable :name                                        compiler::name)))                        (t (let ((compiler::parent (compiler::env-parent compiler::env)))                                (cond                                   ((eq compiler::parent t)                                    (cond                                       ((variable-globally-special-p compiler::name)                                        (compiler::env-bind-variable compiler::env compiler::name                                                :special (compiler::make-variable :scope :special                                                                :kind :variable :name compiler::name))                                        )                                       ((cl:constantp compiler::name)                                        (compiler::env-bind-variable compiler::env compiler::name                                                :constant (cl:if (fasl\:value-dumpable-p (                                                                                      cl:symbol-value                                                                                                                                                                                compiler::name                                                                                         ))                                                                (compiler::make-literal :value                                                                       (cl:symbol-value                                                                               compiler::name))                                                                (compiler::make-variable :scope                                                                        :global :kind :variable :name                                                                        compiler::name))))                                       ((get compiler::name 'globalvar)                                        (compiler::env-bind-variable compiler::env compiler::name                                                :global (compiler::make-variable :scope :global :kind                                                               :variable :name compiler::name)))                                       (t nil)))                                   (compiler::parent (compiler:env-boundp compiler::parent                                                             compiler::name))                                   (t nil)))))))))(compiler:env-fboundp  (cl:lambda (compiler::env compiler::name)         (cl:block compiler:env-fboundp (let ((compiler::lookup (cl:assoc compiler::name (                                                                                   compiler::env-fenv                                                                                                                                                                                  compiler::env                                                                                          ))))                                             (cl:if compiler::lookup (cl:values-list (cdr                                                                                      compiler::lookup                                                                                          ))                                                    (let ((compiler::parent (compiler::env-parent                                                                             compiler::env)))                                                         (cl:if (and compiler::parent                                                                     (neq compiler::parent t))                                                                (compiler:env-fboundp                                                                        compiler::parent                                                                        compiler::name)                                                                nil)))))))(compiler:make-empty-env  (cl:lambda nil (compiler::make-env))))(putprops cmlcompile filetype cl:compile-file)(declare\: donteval@load doeval@compile dontcopy compilervars (addtovar nlama )(addtovar nlaml )(addtovar lama compiler:make-empty-env compiler:env-fboundp compiler:env-boundp                      compiler:copy-env-with-variable compiler:copy-env-with-function cl:compile-file))(putprops cmlcompile copyright ("Xerox Corporation" 1985 1986))(declare\: dontcopy  (filemap (nil (3878 22040 (cl:compile-file 3888 . 9000) (interlisp-format-p 9002 . 9227) (interlisp-nlambda-function-p 9229 . 9472) (compile-file-expression 9474 . 14225) (compile-file-walk-function 14227 . 14474) (argtype.state 14476 . 14626) (compile.check.argtype 14628 . 16488) (compile.file.defineq 16490 . 16974) (compile-file-setf-symbol-function 16976 . 17580) (compile-file-ex/import 17582 . 17927) (compile.file.apply 17929 . 18183) (compile.file.reset 18185 . 19148) (compile-in-core 19150 . 22038)) (24424 25585 (newdefc 24434 . 25583)) (29311 35140 (compiler:copy-env-with-function 29321 . 29848) (compiler:copy-env-with-variable 29850 . 30323) (compiler:env-boundp 30325 . 33515) (compiler:env-fboundp 33517 . 35068) (compiler:make-empty-env 35070 . 35138)))))stop