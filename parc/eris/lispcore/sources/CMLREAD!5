(DEFINE-FILE-INFO §READTABLE "INTERLISP" §PACKAGE "INTERLISP")(FILECREATED "14-Oct-86 00:18:26" {ERIS}<LISPCORE>SOURCES>CMLREAD.;5 41484        changes to%:  (FNS INIT-CML-READTABLES CL:READ CL:COPY-READTABLE CL:READ-PRESERVING-WHITESPACE                          CL:READ-DELIMITED-LIST CL:READ-LINE CL:READ-CHAR CL:UNREAD-CHAR CL:PEEK-CHAR                          CL:LISTEN CL:READ-CHAR-NO-HANG CL:CLEAR-INPUT CL:READ-FROM-STRING                          CL:READ-BYTE CL:WRITE-BYTE CMLRDTBL CMLREADSEMI)                    (FUNCTIONS CL-MACRO-WRAPPED-P DO-DISPATCH-MACRO CL:GET-DISPATCH-MACRO-CHARACTER                            CL:GET-MACRO-CHARACTER HASH-DOT HASH-MINUS HASH-PLUS HASH-R CL-WRAP-MACRO                            IL-MACRO-WRAPPED-P IL-WRAP-MACRO CL:PARSE-INTEGER HASH-LEFTPAREN HASH-A                            HASH-B HASH-QUOTE HASH-BACKSLASH HASH-C HASH-COLON HASH-COMMA                            HASH-DOUBLEQUOTE HASH-ILLEGAL-HASH-CHAR HASH-LEFTANGLE                            HASH-NO-PARAMETER-ERROR HASH-O HASH-S HASH-STAR HASH-VBAR HASH-X                            CL:MAKE-DISPATCH-MACRO-CHARACTER CL:SET-DISPATCH-MACRO-CHARACTER                            CL:SET-MACRO-CHARACTER)                    (VARS CMLREADCOMS)      previous date%: "12-Sep-86 22:26:17" {ERIS}<LISPCORE>SOURCES>CMLREAD.;4)(* "Copyright (c) 1985, 1986 by Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT CMLREADCOMS)(RPAQQ CMLREADCOMS        [(* ;; "This is a collection of hacks designed to make our reader handle some subset of Common Lisp syntax.  It doesn't really work right"           )        (COMS (FNS CL:READ CL:COPY-READTABLE)              (COMS (* ;           "READ-PRESERVING-WHITESPACE definitely needs more work.  Other functions in this COMS may."                       )                    (FNS CL:READ-PRESERVING-WHITESPACE CL:READ-DELIMITED-LIST CL:READ-LINE                          CL:READ-CHAR CL:UNREAD-CHAR CL:PEEK-CHAR CL:LISTEN CL:READ-CHAR-NO-HANG                          CL:CLEAR-INPUT CL:READ-FROM-STRING CL:READ-BYTE CL:WRITE-BYTE))              [DECLARE%: DONTEVAL@LOAD DOCOPY (P (MOVD? 'NILL 'CMLTRANSLATE]              (* ; "must turn off packed version of CLISP infix")              (VARS [CLISPCHARS (LDIFFERENCE CLISPCHARS '(- * %:]                    (CLISPCHARRAY (MAKEBITTABLE CLISPCHARS))                    (DWIMINMACROSFLG)))        (FUNCTIONS CL-MACRO-WRAPPED-P CL-UNWRAP-MACRO CL-WRAP-MACRO IL-MACRO-WRAPPED-P                IL-UNWRAP-MACRO IL-WRAP-MACRO CL:PARSE-INTEGER)        (* ; "Common Lisp readtable interface functions and supplied hash macro functions")        (FUNCTIONS CL:SET-SYNTAX-FROM-CHAR DO-DISPATCH-MACRO FIND-MACRO-FUNCTION                CL:GET-DISPATCH-MACRO-CHARACTER CL:GET-MACRO-CHARACTER HASH-LEFTPAREN HASH-A HASH-B                HASH-BACKSLASH HASH-C HASH-COLON HASH-COMMA HASH-DOT HASH-DOUBLEQUOTE                HASH-ILLEGAL-HASH-CHAR HASH-LEFTANGLE HASH-MINUS HASH-NO-PARAMETER-ERROR HASH-O                HASH-PLUS HASH-QUOTE HASH-R HASH-S HASH-STAR HASH-VBAR HASH-X                CL:MAKE-DISPATCH-MACRO-CHARACTER CL:SET-DISPATCH-MACRO-CHARACTER                CL:SET-MACRO-CHARACTER)        (INITVARS (*STANDARD-INPUT* NIL)               (*READ-DEFAULT-FLOAT-FORMAT* 'CL:SINGLE-FLOAT))        [COMS (* ;; "Attempt to build a CommonLisp readtable.  Most features simulated for the basic reading, but macros need work"                 )              (FNS CMLRDTBL INIT-CML-READTABLES SET-DEFAULT-HASHMACRO-SETTINGS CMLREADSEMI)              (DECLARE%: DONTEVAL@LOAD DOCOPY (P (INIT-CML-READTABLES]        [COMS (* ;; "Crude means to aid reading and printing things in same reader environment.  There are some fns and an INITRECORDS for this on ATBL to get it early in the loadup"                 )              (RECORDS READER-ENVIRONMENT)              (FUNCTIONS WITH-READER-ENVIRONMENT)              (ADDVARS (SYSSPECVARS *PACKAGE* *READTABLE* *READ-BASE* *PRINT-BASE*))              (PROP INFO WITH-READER-ENVIRONMENT)              (GLOBALVARS *COMMON-LISP-READ-ENVIRONMENT*)              (INITVARS (*COMMON-LISP-READ-ENVIRONMENT* (create READER-ENVIRONMENT REPACKAGE _                                                               (CL:FIND-PACKAGE "USER")                                                               REREADTABLE _ CMLRDTBL REBASE _ 10]        (PROP FILETYPE CMLREAD)        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS               (ADDVARS (NLAMA)                      (NLAML)                      (LAMA CL:WRITE-BYTE CL:READ-BYTE CL:READ-FROM-STRING CL:CLEAR-INPUT                             CL:READ-CHAR-NO-HANG CL:LISTEN CL:PEEK-CHAR CL:UNREAD-CHAR CL:READ-CHAR                             CL:READ-LINE CL:READ-PRESERVING-WHITESPACE CL:COPY-READTABLE CL:READ])(* ;; "This is a collection of hacks designed to make our reader handle some subset of Common Lisp syntax.  It doesn't really work right")(DEFINEQ(CL:READ  (CL:LAMBDA (&OPTIONAL INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P)                                                             (* bvm%: "13-Oct-86 15:21")         (READ INPUT-STREAM)))(CL:COPY-READTABLE  [CL:LAMBDA (&OPTIONAL (FROM-READTABLE *READTABLE*)                    TO-READTABLE)                            (* bvm%: "13-Oct-86 15:21")                                                  (* ;                  "If FROM-READTABLE is NIL, then a copy of a standard Common Lisp readtable is made.")         (if (AND (NULL FROM-READTABLE)                  (NULL TO-READTABLE))             then                                            (* ; "just make a brand new one")                  (CMLRDTBL)           else (SETQ FROM-READTABLE (\DTEST (OR FROM-READTABLE (CMLRDTBL))                                            'READTABLEP))                (if TO-READTABLE                    then (RESETREADTABLE (\DTEST TO-READTABLE 'READTABLEP)                                FROM-READTABLE)                         TO-READTABLE                  else (COPYREADTABLE FROM-READTABLE]))(* ; "READ-PRESERVING-WHITESPACE definitely needs more work.  Other functions in this COMS may.")(DEFINEQ(CL:READ-PRESERVING-WHITESPACE  (CL:LAMBDA (&OPTIONAL (STREAM *STANDARD-INPUT*)                    (EOF-ERRORP T)                    (EOF-VALUE NIL)                    (RECURSIVEP NIL))                        (* bvm%: "13-Oct-86 15:22")                                                  (* ;;  "Reads from stream and returns the object read, preserving the whitespace that followed the object.")         (LET ((RESULT (CL:READ STREAM EOF-ERRORP EOF-VALUE RECURSIVEP)))              (if (SYNTAXP (LASTC STREAM)                         'SEPRCHAR)                  then (\BACKCHAR STREAM))              RESULT)))(CL:READ-DELIMITED-LIST  [LAMBDA (CHAR INPUT-STREAM RECURSIVE-P)                    (* bvm%: "13-Oct-86 15:43")                                                  (* ;;; "Read a list of elements terminated by CHAR.  CHAR must not be a separator char, and ideally should not be a constituent char (if it is, it must be preceded by whitespace for READ-DELIMITED-LIST to work)")                                                  (* ;; "Note: this is not quite right, because it loses if the terminator is preceded by a macro character that returns zero values, for example, a semi-colon.  It also ignores RECURSIVE-P.  When the real reader is written, this should be integrated with it.")    (LET [(ENDCODE (OR (FIXP CHAR)                       (CL:CHAR-CODE CHAR)))          (INSTREAM (\GETSTREAM INPUT-STREAM 'INPUT]         (until (EQ (SKIPSEPRCODES INSTREAM)                    ENDCODE) collect (READ INSTREAM) finally                                                            (* ; "Consume the terminating character")                                                           (READCCODE INSTREAM])(CL:READ-LINE  [CL:LAMBDA (&OPTIONAL (STREAM *STANDARD-INPUT*)                    (EOF-ERRORP T)                    EOF-VALUE RECURSIVE-P)                   (* bvm%: "13-Oct-86 15:44")                                                  (* ;;          "Returns a line of text read from the STREAM as a string, discarding the newline character.")         (DECLARE (IGNORE RECURSIVE-P))         (LET ((RESULT (RSTRING STREAM READ-LINE-RDTBL)))              (if (\EOFP STREAM)                  then (if (EQ (NCHARS RESULT)                               0)                           then                   (* ;                                                   "eof before anything read, so observe EOF-ERRORP")                                (if EOF-ERRORP                                    then (\EOF.ACTION STREAM)                                  else EOF-VALUE)                         else (CL:VALUES RESULT T))                else                                         (* ; "consume the eol")                     (READCCODE STREAM)                     (CL:VALUES RESULT NIL])(CL:READ-CHAR  [CL:LAMBDA (&OPTIONAL (STREAM *STANDARD-INPUT*)                    (EOF-ERRORP T)                    EOF-VALUE RECURSIVE-P)                   (* bvm%: "13-Oct-86 15:44")                                                  (* ;;                                                   "Inputs a character from STREAM and returns it.")         (DECLARE (IGNORE RECURSIVE-P))         (LET [(STREAM (\GETSTREAM STREAM 'INPUT]              (CL:IF (AND (NOT EOF-ERRORP)                          (\EOFP STREAM))                     EOF-VALUE                     (CL:CODE-CHAR (READCCODE STREAM])(CL:UNREAD-CHAR  (CL:LAMBDA (CHARACTER &OPTIONAL (INPUT-STREAM *STANDARD-INPUT*))                                                             (* bvm%: "13-Oct-86 15:44")                                                  (* ;; "Puts the CHARACTER back on the front of the input STREAM.  According to the manual, `One may apply UNREAD-CHAR only to the character most recently read from INPUT-STREAM.'")         (\BACKCHAR (\GETSTREAM INPUT-STREAM 'INPUT))         NIL))(CL:PEEK-CHAR  [CL:LAMBDA (&OPTIONAL (PEEK-TYPE NIL)                    (STREAM *STANDARD-INPUT*)                    (EOF-ERRORP T)                    EOF-VALUE RECURSIVE-P)                   (* bvm%: "13-Oct-86 15:45")                                                  (* ;;                           "Peeks at the next character in the input Stream.  See manual for details.")         (DECLARE (IGNORE RECURSIVE-P))         (LET ((STREAM (\GETSTREAM STREAM 'INPUT))               CL:CHAR)              (SELECTQ PEEK-TYPE                  (NIL                                       (* ; "standard case--return next char")                       (if (SETQ CL:CHAR (\PEEKCCODE STREAM (NULL EOF-ERRORP)))                           then (CL:CODE-CHAR CL:CHAR)                         else EOF-VALUE))                  (T                                         (* ; "skip whitespace before peeking")                     (if (SETQ CL:CHAR (SKIPSEPRCODES STREAM))                         then (CL:CODE-CHAR CL:CHAR)                       elseif EOF-ERRORP                         then (\EOF.ACTION STREAM)                       else EOF-VALUE))                  (if (CL:CHARACTERP PEEK-TYPE)                      then (LET ((DESIREDCHAR (CL:CHAR-CODE PEEK-TYPE))                                 (NOERROR (NULL EOF-ERRORP)))                                (until (EQ (SETQ CL:CHAR (\PEEKCCODE STREAM NOERROR))                                           DESIREDCHAR) do (if (NULL CL:CHAR)                                                               then (RETURN EOF-VALUE))                                                           (READCCODE STREAM)                                   finally (RETURN PEEK-TYPE)))                    else (\ILLEGAL.ARG PEEK-TYPE])(CL:LISTEN  [CL:LAMBDA (&OPTIONAL (STREAM *STANDARD-INPUT*))           (* bvm%: "13-Oct-86 15:45")                                                  (* ;;                                          "Returns T if a character is available on the given STREAM ")         (READP (\GETSTREAM STREAM 'INPUT])(CL:READ-CHAR-NO-HANG  (CL:LAMBDA (&OPTIONAL (STREAM *STANDARD-INPUT*)                    (EOF-ERRORP T)                    EOF-VALUE RECURSIVE-P)                   (* bvm%: "13-Oct-86 15:46")                                                  (* ;;                              "Returns the next character from the STREAM if one is availible, or NIL")         (DECLARE (IGNORE RECURSIVE-P))         (CL:IF (CL:LISTEN STREAM)                (CL:READ-CHAR STREAM EOF-ERRORP EOF-VALUE)                NIL)))(CL:CLEAR-INPUT  [CL:LAMBDA (&OPTIONAL (STREAM *STANDARD-INPUT*))           (* bvm%: "13-Oct-86 15:46")                                                  (* ;;                                               "Clears any buffered input associated with the Stream.")         (CLEARBUF (\GETSTREAM STREAM 'INPUT])(CL:READ-FROM-STRING  [CL:LAMBDA (STRING &OPTIONAL EOF-ERROR-P EOF-VALUE &KEY START END PRESERVE-WHITESPACE)                                                             (* bvm%: "13-Oct-86 15:48")         (LET [(STREAM (OPENSTRINGSTREAM (if END                                             then (SUBSTRING STRING 1 END)                                           else (MKSTRING STRING]              (if START                  then (SETFILEPTR STREAM START))              (CL:VALUES (CL:IF PRESERVE-WHITESPACE (CL:READ-PRESERVING-WHITESPACE STREAM EOF-ERROR-P                                                            EOF-VALUE)                                (CL:READ STREAM EOF-ERROR-P EOF-VALUE))                     (\GETFILEPTR STREAM])(CL:READ-BYTE  [CL:LAMBDA (BINARY-INPUT-STREAM &OPTIONAL (EOF-ERRORP T)                    EOF-VALUE)                               (* bvm%: "13-Oct-86 15:49")                                                  (* ;;                                                   "Returns the next byte of the BINARY-INPUT-STREAM")         (LET [(STREAM (\GETSTREAM BINARY-INPUT-STREAM 'INPUT]              (CL:IF (AND (NOT EOF-ERRORP)                          (\EOFP STREAM))                     EOF-VALUE                     (\BIN STREAM])(CL:WRITE-BYTE  (CL:LAMBDA (CL:INTEGER BINARY-OUTPUT-STREAM)               (* bvm%: "13-Oct-86 15:49")                                                  (* ;;                                              "Outputs the INTEGER to the binary BINARY-OUTPUT-STREAM")         (BOUT BINARY-OUTPUT-STREAM CL:INTEGER)         CL:INTEGER)))(DECLARE%: DONTEVAL@LOAD DOCOPY (MOVD? 'NILL 'CMLTRANSLATE))(* ; "must turn off packed version of CLISP infix")(RPAQ CLISPCHARS (LDIFFERENCE CLISPCHARS '(- * %:)))(RPAQ CLISPCHARRAY (MAKEBITTABLE CLISPCHARS))(RPAQQ DWIMINMACROSFLG NIL)(CL:DEFUN CL-MACRO-WRAPPED-P (FORM)               (* ;;;                                              "Predicate that checks for forms built by CL-WRAP-MACRO")   (AND (CL:CONSP FORM)        (EQ (CAR FORM)            'CL:LAMBDA)        (CL:CONSP (CDR FORM))        (CL:EQUAL (CADR FORM)               '(STREAM READTABLE Z))        (CL:CONSP (CDDR FORM))        (NULL (CDDDR FORM))        (CL:CONSP (CADDR FORM))        (EQ (CAADDR FORM)            'CL:FUNCALL)))(CL:DEFUN CL-UNWRAP-MACRO (FORM)                     (* * "Fetches CL function out wrapped by CL-WRAP-MACRO") (CADR (CADR (CADDR FORM))))(CL:DEFUN CL-WRAP-MACRO (FN CHAR)                 (* ;;;                         "Wraps a form around a CL readmacro to make it acceptable as an IL readmacro")   `(CL:LAMBDA (STREAM READTABLE Z)           (CL:FUNCALL ',FN STREAM ,CHAR)))(CL:DEFUN IL-MACRO-WRAPPED-P (FORM)               (* ;;;                                              "Predicate that checks for forms built by IL-WRAP-MACRO")   (AND (CL:CONSP FORM)        (EQ (CAR FORM)            'CL:LAMBDA)        (CL:CONSP (CDR FORM))        (EQUAL (CADR FORM)               '(STREAM CHAR))        (CL:CONSP (SETQ FORM (CDDR FORM)))        (NULL (CDR FORM))        (CL:CONSP (SETQ FORM (CAR FORM)))        (EQ (CAR FORM)            'CL:FUNCALL)        (EQ (CADDR FORM)            'STREAM)))(CL:DEFUN IL-UNWRAP-MACRO (FORM) (CADR (CADR (CADDR FORM))))(CL:DEFUN IL-WRAP-MACRO (FORM)                    (* ;;;                         "Wraps a form around an IL readmacro to make it acceptable as a CL readmacro")   `(CL:LAMBDA (STREAM CHAR)           (CL:FUNCALL ',FORM STREAM)))(CL:DEFUN CL:PARSE-INTEGER (STRING &KEY (START 0)                                  (END (CL:LENGTH STRING))                                  (RADIX 10)                                  JUNK-ALLOWED)   (PROG (SA BASE OFFST FATP LEN INDEX CHAR STATE MAXDIGITCODE SIGN STARTINT ENDINT VALUE ANSWER)         (SETQ SA (fetch (READTABLEP READSA) of *READTABLE*))         (SETQ BASE (fetch (STRINGP BASE) of STRING))         (SETQ LEN (fetch (STRINGP LENGTH) of STRING))         (SETQ OFFST (fetch (STRINGP OFFST) of STRING))         (SETQ FATP (fetch (STRINGP FATSTRINGP) of STRING))         (SETQ INDEX START)         (while (AND (< INDEX END)                     (EQ (\SYNCODE SA (SETQ CHAR (\GETBASECHAR FATP BASE (+ OFFST INDEX))))                         SEPRCHAR.RC)) do (SETQ INDEX (CL:1+ INDEX)))         (CL:IF (> INDEX END)                (CL:IF JUNK-ALLOWED (CL:RETURN-FROM CL:PARSE-INTEGER (CL:VALUES NIL END))                       (CL:ERROR "No non-whitespace characters in number.")))         (SETQ STATE 'INIT)         (SETQ MAXDIGITCODE (+ (CHARCODE 0)                               RADIX -1))         (while (< INDEX END) do (SETQ STATE (OR (SELCHARQ (SETQ CHAR (\GETBASECHAR FATP BASE                                                                             (+ OFFST INDEX)))                                                      (- (AND (NOT SIGN)                                                              (SELECTQ STATE                                                                  (INIT (SETQ SIGN '-)                                                                        STATE)                                                                  NIL)))                                                      (+ (AND (NOT SIGN)                                                              (SELECTQ STATE                                                                  (INIT (SETQ SIGN '+)                                                                        STATE)                                                                  NIL)))                                                      NIL)                                                 (COND                                                    ((AND (IGEQ CHAR (CHARCODE 0))                                                          (ILEQ CHAR MAXDIGITCODE))                                                             (* ; "digit")                                                     (SELECTQ STATE                                                         (INIT (SETQ STARTINT INDEX)                                                               'INITDIGIT)                                                         (INITDIGIT 'INITDIGIT)                                                         NIL)))                                                 (RETURN)))                                 (SETQ INDEX (CL:1+ INDEX)))         (OR ENDINT (SETQ ENDINT INDEX))         (while (AND (< INDEX END)                     (EQ (\SYNCODE SA (SETQ CHAR (\GETBASECHAR FATP BASE (+ OFFST INDEX))))                         SEPRCHAR.RC)) do (SETQ INDEX (CL:1+ INDEX)))         (SETQ ANSWER (COND                         ((AND (EQ STATE 'INITDIGIT)                               (= INDEX END))                          (\MKINTEGER BASE STARTINT ENDINT (EQ SIGN '-)                                 RADIX FATP))                         (JUNK-ALLOWED NIL)                         ((EQ STATE 'INIT)                          (CL:ERROR "There aren't any digits in this integer string: ~S." STRING))                         (T (CL:ERROR "There Is junk in this integer string: ~S." STRING))))         (RETURN (CL:VALUES ANSWER INDEX))))(* ; "Common Lisp readtable interface functions and supplied hash macro functions")(CL:DEFUN CL:SET-SYNTAX-FROM-CHAR (TO-CHAR FROM-CHAR &OPTIONAL (TO-READTABLE *READTABLE*)                                         (FROM-READTABLE CMLRDTBL)) (SETSYNTAX (CL:CHAR-CODE TO-CHAR)                                                                           (GETSYNTAX (CL:CHAR-CODE                                                                                       FROM-CHAR)                                                                                  FROM-READTABLE)                                                                           TO-READTABLE))(CL:DEFUN DO-DISPATCH-MACRO (CHAR STREAM RDTBL)   (LET ((*READTABLE* RDTBL)         (DISP-TABLE (CDR (ASSOC CHAR (fetch (READTABLEP DISPATCHMACRODEFS) of RDTBL))))         INDEX NEXTCHAR)        (COND           ((NOT DISP-TABLE)            (CL:ERROR "~S is not a dispatch macro character" CHAR))           (T                                         (* ; "DISPATCHMACRODEFS is a list of A-lists")              (while (DIGITCHARP (SETQ NEXTCHAR (READCCODE STREAM RDTBL)))                 do                                          (* ; "read the optional numeric arg")                    (SETQ INDEX (+ (TIMES (OR INDEX 0)                                          10)                                   (- NEXTCHAR (CHARCODE 0)))))              (LET* ((DISP-CHARACTER (CL:CHAR-UPCASE (CL:CODE-CHAR NEXTCHAR)))                     (DISP-FUNCTION (CDR (ASSOC DISP-CHARACTER DISP-TABLE))))                    (if DISP-FUNCTION                        then (CL:FUNCALL DISP-FUNCTION STREAM DISP-CHARACTER INDEX)                      else (CL:ERROR                                   "Undefined dispatch character ~S for dispatch macro character ~S"                                   DISP-CHARACTER CHAR)))))))(CL:DEFUN FIND-MACRO-FUNCTION (FORM) (COND                                        ((CL-MACRO-WRAPPED-P FORM)                                         (CL-UNWRAP-MACRO FORM))                                        ((CL:FUNCTIONP FORM)                                         (IL-WRAP-MACRO FORM))))(CL:DEFUN CL:GET-DISPATCH-MACRO-CHARACTER (DISP-CHAR SUB-CHAR &OPTIONAL (READTABLE *READTABLE*))   (CDR (ASSOC SUB-CHAR (CDR (ASSOC DISP-CHAR (fetch (READTABLEP DISPATCHMACRODEFS) of READTABLE))))))(CL:DEFUN CL:GET-MACRO-CHARACTER (CHAR &OPTIONAL (READTABLE *READTABLE*))                                                   (* ;;; "insures entry is Common Lisp form - (MACRO {FIRST,ALWAYS} (LAMBDA (STREAM READTABLE) (FUNCALL <function> '<char> STREAM))))")   (LET ((TABENTRY (GETSYNTAX (CL:CHAR-CODE CHAR)                          READTABLE)))        (AND (CL:CONSP TABENTRY)             (EQ (CAR TABENTRY)                 'MACRO)             (CL:CONSP (CDR TABENTRY))             (FMEMB (CADR TABENTRY)                    '(ALWAYS FIRST))             (CL:CONSP (SETQ TABENTRY (CDDR TABENTRY)))             (NULL (CDR TABENTRY))             (CL:VALUES (FIND-MACRO-FUNCTION (CAR TABENTRY))                    (NEQ (CADR TABENTRY)                         'ALWAYS)))))(CL:DEFUN HASH-LEFTPAREN (STREAM CHAR INDEX)                 (* jrb%: "28-Jul-86 21:50")   (LET ((CONTENTS (CL:READ-DELIMITED-LIST #\) STREAM T)))        (COND           (INDEX (LET ((VEC (CL:MAKE-ARRAY INDEX :INITIAL-ELEMENT (CAR (LAST CONTENTS)))))                       (CL:DOTIMES (I (LENGTH CONTENTS))                              (CL:SETF (CL:AREF VEC I)                                     (POP CONTENTS)))                       VEC))           (T (CL:MAKE-ARRAY (LENGTH CONTENTS)                     :INITIAL-CONTENTS CONTENTS)))))(CL:DEFUN HASH-A (STREAM CHAR PARAM) (LET ((CONTENTS (CL:READ STREAM)))                                          (CL:MAKE-ARRAY (ESTIMATE-DIMENSIONALITY PARAM CONTENTS)                                                 :INITIAL-CONTENTS CONTENTS)))(CL:DEFUN HASH-B (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (READNUMBERINBASE STREAM 2))(CL:DEFUN HASH-BACKSLASH (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                             (CHARACTER.READ STREAM))(CL:DEFUN HASH-C (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (DESTRUCTURING-BIND (NUM DEN)                                            (READ STREAM)                                            (CL:COMPLEX NUM DEN)))(CL:DEFUN HASH-COLON (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                                  (* ;                                                "Uninterned symbol.  This definition may yet be wrong")                                         (CL:MAKE-SYMBOL (READ-EXTENDED-TOKEN STREAM *READTABLE* T)))(CL:DEFUN HASH-COMMA (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                         (LIST 'LOADTIMECONSTANT (READ STREAM)))(CL:DEFUN HASH-DOT (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                       (COND                                          ((fetch (READTABLEP COMMONLISP) of *READTABLE*)                                           (CL:EVAL (READ STREAM)))                                          (T (EVAL (READ STREAM)))))(CL:DEFUN HASH-DOUBLEQUOTE (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                               (RSTRING STREAM *READTABLE* 'SKIP))(CL:DEFUN HASH-ILLEGAL-HASH-CHAR (STREAM CHAR PARAM) (CL:ERROR "Illegal hash macro character ~S" CHAR                                                            ))(CL:DEFUN HASH-LEFTANGLE (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                             (CL:ERROR "Unreadable object #<~A>" (CL:READ STREAM)))(CL:DEFUN HASH-MINUS (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                         (COND                                            ((CMLREAD.FEATURE.PARSER (LET ((*PACKAGE*                                                                                   *KEYWORD-PACKAGE*))                                                                          (CL:READ STREAM)))                                             (CL:READ STREAM)))                                         (CL:VALUES))(CL:DEFUN HASH-NO-PARAMETER-ERROR (CHAR PARAM) (CL:WHEN PARAM (CL:ERROR                                                         "Parameter ~D not allowed with hash macro ~S"                                                                      PARAM CHAR)))(CL:DEFUN HASH-O (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (READNUMBERINBASE STREAM 8))(CL:DEFUN HASH-PLUS (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                                      (* ; "Skip expression if feature not present")                                        (COND                                           ((NOT (CMLREAD.FEATURE.PARSER (LET ((*PACKAGE*                                                                                     *KEYWORD-PACKAGE*                                                                                      ))                                                                              (CL:READ STREAM))))                                            (CL:READ STREAM)))                                        (CL:VALUES))(CL:DEFUN HASH-QUOTE (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                         (LIST 'CL:FUNCTION (CL:READ STREAM)))(CL:DEFUN HASH-R (STREAM CHAR PARAM) (COND                                        (PARAM (READNUMBERINBASE STREAM PARAM))                                        (T (CL:ERROR "No base supplied for #R"))))(CL:DEFUN HASH-S (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (CREATE-STRUCTURE (READ STREAM)))(CL:DEFUN HASH-STAR (STREAM CHAR PARAM)   (LET* ((CONTENTS (READ-EXTENDED-TOKEN STREAM))          (LEN (NCHARS CONTENTS)))         (if (AND (EQ LEN 0)                  PARAM                  (NEQ PARAM 0))             then (CL:ERROR "No contents specified for bit vector #~A*" PARAM)           elseif (AND PARAM (> LEN PARAM))             then (CL:ERROR "Bit vector contents longer than specified length in #~A*~A" PARAM                          CONTENTS)           else (LET ((BITARRAY (CL:MAKE-ARRAY (OR PARAM LEN)                                       :ELEMENT-TYPE                                       'CL:BIT :INITIAL-ELEMENT                                       (if PARAM                                           then (SELCHARQ (NTHCHARCODE CONTENTS -1)                                                     (0 0)                                                     (1 1)                                                     (CL:ERROR "Illegal bit vector element in #~A*~A"                                                             PARAM CONTENTS))                                         else 0))))                     (CL:DOTIMES (I LEN)                            (CL:SETF (CL:AREF BITARRAY I)                                   (SELCHARQ (NTHCHARCODE CONTENTS (CL:1+ I))                                        (0 0)                                        (1 1)                                        (CL:ERROR "Illegal bit vector element in #~A*~A" PARAM                                                CONTENTS))))                     BITARRAY))))(CL:DEFUN HASH-VBAR (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                        (SKIP.HASH.COMMENT STREAM *READTABLE*)                                        (CL:VALUES))(CL:DEFUN HASH-X (STREAM CHAR PARAM) (HASH-NO-PARAMETER-ERROR CHAR PARAM)                                     (READNUMBERINBASE STREAM 16))(CL:DEFUN CL:MAKE-DISPATCH-MACRO-CHARACTER (CHAR &OPTIONAL NON-TERMINATING (READTABLE *READTABLE*))   (SETSYNTAX (CL:CHAR-CODE CHAR)          `(MACRO ,(CL:IF NON-TERMINATING 'FIRST 'ALWAYS) (LAMBDA (STREAM READTABLE Z)                                                            (DO-DISPATCH-MACRO ,CHAR STREAM READTABLE                                                                   ))) READTABLE)   T)(CL:DEFUN CL:SET-DISPATCH-MACRO-CHARACTER (DISP-CHAR SUB-CHAR FUNCTION &OPTIONAL (READTABLE                                                                                         *READTABLE*))   (CL:IF (CL:DIGIT-CHAR-P SUB-CHAR)          (CL:ERROR "Digit ~S illegal as a sub-character for a dispatching macro" SUB-CHAR))   (SETQ SUB-CHAR (CL:CHAR-UPCASE SUB-CHAR))   (LET ((DISP-TABLE (OR (ASSOC DISP-CHAR (fetch (READTABLEP DISPATCHMACRODEFS) of READTABLE))                         (LET ((NEWTABLE (LIST DISP-CHAR)))                              (push (fetch (READTABLEP DISPATCHMACRODEFS) of READTABLE)                                    NEWTABLE)                              NEWTABLE)))         DISP-CONS)        (if (SETQ DISP-CONS (ASSOC SUB-CHAR (CDR DISP-TABLE)))            then (CL:SETF (CDR DISP-CONS)                        FUNCTION)          else (push (CDR DISP-TABLE)                     (CONS SUB-CHAR FUNCTION)))        T))(CL:DEFUN CL:SET-MACRO-CHARACTER (CHAR FUNCTION &OPTIONAL NON-TERMINATING (READTABLE *READTABLE*))   (SETSYNTAX (CL:CHAR-CODE CHAR)          `(MACRO ,(CL:IF NON-TERMINATING 'FIRST 'ALWAYS) ,(COND                                                              ((IL-MACRO-WRAPPED-P FUNCTION)                                                               (IL-UNWRAP-MACRO FUNCTION))                                                              (T (CL-WRAP-MACRO FUNCTION))))           READTABLE))(RPAQ? *STANDARD-INPUT* NIL)(RPAQ? *READ-DEFAULT-FLOAT-FORMAT* 'CL:SINGLE-FLOAT)(* ;; "Attempt to build a CommonLisp readtable.  Most features simulated for the basic reading, but macros need work")(DEFINEQ(CMLRDTBL  [LAMBDA NIL                                                (* bvm%: "13-Oct-86 15:53")                                                   (* ;; "Creates a vanilla common-lisp read table")    (PROG [(TBL (COPYREADTABLE 'ORIG]                        (* ;; "First reset the table")          (for I from 0 to \MAXTHINCHAR do (SETSYNTAX I 'OTHER TBL))                                                             (* ;; "Install the goodies")          (SETSEPR (CHARCODE (SPACE CR ^L LF TAB))                 1 TBL)          (SETSYNTAX (CHARCODE "'")                 '(MACRO ALWAYS READQUOTE) TBL)   (* ;; "Note that in cml, most of these macros are terminating, even though it would be nicer for us if they were not")          (SETSYNTAX (CHARCODE ";")                 '(MACRO ALWAYS CMLREADSEMI) TBL)          (SETSYNTAX (CHARCODE ")")                 'RIGHTPAREN TBL)          (SETSYNTAX (CHARCODE "(")                 'LEFTPAREN TBL)          (READTABLEPROP TBL 'CASEINSENSITIVE T)          (READTABLEPROP TBL 'COMMONLISP T)          (READTABLEPROP TBL 'COMMONNUMSYNTAX T)          (READTABLEPROP TBL 'USESILPACKAGE NIL)          (READTABLEPROP TBL 'ESCAPECHAR (CHARCODE "\"))          (READTABLEPROP TBL 'MULTIPLE-ESCAPECHAR (CHARCODE "|"))          (SET-DEFAULT-HASHMACRO-SETTINGS TBL)          (SETSYNTAX (CHARCODE %")                 'STRINGDELIM TBL)          (SETSYNTAX (CHARCODE "`")                 '(MACRO ALWAYS READBQUOTE) TBL)          (SETSYNTAX (CHARCODE ",")                 '(MACRO ALWAYS READBQUOTECOMMA) TBL)          (RETURN TBL])(INIT-CML-READTABLES  [LAMBDA NIL                                                (* bvm%: "14-Oct-86 00:05")    (READTABLEPROP (SETQ CMLRDTBL (CMLRDTBL))           'NAME "LISP")    (SETQ *COMMON-LISP-READ-ENVIRONMENT* (MAKE-READER-ENVIRONMENT *LISP-PACKAGE* CMLRDTBL 10))    (LET ((FILETBL (COPYREADTABLE CMLRDTBL)))     (* ;                                                "Make one for files that has font indicators as seprs")         (for I from 1 to 26 do (SETSYNTAX I 'SEPRCHAR FILETBL))         (READTABLEPROP FILETBL 'NAME "XCL"))    (PROGN                                          (* ; "Read table to make READ-LINE work easily")           (SETQ READ-LINE-RDTBL (COPYREADTABLE 'ORIG))           (SETBRK (CHARCODE (EOL))                  NIL READ-LINE-RDTBL)           (SETSEPR NIL NIL READ-LINE-RDTBL])(SET-DEFAULT-HASHMACRO-SETTINGS  [LAMBDA (RDTBL)                                            (* bvm%: "11-Sep-86 14:49")    (READTABLEPROP RDTBL 'HASHMACROCHAR (CHARCODE "#"))    (CL:MAKE-DISPATCH-MACRO-CHARACTER #\# T RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\( 'HASH-LEFTPAREN RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\' 'HASH-QUOTE RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\. 'HASH-DOT RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\, 'HASH-COMMA RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\\ 'HASH-BACKSLASH RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\* 'HASH-STAR RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\: 'HASH-COLON RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\O 'HASH-O RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\B 'HASH-B RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\X 'HASH-X RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\R 'HASH-R RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\A 'HASH-A RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\S 'HASH-S RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\C 'HASH-C RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\+ 'HASH-PLUS RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\- 'HASH-MINUS RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\| 'HASH-VBAR RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\< 'HASH-LEFTANGLE RDTBL)    (CL:SET-DISPATCH-MACRO-CHARACTER #\# #\" 'HASH-DOUBLEQUOTE RDTBL)    RDTBL])(CMLREADSEMI  [LAMBDA (STREAM RDTBL)                                     (* bvm%: "13-Oct-86 15:53")                                                      (* ;;; "Read and discard through end of line")    (until (EQ (READCCODE STREAM)               (CHARCODE NEWLINE)) do NIL)    (CL:VALUES]))(DECLARE%: DONTEVAL@LOAD DOCOPY (INIT-CML-READTABLES))(* ;; "Crude means to aid reading and printing things in same reader environment.  There are some fns and an INITRECORDS for this on ATBL to get it early in the loadup")(DECLARE%: EVAL@COMPILE(DATATYPE READER-ENVIRONMENT (REPACKAGE REREADTABLE REBASE RESPEC)))(/DECLAREDATATYPE 'READER-ENVIRONMENT '(POINTER POINTER POINTER POINTER) '((READER-ENVIRONMENT 0                                                                                   POINTER)                                                                           (READER-ENVIRONMENT 2                                                                                   POINTER)                                                                           (READER-ENVIRONMENT 4                                                                                   POINTER)                                                                           (READER-ENVIRONMENT 6                                                                                   POINTER))       '8)(DEFMACRO WITH-READER-ENVIRONMENT (ENV . BODY) `((CL:LAMBDA (E)                                                        (LET ((*PACKAGE* (ffetch (READER-ENVIRONMENT                                                                                  REPACKAGE)                                                                            of E))                                                              (*READTABLE* (ffetch (                                                                                   READER-ENVIRONMENT                                                                                    REREADTABLE)                                                                              of E))                                                              (*READ-BASE* (ffetch (                                                                                   READER-ENVIRONMENT                                                                                    REBASE)                                                                              of E))                                                              (*PRINT-BASE* (ffetch (                                                                                   READER-ENVIRONMENT                                                                                     REBASE)                                                                               of E)))                                                             ,@BODY))                                                 (\DTEST ,ENV 'READER-ENVIRONMENT)))(ADDTOVAR SYSSPECVARS *PACKAGE* *READTABLE* *READ-BASE* *PRINT-BASE*)(PUTPROPS WITH-READER-ENVIRONMENT INFO EVAL)(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS *COMMON-LISP-READ-ENVIRONMENT*))(RPAQ? *COMMON-LISP-READ-ENVIRONMENT* (create READER-ENVIRONMENT REPACKAGE _ (CL:FIND-PACKAGE "USER")                                             REREADTABLE _ CMLRDTBL REBASE _ 10))(PUTPROPS CMLREAD FILETYPE CL:COMPILE-FILE)(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA CL:WRITE-BYTE CL:READ-BYTE CL:READ-FROM-STRING CL:CLEAR-INPUT CL:READ-CHAR-NO-HANG                      CL:LISTEN CL:PEEK-CHAR CL:UNREAD-CHAR CL:READ-CHAR CL:READ-LINE                      CL:READ-PRESERVING-WHITESPACE CL:COPY-READTABLE CL:READ))(PUTPROPS CMLREAD COPYRIGHT ("Xerox Corporation" 1985 1986))(DECLARE%: DONTCOPY  (FILEMAP (NIL (5028 6223 (CL:READ 5038 . 5250) (CL:COPY-READTABLE 5252 . 6221)) (6331 15288 (CL:READ-PRESERVING-WHITESPACE 6341 . 6996) (CL:READ-DELIMITED-LIST 6998 . 8153) (CL:READ-LINE 8155 . 9336) (CL:READ-CHAR 9338 . 9971) (CL:UNREAD-CHAR 9973 . 10464) (CL:PEEK-CHAR 10466 . 12358) (CL:LISTEN 12360 . 12687) (CL:READ-CHAR-NO-HANG 12689 . 13237) (CL:CLEAR-INPUT 13239 . 13574) (CL:READ-FROM-STRING 13576 . 14366) (CL:READ-BYTE 14368 . 14927) (CL:WRITE-BYTE 14929 . 15286)) (33520 37838 (CMLRDTBL 33530 . 35179) (INIT-CML-READTABLES 35181 . 36056) (SET-DEFAULT-HASHMACRO-SETTINGS 36058 . 37510) (CMLREADSEMI 37512 . 37836)))))STOP