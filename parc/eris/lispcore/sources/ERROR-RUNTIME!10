(DEFINE-FILE-INFO §READTABLE "XCL" §PACKAGE "INTERLISP")(FILECREATED "21-Oct-86 04:02:59" {ERIS}<LISPCORE>SOURCES>ERROR-RUNTIME.\;10 31917        |changes| |to:|  (STRUCTURES SIMPLE-CONDITION CL:ERROR ERROR)                       (VARS ERROR-RUNTIMECOMS)      |previous| |date:| "20-Oct-86 17:23:29" {ERIS}<LISPCORE>SOURCES>ERROR-RUNTIME.\;8); Copyright (c) 1986 by Xerox Corporation.  All rights reserved.(PRETTYCOMPRINT ERROR-RUNTIMECOMS)(RPAQQ ERROR-RUNTIMECOMS        ((COMS (* |;;;| "Internal functions.")              (FUNCTIONS CONDITION-TYPEP CONDITION-SUBTYPEP CONDITION-TYPE-OF                      FAKE-TYPEP-FOR-CONDITIONS FAKE-SUBTYPEP-FOR-CONDITIONS                      FAKE-TYPE-OF-FOR-CONDITIONS)              (FUNCTIONS CONDITION-HANDLER CONDITION-REPORTER %PRINT-CONDITION %PROCEED-CASE-PRINTER                      %PROCEED-CASE-DEFAULT-REPORTER REPORT-CONDITION CONDITION-PARENT)              (VARIABLES *CONDITION-HANDLER-BINDINGS* *PROCEED-CASES*)              (FUNCTIONS CHECK-TYPE-FAIL ECASE-FAIL ASSERT-FAIL)              (FUNCTIONS MAKE-INTO-CONDITION RAISE-SIGNAL DEFAULT-HANDLE-CONDITION                      DEFAULT-PROCEED-REPORTER FIX-INHERITANCE-LINKS DEFAULT-PROCEED-TEST                      TEST-PROCEED-CASE))        (COMS (* |;;;| "Pre-defined condition types.")              (STRUCTURES CONDITION SIMPLE-CONDITION WARNING SIMPLE-WARNING OLD-BREAK1                      SERIOUS-CONDITION ERROR SIMPLE-ERROR OLD-INTERLISP-ERROR ASSERTION-FAILED                      CELL-ERROR UNBOUND-VARIABLE UNDEFINED-FUNCTION NO-PROCEED-TEST                      INDEX-BOUNDS-ERROR)              (COMS (FUNCTIONS PRETTY-TYPE-NAME)                    (STRUCTURES TYPE-MISMATCH))              (STRUCTURES CONTROL-ERROR ILLEGAL-GO ILLEGAL-RETURN ILLEGAL-THROW BAD-PROCEED-CASE)              (STRUCTURES CALL-ERROR TOO-MANY-ARGUMENTS TOO-FEW-ARGUMENTS INVALID-ARGUMENT-LIST)              (STRUCTURES STREAM-ERROR READ-ERROR END-OF-FILE)              (STRUCTURES STORAGE-CONDITION STACK-OVERFLOW STORAGE-EXHAUSTED))        (COMS (* |;;;| "Exported symbols. Anything here that's not in CL should be in XCL.")              (VARIABLES *BREAK-ON-WARNINGS*)              (FUNCTIONS MAKE-CONDITION SIGNAL CL:ERROR CL:CERROR CL:WARN CL:BREAK DEBUG)              (STRUCTURES PROCEED-CASE REAL-PROCEED-CASE)              (FUNCTIONS FIND-PROCEED-CASE COMPUTE-PROCEED-CASES INVOKE-PROCEED-CASE)              (FUNCTIONS ABORT PROCEED USE-VALUE STORE-VALUE))        (COMS (FUNCTIONS SIMPLE-FORMAT)              (P (MOVD? 'SIMPLE-FORMAT 'CL:FORMAT)))        (DECLARE\: DONTCOPY (VARS SHOULD-BE-IN-PACKAGE))        (PROP FILETYPE ERROR-RUNTIME)))(* |;;;| "Internal functions.")(DEFMACRO CONDITION-TYPEP (DATUM TYPE) (CL:IF %CONDITION-TYPES-REAL `(TYPEP ,DATUM ,TYPE)                                              `(FAKE-TYPEP-FOR-CONDITIONS ,DATUM ,TYPE)))(DEFMACRO CONDITION-SUBTYPEP (T1 T2) (CL:IF %CONDITION-TYPES-REAL `(CL:SUBTYPEP ,T1 ,T2)                                            `(FAKE-SUBTYPEP-FOR-CONDITIONS ,T1 ,T2)))(DEFMACRO CONDITION-TYPE-OF (DATUM) (CL:IF %CONDITION-TYPES-REAL `(CL:TYPE-OF ,DATUM)                                           `(FAKE-TYPE-OF-FOR-CONDITIONS ,DATUM)))(CL:DEFUN FAKE-TYPEP-FOR-CONDITIONS (DATUM TYPE)             (* |amd| " 9-Apr-86 17:41")   (AND (CL:CONSP DATUM)        (CL:SYMBOLP (CAR DATUM))        (CONDITION-SUBTYPEP (CAR DATUM)               TYPE)))(CL:DEFUN FAKE-SUBTYPEP-FOR-CONDITIONS (T1 T2) (CL:VALUES (AND (|for| |old| T1                                                                  |by| (CONDITION-PARENT T1)                                                                  |while| T1                                                                  |thereis| (EQ T1 T2))                                                               T)                                                      T))(CL:DEFUN FAKE-TYPE-OF-FOR-CONDITIONS (DATUM) (CAR DATUM))(DEFMACRO CONDITION-HANDLER (CONDITION-TYPE) `(GETPROP ,CONDITION-TYPE '%CONDITION-HANDLER))(DEFMACRO CONDITION-REPORTER (CONDITION-TYPE) `(GETPROP ,CONDITION-TYPE '%CONDITION-REPORTER))(CL:DEFUN %PRINT-CONDITION (CONDITION STREAM LEVEL) (DECLARE (IGNORE LEVEL))                                                    (CL:IF *PRINT-ESCAPE* (CL:FORMAT STREAM                                                                             "#<Condition ~S @ ~O,~O>"                                                                                 (CL:TYPE-OF                                                                                         CONDITION)                                                                                 (\\HILOC CONDITION)                                                                                 (\\LOLOC CONDITION))                                                           (REPORT-CONDITION CONDITION STREAM)))(CL:DEFUN %PROCEED-CASE-PRINTER (PC STREAM LEVEL) (DECLARE (IGNORE LEVEL))                                                  (CL:IF *PRINT-ESCAPE* (DEFAULT-STRUCTURE-PRINTER                                                                         PC STREAM LEVEL)                                                         (CL:FUNCALL (PROCEED-CASE-REPORT PC)                                                                PC STREAM)))(CL:DEFUN %PROCEED-CASE-DEFAULT-REPORTER (PC STREAM) (CL:FUNCALL (DEFAULT-PROCEED-REPORT (                                                                                    PROCEED-CASE-NAME                                                                                          PC))                                                            PC STREAM))(CL:DEFUN REPORT-CONDITION (CONDITION STREAM) (CL:DO* ((TYPE (CONDITION-TYPE-OF CONDITION)                                                             (CONDITION-PARENT TYPE))                                                       (REPORTER (CONDITION-REPORTER TYPE)                                                              (CONDITION-REPORTER TYPE)))                                                     ((NULL TYPE)                                                      (CL:BREAK "No report function found for ~S."                                                              CONDITION))                                                     (CL:WHEN REPORTER                                                            (RETURN (CL:IF STREAM                                                                           (CL:FUNCALL REPORTER                                                                                   CONDITION STREAM)                                                                           (CL:WITH-OUTPUT-TO-STRING                                                                            (STREAM)                                                                            (CL:FUNCALL REPORTER                                                                                    CONDITION STREAM))                                                                           )))))(DEFMACRO CONDITION-PARENT (TYPE) `(GETPROP ,TYPE '%CONDITION-PARENT))(CL:DEFVAR *CONDITION-HANDLER-BINDINGS* NIL "Condition handler binding stack")(CL:DEFVAR *PROCEED-CASES* NIL "Active proceed case stack")(CL:DEFUN CHECK-TYPE-FAIL (PROCEEDABLE PLACE VALUE DESIRED-TYPE MESSAGE)   (PROCEED-CASE (CL:ERROR 'TYPE-MISMATCH :NAME PLACE :VALUE VALUE :DESIRED-TYPE DESIRED-TYPE                         :MESSAGE MESSAGE)          (STORE-VALUE (IGNORE NEW)                 :REPORT                 (CL:FORMAT T "Change the value of ~A" PLACE)                 :TEST                 (CL:LAMBDA (CONDITION)                        (AND PROCEEDABLE (CONDITION-TYPEP CONDITION 'TYPE-MISMATCH)))                 NEW)))(CL:DEFUN ECASE-FAIL (PROCEEDABLE PLACE VALUE SELECTORS)   (PROCEED-CASE (CL:ERROR "The value of ~S, ~S,~&is ~?." PLACE VALUE                         "~#[wrong~;not ~S~;neither ~S nor ~S~:;not~@{~#[~; or~] ~S~^,~}~]" SELECTORS)          (STORE-VALUE (IGNORE V)                 :TEST                 (CL:LAMBDA (CONDITION)                        (DECLARE (IGNORE CONDITION))                        PROCEEDABLE)                 :REPORT                 (CL:FORMAT T "Change the value of ~A" PLACE)                 V)))(CL:DEFUN ASSERT-FAIL (STRING &REST ARGS) (PROCEED-CASE (CL:ERROR 'ASSERTION-FAILED :FORMAT-STRING                                                                STRING :FORMAT-ARGUMENTS ARGS)                                                 (PROCEED NIL :REPORT "Re-test assertion")))(CL:DEFUN MAKE-INTO-CONDITION (DATUM DESIRED-TYPE ARGS)                                                    (* |;;| "The entire thing should be a typecase.")   (CL:IF (CONDITION-TYPEP DATUM 'CONDITION)          DATUM          (CL:ETYPECASE DATUM (CL:SYMBOL (CL:IF (CONDITION-SUBTYPEP DATUM 'CONDITION)                                                (CL:APPLY (FUNCTION MAKE-CONDITION)                                                       DATUM ARGS)                                                (CL:ERROR "~S is not a condition type." DATUM)))                 (STRING (MAKE-CONDITION DESIRED-TYPE :FORMAT-STRING DATUM :FORMAT-ARGUMENTS ARGS)))))(CL:DEFUN RAISE-SIGNAL (C) (CL:DO* ((*CONDITION-HANDLER-BINDINGS* *CONDITION-HANDLER-BINDINGS*                                           (CDR *CONDITION-HANDLER-BINDINGS*)))                                  ((NULL *CONDITION-HANDLER-BINDINGS*)                                   (DEFAULT-HANDLE-CONDITION C)                                   C)                                  (DESTRUCTURING-BIND (TYPE . HANDLER)                                         (CAR *CONDITION-HANDLER-BINDINGS*)                                         (CL:WHEN (CONDITION-TYPEP C TYPE)                                                (LET ((*CONDITION-HANDLER-BINDINGS* (CDR                                                                          *CONDITION-HANDLER-BINDINGS*                                                                                         )))                                                     (CL:FUNCALL HANDLER C))))))(CL:DEFUN DEFAULT-HANDLE-CONDITION (CONDITION) (CL:DO ((TYPE (CONDITION-TYPE-OF CONDITION)                                                             (CONDITION-PARENT TYPE)))                                                      ((NULL TYPE))                                                      (LET ((HANDLER (CONDITION-HANDLER TYPE)))                                                           (CL:WHEN HANDLER (CL:FUNCALL HANDLER                                                                                    CONDITION)))))(CL:DEFUN DEFAULT-PROCEED-REPORTER (PC STREAM) (CL:FORMAT STREAM "Proceed-type: ~A" (                                                                                    PROCEED-CASE-NAME                                                                                     PC)))(CL:DEFUN FIX-INHERITANCE-LINKS (NAME NEW-PARENT) (LET ((OLD-PARENT (CONDITION-PARENT NAME)))                                                       (CL:UNLESS (OR (EQ NEW-PARENT OLD-PARENT)                                                                      (NULL OLD-PARENT))                                                              (LET ((CHILDREN (GET OLD-PARENT                                                                                   '                                                                                  %CONDITION-CHILDREN                                                                                   )))                                                                   (CL:SETF (GET OLD-PARENT                                                                                 '%CONDITION-CHILDREN                                                                                 )                                                                          (DREMOVE NAME CHILDREN))))                                                       (CL:PUSHNEW NAME (GETPROP NEW-PARENT                                                                               '%CONDITION-CHILDREN))                                                       (CL:SETF (CONDITION-PARENT NAME)                                                              NEW-PARENT)))(DEFMACRO DEFAULT-PROCEED-TEST (PROCEED-TYPE) `(GETPROP ,PROCEED-TYPE '%DEFAULT-PROCEED-TEST))(CL:DEFUN TEST-PROCEED-CASE (PC CONDITION &AUX TEST) (COND                                                        ((CL:SETF TEST (PROCEED-CASE-TEST PC))                                                         (CL:FUNCALL TEST CONDITION))                                                        ((AND (PROCEED-CASE-NAME PC)                                                              (CL:SETF TEST                                                                     (OR (DEFAULT-PROCEED-TEST                                                                          (PROCEED-CASE-NAME PC))                                                                         (NO-PROCEED-TEST                                                                          (PROCEED-CASE-NAME PC)))))                                                         (CL:FUNCALL TEST CONDITION))                                                        (T   (* \; "This case shouldn't happen")                                                           (PROCEED-CASE (CL:ERROR                                                                 "Couldn't find test function for ~S."                                                                                 PC)                                                                  (PROCEED NIL :TEST TRUE :REPORT                                                                      "Assume proceed case is enabled"                                                                          T)))))(* |;;;| "Pre-defined condition types.")(DEFINE-CONDITION CONDITION CONDITION :REPORT "Condition ~S occurred." --DUMMY-SLOT--)(DEFINE-CONDITION SIMPLE-CONDITION CONDITION :REPORT (CL:APPLY #'CL:FORMAT T FORMAT-STRING                                                             FORMAT-ARGUMENTS)                                         FORMAT-STRING FORMAT-ARGUMENTS)(DEFINE-CONDITION WARNING CONDITION)(DEFINE-CONDITION SIMPLE-WARNING WARNING :REPORT (CL:APPLY (FUNCTION CL:FORMAT)                                                        T FORMAT-STRING FORMAT-ARGUMENTS)                                       FORMAT-STRING FORMAT-ARGUMENTS)(DEFINE-CONDITION OLD-BREAK1 CONDITION :REPORT (DESTRUCTURING-BIND (MESS1 MESS2 MESS3)                                                      LIST                                                      (ERRORMESS1 MESS1 MESS2 MESS3))                                   LIST)(DEFINE-CONDITION SERIOUS-CONDITION CONDITION :REPORT (CL:FORMAT T "Serious condition ~S occurred."                                                             (CONDITION-TYPE-OF CONDITION)))(DEFINE-CONDITION ERROR SERIOUS-CONDITION)(DEFINE-CONDITION SIMPLE-ERROR ERROR :REPORT (CL:APPLY (FUNCTION CL:FORMAT)                                                    T FORMAT-STRING FORMAT-ARGUMENTS)                                     FORMAT-STRING FORMAT-ARGUMENTS)(DEFINE-CONDITION OLD-INTERLISP-ERROR ERROR :REPORT (CL:IF (EQ NUMBER 17)                                                           (DESTRUCTURING-BIND (MESS1 . MESS2)                                                                  MESSAGE                                                                  (ERRORMESS1 MESS1 MESS2                                                                         'ERROR))                                                           (ERRORM (LIST NUMBER MESSAGE)))                                            NUMBER MESSAGE)(DEFINE-CONDITION ASSERTION-FAILED SIMPLE-ERROR :REPORT (CL:APPLY (FUNCTION CL:FORMAT)                                                               T                                                               (OR FORMAT-STRING "Assertion failed.")                                                               FORMAT-ARGUMENTS))(DEFINE-CONDITION CELL-ERROR ERROR NAME)(DEFINE-CONDITION UNBOUND-VARIABLE CELL-ERROR :REPORT (CL:FORMAT T "Unbound variable: ~S." NAME))(DEFINE-CONDITION UNDEFINED-FUNCTION CELL-ERROR :REPORT (CL:FORMAT T "Undefined function: ~S." NAME))(DEFINE-CONDITION NO-PROCEED-TEST UNDEFINED-FUNCTION :REPORT (CL:FORMAT T                                                             "No test specified for proceed case: ~S."                                                                     NAME))(DEFINE-CONDITION INDEX-BOUNDS-ERROR CELL-ERROR :REPORT (CL:FORMAT T "Index out of bounds: ~D." INDEX                                                               )                                           INDEX)(CL:DEFUN PRETTY-TYPE-NAME (TYPESPEC) (CONCAT "a " TYPESPEC))(DEFINE-CONDITION TYPE-MISMATCH CELL-ERROR :REPORT (CL:FORMAT T "The value of ~A, ~A, is not ~A."                                                           NAME VALUE (OR MESSAGE (PRETTY-TYPE-NAME                                                                                  DESIRED-TYPE)))                                      VALUE DESIRED-TYPE MESSAGE)(DEFINE-CONDITION CONTROL-ERROR ERROR)(DEFINE-CONDITION ILLEGAL-GO CONTROL-ERROR :REPORT (CL:FORMAT T "GO to a non-existant tag: ~S." TAG)                                   TAG)(DEFINE-CONDITION ILLEGAL-RETURN CONTROL-ERROR :REPORT (CL:FORMAT T                                                               "RETURN to non-existant block: ~S." TAG                                                              )                                       TAG)(DEFINE-CONDITION ILLEGAL-THROW CONTROL-ERROR :REPORT (CL:FORMAT T "Tag for THROW not found: ~S." TAG                                                             )                                      TAG)(DEFINE-CONDITION BAD-PROCEED-CASE CONTROL-ERROR :REPORT (CL:FORMAT T                                                            "Proceed case ~S is not currently active."                                                                 NAME)                                         NAME)(DEFINE-CONDITION CALL-ERROR CONTROL-ERROR CALLEE)(DEFINE-CONDITION TOO-MANY-ARGUMENTS CALL-ERROR :REPORT (CL:IF (AND MAXIMUM ACTUAL)                                                               (CL:FORMAT T "Too many arguments to ~A:~%   ~D ~:*~[were~;was~:;were~] given but at most ~D ~:*~[are~;is~:;are~] accepted"                                                                       CALLEE ACTUAL MAXIMUM)                                                               (CL:FORMAT T                                                                       "Too many arguments to ~A"                                                                       CALLEE))                                           MAXIMUM ACTUAL)(DEFINE-CONDITION TOO-FEW-ARGUMENTS CALL-ERROR :REPORT (CL:IF (AND MINIMUM ACTUAL)                                                              (CL:FORMAT T "Too few arguments to ~A:~%   ~D ~:*~[were~;was~:;were~] given but at least ~D ~:*~[are~;is~:;are~] necessary"                                                                      CALLEE ACTUAL MINIMUM)                                                              (CL:FORMAT T "Too few arguments to ~A"                                                                      CALLEE))                                          MINIMUM ACTUAL)(DEFINE-CONDITION INVALID-ARGUMENT-LIST CALL-ERROR :REPORT (CL:FORMAT T                                                                   "~S has an invalid argument list"                                                                   CALLEE))(DEFINE-CONDITION STREAM-ERROR ERROR :REPORT (CL:FORMAT T "Stream error on ~S." STREAM)                                     STREAM)(DEFINE-CONDITION READ-ERROR STREAM-ERROR)(DEFINE-CONDITION END-OF-FILE READ-ERROR :REPORT "End of file:~%    ~S" STREAM)(DEFINE-CONDITION STORAGE-CONDITION SERIOUS-CONDITION)(DEFINE-CONDITION STACK-OVERFLOW STORAGE-CONDITION :REPORT "Stack overflow")(DEFINE-CONDITION STORAGE-EXHAUSTED STORAGE-CONDITION)(* |;;;| "Exported symbols. Anything here that's not in CL should be in XCL.")(CL:DEFVAR *BREAK-ON-WARNINGS* NIL                           "If true, calls to WARN will cause a break as well as logging the warning.")(CL:DEFUN MAKE-CONDITION (TYPE &REST SLOT-INITIALIZATIONS)                                                    "Create a condition object of the specified type."   (CL:APPLY (STRUCTURE-CONSTRUCTOR TYPE)          SLOT-INITIALIZATIONS))(CL:DEFUN SIGNAL (DATUM &REST ARGS) (LET ((CONDITION (MAKE-INTO-CONDITION DATUM 'SIMPLE-CONDITION                                                             ARGS)))                                         (RAISE-SIGNAL CONDITION)                                         (CL:IF (CONDITION-TYPEP CONDITION 'SERIOUS-CONDITION)                                                (DEBUG CONDITION)                                                (CL:RETURN-FROM SIGNAL CONDITION))))(CL:DEFUN CL:ERROR (DATUM &REST ARGS) (DEBUG (RAISE-SIGNAL (MAKE-INTO-CONDITION DATUM 'SIMPLE-ERROR                                                                   ARGS))))(CL:DEFUN CL:CERROR (PROCEED-FORMAT-STRING DATUM &REST ARGUMENTS &AUX CONDITION)   (PROCEED-CASE (DEBUG (RAISE-SIGNAL (CL:SETF CONDITION (MAKE-INTO-CONDITION DATUM 'SIMPLE-ERROR                                                                 ARGUMENTS))))          (PROCEED NIL :REPORT (CL:APPLY (FUNCTION CL:FORMAT)                                      T PROCEED-FORMAT-STRING ARGUMENTS)                 CONDITION)))(CL:DEFUN CL:WARN (DATUM &REST ARGUMENTS) (LET ((CONDITION (MAKE-INTO-CONDITION DATUM 'SIMPLE-WARNING                                                                   ARGUMENTS)))                                               (CL:UNLESS (CONDITION-TYPEP CONDITION 'WARNING)                                                      (CL:CERROR                                                              "Signal and report the condition anyway"                                                             'TYPE-MISMATCH :NAME 'CONDITION :VALUE                                                              CONDITION :DESIRED-TYPE 'WARNING))                                               (RAISE-SIGNAL CONDITION)                                               (CL:IF %CONDITION-TYPES-REAL (CL:FORMAT *ERROR-OUTPUT*                                                                                    "~&Warning: ~A~%"                                                                                    CONDITION)                                                      (CL:FORMAT *ERROR-OUTPUT* "~&Warning: ~A~%"                                                             (REPORT-CONDITION CONDITION NIL)))                                               (CL:WHEN *BREAK-ON-WARNINGS* (CL:BREAK CONDITION))                                               CONDITION))(CL:DEFUN CL:BREAK (&OPTIONAL (DATUM "Break")                          &REST ARGUMENTS &AUX CONDITION)                                                   (* |;;|                           "Want to try and get some indication of which break you're returning from.")   (PROCEED-CASE (DEBUG (CL:SETF CONDITION (MAKE-INTO-CONDITION DATUM 'SIMPLE-CONDITION ARGUMENTS)))          (PROCEED NIL :REPORT "Return from BREAK" CONDITION)))(CL:DEFUN DEBUG (&OPTIONAL (DATUM "Break")                       &REST ARGS) (CL:LOOP (ERRORX (MAKE-INTO-CONDITION DATUM 'SIMPLE-CONDITION ARGS                                                           ))))(DEFSTRUCT (PROCEED-CASE (:PRINT-FUNCTION %PROCEED-CASE-PRINTER)) NAME TAG SELECTOR TEST                                                                       (REPORT '                                                                       %PROCEED-CASE-DEFAULT-REPORTER                                                                              ))(DEFSTRUCT (REAL-PROCEED-CASE (:INCLUDE PROCEED-CASE)                              (:PRINT-FUNCTION %PROCEED-CASE-PRINTER)) CONTINUATION)(CL:DEFUN FIND-PROCEED-CASE (DATUM CONDITION) (CL:ETYPECASE                                               DATUM                                               (NULL (CL:ERROR                                                "~S is an invalid argument to ~S;~%    use ~S instead"                                                             NIL 'FIND-PROCEED-CASE '                                                            COMPUTE-PROCEED-CASES))                                               (PROCEED-CASE (AND (FMEMB DATUM *PROCEED-CASES*)                                                                  (TEST-PROCEED-CASE DATUM CONDITION)                                                                  DATUM))                                               (CL:SYMBOL (|for| PC |in| *PROCEED-CASES*                                                             |thereis| (AND (EQ (PROCEED-CASE-NAME                                                                                 PC)                                                                                DATUM)                                                                            (TEST-PROCEED-CASE PC                                                                                    CONDITION)                                                                            PC)))))(CL:DEFUN COMPUTE-PROCEED-CASES (CONDITION) (|for| PC |in| *PROCEED-CASES*                                               |when| (CL:CATCH 'SKIP-PROCEED-CASE (TEST-PROCEED-CASE                                                                                    PC CONDITION))                                               |collect| PC))(CL:DEFUN INVOKE-PROCEED-CASE (PROCEED-CASE CONDITION &REST CL:VALUES)   (LET ((PC (FIND-PROCEED-CASE PROCEED-CASE CONDITION)))        (IF PC            THEN                                         (* |;;| "Hack until real unwinder is in. ")                 (AND (BOUNDP 'BREAKRESETVALS)                      (BOUNDP '\\BREAKRESETEXPR)                      (BREAKRESETFN 'LEAVING))                 (CL:TYPECASE PC (REAL-PROCEED-CASE                                  (|with| REAL-PROCEED-CASE PC                                         (CL:THROW TAG (CL:VALUES-LIST (LIST* CONTINUATION CONDITION                                                                              (COND                                                                                 ((CL:SYMBOLP                                                                                          PROCEED-CASE                                                                                         )                                                                                  CL:VALUES)                                                                                 ((CL:FBOUNDP NAME)                                                                                  (CL:APPLY                                                                                   (                                                                                PROCEED-ARG-COLLECTOR                                                                                    NAME)                                                                                   CONDITION                                                                                    CL:VALUES))                                                                                 (T CL:VALUES)))))))                        (PROCEED-CASE (|with| PROCEED-CASE PC (CL:THROW                                                               TAG                                                               (LIST* SELECTOR CONDITION                                                                      (COND                                                                         ((CL:SYMBOLP PROCEED-CASE)                                                                          CL:VALUES)                                                                         ((CL:FBOUNDP NAME)                                                                          (CL:APPLY (                                                                                PROCEED-ARG-COLLECTOR                                                                                     NAME)                                                                                 CONDITION CL:VALUES)                                                                          )                                                                         (T CL:VALUES)))))))          ELSE (CL:ERROR 'BAD-PROCEED-CASE :NAME PROCEED-CASE))))(DEFINE-PROCEED-FUNCTION ABORT :TEST TRUE :REPORT "Abort")(DEFINE-PROCEED-FUNCTION PROCEED :REPORT "Proceed with no special action" :TEST TRUE)(DEFINE-PROCEED-FUNCTION USE-VALUE :REPORT "Use a different value" :TEST TRUE                                         (VALUE (PROGN (CL:FORMAT *QUERY-IO* "Enter a new value: ")                                                       (EVAL (CL:READ *QUERY-IO*)))))(DEFINE-PROCEED-FUNCTION STORE-VALUE :REPORT "Store a new value and use it" :TEST TRUE                                           (VALUE (PROGN (CL:FORMAT *QUERY-IO*                                                                 "Enter a value to store: ")                                                         (CL:EVAL (CL:READ *QUERY-IO*)))))(CL:DEFUN SIMPLE-FORMAT (STREAM &REST ARGS) (CL:WHEN (EQ STREAM T)                                                   (CL:SETF STREAM *STANDARD-OUTPUT*))                                            (CL:DOLIST (X ARGS)                                                   (CL:PRINT X STREAM)))(MOVD? 'SIMPLE-FORMAT 'CL:FORMAT)(DECLARE\: DONTCOPY (RPAQQ SHOULD-BE-IN-PACKAGE        (("XCL" :EXTERNAL DEFINE-CONDITION HANDLER-BIND CONDITION-BIND CONDITION-CASE IGNORE-ERRORS                PROCEED-CASE DEFINE-PROCEED-FUNCTION CATCH-ABORT CONDITION SIMPLE-CONDITION WARNING                SIMPLE-WARNING SERIOUS-CONDITION ERROR SIMPLE-ERROR ASSERTION-FAILED CELL-ERROR                UNBOUND-VARIABLE UNDEFINED-FUNCTION INDEX-BOUNDS-ERROR TYPE-MISMATCH CONTROL-ERROR                ILLEGAL-GO ILLEGAL-RETURN ILLEGAL-THROW CALL-ERROR TOO-MANY-ARGUMENTS                TOO-FEW-ARGUMENTS INVALID-ARGUMENT-LIST STREAM-ERROR READ-ERROR END-OF-FILE                STORAGE-CONDITION STACK-OVERFLOW STORAGE-EXHAUSTED MAKE-CONDITION SIGNAL DEBUG                FIND-PROCEED-CASE COMPUTE-PROCEED-CASES INVOKE-PROCEED-CASE ABORT PROCEED USE-VALUE                STORE-VALUE)        ("SI" :INTERNAL *PROCEED-CASES* *CONDITION-HANDLER-BINDINGS*))))(PUTPROPS ERROR-RUNTIME FILETYPE CL:COMPILE-FILE)(PUTPROPS ERROR-RUNTIME COPYRIGHT ("Xerox Corporation" 1986))(DECLARE\: DONTCOPY  (FILEMAP (NIL)))STOP