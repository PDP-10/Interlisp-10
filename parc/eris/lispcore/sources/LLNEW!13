(DEFINE-FILE-INFO §READTABLE "XCL" §PACKAGE "INTERLISP")(filecreated "17-Oct-86 12:45:03" {eris}<lispcore>sources>llnew.\;13 56868        |changes| |to:|  (fns makeinitlast)                       (vars llnewcoms)      |previous| |date:| " 8-Sep-86 14:40:01" {eris}<lispcore>sources>llnew.\;11); Copyright (c) 1981, 1982, 1983, 1984, 1985, 1986 by Xerox Corporation.  All rights reserved.(prettycomprint llnewcoms)(rpaqq llnewcoms        ((coms (* \; "low level memory access")              (fns \\addbase \\getbase \\putbase \\putbase.ufn \\putbaseptr.ufn \\putbits.ufn                    \\getbasebyte \\putbasebyte \\getbaseptr \\putbaseptr \\hiloc \\loloc \\vag2 eq                    eql \\rplptr \\rplptr.ufn)              (prop bytemacro eql)              (fns loc vag)              (fns createpages \\new4page)              (declare\: dontcopy (export (records pointer word)                                         (macros ptrgtp .coerce.to.smallposp. .coerce.to.byte.))                     (addvars (inewcoms (fns \\getbasebyte \\putbasebyte createpages \\new4page))                            (rdcoms (fns \\car.ufn \\cdr.ufn)                                   (fns \\copy \\uncopy)                                   (fns \\getbasebyte \\putbasebyte))                            (initptrs (\\listpdtd))                            (mki.subfns (\\addbase . i.addbase)                                   (\\getbase . i.getbase)                                   (\\putbase . i.putbase)                                   (\\getbaseptr . i.getbaseptr)                                   (\\putbaseptr . i.putbaseptr)                                   (\\hiloc . i.hiloc)                                   (\\loloc . i.loloc)                                   (\\vag2 . i.vag2)                                   (.coerce.to.smallposp. . prog1)                                   (.coerce.to.byte. . prog1)                                   (lockedpagep . mki.lockedpagep)                                   (\\rplptr . i.putbaseptr)                                   (cons . i.\\cons.ufn))                            (rd.subfns (\\addbase . vaddbase)                                   (\\getbase . vgetbase)                                   (\\putbase . vputbase)                                   (\\getbaseptr . vgetbaseptr)                                   (\\putbaseptr . vputbaseptr)                                   (\\hiloc . vhiloc)                                   (\\loloc . vloloc)                                   (\\vag2 . vvag2)                                   (.coerce.to.smallposp. . prog1)                                   (.coerce.to.byte. . prog1)                                   (cons . vcons)                                   (createcell . vcreatecell)                                   (copystring . vcopystring)                                   (ptrgtp . igreaterp)                                   (\\rplptr . vputbaseptr)                                   (car . v\\car.ufn)                                   (cdr . v\\cdr.ufn)                                   (car/cdrerr . t)))                     eval@compile                     (addvars (dontcompilefns createpages))))        (coms (* \; "cons cells")              (fns cons \\cons.ufn car \\car.ufn cdr \\cdr.ufn rplaca \\rplaca.ufn rplacd                    \\rplacd.ufn docollect \\rplcons endcollect \\initconspage \\nextconspage)              (fns \\restlist.ufn \\findkey.ufn)              (initvars (car/cdrerr 'cdr))              (declare\: dontcopy (globalvars car/cdrerr)                     (export (records listp conspage)                            (constants * consconstants))                     (macros .makeconscell.)                     (* \; "for MAKEINIT")                     (addvars (inewcoms (fns \\cons.ufn \\initconspage \\nextconspage))                            (expandmacrofns .makeconscell.)))              (coms (* \; "testing out CONSes")                    (fns checkconspages \\checkconspage)                    (declare\: dontcopy (macros !check))))        (coms (* \; "other random stuff for makeinit")              (fns makeinitfirst makeinitlast \\copy \\uncopy)              (declare\: dontcopy (export (macros local allocal))                     (addvars (mki.subfns (check . *)                                     (raid . help)                                     (uninterruptably                                          . progn)                                     (|\\StatsAdd1| . *)                                     (evq . i.\\copy)                                     (copy . i.\\copy))                            (rd.subfns (check . *)                                   (raid . help)                                   (uninterruptably                                        . progn)                                   (|\\StatsAdd1| . *)                                   (evq . v\\copy)                                   (copy . v\\copy)                                   (1st . v\\uncopy)))                     (addvars (inewcoms (fns makeinitfirst \\copy makeinitlast)))                     eval@compile                     (addvars (dontcompilefns makeinitfirst \\copy makeinitlast \\uncopy))))        (localvars . t)))(* \; "low level memory access")(defineq(\\addbase  (lambda (x d)                                              (* |lmm| " 2-NOV-81 18:33")                    (* |usually| |done| |in| |microcode;| |this| |version| |uses| |only|           |arithmetic| |and| \\vag2)    (prog (nh nl (xh (\\hiloc x))              (xl (\\loloc x)))          (.unbox. d nh nl)          (cond             ((igreaterp xl (idifference max.small.integer nl))                                                             (* |carry|)              (|add| xh 1)              (setq xl (sub1 (idifference xl (idifference max.small.integer nl)))))             (t (|add| xl nl)))          (cond             ((igreaterp nh max.pos.hinum)              (setq xh (sub1 (idifference xh (idifference max.small.integer nh)))))             (t (|add| xh nh)))          (return (\\vag2 xh xl)))))(\\getbase  (lambda (x d)                                              (* |lmm| " 2-NOV-81 18:33")                    (* |usually| |done| |in| |microcode;| |case| |where| d=0 must |be| |done| |in|           |microcode|)    (\\getbase (\\addbase x d)           0)))(\\putbase  (lambda (x d v)                                            (* |lmm| "11-FEB-83 07:35")                    (* |usually| |done| |in| |microcode;| |case| |where| d=0 must |be| |handled|           |there|)    (\\putbase (\\addbase x d)           0           (.coerce.to.smallposp. v))))(\\putbase.ufn  (lambda (x v d)                                            (* |lmm| "11-FEB-83 07:35")                    (* |usually| |done| |in| |microcode;| |case| |where| d=0 must |be| |handled|           |there|)    (\\putbase (\\addbase x d)           0           (.coerce.to.smallposp. v))))(\\putbaseptr.ufn  (lambda (x v d)                                            (* |lmm| "10-NOV-81 15:12")                    (* |usually| |done| |in| |microcode;| |this| |def| |uses| |only| putbase\,           addbase\, |etc|)    (\\putbase x d (\\hiloc v))    (\\putbase (\\addbase x d)           1           (\\loloc v))    v))(\\putbits.ufn  (lambda (x v n.fd)                                         (* |lmm| "11-FEB-83 07:35")    (prog ((nv (.coerce.to.smallposp. v))           (width (add1 (logand n.fd 15)))           (first (lrsh (logand n.fd 255)                        4))           mask shift)          (setq shift (idifference 16 (iplus first width)))          (setq mask (sub1 (llsh 1 width)))          (\\putbase (setq x (\\addbase x (lrsh n.fd 8)))                 0                 (logor (logand (\\getbase x 0)                               (logxor 65535 (llsh mask shift)))                        (llsh (logand nv mask)                              shift)))          (return nv))))(\\getbasebyte  (lambda (ptr n)                                            (* |bvm:| " 5-Feb-85 12:05")                    (* |usually| |done| |in| |microcode;| |this| |def.|          |uses| |only| \\getbase |and| |arithmetic| -          |used| |by| makeinit |too|)    (cond       ((evenp n)        (|fetch| (word hibyte) |of| (\\getbase ptr (foldlo n bytesperword))))       (t (|fetch| (word lobyte) |of| (\\getbase ptr (foldlo n bytesperword)))))))(\\putbasebyte  (lambda (ptr disp byte)                                    (* |JonL| "31-Dec-83 23:48")                    (* |usually| |done| |in| |microcode| -          |this| |def| |used| |by| makeinit |too|)    (setq byte (.coerce.to.byte. byte))    (\\putbase ptr (foldlo (setq disp (\\dtest disp 'smallp))                          bytesperword)           (cond              ((evenp disp bytesperword)               (|create| word |using| (\\getbase ptr (foldlo disp bytesperword))                                    hibyte _ byte))              (t (|create| word |using| (\\getbase ptr (foldlo disp bytesperword))                                      lobyte _ byte))))    byte))(\\getbaseptr  (lambda (x d)                                              (* |lmm| " 2-NOV-81 18:34")                    (* |usually| |done| |in| |microcode;| |this| |def.|          |uses| getbase\, vag2\, |etc.| |and| |handles| |overflows| |too|)    (\\vag2 (|fetch| lobyte |of| (\\getbase x d))           (\\getbase (\\addbase x 1)                  d))))(\\putbaseptr  (lambda (x d v)                                            (* |lmm| " 2-NOV-81 18:35")                    (* |usually| |done| |in| |microcode;| |this| |def| |uses| |only| putbase\,           addbase\, |etc|)    (\\putbase x d (\\hiloc v))    (\\putbase (\\addbase x d)           1           (\\loloc v))    v))(\\hiloc  (lambda (x)                                                (* |lmm| "10-MAR-81 15:02")                                                             (* must |be| |handled| |in|                                                              |microcode|)    (\\hiloc x)))(\\loloc  (lambda (x)                                                (* |lmm| "10-MAR-81 15:03")                                                             (* must |be| |handled| |in|                                                              |microcode|)    (\\loloc x)))(\\vag2  (lambda (h l)                                              (* |JonL| "31-Dec-83 23:39")                    (* |case| |where| h |is| |byte| |and| l |is| |smallposp| must |be| |handled|           |in| |microcode.| |Other| |cases| |may| |run| |error| |here.|)    (\\vag2 (.coerce.to.byte. h)           (.coerce.to.smallposp. l))))(eq  (lambda (x y)                                              (* |lmm| "10-MAR-81 15:04")                                                             (* must |be| |handled| |in|                                                              |microcode|)    (eq x y)))(eql  (lambda (x y)                                              (* |raf| " 8-Sep-86 14:23")                    (* * "Like EQ except for numbers")    (or (eq x y)        (cl:typecase x (integer (and (typep y 'integer)                                     (ieqp x y)))               (float (and (typep y 'float)                           (feqp x y)))               (ratio (and (typep y 'ratio)                           (eql (ratio-numerator x)                                (ratio-numerator y))                           (eql (ratio-denominator x)                                (ratio-denominator y))))               (complex (and (typep y 'complex)                             (eql (complex-realpart x)                                  (complex-realpart y))                             (eql (complex-imagpart x)                                  (complex-imagpart y))))))))(\\rplptr  (lambda (obj offset val)                                   (* |lmm| " 3-NOV-81 12:10")    (uninterruptably        (\\addref val)        (\\delref (\\getbaseptr (setq obj (\\addbase obj offset))                         0))        (\\putbasebyte obj 1 (\\hiloc val))                  (* \\putbaseptr |smashes| |the| |high|                                                              |byte|)        (\\putbase obj 1 (\\loloc val))        val)))(\\rplptr.ufn  (lambda (obj val offset)                                   (* |lmm| " 3-NOV-81 12:10")                    (* ufn |is| |different| |from| |function| |since| |the| |offset|          (|inline|) |gets| |pushed| |last|)    (uninterruptably        (\\addref val)        (\\delref (\\getbaseptr (setq obj (\\addbase obj offset))                         0))        (\\putbasebyte obj 1 (\\hiloc val))                  (* \\putbaseptr |smashes| |the| |high|                                                              |byte|)        (\\putbase obj 1 (\\loloc val))        val))))(putprops eql bytemacro comp.eq)(defineq(loc  (lambda (x)                                                (* |lmm| " 2-NOV-81 18:29")                    (* |Return| hiloc-loloc |pair,| |for| |easier| |traffic| |with| raid.          vag |interprets| |such| |pairs| |correctly.|)    (cons (\\hiloc x)          (\\loloc x))))(vag  (lambda (loc)                                              (* |lmm| " 2-NOV-81 18:28")                                                             (* loc |can| |be| \a hiloc-loloc                                                              |pair|)    (cond       ((listp loc)        (\\vag2 (car loc)               (or (fixp (cdr loc))                   (fix (cadr loc)))))       (t (\\vag2 (\\hinum loc)                 (\\lonum loc)))))))(defineq(createpages  (lambda (va n blankflg lockflg)                            (* |bvm:| "29-MAR-83 16:35")                    (* |called| |only| |under| makeinit -          blankflg |means| |that| makeinit |won't| |write| |on| |this| |page,| |so|           |fake| |it| -          |to| |prevent| |storage| |overflow| |when| |running| |on| |Maxc| |and|           |init'ing| gc |table|)    (|for| i |from| 0 |to| (sub1 n) |do| (\\newpage (\\addbase va (unfold i wordsperpage))                                                nil lockflg blankflg))    va))(\\new4page  (lambda (ptr)                                              (* |lmm| "11-FEB-83 07:47")    (\\newpage (\\addbase (\\newpage (\\addbase (\\newpage (\\addbase (\\newpage ptr)                                                                  wordsperpage))                                            wordsperpage))                      wordsperpage)))))(declare\: dontcopy (* FOLLOWING DEFINITIONS EXPORTED)(declare\: eval@compile(accessfns pointer ((page# (iplus (llsh (\\hiloc datum)                                        8)                                  (lrsh (\\loloc datum)                                        8)))                    (wordinpage (logand (\\loloc datum)                                       255))                    (cellinpage (lrsh (|fetch| wordinpage |of| datum)                                      1))                    (byteinpage (llsh (|fetch| wordinpage |of| datum)                                      1))                    (segment# (\\hiloc datum))                    (wordinsegment (\\loloc datum))                    (cellinsegment (lrsh (|fetch| wordinsegment |of| datum)                                         1))                    (word# (|fetch| wordinpage |of| datum))                    (dblword# (|fetch| cellinpage |of| datum))                    (pagebase (\\vag2 (\\hiloc datum)                                     (logand (\\loloc datum)                                            65280))))                   (create (\\vag2 (lrsh page# 8)                                  (llsh (logand page# 255)                                        8))))(accessfns word ((hibyte (lrsh datum 8))                 (lobyte (logand datum 255)))                (create (iplus (llsh hibyte 8)                               lobyte))))(declare\: eval@compile (putprops ptrgtp macro (openlambda (x y)                              (or (igreaterp (\\hiloc x)                                         (\\hiloc y))                                  (and (eq (\\hiloc x)                                           (\\hiloc y))                                       (igreaterp (\\loloc x)                                              (\\loloc y))))))(putprops .coerce.to.smallposp. dmacro (openlambda (x)                                              (cond ((smallposp x)                                                     x)                                                    (t (\\illegal.arg x)))))(putprops .coerce.to.byte. dmacro (openlambda (x)                                         (cond ((and (smallposp x)                                                     (ilessp x (constant (llsh 1 bitsperbyte))))                                                x)                                               (t (\\illegal.arg x))))))(* END EXPORTED DEFINITIONS)(addtovar inewcoms (fns \\getbasebyte \\putbasebyte createpages \\new4page))(addtovar rdcoms (fns \\car.ufn \\cdr.ufn)                 (fns \\copy \\uncopy)                 (fns \\getbasebyte \\putbasebyte))(addtovar initptrs (\\listpdtd))(addtovar mki.subfns (\\addbase . i.addbase)                     (\\getbase . i.getbase)                     (\\putbase . i.putbase)                     (\\getbaseptr . i.getbaseptr)                     (\\putbaseptr . i.putbaseptr)                     (\\hiloc . i.hiloc)                     (\\loloc . i.loloc)                     (\\vag2 . i.vag2)                     (.coerce.to.smallposp. . prog1)                     (.coerce.to.byte. . prog1)                     (lockedpagep . mki.lockedpagep)                     (\\rplptr . i.putbaseptr)                     (cons . i.\\cons.ufn))(addtovar rd.subfns (\\addbase . vaddbase)                    (\\getbase . vgetbase)                    (\\putbase . vputbase)                    (\\getbaseptr . vgetbaseptr)                    (\\putbaseptr . vputbaseptr)                    (\\hiloc . vhiloc)                    (\\loloc . vloloc)                    (\\vag2 . vvag2)                    (.coerce.to.smallposp. . prog1)                    (.coerce.to.byte. . prog1)                    (cons . vcons)                    (createcell . vcreatecell)                    (copystring . vcopystring)                    (ptrgtp . igreaterp)                    (\\rplptr . vputbaseptr)                    (car . v\\car.ufn)                    (cdr . v\\cdr.ufn)                    (car/cdrerr . t))eval@compile (addtovar dontcompilefns createpages))(* \; "cons cells")(defineq(cons  (lambda (x y)                                              (* |lmm| "11-FEB-82 13:55")                                                             (* |use| |microcode| ufn |to| |get|                                                              |to| \\cons.ufn)    ((opcodes cons)     x y)))(\\cons.ufn  (lambda (x y)                                              (* |bvm:| " 5-Feb-85 12:13")    (cond       ((zerop cdrcoding)        (raid)        (prog ((cell (createcell \\listp)))              (|replace| (listp car) |of| cell |with| x)              (|replace| (listp cdr) |of| cell |with| y)              (return cell))))    (uninterruptably        (\\addref x)        (\\addref y)        (|\\StatsAdd1| (|fetch| dtdcntloc |of| \\listpdtd))        (.increment.allocation.count. 1)        (prog (cns.page)              (setq cns.page (cond                                ((and (eq (ntypx y)                                          \\listp)                                      (igreaterp (|fetch| (conspage cnt) |of| (setq cns.page                                                                               (|fetch| (pointer                                                                                         pagebase)                                                                                  |of| y)))                                             0))                    (* |Test| |for| |any| |cells| |left| |on| |page| -          ntypx |rather| |than| listp |test| |for| |benefit| |of| makeinit)                                 (.makeconscell. cns.page x (iplus \\cdr.onpage (|fetch| (pointer                                                                                          dblword#)                                                                                   |of| y))))                                (t (.makeconscell. (setq cns.page (\\nextconspage))                                          x                                          (cond                                             ((null y)                                              \\cdr.nil)                                             (t (iplus \\cdr.indirect (|fetch| (pointer dblword#)                                                                         |of| (.makeconscell.                                                                                      cns.page y 0))))                                             )))))              (\\delref cns.page)              (return cns.page)))))(car  (lambda (x)                                                (* |lmm| "11-FEB-82 13:56")    ((opcodes car)     x)))(\\car.ufn  (lambda (x)                                                (* |lmm| "18-Jul-84 00:07")                    (* |most| |cases| |handled| |in| |microcode| -          |this| |code| |also| |used| |by| makeinit/readsys)    (\\callme 'car)    (cond       ((listp x)        (cond           ((zerop cdrcoding)            (|fetch| (listp car) |of| x))           (t (cond                 ((eq (|fetch| cdrcode |of| x)                      \\cdr.indirect)                  (|fetch| carfield |of| (|fetch| carfield |of| x)))                 (t (|fetch| carfield |of| x))))))       ((null x)        nil)       (t (selectq car/cdrerr              (t (lisperror "ARG NOT LIST" x))              ((nil cdr)                    (cond                      ((eq x t)                       t)                      ((litatom x)                       nil)                      (t '"{car of non-list}")))              (cond                 ((eq x t)                  t)                 ((stringp x)                  (lisperror "ARG NOT LIST" x))                 (t '"{car of non-list}")))))))(cdr  (lambda (x)                                                (* |lmm| "11-FEB-82 13:56")    ((opcodes cdr)     x)))(\\cdr.ufn  (lambda (x)                                                (* |lmm| "17-Jul-84 22:26")                    (* |most| |cases| |handled| |in| |microcode| -          |this| |code| |also| |used| |by| makeinit/readsys)    (\\callme 'cdr)    (cond       ((listp x)        (cond           ((zerop cdrcoding)            (|fetch| (listp cdr) |of| x))           (t (prog ((q (|fetch| cdrcode |of| x)))                    (return (cond                               ((eq q \\cdr.nil)                                nil)                               ((igreaterp q \\cdr.onpage)                                (\\addbase (|fetch| (pointer pagebase) |of| x)                                       (llsh (idifference q \\cdr.onpage)                                             1)))                               ((eq q \\cdr.indirect)                                (\\cdr.ufn (|fetch| carfield |of| x)))                               (t (|fetch| carfield |of| (\\addbase (|fetch| pagebase |of| x)                                                                (llsh q 1))))))))))       ((null x)        nil)       (t (selectq car/cdrerr              ((t cdr)                    (lisperror "ARG NOT LIST" x))              (nil (cond                      ((litatom x)                       (getproplist x))                      (t "{cdr of non-list}")))              (cond                 ((stringp x)                  (lisperror "ARG NOT LIST" x))                 (t "{cdr of non-list}")))))))(rplaca  (lambda (x y)                                              (* |lmm| "11-FEB-82 13:55")                                                             (* |invoke| \\rplaca.ufn)    ((opcodes rplaca)     x y)))(\\rplaca.ufn  (lambda (x y)                                              (* |lmm| " 1-DEC-81 21:17")    (cond       ((nlistp x)        (cond           ((null x)                                         (* |if| x |is| nil |and| y |is| nil                                                              |ok|)            (cond               (y (lisperror "ATTEMPT TO RPLAC NIL" y))))           (t (lisperror "ARG NOT LIST" x))))       (t (cond             ((zerop cdrcoding)              (|replace| (listp car) |of| x |with| y)              x)             (t (uninterruptably                    (\\delref (car x))                    (\\addref y)                    (|replace| carfield |of| (cond                                                ((eq (|fetch| cdrcode |of| x)                                                     \\cdr.indirect)                                                 (|fetch| carfield |of| x))                                                (t x)) |with| y)                    x)))))))(rplacd  (lambda (x y)                                              (* |lmm| "11-FEB-82 13:55")    ((opcodes rplacd)     x y)))(\\rplacd.ufn  (lambda (x y)                                              (* |lmm| "11-JAN-82 10:15")    (cond       ((nlistp x)        (cond           ((null x)                                         (* |if| x |is| nil |and| y |is| nil                                                              |ok|)            (cond               (y (lisperror "ATTEMPT TO RPLAC NIL" y))))           (t (lisperror "ARG NOT LIST" x))))       ((zerop cdrcoding)        (|replace| (listp cdr) |of| x |with| y)        x)       (t (uninterruptably              (\\delref (cdr x))              (\\addref y)              (prog (rp.page (rp.q (|fetch| cdrcode |of| x)))                    (cond                       ((eq rp.q \\cdr.indirect)                        (setq rp.page (|fetch| carfield |of| x))                        (check (ileq (|fetch| cdrcode |of| rp.page)                                     \\cdr.maxindirect)                               (neq (|fetch| cdrcode |of| rp.page)                                    \\cdr.indirect))                        (setq rp.page (\\addbase (|fetch| pagebase |of| rp.page)                                             (llsh (idifference (|fetch| cdrcode |of| rp.page)                                                          \\cdr.indirect)                                                   1)))                        (check (listp rp.page)                               (eq 0 (|fetch| cdrcode |of| rp.page)))                        (|replace| fullcarfield |of| rp.page |with| y))                       ((ileq rp.q \\cdr.maxindirect)                        (setq rp.page (\\addbase (|fetch| pagebase |of| x)                                             (llsh (idifference rp.q \\cdr.indirect)                                                   1)))                        (check (listp rp.page)                               (eq 0 (|fetch| cdrcode |of| rp.page)))                        (|replace| fullcarfield |of| rp.page |with| y))                       ((null y)                        (|replace| cdrcode |of| x |with| \\cdr.nil))                       ((eq (setq rp.page (|fetch| pagebase |of| x))                            (|fetch| pagebase |of| y))       (* |New| cdr |on| |same| |page|)                        (|replace| cdrcode |of| x |with| (iplus \\cdr.onpage (|fetch| (pointer                                                                                              dblword#                                                                                             )                                                                                |of| y))))                       ((igreaterp (|fetch| (conspage cnt) |of| rp.page)                               0)                            (* |Room| |on| |page| |for| |cdr|                                                              |cell|)                        (|replace| cdrcode |of| x |with| (iplus \\cdr.indirect                                                                (|fetch| (pointer dblword#)                                                                   |of| (.makeconscell. rp.page y 0))                                                                )))                       (t (|replace| fullcarfield |of| x                             |with| (.makeconscell. (setq rp.page (\\nextconspage))                                           (|fetch| carfield |of| x)                                           (iplus \\cdr.indirect (|fetch| (pointer dblword#)                                                                    |of| (.makeconscell. rp.page y 0)                                                                        ))))                          (|replace| cdrcode |of| x |with| \\cdr.indirect)))                    (return x)))))))(docollect  (lambda (item lst)                                         (* |lmm:| "30-SEP-76 13:03:33")    (cond       ((nlistp lst)        (frplacd (setq lst (list item))               lst))       (t (cdr (frplacd lst (cons item (cdr lst))))))))(\\rplcons  (lambda (lst item)                                         (* |bvm:| " 5-Feb-85 22:49")                                                             (* (cdr (rplacd lst (cons item nil))))    (cond       ((and (neq cdrcoding 0)             (listp lst)             (uninterruptably                                     (* |Have| |to| |go| |uninterruptable| |here| |so| |that| |someone| |doesn't|           |change| |the| cnt |field| |to| |zero| |out| |from| |under| |us|)                 (prog ((cpage (|fetch| (pointer pagebase) |of| lst))                        cell)                       (return (cond                                  ((and (neq (|fetch| (conspage cnt) |of| cpage)                                             0)                                        (igreaterp (|fetch| cdrcode |of| lst)                                               \\cdr.maxindirect))                                   (\\addref item)                                   (\\delref (cdr lst))                                   (setq cell (.makeconscell. cpage item \\cdr.nil))                                   (|\\StatsAdd1| (|fetch| dtdcntloc |of| \\listpdtd))                                   (.increment.allocation.count. 1)                                   (|replace| cdrcode |of| lst |with| (iplus \\cdr.onpage                                                                             (|fetch| (pointer                                                                                              dblword#                                                                                             )                                                                                |of| cell)))                                   cell)))))))       (t (setq item (cons item nil))                    (* |Have| |to| |be| |careful| |how| |this| |part| |is| |written,| |or|           |compiler| |will| |turn| |it| |into| rplcons !)          (rplacd lst item)          item))))(endcollect  (lambda (x y)                                              (* |lmm| "21-MAR-81 13:37")    (cond       ((null x)        y)       (t (prog1 (cdr x)                 (rplacd x y))))))(\\initconspage  (lambda (base link)                                        (* |lmm| "20-DEC-81 23:11")    (cond       ((zerop cdrcoding)        (raid))       (t (prog ((j (|replace| nextcell |of| base |with| 254))                 cell)            lp  (cond                   ((neq j 0)                    (setq cell (\\addbase base j))                    (|replace| fullcarfield |of| cell |with| nil)                    (|replace| cdrcode |of| cell |with| (setq j (idifference j 2)))                    (go lp)))                (|replace| (conspage cnt) |of| base |with| 127)                    (* |if| link=nil\, |stores| \a 0.0 |This| |assumes| |that| |the| |pagebase|           |of| nil |is| nil)                (|replace| nextpage |of| base |with| (|fetch| (pointer page#) |of| link))                (return base))))))(\\nextconspage  (lambda nil                                                (* |lmm| "27-Mar-85 09:20")    (check (null \\interruptable))    (prog ((n (|fetch| dtdnextpage |of| \\listpdtd))           pg)      lp  (cond             ((eq n 0)              (setq pg (\\allocmdspage (|fetch| dtdtypeentry |of| \\listpdtd)))              (\\initconspage pg (\\initconspage (\\addbase pg wordsperpage)                                        nil))              (|replace| dtdnextpage |of| \\listpdtd |with| (pageloc pg)))             (t (setq pg (|create| pointer                                page# _ n))))          (cond             ((igreaterp (|fetch| (conspage cnt) |of| pg)                     1)              (return pg)))          (|replace| dtdnextpage |of| \\listpdtd |with| (setq n (|fetch| (conspage nextpage)                                                                   |of| pg)))          (|replace| (conspage nextpage) |of| pg |with| \\conspage.last)                                                             (* |Take| |off| |free| |list|)          (go lp)))))(defineq(\\restlist.ufn  (lambda (tail lastn firstn)                                (* |bvm:| "31-Aug-86 16:30")                    (* * "Handles &REST args by building a list of the args from FIRSTN thru LASTN, all consed onto the front of TAIL, which could be non-NIL in the case where the microcode has started the job")    (cond       (tail                                                 (* |Some| |already| |done,| |better|                                                              |take| |care| |of| |gc|)             (\\gc.handleoverflow)))    (let* ((caller (\\myalink))           (blink (|fetch| (fx blink) |of| caller))           (ivar (|fetch| (bf ivar) |of| blink))           (base (stackaddbase (idifference ivar wordspercell))))          (|for| i |from| lastn |to| firstn |by| -1 |do| (setq tail (cons (\\getbaseptr base                                                                                 (unfold i                                                                                         wordspercell)                                                                                 )                                                                          tail))                                                              (* "Might want to experiment with stopping after one iteration to let the microcode do the rest of the consing")             |finally| (return tail)))))(\\findkey.ufn  (lambda (key argn)                                         (* |bvm:| "15-Jul-86 16:51")                    (* * "Searches argument list of current function for an argument EQ to KEY.  Search starts at the argument index given as the alpha byte ARGN and examines every other argument.  The first arg is numbered 1; i.e., arg(i) is located at ivar0 + 2*(i-1).  If KEY is found as arg i, returns i+1 (which is later to be fed to ARG0); otherwise returns NIL.")    (let* ((caller (\\myalink))           (blink (|fetch| (fx blink) |of| caller))           (ivar (|fetch| (bf ivar) |of| blink))           (nargs (sub1 (foldlo (idifference blink ivar)                               wordspercell))))          (|for| i |from| argn |to| nargs |by| 2             |as| (base _ (stackaddbase (plus ivar (unfold (sub1 argn)                                                          wordspercell))))             |by| (\\addbase base (times 2 wordspercell)) |when| (eq (\\getbaseptr base 0)                                                                     key)             |do| (return (add1 i)))))))(rpaq? car/cdrerr 'cdr)(declare\: dontcopy (declare\: doeval@compile dontcopy(globalvars car/cdrerr))(* FOLLOWING DEFINITIONS EXPORTED)(declare\: eval@compile(blockrecord listp ((car pointer)                    (cdr pointer))                   (create (createcell \\listp))             (* following are cdr-code fields)                   (blockrecord listp ((cdrcode byte)                                       (carfield xpointer)))                   (accessfns listp ((fullcarfield nil (\\putbaseptr datum 0 newvalue))))                    (* |because| |replace| |of| xpointer |is| |slow,| |the| car |field| |is|           |stored| |with| putbaseptr\, |even| |though| |that| |smashes| |the| |hi| |byte|)                   )(blockrecord conspage ((cnt byte)                       (nextcell byte)                       (nextpage word))))(rpaqq consconstants (\\cdr.onpage \\cdr.nil \\cdr.indirect \\cdr.maxindirect \\conspage.last))(declare\: eval@compile (rpaqq \\cdr.onpage 128)(rpaqq \\cdr.nil 128)(rpaqq \\cdr.indirect 0)(rpaqq \\cdr.maxindirect 127)(rpaqq \\conspage.last 65535)(constants \\cdr.onpage \\cdr.nil \\cdr.indirect \\cdr.maxindirect \\conspage.last))(* END EXPORTED DEFINITIONS)(declare\: eval@compile (putprops .makeconscell. macro (openlambda (page a d)                                      (prog ((.mk.newcell (\\addbase page (|fetch| (conspage nextcell                                                                                          )                                                                                 |of| page))))                                            (check (neq (|fetch| (conspage cnt)                                                               |of| page)                                                        0)                                                   (evenp (|fetch| (conspage nextcell)                                                                 |of| page)))                                            (|replace| (conspage nextcell)                                                   |of| page |with| (|fetch| (listp cdrcode)                                                                           |of| .mk.newcell))                                            (check (evenp (|fetch| (conspage nextcell)                                                                 |of| page)))                                            (|add| (|fetch| (conspage cnt)                                                          |of| page)                                                   -1)                                            (|replace| (listp fullcarfield)                                                   |of| .mk.newcell |with| a)                                            (|replace| (listp cdrcode)                                                   |of| .mk.newcell |with| d)                                            (return .mk.newcell)))))(addtovar inewcoms (fns \\cons.ufn \\initconspage \\nextconspage))(addtovar expandmacrofns .makeconscell.))(* \; "testing out CONSes")(defineq(checkconspages  (lambda nil                                                (* |bvm:| "29-Jan-85 22:51")    (cond       ((zerop cdrcoding)        nil)       (t (|for| (cpage _ (|create| pointer                                 page# _ (|fetch| dtdnextpage |of| \\listpdtd)))             |do| (cond                     ((null cpage)                           (* |End| |of| |free| |list|)                      (return))                     ((neq (ntypx cpage)                           \\listp)                    (* |Free| |list| |not| |pointing| |at| \a |cons| |page.|          |Test| |is| |not| |for| listp |because| listp |is| |formally| |defined| |to|           |be| |false| |for| |list| |page| |bases|)                      (help cpage))                     (t (setq cpage (|create| pointer                                           page# _ (|fetch| (conspage nextpage) |of| cpage))))))          (\\mapmds 'listp (function \\checkconspage))))))(\\checkconspage  (lambda (pn)                                               (* |bvm:| "27-Jan-85 14:52")                                                             (* |check| |if| |page| pn |is| |ok|)    (prog ((ptr (|create| pointer                       page# _ pn))           nxt cnt)          (setq cnt (|fetch| (conspage cnt) |of| ptr))          (!check (evenp (setq nxt (|fetch| (conspage nextcell) |of| ptr))                         wordspercell))      lp  (cond             ((igreaterp cnt 0)              (!check (and (neq nxt 0)                           (evenp (setq nxt (|fetch| (listp cdrcode) |of| (\\addbase ptr nxt)))                                  wordspercell)))              (|add| cnt -1)              (go lp)))          (!check (eq nxt 0))))))(declare\: dontcopy (declare\: eval@compile (putprops !check macro ((x)                        (or x (raid 'x))))))(* \; "other random stuff for makeinit")(defineq(makeinitfirst  (lambda nil                                                (* |bvm:| "13-Jun-86 15:41")    (createmdstypetable)    (\\setup.hunk.typenumbers)    (initdatatypes)    (preinitarrays)    (\\turn.on.hunking)    (initatoms)    (initdatatypenames)    (initufntable)    (initgc)    (\\newpage |\\InterfacePage| nil t)))(makeinitlast  (lambda (versions)                                         (* |Pavel| "17-Oct-86 12:42")    (setupstack t)    (makeinitbfs)    (progn                     (* |fold| |in| |property| |list| |and| |values| |gathered| |from| |boot|           |files|)           (selectq (systemtype)               ((d alto)                     (local (maphash mki.plha (function (lambda (p a)                                                         (setproplist a (copy p))))))                    (local (maphash mki.tvha (function (lambda (v a)                                                         (settopval a (copy (local (cdr v)))))))))               (prog (al gag)                    (* |the| |reason| |this| |is| |set| |up| |this| |way| |is| |because| |there|           |is| \a |bug| |in| |Interlisp-10| |suchthat| |if| \a |garbage| |collection|           |happens| |in| |the| |middle| |of| \a maphash\, |some| |of| |the| |values| |in|           |the| |hash| |array| |may| |be| |missed| |because| |the| |garbage| |collector|           |has| |moved| |stuff| |around| |and| |rehashed| |the| |data| |in| |the|           |array.| |Thus| |we| |are| |careful| |to| |set| |things| |up| |so| |that| |no|           |garbage| |collection| |happens|)                     (allocal (progn (minfs (imax (minfs)                                                  (itimes 2 (arraysize (car mki.plha)))                                                  (arraysize (car mki.tvha))))                                     (reclaim)                                     (setq gag (gcgag "[***** GARBAGE COLLECTION - ERROR ******]"))                                     (maphash mki.plha (function (lambda (p a)                                                                   (|push| al (cons a p)))))                                     (setq gag (gcgag gag))))                     (local (mapc al (function (lambda (x)                                                 (setproplist (car x)                                                        (copy (cdr x)))))))                     (allocal (progn (setq al)                                     (reclaim)                                     (setq gag (gcgag gag))                                     (maphash mki.tvha (function (lambda (v a)                                                                   (|push| al (rplaca v a)))))                                     (gcgag gag)))                     (local (mapc al (function (lambda (x)                                                 (settopval (car x)                                                        (copy (cdr x)))))))))                                                             (* |set| |most| |initial| |variables|)           )    (prog ((afl (filearraybase)))                    (* |put| |output| |on| \a |double| |page| |boundary| -          |output| |at| |least| |one| |page|)          (local (boutzeros (idifference (times 2 bytesperpage)                                   (unfold (imod (\\loloc afl)                                                 (times 2 wordsperpage))                                          bytesperword))))          (setq mki.codelastpage (pageloc (filearraybase)))                    (* |now| |we| |can| |update| |the| |string/array| |space| |freelist| |to|           |point| |beyond| |the| |code| |area| -          w\e |call| postinitarrays |with| (\a) |pointer| |to| |word| |after| |end| |of|           |compiled| |code,| (\b) |page| |number| |of| |beginning| |of| |compiled|           |code,| |and| (\c) |page| |number| |after| |compiled| |code|)          (postinitarrays afl (iplus |\\FirstArrayPage| mki.codestartoffset)                 mki.codelastpage))    (mapc (allocal (append initvalues initptrs))          (function (lambda (x)                              (* |make| |sure| |atoms| |exist| |for|                                                              |initial| |atoms|)                      (\\atomvalindex (local (car x))))))    (|for| x |in| initvalues |as| a |in| mki.values       |do| (setq a (local (evalv a)))            (settopval (local (car x))                   (cond                      ((allocal (or (eq a t)                                    (eq a nil)                                    (and (fixp a)                                         (igeq a -65536)                                         (ileq a 65535))))                       (copy a))                      (t (shouldnt)))))    (|for| x |in| initptrs |as| a |in| mki.ptrs |do| (settopval (local (car x))                                                            (local (evalv a))))    (|for| x |in| lockedvars |do|                            (* |;;| "If the variable exists, then we lock it.  Otherwise, just print a message and proceed anyway, hoping the fellow knows what he's doing.  We don't want to create a new piece of storage at this point because we've already made a note of where our last allocated page is.")                                  (if (gethash x mki.atomarray)                                      then (\\lockvar x)                                    else (|printout| t "***Note: Locked var " x                                                 " does not exist, proceeding anyway." t)))    (setuppagemap)    (dumpinitpages (iplus |\\FirstArrayPage| mki.codestartoffset)           mki.codelastpage versions)))(\\copy  (lambda (x)                                                (* |bvm:| "27-Aug-86 22:16")                                                             (* |Prints| x |into| |the| makeinit /                                                              readsys |system|)    (selectq (local (typename x))        (litatom (unlessrdsys (mki.atom x)                        (vatomnumber x t)))        (listp (prog ((r (local (reverse x)))                      (v (\\copy (local (cdr (local (last x)))))))                 lp  (cond                        ((local (listp r))                         (setq v (cons (\\copy (local (car r)))                                       v))                         (setq r (local (cdr r)))                         (go lp)))                     (return v)))        ((fixp smallp)              (prog (v)                   (cond                      ((local (igreaterp 0 x))               (* |negative|)                       (cond                          ((local (igreaterp x -65537))      (* |small| |neg|)                           (return (\\addbase \\smallnegspace (local (logand x 65535)))))))                      ((local (ilessp x 65536))              (* |small| |pos|)                       (return (\\addbase \\smallpospspace x))))                                                             (* |need| |to| |create| \a |boxed|                                                              |integer|)                   (setq v (createcell \\fixp))                   (\\putbase v 0 (logor (cond                                            ((igreaterp 0 x)                                             32768)                                            (t 0))                                         (logand (lrsh x 16)                                                32767)))                   (\\putbase v 1 (logand x 65535))                   (return v)))        (stringp (copystring x))        (floatp (prog ((val (createcell \\floatp)))                      (selectq (systemtype)                          ((alto d)                                (\\putbase val 0 (local (\\getbase x 0)))                               (\\putbase val 1 (local (\\getbase x 1))))                          (mki.ieee x val))                      (return val)))        (character (\\vag2 \\charhi (cl:char-code x)))        (error x '(|can't| |be| |copied| |to| |remote| |file|)))))(\\uncopy  (lambda (x carlvl cdrlvl)                                  (* |bvm:| "28-Jan-86 18:03")    (selectc (ntypx x)        (\\smallp (cond                     ((eq (\\hiloc x)                          |\\SmallPosHi|)                    (* |This| |test| |used| |to| |be| smallposp |until| |its| |definition|           |changed| |to| |test| (igreaterp x 0)\, |which| |doesn't| |work| |renamed|)                      (\\loloc x))                     (t (iplus (\\loloc x)                               -65536))))        (\\fixp                                              (* integer)                (local (|create| fixp                              hinum _ (|ffetch| (fixp hinum) |of| x)                              lonum _ (|ffetch| (fixp lonum) |of| x))))        (\\floatp (local (|create| floatp                                hiword _ (|ffetch| (floatp hiword) |of| x)                                loword _ (|ffetch| (floatp loword) |of| x))))        (\\litatom (vatom (\\loloc x)))        (\\stringp (prog ((ptr (|ffetch| (stringp base) |of| x))                          (offst (|ffetch| (stringp offst) |of| x))                          (length (|ffetch| (stringp length) |of| x))                          (i 1)                          str)                    (* |Use| |ffetch| |to| |avoid| |bogus| |DTEST's| |in| |the| |renamed| |version|)                         (setq str (allocstring length))                         (frptq length (local (rplstring str i (local (fcharacter (\\getbasebyte                                                                                   ptr offst)))))                                (|add| i 1)                                (|add| offst 1))                         (return str)))        (\\listp (cond                    ((listp x)                     (cond                        ((eq cdrlvl 0)                       (* |Abbreviate|)                         '(--))                        (t (local (cons (cond                                           ((or (eq carlvl 0)                                                (and (or (eq carlvl 1)                                                         (eq cdrlvl 1))                                                     (listp (car x))))                                            '&)                                           (t (\\uncopy (car x)                                                     (and carlvl (sub1 carlvl))                                                     (and cdrlvl (sub1 cdrlvl)))))                                        (\\uncopy (cdr x)                                               carlvl                                               (and cdrlvl (sub1 cdrlvl))))))))                    (t                     (* |Redundant| listp |test| |in| |case| x |is| |list| |page| |header|)                       (allocal (vtypedpointer 'listp x)))))        (0 (local (vtypedpointer nil x)))        (local (vtypedpointer (typename x)                      x))))))(declare\: dontcopy (* FOLLOWING DEFINITIONS EXPORTED)(declare\: eval@compile (putprops local macro ((x)                       x))(putprops allocal macro ((x)                         x)))(* END EXPORTED DEFINITIONS)(addtovar mki.subfns (check . *)                     (raid . help)                     (uninterruptably                          . progn)                     (|\\StatsAdd1| . *)                     (evq . i.\\copy)                     (copy . i.\\copy))(addtovar rd.subfns (check . *)                    (raid . help)                    (uninterruptably                         . progn)                    (|\\StatsAdd1| . *)                    (evq . v\\copy)                    (copy . v\\copy)                    (1st . v\\uncopy))(addtovar inewcoms (fns makeinitfirst \\copy makeinitlast))eval@compile (addtovar dontcompilefns makeinitfirst \\copy makeinitlast \\uncopy))(declare\: doeval@compile dontcopy(localvars . t))(putprops llnew copyright ("Xerox Corporation" 1981 1982 1983 1984 1985 1986))(declare\: dontcopy  (filemap (nil (5415 13784 (\\addbase 5425 . 6303) (\\getbase 6305 . 6604) (\\putbase 6606 . 6936) (\\putbase.ufn 6938 . 7272) (\\putbaseptr.ufn 7274 . 7653) (\\putbits.ufn 7655 . 8369) (\\getbasebyte 8371 . 8879) (\\putbasebyte 8881 . 9628) (\\getbaseptr 9630 . 10038) (\\putbaseptr 10040 . 10415) (\\hiloc 10417 . 10720) (\\loloc 10722 . 11025) (\\vag2 11027 . 11394) (eq 11396 . 11691) (eql 11693 . 12622) (\\rplptr 12624 . 13130) (\\rplptr.ufn 13132 . 13782)) (13823 14653 (loc 13833 . 14153) (vag 14155 . 14651)) (14654 15666 (createpages 14664 . 15273) (\\new4page 15275 . 15664)) (19948 36022 (cons 19958 . 20280) (\\cons.ufn 20282 . 22617) (car 22619 . 22753) (\\car.ufn 22755 . 23937) (cdr 23939 . 24073) (\\cdr.ufn 24075 . 25688) (rplaca 25690 . 25923) (\\rplaca.ufn 25925 . 27017) (rplacd 27019 . 27161) (\\rplacd.ufn 27163 . 31279) (docollect 31281 . 31556) (\\rplcons 31558 . 33662) (endcollect 33664 . 33882) (\\initconspage 33884 . 34818) (\\nextconspage 34820 . 36020)) (36023 38721 (\\restlist.ufn 36033 . 37526) (\\findkey.ufn 37528 . 38719)) (41921 43801 (checkconspages 41931 . 42958) (\\checkconspage 42960 . 43799)) (43973 55766 (makeinitfirst 43983 . 44333) (makeinitlast 44335 . 50005) (\\copy 50007 . 52551) (\\uncopy 52553 . 55764)))))stop