(DEFINE-FILE-INFO §READTABLE "XCL" §PACKAGE "INTERLISP")(FILECREATED "22-Oct-86 16:30:02" {ERIS}<LISPCORE>SOURCES>CMLARITH.\;9 117196       |changes| |to:|  (FNS %COMPLEX-TIMESI CL:CONJUGATE %= COMPLEX CL:REALPART CL:IMAGPART)      |previous| |date:| "30-Sep-86 00:31:17" {ERIS}<LISPCORE>SOURCES>CMLARITH.\;6); Copyright (c) 1985, 1986 by Xerox Corporation.  All rights reserved.(PRETTYCOMPRINT CMLARITHCOMS)(RPAQQ CMLARITHCOMS        ((* |;;;| "CMLARITH.  Common Lisp Arithmetic.  Covers all of Common Lisp arithmetic except for higher math functions.  Covers sections 2.1-2.1.4, 12.1-12.4, and 12.6-12.10 Doesn't cover sections 12.5-12.5.3.  -- By Kelly Roach "           )        (COMS (* \; "Miscellaneous. ")              (FNS CL:ISQRT PRIMEP CL:PHASE CL:SIGNUM %SIGNUM))        (COMS (* \; "Section 2.1.2 Ratios. ")              (STRUCTURES RATIO)              (DECLARE\: DONTEVAL@LOAD DOCOPY (P (* \; "The following makes NUMBERP true on ratios")                                                 (\\SETTYPEMASK (\\TYPENUMBERFROMNAME 'RATIO)                                                        (LOGOR \\TT.NUMBERP \\TT.ATOM))))              (FNS CL:NUMERATOR CL:DENOMINATOR CL:RATIONALP CL:RATIONAL CL:RATIONALIZE %RATIO-PRINT                    %BUILD-RATIO %RATIONALIZE-FLOAT %RATIO* %RATIO/ %RATIO-TIMES-QUOTIENT %RATIO+                    %RATIO- %RATIO-PLUS-DIFFERENCE %RATIO-INTEGER* %RATIO-INTEGER+ %RATIO-INTEGER-))        (COMS (* \; "Section 2.1.4 Complex Numbers.")              (STRUCTURES COMPLEX)              (DECLARE\: DONTEVAL@LOAD DOCOPY (P (* \; "Make it so that COMPLEX is NUMBERP")                                                 (\\SETTYPEMASK (\\TYPENUMBERFROMNAME 'COMPLEX)                                                        (LOGOR \\TT.NUMBERP \\TT.ATOM))))              (FNS COMPLEX CL:REALPART CL:IMAGPART %COMPLEX+ %COMPLEX- %COMPLEX* %COMPLEX/                    %COMPLEX-ABS %COMPLEX-MINUS %COMPLEX-TIMESI CL:CONJUGATE %COMPLEX-PRINT))        (COMS (* \; "Section 12.2 Predicates on Numbers.")              (* \; "MINUSP is made to work on ratios.  Otherwise, backwards compatible.")              (FNS NEW-MINUSP)              (DECLARE\: DONTEVAL@LOAD DOCOPY (P (MOVD 'NEW-MINUSP 'MINUSP)))              (FNS CL:ZEROP)              (FNS EVENP ODDP CL:PLUSP))        (COMS (* \; "Section 12.3 Comparisons on Numbers.")              (FNS %= %>)              (FNS = %= CL:/= < > <= >=)              (OPTIMIZERS = CL:/= < > <= >=)              (* |;;|  "MAX and MIN are OK because they use GREATERP and GREATERP is fixed by this file to work on ratios."                 ))        (COMS (* \; "Section 12.4 Arithmetic Operations.")              (FNS + - CL:* / %/ CL:1+ CL:1-)              (OPTIMIZERS + - CL:* / CL:1+ CL:1-)              (DECLARE\: DONTEVAL@LOAD DOCOPY (P (MOVD '+ 'PLUS)                                                 (MOVD '- 'DIFFERENCE)                                                 (MOVD 'CL:1+ 'ADD1)                                                 (MOVD 'CL:1- 'SUB1)                                                 (MOVD 'CL:* 'TIMES)))              (* \; "INCF and DECF implemented by CMLSETF.")              (* \; "CONJUGATE implemented in section 2.1.4 above.")              (FNS CL:GCD %GCD CL:LCM))        (COMS (* \; "Section 12.6 Type Conversions and Component Extractions on Numbers.")              (* |;;;|                  "LLFLOAT replacements.  LLFLOAT ufns seem OK once we modify \\FLOAT appropriately.")              (FNS FLOAT \\FLOAT)              (* \; "NUMERATOR and DENOMINATOR implemented in section 2.1.2 above.")              (FNS CL:FLOOR CL:TRUNCATE CL:CEILING ROUND CL:MOD CL:REM CL:FFLOOR CL:FCEILING                    CL:FTRUNCATE CL:FROUND)              (* \; "Page 218 functions.")              (FNS CL:DECODE-FLOAT CL:SCALE-FLOAT CL:FLOAT-RADIX CL:FLOAT-SIGN CL:FLOAT-DIGITS                    CL:FLOAT-PRECISION CL:INTEGER-DECODE-FLOAT)              (* \; "EXPT COMPLEX REALPART and IMAGPART are defined by CMLFLOAT."))        (COMS (* |;;;| "LLARITH replacements.  Either you have to live with these replacements or you have to start fixing CLISP for loops, the history mechanism etc.  Larry tried taking these out and the things I had fixed by putting these replacements in started breaking again.  These replacements are supposed to be good for you in any case."                 )              (COMS (* \; "Non ufns")                    (* |;;| "GREATERP and LESSP are made to work on ratios.  EQP, ABS, and MINUS is fixed to work on ratios and complexs.  *"                       )                    (FNS NEW-LESSP NEW-EQP NEW-ABS NEW-MINUS)                    (DECLARE\: DONTEVAL@LOAD DOCOPY (P (MOVD '%> 'GREATERP)                                                       (MOVD 'NEW-LESSP 'LESSP)                                                       (MOVD 'NEW-EQP 'EQP)                                                       (MOVD 'NEW-ABS 'ABS)                                                       (MOVD 'NEW-MINUS 'MINUS))))              (COMS (* \; "New LLARITH UFNS")                    (COMS (* |;;| "INTEGER ARITH UFNS .UNBOX.  is made to understand RATIOs so integer arith ufns must be recompiled.  \\IQUOTREM has not changed, but \\IQUOTREM uses .UNBOX.  and NEW-SLOWIQUOTIENT and NEW-IREMAINDER use \\IQUOTREM."                             )                          (DECLARE\: EVAL@COMPILE DONTCOPY (MACROS .CMLUNBOX. .CMLIQUOTREM.))                          (FNS NEW-SLOWIPLUS2 NEW-SLOWIDIFFERENCE NEW-SLOWITIMES2 NEW-SLOWIQUOTIENT                                NEW-IREMAINDER NEW-SLOWIGREATERP))                    (DECLARE\: DONTEVAL@LOAD DOCOPY (P (\\SETUFNENTRY (CAR (\\FINDOP 'IPLUS2))                                                              'NEW-SLOWIPLUS2 2 0)                                                       (\\SETUFNENTRY (CAR (\\FINDOP 'IDIFFERENCE))                                                              'NEW-SLOWIDIFFERENCE 2 0)                                                       (\\SETUFNENTRY (CAR (\\FINDOP 'ITIMES2))                                                              'NEW-SLOWITIMES2 2 0)                                                       (\\SETUFNENTRY (CAR (\\FINDOP 'IQUOTIENT))                                                              'NEW-SLOWIQUOTIENT 2 0)                                                       (\\LOCKFN 'NEW-SLOWIQUOTIENT)                                                       (* \; "because original is locked")                                                       (\\SETUFNENTRY (CAR (\\FINDOP 'IREMAINDER))                                                              'NEW-IREMAINDER 2 0)                                                       (\\SETUFNENTRY (CAR (\\FINDOP 'IGREATERP))                                                              'NEW-SLOWIGREATERP 2 0)))))        (COMS (* \; "New general arithmetic UFNs which know about ratio and complex")              (* |;;| "NOTE: %/ CAN NOT COMPILE INTO THE EXISTING QUOTIENT OPCODE.  This is because %/ is supposed to produce a rational when numerator is not evenly divisible by denominator.  Therefore, there is no MACRO for %/ below."                 )              (PROP DOPVAL %+ %- %* %>)              (FNS %+ %- %* %/)              (DECLARE\: DONTEVAL@LOAD DOCOPY (P (\\SETUFNENTRY (CAR (\\FINDOP 'PLUS2))                                                        '%+ 2 0)                                                 (\\SETUFNENTRY (CAR (\\FINDOP 'DIFFERENCE))                                                        '%- 2 0)                                                 (\\SETUFNENTRY (CAR (\\FINDOP 'TIMES2))                                                        '%* 2 0)                                                 (\\SETUFNENTRY (CAR (\\FINDOP 'GREATERP))                                                        '%> 2 0))))        (COMS (* \; "Section 12.7 Logical Operations on Numbers.")              (* \; "Page 221 functions.  LOGAND LOGXOR are OK.")              (FNS CL:LOGIOR CL:LOGEQV CL:LOGNAND CL:LOGNOR CL:LOGANDC1 CL:LOGANDC2 CL:LOGORC1                    CL:LOGORC2)              (* \; "Page 222. BOOLE and constants.")              (FNS CL:BOOLE)              (INITVARS (CL:BOOLE-CLR 0)                     (CL:BOOLE-SET 1)                     (CL:BOOLE-1 2)                     (CL:BOOLE-2 3)                     (CL:BOOLE-C1 4)                     (CL:BOOLE-C2 5)                     (CL:BOOLE-AND 6)                     (CL:BOOLE-IOR 7)                     (CL:BOOLE-XOR 8)                     (CL:BOOLE-EQV 9)                     (CL:BOOLE-NAND 10)                     (CL:BOOLE-NOR 11)                     (CL:BOOLE-ANDC1 12)                     (CL:BOOLE-ANDC2 13)                     (CL:BOOLE-ORC1 14)                     (CL:BOOLE-ORC2 15))              (* \; "Remainder of section 12.7 LOGNOT is OK.")              (FNS CL:LOGTEST CL:LOGBITP)              (FNS CL:ASH)              (FNS CL:LOGCOUNT %LOGCOUNT)              (FNS CL:INTEGER-LENGTH))        (COMS (* \; "Section 12.8 Byte Manipulations Functions.")              (* \; "BYTE macro already implemented.  Should be function.")              (FNS BYTE-SIZE CL:BYTE-POSITION)              (* \; "LDB macro already implemented.  Should be function.")              (FNS CL:LDB-TEST CL:MASK-FIELD)              (* \; "DPB macro already implemented.  Should be function.")              (FNS CL:DEPOSIT-FIELD))        (DECLARE\: EVAL@COMPILE DONTCOPY (FILES (LOADCOMP)                                                LLFLOAT LLCODE LLBIGNUM))        (PROP FILETYPE CMLARITH)        (DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS               (ADDVARS (NLAMA)                      (NLAML)                      (LAMA CL:DEPOSIT-FIELD CL:MASK-FIELD CL:LDB-TEST CL:BYTE-POSITION BYTE-SIZE                             CL:LOGCOUNT CL:LOGBITP CL:LOGTEST CL:BOOLE CL:LOGORC2 CL:LOGORC1                             CL:LOGANDC2 CL:LOGANDC1 CL:LOGNOR CL:LOGNAND CL:LOGEQV CL:LOGIOR                             CL:INTEGER-DECODE-FLOAT CL:FLOAT-PRECISION CL:FLOAT-DIGITS CL:FLOAT-SIGN                             CL:FLOAT-RADIX CL:DECODE-FLOAT CL:FROUND CL:FTRUNCATE CL:FCEILING                             CL:FFLOOR CL:REM CL:MOD ROUND CL:CEILING CL:TRUNCATE CL:FLOOR FLOAT                             CL:LCM %GCD CL:GCD / CL:* - + >= <= > < CL:/= = CL:PLUSP ODDP EVENP                             CL:ZEROP %COMPLEX-PRINT %COMPLEX-TIMESI %COMPLEX-MINUS %COMPLEX-ABS                             %COMPLEX/ %COMPLEX* %COMPLEX- %COMPLEX+ CL:IMAGPART CL:REALPART COMPLEX                             %RATIO-INTEGER- %RATIO-INTEGER+ %RATIO-INTEGER* %RATIO-PLUS-DIFFERENCE                             %RATIO- %RATIO+ %RATIO-TIMES-QUOTIENT %RATIO/ %RATIO* %BUILD-RATIO                             CL:RATIONALIZE CL:RATIONAL CL:DENOMINATOR CL:NUMERATOR %SIGNUM CL:SIGNUM                             CL:PHASE PRIMEP CL:ISQRT)))))(* |;;;| "CMLARITH.  Common Lisp Arithmetic.  Covers all of Common Lisp arithmetic except for higher math functions.  Covers sections 2.1-2.1.4, 12.1-12.4, and 12.6-12.10 Doesn't cover sections 12.5-12.5.3.  -- By Kelly Roach ")(* \; "Miscellaneous. ")(DEFINEQ(CL:ISQRT  (CL:LAMBDA (INTEGER)                                       (* |kbr:| "12-Jul-86 18:05")                    (* ISQRT\: |Integer| |square| |root| -          |isqrt| (\n) **2 <= \n |Upper| |and| |lower| |bounds| |on| |the| |result| |are|           |estimated| |using| |integer-length.| O\n |each| |iteration,| |one| |of| |the|           |bounds| |is| |replaced| |by| |their| |mean.|          |The| |lower| |bound| |is| |returned| |when| |the| |bounds| |meet| |or|           |differ| |by| |only| 1.0 |Initial| |bounds| |guarantee| |that| |lg|          (|sqrt| (\n)) = |lg| (\n) /2 |iterations| |suffice.|          *)         (CL:IF (AND (CL:INTEGERP INTEGER)                     (NOT (MINUSP INTEGER)))                (CL:DO* ((LG (CL:INTEGER-LENGTH INTEGER))                         (LO (CL:ASH 1 (CL:ASH (CL:1- LG)                                              -1)))                         (HI (+ LO (CL:ASH LO (CL:IF (ODDP LG)                                                     -1 0)))))                       ((<= (CL:1- HI)                         LO)                        LO)                       (LET ((MID (CL:ASH (+ LO HI)                                         -1)))                            (CL:IF (<= (CL:* MID MID)                                    INTEGER)                                   (SETQ LO MID)                                   (SETQ HI MID))))                (CL:ERROR "Isqrt: ~S argument must be a nonnegative integer" INTEGER))))(PRIMEP  (CL:LAMBDA (X)                                             (* |kbr:| " 7-Apr-86 20:54")                    (* |Returns| T |iff| X |is| \a |positive| |prime| |integer.|          *)         (CL:IF (<= X 5)                (AND (>= X 2)                     (CL:/= X 4))                (AND (NOT (EVENP X))                     (NOT (= 0 (CL:REM X 3)))                     (CL:DO ((Q 6)                             (R 1)                             (INC 2 (LOGXOR INC 6))                             (D 5 (+ D INC)))                            ((OR (= R 0)                                 (> D Q))                             (CL:/= R 0))                            (CL:MULTIPLE-VALUE-SETQ (Q R)                                   (CL:TRUNCATE X D)))))))(CL:PHASE  (CL:LAMBDA (CL:NUMBER)                                     (* |kbr:| "23-Jul-86 16:19")         (COND            ((CL:COMPLEXP CL:NUMBER)             (CL:ATAN (COMPLEX-IMAGPART CL:NUMBER)                    (COMPLEX-REALPART CL:NUMBER)))            ((MINUSP CL:NUMBER)             %PI)            (T                     (* |Page| 206 |of| |the| |silver| |book:| |The| |phase| |of| \a |positive|           |non-complex| |number| |is| |zero.| |The| |phase| |of| |zero| |is|           |arbitrarily| |defined| |to| |be| |zero.|          |The| |result| |is| \a |floating-point| |number.|          *)               0.0))))(CL:SIGNUM  (CL:LAMBDA (CL:NUMBER)                                     (* |kbr:| "13-May-86 17:10")                    (* I\f CL:NUMBER |is| |zero,| |return| NUMBER\, |else| |return|          (/ CL:NUMBER (ABS CL:NUMBER))\. |Currently| |not| |implemented| |for| |complex|           |numbers.| *)         (COND            ((ZEROP CL:NUMBER)             CL:NUMBER)            (T (COND                  ((CL:RATIONALP CL:NUMBER)                   (COND                      ((CL:PLUSP CL:NUMBER)                       1)                      (T -1)))                  (T (/ CL:NUMBER (ABS CL:NUMBER))))))))(%SIGNUM  (CL:LAMBDA (X)         (LET ((RES (COND                       ((CL:PLUSP X)                        1)                       ((ZEROP X)                        0)                       (T -1))))              (CL:IF (FLOATP X)                     (FLOAT RES X)                     RES)))))(* \; "Section 2.1.2 Ratios. ")(DEFSTRUCT (RATIO (:CONSTRUCTOR %MAKE-RATIO (CL:NUMERATOR CL:DENOMINATOR))                  (:PRINT-FUNCTION %RATIO-PRINT)) (CL:NUMERATOR :READ-ONLY) (CL:DENOMINATOR                                                                                    :READ-ONLY))(DECLARE\: DONTEVAL@LOAD DOCOPY (* \; "The following makes NUMBERP true on ratios")(\\SETTYPEMASK (\\TYPENUMBERFROMNAME 'RATIO)       (LOGOR \\TT.NUMBERP \\TT.ATOM)))(DEFINEQ(CL:NUMERATOR  (CL:LAMBDA (CL:RATIONAL)                                   (* |kbr:| "12-Jul-86 18:05")                                                             (* |Returns| |the| |numerator| |of| \a                                                              |rational.|)         (CL:ETYPECASE CL:RATIONAL (INTEGER CL:RATIONAL)                (RATIO (RATIO-NUMERATOR CL:RATIONAL)))))(CL:DENOMINATOR  (CL:LAMBDA (CL:RATIONAL)                                   (* |kbr:| "12-Jul-86 18:05")                                                             (* |Returns| |the| |denominator| |of|                                                              \a |rational.| *)         (CL:ETYPECASE CL:RATIONAL (INTEGER 1)                (RATIO (RATIO-DENOMINATOR CL:RATIONAL)))))(CL:RATIONALP  (LAMBDA (CL:NUMBER)                                        (* |lmm| "22-May-86 15:45")    (OR (CL:INTEGERP CL:NUMBER)        (RATIO-P CL:NUMBER))))(CL:RATIONAL  (CL:LAMBDA (CL:NUMBER)                                     (* |lmm| "19-Jun-86 14:42")                    (* |Rational| |produces| \a |rational| |number| |for| |any| |numeric|           |argument.| |Rational| |assumed| |that| |the| |floating| |point| |is|           |completely| |accurate.| *)         (CL:ETYPECASE CL:NUMBER (INTEGER CL:NUMBER)                (FLOAT (CL:MULTIPLE-VALUE-BIND (F E SIGN)                              (CL:DECODE-FLOAT CL:NUMBER)                              (LET* ((PRECISION (CL:FLOAT-PRECISION F))                                     (F (CL:TRUNCATE (CL:SCALE-FLOAT F PRECISION)))                                     (V (CL:IF (MINUSP E)                                               (%BUILD-RATIO F (CL:ASH 1 (- PRECISION E)))                                               (%BUILD-RATIO (CL:ASH F E)                                                      (CL:ASH 1 PRECISION)))))                                    V)))                (RATIO CL:NUMBER)                (COMPLEX (%MAKE-COMPLEX (CL:RATIONAL (CL:REALPART CL:NUMBER))                                (CL:RATIONAL (CL:IMAGPART CL:NUMBER)))))))(CL:RATIONALIZE  (CL:LAMBDA (CL:NUMBER)                                     (* |kbr:| "14-Aug-86 15:07")                    (* |Rationalize| |does| \a |rational,| |but| |it| |assumes| |that| |floats|           |are| |only| |accurate| |to| |their| |precision,| |and| |generates| \a |good|           |rational| |aproximation| |of| |them.| *)         (CL:ETYPECASE CL:NUMBER ((OR INTEGER RATIO)                                  CL:NUMBER)                (FLOAT (%RATIONALIZE-FLOAT CL:NUMBER))                (COMPLEX (%MAKE-COMPLEX (CL:RATIONALIZE (CL:REALPART CL:NUMBER))                                (CL:RATIONALIZE (CL:IMAGPART CL:NUMBER)))))))(%RATIO-PRINT  (LAMBDA (CL:NUMBER STREAM)                                 (* |bvm:| " 3-Aug-86 16:08")    (LET ((TOP (CL:NUMERATOR CL:NUMBER))          (BOTTOM (CL:DENOMINATOR CL:NUMBER)))         (COND            ((NOT (|fetch| (READTABLEP COMMONNUMSYNTAX) |of| *READTABLE*))                                                             (* |Can't| |print| |nice| |ratios|                                                              |to| |old| |read| |tables|)             (PRIN1 "|." STREAM)             (\\PRINDATUM (LIST '/ TOP BOTTOM)                    STREAM))            (T (LET (*PRINT-RADIX*)                    (* |Can't| |have| |radix| |specifier| |in| |ratio,| |but| |ratio| |must|           |print| |in| |current| |base.| |Note| |that| |this| |means| |you'd| |better|           |always| |read| |and| |print| |in| |same| |base,| |since| |radix| |specifiers|           |can't| |help| |you| |here|)                    (.SPACECHECK. STREAM (IPLUS 1 (NCHARS TOP)                                                (NCHARS BOTTOM)))                    (LET (\\THISFILELINELENGTH)                         (DECLARE (SPECVARS \\THISFILELINELENGTH))                    (* |Turn| |off| |linelength| |check| |just| |in| |case| |the| NCHARS |count|           |is| |off| |because| |of| |radices|)                         (\\PRINDATUM TOP STREAM)                         (PRIN3 "/" STREAM)                         (\\PRINDATUM BOTTOM STREAM))))))    T))(%BUILD-RATIO  (CL:LAMBDA (X Y)                                           (* |kbr:| " 8-May-86 22:13")                    (* %BUILD-RATIO |takes| |two| |integer| |arguments| |and| |builds| |the|           |rational| |number| |which| |is| |their| |quotient.|          *)         (CL:MULTIPLE-VALUE-BIND (Q R)                (CL:TRUNCATE X Y)                (CL:IF (ZEROP R)                       Q                       (LET ((CL:GCD (%GCD X Y)))                            (CL:UNLESS (= CL:GCD 1)                                   (PROGN (SETQ X (/ X CL:GCD))                                          (SETQ Y (/ Y CL:GCD))))                            (CL:IF (MINUSP Y)                                   (%MAKE-RATIO (- X)                                          (- Y))                                   (%MAKE-RATIO X Y)))))))(%RATIONALIZE-FLOAT  (LAMBDA (X)                                                (* |kbr:| "20-Aug-86 19:36")                                                             (* |Produce| \a |rational|                                                              |approximating| X. *)    (PROG (SIGN XNUM XDEN EXPT R F OLDNUM OLDDEN NUM DEN)                    (* * |This| |routine| |presupposes| |familiarity| |with| |topics| |in| |number|           |theory| |and| IEEE FLOATP |representation.|          |The| |algorithm| |uses| \a |standard| |mathematical| |technique| |for|           |approximating| \a |real| |valued| |number,| |but| |in| |very| |sophisticated|           |form| |more| |amenable| |to| |the| |computer| |and| |the| |nature| |of| IEEE           FLOATP\s |and| |is| |not| |an| |algorithm| |you| |are| |likely| |to| |find|           |published| |anywhere.| |Warning| |to| |the| |wise:| I\f |you| |don't| |know|           |anything| |about| |the| |theory| |of| |continued| |fractions,| |then| I           |suggest| |you| |look| |but| |don't| |touch.|          *)                    (* * |First| |of| |all,| X |is| |range| |reduced| |to| |the| |interval|          ((SQRT .5) (SQRT 2)) |excluding| (SQRT 2) |This| |strategy| |has| |the|           |property| |that| FLOATP\s |differing| |only| |by| |sign| |and| \a |power| |of|           |two| |rationalize| |into| |rationals| |differing| |only| |by| |sign| |and| \a           |power| |of| |two.| |The| |choice| |of| |interval|          ((SQRT .5) (SQRT 2)) |versus| |another| |interval| |such| |as|          (.5 1) |is| |due| |to| |our| |wanting| |there| |to| |be| |roughly| |the| |same|           |number| |of| |significant| |bits| |in| |the| |numerator| |as| |in| |the|           |denominator| |of| |the| |answer| |that| |is| |returned.|          |Here,| |significant| |bits| |is| |taken| |to| |mean| |the| |number| |of|           |bits| |in| |the| |results| |returned| |by| |the| |continued| |fraction|           |approximation| |and| |excludes| |the| |bits| |resulting| |from| |multiplying|           |by| |the| |power| |of| |two.| *)          (PROGN                                             (* |Get| SIGN XNUM XDEN |and| EXPT                                                              |for| X. *)                 (CL:MULTIPLE-VALUE-SETQ (XNUM EXPT SIGN)                        (CL:INTEGER-DECODE-FLOAT X))                 (COND                    ((EQ XNUM 0)                             (* I\n |case| X = 0\, |just| |return|                                                              0 *)                     (RETURN 0)))                            (* 24 |because| FLOATP\s |have| 24                                                              |bit| |mantissas.| *)                 (SETQ XDEN (CONSTANT (EXPT 2 24)))                 (SETQ EXPT (+ EXPT 24))                 (SETQ R (CL:DECODE-FLOAT X))                 (COND                    ((< XNUM 11863283)                       (* 11863283 = (SQRT .5) |mantissa.|                                                             *)                     (SETQ XDEN (LRSH XDEN 1))                     (SETQ EXPT (CL:1- EXPT))                     (SETQ R (CL:* 2 R))))                    (* A\t |this| |point,| X = (CL:* (/ XNUM XDEN)          (EXPT 2 EXPT)) |and| (/ XNUM XDEN) |is| |in| |the| |interval|          ((SQRT .5) (SQRT 2)) *)                 )          (SETQ OLDNUM 1)          (SETQ OLDDEN 0)          (SETQ NUM 0)          (SETQ DEN 1)      CFLOOP                                                             (* |Continued| |fraction|                                                              |approximation| |loop.|                                                             *)          (COND             ((AND (NOT (EQ DEN 0))                   (= (FQUOTIENT NUM DEN)                      R))              (COND                 ((> EXPT 0)                  (SETQ NUM (CL:ASH NUM EXPT)))                 ((< EXPT 0)                  (SETQ DEN (CL:ASH DEN (- EXPT)))))              (RETURN (/ (CL:* SIGN NUM)                         DEN))))          (|swap| XNUM XDEN)          (CL:MULTIPLE-VALUE-SETQ (F XNUM)                 (CL:TRUNCATE XNUM XDEN))          (SETQ NUM (+ OLDNUM (CL:* F (SETQ OLDNUM NUM))))          (SETQ DEN (+ OLDDEN (CL:* F (SETQ OLDDEN DEN))))          (GO CFLOOP))))(%RATIO*  (CL:LAMBDA (X Y)                                           (* |kbr:| " 8-Apr-86 16:10")                    (* %RATIO* |does| \a |ratio| |to| |ratio| |multiplication.|          %RATIO/ |does| \a |ratio| |to| |ratio| |division.|          *)         (LET* ((NUMX (CL:NUMERATOR X))                (NUMY (CL:NUMERATOR Y))                (DENX (CL:DENOMINATOR X))                (DENY (CL:DENOMINATOR Y)))               (%RATIO-TIMES-QUOTIENT NUMX DENX NUMY DENY))))(%RATIO/  (CL:LAMBDA (X Y)                                           (* |kbr:| " 8-Apr-86 14:02")         (LET* ((NUMX (CL:NUMERATOR X))                (NUMY (CL:NUMERATOR Y))                (DENX (CL:DENOMINATOR X))                (DENY (CL:DENOMINATOR Y)))               (CL:IF (MINUSP NUMY)                      (%RATIO-TIMES-QUOTIENT NUMX DENX (- DENY)                             (- NUMY))                      (%RATIO-TIMES-QUOTIENT NUMX DENX DENY NUMY)))))(%RATIO-TIMES-QUOTIENT  (CL:LAMBDA (H1 K1 H2 K2)                                   (* |kbr:| " 8-Apr-86 16:40")         (LET ((GCDH1K2 (%GCD H1 K2))               (GCDH2K1 (%GCD H2 K1)))              (CL:UNLESS (= GCDH1K2 1)                     (PROGN (SETQ H1 (/ H1 GCDH1K2))                            (SETQ K2 (/ K2 GCDH1K2))))              (CL:UNLESS (= GCDH2K1 1)                     (PROGN (SETQ H2 (/ H2 GCDH2K1))                            (SETQ K1 (/ K1 GCDH2K1)))))         (LET ((H (CL:* H1 H2))               (K (CL:* K1 K2)))              (CL:IF (= K 1)                     H                     (%MAKE-RATIO H K)))))(%RATIO+  (CL:LAMBDA (X Y)                    (* |%sp-ratio+| |does| \a |ratio| |to| |ratio| |addition.|          |%sp-ratio-| |does| \a |ratio| |to| |ratio| |subtraction.|          VM\:T *)         (%RATIO-PLUS-DIFFERENCE X Y NIL)))(%RATIO-  (CL:LAMBDA (X Y)         (%RATIO-PLUS-DIFFERENCE X Y T)))(%RATIO-PLUS-DIFFERENCE  (CL:LAMBDA (X Y DIFFERENCEFLG)                             (* |kbr:| " 8-May-86 21:08")         (LET* ((H1 (CL:NUMERATOR X))                (K1 (CL:DENOMINATOR X))                (H2 (CL:NUMERATOR Y))                (K2 (CL:DENOMINATOR Y))                (D1 (%GCD K1 K2)))               (CL:WHEN DIFFERENCEFLG (SETQ H2 (- H2)))               (CL:IF (= D1 1)                      (%MAKE-RATIO (+ (CL:* H1 K2)                                      (CL:* H2 K1))                             (CL:* K1 K2))                      (LET* ((K1/D1 (/ K1 D1))                             (TEE (+ (CL:* H1 (/ K2 D1))                                     (CL:* H2 K1/D1)))                             (D2 (%GCD TEE D1))                             (K2/D2 K2))                            (CL:UNLESS (= D2 1)                                   (PROGN (SETQ K2/D2 (/ K2 D2))                                          (SETQ TEE (/ TEE D2))))                            (CL:IF (= K1/D1 1 K2/D2)                                   TEE                                   (%MAKE-RATIO TEE (CL:* K1/D1 K2/D2))))))))(%RATIO-INTEGER*  (CL:LAMBDA (X Y)                                           (* |kbr:| " 8-Apr-86 20:19")                                                             (* %RATIO-INTEGER* |multiplies| \a                                                              |ratio| |by| |an| |integer.|                                                             *)         (CL:IF (ZEROP Y)                0                (LET* ((DEN (CL:DENOMINATOR X))                       (CL:GCD (%GCD DEN Y)))                      (CL:UNLESS (= CL:GCD 1)                             (PROGN (SETQ Y (/ Y CL:GCD))                                    (SETQ DEN (/ DEN CL:GCD))))                      (CL:IF (= DEN 1)                             (CL:* (CL:NUMERATOR X)                                   Y)                             (%MAKE-RATIO (CL:* (CL:NUMERATOR X)                                                Y)                                    DEN))))))(%RATIO-INTEGER+  (CL:LAMBDA (X Y)                                           (* |lmm| "22-May-86 15:41")                                                             (* %RATIO-INTEGER+ |adds| |an|                                                              |integer| |to| \a |ratio.|                                                             *)         (LET ((DENX (RATIO-DENOMINATOR X)))              (%MAKE-RATIO (+ (RATIO-NUMERATOR X)                              (CL:* DENX Y))                     DENX))))(%RATIO-INTEGER-  (CL:LAMBDA (X Y)                                           (* |lmm| "22-May-86 15:41")                                                             (* %RATIO-INTEGER- |subtracts| |an|                                                              |integer| |from| \a |ratio.|                                                             *)         (LET ((DENX (RATIO-DENOMINATOR X)))              (%MAKE-RATIO (- (RATIO-NUMERATOR X)                              (CL:* DENX Y))                     DENX)))))(* \; "Section 2.1.4 Complex Numbers.")(DEFSTRUCT (COMPLEX (:PREDICATE CL:COMPLEXP)                    (:CONSTRUCTOR %MAKE-COMPLEX (CL:REALPART CL:IMAGPART))                    (:PRINT-FUNCTION %COMPLEX-PRINT)) (CL:REALPART :READ-ONLY) (CL:IMAGPART                                                                                       :READ-ONLY))(DECLARE\: DONTEVAL@LOAD DOCOPY (* \; "Make it so that COMPLEX is NUMBERP")(\\SETTYPEMASK (\\TYPENUMBERFROMNAME 'COMPLEX)       (LOGOR \\TT.NUMBERP \\TT.ATOM)))(DEFINEQ(COMPLEX  (CL:LAMBDA (CL:REALPART &OPTIONAL (CL:IMAGPART 0))         (* |kbr:| " 9-Jul-86 21:05")                    (* |Builds| \a |complex| |number| |from| |the| |specified| |components.|          |Note:| CL:IMAGPART = 0.0 |or| |floating| CL:REALPART |implies| |that| |we|           |must| |build| \a |complex| |not| \a |real| |according| |to| |the| |manual|           |while| CL:IMAGPART = 0 |and| |rational| CL:REALPART |implies| |that| |we|           |build| \a |real.| |Strange,| |but| |that's| |the| |way| |Guy| |Steele| |wants|           |it.| *)         (CTYPECASE CL:REALPART (CL:RATIONAL (CL:IF (EQL CL:IMAGPART 0)                                                    CL:REALPART                                                    (CTYPECASE CL:IMAGPART (CL:RATIONAL (                                                                                        %MAKE-COMPLEX                                                                                         CL:REALPART                                                                                          CL:IMAGPART)                                                                                  )                                                           (FLOAT (%MAKE-COMPLEX (FLOAT CL:REALPART)                                                                         CL:IMAGPART)))))                (FLOAT (%MAKE-COMPLEX CL:REALPART (FLOAT CL:IMAGPART))))))(CL:REALPART  (CL:LAMBDA (CL:NUMBER)                                     (* |lmm| "22-May-86 16:19")         (CL:ETYPECASE CL:NUMBER (COMPLEX (COMPLEX-REALPART CL:NUMBER))                (CL:NUMBER CL:NUMBER))))(CL:IMAGPART  (CL:LAMBDA (CL:NUMBER)                                     (* |lmm| "22-May-86 16:56")         (CL:ETYPECASE CL:NUMBER (COMPLEX (COMPLEX-IMAGPART CL:NUMBER))                (FLOAT 0.0)                (CL:NUMBER 0))))(%COMPLEX+  (CL:LAMBDA (X Y)                                           (* |addition| *)         (COMPLEX (+ (CL:REALPART X)                     (CL:REALPART Y))                (+ (CL:IMAGPART X)                   (CL:IMAGPART Y)))))(%COMPLEX-  (CL:LAMBDA (X Y)                                           (* |subtraction| *)         (COMPLEX (- (CL:REALPART X)                     (CL:REALPART Y))                (- (CL:IMAGPART X)                   (CL:IMAGPART Y)))))(%COMPLEX*  (CL:LAMBDA (Z1 Z2)                                         (* |multiplication| *)         (LET* ((R1 (CL:REALPART Z1))                (C1 (CL:IMAGPART Z1))                (R2 (CL:REALPART Z2))                (C2 (CL:IMAGPART Z2)))               (COMPLEX (- (CL:* R1 R2)                           (CL:* C1 C2))                      (+ (CL:* C1 R2)                         (CL:* R1 C2))))))(%COMPLEX/  (CL:LAMBDA (Z1 Z2)                                         (* |kbr:| "23-Apr-86 00:05")                                                             (* |complex| |division| *)         (LET* ((R1 (CL:REALPART Z1))                (C1 (CL:IMAGPART Z1))                (R2 (CL:REALPART Z2))                (C2 (CL:IMAGPART Z2))                (CONS1 (CL:* R2 R2))                (CONS2 (CL:* C2 C2))                (MULT1 (CL:* R1 R2)))               (COMPLEX (/ (+ MULT1 (CL:* C1 C2))                           (+ CONS1 CONS2))                      (/ (- (CL:* C1 R2)                            (CL:* R1 C2))                         (+ CONS1 CONS2))))))(%COMPLEX-ABS  (CL:LAMBDA (Z)                                             (* |lmm| "27-Jun-86 22:36")         (LET ((X (COMPLEX-REALPART Z))               (Y (COMPLEX-IMAGPART Z)))              (CL:SQRT (+ (CL:* X X)                          (CL:* Y Y))))))(%COMPLEX-MINUS  (CL:LAMBDA (Z)                                             (* |kbr:| " 8-Apr-86 00:06")         (COMPLEX (- (CL:REALPART Z))                (- (CL:IMAGPART Z)))))(%COMPLEX-TIMESI  (CL:LAMBDA (Z)                                             (* |kbr:| " 8-Apr-86 00:06")                                                             (* |multiplying| \i (|the| |square|                                                              |root| |of| -1) |times| \a |number| *)         (COMPLEX (- (CL:IMAGPART Z))                (CL:REALPART Z))))(CL:CONJUGATE  (LAMBDA (CL:NUMBER)                                        (* |lmm| "22-May-86 16:57")    (CL:ETYPECASE CL:NUMBER (COMPLEX (%MAKE-COMPLEX (COMPLEX-REALPART CL:NUMBER)                                            (- (COMPLEX-IMAGPART CL:NUMBER))))           (CL:NUMBER CL:NUMBER))))(%COMPLEX-PRINT  (CL:LAMBDA (COMPLEX STREAM)                                (* |lmm| "26-Jun-86 10:31")         (FORMAT STREAM "~CC(~S ~S)" (CL:INT-CHAR (|fetch| (READTABLEP HASHMACROCHAR) |of|                                                                                           *READTABLE*                                                         ))                (COMPLEX-REALPART COMPLEX)                (COMPLEX-IMAGPART COMPLEX)))))(* \; "Section 12.2 Predicates on Numbers.")(* \; "MINUSP is made to work on ratios.  Otherwise, backwards compatible.")(DEFINEQ(NEW-MINUSP  (LAMBDA (CL:NUMBER)                                        (* |kbr:| " 9-Jul-86 22:10")    (%> 0 CL:NUMBER))))(DECLARE\: DONTEVAL@LOAD DOCOPY (MOVD 'NEW-MINUSP 'MINUSP))(DEFINEQ(CL:ZEROP  (CL:LAMBDA (CL:NUMBER)                                     (* |kbr:| "21-Jul-86 17:19")         (= CL:NUMBER 0))))(DEFINEQ(EVENP  (CL:LAMBDA (CL:NUMBER &OPTIONAL (MODULUS 2))               (* |lmm| "22-May-86 17:25")         (ZEROP (CL:MOD CL:NUMBER MODULUS))))(ODDP  (CL:LAMBDA (CL:NUMBER &OPTIONAL (MODULUS 2))               (* |lmm| "22-May-86 17:26")         (NOT (ZEROP (CL:MOD CL:NUMBER MODULUS)))))(CL:PLUSP  (CL:LAMBDA (CL:NUMBER)                                     (* |lmm| "22-May-86 16:59")         (> CL:NUMBER 0))))(* \; "Section 12.3 Comparisons on Numbers.")(DEFINEQ(%=  (LAMBDA (X Y)                                              (* |kbr:| " 9-Jul-86 19:37")                    (* %= |does| |coercion| |when| |checking| |numbers| |for| |equality.|          |Page| 196 |of| |silver| |book.| *)    (\\CALLME '=)    (OR (EQL X Y)        (CTYPECASE X (INTEGER (CTYPECASE Y (FLOAT (FEQP X Y))                                     (COMPLEX (AND (%= X (COMPLEX-REALPART Y))                                                   (%= 0 (COMPLEX-IMAGPART Y))))                                     (CL:NUMBER NIL)))               (RATIO (CTYPECASE Y (RATIO (AND (EQL (RATIO-NUMERATOR X)                                                    (RATIO-NUMERATOR Y))                                               (EQL (RATIO-DENOMINATOR X)                                                    (RATIO-DENOMINATOR Y))))                             (FLOAT (EQL (FLOAT X)                                         Y))                             (INTEGER NIL)                             (COMPLEX (AND (%= X (COMPLEX-REALPART Y))                                           (%= (COMPLEX-IMAGPART Y)                                               0)))))               (FLOAT (CTYPECASE Y (FLOAT                    (* EQL |failed|)                                          NIL)                             ((OR INTEGER RATIO)                              (FEQP X Y))                             (COMPLEX (AND (%= X (COMPLEX-REALPART Y))                                           (%= (COMPLEX-IMAGPART Y)                                               0)))))               (COMPLEX (CTYPECASE Y (COMPLEX (AND (%= (COMPLEX-REALPART X)                                                       (COMPLEX-REALPART Y))                                                   (%= (COMPLEX-IMAGPART X)                                                       (COMPLEX-IMAGPART Y))))                               (CL:NUMBER (AND (%= (COMPLEX-REALPART X)                                                   Y)                                               (%= (COMPLEX-IMAGPART X)                                                   0)))))))))(%>  (LAMBDA (X Y)                                              (* |lmm| "20-Jun-86 07:16")    (\\CALLME '>)    (CTYPECASE X (INTEGER (CTYPECASE Y (INTEGER (IGREATERP X Y))                                 (FLOAT (FGREATERP X Y))                                 (RATIO (IGREATERP (CL:* (CL:DENOMINATOR Y)                                                         X)                                               (CL:NUMERATOR Y)))))           (FLOAT (CTYPECASE Y ((OR INTEGER FLOAT)                                (FGREATERP X Y))                         (RATIO (FGREATERP (CL:* (CL:DENOMINATOR Y)                                                 X)                                       (CL:NUMERATOR Y)))))           (RATIO (CTYPECASE Y (INTEGER (IGREATERP (CL:NUMERATOR X)                                               (CL:* (CL:DENOMINATOR X)                                                     Y)))                         (FLOAT (FGREATERP (FQUOTIENT (CL:NUMERATOR X)                                                  (CL:DENOMINATOR X))                                       Y))                         (RATIO (IGREATERP (CL:* (CL:NUMERATOR X)                                                 (CL:DENOMINATOR Y))                                       (CL:* (CL:NUMERATOR Y)                                             (CL:DENOMINATOR X))))))))))(DEFINEQ(=  (CL:LAMBDA (CL:NUMBER &REST MORE-NUMBERS)                  (* |kbr:| " 9-Jul-86 19:28")         (|for| N |in| MORE-NUMBERS |always| (%= CL:NUMBER N))))(%=  (LAMBDA (X Y)                                              (* |kbr:| " 9-Jul-86 19:37")                    (* %= |does| |coercion| |when| |checking| |numbers| |for| |equality.|          |Page| 196 |of| |silver| |book.| *)    (\\CALLME '=)    (OR (EQL X Y)        (CTYPECASE X (INTEGER (CTYPECASE Y (FLOAT (FEQP X Y))                                     (COMPLEX (AND (%= X (COMPLEX-REALPART Y))                                                   (%= 0 (COMPLEX-IMAGPART Y))))                                     (CL:NUMBER NIL)))               (RATIO (CTYPECASE Y (RATIO (AND (EQL (RATIO-NUMERATOR X)                                                    (RATIO-NUMERATOR Y))                                               (EQL (RATIO-DENOMINATOR X)                                                    (RATIO-DENOMINATOR Y))))                             (FLOAT (EQL (FLOAT X)                                         Y))                             (INTEGER NIL)                             (COMPLEX (AND (%= X (COMPLEX-REALPART Y))                                           (%= (COMPLEX-IMAGPART Y)                                               0)))))               (FLOAT (CTYPECASE Y (FLOAT                    (* EQL |failed|)                                          NIL)                             ((OR INTEGER RATIO)                              (FEQP X Y))                             (COMPLEX (AND (%= X (COMPLEX-REALPART Y))                                           (%= (COMPLEX-IMAGPART Y)                                               0)))))               (COMPLEX (CTYPECASE Y (COMPLEX (AND (%= (COMPLEX-REALPART X)                                                       (COMPLEX-REALPART Y))                                                   (%= (COMPLEX-IMAGPART X)                                                       (COMPLEX-IMAGPART Y))))                               (CL:NUMBER (AND (%= (COMPLEX-REALPART X)                                                   Y)                                               (%= (COMPLEX-IMAGPART X)                                                   0)))))))))(CL:/=  (CL:LAMBDA (&REST NUMBERS)                                 (* |lmm| "16-Jul-85 16:56")         (|for| X |on| NUMBERS |always| (|for| Y |in| (CDR X) |always| (NOT (= (CAR X)                                                                               Y))))))(<  (CL:LAMBDA (CL:NUMBER &REST MORE-NUMBERS)                  (* |kbr:| " 9-Jul-86 19:18")         (OR (NULL MORE-NUMBERS)             (AND (%> (CAR MORE-NUMBERS)                      CL:NUMBER)                  (|for| TAIL |on| MORE-NUMBERS |while| (CDR TAIL) |always| (%> (CADR TAIL)                                                                                (CAR TAIL)))))))(>  (CL:LAMBDA (CL:NUMBER &REST MORE-NUMBERS)                  (* |kbr:| " 9-Jul-86 19:16")         (OR (NULL MORE-NUMBERS)             (AND (%> CL:NUMBER (CAR MORE-NUMBERS))                  (|for| TAIL |on| MORE-NUMBERS |while| (CDR TAIL) |always| (%> (CAR TAIL)                                                                                (CADR TAIL)))))))(<=  (CL:LAMBDA (CL:NUMBER &REST MORE-NUMBERS)                  (* |kbr:| " 9-Jul-86 19:27")         (OR (NULL MORE-NUMBERS)             (AND (NOT (%> CL:NUMBER (CAR MORE-NUMBERS)))                  (|for| TAIL |on| MORE-NUMBERS |while| (CDR TAIL)                     |always| (NOT (%> (CAR TAIL)                                       (CADR TAIL))))))))(>=  (CL:LAMBDA (CL:NUMBER &REST MORE-NUMBERS)                  (* |kbr:| " 9-Jul-86 20:46")         (OR (NULL MORE-NUMBERS)             (AND (NOT (%> (CAR MORE-NUMBERS)                           CL:NUMBER))                  (|for| TAIL |on| MORE-NUMBERS |while| (CDR TAIL)                     |always| (NOT (%> (CADR TAIL)                                       (CAR TAIL)))))))))(DEFOPTIMIZER = (N &REST NS)   (COND      ((CDR NS)       (LET ((NNAME (GENSYM)))            `(LET ((,NNAME ,N))                  (AND ,@(|for| X |in| NS |collect| `(%= ,NNAME ,X))))))      (T `(%= ,N ,(CAR NS)))))(DEFOPTIMIZER CL:/= (N &REST NS)   (COND      (NS       (COND          ((CDR NS)           (LET            ((VARS (|for| X |in| (CONS N NS) |collect| (LIST (GENSYM 'CL:/=)                                                             X))))            `(LET ,VARS                  (AND ,@(|for| X |on| VARS                            |join| (|for| Y |on| (CDR VARS)                                      |collect| `(NOT (= ,(CAAR X) ,(CAAR Y)))))))))          (T `(NOT (= ,N ,(CAR NS))))))      (T T)))(DEFOPTIMIZER < (N &REST NS)   (COND      ((NULL NS)       T)      ((CDR NS)       (LET ((VARS (FOR X IN (CONS N NS) COLLECT (LIST (GENSYM 'CL:/=)                                                       X))))            `((OPENLAMBDA ,(MAPCAR VARS 'CAR)                     (AND ,@(|for| X |on| VARS |while| (CDR X)                               |collect| `(LESSP ,(CAAR X) ,(CAADR X)))))              ,@(MAPCAR VARS 'CADR))))      (T `(LESSP ,N ,(CAR NS)))))(DEFOPTIMIZER > (N &REST NS)   (COND      ((NULL NS)       T)      ((CDR NS)       (LET ((VARS (FOR X IN (CONS N NS) COLLECT (LIST (GENSYM 'CL:/=)                                                       X))))            `((OPENLAMBDA ,(MAPCAR VARS 'CAR)                     (AND ,@(|for| X |on| VARS |while| (CDR X)                               |collect| `(GREATERP ,(CAAR X) ,(CAADR X)))))              ,@(MAPCAR VARS 'CADR))))      (T `(GREATERP ,N ,(CAR NS)))))(DEFOPTIMIZER <= (N &REST NS)   (COND      ((NULL NS)       T)      ((CDR NS)       (LET ((VARS (FOR X IN (CONS N NS) COLLECT (LIST (GENSYM 'CL:/=)                                                       X))))            `((OPENLAMBDA ,(MAPCAR VARS 'CAR)                     (AND ,@(|for| X |on| VARS |while| (CDR X)                               |collect| `(LEQ ,(CAAR X) ,(CAADR X)))))              ,@(MAPCAR VARS 'CADR))))      (T `(LEQ ,N ,(CAR NS)))))(DEFOPTIMIZER >= (N &REST NS)   (COND      ((NULL NS)       T)      ((CDR NS)       (LET ((VARS (FOR X IN (CONS N NS) COLLECT (LIST (GENSYM '>=)                                                       X))))            `((OPENLAMBDA ,(MAPCAR VARS 'CAR)                     (AND ,@(|for| X |on| VARS |while| (CDR X)                               |collect| `(NOT (< ,(CAAR X) ,(CAADR X))))))              ,@(MAPCAR VARS (FUNCTION CADR)))))      (T `(GEQ ,N ,(CAR NS)))))(* |;;| "MAX and MIN are OK because they use GREATERP and GREATERP is fixed by this file to work on ratios.")(* \; "Section 12.4 Arithmetic Operations.")(DEFINEQ(+  (LAMBDA N                                                  (* |kbr:| " 6-May-86 16:02")                    (* |Microcode| |generally| |handles| |the| |case| |of| |two| |args| |both|           FIXP\s)    (PROG (A R J)          (COND             ((EQ N 0)              (RETURN 0)))          (SETQ R (ARG N 1))          (SETQ J 1)      LP  (COND             ((NOT (EQ J N))              (SETQ J (ADD1 J))              (SETQ A (ARG N J))              (SETQ R (%+ R A))              (GO LP)))          (RETURN R))))(-  (LAMBDA N                                                  (* |kbr:| " 8-May-86 17:25")    (PROG (A R J)          (COND             ((EQ N 1)              (SETQ A (ARG N 1))              (SETQ R (%- 0 A))              (RETURN R)))          (SETQ R (ARG N 1))          (SETQ J 1)      LP  (COND             ((NOT (EQ J N))              (SETQ J (ADD1 J))              (SETQ A (ARG N J))              (SETQ R (%- R A))              (GO LP)))          (RETURN R))))(CL:*  (LAMBDA N                                                  (* |kbr:| " 6-May-86 17:02")    (PROG (A R J)          (COND             ((EQ N 0)              (RETURN 1)))          (SETQ R (ARG N 1))          (SETQ J 1)      LP  (COND             ((NOT (EQ J N))              (SETQ J (ADD1 J))              (SETQ A (ARG N J))              (SETQ R (%* R A))              (GO LP)))          (RETURN R))))(/  (CL:LAMBDA (CL:NUMBER &REST NUMBERS)                       (* |kbr:| " 6-May-86 18:28")         (COND            ((NULL NUMBERS)             (%/ 1 CL:NUMBER))            (T (|for| X |in| NUMBERS |do| (SETQ CL:NUMBER (%/ CL:NUMBER X)) |finally| (RETURN                                                                                             CL:NUMBER                                                                                             ))))))(%/  (LAMBDA (N1 N2)                                            (* |kbr:| "11-Sep-86 16:41")    (\\CALLME '/)                    (* UFN |for| / |Microcode| |generally| |handles| |the| |case| |of| |two| |args|           |both| FIXP\s)    (CTYPECASE N1 (INTEGER (CTYPECASE N2 (INTEGER (COND                                                     ((OR (EQ N1 MIN.INTEGER)                                                          (EQ N1 MAX.INTEGER)                                                          (EQ N2 MIN.INTEGER)                                                          (EQ N2 MAX.INTEGER)                                                          (EVENP N1 N2))                                                      (IQUOTIENT N1 N2))                                                     (T (%BUILD-RATIO N1 N2))))                                  (FLOAT (FQUOTIENT N1 N2))                                  (RATIO (%/ (CL:* (CL:DENOMINATOR N2)                                                   N1)                                             (CL:NUMERATOR N2)))                                  (COMPLEX (%COMPLEX/ (%MAKE-COMPLEX N1 0)                                                  N2))))           (FLOAT (CTYPECASE N2 ((OR INTEGER FLOAT)                                 (FQUOTIENT N1 N2))                         (RATIO (%/ (CL:* (CL:DENOMINATOR N2)                                          N1)                                    (CL:NUMERATOR N2)))                         (COMPLEX (%COMPLEX/ (%MAKE-COMPLEX N1 0.0)                                         N2))))           (RATIO (CTYPECASE N2 (INTEGER (%BUILD-RATIO (CL:NUMERATOR N1)                                                (CL:* (CL:DENOMINATOR N1)                                                      N2)))                         (FLOAT (FQUOTIENT N1 N2))                         (RATIO (%RATIO/ N1 N2))                         (COMPLEX (%COMPLEX/ (%MAKE-COMPLEX N1 0)                                         N2))))           (COMPLEX (CTYPECASE N2 (INTEGER (%COMPLEX/ N1 (%MAKE-COMPLEX N2 0)))                           (FLOAT (%COMPLEX/ N1 (%MAKE-COMPLEX N2 0.0)))                           (RATIO (%/ (CL:* (CL:DENOMINATOR N2)                                            N1)                                      (CL:NUMERATOR N2)))                           (COMPLEX (%COMPLEX/ N1 N2)))))))(CL:1+  (LAMBDA (CL:NUMBER)                                        (* |kbr:| "12-Jul-86 18:05")    (+ CL:NUMBER 1)))(CL:1-  (LAMBDA (CL:NUMBER)                                        (* |kbr:| "12-Jul-86 18:05")    (- CL:NUMBER 1))))(DEFOPTIMIZER + (&REST NUMBERS) (COND                                   ((NULL NUMBERS)                                    0)                                   (T `(PLUS (\\.\, NUMBERS)))))(DEFOPTIMIZER - (CL:NUMBER &REST NUMBERS) (COND                                             ((NULL NUMBERS)                                              `(DIFFERENCE 0 ,CL:NUMBER))                                             (T (|for| X |in| NUMBERS                                                   |do| (SETQ CL:NUMBER `(DIFFERENCE ,CL:NUMBER                                                                                ,X))                                                   |finally| (RETURN CL:NUMBER)))))(DEFOPTIMIZER CL:* (&REST NUMBERS) (COND                                      ((NULL NUMBERS)                                       1)                                      (T `(TIMES (\\.\, NUMBERS)))))(DEFOPTIMIZER / (CL:NUMBER &REST NUMBERS) (COND                                             ((NULL NUMBERS)                                              `(%/ 1 ,CL:NUMBER))                                             (T (|for| X |in| NUMBERS                                                   |do| (SETQ CL:NUMBER `(%/ ,CL:NUMBER ,X))                                                   |finally| (RETURN CL:NUMBER)))))(DEFOPTIMIZER CL:1+ (X) `(PLUS ,X 1))(DEFOPTIMIZER CL:1- (X) `(DIFFERENCE ,X 1))(DECLARE\: DONTEVAL@LOAD DOCOPY (MOVD '+ 'PLUS)(MOVD '- 'DIFFERENCE)(MOVD 'CL:1+ 'ADD1)(MOVD 'CL:1- 'SUB1)(MOVD 'CL:* 'TIMES))(* \; "INCF and DECF implemented by CMLSETF.")(* \; "CONJUGATE implemented in section 2.1.4 above.")(DEFINEQ(CL:GCD  (CL:LAMBDA (&REST INTEGERS)                                (* |kbr:| " 9-Jul-86 17:36")                    (* CL:GCD -- |gcd| |of| |an| |arbitrary| |number| |of| |integers.|          |Since| |the| |probability| |is| >.6 |that| |the| CL:GCD |of| |two| |numbers|           |is| 1\, |it| |is| |worth| |to| |time| |to| |check| |for| CL:GCD=1 |and| |quit|           |if| |so.| |However,| |in| |this| |case| |some| |arguments| |may| |never| |be|           |type-checked.| *)                    (* |Returns| |the| |greatest| |common| |divisor| |of| |zero| |or| |more|           |integers| *)         (PROG (ANSWER)               (COND                  ((NULL INTEGERS)                   (RETURN 0)))               (OR (CL:INTEGERP (CAR INTEGERS))                   (CL:ERROR "GCD: ~S is not an integer." (CAR INTEGERS)))               (SETQ ANSWER (ABS (CAR INTEGERS)))               (|for| INTEGER |in| (CDR INTEGERS) |do| (OR (CL:INTEGERP INTEGER)                                                           (CL:ERROR "GCD: ~S is not an integer."                                                                   INTEGER))                                                       (SETQ ANSWER (%GCD ANSWER INTEGER))                                                       (COND                                                          ((EQ ANSWER 1)                                                           (RETURN))))               (RETURN ANSWER))))(%GCD  (CL:LAMBDA (U V)                                           (* |kbr:| " 8-Apr-86 16:42")                    (* %GCD -- |Gcd| |of| |two| |integers,| |no| |type| |checking.|          |Rational| |routines| |should| |call| |this,| |not| CL:GCD\, |to| |save|           |overhead.| |Timings| |show| |this| |routine| |to| |be| |faster| WITHOUT          ((ZEROP V) U) . *)         (LET ((U (ABS U))               (V (ABS V)))              (COND                 ((ZEROP U)                  V)                 ((OR (= 1 V)                      (= 1 U))                  1)                 (T (CL:DO* ((K (CL:DO ((K 0 (CL:1+ K)))                                       ((OR (ODDP U)                                            (ODDP V))                                        K)                                       (PROGN (SETQ U (CL:ASH U -1))                                              (SETQ V (CL:ASH V -1)))))                             (TEE (CL:IF (ODDP U)                                         (- V)                                         (CL:ASH U -1))                                  (- U V)))                           ((ZEROP TEE)                            (CL:ASH U K))                           (CL:DO NIL ((ODDP TEE))                                  (SETQ TEE (CL:ASH TEE -1)))                           (CL:IF (CL:PLUSP TEE)                                  (SETQ U TEE)                                  (SETQ V (- TEE)))))))))(CL:LCM  (CL:LAMBDA (INTEGER &REST MORE-INTEGERS)                   (* |kbr:| " 9-Jul-86 17:45")                    (* CL:LCM -- |least| |common| |multiple.|          A\t |least| |one| |argument| |is| |required.|          W\e |must| |quit| |when| LCM=0 |is| |computed| |to| |avoid| |division| |by|           |zero.| I\n |this| |case,| |some| |arguments| |may| |never| |be|           |type-checked.| *)                    (* |Returns| |the| |least| |common| |multiple| |of| |one| |or| |more|           |integers.| *)         (PROG (ANSWER)               (OR (CL:INTEGERP INTEGER)                   (CL:ERROR "LCM: ~S is not an integer." INTEGER))               (SETQ ANSWER (ABS INTEGER))               (|for| INTEGER |in| MORE-INTEGERS |do| (OR (CL:INTEGERP INTEGER)                                                          (CL:ERROR "LCM: ~S is not an integer."                                                                  INTEGER))                                                      (SETQ ANSWER (CL:* (/ (ABS INTEGER)                                                                            (%GCD ANSWER INTEGER))                                                                         ANSWER))                                                      (COND                                                         ((EQ ANSWER 0)                                                          (RETURN))))               (RETURN ANSWER)))))(* \; "Section 12.6 Type Conversions and Component Extractions on Numbers.")(* |;;;| "LLFLOAT replacements.  LLFLOAT ufns seem OK once we modify \\FLOAT appropriately.")(DEFINEQ(FLOAT  (CL:LAMBDA (CL:NUMBER &OPTIONAL OTHER)                     (* |kbr:| " 8-May-86 16:24")                                                             (* |compiles| |this| |way,| |too|)         (\\DTEST CL:NUMBER 'FLOATP)))(\\FLOAT  (LAMBDA (X)                                                (* |kbr:| " 9-Jul-86 21:24")    (OR (FLOATP X)        (COND           ((FIXP X)            (SELECTC (NTYPX X)                (\\FIXP (LET ((HI (|fetch| (FIXP HINUM) |of| X))                              (LO (|fetch| (FIXP LONUM) |of| X))                              (SIGN 0))                             (COND                                ((IGREATERP HI MAX.POS.HINUM)                                 (.NEGATE. HI LO)                                 (SETQ SIGN 1)))                             (\\MAKEFLOAT SIGN (IPLUS \\EXPONENT.BIAS 31)                                    HI LO T)))                (\\SMALLP (LET* ((HI 0)                                 (SIGN 0)                                 (LO (COND                                        ((IGEQ X 0)                                         X)                                        (T (SETQ SIGN 1)     (* X |is| |negative--negate| |it|)                                           (COND                                              ((EQ 0 (\\LOLOC X))                                                             (* |Min| |small| |integer|)                                               (SETQ HI 1)                                               0)                                              (T (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER (\\LOLOC X)))))                                           ))))                                (\\MAKEFLOAT SIGN (IPLUS \\EXPONENT.BIAS 31)                                       HI LO T)))                (\\BIGNUM.TO.FLOAT X)))           ((RATIO-P X)            (FQUOTIENT (RATIO-NUMERATOR X)                   (RATIO-DENOMINATOR X)))           (T (\\FLOAT (LISPERROR "NON-NUMERIC ARG" X T))))))))(* \; "NUMERATOR and DENOMINATOR implemented in section 2.1.2 above.")(DEFINEQ(CL:FLOOR  (CL:LAMBDA (CL:NUMBER &OPTIONAL (DIVISOR 1))                    (* I\f |the| |numbers| |do| |not| |divide| |exactly| |and| |the| |result| |of|          (/ |number| |divisor|) |would| |be| |negative| |then| |decrement| |the|           |quotient| |and| |augment| |the| |remainder| |by| |the| |divisor.|          *)                    (* |Returns| |the| |greatest| |integer| |not| |greater| |than| |number,| |or|           |number/divisor.| |The| |second| |returned| |value| |is|          (|mod| |number| |divisor|)\. *)         (CL:MULTIPLE-VALUE-BIND (TRU CL:REM)                (CL:TRUNCATE CL:NUMBER DIVISOR)                (CL:IF (AND (NOT (ZEROP CL:REM))                            (CL:IF (MINUSP DIVISOR)                                   (CL:PLUSP CL:NUMBER)                                   (MINUSP CL:NUMBER)))                       (CL:VALUES (CL:1- TRU)                              (+ CL:REM DIVISOR))                       (CL:VALUES TRU CL:REM)))))(CL:TRUNCATE  (CL:LAMBDA (CL:NUMBER &OPTIONAL (DIVISOR 1))               (* |kbr:| "22-Jul-86 15:17")                    (* |Returns| |number| (|or| |number/divisor|) |as| |an| |integer,| |rounded|           |toward| 0.0 |The| |second| |returned| |value| |is| |the| |remainder.|          *)         (PROG (TRU CL:REM)               (SETQ TRU (COND                            ((EQ DIVISOR 1)                             (CTYPECASE CL:NUMBER (INTEGER CL:NUMBER)                                    (FLOAT (\\FIXP.FROM.FLOATP CL:NUMBER))                                    (RATIO (IQUOTIENT (RATIO-NUMERATOR CL:NUMBER)                                                  (RATIO-DENOMINATOR CL:NUMBER)))))                            (T (CTYPECASE CL:NUMBER                                      (INTEGER (CTYPECASE DIVISOR (INTEGER (IQUOTIENT CL:NUMBER                                                                                   DIVISOR))                                                      (FLOAT (\\FIXP.FROM.FLOATP (FQUOTIENT CL:NUMBER                                                                                         DIVISOR)))                                                      (RATIO (RETURN (CL:TRUNCATE (/ CL:NUMBER                                                                                      DIVISOR))))))                                      (FLOAT (CTYPECASE DIVISOR ((OR INTEGER FLOAT)                                                                 (\\FIXP.FROM.FLOATP (FQUOTIENT                                                                                      CL:NUMBER                                                                                       DIVISOR)))                                                    (RATIO (RETURN (CL:TRUNCATE (/ CL:NUMBER DIVISOR)                                                                          )))))                                      (RATIO (RETURN (CL:TRUNCATE (/ CL:NUMBER DIVISOR))))))))               (SETQ CL:REM (- CL:NUMBER (CL:* TRU DIVISOR)))               (RETURN (CL:VALUES TRU CL:REM)))))(CL:CEILING  (CL:LAMBDA (CL:NUMBER &OPTIONAL (DIVISOR 1))                    (* I\f |the| |numbers| |do| |not| |divide| |exactly| |and| |the| |result| |of|          (/ |number| |divisor|) |would| |be| |positive| |then| |increment| |the|           |quotient| |and| |decrement| |the| |remainder| |by| |the| |divisor.|          *)                    (* |Returns| |the| |smallest| |integer| |not| |less| |than| |number,| |or|           |number/divisor.| |The| |second| |returned| |value| |is| |the| |remainder.|          *)         (CL:MULTIPLE-VALUE-BIND (TRU CL:REM)                (CL:TRUNCATE CL:NUMBER DIVISOR)                (CL:IF (AND (NOT (ZEROP CL:REM))                            (CL:IF (MINUSP DIVISOR)                                   (MINUSP CL:NUMBER)                                   (CL:PLUSP CL:NUMBER)))                       (CL:VALUES (+ TRU 1)                              (- CL:REM DIVISOR))                       (CL:VALUES TRU CL:REM)))))(ROUND  (CL:LAMBDA (CL:NUMBER &OPTIONAL (DIVISOR 1 DIVP))          (* |kbr:| "12-Jul-86 19:43")                    (* |Rounds| |number| (|or| |number/divisor|) |to| |nearest| |integer.|          |The| |second| |returned| |value| |is| |the| |remainder.|          *)         (LET ((THRESH (CL:IF DIVP (/ (ABS DIVISOR)                                      2)                              .5)))              (CL:MULTIPLE-VALUE-BIND (TRU CL:REM)                     (CL:TRUNCATE CL:NUMBER DIVISOR)                     (COND                        ((OR (> CL:REM THRESH)                             (AND (= CL:REM THRESH)                                  (ODDP TRU)))                         (CL:IF (MINUSP DIVISOR)                                (CL:VALUES (- TRU 1)                                       (+ CL:REM DIVISOR))                                (CL:VALUES (+ TRU 1)                                       (- CL:REM DIVISOR))))                        ((LET ((-THRESH (- THRESH)))                              (OR (< CL:REM -THRESH)                                  (AND (= CL:REM -THRESH)                                       (ODDP TRU))))                         (CL:IF (MINUSP DIVISOR)                                (CL:VALUES (+ TRU 1)                                       (- CL:REM DIVISOR))                                (CL:VALUES (- TRU 1)                                       (+ CL:REM DIVISOR))))                        (T (CL:VALUES TRU CL:REM)))))))(CL:MOD  (CL:LAMBDA (CL:NUMBER DIVISOR)                             (* |Returns| |second| |result| |of|                                                              CL:FLOOR. *)         (LET ((CL:REM (CL:REM CL:NUMBER DIVISOR)))              (CL:IF (AND (NOT (ZEROP CL:REM))                          (CL:IF (MINUSP DIVISOR)                                 (CL:PLUSP CL:NUMBER)                                 (MINUSP CL:NUMBER)))                     (+ CL:REM DIVISOR)                     CL:REM))))(CL:REM  (CL:LAMBDA (CL:NUMBER DIVISOR)                             (* |kbr:| "17-Sep-86 15:03")                                                             (* |Returns| |second| |result| |of|                                                              TRUNCATE. *)         (CL:MULTIPLE-VALUE-BIND (TRU CL:REM)                (CL:TRUNCATE CL:NUMBER DIVISOR)                (DECLARE (IGNORE TRU))                CL:REM)))(CL:FFLOOR  (CL:LAMBDA (CL:NUMBER &OPTIONAL (DIVISOR 1))                    (* |Same| |as| CL:FLOOR\, |but| |returns| |first| |value| |as| \a |float.|          *)         (CL:MULTIPLE-VALUE-BIND (FLR CL:REM)                (CL:FLOOR CL:NUMBER DIVISOR)                (CL:VALUES (FLOAT FLR)                       CL:REM))))(CL:FCEILING  (CL:LAMBDA (CL:NUMBER &OPTIONAL (DIVISOR 1))                    (* |Same| |as| CEILING\, |but| |returns| |first| |value| |as| \a |float.|          *)         (CL:MULTIPLE-VALUE-BIND (CEI CL:REM)                (CL:CEILING CL:NUMBER DIVISOR)                (CL:VALUES (FLOAT CEI)                       CL:REM))))(CL:FTRUNCATE  (CL:LAMBDA (CL:NUMBER &OPTIONAL (DIVISOR 1))                    (* |Same| |as| TRUNCATE\, |but| |returns| |first| |value| |as| \a |float.|          *)         (CL:MULTIPLE-VALUE-BIND (TRU CL:REM)                (CL:TRUNCATE CL:NUMBER DIVISOR)                (CL:VALUES (FLOAT TRU)                       CL:REM))))(CL:FROUND  (CL:LAMBDA (CL:NUMBER &OPTIONAL (DIVISOR 1))                    (* |Same| |as| ROUND\, |but| |returns| |first| |value| |as| \a |float.|          *)         (CL:MULTIPLE-VALUE-BIND (ROU CL:REM)                (ROUND CL:NUMBER DIVISOR)                (CL:VALUES (FLOAT ROU)                       CL:REM)))))(* \; "Page 218 functions.")(DEFINEQ(CL:DECODE-FLOAT  (CL:LAMBDA (FLOAT)                                         (* |kbr:| "20-Aug-86 17:35")         (SETQ FLOAT (\\DTEST FLOAT 'FLOATP))         (COND            ((= FLOAT 0.0)             (CL:VALUES 0.0 0 1.0))            (T (CL:VALUES (|create| FLOATP                                 SIGNBIT _ 0                                 EXPONENT _ (SUB1 \\EXPONENT.BIAS)                                 HIFRACTION _ (|fetch| (FLOATP HIFRACTION) |of| FLOAT)                                 LOFRACTION _ (|fetch| (FLOATP LOFRACTION) |of| FLOAT))                      (IDIFFERENCE (|fetch| (FLOATP EXPONENT) |of| FLOAT)                             (SUB1 \\EXPONENT.BIAS))                      (COND                         ((EQ (|fetch| (FLOATP SIGNBIT) |of| FLOAT)                              0)                          1.0)                         (T -1.0)))))))(CL:SCALE-FLOAT  (LAMBDA (FLOAT INTEGER)                                    (* |kbr:| "20-Aug-86 17:40")                    (* \\MAKEFLOAT |knows| |how| |to| |handle| |underflow| |and| |overflow|           |possibilities.| *)    (SETQ FLOAT (\\DTEST FLOAT 'FLOATP))    (COND       ((= FLOAT 0.0)        0.0)       (T (\\MAKEFLOAT (|fetch| (FLOATP SIGNBIT) |of| FLOAT)                 (IPLUS (|fetch| (FLOATP EXPONENT) |of| FLOAT)                        INTEGER 8)                 (IPLUS \\HIDDENBIT (|fetch| (FLOATP HIFRACTION) |of| FLOAT))                 (|fetch| (FLOATP LOFRACTION) |of| FLOAT)                 T)))))(CL:FLOAT-RADIX  (CL:LAMBDA (FLOAT)                                         (* |kbr:| "17-Sep-86 15:04")         (DECLARE (IGNORE FLOAT))         2))(CL:FLOAT-SIGN  (CL:LAMBDA (FLOAT1 &OPTIONAL (FLOAT2 (FLOAT 1 FLOAT1)))    (* |Part| 12.5 |of| |the| |laser|                                                              |edition| *)         (CL:IF (EQ (MINUSP FLOAT1)                    (MINUSP FLOAT2))                FLOAT2                (- FLOAT2))))(CL:FLOAT-DIGITS  (CL:LAMBDA (FLOAT)                                         (* |kbr:| "16-Aug-86 19:35")         (CL:TYPECASE FLOAT (FLOAT 24)                (T (CL:ERROR "Float-digits: ~A not a float" FLOAT)))))(CL:FLOAT-PRECISION  (CL:LAMBDA (FLOAT)                                         (* |kbr:| "12-Jul-86 18:29")         (CL:IF (ZEROP FLOAT)                0                (CL:FLOAT-DIGITS FLOAT))))(CL:INTEGER-DECODE-FLOAT  (CL:LAMBDA (FLOAT)                                         (* |kbr:| "20-Aug-86 17:39")         (SETQ FLOAT (\\DTEST FLOAT 'FLOATP))         (COND            ((= FLOAT 0.0)             (CL:VALUES 0 0 1))            (T (CL:VALUES (IPLUS (LLSH (IPLUS 128 (|fetch| (FLOATP HIFRACTION) |of| FLOAT))                                       16)                                 (|fetch| (FLOATP LOFRACTION) |of| FLOAT))                      (IDIFFERENCE (|fetch| (FLOATP EXPONENT) |of| FLOAT)                             (IPLUS \\EXPONENT.BIAS 23))                      (COND                         ((EQ (|fetch| (FLOATP SIGNBIT) |of| FLOAT)                              0)                          1)                         (T -1))))))))(* \; "EXPT COMPLEX REALPART and IMAGPART are defined by CMLFLOAT.")(* |;;;| "LLARITH replacements.  Either you have to live with these replacements or you have to start fixing CLISP for loops, the history mechanism etc.  Larry tried taking these out and the things I had fixed by putting these replacements in started breaking again.  These replacements are supposed to be good for you in any case.")(* \; "Non ufns")(* |;;| "GREATERP and LESSP are made to work on ratios.  EQP, ABS, and MINUS is fixed to work on ratios and complexs.  *")(DEFINEQ(NEW-LESSP  (LAMBDA (X Y)                                              (* |kbr:| " 9-Jul-86 22:00")    (%> Y X)))(NEW-EQP  (LAMBDA (X Y)                                              (* |Pavel| "15-Aug-86 19:47")    (COND       ((EQ X Y))       ((AND (NUMBERP X)             (NUMBERP Y))        (%= X Y))       (T (\\EXTENDED.EQP X Y)))))(NEW-ABS  (LAMBDA (X)                                                (* |kbr:| " 9-Jul-86 22:17")    (CTYPECASE X (INTEGER (COND                             ((ILESSP X 0)                              (IDIFFERENCE 0 X))                             (T X)))           (CL:SINGLE-FLOAT (COND                               ((FLESSP X 0.0)                                (FDIFFERENCE 0.0 X))                               (T X)))           (RATIO (COND                     ((ILESSP (CL:NUMERATOR X)                             0)                      (%MAKE-RATIO (IDIFFERENCE 0 (CL:NUMERATOR X))                             (CL:DENOMINATOR X)))                     (T X)))           (COMPLEX (%COMPLEX-ABS X)))))(NEW-MINUS  (LAMBDA (N)                                                (* |kbr:| " 8-May-86 18:31")    (%- 0 N))))(DECLARE\: DONTEVAL@LOAD DOCOPY (MOVD '%> 'GREATERP)(MOVD 'NEW-LESSP 'LESSP)(MOVD 'NEW-EQP 'EQP)(MOVD 'NEW-ABS 'ABS)(MOVD 'NEW-MINUS 'MINUS))(* \; "New LLARITH UFNS")(* |;;| "INTEGER ARITH UFNS .UNBOX.  is made to understand RATIOs so integer arith ufns must be recompiled.  \\IQUOTREM has not changed, but \\IQUOTREM uses .UNBOX.  and NEW-SLOWIQUOTIENT and NEW-IREMAINDER use \\IQUOTREM.")(DECLARE\: EVAL@COMPILE DONTCOPY (DECLARE\: EVAL@COMPILE (PUTPROPS .CMLUNBOX. MACRO ((V HV LV FORM)                            (PROG NIL UBLP                                  (SELECTC (NTYPX V)                                         (\\FIXP (SETQ HV (|ffetch| (FIXP HINUM)                                                                 |of| V))                                                (SETQ LV (|ffetch| (FIXP LONUM)                                                                |of| V)))                                         (\\SMALLP (COND ((ILEQ 0 V)                                                          (SETQ HV 0)                                                          (SETQ LV V))                                                         (T (SETQ HV 65535)                                                            (SETQ LV (\\LOLOC V)))))                                         (\\FLOATP (SETQ V (\\FIXP.FROM.FLOATP V))                                                (GO UBLP))                                         (COND ((RATIO-P V)                                                (SETQ V (IQUOTIENT (RATIO-NUMERATOR V)                                                               (RATIO-DENOMINATOR V)))                                                (GO UBLP))                                               (T (CL:TYPECASE V                                                         (CL:NUMBER (COND ('FORM (* I\f |there| |is|                                                                                     \a FORM\, |then|                                                                                     |compiler| |will|                                                                                     |compile| |this|                                                                                     |branch| |of|                                                                                     |macro.| *)                                                                                 FORM)                                                                          (T (* I\f |there| |is| |no|                                                                                 FORM\, |then|                                                                                 |compiler| |will|                                                                                 |compile| |this|                                                                                 |branch| |of|                                                                                 |macro.| *)                                                                             (SETQ V                                                                                   (\\LISPERROR                                                                                    V "ARG NOT FIXP"                                                                                     T))                                                                             (GO UBLP))))                                                         (T (SETQ V (LISPERROR "NON-NUMERIC ARG" V T)                                                                  )                                                            (GO UBLP)))))))))(PUTPROPS .CMLIQUOTREM. MACRO ((X Y QUO CL:REM)                               (PROG (HX LX HY LY SIGNQUOTIENT SIGNREMAINDER (CNT 0)                                         (HZ 0)                                         (LZ 0))                                     (.CMLUNBOX. X HX LX (GO RETBIG))                                     (.CMLUNBOX. Y HY LY (GO RETBIG))                                     (COND ((IGREATERP HX MAX.POS.HINUM)                                            (.NEGATE. HX LX)                                            (SETQ SIGNQUOTIENT (SETQ SIGNREMAINDER T))))                                     (* |Remainder| |has| |sign| |of| |dividend|)                                     (COND ((IGREATERP HY MAX.POS.HINUM)                                            (.NEGATE. HY LY)                                            (SETQ SIGNQUOTIENT (NOT SIGNQUOTIENT))))                                     (COND ((NEQ HX 0)                                            (GO BIGDIVIDEND))                                           ((NEQ HY 0)                                            (* Y |is| |big,| X |is| |small,| |so| |result| |is| 0)                                            (GO DONE))                                           ((EQ 0 LX)                                            (GO RET0))                                           ((EQ 0 LY)                                            (GO DIVZERO))                                           ((EQ LY 1)                                            (SETQ LZ LX)                                            (SETQ LX 0)                                            (GO DONE)))                                     (* |here| |we| |are| |dividing| |small| X |by| |small| Y\, |and|                                         |we| |know| Y |gt| 1)                                     LP1                                     (* |shift| Y |left| |until| |it| |is| |as| |big| |as| X\, |and|                                         |count| |how| |many| |times|)                                     (COND ((AND (ILESSP LY LX)                                                 (ILEQ LY MAX.POS.HINUM))                                            (SETQ LY (LLSH LY 1))                                            (SETQ CNT (ADD1 CNT))                                            (GO LP1)))                                     LP2                                     (* |now| |start| |dividing| Y |into| X |by| |subtracting| |and|                                         |shifting,| |ending| |up| |with| Y |shifted| |back| |where|                                         |it| |started|)                                     (COND ((ILEQ LY LX)                                            (SETQ LX (IDIFFERENCE LX LY))                                            (* Y |divides| X |once,| |so| |add| |bit| |into|                                                |quotient|)                                            (SETQ LZ (ADD1 LZ))))                                     (SETQ LY (LRSH LY 1))                                     (SETQ CNT (SUB1 CNT))                                     (COND ((IGEQ CNT 0)                                            (SETQ LZ (LLSH LZ 1))                                            (GO LP2)))                                     (GO DONE)                                     BIGDIVIDEND                                     (* X |is| |big,| |so| |result| |may| |be| |big.| |Algorithm|                                         |is| |same| |as| |above,| |but| |everything| |is| |doubled|                                         |in| |length|)                                     (COND ((EQ 0 HY)                                            (COND ((EQ 0 (SETQ HY LY))                                                   (GO DIVZERO))                                                  ((AND SIGNREMAINDER (NULL SIGNQUOTIENT)                                                        (EQ 1 LY)                                                        (EQ HX \\SIGNBIT)                                                        (EQ 0 LX))                                                   (* |Means| |that| X |is| MIN.FIXP |and| Y |is| -1)                                                   (GO RETBIG)))                                            (SETQ LY 0)                                            (SETQ CNT 16))                                           ((AND SIGNREMAINDER (NULL SIGNQUOTIENT)                                                 (EQ 0 LX)                                                 (EQ HX \\SIGNBIT)                                                 (EQ 0 HY)                                                 (EQ 1 LY))                                            (* |Means| |that| X |is| MIN.FIXP |and| Y |is| -1)                                            (GO RETBIG)))                                     BIGLP                                     (COND ((AND (OR (AND (EQ HY HX)                                                          (ILESSP LY LX))                                                     (ILESSP HY HX))                                                 (ILESSP HY MAX.POS.HINUM))                                            (.LLSH1. HY LY)                                            (SETQ CNT (ADD1 CNT))                                            (GO BIGLP)))                                     BIGLP2                                     (COND ((OR (ILESSP HY HX)                                                (AND (EQ HY HX)                                                     (ILEQ LY LX)))                                            (* Y |divides| X\, |so| |subtract| Y |from| X |and| |put|                                                \a |bit| |in| |quotient|)                                            (SETQ HX (IDIFFERENCE (IDIFFERENCE HX HY)                                                            (.SUBSMALL. LX LY)))                                            (SETQ LZ (ADD1 LZ))                                            (* |note| |that| |this| |never| |overflows,| |because|                                                |of| |the| |preceding| |left| |shift|)))                                     (.LRSH1. HY LY)                                     (SETQ CNT (SUB1 CNT))                                     (COND ((IGEQ CNT 0)                                            (.LLSH1. HZ LZ)                                            (GO BIGLP2)))                                     DONE                                     (COND ('CL:REM (* |remainder| |is| |left| |in| X)                                                  (COND (SIGNREMAINDER (.NEGATE. HX LX)))                                                  (SETQ CL:REM (\\MAKENUMBER HX LX))))                                     (COND ('QUO (COND (SIGNQUOTIENT (.NEGATE. HZ LZ)))                                                 (SETQ QUO (\\MAKENUMBER HZ LZ))))                                     (RETURN)                                     DIVZERO                                     (SELECTQ \\OVERFLOW (T (ERROR "DIVIDE BY ZERO" Y))                                            (GO RET0))                                     RET0                                     (COND ('CL:REM (SETQ CL:REM 0)))                                     (COND ('QUO (SETQ QUO 0)))                                     (RETURN)                                     RETBIG                                     (|if| 'QUO |then| (SETQ QUO (\\BIGNUM.QUOTIENT X Y)))                                     (|if| 'CL:REM |then| (SETQ CL:REM (\\BIGNUM.REMAINDER X Y)))                                     (RETURN))))))(DEFINEQ(NEW-SLOWIPLUS2  (LAMBDA (X Y)                                              (* |lmm| "12-Apr-85 08:51")    (\\CALLME 'IPLUS)    (PROG (HX LX HY LY SIGNX)          (.CMLUNBOX. X HX LX (GO RETBIG))          (.CMLUNBOX. Y HY LY (GO RETBIG))          (SETQ SIGNX (IGREATERP HX MAX.POS.HINUM))          (SETQ HX (COND                      ((IGREATERP HX (IDIFFERENCE MAX.SMALL.INTEGER HY))                       (IDIFFERENCE HX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER HY))))                      (T (IPLUS HX HY))))                    (* |Add| |high| |parts|)          (SETQ LX (COND                      ((IGREATERP LX (IDIFFERENCE MAX.SMALL.INTEGER LY))                                                             (* |Carry| |into| |high| |part.|)                       (SETQ HX (COND                                   ((EQ HX MAX.SMALL.INTEGER)                                    0)                                   (T (ADD1 HX))))                       (IDIFFERENCE LX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER LY))))                      (T (IPLUS LX LY))))          (COND             ((AND (EQ SIGNX (IGREATERP HY MAX.POS.HINUM))                   (NOT (EQ SIGNX (IGREATERP HX MAX.POS.HINUM))))                    (* |overflow| |occurs| |if| X |and| Y |are| |same| |sign,| |but| |result| |is|           |opposite| |sign|)              (GO RETBIG)))          (RETURN (\\MAKENUMBER HX LX))      RETBIG          (RETURN (\\BIGNUM.PLUS X Y)))))(NEW-SLOWIDIFFERENCE  (LAMBDA (X Y)                                              (* |lmm| "12-Apr-85 07:37")    (\\CALLME 'IDIFFERENCE)    (PROG (HX LX HY LY SIGNX)          (.CMLUNBOX. X HX LX (GO RETBIG))          (.CMLUNBOX. Y HY LY (GO RETBIG))                    (* |Allow| |this| |unboxing| |before| |the| |following| |test| |so| |that|           |error| |checking| |will| |be| |performed| |on| Y)          (COND             ((EQ Y 0)              (RETURN (\\MAKENUMBER HX LX))))          (.NEGATE. HY LY)          (SETQ SIGNX (IGREATERP HX MAX.POS.HINUM))          (COND             ((COND                 ((AND (ZEROP LY)                       (EQ HY \\SIGNBIT))                    (* Y = -Y = |Min.integer.| |Overflow| |occurs| |if| X |is| |positive|)                  (SETQ HX (LOGXOR HX HY))                  (NOT SIGNX))                 (T (SETQ HX (COND                                ((IGREATERP HX (IDIFFERENCE MAX.SMALL.INTEGER HY))                                 (IDIFFERENCE HX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER HY))))                                (T (IPLUS HX HY))))          (* |Add| |high| |parts|)                    (SETQ LX (COND                                ((IGREATERP LX (IDIFFERENCE MAX.SMALL.INTEGER LY))                                                             (* |Carry| |into| |high| |part.|)                                 (SETQ HX (COND                                             ((EQ HX MAX.SMALL.INTEGER)                                              0)                                             (T (ADD1 HX))))                                 (IDIFFERENCE LX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER LY))))                                (T (IPLUS LX LY))))                    (* |overflow| |occurs| |if| X |and| Y |are| |same| |sign,| |but| |result| |is|           |opposite| |sign|)                    (AND (EQ SIGNX (IGREATERP HY MAX.POS.HINUM))                         (NOT (EQ SIGNX (IGREATERP HX MAX.POS.HINUM))))))              (GO RETBIG)))          (RETURN (\\MAKENUMBER HX LX))      RETBIG          (RETURN (\\BIGNUM.DIFFERENCE X Y)))))(NEW-SLOWITIMES2  (LAMBDA (X Y)                                              (* |lmm| "12-Apr-85 08:52")    (\\CALLME 'ITIMES)    (COND       ((OR (EQ X 0)            (EQ Y 0))        0)       (T (PROG (HX HY LX LY SIGN HR LR CARRY)                (SETQ HR 0)                (SETQ LR 0)                (.CMLUNBOX. X HX LX (GO RETBIG))                (.CMLUNBOX. Y HY LY (GO RETBIG))                (COND                   ((IGREATERP HX MAX.POS.HINUM)                    (COND                       ((EQUAL X MIN.FIXP)                        (GO RETBIG)))                    (.NEGATE. HX LX)                    (SETQ SIGN T)))                (COND                   ((IGREATERP HY MAX.POS.HINUM)                    (COND                       ((EQUAL Y MIN.FIXP)                        (GO RETBIG)))                    (.NEGATE. HY LY)                    (SETQ SIGN (NOT SIGN))))                (COND                   ((NOT (EQ HY 0))                    (COND                       ((NOT (EQ HX 0))                        (GO OVER)))                    (|swap| LX LY)                    (|swap| HX HY)))            MLP (COND                   ((ODDP (PROG1 LY (SETQ LY (LRSH LY 1))))                    (COND                       ((IGREATERP LR (IDIFFERENCE MAX.SMALL.INTEGER LX))                                                             (* |low| |parts| |overflow|)                    (* |make| |the| |low| |word| |be| |the| |less| |significant| |bits| |and|           |return| |the| |carry.|)                        (SETQ LR (IDIFFERENCE LR (IDIFFERENCE MAX.SMALL.INTEGER (SUB1 LX))))                        (SETQ CARRY 1))                       (T                                    (* |no| |carry| |just| |add| |the|                                                              |low| |halves.|)                          (SETQ LR (IPLUS LR LX))                          (SETQ CARRY 0)))                    (* |the| |low| |order| |part| |of| |the| |answer| |has| |been| |set| |and|           CARRY |is| |the| |numeric| |value| |of| |the| |carry| |from| |the| |low| |part|           |either| 0 |or| 1)                    (COND                       ((IGREATERP (SETQ HR (IPLUS HR HX CARRY))                               MAX.POS.HINUM)                        (COND                           ((AND (EQ LY 0)                                 SIGN                                 (EQ HR (ADD1 MAX.POS.HINUM))                                 (EQ LR 0))                            (RETURN MIN.FIXP)))                        (GO OVER)))))                (COND                   ((ZEROP LY)                    (GO RET)))                (COND                   ((IGEQ HX (LRSH (ADD1 MAX.POS.HINUM)                                   1))                    (GO OVERTEST)))                (.LLSH1. HX LX)                (GO MLP)            OVERTEST                (COND                   ((AND (EQ HX (LRSH (ADD1 MAX.POS.HINUM)                                      1))                         (ZEROP LX)                         SIGN                         (EQ LY 1)                         (EQ HR 0)                         (EQ LR 0))                          (* |odd| |special| |case|)                    (RETURN MIN.FIXP)))            OVER                (GO RETBIG)            RET (COND                   (SIGN (.NEGATE. HR LR)))                (RETURN (\\MAKENUMBER HR LR))            RETBIG                (RETURN (\\BIGNUM.TIMES X Y)))))))(NEW-SLOWIQUOTIENT  (LAMBDA (X Y)                                              (* |kbr:| " 5-Aug-86 15:45")    (\\CALLME 'IQUOTIENT)    (.CMLIQUOTREM. X Y X)    X))(NEW-IREMAINDER  (LAMBDA (X Y)                                              (* |kbr:| " 5-Aug-86 15:46")    (.CMLIQUOTREM. X Y NIL Y)    Y))(NEW-SLOWIGREATERP  (LAMBDA (X Y)                                              (* |lmm| "12-Apr-85 07:35")    (\\CALLME 'IGREATERP)    (PROG (HX LX HY LY)          (.CMLUNBOX. X HX LX (GO RETBIG))          (.CMLUNBOX. Y HY LY (GO RETBIG))          (RETURN (COND                     ((EQ HX HY)                      (IGREATERP LX LY))                     (T (IGREATERP (LOGXOR HX \\SIGNBIT)                               (LOGXOR HY \\SIGNBIT)))))      RETBIG          (RETURN (EQ 1 (\\BIGNUM.COMPARE X Y)))))))(DECLARE\: DONTEVAL@LOAD DOCOPY (\\SETUFNENTRY (CAR (\\FINDOP 'IPLUS2))       'NEW-SLOWIPLUS2 2 0)(\\SETUFNENTRY (CAR (\\FINDOP 'IDIFFERENCE))       'NEW-SLOWIDIFFERENCE 2 0)(\\SETUFNENTRY (CAR (\\FINDOP 'ITIMES2))       'NEW-SLOWITIMES2 2 0)(\\SETUFNENTRY (CAR (\\FINDOP 'IQUOTIENT))       'NEW-SLOWIQUOTIENT 2 0)(\\LOCKFN 'NEW-SLOWIQUOTIENT)(* \; "because original is locked")(\\SETUFNENTRY (CAR (\\FINDOP 'IREMAINDER))       'NEW-IREMAINDER 2 0)(\\SETUFNENTRY (CAR (\\FINDOP 'IGREATERP))       'NEW-SLOWIGREATERP 2 0))(* \; "New general arithmetic UFNs which know about ratio and complex")(* |;;| "NOTE: %/ CAN NOT COMPILE INTO THE EXISTING QUOTIENT OPCODE.  This is because %/ is supposed to produce a rational when numerator is not evenly divisible by denominator.  Therefore, there is no MACRO for %/ below.")(PUTPROPS %+ DOPVAL (2 PLUS2))(PUTPROPS %- DOPVAL (2 DIFFERENCE))(PUTPROPS %* DOPVAL (2 TIMES2))(PUTPROPS %> DOPVAL (2 GREATERP))(DEFINEQ(%+  (LAMBDA (N1 N2)                                            (* |kbr:| "12-Jul-86 18:32")    (\\CALLME '+)                    (* UFN |for| + |Microcode| |generally| |handles| |the| |case| |of| |two| |args|           |both| FIXP\s)    (CTYPECASE N1 (INTEGER (CTYPECASE N2 (INTEGER (IPLUS N1 N2))                                  (FLOAT (FPLUS N1 N2))                                  (RATIO (%RATIO-INTEGER+ N2 N1))                                  (COMPLEX (%COMPLEX+ (%MAKE-COMPLEX N1 0)                                                  N2))))           (FLOAT (CTYPECASE N2 ((OR INTEGER FLOAT)                                 (FPLUS N1 N2))                         (RATIO (FPLUS N1 (FQUOTIENT (CL:NUMERATOR N2)                                                 (CL:DENOMINATOR N2))))                         (COMPLEX (%COMPLEX+ (%MAKE-COMPLEX N1 0.0)                                         N2))))           (RATIO (CTYPECASE N2 (INTEGER (%RATIO-INTEGER+ N1 N2))                         (FLOAT (FPLUS (FQUOTIENT (CL:NUMERATOR N1)                                              (CL:DENOMINATOR N1))                                       N2))                         (RATIO (%RATIO+ N1 N2))                         (COMPLEX (%COMPLEX+ (%MAKE-COMPLEX N1 0)                                         N2))))           (COMPLEX (CTYPECASE N2 (INTEGER (%COMPLEX+ N1 (%MAKE-COMPLEX N2 0)))                           (FLOAT (%COMPLEX+ N1 (%MAKE-COMPLEX N2 0.0)))                           (RATIO (%COMPLEX+ N1 (%MAKE-COMPLEX N2 0)))                           (COMPLEX (%COMPLEX+ N1 N2)))))))(%-  (LAMBDA (N1 N2)                                            (* |kbr:| "12-Jul-86 18:32")    (\\CALLME '-)                    (* UFN |for| -          |Microcode| |generally| |handles| |the| |case| |of| |two| |args| |both| FIXP\s)    (CTYPECASE N1 (INTEGER (CTYPECASE N2 (INTEGER (IDIFFERENCE N1 N2))                                  (FLOAT (FDIFFERENCE N1 N2))                                  (RATIO (%RATIO- (%MAKE-RATIO N1 1)                                                N2))                                  (COMPLEX (%COMPLEX- (%MAKE-COMPLEX N1 0)                                                  N2))))           (FLOAT (CTYPECASE N2 ((OR INTEGER FLOAT)                                 (FDIFFERENCE N1 N2))                         (RATIO (FDIFFERENCE N1 (FQUOTIENT (CL:NUMERATOR N2)                                                       (CL:DENOMINATOR N2))))                         (COMPLEX (%COMPLEX- (%MAKE-COMPLEX N1 0.0)                                         N2))))           (RATIO (CTYPECASE N2 (INTEGER (%RATIO-INTEGER- N1 N2))                         (FLOAT (FDIFFERENCE (FQUOTIENT (CL:NUMERATOR N1)                                                    (CL:DENOMINATOR N1))                                       N2))                         (RATIO (%RATIO- N1 N2))                         (COMPLEX (%COMPLEX- (%MAKE-COMPLEX N1 0)                                         N2))))           (COMPLEX (CTYPECASE N2 (INTEGER (%COMPLEX- N1 (%MAKE-COMPLEX N2 0)))                           (FLOAT (%COMPLEX- N1 (%MAKE-COMPLEX N2 0.0)))                           (RATIO (%COMPLEX- N1 (%MAKE-COMPLEX N2 0)))                           (COMPLEX (%COMPLEX- N1 N2)))))))(%*  (LAMBDA (N1 N2)                                            (* |lmm| "19-Jun-86 15:42")    (\\CALLME 'CL:*)                    (* UFN |for| CL:* |Microcode| |generally| |handles| |the| |case| |of| |two|           |args| |both| FIXP\s)    (CTYPECASE N2 (INTEGER (CTYPECASE N1 (INTEGER (ITIMES N1 N2))                                  (FLOAT (FTIMES N1 N2))                                  (RATIO (%RATIO-INTEGER* N1 N2))                                  (COMPLEX (%COMPLEX* N1 (%MAKE-COMPLEX N2 0)))))           (FLOAT (CTYPECASE N1 ((OR INTEGER FLOAT)                                 (FTIMES N1 N2))                         (RATIO (FTIMES (FQUOTIENT (CL:NUMERATOR N1)                                               (CL:DENOMINATOR N1))                                       N2))                         (COMPLEX (%COMPLEX* N1 (%MAKE-COMPLEX N2 0.0)))))           (RATIO (CTYPECASE N1 (INTEGER (%RATIO-INTEGER* N2 N1))                         (FLOAT (FTIMES N1 (FQUOTIENT (CL:NUMERATOR N2)                                                  (CL:DENOMINATOR N2))))                         (RATIO (%RATIO* N2 N1))                         (COMPLEX (%COMPLEX* N1 (%MAKE-COMPLEX N2 0)))))           (COMPLEX (CTYPECASE N1 ((OR INTEGER RATIO)                                   (%COMPLEX* (%MAKE-COMPLEX N1 0)                                          N2))                           (FLOAT (%COMPLEX* (%MAKE-COMPLEX N1 0.0)                                         N2))                           (COMPLEX (%COMPLEX* N1 N2)))))))(%/  (LAMBDA (N1 N2)                                            (* |kbr:| "11-Sep-86 16:41")    (\\CALLME '/)                    (* UFN |for| / |Microcode| |generally| |handles| |the| |case| |of| |two| |args|           |both| FIXP\s)    (CTYPECASE N1 (INTEGER (CTYPECASE N2 (INTEGER (COND                                                     ((OR (EQ N1 MIN.INTEGER)                                                          (EQ N1 MAX.INTEGER)                                                          (EQ N2 MIN.INTEGER)                                                          (EQ N2 MAX.INTEGER)                                                          (EVENP N1 N2))                                                      (IQUOTIENT N1 N2))                                                     (T (%BUILD-RATIO N1 N2))))                                  (FLOAT (FQUOTIENT N1 N2))                                  (RATIO (%/ (CL:* (CL:DENOMINATOR N2)                                                   N1)                                             (CL:NUMERATOR N2)))                                  (COMPLEX (%COMPLEX/ (%MAKE-COMPLEX N1 0)                                                  N2))))           (FLOAT (CTYPECASE N2 ((OR INTEGER FLOAT)                                 (FQUOTIENT N1 N2))                         (RATIO (%/ (CL:* (CL:DENOMINATOR N2)                                          N1)                                    (CL:NUMERATOR N2)))                         (COMPLEX (%COMPLEX/ (%MAKE-COMPLEX N1 0.0)                                         N2))))           (RATIO (CTYPECASE N2 (INTEGER (%BUILD-RATIO (CL:NUMERATOR N1)                                                (CL:* (CL:DENOMINATOR N1)                                                      N2)))                         (FLOAT (FQUOTIENT N1 N2))                         (RATIO (%RATIO/ N1 N2))                         (COMPLEX (%COMPLEX/ (%MAKE-COMPLEX N1 0)                                         N2))))           (COMPLEX (CTYPECASE N2 (INTEGER (%COMPLEX/ N1 (%MAKE-COMPLEX N2 0)))                           (FLOAT (%COMPLEX/ N1 (%MAKE-COMPLEX N2 0.0)))                           (RATIO (%/ (CL:* (CL:DENOMINATOR N2)                                            N1)                                      (CL:NUMERATOR N2)))                           (COMPLEX (%COMPLEX/ N1 N2))))))))(DECLARE\: DONTEVAL@LOAD DOCOPY (\\SETUFNENTRY (CAR (\\FINDOP 'PLUS2))       '%+ 2 0)(\\SETUFNENTRY (CAR (\\FINDOP 'DIFFERENCE))       '%- 2 0)(\\SETUFNENTRY (CAR (\\FINDOP 'TIMES2))       '%* 2 0)(\\SETUFNENTRY (CAR (\\FINDOP 'GREATERP))       '%> 2 0))(* \; "Section 12.7 Logical Operations on Numbers.")(* \; "Page 221 functions.  LOGAND LOGXOR are OK.")(DEFINEQ(CL:LOGIOR  (LAMBDA N                                                  (* |lmm| "19-Jun-86 16:22")                    (* |called| |only| |by| |interpreted| |code| -          |this| |defn| |relies| |on| |fact| |that| |compiler| |turns| LOGOR |calls|           |into| |sequences| |of| |opcodes|)    (SELECTQ N        (2 (LOGOR (ARG N 1)                  (ARG N 2)))        (1 (LOGOR (ARG N 1)))        (0 (LOGOR))        (PROG ((R (LOGOR (ARG N 1)                         (ARG N 2)                         (ARG N 3)))               (J 4))          LP  (COND                 ((ILEQ J N)                  (SETQ R (LOGOR R (ARG N J)))                  (SETQ J (ADD1 J))                  (GO LP)))              (RETURN R)))))(CL:LOGEQV  (CL:LAMBDA (&REST INTEGERS)                                (* |lmm| " 5-Sep-85 02:19")         (COND            (INTEGERS (CL:DO* ((RESULT (|pop| INTEGERS)                                      (CL:LOGNOT (LOGXOR RESULT (|pop| INTEGERS)))))                             ((NULL INTEGERS)                              RESULT)))            (T -1))))(CL:LOGNAND  (CL:LAMBDA (INTEGER1 INTEGER2)                             (* |kbr:| "31-Aug-85 21:00")         (CL:LOGNOT (LOGAND INTEGER1 INTEGER2))))(CL:LOGNOR  (CL:LAMBDA (INTEGER1 INTEGER2)                             (* |kbr:| "31-Aug-85 21:00")         (CL:LOGNOT (LOGOR INTEGER1 INTEGER2))))(CL:LOGANDC1  (CL:LAMBDA (INTEGER1 INTEGER2)                             (* |kbr:| "31-Aug-85 21:00")         (LOGAND (CL:LOGNOT INTEGER1)                INTEGER2)))(CL:LOGANDC2  (CL:LAMBDA (INTEGER1 INTEGER2)                             (* |kbr:| "31-Aug-85 21:01")         (LOGAND INTEGER1 (CL:LOGNOT INTEGER2))))(CL:LOGORC1  (CL:LAMBDA (INTEGER1 INTEGER2)                             (* |kbr:| "31-Aug-85 21:01")         (LOGOR (CL:LOGNOT INTEGER1)                INTEGER2)))(CL:LOGORC2  (CL:LAMBDA (INTEGER1 INTEGER2)                             (* |kbr:| "31-Aug-85 21:01")         (LOGOR INTEGER1 (CL:LOGNOT INTEGER2)))))(* \; "Page 222. BOOLE and constants.")(DEFINEQ(CL:BOOLE  (CL:LAMBDA (OP INTEGER1 INTEGER2)                          (* |lmm| " 5-Sep-85 02:24")         (SELECTQ OP             (0 0)             (1 -1)             (2 INTEGER1)             (3 INTEGER2)             (4 (CL:LOGNOT INTEGER1))             (5 (CL:LOGNOT INTEGER2))             (6 (LOGAND INTEGER1 INTEGER2))             (7 (CL:LOGIOR INTEGER1 INTEGER2))             (8 (LOGXOR INTEGER1 INTEGER2))             (9 (CL:LOGEQV INTEGER1 INTEGER2))             (10 (CL:LOGNAND INTEGER1 INTEGER2))             (11 (CL:LOGNOR INTEGER1 INTEGER2))             (12 (CL:LOGANDC1 INTEGER1 INTEGER2))             (13 (CL:LOGANDC2 INTEGER1 INTEGER2))             (14 (CL:LOGORC1 INTEGER1 INTEGER2))             (15 (CL:LOGORC2 INTEGER1 INTEGER2))             (CL:ERROR "~S is not of type (mod 16)." OP)))))(RPAQ? CL:BOOLE-CLR 0)(RPAQ? CL:BOOLE-SET 1)(RPAQ? CL:BOOLE-1 2)(RPAQ? CL:BOOLE-2 3)(RPAQ? CL:BOOLE-C1 4)(RPAQ? CL:BOOLE-C2 5)(RPAQ? CL:BOOLE-AND 6)(RPAQ? CL:BOOLE-IOR 7)(RPAQ? CL:BOOLE-XOR 8)(RPAQ? CL:BOOLE-EQV 9)(RPAQ? CL:BOOLE-NAND 10)(RPAQ? CL:BOOLE-NOR 11)(RPAQ? CL:BOOLE-ANDC1 12)(RPAQ? CL:BOOLE-ANDC2 13)(RPAQ? CL:BOOLE-ORC1 14)(RPAQ? CL:BOOLE-ORC2 15)(* \; "Remainder of section 12.7 LOGNOT is OK.")(DEFINEQ(CL:LOGTEST  (CL:LAMBDA (INTEGER1 INTEGER2)                             (* |kbr:| "31-Aug-85 21:10")         (NOT (EQ (LOGAND INTEGER1 INTEGER2)                  0))))(CL:LOGBITP  (CL:LAMBDA (INDEX INTEGER)                                 (* |kbr:| "31-Aug-85 21:12")         (EQ (LOADBYTE INTEGER INDEX 1)             1))))(DEFINEQ(CL:ASH  (LAMBDA (INTEGER COUNT)                                    (* |kbr:| "12-Jul-86 18:05")    (COND       ((ILEQ COUNT 0)        (COND           ((EQ COUNT 0)            INTEGER)           (T (RSH INTEGER (IMINUS COUNT)))))       ((EQ INTEGER 0)        0)       ((IGREATERP COUNT (CONSTANT (INTEGERLENGTH MAX.FIXP)))        (\\BIGNUM.LSH INTEGER COUNT))       (T (FRPTQ COUNT (SETQ INTEGER (IPLUS INTEGER INTEGER)))          INTEGER)))))(DEFINEQ(CL:LOGCOUNT  (CL:LAMBDA (INTEGER)                                       (* |kbr:| "12-Jul-86 18:05")                    (* |Logcount| |returns| |the| |number| |of| |bits| |that| |are| |the|           |complement| |of| |the| |sign| |in| |the| |integer| |argument| \x.          *)                    (* I\f INTEGER |is| |negative,| |then| |the| |number| |of| 0 |bits| |is|           |returned,| |otherwise| |number| |of| 1 |bits| |is| |returned.|          *)         (COND            ((OR (SMALLP INTEGER)                 (FIXP INTEGER))             (%LOGCOUNT (CL:IF (MINUSP INTEGER)                               (CL:LOGNOT INTEGER)                               INTEGER)))            ((|type?| BIGNUM INTEGER)             (|for| ELEMENT |in| (|fetch| (BIGNUM ELEMENTS) |of| (CL:IF (MINUSP INTEGER)                                                                        (CL:LOGNOT INTEGER)                                                                        INTEGER))                |sum| (%LOGCOUNT ELEMENT)))            (T (CL:ERROR "Argument not integer, ~A." INTEGER)))))(%LOGCOUNT  (LAMBDA (N)                                                (* |kbr:| " 7-Apr-86 21:50")                    (* |Returns| |number| |of| 1 |bits| |in| |nonnegative| |integer| N.          *)    (PROG (CNT)          (SETQ CNT 0)                    (* |This| |loop| |uses| \a LOGAND |trick| |for| |extra| |speed.|          *)          (|while| (NOT (EQ N 0)) |do|                     (* |Change| |rightmost| 1 |bit| |of| N |to| \a 0 |bit.|          *)                                       (SETQ N (LOGAND N (CL:1- N)))                                       (SETQ CNT (CL:1+ CNT)))          (RETURN CNT)))))(DEFINEQ(CL:INTEGER-LENGTH  (LAMBDA (INTEGER)                                          (* |kbr:| "12-Jul-86 18:05")    (COND       ((< INTEGER 0)        (SETQ INTEGER (- -1 INTEGER))))    (CL:MACROLET ((NBITS.OR.LESS (INTEGER N)                         `(< ,INTEGER ,(CL:ASH 1 N))))           (COND              ((NBITS.OR.LESS INTEGER 16)               (COND                  ((NBITS.OR.LESS INTEGER 8)                   (COND                      ((NBITS.OR.LESS INTEGER 4)                       (COND                          ((NBITS.OR.LESS INTEGER 2)                           (COND                              ((NBITS.OR.LESS INTEGER 1)                               (COND                                  ((EQ INTEGER 0)                                   0)                                  (T 1)))                              (T 2)))                          ((NBITS.OR.LESS INTEGER 3)                           3)                          (T 4)))                      ((NBITS.OR.LESS INTEGER 6)                       (COND                          ((NBITS.OR.LESS INTEGER 5)                           5)                          (T 6)))                      ((NBITS.OR.LESS INTEGER 7)                       7)                      (T 8)))                  ((NBITS.OR.LESS INTEGER 12)                   (COND                      ((NBITS.OR.LESS INTEGER 10)                       (COND                          ((NBITS.OR.LESS INTEGER 9)                           9)                          (T 10)))                      ((NBITS.OR.LESS INTEGER 11)                       11)                      (T 12)))                  ((NBITS.OR.LESS INTEGER 14)                   (COND                      ((NBITS.OR.LESS INTEGER 13)                       13)                      (T 14)))                  ((NBITS.OR.LESS INTEGER 15)                   15)                  (T 16)))              (T (+ 16 (CL:INTEGER-LENGTH (CL:ASH INTEGER -16)))))))))(* \; "Section 12.8 Byte Manipulations Functions.")(* \; "BYTE macro already implemented.  Should be function.")(DEFINEQ(BYTE-SIZE  (CL:LAMBDA (BYTESPEC)                                      (* |kbr:| "31-Aug-85 21:15")         (|fetch| (BYTESPEC BYTESPEC.SIZE) |of| BYTESPEC)))(CL:BYTE-POSITION  (CL:LAMBDA (BYTESPEC)                                      (* |lmm| "16-Sep-85 13:28")         (|fetch| (BYTESPEC BYTESPEC.POSITION) |of| BYTESPEC))))(* \; "LDB macro already implemented.  Should be function.")(DEFINEQ(CL:LDB-TEST  (CL:LAMBDA (BYTESPEC INTEGER)                              (* |kbr:| "31-Aug-85 21:21")         (NOT (EQ (CL:MASK-FIELD BYTESPEC INTEGER)                  0))))(CL:MASK-FIELD  (CL:LAMBDA (BYTESPEC INTEGER)                              (* |kbr:| "31-Aug-85 21:21")         (LOGAND (MASK.1\'S (|fetch| (BYTESPEC BYTESPEC.POSITION) |of| BYTESPEC)                        (|fetch| (BYTESPEC BYTESPEC.SIZE) |of| BYTESPEC))                INTEGER))))(* \; "DPB macro already implemented.  Should be function.")(DEFINEQ(CL:DEPOSIT-FIELD  (CL:LAMBDA (NEWBYTE BYTESPEC INTEGER)                      (* |kbr:| "14-Aug-86 13:13")         (LOGOR (CL:LOGANDC2 INTEGER (MASK.1\'S (|fetch| (BYTESPEC BYTESPEC.POSITION) |of| BYTESPEC)                                            (|fetch| (BYTESPEC BYTESPEC.SIZE) |of| BYTESPEC)))                (LSH NEWBYTE (|fetch| (BYTESPEC BYTESPEC.POSITION) |of| BYTESPEC))))))(DECLARE\: EVAL@COMPILE DONTCOPY (FILESLOAD (LOADCOMP)       LLFLOAT LLCODE LLBIGNUM))(PUTPROPS CMLARITH FILETYPE CL:COMPILE-FILE)(DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA           CL:DEPOSIT-FIELD CL:MASK-FIELD CL:LDB-TEST CL:BYTE-POSITION BYTE-SIZE CL:LOGCOUNT                 CL:LOGBITP CL:LOGTEST CL:BOOLE CL:LOGORC2 CL:LOGORC1 CL:LOGANDC2 CL:LOGANDC1                 CL:LOGNOR CL:LOGNAND CL:LOGEQV CL:LOGIOR CL:INTEGER-DECODE-FLOAT CL:FLOAT-PRECISION                 CL:FLOAT-DIGITS CL:FLOAT-SIGN CL:FLOAT-RADIX CL:DECODE-FLOAT CL:FROUND CL:FTRUNCATE                 CL:FCEILING CL:FFLOOR CL:REM CL:MOD ROUND CL:CEILING CL:TRUNCATE CL:FLOOR FLOAT                 CL:LCM %GCD CL:GCD / CL:* - + >= <= > < CL:/= = CL:PLUSP ODDP EVENP CL:ZEROP                 %COMPLEX-PRINT %COMPLEX-TIMESI %COMPLEX-MINUS %COMPLEX-ABS %COMPLEX/ %COMPLEX*                 %COMPLEX- %COMPLEX+ CL:IMAGPART CL:REALPART COMPLEX %RATIO-INTEGER- %RATIO-INTEGER+                 %RATIO-INTEGER* %RATIO-PLUS-DIFFERENCE %RATIO- %RATIO+ %RATIO-TIMES-QUOTIENT %RATIO/                 %RATIO* %BUILD-RATIO CL:RATIONALIZE CL:RATIONAL CL:DENOMINATOR CL:NUMERATOR %SIGNUM                 CL:SIGNUM CL:PHASE PRIMEP CL:ISQRT))(PUTPROPS CMLARITH COPYRIGHT ("Xerox Corporation" 1985 1986))(DECLARE\: DONTCOPY  (FILEMAP (NIL (11420 15522 (CL:ISQRT 11430 . 13026) (PRIMEP 13028 . 13867) (CL:PHASE 13869 . 14544) (CL:SIGNUM 14546 . 15201) (%SIGNUM 15203 . 15520)) (16003 31561 (CL:NUMERATOR 16013 . 16429) (CL:DENOMINATOR 16431 . 16845) (CL:RATIONALP 16847 . 17024) (CL:RATIONAL 17026 . 18282) (CL:RATIONALIZE 18284 . 18993) (%RATIO-PRINT 18995 . 20535) (%BUILD-RATIO 20537 . 21439) (%RATIONALIZE-FLOAT 21441 . 26096) (%RATIO* 26098 . 26623) (%RATIO/ 26625 . 27141) (%RATIO-TIMES-QUOTIENT 27143 . 27843) (%RATIO+ 27845 . 28105) (%RATIO- 28107 . 28184) (%RATIO-PLUS-DIFFERENCE 28186 . 29420) (%RATIO-INTEGER* 29422 . 30444) (%RATIO-INTEGER+ 30446 . 30998) (%RATIO-INTEGER- 31000 . 31559)) (32092 37594 (COMPLEX 32102 . 33615) (CL:REALPART 33617 . 33847) (CL:IMAGPART 33849 . 34103) (%COMPLEX+ 34105 . 34378) (%COMPLEX- 34380 . 34656) (%COMPLEX* 34658 . 35119) (%COMPLEX/ 35121 . 35880) (%COMPLEX-ABS 35882 . 36168) (%COMPLEX-MINUS 36170 . 36384) (%COMPLEX-TIMESI 36386 . 36799) (CL:CONJUGATE 36801 . 37119) (%COMPLEX-PRINT 37121 . 37592)) (37733 37885 (NEW-MINUSP 37743 . 37883)) (37948 38102 (CL:ZEROP 37958 . 38100)) (38103 38579 (EVENP 38113 . 38270) (ODDP 38272 . 38434) (CL:PLUSP 38436 . 38577)) (38634 42360 (%= 38644 . 40897) (%> 40899 . 42358)) (42361 46775 (= 42371 . 42556) (%= 42558 . 44811) (CL:/= 44813 . 45122) (< 45124 . 45548) (> 45550 . 45952) (<= 45954 . 46349) (>= 46351 . 46773)) (49758 54601 (+ 49768 . 50324) (- 50326 . 50827) (CL:* 50829 . 51264) (/ 51266 . 51765) (%/ 51767 . 54327) (CL:1+ 54329 . 54463) (CL:1- 54465 . 54599)) (56336 60978 (CL:GCD 56346 . 57877) (%GCD 57879 . 59448) (CL:LCM 59450 . 60976)) (61166 63257 (FLOAT 61176 . 61423) (\\FLOAT 61425 . 63255)) (63337 71605 (CL:FLOOR 63347 . 64387) (CL:TRUNCATE 64389 . 66568) (CL:CEILING 66570 . 67599) (ROUND 67601 . 69192) (CL:MOD 69194 . 69730) (CL:REM 69732 . 70188) (CL:FFLOOR 70190 . 70541) (CL:FCEILING 70543 . 70897) (CL:FTRUNCATE 70899 . 71256) (CL:FROUND 71258 . 71603)) (71643 75086 (CL:DECODE-FLOAT 71653 . 72596) (CL:SCALE-FLOAT 72598 . 73293) (CL:FLOAT-RADIX 73295 . 73467) (CL:FLOAT-SIGN 73469 . 73799) (CL:FLOAT-DIGITS 73801 . 74037) (CL:FLOAT-PRECISION 74039 . 74259) (CL:INTEGER-DECODE-FLOAT 74261 . 75084)) (75667 76949 (NEW-LESSP 75677 . 75808) (NEW-EQP 75810 . 76057) (NEW-ABS 76059 . 76814) (NEW-MINUS 76816 . 76947)) (88496 96644 (NEW-SLOWIPLUS2 88506 . 89998) (NEW-SLOWIDIFFERENCE 90000 . 92179) (NEW-SLOWITIMES2 92181 . 95769) (NEW-SLOWIQUOTIENT 95771 . 95951) (NEW-IREMAINDER 95953 . 96108) (NEW-SLOWIGREATERP 96110 . 96642)) (97649 105421 (%+ 97659 . 99380) (%- 99382 . 101200) (%* 101202 . 102857) (%/ 102859 . 105419)) (105807 107988 (CL:LOGIOR 105817 . 106581) (CL:LOGEQV 106583 . 106966) (CL:LOGNAND 106968 . 107131) (CL:LOGNOR 107133 . 107294) (CL:LOGANDC1 107296 . 107476) (CL:LOGANDC2 107478 . 107642) (CL:LOGORC1 107644 . 107822) (CL:LOGORC2 107824 . 107986)) (108037 108916 (CL:BOOLE 108047 . 108914)) (109429 109796 (CL:LOGTEST 109439 . 109621) (CL:LOGBITP 109623 . 109794)) (109797 110276 (CL:ASH 109807 . 110274)) (110277 112143 (CL:LOGCOUNT 110287 . 111456) (%LOGCOUNT 111458 . 112141)) (112144 114190 (CL:INTEGER-LENGTH 112154 . 114188)) (114321 114705 (BYTE-SIZE 114331 . 114511) (CL:BYTE-POSITION 114513 . 114703)) (114775 115296 (CL:LDB-TEST 114785 . 114978) (CL:MASK-FIELD 114980 . 115294)) (115366 115807 (CL:DEPOSIT-FIELD 115376 . 115805)))))STOP