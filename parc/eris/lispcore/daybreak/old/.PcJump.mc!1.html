<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>daybreak>old>PcJump.mc!1</title>
  </head>
  <body>
    <pre>
{file:  PcJump.mclast edit   21-Feb-84 17:51:1011-Jun-85 15:54:02 don	modified for new PC Cross startegy --  {Pc} marks changes13-Jun-85 20:33:07 purcell	newIFU fixes marked by {&amp;}}	SetTask[0];{*************************	JUMP	1%  2 clicks**************************}@JUMP:	opcode[200'b],	MAR &larr; PC &larr; [rhPC, PC+1], GOTO[JnPos],	c1;	MAR &larr; PC &larr; [rhPC, PC+1+PC16], GOTO[JnPos],	c1,opcode[201'b];	MAR &larr; PC &larr; [rhPC, PC+2], GOTO[JnPos],	c1,opcode[202'b];	MAR &larr; PC &larr; [rhPC, PC+2+PC16], GOTO[JnPos],	c1,opcode[203'b];	MAR &larr; PC &larr; [rhPC, PC+3], GOTO[JnPos],	c1,opcode[204'b];	MAR &larr; PC &larr; [rhPC, PC+3+PC16], GOTO[JnPos],	c1,opcode[205'b];	MAR &larr; PC &larr; [rhPC, PC+4], GOTO[JnPos],	c1,opcode[206'b];	MAR &larr; PC &larr; [rhPC, PC+4+PC16], GOTO[JnPos],	c1,opcode[207'b];	MAR &larr; PC &larr; [rhPC, PC+5], GOTO[JnPos],	c1,opcode[210'b];{88}	MAR &larr; PC &larr; [rhPC, PC+5+PC16], GOTO[JnPos],	c1,opcode[211'b];	MAR &larr; PC &larr; [rhPC, PC+6], GOTO[JnPos],	c1,opcode[212'b];	MAR &larr; PC &larr; [rhPC, PC+6+PC16], GOTO[JnPos],	c1,opcode[213'b];	MAR &larr; PC &larr; [rhPC, PC+7], GOTO[JnPos],	c1,opcode[214'b];	MAR &larr; PC &larr; [rhPC, PC+7+PC16], GOTO[JnPos],	c1,opcode[215'b];	MAR &larr; PC &larr; [rhPC, PC+8], GOTO[JnPos],	c1,opcode[216'b];	MAR &larr; PC &larr; [rhPC, PC+8+PC16], GOTO[JnPos],	c1,opcode[217'b];JnPos:	Xbus &larr; 0, XC2npcDisp, BRANCH[$, JnCross, 1],	c2;	IB &larr; MD, BRANCH[ptr1, ptr0, 02],	c3;{Pc}{JnCross:	Q &larr; 0FF + 1, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3;}JnCross:	IB &larr; MD, CANCELBR[$, 03],	c3;	Xbus &larr; uPCCrossL, XRefBr,	c1;	Xbus &larr; 0, XC2npcDisp, BRANCH[NewCross, OldCross],	c2;NewCross:	Q &larr; 0FF + 1, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 03],	c3;OldCross:	uPCCrossL &larr; 0, BRANCH[ptr1, ptr0, 02],	c3;{Pc}@JUMPX:	opcode[260'b],	S &larr; S + 1, Xbus &larr; ibNA, XLDisp, L2 &larr; L2.ok,	c1;	Rx &larr; ib RShift1, XLDisp, SE &larr; 0, BRANCH[jxp, jxn, 1],	c2;jxp:	BRANCH[jpe, jpo, 2],	c3;{Pc}{jxn:	Rx &larr; 7F - Rx, BRANCH[jne, jno, 2],	c3;}jxn:	Rx &larr; 7F - Rx, BRANCH[jnePc, jnoPc, 2],	c3;{Pc}{*************************	FJUMP, TJUMP	4%  4 clicks**************************}@FJUMP:	opcode[220'b],	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0,	c1;	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 1,	c1, opcode[221'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 2,	c1, opcode[222'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 3,	c1, opcode[223'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 4,	c1, opcode[224'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 5,	c1, opcode[225'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 6,	c1, opcode[226'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 7,	c1, opcode[227'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 8,	c1, opcode[230'b];{98}	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 9,	c1, opcode[231'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0A,	c1, opcode[232'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0B,	c1, opcode[233'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0C,	c1, opcode[234'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0D,	c1, opcode[235'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0E,	c1, opcode[236'b];	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;	MAR &larr; [rhS, S], S &larr; S -1, L2 &larr; 0F,	c1, opcode[237'b];fj:	 Ybus &larr; TOSH or TOS, NZeroBr, CANCELBR[jmp, 2],	c2;@TJUMP:	opcode[240'b],	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1;	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[241'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[242'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[243'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[244'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[245'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[246'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[247'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[250'b];{A8}	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[251'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[252'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[253'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[254'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[255'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[256'b];	MAR &larr; [rhS, S], S &larr; S -1, GOTO[tj],	c1, opcode[257'b];tj:	Ybus &larr; TOSH or TOS, ZeroBr, CANCELBR[jmp, 2],	c2;jmp:	TOS &larr; MD, BRANCH[$, NoJump], L2Disp,	c3;	MAR &larr; [rhS, S + 0], DISP4[TgetsL,1],	c1;TgetsL:	Rx &larr; 1, L2Disp, GOTO[jjoin],	c2, at[1, 10, TgetsL];	Rx &larr; 2, L2Disp, GOTO[jjoin],	c2, at[3, 10, TgetsL];	Rx &larr; 3, L2Disp, GOTO[jjoin],	c2, at[5, 10, TgetsL];	Rx &larr; 4, L2Disp, GOTO[jjoin],	c2, at[7, 10, TgetsL];	Rx &larr; 5, L2Disp, GOTO[jjoin],	c2, at[9, 10, TgetsL];	Rx &larr; 6, L2Disp, GOTO[jjoin],	c2, at[0B, 10, TgetsL];	Rx &larr; 7, L2Disp, GOTO[jjoin],	c2, at[0D, 10, TgetsL];	Rx &larr; 8, L2Disp, GOTO[jjoin],	c2, at[0F, 10, TgetsL];NoJump:	MAR &larr; [rhS, S], S &larr; S -1, CANCELBR[$, 0F],	c1;	PC &larr; PC+PC16, L2 &larr; L2.0, IBDisp, DISP2[njNoCar],	c2;	S &larr; S - 0FF,	c3, at[2, 10, njNoCar];	MAR &larr; [rhS, S+0],	c1;	S &larr; S -1, L2 &larr; L2.0, IBDisp,	c2;njNoCar:	TOSH &larr; MD, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0, 10, njNoCar];{*************************	FJUMPX, TJUMPX**************************}{based on the stack pointer conventions:}{Q: does MAR&larr; interfere with XLDisp when no pagecarry?}@FJUMPX:	opcode[262'b],	MAR &larr; [rhS, S], S &larr; S - 1, Xbus &larr; ibNA, XLDisp,	c1;	Ybus &larr; TOSH or TOS, NZeroBr, BRANCH[pos, neg, 1],	c2;@TJUMPX:	opcode[263'b],	MAR &larr; [rhS, S], S &larr; S -1, Xbus&larr; ibNA, XLDisp,	c1;	Ybus &larr; TOSH or TOS, ZeroBr, BRANCH[pos, neg, 1],	c2;{*************************	NFJUMPX, NTJUMPX	2%  4 clicks**************************}@NFJUMPX:	opcode[264'b],	{different on jump: don't pop}	MAR &larr; [rhS, S], S &larr; S - 1, Xbus &larr; ibNA, XLDisp,	c1;	Ybus &larr; TOSH or TOS, NZeroBr, BRANCH[Npos, Nneg, 1],	c2;@NTJUMPX:	opcode[265'b],MAR &larr; [rhS, S], S &larr; S - 1, Xbus &larr; ibNA, XLDisp,	c1;	Ybus &larr; TOSH or TOS, ZeroBr, BRANCH[Npos, Nneg, 1],	c2;Npos:	uTOS &larr; TOS, TOS &larr; MD, BRANCH[$, NoJumpP],	c3;	TOS &larr; uTOS,	c1;	Rx &larr; ib RShift1, XLDisp, SE &larr; 0,	c2;	S &larr; S + 2, BRANCH[jpe, jpo, 2],	c3;Nneg:	uTOS &larr; TOS, TOS &larr; MD, BRANCH[$, NoJumpF],	c3;	Rx &larr; 0FF,	c1;	,	c2;	,	c3;	TOS &larr; uTOS,	c1;	Rx &larr; (ib xor Rx) RShift1, XLDisp, SE &larr; 0,	c2;{Pc}{	S &larr; S + 2, BRANCH[jne, jno, 2],	c3;}	S &larr; S + 2, BRANCH[jnePc, jnoPc, 2],	c3;{Pc}{*************************	JUMPXX**************************}@JUMPXX:	opcode[261'b],	Rx &larr; ib, XLDisp,	c1;jw:	Rx &larr; Rx LRot8, BRANCH[jwPos, jwNeg, 1],	c2;jwPos:	Rx &larr; RShift1 (Rx or ib), SE&larr;0, XLDisp, GOTO[jwtos],	c3;jwNeg:	Rx &larr; RShift1 (Rx or ib), SE&larr;1, XLDisp, GOTO[jwtos],	c3;jwtos:	PC &larr; PC and 0FF, BRANCH[jwEven, jwOdd, 2],	c1;{PC,,pc16&larr;location in page}jwEven:	PC &larr; PC + Rx, GOTO[jwCross],	c2;jwOdd:	PC &larr; PC + Rx + PC16, GOTO[jwCross],	c2;{Pc}{jwCross:		uPCCrossL &larr; 0,	c3;	,	c1;	,	c2;	Q &larr; PC and ~0FF, L0 &larr; L0.JRemap, GOTO[UpdatePC],	c3;}jwCross:		Xbus &larr; uPCCrossL, XRefBr,	c3;	Q &larr; PC - 0FF - 1, BRANCH[PcCWas0, PcCWas1],	c1;PcCWas0:	uPCCrossL &larr; 0,	c2;	Q &larr; PC and ~0FF, L0 &larr; L0.JRemap, GOTO[UpdatePC],	c3;PcCWas1:	uPCCrossL &larr; 0,	c2;	Q &larr; Q and ~0FF, L0 &larr; L0.JRemap, GOTO[UpdatePC],	c3;{Pc}{*************************	Common Jump Code**************************}pos:	TOS &larr; MD, BRANCH[$, NoJumpX],	c3;	MAR &larr; [rhS, S+0],	c1;	Rx &larr; ib RShift1, XLDisp, SE &larr; 0,	c2;jjoin:	TOSH &larr; MD, BRANCH[jpe, jpo, 0E],	c3; jpe:	MAR &larr; PC &larr; [rhPC, PC + Rx], GOTO[jp], MesaIntBr,	c1;jpo:	MAR &larr; PC &larr; [rhPC, PC + Rx + PC16], MesaIntBr,	c1;jp:	S &larr; S - 1, Xbus &larr; 0, XC2npcDisp, DISP2[JumpPX],	c2;{Pc}jp3:	IB &larr; MD, BRANCH[ptr1, ptr0, 0E],	c3, at[0, 4, JumpPX];ptr0:	IBPtr &larr; 0, GOTO[Pcptr],	c1;ptr1:	IBPtr &larr; 1, GOTO[Pcptr],	c1;Pcptr:	Xbus &larr; uPCCrossL, XRefBr,	c2;	BRANCH[$, PcSpec],	c3;	MAR &larr; [rhPC, PC + 1], L2 &larr; L2.0, GOTO[RefillNE2],	c1; {	this mod is only for catching jumps with zero offsets {unlikely, but possible} from an instruction in the last word of a page}PcSpec:	,	c1;	uPCCrossL &larr; 0,	c2;	Q &larr; 0 - 0FF - 1, L0 &larr; L0.JRemap, GOTO[UpdatePC],	c3;{Pc}NoJumpP:	MAR &larr; [rhS, S], S &larr; S - 1, Xbus &larr; ib, GOTO[nj],	c1;NoJumpF:	MAR &larr; [rhS, S], S &larr; S - 1, Xbus &larr; ib, GOTO[nj],	c1;NoJumpN:	MAR &larr; [rhS, S], S &larr; S - 1, Xbus &larr; ib, GOTO[nj],	c1;NoJumpX:	MAR &larr; [rhS, S], S &larr; S - 1, Xbus &larr; ib, GOTO[nj],	c1;nj:	PC &larr; PC+1, IBDisp, L2 &larr; L2.0, DISP4[njxNoCar],	c2;	S &larr; S - 0FF,	c3, at[2, 10, njxNoCar];	MAR &larr; [rhS, S+0],	c1;	S &larr; S - 1, IBDisp, L2 &larr; L2.0,	c2;njxNoCar:	TOSH &larr; MD, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0, 10, njxNoCar];{Pc}{	Q &larr; 0FF + 1, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3, at[2, 4, JumpPX];	Q &larr; 0FF + 1, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3, at[3, 4, JumpPX];}	IB &larr; MD, CANCELBR[PcChka, 03],	c3, at[2, 4, JumpPX];	IB &larr; MD, CANCELBR[PcChka, 03],	c3, at[3, 4, JumpPX];PcChka:	Xbus &larr;uPCCrossL, XRefBr,	c1;	Xbus &larr; 0, XC2npcDisp, BRANCH[NewCrossa, OldCrossa],	c2;NewCrossa:	Q &larr; 0FF + 1, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 03],	c3;OldCrossa:	uPCCrossL &larr; 0, BRANCH[ptr1, ptr0, 02],	c3;{Pc}	Q &larr; ~0FF, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3, at[2, 4, JumpNX];	Q &larr; ~0FF, L0 &larr; L0.JRemap, CANCELBR[UpdatePC, 0F],	c3, at[3, 4, JumpNX];	IB &larr; MD, uPCCrossL &larr; 0, BRANCH[ptrJ1, ptrJ0, 0E],	c3, at[1, 4, JumpPX];	IB &larr; MD, uPCCrossL &larr; 0, BRANCH[ptrJ1, ptrJ0, 0E],	c3, at[1, 4, JumpNX];ptrJ0:	IBPtr&larr;0, GOTO[MInt],	c1; ptrJ1:	IBPtr&larr;1, GOTO[MInt],	c1;neg:	TOS &larr; MD, BRANCH[$, NoJumpN],	c3;	TT &larr; 0FF,	c1;	,	c2;	,	c3;	MAR &larr; [rhS, S],	c1;	Rx &larr; (ib xor TT) RShift1, SE &larr; 0, XLDisp, CANCELBR[$, 2],	c2;{Pc}{	TOSH &larr; MD, BRANCH[jne, jno, 2],	c3;}	TOSH &larr; MD, BRANCH[jnePc, jnoPc, 2],	c3;jnePc:	Xbus &larr; uPCCrossL, XRefBr,	c1;	uPCCrossL &larr; 0, BRANCH[PcModE, PcModEX],	c2;PcModE:	GOTO[jne],	c3;jnoPc:	Xbus &larr; uPCCrossL, XRefBr,	c1;	uPCCrossL &larr; 0, BRANCH[PcModO, PcModOX],	c2;PcModO:	GOTO[jno],	c3;PcModEX:	,	c3;	MAR &larr; PC &larr; [rhPC, PC - Rx -1], GOTO[jnPc],	c1;PcModOX:	,	c3;	MAR &larr; PC &larr; [rhPC, PC - Rx -PC16], GOTO[jnPc],	c1;jnPc:	S &larr; S - 1, DISP2[JumpNXPc],	c2;	Q &larr; ~0FF, L0 &larr; L0.JRemap, GOTO[UpdatePC],	c3, at[0, 4, JumpNXPc];	Q &larr; ~0FF, L0 &larr; L0.JRemap, GOTO[UpdatePC],	c3, at[2, 4, JumpNXPc];{Pc}jne:	MAR &larr; PC &larr; [rhPC, PC - Rx -1], GOTO[jn], MesaIntBr,	c1;jno:	MAR &larr; PC &larr; [rhPC, PC - Rx - PC16], GOTO[jn], MesaIntBr,	c1;jn:	S &larr; S - 1, Xbus &larr; 0, XC2npcDisp, DISP2[JumpNX],	c2;jn3:	IB &larr; MD, BRANCH[ptr1, ptr0, 0E],	c3, at[0, 4, JumpNX];{*************************}{Jump.dfn	comments on PC, IFU, page crossing and control transferThe DLion Interlisp-D Instruction Fetch Unit (IFU) is implemented in hardware and microcode.Code arrays cannot cross segments.  Name tables cannot cross pages.The IFU state variables and their values AT OPCODE ENTRY are:	STATE CONCEPTUALLY STORED IN THE LOCAL FRAMEcodeB		UvCL + UvChighL*2&uarr;16			fn header		tPC		2*[UvPCpageL-UvCL+(PC and 0FF)]+PC16	true byte PC	ADDITIONAL IFU STATEIBCnt=IBPtr	number of valid bytes in IFU  (must correlate even/odd with pc16 in puntFor? elsewhere ErrnIBnStkp?)CACHED IFU STATE :UvChighL	(codeB)/(2&uarr;16)				code base highUvCL		(0FFFF and codeB)UvPCpageL	(0FF00 and (codeB + tPC/2)rhPC		upper Map(codeB + tPC/2))			PC real segment and flagsPC		(0FF and tPC/2)+(0FF00 and Map(codeB + tPC/2))	PC real word addresspc16		(tPC and 1)					PC byte flip flopuPCCrossL	((tPC and 1FE)=1FE) = (PC = (FF mod 100)) 	MInt		interrupt or uPCCrossLIFU STATE AT OPCODE ENTRYA1) OPCODE ENTRY				STANDARDA2) OPCODE ENTRY abort to Pfault PUNT		uPCCrossL and (PC and FE)#FE has special meaning (for puntFor? for 4 byte ops?) =&gt; tPC &larr; tPC + 200						L2 has special meaningB1) OPCODE EXIT to refill		(1b)	(Mint)    if (uPCCrossL and (PC and FF)#FF)		then UpdatePC + 100; {uPCCrossL &larr; 0}					(2)	(RefillE) if ~uPCCrossL and IBCnt=0 and (tPC and 1FF)=0 then UpdatePC + 100					(1a)	(RefilNE) uPCCrossL &larr; (PC and FF)=FF						B2) OPCODE EXIT to "punt forward"	(1b)	if uPCCrossL and (PC and FE)#FE 			then UpdatePC + 100					(2)	if {~uPCCrossL and} IBCnt=0 and (tPC and 1FF)=0 	then UpdatePC + 100PAGE CROSS PRINCIPLE: Notice page cross by (1a+1b)IFU containing bytes from 2 pages or (2) by IFU exhausted at exactly page boundry.PAGE CROSS PRINCIPLE for 4 bytes (i) still valid (ii):{c) going to PCUpdate				tPC &larr; tPC + 2*Q}f) at fmMD of function call			L3}{Buffer Empty Refill.  Control goes from NoRCross to RefillNE since RefillE+1 does not contain an IBDisp.}RefillE:	MAR &larr; [rhPC, PC], PC &larr; PC - PC16, L0 &larr; L0.ERefill,	c1, at[400];	PC &larr; PC+PC16 {restore}, DISP2[NoRCross],	c2;{Buffer Not Empty Refill.}	{"Noop" location of Instruction Dispatch table}OpTable:RefillNE:		at[OpTable],Refil:	MAR &larr; [rhPC, PC + 1], L2 &larr; L2.0,	c1;RefillNE2:	AlwaysIBDisp, L0 &larr; L0.NERefill.Set, DISP2[NoRCross],	c2;NoRCross:	IB &larr; MD, uPCCrossL &larr; 0, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0,4,NoRCross];{Pc}{RCross:	Q &larr; 0FF + 1, GOTO[UpdatePC],	c3, at[2,4,NoRCross];}	Xbus &larr; uPCCrossL, XRefBr,	c3, at[2,4,NoRCross];	BRANCH[PcMoveVPC, PcVPCok],	c1;PcMoveVPC:	Q &larr; 0FF + 1,	c2;	GOTO[UpdatePC],	c3;PcVPCok:	Q &larr; 0,	c2;	GOTO[UpdatePC],	c3;{Pc}{************************	Refill Remap Routines*******************************}{Entry:T	old real PCQ[0-7]	page displacement to be added to virtual PCQ[8-15]	ignoredPC[0-7]	ignoredPC[8-15]	valid location within new pagepc16	must be validExit:UvPCpageL	new virtual PC pageTT	new virtual PC pagerhTT	UvChighLPC	new real PC valueQ	new real PC value}{L0.ERefill &amp; uPCCrossL indicate remap and fetch (NE) PC+1}{Pc needs doing in UpdatePC!}UpdatePC:	TT &larr; UvPCpageL, L1 &larr; L1.Refill{for fault trap},	c1, at[0F,10];UpdatePC2:	TT &larr; TT + Q, rhTT &larr; UvChighL,	c2;UpdatePC3:	Q{lowPC} &larr; PC,	c3;	Map &larr; MAR &larr; TT &larr; [rhTT, 0+0], L0Disp,	c1;	DISP4[ECross],	c2;	PC &larr; Q{lowPC}, GOTO[NoMoreFix],	c1, at[L1.Refill,10,Fix];{Buffer Empty Refill page cross OR PCCross flag true.  Remap the PC (which points to 1st or 2nd word of page).  If we are doing an empty refill, return to the Empty Refill code at NoRCross.  If we are updating the PC because PCCross is true, return to Refill-interrupt code.}{Even if we fault, have UvPCpageL updated.}ECross:	UvPCpageL &larr; TT, PC &larr; MD, rhPC &larr; MD, XRefBr,	c3, at[L0.ERefill,10,ECross];{Pc}ERedo:	MAR &larr; Q &larr; [rhPC, Q+0], BRANCH[EMapUD, $],	c1, at[L0.ERefill,10,RMapFixCaller];EMapOK:	PC &larr; Q, GOTO[NoRCross],	c2;{Pc}EMapUD:	Rx &larr; PC, CANCELBR[RLMapFix]  {returns at ERedo},	c2;{Buffer Not Empty Refill page cross.  Fetch the first word of the next page and do NOT Remap PC.  Set PCCross true and the Refill-Interrupt hardware bit.  Dispatch on the IB (as in the RefillNE code).}{Pc}NECross:	UvPCpageL &larr; TT, PC &larr; MD, rhPC &larr; MD, XRefBr,	c3, at[L0.NERefill,10,ECross];{&amp;P}NERedo:	MAR &larr; Q &larr; [rhPC, 0+0], BRANCH[NEMapUD, $],	c1, at[L0.NERefill,10,RMapFixCaller];	PC &larr; Q - 1, AlwaysIBDisp, L2 &larr; L2.0,	c2;	IB &larr; MD, uPCCrossL &larr; (~TT xor TT), L2 &larr; L2.0, DISPNI[OpTable],	c3;NEMapUD:	Rx &larr; PC, CALL[RLMapFix]  {returns at NERedo},	c2;{Pc}{Jump Cross Remap.  Remap the PC (which can point to any word of a page).}{Even if we fault, have UvPCpageL updated.}JCross:	UvPCpageL &larr; TT, PC &larr; MD, rhPC &larr; MD, XRefBr,	c3, at[L0.JRemap,10,ECross];JRedo:	MAR &larr; Q &larr; [rhPC, Q+0], BRANCH[JMapUD, $],	c1, at[L0.JRemap,10,RMapFixCaller];	PC &larr; Q, Xbus&larr;0, XC2npcDisp,	c2;	IB &larr; MD, uPCCrossL &larr; 0, BRANCH[ptr1, ptr0, 0E],	c3;JMapUD:	Rx &larr; PC, CALL[RLMapFix]  {returns at JRedo},	c2;{*************************	Interrupt Processing**************************}MInt0:			 at[600],	TT &larr; 0{buffer empty}, GOTO[MInt],	c1;MInt1:			 at[700],	TT &larr; TT xor ~TT{not empty}, GOTO[MInt],	c1;MInt:	Ybus &larr; uWDC, NZeroBr,	c2;	TT &larr; uWP, ClrIntErr, BRANCH[Interuption, IgnoreInt],	c3;IgnoreInt:	Noop,	c1;IBDispOnlyL: IBDisp, L2 &larr; L2.0, GOTO[DISPNIonly],	c2;DISPNIonly:	L2 &larr; L2.0, DISPNI[OpTable],	c3;Interuption: Ybus &larr; TT, ZeroBr,	c1;	BRANCH[Wakeups, NoWakeups],	c2;NoWakeups:	GOTO[IgnoreInt],	c3;Wakeups:		uWP &larr; 0,	c3;	Rx &larr; 1,	c1;	uWDC &larr; Rx,{off interrupts}	c2;	Rx &larr; KbdFXP, L2 &larr; 0{NotInCall}, GOTO[PuntFor],	c3;	{ E N D }	</pre>
  </body>
</html>
