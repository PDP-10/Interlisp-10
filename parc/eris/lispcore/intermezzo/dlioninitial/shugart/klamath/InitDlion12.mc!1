{File name:  InitDLion12.mcPurcell   1-Jul-84 18:27:07  clear page 14000 in add to IOPagePurcell   1-Jul-84 18:27:07  clear page 20000Purcell  1-Jul-84 17:46:10File name:  InitDLion.mcDescription: Mesa Emulator initialization,Last Edited by Amy Fasnacht: 13-Sep-83 16:03:33 Add support for 24-bit VA spaceLast Edited by Daniels:  5-Aug-83 10:57:41 uPMask _ uPMask2 _ 1FF8 (was 0FFC)Last Edited by Amy Fasnacht: September 22, 1982  5:12 PM Add uTMErRst initialization for MagTapeLast Edited by Amy Fasnacht: September 22, 1982  5:12 PM Delete uStartScan initializationLast Edited by Amy Fasnacht: August 5, 1982  1:49 PM Change IOPage referencesLast Edited by Amy Fasnacht: June 29, 1982  9:11 AM Add LSEP initializationsLast Edited by Amy Fasnacht: May 18, 1982  10:19 AM Change display registersLast Edited by Amy Fasnacht: February 9, 1982  10:48 AM Replace Trident/Shugart conditional assembly initializations with branches based on CPBootDevice (accomodates etherbooting).Last Edited by Jim Frandeen: February 2, 1982  1:22 PM Initialize uE3FF.Last Edited by Amy Fasnacht: January 6, 1982  4:01 PM Bug fix - branch to DisplayInit after initializing SAx000 registersLast Edited by Jim Frandeen: December 17, 1981  1:03 PM Use only two registers for initialization.Last Edited by J. Furst: December 8, 1981  2:07 PM, Added new Trident reg. UF000Sandman : November 17, 1981  1:24 PM New instruction setLast Edited by Jim Frandeen: November 8, 1981  5:00 PM initialize new display registers for smooth scrollingLast Edited by Neely: October 13, 1981  11:20 AM Trident IntegrationLast Edited by Jim Frandeen: April 1, 1981  2:09 PM: initialize UtbFlagsAuthor: Sandman,}Reserve[0F6F]; Reserve[0F78]; Reserve[0F7F,0FFF];	{Kernel}SetTask[0];{NOTE: we must use only two regisers (dY and dZ) for initialization so that register usage will not conflict with booting. For example, Protected.mc uses three registers to check for Ethernet timeout. We do Display initialization last since the Display microcode counts on two of its registers being initialized, and we use these two registers for all other initialization.}IfEqual[Config, 3, SkipTo[SetEtherBoot],];IfEqual[Config, 2, SkipTo[SetTrident],];OnceOnlyInit:	CPBootDevice _ 0,	c1;	Noop,	c2;SkipTo[SkipSetTrident];SetTrident!OnceOnlyInit:	dY _ 0C,	c1;	CPBootDevice _ dY,	c2;SkipSetTrident!	Noop,	c3;	dZ _ LShift1 0FF, SE_1, CANCELBR[$,0F],	c1;SkipTo[StartInit];SetEtherBoot!OnceOnlyInit:	dZ _ LShift1 0FF, SE_1, CANCELBR[$,0F],	c1;StartInit!	dZ _ LShift1 dZ, SE_1,	c2;	u3FF _ dZ, dZ _ dZ LShift1, SE_1,	c3;	{MCtl _ **  dZ + 1,}	c1;	u7FF _ dZ, dZ _ dZ LShift1, SE_1,	c2;	dZ _ dZ LShift1, SE_1,	c3;	u1FFF _ dZ, dZ _ dZ LShift1, SE_1,	c1;	u3FFF _ dZ,	c2;	dZ _ 64,	c3;	dZ _ dZ LRot8, Refresh,	c1;	UtbFlags _ dZ,	c2;	dZ _ LShift1 0F, SE_1,	c3;	dZ _ dZ LRot8, ClrIntErr,	c1;	dZ _ dZ or 0F8,	c2;	uPMask _ dZ,	c3;	uPMask2 _ dZ, Refresh,	c1;	dZ _ 0E,	c2;	dZ _ dZ LRot12,	c3;	uPPMask _ dZ, Refresh,	c1;	dZ _ RShift1 0, SE _ 1,	c2;	u8000 _ dZ,	c3;		MCtl _ dZ or 2, c1;	, c2;	, c3;	dY _ 0, Refresh,	c1; 	dZ _ IOPage,	c2;	dZ _ dZ LRot8, 	c3;	rhdZ _ IOPageHigh,	c1; 	uIOPage _ dZ,		c2;	Noop,	c3;{clear I/O page, TOS = 0}IOPageLoop:	MAR _ [rhdZ, dZ+0],	c1;	MDR _ dY{=0}, dZ _ dZ + 1, PgCrOvDisp,	c2;	uPCCross _ 0, BRANCH[IOPageLoop,$,1],	c3;{clear MESA (2nd) I/O page, TOS = 0}	rhdZ _ 1{2}{IOPageHigh},	c1; 	dZ _ 40{0},		c2;	{uIOPage _ 0{dZ},}dZ _ dZ LRot8, {Noop,}	c3;IOPageLoop2:	MAR _ [rhdZ, dZ+0],	c1;	MDR _ dY{=0}, dZ _ dZ + 1, PgCrOvDisp,	c2;	uPCCross _ 0, BRANCH[IOPageLoop2,$,1],	c3;EtherInit:	Refresh,	c1;	dZ _ 55,	c2;	dZ _ dZ LRot8 or dZ,	c3;	uEPreamble _ dZ, Refresh,	c1;	dZ _ dZ or 0C0,	c2;	uELastPreamble _ dZ,	c3;	dZ _ LShift1 0FF, SE _ 1 {1FF},	c1;	dZ _ LShift1 dZ, SE _ 1 {3FF},	c2;	uE3FF _ dZ,	c3;MagTapeInit:	rTWc _ CTClrMEr,	c1;	rTWc _ rTWc LRot8,	c2;	uTMErRst _ rTWc,	c3;	DiskInit:	Xbus _ CPBootDevice, XDisp,	c1;	BRANCH[SAx000Init, TridentInit, 7],	c2;SAx000 Init:	Noop,	c3;{initialize 16 bit const used to clear mem errorflags}	dZ _ CClearMemError,	c1;	dZ _ dZ LRot8,	c2;	U0C00 _ dZ,	c3;	{form top byte of status mask, bottom byte depends on drive connected}	dY _ CHeadMsk,	c1;	dY _ dY LRot8,	c2;	Xbus _ KStatus, XwdDisp,	c3;	dZ _ CSA1MaxSectTst, BRANCH[SetSA1Const, SetSA4Const,2],	c1;SetSA4Const:	{sector test number}	dZ _ CSA4MaxSectTst, 	c2, at[3,4,SetSA1Const];	UMaxSectTst _ dZ,	c3;	{synchronization word and error mask}	dZ _ dZ xor ~dZ,	c1;	dY _ dY or CSA4ErrMsk, GOTO[SetURegs],	c2;SetSA1Const:	UMaxSectTst _ dZ,	c2, at[2,4,SetSA4Const];	dZ _ CAddrMkHi,	c3;	{address mark and error mask}	dZ _ dZ LRot8,	c1;	dY _ dY or CSA1ErrMsk,	c2;SetURegs:	dZ _ dZ or CAddrMkLo,	c3;	{save sync word or address mark; set status mask}	USyncAdrMk _ dZ, Refresh,	c1;	UStatusMsk _ dY,	c2;	GOTO[DisplayInit],	c3;TridentInit:	Noop,	c3;{Initialization of U0C00 -- A 16 bit constant used to clear memory error flags}	dZ _ 0C	,c1;	dZ _ dZ LRot8	,c2;	U0C00 _ dZ	,c3;{Initialization of U0C04 -- A 16 bit constant used to reset Control Tag in the Command register}	dZ _ dZ or 4	,c1;	U0C04 _ dZ	,c2;	dZ _ 2C	,c3;{Initialization of U2C04 -- A 16 bit constant used to set the Head Tag in the Command register}	dZ _ dZ LRot8	,c1;	dZ _ dZ or 4	,c2;	U2C04 _ dZ	,c3;{Initialize U2C05 register and prepare initializing UCStatMask.}	dZ _ dZ or 1	,c1;	U2C05 _ dZ	,c2;	dZ _ 4E	,c3;{Initialize UCStatMask with 4E06.}	dZ _ dZ LRot8	,c1;	dZ _ dZ or 6	,c2;	UCStatMask _ dZ	,c3;{Initialization of UF001 -- A 16 bit constant used to turn on "Sequence" for all four drives in the Control register}	dZ _ 0F0	,c1;	dZ _ dZ LRot8	,c2;	UF000 _ dZ	,c3;{Initialization of UF001 -- A 16 bit constant used to turn on "Sequence" for all four drives in the Control register}	dZ _ 1F	,c1;	dZ _ dZ LRot12	,c2;	UF001 _ dZ	,c3;{Initialize U0400 register}	dZ _ 4	,c1;	dZ _ dZ LRot8	,c2;	U0400 _ dZ	,c3;{Initialization of U4000 and KCmd register (TestCtl = 1) and USIP with 0.}KRegInit:	KCmd _ dZ _ dZ LRot4	,c1;	U4000 _ dZ	,c2;	USIP _ 0	,c3;{Initialize KCtl with 0F000 .}	dZ _ 0F	,c1;	KCtl _ dZ  LRot12	,c2;	dZ _ 0FF + 1	,c3;{Initialize  U0100.}EndInit:	U0100 _ dZ, Refresh	,c1;	Noop	,c2;	Noop, 	,c3;DisplayInit:	rhdY _ IOPageHigh, Refresh,	c1;	dZ _ uIOPage,	c2;	Noop,	c3;	Noop,	c1;	dZ _ dZ + IOPage.DCSB.cursorMap,	c2;	uInitCurMapAddr _ dZ,	c3;	dZ _ 88,	c1;	dZ _ dZ LRot8,	c2;	dZ _ dZ or 22 {8822},	c3;	uInitBorder _ dZ, Refresh,	c1;	dZ _ PicLenShifted,	c2;	dY _ dZ LRot8,	c3;	uInitCurBufAddr _ dY,	c1;	dZ _ LRot1 dZ,	c2;	dZ _ LRot1 dZ, rhdZ _ 0,	c3;	uInitPicLength _ dZ {328'x}, Refresh,	c1;	uClockBits _ 0,	c2;	Noop,	c3;	ClrDPRq,	c1;	dZ _ uPatchCount _ 0,	c2;	dY _ 7,	c3;	uCopyCount _ dY, Refresh,	c1;	uPatchLine _ dZ xor ~dZ,	c2;	dY _ 3F,	c3;	dY _ dY LRot4,	c1;	u3F0 _ dY,	c2;	dY _ 0FC,	c3;	dY _ dY LRot8,	c1;	uNormalFifo _ dY,	c2;LsepInit:	dY _ 10,	c3;	uDisableLSEP _ dY,	c1;	dY _ 15,	c2;	uEndBandScan _ dY,	c3;	dY _ 1B,	c1;	uStartActive _ dY,	c2;	dY _ 1, GOTO[DoneOnceOnlyInit]	c3;(0,5080)(1,5842)(2,15240)(3,16510)(4,17780)\f1 2i28I63i18I