{Recalibrate.mc  debugging hack for Initial.mc  last edit by Jim Frandeen December 16, 1981  3:29 PM: remove stepCount RegDef}SetTask[0];{control bits, high byte}	Set[driveSelectBit, 4], Set[faultClearBit, 2];{useful combinations}	Set[faultClearCmd, Or[driveSelectBit, faultClearBit]];z20320k40(0,8320)(1,5644)(2,14817)\f1 167t1 1t0recal:	rE_ 20, CANCELBR[$, 0F],	c1;	stepCount_ rE,	c2;	Noop,	c3;	rE_ faultClearCmd,	c1;	KCtl_ rE LRot8,	c2;	KCtl_ 0,	c3;recal0:	Xbus_ KStatus, XRefBr,	c1;	rE_ driveSelectBit, BRANCH[$, recal1],	c2; {check for drive ready}	rE_ KCtl_ rE LRot8, GOTO[recal0],	c3;{disk is ready}recal1:	rE_ driveSelectBit,	c3; {step out first}	rE_ rE LRot8,	c1;	rE_ rE or inBit,	c2;	KCtl_ rE LRot0,	c3;{Step bit must be high for at least one microsecond and then low for at least one microsecond.  Since a click is 411 ns, stepBit can change only once every third click.}check00:	rD_ ~KStatus, CANCELBR[$, 1],	c1, at[0B, 10, check00];	rD_ rD LRot8, XDisp,	c2; {pick up status}	[]_ rD and 2, ZeroBr, DISP4[check00, 0B],	c3; {check for seek complete}seekComplete:	rE_ rE or stepBit, BRANCH[at00, $],	c1, at[0F, 10, check00];	KCtl_ rE LRot0,	c2;	rD_ 3,	c3;seekWait:	rE_ rE and ~stepBit,	c1;	rD_ rD-1, ZeroBr,	c2;	BRANCH[seekWait, $],	c3;	rD_ stepCount, ZeroBr,	c1;	KCtl_ rE LRot0, BRANCH[$, countedOut],	c2;	rD_ rD-1,	c3;	stepCount_ rD,	c1;	Noop,	c2;	GOTO[check00],	c3;countedOut:	Noop,	c3;	rD_ rE and inBit,	c1;	[]_ rD, ZeroBr,	c2;	rE_ rE xor inBit, BRANCH[$, recalLost],	c3;	rD_ 0FF+1, {max is 256 cylinders  for SA1000}	c1;	rD_ LShift1 rD,	c2;	stepCount_ rD, GOTO[check00],	c3;recalLost:	Noop,	c1;	Noop,	c2;	GOTO[recalLost],	c3;at00:	Noop,	c2;	Noop,	c3;at000:	GOTO[at00],	c1;z20320k40(0,4939)\f1(635)\f1