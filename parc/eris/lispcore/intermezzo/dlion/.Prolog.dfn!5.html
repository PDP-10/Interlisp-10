<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Intermezzo>dlion>Prolog.dfn!5</title>
  </head>
  <body>
    <pre>
{	NewProlog.dfnlast edit:     23-Apr-85 16:20:02by don:  16-Apr-85 14:20:18}{Copyright 1985 Xerox Corporation.  All rights reserved.    This is unpublished proprietary software and or documentation.    Information contained here is proprietary to Xerox and is for Xerox internal use and is furnished to others only under a confidential disclosure agreement.}{	PROLOG MACROs  and constants}Set[PrologOpValue, 500],MacroDef[UI,  (  GOTO[UI2], c1, at[Add[#1, PrologOpValue]])];MacroDef[PrologOp,  ( c1,  at[Add[#1, PrologOpValue]])];MacroDef[OddW, (CANCELBR[$, 2], LOOPHOLE[wok])];MacroDef[PrReadMode, (L2 &larr; 0)];MacroDef[PrWriteMode, (L2 &larr; 1)];{	PROLOG U REGISTERS }{	P	prolog program pointer }{	uses Lisp regs rhPC and PC }	{RegDef[rhPC, RH, 05],	RegDef[PC, R, 05],}	RegDef[upLVPChi, U, 016],	RegDef[upVPChi, U, 026],	RegDef[upVPClo, U, 01C],{	B	last choice point (backtrack point) (local stack) }{	uses Lisp regs rhTOSH and TOSH }	RegDef[rhBB, RH, 01],	RegDef[BB, R, 01],	RegDef[uprhB, U, 0CC],	RegDef[upB, U, 0CD],{	H	top of heap }{	uses Lisp regs rhS and S }	RegDef[rhHH, RH, 04],	RegDef[HH, R, 04],	RegDef[uprhHH, U, 0DD],	RegDef[upHH, U, 0DF],{	S	structure pointer (heap) }{	uses Lisp regs rhTOS and TOS }	RegDef[rhSS, RH, 00],	RegDef[SS, R, 00],	RegDef[uprhSS, U, 0E3],	RegDef[upSS, U, 0E5],{	C	XXX }	RegDef[rhCC, RH, 03],	RegDef[CC, R, 03],	RegDef[uprhCC, U, 0E9],	RegDef[upCC, U, 0EA],{	CP	continuation program pointer }	RegDef[uprhCP, U, 09A],	RegDef[upCP, U, 03D],{	E	last environment (local stack) }	RegDef[uprhE, U, 0CE],	RegDef[upE, U, 0D3],{	TR	top of trail }	RegDef[uprhTR, U, 0D9],	RegDef[upTR, U, 0DA],{	HB	heap backtrack point (H value corresponding to B) }	RegDef[uprhHB, U, 0DB],	RegDef[upHB, U, 0DC],{	R	XXX }	RegDef[uprhR, U, 0E7],	RegDef[upR, U, 0E8],{	B0	XXX }	RegDef[uprhB0, U, 0BD],	RegDef[upLB0, U, 0C1],	RegDef[upB0, U, 019],{	N	alpha byte of instruction }	RegDef[upN, U, 09B],{	I	temp used by lisp interpreter }	RegDef[upI, U, 06E],{	T0	XXX }	RegDef[uphiT0, U, 0BA],	RegDef[upT0, U, 0BC],{	T1	XXX }	RegDef[uphiT1, U, 09F],	RegDef[upT1, U, 0B1],	RegDef[upDebug, U, 03C],{conains 0 if no debug, 1 if single step, 17 if careful}	RegDef[upWriteMode, U, 036],{contains 256 if Write-Mode true, else 0}	RegDef[uLMBbase, U, 06C],{real addr of Lisp/Microcode table as (Bits 8 to 15,,Bits 0 to 7) of the 24 bit base address}	RegDef[uSQtablebase, U, 06B],{real addr of base of SELECTQ arms table as (Bits 8 to 15,,Bits 0 to 7) of the 24 bit base address}	RegDef[uSQbasehi, U, 05E],{virtual address of code base used by SQ offsets}	RegDef[uSQbaselo, U, 05F],{virtual address of code base used by SQ offsets}	RegDef[upVMlim, U, 09C],{contains the smallest virtual address above Prolog's VM in the form (Bits 8 to 15,,Bits 0 to 7) of the address.  (The address always ends in eight zeros.)}	RegDef[upA0Base, U, 09E],RegDef[upA1Base, U, 09D],{contain real addresses of base of memory A registers as (Bits 8 to 15,,Bits 0 to 7) of the 24 bit base addresses.  The tables are page alligned, and locked in memory while Prolog is running}	RegDef[upPFcont, U, 04E],{continuation point after a page fault if non-zero}	RegDef[upStep, U, 03E],{toggles upon execution of @PROLOGOPFETCHPLUSOPDISP, will stop if # 0}{	registers saving Lisp state}	RegDef[upTOS, U, 051],	RegDef[upTOSH, U, 052],	RegDef[upPV, U, 053],	RegDef[upPC, U, 054],	RegDef[upS, U, 055],	RegDef[upPC16, U, 056],{	Values for Prolog A regs }	RegDef[upPRA1hi, U, 000],	RegDef[upPRA1lo, U, 001],	RegDef[upPRA2hi, U, 002],	RegDef[upPRA2lo, U, 003],	RegDef[upPRA3hi, U, 004],	RegDef[upPRA3lo, U, 005],	RegDef[upPRA4hi, U, 006],	RegDef[upPRA4lo, U, 007],{	Values for Prolog A regs saved }	RegDef[upA1hi, U, 014],	RegDef[upA1lo, U, 015],	RegDef[upA2hi, U, 0ED],	RegDef[upA2lo, U, 0EE],	RegDef[upA3hi, U, 0EB],	RegDef[upA3lo, U, 0EC],	RegDef[upA4hi, U, 011],	RegDef[upA4lo, U, 012],{	Saved Prolog regs}	RegDef[upSave, U, 048],	RegDef[upUnPC, U, 03F],	RegDef[upKK, U, 06A],{safe}{	Temporary Prolog regs}	RegDef[upTT, U, 027],	RegDef[upTemp, U, 035],	RegDef[upTemp1, U, 037],	RegDef[upTemp2, U, 038],	RegDef[upTemp3, U, 041],	RegDef[upTemp4, U, 042],	RegDef[upTemp5, U, 043],RegDef[UPblock0, UY, 00],RegDef[UPblock1, UY, 01],RegDef[UPblock2, UY, 02],RegDef[UPblock3, UY, 03],RegDef[UPblock4, UY, 04],RegDef[UPblock5, UY, 05],RegDef[UPblock6, UY, 06],RegDef[UPblock7, UY, 07],RegDef[UPblock8, UY, 08],RegDef[UPblock9, UY, 09],RegDef[UPblockA, UY, 0A],RegDef[UPblockB, UY, 0B],RegDef[UPblockC, UY, 0C],RegDef[UPblockD, UY, 0D],RegDef[UPblockE, UY, 0E],RegDef[UPblockF, UY, 0F],Set[PrologBank, 00],Set[PrologToLisp, 141],Set[LispToProlog, 142],{	TAGS }Set[Pr.ref.tag.val, 000],Set[Pr.struct.tag.val, 048],Set[Pr.list.tag.val, 080],Set[Pr.symbol.tag.val, 0C8],Set[Pr.immed.tag.val, 0D9],Set[Pr.boxed.tag.val, 0E9],Set[Pr.float.tag.val, 0F8],{	after XDisp on high nibble, use the following catches: }Set[Pr.ref.tag.7, 00],Set[Pr.struct.tag.7, 04],Set[Pr.list.tag.7, 08],Set[Pr.symbol.tag.7, 0C],Set[Pr.immed.tag.7, 0D],Set[Pr.boxed.tag.7, 0E],Set[Pr.float.tag.7, 0F],{	after XHDisp, use the following catches: }Set[Pr.ref.tag.4, 00],Set[Pr.struct.tag.4, 02],Set[Pr.list.tag.4, 01],Set[Pr.other.tag.4, 03],{	returns from PrRMapFix in bank 0}{	odd values are used if VPC/PC is correct	even values are used if VPC/PC is +1}Set[L0.PrR1.24, 01];{PrR1}Set[L0.PC4a, 3],Set[L0.PCcont, 7],Set[L0.PrExu2, 9];Set[L0.PFPC4b, 0B];Set[L0.PFPCdc, 0D];Set[L0.PC2, 2],Set[L0.PC4b, 4],Set[L0.PrExu1, 8];Set[L0.PCPFcont, 0A];Set[L0.PrExu3, 0F];{the following values are used when returning to Lisp}	Set[L1.PrDebugSS, 1],	Set[L1.PrInt, 2],	Set[L1.PrDebugC, 3],	Set[L1.PrPF, 4],	Set[L1.PrUI, 5],	Set[L1.PrHeapErr, 6],	Set[L1.PrSink, 7],{	return values for ReadSomeU }Set[L2.ReadUHi, 01],Set[L2.ReadULo, 02],Set[L2.ReadUTag, 03],{	return values for WriteSomeU }Set[L2.WriteUhi, 01],Set[L2.WriteUlo, 02];{	PF restart points:PrR1:	PF15PrR2	PF10	PF11PrR3	PF13	PF55	PF5A	PF5BPrR4	PF58PrR5	nonePrR6	PF53	PF54PrR7	PF29	PF2A	PF2B	PF2C	PF2D	PF2E	PF02PrR10	nonePrUUn1	nonePrUn1	PF28	PF20	PF21	PF22	PF23	PF24	PF25	PF26	PF27PrUn2	nonePrUn3	PF30	PF31	PF32	PF33	PF34	PF35	PF36	PF37	PF38	PF39	PF3A	PF3B	PF3C	PF3D	PF3EPrUn4	PF41	PF42	PF43	PF44	PF45PrUn5	PF51	PF52	PF59}	{ E N D }</pre>
  </body>
</html>
