{File : FTS.mcAuthor : Gwan SantosaDate : 26-Jul-85 16:48:38This program converts an array of floating points into an array of integersThe integers are 8 bits numbers, the floating points are 32 bits numbers.The format :(FTS Src Dest Count)	S - 2	Src	S - 0	Dst	TOS	CountStart:	Fetch Stack parameters	Set up SRCEMREG (set up the address of the last entry, because we work backward)	Set up DSTMEMREG	Call Conversion subroutine	Decrement Count 	Set up SRCMEMREG	GOTO[FSILE]Inner Loop:	Set up SRCMEMREG	Set up DSTMEMREGFSILE:	Call Conversion subroutine			Store Result in memory	Decrement Count, if 0, exit at FSEX0	Count is not 0, Set up SRCMEMREG.	Call Conversion subroutine	Decrement Count, back to inner loop.FSEX0:	DoneWe have to work backward, i.e. : start from the tail of the array.After page fault we only continue to convert the rest of the arrayThe size of the Dst is 1/2 of Src.In the conversion subroutine, if the number is >FF, will return FF, if <0, will return 0.Restriction :The calling function must make sure :1. The count is an even number, non zero.2. The count is not greater than the number of Src elements.3. Src and Dst is a pointer to base address of the arrays.4. Src is a floating point array ('FLOATP).5. Dst is an integer array ('WORD).	}Set[L0.FS.RO.00, 00];Set[L0.FS.RO.01, 01];Set[L0.FS.NR.0F, 0F];Set[L1.FS.NR.0B, 0B];Set[L0.FS.RO.02, 02];Set[L0.FS.RO.03, 03];Set[L0.FS.NR.0C, 0C];Set[L1.FS.NR.0C, 0C];Set[L2.FS.FtoS.00, 00];Set[L2.FS.FtoS.01, 01];Set[L2.FS.FtoS.02, 02];Set[L2.FS.FtoS.03, 03];Set[L3.SRCMEMREG.00, 00];Set[L3.SRCMEMREG.01, 01];Set[L3.SRCMEMREG.02, 02];RegDef[rSTATUS, R, 03]; {=PV}RegDef[rRESM, R, 06]; {=Rx}RegDef[rRESL, R, 05]; {=PC}RegDef[rRESLtemp,R, 04]; {=S}RegDef[uNSrcoffset, U, 51];RegDef[urhNSrc, U, 53];RegDef[uNDstoffset, U, 35];RegDef[urhNDst, U, 45];RegDef[uNSrcoffsetReal, U, 1E];RegDef[urhNSrcReal, U, 30];RegDef[uNDstoffsetReal, U, 59];RegDef[urhNDstReal, U, 7];FSBK0:	Ybus _ TOSH xor smallpl, ZeroBr,	c3, at[0F, 10, SPLITNUM]; {Check if size = NIL}	FSBK1:	TT _ 0FF + 1, BRANCH[FSER1, $],	 	c1; {set PPort to read}	Q _ uPPsave, L1 _ L1.FS.NR.0B,		c2;	PPort _ Q and ~TT, CALL[SaveAllRegsB2],	c3; {Save all registers}		MAR _ [rhS, S - 1],			c1, at[L1.FS.NR.0B, 10, SaveRegsB2Ret]; {Point to Dst Bitmap}	Ybus _ TOS, ZeroBr, CANCELBR[$, 2],	c2; {Check if size = 0}			PV _ MD, BRANCH[$, FSER0],		c3; {PV = high word V address of Dst}						MAR _ [rhS, S + 0],			c1;	S _ S - 2,				c2;	PC _ MD, 				c3; {PC = low word V address of Dst}			MAR _ [rhS, S - 1], 			c1; {Point to Src array}			FloatNop, CANCELBR[$, 2],		c2;			Q _ MD, 				c3; {Q = high word V address of Src}		MAR _ [rhS, S + 0],			c1;	FloatNop, 				c2;			TT _ MD,				c3; {TT = low word V address of Src}		Rx _ TOS - 1,					c1; {Set up ORGSRCMEMREG, TOS contains COUNTS}		Rx _ Rx LShift1, SE _ 0,			c2; {Rx = (COUNTS - 1) X 2}		FSBK2:	TT _ TT + Rx, CarryBr,				c3;	uNSrcoffset _ TT, BRANCH[PRNC11, PRCR11],	c1;	PRCR11:	Q _ Q + 1, GOTO[FSMG55],			c2;PRNC11:	Noop,						c2;FSMG55:	rhTT _ Q LRot0,					c3;			FSBK3:	Map _ [rhTT, TT + 0], L1 _ L1.FS.NR.0C,		c1; {Map Src address}	urhNSrc _ Q, L0 _ L0.FS.RO.00,			c2; {Must fetch 2 words for each floating point}	rhRx _ Rx _ MD, XRefBr,				c3;		MAR _ Q _ [rhRx, TT + 0], BRANCH[FSCH0, $],	c1, at[L0.FS.RO.00, 10, NRMapFixCallerB2]; {Calculate (last -1) position}	uNSrcoffsetReal _ Q, 				c2;	S _ MD,  					c3;		Rx _ Q, FloatMode.RZ.AI.FAST,		c1;	Q _ rhRx, 				c2;	urhNSrcReal _ Q, 			c3;		 	MAR _ Q _ [rhRx, Rx + 1],		c1;	uFix _ S, BRANCH[$, FXFS1, 1],		c2;FSC2:	TOSH _ MD,				c3;			TT _ TOS - 1, L2 _ L2.FS.FtoS.00,	c1;		TT _ TT RShift1, SE _ 0, 		c2; {TT = (COUNTS - 1)/2}		TT _ TT + PC, CarryBr,			c3;		uNDstoffset _ TT, BRANCH[DNC1, DC1],	c1;	DNC1:	Noop, GOTO[DSTM1],			c2;DC1:	PV _ PV + 1,				c2;DSTM1:	rhTT _ PV LRot0,			c3;			MDST:	Map _ [rhTT, TT + 0], L1 _ L1.FS.NR.0C,	c1; {Map address of Last Dst}	urhNDst _ PV, L0 _ L0.FS.NR.0F, 	c2; {mode must be RZ for FLFixA}	rhRx _ Rx _ MD, XwdDisp,		c3;		MAR _ Q _ [rhRx, TT + 0], DISP2[FSCH1],	c1, at[L0.FS.NR.0F, 10, NRWMapFixCallerB2];	uNDstoffsetReal _ Q,			c2, at[1, 4, FSCH1];	Rx _ rhRx, CALL[FtoS],			c3;	 		rRESLtemp _ rRESL,  			c2, at[L2.FS.FtoS.00, 10, FtoSRet];	urhNDstReal _ Rx, L2 _ L2.FS.FtoS.02,	c3; {Save result in rRESLtemp}			TOS _ TOS - 1, L3 _ L3.SRCMEMREG.00,	c1;	Rx _ uNSrcoffsetReal, CALL[SRCMEMREG],	c2; {Set up floating point number}	rhRx _ 	urhNDstReal, CALL[FtoS],	c3, at[L3.SRCMEMREG.00, 10, SRCMEMREGRet];	FSIL:	L2 _ L2.FS.FtoS.02, CALL[DSTMEMREG],	c1; {Inner loop}		Rx _ uNSrcoffsetReal, CALL[SRCMEMREG],	c2, at[L3.SRCMEMREG.01, 10, DSTMEMREGRet];	rhRx _ 	urhNDstReal, CALL[FtoS],	c3, at[L3.SRCMEMREG.01, 10, SRCMEMREGRet];		FSILE:	rRESL _ rRESL LRot8,				c2, at[L2.FS.FtoS.02, 10, FtoSRet];	Rx _ uNDstoffsetReal, L2 _ L2.FS.FtoS.03,	c3;				MAR _ [rhRx, Rx + 0], L3 _ L3.SRCMEMREG.02,	c1; {Store in Dst}	MDR _ rRESLtemp or rRESL,			c2; {Compact the result}	TOS _ TOS - 1, ZeroBr,				c3; {Decrement counter}		uTOS _ TOS, BRANCH[$, FSEX0],		c1; {uTOS is updated every 2 counts}	Rx _ uNSrcoffsetReal, CALL[SRCMEMREG],	c2;	CALL[FtoS],				c3, at[L3.SRCMEMREG.02, 10, SRCMEMREGRet];		TOS _ TOS - 1, L3 _ L3.SRCMEMREG.01,	c2, at[L2.FS.FtoS.03, 10, FtoSRet];	rRESLtemp _ rRESL, GOTO[FSIL],		c3;{========================================================================Conversion========================================================================}	FtoS:	FloatAB _ uFix, FLFixA,	c1;		FloatAB _ TOSH LRot0,	c2;		FloatStartFlow,		c3;			uRx _ Rx,		c1;		Noop,			c2;	Noop,			c3;		Noop,			c1;		FloatUnloadS, Float.M,	c2; {unload MS word}	FloatUnloadS, Float.L,	c3; {unload LS word}		rSTATUS _ PPort,	c1; {store MS word of result}	rRESM _ FloatResult, 	c2; {read status}	rRESL _ FloatResult, 	c3; {LS word}			Xbus _ rRESM LRot8, XDisp,			c1; {Check sign bit}	Ybus _ rRESM, ZeroBr, DISP4[FSRSF, 0E], 	c2; {If 0, check further}					  		    {If 1, force low word to 0}							    	rRESL _ 0, CANCELBR[$],	L2Disp,	c3, at[0F, 10, FSRSF];		FSOK2:	Rx _ uRx, RET[FtoSRet],		c1;								    								   	Rx _ uRx, BRANCH[FSLF0, FSMG0],	c3, at[0E, 10, FSRSF];FSLF0:	rRESL _ 0FF, 			c1; {Force low word to 0FF}	Noop,				c2;	L2Disp,	GOTO[FSOK2],		c3;		FSMG0:	TT _ rRESL and ~0FF,		c1;	Ybus _ TT, ZeroBr, 		c2;		BRANCH[FC255, FSOK1], L2Disp,	c3;	FC255:	rRESL _ 0FF, RET[FtoSRet], 	c1; {Force low word to 0FF}	FSOK1:	RET[FtoSRet],			c1;{========================================================================DSTMEMREG========================================================================}DSTMEMREG:	rhRx _ 	urhNDstReal,		c2;	Rx _ uNDstoffsetReal,		c3;		MAR _ Rx _ [rhRx, Rx - 1],	c1; {Set up Dst address}	TOSH _ Rx, BRANCH[$, FSFX0, 1],	c2;	DSMG3:	Q _ rhRx,			c3;	urhNDstReal _ Q,		c1; {The real address of Dst is decremented by 2 each time}	uNDstoffsetReal _ Rx,		c2;	L3Disp,				c3;		RET[DSTMEMREGRet],		c1;			{========================================================================SRCMEMREG========================================================================This subroutine fetch 32 bits floating point number}SRCMEMREG:			rhRx _ urhNSrcReal,		c3;			MAR _ Rx _ [rhRx, Rx - 1],	c1;	TOSH _ Rx, BRANCH[$, FSFX1, 1],	c2;SRCT1:	TOSH _ MD,			c3;		MAR _ Rx _ [rhRx, Rx - 1],	c1;	Q _ Rx, BRANCH[$, FSFX2, 1],	c2;SRCT2:	Q _ MD,				c3;	uFix _ Q,			c1;	Q _ rhRx,			c2;	urhNSrcReal _ Q,		c3; {Update the real address}				uNSrcoffsetReal _ Rx, L3Disp,	c1; {The real address of Src is decremented by 2 each time}	RET[SRCMEMREGRet],		c2;	{================================================================================================Error cases================================================================================================}FSER0:	PV _ uPVx,		c1;FSER1:	GOTO[ufnX3],		c2;			{================================================================================================Exit points================================================================================================}FSEX0:	TOSH _ smallpl,					c2;	Q _ 4'd, 					c3;	Xbus _ ib, GOTO[RestoreAllRegsAndExitB2],	c1;{========================================================================Remap========================================================================}FSCH0:	CALL[NRLMapFixB2],			c2;	FXFS1:	TT _ uNSrcoffset,			c3;		Rx _ 0FF + 1,				c1;	TT _ TT + Rx, CarryBr,			c2;	Rx _ urhNSrc, BRANCH[SNC1, SC1],	c3;	 SNC1:	Noop, GOTO[SRMG1],	c1;SC1:	Rx _ Rx + 1,		c1;SRMG1:	rhTT _ Rx LRot0,	c2;	L0 _ L0.FS.RO.01,	c3;		Map _ [rhTT, TT + 0], 	c1;	L1 _ L1.FS.NR.0C,	c2;	rhRx _ Rx _ MD, XRefBr,	c3;		MAR _ [rhRx, Q + 0], BRANCH[FSCH3, $],	c1, at[L0.FS.RO.01, 10, NRMapFixCallerB2];	GOTO[FSC2],				c2;FSCH3:	CALL[NRLMapFixB2],			c2;FSFX0:	TT _ uNDstoffset,			c3;		Q _ 0FF + 1,				c1;		TT _ TT - Q, CarryBr,			c2;	Q _ urhNDst, BRANCH[SBR2, SNBR2],	c3;	SNBR2:	Noop, GOTO[SMG03],			c1;SBR2:	Q _ Q - 1,				c1;SMG03:	rhTT _ Q LRot0,				c2;	urhNDst _ Q, L1 _ L1.FS.NR.0C,		c3;				Map _ [rhTT, TT + 0],			c1;	uNDstoffset _ TT, L0 _ L0.FS.NR.0C,	c2;	rhRx _ Rx _ MD, XwdDisp,		c3;		MAR _ Q _ [rhRx, TOSH + 0], DISP2[FSCH6],	c1, at[L0.FS.NR.0C, 10, NRWMapFixCallerB2];	Rx _ Q, GOTO[DSMG3],				c2, at[1, 4, FSCH6];FSFX1:	TT _ uNSrcoffset,			c3;	Q _ 0FF + 1,				c1;		TT _ TT - Q, CarryBr,			c2;	Q _ urhNSrc, BRANCH[SBR1, SNBR1],	c3;	SNBR1:	Noop, GOTO[SMG02],		c1;SBR1:	Q _ Q - 1,			c1;SMG02:	rhTT _ Q LRot0,			c2;	urhNSrc _ Q, L0 _ L0.FS.RO.02,	c3;				Map _ [rhTT, TT + 0],			c1;	uNSrcoffset _ TT, L1 _ L1.FS.NR.0C,	c2;	rhRx _ Rx _ MD, XRefBr,			c3;		MAR _ Q _ [rhRx, TOSH + 0], BRANCH[FSCH66, $],	c1, at[L0.FS.RO.02, 10, NRMapFixCallerB2];	Rx _ Q, GOTO[SRCT1],				c2;				FSCH66:	CALL[NRLMapFixB2],			c2;		FSFX2:	TT _ uNSrcoffset,			c3;	Rx _ 0FF + 1,				c1;		TT _ TT - Rx, CarryBr,			c2;	Rx _ urhNSrc, BRANCH[SBR3, SNBR3],	c3;	SNBR3:	Noop, GOTO[SMG02],		c1;SBR3:	Rx _ Rx - 1,			c1;SMG04:	rhTT _ Rx LRot0,		c2;	urhNSrc _ Rx, L0 _ L0.FS.RO.03,	c3;				Map _ [rhTT, TT + 0],			c1;	uNSrcoffset _ TT, L1 _ L1.FS.NR.0C,	c2;	rhRx _ Rx _ MD, XRefBr,			c3;		MAR _ Q _ [rhRx, Q + 0], BRANCH[FSCH7, $],	c1, at[L0.FS.RO.03, 10, NRMapFixCallerB2];	Rx _ Q, GOTO[SRCT2],				c2;		FSCH7:	CALL[NRLMapFixB2],				c2;			GOTO[NRWLMapFixB2],	c2, at[0, 4, FSCH6];	GOTO[NRWLMapFixB2],	c2, at[2, 4, FSCH6];	GOTO[NRWLMapFixB2],	c2, at[3, 4, FSCH6];	GOTO[NRWLMapFixB2],	c2, at[0, 4, FSCH1];	GOTO[NRWLMapFixB2],	c2, at[2, 4, FSCH1];	GOTO[NRWLMapFixB2],	c2, at[3, 4, FSCH1];		Q _ 0, GOTO[RestoreAllRegsAndPFB2],	c1, at[L1.FS.NR.0C, 10, NTrapFixesB2];					{END}