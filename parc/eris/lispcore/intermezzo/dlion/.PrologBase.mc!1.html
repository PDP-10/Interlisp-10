<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Intermezzo>dlion>PrologBase.mc!1</title>
  </head>
  <body>
    <pre>
{	PrologBase.mcby don:  16-Apr-85 14:49:02}{	Refill }{PHILOSOPHY:PC is kept pointing to the last word fetched into IB, which is essentially PC + 1 {in words}.  This is not always true during refill, and must be kept track of carefully.	2 byte refill:		IB &larr; [PC &larr; PC + 1], AlwaysIBDisp	4 byte refill:		IB &larr; [PC &larr; PC + 1],		IB &larr; [PC &larr; PC + 1], AlwaysIBDisp	6 byte refill:		IB &larr; [PC &larr; PC + 2],		IB &larr; [PC &larr; PC + 1], AlwaysIBDisp}{	moved to Prolog.dfnSet[L0.PC2, 1],{if PF then PC is + 0, VPC is + 0}Set[L0.PC4a, 3],{if PF then PC is + 0, VPC is + 0}Set[L0.PC4b, 4],{if PF then PC is + 1, VPC is + 1}Set[L0.PCcont, 7],{if PF then PC is + 0, VPC is + 0}{the following values are used when returning to Lisp}Set[L1.PrDebugSS, 1],Set[L1.PrInt, 2],Set[L1.PrDebugC, 3],Set[L1.PrPF, 4],Set[L1.PrUI, 5],}{	there are specific entry points to refill for 2, 4, 6 byte ops }{	last c3 contained:  "L3Disp, MesaIntBr, " }{--------------------------------------------------------------------}Pr2Refill:	MAR &larr; PC &larr; [rhPC, PC + 1], BRANCH[Pr2RefillC2, PrologExit2{PC-0}],	c1;Pr2RefillC2:	AlwaysIBDisp, L2Disp, BRANCH[$, PrbumpPC2, 1],	c2;PrRemap2C3:	IB &larr; MD, DISPNI[PrologOpTable],	c3;PrbumpPC2:	TT &larr; upVPClo, CANCELBR[$],	c3;	Q &larr; 0FF + 1, L0 &larr; L0.PC2,	c1;	TT &larr; TT + Q, CarryBr, GOTO[PrBumpCom],	c2;PrBumpCom:	Q &larr; rhTT &larr; upVPChi, BRANCH[PrPCMap, PrincrhTT],	c3;PrincrhTT:	Q &larr; Q + 1,	c1;	upVPChi &larr; Q,	c2;	rhTT &larr; Q LRot0, GOTO[PrPCMap],	c3;PrPCMap:	Map &larr; MAR &larr; TT &larr; [rhTT, PC + 0],	c1;{move low 8 bits of PC to TT}	upVPClo &larr; TT, L0Disp,	c2;	PC &larr; rhPC &larr; MD, XRefBr, DISP4[PrRMapFixret],	c3;	MAR &larr; Q &larr; [rhPC, TT + 0], BRANCH[remapPC2, $],	c1, at[L0.PC2, 10, PrRMapFixret];{move all 16 bits of PC from PC and TT to Q}	PC &larr; Q, AlwaysIBDisp, L2Disp, GOTO[PrRemap2C3],	c2;{restore PC}remapPC2:	Rx &larr; PC, GOTO[PrRMapFix],	c2;{--------------------------------------------------------------------}Pr4Refill:	MAR &larr; PC &larr; [rhPC, PC + 1], BRANCH[Pr4RefillC2, PrologExit4],	c1;Pr4RefillC2:	BRANCH[$, PrbumpPC4a, 1],	c2;Pr4RefillC3a:	IB &larr; MD,	c3;PrSecondIBFetch:	MAR &larr; PC &larr; [rhPC, PC + 1], IBPtr &larr; 0,	c1;	AlwaysIBDisp, L2Disp, BRANCH[$, PrbumpPC4b, 1],	c2;Pr4RefillC3b:	IB &larr; MD, DISPNI[PrologOpTable],	c3;PrbumpPC4a:	TT &larr; upVPClo, L0 &larr; L0.PC4a, CANCELBR[$],	c3;	Q &larr; 0FF + 1,	c1;	TT &larr; TT + Q, CarryBr, GOTO[PrBumpCom],	c2;	MAR &larr; Q &larr; [rhPC, TT + 0], BRANCH[remapPC4a, $]	c1, at[L0.PC4a, 10, PrRMapFixret];	PC &larr; Q, GOTO[Pr4RefillC3a],	c2;remapPC4a:	Rx &larr; PC, GOTO[PrRMapFix],	c2;PrbumpPC4b:	TT &larr; upVPClo, CANCELBR[$],	c3;	Q &larr; 0FF + 1, L0 &larr; L0.PC4b,	c1;	TT &larr; TT + Q, CarryBr, GOTO[PrBumpCom],	c2;	MAR &larr; [rhPC, TT + 0], BRANCH[remapPC4b, $]	c1, at[L0.PC4b, 10, PrRMapFixret];	PC &larr; Q, AlwaysIBDisp, L2Disp, GOTO[Pr4RefillC3b],	c2;remapPC4b:	Rx &larr; PC, GOTO[PrRMapFix],	c2;{--------------------------------------------------------------------}Pr6Refill:	MAR &larr; PC &larr; [rhPC, PC + 2], BRANCH[Pr4RefillC2, PrologExit4],	c1;{--------------------------------------------------------------------}{	Refill Exits }{	come here if Interrupt or DebugMode}{	there is a pending page cross branch to handle }PrologExit2:	{PC is + 1, and VPC is correct }	TT &larr; upVPClo, CANCELBR[$, 2],	c2;{ignore PageCross}Prvpcok:	PC &larr; PC - 1, GOTO[PrSaveVPC],	c3;PrologExit4:	{there is a pending page cross branch to handle }	{PC is + 0, and VPC is - 1 }	TT &larr; upVPClo, BRANCH[PrExPCok, PrExPgCr, 1],	c2;PrExPCok:	GOTO[PrSaveVPC],	c3;PrExPgCr:	{add 1 to VPC}	Q &larr; 0FF + 1,	c3;	TT &larr; TT + Q, CarryBr,	c1;	upVPClo &larr; TT, BRANCH[$, PrfixPChi],	c2;	GOTO[PrSaveVPC],	c3;PrfixPChi:	Q &larr; upVPChi,	c3;	Q &larr; Q + 1,	c1;	upVPChi &larr; Q,	c2;	GOTO[PrSaveVPC],	c3;PrSaveVPC:	MAR &larr; TT &larr; [TT, PC + 0],	c1;{byte merge}	upVPClo &larr; TT,	c2;	GOTO[VerifyPrologExit],	c3;VerifyPrologExit:	Q &larr; upDebug, L1 &larr; L1.PrDebugSS,	c1;	Ybus &larr; Q - 2, CarryBr,	c2;	BRANCH[PrDebugSS, PrNotDebugSS],	c3;PrDebugSS:	{save Prolog state and perform Lisp IBDisp}	GOTO[SavePrologC2],	c1;PrNotDebugSS:	MesaIntBr, L1 &larr; L1.PrInt,	c1;	BRANCH[PrNoInt, PrInt],	c2;PrInt:	Ybus &larr; uWDC, NZeroBr, BRANCH[PrNointc1, $],	c3;	Ybus &larr; uWP, ZeroBr, BRANCH[$, PrNointc2],	c1;	uWP &larr; 0, BRANCH[PrIntNow, PrNointc3],	c2;PrIntNow:	ClrIntErr, Rx &larr; 1, CANCELBR[SavePrologC1],	c3;PrInttoLisp:	,	c1;	uWDC &larr; Rx,{off interrupts}	c2;	Rx &larr;  KbdFXP, GOTO[SavePrologC1],	c3;PrNoInt:	GOTO[PrNointc1],	c3;PrNointc3:	ClrIntErr, GOTO[PrNointc1],	c3;PrNointc1:	CANCELBR[PrNointc2],	c1;PrNointc2:	CANCELBR[$],	c2;	,	c3;	Ybus &larr; Q, ZeroBr, L1 &larr; L1.PrDebugC,	c1;	BRANCH[PrDebugC, PrNoDebug],	c2;PrDebugC:	{save Prolog state and GOTO[PrologOpDisp]}	GOTO[SavePrologC1],	c3;PrNoDebug:	{redo PrRefill - no reason to stop - PC is ok}	,	c3;	,	c1;	TT &larr; upVPClo,	c2;	rhTT &larr; upVPChi,	c3;	Map &larr; MAR &larr; TT &larr; [rhTT, PC + 0], L0 &larr; L0.PCcont,	c1;PrPCcont:	L0Disp,	c2;	PC &larr; rhPC &larr; MD, XRefBr, DISP4[PrRMapFixret],	c3;	MAR &larr; Q &larr; [rhPC, TT + 0], BRANCH[remapPCcont, $],	c1, at[L0.PCcont, 10, PrRMapFixret];	PC &larr; Q,	c2;	IB &larr; MD,	c3;	MAR &larr; PC &larr; [rhPC, PC + 1], IBPtr &larr; 0,	c1;	AlwaysIBDisp, L2Disp, BRANCH[Pr4RefillC3b, PrbumpPC4b, 1],	c2;remapPCcont:	Rx &larr; PC, GOTO[PrRMapFix],	c2;UI3:	,	c3;UI1:	,	c1;UI2:	{standard entry point for UI's}	{PC is + 1 and VPC is + 1 }	PC &larr; PC - 1, PgCarryBr, L1 &larr; L1.PrUI,	c2;	TT &larr; upVPClo, BRANCH[$, PrSaveVPCforUI],	c3;	TT &larr; TT and ~0FF,	c1;	,	c2;	,	c3;PrPCdecCont:	TT &larr; TT - 1, CarryBr,	c1;	upVPClo &larr; TT, BRANCH[PrfixdecPChi, $],	c2;	GOTO[PrSaveVPCforUI],	c3;PrfixdecPChi:	Q &larr; upVPChi,	c3;	Q &larr; Q - 1,	c1;	upVPChi &larr; Q,	c2;	GOTO[PrSaveVPCforUI],	c3;PrSaveVPCforUI:	MAR &larr; TT &larr; [TT, PC + 0],	c1;{byte merge}	upVPClo &larr; TT, GOTO[SavePrologC3],	c2;{	SAVE PROLOG REGISTERS }{	PC has been saved to upVPChi and upVPClo	L1 has been set with the type of exit	BB to uprhB and upB	TR to uprhTR and upTR	H to uprhHH and upHH	S to uprhSS and upSS	A1 to upA1hi and upA1lo	A2 to upA2hi and upA2lo	A3 to upA3hi and upA3lo	A4 to upA4hi and upA4lo	{L2 {Write-Mode} to upWriteMode -- done whenever Write-Mode changes}}SavePrologC1:	,	c1;SavePrologC2:	,	c2;SavePrologC3:	upB &larr; BB,	c3;	Q &larr; rhBB,	c1;	uprhB &larr; Q,	c2;	upCC &larr;CC,	c3;	Q &larr; rhCC,	c1;	uprhCC &larr; Q,	c2;	upHH &larr; HH,	c3;	Q &larr; rhHH,	c1;	uprhHH &larr; Q,	c2;	upSS &larr; SS,	c3;	Q &larr; rhSS,	c1;	uprhSS &larr; Q,	c2;	Q &larr; upPRA4hi,	c3;	upA4hi &larr; Q,	c1;	Q &larr; upPRA4lo,	c2;	upA4lo &larr; Q,	c3;	Q &larr; upPRA1hi,	c1;	upA1hi &larr; Q,	c2;	Q &larr; upPRA1lo,	c3;	upA1lo &larr; Q,	c1;	Q &larr; upPRA2hi,	c2;	upA2hi &larr; Q,	c3;	Q &larr; upPRA2lo,	c1;	upA2lo &larr; Q,	c2;	Q &larr; upPRA3hi,	c3;	upA3hi &larr; Q,	c1;	Q &larr; upPRA3lo,	c2;	upA3lo &larr; Q,	c3;SavePrologEnd:	Bank &larr; EmuBank,	c1;	,	c2;	CROSS[PrologToLisp],	c3;{--------------------------------------------------------------}{	entry from Lisp	restore regs and L2, and L3 do PC fetch and PrologIBDisp}	at[LispToProlog],	BB &larr; upB,	c1;	rhBB &larr; uprhB,	c2;	CC &larr; upCC,	c3;	rhCC &larr;uprhCC,	c1;	HH &larr; upHH,	c2;	rhHH &larr; uprhHH,	c3;	SS &larr; upSS,	c1;	rhSS &larr;uprhSS,	c2;	Q &larr; upA4hi,	c3;	upPRA4hi &larr; Q,	c1;	Q &larr; upA4lo,	c2;	upPRA4lo &larr; Q,	c3;	Q &larr; upA1hi,	c1;	upPRA1hi &larr; Q,	c2;	Q &larr; upPRA1lo,	c3;	upA1lo &larr; Q,	c1;	Q &larr; upA2hi,	c2;	upPRA2hi &larr; Q,	c3;	Q &larr; upA2lo,	c1;	upPRA2lo &larr; Q,	c2;	Q &larr; upA3hi,	c3;	upPRA3hi &larr; Q,	c1;	Q &larr; upA3lo,	c2;	upPRA3lo &larr; Q,	c3;	Ybus &larr; upDebug, NZeroBr,	c1;	BRANCH[LPrDB0, LPrDB1], L3 &larr; 0,	c2;{set L3 to 1 if Debug not zero}LPrDB0:	GOTO[RestorePrologEnd],	c3;LPrDB1:	GOTO[RestorePrologEnd],	c3;RestorePrologEnd:	Ybus &larr; upWriteMode, NZeroBr,	c1;	TT &larr; upVPClo, BRANCH[LPrWM0, LPrWM1], L2 &larr; 0,	c2;LPrWM0:	rhTT &larr; upVPChi, GOTO[startprologpcfetch],	c3;LPrWM1:	rhTT &larr; upVPChi, GOTO[startprologpcfetch],	c3;startprologpcfetch:	Map &larr; [rhTT, TT], L0 &larr; L0.PCcont, GOTO[PrPCcont],	c1;{--------------------------------------------------------------}{	Read Map Update Routine}{	returns thru L0 }PrRMapFix:	PC &larr; Q,	c3;	,	c1;	,	c2;PrRMapFixNorm:	Xbus &larr; Rx LRot0, XwdDisp,	c3;	Map &larr; [rhTT,TT], DISP2[PrRFixFlags],	c1;	MDR &larr; Rx or 10, L0Disp, GOTO[PrReRead],	c2, at[0, 4, PrRFixFlags];	MDR &larr; Rx or 10, L0Disp, GOTO[PrReRead],	c2, at[1, 4, PrRFixFlags];	MDR &larr; Rx or 10, L0Disp, GOTO[PrReRead],	c2, at[2, 4, PrRFixFlags];	GOTO[PrRWTrap], L1 &larr; L1.PrPF,	c2, at[3, 4, PrRFixFlags];PrReRead:	Xbus &larr; 1, XDisp, RET[PrRMapFixret],	c3;PrRWTrap:	{L0 indicates current state of PC	if L0 is odd, then PC is + 0, VPC is + 0	if L0 is even, then PC is + 1, VPC is + 1}	{rebuild correct PC and goto SaveProlog}	L0Disp,	c3;	BRANCH[PrPFdecPC, PrPCstate0, 0E],	c1;PrPCstate0:	GOTO[SavePrologC3],	c2;PrPFdecPC:	Rx &larr; upVPClo, L1 &larr; L1.PrPF,	c2;	,	c3;	MAR &larr; Rx &larr; [Rx, PC + 0],	c1;{byte merge}	PC &larr; Rx - 1, CarryBr,	c2;	upVPClo &larr; PC, BRANCH[PrfixPChigh, $],	c3;	GOTO[SavePrologC2],	c1;PrfixPChigh:	Q &larr; upVPChi,	c1;	Q &larr; Q - 1,	c2;	upVPChi &larr; Q, GOTO[SavePrologC1],	c3;{--------------------------------------------------------------}	{ E N D }</pre>
  </body>
</html>
