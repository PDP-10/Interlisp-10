{	PrologBase.mcby don:  16-Apr-85 14:49:02}{	Refill }{PHILOSOPHY:PC is kept pointing to the last word fetched into IB, which is essentially PC + 1 {in words}.  This is not always true during refill, and must be kept track of carefully.	2 byte refill:		IB _ [PC _ PC + 1], AlwaysIBDisp	4 byte refill:		IB _ [PC _ PC + 1],		IB _ [PC _ PC + 1], AlwaysIBDisp	6 byte refill:		IB _ [PC _ PC + 2],		IB _ [PC _ PC + 1], AlwaysIBDisp}{	moved to Prolog.dfnSet[L0.PC2, 1],{if PF then PC is + 0, VPC is + 0}Set[L0.PC4a, 3],{if PF then PC is + 0, VPC is + 0}Set[L0.PC4b, 4],{if PF then PC is + 1, VPC is + 1}Set[L0.PCcont, 7],{if PF then PC is + 0, VPC is + 0}{the following values are used when returning to Lisp}Set[L1.PrDebugSS, 1],Set[L1.PrInt, 2],Set[L1.PrDebugC, 3],Set[L1.PrPF, 4],Set[L1.PrUI, 5],}{	there are specific entry points to refill for 2, 4, 6 byte ops }{	last c3 contained:  "L3Disp, MesaIntBr, " }{--------------------------------------------------------------------}Pr2Refill:	MAR _ PC _ [rhPC, PC + 1], BRANCH[Pr2RefillC2, PrologExit2{PC-0}],	c1;Pr2RefillC2:	AlwaysIBDisp, L2Disp, BRANCH[$, PrbumpPC2, 1],	c2;PrRemap2C3:	IB _ MD, DISPNI[PrologOpTable],	c3;PrbumpPC2:	TT _ upVPClo, CANCELBR[$],	c3;	Q _ 0FF + 1, L0 _ L0.PC2,	c1;	TT _ TT + Q, CarryBr, GOTO[PrBumpCom],	c2;PrBumpCom:	Q _ rhTT _ upVPChi, BRANCH[PrPCMap, PrincrhTT],	c3;PrincrhTT:	Q _ Q + 1,	c1;	upVPChi _ Q,	c2;	rhTT _ Q LRot0, GOTO[PrPCMap],	c3;PrPCMap:	Map _ MAR _ TT _ [rhTT, PC + 0],	c1;{move low 8 bits of PC to TT}	upVPClo _ TT, L0Disp,	c2;	PC _ rhPC _ MD, XRefBr, DISP4[PrRMapFixret],	c3;	MAR _ Q _ [rhPC, TT + 0], BRANCH[remapPC2, $],	c1, at[L0.PC2, 10, PrRMapFixret];{move all 16 bits of PC from PC and TT to Q}	PC _ Q, AlwaysIBDisp, L2Disp, GOTO[PrRemap2C3],	c2;{restore PC}remapPC2:	Rx _ PC, GOTO[PrRMapFix],	c2;{--------------------------------------------------------------------}Pr4Refill:	MAR _ PC _ [rhPC, PC + 1], BRANCH[Pr4RefillC2, PrologExit4],	c1;Pr4RefillC2:	BRANCH[$, PrbumpPC4a, 1],	c2;Pr4RefillC3a:	IB _ MD,	c3;PrSecondIBFetch:	MAR _ PC _ [rhPC, PC + 1], IBPtr _ 0,	c1;	AlwaysIBDisp, L2Disp, BRANCH[$, PrbumpPC4b, 1],	c2;Pr4RefillC3b:	IB _ MD, DISPNI[PrologOpTable],	c3;PrbumpPC4a:	TT _ upVPClo, L0 _ L0.PC4a, CANCELBR[$],	c3;	Q _ 0FF + 1,	c1;	TT _ TT + Q, CarryBr, GOTO[PrBumpCom],	c2;	MAR _ Q _ [rhPC, TT + 0], BRANCH[remapPC4a, $]	c1, at[L0.PC4a, 10, PrRMapFixret];	PC _ Q, GOTO[Pr4RefillC3a],	c2;remapPC4a:	Rx _ PC, GOTO[PrRMapFix],	c2;PrbumpPC4b:	TT _ upVPClo, CANCELBR[$],	c3;	Q _ 0FF + 1, L0 _ L0.PC4b,	c1;	TT _ TT + Q, CarryBr, GOTO[PrBumpCom],	c2;	MAR _ [rhPC, TT + 0], BRANCH[remapPC4b, $]	c1, at[L0.PC4b, 10, PrRMapFixret];	PC _ Q, AlwaysIBDisp, L2Disp, GOTO[Pr4RefillC3b],	c2;remapPC4b:	Rx _ PC, GOTO[PrRMapFix],	c2;{--------------------------------------------------------------------}Pr6Refill:	MAR _ PC _ [rhPC, PC + 2], BRANCH[Pr4RefillC2, PrologExit4],	c1;{--------------------------------------------------------------------}{	Refill Exits }{	come here if Interrupt or DebugMode}{	there is a pending page cross branch to handle }PrologExit2:	{PC is + 1, and VPC is correct }	TT _ upVPClo, CANCELBR[$, 2],	c2;{ignore PageCross}Prvpcok:	PC _ PC - 1, GOTO[PrSaveVPC],	c3;PrologExit4:	{there is a pending page cross branch to handle }	{PC is + 0, and VPC is - 1 }	TT _ upVPClo, BRANCH[PrExPCok, PrExPgCr, 1],	c2;PrExPCok:	GOTO[PrSaveVPC],	c3;PrExPgCr:	{add 1 to VPC}	Q _ 0FF + 1,	c3;	TT _ TT + Q, CarryBr,	c1;	upVPClo _ TT, BRANCH[$, PrfixPChi],	c2;	GOTO[PrSaveVPC],	c3;PrfixPChi:	Q _ upVPChi,	c3;	Q _ Q + 1,	c1;	upVPChi _ Q,	c2;	GOTO[PrSaveVPC],	c3;PrSaveVPC:	MAR _ TT _ [TT, PC + 0],	c1;{byte merge}	upVPClo _ TT,	c2;	GOTO[VerifyPrologExit],	c3;VerifyPrologExit:	Q _ upDebug, L1 _ L1.PrDebugSS,	c1;	Ybus _ Q - 2, CarryBr,	c2;	BRANCH[PrDebugSS, PrNotDebugSS],	c3;PrDebugSS:	{save Prolog state and perform Lisp IBDisp}	GOTO[SavePrologC2],	c1;PrNotDebugSS:	MesaIntBr, L1 _ L1.PrInt,	c1;	BRANCH[PrNoInt, PrInt],	c2;PrInt:	Ybus _ uWDC, NZeroBr, BRANCH[PrNointc1, $],	c3;	Ybus _ uWP, ZeroBr, BRANCH[$, PrNointc2],	c1;	uWP _ 0, BRANCH[PrIntNow, PrNointc3],	c2;PrIntNow:	ClrIntErr, Rx _ 1, CANCELBR[SavePrologC1],	c3;PrInttoLisp:	,	c1;	uWDC _ Rx,{off interrupts}	c2;	Rx _  KbdFXP, GOTO[SavePrologC1],	c3;PrNoInt:	GOTO[PrNointc1],	c3;PrNointc3:	ClrIntErr, GOTO[PrNointc1],	c3;PrNointc1:	CANCELBR[PrNointc2],	c1;PrNointc2:	CANCELBR[$],	c2;	,	c3;	Ybus _ Q, ZeroBr, L1 _ L1.PrDebugC,	c1;	BRANCH[PrDebugC, PrNoDebug],	c2;PrDebugC:	{save Prolog state and GOTO[PrologOpDisp]}	GOTO[SavePrologC1],	c3;PrNoDebug:	{redo PrRefill - no reason to stop - PC is ok}	,	c3;	,	c1;	TT _ upVPClo,	c2;	rhTT _ upVPChi,	c3;	Map _ MAR _ TT _ [rhTT, PC + 0], L0 _ L0.PCcont,	c1;PrPCcont:	L0Disp,	c2;	PC _ rhPC _ MD, XRefBr, DISP4[PrRMapFixret],	c3;	MAR _ Q _ [rhPC, TT + 0], BRANCH[remapPCcont, $],	c1, at[L0.PCcont, 10, PrRMapFixret];	PC _ Q,	c2;	IB _ MD,	c3;	MAR _ PC _ [rhPC, PC + 1], IBPtr _ 0,	c1;	AlwaysIBDisp, L2Disp, BRANCH[Pr4RefillC3b, PrbumpPC4b, 1],	c2;remapPCcont:	Rx _ PC, GOTO[PrRMapFix],	c2;UI3:	,	c3;UI1:	,	c1;UI2:	{standard entry point for UI's}	{PC is + 1 and VPC is + 1 }	PC _ PC - 1, PgCarryBr, L1 _ L1.PrUI,	c2;	TT _ upVPClo, BRANCH[$, PrSaveVPCforUI],	c3;	TT _ TT and ~0FF,	c1;	,	c2;	,	c3;PrPCdecCont:	TT _ TT - 1, CarryBr,	c1;	upVPClo _ TT, BRANCH[PrfixdecPChi, $],	c2;	GOTO[PrSaveVPCforUI],	c3;PrfixdecPChi:	Q _ upVPChi,	c3;	Q _ Q - 1,	c1;	upVPChi _ Q,	c2;	GOTO[PrSaveVPCforUI],	c3;PrSaveVPCforUI:	MAR _ TT _ [TT, PC + 0],	c1;{byte merge}	upVPClo _ TT, GOTO[SavePrologC3],	c2;{	SAVE PROLOG REGISTERS }{	PC has been saved to upVPChi and upVPClo	L1 has been set with the type of exit	BB to uprhB and upB	TR to uprhTR and upTR	H to uprhHH and upHH	S to uprhSS and upSS	A1 to upA1hi and upA1lo	A2 to upA2hi and upA2lo	A3 to upA3hi and upA3lo	A4 to upA4hi and upA4lo	{L2 {Write-Mode} to upWriteMode -- done whenever Write-Mode changes}}SavePrologC1:	,	c1;SavePrologC2:	,	c2;SavePrologC3:	upB _ BB,	c3;	Q _ rhBB,	c1;	uprhB _ Q,	c2;	upCC _CC,	c3;	Q _ rhCC,	c1;	uprhCC _ Q,	c2;	upHH _ HH,	c3;	Q _ rhHH,	c1;	uprhHH _ Q,	c2;	upSS _ SS,	c3;	Q _ rhSS,	c1;	uprhSS _ Q,	c2;	Q _ upPRA4hi,	c3;	upA4hi _ Q,	c1;	Q _ upPRA4lo,	c2;	upA4lo _ Q,	c3;	Q _ upPRA1hi,	c1;	upA1hi _ Q,	c2;	Q _ upPRA1lo,	c3;	upA1lo _ Q,	c1;	Q _ upPRA2hi,	c2;	upA2hi _ Q,	c3;	Q _ upPRA2lo,	c1;	upA2lo _ Q,	c2;	Q _ upPRA3hi,	c3;	upA3hi _ Q,	c1;	Q _ upPRA3lo,	c2;	upA3lo _ Q,	c3;SavePrologEnd:	Bank _ EmuBank,	c1;	,	c2;	CROSS[PrologToLisp],	c3;{--------------------------------------------------------------}{	entry from Lisp	restore regs and L2, and L3 do PC fetch and PrologIBDisp}	at[LispToProlog],	BB _ upB,	c1;	rhBB _ uprhB,	c2;	CC _ upCC,	c3;	rhCC _uprhCC,	c1;	HH _ upHH,	c2;	rhHH _ uprhHH,	c3;	SS _ upSS,	c1;	rhSS _uprhSS,	c2;	Q _ upA4hi,	c3;	upPRA4hi _ Q,	c1;	Q _ upA4lo,	c2;	upPRA4lo _ Q,	c3;	Q _ upA1hi,	c1;	upPRA1hi _ Q,	c2;	Q _ upPRA1lo,	c3;	upA1lo _ Q,	c1;	Q _ upA2hi,	c2;	upPRA2hi _ Q,	c3;	Q _ upA2lo,	c1;	upPRA2lo _ Q,	c2;	Q _ upA3hi,	c3;	upPRA3hi _ Q,	c1;	Q _ upA3lo,	c2;	upPRA3lo _ Q,	c3;	Ybus _ upDebug, NZeroBr,	c1;	BRANCH[LPrDB0, LPrDB1], L3 _ 0,	c2;{set L3 to 1 if Debug not zero}LPrDB0:	GOTO[RestorePrologEnd],	c3;LPrDB1:	GOTO[RestorePrologEnd],	c3;RestorePrologEnd:	Ybus _ upWriteMode, NZeroBr,	c1;	TT _ upVPClo, BRANCH[LPrWM0, LPrWM1], L2 _ 0,	c2;LPrWM0:	rhTT _ upVPChi, GOTO[startprologpcfetch],	c3;LPrWM1:	rhTT _ upVPChi, GOTO[startprologpcfetch],	c3;startprologpcfetch:	Map _ [rhTT, TT], L0 _ L0.PCcont, GOTO[PrPCcont],	c1;{--------------------------------------------------------------}{	Read Map Update Routine}{	returns thru L0 }PrRMapFix:	PC _ Q,	c3;	,	c1;	,	c2;PrRMapFixNorm:	Xbus _ Rx LRot0, XwdDisp,	c3;	Map _ [rhTT,TT], DISP2[PrRFixFlags],	c1;	MDR _ Rx or 10, L0Disp, GOTO[PrReRead],	c2, at[0, 4, PrRFixFlags];	MDR _ Rx or 10, L0Disp, GOTO[PrReRead],	c2, at[1, 4, PrRFixFlags];	MDR _ Rx or 10, L0Disp, GOTO[PrReRead],	c2, at[2, 4, PrRFixFlags];	GOTO[PrRWTrap], L1 _ L1.PrPF,	c2, at[3, 4, PrRFixFlags];PrReRead:	Xbus _ 1, XDisp, RET[PrRMapFixret],	c3;PrRWTrap:	{L0 indicates current state of PC	if L0 is odd, then PC is + 0, VPC is + 0	if L0 is even, then PC is + 1, VPC is + 1}	{rebuild correct PC and goto SaveProlog}	L0Disp,	c3;	BRANCH[PrPFdecPC, PrPCstate0, 0E],	c1;PrPCstate0:	GOTO[SavePrologC3],	c2;PrPFdecPC:	Rx _ upVPClo, L1 _ L1.PrPF,	c2;	,	c3;	MAR _ Rx _ [Rx, PC + 0],	c1;{byte merge}	PC _ Rx - 1, CarryBr,	c2;	upVPClo _ PC, BRANCH[PrfixPChigh, $],	c3;	GOTO[SavePrologC2],	c1;PrfixPChigh:	Q _ upVPChi,	c1;	Q _ Q - 1,	c2;	upVPChi _ Q, GOTO[SavePrologC1],	c3;{--------------------------------------------------------------}	{ E N D }