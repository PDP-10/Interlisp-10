{File name TripleCheck.mcDescription:  DandeLion InterLisp Emulator TripleCheckCharnley  15-Jan-85 10:29:44  Created}{	uses opcode 373'b  alpha = 5  ( FLOATARRAY2 5)}{	called   (TRIPLECHECK Src1 Src2 Src3 WCount)	if WCount = 0 then return( NIL )	loop:	if NOT( [Src1 + WCount - 1] = [Src2 + WCount - 1] = [Src3 + WCount - 1] ) then WCount _ WCount - 1, loop	return( WCount )}{Set[L2.Triple, 5];Set[L0.trS2i, 1];Set[L0.trS1i, 2];Set[L0.trDi, 3];Set[L0.trS2, 4];Set[L0.trS1, 5];Set[L0.trD, 6];}	GOTO[FLOATARRAYPREP],	c3, at[L2.Triple, 10, FOP2Disp];{Triple}{	has already saved		uTOSH _ TOSH		uTOS _ TOS	saves regs:		uS _ S		uPVx _ PV		uPC _ PC		urhS _ rhS		urhPV _ rhPV	gets stk-1, stk-2, stk-3		stk-3 (first arg)			uS2Hi, uS2Lo		stk-2 (second arg)			uS1Hi, uS1Lo		stk-1 (third arg)			uDHi, uDLo}		at[L2.Triple, 10, LFAop],{FOP2 = Triple}	Q _ TOS - 1, L1 _ L1.RestoreTosB2,	c1;	TT _ uS2Lo,	c2;	TT _ TT + Q, CarryBr,	c3;	uS2Lo _ TT, BRANCH[$, trfixS2hi],	c1;trS2:	TT _ uS1Lo,	c2;	TT _ TT + Q, CarryBr,	c3;	uS1Lo _ TT, BRANCH[$, trfixS1hi],	c1;trS1:	TT _ uDLo,	c2;	TT _ TT + Q, CarryBr,	c3;	uDLo _ TT, BRANCH[$, trfixDhi],	c1;trD:	,	c2;	GOTO[TrMapInit],	c3;trfixS2hi:	TT _ uS2Hi,	c2;	TT _ TT + 1,	c3;	uS2Hi _ TT, GOTO[trS2],	c1;trfixS1hi:	TT _ uS1Hi,	c2;	TT _ TT + 1,	c3;	uS1Hi _ TT, GOTO[trS1],	c1;trfixDhi:	TT _ uDHi,	c2;	TT _ TT + 1,	c3;	uDHi _ TT, GOTO[trD],	c1;TrMapInit:	TT _ uS2Hi, L0 _ L0.trS2i,	c1;	rhTT _ TT LRot0,	c2;	TT _ uS2Lo, CALL[TrMap],	c3;	at[L0.trS2i, 10, TrMapRet],	Q _ rhRx,	c1;	rhS2 _ Q LRot0,	c2;	S2 _ Rx,	c3;	MAR _ S2 _ [rhS2, TT + 0],	c1;	,	c2;	Q _ MD,	c3;	UQSave _ Q,	c1;	,	c2;	,	c3;	TT _ uS1Hi, L0 _ L0.trS1i,	c1;	rhTT _ TT LRot0,	c2;	TT _ uS1Lo, CALL[TrMap],	c3;	at[L0.trS1i, 10, TrMapRet],	Q _ rhRx,	c1;	rhS1 _ Q LRot0,	c2;	S1 _ Rx,	c3;	MAR _ S1 _ [rhS1, TT + 0],	c1;	Q _ UQSave,	c2;	Q _MD xor Q,	c3;	,	c1;	Ybus _ Q, ZeroBr,	c2;	BRANCH[TrEarlya, $],	c3;	TT _ uDHi, L0 _ L0.trDi,	c1;	rhTT _ TT LRot0,	c2;	TT _ uDLo, CALL[TrMap],	c3;	at[L0.trDi, 10, TrMapRet],	Q _ rhRx,	c1;	rhD _ Q LRot0,	c2;	D _ Rx,	c3;	MAR _ D _ [rhD, TT + 0],	c1;	Q _ UQSave,	c2;	Q _MD xor Q, GOTO[TrLoopDec],	c3;{	inner loop}TrLoop:	MAR _ S2 _ [rhS2, S2 - 1], L0 _ L0.trS2,	c1;TrMapS2RetX:	Ybus _ Q, ZeroBr, BRANCH[$, TrfixS2, 1],	c2;	Q _ MD, BRANCH[TrEarly2, $],	c3;	MAR _ S1 _ [rhS1, S1 - 1], L0 _ L0.trS1,	c1;TrMapS1RetX:	BRANCH[$, TrfixS1, 1],	c2;	Q _ MD xor Q,	c3;	MAR _ D _ [rhD, D - 1], L0 _ L0.trD,	c1;TrMapDRetX:	Ybus _ Q, ZeroBr, BRANCH[$, TrfixD, 1],	c2;	Q _ MD xor Q, BRANCH[TrEarly1, TrLoop],	c3;TrLoopDec:	TOS _ TOS - 1, ZeroBr,	c1;	uTOS _ TOS, BRANCH[$, TrDone],	c2;	GOTO[TrLoop],	c3;	{Early (mismatch) exits here}TrEarly1:	TOS _ TOS,	c1;	Q _ smallpl,	c2;	uTOSH _ Q, L1 _ L1.LFAexit, GOTO[TrExit],	c3;TrEarly2:	TOS _ TOS + 1,	c1;	Q _ smallpl,	c2;	uTOSH _ Q, L1 _ L1.LFAexit, GOTO[TrExit],	c3;TrEarlya:	TOS _ TOS,	c1;	Q _ smallpl,	c2;	uTOSH _ Q, L1 _ L1.LFAexit, GOTO[TrExit],	c3;TrEarlyc:	,	c3;	TOS _ TOS + 1,	c1;	Q _ smallpl,	c2;	uTOSH _ Q, L1 _ L1.LFAexit, GOTO[TrExit],	c3;TrDone:	,	c3;	Ybus _ Q, ZeroBr,	c1;	BRANCH[TrEarlyc, $],	c2;	uTOSH _ 0, L1 _ L1.LFAexit, GOTO[TrExit],	c3;TrfixS2:	S2 _ rhS2, CANCELBR[$],	c3;	TT _ uS2Lo,	c1;	rhTT _ S2 LRot0,	c2;	CALL[TrMap],	c3;	at[L0.trS2, 10, TrMapRet],	MAR _ S2 _ [rhS2, 0FF + 0], GOTO[TrMapS2RetX],	c1;TrfixS1:	S1 _ rhS1, CANCELBR[$],	c3;	TT _ uS1Lo,	c1;	rhTT _ S1 LRot0,	c2;	CALL[TrMap],	c3;	at[L0.trS1, 10, TrMapRet],	MAR _ S1 _ [rhS1, 0FF + 0], GOTO[TrMapS1RetX],	c1;TrfixD:	D _ rhD, CANCELBR[$],	c3;	TT _ uDLo,	c1;	rhTT _ D LRot0,	c2;	CALL[TrMap],	c3;	at[L0.trD, 10, TrMapRet],	MAR _ D _ [rhD, 0FF + 0], GOTO[TrMapDRetX],	c1;TrMap:	Map _ [rhTT, TT],	c1;	,	c2;	Rx _ rhRx _ MD, XwdDisp,	c3;	Map _ [rhTT,TT], DISP2[TrFixRFlags],	c1;	MDR _ Rx or 10, L0Disp, GOTO[TrReRead],	c2, at[0, 4, TrFixRFlags];	MDR _ Rx or 10, L0Disp, GOTO[TrReRead],	c2, at[1, 4, TrFixRFlags];	MDR _ Rx or 10, L0Disp, GOTO[TrReRead],	c2, at[2, 4, TrFixRFlags];	GOTO[RWTrapB2],	c2, at[3, 4, TrFixRFlags];TrReRead:	RET[TrMapRet],	c3;	{when completed come here for restoring regs}	{set uTOSH to value desired in TOSH}	{set TOS to value desired in TOS}	{when completed, set L1 = L1.LFAexit}TrExit:	Q _ 6{delta stk}, GOTO[LFACommonExit],	c1;	{ E N D }