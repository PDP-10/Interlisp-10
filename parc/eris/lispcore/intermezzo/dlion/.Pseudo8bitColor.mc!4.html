<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Intermezzo>dlion>Pseudo8bitColor.mc!4</title>
  </head>
  <body>
    <pre>
{File : Pseudo8bitColor.mcAuthor : Gwan SantosaDate : 17-Jun-85 18:22:52This program converts certain colors of an 8 bits per pixel bitmap into other colorsThe parameters are :	S - 10	Pointer to color array, page aligned	S - 8	Bitmap	S - 6	X (Left)	S - 4	Y (Bottom)	S - 2	Transfer width	S - 0	Untransfered width (0 on initial call)	TOS	Transfer height	The algorithm :1. Fetch pixel value.2. Use that value as a pointer to color array.3. Replace that pixel with the value of that color array's entry.@PSCLROP:	opcode['b],	Bank &larr; PSCLRBank, 		c1; {This section is in PixelBltB1.mc}	uTOS &larr; TOS,			c2;	uTOSH &larr; TOSH, CROSS[PSCLR],	c3;		at[PSCLR],	Xbus &larr; ibNA, XDisp,		c1; {This section is in PixelBltB2.mc}	DISP4[PSEUDOCLRDISP], 		c2;}Set[L0PSMUL0, 1];Set[L0.PS.NR.00, 00];Set[L0.PS.NR.01, 01];Set[L0.PS.NR.08, 08];Set[L1.PS.NR.01, 01];Set[L1.PS.NR.08, 08];Set[L2PSRET0, 08];Set[L1PSSAVE, 8];RegDef[rPSCArray, R, 4]; {=S}RegDef[rhPSCArray, RH, 4]; {=rhS}RegDef[rPS, R, 3]; {=PV}RegDef[rhPS, RH, 3]; {=rhPV}RegDef[urhPS, U, 38];RegDef[urPS, U, 41];RegDef[uPSXLo, U, 43];RegDef[uPSYLo, U, 19];RegDef[Data88, R, 6]; {=Rx}RegDef[PSCOUNT, R, 1]; {=TOSH}RegDef[PSTMP, R, 0]; {=TOS}RegDef[urSAddr, U, 38]; {tmp, used in PixelBlt}RegDef[urhSAddr, U, 41]; {tmp, used in PixelBlt}RegDef[urDAddr, U, 43]; {tmp, used in PixelBlt}RegDef[urhDAddr, U, 19]; {tmp, used in PixelBlt}RegDef[upixelcount, U, 45]; {tmp, used in PixelBlt}RegDef[uXoffset, U, 46]; {tmp, used in PixelBlt}{RegDef[uSrcflag, U, 47]; {tmp, used in PixelBlt}RegDef[uDstflag, U, 0C]; {tmp, used in PixelBlt}}RegDef[uSrcBITMAPLo, U, 5D]; {tmp, used in PixelBlt}RegDef[uSrcBITMAPHi, U, 19]; {tmp, used in PixelBlt}RegDef[uSrcXLo, U,57]; {tmp, used in PixelBlt}RegDef[uSrcYLo, U,05]; {tmp, used in PixelBlt}RegDef[uDstBITMAPHi, U, 35]; {tmp, used in PixelBlt}RegDef[uDstBITMAPLo, U, 04]; {tmp, used in PixelBlt}RegDef[uDstXLo, U, 26]; {tmp, used in PixelBlt}RegDef[uDstYLo, U, 31]; {tmp, used in PixelBlt}RegDef[uTrnWidthLo, U, 3A]; {tmp, used in PixelBlt}RegDef[uUnTrnWidthLo, U, 5C]; {tmp, used in PixelBlt}RegDef[uTrnHeightLo, U, 0D]; {= uTOS, used in PixelBlt}	uS &larr; S,				c3, at[00, 10, PSEUDOCLRDISP];	PSBK1:	MAR &larr; [rhS, S - 1],					c1; {Point to UnTrnWidthHi}	Ybus &larr; TOSH xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check TrnHeight}	Q &larr; MD, BRANCH[BTER0, $],				c3;		MAR &larr; [rhS, S + 0],		c1; {Point to UnTrnWidthLo}	S &larr; S-2, L1 &larr; L1.NoFixesB2,	c2;	TT &larr; MD,			c3;		MAR &larr; [rhS, S - 1],				c1; {Point to TrnWidthHi}	Ybus &larr; Q xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check UnTrnWidth}	Q &larr; MD, BRANCH[BTER1, $],			c3;		MAR &larr; [rhS, S + 0],		c1; {Point to TrnWidthLo}	S &larr; S-2, L3 &larr; 0,		c2;	Rx &larr; MD,			c3;	Ybus &larr; Q xor smallpl, ZeroBr,			c1; {Check TrnWidth}	uUnTrnWidthLo &larr; TT, ZeroBr, BRANCH[BTER2, $],	c2; {Check UnTrnWidth}	uTrnWidthLo &larr; Rx, ZeroBr, BRANCH[PWNZ, PWZ],	c3; {Check TrnWidth}	PWZ:	BRANCH[GPTR1, PNOTR1],				c1; {In between lines case}GPTR1:	upixelcount &larr; Rx,				c2; {Load number of pixel per line}	uXoffset &larr; 0, GOTO[PNFM],			c3; {X offset = 0}				PWNZ:	upixelcount &larr; TT, BRANCH[GPTR2, PNOTR2],	c1; {Load number of pixel left}GPTR2:	Rx &larr; Rx - TT, NegBr,				c2; {Calculate X offset}	uXoffset &larr; Rx, BRANCH[$, PNOTR3],      		c3; 	PNFM:	MAR &larr; [rhS, S - 1],				c1; {Point to YHi}	uTrnHeightLo &larr; TOS, CANCELBR[$, 2], ZeroBr,	c2; {Check if transfer height is 0}	Q &larr; MD, BRANCH[$, PNOTR4],			c3;		MAR &larr; [rhS, S + 0],				c1; {Point to YLo}	S &larr; S - 2, L2 &larr; L2PSRET0,			c2;	Rx &larr; MD, 					c3;		MAR &larr; [rhS, S - 1], 				c1; {Point to XHi}	Ybus &larr; Q xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check Y}	Q &larr; MD,	BRANCH[PSYE1, $],			c3;		MAR &larr; [rhS, S + 0], 				c1; {Point to XLo}	Ybus &larr; Q xor smallpl, CANCELBR[$, 2], ZeroBr,	c2; {Check X}	TT &larr; MD, BRANCH[PSXE1, $],			c3;		,						c1;	S &larr; S - 2,					c2;	uPSXLo &larr; TT,					c3;		MAR &larr; [rhS, S - 1], 				c1; {Point to BITMAPHi}	uPSYLo &larr; Rx, CANCELBR[$, 2],			c2;	Rx &larr; MD,					c3;	PSBK5:	MAR &larr; [rhS, S + 0],				c1; {Point to BITMAPLo}	S &larr; S + 8, 					c2;	TT &larr; MD, CALL[GetandTestBitMapParams],		c3;		S &larr; S - 10'd,					c3, at[L2PSRET0, 10, GetBitMapParamsRet];		MAR &larr; [rhS, S - 1], 				c1; {Point to ClrArrayHi}	Ybus &larr; Q xor 8, CANCELBR[$, 2], ZeroBr,		c2; {Check if 8 bits per pixel bitmap}	Q &larr; MD,	 BRANCH[PSE00, $],			c3;		MAR &larr; [rhS, S + 0],				c1; {Point to ClrArrayLo}	rhTT &larr; Q LRot0, 				c2; {Set up high VA of color table}	TT &larr; MD,					c3; {Set up low VA of color table}	PSBK6:	Map &larr; [rhTT, TT + 0], L1 &larr; L1.NoFixesB2,	c1;	S &larr; S + 10'd, L0 &larr; L0.PS.NR.00,			c2;	rhRx &larr; Rx &larr; MD, XRefBr,				c3;		BRANCH[PSCH0, $],				c1, at[L0.PS.NR.00, 10, RMapFixCallerB2];	Q &larr; uBITMAPHEIGHT, L1 &larr; L1PSSAVE,		c2; {Save registers}		rhPSCArray &larr; Rx LRot0, CALL[SaveAllRegsB2],	c3; {Load the real address of color table}{==============================================================================================Check boundaries==============================================================================================}PSBK2:	rPSCArray &larr; Rx,			c1, at[L1PSSAVE, 10, SaveRegsB2Ret];	TT &larr; uPSYLo, 			c2; {Check 1st Y}		Ybus &larr; Q - TT - 1, NegBr,	c3;	TT &larr; TOS + TT, BRANCH[$, PSE01],	c1; {TOS = TrnHeight}	Ybus &larr; Q - TT, NegBr,			c2; {Check 2nd Y}	Q &larr; uPSXLo, BRANCH[$, PSE02],		c3; {Load X}		TT &larr; RShift1 uBITMAPWIDTH, SE &larr; 0, 	c1; {Divide Bitmapwidth by 8}	TT &larr; RShift1 TT, SE &larr; 0,		c2;	TT &larr; RShift1 TT, SE &larr; 0,		c3;	Ybus &larr; TT - Q - 1, NegBr,		c1; {Check 1st X}		Rx &larr; uTrnWidthLo, BRANCH[$, PSE03],	c2;		Q &larr; Q + Rx,				c3;		Ybus &larr; TT - Q, NegBr,		c1; {Check 2nd X}	Q &larr; uPSYLo, BRANCH[$, PSE04],	c2;	PSOLP:	Q &larr; Q + TOS,			c3;PSBK3:	Rx &larr; uBITMAPHEIGHT,			c1;	Q &larr; Rx - Q, L0 &larr; L0PSMUL0,		c2;		TOS &larr; uBITMAPRASTERWIDTH, CALL[MTPL],	c3; {Calculate Y*Bitmaprasterwidth}	TOS &larr; uXoffset,			c2, at[L0PSMUL0 , 10, MULCALLER];	Rx &larr; uPSXLo,			c3;		TOS &larr; Rx + TOS,			c1;	Rx &larr; RShift1 TOS, SE &larr; 0,	c2;	Q &larr; Q + Rx, CarryBr, 		c3;		Rx &larr; uBITMAPBASELO, BRANCH[PSNA1, PSA1],	c1;	PSA1:	TT &larr; TT + 1, GOTO[PSMG1],	c2;PSNA1:	Noop,				c2;PSMG1:	Rx &larr; Rx + Q, CarryBr,		c3;	Q &larr; uBITMAPBASEHI, BRANCH[PSNA2, PSA2],	c1;	PSA2:	TT &larr; TT + 1, GOTO[PSMG2],		c2;PSNA2:	Noop,					c2;PSMG2:	Q &larr; TT + Q,				c3;	PSCOUNT &larr; upixelcount, 		c1;	urhPS &larr; Q, L0 &larr; L0.PS.NR.01,	c2;	rhTT &larr; Q LRot0,			c3;		Map &larr; TT &larr; [rhTT, Rx],		c1;	urPS &larr; Rx, L1 &larr; L1.PS.NR.01,	c2;	rhRx &larr; Rx &larr; MD, XwdDisp,	c3;		MAR &larr; Q &larr; [rhRx, TT + 0], DISP2[PSCH11],	c1, at[L0.PS.NR.01, 10, NRWMapFixCallerB2];	rhPS &larr; Rx LRot0,				c2, at[1, 4, PSCH11];	Data88 &larr; MD,					c3;		Ybus &larr; TOS, YDisp,		c1;	rPS &larr; Q, DISP4[PSODDEVEN, 0E],	c2;		GOTO[PSMG4],			c3, at[0E, 10, PSODDEVEN];		PSTMP &larr; Data88 and 0FF,		c3, at[0F, 10, PSODDEVEN];		MAR &larr; [rhPSCArray, PSTMP + 0],	c1;	Data88 &larr; Data88 and ~0FF,	c2;	Q &larr; MD or Data88, GOTO[PSIL2],	c3;PSILP:	MAR &larr; rPS &larr; [rhPS, rPS + 1], BRANCH[$, PSO2],	c1;	BRANCH[$, FXPSA1, 1],				c2;	Data88 &larr; MD,					c3;	PSMG4:	TT &larr; Data88  LRot8,		c1;	Q &larr; TT and 0FF,			c2;	Data88 &larr; Data88 and 0FF,	c3;	PSIL1:	MAR &larr; [rhPSCArray, Q + 0],	c1;	PSCOUNT &larr; PSCOUNT - 1, ZeroBr, 	c2;	PSTMP &larr; MD, BRANCH[$, PSO1],	c3;		MAR &larr; [rhPSCArray, Data88 + 0],	c1;	PSTMP &larr; PSTMP LRot8, 		c2;	Q &larr; MD or PSTMP,		c3;	PSIL2:	MAR &larr; [rhPS, rPS + 0],				c1;	MDR &larr; Q,					c2;	PSCOUNT &larr; PSCOUNT - 1, ZeroBr, GOTO[PSILP],	c3;PSO2:	TOSH &larr; uTOSH, CANCELBR[PSO3, 3],		c2;PSO1:	PSTMP &larr; PSTMP LRot8,		c1;	TOSH &larr; uTOSH,			c2;	Data88 &larr; Data88 or PSTMP,	c3;			MAR &larr; [rhPS, rPS + 0],	c1;	MDR &larr; Data88,		c2;PSO3:	Q &larr; uTrnHeightLo,	c3;			Q &larr; Q - 1, ZeroBr,			c1;	uTrnHeightLo &larr; Q, BRANCH[$, PSEX],	c2;		uXoffset &larr; 0, MesaIntBr,		c3;		Ybus &larr; uWDC, NZeroBr, BRANCH[PSNI1, $],	c1;	Ybus &larr; uWP, ZeroBr, BRANCH[$, PSNI2],	c2;		Q &larr; 0, BRANCH[PSIN, PSNI3],		c3;	PSIN:	rhS &larr; nRhS,		c1;	S &larr; uS,			c2;	PV &larr; uPVx,		c3;		MAR &larr; [rhS, S + 0],	c1;		       	MDR &larr; Q, 		c2;	TOS &larr; uTrnHeightLo,	c3;			Bank &larr; EmuBank,			c1;	uWP &larr; 0,			c2;	rhPV &larr; nRhS, CROSS[EmuInt],	c3;PSNI1:	Q &larr; uTrnWidthLo, CANCELBR[$],	c2;		TOS &larr; uTrnHeightLo,		c3;		upixelcount &larr; Q, 		c1;	Q &larr; uPSYLo, GOTO[PSOLP],	c2;	PSNI2:	CANCELBR[$],			c3;PSNI3:	Q &larr; uTrnWidthLo,  		c1;	TOS &larr; uTrnHeightLo,		c2;	uWP &larr; 0,			c3;		upixelcount &larr; Q, 		c1;	Q &larr; uPSYLo, GOTO[PSOLP],	c2;FXPSA1:	TT &larr; urPS,				c3; {Retrieve original rPS}			Q &larr; 0FF + 1,				c1; {Load Q with 100}	TT &larr; TT + Q, CarryBr,			c2; {Add with 100}		Q &larr; urhPS, BRANCH[PSND1, PSAD1],	c3;	PSAD1:	Q &larr; Q + 1,				c1;	urhPS &larr; Q,				c2;		rhTT &larr; Q LRot0,	GOTO[PSMP1],		c3;		PSND1:	rhTT &larr; Q LRot0,				c1;	urhPS &larr; Q,				c2;	Noop,					c3;	PSMP1:	Map &larr; [rhTT, TT + 0], L1 &larr; L1.PS.NR.08,	c1;	urPS &larr; TT, L0 &larr; L0.PS.NR.08,		c2;	rhRx &larr; Rx &larr; MD, XwdDisp,		c3;		MAR &larr; Q &larr; [rhRx, rPS + 0], DISP2[PSMAP11],	c1, at[L0.PS.NR.08, 10, NRWMapFixCallerB2];	rPS &larr; Q, 					c2, at[1, 4, PSMAP11];	Data88 &larr; MD,					c3;		Q &larr; rhRx,		c1;	rhPS &larr; Q LRot0,		c2;	GOTO[PSMG4],		c3;	S &larr; uS,			c1, at[L1.PS.NR.08, 10, NTrapFixesB2];	rhS &larr; nRhS,		c2;	Noop,			c3;		MAR &larr; [rhS, S + 0],	c1;	MDR &larr; PSCOUNT,		c2;	Q &larr; 0,			c3;		GOTO[RestoreAllRegsAndPFB2],	c1;PSCH0:	CALL[RLMapFixB2],	c2;	S &larr; uS,			c1, at[L1.PS.NR.01 , 10, NTrapFixesB2];	rhS &larr; nRhS,		c2;	Noop,			c3;		MAR &larr; [rhS, S + 0],	c1;	MDR &larr; PSCOUNT,		c2;	Q &larr; 0,			c3;		GOTO[RestoreAllRegsAndPFB2],	c1;		GOTO[NRWLMapFixB2],		c2, at[0, 4, PSMAP11];	GOTO[NRWLMapFixB2],		c2, at[2, 4, PSMAP11];	GOTO[NRWLMapFixB2],		c2, at[3, 4, PSMAP11];	GOTO[NRWLMapFixB2],		c2, at[0, 4, PSCH11];	GOTO[NRWLMapFixB2],		c2, at[2, 4, PSCH11];	GOTO[NRWLMapFixB2],		c2, at[3, 4, PSCH11];{==============================================================================================Exit point==============================================================================================}PSEX:	Q &larr; 12'd,					c3;PSBK4:	Xbus &larr; ib, GOTO[RestoreAllRegsAndExitB2],	c1;{==============================================================================================Error cases==============================================================================================}BTER0:	S &larr; uS, GOTO[ufnX2],		c1;BTER1:	S &larr; uS, GOTO[ufnX2],		c1;BTER2:	S &larr; uS, CANCELBR[ufnX1, 3],	c3;PNOTR1:	S &larr; uS, GOTO[ufnX3],		c2;PNOTR2:	S &larr; uS, GOTO[ufnX3],		c2;PNOTR3:	S &larr; uS, GOTO[ufnX2],		c1;PNOTR4: S &larr; uS, GOTO[ufnX2],		c1;PSYE1:	S &larr; uS, GOTO[ufnX2],		c1;PSXE1:	S &larr; uS, GOTO[ufnX2],		c1;PSE00:	S &larr; uS, GOTO[ufnX2],		c1;PSE01:	S &larr; uS,				c2;	rhS &larr; nRhS, GOTO[ufnX1],	c3;PSE02:	S &larr; uS,				c1;	rhS &larr; nRhS, GOTO[ufnX3],	c2;PSE03:	S &larr; uS,				c3;	rhS &larr; nRhS, GOTO[ufnX2],	c1;PSE04:	S &larr; uS,				c3;	rhS &larr; nRhS, GOTO[ufnX2],	c1;	{END}	</pre>
  </body>
</html>
