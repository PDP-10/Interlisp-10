{File : VECTOROPS.mcAuthor : Gwan SantosaDate :  2-Aug-85 14:11:37This program does the following vector operations :1. Get a pointer to a maximum value of a vector.2. Get a pointer to a minimum value of a vector.3. Get a pointer to an absolute minimum value of a vector.4. Get a pointer to an absolute maximum value of a vector.5. Get sum of vector's elements (not coded yet).Algorithm (for 1 to 4) :	Fetch stack parameters. (TOS = count down counter)	Check counter, if 0, exit.	If 1, exit.	Otherwise :	Initialize current position to 1.	Initialize index to 0.	Fetch 2 floating point numbers from array.	Store the first element into reference register.Inner loop :		Call comparison subroutine.	If TOS is 0, done.	Else :	Update current position	Fetch next element.	Back to Inner loop	Comparison subroutine :	Check if to find absolute extreme.	If yes, convert sign bit to +.	Else :	Compare 2 numbers.	If new extreme is found, update index and reference register.	Return	}{Set[L1.FS.NR.0C, 0C];}Set[L0.VO.RO.04, 04];Set[L0.VO.RO.05, 05];Set[L0.VO.RO.09, 09];Set[L0.VO.RO.0A, 0A];Set[L0.VO.RO.0B, 0B];RegDef[rCOUNT, R, 04]; {=S}RegDef[rRESMN, R, 05]; {=PC}RegDef[uINDEX, U, 42];RegDef[uNEWH, U, 44];RegDef[uMAXH, U, 05];RegDef[uMAXL, U, 56];	Ybus _ TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[0C, 10, ub2op]; {Check if size = NIL}	Ybus _ TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[0D, 10, ub2op]; {Check if size = NIL}	Ybus _ TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[0E, 10, ub2op]; {Check if size = NIL}		Ybus _ TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[0F, 10, ub2op]; {Check if size = NIL}	VOBK1:	TT _ 0FF + 1, BRANCH[VOER1, $],	 	c1; {set PPort to read}	Q _ uPPsave, L1 _ L1.FS.NR.0C,		c2;	PPort _ Q and ~TT, CALL[SaveAllRegsB2],	c3; {Save all registers}		MAR _ [rhS, S - 1],			c1, at[L1.FS.NR.0C, 10, SaveRegsB2Ret];	Ybus _ TOS, ZeroBr, CANCELBR[$, 2],	c2; {Check if size = 0}	Q _ MD, BRANCH[$, VOER0],		c3;		MAR _ [rhS, S + 0],			c1;	TOS _ TOS - 1, ZeroBr,			c2; {check if only 1 entry}	TT _ MD, BRANCH[$, VOEX0],		c3;		rhTT _ Q LRot0,				c1;	FloatNop,				c2;	FloatNop,				c3;	TS101:	Map _ [rhTT, TT + 0], L1 _ L1.FS.NR.0C, c1;	uTT _ TT, L0 _ L0.VO.RO.04, 		c2;	rhRx _ Rx _ MD, XRefBr,			c3;	TS202:	MAR _ Q _ [rhRx, TT + 0], BRANCH[VOCH0, $],	c1, at[L0.VO.RO.04, 10, NRMapFixCallerB2];	Rx _ Q,						c2;	TOSH _ MD,					c3;	TS303:	MAR _ Rx _ [rhRx, Rx + 1], L2 _ 00,	c1; {Get first element and initialize as MAX}	uMAXH _ TOSH, BRANCH[$, FXVO0, 1],	c2;	TOSH _ MD,				c3;			TS404:	MAR _ Rx _ [rhRx, Rx + 1], L2 _ 01,	c1, at[00, 10, FETCHRET];	uMAXL _ TOSH, BRANCH[$, FXVO1, 1],	c2;	TOSH _ MD,				c3;	TS505:	MAR _ Rx _ [rhRx, Rx + 1], L2 _ 02,	c1, at[01, 10, FETCHRET];	uNEWH _ TOSH, BRANCH[$, FXVO2, 1],	c2;	TOSH _ MD,				c3; {Get second element and initialize as NEW}	TS606:	rCOUNT _ 1,					c1, at[02, 10, FETCHRET];	uINDEX _ 0,					c2; {Index keeps track of the latest extreme}	FloatMode.RN.AI.IEEE, FloatFLOW, CALL[VOCP],	c3; {Count keeps track of the current position}{========================================================================================================Inner loop========================================================================================================}		TOS _ TOS - 1, ZeroBr,			c1, at[0, 10, COMPRET]; {TOS is the count down counter}	rCOUNT _ rCOUNT + 1, BRANCH[$, VOEX1],	c2; {If TOS = 0, done}	L2 _ 03,				c3; {Current position (rCOUNT) is updated}		MAR _ Rx _ [rhRx, Rx + 1], 		c1; {Fetch next element}	BRANCH[$, FXVO3, 1],			c2;	TOSH _ MD, 				c3;	MAR _ Rx _ [rhRx, Rx + 1], 		c1, at[03, 10, FETCHRET];	uNEWH _ TOSH, BRANCH[$, FXVO4, 1],	c2;CHRT5:	TOSH _ MD, CALL[VOCP],			c3; {Call comparison subroutine}	{==========================================================================================Compare subroutine==========================================================================================This subroutine handles 4 comparisons.The low 2 bits of ib determines which operation.00 : Find index of max. value.01 : Find index of min. value.10 : Find index of absolute max. value.11 : Find index of absolute min. value.If a new extreme value is found, it will update the index and the new extreme value isloaded into a reference register uMAX}VOCP:	Xbus _ ibNA, XDisp,		c1;	Q _ uMAXH, DISP4[MAXMIN, 0D],	c2;		GOTO[VCOM],			c3, at[0D, 10, MAXMIN];		TT _ ~TT xor TT,		c3, at[0F, 10, MAXMIN];		TT _ RShift1 TT, SE _ 0,	c1; {This section convert the sign bit to +}	Q  _ TT and Q,			c2;	uMAXH _ Q,			c3;		Q _ uNEWH,			c1;	Q _ TT and Q,			c2;	uNEWH _ Q, GOTO[VCOM],		c3;		VCOM:	FloatAB _ uNEWH,		c1;		FloatAB _ TOSH LRot0,		c2;	FloatA _ uMAXH,	FLAMinusB,	c3;		FloatA _ uMAXL,			c1;			FloatNop,			c2;	Noop,				c3;		L3 _ 0,				c1;		Noop,				c2;	FloatUnloadS,	Float.M,	c3;		FloatUnloadS,	Float.L,	c1;		rSTATUS _ PPort,		c2;	rRESMN _ FloatResult,		c3;		Q _ FloatResult,		c1;	rRESMN _ rRESMN LRot8,		c2;		rRESMN _ rRESMN and 80, 	c3;		Xbus _ ibNA, XDisp,		c1;	DISP4[VOMAXMIN, 0E],		c2;			Ybus _ rRESMN, ZeroBr,		c3, at[0E, 10, VOMAXMIN]; {Determine max. value}			BRANCH[FNMAX1, SMMAX],		c1;	FNMAX1:	Q _ uNEWH, 			c2; {B>A, New max. is found}	uMAXH _ Q,			c3; {Update uMAXH and uMAXL}			uMAXL _ TOSH,			c1; {They now contain the new extreme value}	uINDEX _ rCOUNT, L3Disp,	c2;	RET[COMPRET],			c3;	SMMAX:	L3Disp,				c2;	RET[COMPRET],			c3;	Ybus _ rRESMN, ZeroBr,		c3, at[0F, 10, VOMAXMIN]; {Determine min. value}	BRANCH[SMMIN, FNMIN1],		c1;	FNMIN1:	Q _ uNEWH, 			c2; {New min. is found}	uMAXH _ Q,			c3; {Update uMAXH and uMAXL}			uMAXL _ TOSH, 			c1; {They now contain the new extreme value}	uINDEX _ rCOUNT, L3Disp,	c2;	RET[COMPRET],			c3;	SMMIN:	L3Disp,				c2;	RET[COMPRET],			c3;	{==========================================================================================Remap==========================================================================================}VOCH0:	CALL[NRLMapFixB2],		c2;VOCH1:	CALL[NRLMapFixB2],		c2;VOCH5:	CALL[NRLMapFixB2],		c2;FXVO0:	GOTO[VOFX],		c3;FXVO1:	GOTO[VOFX],		c3;FXVO2:	GOTO[VOFX],		c3;FXVO3:	TT _ uTT, GOTO[VOFX],		c3;		VOFX:	Q _ 0FF + 1,			c1;	TT _ TT + Q, CarryBr,		c2;	Q _ rhTT, BRANCH[VONC0, VOC0],	c3;	VONC0:	GOTO[VOMG0],			c1;	VOC0:	Q _ Q + 1,			c1;VOMG0:	rhTT _ Q LRot0,			c2;	uTT _ TT,			c3;	Map _ [rhTT, TT + 0], L0 _ L0.VO.RO.05,	c1;	TOSH _ Rx, L1 _ L1.FS.NR.0C,		c2;	rhRx _ Rx _ MD, XRefBr,			c3;		MAR _ Q _ [rhRx, TOSH + 0], BRANCH[VOCH1, $],	c1, at[L0.VO.RO.05, 10, NRMapFixCallerB2];	Rx _ Q, L2Disp,			c2;	TOSH _ MD, DISP4[FETCHRET],		c3;FXVO4:	TT _ uTT,			c3;	Q _ 0FF + 1,			c1;	TT _ TT + Q, CarryBr,		c2;	Q _ rhTT, BRANCH[VONC4, VOC4],	c3;	VONC4:	GOTO[MGVO1],			c1;		VOC4:	Q _ Q + 1,			c1;MGVO1:	rhTT _ Q LRot0,			c2;	TOSH _ Rx,			c3;	Map _ [rhTT, TT + 0], L1 _ L1.FS.NR.0C,	c1;	uTT _ TT, L0 _ L0.VO.RO.09,		c2;	rhRx _ Rx _ MD, XRefBr,			c3;		MAR _ Q _ [rhRx, TOSH + 0], BRANCH[VOCH5, $],	c1, at[L0.VO.RO.09, 10, NRMapFixCallerB2];	Rx _ Q, GOTO[CHRT5],				c2;	{==========================================================================================Exit points==========================================================================================}VOEX0:	S _ S - 2, L1 _ L1.RestoreAndExit,	c1;	Xbus _ ib, L1Disp,			c2;		DISP4[RestoreRegsB2Ret],	        c3;	VOEX1:	TOS _ uINDEX,				c3;	TOSH _ uTOSH,				c1;	S _ uS,					c2;	PC _ uPC,				c3;		S _ S - 2, L1 _ L1.RestoreAndExit,	c1;	Xbus _ ib, L1Disp,			c2;		PV _ uPVx, DISP4[RestoreRegsB2Ret], 	c3;		{==========================================================================================Error cases==========================================================================================}VOER0:	Noop,		c1;VOER1:	GOTO[ufnX3],	c2;	{END}