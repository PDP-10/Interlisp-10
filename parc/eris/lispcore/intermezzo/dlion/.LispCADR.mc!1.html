<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Intermezzo>dlion>LispCADR.mc!1</title>
  </head>
  <body>
    <pre>
{LispCADR.mccal:  18-Dec-84 10:12:24}{	SUBROUTINE: takes VA of CONS cell, returns CAR and CDR of cell	Rx has lo bits of VA of cell	TT has hi bits of VA of cell	L3 used for return thru CADRret	trashes Q, L0, L1, rhRx, rhTT	trashes uRx, uhiVA, UQSave	returns:		TT has hi bits of CDR of cell		Rx has lo bits of CDR of cell		uCARlo has lo bits of CAR of cell		uCARhi has hi bits of CAR of cell	will ufnX if VA not type list	will pagefault {NoFixes} if cell page faults}CADR:	uRx &larr; Rx,	c1;{uRx &larr; lo bits of cell VA}	Ybus &larr; TT or Rx, NZeroBr,	c2;	rhRx &larr; crhTypeTable, BRANCH[lccellnil, $],	c3;	MAR &larr; Rx &larr; [Rx, TT + 0],	c1;{byte merge}	Rx &larr; Rx LRot8,	c2;	Rx &larr; Rx RShift1, getTypemsBit,	c3;	MAR &larr; [rhRx, Rx + 0], L1 &larr; L1.NoFixes,	c1;{type table fetch}	Rx &larr; ListType,	c2;	Rx &larr; MD xor Rx, L0 &larr; L0.RedoCADR,	c3;	Ybus &larr; Rx - 1, PgCarryBr,	c1;{test if tos is type list}	rhTT &larr; TT LRot0, BRANCH[$, lcnotlist],	c2;	TT &larr; uRx,	c3;{lo bits of cell VA}lcmapagain:	Map &larr; [rhTT, TT],	c1;	uRx &larr; TT,	c2;{uRx &larr; lo bits of cell VA}	rhRx &larr; Rx &larr; MD, XRefBr,	c3;	BRANCH[lcremap, $],	c1, at[L0.RedoCADR, 10, RxMapFixCaller];	Q &larr; rhTT,	c2;	uhiVA &larr; Q,	c3;{uhiVA &larr; hi bits of cell VA}	MAR &larr; Q &larr; [rhRx, TT + 0],	c1;	UQSave &larr; Q,	c2;{UQSave &larr; low 16 bits cell RA}	rhTT &larr; TT &larr; MD,	c3;{high 16 bits cell contents}	MAR &larr; [rhRx, Q + 1],	c1;	Rx &larr; TT LRot8, CANCELBR[$, 2],	c2;{low 8 bits of Rx are cell cdrcode}	Q &larr; MD,	c3;{low 16 bits cell contents}	Ybus &larr; Rx - 1, PgCarryBr,	c1;{test if cdrcode = 0 : indirect}	BRANCH[lcindir, lcdir],	c2;lcindir:	TT &larr; Q, GOTO[lcmapagain],	c3;lcdir:	uCARlo &larr; Q,	c3;	Q &larr; rhTT,	c1;	uCARhi &larr; Q,	c2;	Xbus &larr; Rx LRot0, XLDisp,	c3;{test 200'b bit of cdrcode}	Rx &larr; LShift1 (Rx and 07F), BRANCH[lcsmallcdrcode, lcbigcdrcode, 1],	c1;		{cdr code &gt;= 200'b}lcbigcdrcode:	Ybus &larr; Rx, ZeroBr,	c2;{test for cdrcode nil}	TT &larr; uRx, BRANCH[$, lccdrnil],	c3;{low 16 bits cell VA}	MAR &larr; TT &larr; [TT, Rx + 0],	c1;{byte merge}	Rx &larr; TT, L3Disp,	c2;{lo bits of CDR}	TT &larr; uhiVA, RET[CADRret],	c3;{hi bits of CDR}		{cdr code &lt; 200'b}lcsmallcdrcode:	,	c2;	TT &larr; UQSave,	c3;{low 16 bits cell RA}	MAR &larr; TT &larr; [TT, Rx + 0],	c1;{byte merge}	Rx &larr; TT,	c2;	,	c3;	MAR &larr; [rhRx, Rx + 0], L2 &larr; 3,	c1;{fetch contents of cdrcoded cell}	,	c2;	TT &larr; MD,	c3;{hi bits of CDR}	MAR &larr; [rhRx, Rx + 1],	c1;	TT &larr; TT and 0FF, L3Disp, CANCELBR[$, 2],	c2;	Rx &larr; MD, RET[CADRret],	c3;{lo bits of CDR}lccellnil:	TT &larr; 0, uCARlo &larr; 0,	c1;	Rx &larr; 0, uCARhi &larr; 0, L3Disp,	c2;	RET[CADRret],	c3;lccdrnil:	Rx &larr; 0,	c1;	TT &larr; 0, L3Disp,	c2;	RET[CADRret],	c3;lcremap:	GOTO[RLxMapFix],	c2;lcnotlist:	GOTO[ufnX1],	c3;	{ E N D }</pre>
  </body>
</html>
