<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Intermezzo>dlion>TripleCheck.mc!1</title>
  </head>
  <body>
    <pre>
{File name TripleCheck.mcDescription:  DandeLion InterLisp Emulator TripleCheckCharnley  15-Jan-85 10:29:44  Created}{	uses opcode 373'b  alpha = 5  ( FLOATARRAY2 5)}{	called   (TRIPLECHECK Src1 Src2 Src3 WCount)	if WCount = 0 then return( NIL )	loop:	if NOT( [Src1 + WCount - 1] = [Src2 + WCount - 1] = [Src3 + WCount - 1] ) then WCount &larr; WCount - 1, loop	return( WCount )}{Set[L2.Triple, 5];Set[L0.trS2i, 1];Set[L0.trS1i, 2];Set[L0.trDi, 3];Set[L0.trS2, 4];Set[L0.trS1, 5];Set[L0.trD, 6];}	GOTO[FLOATARRAYPREP],	c3, at[L2.Triple, 10, FOP2Disp];{Triple}{	has already saved		uTOSH &larr; TOSH		uTOS &larr; TOS	saves regs:		uS &larr; S		uPVx &larr; PV		uPC &larr; PC		urhS &larr; rhS		urhPV &larr; rhPV	gets stk-1, stk-2, stk-3		stk-3 (first arg)			uS2Hi, uS2Lo		stk-2 (second arg)			uS1Hi, uS1Lo		stk-1 (third arg)			uDHi, uDLo}		at[L2.Triple, 10, LFAop],{FOP2 = Triple}	Q &larr; TOS - 1, L1 &larr; L1.RestoreTosB2,	c1;	TT &larr; uS2Lo,	c2;	TT &larr; TT + Q, CarryBr,	c3;	uS2Lo &larr; TT, BRANCH[$, trfixS2hi],	c1;trS2:	TT &larr; uS1Lo,	c2;	TT &larr; TT + Q, CarryBr,	c3;	uS1Lo &larr; TT, BRANCH[$, trfixS1hi],	c1;trS1:	TT &larr; uDLo,	c2;	TT &larr; TT + Q, CarryBr,	c3;	uDLo &larr; TT, BRANCH[$, trfixDhi],	c1;trD:	,	c2;	GOTO[TrMapInit],	c3;trfixS2hi:	TT &larr; uS2Hi,	c2;	TT &larr; TT + 1,	c3;	uS2Hi &larr; TT, GOTO[trS2],	c1;trfixS1hi:	TT &larr; uS1Hi,	c2;	TT &larr; TT + 1,	c3;	uS1Hi &larr; TT, GOTO[trS1],	c1;trfixDhi:	TT &larr; uDHi,	c2;	TT &larr; TT + 1,	c3;	uDHi &larr; TT, GOTO[trD],	c1;TrMapInit:	TT &larr; uS2Hi, L0 &larr; L0.trS2i,	c1;	rhTT &larr; TT LRot0,	c2;	TT &larr; uS2Lo, CALL[TrMap],	c3;	at[L0.trS2i, 10, TrMapRet],	Q &larr; rhRx,	c1;	rhS2 &larr; Q LRot0,	c2;	S2 &larr; Rx,	c3;	MAR &larr; S2 &larr; [rhS2, TT + 0],	c1;	,	c2;	Q &larr; MD,	c3;	UQSave &larr; Q,	c1;	,	c2;	,	c3;	TT &larr; uS1Hi, L0 &larr; L0.trS1i,	c1;	rhTT &larr; TT LRot0,	c2;	TT &larr; uS1Lo, CALL[TrMap],	c3;	at[L0.trS1i, 10, TrMapRet],	Q &larr; rhRx,	c1;	rhS1 &larr; Q LRot0,	c2;	S1 &larr; Rx,	c3;	MAR &larr; S1 &larr; [rhS1, TT + 0],	c1;	Q &larr; UQSave,	c2;	Q &larr;MD xor Q,	c3;	,	c1;	Ybus &larr; Q, ZeroBr,	c2;	BRANCH[TrEarlya, $],	c3;	TT &larr; uDHi, L0 &larr; L0.trDi,	c1;	rhTT &larr; TT LRot0,	c2;	TT &larr; uDLo, CALL[TrMap],	c3;	at[L0.trDi, 10, TrMapRet],	Q &larr; rhRx,	c1;	rhD &larr; Q LRot0,	c2;	D &larr; Rx,	c3;	MAR &larr; D &larr; [rhD, TT + 0],	c1;	Q &larr; UQSave,	c2;	Q &larr;MD xor Q, GOTO[TrLoopDec],	c3;{	inner loop}TrLoop:	MAR &larr; S2 &larr; [rhS2, S2 - 1], L0 &larr; L0.trS2,	c1;TrMapS2RetX:	Ybus &larr; Q, ZeroBr, BRANCH[$, TrfixS2, 1],	c2;	Q &larr; MD, BRANCH[TrEarly2, $],	c3;	MAR &larr; S1 &larr; [rhS1, S1 - 1], L0 &larr; L0.trS1,	c1;TrMapS1RetX:	BRANCH[$, TrfixS1, 1],	c2;	Q &larr; MD xor Q,	c3;	MAR &larr; D &larr; [rhD, D - 1], L0 &larr; L0.trD,	c1;TrMapDRetX:	Ybus &larr; Q, ZeroBr, BRANCH[$, TrfixD, 1],	c2;	Q &larr; MD xor Q, BRANCH[TrEarly1, TrLoop],	c3;TrLoopDec:	TOS &larr; TOS - 1, ZeroBr,	c1;	uTOS &larr; TOS, BRANCH[$, TrDone],	c2;	GOTO[TrLoop],	c3;	{Early (mismatch) exits here}TrEarly1:	TOS &larr; TOS,	c1;	Q &larr; smallpl,	c2;	uTOSH &larr; Q, L1 &larr; L1.LFAexit, GOTO[TrExit],	c3;TrEarly2:	TOS &larr; TOS + 1,	c1;	Q &larr; smallpl,	c2;	uTOSH &larr; Q, L1 &larr; L1.LFAexit, GOTO[TrExit],	c3;TrEarlya:	TOS &larr; TOS,	c1;	Q &larr; smallpl,	c2;	uTOSH &larr; Q, L1 &larr; L1.LFAexit, GOTO[TrExit],	c3;TrEarlyc:	,	c3;	TOS &larr; TOS + 1,	c1;	Q &larr; smallpl,	c2;	uTOSH &larr; Q, L1 &larr; L1.LFAexit, GOTO[TrExit],	c3;TrDone:	,	c3;	Ybus &larr; Q, ZeroBr,	c1;	BRANCH[TrEarlyc, $],	c2;	uTOSH &larr; 0, L1 &larr; L1.LFAexit, GOTO[TrExit],	c3;TrfixS2:	S2 &larr; rhS2, CANCELBR[$],	c3;	TT &larr; uS2Lo,	c1;	rhTT &larr; S2 LRot0,	c2;	CALL[TrMap],	c3;	at[L0.trS2, 10, TrMapRet],	MAR &larr; S2 &larr; [rhS2, 0FF + 0], GOTO[TrMapS2RetX],	c1;TrfixS1:	S1 &larr; rhS1, CANCELBR[$],	c3;	TT &larr; uS1Lo,	c1;	rhTT &larr; S1 LRot0,	c2;	CALL[TrMap],	c3;	at[L0.trS1, 10, TrMapRet],	MAR &larr; S1 &larr; [rhS1, 0FF + 0], GOTO[TrMapS1RetX],	c1;TrfixD:	D &larr; rhD, CANCELBR[$],	c3;	TT &larr; uDLo,	c1;	rhTT &larr; D LRot0,	c2;	CALL[TrMap],	c3;	at[L0.trD, 10, TrMapRet],	MAR &larr; D &larr; [rhD, 0FF + 0], GOTO[TrMapDRetX],	c1;TrMap:	Map &larr; [rhTT, TT],	c1;	,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp,	c3;	Map &larr; [rhTT,TT], DISP2[TrFixRFlags],	c1;	MDR &larr; Rx or 10, L0Disp, GOTO[TrReRead],	c2, at[0, 4, TrFixRFlags];	MDR &larr; Rx or 10, L0Disp, GOTO[TrReRead],	c2, at[1, 4, TrFixRFlags];	MDR &larr; Rx or 10, L0Disp, GOTO[TrReRead],	c2, at[2, 4, TrFixRFlags];	GOTO[RWTrapB2],	c2, at[3, 4, TrFixRFlags];TrReRead:	RET[TrMapRet],	c3;	{when completed come here for restoring regs}	{set uTOSH to value desired in TOSH}	{set TOS to value desired in TOS}	{when completed, set L1 = L1.LFAexit}TrExit:	Q &larr; 6{delta stk}, GOTO[LFACommonExit],	c1;	{ E N D }</pre>
  </body>
</html>
