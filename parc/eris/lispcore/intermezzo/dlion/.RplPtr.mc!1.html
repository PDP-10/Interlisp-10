<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Intermezzo>dlion>RplPtr.mc!1</title>
  </head>
  <body>
    <pre>
{File name RplPtr.mcDescription:  part of DandeLion InterLisp EmulatorAuthor: CharnleyLast edited by Charnley:    27-Oct-83 14:23:29Created by Charnley: 17-Jun-83 12:12:27}SetTask[0];{*******************************************************************	RPLPTR	GVAR&larr;*******************************************************************}{	GVAR&larr;	store TOS at VALSPACE + 2 * (alpha,,beta), preserving hi byte of destination		delref value at VALSPACE + 2 * (alpha,,beta)		addref tos}@GVARg:	opcode[27'b],	TT &larr; VALbase, L3 &larr; L3.RplGvar,	c1;	TT &larr; TT LRot8,	c2;	Rx &larr; ib, L1 &larr; L1.NoFixes, XLDisp,	c3;	Rx &larr; Rx LRot8, BRANCH[GVValLo, GVValHi, 1],	c1;GVValLo:	Q &larr; VALspace, GOTO[GVVal],	c2;GVValHi:	Q &larr; VALspaceHi, GOTO[GVVal],	c2;GVVal:	Rx &larr; Rx or ibNA,	c3;	Rx &larr; LShift1 Rx, SE &larr; 0,	c1;	TT &larr; TT + Rx,	c2;	rhTT &larr; Q LRot0, GOTO[RplMap],	c3;{	RPLPTR	delref value at [tos - 1] + alpha	addref tos	store tos at [tos - 1] + alpha, preserving hi byte of destination	return value is tos - 1}@RPLPTR:		opcode[24'b],	MAR &larr; [rhS, S + 0], L3 &larr; L3.RplPtr,	c1;	L1 &larr; L1.NoFixes,	c2;	Rx &larr; MD{TOS-1.Lo},	c3;	MAR &larr; [rhS, S - 1],	c1;	TT &larr; Rx + ibNA, CarryBr, CANCELBR[$, 2],	c2;	rhTT &larr; MD{TOS-1.Hi}, BRANCH[RplMap, RplFixVHi],	c3;RplFixVHi:	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c1;	rhTT &larr; Q LRot0,	c2;	c3;RplMap:	{map the address}	Map &larr; Q &larr; [rhTT, TT], L0 &larr; L0.RedoRpl,	c1;	,	c2;	Rx &larr; rhRx &larr; MD, XwdDisp{XDirtyDisp},	c3;RplGet:	{mapping this reference can fault}	{get contents of address}	MAR &larr; Q &larr; [rhRx, Q + 0], DISP2[RplRemap],	c1, at[L0.RedoRpl, 10, WMapFixCaller];	uSavAddr &larr; Q,	c2, at[1, 4, RplRemap];	TT{oldHi} &larr; MD, GOTO[Rpl2ndwd],	c3;RplRemap:	CALL[WLMapFix],	c2, at[0, 4, RplRemap];	CALL[WLMapFix],	c2, at[2, 4, RplRemap];	CALL[WLMapFix],	c2, at[3, 4, RplRemap];Rpl2ndwd:	MAR &larr; [rhRx, Q + 1],	c1;	uSavOldHi &larr; TT, CANCELBR[$, 2],	c2;	TT{oldLo} &larr; MD,	c3;	{no faults from here on}	{setup for GcLookup:	  Rx &larr; addrHi &amp; 0FF	  TT &larr; addrLo	  uGcLov &larr; 0 {before first call only}	  L2 &larr; subr #	  Q &larr; 0 if addref, 1 if delref, 2 if stkref	  Trashes rhTT and rhRx	  }RplGo:	Rx &larr; uSavOldHi,	c1;	Rx &larr; Rx and 0FF,	c2;	uGcLov &larr; 0{init for GcLookup to mark}, L2 &larr; L2.RplDel,	c3;RplDel:	{del ref to gotten}	Q &larr; rhRx,	c1;{save rhRx cuz gets smashed}	uuRx &larr; Q,	c2;	,	c3;	Q &larr; Q.DelRef, CALL[GcLookup],	c1;	{GcLookup Subroutine here}	TT &larr; TOS, L2 &larr; L2.RplAdd,	c2,at[L2.RplDel,10,GcLookRet];	Rx &larr; TOSH and 0FF,	c3;RplAdd:	{add ref to tos}	Q &larr; Q.AddRef, CALL[GcLookup],	c1;		{GcLookup Subroutine here}RplBuild:	{fix TOS high byte}	TT &larr; uSavOldHi{old hi},	c2, at[L2.RplAdd, 10, GcLookRet];	c3;	MAR &larr; TT &larr; [TT, TOSH + 0],	c1;{merge bytes -- not memory ref}	Rx &larr; uSavAddr{saved Addr},	c2;	rhRx &larr; uuRx,	c3;RplPut:	{put TOSH,,TOS to address}	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TT,	c2;	TT &larr; uGcLov{set by GcLookup}{for GVAR},	c3;	MAR &larr; [rhRx, Rx + 1], L3Disp,	c1;	MDR &larr; TOS, DISP4[RplEnd], LOOPHOLE[wok],	c2;RplPop:	{POP}	,	c3, at[L3.RplPtr, 10, RplEnd];	MAR &larr; [rhS, S + 0],	c1;	Xbus &larr; ib,	c2;	TOS &larr; MD,	c3;	MAR &larr; [rhS, S - 1],	c1;	Ybus &larr; uGcLov{set by GcLookup}, NZeroBr, CANCELBR[$, 2],	c2;	TOSH &larr; MD, BRANCH[RplNoOvXit, RplOvXit],	c3;RplNoOvXit:	S &larr; S - 2,	c1;	PC &larr; PC + 1, IBDisp, L2 &larr; L2.0, GOTO[DNI.nop],	c2;	RplOvXit:	{if overflow entries, exit via GCSCAN }	S &larr; S - 2, L3{ib's} &larr; 1,	c1;	Rx &larr; AtomGCSCAN {371'b}, c2;RplFNXIT:	IB &larr; Rx LRot0,	c3;	MAR &larr; Q &larr; [rhS, S + 1], IBPtr &larr; 0, GOTO[FN1Ext],	c1;GVAREnd:	Xbus &larr; ib, Ybus &larr; TT, ZeroBr, L3{ib's} &larr; 2,	c3, at[L3.RplGvar, 10, RplEnd];	Rx &larr; AtomGCSCAN {371'b}, BRANCH[GVAROvXit, GVARNoOvXit],	c1;GVARNoOvXit:	PC &larr; PC + 1, IBDisp, L2 &larr; L2.0,	c2;	PC &larr; PC + PC16, L2 &larr; L2.0, DISPNI[OpTable],	c3;GVAROvXit:	GOTO[RplFNXIT], c2;	{ E N D }</pre>
  </body>
</html>
