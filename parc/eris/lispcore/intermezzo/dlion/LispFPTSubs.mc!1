{File name LispFPTSubs.mcDescription:  DandeLion InterLisp Emulator Floating Point OpCodesAuthor: CharnleyLast modified: Charnley                7-Aug-84 11:02:42Created:    7-Aug-84 11:02:39}{	FloatIt	Convert TOSH,,TOS to an unboxed floating point number in TOSH,,TOS	can page fault getting data, will restore TOSH and TOS from uTOSH and uTOS	will coerce smallp, smallneg, and Fixp to floating point}{	TIMINGS	FloatP   8  1/3	FixP(long: top 9 bits not the same)   21  1/3	FixP(short: top 9 bits the same)   14  1/3	Smallp   5  1/3	Smallneg   5  1/3}{	trashes Rx, L0, L1	leaves TOSH LRot1 in TT (for fpt ucode)	leaves Q with 0FF (for fpt ucode)	returns thru L3}FloatIt:	Ybus _ TOSH xor smallpl, ZeroBr,	c3;CreateFPT:	MAR _ Q _ [TOS, TOSH + 0], BRANCH[$, FLsmp],	c1;{not mem ref, byte merge}	Ybus _ TOSH xor smallneg, ZeroBr, 	c2;	Rx _ Q, rhRx _ crhTypeTable, BRANCH[$, FLsmn],	c3;	Rx _ Rx LRot8,	c1;	Rx _ Rx RShift1, getTypemsBit, 	c2;	rhTT _ TOSH LRot0,	c3;	MAR _ [rhRx, Rx + 0],	c1;	Q _ 0FF,	c2;	Q _ MD and Q, FloatNop,	c3;	Ybus _ Q xor FloatpType, ZeroBr,	c1;	Ybus _ Q xor FixpType, ZeroBr, BRANCH[GetXnonFpt, $],	c2;	TT _ TOS, CANCELBR[$], FloatNop,	c3;	Map _ [rhTT,TT], L0 _ L0.RedoCreate,	c1;	Q _ 0FF, L1 _ L1.RestoreTosB2, 	c2;	Rx _ rhRx _ MD, XRefBr,	c3;	MAR _ [rhRx, TT + 0], BRANCH[FLptRemap, $],	c1, at[L0.RedoCreate, 10, RMapFixCallerB2];	Q _ 0FF,	c2;	TOSH _ MD,	c3;	MAR _ [rhRx, TT + 1],	c1;	TT _ LRot1 TOSH, CANCELBR[$, 2], L3Disp,	c2;	TOS _ MD, RET[FloatItRet],	c3;FLptRemap:	CALL[RLMapFixB2],	c2;GetXnonFpt:	{non-FloatType arg}	TT _ TOS, FloatNop, BRANCH[ArgNotFixp, ArgIsFixp],	c3;ArgNotFixp:	GOTO[ufnZ2],	c1;ArgIsFixp:	Map _ [rhTT,TT], L0 _ L0.RedoFLFix,	c1;	L1 _ L1.RestoreTosB2, 	c2;	Rx _ rhRx _ MD, XRefBr,	c3;	MAR _ [rhRx, TT + 0], BRANCH[FxptRemap, $],	c1, at[L0.RedoFLFix, 10, RMapFixCallerB2];	,	c2;	TOSH _ MD,	c3;	MAR _ [rhRx, TT + 1],	c1;	CANCELBR[$, 2],	c2;	TOS _ MD, GOTO[ChipConvFixp],	c3;FxptRemap:	CALL[RLMapFixB2],	c2;FLsmp:	CANCELBR[$], FloatNop,	c2;	ufloat _ 0, GOTO[ChipConvShort],	c3;FLsmn:	FloatNop,	c1;	FloatNop,	c2;	ufloat _ S xor ~S, GOTO[ChipConvShort],	c3;ChipConvShort:	FloatMode.RN.AI.FAST, FloatFLOW,	c1;	FloatA _ ufloat, FLFloatA,	c2;	FloatA _ TOS LRot0,	c3;	FloatStartFlow,	c1;	Noop,	c2;	Noop,	c3;	Q _ 0FF,	c1;	FloatUnloadS, Float.M,	c2;	FloatUnloadS, Float.L,	c3;	TOSH _ FloatResult,	c1;	TOS _ FloatResult, L3Disp,	c2;	TT _ LRot1 TOSH, RET[FloatItRet],	c3;ChipConvFixp:	Q _ 80,	c1;	Ybus _ TOSH - Q, CarryBr,	c2;	Ybus _ TOSH + Q, CarryBr, BRANCH[IsShortp, $],	c3;	Ybus _ TOSH, NegBr, BRANCH[IsNotShort, IsShortn],	c1;IsShortp:	CANCELBR[$],	c1;IsShortn:	CANCELBR[$], ufloat _ TOSH,	c2;	GOTO[ChipConvShort],	c3;IsNotShort:	Q _ 8, BRANCH[itispos, itisneg],	c2;{Q _ 100}itispos:	ufloat _ 0, GOTO[ChipConvLong],	c3;itisneg:	ufloat _ S xor ~S, GOTO[ChipConvLong],	c3;ChipConvLong:	FloatMode.RN.AI.FAST, FloatPIPE,	c1;	FloatAB _ ufloat, FLFloatA,	c2;	FloatAB _ TOS LRot0,	c3;{has unload side effect}	FloatPump,	c1;	FloatPump,	c2;	FloatA _ ufloat, FLFloatA,	c3;	FloatA _ TOSH LRot0,	c1;	FloatPump,	c2;	FloatPump,	c3;	FloatUnloadS, Float.M, FloatPump,	c1;	FloatUnloadS, Float.L, FloatPump,	c2;	FloatAB _ FloatResult,	c3;	FloatAB _ FloatResult,	c1;	FloatUnloadS, Float.M, FloatPump,	c2;	FloatUnloadS, Float.L, FloatPump,	c3;	Rx _ Q,	c1;	Rx _ Rx LRot8,	c2;	Q _ Rx,	c3;	Rx _ FloatResult, FloatPump,	c1;	TT _ FloatResult, FloatPump,	c2;	Rx _ Rx + Q,	c3;	Q _ 0FF,	c1;	ufloatplus _ Rx,	c2;	FloatA _ ufloatplus, FLPlus,	c3;	FloatA _ TT LRot0,	c1;	FloatPump,	c2;	FloatPump,	c3;	FloatPump,	c1;	FloatPump,	c2;	FloatPump,	c3;	FloatPump,	c1;	FloatPump, FloatUnloadS, Float.M,	c2;	FloatPump, FloatUnloadS, Float.L,	c3;	TOSH _ FloatResult,	c1;	TOS _ FloatResult, L3Disp,	c2;	TT _ LRot1 TOSH, RET[FloatItRet],	c3;	{ E N D }