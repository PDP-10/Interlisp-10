<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Intermezzo>dlion>Dandelion.dfn!1</title>
  </head>
  <body>
    <pre>
{File name: &lt;tajo&gt;Dandelion.dfn Description: Definitions for all Dandelion Microcode, Created: 3 Jan 80, Purcell: 13-Jan-85 11:16:23 new IOPage real loc{%1} Last Edited:   20-Jul-83 17:06:46 by donJim Frandeen, April 11, 1982  4:42 PM: Add uIOPVirtLow, High for IOP. Ev Neely, March 29, 1982  7:24 PM: Modified tridents CMemError to 0E (was 8) Ev Neely, March 24, 1982  7:39 AM: Modified tridents CRetry to 90 (was 30) Jim Frandeen, March 3, 1982  1:47 PM: Move Xfer temp registers where they will not disturb BandBlt. Jim Frandeen, February 23, 1982  5:01 PM: Add UtbCoordHigh. Amy Fasnacht, February 4, 1982  3:40 PM: Delete source socket ureg and constants, add Trident boot file number constant for EtherInitial. Neely, February 3, 1982  9:46 AM: Add uDevOrd (U 2) for TridentInitial. Jim Frandeen, February 2, 1982  2:13 PM: Add uXmitInterrupt and uE3FF for Ether. Amy Fasnacht, January 27, 1982  4:36 PM: Add uFileNumber2, add Etherinitial constants. Neely, January 14, 1982  3:01 PM: Added some TridentInitial usage comments. Amy Fasnacht, January 14, 1982  1:09 PM: Comment out tridentboot constants common to trident constants. Neely, January 13, 1982  2:01 PM: change 5 constants for 30 sector trident. Neely, January 6, 1982  4:21 PM: Add TridentInitial Registers. Jim Frandeen, January 7, 1982  2:35 PM: Rearrange registers for new TextBlt FontBody.  Register block 5. Amy Fasnacht, January 5, 1982  11:58 AM: Rearrange booting registers. Amy Fasnacht, December 21, 1981  4:08 PM: Add CPBootDevice register. Amy Fasnacht, December 14, 1981  1:57 PM: Merged Boot.df into Dandelion.df, change U0C00 to U register 0A8. Furst, December 8, 1981  1:57 PM: Add new U register UF000 (0A7).Sandman, November 17, 1981  3:36 PM: New instruction set.Jim Frandeen, November 8, 1981  5:45 PM: Rearrange display registers for smooth scrolling.Ev. Neely, October 9, 1981  2:41 PM: Merged Trident Register Defs.Jim Frandeen, July 2, 1981  9:48 AM: Rearrange registers for TextBlt.Olmstead, March 23, 1981  5:11 PM:  Remove multiple definition of uCurrentFlags introduced by last edit.Olmstead, March 23, 1981  4:05 PM:  Changed spelling of all occurrences of "uregMumble" to "uMumble"Olmstead, March 18, 1981  5:41 PM:  Re-did BandBLT's U registersOlmstead, March 18, 1981  5:40 PM:  Reserved U regs 0AB-0AF for Disk taskJim Frandeen, March 11, 1981  4:13 PM: Major reorganization.Jim Frandeen, February 26, 1981  2:49 PM: Changes for BitBlt to use more stack registers.Jim Frandeen, February 20, 1981  3:16 PM: Changes for Block}{R AND RH REGISTER DEFINITIONSSince there are no task specific registers in the machine, task identifiers are not bound to the register numbers with which they are shown.Q is reserved for the Emulator Task.Also, the stackP, STK, ib, and pc16 registers are reserved for the Emulator task.}{REGISTERS 0 - 6: EMULATOR}RegDef[TOS,	R,	0];RegDef[Hold,	R,	0];	{BBLoops}RegDef[Rbb0,	R,	0];	{BitBlt and TextBlt}RegDef[VS,	R,	0];	{BitBlt}RegDef[Mask2,	R,	0];	{BitBlt}RegDef[rhMDS,	RH,	0];	{top element of stack (rhMDS is VA of 64K aligned MDS)}RegDef[rhVS,	RH,	0];	{BitBlt uses fact that rhVS = rhMDS}RegDef[T,	R,	1];RegDef[Save,	R,	1];	{BitBlt}RegDef[VD,	R,	1];	{BitBlt}RegDef[Rbb1,	R,	1];	{BitBlt and TextBlt}RegDef[Mask1,	R,	1];	{BitBlt}RegDef[rhT,	RH,	1];	{temporary}RegDef[rhVD,	RH,	1];	{BitBlt}RegDef[TT,	R,	2];RegDef[Src,	R,	2];	{BitBlt}RegDef[Rbb2,	R,	2];	{BitBlt and TextBlt Rbb2 must equal TT to share MaskTbl}RegDef[Temp,	R,	2];	{BitBlt}RegDef[TempDelta,	R,	2];	{BitBlt}RegDef[rhTT,	RH,	2];	{temporary}RegDef[rhType,	RH,	2];	{BitBlt}RegDef[L,	R,	3];RegDef[Dst,	R,	3];	{BitBlt}RegDef[TempBpl,	R,	3];	{BitBlt}RegDef[Rbb3,	R,	3];	{BitBlt and TextBlt}RegDef[rhL,	RH,	3];	{local frame (RA, extended by rhL=real rhMDS)}RegDef[rhWho,	RH,	3];	{BitBlt}RegDef[G,	R,	4];RegDef[SrcA,	R,	4];	{BitBlt}RegDef[Rbb4,	R,	4];	{BitBlt and TextBlt}RegDef[rhG,	RH,	4];	{global frame (RA, extended by rhG=real rhMDS)}RegDef[rhSrcA,	RH,	4];	{BitBlt}RegDef[PC,	R,	5];RegDef[DstA,	R,	5];	{BitBlt}RegDef[rhPC,	RH,	5];	{word address of next inst (RA, extended by rhPC=real UvChigh)}RegDef[rhDstA,	RH,	5];	{BitBlt}RegDef[rhDest,	RH,	5];	{BandBLT}RegDef[Rx,	R,	6];RegDef[Lcount,	R,	6];	{BitBlt}RegDef[TempB,	R,	6];	{BitBlt}RegDef[rhRx,	RH,	6];	{temporary}RegDef[rhRet,	RH,	6];	{BitBlt}{REGISTERS 7 - 8: DISK(x000&amp;Trident)}RegDef[RAdr,	R,	7];	{Disk(x000&amp;Trident)}RegDef[RHRAdr,	RH,	7];	{Disk x000}RegDef[RCnt,	R,	8];	{Disk(x000&amp;Trident)}RegDef[RHRCnt,	RH,	8];	{Diskx000}RegDef[RHCnt,	RH,	8];	{DiskTrident}{REGISTERS 9 - B: DISPLAY/Raven}RegDef[Line,	R,	9];	{Display}RegDef[dZ,	R,	9];	{Display}RegDef[rD0,	R,	9];	{Display}RegDef[rM,	R,	9];	{Etherbooting}RegDef[rhLine,	RH,	9];	{Display}RegDef[rhdZ,	RH,	9];	{Display}RegDef[displayBase0,	RH,	9];	{Display}RegDef[dX,	R,	0A];	{Display}RegDef[rD1,	R,	0A];	{Display}RegDef[rhdX,	RH,	0A];	{Display}RegDef[dY,	R,	0B];	{Display}RegDef[rD2,	R,	0B];	{Display}RegDef[rhdY,	RH,	0B];	{Display}RegDef[displayBase2,	RH,	0B];	{Display}{REGISTERS C - D: ETHER}RegDef[E,	R,	0C];	{Ether}RegDef[rhE,	RH,	0C];	{Ether}RegDef[EE,	R,	0D];	{Ether}RegDef[rhEE,	RH,	0D];	{Ether}{REGISTER E: IOP}RegDef[rIAd,	R,	0E];	{IOP Port}RegDef[rIOP,	R,	0E];	{IOP Port}RegDef[RHrIAd,	RH,	0E];	{IOP Port}RegDef[rhIOP,	RH,	0E];	{IOP Port}{REGISTER F: IOP/KERNEL}RegDef[rK,	R,	0F];RegDef[rTmp,	R,	0F];	{IOP Port}RegDef[RPgCnt,	R,	0F];	{TridentBoot}RegDef[RHrK,	RH,	0F];{The allocation of Link registers:#    task0    Emulator1    Emulator2    Emulator3    Emulator4    Disk5    Display/LSEP6    Ethernet7    IOP}{U REGISTER DEFINITIONSRegisters indicated by ** contain Emulator state and must not be modified.}{U REGISTER BLOCK 0 -- EMULATOR STACK}RegDef[UBitBltArg,	U,	2];	{BitBlt}RegDef[UHeight,	U,	3];	{BitBlt}RegDef[UDstVALo,	U,	4];	{BitBlt}RegDef[UDstBit,	U,	5];	{BitBlt}RegDef[USrcVALo,	U,	6];	{BitBlt}RegDef[USrcBit,	U,	7];	{BitBlt}RegDef[UGray,	U,	8];	{BitBlt -- shares with USrcBpl}RegDef[USrcBpl,	U,	8];	{BitBlt -- shares with UGray}RegDef[UDstBpl,	U,	9];	{BitBlt}RegDef[UrhVS,	U,	0A];	{BitBlt}RegDef[UrhVD,	U,	0B];	{BitBlt}RegDef[UFlags,	U,	0C];	{BitBlt}RegDef[UWidth,	U,	0D];	{BitBlt}{U REGISTER BLOCK 1 -- EMULATOR}RegDef[uWP,	U,	10];	{** wakeups pending}RegDef[uWDC,	U,	18];	{** wakeup disable counter}RegDef[UGsave,	U,	19];	{BitBlt temp}{U REGISTER BLOCK 2 -- EMULATOR}RegDef[uFaultParm0	,U,	26];	{** rA = TT; fault parameter}RegDef[u1FFF,	U,	2E];	{** constant}RegDef[u7FF,	U,	2F];	{** constant}{U REGISTER BLOCK 3 -- EMULATOR}RegDef[UQSave,	U,	31];	{BitBlt temp}	RegDef[UWidthM1,	U,	34];	{BitBlt temp}	RegDef[Umask1,	U,	35];	{BitBlt temp}	RegDef[uFaultParm1,	U,	37];	{fault parameter}RegDef[Umask2,	U,	37];	{BitBlt temp}	RegDef[UmaskL,	U,	38];	{BitBlt temp}	RegDef[ULsave,	U,	3A];	{rA = L = 3. fZ = ErrnIBnStkp = A}{BitBlt temp}{U REGISTER BLOCK 4 -- EMULATOR}RegDef[UXsave,	U,	42];	{BitBlt temp}RegDef[UVSsave,	U,	43];	{BitBlt temp}RegDef[USrcVALoSav,	U,	44];	{BitBlt temp}{U REGISTER BLOCK 5 -- EMULATOR}RegDef[UrhPCsave	,U,	5B];	{rA = PC, fZ = &larr;RH}{BitBlt temp}RegDef[UDstVALoSav	,U,	5C];	{BitBlt temp}RegDef[UWidthW	,U,	5D];	{BitBlt temp}{U REGISTER BLOCK 6 -- EMULATOR}RegDef[ULcntsav,	U,	60];	{BitBlt temp rA = Lcount}RegDef[uRx,	U,	60];	{Lisp temp rA = Rx}{U REGISTER BLOCK 7 -- DISK(x000) &amp; TRIDENT}RegDef[URAdrBlk,	UY,	7];	RegDef[UFreezeCmd,	U,	70];	{Disk Transfer Run of Pages parameters}RegDef[USaveRAdr,	U,	71];	{Disk}RegDef[dbUFindSectMkCmd,	U,	72];	{DiskBootDLion - Command used to find the sector mark on the disk}RegDef[UWaitCmd,	U,	72];	{Disk Transfer subroutine parameters}RegDef[UWdCount,	U,	73];	{Disk Transfer subroutine parameters}RegDef[UXferCmd,	U,	74];	{Disk Transfer subroutine parameters}RegDef[USyncAdrMk,	U,	75];	{Disk used to optimize the code for speed}{DiskBootDLion - mask used to detect error flags after Header Read}RegDef[UMaxSectTst,	U,	76];	{Disk used to optimize the code for speed}RegDef[UHeadSectorAddr,	U,	77];	{Disk used to optimize the code for speed}RegDef[ULabelCmd,	U,	78];	{Disk Transfer Run of Pages parameters}RegDef[ULabelLen,	U,	79];	{Disk Transfer Run of Pages parameters}RegDef[ULabelAddr,	U,	7A];	{Disk Transfer Run of Pages parameters}RegDef[ULabelQuitMsk,	U,	7B];	{Disk Transfer Run of Pages parameters}RegDef[UDataCmd,	U,	7C];	{Disk Transfer Run of Pages parameters}RegDef[UDataLen,	U,	7D];	{Disk Transfer Run of Pages parameters}RegDef[UDataPgNum,	U,	7E];	{Disk Transfer Run of Pages parameters}RegDef[UDataQuitMsk,	U,	7F];	{Disk Transfer Run of Pages parameters}{U REGISTER BLOCK 8 -- DISK(x000)}RegDef[URCntBlk,	UY,	8];	RegDef[UFindSectMkCmd,	U,	80];	{Disk Transfer Run of Pages parameters}RegDef[USectorCount,	U,	81];	{Disk Transfer Run of Pages parameters}RegDef[UFailCount,	U,	82];	{Disk Transfer Run of Pages parameters}RegDef[UHeaderCmd,	U,	83];	{Disk Transfer Run of Pages parameters}RegDef[UHeaderLen,	U,	84];	{Disk Transfer Run of Pages parameters}RegDef[UHeaderAddr,	U,	85];	{Disk Transfer Run of Pages parameters}RegDef[UHeaderQuitMsk,	U,	86];	{Disk Transfer Run of Pages parameters}RegDef[UHeaderLoopMsk,	U,	87];	{Disk Transfer Run of Pages parameters}RegDef[UHeaderNotOkMsk,	U,	88];	{Disk used to optimize the code for speed}RegDef[UStatus,	U,	89];	RegDef[UField,	U,	8A];	{Disk FinishIOCB parameters}RegDef[UInterruptMsk,	U,	8B];	{Disk FinishIOCB parameters}RegDef[ULabPgLo,	U,	8C];	{Disk used to optimize the code for speed}RegDef[ULabPgAddr,	U,	8D];	{Disk used to optimize the code for speed}RegDef[USectorCntAddr,	U,	8E];	RegDef[UHeadSector,	U,	8F];	{Disk used to optimize the code for speed}{U REGISTER BLOCK 9 -- DISPLAY/BandBLT}RegDef[uDCBLoc,	U,	90];RegDef[uInitCurBufAddr,	U,	91];	{Display constant = CA00}RegDef[uCursorFifo0,	U,	92];{new, uPatchPtr}RegDef[uInitPicLength,	U,	95];	{Display constant = 808 }RegDef[uCursorFifo1,	U,	96];	{ }{U REGISTER BLOCK A -- DISPLAY/BandBLT/Disk}RegDef[uCurBufAddr,	U,	0A0];	{Display rA = dX }RegDef[uDWakeup,	U,	0A1];{dX}RegDef[uInitCurMapAddr,	U,	0A2];	{Display rA = dX}RegDef[uCursorDiff,	U,	0A3];{dX}RegDef[uCursorFifo2,	U,	0A4];{dX}RegDef[uClockHigh,	U,	0A5];	{Display }RegDef[uClockLow,	U,	0A6];	{Display rA = dX}RegDef[UNxtIOCBLnk,	U,	0A8];	{Disk FinishIOCB parameters}RegDef[U4000,	U,	0A8];          {Trident}RegDef[U0C00,	U,	0A9];	{Disk used to optimize the code for speed}RegDef[UStatusMsk,	U,	0AA];	{Disk FinishIOCB parameters}RegDef[UF001,	U,	0AA];          {Trident}RegDef[U0400,	U,	0AB];          {Trident}RegDef[U0100,	U,	0AC];          {Trident}RegDef[rAuCursorMask,	U,	0AD];{dX}{% rsvp disk}RegDef[uNoPic,	U,	0AE];{dX}{% rsvp disk}{U REGISTER BLOCK B -- DISPLAY/LSEP/Refresh/BandBLT}RegDef[uExitLength,	U,	0B0];RegDef[uCopyCount,	U,	0B2];	{DisplayCSB parameter -1}RegDef[uPicLength,	U,	0B3];	{Display rA = dY}RegDef[uStartPic,	U,	0B4];RegDef[r9u3FF,	U,	0B5];{uWakeupMask in new}RegDef[uSaveLOwritePHigh,	U,	0B6];	{BandBLT}RegDef[uCursorStop,	U,	0B6];RegDef[uDoCursor,	U,	0B7];RegDef[rBuInitPicLength,	U,	0B8];RegDef[uCurVisAddr,	U,	0B9];	{Display rA = dY }RegDef[uCurMapAddr,	U,	0BB];	{Display, rA = dY, fZ = &larr;RH}RegDef[uFC00,	U,	0BE];		{Display constant = FC00 rA = dY }RegDef[uNormalFifo,	U,	0BE];		{Display constant = FC00 rA = dY }RegDef[uClockBits,	U,	0BF];		{Display rA = dY }{U REGISTER BLOCK C -- ETHER}RegDef[uBlockC,	U,	0C0];RegDef[uEPreamble,	U,	0C2];	{Ether constant = 0AAAA}RegDef[uELastPreamble,	U,	0C3];	{Ether constant = 0AADA}RegDef[uESize,	U,	0C4];	{Ether}RegDef[uEIOCB,	U,	0C5];	{Ether}RegDef[uEBufferHi,	U,	0C6];	{Ether rA = E}RegDef[uEBuffer,	U,	0C7];	{Ether rA = E, fZ = EStrobe}RegDef[uE3FF,	U,	0C8];	{Ether constant 3FF rA = E}RegDef[uEDest0,	U,	0C9];	{Ether rA = E}RegDef[uEDest1,	U,	0CA];	{Ether}RegDef[uEDest2,	U,	0CB];	{Ether}{U REGISTER BLOCK D -- ETHER}RegDef[uBlockD,	U,	0D0];RegDef[uETemp2,	U,	0D0];	{Ether rA = EE, fZ = &larr;EIData}RegDef[uETemp,	U,	0D1];	{Ether}RegDef[uEStatus,	U,	0D2];	{Ether}RegDef[uEHost0,	U,	0D4];	{Ether rA = EE}RegDef[uEHost1,	U,	0D5];	{Ether rA = EE}RegDef[uEHost2,	U,	0D6];	{Ether rA = EE}RegDef[uXmitInterrupt,	U,	0D7];	{Ether fZ = EStrobe = 7}RegDef[uEOldMask,	U,	0D8];	{Ether rA = EE}{U REGISTER BLOCK E -- ETHER/KERNEL/EMULATOR/IOP}RegDef[uBlockE,	U,	0E0];RegDef[uIOPVirtLow,	U,	0E1];	{IOP}RegDef[uIOPVirtHigh,	U,	0E2];	{IOP}RegDef[uBufMax,	U,	0E0];	{IOP Port -- constrained by WHiByte+2}RegDef[uIOPage,	U,	0E4];	{Ether contains 4001; allows rhR &larr; R &larr; uIOPage; MAR &larr; [rhR, R+xx]}RegDef[UKSaveDisp,	U,	0EF];{U REGISTER BLOCK F -- KERNEL/EMULATOR/IOP}RegDef[uBlockF,	U,	0F0];RegDef[UPCsave,	U,	0F0];	{Emulator}RegDef[UrefillType,	U,	0F1];	{BitBlt}RegDef[uVirtPage,	U,	0F2];	{BandBLT}RegDef[uRasterLow,	U,	0F3];	{BandBLT}RegDef[uKSaveR,	U,	0F4];RegDef[uIOPStatusSave,	U,	0F5];RegDef[uKSaveQ,	U,	0F6];RegDef[uKernAC,	U,	0F7];RegDef[uData,	U,	0F8];	{IOP Port -- constrained by WLo+1}RegDef[uIOPIDataSave,	U,	0F9];	{rA = rK, fZ = &larr;IOPStatus}RegDef[uKTRefCnt,	U,	0F9];	{uIOPIDataSave = uKTRefCnt}RegDef[uIOPCtlSave,	U,	0FA];RegDef[u1F,	U,	0FB];	{01F'x}RegDef[uKAddr,	U,	0FC];RegDef[uKCount,	U,	0FD];RegDef[UKernMD,	U,	0FE];RegDef[UBreakID,	U,	0FF];	{UBreakID[0-3] = rK}RegDef[UKTemp,	U,	0FF];	{UBreakID = UKTemp}{KERNEL Author: R. Garner Created: 4 Oct 79, Last Edited: R. Garner, October 28, 1980  2:16 PM}Set[IOPAttnInMode, 5];Set[IOPInMode, 1];Set[IOPDisableMode, 0];	Set[IOPageHigh, 2]; {%1}	Set[IOPage, 0]; {%1}	Set[DCBLoc, 0EB];	Set[cursorMapLoc, 5];Set[KBufferLoc, 0FF4], Set[KBufferEnd, 0FFF];  {First location of overlay area, had better be even!}Set[GetIOPByteLoc, 0FD0];Set[KBufferExtenLoc, Add[GetIOPByteLoc, 8]], Set[KBufferExtenEnd, Add[GetIOPByteLoc, 0F]];Set[KWaitLoc, 0FE0];Set[K1EntryLoc, 0F80];Set[K2EntryLoc, 0FBF];Set[K3EntryLoc, 0FCF];Set[KcLoc, 0FA0];  {WriteLink exploits the fact that IA.7=0}Set[K1ELoc, 0FB8];Set[KBELoc, 0FB9];{EMULATOR}{BitBlt definitions}	{BitBlt must have the following registers be distinct sets}	{Set1: VS, VD, TempDelta, TempBpl, SrcA, DstA, TempB}	{Set2: Hold, Save, Src, Dst, SrcA, DstA, Lcount}	{Set3: Rbb0, Rbb1, Rbb2, SrcA, DstA, Lcount}	{Set4: Mask1, Mask2, Src, Dst, SrcA, DstA, Lcount}	{Set5: Rbb0, Rbb1, Rbb2, Rbb3, Rbb4}{Other BitBlt definitions moved to Mesa.df}{   Display definitions   Description: Definitions for use by Display.mc, StartMesa.mc, InitDLion.mc   Author: Jim Frandeen   Created: November 3, 1981   Last edit: Jim Frandeen  November 3, 1981  5:16 PM}{Format of Display Control Status Block}Set[DisplayCSBOffset, 0E8]; {14001 (uIOPage) + 0E8 = 140E9}Set[currentIOCB, 0];	{140E9}  Set[fieldCmd, 1];	{140EA}	 Set[wakeupMask, 2];	{140EB}	Set[syncCmd, 3];	{140EC}Set[cursorX, 4];	{140ED}Set[cursorY, 5];	{140EE}Set[border, 6];	{140EF}Set[cursorMap, 7];	{140F0-140FF}Set[IOPage.DSCB.fieldCmd, 0EA]; {14000 + EA = 140EA}  Set[IOPage.DSCB.syncCmd, 0EC]; {14000 + EC = 140EC}  Set[IOPage.DCSB, 0E9];Set[DCSB.cursorMap, 7];Set[PicLenShifted, 0CA]; {PicLength = 328'x = 808'd. PicLenShifted = RShift2 PicLength}{Ethernet Author: Sandman Created: October 27, 1980  4:03 PM, Last Edited: October 27, 1980  4:08 PM}MacroDef[SuppressTimingWarning,LOOPHOLE[stw]];MacroDef[WriteOK,LOOPHOLE[wok]];{IOP Constants}Set[IOPOutMode, 2];	{IOP port output mode}{Set[IOPInMode, 1];	{IOP port input mode}previously set}Set[IOPAWMode, 3];	{IOP port alwaysWU mode}{Protected Area DefinitionsThe protected area of control store holds those microinstructions that must not be disturbed while the IOP interprets the boot file residing in main storage.  In particular, the IOP task, the memory refresh task, the emulator idle loop, the error trap location (location 0), and maintenance panel routines}Set[ProtectStart, 0], Set[ProtectFence, 0FF];Set[IdleLoc, 81], Set[Maintenance1Loc, 82], Set[Maintenance2Loc, 83], Set[Maintenance3Loc, 84];Set[ErrorHandlerLoc, 100];</pre>
  </body>
</html>
