<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>Intermezzo>dlion>vectorops.mc!1</title>
  </head>
  <body>
    <pre>
{File : VECTOROPS.mcAuthor : Gwan SantosaDate :  2-Aug-85 14:11:37This program does the following vector operations :1. Get a pointer to a maximum value of a vector.2. Get a pointer to a minimum value of a vector.3. Get a pointer to an absolute minimum value of a vector.4. Get a pointer to an absolute maximum value of a vector.5. Get sum of vector's elements (not coded yet).Algorithm (for 1 to 4) :	Fetch stack parameters. (TOS = count down counter)	Check counter, if 0, exit.	If 1, exit.	Otherwise :	Initialize current position to 1.	Initialize index to 0.	Fetch 2 floating point numbers from array.	Store the first element into reference register.Inner loop :		Call comparison subroutine.	If TOS is 0, done.	Else :	Update current position	Fetch next element.	Back to Inner loop	Comparison subroutine :	Check if to find absolute extreme.	If yes, convert sign bit to +.	Else :	Compare 2 numbers.	If new extreme is found, update index and reference register.	Return	}{Set[L1.FS.NR.0C, 0C];}Set[L0.VO.RO.04, 04];Set[L0.VO.RO.05, 05];Set[L0.VO.RO.09, 09];Set[L0.VO.RO.0A, 0A];Set[L0.VO.RO.0B, 0B];RegDef[rCOUNT, R, 04]; {=S}RegDef[rRESMN, R, 05]; {=PC}RegDef[uINDEX, U, 42];RegDef[uNEWH, U, 44];RegDef[uMAXH, U, 05];RegDef[uMAXL, U, 56];	Ybus &larr; TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[0C, 10, ub2op]; {Check if size = NIL}	Ybus &larr; TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[0D, 10, ub2op]; {Check if size = NIL}	Ybus &larr; TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[0E, 10, ub2op]; {Check if size = NIL}		Ybus &larr; TOSH xor smallpl, ZeroBr, GOTO[VOBK1],	c3, at[0F, 10, ub2op]; {Check if size = NIL}	VOBK1:	TT &larr; 0FF + 1, BRANCH[VOER1, $],	 	c1; {set PPort to read}	Q &larr; uPPsave, L1 &larr; L1.FS.NR.0C,		c2;	PPort &larr; Q and ~TT, CALL[SaveAllRegsB2],	c3; {Save all registers}		MAR &larr; [rhS, S - 1],			c1, at[L1.FS.NR.0C, 10, SaveRegsB2Ret];	Ybus &larr; TOS, ZeroBr, CANCELBR[$, 2],	c2; {Check if size = 0}	Q &larr; MD, BRANCH[$, VOER0],		c3;		MAR &larr; [rhS, S + 0],			c1;	TOS &larr; TOS - 1, ZeroBr,			c2; {check if only 1 entry}	TT &larr; MD, BRANCH[$, VOEX0],		c3;		rhTT &larr; Q LRot0,				c1;	FloatNop,				c2;	FloatNop,				c3;	TS101:	Map &larr; [rhTT, TT + 0], L1 &larr; L1.FS.NR.0C, c1;	uTT &larr; TT, L0 &larr; L0.VO.RO.04, 		c2;	rhRx &larr; Rx &larr; MD, XRefBr,			c3;	TS202:	MAR &larr; Q &larr; [rhRx, TT + 0], BRANCH[VOCH0, $],	c1, at[L0.VO.RO.04, 10, NRMapFixCallerB2];	Rx &larr; Q,						c2;	TOSH &larr; MD,					c3;	TS303:	MAR &larr; Rx &larr; [rhRx, Rx + 1], L2 &larr; 00,	c1; {Get first element and initialize as MAX}	uMAXH &larr; TOSH, BRANCH[$, FXVO0, 1],	c2;	TOSH &larr; MD,				c3;			TS404:	MAR &larr; Rx &larr; [rhRx, Rx + 1], L2 &larr; 01,	c1, at[00, 10, FETCHRET];	uMAXL &larr; TOSH, BRANCH[$, FXVO1, 1],	c2;	TOSH &larr; MD,				c3;	TS505:	MAR &larr; Rx &larr; [rhRx, Rx + 1], L2 &larr; 02,	c1, at[01, 10, FETCHRET];	uNEWH &larr; TOSH, BRANCH[$, FXVO2, 1],	c2;	TOSH &larr; MD,				c3; {Get second element and initialize as NEW}	TS606:	rCOUNT &larr; 1,					c1, at[02, 10, FETCHRET];	uINDEX &larr; 0,					c2; {Index keeps track of the latest extreme}	FloatMode.RN.AI.IEEE, FloatFLOW, CALL[VOCP],	c3; {Count keeps track of the current position}{========================================================================================================Inner loop========================================================================================================}		TOS &larr; TOS - 1, ZeroBr,			c1, at[0, 10, COMPRET]; {TOS is the count down counter}	rCOUNT &larr; rCOUNT + 1, BRANCH[$, VOEX1],	c2; {If TOS = 0, done}	L2 &larr; 03,				c3; {Current position (rCOUNT) is updated}		MAR &larr; Rx &larr; [rhRx, Rx + 1], 		c1; {Fetch next element}	BRANCH[$, FXVO3, 1],			c2;	TOSH &larr; MD, 				c3;	MAR &larr; Rx &larr; [rhRx, Rx + 1], 		c1, at[03, 10, FETCHRET];	uNEWH &larr; TOSH, BRANCH[$, FXVO4, 1],	c2;CHRT5:	TOSH &larr; MD, CALL[VOCP],			c3; {Call comparison subroutine}	{==========================================================================================Compare subroutine==========================================================================================This subroutine handles 4 comparisons.The low 2 bits of ib determines which operation.00 : Find index of max. value.01 : Find index of min. value.10 : Find index of absolute max. value.11 : Find index of absolute min. value.If a new extreme value is found, it will update the index and the new extreme value isloaded into a reference register uMAX}VOCP:	Xbus &larr; ibNA, XDisp,		c1;	Q &larr; uMAXH, DISP4[MAXMIN, 0D],	c2;		GOTO[VCOM],			c3, at[0D, 10, MAXMIN];		TT &larr; ~TT xor TT,		c3, at[0F, 10, MAXMIN];		TT &larr; RShift1 TT, SE &larr; 0,	c1; {This section convert the sign bit to +}	Q  &larr; TT and Q,			c2;	uMAXH &larr; Q,			c3;		Q &larr; uNEWH,			c1;	Q &larr; TT and Q,			c2;	uNEWH &larr; Q, GOTO[VCOM],		c3;		VCOM:	FloatAB &larr; uNEWH,		c1;		FloatAB &larr; TOSH LRot0,		c2;	FloatA &larr; uMAXH,	FLAMinusB,	c3;		FloatA &larr; uMAXL,			c1;			FloatNop,			c2;	Noop,				c3;		L3 &larr; 0,				c1;		Noop,				c2;	FloatUnloadS,	Float.M,	c3;		FloatUnloadS,	Float.L,	c1;		rSTATUS &larr; PPort,		c2;	rRESMN &larr; FloatResult,		c3;		Q &larr; FloatResult,		c1;	rRESMN &larr; rRESMN LRot8,		c2;		rRESMN &larr; rRESMN and 80, 	c3;		Xbus &larr; ibNA, XDisp,		c1;	DISP4[VOMAXMIN, 0E],		c2;			Ybus &larr; rRESMN, ZeroBr,		c3, at[0E, 10, VOMAXMIN]; {Determine max. value}			BRANCH[FNMAX1, SMMAX],		c1;	FNMAX1:	Q &larr; uNEWH, 			c2; {B&gt;A, New max. is found}	uMAXH &larr; Q,			c3; {Update uMAXH and uMAXL}			uMAXL &larr; TOSH,			c1; {They now contain the new extreme value}	uINDEX &larr; rCOUNT, L3Disp,	c2;	RET[COMPRET],			c3;	SMMAX:	L3Disp,				c2;	RET[COMPRET],			c3;	Ybus &larr; rRESMN, ZeroBr,		c3, at[0F, 10, VOMAXMIN]; {Determine min. value}	BRANCH[SMMIN, FNMIN1],		c1;	FNMIN1:	Q &larr; uNEWH, 			c2; {New min. is found}	uMAXH &larr; Q,			c3; {Update uMAXH and uMAXL}			uMAXL &larr; TOSH, 			c1; {They now contain the new extreme value}	uINDEX &larr; rCOUNT, L3Disp,	c2;	RET[COMPRET],			c3;	SMMIN:	L3Disp,				c2;	RET[COMPRET],			c3;	{==========================================================================================Remap==========================================================================================}VOCH0:	CALL[NRLMapFixB2],		c2;VOCH1:	CALL[NRLMapFixB2],		c2;VOCH5:	CALL[NRLMapFixB2],		c2;FXVO0:	GOTO[VOFX],		c3;FXVO1:	GOTO[VOFX],		c3;FXVO2:	GOTO[VOFX],		c3;FXVO3:	TT &larr; uTT, GOTO[VOFX],		c3;		VOFX:	Q &larr; 0FF + 1,			c1;	TT &larr; TT + Q, CarryBr,		c2;	Q &larr; rhTT, BRANCH[VONC0, VOC0],	c3;	VONC0:	GOTO[VOMG0],			c1;	VOC0:	Q &larr; Q + 1,			c1;VOMG0:	rhTT &larr; Q LRot0,			c2;	uTT &larr; TT,			c3;	Map &larr; [rhTT, TT + 0], L0 &larr; L0.VO.RO.05,	c1;	TOSH &larr; Rx, L1 &larr; L1.FS.NR.0C,		c2;	rhRx &larr; Rx &larr; MD, XRefBr,			c3;		MAR &larr; Q &larr; [rhRx, TOSH + 0], BRANCH[VOCH1, $],	c1, at[L0.VO.RO.05, 10, NRMapFixCallerB2];	Rx &larr; Q, L2Disp,			c2;	TOSH &larr; MD, DISP4[FETCHRET],		c3;FXVO4:	TT &larr; uTT,			c3;	Q &larr; 0FF + 1,			c1;	TT &larr; TT + Q, CarryBr,		c2;	Q &larr; rhTT, BRANCH[VONC4, VOC4],	c3;	VONC4:	GOTO[MGVO1],			c1;		VOC4:	Q &larr; Q + 1,			c1;MGVO1:	rhTT &larr; Q LRot0,			c2;	TOSH &larr; Rx,			c3;	Map &larr; [rhTT, TT + 0], L1 &larr; L1.FS.NR.0C,	c1;	uTT &larr; TT, L0 &larr; L0.VO.RO.09,		c2;	rhRx &larr; Rx &larr; MD, XRefBr,			c3;		MAR &larr; Q &larr; [rhRx, TOSH + 0], BRANCH[VOCH5, $],	c1, at[L0.VO.RO.09, 10, NRMapFixCallerB2];	Rx &larr; Q, GOTO[CHRT5],				c2;	{==========================================================================================Exit points==========================================================================================}VOEX0:	S &larr; S - 2, L1 &larr; L1.RestoreAndExit,	c1;	Xbus &larr; ib, L1Disp,			c2;		DISP4[RestoreRegsB2Ret],	        c3;	VOEX1:	TOS &larr; uINDEX,				c3;	TOSH &larr; uTOSH,				c1;	S &larr; uS,					c2;	PC &larr; uPC,				c3;		S &larr; S - 2, L1 &larr; L1.RestoreAndExit,	c1;	Xbus &larr; ib, L1Disp,			c2;		PV &larr; uPVx, DISP4[RestoreRegsB2Ret], 	c3;		{==========================================================================================Error cases==========================================================================================}VOER0:	Noop,		c1;VOER1:	GOTO[ufnX3],	c2;	{END}</pre>
  </body>
</html>
