{Bdbinit.mcLast edited: Purcell,      9-Feb-85 12:25:24  {%%} disabled mapinitLast edited: don,      6-Feb-85  8:58:38 cleaned up a little -- no changesLast edited: Purcell,     6-Feb-85  0:08:13 stallLast edited: Purcell,    3-Feb-85 20:17:16  interface real page stays at 3 {%4}.by cal 11-Jan-85 14:36:07changed MAR's to Map's where appropriate  1-Feb-85 10:28:48}Reserve[0F6F]; Reserve[0F78]; Reserve[0F7F,0FFF];	{Kernel}SetTask[0];StartAddress[Germ];Set[labelPageLow, 10];	{low 16 bits of file page number}Set[bigVMrefFlg, 75'b];Set[vmSizeLoc, 100'b];RegDef[topPage, U, 0D];RegDef[uVMFileSize, U, 6A];Germ:	, CANCELBR[StartDBInit,0F],	c1, at[0,2,Germ];	, CANCELBR[StartDBInit,0F],	c1, at[1,2,Germ];StartDBInit:	Rx _ 41,	c2;	DCtl _ Rx LRot0,	c3;		ClrIntErr, c1;	IOPCtl _ 1,	c2;	Rx _ 040{wait 2 sec},	c3;	{Rx major, Q minor  }bLp:	Noop, BRANCH[$, bL2],	c1;	Noop, GOTO[bJn],	c2;bL2:	Rx _ Rx  - 1, ZeroBr,	c2;bJn:	Q _ Q - 1, ZeroBr, BRANCH[bLp, bStallDone],	c3;bBurdock:	IOPCtl _ 1, CANCELBR[$, 0F],	c1;	Rx _ 41,	c2;	DCtl _ Rx LRot0, TOSH _ 0,	c3;bStallDone: CANCELBR[$],	rhRx _ 0, Rx _ 0,	c1;	Q _ 0FF + 1,	c2;	TT _ 60{Vacant},	c3;initMap:	{init 32mb map to vacant}	Map _ [rhRx, Rx], BRANCH[$, initfixrh],	c1;{%%}	{MDR _ TT{Vacant}},	c2;	Rx _ Rx + Q, CarryBr, GOTO[initMap],	c3;	initfixrh:	Rx _ rhRx + 1, PgCarryBr, LOOPHOLE[byteTiming],	c2;	rhRx _ Rx LRot0, BRANCH[initMap, $],	c3;{%B}{***32MB:  I/O Page back where Mesa wanted it!!!}	Rx _ ~0FF,	c1;	TOS _ 2{%B 5},		c2;			rhRx _ 0,	c3;{Map[IOPageVp=0FF] _ 2 }	Map_ [rhRx, Rx],	c1;{%%}	{MDR _ TOS,}	c2;	,	c3;{update Interface page and interpret FPTOVP}LIa:	rhTOSH_ 0,	c1;	TOSH_ 0FF+1,	c2; {base address of IOCB page}	PV _ labelPageLow, c3;{%M	MAR _ [{rDrh}rhTOSH, {rE}PV+0], c1;	, c2;	{rE}PV _ MD, c3;  {read number of pages xferred}		uVMFileSize _ {rE}PV, c1;	, c2;	, c3;%M}{pretend for now 16K pages or 8MB VM/ sysout}	PV _ 40, c1;	PV _ PV LRot8, c2;	uVMFileSize _ {rE}PV, c3;{Map[InterfacePageVp] _ 3}	rhTT _ {6'b}INTERFACEspace, CANCELBR[$, 1],	c1;	TT _ {0'b}INTERFACEbasePage,	c2;	TT _ TT LRot8,	c3;	Rx _ {3%M}{6}3{%4}{real interface page},	c1;	Rx{300} _ Rx LRot8,	c2;{	LVM	{rBrh}rhRx _ {rB}Rx _ {rB}Rx + 030{dirty},	c3;}	rhRx _ 0C0, Rx _ Rx + 0C0{dirty},	c3;LIb:	Map{InterfacePage} _ [rhTT,TT],	c1;	MDR _ Rx{3C0},	c2;	,	c3;      	MAR_ [rhRx, 15'b{MachineType} + 0],	c1;	MDR _ 6{\DANDELION},	c2;	Q _ uVMFileSize,	c3;					{**32MB: Say we can do big VM refs (will put real switch in later)}LIc:	MAR _ [rhRx, bigVMrefFlg + 0], c1;	MDR _ 1 {true}, c2;	, c3;		MAR _ [rhRx, vmSizeLoc + 0], c1;	MDR _ Q, c2;	, c3;{%M	Q _ topPage{virtual},	c1;	Q _ Q + 40,{ map not included}{topPage was measured as if map were 32KB}	c2;	Q{NRealPages} _ Q + 0FF{+1}{bank 0 was not incl but},	c3;%M}	TT _ 09,	c1;	TT _ TT LRot8,	c2;	Q _ TT - 1,	c3;{faking size of real mem at 1.5 mb-gap or 1.0 mb + gap}{%M}LId:	MAR_ [{rBrh}rhRx, 70'b{NRealPages} + 0],	c1;	MDR _ Q{NRealPages} {_ topPage}{rC{C00}},	c2;	Noop,	c3;{interpret FPTOVP setup}{assume FPTOVP doesn't cross segment}{for i{acR} _ {{501'b=141h}}{201h}IOPage+1 to MaxRealPage{rC}	}{	unless FPTOVP[i-1]=none{-1}	}{	do MAP[FPTOVP[i-1]]:vp _ i	}	MAR_ [rhRx, 73'b{FPTOVPStart} + 0],	c1;	,	c2;	TT{F2Vpage} _ MD,	c3;Set[fpvpPageOff, Add[IOPageHigh, 1{file1=real2}]];Set[IOPagePage, Rshift[IOPage, 8]];{%B offset 3{dbGap} seg's}	TOS _ 3{dbGap}, c1;	TOS _ TOS LRot8, c2;	TT _ TT + TOS, c3;{%B}LIe:	TT{F2VrealPage+IOPageHigh} _ TT + fpvpPageOff,	c1;	rhTT _ TT _ TT LRot8,	c2;	TT _ TT and ~0FF,	c3;	TT{F2V+IOPagePage} _ TT + IOPagePage,	c1;	,	c2;	rhRx _ 1{MapSpace}, c3;	TOS _ IOPageHigh, c1;		{***32MB:  Count = 201H now}	TOS _ TOS LRot8, c2;	TOS _ TOS + IOPagePage +1, c3;{interpret FPTOVP Loop 	}{acR:	FPTOVP[i-1] ptr 	}{rB:	FPTOVP[i-1]:vp	}{rC:	i _ {{501'b=141h}}{201h}IOPage+1		}{Q:	NRealPages= C00		}{rBrh:	10000{Map}	}{spin2:	GOTO[spin2],	c*;}{%%%}f2vLp:	MAR_ TT _ [rhTT, TT + 0],	c1;		c2;	Rx{vp} _ MD,	c3;{%B}	Ybus _ Rx + 1, CarryBr{=1?},	c1;	BRANCH[$, none],	c2;	rhRx _ Rx _ Rx LRot8,	c3;	,	c1;	TOS _ TOS LRot8, XRefBr,	c2;	Ybus _ TOS + 0F, NibCarryBr{nondisplay bank?}, BRANCH[$, fvMod],	c3;{%B}	Map_ [rhRx, Rx], BRANCH[fvNo, $],	c1;{%%}	{MDR _ TOS{i},} GOTO[none],	c2;fvNo:	Noop, GOTO[none],	c2;fvMod:	Map_ [rhRx, Rx], BRANCH[fvMNo, $],	c1;{%%}	{MDR _ TOS{i} + 70}{move over flags to "dp" bit}, GOTO[none],	c2;fvMNo:	Noop, GOTO[none],	c2;none:	TOS _ TOS LRot8, CANCELBR[$, 1],	c3;	TOS _ TOS + 1,	c1;	Ybus _ TOS xor Q{NRealPages}, ZeroBr,	c2;	TT _ TT + 1, BRANCH[f2vLp, $],	c3;{%B}	Rx _ ~0FF,	c1;	TOS _ 2{%B 5},		c2;		{***32MB:  I/O Page back where Mesa wanted it!!!}	rhRx _ 0,	c3;{Map[IOPageVp=0FF] _ 2 }	Map_ [rhRx, Rx],	c1;{%%}	{MDR _ TOS},	c2;	,	c3;	{start u register init here}LIf:	Rx{182} _ 0C1 LRot1,	c1;	Rx _ Rx LRot1,	c2;	uPcBreak _ Rx{304},	c3;	,	c1;	Q _ rhRx,	c2;	UGsave _ Q,	c3;	Rx _ VALspace,	c1;	uValHigh _ Rx,	c2;	{stackP _ 0,}	c3;	Rx _ Rx xor ~Rx,	c1;	unboundPvar _ Rx,	c2;	unboundFvar _ Rx,	c3;	uStkLimO _ Rx,	c1;	uWP _ 0,	c2;	uWDC _ 0{uWDC inited by mesaInit},	c3;	Rx _  ~0FD,	c1;	Rx _ Rx LRot8,	c2;	uBfResidualRhmask _ Rx{2FF},	c3;	Rx _  0A0,	c1;	Rx _ Rx LRot8,	c2;	uFreeStackBlock _ Rx{0A000},	c3;	Rx _  0FF + 1,	c1;	uFxNoPushReturn _ Rx{100h},	c2;	Rx _  LShift1(Rx + Rx), SE_0,	c3;	uFxInCall _ Rx{400h},	c1;	Rx _  7F,	c2;	u7F _ Rx{7F},	c3;	Rx _  ~0FF,	c1;{OK}	u0FF _ ~Rx{~0FF},	c2;	uFF00 _  Q _ Rx{~0FF},	c3;	Rx _ Q{0FF00} or 1,	c1;	Rx _ Rx LRot8,	c2;	u1FF _ Rx{1FF},	c3;	Rx _ Q{0FF00} or 3,	c1;	Rx _ Rx LRot8,	c2;	uTT3FF _ Rx{3FF},	c3;	Rx _ Q{0FF00} or 3,	c1;	Rx _ Rx LRot8,	c2;	u3FF _ Rx{3FF},	c3;	Rx _ Q{0FF00} or 0F,	c1;	Rx _ Rx LRot8,	c2;	u0FFF _ Rx{0FFF},	c3;	Rx _ Q{0FF00} or 1F,	c1;	Rx _ Rx LRot8,	c2;	u1FFF _ Rx{1FFF},	c3;	Rx _ Q{0FF00} or 3F,	c1;	Rx _ Rx LRot8,	c2;	uTT3FFF _ Rx{3FFF},	c3;	Rx _ Q{0FF00} or 3F,	c1;	Rx _ Rx LRot8,	c2;	u3FFF _ Rx{3FFF},	c3;	Rx _ Q{0FF00} or 7F,	c1;	Rx _ Rx LRot8,	c2;	u7FFF _ Rx{7FFF},	c3;	Rx _ Q{0FF00} or 7,	c1;	Rx _ Rx LRot8,	c2;	u7FF _ Rx{7FF},	c3;	,	c1;	Rx _ Rx xor 1,	c2;	u7FE _ Rx{7FF},	c3;	Rx _ 0,	c1;	uLispOptions _ Rx,	c2;	c3;	Rx _ 80,	c1;	Rx _  Rx LRot8,	c2;	uBFmark _ Rx{8000},	c3;{compliance: using uSTACKspace with duplicated high byte for bind ptr}	Rx _ STACKspace,	c1;	Rx _ Rx LRot8,	c2;	Rx _ Rx or STACKspace,	c3;	Noop,	c1;	uSTACKspace _ Rx,	c2;	Rx _ 0C0,	c3;	Rx _  Rx LRot8,	c1;	Noop,	c2;	uFXmark _ Rx{C000},	c3;	Set[UFNTablePageHalf, Rshift[UFNTablebase, 9]];	Rx _  UFNTablePageHalf,	c1;	Rx _  Rx LRot8,	c2;	uUFNTableBaseHalf _ Rx, GOTO[dbinitthru],	c3;	{ E N D }