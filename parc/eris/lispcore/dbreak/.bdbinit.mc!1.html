<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispCore>DBreak>bdbinit.mc!1</title>
  </head>
  <body>
    <pre>
{Bdbinit.mcLast edited: Purcell,      9-Feb-85 12:25:24  {%%} disabled mapinitLast edited: don,      6-Feb-85  8:58:38 cleaned up a little -- no changesLast edited: Purcell,     6-Feb-85  0:08:13 stallLast edited: Purcell,    3-Feb-85 20:17:16  interface real page stays at 3 {%4}.by cal 11-Jan-85 14:36:07changed MAR's to Map's where appropriate  1-Feb-85 10:28:48}Reserve[0F6F]; Reserve[0F78]; Reserve[0F7F,0FFF];	{Kernel}SetTask[0];StartAddress[Germ];Set[labelPageLow, 10];	{low 16 bits of file page number}Set[bigVMrefFlg, 75'b];Set[vmSizeLoc, 100'b];RegDef[topPage, U, 0D];RegDef[uVMFileSize, U, 6A];Germ:	, CANCELBR[StartDBInit,0F],	c1, at[0,2,Germ];	, CANCELBR[StartDBInit,0F],	c1, at[1,2,Germ];StartDBInit:	Rx &larr; 41,	c2;	DCtl &larr; Rx LRot0,	c3;		ClrIntErr, c1;	IOPCtl &larr; 1,	c2;	Rx &larr; 040{wait 2 sec},	c3;	{Rx major, Q minor  }bLp:	Noop, BRANCH[$, bL2],	c1;	Noop, GOTO[bJn],	c2;bL2:	Rx &larr; Rx  - 1, ZeroBr,	c2;bJn:	Q &larr; Q - 1, ZeroBr, BRANCH[bLp, bStallDone],	c3;bBurdock:	IOPCtl &larr; 1, CANCELBR[$, 0F],	c1;	Rx &larr; 41,	c2;	DCtl &larr; Rx LRot0, TOSH &larr; 0,	c3;bStallDone: CANCELBR[$],	rhRx &larr; 0, Rx &larr; 0,	c1;	Q &larr; 0FF + 1,	c2;	TT &larr; 60{Vacant},	c3;initMap:	{init 32mb map to vacant}	Map &larr; [rhRx, Rx], BRANCH[$, initfixrh],	c1;{%%}	{MDR &larr; TT{Vacant}},	c2;	Rx &larr; Rx + Q, CarryBr, GOTO[initMap],	c3;	initfixrh:	Rx &larr; rhRx + 1, PgCarryBr, LOOPHOLE[byteTiming],	c2;	rhRx &larr; Rx LRot0, BRANCH[initMap, $],	c3;{%B}{***32MB:  I/O Page back where Mesa wanted it!!!}	Rx &larr; ~0FF,	c1;	TOS &larr; 2{%B 5},		c2;			rhRx &larr; 0,	c3;{Map[IOPageVp=0FF] &larr; 2 }	Map&larr; [rhRx, Rx],	c1;{%%}	{MDR &larr; TOS,}	c2;	,	c3;{update Interface page and interpret FPTOVP}LIa:	rhTOSH&larr; 0,	c1;	TOSH&larr; 0FF+1,	c2; {base address of IOCB page}	PV &larr; labelPageLow, c3;{%M	MAR &larr; [{rDrh}rhTOSH, {rE}PV+0], c1;	, c2;	{rE}PV &larr; MD, c3;  {read number of pages xferred}		uVMFileSize &larr; {rE}PV, c1;	, c2;	, c3;%M}{pretend for now 16K pages or 8MB VM/ sysout}	PV &larr; 40, c1;	PV &larr; PV LRot8, c2;	uVMFileSize &larr; {rE}PV, c3;{Map[InterfacePageVp] &larr; 3}	rhTT &larr; {6'b}INTERFACEspace, CANCELBR[$, 1],	c1;	TT &larr; {0'b}INTERFACEbasePage,	c2;	TT &larr; TT LRot8,	c3;	Rx &larr; {3%M}{6}3{%4}{real interface page},	c1;	Rx{300} &larr; Rx LRot8,	c2;{	LVM	{rBrh}rhRx &larr; {rB}Rx &larr; {rB}Rx + 030{dirty},	c3;}	rhRx &larr; 0C0, Rx &larr; Rx + 0C0{dirty},	c3;LIb:	Map{InterfacePage} &larr; [rhTT,TT],	c1;	MDR &larr; Rx{3C0},	c2;	,	c3;      	MAR&larr; [rhRx, 15'b{MachineType} + 0],	c1;	MDR &larr; 6{\DANDELION},	c2;	Q &larr; uVMFileSize,	c3;					{**32MB: Say we can do big VM refs (will put real switch in later)}LIc:	MAR &larr; [rhRx, bigVMrefFlg + 0], c1;	MDR &larr; 1 {true}, c2;	, c3;		MAR &larr; [rhRx, vmSizeLoc + 0], c1;	MDR &larr; Q, c2;	, c3;{%M	Q &larr; topPage{virtual},	c1;	Q &larr; Q + 40,{ map not included}{topPage was measured as if map were 32KB}	c2;	Q{NRealPages} &larr; Q + 0FF{+1}{bank 0 was not incl but},	c3;%M}	TT &larr; 09,	c1;	TT &larr; TT LRot8,	c2;	Q &larr; TT - 1,	c3;{faking size of real mem at 1.5 mb-gap or 1.0 mb + gap}{%M}LId:	MAR&larr; [{rBrh}rhRx, 70'b{NRealPages} + 0],	c1;	MDR &larr; Q{NRealPages} {&larr; topPage}{rC{C00}},	c2;	Noop,	c3;{interpret FPTOVP setup}{assume FPTOVP doesn't cross segment}{for i{acR} &larr; {{501'b=141h}}{201h}IOPage+1 to MaxRealPage{rC}	}{	unless FPTOVP[i-1]=none{-1}	}{	do MAP[FPTOVP[i-1]]:vp &larr; i	}	MAR&larr; [rhRx, 73'b{FPTOVPStart} + 0],	c1;	,	c2;	TT{F2Vpage} &larr; MD,	c3;Set[fpvpPageOff, Add[IOPageHigh, 1{file1=real2}]];Set[IOPagePage, Rshift[IOPage, 8]];{%B offset 3{dbGap} seg's}	TOS &larr; 3{dbGap}, c1;	TOS &larr; TOS LRot8, c2;	TT &larr; TT + TOS, c3;{%B}LIe:	TT{F2VrealPage+IOPageHigh} &larr; TT + fpvpPageOff,	c1;	rhTT &larr; TT &larr; TT LRot8,	c2;	TT &larr; TT and ~0FF,	c3;	TT{F2V+IOPagePage} &larr; TT + IOPagePage,	c1;	,	c2;	rhRx &larr; 1{MapSpace}, c3;	TOS &larr; IOPageHigh, c1;		{***32MB:  Count = 201H now}	TOS &larr; TOS LRot8, c2;	TOS &larr; TOS + IOPagePage +1, c3;{interpret FPTOVP Loop 	}{acR:	FPTOVP[i-1] ptr 	}{rB:	FPTOVP[i-1]:vp	}{rC:	i &larr; {{501'b=141h}}{201h}IOPage+1		}{Q:	NRealPages= C00		}{rBrh:	10000{Map}	}{spin2:	GOTO[spin2],	c*;}{%%%}f2vLp:	MAR&larr; TT &larr; [rhTT, TT + 0],	c1;		c2;	Rx{vp} &larr; MD,	c3;{%B}	Ybus &larr; Rx + 1, CarryBr{=1?},	c1;	BRANCH[$, none],	c2;	rhRx &larr; Rx &larr; Rx LRot8,	c3;	,	c1;	TOS &larr; TOS LRot8, XRefBr,	c2;	Ybus &larr; TOS + 0F, NibCarryBr{nondisplay bank?}, BRANCH[$, fvMod],	c3;{%B}	Map&larr; [rhRx, Rx], BRANCH[fvNo, $],	c1;{%%}	{MDR &larr; TOS{i},} GOTO[none],	c2;fvNo:	Noop, GOTO[none],	c2;fvMod:	Map&larr; [rhRx, Rx], BRANCH[fvMNo, $],	c1;{%%}	{MDR &larr; TOS{i} + 70}{move over flags to "dp" bit}, GOTO[none],	c2;fvMNo:	Noop, GOTO[none],	c2;none:	TOS &larr; TOS LRot8, CANCELBR[$, 1],	c3;	TOS &larr; TOS + 1,	c1;	Ybus &larr; TOS xor Q{NRealPages}, ZeroBr,	c2;	TT &larr; TT + 1, BRANCH[f2vLp, $],	c3;{%B}	Rx &larr; ~0FF,	c1;	TOS &larr; 2{%B 5},		c2;		{***32MB:  I/O Page back where Mesa wanted it!!!}	rhRx &larr; 0,	c3;{Map[IOPageVp=0FF] &larr; 2 }	Map&larr; [rhRx, Rx],	c1;{%%}	{MDR &larr; TOS},	c2;	,	c3;	{start u register init here}LIf:	Rx{182} &larr; 0C1 LRot1,	c1;	Rx &larr; Rx LRot1,	c2;	uPcBreak &larr; Rx{304},	c3;	,	c1;	Q &larr; rhRx,	c2;	UGsave &larr; Q,	c3;	Rx &larr; VALspace,	c1;	uValHigh &larr; Rx,	c2;	{stackP &larr; 0,}	c3;	Rx &larr; Rx xor ~Rx,	c1;	unboundPvar &larr; Rx,	c2;	unboundFvar &larr; Rx,	c3;	uStkLimO &larr; Rx,	c1;	uWP &larr; 0,	c2;	uWDC &larr; 0{uWDC inited by mesaInit},	c3;	Rx &larr;  ~0FD,	c1;	Rx &larr; Rx LRot8,	c2;	uBfResidualRhmask &larr; Rx{2FF},	c3;	Rx &larr;  0A0,	c1;	Rx &larr; Rx LRot8,	c2;	uFreeStackBlock &larr; Rx{0A000},	c3;	Rx &larr;  0FF + 1,	c1;	uFxNoPushReturn &larr; Rx{100h},	c2;	Rx &larr;  LShift1(Rx + Rx), SE&larr;0,	c3;	uFxInCall &larr; Rx{400h},	c1;	Rx &larr;  7F,	c2;	u7F &larr; Rx{7F},	c3;	Rx &larr;  ~0FF,	c1;{OK}	u0FF &larr; ~Rx{~0FF},	c2;	uFF00 &larr;  Q &larr; Rx{~0FF},	c3;	Rx &larr; Q{0FF00} or 1,	c1;	Rx &larr; Rx LRot8,	c2;	u1FF &larr; Rx{1FF},	c3;	Rx &larr; Q{0FF00} or 3,	c1;	Rx &larr; Rx LRot8,	c2;	uTT3FF &larr; Rx{3FF},	c3;	Rx &larr; Q{0FF00} or 3,	c1;	Rx &larr; Rx LRot8,	c2;	u3FF &larr; Rx{3FF},	c3;	Rx &larr; Q{0FF00} or 0F,	c1;	Rx &larr; Rx LRot8,	c2;	u0FFF &larr; Rx{0FFF},	c3;	Rx &larr; Q{0FF00} or 1F,	c1;	Rx &larr; Rx LRot8,	c2;	u1FFF &larr; Rx{1FFF},	c3;	Rx &larr; Q{0FF00} or 3F,	c1;	Rx &larr; Rx LRot8,	c2;	uTT3FFF &larr; Rx{3FFF},	c3;	Rx &larr; Q{0FF00} or 3F,	c1;	Rx &larr; Rx LRot8,	c2;	u3FFF &larr; Rx{3FFF},	c3;	Rx &larr; Q{0FF00} or 7F,	c1;	Rx &larr; Rx LRot8,	c2;	u7FFF &larr; Rx{7FFF},	c3;	Rx &larr; Q{0FF00} or 7,	c1;	Rx &larr; Rx LRot8,	c2;	u7FF &larr; Rx{7FF},	c3;	,	c1;	Rx &larr; Rx xor 1,	c2;	u7FE &larr; Rx{7FF},	c3;	Rx &larr; 0,	c1;	uLispOptions &larr; Rx,	c2;	c3;	Rx &larr; 80,	c1;	Rx &larr;  Rx LRot8,	c2;	uBFmark &larr; Rx{8000},	c3;{compliance: using uSTACKspace with duplicated high byte for bind ptr}	Rx &larr; STACKspace,	c1;	Rx &larr; Rx LRot8,	c2;	Rx &larr; Rx or STACKspace,	c3;	Noop,	c1;	uSTACKspace &larr; Rx,	c2;	Rx &larr; 0C0,	c3;	Rx &larr;  Rx LRot8,	c1;	Noop,	c2;	uFXmark &larr; Rx{C000},	c3;	Set[UFNTablePageHalf, Rshift[UFNTablebase, 9]];	Rx &larr;  UFNTablePageHalf,	c1;	Rx &larr;  Rx LRot8,	c2;	uUFNTableBaseHalf &larr; Rx, GOTO[dbinitthru],	c3;	{ E N D }</pre>
  </body>
</html>
