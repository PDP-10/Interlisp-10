-- =======================-- File: EmSetUpVT100Pack.mesa -- Last revised by: Tom				16-Jul-84 14:09:25      -- Owner: Tom-- Overview: Provides the Set-Up Property Sheet for the VT100 terminal emulator.-- Copyright (C) Xerox Corporation 1983,1984. All rights reserved.DIRECTORY  CharDefs USING [Codes0],  EmGTTYActionDefs USING [ClearTab, Execute, GetNextTab, SetTab, TTyModeIs],  EmGTTYCharTransDefs USING [DC1, DC3, SetPoundSign],  EmGTTYComDefs USING [ReportToHost],  EmGTTYPrivDefs USING [    EmData, EmIconData, GetComHandle, GetFileData, LptIconData, maxColumns,       noTabsLeft, permanentZone, SavePSData, shortZone, validId],  EmSetUpVT100Defs USING [],  EmTTYDefs USING [Lpttrtttyicondata, Lpttrtttyschemadata, Trtttyicondata],  Environment USING [Block, Byte],  GVDTDefs USING [CRShape, GetCursorShape, SetCursorShape],  HelpDefs USING [OpenHelpWindow],  IconDefs USING [Icon, ParentFromIcon, ReferenceFromIcon],  MessageDefs USING [Msg, Msgkey, msgNil],  MessageSwnDefs USING [DisplayMessageLiteral],  NSFile USING [Close, Error, Handle, OpenChild],  ParameterDefs USING [    Aqparmsheetbodydata, BuildParmSheetBody, CreateParm, DestroyTextParmvalue,     EraseParm, Find, GetCardinal, GetChoiceParmvalue, GetStateParmvalue,     GetTextParmvalue, Parm, Parmdata, Parmkey, parmNil, Pvbuildpsbody,     Pvchoiceparmchanged, Pvdestroydata, Pvhelp, Pvparmsarevalid, Pvstateparmchanged,     Pvtextparmchanged, Rgparmdata, SelectTextparm, ShowParm],  PswnDefs USING [Aqopendata, PsOpen, Pvpsmgr],  RS232CEnvironment USING [LineSpeed, Parity],  SchemaDefs USING [Lschema, lschemaNil, Posn],  StandardDefs USING [String],  SvDefs USING [DecimalAppendCv],  TraitDefs USING [Instance, MyData],  WSStringDefs USING [StringFromLONGSTRING],  WSStringUtilDefs USING [    CopyString, CvFromStringDecimal, DestroyString, InvalidNumber, stringNull],  ZkeyMessageDefs USING [GetMsg, Msgkey];EmSetUpVT100Pack: PROGRAM  IMPORTS     EmGTTYActionDefs, EmGTTYCharTransDefs, EmGTTYComDefs, EmGTTYPrivDefs, GVDTDefs,     HelpDefs, IconDefs, MessageSwnDefs, NSFile, ParameterDefs, PswnDefs, SchemaDefs,     SvDefs, TraitDefs, WSStringDefs, WSStringUtilDefs, ZkeyMessageDefs  EXPORTS EmSetUpVT100Defs  SHARES IconDefs, ParameterDefs =  BEGIN  --=======================  --  Constants   --=======================    nil:  LONG STRING = "";	-- null lsv  tabs: CARDINAL = 28;		-- parm sheet display offset    numParms:     CARDINAL = 13;	-- number of parms in main group excluding root parm  subgroupSize: CARDINAL = 32;	-- number of parms in Screen Tab subgroup      -- Indices into list of parameters of main group.  parmSaveData:	     CARDINAL = 0;  parmScroll:        CARDINAL = 1;  parmCursor:        CARDINAL = 2;  parmMarginBell:    CARDINAL = 3;  parmAnsiVT52:      CARDINAL = 4;  parmPoundSign:     CARDINAL = 5;   parmAutoWrap:      CARDINAL = 6;  parmLTSActive:     CARDINAL = 7;  parmParity:        CARDINAL = 8;  parmTRSpeed:       CARDINAL = 9;  parmAnswerBackMsg: CARDINAL = 10;  parmScreenMode:    CARDINAL = 11;  parmTabGroup:      CARDINAL = 12;   -- Screen Tab Group indices.   parmColumn:        CARDINAL = 0;       --=======================  --  Private Types  --=======================    Aqosdata: TYPE = ARRAY [0..numParms] OF ParameterDefs.Parm;  Ptosdata: TYPE = LONG POINTER TO Aqosdata;    -- extra byte required due to MESA language limitation  XOnXOff: TYPE = PACKED ARRAY [0..2) OF Environment.Byte;        --=======================  --  Global Variables  --=======================    -- Tab column designators.   nextcol, 			-- next available slot in tab parm array  lastcol: CARDINAL _ 0;	-- last tab (column) position encountered    -- Boolean flags to indicate which parms were modified.  ansiChanged,  choiceChanged,  cursorChanged,  poundChanged,  textAnswerBackChanged: BOOLEAN _ FALSE;    -- Icon's lschema for trait data access.  lschemaTTYicon: SchemaDefs.Lschema _ SchemaDefs.lschemaNil;  -- Keep in global frame for shared access between Parm routines.	  ptosdata: Ptosdata _ NIL;		      -- Save global pointer to Init data structure so we can get handles at build-time.  parmdataMain: LONG POINTER TO ParameterDefs.Parmdata _ NIL;    -- Declare parm group arrays.  rgparmdataGroup0:   ParameterDefs.Rgparmdata _ DESCRIPTOR[NIL, 0];	  rgparmdataTabGroup: ParameterDefs.Rgparmdata _ DESCRIPTOR[NIL, 0];      --=======================  --  Public Procedure   --=======================    SetUpVT100Mgr: PUBLIC PswnDefs.Pvpsmgr =    -- PROCEDURE [ctxt: TreeEltDefs.Ctxt, pvreturncontrol: ParameterDefs.Pvreturnoscontrol] =     BEGIN    setupopendata: PswnDefs.Aqopendata;    cvOsWth: CARDINAL _ 425;      cvOSht:  CARDINAL = 350;        -- Parse message to get the width of the setup sheet,    -- so that it can be language-dependent.    cvOsWth _ WSStringUtilDefs.CvFromStringDecimal[ZkeyMessageDefs.GetMsg[keyZ457].msg !      WSStringUtilDefs.InvalidNumber => { cvOsWth _ 425; CONTINUE }];          IF cvOsWth > 600 THEN cvOsWth _ 600    ELSE IF cvOsWth < 200 THEN cvOsWth _ 200;        -- Set icon's lschema now so later we can access its data area.    lschemaTTYicon _ LOOPHOLE[ctxt, SchemaDefs.Lschema];        setupopendata _ [      areaAvoid: SchemaDefs.Posn[lschemaTTYicon].area,      bvHorizScrolling: FALSE,       bvVertScrolling:  FALSE,       lschemaRequestor: lschemaTTYicon,       pvbuildbody: BuildSetUpBody,       rsBody: [cvOsWth, cvOSht],       ctxt: ctxt,      pvreturncontrol: pvreturncontrol,       svTitle: ZkeyMessageDefs.GetMsg[keyZ939].msg];          -- Build the VT100 SetUp Sheet.    [] _ PswnDefs.PsOpen[@setupopendata]    END;  -- of SetUpVT100Mgr  --=======================  --  Internal Utilites  --=======================  BuildSetUpBody: ParameterDefs.Pvbuildpsbody =    -- PROCEDURE [lschemaViewer: SchemaDefs.Lschema, ctxt: TreeEltDefs.Ctxt]    -- RETURNS [lschemaBody: SchemaDefs.Lschema] =    BEGIN     -- Pointer to icon's trait data.      Mydata:   EmTTYDefs.Lpttrtttyschemadata = TraitDefs.MyData[lschemaTTYicon, trtTTYschema];     emdata:   EmGTTYPrivDefs.EmData = Mydata.lptEmState;    iconData: EmGTTYPrivDefs.LptIconData = emdata.iconData;    setupbodydata: ParameterDefs.Aqparmsheetbodydata;    svtab: ARRAY [0..subgroupSize) OF LONG STRING _ ALL[NIL];    i, stop: CARDINAL _ 0;  -- holds absolute tab position; stop+1 holds relative    DC3: XOnXOff _ ALL[EmGTTYCharTransDefs.DC3];        -- Send XOFF sequence to host.    EmGTTYComDefs.ReportToHost[emdata.commun, Environment.Block[@DC3, 0, 1]];        -- Reset change flags.    ansiChanged _    choiceChanged _    cursorChanged _    poundChanged _    textAnswerBackChanged _ FALSE;        -- allocate string array    FOR i IN [0..subgroupSize) DO       svtab[i] _ EmGTTYPrivDefs.shortZone.NEW[StringBody[6]]      ENDLOOP;        -- Set up initial values for tab settings.    nextcol _ lastcol _ 0;    stop _ IF iconData.tab[0] THEN 0 ELSE       EmGTTYActionDefs.GetNextTab[emdata.action, 0];    FOR i IN [0..subgroupSize) DO      rgparmdataTabGroup[i].parm _ ParameterDefs.parmNil;      IF stop # EmGTTYPrivDefs.noTabsLeft THEN {        nextcol _ nextcol + 1;	SvDefs.DecimalAppendCv[svtab[i], lastcol _ stop + 1];	rgparmdataTabGroup[i].appearance _ visible;	stop _ EmGTTYActionDefs.GetNextTab[emdata.action, stop]		}      ELSE rgparmdataTabGroup[i].appearance _ invisible;      WITH pdbound: rgparmdataTabGroup[i] SELECT FROM	textparm => pdbound.parmnucleusdata.lsv _ svtab[i]	ENDCASE  => NULL      ENDLOOP;    rgparmdataTabGroup[0].appearance _ visible;        -- Set up initial values.     -- Make sure all parms are created by setting fields to NIL.    parmdataMain.parm _ ParameterDefs.parmNil;    FOR i IN [0..numParms) DO      rgparmdataGroup0[i].parm _ ParameterDefs.parmNil;      WITH pdbound: rgparmdataGroup0[i] SELECT FROM	choiceparm =>                                 	  SELECT i FROM	    parmCursor     => pdbound.choiceInit _ SELECT 	      GVDTDefs.GetCursorShape[emdata.display] FROM 	        underscore, ghostunderscore, blinkunderscore => 0, ENDCASE => 1;	    parmMarginBell => 	      pdbound.choiceInit _ IF iconData.marginBell THEN 0 ELSE 1;            parmAnsiVT52   => 	      pdbound.choiceInit _ IF EmGTTYActionDefs.TTyModeIs[	        emdata.action, ansi] THEN 0 ELSE 1;	    parmPoundSign  => 	      pdbound.choiceInit _ IF iconData.USlbSign THEN 0 ELSE 1;	    parmAutoWrap   => 	      pdbound.choiceInit _ IF iconData.autoWrap THEN 0 ELSE 1;	    parmLTSActive  => 	      pdbound.choiceInit _ IF iconData.LTSMode THEN 0 ELSE 1;	    parmScreenMode => 	      pdbound.choiceInit _ IF iconData.screenTabs 	        OR nextcol > 0 THEN 0 ELSE 1	    ENDCASE => ERROR;	infoparm =>                                 	  SELECT i FROM	    parmScroll  => pdbound.parmnucleusdata.msg _ ZkeyMessageDefs.GetMsg[keyZ941].msg;	    parmParity  => pdbound.parmnucleusdata.msg _ ZkeyMessageDefs.GetMsg[	      SELECT iconData.parity FROM	        zero => keyZ419, odd => keyZ416,		even => keyZ417, one => keyZ418,		ENDCASE => keyZ415].msg;	    parmTRSpeed => pdbound.parmnucleusdata.msg _ ZkeyMessageDefs.GetMsg[	      SELECT iconData.lineSpeed FROM 	        bps50   => keyZ398, bps75    => keyZ399,		bps110  => keyZ400, bps134p5 => keyZ401,		bps150  => keyZ402, bps300   => keyZ403,		bps600  => keyZ404, bps1200  => keyZ405,		bps2400 => keyZ406, bps3600  => keyZ407,		bps4800 => keyZ408, bps7200  => keyZ409,		bps9600 => keyZ410, ENDCASE  => keyZ403].msg	    ENDCASE => ERROR;        stateparm =>	  pdbound.bvStateIsOn _ FALSE;	textparm  => 	  pdbound.parmnucleusdata.msg _ iconData.answerbackMsg;	groupparm =>	  pdbound.appearance _ 	    IF iconData.screenTabs OR nextcol > 0 THEN visible ELSE invisible	ENDCASE => ERROR        ENDLOOP;        <<    Create setup sheet body. All arguments are replaceable except the first    parm. The rest of the arguments are handles to implementations of setup     Sheet menu commands that are specific to this setup sheet. We Note that     CreateParm will enumerate all the children of parmdataTop and create parm     handles for them. Now this implies all I have to do is collect them from     the rgparmdataGroup0 data structure after the CreateParm call.    >>    -- Allocate space for local data.     ptosdata _ EmGTTYPrivDefs.shortZone.NEW[Aqosdata _ ALL[ParameterDefs.parmNil]];        -- Create main body.    ptosdata[numParms] _ ParameterDefs.CreateParm[parmdataMain, lschemaViewer];      setupbodydata _ [      lschemaViewer: lschemaViewer,       pvdestroydata: DestroypsData,      pvhelp: Help,       pvparmsarevalid: ParmsAreValidTTY,      parmSheet: ptosdata[numParms]];    -- Get lschema for Setup Sheet.    lschemaBody _ ParameterDefs.BuildParmSheetBody[@setupbodydata];        -- Collect parm handles to the option sheet parameter lines to be used     -- in any subsequent parm processing routines.    FOR i IN [0..numParms) DO       ptosdata[i] _ rgparmdataGroup0[i].parm       ENDLOOP;        -- Deallocate string buffers    FOR i IN [0..subgroupSize) DO       EmGTTYPrivDefs.shortZone.FREE[@svtab[i]]      ENDLOOP;    IF nextcol = 0 THEN nextcol _ 1    END;  -- of BuildSetUpBody      ParmsAreValidTTY: ParameterDefs.Pvparmsarevalid =    -- PROCEDURE [] RETURNS [BOOLEAN] =       BEGIN    Mydata:   EmTTYDefs.Lpttrtttyschemadata = TraitDefs.MyData[lschemaTTYicon, trtTTYschema];     emdata:   EmGTTYPrivDefs.EmData = Mydata.lptEmState;    iconData: EmGTTYPrivDefs.LptIconData = emdata.iconData;    i: CARDINAL _ 0;        IF (iconData.screenTabs _ ParameterDefs.GetChoiceParmvalue[      ptosdata[parmScreenMode]] = 0) THEN {      tab:   CARDINAL _ 0;      set:   PACKED ARRAY [0..EmGTTYPrivDefs.maxColumns] OF BOOLEAN _ ALL[FALSE];      valid: BOOLEAN _ TRUE;      FOR i IN [0..nextcol) DO        column: ParameterDefs.Parm = ParameterDefs.Find[	  ptosdata[parmTabGroup], [[0, i]]];	temp: LONG STRING = ParameterDefs.GetTextParmvalue[column];	noTab: BOOLEAN = temp.length = 0;	ParameterDefs.DestroyTextParmvalue[temp];	IF noTab THEN LOOP;	-- no argument in parameter box to process        [tab, valid] _ ParameterDefs.GetCardinal[column];	IF valid AND tab IN [0..EmGTTYPrivDefs.maxColumns] THEN 	  set[tab] _ TRUE	ELSE {	  MessageSwnDefs.DisplayMessageLiteral[ZkeyMessageDefs.GetMsg[keyZ938].msg];	  -- keyZ938 = keyTTYsuInvalidTabEntry	  ParameterDefs.SelectTextparm[column];	  RETURN[FALSE]	  }        ENDLOOP;	      -- The variable lastcol is used solely for remembering the state      -- of the original tab settings before any edits. This allows the user to      -- make changes to existing tab stops on the sheet; We simply perform a blanket       -- clear of all tab columns up to lastcol, and then do a selective set resulting         -- in any unchanged, changed or new entries to be entered again.	      FOR i IN (0..lastcol] DO				-- clear original tab settings        EmGTTYActionDefs.ClearTab[emdata.action, i-1]	ENDLOOP;	      FOR i IN (0..EmGTTYPrivDefs.maxColumns] DO	-- set new tab settings        IF set[i] THEN EmGTTYActionDefs.SetTab[emdata.action, i-1]	ENDLOOP      }    ELSE       EmGTTYActionDefs.ClearTab[emdata.action, 0, TRUE];        IF cursorChanged THEN {      crshape: GVDTDefs.CRShape = GVDTDefs.GetCursorShape[emdata.display];      cursorChanged _ FALSE;      IF ParameterDefs.GetChoiceParmvalue[ptosdata[parmCursor]] = 0 THEN         BEGIN         emdata.preCursorShape _ SELECT emdata.preCursorShape FROM	  box      => underscore,	  ghostbox => ghostunderscore,	  blinkbox => blinkunderscore,	  ENDCASE  => emdata.preCursorShape;        GVDTDefs.SetCursorShape[emdata.display,           SELECT crshape FROM 	    box      => underscore,	    ghostbox => ghostunderscore,	    blinkbox => blinkunderscore,	    ENDCASE  => crshape] 	END      ELSE         BEGIN         emdata.preCursorShape _ SELECT emdata.preCursorShape FROM	  underscore      => box,	  ghostunderscore => ghostbox,	  blinkunderscore => blinkbox,	  ENDCASE         => emdata.preCursorShape;        GVDTDefs.SetCursorShape[emdata.display,           SELECT crshape FROM 	    underscore      => box,	    ghostunderscore => ghostbox,	    blinkunderscore => blinkbox,	    ENDCASE         => crshape] 	END      };	    IF ansiChanged THEN {      ansiChanged _ FALSE;      EmGTTYActionDefs.Execute[emdata.action, 0,         IF (iconData.ansiMode _ ParameterDefs.GetChoiceParmvalue[          ptosdata[parmAnsiVT52]] = 0) THEN ANSIOn ELSE VT52On]      };         IF poundChanged THEN {      poundChanged _ FALSE;      EmGTTYCharTransDefs.SetPoundSign[emdata.language,         IF (iconData.USlbSign _           ParameterDefs.GetChoiceParmvalue[ptosdata[parmPoundSign]] = 0) THEN	    poundSign ELSE britishPoundSterlingSign]      };	    IF choiceChanged THEN {      choiceChanged _ FALSE;      iconData.autoWrap _ ParameterDefs.GetChoiceParmvalue[ptosdata[parmAutoWrap]] = 0;      iconData.LTSMode  _ ParameterDefs.GetChoiceParmvalue[ptosdata[parmLTSActive]] = 0;      iconData.marginBell _ ParameterDefs.GetChoiceParmvalue[ptosdata[parmMarginBell]] = 0      };          IF textAnswerBackChanged THEN {      temp: LONG STRING = ParameterDefs.GetTextParmvalue[ptosdata[parmAnswerBackMsg]];      textAnswerBackChanged _ FALSE;      IF iconData.answerbackMsg # WSStringUtilDefs.stringNull THEN         WSStringUtilDefs.DestroyString[iconData.answerbackMsg];      iconData.answerbackMsg _ WSStringUtilDefs.CopyString[        WSStringDefs.StringFromLONGSTRING[temp]];      ParameterDefs.DestroyTextParmvalue[temp]      };          IF ParameterDefs.GetStateParmvalue[ptosdata[parmSaveData]] THEN {      -- Store permanently the values in the VT100 SetUp sheet into the backing file.      ENABLE 	NSFile.Error => CONTINUE;      TTYicon: IconDefs.Icon = emdata.icon;      fileTTY: NSFile.Handle = NSFile.OpenChild[	IconDefs.ParentFromIcon[TTYicon], IconDefs.ReferenceFromIcon[TTYicon].fileID];      Mydata: EmTTYDefs.Lpttrtttyicondata _ EmGTTYPrivDefs.shortZone.NEW[	EmTTYDefs.Trtttyicondata _ [NULL, EmGTTYPrivDefs.validId,  	  EmGTTYPrivDefs.shortZone.NEW[EmGTTYPrivDefs.EmIconData]]];      Mymore: EmGTTYPrivDefs.LptIconData _ Mydata.lptMoreState;      valid:  BOOLEAN = EmGTTYPrivDefs.GetFileData[fileTTY, Mydata];      NSFile.Close[fileTTY];      IF valid THEN {	Mymore.screenTabs _ iconData.screenTabs;	Mymore.marginBell _ iconData.marginBell;	Mymore.answerbackMsg _ iconData.answerbackMsg;	Mymore.USlbSign _ iconData.USlbSign;	Mymore.tab _ iconData.tab;	Mymore.cursorShape _ SELECT emdata.preCursorShape FROM	  underscore, ghostunderscore, blinkunderscore => underscore, ENDCASE => box;	EmGTTYPrivDefs.SavePSData[TTYicon, Mymore]	};      EmGTTYPrivDefs.shortZone.FREE[@Mydata.lptMoreState];      EmGTTYPrivDefs.shortZone.FREE[@Mydata]      };          RETURN[TRUE]    END;  -- of ParmsAreValidTTY          DestroypsData: ParameterDefs.Pvdestroydata =    -- PROCEDURE [] =    -- This procedure will be called in three different cases:    -- a)  when the CANCEL menu item/button is clicked.    -- b)  after selecting the START button with ParmsAreValidTTY returning valid.    -- c)  if the user selects END SESSION in the auxillary menu to log off.    -- In all three cases, PsBodySchemaPack calls DestroyosData[] which closes the     -- Set-Up Sheet.    BEGIN    DC1: XOnXOff _ ALL[EmGTTYCharTransDefs.DC1];    -- Free up storage containing parm handles.    EmGTTYPrivDefs.shortZone.FREE[@ptosdata];    -- Send XON sequence to host.    EmGTTYComDefs.ReportToHost[EmGTTYPrivDefs.GetComHandle[lschemaTTYicon], Environment.Block[@DC1, 0, 1]]     END;  -- of DestroypsData             Help: ParameterDefs.Pvhelp =     BEGIN    HelpDefs.OpenHelpWindow[helptypeVT100SetupPropSheet]     END;  -- of Help          AnsiChanged: ParameterDefs.Pvchoiceparmchanged =    BEGIN    ansiChanged _ TRUE     END;  -- of AnsiChanged         ChoiceChanged: ParameterDefs.Pvchoiceparmchanged =     BEGIN    choiceChanged _ TRUE    END;  -- of ChoiceChanged      CursorChanged: ParameterDefs.Pvchoiceparmchanged =    BEGIN     cursorChanged _ TRUE    END;  -- of CursorChanged            PoundChanged: ParameterDefs.Pvchoiceparmchanged =    BEGIN    poundChanged _ TRUE    END;  -- of PoundChanged           SetclearChanged: ParameterDefs.Pvchoiceparmchanged =    BEGIN    IF ParameterDefs.GetChoiceParmvalue[parm] = 0 THEN {       ParameterDefs.ShowParm[ptosdata[parmTabGroup]];      ParameterDefs.SelectTextparm[ParameterDefs.Find[        ptosdata[parmTabGroup], [[0, parmColumn]]]]      }    ELSE       ParameterDefs.EraseParm[ptosdata[parmTabGroup]]    END;  -- of SetclearChanged          StateChanged: ParameterDefs.Pvstateparmchanged =    BEGIN    NULL  -- NOOP    END;  -- of StateChanged             TabColumnChanged: ParameterDefs.Pvtextparmchanged =     BEGIN    tab:   CARDINAL _ 0;    valid: BOOLEAN _ TRUE;        -- IF CLEAR choice selected OR NOT last element THEN skip error checking.    IF ParameterDefs.GetChoiceParmvalue[ptosdata[parmScreenMode]] = 1 OR      parm # ParameterDefs.Find[ptosdata[parmTabGroup], [[0, nextcol-1]]]         THEN RETURN;    [tab, valid] _ ParameterDefs.GetCardinal[parm];    IF valid AND tab IN (0..EmGTTYPrivDefs.maxColumns] AND nextcol < subgroupSize THEN {      ParameterDefs.ShowParm[ParameterDefs.Find[	ptosdata[parmTabGroup], [[0, nextcol]]]];      nextcol _ nextcol + 1       }    END;  -- of TextColumnChanged       TextAnswerBackChanged: ParameterDefs.Pvtextparmchanged =     BEGIN    textAnswerBackChanged _ TRUE    END;  -- of TextAnswerBackChanged   --=======================  --  Initial Operations  --=======================    Init: PROCEDURE =    BEGIN    keyTTYsuNVMOption:       MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ1282]];    keyTTYsuSaveData:        MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ1283]];    keyTTYosOnOffChoices:    MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ816]];    keyTTYsuScroll:          MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ940]];    keyTTYsuCursor:          MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ942]];    keyTTYsuCursorChoice:    MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ943]];    keyTTYsuMarginBell:      MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ944]];    keyTTYsuAnsiVT52:        MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ945]];    keyTTYsuAnsiVT52Choice:  MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ946]];    keyTTYsuPoundSign:       MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ947]];    keyTTYsuPoundChoice:     MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ948]];    keyTTYsuAutoWrap:        MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ00]];    keyTTYsuLTSActive:       MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ949]];    keyTTYsuParity:          MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ03]];    keyTTYsuTandRSpeed:      MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ950]];    keyTTYsuAnswerBackMsg:   MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ951]];    keyTTYsuScreenTabs:      MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ04]];    keyTTYsuScreenTabChoice: MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ952]];    keyTTYsuColumn:          MessageDefs.Msgkey = LOOPHOLE[ZkeyMessageDefs.Msgkey[keyZ953]];        ptrgparmdataTabGroup: LONG POINTER TO ARRAY [0..subgroupSize) OF      ParameterDefs.Parmdata _ EmGTTYPrivDefs.permanentZone.NEW[        ARRAY [0..subgroupSize) OF ParameterDefs.Parmdata _ ALL[	  ParameterDefs.Parmdata[	    parmkey: ParameterDefs.Parmkey[0, parmColumn],	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuColumn, tabs]],	    -- shellparmdata: [lsv, lsv["Column:@\\", tabs]],	    variant: textparm[	      parmnucleusdata: [lsv, lsv[nil]],	      wthText: 36,	      pvtextparmchanged: TabColumnChanged]]]];	       ptrgparmdataGroup0: LONG POINTER TO ARRAY [0..numParms) OF       ParameterDefs.Parmdata _ EmGTTYPrivDefs.permanentZone.NEW[        ARRAY [0..numParms) OF ParameterDefs.Parmdata _ [	  ParameterDefs.Parmdata[ 	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuNVMOption, tabs]],	    -- shellparmdata: [lsv, lsv["NVR Option:@\\", tabs]],	    variant: stateparm[	      parmnucleusdata: [msgkey, msgkey[keyTTYsuSaveData]],	      -- parmnucleusdata: [lsv, lsv["@SAVE DATA\\"]],	      pvstateparmchanged: StateChanged]],	  ParameterDefs.Parmdata[ 	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuScroll, tabs]],	    -- shellparmdata: [lsv, lsv["Scroll:@\\", tabs]],	    variant: infoparm[	      parmnucleusdata: [msg, msg[MessageDefs.msgNil]]]],  	  ParameterDefs.Parmdata[	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuCursor, tabs]],	    -- shellparmdata: [lsv, lsv["Cursor:@\\", tabs]],	    variant: choiceparm[	      parmnucleusdata: [msgkey, msgkey[keyTTYsuCursorChoice]],	      -- parmnucleusdata: [lsv, lsv["@UNDERLINE@BLOCK\\"]],	      pvchoiceparmchanged: CursorChanged]],  	  ParameterDefs.Parmdata[   	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuMarginBell, tabs]],	    -- shellparmdata: [lsv, lsv["Margin Bell:@\\", tabs]],	    variant: choiceparm[	      parmnucleusdata: [msgkey, msgkey[keyTTYosOnOffChoices]],	      -- parmnucleusdata: [lsv, lsv["@ON@OFF\\"]],	      pvchoiceparmchanged: ChoiceChanged]],  	  ParameterDefs.Parmdata[	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuAnsiVT52, tabs]],	    -- shellparmdata: [lsv, lsv["Ansi/VT52:@\\", tabs]],	    variant: choiceparm[	      parmnucleusdata: [msgkey, msgkey[keyTTYsuAnsiVT52Choice]],	      -- parmnucleusdata: [lsv, lsv["@ANSI@VT52\\"]],	      pvchoiceparmchanged: AnsiChanged]],  	  ParameterDefs.Parmdata[         	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuPoundSign, tabs]],	    -- shellparmdata: [lsv, lsv["#/ÿ £:@\\", tabs]],	    variant: choiceparm[	      parmnucleusdata: [msgkey, msgkey[keyTTYsuPoundChoice]],	      -- parmnucleusdata: [lsv, lsv["@#@ÿ £\\"]],	      pvchoiceparmchanged: PoundChanged]],  	  ParameterDefs.Parmdata[   	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuAutoWrap, tabs]],	    -- shellparmdata: [lsv, lsv["Auto Wrap:@\\", tabs]],	    variant: choiceparm[	      parmnucleusdata: [msgkey, msgkey[keyTTYosOnOffChoices]],	      -- parmnucleusdata: [lsv, lsv["@ON@OFF\\"]],	      pvchoiceparmchanged: ChoiceChanged]],  	  ParameterDefs.Parmdata[      	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuLTSActive, tabs]],	    -- shellparmdata: [lsv, lsv["LTS Active (New line):@\\", tabs]],	    variant: choiceparm[	      parmnucleusdata: [msgkey, msgkey[keyTTYosOnOffChoices]],	      -- parmnucleusdata: [lsv, lsv["@ON@OFF\\"]],	      pvchoiceparmchanged: ChoiceChanged]],  	  ParameterDefs.Parmdata[        	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuParity, tabs]],	    -- shellparmdata: [lsv, lsv["Parity:@\\", tabs]],	    variant: infoparm[	      parmnucleusdata: [msg, msg[MessageDefs.msgNil]]]],  	  ParameterDefs.Parmdata[         	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuTandRSpeed, tabs]],	    -- shellparmdata: [lsv, lsv["T & R Speed:@\\", tabs]],	    variant: infoparm[	      parmnucleusdata: [msg, msg[MessageDefs.msgNil]]]],  	  ParameterDefs.Parmdata[       	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuAnswerBackMsg, tabs]],	    -- shellparmdata: [lsv, lsv["Answer Back Message:@\\", tabs]],	    variant: textparm[	      parmnucleusdata: [msg, msg[MessageDefs.msgNil]],	      wthText: 130,	      pvtextparmchanged: TextAnswerBackChanged]],	      	  ParameterDefs.Parmdata[	    bvShellDesired: TRUE,	    shellparmdata: [msgkey, msgkey[keyTTYsuScreenTabs, tabs]],	    -- shellparmdata: [lsv, lsv["Screen Tabs:@\\", tabs]],	    variant: choiceparm[	      parmnucleusdata: [msgkey, msgkey[keyTTYsuScreenTabChoice]],	      -- parmnucleusdata: [lsv, lsv["@SET@CLEAR\\"]],	      pvchoiceparmchanged: SetclearChanged]],     	  ParameterDefs.Parmdata[	    variant: groupparm[	      bvIsVertical: TRUE,	      rgparmdata: DESCRIPTOR[ptrgparmdataTabGroup^]]]]];	       -- executable code              FOR i: CARDINAL IN (0..subgroupSize) DO       ptrgparmdataTabGroup[i].parmkey _ ParameterDefs.Parmkey[0, i]      ENDLOOP;    parmdataMain _ EmGTTYPrivDefs.permanentZone.NEW[ParameterDefs.Parmdata _ [      variant: groupparm[        bvIsVertical: TRUE,        rgparmdata: DESCRIPTOR[ptrgparmdataGroup0^]]]];          rgparmdataGroup0   _ DESCRIPTOR[ptrgparmdataGroup0^];    rgparmdataTabGroup _ DESCRIPTOR[ptrgparmdataTabGroup^]    END;  -- of Init  --  MAINLINE CODE    Init[]  END.  -- of PROGRAM EmSetUpVT100Pack  LOG.20-Feb-84 14:25:28 - Tom - Created. 6-Mar-84 18:47:12 - Tom - Added tab setting functionality.28-Mar-84 17:37:00 - Tom - Replaced string literals with msgkeys.11-May-84 11:40:18 - Tom - Upgraded to Klamath.16-May-84 13:30:02 - Tom - Enabled backing file routine to save information across			   boots and logouts. 5-Jun-84  9:52:21 - Tom - Added AUTO XON/XOFF NoScroll feature setting and  			   fixed tab offset problem. 8-Jun-84 17:08:06 - Tom - No longer save ANSI/VT52 state in order to accomodate  			   EmGTTYActionPack which cannot come up as a VT52.12-Jun-84 10:31:56 - Tom - Replaced string literals with msgkeys.16-Jul-84 14:09:22 - Tom - Corrected problem of a tab parameter which when empty			   produced an invalid tab message. Should allow user to			   have empty tab slots if so desired. Fixed MESA language			   problem with PACKED ARRAY's of one byte.