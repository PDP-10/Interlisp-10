-- Em3270OsMgrPack: 3270 Emulator Icon option sheet manager-- Last revised for 3.2fKlamath by Pettit:	30-Nov-83 16:11:14-- Last revised for 3.3 by Caro:	 9-Apr-84 14:54:36-- Owner: LuiDIRECTORY  CharDefs,   Em3270Defs,  Em3270PrivDefs,  Em3270OsMgrDefs,  GateStream USING [DeviceAddress, unspecifiedDeviceAddress],  HelpDefs USING [OpenHelpWindow],  IconDefs,  MessageDefs USING [DestroyMsg, GetMsg, Msg, msgNil],  ParameterDefs USING [    Aqparmsheetbodydata, BuildParmSheetBody, Choice, CreateParm, GetChoiceParmvalue,    Pvhelp, Parm, Parmdata, Parmkey, parmNil, Pvbuildosbody,    Pvchoiceparmchanged, Pvdestroydata, Pvparmsarevalid, Rgparmdata],  PswnDefs USING [Aqopendata, OsOpen, Pvosmgr],  SchemaDefs USING [Lschema, Posn],  SelectionDefs USING [GetRootCs],  StandardDefs USING [Bv, Cv, Lsv, Msg],  TraitDefs USING [Instance, MyData],  TreeEltDefs USING [WindowContaining],  WSStringUtilDefs USING [CvFromStringDecimal, InvalidNumber],  ZkeyMessageDefs USING [GetMsg],   ZoneMgrDefs USING [GetPredefinedZone];Em3270OsMgrPack: PROGRAM  IMPORTS    CharDefs, HelpDefs, MessageDefs, ParameterDefs, PswnDefs, SchemaDefs, SelectionDefs, TraitDefs,     TreeEltDefs, WSStringUtilDefs, ZkeyMessageDefs, ZoneMgrDefs  EXPORTS Em3270OsMgrDefs  SHARES ParameterDefs, IconDefs  =  BEGIN  OPEN Em3270Defs, Em3270PrivDefs, Em3270OsMgrDefs, ParameterDefs, StandardDefs;  --===================  -- Types.  --===================  Ptosdata: TYPE = LONG POINTER TO Aqosdata;  Aqosdata: TYPE = RECORD [parmTopHandle, parmInfoHostN, parmInfoLang, parmChoiceHandle: Parm];  --===================  -- Constants   --===================  lsvNil: Lsv = " ";  -- used for host name info parm at Init-time (must be non-NIL)  chBegin: CharDefs.Char = -- '@ -- CharDefs.Roman[atSign];  chEnd: CharDefs.Char = -- '\ -- CharDefs.Roman[backSlash];    --===================  --  Global Variables  --===================  bvchoicechange: Bv _ FALSE;  -- indicates if either parms have been modified  lschema3270icon: SchemaDefs.Lschema;  -- icon's global lschema for trait data access; possible because there are no multiple instance of options sheets.--  termString: WSStringDefs.String;    -- allocate space in permenent zone for rgparmdata to store PS data structure between boots.  parmzone: UNCOUNTED ZONE _ ZoneMgrDefs.GetPredefinedZone[permanent];  parmhandlezn: UNCOUNTED ZONE _ ZoneMgrDefs.GetPredefinedZone[short];  ptosdata: Ptosdata;  -- keep in global frame  -- Save pointer to data structure (gobally) set up at INIT-time so we can get parm-handles at Build-time  parmdataMain: LONG POINTER TO Parmdata _ NIL;  rgparmdataGroup0: Rgparmdata _ DESCRIPTOR[NIL, 0];  --===================  -- Public Operations  --===================  Em3270osMgr: PUBLIC PswnDefs.Pvosmgr =    --	PROC[ ctxt:Ctxt, pvreturncontrol:Pvreturnoscontrol];    BEGIN    cvOsWth: StandardDefs.Cv _ 300; -- initialize with default to prevent compiler warnings.    msgOsWth: StandardDefs.Msg;    lsRoot:SchemaDefs.Lschema;    aqosopendata: PswnDefs.Aqopendata;        -- Parse message to get the width of the property sheet, so that it can be language-dependent.    msgOsWth _ ZkeyMessageDefs.GetMsg[keyZ456].msg;  -- For OS 4.0    -- msgOsWth _ GrMessageDefs.GetMsg[keyEm3270OsWth].msg; ++ for later    cvOsWth _ WSStringUtilDefs.CvFromStringDecimal[msgOsWth      ! WSStringUtilDefs.InvalidNumber => { cvOsWth _ 300; --Wth of American PS-- CONTINUE }];    IF cvOsWth > 600 THEN cvOsWth _ 600    ELSE IF cvOsWth < 200 THEN cvOsWth _ 200;    MessageDefs.DestroyMsg[msgOsWth];        lsRoot _ SelectionDefs.GetRootCs[].lschema;  --return the DeskTop as the real owner of this OverlayStdWn option sheet.  It owns a DW.?    aqosopendata _ [      areaAvoid: SchemaDefs.Posn[TreeEltDefs.WindowContaining[lsRoot]].area,       bvHorizScrolling: FALSE, bvVertScrolling: FALSE, lschemaRequestor: lsRoot, pvbuildbody: Build3270osBody, rsBody: [cvOsWth, 80], ctxt: ctxt,      pvreturncontrol: pvreturncontrol, svTitle: MessageDefs.GetMsg[key3270OsTitle].msg];          -- Set tricon's lschema now so later we can access its data area    lschema3270icon _ LOOPHOLE[ctxt, LONG POINTER TO OpenData].icon3270.iconInstance;    [] _ PswnDefs.OsOpen[@aqosopendata];  -- build 3270 Option Sheet    END;  -- of Open  --===================  -- Private Operation  --===================  Build3270osBody: Pvbuildosbody =    --	PROC[lschemaViewer: Lschema, ctxt: Ctxt]  RETURNS[ lschemaBody:Lschema]    BEGIN    aqoptionsheetbodydata: Aqparmsheetbodydata;    Mydata: Lpttrt3270icondata _ TraitDefs.MyData[lschema3270icon, trt3270icon];  -- pointer to icon's trait data    lsvHostName: LONG POINTER TO OpenData _ ctxt.lptr;    lsvHostName.lang _ Mydata.language;    --  save the language field so we can access it at Em3270Pack.ReturnControl3270Os.     bvchoicechange _ FALSE;  -- reset the choice parm to unmodified    -- Fetch current host name from 3270 icon to put in non-constant info data    -- Make sure both parms are created by seting fields to parmNil    parmdataMain.parm _ rgparmdataGroup0[0].parm _ rgparmdataGroup0[1].parm _ rgparmdataGroup0[2].parm _ parmNil;    WITH parmdataBound: rgparmdataGroup0[0] SELECT FROM      infoparm => parmdataBound.parmnucleusdata.lsv _ lsvHostName.lptHostN;      ENDCASE => ERROR;       --  the language part   --  needs to be change when the language field is added to trt3270icondata     WITH parmdataBound: rgparmdataGroup0[1] SELECT FROM      infoparm => 	   parmdataBound.parmnucleusdata.msg _ SELECT Mydata.language FROM 		USenglish => MessageDefs.GetMsg[key3270USEnglish].msg,		UKenglish => MessageDefs.GetMsg[key3270UKEnglish].msg,		JapaneseKana => MessageDefs.GetMsg[key3270JapaneseKana].msg,		German => MessageDefs.GetMsg[key3270German].msg,	     --   GermanAlt => MessageDefs.GetMsg[key3270GermanAlt].msg,		Swedish => MessageDefs.GetMsg[key3270Swedish].msg,	     --   SwedishAlt => MessageDefs.GetMsg[key3270SwedishAlt].msg,		French => MessageDefs.GetMsg[key3270French].msg,		JapaneseEnglish => MessageDefs.GetMsg[key3270JapaneseEng].msg,	      ENDCASE => MessageDefs.GetMsg[key3270USEnglish].msg;       ENDCASE => ERROR;       --  WITH parmdataBound: rgparmdataGroup0[1] SELECT FROM  --    infoparm => parmdataBound.parmnucleusdata.msg _ MessageDefs.MsgFromLsv[lsvHostName.lptHostN];  --    ENDCASE => ERROR;    -- Set choice parm from trait data.  Note that the trait data is one less than the choice parm because of "ANY"    WITH parmdataBound: rgparmdataGroup0[2] SELECT FROM      choiceparm => {	  trmAddr: GateStream.DeviceAddress;	  parmdataBound.parmnucleusdata.msg _ SetTermChoicePara[Mydata];       	  trmAddr _ Mydata.terminalAddress;	  parmdataBound.choiceInit _ IF trmAddr IN[0..7]  THEN (trmAddr + 1) ELSE 0};      ENDCASE => ERROR;    -- Create option sheet body.  All arguments are replaceable except the    -- first one.  The rest of the arguments are handles to implementations of    -- option sheet menu commands that are specific to this option sheet.    -- Note that CreateParm will enumerate all the children of parmdataTop and create parm handle for them.  That means all I have to do is collect them  from the rgparmdataGroup0 data structure after the CreateParm call.        -- Allocate space for local data    ptosdata _ parmhandlezn.NEW[Aqosdata];    ptosdata.parmTopHandle _ CreateParm[parmdataMain, lschemaViewer];    -- ++ aqoptionsheetbodydata _ [    -- ++  lschemaViewer: lschemaViewer, pvdestroydata: DestroyosData,    -- ++  pvhelp: HelpDflt, pvparmsarevalid: ParmsAreValid3270,    -- ++  parmSheet: ptosdata.parmTopHandle];        -- aqoptionsheetbodydata should be changed to the folowing(this would cuase it to bring up the OptionSheet Help Document):    aqoptionsheetbodydata _ [      lschemaViewer: lschemaViewer, pvdestroydata: DestroyosData,      pvhelp: Help, pvparmsarevalid: ParmsAreValid3270,      parmSheet: ptosdata.parmTopHandle];    -- Get lschema for Option Sheet    lschemaBody _ ParameterDefs.BuildParmSheetBody[@aqoptionsheetbodydata];    -- Collect parm handles to the option sheet parameter lines to be used in any subsequent parm processing routines    ptosdata.parmInfoHostN _ rgparmdataGroup0[0].parm;    ptosdata.parmInfoLang _ rgparmdataGroup0[1].parm;    ptosdata.parmChoiceHandle _ rgparmdataGroup0[2].parm;    END;  -- of BuildClientosBody   -- ++ the following Proc is need to bring up the Help and training stuff   Help: Pvhelp = {HelpDefs.OpenHelpWindow[helptype3270OptionSheet]};    --  SetTermChoicePara: PROC[Mydata:Lpttrt3270icondata] RETURNS[msg: MessageDefs.Msg]= --   this proc sets up the valid number of terminal to be display on the option sheet.--  BEGIN --   numberOfPorts: CARDINAL = 4;      This only temporary until a new field can be added to trt3270icondata. allows us to test code--  aqeditctxt: WSStringDefs.Aqeditctxt;   initialized in 'BeginEdit--  termString _ WSStringUtilDefs.StringCreate[ (5+2*Mydata.portOnController)]; --   termString _ WSStringUtilDefs.StringCreate[ (5+2*numberOfPorts)];    used as stub before--  WSStringDefs.BeginEdit[@termString, @aqeditctxt];--  WSStringDefs.AppendChar[@aqeditctxt, chBegin];--  WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[upperA]];--  WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[upperN]];--  WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[upperY]];--  FOR i: CARDINAL IN [1..Mydata.portOnController] DO  --   FOR i: CARDINAL IN [1..numberOfPorts] DO     no longer necessary, used as stub before--    WSStringDefs.AppendChar[@aqeditctxt, chBegin];--    SELECT i FROM     we need something that does WSStringDefs.AppendNumber--      1 => WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[digit0]];--      2 => WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[digit1]];--      3 => WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[digit2]];--      4 => WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[digit3]];--      5 => WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[digit4]];--      6 => WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[digit5]];--      7 => WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[digit6]];--      8 => WSStringDefs.AppendChar[@aqeditctxt, CharDefs.Roman[digit7]];--    ENDCASE  => ERROR;      maximunm number of terimal per controller is 8--  ENDLOOP;--  WSStringDefs.AppendChar[@aqeditctxt, chEnd];--  WSStringDefs.EndEdit[@aqeditctxt];--  msg _ WSStringUtilDefs.MsgFromString[termString];--  END;    SetTermChoicePara  SetTermChoicePara: PROC[Mydata:Lpttrt3270icondata] RETURNS[msg: MessageDefs.Msg]=     -- this proc sets up the valid number of terminal to be display on the option sheet.    BEGIN    RETURN [       SELECT Mydata.portOnController FROM	1 => ZkeyMessageDefs.GetMsg[keyZ242].msg,	2 => ZkeyMessageDefs.GetMsg[keyZ243].msg,	3 => ZkeyMessageDefs.GetMsg[keyZ244].msg,	4 => ZkeyMessageDefs.GetMsg[keyZ245].msg,	5 => ZkeyMessageDefs.GetMsg[keyZ246].msg,	6 => ZkeyMessageDefs.GetMsg[keyZ247].msg,	7 => ZkeyMessageDefs.GetMsg[keyZ248].msg,	8 => ZkeyMessageDefs.GetMsg[keyZ424].msg,      ENDCASE  => ERROR] ;     -- maximunm number of terimal per controller is 8    END;   -- SetTermChoicePara          --===================  -- ChangeParm Routines  --===================  SetTermAddr: Pvchoiceparmchanged =    --	PROC[parm:Parm, choiceNew, choiceOld:Choice, ptctxt:Pctxt]    -- This should just set a flag that idcates that the Terminal Address parameter was changed.  "ParmsAreValid" is where the real parameter processing should take place.  It is called once for each character typed in.    BEGIN    bvchoicechange _ TRUE;  -- indicate the choice parm has been modified    END;  -- of SetTermAddr  ParmsAreValid3270: Pvparmsarevalid =    --	PROC RETURNS[Bv]    -- This is where the real parameter processing should take place.    -- Determine which parameters where changed and process them appropriatly.    BEGIN    valid: Bv _ TRUE;    Mydata: Lpttrt3270icondata _ TraitDefs.MyData[lschema3270icon, trt3270icon];      -- point to the icon's data area    IF bvchoicechange THEN  -- handle change in terminal adrreses      BEGIN      choiceTA: Choice _ GetChoiceParmvalue[ptosdata.parmChoiceHandle];      bvchoicechange _ FALSE;  -- reset "is changed" flag            -- Set choice in trait data. Note that the trait data is one less than the choice parm.      -- Note that the terminalAddress is written to the 3270 icon's file object only when that      -- icon is destroyed (see Em3270Pack.DestroyIcon).      Mydata.terminalAddress _	IF choiceTA IN[1..8] THEN (choiceTA - 1) ELSE GateStream.unspecifiedDeviceAddress;	-- save away term. addr. in trait data      END;    RETURN[valid];    END;  -- of ParmsAreValid3270  --===================  -- Private operations  --===================  DestroyosData: Pvdestroydata =    BEGIN    parmhandlezn.FREE[@ptosdata];  -- free up storage containing parm handles--    WSStringUtilDefs.DestroyString[termString];        END;  -- of DestroyData  --===================  -- Initial Operations  --===================  Init: PROC =    -- Define arrays of data to pass to Parameter that will tell it how to construct the    -- window and what the initial values of the parms will be.    -- Fillin parm data for text group.  Notice that some fields are defaulted.    -- ParameterDefs provides Noop change parm routines for those cases where it    -- is either necessary to do nothing due to the procedure not being implemented    -- or it is desirable to do nothing, in either case you have saved some code links.    -- Allocate data arrays from permanent system zone    -- and fill in constant data    BEGIN    ptrgparmdataGroup0: LONG POINTER TO ARRAY [0..3) OF Parmdata _      parmzone.NEW[ARRAY [0..3) OF Parmdata _ [	       -- host name part	       Parmdata[	       bvShellDesired: TRUE,	       shellparmdata:[msg, msg[MessageDefs.GetMsg[key3270HostName].msg]], 	       variant: infoparm[parmnucleusdata: [lsv, lsv[lsvNil]]]],  -- to be filled in at OS time	       	       --   language part. 	       Parmdata[	       bvShellDesired: TRUE,	       shellparmdata:[msg, msg[MessageDefs.GetMsg[key3270osHostLanguage].msg]], 	       -- shellparmdata:[lsv, lsv["Host language : @\"]], 	       variant: infoparm[parmnucleusdata: [msg, msg[MessageDefs.msgNil]]]],  -- to be filled in at OS time 	       	       -- terminal address part.	       Parmdata[	       bvShellDesired: TRUE,	       shellparmdata: [msg, msg[MessageDefs.GetMsg[key3270TermAddr].msg ]],	       variant: choiceparm[	       parmnucleusdata: [msg, msg[MessageDefs.msgNil]],	       -- the following statement is not necessary 	       -- msg, msg[MessageDefs.GetMsg[key3270TermAddrChoice].msg ]],	       choiceInit: FIRST[Choice],  -- maps into termAddrDflt = "ANY"	       pvchoiceparmchanged: SetTermAddr]]]];    parmdataMain _ parmzone.NEW[Parmdata _ [      variant: groupparm[	bvIsVertical: TRUE,	rgparmdata: DESCRIPTOR[ptrgparmdataGroup0^]]]];    rgparmdataGroup0 _ DESCRIPTOR[ptrgparmdataGroup0^];    END;  -- of Init  --===================  -- Mainline Code  --===================  Init[];  END.  -- of Em3270OsMgrPackLOGMarch 16, 1981 - Kernaghan - Created12-Mar-82 - Weissman - Fix bounds fault on terminalAddress in Build3270osBody15-Mar-82 - Kernaghan - Improved terminalAddress range check in ParmsAreValid3270.April 1, 1982 - Kernaghan - Changed OS body size from [400,175] to [350, 100].April 2, 1982 - Kernaghan - Changed OS body size from [350,100] to [300, 70].17-Aug-82  -  LUi	- added a languages field(infopara) to option sheet. Modify code to display only valid termainals.25-Aug-82  -  LUi	- added code to display the language field. 1-Sep-82  -  LUi	- changed language part in Init from lsv to msg.13-Sep-82  -  LUi	- added Help stuff.(commented out until helptype is available)16-Sep-82  -  LUi	- added new msgKeys23-Sep-82  -  Lui	- activated Help stuff. 13-Oct-82  -  Lui	- added UKenglish, new message keys.28-Oct-82  -  Lui	- activated to use info from clearinghouse.15-Feb-83  -  Lui	- replaced all string literals with zkeys.18-Feb-83  -  Lui	- fixed space leak.21-Mar-83  -  Lui	- Get OS width from message file, to allow multinational dependencies10-Jun-83  -  Lui	- AR 13585: added JapaneseEnglish30-Nov-83  -  Pettit	- Klamath conversion: GateStream.TerminalAddress -> DeviceAddress. 9-Apr-84 14:55:20 - Caro - Upgrade to new Em3270Defs