				SETF     By Kelly Roach.  Last Revised 1-Mar-84.  SETF (SET Field)modifies the record package slightly to get the user the MACLISPSETF-style record accessing.  Less verbose than CLISP fetch & replace,but without the drawbacks of packing record accesses into atoms aswith CLISP infixes ":" and ".".  To use, LOAD <LISP>LIBRARY>SETF.DCOM.     (1) RECORD ACCESS.  For any record name "r" and field name "f",SETF makes the following translations:	(r.f d)  =>  (fetch (r f) of d)	(SETF (r.f d) v)  =>  (replace (r f) of d with v)(More precisely, these forms translate to what the fetch & replaceforms translate to).     (2) ARRAY ACCESS.  SETF can be used with ELT:	(SETF (ELT ARRAY N) V)  => (SETA ARRAY N V)     (3) CAR & CDR ACCESS.  SETF can be used with CAR & CDR:	(SETF (CAR X) Y)  =>  (RPLACA X Y)	(SETF (CDR X) Y)  =>  (RPLACD X Y)     (4) USER HOOK.  The user can define his own SETF translationsusing property SETFDEF (This is how SETF for ELT, CAR, & CDR isimplemented).  If the user does	(PUTPROP 'CADR 'SETFDEF '(RPLACA (CDR DATUM) NEWVALUE))	(PUTPROP 'ASSOC 'SETFDEF 'FOOFN)then SETF will make the translations	(SETF (CADR X) Y)  =>  (RPLACA (CDR X) Y)	(SETF (ASSOC KEY ALST) V)  =>	     what (FOOFN '(ASSOC KEY ALST)) evals to.     In general, if the user does	(PUTPROP a 'SETFDEF setfdef)then SETF makes the translation	(SETF (a d) n)  =>	     setdef with d & n substituted for DATUM & NEWVALUEif "setfdef" is a list and	(SETF (a ...) ...)  =>	     what (setfdef '(SETF (a ...) ...)) evals toif "setfdef" is a litatom.