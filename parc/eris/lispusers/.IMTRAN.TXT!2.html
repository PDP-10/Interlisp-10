<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispUsers>IMTRAN.TXT!2</title>
  </head>
  <body>
    <pre>
author:  Michael Sannellafile:  {Phylum}&lt;LispUsers&gt;IMTRAN. (&amp; .DCOM)******  IM format and the IMTRAN IM-to-TEX translation program.  *****IM format is the text formatting language that the Interlisp Reference Manual is represented in.  It is somewhat like TEX source code, in that there are keywords, and brackets are used to delimit text.  However, IM format was specifically designed for representing the Interlisp Manual, so the "text objects" used are semantically meaningful objects within the manual, such as "function definition", "lisp code", "subsection".IM format files are easy to edit (IM format only uses normal printing ascii characters, so IM files can be edited with Laurel, Bravo, Tedit, etc..), but they don't look very pretty.  To produce the manual, it was necessary to find a way to format and print IM files.  After much thought, I finally decided to create IMTRAN, a program that translates from IM format files to TEX souce files, and use TEX to actually format and print the manual.A useful feature of IMTRAN is that is very forgiving about errors in IM format, even misplaced bracket errors!  This is not to say that the output will be pretty, but at least the translation program will not bomb out on you.This file (IMTRAN.txt) contains info on using the IMTRAN IM-to-TEX translation program, on FLGs which effect IMTRAN, on how to generate the index and table of contents, and a description of IM format.******  How to use IMTRAN to format and print an IM format file  *****(1)  get into Interlisp-D, and load {phylum}&lt;LispManual&gt;IMTRAN.DCOM(2)  type (IM.TEX '&lt;infile&gt; '&lt;outfile&gt;)[if the extensions are not given, defaults to &lt;infile&gt;.IM and &lt;outfile&gt;.TEX. &lt;outfile&gt; defaults to &lt;infile&gt;.TEX](3)  the translation program will run, printing out warning messages.  It will also create files &lt;infile&gt;.IMERR (transcript of error messages).(4)  chat to maxc, CONN to {maxc}&lt;Manual&gt;, and, using pupftp, bring the tex file over to maxc.  [Alternatively, just specify {maxc}&lt;Manual&gt;.... as the &lt;outfile&gt; to IM.TEX.  TEX will still accept it, even though CRs would not be translated to CR/LF as pupftp does.](5)  run TeX on the output file --- type to maxc:	@tex	*\input &lt;outfile file name without extension&gt;this should run, and print lots of silly warning messages, and finally end,leaving a press file on &lt;outfile&gt;.PRESS[note:  "input" must be in lower case]Note:  Actually, you can run Tex on any MAXC directory, if you copy {MAXC}&lt;MANUAL&gt;IMBASIC.TEX to the directory.******  FLGs in IMTRAN  *****IMTRAN is effected by a number of global variables:IM.NOTE.FLG	If T, notes will be printed out, otherwise they will be suppressed.  Initially NIL.  (Note: If this is T, the translation programs will print out a message to remind you that notes will be printed.)IM.DRAFT.FLG	If T, the output will have "--DRAFT--" printed on four corners of every page.  Initially NIL.IM.FILE.TAG.FLG	If T, the output will have the input file names printed at the bottom of each page.  Initially NIL.IM.EVEN.FLG	If T, Tex will try to make the press file have an even # of pages, by adding an empty page if needed.  Initially NIL.IM.CHECK.DEFS	If T, checks whether vars and fns are bound/defined in the current Interlisp, and prints a warning if not.  For Fns, will also check arg list consistancy.  Initially NIL.The following FLGs are only of interest when generating an index:IM.PTR.FILE.FLG	If T, a file &lt;infile&gt;.IMPTR will be generated giving index information.  Initially NIL.IM.PAGE.FILE.FLG	If T, TEX will generate a file &lt;infile&gt;.IMPAGE containing page information.  Initially NIL.IM.REF.FLG	If T, the translation program will try to resolve cross-references by looking at various hash tables.  Initially NIL.IM.SEND.IMPLICIT	If T, send "implicit references" for fns and vars (if not in index hash array).  Initially NIL.IM.FLUSH.IMPLICIT	If T, flush "implicit references" when reading in index data with GRAB.IMPTR.  Initially NIL.******  Generating an Index and TOC, and resolving Cross-references  *****One of the benefits of IM format is that it is possible to generate an index and table of contents, and to have page cross-references resolved.  However, it is not easy.  The procedure is as follows:(1)  Run all of the chapters of the document through IM.TEX and Tex, after setting IM.PTR.FILE.FLG and IM.PAGE.FILE.FLG to T.  IM.TEX will generate an index file xxx.IMPTR, and Tex will generate a file xxx.IMPAGE.(2)  Load all of the index files using (GRAB.IMPTR imptrFileName) and (GRAB.IMPAGE impageFileName)(3)  Create the index by running (MAKE.IM.INDEX indexFileName), which will put a Tex source file containing the index on indexFileName.(4)  Create the table of contents by running (MAKE.IM.TOC tocFileName), which will put a Tex source file containing the table of contents on tocFileName.(5)  Now, run all of the parts of the document through IM.TEX and Tex again, with IM.REF.FLG set to T, so the index info will be used to resolve cross-references.******  IM Format Description  *****This is a complete description of the syntax and vocabulary of "IM format".  The general syntax is not likely to change, but the vocabulary will probably be extended as the Interlisp Manual is edited, and we discover new text objects that we need.IM Format Syntax***************An IM-format file consists of a linear string of visible, editable characters.  No funny control characters are allowed.  "Text" is defined to be a linear string of characters, organized into paragraphs (delimited by blank lines), interspersed with any number of "Text Objects".  Text Objects are used to specify the meaning of various pieces of text, which may be processed and formatted in different ways.Text Objects can be divided into two types: those that take a single unnamed argument, and those that take a number of labeled arguments.  All of the 'arguments' to Text Objects can be arbitrary text, organized in paragraphs, and including sub-text-objects nested to any level.  Text Objects within a file and arguments within a text object are specified using the characters "{" and "}".  These characters are ALWAYS interpreted as Text Object delimiters or Text Object argument delimiters---there are special text objects for indicating that you really want a left or right bracket character as part of your text.The format of Text Objects is:{&lt;TOname&gt;  &lt;TOarg&gt;}	-	single argument TO{&lt;TOname&gt; {&lt;TOargname1&gt; &lt;TOarg1&gt;} {&lt;TOargname2&gt; &lt;TOarg2&gt;} .... }	-	multi-argument TOBetween a TOname or TOargname and its TOarg, and between named TOargs, there can be any combination of spaces, tabs, and CRs.  These can be used to make your file look better.In order to help with the problem of matching brackets in large TOs (such as SubSecs, which can extend over many pages), I have introduced a new piece of syntax: Begin and End:"{Begin &lt;TOname&gt; &lt;tag&gt;}"	is treated exactly like	"{&lt;TOname&gt; ""{End &lt;TOname&gt; &lt;tag&gt;}"		is treated exactly like	"}"except that additional checks are made when the file is processed that the "Begin"s and "End"s match up.  The (optional) "&lt;tag&gt;"s can be used as an additional check, to distinguish between different TOs of the same type.  If you use a Begin TO, you should use a matching End TO.Note that Begin and End TOs can be used with TOs that have labeled args, for example:{Begin SubSec &lt;tag&gt;}{Title ----}{Text..}{End SubSec &lt;tag&gt;}In order to allow the IM format translation program to recover from errors (like missing brackets), information has been included in the program about what TOs "should" appear in other TOs.  In general, "complex" TOs such as LabeledLists can only appear in other complex TOs.  "Simple" TOs such as Lisp can appear within anything.  These rules are defined on a per-argument basis for TOs with multiple labeled arguments --- for example, a LabeledList can appear within the "Text" argument of a FnDef, but not within the "Name" argument.  This feature should not cause any problems, as long as TOs are used "reasonably."Other rules followed by the translation program:  FnDef's, VarDef's, Def's, etc can only appear at the "top-level", or inside a SubSec or Chapter.  (this rule is very useful, because it helps trap many bracket errors before they propogate too far)  Footnotes may not be nested.New feature &lt;which may get changed&gt;:  If a TO name is unrecognized, it will be printed out surrounded by brackets.  For example, {FOO} will actually print as "{FOO}".  This allows simple expressions to be bracketed without actually using the "{bracket ...}" TO.Text Objects currently defined:**************************(note: the order of arguments in multi-argument TOs IS significant.)(note: No distinction is made between upper and lower case in the TO names and the argument names, or in Begin/End tags)(note: Many TO names and argument names have synonyms.  These are indicated below.)************************** plain text Text objects ******&lt;paragraph&gt; 	All plain text is organized into paragraphs, delimited by blank lines.{Chapter {number &lt;number&gt;} {title &lt;title&gt;} {text &lt;text&gt;} }	Specifies the number, title, and text of a chapter.  If the number is not specified, the IM format translator will ask you to supply a number.{subsec {title &lt;title&gt;} {text &lt;text&gt;} }	This can be used to generate sections, subsections, etc. to any depth.  Heirarchical numbering is done automatically.{Comment &lt;text&gt;}	Used to insert comments (which won't appear in the final formatted output).{Note &lt;text&gt;}	Inserts comments that may be printed in the final formatted output, depending on a flag.  Should be used for comments such as {Note I should write something about X here}{foot &lt;text&gt;}	Generates a footnote.  Footnotes may not occur within other footnotes.Synonyms:	footnote	-&gt; foot{sub &lt;text&gt;}	Subscripts &lt;text&gt;.{super &lt;text&gt;}	Superscripts &lt;text&gt;.{it &lt;text&gt;}	Used to italisize pieces of text.Synonyms:	italics, emphasize	-&gt; it{rm &lt;text&gt;}	Used to print text in the default, "roman" font.{lisp &lt;text&gt;}	The text object for normal single-line references to lisp code.  This is used for writing things like: "Obviously, {lisp (CONS 'A 'B)} evaluates to {lisp (A . B)}."{lispcode &lt;text&gt;}	The text object for multiline lisp code, which do not appear in the middle of text, and have to be formatted differently.  Spaces, tabs, and carriage returns are significant within &lt;text&gt;.************************** TOs for Interlisp manual objects ******{FnDef {Name &lt;name&gt;} {Args &lt;args&gt;} {Type &lt;keywords&gt;} {Text &lt;text&gt;} } 	This is used to define all lisp system functions.  It needs to know the name of the function, and the args, and the text of the function description.  (If the function has 0 args, the {Args --} argument may be omitted.)  {Type ...} is an optional argument used to specify the argument type of the function.  If the keywords NLambda or NoSpread (case doesn't matter) are included in &lt;keywords&gt;, the function is specified to have the corresponding argument type.Synonyms:	FnName	-&gt; Name		FnArgs	-&gt; Args		FnType	-&gt; Type{vardef {name &lt;name&gt;} {text &lt;text&gt;} } 	Used to define system variables.{propdef {name &lt;name&gt;} {text &lt;text&gt;} }	Used to define property names.{MacDef {Name &lt;name&gt;} {Args &lt;args&gt;} {Type &lt;keywords&gt;} {Text &lt;text&gt;} }	Like FnDef, but for macros.{arg &lt;name&gt;} 	Used to talk about an abstract argument to a function, such as "x" or "y" or "number".  It is used primarily within function definitions.{fn &lt;name&gt;} 	Used to talk about the name of a function. i.e.: "...it calls {fn CONS} to do something."{var &lt;name&gt;} 	Used to talk about a system variable.{prop &lt;name&gt;}	Used to talk about a property name.{Mac &lt;name&gt;}	Like Fn, but for macros.{EditCom &lt;name&gt;}	Used to talk about an edit command.{BreakCom &lt;name&gt;}	Used to talk about a break command.{PACom &lt;name&gt;}	Used to talk about a programmer's assistant command.{FileCom &lt;name&gt;}	Used to talk about a file package command.************************** Indexing Text objects ******The following TOs (for indexing, defining, and referencing) all deal with objects with specific "object-types."  The Interlisp Manual contains a very large number of names (CONS, NIL, FOO, etc).  It is not enough just to list the name in the index --- it is also important to indicate WHAT the name is (a function, a variable, an error message, etc.)  An "object-type" is essentially the description that would be printed in the index to describe a particular name.  In IM format, such a description is given by a list of words, within parenthesis.  [note upper/lower case are NOT distinguished in "object-types"]  For example:		(Function)		(Error Message)		(Transor Command)		(Compiler Question) Some commonly-used object-types may be abbreviated with single words:	FN		-&gt;	(Function)	Var		-&gt;	(Variable)	Prop		-&gt;	(Property Name)	BreakCom	-&gt;	(Break Command)	EditCom	-&gt;	(Editor Command)	PACom	-&gt;	(Prog. Asst. Command)	FileCom	-&gt;	(File Package Command)	Error		-&gt;	(Error Message)	Litatom	--,	Atom		---&gt;	(Litatom)[note: In {PageRef ...} and {SectionRef ...}, the word TAG can be used to refer to tags, as specified below.  The word FIGURE is a synonym for TAG; this can be used to refer to a figure tag.  The word TERM can be used in {index ...} to index an English term.]{index &lt;text&gt;}	Creates an index reference.  Some of the text objects (such as function definitions) will automatically create an index reference, but it is useful to be able to create one explicitly.  This should have the format:         {index  &lt;keywords&gt;   &lt;object&gt;  &lt;object type&gt;}	&lt;keywords&gt; (optional) can be any combination of the words		*BEGIN*		*END*		*PRIMARY*	&lt;object&gt; can be any number of words.	&lt;object type&gt; should be an object-type as specified above.		If this is omitted (&lt;text&gt; does not end with ")" and		the last word in &lt;text&gt; is not one of the special		object-type words), then this is the index of a term.		This can also be specified by using the word TERM.	Examples:  	{index *PRIMARY* BLOBBY (Transor Command)}			{index SELF-DESTRUCT SEQUENCE INITIATED  Error)			{index *BEGIN* *PRIMARY* file names){indexX {name &lt;name&gt;} {type &lt;type&gt;} {info &lt;info words&gt;} {text &lt;text&gt;}}	Used for creating index references whose printname is different from the "index name".  &lt;name&gt; is the index name, used for referencing the object, and alphabetizing the index entry.  &lt;type&gt; is the object type.  &lt;info words&gt; (optional) can contain one or more of the keywords *BEGIN*, *END*, *PRIMARY*.  &lt;text&gt; is the text printed in the index for this index entry.Example:  {indexX {name +} {type (Infix Operator)} {text {lisp {arg X}+{arg Y}}}} could be used to index "+" as an infix operator so that it would appear in the index alphabetized near other "+"s, but printing as "A+B".{Def {type &lt;type&gt;} {name &lt;name&gt;} {printname &lt;pname&gt;} {args &lt;args&gt;} {parens} {noparens} {text &lt;text&gt;} }	May be used to specify the definition of anything.  &lt;type&gt; should be an object-type, as specified above.  &lt;name&gt; should be the name of the object, ideally a single word.  If {printname &lt;pname&gt;} (optional) is given, it will be used for printing the object in the top line of the definition and in the index.  If {printname &lt;pname&gt;} is not given, the printed name is specified by {name &lt;name&gt;}, {args &lt;args&gt;}, {parens}, and {noparens}.  &lt;args&gt; should be the "arguments" of this object.  [{args &lt;args&gt;} is optional.]  Normally, {Def will put parenthesis around the object if and only if {Args &lt;args&gt;} is given.  {parens} and {noparens} (if given) can be used to change this default behavior.  Examples:	{Def {Type (Blobby Command)} {Name DOBLOB} {Args A B}		{Text ....}}	{Def {Type (CLISP Character)}  {Name +}  {PrintName {lisp {arg X}+{arg Y}}}		{Text ....}}[Note:  {IndexX ...} and {Def ...} DO NOT allow multi-word index names.  If more than one word is given, only the first is used.  &lt;&lt;&lt;may be changed&gt;&gt;&gt;]{Tag &lt;tag&gt;}	This may be used to associate &lt;tag&gt;, a single word (upper/lower case doesn't matter), with a particular place in the text.  This can be referenced by {SectionRef and {PageRef as described below.{SectionRef &lt;object-type&gt; &lt;object&gt;}{PageRef &lt;object-type&gt; &lt;object&gt;}	These TOs are used to provide a cross-reference facility.  {SectionRef will print "section " and the section that the "main" occurence of the object with the given type occurs. &lt;"main" shall remain undefined for now&gt;  {PageRef prints "page " and the appropriate page number.  If &lt;object-type&gt; is "Tag", these TOs can refer to tags generated with {Tag &lt;tag&gt;}.  Examples:	{SectionRef Fn CONS} could print "section 3.1.1"	{PageRef (File Package Type) Expressions} could print "page 14.34"	{PageRef Tag CompilingCLISP} could print "page 20.42"[note currently, the translation program will not automatically substitute cross-references.  Instead, {PageRef Tag CompilingCLISP} will print "page &lt;Tag CompilingCLISP&gt;".]{Term &lt;text&gt;}	Prints &lt;text&gt; exactly as given, and also puts it into the index.  Equivalent to "&lt;text&gt;{index &lt;text&gt; Term}".{Figure {tag &lt;tag&gt;} {text &lt;text&gt;} {caption &lt;text&gt;} }	Prints a simple "figure", with figure text and caption as specified by the "text" and "caption" arguments.  "{tag &lt;tag&gt;}" is an optional argument which, if specified, generates a tag at the beginning of the figure.  This tag can be used to refer to the page or section that this figure appears on (using {PageRef Figure &lt;tag&gt;} or {SectionRef Figure &lt;tag&gt;}), or to refer to the figure number (using {FigureRef &lt;tag&gt;}){FigureRef &lt;tag&gt;}	Prints "figure" and the figure number of the figure with the specified tag.************************** Complex Text objects ******{numberedlist {item &lt;text&gt;} {item &lt;text&gt;} {item &lt;text&gt;} ...} 	Used for making numbered lists of items.Synonyms:	Text	-&gt; Item{unnumberedlist {item &lt;text&gt;} {item &lt;text&gt;} {item &lt;text&gt;} ...} 	Like {numberedlist ...}, except that it uses bullets to mark each item in the list.Synonyms:	UnlabeledList  -&gt; Unnumberedlist		Text	-&gt; Item{labeledlist {name &lt;text&gt;} {item &lt;text&gt;} {name &lt;text&gt;} {item &lt;text&gt;} ...} 	Used for making a table associating a set of labels with descriptions of their meanings.Synonyms:	Label	-&gt; Name		Text	-&gt; Item{Table {Column} ... {Column} {First &lt;text&gt;} {Next &lt;text&gt;} {Next &lt;text&gt;} ... {First &lt;text&gt;} ... }	Used for formatting multi-column tables.  The number of {Column}'s before the first {First or {Next indicates how many columns the table should have.  If no {Column}'s are given, the default is three columns.  There are other formatting arguments, but they will probably change.************************** Other Text objects ******{Include &lt;filename&gt;}	Used to include the text of one file within another.  Files may be nested arbitrarily deep.	{Lbracket}{Rbracket}{bracket &lt;text&gt;}	These are used to insert the curly-bracket symbol into the text.  {Lbracket} and {Rbracket} insert left and right brackets, and {bracket &lt;text&gt;} puts brackets around the given piece of text.The following TOs are used to specify certain non-typeable characters.{CRsymbol} or {cr} -	carriage return symbol				(currently a superscripted 'CR'){pi}			-	Greek letter pi{plusminus}		-	Plus or Minus ("+" + "-"){GE}			-	greater than or equal ("&gt;" + "="){LE}			-	less than or equal ("&lt;" + "="){NE}			-	not equal ("=" + "|"){endash}		-	short dash{emdash}		-	long dash{ellipsis}		-	ellipsis (...){bullet}		-	bullet{anonarg}		-	long dash  (should be used in the argument list				of a function definition to specify the "unspecified				arguments" specified in the current manual with a				dash)</pre>
  </body>
</html>
