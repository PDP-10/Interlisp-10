<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>SystemTools>DiagnosticsImplI.mesa!1</title>
  </head>
  <body>
    <pre>
-- File: DiagnosticsImplI.mesa - last edit by: -- Paul		13-Jul-84 11:06:54DIRECTORY  DiagnosticsOps USING [PlotterType],  GreenFace USING [    Command, ForceWakeups, GetAndResetStatus, GetStatus, LogCommand, LogStatus,    PutCommand, SendPage, Status],  Inline USING [LongCOPY],  Msg USING [FeedBack],  Process USING [Detach, Pause, MsecToTicks, SetTimeout],  Space USING [PageFromLongPointer, ScratchMap],  UserTerminal USING [GetBitBltTable],  VM USING [Interval, MakeResident, MakeSwappable];DiagnosticsImplI: MONITOR  IMPORTS GreenFace, Inline, Msg, Process, Space, UserTerminal, VM  EXPORTS DiagnosticsOps =  BEGIN  DataType: TYPE = {nthBit, count, ff00, ascii};  Enumerated: TYPE = RECORD [string: LONG STRING, value: UNSPECIFIED];  -- Variable declarations  cmd: GreenFace.Command &larr; reset;  bitStep: CARDINAL &larr; 1;  dataType: DataType &larr; ff00;  bufferPages: CARDINAL = 2;  buffer: LONG POINTER = Space.ScratchMap[bufferPages];  vi: VM.Interval = [page: Space.PageFromLongPointer[buffer], count: bufferPages];  greenStarStatus: GreenFace.Status;  GetStatus: PUBLIC PROCEDURE [plotter: DiagnosticsOps.PlotterType]    RETURNS [GreenFace.Status] = {RETURN[greenStarStatus]};  SendCommand: PUBLIC PROCEDURE [    plotter: DiagnosticsOps.PlotterType, cmd: GreenFace.Command] = {SendCmd[cmd]};  PrintPattern: PUBLIC PROCEDURE [plotter: DiagnosticsOps.PlotterType] = {    dataType &larr; ascii;    SendVideo[];};      PlotPattern: PUBLIC PROCEDURE [plotter: DiagnosticsOps.PlotterType] = {    dataType &larr; count;    SendVideo[];};  PlotScreen: PUBLIC PROCEDURE [plotter: DiagnosticsOps.PlotterType] = {    pID: PROCESS;    Msg.FeedBack[s: "Plot invoked"L, severity: info, endWithCR: TRUE];    VM.MakeResident[vi, wait];    pID &larr; FORK PlotPage[plotter];    JOIN pID;    VM.MakeSwappable[vi]};  PlotPage: PROCEDURE [plotter: DiagnosticsOps.PlotterType] = {    screenData: LONG POINTER TO PACKED ARRAY [0..1024) OF BOOLEAN &larr;      UserTerminal.GetBitBltTable[].src.word;    Pixel: TYPE = MACHINE DEPENDENT{white(0), black(3)};    printData: LONG POINTER TO PACKED ARRAY OF Pixel = buffer;    word: CARDINAL &larr; 0;    SendCmd[reset];    Pause[1000];    AssertStatus[plotterready];    SendCmd[plot];    Zero[buffer, 512];    SendCmd[rlter];    AssertStatus[plotterready];    Msg.FeedBack[s: "screen contents..."L, severity: info, endWithCR: TRUE];    Pause[1000];    FOR k: CARDINAL IN [0..808) DO  --808 visible display lines      offset: CARDINAL = word * 8;      FOR i: CARDINAL IN [0..1024) DO        dataOffset: CARDINAL = offset + i;        IF screenData[i] THEN          printData[dataOffset] &larr; printData[dataOffset + 1056] &larr; black        ELSE printData[dataOffset] &larr; printData[dataOffset + 1056] &larr; white;        ENDLOOP;      word &larr; word + 8;      --if word = 256 then send both pages and reset word to 0      -- send a buffer      GreenFace.SendPage[buffer];      IF word = 256 THEN {GreenFace.SendPage[buffer + 256]; word &larr; 0};      Inline.LongCOPY[from: buffer + 256, nwords: word, to: buffer];      Zero[buffer + word + 128, 4];      Zero[buffer + word + 260, 4];      screenData &larr; screenData + 64;      ENDLOOP;    SendCmd[rffed];    AssertStatus[plotterready]};  Pause: PROCEDURE [msec: CARDINAL] = {Process.Pause[Process.MsecToTicks[msec]]};    AssertStatus: PROCEDURE [expectedStatus: GreenFace.Status] = {    Pause[1000];    SendCmd[sensestatus];    Pause[1000];    [] &larr; GreenFace.GetAndResetStatus[];    IF expectedStatus = greenStarStatus THEN RETURN;  -- ok    Text["Bad status -- expected "L];    GreenFace.LogStatus[expectedStatus, Text];    Text[", got "L];    GreenFace.LogStatus[greenStarStatus, Line]};  Statusproc: ENTRY PROCEDURE = {    cv: CONDITION;    Process.SetTimeout[@cv, 1];    Text["Status = "L];     GreenFace.LogStatus[greenStarStatus, Line];    DO      status: GreenFace.Status = GreenFace.GetStatus[];      IF status = null OR status = greenStarStatus THEN {WAIT cv; LOOP};      Text["Status = "L];      GreenFace.LogStatus[greenStarStatus &larr; status, Line];      ENDLOOP};  DoWakeup: PROCEDURE = {GreenFace.ForceWakeups[]};  SendVideo: PROCEDURE = {    bitArray: LONG POINTER TO PACKED ARRAY [0..4096) OF BOOLEAN = buffer;    byteArray: LONG POINTER TO PACKED ARRAY [0..512) OF [0..256) = buffer;    VM.MakeResident[vi, wait];    Text["Sending... "L];    SELECT dataType FROM      count =&gt; {        FOR j: CARDINAL IN [0..512) DO byteArray[j] &larr; (j + 1) MOD 256 ENDLOOP;        Line["1, 2, ... FF, 0, 1, 2, ... FF, 0"L]};      ascii =&gt; {        FOR j: CARDINAL IN [0..512) DO          i: CARDINAL = j MOD 28;          byteArray[j] &larr;            SELECT i FROM              26 =&gt; 13,  -- CR              27 =&gt; 10,  -- LF              ENDCASE =&gt; LOOPHOLE['A, CARDINAL] + i;  -- A ... Z          ENDLOOP;        Line["A, B, C, ... Z, CR, LF, A, B, ..."L]};      ff00 =&gt; {        FOR j: CARDINAL IN [0..512) DO          byteArray[j] &larr; IF j MOD 2 = 0 THEN 255 ELSE 0 ENDLOOP;        Line["FF, 00, FF, 00, ..."L]};      nthBit =&gt; {FOR j: CARDINAL IN [0..512) DO byteArray[j] &larr; 142b ENDLOOP};      ENDCASE =&gt; Line["BAD ENUMERATED VALUE!!!"L];    GreenFace.SendPage[buffer];    VM.MakeSwappable[vi]};  SendCmd: PROCEDURE [cmd: GreenFace.Command] = {    Text["Command = "L];    IF cmd = null THEN {Line["0; not sent!"L]; RETURN};    GreenFace.PutCommand[cmd];    GreenFace.LogCommand[cmd, Line] --effective 500 milli pause-- };  Zero: PROC [lp: LONG POINTER, count: CARDINAL] = {    lp&uarr; &larr; 0; Inline.LongCOPY[from: lp, nwords: count - 1, to: lp + 1]};  Text: PROC [s: LONG STRING] = {    Msg.FeedBack[s: s, severity: info, endWithCR: FALSE]};  Line: PROC [s: LONG STRING] = {    Msg.FeedBack[s: s, severity: info, endWithCR: TRUE]};  -- Tool routines  PrintInit: PROCEDURE = {    pID: PROCESS;    pID &larr; FORK WakeUpGreenStar[];    JOIN pID;};      WakeUpGreenStar: PROCEDURE = {    SendCmd[reset];    Pause[4000];    greenStarStatus &larr; GreenFace.GetAndResetStatus[];    Pause[1000];    SendCmd[rffed]};    Init: PROCEDURE = {    PrintInit[];    Process.Detach[FORK Statusproc[]]};  END.</pre>
  </body>
</html>
