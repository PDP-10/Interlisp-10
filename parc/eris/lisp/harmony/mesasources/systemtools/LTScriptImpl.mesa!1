--LTScriptImpl.mesa--limited tool to write prometheus script --Created by--   JFung.PASA	  	22-May-84 13:16:54--last edited by--   JFung.PASA	   	 6-Sep-84 10:19:48 DIRECTORY     Cursor,     EventTypes,     Exec,     File,     Format,     FormSW,     Heap,     LispToolOps,     MFile,     MStream,     Process,     Profile,     Put,     Runtime,     Stream,     String,     StringLookUp,     Supervisor,     Time,     Token,     Tool,     ToolDriver,     ToolWindow,     UserInput,     Version,     Volume,     Window;LTScriptImpl: PROGRAM     IMPORTS          Cursor, FormSW, Heap, LispToolOps, MFile, MStream, Process, Put,          Runtime, Stream, String, Time, Tool, ToolDriver, Window     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;     SA1000Size: LONG CARDINAL = 16188;     SA4000Size: LONG CARDINAL = 44797;     Q2040Size:  LONG CARDINAL = 65274;     DiskType: TYPE = {SA1000, SA4000, Q2040};     DataHandle: TYPE = LONG POINTER TO Data;     Data: TYPE = MACHINE DEPENDENT RECORD [          -- Message subwindow stuff          msgSW(0): Window.Handle _ NIL,          -- File subwindow stuff          fileSW(2): Window.Handle _ NIL,          -- Form subwindow stuff          -- Note: enumerateds and booleans must be word boundary          -- aligned as addresses for them must be generated          --formSW: Window.Handle _ NIL,          paramSW(4): Window.Handle _ NIL,          commandSW(6): Window.Handle _ NIL,          busy(8): BOOLEAN _ FALSE,  -- command is running          vol1Name(9): LONG STRING _ NIL,          vol2Name(11): LONG STRING _ NIL,          vol3Name(13): LONG STRING _ NIL,          vol4Name(15): LONG STRING _ NIL,          vol5Name(17): LONG STRING _ NIL,          vol6Name(19): LONG STRING _ NIL,          vol1Size(21): CARDINAL _ 3500,          vol2Size(22): LONG CARDINAL _ 0,          vol3Size(24): LONG CARDINAL _ 0,          vol4Size(26): LONG CARDINAL _ 0,          vol5Size(28): LONG CARDINAL _ 0,          vol6Size(30): LONG CARDINAL _ 0,	  vol7Name(32): LONG STRING _ NIL,          vol8Name(34): LONG STRING _ NIL,          vol9Name(36): LONG STRING _ NIL,	  vol10Name(38): LONG STRING _ NIL,          vol7Size(40): LONG CARDINAL _ 0,          vol8Size(42): LONG CARDINAL _ 0,          vol9Size(44): LONG CARDINAL _ 0,          vol10Size(46): LONG CARDINAL _ 0,          driveSize(48): LONG CARDINAL _ Q2040Size,          freePages(50): LONG CARDINAL _ Q2040Size - 3500,          diskType(52): DiskType _ Q2040];     active: BOOLEAN _ FALSE;     debug: BOOLEAN _ FALSE;     diagName: LONG STRING _ "SystemTools"L;     formDisplay: ToolWindow.DisplayProcType _ NIL;               myFile: MFile.Handle _ NIL;     nVols: INTEGER _ 1;     scriptWH: Window.Handle _ NIL;     toolData: DataHandle _ NIL;<<     ClearFileSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL _ 0, i + 1 UNTIL               (item _ FormSW.FindItem[toolData.fileSW, i]) = NIL DO               item.flags.invisible _ TRUE ENDLOOP;          FormSW.Display[toolData.fileSW];          formDisplay _ Window.GetDisplayProc[toolData.fileSW];          END;>>     ClearMsgSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL _ 0, i + 1 UNTIL               (item _ FormSW.FindItem[toolData.msgSW, i]) = NIL DO               item.flags.invisible _ TRUE ENDLOOP;          FormSW.Display[toolData.msgSW];          formDisplay _ Window.GetDisplayProc[toolData.msgSW];          END;     ClearSubWindows: PROCEDURE =          BEGIN          --ClearFileSubwindow;          ClearMsgSubwindow;          END;     <<     ClientTransition: ToolWindow.TransitionProcType =          -- This procedure is called whenever the system determines that this          -- Tool's state is undergoing a user invoked transition.          -- In this Example we demonstrate a technique that minimizes the memory          -- requirements for a Tool that is inactive.          BEGIN          SELECT TRUE FROM               old = inactive =>                    BEGIN                    IF toolData = NIL THEN                         toolData _ Heap.systemZone.NEW[Data _ []];                    active _ TRUE;                    END;               new = inactive =>                    BEGIN                    <<Supervisor.RemoveDependency[                        client: agent, implementor: Event.toolWindow];			>>                    IF toolData # NIL THEN                         BEGIN                         FormSW.Destroy[toolData.paramSW];                         FormSW.Destroy[toolData.commandSW];                         Heap.systemZone.FREE[@toolData];                         END;                    --ToolDriver.RemoveSWs[tool: "LispTool"L];                    active _ FALSE;                    END;               ENDCASE          END;  --ClientTransition>>       DataChanged: FormSW.ProcType =      BEGIN       END;         NumberChanged: FormSW.LongNumberNotifyProcType =      BEGIN        END;         FormSWMakeScript: FormSW.ProcType =          BEGIN          floppyFileName: LONG STRING _ "Prometheus.script"L;          toolData.busy _ TRUE;          ClearSubWindows;          Put.Line[               toolData.fileSW,               "WARNING: will DESTROY your old file, confirm to continue"L];          IF ILT.Confirm[] THEN {               Put.Line[                    toolData.fileSW,                    "Insert ""Installation Utility"" floppy, confirm when ready"L];               IF ILT.Confirm[] THEN 	            IF ILT.FloppyDelete[floppyFileName] THEN 		    IF WriteUserScript[] THEN {		    	ILT.FloppyWrite[floppyFileName];			Put.Line[toolData.fileSW, " Done"L];                	};	       };          toolData.busy _ FALSE;          END;     FormSWQuit: FormSW.ProcType =          BEGIN          --[] _ ToolWindow.Deactivate[scriptWH];          IF toolData # NIL THEN               BEGIN               --Put.Line[toolData.fileSW, "Tool.Destroy"L];               --Process.Pause[Process.SecondsToTicks[5]];               Tool.Destroy[scriptWH];               --Put.Line[toolData.fileSW, "Heap.systemZone.FREE"L];               --Process.Pause[Process.SecondsToTicks[5]];               Heap.systemZone.FREE[@toolData];               END;          END;     MakeCommands: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..3) OF CARDINAL _ [0, 30, 60];          nItems: CARDINAL = 2;          items _ AllocateItemDescriptor[nItems];          items[0] _ CommandItem[tag: "Make Script"L, proc: FormSWMakeScript, 	  	place: newLine];          items[1] _ CommandItem[tag: "Quit"L, proc: FormSWQuit];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE];          END;  --MakeCommands     MakeParams: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..7) OF CARDINAL _ [0, 28, 52, 56, 60, 68, 75];          nItems: CARDINAL = 23;          diskForm: ARRAY [0..3) OF Enumerated _ [               ["10Mb"L, DiskType[SA1000]], ["29Mb"L, DiskType[SA4000]], [               "42Mb"L, DiskType[Q2040]]];          items _ AllocateItemDescriptor[nItems];          items[0] _ EnumeratedItem[               tag: "DiskType"L, place: newLine, z: Heap.systemZone, feedback: all,               value: @toolData.diskType, copyChoices: TRUE,               proc: ServerNotifyProc, choices: DESCRIPTOR[diskForm]];	       -- note: compiler does not check if this is a "short"NumberItem	                 items[1] _ LongNumberItem[               tag: "Drive Size"L, value: @toolData.driveSize, readOnly: TRUE];          items[2] _ LongNumberItem[               tag: "Free Pages"L, value: @toolData.freePages];          items[3] _ StringItem[               tag: "Volume1"L, string: @toolData.vol1Name, 	       inHeap: TRUE, readOnly: TRUE, place: newLine];          items[4] _ NumberItem[               tag: "Volume1 Size"L, value: @toolData.vol1Size, readOnly: TRUE];          items[5] _ StringItem[               tag: "Volume2"L, string: @toolData.vol2Name, inHeap: TRUE,               place: newLine, filterProc: StringChanged];          items[6] _ LongNumberItem[               tag: "Volume2 Size"L, value: @toolData.vol2Size];          items[7] _ StringItem[               tag: "Volume3"L, string: @toolData.vol3Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[8] _ LongNumberItem[               tag: "Volume3 Size"L, value: @toolData.vol3Size];          items[9] _ StringItem[               tag: "Volume4"L, string: @toolData.vol4Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[10] _ LongNumberItem[               tag: "Volume4 Size"L, 	       --proc: NumberChanged,	       value: @toolData.vol4Size 	       ];                    items[11] _ StringItem[               tag: "Volume5"L, string: @toolData.vol5Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[12] _ LongNumberItem[               tag: "Volume5 Size"L, value: @toolData.vol5Size, proc: NumberChanged];          items[13] _ StringItem[               tag: "Volume6"L, string: @toolData.vol6Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[14] _ LongNumberItem[               tag: "Volume6 Size"L, value: @toolData.vol6Size, proc: NumberChanged];	       	  items[15] _ StringItem[               tag: "Volume7"L, string: @toolData.vol7Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[16] _ LongNumberItem[               tag: "Volume7 Size"L, value: @toolData.vol7Size, proc: NumberChanged];	          	  items[17] _ StringItem[               tag: "Volume8"L, string: @toolData.vol8Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[18] _ LongNumberItem[               tag: "Volume8 Size"L, value: @toolData.vol8Size, proc: NumberChanged];	       	           	  items[19] _ StringItem[               tag: "Volume9"L, string: @toolData.vol9Name, inHeap: TRUE,	       filterProc: StringChanged,  place: newLine];          items[20] _ LongNumberItem[               tag: "Volume9 Size"L, value: @toolData.vol9Size, proc: NumberChanged];	                 items[21] _ StringItem[               tag: "Volume10"L, string: @toolData.vol10Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[22] _ LongNumberItem[               tag: "Volume10 Size"L, value: @toolData.vol10Size, proc: NumberChanged];	                 SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE]          END;  --MakeParams     MakeScript: PUBLIC PROCEDURE[] =          BEGIN          IF toolData = NIL THEN toolData _ Heap.systemZone.NEW[Data _ []];          scriptWH _ MakeTool[];          -- Display diag. vol name          toolData.vol1Name _ String.CopyToNewString[               s: diagName, z: Heap.systemZone];	   FormSW.DisplayItem[toolData.paramSW, 3];    	       	  -- Display drive size info               FormSW.DisplayItem[toolData.paramSW, 1];          toolData.freePages _ toolData.driveSize - toolData.vol1Size;	  -- display free pages          FormSW.DisplayItem[toolData.paramSW, 2];          END;     MakeSWs: Tool.MakeSWsProc =          BEGIN          logName: STRING _ [40];          addresses: ARRAY [0..4) OF ToolDriver.Address;          Tool.UnusedLogName[unused: logName, root: "MakeScript.log"L];          toolData.msgSW _ Tool.MakeMsgSW[window: window, lines: 1];          toolData.paramSW _ Tool.MakeFormSW[window: window, formProc: MakeParams];          toolData.commandSW _ Tool.MakeFormSW[               window: window, formProc: MakeCommands];          toolData.fileSW _ Tool.MakeFileSW[window: window, name: logName];	  	  --FormSW.SetModifyNotificationProc[toolData.paramSW, DataChanged];          -- do the ToolDriver stuff          addresses _ [               [name: "msgSW"L, sw: toolData.msgSW], [               name: "ParamSW"L, sw: toolData.paramSW], [               name: "CmdSW"L, sw: toolData.commandSW], [               name: "fileSW"L, sw: toolData.fileSW]];          ToolDriver.NoteSWs[               tool: "MakeScript"L, subwindows: DESCRIPTOR[addresses]];          END;     MakeTool: PROCEDURE RETURNS [wh: Window.Handle] =          BEGIN          heraldName: STRING _ [80];          String.AppendString[heraldName, "AISBU System Tools: Make Script Option "L];          String.AppendString[heraldName, " of "L];          Time.Append[heraldName, Time.Unpack[Runtime.GetBcdTime[]]];          heraldName.length _ heraldName.length - 3;          --String.AppendString[heraldName, " on Pilot Version "L];          --Version.Append[heraldName];          RETURN[               Tool.Create[                    makeSWsProc: MakeSWs, initialState: default,                    --clientTransition: ClientTransition,                     name: heraldName, 		    initialBox: [[512, 0], [512, 400]],                    --x, y, width, height                     tinyName1: "Make"L, tinyName2: "Script"L]];          END;     ServerNotifyProc: FormSW.EnumeratedNotifyProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "ServerNotifyProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          IF toolData.diskType = SA1000 THEN toolData.driveSize _ SA1000Size          ELSE               IF toolData.diskType = SA4000 THEN toolData.driveSize _ SA4000Size               ELSE toolData.driveSize _ Q2040Size;          toolData.freePages _ toolData.driveSize - toolData.vol1Size;	  	            FormSW.DisplayItem[toolData.paramSW, 1];          FormSW.DisplayItem[toolData.paramSW, 2];          END;  --ServerNotifyProc     StringChanged: FormSW.FilterProcType =      BEGIN    	  -- Display free pages info 	  IF debug THEN {	  	Put.Line[toolData.fileSW, "StringChanged..."L];		Put.Text[toolData.fileSW, "vol2Size: "L];          	Put.LongDecimal[toolData.fileSW, toolData.vol2Size];          	Process.Pause[Process.SecondsToTicks[5]];		};			  nVols _ 1; 	  toolData.freePages _ toolData.driveSize - toolData.vol1Size;	  	  IF toolData.vol2Size > 0 OR toolData.vol2Name # NIL THEN  {	  	nVols _ nVols + 1;	  	toolData.freePages _ toolData.freePages - toolData.vol2Size;		};			  IF toolData.vol3Size > 0 OR toolData.vol3Name # NIL THEN {	  	nVols _ nVols + 1;		toolData.freePages _ toolData.freePages - toolData.vol3Size;		};			  IF toolData.vol4Size > 0 OR toolData.vol4Name # NIL THEN {	  	nVols _ nVols + 1;	  	toolData.freePages _ toolData.freePages - toolData.vol4Size;		};			  IF toolData.vol5Size > 0 OR toolData.vol5Name # NIL THEN {	  	nVols _ nVols + 1;		toolData.freePages _ toolData.freePages - toolData.vol5Size;		};			  IF toolData.vol6Size > 0 OR toolData.vol6Name # NIL THEN  {	  	nVols _ nVols + 1;	  	toolData.freePages _ toolData.freePages - toolData.vol6Size;		};			  IF toolData.vol7Size > 0 OR toolData.vol7Name # NIL THEN {	  	nVols _ nVols + 1;		toolData.freePages _ toolData.freePages - toolData.vol7Size;		};			  IF toolData.vol8Size > 0 OR toolData.vol8Name # NIL THEN {	  	nVols _ nVols + 1;	  	toolData.freePages _ toolData.freePages - toolData.vol4Size;		};			  IF toolData.vol9Size > 0 OR toolData.vol9Name # NIL THEN {	  	nVols _ nVols + 1;		toolData.freePages _ toolData.freePages - toolData.vol9Size;		};			  		  IF toolData.vol10Name # NIL THEN {	  	nVols _ nVols + 1;		toolData.vol10Size _ toolData.freePages;		FormSW.DisplayItem[toolData.paramSW, 22];		toolData.freePages _ toolData.freePages - toolData.vol10Size;		};		          FormSW.DisplayItem[toolData.paramSW, 2];	  FormSW.StringEditProc[sw, item, insert, string];       END;  -- StringChanged          WriteUserScript: PROCEDURE[] RETURNS [BOOLEAN] =          BEGIN          name: LONG STRING _ "Prometheus.script"L;          writeS: MStream.Handle _ NIL;          --tempString: LONG STRING _ [80];	  tempString: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  tempString1: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  tempString2: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  	  tempString3: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  tempString4: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  tempString5: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  tempString6: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  	  tempString7: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  tempString8: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  tempString9: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  tempString10: LONG STRING _ Heap.systemZone.NEW[StringBody [80]];	  z: UNCOUNTED ZONE _ Heap.systemZone;	  --StringChanged[];          IF ~MFile.ValidFilename[name] THEN {               Put.Line[toolData.msgSW, "Invalid file name"L]; RETURN[FALSE]; };          myFile _ MFile.Acquire[               name, anchor, MFile.dontRelease !               MFile.Error => {myFile _ NIL; CONTINUE}];          Cursor.Set[hourGlass];          --IF myFile # NIL THEN MFile.Release[myFile];          BEGIN          ENABLE MFile.Error => GOTO problem;          --ENABLE MFile.Error  => {MFile.Release[myFile]; CONTINUE;};          IF myFile # NIL THEN               BEGIN               IF debug THEN {                    Put.Line[toolData.fileSW, "SetAccess..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               MFile.SetAccess[myFile, readWrite];               END          ELSE               BEGIN               IF debug THEN {                    Put.Line[toolData.fileSW, "ReadWrite..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               myFile _ MFile.ReadWrite[name, MFile.dontRelease, text];               END;          --myFile _ MFile.ReadWrite[name, MFile.dontRelease, text];          -- myFile is ReadWrite so can Copy handle with read later          writeS _ MStream.Create[myFile, []];          MStream.SetLength[writeS, 0];          writeS.PutString["\\Partition disk according to user definition\n"L];          writeS.PutString[               "Comment WARNING - PARTITIONING A DISK DESTROYS ALL ITS CONTENTS\n"L];          writeS.PutString["Confirm Continue?\n"L];          --tempString _ String.CopyToNewString[          --    s: "Create Rd0 YLisp "L, z: Heap.systemZone];	  	  String.AppendString[tempString1, "Create Rd0 YLisp "L];          String.AppendDecimal[tempString1, nVols];	  String.AppendString[tempString1, "\n"L];	                 IF debug THEN {	  	Put.Text[toolData.fileSW, "tempString1"L];          	Put.Line[toolData.fileSW, tempString1];	  	Process.Pause[Process.SecondsToTicks[5]];		Put.Line[toolData.fileSW, "Append decimal"];	  	Put.Decimal[toolData.fileSW, nVols];	  	Process.Pause[Process.SecondsToTicks[5]];          	Put.Line[toolData.fileSW, "AppendDecimal"L];          	Put.Line[toolData.fileSW, tempString1];	  	Process.Pause[Process.SecondsToTicks[5]];		};	            writeS.PutString[tempString1];          writeS.PutString["SystemTools 3500 normal\n"L];          IF ~String.Empty[toolData.vol2Name] AND toolData.vol2Size > 0 THEN {          	String.AppendString[tempString2, toolData.vol2Name];		String.AppendString[tempString2, " "L];		String.AppendLongDecimal[tempString2, toolData.vol2Size];	        String.AppendString[tempString2, " normal\n"L];                writeS.PutString[tempString2]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString2];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	       	                 IF ~String.Empty[toolData.vol3Name] AND toolData.vol3Size > 0 THEN {          	String.AppendString[tempString3, toolData.vol3Name];		String.AppendString[tempString3, " "L];		String.AppendLongDecimal[tempString3, toolData.vol3Size];	        String.AppendString[tempString3, " normal\n"L];                writeS.PutString[tempString3]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString3];	  		Put.Text[toolData.fileSW, "tempString"L];          		Process.Pause[Process.SecondsToTicks[5]];			};               };	                 IF ~String.Empty[toolData.vol4Name] AND toolData.vol4Size > 0 THEN {          	String.AppendString[tempString4, toolData.vol4Name];		String.AppendString[tempString4, " "L];		String.AppendLongDecimal[tempString4, toolData.vol4Size];	        String.AppendString[tempString4, " normal\n"L];                writeS.PutString[tempString4]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString4];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	       	                 IF ~String.Empty[toolData.vol5Name] AND toolData.vol5Size > 0 THEN {         	String.AppendString[tempString5, toolData.vol5Name];		String.AppendString[tempString5, " "L];		String.AppendLongDecimal[tempString5, toolData.vol5Size];	        String.AppendString[tempString5, " normal\n"L];                writeS.PutString[tempString5]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString4];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	                 IF ~String.Empty[toolData.vol6Name] AND toolData.vol6Size > 0 THEN {         	String.AppendString[tempString6, toolData.vol6Name];		String.AppendString[tempString6, " "L];		String.AppendLongDecimal[tempString6, toolData.vol6Size];	        String.AppendString[tempString6, " normal\n"L];                writeS.PutString[tempString6]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString6];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	       	            IF ~String.Empty[toolData.vol7Name] AND toolData.vol7Size > 0 THEN {         	String.AppendString[tempString7, toolData.vol7Name];		String.AppendString[tempString7, " "L];		String.AppendLongDecimal[tempString7, toolData.vol7Size];	        String.AppendString[tempString7, " normal\n"L];                writeS.PutString[tempString7]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString7];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	       	            IF ~String.Empty[toolData.vol8Name] AND toolData.vol8Size > 0 THEN {         	String.AppendString[tempString8, toolData.vol8Name];		String.AppendString[tempString8, " "L];		String.AppendLongDecimal[tempString8, toolData.vol8Size];	        String.AppendString[tempString8, " normal\n"L];                writeS.PutString[tempString8]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString8];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	            	            IF ~String.Empty[toolData.vol9Name] AND toolData.vol9Size > 0 THEN {         	String.AppendString[tempString9, toolData.vol9Name];		String.AppendString[tempString9, " "L];		String.AppendLongDecimal[tempString9, toolData.vol9Size];	        String.AppendString[tempString9, " normal\n"L];                writeS.PutString[tempString9]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString9];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	                      IF ~String.Empty[toolData.vol10Name] AND toolData.vol10Size > 0 THEN {         	String.AppendString[tempString10, toolData.vol10Name];		String.AppendString[tempString10, " "L];		String.AppendLongDecimal[tempString10, toolData.vol10Size];	        String.AppendString[tempString10, " normal\n"L];                writeS.PutString[tempString10]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString10];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	                      writeS.PutString["Check RD0\n"L];          writeS.PutString["Comment Disk partitioned for Interlisp-D\n"L];          EXITS               problem => {                    Put.Line[toolData.fileSW, "Error in auquiring file..."L];                    IF myFile # NIL THEN MFile.Release[myFile];                    RETURN[FALSE];                    }          END;	  writeS.SendNow;          ILT.WriteScriptA[myFile, writeS];	-- write part a first	  ILT.WriteScriptB[myFile, writeS];	-- write more	  IF debug THEN {			Put.Text[toolData.fileSW, "SendNow..."L];         		Process.Pause[Process.SecondsToTicks[5]];			};          writeS.SendNow;	   	  IF debug THEN {			Put.Text[toolData.fileSW, "CopyFileHandle..."L];         		Process.Pause[Process.SecondsToTicks[5]];			};          myFile _ MFile.CopyFileHandle[               MStream.GetFile[writeS], MFile.dontRelease, readOnly];          IF debug THEN {               Put.Line[toolData.fileSW, "Delete..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS.Delete;	            IF myFile # NIL THEN MFile.Release[myFile];          Cursor.Set[textPointer];          --Process.Pause[Process.SecondsToTicks[5]];	  	  RETURN[TRUE];	  END;         END...