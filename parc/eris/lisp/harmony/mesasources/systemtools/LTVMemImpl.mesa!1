--LTVMemImpl.mesa--Created by--   JFung.PASA	  	17-Nov-83 13:59:25--last edited by--   JFung.PASA	   	17-Jul-84 14:07:51DIRECTORY     Environment,     File,     FileTypes USING [tUntypedFile],     Format,     LispToolOps,     OthelloOps,     Process,     Put,     Scavenger,     Space,     TemporaryBooting USING [InvalidParameters],     Volume,     Window;LTVMemImpl: PROGRAM     IMPORTS          File, LispToolOps, OthelloOps, Process, Put, TemporaryBooting, Volume     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;     debug: BOOLEAN _ FALSE;     volumeID: Volume.ID _ Volume.nullID;     volumeOpen: BOOLEAN _ FALSE;     CloseVolume: PROC =          BEGIN          IF volumeOpen THEN {Volume.Close[volumeID]; volumeOpen _ FALSE}          END;     GetFileSize: PUBLIC PROCEDURE[] RETURNS [pageCount: File.PageCount] =          --BEGIN OPEN OthelloOps;	  BEGIN--          cap: File.Capability;	  cap: File.File;          firstPage: File.PageNumber;          created: BOOLEAN _ FALSE;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Enter DisplayFileSize..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          pageCount _ ILT.toolData.vMemSize;          [volumeID, volumeOpen] _ ILT.GetVolumeID[ILT.toolData.volName];          IF ~volumeOpen THEN RETURN;	  IF debug THEN {               Put.Line[ILT.toolData.fileSW, "GetVolumeBootFile"L];               Process.Pause[Process.SecondsToTicks[5]];               };          [cap, firstPage] _ OthelloOps.GetVolumeBootFile[volumeID, hardMicrocode	       ! Volume.Unknown => {	       --! UNWIND => {	       IF debug THEN {	       Put.Line[ILT.toolData.fileSW, "Volume Unknown"L];               Process.Pause[Process.SecondsToTicks[10]];	       };	       CONTINUE;	       }];	       	  IF cap = File.nullFile THEN {	  	pageCount _ 0;	       IF debug THEN {               Put.Line[ILT.toolData.fileSW, "nullFile"L];	       Process.Pause[Process.SecondsToTicks[10]];               }}	  ELSE  pageCount _ File.GetSize[cap	       ! UNWIND => {	       Put.Line[ILT.toolData.fileSW, "File Unknown"L];               Process.Pause[Process.SecondsToTicks[10]];	       CONTINUE;	       }];          IF debug THEN {               Put.LongDecimal[ILT.toolData.fileSW, pageCount];               Put.CR[ILT.toolData.fileSW];	       Process.Pause[Process.SecondsToTicks[10]];               };          END;  --GetFileSize     SetVMemFileSize: PUBLIC PROCEDURE [pages: File.PageCount] =          BEGIN OPEN OthelloOps;--          cap: File.Capability;          cap: File.File;          defaultVMemSize: File.PageCount;	  firstPage: File.PageNumber;          freePages: Volume.PageCount;	  created: BOOLEAN _ FALSE;	  currentSize: File.PageCount;          maxSize: Volume.PageCount;          size: File.PageCount;          sysoutSize: File.PageCount;          volSize: Volume.PageCount;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "SetVMemFileSize...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [volumeID, volumeOpen] _ ILT.GetVolumeID[ILT.toolData.volName];          IF ~volumeOpen THEN RETURN;          [cap, firstPage] _ GetVolumeBootFile[volumeID, hardMicrocode];          IF cap # File.nullFile THEN               BEGIN               ENABLE                    File.Unknown => {                         cap _ File.nullFile;                         IF debug THEN {                              Put.Line[                                   ILT.toolData.fileSW,                                   " not nullFile...."L];                              Process.Pause[Process.SecondsToTicks[5]];                              };                         CONTINUE};               END;  --IF cap # File.nullFile           IF (created _ cap = File.nullFile) THEN               BEGIN               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, " = nullFile...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               --cap _ File.Create[volumeID, 0, FileTypes.tUntypedFile];	       Put.Line[ILT.toolData.msgSW, " No sysout file on volume!"L];	       RETURN;               END;          [volSize, freePages] _ Volume.GetAttributes[volumeID];          --defaultVMemSize _ volSize - 2000;          sysoutSize _ File.GetSize[cap];          IF cap = File.nullFile THEN currentSize _ 0          ELSE currentSize _ File.GetSize[cap];          IF debug THEN {               Put.LongDecimal[ILT.toolData.fileSW, currentSize];               Put.CR[ILT.toolData.fileSW];               };	  Put.Text[ILT.toolData.fileSW, " \n Volume size = "L];          Put.LongDecimal[ILT.toolData.fileSW, volSize];          Put.Line[ILT.toolData.fileSW, " pages"L];<<          Put.Text[ILT.toolData.fileSW, " Default VMem size = "L];          Put.LongDecimal[ILT.toolData.fileSW, defaultVMemSize];          Put.Line[ILT.toolData.fileSW, " pages"L];          Put.Text[ILT.toolData.fileSW, " Free pages on volume = "L];          Put.LongDecimal[ILT.toolData.fileSW, freePages];          Put.CR[ILT.toolData.fileSW];>>    	  -- calculate maximum vmem size	  maxSize _ currentSize + freePages;          File.SetSize[               cap, maxSize !               Volume.InsufficientSpace => {maxSize _ maxSize - 100; RETRY}];          Put.Text[ILT.toolData.fileSW, " Approximate maximum VMem size = "L];          Put.LongDecimal[ILT.toolData.fileSW, maxSize];          Put.Line[ILT.toolData.fileSW, " pages"L];          IF ILT.toolData.vMemSize < sysoutSize THEN               BEGIN               Put.Line[                    ILT.toolData.fileSW,                    "WARNING: will shrink virtual memory size, please confirm to continue."L];               IF ~ILT.Confirm[] THEN 	       		BEGIN 			size _ ILT.GetFileSize[];			ILT.DisplayFileSize[size];	       		CloseVolume[]; 			RETURN; 			END;               END;          File.SetSize[               cap, ILT.toolData.vMemSize !               Volume.InsufficientSpace => {                    Put.Line[ILT.toolData.fileSW, " Not enough room for file!"L];                    CloseVolume[];                    GOTO noGood;                    }];		              Put.Line[ILT.toolData.fileSW, " Done."L];          CloseVolume[];          EXITS noGood => RETURN;          END;  -- SetVMemFileSize     END.  -- Prog. ILTVMemImpl