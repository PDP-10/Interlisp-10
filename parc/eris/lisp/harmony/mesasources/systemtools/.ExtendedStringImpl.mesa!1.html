<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>SystemTools>ExtendedStringImpl.mesa!1</title>
  </head>
  <body>
    <pre>
-- ExtendedStringImpl.mesa - edited by:-- AOF		20-Jan-82 10:40:47-- Poskanzer	28-Mar-83 16:40:31DIRECTORY  Environment USING [bitsPerWord],  ExtendedString USING [],  Heap USING [systemZone],  Inline USING [BITNOT, BITSHIFT, BITAND, BITOR, LongCOPY, HighHalf, LowHalf],  String USING [AppendChar];ExtendedStringImpl: PROGRAM IMPORTS Heap, Inline, String EXPORTS ExtendedString  =  BEGIN  InvalidBase: PUBLIC ERROR = CODE;  InvalidNumber: PUBLIC ERROR = CODE;  ConvertToBase: PROC [    field: LONG POINTER, size, base: CARDINAL,    array: LONG DESCRIPTOR FOR ARRAY OF CARDINAL] =    BEGIN    index: INTEGER;    bit: CARDINAL;    Sequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF CARDINAL];    copy: LONG POINTER &larr; Heap.systemZone.NEW[Sequence [size]];    Inline.LongCOPY[field, size, copy];    FOR index IN [1..LENGTH[array]) DO array[index] &larr; base; ENDLOOP;    array[0] &larr; 0;    THROUGH [0..size*Environment.bitsPerWord) DO      bit &larr; ShiftFieldLeft[copy, size, 1, 0];      FOR index &larr; 0, index + 1 UNTIL array[index] = base DO        array[index] &larr; array[index]*2 + bit;        IF array[index] &gt;= base THEN          BEGIN          array[index] &larr; array[index] - base;          bit &larr; 1;          IF array[index + 1] = base THEN array[index + 1] &larr; 0;          END        ELSE bit &larr; 0;        ENDLOOP;      ENDLOOP;    Heap.systemZone.FREE[@copy];    END;  ShiftFieldLeft: PROCEDURE [    ptr: LONG POINTER, size: CARDINAL, shift: INTEGER, new: CARDINAL]    RETURNS [lost: CARDINAL] =    --Shift field pointed to by "ptr" and of size (words) "size" left "shift" places.    --Save the bits lost off the left end in "lost" and add bits "new" to right end of field.    BEGIN    saveMask: CARDINAL = Inline.BITNOT[Inline.BITSHIFT[177777B, -shift]];    ptr &larr; ptr + size;    THROUGH [0..size) DO      ptr &larr; ptr - 1;      lost &larr; Inline.BITAND[ptr&uarr;, saveMask];      ptr&uarr; &larr; Inline.BITSHIFT[ptr&uarr;, shift];      ptr&uarr; &larr; Inline.BITOR[ptr&uarr;, new];      new &larr; lost &larr; Inline.BITSHIFT[lost, shift - Environment.bitsPerWord];      ENDLOOP;    END;  AppendNumber: PUBLIC PROC [    field: LONG POINTER, size: CARDINAL, base: CARDINAL, string: LONG STRING] =    BEGIN    digit, index, length: INTEGER;    Array: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF CARDINAL];    array: LONG POINTER TO ARRAY OF CARDINAL;    char: STRING &larr; "0123456789ABCDEF"L;    IF      (length &larr;        SELECT base FROM          IN [2..8) =&gt; size*Environment.bitsPerWord + 1,          IN [8..10) =&gt; (size*Environment.bitsPerWord + 3)/3 + 1,          IN [10..16) =&gt; size*Environment.bitsPerWord/3 + 1,          16 =&gt; size*Environment.bitsPerWord/4 + 1,          ENDCASE =&gt; 0) = 0 THEN ERROR InvalidBase;    array &larr; LOOPHOLE[Heap.systemZone.NEW[Array [length]]];    ConvertToBase[field, size, base, DESCRIPTOR[BASE[array&uarr;], length]];    FOR index IN [0..length) DO IF array[index] = base THEN EXIT; ENDLOOP;    FOR digit DECREASING IN [0..index) DO      String.AppendChar[string, char[array[digit]]]; ENDLOOP;    Heap.systemZone.FREE[@array];    END;  AppendDecimal: PUBLIC PROC [    field: LONG POINTER, size: CARDINAL, string: LONG STRING] =    BEGIN AppendNumber[field, size, 10, string]; END;  AppendOctal: PUBLIC PROC [    field: LONG POINTER, size: CARDINAL, string: LONG STRING] =    BEGIN AppendNumber[field, size, 8, string]; END;  AppendHex: PUBLIC PROC [    field: LONG POINTER, size: CARDINAL, string: LONG STRING] =    BEGIN AppendNumber[field, size, 16, string]; END;  StringToNumber: PUBLIC PROC [    field: LONG POINTER, size: CARDINAL, base: CARDINAL, string: LONG STRING] =    BEGIN    address: LONG POINTER TO CARDINAL;    new: LONG CARDINAL;    overflow: CARDINAL;    realBase: CARDINAL &larr; base;    length: CARDINAL &larr; string.length;    FOR index: CARDINAL IN [0..size) DO      address &larr; field + index; address&uarr; &larr; 0B; ENDLOOP;    IF length = 0 THEN ERROR InvalidNumber;    IF string[length - 1] = 'B OR string[length - 1] = 'b THEN      BEGIN realBase &larr; 8; length &larr; length - 1; END    ELSE      IF string[length - 1] = 'D OR string[length - 1] = 'd THEN        BEGIN realBase &larr; 10; length &larr; length - 1; END      ELSE        IF string[length - 1] = 'H OR string[length - 1] = 'h          OR string[length - 1] = 'X OR string[length - 1] = 'x THEN          BEGIN realBase &larr; 16; length &larr; length - 1; END;    FOR index: CARDINAL IN [0..length) DO      overflow &larr;        SELECT string[index] FROM          IN ['0..'9] =&gt; string[index] - '0,          IN ['A..'Z] =&gt; string[index] - 'A + 10,          IN ['a..'z] =&gt; string[index] - 'a + 10,          ENDCASE =&gt; LAST[CARDINAL];      IF overflow &gt;= realBase THEN ERROR InvalidNumber;      FOR subfield: CARDINAL DECREASING IN [0..size) DO        address &larr; field + subfield;        new &larr; LONG[address&uarr;]*realBase + LONG[overflow];        overflow &larr; Inline.HighHalf[new];        address&uarr; &larr; Inline.LowHalf[new];        ENDLOOP;      ENDLOOP;    END;  StringToDecimal: PUBLIC PROC [    field: LONG POINTER, size: CARDINAL, string: LONG STRING] =    BEGIN StringToNumber[field, size, 10, string]; END;  StringToOctal: PUBLIC PROC [    field: LONG POINTER, size: CARDINAL, string: LONG STRING] =    BEGIN StringToNumber[field, size, 8, string]; END;  END...   </pre>
  </body>
</html>
