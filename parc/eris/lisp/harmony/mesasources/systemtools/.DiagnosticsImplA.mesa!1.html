<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>SystemTools>DiagnosticsImplA.mesa!1</title>
  </head>
  <body>
    <pre>
-- DiagnosticsImplA.mesa  -  edited by:-- Poskanzer	12-Sep-83 17:11:55-- Paul		17-Jul-84 17:51:29DIRECTORY  ByeOps USING [ResumeBouncing, StopBouncing],  CH USING [zeroMaxLengthNames],  CHStubInternal USING [FindDomainAddr],  CommOnlineDiagnostics USING [PatternType, WordsInPacket],  DiagnosticsOps USING [    AppendServers, ConfirmIndex, Data, DataDisplayed, DataHandle, EchoUserTest,     FloppyCleanReadWriteHeads, FloppyCommandFileTest,    FloppyDisplayErrorLog, FloppyExerciser, FloppyFormatDiskette,    FloppyStandardTest, FloppyTest, Help, KeyboardAndMouseTest, LFDisplayTest,    Operation, PlotPattern, PlotScreen, PlotterType, PrintPattern, PutLine,    RS232CLoopBackTest, RS232LineType, SendCommand, StringIndex,    Tests, Two90Mode, Two90Pattern, Two90Test],  Format USING [HostNumber, NetworkNumber, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Destroy, Display, DisplayItem, Enumerated, EnumeratedItem,    EnumeratedNotifyProcType, FindItem, ItemHandle, newLine,     nullIndex, NumberItem, ProcType, StringItem],  GreenFace USING [Command, Status],  Heap USING [systemZone],  Msg USING [FeedBack, SetWindow],  NetworkStream USING [AssignNetworkAddress],  OnlineDiagnostics USING [ErrorHandling, SectorLength],  Process USING [Detach],  Profile USING [GetDefaultDomain, GetDefaultOrganization, String],  RS232C USING [LineSpeed],  RS232CEnvironment USING [LineSpeed],  String USING [    AppendNumber, AppendString, AppendStringAndGrow, Copy, CopyToNewString],  System USING [NetworkAddress, switches],  Tool USING [Create, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [Activate, Deactivate, TransitionProcType],  UserInput USING [CreatePeriodicNotify, PeriodicProcType],  UserTerminal USING [BlinkDisplay],  Window USING [GetChild, GetParent, Handle, rootWindow, Stack, ValidateTree],  WindowFont USING [FontHeight];DiagnosticsImplA: MONITOR  IMPORTS    ByeOps, CH, CHStubInternal, DiagnosticsOps, Format, FormSW,      Heap, Msg, NetworkStream, Process, Profile, String, System, Tool,    ToolWindow, UserInput, UserTerminal, Window, WindowFont  EXPORTS DiagnosticsOps =  BEGIN  -- TYPEs  FormIndex: TYPE = {    help, start, cancel, addCommand, deleteCommand, test, floppyTest,    currOrganization, currDomain, thisEthernetID, thisProcessorID, listFS, listPS,    listMS, testEthernetID, testProcessorID, realFeedBack, dataPattern,    minPacketSize, maxPacketSize, waitResponse, delayBetween, displayServers,    lineType, lineSpeed, pattern, constant, doubleDensity, doubleSided,    sectorsPerTrack, sectorLength, errorHandling, operation, cmdFile, trackNumber,    startingSector, sectorCount, increment, dataWord, loopCount, dataDisplayed,    two90TestType, two90PlotterType, two90Status, two90Mode, two90command,    plotprint};  -- Variable declarations.  oldMsgwh: Window.Handle &larr; NIL; --where Msg window was  diagnosticwh: PUBLIC Window.Handle &larr; NIL;  -- Tool's window  toolData: PUBLIC DiagnosticsOps.DataHandle &larr; NIL;  -- Tool's data  z: UNCOUNTED ZONE = Heap.systemZone;  -- Some of the following should probably be in toolData.  -- to let the GetXXXProc's know when ConfirmCommand has been bugged  confirmation: PUBLIC CONDITION;    cmdMax: CARDINAL = 100;  running: PUBLIC BOOLEAN &larr; FALSE;  -- whether there is a detached process running  probing: BOOLEAN &larr; FALSE;  -- whether we are probing the ethernet; like running  calledByBye: PUBLIC BOOLEAN &larr; FALSE;  -- whether we were activated by Bye  active: BOOLEAN &larr; FALSE;  -- whether the tool is currently active  -- FormSW support routines.  ConfirmCommand: ENTRY FormSW.ProcType =    BEGIN    ENABLE UNWIND =&gt; NULL;    IF NOT toolData.confirming THEN UserTerminal.BlinkDisplay[]    ELSE      BEGIN      toolData.latestConfirm &larr; LOOPHOLE[index, DiagnosticsOps.ConfirmIndex];      NOTIFY confirmation;      END;    END;  ActionCommand: FormSW.ProcType =    BEGIN    IF toolData.confirming OR running THEN      BEGIN      DiagnosticsOps.PutLine["There is already a command running.  Please wait."L];      UserTerminal.BlinkDisplay[];      END    ELSE      BEGIN      SELECT LOOPHOLE[index, FormIndex] FROM        help =&gt; DiagnosticsOps.Help[toolData.test];        start =&gt;          BEGIN  --start--          SELECT toolData.test FROM            display =&gt;              BEGIN  --display--              IF calledByBye THEN ByeOps.StopBouncing[];              DiagnosticsOps.LFDisplayTest[];              UglyHackToGetAroundBugInFormSW[];              IF calledByBye THEN ByeOps.ResumeBouncing[];              END --display-- ;            keyboard =&gt;              BEGIN  --keyboard--              IF calledByBye THEN ByeOps.StopBouncing[];              DiagnosticsOps.KeyboardAndMouseTest[];              UglyHackToGetAroundBugInFormSW[];              IF calledByBye THEN ByeOps.ResumeBouncing[];              END --keyboard-- ;            RS232C =&gt;              BEGIN  --RS232C Loopback              DiagnosticsOps.RS232CLoopBackTest[                host: toolData.strings[thisProcessorID],                hostNet: toolData.strings[thisEthernetID],                lineType: toolData.lineType, lineSpeed: toolData.lineSpeed,                pattern: toolData.pattern, constant: toolData.constant,                minPacketSize: toolData.minPacketSize,                maxPacketSize: toolData.maxPacketSize];              END --RS232C Loopback-- ;            ethernet =&gt;              IF probing THEN                BEGIN                DiagnosticsOps.PutLine["Probing the ethernet.  Please wait."L];                UserTerminal.BlinkDisplay[];                END              ELSE                DiagnosticsOps.EchoUserTest[                  currDomain: toolData.strings[currDomain],                  currOrganization: toolData.strings[currOrganization],                  usernet: toolData.strings[thisEthernetID],                  user: toolData.strings[thisProcessorID],                  targetnet: toolData.strings[testEthernetID],                  target: toolData.strings[testProcessorID],                  realFeedBack: toolData.realFeedBack,                  waitResponse: toolData.waitResponse,                  dataPattern: toolData.dataPattern,                  minPacketSize: toolData.minPacketSize,                  maxPacketSize: toolData.maxPacketSize,                  delayBetween: toolData.delayBetween];            floppy =&gt;              BEGIN  --floppy--              running &larr; TRUE;              SELECT toolData.floppyTest FROM                clean =&gt;                  Process.Detach[FORK DiagnosticsOps.FloppyCleanReadWriteHeads[]];                standard =&gt;                  Process.Detach[FORK DiagnosticsOps.FloppyStandardTest[]];                summary =&gt;                  Process.Detach[FORK DiagnosticsOps.FloppyDisplayErrorLog[]];                format =&gt;                  Process.Detach[FORK DiagnosticsOps.FloppyFormatDiskette[]];                exercise =&gt; Process.Detach[FORK DiagnosticsOps.FloppyExerciser[]];                cmdFile =&gt;                  BEGIN  --cmdFile--                  IF toolData.inALoop THEN                    BEGIN                    CmdAppend["E,"L];                    FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[cmdFile]]];                    END;                  Process.Detach[                    FORK DiagnosticsOps.FloppyCommandFileTest[                    toolData.doubleDensity, toolData.doubleSided,                    toolData.sectorsPerTrack, toolData.sectorLength,                    toolData.errorHandling, toolData.strings[cmdFile]]];                  END --cmdFile-- ;                ENDCASE;              END --floppy-- ;	    two90 =&gt;	      BEGIN  --two90--	      t: DiagnosticsOps.PlotterType &larr; toolData.two90Plotter;	      IF System.switches['g] = down THEN {                SELECT toolData.two90test FROM	          command =&gt;		    Process.Detach[		      FORK DiagnosticsOps.SendCommand[t, toolData.two90Command]];		  output =&gt;		    SELECT toolData.two90Output FROM		      plot =&gt; Process.Detach[FORK DiagnosticsOps.PlotPattern[t]];		      print =&gt;  Process.Detach[		        FORK DiagnosticsOps.PrintPattern[t]];		      screen =&gt; Process.Detach[FORK DiagnosticsOps.PlotScreen[t]];		      ENDCASE =&gt; ERROR;		  ENDCASE =&gt; ERROR} 	      ELSE Msg.FeedBack["290 Not Enabled"L, warning, TRUE];	      END; --two90--            none =&gt; NULL;            ENDCASE;          END --start-- ;        cancel =&gt;          IF probing THEN            BEGIN            DiagnosticsOps.PutLine["Probing the ethernet.  Please wait."L];            UserTerminal.BlinkDisplay[];            END          ELSE [] &larr; ToolWindow.Deactivate[diagnosticwh];        addCommand =&gt;          BEGIN  --addCommand--          temp: LONG STRING = [100];          SELECT toolData.operation FROM            initialize =&gt; CmdAppend["I,"L];            recalibrate =&gt; CmdAppend["RC,"L];            readStatus =&gt; CmdAppend["RAST,"L];            readHeader =&gt;              BEGIN  --readHeader--              String.Copy[temp, "RAH,"L];              IF AppendTrackNumber[temp] THEN                IF toolData.inALoop THEN                  BEGIN IF AppendIncrement[temp] THEN CmdAppend[temp]; END                ELSE CmdAppend[temp];              END --readHeader-- ;            readSectors =&gt;              BEGIN  --readSectors--              String.Copy[temp, "RASE,"L];              IF AppendTrackNumber[temp] THEN                IF AppendStartingSector[temp] THEN                  IF toolData.inALoop THEN                    BEGIN IF AppendIncrement[temp] THEN CmdAppend[temp]; END                  ELSE BEGIN IF AppendSectorCount[temp] THEN CmdAppend[temp]; END;              END --readSectors-- ;            writeSectors, writeDeletedSectors =&gt;              BEGIN  --write--              IF toolData.operation = writeSectors THEN String.Copy[temp, "WS,"L]              ELSE String.Copy[temp, "WD,"L];              IF AppendTrackNumber[temp] THEN                IF AppendStartingSector[temp] THEN                  IF toolData.inALoop THEN                    BEGIN                    IF AppendIncrement[temp] THEN                      IF AppendDataWord[temp] THEN CmdAppend[temp];                    END                  ELSE                    BEGIN                    IF AppendSectorCount[temp] THEN                      IF AppendDataWord[temp] THEN CmdAppend[temp];                    END;              END --write-- ;            verify =&gt; CmdAppend["V,"L];            loop =&gt;              BEGIN  --loop--              IF toolData.inALoop THEN CmdAppend["E,"L]              ELSE                BEGIN                String.Copy[temp, "S,"L];                String.AppendNumber[temp, toolData.loopCount, 10];                String.AppendString[temp, ","L];  --!! Diag2Pack.mesa uses "'", but this works.                CmdAppend[temp];                END;              ToggleInALoop[];              END --loop-- ;            displayData =&gt;              CmdAppend[                SELECT toolData.dataDisplayed FROM                  status =&gt; "DST,"L,                  header =&gt; "DH,"L,                  sector =&gt; "DSE,"L,                  summary =&gt; "DL,"L,                  ENDCASE =&gt; "DST,"L];            clearLog =&gt; CmdAppend["C,"L];            log =&gt; CmdAppend["L,"L];            ENDCASE;          END --addCommand-- ;        deleteCommand =&gt; CmdDelete[];        ENDCASE =&gt; DiagnosticsOps.PutLine["Unknown command - should never happen!?!?"L];      END;    END;  KamikazeProc: UserInput.PeriodicProcType =    BEGIN FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[start]]]; END;  UglyHackToGetAroundBugInFormSW: PROCEDURE =    BEGIN    [] &larr; UserInput.CreatePeriodicNotify[      proc: KamikazeProc, window: Window.rootWindow, rate: 0];    END;  CmdAppend: PROCEDURE [string: LONG STRING] =    BEGIN    IF toolData.cmdCount &lt; cmdMax THEN      BEGIN      String.AppendStringAndGrow[@toolData.strings[cmdFile], string, z];      toolData.cmdCount &larr; toolData.cmdCount + 1;      toolData.cmdIndexes[toolData.cmdCount] &larr; toolData.strings[cmdFile].length;      FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[cmdFile]]];      END;    END;  CmdDelete: PROCEDURE =    BEGIN    IF toolData.cmdCount &gt; 0 THEN      BEGIN      ch: CHARACTER &larr; toolData.strings[cmdFile][        toolData.cmdIndexes[toolData.cmdCount - 1]];      IF ch = 'E OR ch = 'S THEN ToggleInALoop[];      toolData.cmdCount &larr; toolData.cmdCount - 1;      toolData.strings[cmdFile].length &larr; toolData.cmdIndexes[toolData.cmdCount];      FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[cmdFile]]];      END;    END;  AppendTrackNumber: PROCEDURE [cmd: LONG STRING] RETURNS [ok: BOOLEAN] =    BEGIN    IF toolData.trackNumber &gt; 76 THEN      BEGIN      DiagnosticsOps.PutLine["Track number invalid - must be between 0 and  76."L];      ok &larr; FALSE;      END    ELSE      BEGIN      String.AppendNumber[cmd, toolData.trackNumber, 10];      String.AppendString[cmd, ",0,"L];  --!! what is the 0? "keyHead", 0 or 1      ok &larr; TRUE;      END;    END;      AppendStartingSector: PROCEDURE [cmd: LONG STRING] RETURNS [ok: BOOLEAN] =    BEGIN    IF toolData.startingSector &lt; 1      OR toolData.startingSector &gt; toolData.sectorsPerTrack THEN      BEGIN      DiagnosticsOps.PutLine[        "Starting sector invalid - must be between 1 and # of sectors per track."L];      ok &larr; FALSE;      END    ELSE      BEGIN      String.AppendNumber[cmd, toolData.startingSector, 10];      String.AppendString[cmd, ","L];      ok &larr; TRUE;      END;    END;      AppendIncrement: PROCEDURE [cmd: LONG STRING] RETURNS [ok: BOOLEAN] =    BEGIN    IF toolData.increment &lt; -2000 OR toolData.increment &gt; 2000 THEN      BEGIN      DiagnosticsOps.PutLine["Increment invalid - must be between -2000 and 2000."L];      ok &larr; FALSE;      END    ELSE      BEGIN      IF toolData.increment &lt; 0 THEN String.AppendString[cmd, "-"L]      ELSE String.AppendString[cmd, "+"L];      String.AppendNumber[cmd, ABS[toolData.increment], 10];      String.AppendString[cmd, ","L];      ok &larr; TRUE;      END;    END;      AppendSectorCount: PROCEDURE [cmd: LONG STRING] RETURNS [ok: BOOLEAN] =    BEGIN    IF toolData.sectorCount &lt; 1 OR toolData.sectorCount &gt; toolData.sectorsPerTrack      THEN      BEGIN      DiagnosticsOps.PutLine[        "Sector count invalid - must be between 1 and # of sectors per track."L];      ok &larr; FALSE;      END    ELSE      BEGIN      String.AppendNumber[cmd, toolData.sectorCount, 10];      String.AppendString[cmd, ","L];      ok &larr; TRUE;      END;    END;      AppendDataWord: PROCEDURE [cmd: LONG STRING] RETURNS [ok: BOOLEAN] =    BEGIN    String.AppendNumber[cmd, toolData.dataWord, 16];    String.AppendString[cmd, ","L];    ok &larr; TRUE;    END;  ToggleInALoop: PROCEDURE =    BEGIN    toolData.inALoop &larr; NOT toolData.inALoop;    IF toolData.test = floppy AND toolData.floppyTest = cmdFile THEN      OperationNotify[        toolData.formSW, FormSW.FindItem[        toolData.formSW, ORD[FormIndex[operation]]], ORD[FormIndex[operation]],        toolData.operation];    END;  TestNotify: FormSW.EnumeratedNotifyProcType =    BEGIN    SELECT LOOPHOLE[oldValue, DiagnosticsOps.Tests] FROM      RS232C =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[thisEthernetID]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[thisProcessorID]]].flags.invisible &larr;          TRUE;        FormSW.FindItem[sw, ORD[FormIndex[minPacketSize]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[maxPacketSize]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[lineType]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[lineSpeed]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[pattern]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[constant]]].flags.invisible &larr; TRUE;        END;      ethernet =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[currOrganization]]].flags.invisible &larr;          TRUE;        FormSW.FindItem[sw, ORD[FormIndex[currDomain]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[thisEthernetID]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[thisProcessorID]]].flags.invisible &larr;          TRUE;        FormSW.FindItem[sw, ORD[FormIndex[thisProcessorID]]].flags.invisible &larr;          TRUE;        FormSW.FindItem[sw, ORD[FormIndex[listFS]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[listPS]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[listMS]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[testEthernetID]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[testProcessorID]]].flags.invisible &larr;          TRUE;        FormSW.FindItem[sw, ORD[FormIndex[realFeedBack]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[dataPattern]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[minPacketSize]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[maxPacketSize]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[waitResponse]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[delayBetween]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[displayServers]]].flags.invisible &larr; TRUE;        END;      floppy =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[floppyTest]]].flags.invisible &larr; TRUE;        END;      two90 =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[two90TestType]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[two90PlotterType]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[two90Status]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[two90Mode]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[two90command]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[plotprint]]].flags.invisible &larr; TRUE;        END;      none =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[start]]].flags.invisible &larr; FALSE;        END;      ENDCASE;    SELECT toolData.test FROM      RS232C =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[thisEthernetID]]].flags.invisible &larr;          FALSE;        FormSW.FindItem[sw, ORD[FormIndex[thisProcessorID]]].flags.invisible &larr;          FALSE;        FormSW.FindItem[sw, ORD[FormIndex[minPacketSize]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[maxPacketSize]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[lineType]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[lineSpeed]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[pattern]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[constant]]].flags.invisible &larr; FALSE;        END;      ethernet =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[currOrganization]]].flags.invisible &larr;          FALSE;        FormSW.FindItem[sw, ORD[FormIndex[currDomain]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[thisEthernetID]]].flags.invisible &larr;          FALSE;        FormSW.FindItem[sw, ORD[FormIndex[thisProcessorID]]].flags.invisible &larr;          FALSE;        FormSW.FindItem[sw, ORD[FormIndex[listFS]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[listPS]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[listMS]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[testEthernetID]]].flags.invisible &larr;          FALSE;        FormSW.FindItem[sw, ORD[FormIndex[testProcessorID]]].flags.invisible &larr;          FALSE;        FormSW.FindItem[sw, ORD[FormIndex[realFeedBack]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[dataPattern]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[minPacketSize]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[maxPacketSize]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[waitResponse]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[delayBetween]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[displayServers]]].flags.invisible &larr;          FALSE;        END;      floppy =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[floppyTest]]].flags.invisible &larr; FALSE;        END;      two90 =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[two90TestType]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[two90PlotterType]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[two90Status]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[two90Mode]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[two90command]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[plotprint]]].flags.invisible &larr; FALSE;        END;      none =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[start]]].flags.invisible &larr; TRUE;        END;      ENDCASE;    IF LOOPHOLE[oldValue, DiagnosticsOps.Tests] = floppy      AND toolData.floppyTest = cmdFile THEN      BEGIN      toolData.floppyTest &larr; clean;      FloppyTestNotify[        sw, FormSW.FindItem[sw, ORD[FormIndex[floppyTest]]], ORD[        FormIndex[floppyTest]], DiagnosticsOps.FloppyTest[cmdFile]];      END;    IF toolData.reDisplay THEN      BEGIN FormSW.Display[sw]; toolData.reDisplay &larr; FALSE; END;    END;  FloppyTestNotify: FormSW.EnumeratedNotifyProcType =    BEGIN    SELECT LOOPHOLE[oldValue, DiagnosticsOps.FloppyTest] FROM      cmdFile =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[addCommand]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[deleteCommand]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[doubleDensity]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[doubleSided]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[sectorsPerTrack]]].flags.invisible &larr;          TRUE;        FormSW.FindItem[sw, ORD[FormIndex[sectorLength]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[errorHandling]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[operation]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[cmdFile]]].flags.invisible &larr; TRUE;        --SetCurrent[sw, nullIndex];        END;      ENDCASE;    SELECT toolData.floppyTest FROM      cmdFile =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[addCommand]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[deleteCommand]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[doubleDensity]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[doubleSided]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[sectorsPerTrack]]].flags.invisible &larr;          FALSE;        FormSW.FindItem[sw, ORD[FormIndex[sectorLength]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[errorHandling]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[operation]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[cmdFile]]].flags.invisible &larr; FALSE;        END;      ENDCASE;    IF LOOPHOLE[oldValue, DiagnosticsOps.FloppyTest] = cmdFile THEN      BEGIN      oldOperation: DiagnosticsOps.Operation &larr; toolData.operation;      toolData.operation &larr; initialize;      OperationNotify[        sw, FormSW.FindItem[sw, ORD[FormIndex[operation]]], ORD[        FormIndex[operation]], oldOperation];      END;    IF toolData.reDisplay THEN      BEGIN FormSW.Display[sw]; toolData.reDisplay &larr; FALSE; END;    END;  OperationNotify: FormSW.EnumeratedNotifyProcType =    BEGIN    SELECT LOOPHOLE[oldValue, DiagnosticsOps.Operation] FROM      readHeader =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[trackNumber]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[increment]]].flags.invisible &larr; TRUE;        --SetCurrent[sw, nullIndex];        END;      readSectors =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[trackNumber]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[startingSector]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[sectorCount]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[increment]]].flags.invisible &larr; TRUE;        --SetCurrent[sw, nullIndex];        END;      writeSectors, writeDeletedSectors =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[trackNumber]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[startingSector]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[sectorCount]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[dataWord]]].flags.invisible &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[increment]]].flags.invisible &larr; TRUE;        --SetCurrent[sw, nullIndex];        END;      loop =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[loopCount]]].flags.invisible &larr; TRUE;        --SetCurrent[sw, nullIndex];        END;      displayData =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[dataDisplayed]]].flags.invisible &larr; TRUE;        END;      ENDCASE;    SELECT toolData.operation FROM      readHeader =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[trackNumber]]].flags.invisible &larr; FALSE;        IF toolData.inALoop THEN          FormSW.FindItem[sw, ORD[FormIndex[increment]]].flags.invisible &larr; FALSE;        END;      readSectors =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[trackNumber]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[startingSector]]].flags.invisible &larr;          FALSE;        IF toolData.inALoop THEN          FormSW.FindItem[sw, ORD[FormIndex[increment]]].flags.invisible &larr; FALSE        ELSE          FormSW.FindItem[sw, ORD[FormIndex[sectorCount]]].flags.invisible &larr; FALSE;        END;      writeSectors, writeDeletedSectors =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[trackNumber]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[startingSector]]].flags.invisible &larr;          FALSE;        IF toolData.inALoop THEN          FormSW.FindItem[sw, ORD[FormIndex[increment]]].flags.invisible &larr; FALSE        ELSE          FormSW.FindItem[sw, ORD[FormIndex[sectorCount]]].flags.invisible &larr; FALSE;        FormSW.FindItem[sw, ORD[FormIndex[dataWord]]].flags.invisible &larr; FALSE;        END;      loop =&gt;        IF NOT toolData.inALoop THEN          BEGIN          toolData.reDisplay &larr; TRUE;          FormSW.FindItem[sw, ORD[FormIndex[loopCount]]].flags.invisible &larr; FALSE;          END;      displayData =&gt;        BEGIN        toolData.reDisplay &larr; TRUE;        FormSW.FindItem[sw, ORD[FormIndex[dataDisplayed]]].flags.invisible &larr; FALSE;        END;      ENDCASE;    IF toolData.reDisplay THEN      BEGIN FormSW.Display[sw]; toolData.reDisplay &larr; FALSE; END;    END;  -- Setup and support routines.  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =&gt;        BEGIN        IF toolData = NIL THEN toolData &larr; z.NEW[DiagnosticsOps.Data &larr; []];        active &larr; TRUE;        END;      new = inactive =&gt;        BEGIN        IF toolData # NIL THEN          BEGIN          FormSW.Destroy[toolData.formSW];          z.FREE[@toolData.strings[cmdFile]];          z.FREE[@toolData];          END;        IF calledByBye THEN          BEGIN calledByBye &larr; FALSE; ByeOps.ResumeBouncing[]; END;        active &larr; FALSE;        END;      ENDCASE    END;  DiagnosticsActivate: PUBLIC PROCEDURE =    BEGIN    calledByBye &larr; TRUE;    IF diagnosticwh = NIL THEN Init[];    ToolWindow.Activate[diagnosticwh];    Window.Stack[      diagnosticwh, Window.GetChild[Window.GetParent[diagnosticwh]]];  -- top me    Window.ValidateTree[];    END;  Init: PROCEDURE =    BEGIN    -- Make the tool window and its subwindows.    diagnosticwh &larr; Tool.Create[      makeSWsProc: MakeSWs, initialState: inactive,      clientTransition: ClientTransition, name: "Diagnostics"L,      initialBox: [[512, 0], [512, 808]], tinyName1: "Diag"L,      tinyName2: "nostics"L];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    old: Window.Handle;    logName: STRING &larr; [40];    Tool.UnusedLogName[unused: logName, root: "Diagnostics.log"L];    toolData.confirmSW &larr; Tool.MakeFormSW[      window: window, formProc: MakeConfirm, zone: z,      h: 2 * WindowFont.FontHeight[]];  -- should be 1    toolData.formSW &larr; Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: z,      h: 45 * WindowFont.FontHeight[]];    probing &larr; TRUE;    Process.Detach[FORK SetupEthernetItems[]];    toolData.fileSW &larr; Tool.MakeFileSW[      window: window, name: logName, allowTypeIn: FALSE];      -- jfung--    old &larr; Msg.SetWindow[toolData.fileSW]; --   IF old # NIL THEN [] &larr; Msg.SetWindow[old] ELSE oldMsgwh &larr; old;    END;  MakeConfirm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    -- This procedure creates the confirmation FormSW.    formItems:      LONG POINTER TO ARRAY DiagnosticsOps.ConfirmIndex OF FormSW.ItemHandle &larr; NIL;    items &larr; AllocateItemDescriptor[      nItems: DiagnosticsOps.ConfirmIndex.LAST.ORD + 1, z: z];    formItems &larr; LOOPHOLE[BASE[items]];    formItems&uarr; &larr; [      confirm: CommandItem[      tag: "Confirm"L, place: newLine, drawBox: TRUE, invisible: TRUE,      proc: ConfirmCommand],      yes: CommandItem[      tag: "Yes"L, drawBox: TRUE, invisible: TRUE, proc: ConfirmCommand],      no: CommandItem[      tag: "No"L, drawBox: TRUE, invisible: TRUE, proc: ConfirmCommand],      continue: CommandItem[      tag: "Continue"L, drawBox: TRUE, invisible: TRUE, proc: ConfirmCommand],      loop: CommandItem[      tag: "Loop"L, drawBox: TRUE, invisible: TRUE, proc: ConfirmCommand],      display: CommandItem[      tag: "Display"L, drawBox: TRUE, invisible: TRUE, proc: ConfirmCommand],      exit: CommandItem[      tag: "Exit"L, drawBox: TRUE, invisible: TRUE, proc: ConfirmCommand]];    RETURN[items: items, freeDesc: TRUE]    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    -- This procedure creates the main FormSW.    formItems: LONG POINTER TO ARRAY FormIndex OF FormSW.ItemHandle &larr; NIL;    dataPatterns: ARRAY [0..5) OF FormSW.Enumerated &larr; [      ["All 0s"L, CommOnlineDiagnostics.WordsInPacket[all0s]], [      "All 1s"L, CommOnlineDiagnostics.WordsInPacket[all1s]], [      "Incr Words"L, CommOnlineDiagnostics.WordsInPacket[incrWords]], [      "All Constant"L, CommOnlineDiagnostics.WordsInPacket[allConstant]], [      "Dont Care"L, CommOnlineDiagnostics.WordsInPacket[dontCare]]];    lineTypes: ARRAY [0..2) OF FormSW.Enumerated &larr; [      ["bitSynchronous"L, DiagnosticsOps.RS232LineType[bitSynchronous]], [      "asynchronous"L, DiagnosticsOps.RS232LineType[asynchronous]]];    lineSpeeds: ARRAY [0..4) OF FormSW.Enumerated &larr; [[      "1200"L, RS232CEnvironment.LineSpeed[bps1200]], [      "2400"L, RS232CEnvironment.LineSpeed[bps2400]], [      "4800"L, RS232CEnvironment.LineSpeed[bps4800]], [      "9600"L, RS232CEnvironment.LineSpeed[bps9600]]];    patterns: ARRAY [0..4) OF FormSW.Enumerated &larr; [      ["All 0s"L, CommOnlineDiagnostics.PatternType[zero]], [      "All 1s"L, CommOnlineDiagnostics.PatternType[ones]], [      "Incrementing"L, CommOnlineDiagnostics.PatternType[byteIncr]], [      "Constant"L, CommOnlineDiagnostics.PatternType[constant]]];          testtwo90: ARRAY [0..2) OF FormSW.Enumerated &larr; [      ["Command"L, DiagnosticsOps.Two90Test[command]],      ["Output"L, DiagnosticsOps.Two90Test[output]]];          plottertwo90: ARRAY [0..7) OF FormSW.Enumerated &larr; [      ["v80"L, DiagnosticsOps.PlotterType[v80]],      ["v8222"L, DiagnosticsOps.PlotterType[v8222]],      ["v8224"L, DiagnosticsOps.PlotterType[v8224]],      ["v8236"L, DiagnosticsOps.PlotterType[v8236]],      ["v8242"L, DiagnosticsOps.PlotterType[v8242]],      ["v8272"L, DiagnosticsOps.PlotterType[v8272]],      ["pdq"L, DiagnosticsOps.PlotterType[pdq]]];          statustwo90: ARRAY [0..11) OF FormSW.Enumerated &larr; [      ["null"L, GreenFace.Status[null]],      ["inplot"L, GreenFace.Status[inplot]],      ["inprint"L, GreenFace.Status[inprint]],      ["overrun"L, GreenFace.Status[overrun]],      ["unrecognized"L, GreenFace.Status[unrecognized]],      ["illegalsequence"L, GreenFace.Status[illegalsequence]],      ["parityerror"L, GreenFace.Status[parityerror]],      ["framingerror"L, GreenFace.Status[framingerror]],      ["busyinprogress"L, GreenFace.Status[busyinprogress]],      ["offline"L, GreenFace.Status[offline]],      ["plotterready"L, GreenFace.Status[plotterready]]];          modetwo90: ARRAY [0..2) OF FormSW.Enumerated &larr; [      ["Plot", DiagnosticsOps.Two90Mode[plot]],       ["Print", DiagnosticsOps.Two90Mode[print]]];          commandtwo90: ARRAY [0..11) OF FormSW.Enumerated &larr; [      ["null"L, GreenFace.Command[null]],      ["plot"L, GreenFace.Command[plot]],      ["print"L, GreenFace.Command[print]],      ["clear"L, GreenFace.Command[clear]],      ["rlter"L, GreenFace.Command[rlter]],      ["rffed"L, GreenFace.Command[rffed]],      ["reotr"L, GreenFace.Command[reotr]],      ["receivebyte"L, GreenFace.Command[receivebyte]],      ["senseplot"L, GreenFace.Command[senseplot]],      ["sensestatus"L, GreenFace.Command[sensestatus]],      ["reset"L, GreenFace.Command[reset]]];          outputtwo90: ARRAY [0..3) OF FormSW.Enumerated &larr; [      ["plot"L, DiagnosticsOps.Two90Pattern[plot]],      ["print"L, DiagnosticsOps.Two90Pattern[print]],      ["screen"L, DiagnosticsOps.Two90Pattern[screen]]];    EnumSeq: TYPE = RECORD [seq: SEQUENCE n: CARDINAL OF FormSW.Enumerated];    testSeq: LONG POINTER TO EnumSeq &larr; z.NEW[EnumSeq [7]];    floppyTestSeq: LONG POINTER TO EnumSeq &larr; z.NEW[EnumSeq [6]];    sectorLengthSeq: LONG POINTER TO EnumSeq &larr; z.NEW[EnumSeq [4]];    errorHandlingSeq: LONG POINTER TO EnumSeq &larr; z.NEW[EnumSeq [3]];    operationSeq: LONG POINTER TO EnumSeq &larr; z.NEW[EnumSeq [12]];    dataDisplayedSeq: LONG POINTER TO EnumSeq &larr; z.NEW[EnumSeq [4]];    testSeq[0] &larr; ["Display"L, DiagnosticsOps.Tests[display]];    testSeq[1] &larr; ["Keyboard"L, DiagnosticsOps.Tests[keyboard]];    testSeq[2] &larr; ["Echo"L, DiagnosticsOps.Tests[ethernet]];    testSeq[3] &larr; ["RS232C Loopback"L, DiagnosticsOps.Tests[RS232C]];    testSeq[4] &larr; ["Floppy Drive"L, DiagnosticsOps.Tests[floppy]];    testSeq[5] &larr; ["290 Interface"L, DiagnosticsOps.Tests[two90]];    testSeq[6] &larr; ["None"L, DiagnosticsOps.Tests[none]];    floppyTestSeq[0] &larr; ["Clean Heads"L, DiagnosticsOps.FloppyTest[clean]];    floppyTestSeq[1] &larr; ["Standard"L, DiagnosticsOps.FloppyTest[standard]];    floppyTestSeq[2] &larr; ["Summary"L, DiagnosticsOps.FloppyTest[summary]];    floppyTestSeq[3] &larr; ["Format"L, DiagnosticsOps.FloppyTest[format]];    floppyTestSeq[4] &larr; ["Exerciser"L, DiagnosticsOps.FloppyTest[exercise]];    floppyTestSeq[5] &larr; ["Command File"L, DiagnosticsOps.FloppyTest[cmdFile]];    sectorLengthSeq[0] &larr; ["128 bytes"L, OnlineDiagnostics.SectorLength[one28]];    sectorLengthSeq[1] &larr; ["256 bytes"L, OnlineDiagnostics.SectorLength[two56]];    sectorLengthSeq[2] &larr; ["512 bytes"L, OnlineDiagnostics.SectorLength[five12]];    sectorLengthSeq[3] &larr; ["1024 bytes"L, OnlineDiagnostics.SectorLength[one024]];    errorHandlingSeq[0] &larr; [      "No Error Checking"L, OnlineDiagnostics.ErrorHandling[noChecking]];    errorHandlingSeq[1] &larr; [      "Stop on Errors"L, OnlineDiagnostics.ErrorHandling[stopOnError]];    errorHandlingSeq[2] &larr; [      "Loop on Errors"L, OnlineDiagnostics.ErrorHandling[loopOnError]];    operationSeq[0] &larr; ["Initialize floppy drive"L, DiagnosticsOps.Operation[initialize]];    operationSeq[1] &larr; ["Recalibrate"L, DiagnosticsOps.Operation[recalibrate]];    operationSeq[2] &larr; ["Read Status"L, DiagnosticsOps.Operation[readStatus]];    operationSeq[3] &larr; ["Read Header"L, DiagnosticsOps.Operation[readHeader]];    operationSeq[4] &larr; ["Read Sectors"L, DiagnosticsOps.Operation[readSectors]];    operationSeq[5] &larr; ["Write Sectors"L, DiagnosticsOps.Operation[writeSectors]];    operationSeq[6] &larr; ["Write Deleted Sectors"L, DiagnosticsOps.Operation[writeDeletedSectors]];    operationSeq[7] &larr; ["Verify"L, DiagnosticsOps.Operation[verify]];    operationSeq[8] &larr; ["Start/Stop Loop"L, DiagnosticsOps.Operation[loop]];    operationSeq[9] &larr; ["Display Data"L, DiagnosticsOps.Operation[displayData]];    operationSeq[10] &larr; ["Clear Status Log"L, DiagnosticsOps.Operation[clearLog]];    operationSeq[11] &larr; ["Log Status"L, DiagnosticsOps.Operation[log]];    toolData.cmdCount &larr; 0;    toolData.cmdIndexes[toolData.cmdCount] &larr; 0;    toolData.inALoop &larr; FALSE;    dataDisplayedSeq[0] &larr; ["Status"L, DiagnosticsOps.DataDisplayed[status]];    dataDisplayedSeq[1] &larr; ["Header"L, DiagnosticsOps.DataDisplayed[header]];    dataDisplayedSeq[2] &larr; ["Sector"L, DiagnosticsOps.DataDisplayed[sector]];    dataDisplayedSeq[3] &larr; ["Summary Log"L, DiagnosticsOps.DataDisplayed[summary]];    items &larr; AllocateItemDescriptor[nItems: FormIndex.LAST.ORD + 1, z: z];    formItems &larr; LOOPHOLE[BASE[items]];    formItems&uarr; &larr; [      help: CommandItem[      tag: "Help"L, place: newLine, drawBox: TRUE, invisible: FALSE,      proc: ActionCommand],      start: CommandItem[      tag: "Start"L, drawBox: TRUE, invisible: TRUE, proc: ActionCommand],      cancel: CommandItem[      tag: "Cancel"L, drawBox: TRUE, invisible: FALSE, proc: ActionCommand],      addCommand: CommandItem[      tag: "Add Command to file"L, drawBox: TRUE, invisible: TRUE,      proc: ActionCommand],      deleteCommand: CommandItem[      tag: "Delete Previous Command"L, drawBox: TRUE, invisible: TRUE,      proc: ActionCommand],      test: EnumeratedItem[      tag: "Test"L, place: newLine, invisible: FALSE,       feedback: all, value: @toolData.test, copyChoices: TRUE,       choices: DESCRIPTOR[testSeq&uarr;], proc: TestNotify],      floppyTest: EnumeratedItem[      tag: "Type of test"L, place: newLine, invisible: TRUE, feedback: all,      value: @toolData.floppyTest, copyChoices: TRUE,      choices: DESCRIPTOR[floppyTestSeq&uarr;], proc: FloppyTestNotify],      currOrganization: StringItem[      tag: "Current Organization"L, place: newLine, invisible: TRUE,      readOnly: TRUE, inHeap: TRUE, string: @toolData.strings[currOrganization]],      currDomain: StringItem[      tag: "Current Domain"L, place: newLine, invisible: TRUE, readOnly: TRUE,      inHeap: TRUE, string: @toolData.strings[currDomain]],      thisEthernetID: StringItem[      tag: "Source Ethernet ID"L, place: newLine, invisible: TRUE,      inHeap: TRUE, string: @toolData.strings[thisEthernetID]],      thisProcessorID: StringItem[      tag: "Source Processor ID number"L, place: newLine, invisible: TRUE,      inHeap: TRUE, string: @toolData.strings[thisProcessorID]],      listFS: StringItem[      tag: "FS"L, place: newLine, invisible: TRUE, readOnly: TRUE, inHeap: TRUE,      string: @toolData.strings[listFS]],      listPS: StringItem[      tag: "PS"L, place: newLine, invisible: TRUE, readOnly: TRUE, inHeap: TRUE,      string: @toolData.strings[listPS]],      listMS: StringItem[      tag: "MS"L, place: newLine, invisible: TRUE, readOnly: TRUE, inHeap: TRUE,      string: @toolData.strings[listMS]],      testEthernetID: StringItem[      tag: "Destination Ethernet ID number"L, place: newLine,       invisible: TRUE, inHeap: TRUE, string: @toolData.strings[testEthernetID]],      testProcessorID: StringItem[      tag: "Destination Processor ID number"L, place: newLine,      invisible: TRUE, inHeap: TRUE, string: @toolData.strings[testProcessorID]],      realFeedBack: BooleanItem[      tag: "Display Real Time Feedback"L, place: newLine, invisible: TRUE,      drawBox: TRUE, switch: @toolData.realFeedBack],      dataPattern: EnumeratedItem[      tag: "Set Data Pattern"L, place: newLine, invisible: TRUE, feedback: all,      value: @toolData.dataPattern, copyChoices: TRUE,      choices: DESCRIPTOR[dataPatterns]],      minPacketSize: NumberItem[      tag: "Minimum Packet Size(2-512 bytes)"L, place: newLine, invisible: TRUE,      value: @toolData.minPacketSize, notNegative: TRUE, signed: FALSE],      maxPacketSize: NumberItem[      tag: "Maximum Packet Size(2-512 bytes)"L, place: newLine, invisible: TRUE,      value: @toolData.maxPacketSize, notNegative: TRUE, signed: FALSE],      waitResponse: BooleanItem[      tag: "Wait for response before sending packet"L, place: newLine,      invisible: TRUE, drawBox: TRUE, switch: @toolData.waitResponse],      delayBetween: NumberItem[      tag: "Delay between packets (milliseconds)"L, place: newLine,      invisible: TRUE, value: @toolData.delayBetween, notNegative: TRUE,      signed: FALSE],      displayServers: BooleanItem[      tag: "Display Server List"L, place: newLine, invisible: TRUE, drawBox: TRUE,      switch: @toolData.displayServers],      lineType: EnumeratedItem[      tag: "Mode"L, place: newLine, invisible: TRUE, feedback: all,      value: @toolData.lineType, copyChoices: TRUE,      choices: DESCRIPTOR[lineTypes]],      lineSpeed: EnumeratedItem[      tag: "Data Rate (bps)"L, place: newLine, invisible: TRUE, feedback: all,      value: @toolData.lineSpeed, copyChoices: TRUE,      choices: DESCRIPTOR[lineSpeeds]],      pattern: EnumeratedItem[      tag: "Set Data Pattern"L, place: newLine, invisible: TRUE, feedback: all,      value: @toolData.pattern, copyChoices: TRUE, choices: DESCRIPTOR[patterns]],      constant: NumberItem[      tag: "Pattern:"L, invisible: TRUE, value: @toolData.constant,      notNegative: TRUE, signed: FALSE],      doubleDensity: BooleanItem[      tag: "Double Density"L, place: newLine, invisible: TRUE,      switch: @toolData.doubleDensity],      doubleSided: BooleanItem[      tag: "Double Sided"L, invisible: TRUE, switch: @toolData.doubleSided],      sectorsPerTrack: NumberItem[      tag: "Sectors per Track"L, invisible: TRUE, value:      @toolData.sectorsPerTrack, notNegative: TRUE, signed: FALSE],      sectorLength: EnumeratedItem[      tag: "Sector Length"L, place: newLine, invisible: TRUE, feedback: all,      value: @toolData.sectorLength, copyChoices: TRUE,      choices: DESCRIPTOR[sectorLengthSeq&uarr;]],      errorHandling: EnumeratedItem[      tag: "Error Handling"L, place: newLine, invisible: TRUE, feedback: all,      value: @toolData.errorHandling, copyChoices: TRUE,      choices: DESCRIPTOR[errorHandlingSeq&uarr;]],      operation: EnumeratedItem[      tag: "Command File Operation"L, place: newLine, invisible: TRUE,      feedback: one, value: @toolData.operation, copyChoices: TRUE,      choices: DESCRIPTOR[operationSeq&uarr;], proc: OperationNotify],      cmdFile: StringItem[      tag: "Commands"L, place: newLine, invisible: TRUE, readOnly: TRUE,      inHeap: TRUE, string: @toolData.strings[cmdFile]],      trackNumber: NumberItem[      tag: "Track number"L, place: newLine, invisible: TRUE,      value: @toolData.trackNumber, notNegative: TRUE, signed: FALSE],      startingSector: NumberItem[      tag: "Starting Sector"L, place: newLine, invisible: TRUE,      value: @toolData.startingSector, notNegative: TRUE, signed: FALSE],      sectorCount: NumberItem[      tag: "Sector Count"L, place: newLine, invisible: TRUE,      value: @toolData.sectorCount, notNegative: TRUE, signed: FALSE],      increment: NumberItem[      tag: "Increment (+ or -) by"L, place: newLine, invisible: TRUE,      value: @toolData.increment, notNegative: FALSE, signed: TRUE],      dataWord: NumberItem[      tag: "Data Word"L, place: newLine, invisible: TRUE,      value: @toolData.dataWord, radix: octal, notNegative: TRUE, signed: FALSE],      loopCount: NumberItem[      tag: "Loop Count"L, place: newLine, invisible: TRUE,      value: @toolData.loopCount, notNegative: TRUE, signed: FALSE],      dataDisplayed: EnumeratedItem[      tag: "Data to Be Displayed"L, place: newLine, invisible: TRUE,       feedback: all, value: @toolData.dataDisplayed, copyChoices: TRUE,      choices: DESCRIPTOR[dataDisplayedSeq&uarr;]],      two90TestType: EnumeratedItem[      tag: "Type of test"L, place: newLine, invisible: TRUE,       feedback: all, value: @toolData.two90test, copyChoices: TRUE,      choices: DESCRIPTOR[testtwo90]],      two90PlotterType: EnumeratedItem[      tag: "Plotter Type"L, place: newLine, invisible: TRUE,       feedback: all, value: @toolData.two90Plotter, copyChoices: TRUE,      choices: DESCRIPTOR[plottertwo90]],      two90Status: EnumeratedItem[      tag: "Plotter Status"L, place: newLine, invisible: TRUE,       feedback: all, value: @toolData.two90Status, copyChoices: TRUE,      choices: DESCRIPTOR[statustwo90]],      two90Mode: EnumeratedItem[      tag: "Plotter Mode"L, place: newLine, invisible: TRUE,       feedback: all, value: @toolData.two90Mode, copyChoices: TRUE,      choices: DESCRIPTOR[modetwo90]],      two90command: EnumeratedItem[      tag: "Command To Send"L, place: newLine, invisible: TRUE,       feedback: all, value: @toolData.two90Command, copyChoices: TRUE,      choices: DESCRIPTOR[commandtwo90]],      plotprint: EnumeratedItem[      tag: "Print/Plot Output test"L, place: newLine, invisible: TRUE,       feedback: all, value: @toolData.two90Output, copyChoices: TRUE,      choices: DESCRIPTOR[outputtwo90]]];    z.FREE[@testSeq];    z.FREE[@floppyTestSeq];    z.FREE[@sectorLengthSeq];    z.FREE[@errorHandlingSeq];    z.FREE[@operationSeq];    z.FREE[@dataDisplayedSeq];    RETURN[items: items, freeDesc: TRUE]    END;  SetupEthernetItems: PROCEDURE =    BEGIN  --SetupEthernetItems--    thisNetworkAddress: System.NetworkAddress;    -- Get the current domain and organization.    Profile.GetDefaultOrganization[GetCurrOrganization];    FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[currOrganization]]];    Profile.GetDefaultDomain[GetCurrDomain];    FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[currDomain]]];    -- Get the current network and host number.    thisNetworkAddress &larr; NetworkStream.AssignNetworkAddress[];    Format.NetworkNumber[      GetThisEthernetID, thisNetworkAddress.net, productSoftware];    FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[thisEthernetID]]];    Format.HostNumber[      GetThisProcessorID, thisNetworkAddress.host, productSoftware];    FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[thisProcessorID]]];    -- List the file servers, print servers, and mail servers.    IF toolData.displayServers THEN {      DiagnosticsOps.AppendServers[DESCRIPTOR[toolData.strings], z];      FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[listFS]]];      FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[listPS]]];      FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[listMS]]]};    GetClearingHouse[];    FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[testEthernetID]]];    FormSW.DisplayItem[toolData.formSW, ORD[FormIndex[testProcessorID]]];    probing &larr; FALSE;    END --SetupEthernetItems-- ;  GetCurrOrganization: PROCEDURE [s: Profile.String] =    BEGIN toolData.strings[currOrganization] &larr; String.CopyToNewString[s, z]; END;  GetCurrDomain: PROCEDURE [s: Profile.String] =    BEGIN toolData.strings[currDomain] &larr; String.CopyToNewString[s, z]; END;  GetThisEthernetID: Format.StringProc =    BEGIN toolData.strings[thisEthernetID] &larr; String.CopyToNewString[s, z]; END;  GetThisProcessorID: Format.StringProc =    BEGIN toolData.strings[thisProcessorID] &larr; String.CopyToNewString[s, z]; END;  GetTestEthernetID: Format.StringProc =    BEGIN toolData.strings[testEthernetID] &larr; String.CopyToNewString[s, z]; END;  GetTestProcessorID: Format.StringProc =    BEGIN toolData.strings[testProcessorID] &larr; String.CopyToNewString[s, z]; END;  GetClearingHouse: PROCEDURE =    BEGIN  --GetClearingHouse--    CHAddr: System.NetworkAddress &larr; CHStubInternal.FindDomainAddr[      CH.zeroMaxLengthNames];    Format.NetworkNumber[GetTestEthernetID, CHAddr.net, productSoftware];    Format.HostNumber[GetTestProcessorID, CHAddr.host, productSoftware];    END --GetClearingHouse-- ;  -- Mainline code.  Init[];  END...  </pre>
  </body>
</html>
