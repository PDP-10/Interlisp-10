<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>SystemTools>LTFloppyImpl.mesa!2</title>
  </head>
  <body>
    <pre>
-- LTFloppyImpl.mesa-- Created by--   JFung.pasa	  	14-Dec-83 12:37:04-- last edited by--   JFung.pasa	   	24-Sep-84 10:27:36DIRECTORY     AccessFloppy,     AccessFloppyUtil,     Ascii,     Environment,     Exec,     File,     FileName,     FileTypes USING [tUntypedFile],     Floppy,     Format,     FormSW,     Heap USING [systemZone],     Inline,     LispToolOps,     MFile,     MStream,     NSString,     OthelloDefs,     OthelloOps,     Process USING [Pause, SecondsToTicks],     Put,     Runtime,     Space,     SpecialMFile USING [GetCapaWithAccess, LeaderPages],     Storage,     Stream,     String,     StringLookUp,     Time,     Tool USING [          Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,          UnusedLogName],     ToolDriver,     ToolWindow,     Token,     UserInput,     Version,     Volume,     Window;LTFloppyImpl: PROGRAM     IMPORTS          AccessFloppy, File, FileName, Floppy, FormSW, Heap, Inline, LispToolOps,          MFile, NSString, OthelloOps, Process, Put, SpecialMFile, Storage, String,          Volume, Time, Tool, ToolDriver, Token, UserInput     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;     -- constant     nullNextFile: NextFile = [];     -- TYPEs     Indicator: TYPE = {off, left, right};     DataHandle: TYPE = LONG POINTER TO Data;     Data: TYPE = MACHINE DEPENDENT RECORD [          -- Message subwindow stuff          msgSW(0): Window.Handle &larr; NIL,          -- File subwindow stuff          fileSW(2): Window.Handle &larr; NIL,          -- Form subwindow stuff          -- Note: enumerateds and booleans must be word boundary          -- aligned as addresses for them must be generated          --formSW: Window.Handle &larr; NIL,          paramSW(4): Window.Handle &larr; NIL,          commandSW(6): Window.Handle &larr; NIL,          busy(8): BOOLEAN &larr; FALSE,  -- command is running          volName(9): LONG STRING &larr; NIL,          pattern(11): LONG STRING &larr; NIL,          indicator(13): Indicator &larr; left,          floppyName(14): LONG STRING &larr; NIL,          stream(16): MStream.Handle &larr; NIL,          from(18): LONG STRING &larr; NIL,          to(20): LONG STRING &larr; NIL,          numberOfFiles(22): INTEGER &larr; 0,          current(23): LptNextFile &larr; NIL,          fileList(25): LptNextFile &larr; NIL];     EnumProc: TYPE = PROCEDURE [          attributes: AccessFloppy.Attributes, fH: Floppy.FileHandle,          name: LONG STRING] RETURNS [stop: BOOLEAN &larr; FALSE];     LptNextFile: TYPE = LONG POINTER TO NextFile;     NextFile: TYPE = RECORD [          file: LONG STRING &larr; NIL,          size: LONG CARDINAL &larr; 0,  -- file size including leader page if it has one.          type: File.Type &larr; AccessFloppy.tFloppyLeaderPage,  -- specify whether it has leader page.          next: LptNextFile &larr; NIL];     VolHints: TYPE = RECORD [names: SEQUENCE length: CARDINAL OF LONG STRING];     SizeHints: TYPE = RECORD [names: SEQUENCE length: CARDINAL OF CARDINAL];     -- global variables     Abort: ERROR [s: STRING] = CODE;     active: BOOLEAN &larr; FALSE;     atSource: PUBLIC CARDINAL &larr; 0;     attributes: AccessFloppy.Attributes &larr; NIL;     bufferSize: Space.PageCount &larr; 30;     dataVersion: CARDINAL = 02222;  -- version of clientData     debug: BOOLEAN &larr; FALSE;     floppyWH: Window.Handle &larr; NIL;     formDisplay: ToolWindow.DisplayProcType &larr; NIL;     heraldName: STRING &larr; [50];     indicatorBox: Window.Box = [[10, 10], [16, 16]];     nullFile: Floppy.FileHandle;     opened: BOOLEAN &larr; FALSE;     --spaceHandle: Space.Handle &larr; Space.nullHandle;     toolData: DataHandle &larr; NIL;     vH: Floppy.VolumeHandle &larr; Floppy.nullVolumeHandle;     volumeID: Volume.ID &larr; Volume.nullID;     volumeOpen: BOOLEAN &larr; FALSE;     z: UNCOUNTED ZONE = Heap.systemZone;     SetOutcome: SIGNAL [value: Exec.Outcome] = CODE;     CleanUp: PROC =          BEGIN          current: LptNextFile &larr; toolData.fileList;          releaseData: MFile.ReleaseData &larr; [NIL, NIL];          WHILE current&uarr; # nullNextFile DO               file: MFile.Handle &larr; NIL;               scratchName: LONG STRING &larr; [120];               String.AppendString[scratchName, current.file];               String.AppendString[scratchName, ".Scratch$"L];               toolData.current &larr; current.next;               file &larr; MFile.Acquire[                    scratchName, MFile.Access[delete], releaseData];               MFile.Delete[file];               --current.file &larr; Storage.FreeStringNil[current.file];               Storage.Free[current];               current &larr; toolData.current;               ENDLOOP;          toolData.fileList &larr; toolData.current &larr; Storage.FreeNodeNil[               toolData.current];          toolData.from &larr; Storage.FreeStringNil[toolData.from];          toolData.to &larr; Storage.FreeStringNil[toolData.to];          END;  -- CleanUp.     &lt;&lt;     CopyCmd: PROCEDURE =          BEGIN          END;       -- from AccessFloppyUtil     CreateBuffer: PUBLIC PROC [size: Space.PageCount]          RETURNS [spH: Space.Handle, spSize: Space.PageCount] =          BEGIN          END;  -- CreateBuffer.     DeleteBuffer: PUBLIC PROC [spH: Space.Handle] =          BEGIN 	  END;  -- DeleteBuffer.     DiskToFloppy: PROC =          BEGIN          END;  -- DiskToFloppy.&gt;&gt;     DisplayFloppyName: PROCEDURE [] =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "DisplayFile...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          FormSW.DisplayItem[toolData.paramSW, 3];          END;  --DisplayFloppyName     EnumerateFloppyFiles: PROCEDURE [          v: Floppy.VolumeHandle, proc: EnumProc, pattern: LONG STRING] =          BEGIN          nullFile: Floppy.FileHandle = [volume: v, file: Floppy.nullFileID];          attributes: AccessFloppy.Attributes &larr; Heap.systemZone.NEW[               AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];          name: LONG STRING = LOOPHOLE[@attributes.length];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "EnumerateFloppyFiles...."L];               --Process.Pause[Process.SecondsToTicks[5]];               };          FOR current: Floppy.FileHandle &larr; Floppy.GetNextFile[nullFile].nextFile,               Floppy.GetNextFile[current].nextFile WHILE current # nullFile DO               ENABLE UNWIND =&gt; Heap.systemZone.FREE[@attributes];               IF Floppy.GetFileAttributes[current].type #                    AccessFloppy.tFloppyLeaderPage THEN LOOP;               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "Floppy.GetNextFile"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    Put.Text[ILT.toolData.fileSW, "Pattern = "L];                    Put.Line[ILT.toolData.fileSW, pattern];                    };               AccessFloppy.GetAttributes[current, attributes];               IF                    --(pattern = NIL                    --OR Exec.MatchPattern[string: name, pattern: pattern]) OR                     proc[attributes, current, name] THEN {                    Put.Line[ILT.toolData.fileSW, "Exited loop."L]; EXIT; };               ENDLOOP;          Heap.systemZone.FREE[@attributes];          END;  --EnumerateFloppyFiles     FileLookUp: PROC [nsName: NSString.String]          RETURNS [fFile: Floppy.FileHandle, continue: BOOLEAN] =          BEGIN          continue &larr; TRUE;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FileLookUp"L];               --Put.Text[ILT.toolData.msgSW, nsName];               --Process.Pause[Process.SecondsToTicks[5]];               };          fFile &larr; AccessFloppy.LookUp[               nsName, attributes !               AccessFloppy.Error =&gt; {                    continue &larr; FALSE;                    Put.Line[ILT.toolData.fileSW, "Floppy Error"L];                    SELECT type FROM                         attributesNotAllowed =&gt; {                              Put.Line[                                   ILT.toolData.msgSW, "attributesNotAllowed"L];                              };                         fileNotFound =&gt; {                              --Put.Text[ILT.toolData.msgSW, name];                              Put.Line[ILT.toolData.msgSW, "File name not found"L];                              };                         invalidParameter =&gt; {                              Put.Line[ILT.toolData.msgSW, "invalidParameter"L]; };                         nameInUse =&gt; {                              Put.Line[ILT.toolData.msgSW, "nameInUse"L]; };                         volumeNotOpen =&gt; {                              Put.Line[ILT.toolData.msgSW, "volumeNotOpen"L]; };                         ENDCASE =&gt; Put.Line[ILT.toolData.msgSW, "others"L];                    IF debug THEN Process.Pause[Process.SecondsToTicks[10]];                    }];          RETURN[fFile, continue];          END;  --FileLookUp     FixDirectory: PUBLIC PROC [dir: LONG POINTER TO LONG STRING] =          BEGIN          IF dir&uarr; = NIL THEN RETURN;          SELECT dir[dir.length - 1] FROM '&gt;, '# =&gt; RETURN; ENDCASE;          String.AppendCharAndGrow[dir, '&gt;, z];          END;  --FixDirectory     FloppyDelete: PUBLIC PROCEDURE [pattern: LONG STRING]          RETURNS [deleted: BOOLEAN] =          BEGIN          name: LONG STRING &larr; NIL;          vH: Floppy.VolumeHandle;          DeleteOne: EnumProc =               BEGIN               deleted &larr; TRUE;               Put.Text[ILT.toolData.msgSW, name];               Put.Text[ILT.toolData.msgSW, "... "L];               AccessFloppy.DeleteFile[                    NSString.StringFromMesaString[name] !                    AccessFloppy.Error =&gt;                         SELECT type FROM                              fileNotFound =&gt; {                                   Put.Line[ILT.toolData.msgSW, "not found"L];                                   IF debug THEN                                        Process.Pause[Process.SecondsToTicks[5]];                                   GOTO error;                                   };                              ENDCASE];               Put.Line[ILT.toolData.msgSW, "deleted"L];               IF debug THEN Process.Pause[Process.SecondsToTicks[10]];               RETURN[];               EXITS error =&gt; {deleted &larr; FALSE; RETURN[]; };               END;  --DeleteOne          [vH] &larr; OpenFloppy[];          IF ~opened THEN RETURN;          BEGIN          ENABLE UNWIND =&gt; {AccessFloppy.Close[ ! Floppy.Error =&gt; CONTINUE]};          --name &larr; toolData.pattern;          --IF toolData.pattern = NIL THEN EXIT;          IF WildCards[pattern] THEN EnumerateFloppyFiles[vH, DeleteOne, pattern]          ELSE [] &larr; DeleteOne[NIL, [vH, Floppy.nullFileID], pattern];          END;          IF debug THEN {               Put.Text[ILT.toolData.fileSW, "AccessFloppy.Close"L];               Process.Pause[Process.SecondsToTicks[5]];               };          AccessFloppy.Close[];          END;  --FloppyDelete     FloppyDuplicate: PUBLIC PROCEDURE = BEGIN END;     FloppyFormat: PROCEDURE [          nFiles: CARDINAL, label: LONG STRING, sides: Floppy.Sides,          density: Floppy.Density] RETURNS [gotError: BOOLEAN] =          BEGIN          gotError: BOOLEAN &larr; FALSE;          BEGIN          v: Floppy.VolumeHandle;          v &larr; AccessFloppy.Open[               !               Floppy.Error =&gt;                    SELECT error FROM                         invalidFormat =&gt; GOTO virgin;                         needsScavenging =&gt; {gotError &larr; TRUE; CONTINUE};                         ENDCASE =&gt; gotError &larr; TRUE; ];          IF ~gotError THEN {               [] &larr; Floppy.GetAttributes[v, label];               Floppy.Close[v];               Put.Text[ILT.toolData.fileSW, "Floppy volume """L];               Put.Text[ILT.toolData.fileSW, label];               Put.Line[ILT.toolData.fileSW, """ already formatted"L];               }          ELSE               Put.Line[                    toolData.fileSW,                    "Floppy probably contains valid information"L];          EXITS virgin =&gt; NULL;          END;          Put.Line[               toolData.fileSW,               "Formatting will DESTROY all contents, confirm to continue"L];          IF ~ILT.Confirm[] THEN RETURN;          --label.length &larr; 0;          IF label = NIL THEN {               Put.Line[toolData.fileSW, "Please supply floppy name"];               Process.Pause[Process.SecondsToTicks[5]];               RETURN;               };          &lt;&lt;	  IF label # NIL THEN  	  	toolData.floppyName &larr; String.CopyToNewString[                    s: label, z: Heap.systemZone]          ELSE toolData.floppyName &larr; String.CopyToNewString[                    s: "UnnamedFloppy"L, z: Heap.systemZone];&gt;&gt;          IF label # NIL OR toolData.floppyName # NIL THEN {               Put.Text[toolData.fileSW, "label # Nil:"L];               Put.Text[toolData.fileSW, label];               Put.Line[toolData.fileSW, "&lt;"L];               Process.Pause[Process.SecondsToTicks[5]];               toolData.floppyName &larr; label;               Put.Text[toolData.fileSW, "floppyName:"L];               Put.Text[toolData.fileSW, toolData.floppyName];               Put.Line[toolData.fileSW, "&lt;"L];               Process.Pause[Process.SecondsToTicks[5]];               toolData.floppyName &larr; String.CopyToNewString[                    s: label, z: Heap.systemZone];               Put.Text[toolData.fileSW, "floppyName:"L];               Put.Text[toolData.fileSW, toolData.floppyName];               Put.Line[toolData.fileSW, "&lt;"L];               };          IF debug THEN {               Put.Line[ILT.toolData.fileSW, toolData.floppyName];               Process.Pause[Process.SecondsToTicks[5]];               };          IF ~ILT.Confirm[] THEN RETURN;  --temp          Put.Text[toolData.fileSW, "Formatting... "L];          Floppy.Format[               0, nFiles, toolData.floppyName, density, sides !               Floppy.Error =&gt;                    SELECT error FROM                         onlyOneSide =&gt; {sides &larr; one; RETRY};                         onlySingleDensity =&gt; {density &larr; single; RETRY};                         badDisk =&gt; {                              Put.Line[                                   toolData.fileSW,                                   "Can't format this disk; may be write protecte"L];                              gotError &larr; TRUE;                              Process.Pause[Process.SecondsToTicks[5]];                              GOTO noGood;                              };                         ENDCASE;               -- ERROR Abort["Can't format this disk; may be write protected"L];               Floppy.AlreadyFormatted =&gt; RESUME ];          Put.Line[toolData.fileSW, "...done"L];          EXITS noGood =&gt; RETURN;          END;  -- FloppyFormat     FloppyInfo: PROCEDURE [] =          BEGIN          density: Floppy.Density;          sides: Floppy.Sides;          label: STRING &larr; [Floppy.maxCharactersInLabel];          freeSpace, largestBlock: LONG CARDINAL;          v: Floppy.VolumeHandle;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "InfoDisk...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [v] &larr; OpenFloppy[];          IF ~opened THEN RETURN;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "GetAttributes...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [freeSpace, largestBlock, , , density, sides] &larr; Floppy.GetAttributes[               v, label];          toolData.floppyName &larr; String.CopyToNewString[               s: label, z: Heap.systemZone];          Put.CR[toolData.fileSW];          Put.Text[toolData.fileSW, "Floppy """L];          Put.Text[toolData.fileSW, label];          Put.Text[toolData.fileSW, """; "L];          Put.Text[toolData.fileSW, IF sides = one THEN "single"L ELSE "double"L];          Put.Text[toolData.fileSW, " sided; "L];          Put.Text[               toolData.fileSW, IF density = single THEN "single"L ELSE "double"L];          Put.Line[toolData.fileSW, " density"L];          Put.LongDecimal[toolData.fileSW, freeSpace];          Put.Text[toolData.fileSW, " free pages; largest free block = "L];          Put.LongDecimal[toolData.fileSW, largestBlock];          Put.Line[toolData.fileSW, " pages"L];          AccessFloppy.Close[];          FormSW.DisplayItem[toolData.paramSW, 2];          END;  --FloppyInfo     FloppyList: PROCEDURE [] =          BEGIN          pattern: LONG STRING &larr; NIL;          v: Floppy.VolumeHandle;          ListOne: EnumProc =               BEGIN               Put.CR[toolData.fileSW];               Put.Text[toolData.fileSW, name];               FOR i: CARDINAL IN [name.length + WritePartial[attributes]..24) DO                    Put.Text[toolData.fileSW, " "]; ENDLOOP;               Put.Number[toolData.fileSW, attributes.type, [10, FALSE, TRUE, 5]];               Put.Text[toolData.fileSW, "  "L];               Put.LongNumber[                    toolData.fileSW, attributes.totalSizeInBytes, [                    10, FALSE, TRUE, 9]];               Put.Text[toolData.fileSW, "  "L];               Put.Date[toolData.fileSW, attributes.createDate, noSeconds];               Put.Text[toolData.fileSW, "  "L];               Put.Date[toolData.fileSW, attributes.lastWrittenDate, noSeconds];               END;  --ListOne          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "ListFiles: AccessFloppy.Open...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [v] &larr; OpenFloppy[];          IF ~opened THEN RETURN;          Put.Text[toolData.fileSW, " NAME                   "L];  --23           Put.Text[toolData.fileSW, " TYPE  "L];  -- 5+2          Put.Text[toolData.fileSW, "   LENGTH  "L];  -- 9+2          Put.Text[toolData.fileSW, "      CREATE          "L];  -- 20+2          Put.Line[toolData.fileSW, "  WRITE"L];          EnumerateFloppyFiles[               v, ListOne, "*"L !               UNWIND =&gt; {AccessFloppy.Close[ ! Floppy.Error =&gt; CONTINUE]}];          AccessFloppy.Close[];          END;  --FloppyList     FloppyReadSysout: PUBLIC PROCEDURE [pattern: LONG STRING] RETURNS [BOOLEAN] =          BEGIN          altName: LONG STRING &larr; NIL;          pagesRemaining: INTEGER &larr; 1;          created: BOOLEAN &larr; FALSE;          continue: BOOLEAN &larr; TRUE;          file: File.File;          firstTime: BOOLEAN &larr; TRUE;          fFile: Floppy.FileHandle;          firstPage: File.PageNumber;          freePages: Volume.PageCount;          loopCnt: CARDINAL &larr; 1;          nextFile: LONG STRING &larr; ILT.toolData.filePathName;          nsName: NSString.String;          readName: LONG STRING &larr; NIL;          switches: LONG STRING &larr; NIL;          v: Floppy.VolumeHandle;          volSize: Volume.PageCount;          --ReadOne: EnumProc =          ReadOne: PROCEDURE [               attributes: AccessFloppy.Attributes, fH: Floppy.FileHandle,               name: LONG STRING] RETURNS [stop: BOOLEAN &larr; FALSE] =               BEGIN               --mFile: MFile.Handle &larr; NIL;               type: MFile.Type &larr; unknown;               destName: LONG STRING &larr; NIL;               srcVFN, destVFN: FileName.VirtualFilename &larr; NIL;               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "ReadOne"L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               --InvertIndicator[];               IF name # NIL THEN srcVFN &larr; FileName.AllocVFN[name];               IF String.Length[altName] # 0 THEN                    destVFN &larr; FileName.AllocVFN[altName]               ELSE destVFN &larr; FileName.AllocVFN["[dummy]"L];               IF String.Length[destVFN.name] = 0 THEN {                    destName &larr; FileName.PackFilename[                         srcVFN, FALSE, FALSE, TRUE, FALSE];                    FileName.UnpackFilename[destName, destVFN];                    FileName.FreeFilename[destName];                    };               destName &larr; FileName.PackFilename[destVFN, FALSE, TRUE, TRUE, FALSE];               Put.Text[ILT.toolData.fileSW, name];               Put.Text[ILT.toolData.fileSW, "... "L];               IF attributes.clientDataLength = 2                    AND attributes.clientData[0] = dataVersion THEN                    type &larr; attributes.clientData[1];               Put.Text[ILT.toolData.fileSW, "copying to "L];               Put.Text[ILT.toolData.fileSW, destName];               [] &larr; WritePartial[attributes];               Put.Text[ILT.toolData.fileSW, "... "L];               IF debug THEN {                    Put.LongDecimal[                         ILT.toolData.fileSW, attributes.totalSizeInBytes];                    Process.Pause[Process.SecondsToTicks[5]];                    };               IF attributes.size # 0 THEN                    Floppy.CopyToPilotFile[                         floppyFile: fH, pilotFile: file,                         firstFloppyPage: AccessFloppy.leaderLength,                         firstPilotPage:                         SpecialMFile.LeaderPages[] + attributes.offset,                         count: attributes.size !                         Floppy.Error =&gt; {                              Put.Line[                                   ILT.toolData.msgSW,                                   "incompatibleSizes/Insufficient space for floppy file"L];                              continue &larr; FALSE;                              Process.Pause[Process.SecondsToTicks[5]];                              }];               Put.Line[ILT.toolData.fileSW, "copied"L];               --MFile.Release[mFile];               IF destVFN # NIL THEN FileName.FreeVFN[destVFN];               IF srcVFN # NIL THEN FileName.FreeVFN[srcVFN];               IF destName # NIL THEN FileName.FreeFilename[destName];               --EXITS return =&gt; NULL;               END;  --ReadOne;          [volumeID, volumeOpen] &larr; ILT.GetVolumeID[ILT.toolData.volName];          [volSize, freePages] &larr; Volume.GetAttributes[volumeID];          [file, firstPage] &larr; OthelloOps.GetVolumeBootFile[               volumeID, hardMicrocode];          Put.Text[ILT.toolData.fileSW, "Creating file."L];          IF (created &larr; file = File.nullFile) THEN {               file &larr; File.Create[                    volumeID, freePages, FileTypes.tUntypedFile !                    Volume.InsufficientSpace =&gt; {                         Put.Text[ILT.toolData.fileSW, "."L];                         freePages &larr; freePages - 100;                         RETRY;                         }];               Put.CR[ILT.toolData.fileSW];               }          ELSE {               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "MakeUnbootable.."L];                    --Process.Pause[Process.SecondsToTicks[10]];                    };               OthelloOps.MakeUnbootable[                    file, hardMicrocode, OthelloDefs.leaderPages];               };          WHILE pagesRemaining &gt; 0 DO               SELECT loopCnt FROM                    1 =&gt;                         Put.Line[                              ILT.toolData.fileSW, "Insert first (#1) floppy "L];                    2 =&gt;                         Put.Line[                              ILT.toolData.fileSW, "Insert second (#2) floppy "L];                    3 =&gt;                         Put.Line[                              ILT.toolData.fileSW, "Insert third (#3) floppy "L];                    4 =&gt;                         Put.Line[                              ILT.toolData.fileSW, "Insert fourth (#4) floppy "L];                    5 =&gt;                         Put.Line[                              ILT.toolData.fileSW, "Insert fifth (#5) floppy "L];                    6 =&gt;                         Put.Line[                              ILT.toolData.fileSW, "Insert sixth (#6) floppy "L];                    ENDCASE =&gt;                         Put.Line[ILT.toolData.fileSW, "Insert next floppy "L];               IF ~ILT.Confirm[] THEN {continue &larr; FALSE; EXIT; };               [v] &larr; OpenFloppy[];               IF ~opened THEN RETURN[FALSE];               IF String.Length[ILT.toolData.filePathName] # 0 THEN {                    Put.Text[ILT.toolData.fileSW, "Retrieving... "L];                    Put.Line[ILT.toolData.fileSW, ILT.toolData.filePathName];                    }               ELSE {                    AccessFloppy.Close[ ! Floppy.Error =&gt; CONTINUE];                    --ERROR Abort["Please enter source file name(s)."L];                    Put.Line[ILT.toolData.msgSW, "Please enter source file name"L];                    };               atSource &larr; 0;               IF attributes = NIL THEN                    attributes &larr; z.NEW[                         AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];               IF String.Length[altName] # 0 THEN FixDirectory[@altName];               readName &larr; String.MakeString[z, 80];               nextFile &larr; GetNextFilename[];               IF nextFile = NIL THEN EXIT;               String.AppendStringAndGrow[@readName, nextFile, z, 80];               [] &larr; Token.FreeTokenString[nextFile];               IF readName = NIL THEN EXIT;               [nsName] &larr; NSString.StringFromMesaString[readName];               IF WildCards[readName] THEN {                    Put.Line[ILT.toolData.msgSW, "Wild Cards not allowed here"L];                    continue &larr; FALSE;                    EXIT;                    };               [fFile, continue] &larr; FileLookUp[nsName];               IF ~continue THEN EXIT;               IF firstTime THEN {                    pagesRemaining &larr; attributes.totalSize; firstTime &larr; FALSE; };               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "Floppy.CopyToPilotFile"L];                    Put.Decimal[ILT.toolData.fileSW, AccessFloppy.leaderLength];                    Put.CR[ILT.toolData.fileSW];                    Put.LongDecimal[                         ILT.toolData.fileSW, SpecialMFile.LeaderPages[]];                    Put.CR[ILT.toolData.fileSW];                    Put.Text[ILT.toolData.fileSW, " attributes.offset"L];                    Put.LongDecimal[ILT.toolData.fileSW, attributes.offset];                    Put.CR[ILT.toolData.fileSW];                    Put.Text[ILT.toolData.fileSW, " attributes.size"L];                    Put.LongDecimal[ILT.toolData.fileSW, attributes.size];                    Put.CR[ILT.toolData.fileSW];                    Process.Pause[Process.SecondsToTicks[5]];                    };               [] &larr; ReadOne[attributes, fFile, NameFromAttributes[attributes]];               pagesRemaining &larr; pagesRemaining - attributes.size;               Put.LongDecimal[ILT.toolData.fileSW, pagesRemaining];               Put.Line[ILT.toolData.fileSW, " pages more"L];               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "UserInput.UserAbort"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    };               IF UserInput.UserAbort[ILT.windowHandle] THEN {                    Put.Text[ILT.toolData.fileSW, "User Abort! "L];                    Put.Line[ILT.toolData.fileSW, "Aborted"L];                    UserInput.ResetUserAbort[ILT.windowHandle];                    continue &larr; FALSE;                    };               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "z.FREE"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    };               z.FREE[@attributes];               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "String.FreeString"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    };               IF readName # NIL THEN String.FreeString[z, readName];               IF altName # NIL THEN String.FreeString[z, altName];               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "AccessFloppy.Close"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    };               AccessFloppy.Close[];               IF ~continue THEN EXIT;               loopCnt &larr; loopCnt + 1;               ENDLOOP;          IF continue THEN {               ILT.ExpandVMemSize[file, volumeID];               ILT.SetupBootFile[file, volumeID];               };          RETURN[continue];          END;  --FloppyReadSysout     FloppyStuff: PUBLIC PROCEDURE =          BEGIN          aborted: BOOLEAN &larr; FALSE;          IF toolData = NIL THEN toolData &larr; Heap.systemZone.NEW[Data &larr; []];          IF attributes = NIL THEN               attributes &larr; z.NEW[                    AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FloppyStuff...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          floppyWH &larr; MakeTool[];          BEGIN          ENABLE {               Abort =&gt; {Put.Line[toolData.fileSW, s]; aborted &larr; TRUE; };               AccessFloppy.Error =&gt; {                    Put.Text[toolData.fileSW, "unexpected "L];                    WriteAccessFloppyError[type];                    Put.CR[toolData.fileSW];                    aborted &larr; TRUE;                    };               AccessFloppy.InconsistentFile =&gt; {                    Put.Line[toolData.fileSW, "AccessFloppy.InconsistentFile"L];                    aborted &larr; TRUE;                    };               AccessFloppy.InvalidVersion =&gt; {                    Put.Line[toolData.fileSW, "AccessFloppy.InvalidVersion"L];                    aborted &larr; TRUE;                    };               AccessFloppy.NoRoomForClientData =&gt; {                    Put.Line[toolData.fileSW, "AccessFloppy.NoRoomForClientData"L];                    aborted &larr; TRUE;                    };               Floppy.Error =&gt; {                    IF error = writeInhibited THEN                         Put.Line[toolData.fileSW, "Floppy is write protected"L]                    ELSE {                         Put.Text[toolData.fileSW, "unexpected "L];                         WriteFloppyError[error];                         Put.CR[toolData.fileSW];                         };                    aborted &larr; TRUE;                    };               };          END;          END;  --FloppyStuff     &lt;&lt;     FloppyToDisk: PROC =          BEGIN          handle: MStream.Handle &larr; NIL;          releaseData: MStream.ReleaseData &larr; [];          FOR current: Floppy.FileHandle &larr; Floppy.GetNextFile[nullFile].nextFile,               Floppy.GetNextFile[current].nextFile WHILE current # nullFile DO               scratchName: LONG STRING &larr; [120];               IF debug THEN {                    Put.Line[toolData.fileSW, ".Floppy.GetFileAttributes...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               [toolData.current.size, toolData.current.type] &larr;                    Floppy.GetFileAttributes[current];               IF debug THEN {                    Put.Line[                         toolData.fileSW, ".AccessFloppy.GetFileAttributes...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               AccessFloppy.GetAttributes[current, attributes];               IF debug THEN {                    Put.Line[toolData.fileSW, ".String.MakeString...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               toolData.current.file &larr; String.MakeString[                    z, AccessFloppy.maxNameLength];               IF debug THEN {                    Put.Line[                         toolData.fileSW,                         "AccessFloppyUtil.MesaStringFromAttributes...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               MesaStringFromAttributes[attributes, toolData.current.file];               IF debug THEN {                    Put.Line[toolData.fileSW, ".String.AppendString...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               String.AppendString[scratchName, toolData.current.file];               String.AppendString[scratchName, ".Scratch$"L];               IF debug THEN {                    Put.Line[toolData.fileSW, ".String.AppendString...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               handle &larr; MStream.ReadWrite[                    name: scratchName, release: releaseData,                    type: MFile.Type[unknown]];               attributes.size &larr; toolData.current.size;  -- modify size to actual file size.               IF debug THEN {                    Put.Line[toolData.fileSW, "RetrieveFilePiece..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               RetrieveFilePiece[current, handle, attributes];               toolData.numberOfFiles &larr; toolData.numberOfFiles + 1;               toolData.current &larr; toolData.current.next &larr; z.NEW[NextFile &larr; []];               IF debug THEN {                    Put.Line[toolData.fileSW, "handle.delete..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               handle.delete[handle];               ENDLOOP;          -- will have current points to a NextFile[NIL, NIL].             END;  -- FloppyToDisk.&gt;&gt;     FloppyWrite: PUBLIC PROCEDURE [name: LONG STRING] =          BEGIN          attributes: AccessFloppy.Attributes &larr; NIL;          altName, switches: LONG STRING &larr; NIL;          fileType: File.Type &larr; FileTypes.tUntypedFile;          mFile: MFile.Handle;          --[] &larr; AccessFloppy.Open[! AccessFloppy.Error =&gt; ERROR Abort["Can't open floppy"L]];          [vH] &larr; OpenFloppy[];          IF ~opened THEN RETURN;          --  DO          BEGIN          ENABLE               UNWIND =&gt; {                    IF mFile # NIL THEN MFile.Release[mFile];                    Heap.systemZone.FREE[@attributes];                    AccessFloppy.Close[ ! Floppy.Error =&gt; CONTINUE]};          fFile: Floppy.FileHandle;          failed: BOOLEAN &larr; FALSE;          mFileError: MFile.ErrorCode;          offset, length: CARDINAL;          IF attributes = NIL THEN               attributes &larr; Heap.systemZone.NEW[                    AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];          mFile &larr; NIL;          IF name = NIL AND switches = NIL THEN GOTO done;          [offset, length] &larr; ParsePartial[               name !               Token.SyntaxError =&gt; {                    Put.Line[ILT.toolData.fileSW, name];                    Put.Line[ILT.toolData.fileSW, " - bad name syntax"L];                    --SetOutcome[error];                    --LOOP;                    }];          IF switches = NIL THEN altName &larr; name;          mFile &larr; MFile.ReadOnly[               name, [] ! MFile.Error =&gt; {mFileError &larr; code; CONTINUE}];          IF mFile = NIL THEN               SELECT mFileError FROM                    noSuchFile =&gt; {                         Put.Line[ILT.toolData.msgSW, " not found"L];                         --SetOutcome[error];                         --LOOP;                         };                    conflictingAccess =&gt; {                         Put.Line[ILT.toolData.msgSW, " conflicting access"L];                         --SetOutcome[error];                         --LOOP;                         };                    ENDCASE =&gt; ERROR Abort[" unexpected MFile.Error"L];          MakeAttributes[mFile, altName, attributes, fileType];          attributes.offset &larr; offset;          attributes.size &larr; MIN[length, attributes.totalSize - offset];          --Put.Text[ILT.toolData.msgSW, name];          [] &larr; WritePartial[attributes];          Put.Text[ILT.toolData.msgSW, "... "L];          Put.Text[ILT.toolData.msgSW, "copying to "L];          Put.Text[ILT.toolData.msgSW, altName];          Put.Text[ILT.toolData.msgSW, "... "L];          IF debug THEN Process.Pause[Process.SecondsToTicks[10]];          fFile &larr; AccessFloppy.CreateFile[               attributes !               AccessFloppy.Error =&gt;                    IF type = nameInUse THEN {failed &larr; TRUE; CONTINUE};               Floppy.Error =&gt;                    SELECT error FROM                         fileListFull =&gt; ERROR Abort["too many files"L];                         insufficientSpace =&gt; ERROR Abort["floppy is full"L];                         ENDCASE];          IF failed THEN {               Put.Line[                    ILT.toolData.msgSW, "floppy file already exists - skipped"L];               Process.Pause[Process.SecondsToTicks[5]];               --SetOutcome[error];               }          ELSE {               IF attributes.size # 0 THEN                    Floppy.CopyFromPilotFile[                         floppyFile: fFile,                         pilotFile: SpecialMFile.GetCapaWithAccess[mFile],                         firstFloppyPage: AccessFloppy.leaderLength,                         firstPilotPage: SpecialMFile.LeaderPages[] + offset,                         count: attributes.size];               Put.Line[ILT.toolData.msgSW, "copied"L]};          Process.Pause[Process.SecondsToTicks[5]];          MFile.Release[mFile];          --ENDLOOP;          EXITS done =&gt; NULL;          END;          Heap.systemZone.FREE[@attributes];          AccessFloppy.Close[];          END;  -- FloppyWrite     FormatAndOpen: PROC [] RETURNS [skip: BOOLEAN] =          BEGIN          density: Floppy.Density &larr; double;          sides: Floppy.Sides &larr; two;          nFile: CARDINAL &larr; 2 * toolData.numberOfFiles + 1;          ok: BOOLEAN;          skip &larr; TRUE;          Put.Line[toolData.fileSW, "Please Remove Floppy Disk, are you ready? "L];          IF ~ILT.Confirm[] THEN RETURN;          Put.Line[toolData.fileSW, "format..."L];          [ok] &larr; FloppyFormat[nFile, toolData.floppyName, sides, density];          IF ~ok THEN {CleanUp; RETURN};          Put.Line[toolData.fileSW, "...ted"L];          vH &larr; AccessFloppy.Open[];          nullFile &larr; [vH, Floppy.nullFileID];          skip &larr; FALSE;          END;  -- FormatAndOpen.     FormSWDeleteProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FormSWDeleteProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [] &larr; FloppyDelete[toolData.pattern];          END;  --FormSWDeleteProc     FormSWDuplicateProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWDuplicateProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Put.Line[toolData.fileSW, "to be implemented"L];          FloppyDuplicate;          END;  --FormSWDuplicateProc     FormSWFormatProc: FormSW.ProcType =          BEGIN          ok: BOOLEAN;          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWFormatProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [ok] &larr; FloppyFormat[256, toolData.floppyName, default, default];          END;  --FormSWFormatProc     FormSWInfoProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWInfoProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          FloppyInfo;          END;  --FormSWInfoProc     FormSWListProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWListProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          FloppyList;          END;  --FormSWListProc     FormSWReadProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWReadProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Put.Line[toolData.fileSW, "to be implemented"L];          END;  --FormSWReadProc     FormSWWriteProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWWriteProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Put.Line[toolData.fileSW, "to be implemented"L];          FloppyWrite[toolData.pattern];          END;  --FormSWWriteProc     FormSWQuitProc: FormSW.ProcType =          BEGIN          IF toolData # NIL THEN               BEGIN Tool.Destroy[floppyWH]; Heap.systemZone.FREE[@toolData]; END;          END;  --FormSWQuitProc     FormSWVolHintsProc: FormSW.MenuProcType =          BEGIN          RETURN[               hints: DESCRIPTOR[               @ILT.toolData.volHints[0], ILT.toolData.volHints.length],                    freeHintsProc: HintsNoLongerBusy, replace: TRUE];          END;     GetNextFilename: PUBLIC PROC RETURNS [fn: LONG STRING &larr; NIL] =          BEGIN          MyGet: PROC [Token.Handle] RETURNS [c: CHARACTER] =               BEGIN               IF atSource &gt;= ILT.toolData.filePathName.length THEN c &larr; Ascii.NUL               ELSE                    BEGIN                    c &larr; ILT.toolData.filePathName[atSource];                    atSource &larr; atSource + 1;                    END;               END;          getObject: Token.Object &larr; [getChar: MyGet, break: Ascii.NUL];          IF atSource &gt;= ILT.toolData.filePathName.length THEN RETURN[NIL];          fn &larr; Token.Item[h: @getObject, temporary: FALSE];          END;  --GetNextFilename     HintsNoLongerBusy: FormSW.FreeHintsProcType = BEGIN END;     MesaStringFromAttributes: PUBLIC PROC [          attris: AccessFloppy.Attributes, name: LONG STRING] =          BEGIN  -- should protect against a bogus attris (i.e., one from a non AccessFloppy file).          name.length &larr; 0;          IF attris = NIL THEN               RETURN WITH ERROR AccessFloppy.Error[invalidParameter];          IF attris.length &gt; attris.maxlength THEN  -- invalidAttributes?               RETURN WITH ERROR AccessFloppy.Error[invalidParameter];          IF name.maxlength &lt; attris.length THEN               RETURN WITH ERROR AccessFloppy.Error[invalidParameter];          IF debug THEN {               Put.Line[toolData.fileSW, "Inline.LongCOPY...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [] &larr; Inline.LongCOPY[               to: @name.text, nwords: attris.length / 2, from: @attris.name];          name.length &larr; attris.length;          IF name.length # 0 THEN  -- pick up odd character.               name[name.length - 1] &larr; LOOPHOLE[attris.name[name.length - 1]];          END;  -- MesaStringFromAttributes.     MakeAttributes: PROCEDURE [          file: MFile.Handle, name: LONG STRING,          attributes: AccessFloppy.Attributes, type: File.Type] =          BEGIN          attributes.version &larr; AccessFloppy.currentVersion;          attributes.type &larr; type;          attributes.lastWrittenDate &larr; Time.Current[];          attributes.name &larr; ALL[0];          attributes.clientDataLength &larr; 2;          attributes.clientData[0] &larr; dataVersion;          [length: attributes.totalSizeInBytes, create: attributes.createDate,               type: attributes.clientData[1]] &larr; MFile.GetProperties[file];          attributes.totalSize &larr; PagesFromBytes[attributes.totalSizeInBytes];          attributes.size &larr; attributes.totalSize;          attributes.length &larr; MIN[name.length, AccessFloppy.maxNameLength];          FOR i: CARDINAL IN [0..attributes.length) DO               attributes.name[i] &larr; LOOPHOLE[name[i]]; ENDLOOP          END;  --MakeAttributes     MakeCommands: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..5) OF CARDINAL &larr; [0, 20, 40, 60, 70];          nItems: CARDINAL = 8;          items &larr; AllocateItemDescriptor[nItems];          items[0] &larr; CommandItem[               tag: "Info"L, place: newLine, proc: FormSWInfoProc];          items[1] &larr; CommandItem[tag: "List"L, proc: FormSWListProc];          items[2] &larr; CommandItem[tag: "Read"L, proc: FormSWReadProc];          items[3] &larr; CommandItem[tag: "Write"L, proc: FormSWWriteProc];          items[4] &larr; CommandItem[               tag: "Format"L, place: newLine, proc: FormSWFormatProc];          items[5] &larr; CommandItem[tag: "Delete"L, proc: FormSWDeleteProc];          items[6] &larr; CommandItem[tag: "Duplicate"L, proc: FormSWDuplicateProc];          items[7] &larr; CommandItem[tag: "Quit"L, proc: FormSWQuitProc];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE];          END;  --MakeCommands     MakeParams: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          i, nVols: CARDINAL;          tabs: ARRAY [0..4) OF CARDINAL &larr; [0, 30, 60, 75];          nItems: CARDINAL = 3;          items &larr; AllocateItemDescriptor[nItems];          nVols &larr; ILT.ListLogicalVolumes[];          String.Copy[toolData.volName, ILT.toolData.volHints[0]];          FOR i IN [0..nVols) DO               IF String.Equivalent[ILT.toolData.volHints[i], "Lisp"L] THEN                    BEGIN                    String.Replace[                         @toolData.volName, ILT.toolData.volHints[i],                         Heap.systemZone];                    EXIT;                    END;               ENDLOOP;          items[0] &larr; StringItem[               tag: "Source Volume"L, place: newLine, string: @toolData.volName,               inHeap: TRUE, menuProc: FormSWVolHintsProc];          items[1] &larr; StringItem[               tag: "Pattern"L, string: @toolData.pattern, inHeap: TRUE];          items[2] &larr; StringItem[               tag: "Floppy Name"L, string: @toolData.floppyName, place: newLine,               inHeap: TRUE];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE]          END;  --MakeParams     MakeSWs: Tool.MakeSWsProc =          BEGIN          addresses: ARRAY [0..4) OF ToolDriver.Address;          logName: STRING &larr; [20];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "MakeSWs...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Tool.UnusedLogName[unused: logName, root: "FloppyOptions.log"L];          toolData.msgSW &larr; Tool.MakeMsgSW[window: window, lines: 2];          toolData.paramSW &larr; Tool.MakeFormSW[window: window, formProc: MakeParams];          toolData.commandSW &larr; Tool.MakeFormSW[               window: window, formProc: MakeCommands];          --note: logName is compulsory, else it bombs               toolData.fileSW &larr; Tool.MakeFileSW[window: window, name: logName];          --Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];          -- do the ToolDriver stuff          addresses &larr; [               [name: "msgSW"L, sw: toolData.msgSW],               --[name: "formSW"L, sw: toolData.formSW],               [name: "ParamSW"L, sw: toolData.paramSW], [               name: "CmdSW"L, sw: toolData.commandSW], [               name: "fileSW"L, sw: toolData.fileSW]];          ToolDriver.NoteSWs[               tool: "FloppyOptions"L, subwindows: DESCRIPTOR[addresses]];          END;  --MakeSWs     MakeTool: PROCEDURE RETURNS [wh: Window.Handle] =          BEGIN          heraldName: STRING &larr; [80];          String.AppendString[heraldName, "XSIS:Xerox Floppy Option"L];          --String.AppendString[heraldName, " of "L];          --Time.Append[heraldName, Time.Unpack[Runtime.GetBcdTime[]]];          --heraldName.length &larr; heraldName.length - 3;          --String.AppendString[heraldName, " on Pilot Version "L];          --Version.Append[heraldName];          RETURN[               Tool.Create[                    makeSWsProc: MakeSWs, initialState: default,                    --clientTransition: Transit,                     name: heraldName]];          --initialBox: [          --place: sw.BitmapPlace[[10, hisBox.dims.h]],          --dims: [hisBox.dims.w - 20, 180]]];          END;  --MakeTool     NameFromAttributes: PROCEDURE [attributes: AccessFloppy.Attributes]          RETURNS [LONG STRING] = INLINE {RETURN[LOOPHOLE[@attributes.length]]};     OpenFloppy: PROCEDURE [] RETURNS [v: Floppy.VolumeHandle] =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "OpenFloppy...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          opened &larr; TRUE;          v &larr; AccessFloppy.Open[               !               Floppy.Error =&gt;                    SELECT error FROM                         notReady =&gt; {                              Put.Line[ILT.toolData.msgSW, "Floppy Not Closed"L];                              IF debug THEN                                   Process.Pause[Process.SecondsToTicks[10]];                              GOTO noGood;                              };                         invalidFormat =&gt; {                              Put.Line[                                   ILT.toolData.msgSW, "Invalid Floppy Format"L];                              GOTO noGood;                              };                         needsScavenging =&gt; {                              Put.Line[                                   ILT.toolData.msgSW, "Floppy Needs Scavenging"L];                              GOTO noGood;                              };                         ENDCASE];          EXITS noGood =&gt; opened &larr; FALSE;          END;  -- OpenFloppy     ParsePartial: PROCEDURE [name: LONG STRING]          RETURNS [offset: CARDINAL &larr; 0, length: CARDINAL &larr; LAST[CARDINAL]] =          BEGIN          h: Token.Handle;          i: CARDINAL;          IF name = NIL THEN RETURN;          FOR i IN [1..name.length) DO               IF name[i] = '[ THEN EXIT; REPEAT FINISHED =&gt; RETURN ENDLOOP;          h &larr; Token.StringToHandle[name, i + 1];          BEGIN          ENABLE UNWIND =&gt; [] &larr; Token.FreeStringHandle[h];          offset &larr; Token.Decimal[h];          SELECT h.break FROM               '. =&gt;                    IF h.getChar[h] = '. THEN                         length &larr; Token.Decimal[h] - offset + 1                    ELSE ERROR Token.SyntaxError[NIL];               '! =&gt; length &larr; Token.Decimal[h];               '] =&gt; NULL;               ENDCASE =&gt; ERROR Token.SyntaxError[NIL];          END;          name.length &larr; i;          [] &larr; Token.FreeStringHandle[h];          END;  --ParsePartial     PagesFromBytes: PROCEDURE [bytes: LONG CARDINAL] RETURNS [LONG CARDINAL] =          BEGIN          RETURN[               (bytes + Environment.bytesPerPage - 1) / Environment.bytesPerPage];          END;  --PagesFromBytes     PutVolumeName: PROCEDURE [] =          BEGIN          Put.Text[toolData.fileSW, "Volume = "L];          Put.LongString[toolData.fileSW, toolData.volName];          Put.CR[toolData.fileSW];          END;  --PutVolumeName     &lt;&lt;     RetrieveFilePiece: PROC [          floppyFile: Floppy.FileHandle, mStream: MStream.Handle,          attributes: AccessFloppy.Attributes] =          BEGIN          mFile: MFile.Handle &larr; NIL;          block: Environment.Block;          bufferSizeInBytes, bytesRemaining, bytesToRead, bytesTransfered:               AccessFloppy.LengthInBytes;          start, pagesToRead: File.PageNumber;          bytesTransfered &larr; 0;          -- starting page number of the floppy file, page count of the floppy file, and byte count of the floppy file.          start &larr; 0;          bytesRemaining &larr; attributes.size*Environment.bytesPerPage;          bufferSizeInBytes &larr; bufferSize*Environment.bytesPerPage;          -- set attributes          mFile &larr; MStream.GetFile[mStream];          MFile.SetTimes[               file: mFile, create: attributes.createDate,               write: attributes.lastWrittenDate];          MFile.SetType[mFile, MFile.Type[binary]];          MStream.SetLength[mStream, bytesRemaining];          -- set up block          block.blockPointer &larr; Space.LongPointer[spaceHandle];          block.startIndex &larr; 0;          --copy as many chunks of the standard buffer size as possible.....          UNTIL bytesRemaining = 0 DO               bytesToRead &larr; MIN[bytesRemaining, bufferSizeInBytes];               pagesToRead &larr; PagesFromBytes[bytesToRead];               Floppy.Read[floppyFile, start, pagesToRead, block.blockPointer];               block.stopIndexPlusOne &larr; Inline.LowHalf[bytesToRead];               mStream.put[mStream, block, FALSE];               start &larr; start + pagesToRead;               bytesTransfered &larr; bytesTransfered + bytesToRead;               bytesRemaining &larr; bytesRemaining - bytesToRead;               ENDLOOP;          END;  -- RetrieveFilePiece.      StoreFilePiece: PROC [          mStream: MStream.Handle, floppyFile: Floppy.FileHandle,          size: File.PageNumber] =          BEGIN          -- store data from disk to floppy          block: Environment.Block;          bufferSizeInBytes, bytesRemaining, bytesToWrite, bytesTransfered:               AccessFloppy.LengthInBytes;          start, pagesToWrite: File.PageNumber;          why: Stream.CompletionCode &larr; normal;          bytesTransfered &larr; 0;          -- starting page number of the floppy file, page count of the floppy file, and byte count of the floppy file.          start &larr; 0;          bytesRemaining &larr; (size*Environment.bytesPerPage);          bufferSizeInBytes &larr; bufferSize*Environment.bytesPerPage;          -- set up block          block.blockPointer &larr; Space.LongPointer[spaceHandle];          block.startIndex &larr; 0;          bytesToWrite &larr; bytesRemaining;          --copy as many chunks of the standard buffer size as possible.....          UNTIL bytesRemaining = 0 OR why = endOfStream DO               bytesToWrite &larr; MIN[bytesRemaining, bufferSizeInBytes];               block.stopIndexPlusOne &larr; Inline.LowHalf[bytesToWrite];               [bytesToWrite, why, ] &larr; mStream.get[                    mStream, block, Stream.defaultInputOptions];               pagesToWrite &larr; PagesFromBytes[bytesToWrite];               Floppy.Write[floppyFile, start, pagesToWrite, block.blockPointer];               start &larr; start + pagesToWrite;               bytesTransfered &larr; bytesTransfered + bytesToWrite;               bytesRemaining &larr; bytesRemaining - bytesToWrite;               ENDLOOP;          END;  -- StoreFilePiece.&gt;&gt;     Transit: ToolWindow.TransitionProcType =          BEGIN          SELECT TRUE FROM               old = inactive =&gt;                    BEGIN                    IF toolData = NIL THEN                         toolData &larr; Heap.systemZone.NEW[Data &larr; []];                    IF attributes = NIL THEN                         attributes &larr; z.NEW[                              AccessFloppy                              .AttributesRecord[AccessFloppy.maxDataSize]];                    --UserInput.ResetUserAbort[window];                    --data.logSW &larr; window;                    -- data.window &larr; ToolWindow.WindowForSubwindow[window];                    -- data.ttyWindow &larr; TTYSW.GetTTYHandle[window];                    -- destroy &larr; FALSE;                    active &larr; TRUE;                    END;               new = inactive =&gt;                    BEGIN                    IF toolData # NIL THEN                         BEGIN                         FormSW.Destroy[toolData.paramSW];                         FormSW.Destroy[toolData.commandSW];                         Heap.systemZone.FREE[@toolData];                         END;                    IF attributes # NIL THEN {                         z.FREE[@attributes]; attributes &larr; NIL};                    --ToolDriver.RemoveSWs[tool: "LispTool"L];                    active &larr; FALSE;                    END;               ENDCASE;          END;  -- Transit     WriteAccessFloppyError: PROCEDURE [type: AccessFloppy.ErrorType] =          BEGIN          Put.Text[toolData.fileSW, "AccessFloppy.Error["L];          Put.Text[               toolData.fileSW,               SELECT type FROM                    attributesNotAllowed =&gt; "attributesNotAllowed"L,                    fileNotFound =&gt; "fileNotFound"L,                    invalidParameter =&gt; "invalidParameter"L,                    nameInUse =&gt; "nameInUse"L,                    volumeNotOpen =&gt; "volumeNotOpen"L,                    ENDCASE =&gt; "?"L];          Put.Text[toolData.fileSW, "]"L];          END;  --WriteAccessFloppyError     WriteFloppyError: PROCEDURE [error: Floppy.ErrorType] =          BEGIN          Put.Text[toolData.fileSW, "Floppy.Error["L];          Put.Text[               toolData.fileSW,               SELECT error FROM                    badDisk =&gt; "badDisk"L,                    badSectors =&gt; "badSectors"L,                    endOfFile =&gt; "endOfFile"L,                    fileListFull =&gt; "fileListFull"L,                    fileNotFound =&gt; "fileNotFound"L,                    hardwareError =&gt; "hardwareError"L,                    incompatibleSizes =&gt; "incompatibleSizes"L,                    invalidFormat =&gt; "invalidFormat"L,                    invalidPageNumber =&gt; "invalidPageNumber"L,                    invalidVolumeHandle =&gt; "invalidVolumeHandle"L,                    insufficientSpace =&gt; "insufficientSpace"L,                    needsScavenging =&gt; "needsScavenging"L,                    noSuchDrive =&gt; "noSuchDrive"L,                    notReady =&gt; "notReady"L,                    onlyOneSide =&gt; "onlyOneSide"L,                    onlySingleDensity =&gt; "onlySingleDensity"L,                    initialMicrocodeSpaceNotAvailable =&gt;                         "initialMicrocodeSpaceNotAvailable"L,                    stringTooShort =&gt; "stringTooShort"L,                    volumeNotOpen =&gt; "volumeNotOpen"L,                    writeInhibited =&gt; "writeInhibited"L,                    zeroSizeFile =&gt; "zeroSizeFile"L,                    ENDCASE =&gt; "?"L];          Put.Line[toolData.fileSW, "]"L];          END;  --WriteFloppyError     -- used by both ILT and subwindows     WritePartial: PROCEDURE [attributes: AccessFloppy.Attributes]          RETURNS [chars: CARDINAL &larr; 0] =          BEGIN          CountedNumber: PROCEDURE [n: LONG CARDINAL] RETURNS [CARDINAL] = {               s: STRING = [12];               String.AppendLongDecimal[s, n];               Put.Text[ILT.toolData.fileSW, s];               RETURN[s.length]};          IF attributes.offset # 0 OR attributes.size # attributes.totalSize THEN {               chars &larr; 4;               Put.Char[ILT.toolData.fileSW, '[];               chars &larr; chars + CountedNumber[attributes.offset];               -- Write[".."L];               chars &larr;                    chars + CountedNumber[attributes.offset + attributes.size - 1];               Put.Char[ILT.toolData.fileSW, ']]};          END;  --WritePartial     &lt;&lt; 	WriteFiles: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =          BEGIN          attributes: AccessFloppy.Attributes &larr; NIL;          name, altName, switches: LONG STRING &larr; NIL;          fileType: File.Type &larr; FileTypes.tUntypedFile;          mFile: MFile.Handle;          Write: Format.StringProc = Exec.OutputProc[h];          IF gSwitches # NIL THEN               fileType &larr; [                    String.StringToNumber[                    gSwitches ! String.InvalidNumber =&gt; CONTINUE]];          [] &larr; AccessFloppy.Open[               ! AccessFloppy.Error =&gt; ERROR Abort["Can't open floppy"L]];          DO               ENABLE                    UNWIND =&gt; {                         IF altName # name THEN                              altName &larr; Exec.FreeTokenString[altName];                         name &larr; Exec.FreeTokenString[name];                         switches &larr; Exec.FreeTokenString[switches];                         IF mFile # NIL THEN MFile.Release[mFile];                         Heap.systemZone.FREE[@attributes];                         AccessFloppy.Close[ ! Floppy.Error =&gt; CONTINUE]};               fFile: Floppy.FileHandle;               failed: BOOLEAN &larr; FALSE;               mFileError: MFile.ErrorCode;               offset, length: CARDINAL;               IF attributes = NIL THEN                    attributes &larr; Heap.systemZone.NEW[                         AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];               mFile &larr; NIL;               IF altName # name THEN altName &larr; Exec.FreeTokenString[altName];               name &larr; Exec.FreeTokenString[name];               switches &larr; Exec.FreeTokenString[switches];               [name, switches] &larr; Exec.GetToken[h];               IF name = NIL AND switches = NIL THEN EXIT;               [offset, length] &larr; ParsePartial[                    name !                    Token.SyntaxError =&gt; {                         Write[name];                         Format.Line[Write, " - bad name syntax"L];                         SetOutcome[error];                         LOOP}];               IF switches # NIL AND switches.length # 0 THEN                    SELECT switches[0] FROM                         's =&gt; {                              switches &larr; Exec.FreeTokenString[switches];                              [altName, switches] &larr; Exec.GetToken[h]};                         't =&gt; {                              fileType &larr; [                                   String.StringToNumber[                                   name ! String.InvalidNumber =&gt; CONTINUE]];                              switches &larr; Exec.FreeTokenString[switches];                              LOOP};                         ENDCASE               ELSE altName &larr; name;               mFile &larr; MFile.ReadOnly[                    name, [] ! MFile.Error =&gt; {mFileError &larr; code; CONTINUE}];               IF mFile = NIL THEN                    SELECT mFileError FROM                         noSuchFile =&gt; {                              Format.Line[Write, " not found"L];                              SetOutcome[error];                              LOOP};                         conflictingAccess =&gt; {                              Format.Line[Write, " conflicting access"L];                              SetOutcome[error];                              LOOP};                         ENDCASE =&gt; ERROR Abort[" unexpected MFile.Error"L];               MakeAttributes[mFile, altName, attributes, fileType];               attributes.offset &larr; offset;               attributes.size &larr; MIN[length, attributes.totalSize - offset];               Write[name];               [] &larr; WritePartial[attributes];               Write["... "L];               Write["copying to "L];               Write[altName];               Write["... "L];               fFile &larr; AccessFloppy.CreateFile[                    attributes !                    AccessFloppy.Error =&gt;                         IF type = nameInUse THEN {failed &larr; TRUE; CONTINUE};                    Floppy.Error =&gt;                         SELECT error FROM                              fileListFull =&gt; ERROR Abort["too many files"L];                              insufficientSpace =&gt; ERROR Abort["floppy is full"L];                              ENDCASE];               IF failed THEN {                    Format.Line[Write, "floppy file already exists - skipped"L];                    SetOutcome[error]}               ELSE {                    IF attributes.size # 0 THEN                         Floppy.CopyFromPilotFile[                              floppyFile: fFile,                              pilotFile: SpecialMFile.GetCapaWithAccess[mFile],                              firstFloppyPage: AccessFloppy.leaderLength,                              firstPilotPage: SpecialMFile.LeaderPages[] + offset,                              count: attributes.size];                    Format.Line[Write, "copied"L]};               MFile.Release[mFile];               ENDLOOP;          Heap.systemZone.FREE[@attributes];          AccessFloppy.Close[];          END;  -- WriteFiles&gt;&gt;     WildCards: PROCEDURE [pattern: LONG STRING] RETURNS [BOOLEAN] =          BEGIN          IF pattern # NIL THEN               FOR i: CARDINAL IN [0..pattern.length) DO                    SELECT pattern[i] FROM '*, '# =&gt; RETURN[TRUE]; ENDCASE;                    ENDLOOP;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, " NOT WildCards"L];               Process.Pause[Process.SecondsToTicks[5]];               };          RETURN[FALSE];          END;     END.    </pre>
  </body>
</html>
