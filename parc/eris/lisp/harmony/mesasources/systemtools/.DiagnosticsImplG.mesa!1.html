<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>SystemTools>DiagnosticsImplG.mesa!1</title>
  </head>
  <body>
    <pre>
-- DiagnosticsImplG.mesa  -  edited by:-- Paul		   13-Jul-84 10:14:01DIRECTORY  Ascii USING [CR, SP],  Authenticator USING [firstVerifier, nullCredentials],  CH USING [Element, Enumerate, NamePattern, wildCard],  CHLookup USING [    Error, FileserverPt, LookupFileserver, LookupMailserver, LookupPrintserver],  CHPIDs USING [ch3fileserver, ch3mailserver, ch3printserver],  DiagnosticsOps USING [    ConfirmIndex, confirmation, diagnosticwh, PutMessage, StringIndex, toolData],  ExtendedString USING [AppendNumber],  FormSW USING [Display, FindItem],  NSString USING [AppendToMesaString, StringFromMesaString],  OnlineDiagnostics USING [    FloppyWhatToDoNext, GetConfirmationProc, GetFloppyChoiceProc, GetYesOrNoProc,    YesOrNo],  Put USING [Char, CR, Line, Text],  String USING [    AppendChar, AppendCharAndGrow, AppendLongNumber, AppendNumber,    AppendStringAndGrow],  UserInput USING [UserAbort];DiagnosticsImplG: MONITOR  IMPORTS     CH, CHLookup, DiagnosticsOps, ExtendedString, FormSW, NSString,     Put, String, UserInput  EXPORTS DiagnosticsOps =  BEGIN    -- Routines to allow the diagnostics to talk to the window.  PutChar: PUBLIC PROCEDURE [ch: CHARACTER, minWidth: CARDINAL &larr; 0] =    BEGIN    Put.Char[DiagnosticsOps.toolData.fileSW, ch];    THROUGH [1..minWidth) DO       Put.Char[DiagnosticsOps.toolData.fileSW, Ascii.SP];       ENDLOOP;    END;  PutCR: PUBLIC PROCEDURE = BEGIN Put.CR[DiagnosticsOps.toolData.fileSW]; END;  PutLine: PUBLIC PROCEDURE [text: LONG STRING] =    BEGIN Put.Line[DiagnosticsOps.toolData.fileSW, text]; END;  PutLongNumber: PUBLIC PROCEDURE [    number: LONG UNSPECIFIED, radix: CARDINAL, minWidth: CARDINAL &larr; 0] =    BEGIN    text: STRING = [40];    String.AppendLongNumber[text, number, radix];    THROUGH [text.length..minWidth) DO PutChar[Ascii.SP]; ENDLOOP;    PutText[text];    END;  PutNumber: PUBLIC PROCEDURE [    number: UNSPECIFIED, radix: CARDINAL, minWidth: CARDINAL &larr; 0] =    BEGIN    text: STRING = [40];    String.AppendNumber[text, number, radix];    THROUGH [text.length..minWidth) DO PutChar[Ascii.SP]; ENDLOOP;    PutText[text];    END;  PutText: PUBLIC PROCEDURE [text: LONG STRING, minWidth: CARDINAL &larr; 0] =    BEGIN    Put.Text[DiagnosticsOps.toolData.fileSW, text];    THROUGH [text.length..minWidth) DO      Put.Char[DiagnosticsOps.toolData.fileSW, Ascii.SP]; ENDLOOP;    END;  PutTextCentered: PUBLIC PROCEDURE [text: LONG STRING, width: CARDINAL &larr; 0] =    BEGIN    leftBlanks: CARDINAL = (width - text.length)/2;    rightBlanks: CARDINAL = width - text.length - leftBlanks;    THROUGH [0..leftBlanks) DO PutChar[Ascii.SP]; ENDLOOP;    PutText[text];    THROUGH [0..rightBlanks) DO PutChar[Ascii.SP]; ENDLOOP;    END;      GetConfirmation: PUBLIC ENTRY OnlineDiagnostics.GetConfirmationProc =    BEGIN    ENABLE UNWIND =&gt; NULL;    MakeConfirmsVisible[confirm, confirm];    DiagnosticsOps.PutMessage[msg];    PutLine["Please select Confirm! when this is done."L];    WAIT DiagnosticsOps.confirmation;    MakeConfirmsInvisible[];    END;  GetFloppyChoice: PUBLIC ENTRY OnlineDiagnostics.GetFloppyChoiceProc =    BEGIN    ENABLE UNWIND =&gt; NULL;    MakeConfirmsVisible[continue, exit];    PutLine["What do you want to do now?"L];    WAIT DiagnosticsOps.confirmation;    MakeConfirmsInvisible[];    RETURN[      SELECT DiagnosticsOps.toolData.latestConfirm FROM        continue =&gt; OnlineDiagnostics.FloppyWhatToDoNext[continueToNextError],        loop =&gt; OnlineDiagnostics.FloppyWhatToDoNext[loopOnThisError],        display =&gt; OnlineDiagnostics.FloppyWhatToDoNext[displayStuff],        ENDCASE =&gt; OnlineDiagnostics.FloppyWhatToDoNext[exit]];    END;  GetYesOrNo: PUBLIC ENTRY OnlineDiagnostics.GetYesOrNoProc =    BEGIN    ENABLE UNWIND =&gt; NULL;    MakeConfirmsVisible[yes, no];    DiagnosticsOps.PutMessage[msg];    PutLine["Please select either Yes! or No! as appropriate."L];    WAIT DiagnosticsOps.confirmation;    MakeConfirmsInvisible[];    RETURN[      SELECT DiagnosticsOps.toolData.latestConfirm FROM        yes =&gt; OnlineDiagnostics.YesOrNo[yes],        ENDCASE =&gt; OnlineDiagnostics.YesOrNo[no]];    END;  MakeConfirmsVisible: PROCEDURE [low, high: DiagnosticsOps.ConfirmIndex] =    BEGIN    DiagnosticsOps.toolData.confirming &larr; TRUE;    FOR i: DiagnosticsOps.ConfirmIndex IN [low..high] DO      FormSW.FindItem[DiagnosticsOps.toolData.confirmSW, ORD[      DiagnosticsOps.ConfirmIndex[i]]].flags.invisible &larr; FALSE;      ENDLOOP;    FormSW.Display[DiagnosticsOps.toolData.confirmSW];    END;  MakeConfirmsInvisible: PROCEDURE =    BEGIN    DiagnosticsOps.toolData.confirming &larr; FALSE;    FOR i: DiagnosticsOps.ConfirmIndex IN DiagnosticsOps.ConfirmIndex DO      FormSW.FindItem[DiagnosticsOps.toolData.confirmSW, ORD[      DiagnosticsOps.ConfirmIndex[i]]].flags.invisible &larr; TRUE;      ENDLOOP;    FormSW.Display[DiagnosticsOps.toolData.confirmSW];    END;  CheckForAbort: PUBLIC PROCEDURE =    BEGIN       IF UserInput.UserAbort[DiagnosticsOps.diagnosticwh] THEN ERROR ABORTED;     END;  -- Append server trash, stolen from Diag1Pack.mesa   AppendServers: PUBLIC PROCEDURE [     strings: LONG DESCRIPTOR FOR ARRAY DiagnosticsOps.StringIndex OF LONG STRING,      z:UNCOUNTED ZONE] =    BEGIN  --AppendServers--    found: BOOLEAN &larr; FALSE;    foundThatID: BOOLEAN &larr; FALSE;    pattern: CH.NamePattern;    index: DiagnosticsOps.StringIndex;    string: LONG POINTER TO LONG STRING;    wildString: LONG STRING &larr; [5];    GetAndAppendID: PROC [name: CH.Element] =      BEGIN  --GetAndAppendID--      AppendID: PROC [fullName: CH.Element, info: CHLookup.FileserverPt] =        BEGIN  --AppendID--        temp: LONG STRING &larr; [100];        -- Append the decimal representation of info.address --        AppendDashedNumberAndGrow[string, @info.address.host, 3, 10, z];        -- Append a blank --        String.AppendStringAndGrow[string, " "L, z];        -- ****************************************************************** --        -- NOTE!!!! - The octal &amp; hex representations of the proc IDs are 	-- not printed at this time. May be re-inserted at a future time.        -- Append the octal representation of info.address        -- AppendNumberAndGrow[string, @info.address.host, 3, 8, z];        -- Append the string "B "        -- String.AppendStringAndGrow[string, "B "L, z];        -- Append the hexadecimal representation of info.address        -- AppendNumberAndGrow[string, @info.address.host, 3, 16, z];        -- Append the string "X "        -- String.AppendStringAndGrow[string, "X "L, z];        -- ****************************************************************** --        -- Append the string " NET # "        String.AppendStringAndGrow[string, " NET # "L, z];        -- Append the net # --        AppendDashedNumberAndGrow[string, @info.address.net, 2, 10, z];        -- Append a blank --        String.AppendStringAndGrow[string, " "L, z];        -- Append the name of the server        NSString.AppendToMesaString[temp, name.local];        String.AppendStringAndGrow[string, temp, z];        -- Append a CR --        String.AppendStringAndGrow[string, "    "L, z];        found &larr; TRUE;        END --AppendID-- ;      SELECT index FROM        listFS =&gt;          CHLookup.LookupFileserver[            name, AppendID !            CHLookup.Error =&gt; BEGIN found &larr; FALSE; CONTINUE; END; ];        listPS =&gt;          CHLookup.LookupPrintserver[            name, LOOPHOLE[AppendID] !            CHLookup.Error =&gt; BEGIN found &larr; FALSE; CONTINUE; END; ];        listMS =&gt;          CHLookup.LookupMailserver[            name, LOOPHOLE[AppendID] !            CHLookup.Error =&gt; BEGIN found &larr; FALSE; CONTINUE; END; ];        ENDCASE =&gt; NULL;      END --GetAndAppendID-- ;    -- Set up the pattern to be used in the enumerations. --    String.AppendChar[wildString, CH.wildCard];    pattern &larr; [      org: NSString.StringFromMesaString[strings[currOrganization]],      domain: NSString.StringFromMesaString[strings[currDomain]],      local: NSString.StringFromMesaString[wildString]];    --The following code enumerates the servers found in the Clearinghouse,    -- and appends their IDs to the appropriate strings.    FOR index IN [listFS..listMS] DO      string &larr; @strings[index];      found &larr; CH.Enumerate[        Authenticator.nullCredentials, Authenticator.firstVerifier, @pattern,        (SELECT index FROM           listFS =&gt; CHPIDs.ch3fileserver,           listPS =&gt; CHPIDs.ch3printserver,           ENDCASE =&gt; CHPIDs.ch3mailserver), GetAndAppendID].code = done;      IF found THEN        WHILE string[string&uarr;.length - 1] = Ascii.SP          OR string[string&uarr;.length - 1] = Ascii.CR DO          string&uarr;.length &larr; string&uarr;.length - 1; ENDLOOP  -- get rid of final CR      ELSE String.AppendStringAndGrow[string, "none"L, z];      ENDLOOP;    END --AppendServers-- ;      AppendDashedNumberAndGrow: PROCEDURE [    string: LONG POINTER TO LONG STRING, field: LONG POINTER, size: CARDINAL,    radix: CARDINAL, z: UNCOUNTED ZONE] =    BEGIN  --AppendDashedNumberAndGrow--    temp: LONG STRING &larr; [100];    temp.length &larr; 0;    ExtendedString.AppendNumber[field, size, radix, temp];    FOR i: CARDINAL IN [0..temp.length) DO      String.AppendCharAndGrow[string, temp[i], z];      IF (temp.length - 1 - i) MOD 3 = 0 AND i # temp.length - 1 THEN        String.AppendCharAndGrow[string, '-, z];      ENDLOOP;    END --AppendDashedNumberAndGrow-- ;  AppendNumberAndGrow: PROCEDURE [    string: LONG POINTER TO LONG STRING, field: LONG POINTER, size: CARDINAL,    radix: CARDINAL, z: UNCOUNTED ZONE] =    BEGIN  --AppendNumberAndGrow--    temp: LONG STRING &larr; [100];    temp.length &larr; 0;    ExtendedString.AppendNumber[field, size, radix, temp];    String.AppendStringAndGrow[string, temp, z];    END --AppendNumberAndGrow-- ;    END.</pre>
  </body>
</html>
