<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>SystemTools>LTLispToolImpl.mesa!1</title>
  </head>
  <body>
    <pre>
--LTLispToolImpl.mesa--Created by--   JFung.PASA	  	20-Sep-83 10:10:02--last edited by--   JFung.PASA	   	13-Sep-84 10:41:03DIRECTORY     CmFile,     Cursor USING [Set],     Display,     Event,     EventTypes,     Exec,     File,     FileTransfer,     Format,     FormSW,     Heap,     LispToolOps,     OthelloDefs,     OthelloOps,     OthelloOpsImpl,     Process,     Profile,     Put,     Runtime,     String,     StringLookUp,     Supervisor,     System,     TemporaryBooting,     Time,     Token,     Tool,     ToolDriver,     ToolWindow,     UserInput,     Version,     Volume,     Window;LTLispToolImpl: PROGRAM     IMPORTS          CmFile, Cursor, Display, Exec, FormSW, Heap, LispToolOps, OthelloDefs,OthelloOps, OthelloOpsImpl,          Process, Profile, Put, Runtime, String, Supervisor, TemporaryBooting,          Time, Token, Tool, ToolDriver, ToolWindow, UserInput, Version, Volume,          Window     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;     Indicator: TYPE = {off, left, right};     twiddleLeft: Graphic = [          111000B, 052000B, 034000B, 177000B, 034000B, 052000B, 111000B, 000000B,          000222B, 000124B, 000070B, 000376B, 000070B, 000124B, 000222B, 000000B];     twiddleRight: Graphic = [          000222B, 000124B, 000070B, 000376B, 000070B, 000124B, 000222B, 000000B,          111000B, 052000B, 034000B, 177000B, 034000B, 052000B, 111000B, 000000B];     debug: BOOLEAN &larr; FALSE;     floppyWH: Window.Handle &larr; NIL;     toolData: PUBLIC ILT.DataHandle &larr; NIL;     windowHandle: PUBLIC Window.Handle &larr; NIL;     FSFileName: LONG STRING &larr;          "[Host:]&lt;Directory&gt;&lt;SubDirectory&gt;FileName.sysout"L;     IFSFileName: LONG STRING &larr;          "[Host]&lt;Directory&gt;&lt;SubDirectory&gt;FileName.sysout"L;     FloppyFileName: LONG STRING &larr; "Lisp.sysout"L;     active: BOOLEAN &larr; FALSE;     &lt;&lt;     agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[          CheckDeactivate];	&gt;&gt;     Graphic: TYPE = ARRAY [0..16) OF WORD;     formDisplay: ToolWindow.DisplayProcType &larr; NIL;     indicatorBox: Window.Box = [[10, 10], [16, 16]];     volume: Volume.ID &larr; Volume.nullID;     CheckDeactivate: Supervisor.AgentProcedure =          BEGIN          ENABLE UNWIND =&gt; NULL;          IF event = EventTypes.deactivate AND ILT.windowHandle # NIL               AND ILT.windowHandle = eventData AND ILT.toolData.busy THEN               BEGIN               Put.Line[                    ILT.toolData.msgSW,                    "The tool is busy:  aborting deactivation"L];               ERROR Supervisor.EnumerationAborted;               END;          END;  --CheckDeactivate     ClearCommandSubwindow: PUBLIC PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL &larr; 0, i + 1 UNTIL               (item &larr; FormSW.FindItem[ILT.toolData.commandSW, i]) = NIL DO               item.flags.invisible &larr; TRUE ENDLOOP;          FormSW.Display[ILT.toolData.commandSW];          ILT.toolData.indicator &larr; left;          --formDisplay &larr; Window.GetDisplayProc[ILT.toolData.commandSW];          formDisplay &larr; Window.SetDisplayProc[ILT.toolData.commandSW, DisplayEmpty];          END;  --ClearCommandSubwindow     ClearFileSubwindow: PUBLIC PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL &larr; 0, i + 1 UNTIL               (item &larr; FormSW.FindItem[ILT.toolData.fileSW, i]) = NIL DO               item.flags.invisible &larr; TRUE ENDLOOP;          FormSW.Display[ILT.toolData.fileSW];          --formDisplay &larr; Window.GetDisplayProc[ILT.toolData.fileSW];          END;  --ClearFileSubwindow     ClearMsgSubwindow: PUBLIC PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL &larr; 0, i + 1 UNTIL               (item &larr; FormSW.FindItem[ILT.toolData.msgSW, i]) = NIL DO               item.flags.invisible &larr; TRUE ENDLOOP;          FormSW.Display[ILT.toolData.msgSW];          --formDisplay &larr; Window.GetDisplayProc[ILT.toolData.msgSW];          END;  --ClearMsgSubwindow     ClearSubWindows: PROCEDURE =          BEGIN          --ClearFileSubwindow;          ClearMsgSubwindow;          END;  --ClearSubWindows     ClientTransition: ToolWindow.TransitionProcType =          -- This procedure is called whenever the system determines that this          -- Tool's state is undergoing a user invoked transition.          -- In this Example we demonstrate a technique that minimizes the memory          -- requirements for a Tool that is inactive.          BEGIN          SELECT TRUE FROM               old = inactive =&gt;                    BEGIN                    IF ILT.toolData = NIL THEN                         ILT.toolData &larr; Heap.systemZone.NEW[ILT.Data &larr; []];                    ProcessUserDotCM[];                    active &larr; TRUE;                    END;               new = inactive =&gt;                    BEGIN                    &lt;&lt;Supervisor.RemoveDependency[                        client: agent, implementor: Event.toolWindow];			&gt;&gt;                    IF ILT.toolData # NIL THEN                         BEGIN                         FormSW.Destroy[ILT.toolData.paramSW];                         FormSW.Destroy[ILT.toolData.commandSW];                         Heap.systemZone.FREE[@ILT.toolData];                         END;                    --ToolDriver.RemoveSWs[tool: "LispTool"L];                    active &larr; FALSE;                    END;               ENDCASE          END;       Confirm: PUBLIC PROCEDURE RETURNS [okay: BOOLEAN] =          BEGIN          Cursor.Set[mouseRed];          [, okay] &larr; UserInput.WaitForConfirmation[];          Cursor.Set[textPointer];          UserInput.WaitNoButtons[];          END;       DisplayCommandSubwindow: PUBLIC PROCEDURE =          BEGIN OPEN FormSW;          item: FormSW.ItemHandle;          ILT.toolData.indicator &larr; off;          [] &larr; Window.SetDisplayProc[ILT.toolData.commandSW, formDisplay];          FormSW.Display[ILT.toolData.commandSW];          FOR i: CARDINAL &larr; 0, i + 1 UNTIL               (item &larr; FormSW.FindItem[ILT.toolData.commandSW, i]) = NIL DO               item.flags.invisible &larr; FALSE ENDLOOP;          FormSW.Display[ILT.toolData.commandSW];          END;      DisplayEmpty: PUBLIC ToolWindow.DisplayProcType =          BEGIN          ENABLE UNWIND =&gt; NULL;          IF ~ILT.toolData.busy THEN RETURN;          --Display.White[window, [[0, 0], window.GetBox[].dims]];          DisplayIndicator[window];          END;       DisplayFile: PUBLIC PROCEDURE[] =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "DisplayFile...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          IF ILT.toolData.fileServer = IFS THEN               ILT.toolData.filePathName &larr; String.CopyToNewString[                    s: IFSFileName, z: Heap.systemZone]          ELSE               IF ILT.toolData.fileServer = FS THEN                    ILT.toolData.filePathName &larr; String.CopyToNewString[                         s: FSFileName, z: Heap.systemZone]               ELSE                    ILT.toolData.filePathName &larr; String.CopyToNewString[                         s: FloppyFileName, z: Heap.systemZone];          FormSW.DisplayItem[ILT.toolData.paramSW, 3];          END;       DisplayFileSize: PUBLIC PROCEDURE [size: File.PageCount] =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "DisplayFileSize...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          ILT.toolData.vMemSize &larr; size;          IF debug THEN {               Put.LongDecimal[ILT.toolData.fileSW, ILT.toolData.vMemSize];               Process.Pause[Process.SecondsToTicks[5]];               };          FormSW.DisplayItem[ILT.toolData.paramSW, 2];          END;     &lt;&lt;     DisplayIndicator: ToolWindow.DisplayProcType =          BEGIN          pattern: ARRAY [0..1] OF ARRAY [0..8) OF WORD;          left: WORD = 177400B;          right: WORD = 000377B;          SELECT ILT.toolData.indicator FROM               left =&gt;                    BEGIN                    pattern &larr; [ALL[left], ALL[right]];                    Display.Bitmap[                         window: window, box: indicatorBox,                         address: [word: @pattern, bit: 0], bitmapBitWidth: 16];                    END;               right =&gt;                    BEGIN                    pattern &larr; [ALL[right], ALL[left]];                    Display.Bitmap[                         window: window, box: indicatorBox,                         address: [word: @pattern, bit: 0], bitmapBitWidth: 16];                    END;               ENDCASE;          END;  --DisplayIndicator&gt;&gt;     --taken from StarFileTool     DisplayIndicator: PUBLIC ToolWindow.DisplayProcType =          BEGIN          pattern: Graphic;          SELECT ILT.toolData.indicator FROM               left =&gt; {pattern &larr; twiddleLeft; };               off, right =&gt; {pattern &larr; pattern &larr; twiddleRight; };               ENDCASE;          Display.Bitmap[               window, indicatorBox, [@pattern, , 0], 16, Display.replaceFlags];          END;  --DisplayIndicator     DisplayVolAttributes: PROCEDURE[] =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "DisplayVolAttributes...."L];               Process.Pause[Process.SecondsToTicks[10]];               };          [] &larr; GetVolAttributes[];          FormSW.DisplayItem[ILT.toolData.paramSW, 5];          FormSW.DisplayItem[ILT.toolData.paramSW, 6];          END;     DoInstall: UserInput.PeriodicProcType =          BEGIN	  file: File.File;	            ClearSubWindows;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Start Install ....."L];               Process.Pause[Process.SecondsToTicks[5]];               };          PutVolumeName[];          IF Confirm[] THEN               BEGIN	       volumeID: Volume.ID &larr; Volume.nullID;	                      ILT.LoginProc[];               ClearCommandSubwindow;               DisplayIndicator[ILT.toolData.commandSW];               ILT.toolData.busy &larr; TRUE;               IF ILT.toolData.fileServer = IFS OR ILT.toolData.fileServer = FS THEN                    ILT.InstallProc[ILT.toolData.volName]               ELSE {	       	     Put.Line[ILT.toolData.fileSW, "To be implemented...."L];		     --[volumeID, file] &larr; ILT.GetBootFile[ILT.toolData.volName];		     IF ILT.FloppyReadSysout[ILT.toolData.filePathName] THEN ILT.SetupBootFile[volumeID];		     };               ILT.toolData.busy &larr; FALSE;               DisplayCommandSubwindow;	       DisplayVolAttributes[];               END;          END;       FormSWBoot: FormSW.ProcType =          BEGIN	  	  sysoutThreshold: CARDINAL &larr; 1000;          ts: System.Switches;          volumeID: Volume.ID;          volumeOpen: BOOLEAN &larr; FALSE;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FormSWBoot...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          --ClearSubWindows;          PutVolumeName[];          IF Confirm[] THEN {               IF ILT.toolData.vMemSize &gt; sysoutThreshold THEN  -- some arbitrary no. for lisp sysout size                    {                    IF ILT.SetVolumeProc[ILT.toolData.volName] THEN                         TemporaryBooting.BootButton[];                    }               ELSE {  -- non-lisp volumes                    IF String.Equivalent[ILT.toolData.volName, "SystemTools"] THEN {                         IF ~String.Equivalent[ILT.toolData.userPassword, "n0way!"L] THEN {			      Put.Line[ILT.toolData.fileSW, "Feature disabled."L];                              GOTO exit;			      };                         };                    [volumeID, volumeOpen] &larr; ILT.GetVolumeID[ILT.toolData.volName];                    IF volumeOpen THEN {                         ts &larr; OthelloOps.DecodeSwitches["N"L 			 	! OthelloOps.BadSwitches =&gt; {					Put.Line[ILT.toolData.fileSW, "BadSwitches...."L];					GOTO exit;				};];                        TemporaryBooting.BootFromVolume[volumeID, ts];                         };                    };               EXITS exit =&gt; NULL;               };          END;       FormSWCopyVMem: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FormSWCopyVMem...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          ILT.BootStuff[];          END;     FormSWEraseProc: FormSW.ProcType =          BEGIN          ILT.toolData.busy &larr; TRUE;          ClearSubWindows;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Start Erase Proc....."L];               Process.Pause[Process.SecondsToTicks[5]];               };          PutVolumeName[];          IF Confirm[] THEN               BEGIN               ILT.EraseProc[ILT.toolData.volName];               ILT.toolData.vMemSize &larr; 0;               ILT.SetVMemFileSize[0];               DisplayFileSize[0];               END;          DisplayVolAttributes[];          ILT.toolData.busy &larr; FALSE;          END;     FormSWFloppyProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FormSWFloppyDup...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Put.Line[ILT.toolData.fileSW, "To Be Implemented."L];          --ILT.FloppyStuff[];          END;     FormSWHelpProc: FormSW.ProcType =          BEGIN          ILT.toolData.busy &larr; TRUE;          ClearSubWindows;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FormSWHelpProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          ILT.DisplayWriteUp;          ILT.toolData.busy &larr; FALSE;          END;     FormSWInstallProc: FormSW.ProcType =          BEGIN          [] &larr; UserInput.CreatePeriodicNotify[               proc: DoInstall, window: sw, rate: 0];          END;     FormSWLoginProc: FormSW.ProcType =          BEGIN          ILT.toolData.busy &larr; TRUE;          ClearSubWindows;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Start Login Proc....."L];               Process.Pause[Process.SecondsToTicks[5]];               };          ILT.LoginProc[];          ILT.toolData.busy &larr; FALSE;          END;     FormSWMakeScript: FormSW.ProcType =          BEGIN          ILT.toolData.busy &larr; TRUE;          ClearSubWindows;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Start MakeScript....."L];               Process.Pause[Process.SecondsToTicks[5]];               };          --Put.Line[ILT.toolData.fileSW, "To be implemented..."L];               ILT.MakeScript[];          ILT.toolData.busy &larr; FALSE;          END;     FormSWQuitProc: FormSW.ProcType =          BEGIN          --v: Volume.ID;          all: Volume.TypeSet = [               normal: TRUE, debugger: TRUE, debuggerDebugger: TRUE];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Quit Proc..."L];               --Process.Pause[Process.SecondsToTicks[5]];               };          [] &larr; ToolWindow.Deactivate[windowHandle];          --FOR v &larr; Volume.GetNext[Volume.nullID, all], Volume.GetNext[v, all] WHILE          -- v ~= Volume.systemID DO ENDLOOP;          --UserInput.ClearInputFocusOnMatch[windowHandle];          --TemporaryBooting.BootFromVolume[v];          END;      FormSWRemoteList: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FormSWRemoteList...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Put.Line[ILT.toolData.fileSW, "To be implemented...."L];          END;       FormSWScavengeProc: FormSW.ProcType =          BEGIN          ILT.toolData.busy &larr; TRUE;          ClearSubWindows;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Scavenge Proc..."L];               --Process.Pause[Process.SecondsToTicks[5]];               };          PutVolumeName[];          IF Confirm[] THEN ILT.ScavengeProc[ILT.toolData.volName];          ILT.toolData.busy &larr; FALSE;          END;       FormSWSetFileSize: FormSW.ProcType =          BEGIN          ILT.toolData.busy &larr; TRUE;          ClearSubWindows;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Start SetFileSize....."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Put.Text[ILT.toolData.fileSW, "VMem size = "L];          Put.LongDecimal[ILT.toolData.fileSW, ILT.toolData.vMemSize];          Put.CR[ILT.toolData.fileSW];          IF Confirm[] THEN ILT.SetVMemFileSize[ILT.toolData.vMemSize];          DisplayVolAttributes[];          ILT.toolData.busy &larr; FALSE;          END;       FormSWSetProc: FormSW.ProcType =          BEGIN          ILT.toolData.busy &larr; TRUE;          ClearSubWindows;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "SetVolume Proc..."L];               --Process.Pause[Process.SecondsToTicks[5]];               };          PutVolumeName[];          IF Confirm[] THEN [] &larr; ILT.SetVolumeProc[ILT.toolData.volName];          ILT.toolData.busy &larr; FALSE;          END;     FormSWVolHintsProc: FormSW.MenuProcType =          BEGIN          RETURN[               hints: DESCRIPTOR[               @ILT.toolData.volHints[0], ILT.toolData.volHints.length],                    freeHintsProc: HintsNoLongerBusy, replace: TRUE];          END;     GetUser: PROCEDURE [name, password: LONG STRING] =          BEGIN          z: UNCOUNTED ZONE = Heap.systemZone;          ILT.toolData.userName &larr; String.CopyToNewString[name, z];          ILT.toolData.userPassword &larr; String.CopyToNewString[password, z]          END;      GetDefaultDomain: PROCEDURE [domain: LONG STRING] =          BEGIN          z: UNCOUNTED ZONE = Heap.systemZone;          ILT.toolData.domainName &larr; String.CopyToNewString[domain, z]          END;       GetDefaultOrganization: PROCEDURE [organization: LONG STRING] =          BEGIN          z: UNCOUNTED ZONE = Heap.systemZone;          ILT.toolData.organizationName &larr; String.CopyToNewString[organization, z]          END;      GetProfileInfo: PROCEDURE =          BEGIN          --Profile.GetUser[GetUser];          Profile.GetDefaultDomain[GetDefaultDomain];          Profile.GetDefaultOrganization[GetDefaultOrganization];          --Profile.GetDefaultRegistry[GetDefaultRegistry];          --Profile.GetLibrarianNames[GetLibrarianNames];          --Profile.GetLibrarian[GetLibrarian]          END;      GetVolAttributes: PUBLIC PROCEDURE[] RETURNS [BOOLEAN] =          BEGIN           volumeID: Volume.ID &larr; Volume.nullID;          volumeOpen: BOOLEAN &larr; FALSE;          [volumeID, volumeOpen] &larr; ILT.GetVolumeID[ILT.toolData.volName];          IF volumeID = Volume.nullID THEN RETURN[FALSE];          [ILT.toolData.currentVolSize, ILT.toolData.currentVolFreeSize] &larr;               Volume.GetAttributes[volumeID];          IF debug THEN {               Put.Text[ILT.toolData.fileSW, " \n Source Volume size = "L];               Put.LongDecimal[ILT.toolData.fileSW, ILT.toolData.currentVolSize];               Put.Line[ILT.toolData.fileSW, " pages"L];               Put.Text[ILT.toolData.fileSW, " Free pages on source volume = "L];               Put.LongDecimal[ILT.toolData.fileSW, ILT.toolData.currentVolFreeSize];               Put.CR[ILT.toolData.fileSW];               Process.Pause[Process.SecondsToTicks[10]];               };          RETURN[TRUE];          END;      HintsNoLongerBusy: FormSW.FreeHintsProcType =          BEGIN          size: File.PageCount;	            ClearMsgSubwindow;          size &larr; ILT.GetFileSize[];          DisplayFileSize[size];          ILT.toolData.busy &larr; FALSE;          DisplayVolAttributes[];          END;      Init: PROCEDURE =          BEGIN          --h: Exec.Handle;          --execWrite: Format.StringProc &larr; Exec.OutputProc[h];          --execWrite["Creating tool window.."L];           --Process.Pause[Process.SecondsToTicks[5]];          Exec.AddCommand["LispTool.~"L, LispTool, Unload];          END;      &lt;&lt;InvertIndicator: FileTransfer.ClientProc =          BEGIN          ENABLE UNWIND =&gt; NULL;          IF ~ILT.toolData.busy THEN RETURN;          SELECT ILT.toolData.indicator FROM               left =&gt; ILT.toolData.indicator &larr; right;               off, right =&gt; ILT.toolData.indicator &larr; left;               ENDCASE;          Display.Invert[ILT.toolData.commandSW, indicatorBox];          END;  --InvertIndicator	  &gt;&gt;     --taken from StarFileTool with author's permission     InvertIndicator: PUBLIC PROC[] =          BEGIN          ENABLE UNWIND =&gt; NULL;          pattern: Graphic;          IF ~ILT.toolData.busy THEN RETURN;          SELECT ILT.toolData.indicator FROM               left =&gt; {ILT.toolData.indicator &larr; right; pattern &larr; twiddleRight; };               off, right =&gt; {ILT.toolData.indicator &larr; left; pattern &larr; twiddleLeft; };               ENDCASE;          Display.Bitmap[               ILT.toolData.commandSW, indicatorBox, [@pattern, , 0], 16,               Display.replaceFlags];          END;     ListLogicalVolumes: PUBLIC PROC RETURNS [nVols: CARDINAL] =          BEGIN          i: CARDINAL;          s: STRING &larr; [80];          v: Volume.ID;          all: Volume.TypeSet = [               normal: TRUE, debugger: TRUE, debuggerDebugger: TRUE];          IF ILT.toolData.volName # NIL THEN RETURN;          -- First, count the logical volumes.          nVols &larr; 0;          FOR v &larr; Volume.GetNext[Volume.nullID, all], Volume.GetNext[v, all] WHILE               v ~= Volume.nullID DO nVols &larr; nVols + 1; ENDLOOP;          -- Now build up the table          ILT.toolData.volHints &larr; Heap.systemZone.NEW[ILT .VolHints[nVols]];          FOR i IN [0..nVols) DO               v &larr; Volume.GetNext[v, all];               Volume.GetLabelString[v, s];               ILT.toolData.volHints[i] &larr; String.CopyToNewString[s, Heap.systemZone];               ENDLOOP;          END;      LispActivate: PUBLIC PROCEDURE =          BEGIN          IF ILT.SetVolumeProc["Lisp"L] THEN TemporaryBooting.BootButton[];          END;     LispTool: Exec.ExecProc =          BEGIN          execWrite: Format.StringProc &larr; Exec.OutputProc[h];          --execWrite["Creating tool window.."L];           --Process.Pause[Process.SecondsToTicks[5]];          IF (ILT.windowHandle # NIL) AND ~active THEN               ToolWindow.Activate[ILT.windowHandle]          ELSE ILT.windowHandle &larr; MakeTool[];          END;       LispToolActivate: PUBLIC PROCEDURE =          BEGIN          IF windowHandle = NIL THEN windowHandle &larr; MakeTool[];          ToolWindow.Activate[windowHandle];          Window.Stack[               windowHandle, Window.GetChild[Window.GetParent[windowHandle]]];  -- top me          Window.ValidateTree[];          END;     MakeCommands: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..6) OF CARDINAL &larr; [0, 15, 30, 45, 60, 75];          nItems: CARDINAL = 11;          items &larr; AllocateItemDescriptor[nItems];          items[0] &larr; CommandItem[               tag: "Install File"L, place: newLine, proc: FormSWInstallProc];          items[1] &larr; CommandItem[tag: "Boot"L, proc: FormSWBoot];          items[2] &larr; CommandItem[tag: "Erase"L, proc: FormSWEraseProc];          items[3] &larr; CommandItem[tag: "Set VMem"L, proc: FormSWSetFileSize];          items[4] &larr; CommandItem[tag: "Make Script"L, proc: FormSWMakeScript];          items[5] &larr; CommandItem[tag: "Help"L, proc: FormSWHelpProc];          items[6] &larr; CommandItem[               tag: "Remote List"L, place: newLine, proc: FormSWRemoteList];          items[7] &larr; CommandItem[tag: "Copy VMem"L, proc: FormSWCopyVMem];          items[8] &larr; CommandItem[tag: "Scavenge"L, proc: FormSWScavengeProc];          items[9] &larr; CommandItem[tag: "Floppy"L, proc: FormSWFloppyProc];          items[10] &larr; CommandItem[tag: "Quit"L, proc: FormSWQuitProc];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE];          END;  --MakeCommands     MakeParams: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          i, nVols: CARDINAL;          tabs: ARRAY [0..4) OF CARDINAL &larr; [0, 30, 60, 75];          nItems: CARDINAL = 11;          emptyString: LONG STRING &larr; NIL;          docForm: ARRAY [0..2) OF Enumerated &larr; [               ["General"L, ILT.DocType[general]], [               "ErrorMsg"L, ILT.DocType[errorMsg]]];          serverForm: ARRAY [0..3) OF Enumerated &larr; [               ["IFS"L, ILT.ServerType[IFS]], ["FS"L, ILT.ServerType[FS]], [               "FLOPPY"L, ILT.ServerType[FLOPPY]]];          volForm: ARRAY [0..2) OF Enumerated &larr; [               ["Lisp"L, ILT.VolType[Lisp]], ["NonLisp"L, ILT.VolType[NonLisp]]];          items &larr; AllocateItemDescriptor[nItems];          nVols &larr; ListLogicalVolumes[];          String.Copy[ILT.toolData.volName, ILT.toolData.volHints[0]];          FOR i IN [0..nVols) DO               IF String.Equivalent[ILT.toolData.volHints[i], "Lisp"L] THEN                    BEGIN                    String.Replace[                         @ILT.toolData.volName, ILT.toolData.volHints[i], Heap.systemZone];                    EXIT;                    END;               ENDLOOP;          items[0] &larr; EnumeratedItem[               tag: "Document"L, place: newLine, z: Heap.systemZone, feedback: all,               value: @ILT.toolData.docType, copyChoices: TRUE,               choices: DESCRIPTOR[docForm]];          items[1] &larr; EnumeratedItem[               tag: "Device"L, z: Heap.systemZone, feedback: all,               value: @ILT.toolData.fileServer, copyChoices: TRUE,               proc: ServerNotifyProc, choices: DESCRIPTOR[serverForm]];          items[2] &larr; NumberItem[tag: "VMem Size"L, value: @ILT.toolData.vMemSize];          items[3] &larr; StringItem[               tag: "File"L, place: newLine, string: @ILT.toolData.filePathName,               inHeap: TRUE];          items[4] &larr; StringItem[               tag: "Volume Menu"L, place: newLine, string: @ILT.toolData.volName,               inHeap: TRUE, menuProc: FormSWVolHintsProc];          items[5] &larr; NumberItem[               tag: "Volume Size"L, value: @ILT.toolData.currentVolSize];          items[6] &larr; NumberItem[               tag: "Free Size"L, value: @ILT.toolData.currentVolFreeSize];          items[7] &larr; StringItem[               tag: "User"L, place: newLine, string: @ILT.toolData.userName,               inHeap: TRUE];          items[8] &larr; StringItem[               tag: "Password"L, string: @ILT.toolData.userPassword, inHeap: TRUE,               feedback: password];          items[9] &larr; StringItem[               tag: "Domain"L, place: newLine, string: @ILT.toolData.domainName,               inHeap: TRUE];          items[10] &larr; StringItem[               tag: "Organization"L, string: @ILT.toolData.organizationName,               inHeap: TRUE];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE]          END;  --MakeParams     MakeSWs: Tool.MakeSWsProc =          BEGIN          size: File.PageCount;          logName: STRING &larr; [40];          addresses: ARRAY [0..4) OF ToolDriver.Address;          Tool.UnusedLogName[unused: logName, root: "LispTool.log"L];          ILT.toolData.msgSW &larr; Tool.MakeMsgSW[window: window, lines: 5];          ILT.toolData.paramSW &larr; Tool.MakeFormSW[               window: window, formProc: MakeParams];          ILT.toolData.commandSW &larr; Tool.MakeFormSW[               window: window, formProc: MakeCommands];          ILT.toolData.fileSW &larr; Tool.MakeFileSW[window: window, name: logName];	  size &larr; ILT.GetFileSize[];	  DisplayFileSize[size];          DisplayFile[];          DisplayVolAttributes[];          --Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];          -- do the ToolDriver stuff          addresses &larr; [               [name: "msgSW"L, sw: ILT.toolData.msgSW],               --[name: "formSW"L, sw: ILT.toolData.formSW],               [name: "ParamSW"L, sw: ILT.toolData.paramSW], [               name: "CmdSW"L, sw: ILT.toolData.commandSW], [               name: "fileSW"L, sw: ILT.toolData.fileSW]];          ToolDriver.NoteSWs[tool: "LispTool"L, subwindows: DESCRIPTOR[addresses]];          END;  --MakeSWs     MakeTool: PROCEDURE RETURNS [wh: Window.Handle] =          BEGIN          heraldName: STRING &larr; [80];          String.AppendString[heraldName, "XEROX AISBU: System Tools"L];          String.AppendString[heraldName, " of "L];          Time.Append[heraldName, Time.Unpack[Runtime.GetBcdTime[]]];          heraldName.length &larr; heraldName.length - 3;  -- gun the seconds          --String.AppendString[heraldName, " on Pilot Version "L];          --Version.Append[heraldName];          RETURN[               Tool.Create[                    makeSWsProc: MakeSWs, initialState: default,                    clientTransition: ClientTransition, name: heraldName,                    initialBox: [[0, 0], [1024, 800]], 		    --x, y, width, height		    tinyName1: "System"L,                    tinyName2: "Tools"L]]          END;  --MakeTool     PutVolumeName: PROCEDURE[] =          BEGIN          Put.Text[ILT.toolData.fileSW, "Volume = "L];          Put.LongString[ILT.toolData.fileSW, ILT.toolData.volName];          Put.CR[ILT.toolData.fileSW];          END;       -- move to profile     ProcessUserDotCM: PROCEDURE =          BEGIN          CMOption: TYPE = MACHINE DEPENDENT{               Domain, User, Password, FSFile, IFSFile, FloppyFile, Protocol, Org,               noMatch(StringLookUp.noMatch)};          DefinedOption: TYPE = CMOption [Domain..Org];          cmOptionTable: ARRAY DefinedOption OF LONG STRING &larr; [               Domain: "Domain"L, User: "User"L, Password: "Password"L,               Org: "Organization"L, FSFile: "NSLisp", IFSFile: "PUPLisp",               FloppyFile: "FloppyLisp", Protocol: "FileServer"L];          cmIndex: CMOption;          CheckType: PROCEDURE [h: CmFile.Handle, table: StringLookUp.TableDesc]               RETURNS [index: CARDINAL] = CmFile.NextValue;          MyNextValue: PROCEDURE [               h: CmFile.Handle,               table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]               RETURNS [index: CMOption] = LOOPHOLE[CheckType];          cmFile: CmFile.Handle &larr; CmFile.UserDotCmOpen[               ! CmFile.Error =&gt; IF code = fileNotFound THEN GOTO return];          IF CmFile.FindSection[cmFile, "System"L] THEN               DO                    SELECT                    (cmIndex &larr; MyNextValue[                         h: cmFile, table: DESCRIPTOR[cmOptionTable] !                         CmFile.TableError =&gt; RESUME ]) FROM                         noMatch =&gt; EXIT;                         User =&gt;                              BEGIN                              value: LONG STRING = Token.Item[cmFile];                              ILT.toolData.userName &larr; String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] &larr; Token.FreeTokenString[value];                              END;                         Password =&gt;                              BEGIN                              value: LONG STRING = Token.Item[cmFile];                              ILT.toolData.userPassword &larr; String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] &larr; Token.FreeTokenString[value];                              END;                         FSFile =&gt;                              BEGIN                              value: LONG STRING &larr; Token.Item[cmFile];                              --String.Copy[FSFileName, value];			      FSFileName &larr; String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] &larr; Token.FreeTokenString[value];                              END;                         IFSFile =&gt;                              BEGIN                              value: LONG STRING &larr; Token.Item[cmFile];                              IFSFileName &larr; String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] &larr; Token.FreeTokenString[value];                              END;                         FloppyFile =&gt;                              BEGIN                              value: LONG STRING &larr; Token.Item[cmFile];                              FloppyFileName &larr; String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] &larr; Token.FreeTokenString[value];                              END;                         Protocol =&gt;                              BEGIN                              value: LONG STRING &larr; Token.Item[cmFile];                              Put.Line[ILT.toolData.fileSW, value];                              IF String.Equivalent[value, "FS"] THEN                                   ILT.toolData.fileServer &larr; FS                              ELSE ILT.toolData.fileServer &larr; IFS;                              [] &larr; Token.FreeTokenString[value];                              END;                         ENDCASE;                    ENDLOOP;          GetProfileInfo[];          [] &larr; CmFile.Close[cmFile];          EXITS return =&gt; NULL;          END;      ServerNotifyProc: FormSW.EnumeratedNotifyProcType =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "ServerNotifyProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          DisplayFile[];          END;       TajoActivate: PUBLIC PROCEDURE =          BEGIN OPEN OthelloOps, OthelloDefs;	  --BEGIN          ts: System.Switches;          volumeID: Volume.ID;          volumeOpen: BOOLEAN &larr; FALSE;		  debug &larr; FALSE;          [volumeID, volumeOpen] &larr; ILT.GetVolumeID["User"L];          IF volumeOpen THEN {               --ts &larr; OthelloOps.DecodeSwitches["N"];	       ts &larr; DecodeSwitches["N"];               TemporaryBooting.BootFromVolume[volumeID, ts];               };          END;       Unload: Exec.ExecProc =          BEGIN          IF ILT.windowHandle # NIL THEN Tool.Destroy[ILT.windowHandle];          ILT.windowHandle &larr; NIL;          [] &larr; Exec.RemoveCommand[h, "LispTool.~"L];          END;       -- Mainline code     Init[];     END...LispToolImpl</pre>
  </body>
</html>
