<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>SystemTools>LTEraseImpl.mesa!1</title>
  </head>
  <body>
    <pre>
--LTEraseImpl.mesa--Created by--   JFung.PASA	  	19-Sep-83 17:06:11--last edited by--   JFung.PASA	   	27-Jul-84 10:37:25DIRECTORY     Cursor USING [Set],     LispToolOps,     Process USING [Pause, SecondsToTicks],     Put USING [CR, Line, LongString, Text],     String USING [EquivalentString],     Volume;LTEraseImpl: PROGRAM     IMPORTS          Cursor, LispToolOps, Process, Put, String, Volume	       EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;          debug: BOOLEAN &larr; FALSE;--toolData: PUBLIC ILT.DataHandle &larr; NIL;--Warning: Item 0 in interface LispToolOps is a duplicate export (in LTEraseImpl), at LispInstallationTool[1622]     EraseProc: PUBLIC PROCEDURE [vName: LONG STRING] =          BEGIN          volumeID: Volume.ID &larr; Volume.nullID;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Enter EraseProc..."L];               Process.Pause[Process.SecondsToTicks[10]];               Put.LongString[ILT.toolData.fileSW, vName];               Put.CR[ILT.toolData.fileSW];               };          [volumeID, ] &larr; ILT.GetVolumeID[vName];          IF debug THEN Put.Text[ILT.toolData.fileSW, "Volume = "L];          IF volumeID = Volume.nullID THEN               BEGIN               IF debug THEN Put.Line[ILT.toolData.fileSW, "Null ID"L];               RETURN;               END;          Put.Text[ILT.toolData.fileSW, " Erasing... "L];	  Cursor.Set[hourGlass];          Volume.Erase[volumeID];	  Cursor.Set[textPointer];          Put.Line[ILT.toolData.fileSW, " Done"L];          END;     GetVolumeID: PUBLIC PROCEDURE [volumeName: LONG STRING]          RETURNS [volumeID: Volume.ID &larr; Volume.nullID, volumeOpen: BOOLEAN] =          BEGIN OPEN Volume;          myType: Volume.Type = Volume.GetType[Volume.systemID];          &lt;&lt;all: Volume.TypeSet &larr; [               normal: TRUE,               debugger: myType = debugger OR myType = debuggerDebugger,               debuggerDebugger: myType = debuggerDebugger];	       &gt;&gt;	       	  all: Volume.TypeSet &larr; [               normal: TRUE,               --debugger: TRUE,	       debugger: myType = debugger OR myType = debuggerDebugger,               --debuggerDebugger: TRUE,	       debuggerDebugger: myType = debuggerDebugger,	       nonPilot: TRUE];               name: STRING = [maxNameLength];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Enter GetVolume..."L];               Process.Pause[Process.SecondsToTicks[5]];               Put.LongString[ILT.toolData.fileSW, volumeName];               Put.CR[ILT.toolData.fileSW];               };          volumeOpen &larr; FALSE;          FOR volumeID &larr; GetNext[Volume.nullID, all], GetNext[volumeID, all] WHILE               volumeID ~= Volume.nullID DO               name.length &larr; 0;               Volume.GetLabelString[volumeID, name];	       IF debug THEN {	      	 Put.Line[ILT.toolData.fileSW, name];	       	 Put.Line[ILT.toolData.fileSW, volumeName];		 Process.Pause[Process.SecondsToTicks[5]];		 };               IF String.EquivalentString[name, volumeName] THEN EXIT;               ENDLOOP;          SELECT volumeID FROM               nullID =&gt;                    BEGIN                    Put.LongString[ILT.toolData.msgSW, volumeName];                    --Process.Pause[Process.SecondsToTicks[5]];                    Put.Line[ILT.toolData.msgSW, " volume not found!"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    RETURN;                    END;               Volume.systemID =&gt;                    BEGIN		    &lt;&lt;                    Put.LongString[ILT.toolData.fileSW, volumeName];                    Put.Line[ILT.toolData.fileSW, " is your system volume!"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    --RETURN;		    &gt;&gt;                    END;               ENDCASE;	  IF debug THEN {	      	 Put.Line[ILT.toolData.fileSW, "Volume.Open"L];		 Process.Pause[Process.SecondsToTicks[5]];		 };	       	Volume.Open[               volume: volumeID !               Volume.NeedsScavenging =&gt; GOTO BadVolume];	       	                 volumeOpen &larr; TRUE;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "volume opened!"L];               Process.Pause[Process.SecondsToTicks[5]];               };          RETURN[volumeID, volumeOpen];          EXITS               BadVolume =&gt;                    BEGIN                    Put.Line[ILT.toolData.msgSW, "Can not open volume "L];                    Put.LongString[ILT.toolData.fileSW, volumeName];                    Put.Line[ILT.toolData.fileSW, " needs scavenging."L];                    Process.Pause[Process.SecondsToTicks[10]];                    END;          END;     END...  </pre>
  </body>
</html>
