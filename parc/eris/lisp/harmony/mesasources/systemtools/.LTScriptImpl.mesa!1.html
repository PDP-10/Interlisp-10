<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>SystemTools>LTScriptImpl.mesa!1</title>
  </head>
  <body>
    <pre>
--LTScriptImpl.mesa--limited tool to write prometheus script --Created by--   JFung.PASA	  	22-May-84 13:16:54--last edited by--   JFung.PASA	   	 6-Sep-84 10:19:48 DIRECTORY     Cursor,     EventTypes,     Exec,     File,     Format,     FormSW,     Heap,     LispToolOps,     MFile,     MStream,     Process,     Profile,     Put,     Runtime,     Stream,     String,     StringLookUp,     Supervisor,     Time,     Token,     Tool,     ToolDriver,     ToolWindow,     UserInput,     Version,     Volume,     Window;LTScriptImpl: PROGRAM     IMPORTS          Cursor, FormSW, Heap, LispToolOps, MFile, MStream, Process, Put,          Runtime, Stream, String, Time, Tool, ToolDriver, Window     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;     SA1000Size: LONG CARDINAL = 16188;     SA4000Size: LONG CARDINAL = 44797;     Q2040Size:  LONG CARDINAL = 65274;     DiskType: TYPE = {SA1000, SA4000, Q2040};     DataHandle: TYPE = LONG POINTER TO Data;     Data: TYPE = MACHINE DEPENDENT RECORD [          -- Message subwindow stuff          msgSW(0): Window.Handle &larr; NIL,          -- File subwindow stuff          fileSW(2): Window.Handle &larr; NIL,          -- Form subwindow stuff          -- Note: enumerateds and booleans must be word boundary          -- aligned as addresses for them must be generated          --formSW: Window.Handle &larr; NIL,          paramSW(4): Window.Handle &larr; NIL,          commandSW(6): Window.Handle &larr; NIL,          busy(8): BOOLEAN &larr; FALSE,  -- command is running          vol1Name(9): LONG STRING &larr; NIL,          vol2Name(11): LONG STRING &larr; NIL,          vol3Name(13): LONG STRING &larr; NIL,          vol4Name(15): LONG STRING &larr; NIL,          vol5Name(17): LONG STRING &larr; NIL,          vol6Name(19): LONG STRING &larr; NIL,          vol1Size(21): CARDINAL &larr; 3500,          vol2Size(22): LONG CARDINAL &larr; 0,          vol3Size(24): LONG CARDINAL &larr; 0,          vol4Size(26): LONG CARDINAL &larr; 0,          vol5Size(28): LONG CARDINAL &larr; 0,          vol6Size(30): LONG CARDINAL &larr; 0,	  vol7Name(32): LONG STRING &larr; NIL,          vol8Name(34): LONG STRING &larr; NIL,          vol9Name(36): LONG STRING &larr; NIL,	  vol10Name(38): LONG STRING &larr; NIL,          vol7Size(40): LONG CARDINAL &larr; 0,          vol8Size(42): LONG CARDINAL &larr; 0,          vol9Size(44): LONG CARDINAL &larr; 0,          vol10Size(46): LONG CARDINAL &larr; 0,          driveSize(48): LONG CARDINAL &larr; Q2040Size,          freePages(50): LONG CARDINAL &larr; Q2040Size - 3500,          diskType(52): DiskType &larr; Q2040];     active: BOOLEAN &larr; FALSE;     debug: BOOLEAN &larr; FALSE;     diagName: LONG STRING &larr; "SystemTools"L;     formDisplay: ToolWindow.DisplayProcType &larr; NIL;               myFile: MFile.Handle &larr; NIL;     nVols: INTEGER &larr; 1;     scriptWH: Window.Handle &larr; NIL;     toolData: DataHandle &larr; NIL;&lt;&lt;     ClearFileSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL &larr; 0, i + 1 UNTIL               (item &larr; FormSW.FindItem[toolData.fileSW, i]) = NIL DO               item.flags.invisible &larr; TRUE ENDLOOP;          FormSW.Display[toolData.fileSW];          formDisplay &larr; Window.GetDisplayProc[toolData.fileSW];          END;&gt;&gt;     ClearMsgSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL &larr; 0, i + 1 UNTIL               (item &larr; FormSW.FindItem[toolData.msgSW, i]) = NIL DO               item.flags.invisible &larr; TRUE ENDLOOP;          FormSW.Display[toolData.msgSW];          formDisplay &larr; Window.GetDisplayProc[toolData.msgSW];          END;     ClearSubWindows: PROCEDURE =          BEGIN          --ClearFileSubwindow;          ClearMsgSubwindow;          END;     &lt;&lt;     ClientTransition: ToolWindow.TransitionProcType =          -- This procedure is called whenever the system determines that this          -- Tool's state is undergoing a user invoked transition.          -- In this Example we demonstrate a technique that minimizes the memory          -- requirements for a Tool that is inactive.          BEGIN          SELECT TRUE FROM               old = inactive =&gt;                    BEGIN                    IF toolData = NIL THEN                         toolData &larr; Heap.systemZone.NEW[Data &larr; []];                    active &larr; TRUE;                    END;               new = inactive =&gt;                    BEGIN                    &lt;&lt;Supervisor.RemoveDependency[                        client: agent, implementor: Event.toolWindow];			&gt;&gt;                    IF toolData # NIL THEN                         BEGIN                         FormSW.Destroy[toolData.paramSW];                         FormSW.Destroy[toolData.commandSW];                         Heap.systemZone.FREE[@toolData];                         END;                    --ToolDriver.RemoveSWs[tool: "LispTool"L];                    active &larr; FALSE;                    END;               ENDCASE          END;  --ClientTransition&gt;&gt;       DataChanged: FormSW.ProcType =      BEGIN       END;         NumberChanged: FormSW.LongNumberNotifyProcType =      BEGIN        END;         FormSWMakeScript: FormSW.ProcType =          BEGIN          floppyFileName: LONG STRING &larr; "Prometheus.script"L;          toolData.busy &larr; TRUE;          ClearSubWindows;          Put.Line[               toolData.fileSW,               "WARNING: will DESTROY your old file, confirm to continue"L];          IF ILT.Confirm[] THEN {               Put.Line[                    toolData.fileSW,                    "Insert ""Installation Utility"" floppy, confirm when ready"L];               IF ILT.Confirm[] THEN 	            IF ILT.FloppyDelete[floppyFileName] THEN 		    IF WriteUserScript[] THEN {		    	ILT.FloppyWrite[floppyFileName];			Put.Line[toolData.fileSW, " Done"L];                	};	       };          toolData.busy &larr; FALSE;          END;     FormSWQuit: FormSW.ProcType =          BEGIN          --[] &larr; ToolWindow.Deactivate[scriptWH];          IF toolData # NIL THEN               BEGIN               --Put.Line[toolData.fileSW, "Tool.Destroy"L];               --Process.Pause[Process.SecondsToTicks[5]];               Tool.Destroy[scriptWH];               --Put.Line[toolData.fileSW, "Heap.systemZone.FREE"L];               --Process.Pause[Process.SecondsToTicks[5]];               Heap.systemZone.FREE[@toolData];               END;          END;     MakeCommands: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..3) OF CARDINAL &larr; [0, 30, 60];          nItems: CARDINAL = 2;          items &larr; AllocateItemDescriptor[nItems];          items[0] &larr; CommandItem[tag: "Make Script"L, proc: FormSWMakeScript, 	  	place: newLine];          items[1] &larr; CommandItem[tag: "Quit"L, proc: FormSWQuit];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE];          END;  --MakeCommands     MakeParams: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..7) OF CARDINAL &larr; [0, 28, 52, 56, 60, 68, 75];          nItems: CARDINAL = 23;          diskForm: ARRAY [0..3) OF Enumerated &larr; [               ["10Mb"L, DiskType[SA1000]], ["29Mb"L, DiskType[SA4000]], [               "42Mb"L, DiskType[Q2040]]];          items &larr; AllocateItemDescriptor[nItems];          items[0] &larr; EnumeratedItem[               tag: "DiskType"L, place: newLine, z: Heap.systemZone, feedback: all,               value: @toolData.diskType, copyChoices: TRUE,               proc: ServerNotifyProc, choices: DESCRIPTOR[diskForm]];	       -- note: compiler does not check if this is a "short"NumberItem	                 items[1] &larr; LongNumberItem[               tag: "Drive Size"L, value: @toolData.driveSize, readOnly: TRUE];          items[2] &larr; LongNumberItem[               tag: "Free Pages"L, value: @toolData.freePages];          items[3] &larr; StringItem[               tag: "Volume1"L, string: @toolData.vol1Name, 	       inHeap: TRUE, readOnly: TRUE, place: newLine];          items[4] &larr; NumberItem[               tag: "Volume1 Size"L, value: @toolData.vol1Size, readOnly: TRUE];          items[5] &larr; StringItem[               tag: "Volume2"L, string: @toolData.vol2Name, inHeap: TRUE,               place: newLine, filterProc: StringChanged];          items[6] &larr; LongNumberItem[               tag: "Volume2 Size"L, value: @toolData.vol2Size];          items[7] &larr; StringItem[               tag: "Volume3"L, string: @toolData.vol3Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[8] &larr; LongNumberItem[               tag: "Volume3 Size"L, value: @toolData.vol3Size];          items[9] &larr; StringItem[               tag: "Volume4"L, string: @toolData.vol4Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[10] &larr; LongNumberItem[               tag: "Volume4 Size"L, 	       --proc: NumberChanged,	       value: @toolData.vol4Size 	       ];                    items[11] &larr; StringItem[               tag: "Volume5"L, string: @toolData.vol5Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[12] &larr; LongNumberItem[               tag: "Volume5 Size"L, value: @toolData.vol5Size, proc: NumberChanged];          items[13] &larr; StringItem[               tag: "Volume6"L, string: @toolData.vol6Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[14] &larr; LongNumberItem[               tag: "Volume6 Size"L, value: @toolData.vol6Size, proc: NumberChanged];	       	  items[15] &larr; StringItem[               tag: "Volume7"L, string: @toolData.vol7Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[16] &larr; LongNumberItem[               tag: "Volume7 Size"L, value: @toolData.vol7Size, proc: NumberChanged];	          	  items[17] &larr; StringItem[               tag: "Volume8"L, string: @toolData.vol8Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[18] &larr; LongNumberItem[               tag: "Volume8 Size"L, value: @toolData.vol8Size, proc: NumberChanged];	       	           	  items[19] &larr; StringItem[               tag: "Volume9"L, string: @toolData.vol9Name, inHeap: TRUE,	       filterProc: StringChanged,  place: newLine];          items[20] &larr; LongNumberItem[               tag: "Volume9 Size"L, value: @toolData.vol9Size, proc: NumberChanged];	                 items[21] &larr; StringItem[               tag: "Volume10"L, string: @toolData.vol10Name, inHeap: TRUE,	       filterProc: StringChanged, place: newLine];          items[22] &larr; LongNumberItem[               tag: "Volume10 Size"L, value: @toolData.vol10Size, proc: NumberChanged];	                 SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE]          END;  --MakeParams     MakeScript: PUBLIC PROCEDURE[] =          BEGIN          IF toolData = NIL THEN toolData &larr; Heap.systemZone.NEW[Data &larr; []];          scriptWH &larr; MakeTool[];          -- Display diag. vol name          toolData.vol1Name &larr; String.CopyToNewString[               s: diagName, z: Heap.systemZone];	   FormSW.DisplayItem[toolData.paramSW, 3];    	       	  -- Display drive size info               FormSW.DisplayItem[toolData.paramSW, 1];          toolData.freePages &larr; toolData.driveSize - toolData.vol1Size;	  -- display free pages          FormSW.DisplayItem[toolData.paramSW, 2];          END;     MakeSWs: Tool.MakeSWsProc =          BEGIN          logName: STRING &larr; [40];          addresses: ARRAY [0..4) OF ToolDriver.Address;          Tool.UnusedLogName[unused: logName, root: "MakeScript.log"L];          toolData.msgSW &larr; Tool.MakeMsgSW[window: window, lines: 1];          toolData.paramSW &larr; Tool.MakeFormSW[window: window, formProc: MakeParams];          toolData.commandSW &larr; Tool.MakeFormSW[               window: window, formProc: MakeCommands];          toolData.fileSW &larr; Tool.MakeFileSW[window: window, name: logName];	  	  --FormSW.SetModifyNotificationProc[toolData.paramSW, DataChanged];          -- do the ToolDriver stuff          addresses &larr; [               [name: "msgSW"L, sw: toolData.msgSW], [               name: "ParamSW"L, sw: toolData.paramSW], [               name: "CmdSW"L, sw: toolData.commandSW], [               name: "fileSW"L, sw: toolData.fileSW]];          ToolDriver.NoteSWs[               tool: "MakeScript"L, subwindows: DESCRIPTOR[addresses]];          END;     MakeTool: PROCEDURE RETURNS [wh: Window.Handle] =          BEGIN          heraldName: STRING &larr; [80];          String.AppendString[heraldName, "AISBU System Tools: Make Script Option "L];          String.AppendString[heraldName, " of "L];          Time.Append[heraldName, Time.Unpack[Runtime.GetBcdTime[]]];          heraldName.length &larr; heraldName.length - 3;          --String.AppendString[heraldName, " on Pilot Version "L];          --Version.Append[heraldName];          RETURN[               Tool.Create[                    makeSWsProc: MakeSWs, initialState: default,                    --clientTransition: ClientTransition,                     name: heraldName, 		    initialBox: [[512, 0], [512, 400]],                    --x, y, width, height                     tinyName1: "Make"L, tinyName2: "Script"L]];          END;     ServerNotifyProc: FormSW.EnumeratedNotifyProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "ServerNotifyProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          IF toolData.diskType = SA1000 THEN toolData.driveSize &larr; SA1000Size          ELSE               IF toolData.diskType = SA4000 THEN toolData.driveSize &larr; SA4000Size               ELSE toolData.driveSize &larr; Q2040Size;          toolData.freePages &larr; toolData.driveSize - toolData.vol1Size;	  	            FormSW.DisplayItem[toolData.paramSW, 1];          FormSW.DisplayItem[toolData.paramSW, 2];          END;  --ServerNotifyProc     StringChanged: FormSW.FilterProcType =      BEGIN    	  -- Display free pages info 	  IF debug THEN {	  	Put.Line[toolData.fileSW, "StringChanged..."L];		Put.Text[toolData.fileSW, "vol2Size: "L];          	Put.LongDecimal[toolData.fileSW, toolData.vol2Size];          	Process.Pause[Process.SecondsToTicks[5]];		};			  nVols &larr; 1; 	  toolData.freePages &larr; toolData.driveSize - toolData.vol1Size;	  	  IF toolData.vol2Size &gt; 0 OR toolData.vol2Name # NIL THEN  {	  	nVols &larr; nVols + 1;	  	toolData.freePages &larr; toolData.freePages - toolData.vol2Size;		};			  IF toolData.vol3Size &gt; 0 OR toolData.vol3Name # NIL THEN {	  	nVols &larr; nVols + 1;		toolData.freePages &larr; toolData.freePages - toolData.vol3Size;		};			  IF toolData.vol4Size &gt; 0 OR toolData.vol4Name # NIL THEN {	  	nVols &larr; nVols + 1;	  	toolData.freePages &larr; toolData.freePages - toolData.vol4Size;		};			  IF toolData.vol5Size &gt; 0 OR toolData.vol5Name # NIL THEN {	  	nVols &larr; nVols + 1;		toolData.freePages &larr; toolData.freePages - toolData.vol5Size;		};			  IF toolData.vol6Size &gt; 0 OR toolData.vol6Name # NIL THEN  {	  	nVols &larr; nVols + 1;	  	toolData.freePages &larr; toolData.freePages - toolData.vol6Size;		};			  IF toolData.vol7Size &gt; 0 OR toolData.vol7Name # NIL THEN {	  	nVols &larr; nVols + 1;		toolData.freePages &larr; toolData.freePages - toolData.vol7Size;		};			  IF toolData.vol8Size &gt; 0 OR toolData.vol8Name # NIL THEN {	  	nVols &larr; nVols + 1;	  	toolData.freePages &larr; toolData.freePages - toolData.vol4Size;		};			  IF toolData.vol9Size &gt; 0 OR toolData.vol9Name # NIL THEN {	  	nVols &larr; nVols + 1;		toolData.freePages &larr; toolData.freePages - toolData.vol9Size;		};			  		  IF toolData.vol10Name # NIL THEN {	  	nVols &larr; nVols + 1;		toolData.vol10Size &larr; toolData.freePages;		FormSW.DisplayItem[toolData.paramSW, 22];		toolData.freePages &larr; toolData.freePages - toolData.vol10Size;		};		          FormSW.DisplayItem[toolData.paramSW, 2];	  FormSW.StringEditProc[sw, item, insert, string];       END;  -- StringChanged          WriteUserScript: PROCEDURE[] RETURNS [BOOLEAN] =          BEGIN          name: LONG STRING &larr; "Prometheus.script"L;          writeS: MStream.Handle &larr; NIL;          --tempString: LONG STRING &larr; [80];	  tempString: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  tempString1: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  tempString2: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  	  tempString3: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  tempString4: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  tempString5: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  tempString6: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  	  tempString7: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  tempString8: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  tempString9: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  tempString10: LONG STRING &larr; Heap.systemZone.NEW[StringBody [80]];	  z: UNCOUNTED ZONE &larr; Heap.systemZone;	  --StringChanged[];          IF ~MFile.ValidFilename[name] THEN {               Put.Line[toolData.msgSW, "Invalid file name"L]; RETURN[FALSE]; };          myFile &larr; MFile.Acquire[               name, anchor, MFile.dontRelease !               MFile.Error =&gt; {myFile &larr; NIL; CONTINUE}];          Cursor.Set[hourGlass];          --IF myFile # NIL THEN MFile.Release[myFile];          BEGIN          ENABLE MFile.Error =&gt; GOTO problem;          --ENABLE MFile.Error  =&gt; {MFile.Release[myFile]; CONTINUE;};          IF myFile # NIL THEN               BEGIN               IF debug THEN {                    Put.Line[toolData.fileSW, "SetAccess..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               MFile.SetAccess[myFile, readWrite];               END          ELSE               BEGIN               IF debug THEN {                    Put.Line[toolData.fileSW, "ReadWrite..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               myFile &larr; MFile.ReadWrite[name, MFile.dontRelease, text];               END;          --myFile &larr; MFile.ReadWrite[name, MFile.dontRelease, text];          -- myFile is ReadWrite so can Copy handle with read later          writeS &larr; MStream.Create[myFile, []];          MStream.SetLength[writeS, 0];          writeS.PutString["\\Partition disk according to user definition\n"L];          writeS.PutString[               "Comment WARNING - PARTITIONING A DISK DESTROYS ALL ITS CONTENTS\n"L];          writeS.PutString["Confirm Continue?\n"L];          --tempString &larr; String.CopyToNewString[          --    s: "Create Rd0 YLisp "L, z: Heap.systemZone];	  	  String.AppendString[tempString1, "Create Rd0 YLisp "L];          String.AppendDecimal[tempString1, nVols];	  String.AppendString[tempString1, "\n"L];	                 IF debug THEN {	  	Put.Text[toolData.fileSW, "tempString1"L];          	Put.Line[toolData.fileSW, tempString1];	  	Process.Pause[Process.SecondsToTicks[5]];		Put.Line[toolData.fileSW, "Append decimal"];	  	Put.Decimal[toolData.fileSW, nVols];	  	Process.Pause[Process.SecondsToTicks[5]];          	Put.Line[toolData.fileSW, "AppendDecimal"L];          	Put.Line[toolData.fileSW, tempString1];	  	Process.Pause[Process.SecondsToTicks[5]];		};	            writeS.PutString[tempString1];          writeS.PutString["SystemTools 3500 normal\n"L];          IF ~String.Empty[toolData.vol2Name] AND toolData.vol2Size &gt; 0 THEN {          	String.AppendString[tempString2, toolData.vol2Name];		String.AppendString[tempString2, " "L];		String.AppendLongDecimal[tempString2, toolData.vol2Size];	        String.AppendString[tempString2, " normal\n"L];                writeS.PutString[tempString2]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString2];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	       	                 IF ~String.Empty[toolData.vol3Name] AND toolData.vol3Size &gt; 0 THEN {          	String.AppendString[tempString3, toolData.vol3Name];		String.AppendString[tempString3, " "L];		String.AppendLongDecimal[tempString3, toolData.vol3Size];	        String.AppendString[tempString3, " normal\n"L];                writeS.PutString[tempString3]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString3];	  		Put.Text[toolData.fileSW, "tempString"L];          		Process.Pause[Process.SecondsToTicks[5]];			};               };	                 IF ~String.Empty[toolData.vol4Name] AND toolData.vol4Size &gt; 0 THEN {          	String.AppendString[tempString4, toolData.vol4Name];		String.AppendString[tempString4, " "L];		String.AppendLongDecimal[tempString4, toolData.vol4Size];	        String.AppendString[tempString4, " normal\n"L];                writeS.PutString[tempString4]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString4];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	       	                 IF ~String.Empty[toolData.vol5Name] AND toolData.vol5Size &gt; 0 THEN {         	String.AppendString[tempString5, toolData.vol5Name];		String.AppendString[tempString5, " "L];		String.AppendLongDecimal[tempString5, toolData.vol5Size];	        String.AppendString[tempString5, " normal\n"L];                writeS.PutString[tempString5]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString4];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	                 IF ~String.Empty[toolData.vol6Name] AND toolData.vol6Size &gt; 0 THEN {         	String.AppendString[tempString6, toolData.vol6Name];		String.AppendString[tempString6, " "L];		String.AppendLongDecimal[tempString6, toolData.vol6Size];	        String.AppendString[tempString6, " normal\n"L];                writeS.PutString[tempString6]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString6];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	       	            IF ~String.Empty[toolData.vol7Name] AND toolData.vol7Size &gt; 0 THEN {         	String.AppendString[tempString7, toolData.vol7Name];		String.AppendString[tempString7, " "L];		String.AppendLongDecimal[tempString7, toolData.vol7Size];	        String.AppendString[tempString7, " normal\n"L];                writeS.PutString[tempString7]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString7];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	       	            IF ~String.Empty[toolData.vol8Name] AND toolData.vol8Size &gt; 0 THEN {         	String.AppendString[tempString8, toolData.vol8Name];		String.AppendString[tempString8, " "L];		String.AppendLongDecimal[tempString8, toolData.vol8Size];	        String.AppendString[tempString8, " normal\n"L];                writeS.PutString[tempString8]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString8];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	            	            IF ~String.Empty[toolData.vol9Name] AND toolData.vol9Size &gt; 0 THEN {         	String.AppendString[tempString9, toolData.vol9Name];		String.AppendString[tempString9, " "L];		String.AppendLongDecimal[tempString9, toolData.vol9Size];	        String.AppendString[tempString9, " normal\n"L];                writeS.PutString[tempString9]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString9];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	                      IF ~String.Empty[toolData.vol10Name] AND toolData.vol10Size &gt; 0 THEN {         	String.AppendString[tempString10, toolData.vol10Name];		String.AppendString[tempString10, " "L];		String.AppendLongDecimal[tempString10, toolData.vol10Size];	        String.AppendString[tempString10, " normal\n"L];                writeS.PutString[tempString10]; 	  	IF debug THEN {			Put.Line[toolData.fileSW, tempString10];	  		Put.Text[toolData.fileSW, "tempString"L];         		Process.Pause[Process.SecondsToTicks[5]];			};               };	                      writeS.PutString["Check RD0\n"L];          writeS.PutString["Comment Disk partitioned for Interlisp-D\n"L];          EXITS               problem =&gt; {                    Put.Line[toolData.fileSW, "Error in auquiring file..."L];                    IF myFile # NIL THEN MFile.Release[myFile];                    RETURN[FALSE];                    }          END;	  writeS.SendNow;          ILT.WriteScriptA[myFile, writeS];	-- write part a first	  ILT.WriteScriptB[myFile, writeS];	-- write more	  IF debug THEN {			Put.Text[toolData.fileSW, "SendNow..."L];         		Process.Pause[Process.SecondsToTicks[5]];			};          writeS.SendNow;	   	  IF debug THEN {			Put.Text[toolData.fileSW, "CopyFileHandle..."L];         		Process.Pause[Process.SecondsToTicks[5]];			};          myFile &larr; MFile.CopyFileHandle[               MStream.GetFile[writeS], MFile.dontRelease, readOnly];          IF debug THEN {               Put.Line[toolData.fileSW, "Delete..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS.Delete;	            IF myFile # NIL THEN MFile.Release[myFile];          Cursor.Set[textPointer];          --Process.Pause[Process.SecondsToTicks[5]];	  	  RETURN[TRUE];	  END;         END...</pre>
  </body>
</html>
