--LTSetProfileImpl.mesa--Created by--   JFung.PASA	  	15-Nov-83 15:44:26--last edited by--   JFung.PASA	   	17-Aug-84 15:16:01 DIRECTORY     CmFile,     Cursor,     Event,     EventTypes,     Exec,     Format,     FormSW,     Heap,     LispToolOps,     MFile,     MStream,     Process,     Profile,     Put,     Runtime,     Stream,     String,     StringLookUp,     Supervisor,     Time,     Token,     Tool,     ToolDriver,     ToolWindow,     UserInput,     Version,     Window;LTSetProfileImpl: PROGRAM     IMPORTS          CmFile, Cursor, Event, Exec, FormSW, Heap, LispToolOps, MFile, MStream,          Process, Profile, Put, Runtime, Stream, String, Supervisor, Time, Token,          Tool, ToolDriver, ToolWindow, Version, Window     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;     ServerType: TYPE = {IFS, FS, FLOPPY};     DataHandle: TYPE = LONG POINTER TO Data;     Data: TYPE = MACHINE DEPENDENT RECORD [          -- Message subwindow stuff          msgSW(0): Window.Handle _ NIL,          -- File subwindow stuff          fileSW(2): Window.Handle _ NIL,          -- Form subwindow stuff          -- Note: enumerateds and booleans must be word boundary          -- aligned as addresses for them must be generated          --formSW: Window.Handle _ NIL,          paramSW(4): Window.Handle _ NIL,          commandSW(6): Window.Handle _ NIL,          busy(8): BOOLEAN _ FALSE,  -- command is running          userName(9): LONG STRING _ NIL,          password(11): LONG STRING _ NIL,          domainName(13): LONG STRING _ NIL,          organizationName(15): LONG STRING _ NIL,          filePathName(17): LONG STRING _ NIL,          volName(19): LONG STRING _ NIL,          fileServerProtocol(21): LONG STRING _ NIL,          NSLisp(23): LONG STRING _ NIL,          PUPLisp(25): LONG STRING _ NIL,          FloppyLisp(27): LONG STRING _ NIL,          fileServer(29): ServerType _ FS];     active: BOOLEAN _ FALSE;     agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[          CheckDeactivate];     debug: BOOLEAN _ FALSE;     formDisplay: ToolWindow.DisplayProcType _ NIL;     heraldName: STRING _ [80];     profileWindow: Window.Handle _ NIL;     toolData: DataHandle _ NIL;     NSFileName: LONG STRING _          "[Host:]<Directory><SubDirectories>FileName.sysout"L;     IFSFileName: LONG STRING _          "[Host]<Directory><SubDirectories>FileName.sysout"L;     FloppyFileName: LONG STRING _ "Lisp.sysout"L;     CheckDeactivate: Supervisor.AgentProcedure =          BEGIN          IF event = EventTypes.deactivate AND profileWindow # NIL               AND profileWindow = eventData AND toolData.busy THEN               BEGIN               Put.Line[                    toolData.msgSW, "The tool is busy:  aborting deactivation"L];               ERROR Supervisor.EnumerationAborted;               END;          END;  --CheckDeactivate     ClearCommandSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL _ 0, i + 1 UNTIL               (item _ FormSW.FindItem[toolData.commandSW, i]) = NIL DO               item.flags.invisible _ TRUE ENDLOOP;          FormSW.Display[toolData.commandSW];          END;     ClearFileSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL _ 0, i + 1 UNTIL               (item _ FormSW.FindItem[toolData.fileSW, i]) = NIL DO               item.flags.invisible _ TRUE ENDLOOP;          FormSW.Display[toolData.fileSW];          formDisplay _ Window.GetDisplayProc[toolData.fileSW];          END;     ClearMsgSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL _ 0, i + 1 UNTIL               (item _ FormSW.FindItem[toolData.msgSW, i]) = NIL DO               item.flags.invisible _ TRUE ENDLOOP;          FormSW.Display[toolData.msgSW];          formDisplay _ Window.GetDisplayProc[toolData.msgSW];          END;     ClearSubWindows: PROCEDURE =          BEGIN          --ClearFileSubwindow;          ClearMsgSubwindow;          END;     ClientTransition: ToolWindow.TransitionProcType =          -- This procedure is called whenever the system determines that this          -- Tool's state is undergoing a user invoked transition.          -- In this Example we demonstrate a technique that minimizes the memory          -- requirements for a Tool that is inactive.          BEGIN          SELECT TRUE FROM               old = inactive =>                    BEGIN                    IF toolData = NIL THEN                         toolData _ Heap.systemZone.NEW[Data _ []];                    ProcessUserDotCM[];                    active _ TRUE;                    END;               new = inactive =>                    BEGIN                    Supervisor.RemoveDependency[                         client: agent, implementor: Event.toolWindow];                    IF toolData # NIL THEN                         BEGIN                         FormSW.Destroy[toolData.paramSW];                         FormSW.Destroy[toolData.commandSW];                         Heap.systemZone.FREE[@toolData];                         END;                    --ToolDriver.RemoveSWs[tool: "LispTool"L];                    active _ FALSE;                    END;               ENDCASE          END;     FormSWMakeUserCM: FormSW.ProcType =          BEGIN          toolData.busy _ TRUE;          ClearSubWindows;          Put.Line[               toolData.fileSW,               "WARNING: will DESTROY your old user.cm, [Confirm?]"L];          IF ILT.Confirm[] THEN ILT.MakeUserCM[];          toolData.busy _ FALSE;          END;  --FormSWMakeUserCM     FormSWQuitProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "Quit Proc..."L];               --Process.Pause[Process.SecondsToTicks[5]];               };          [] _ ToolWindow.Deactivate[profileWindow];          END;  --FormSWQuitProc     GetUser: PUBLIC PROCEDURE [name, password: LONG STRING] =          BEGIN          z: UNCOUNTED ZONE = Heap.systemZone;          toolData.userName _ String.CopyToNewString[name, z];          toolData.password _ String.CopyToNewString[password, z]          END;  --GetUser     GetDefaultDomain: PUBLIC PROCEDURE [domain: LONG STRING] =          BEGIN          z: UNCOUNTED ZONE = Heap.systemZone;          toolData.domainName _ String.CopyToNewString[domain, z]          END;  --GetDefaultDomain     GetDefaultOrganization: PUBLIC PROCEDURE [organization: LONG STRING] =          BEGIN          z: UNCOUNTED ZONE = Heap.systemZone;          toolData.organizationName _ String.CopyToNewString[organization, z]          END;  --GetDefaultOrganization     GetProfileInfo: PUBLIC PROCEDURE =          BEGIN          --Profile.GetUser[GetUser];          Profile.GetDefaultDomain[GetDefaultDomain];          Profile.GetDefaultOrganization[GetDefaultOrganization];          --Profile.GetDefaultRegistry[GetDefaultRegistry];          --Profile.GetLibrarianNames[GetLibrarianNames];          --Profile.GetLibrarian[GetLibrarian]          END;  --GetProfileInfo     Init: PROCEDURE =          BEGIN          --h: Exec.Handle;          --execWrite: Format.StringProc _ Exec.OutputProc[h];          --execWrite["Creating tool window.."L];           --Process.Pause[Process.SecondsToTicks[5]];          Exec.AddCommand["SetDomain.~"L, ProfileExec, Unload];          --IF (profileWindow # NIL) AND ~active THEN          -- ToolWindow.Activate[profileWindow]          --ELSE profileWindow _ MakeTool[];          END;  --Init     MakeCommands: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..3) OF CARDINAL _ [0, 30, 60];          nItems: CARDINAL = 2;          items _ AllocateItemDescriptor[nItems];          items[0] _ CommandItem[               tag: "Set Profile"L, place: newLine, proc: FormSWMakeUserCM];          -- newLine is required, else will get 915 trap          items[1] _ CommandItem[tag: "Quit"L, proc: FormSWQuitProc];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE];          END;  --MakeCommands     MakeParams: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..7) OF CARDINAL _ [0, 28, 52, 56, 60, 68, 75];          nItems: CARDINAL = 8;          serverForm: ARRAY [0..3) OF Enumerated _ [               ["IFS"L, ServerType[IFS]], ["FS"L, ServerType[FS]], [               "FLOPPY"L, ServerType[FLOPPY]]];          items _ AllocateItemDescriptor[nItems];          items[0] _ StringItem[               tag: "User"L, string: @toolData.userName, inHeap: TRUE,               place: newLine];          items[1] _ StringItem[               tag: "Password"L, string: @toolData.password, inHeap: TRUE,               feedback: password];          items[2] _ StringItem[               tag: "Domain"L, place: newLine, string: @toolData.domainName,               inHeap: TRUE];          items[3] _ StringItem[               tag: "Organization"L, string: @toolData.organizationName,               inHeap: TRUE];          items[4] _ EnumeratedItem[               tag: "Device"L, z: Heap.systemZone, feedback: all,               value: @toolData.fileServer, copyChoices: TRUE,               proc: ServerNotifyProc, choices: DESCRIPTOR[serverForm]];          items[5] _ StringItem[               tag: "NSLisp"L, place: newLine, string: @toolData.NSLisp,               inHeap: TRUE];          items[6] _ StringItem[               tag: "PupLisp"L, place: newLine, string: @toolData.PUPLisp,               inHeap: TRUE];          items[7] _ StringItem[               tag: "FloppyLisp"L, place: newLine, string: @toolData.FloppyLisp,               inHeap: TRUE];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE]          END;  --MakeParams     MakeSWs: Tool.MakeSWsProc =          BEGIN          logName: STRING _ [40];          addresses: ARRAY [0..4) OF ToolDriver.Address;          Tool.UnusedLogName[unused: logName, root: "SetProfile.log"L];          toolData.msgSW _ Tool.MakeMsgSW[window: window, lines: 1];          toolData.paramSW _ Tool.MakeFormSW[window: window, formProc: MakeParams];          toolData.commandSW _ Tool.MakeFormSW[               window: window, formProc: MakeCommands];          toolData.fileSW _ Tool.MakeFileSW[window: window, name: logName];          Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];          -- do the ToolDriver stuff          addresses _ [               [name: "msgSW"L, sw: toolData.msgSW], [               name: "ParamSW"L, sw: toolData.paramSW], [               name: "CmdSW"L, sw: toolData.commandSW], [               name: "fileSW"L, sw: toolData.fileSW]];          ToolDriver.NoteSWs[               tool: "SetProfile"L, subwindows: DESCRIPTOR[addresses]];          END;     MakeTool: PROCEDURE RETURNS [wh: Window.Handle] =          BEGIN          String.AppendString[heraldName, "XEROX AISBU: Profile Tool "L];          String.AppendString[heraldName, " of "L];          Time.Append[heraldName, Time.Unpack[Runtime.GetBcdTime[]]];          heraldName.length _ heraldName.length - 3;          --String.AppendString[heraldName, " on Pilot Version "L];          --Version.Append[heraldName];          RETURN[               Tool.Create[                    makeSWsProc: MakeSWs, initialState: default,                    clientTransition: ClientTransition, name: heraldName,                    initialBox: [[0, 0], [1024, 800]],                    --x, y, width, height                     tinyName1: "Profile"L, tinyName2: "Tool"L]]          END;     MakeUserCM: PUBLIC PROCEDURE[] =          BEGIN          name: LONG STRING _ "User.cm"L;          myFile: MFile.Handle _ NIL;          --readS: MStream.Handle _ NIL;          writeS: MStream.Handle _ NIL;          IF debug THEN {               Put.Line[toolData.fileSW, "Enter MakeUserCM..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          IF ~MFile.ValidFilename[name] THEN {               Put.Line[toolData.msgSW, "Invalid file name"L]; RETURN; };          IF debug THEN {               Put.Line[toolData.fileSW, "Acquire..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          myFile _ MFile.Acquire[               name, anchor, MFile.dontRelease !               MFile.Error => {myFile _ NIL; CONTINUE}];          IF debug THEN {               Put.Line[toolData.fileSW, "Set hourGlass..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Cursor.Set[hourGlass];          --IF myFile # NIL THEN MFile.Release[myFile];          BEGIN          ENABLE MFile.Error => GOTO problem;          --ENABLE MFile.Error  => {MFile.Release[myFile]; CONTINUE;};          IF myFile # NIL THEN               BEGIN               IF debug THEN {                    Put.Line[toolData.fileSW, "SetAccess..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               MFile.SetAccess[myFile, readWrite];               END          ELSE               BEGIN               IF debug THEN {                    Put.Line[toolData.fileSW, "ReadWrite..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               myFile _ MFile.ReadWrite[name, MFile.dontRelease, text];               END;          --myFile _ MFile.ReadWrite[name, MFile.dontRelease, text];          -- myFile is ReadWrite so can Copy handle with read later          IF debug THEN {               Put.Line[toolData.fileSW, "Create..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS _ MStream.Create[myFile, []];          IF debug THEN {               Put.Line[toolData.fileSW, "SetLength..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          MStream.SetLength[writeS, 0];          IF toolData.fileServer = FS THEN               toolData.fileServerProtocol _ String.CopyToNewString[                    s: "FS"L, z: Heap.systemZone]          ELSE               IF toolData.fileServer = IFS THEN                    toolData.fileServerProtocol _ String.CopyToNewString[                         s: "IFS"L, z: Heap.systemZone]               ELSE                    toolData.fileServerProtocol _ String.CopyToNewString[                         s: "FLOPPY"L, z: Heap.systemZone];          writeS.PutString["[User.cm]\n"L];          writeS.PutString["[System]\n"L];          IF debug THEN {               Put.Line[toolData.fileSW, "[User.cm]"L];               Put.Line[toolData.fileSW, "[System]"L];               };          IF ~String.Empty[toolData.userName] THEN {               writeS.PutString["User: "L];               writeS.PutString[toolData.userName];               writeS.PutString["\n"L];               IF debug THEN {                    Put.Line[toolData.fileSW, "User: "L];                    Put.Line[toolData.fileSW, toolData.userName];                    Process.Pause[Process.SecondsToTicks[5]];                    };               };          IF ~String.Empty[toolData.password] THEN {               writeS.PutString["Password: "L];               writeS.PutString[toolData.password];               writeS.PutString["\n"L];               IF debug THEN {                    Put.Line[toolData.fileSW, "Password: "L];                    Put.Line[toolData.fileSW, toolData.password];                    Process.Pause[Process.SecondsToTicks[5]];                    };               };          IF ~String.Empty[toolData.domainName] THEN {               writeS.PutString["Domain: "L];               writeS.PutString[toolData.domainName];               writeS.PutString["\n"L];               IF debug THEN {                    Put.Line[toolData.fileSW, "Domain: "L];                    Put.Line[toolData.fileSW, toolData.domainName];                    Process.Pause[Process.SecondsToTicks[5]];                    };               };          IF ~String.Empty[toolData.organizationName] THEN {               writeS.PutString["Organization: "L];               writeS.PutString[toolData.organizationName];               writeS.PutString["\n"L];               IF debug THEN {                    Put.Line[toolData.fileSW, "Organization: "L];                    Put.Line[toolData.fileSW, toolData.organizationName];                    Process.Pause[Process.SecondsToTicks[5]];                    };               };          IF ~String.Empty[toolData.fileServerProtocol] THEN {               writeS.PutString["FileServer: "L];               writeS.PutString[toolData.fileServerProtocol];               writeS.PutString["\n"L];               IF debug THEN {                    Put.Line[toolData.fileSW, "FileServer: "L];                    Put.Line[toolData.fileSW, toolData.fileServerProtocol];                    Process.Pause[Process.SecondsToTicks[5]];                    };               };          IF ~String.Empty[toolData.NSLisp] THEN {               writeS.PutString["NSLisp: "L];               writeS.PutString[toolData.NSLisp];               writeS.PutString["\n"L];               IF debug THEN {                    Put.Line[toolData.fileSW, "NSLisp"L];                    Put.Line[toolData.fileSW, toolData.NSLisp];                    Process.Pause[Process.SecondsToTicks[5]];                    };               };          IF ~String.Empty[toolData.PUPLisp] THEN {               writeS.PutString["PUPLisp: "L];               writeS.PutString[toolData.PUPLisp];               writeS.PutString["\n"L];               IF debug THEN {                    Put.Line[toolData.fileSW, "PUPLisp: "L];                    Put.Line[toolData.fileSW, toolData.PUPLisp];                    Process.Pause[Process.SecondsToTicks[5]];                    };               };          IF ~String.Empty[toolData.FloppyLisp] THEN {               writeS.PutString["FloppyLisp: "L];               writeS.PutString[toolData.FloppyLisp];               writeS.PutString["\n"L];               IF debug THEN {                    Put.Line[toolData.fileSW, "FloppyLisp: "L];                    Put.Line[toolData.fileSW, toolData.FloppyLisp];                    Process.Pause[Process.SecondsToTicks[5]];                    };               };          writeS.PutString["Screen: White\n"L];          writeS.PutString["Debug: No\n"L];          writeS.PutString["[SystemTools:System]\n"L];          writeS.PutString["InitialCommand: SystemTools\n"L];          IF debug THEN {               Put.Line[toolData.fileSW, "Screen: White\n"L];               Put.Line[toolData.fileSW, "Debug: No"L];               Put.Line[toolData.fileSW, "[SystemTools:System]"L];               Put.Line[toolData.fileSW, "InitialCommand: SystemTools"L];               Process.Pause[Process.SecondsToTicks[5]];               };          IF debug THEN {               Put.Line[toolData.fileSW, "SendNow..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS.SendNow;          IF debug THEN {               Put.Line[toolData.fileSW, "CopyFileHandle..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          myFile _ MFile.CopyFileHandle[               MStream.GetFile[writeS], MFile.dontRelease, readOnly];          IF debug THEN {               Put.Line[toolData.fileSW, "Delete..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          EXITS               problem => {                    Put.Line[toolData.fileSW, "problem..."L];                    IF myFile # NIL THEN                         BEGIN                         Put.Line[toolData.msgSW, "Error in auquiring file"L];                         MFile.Release[myFile];                         END;                    }          END;          writeS.Delete;          IF myFile # NIL THEN MFile.Release[myFile];          Cursor.Set[textPointer];          Put.Line[toolData.fileSW, " Done"L];          END;  --MakeUserCM     ProcessUserDotCM: PUBLIC PROCEDURE =          BEGIN          CMOption: TYPE = MACHINE DEPENDENT{               Domain, User, Password, NSFile, IFSFile, FloppyFile, Protocol, Org,               noMatch(StringLookUp.noMatch)};          DefinedOption: TYPE = CMOption [Domain..Org];          cmOptionTable: ARRAY DefinedOption OF LONG STRING _ [               Domain: "Domain"L, User: "User"L, Password: "Password"L,               Org: "Organization"L, NSFile: "NSLisp", IFSFile: "PUPLisp",               FloppyFile: "FloppyLisp", Protocol: "FileServer"L];          cmIndex: CMOption;          CheckType: PROCEDURE [h: CmFile.Handle, table: StringLookUp.TableDesc]               RETURNS [index: CARDINAL] = CmFile.NextValue;          MyNextValue: PROCEDURE [               h: CmFile.Handle,               table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]               RETURNS [index: CMOption] = LOOPHOLE[CheckType];          cmFile: CmFile.Handle _ CmFile.UserDotCmOpen[               ! CmFile.Error => IF code = fileNotFound THEN GOTO return];          IF CmFile.FindSection[cmFile, "System"L] THEN               DO                    SELECT                    (cmIndex _ MyNextValue[                         h: cmFile, table: DESCRIPTOR[cmOptionTable] !                         CmFile.TableError => RESUME ]) FROM                         noMatch => EXIT;                         User =>                              BEGIN                              value: LONG STRING = Token.Item[cmFile];                              toolData.userName _ String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] _ Token.FreeTokenString[value];                              END;                         Password =>                              BEGIN                              value: LONG STRING = Token.Item[cmFile];                              toolData.password _ String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] _ Token.FreeTokenString[value];                              END;                         <<    				-- call twice for "xsis north" type tokens                         Domain =>                              BEGIN                              value: LONG STRING = Token.Item[cmFile];			      value1: LONG STRING = Token.Item[cmFile];			      IF ~String.Empty[value1] THEN {			      	String.AppendString[value, " "L];			      	String.AppendString[value, value1];				};                              toolData.domainName _ String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] _ Token.FreeTokenString[value];			      [] _ Token.FreeTokenString[value1];                              END;                         Org =>                              BEGIN                              value: LONG STRING _ Token.Item[cmFile];                              toolData.organizationName _ String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] _ Token.FreeTokenString[value];                              END;>>                         NSFile =>                              BEGIN                              value: LONG STRING _ Token.Item[cmFile];                              toolData.NSLisp _ String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] _ Token.FreeTokenString[value];                              END;                         IFSFile =>                              BEGIN                              value: LONG STRING _ Token.Item[cmFile];                              toolData.PUPLisp _ String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] _ Token.FreeTokenString[value];                              END;                         FloppyFile =>                              BEGIN                              value: LONG STRING _ Token.Item[cmFile];                              toolData.FloppyLisp _ String.CopyToNewString[                                   s: value, z: Heap.systemZone];                              [] _ Token.FreeTokenString[value];                              END;                         Protocol =>                              BEGIN                              value: LONG STRING _ Token.Item[cmFile];                              Put.Line[toolData.fileSW, value];                              IF String.Equivalent[value, "FS"] THEN                                   toolData.fileServer _ FS                              ELSE                                   IF String.Equivalent[value, "IFS"] THEN                                        toolData.fileServer _ IFS                                   ELSE toolData.fileServer _ FLOPPY;                              [] _ Token.FreeTokenString[value];                              END;                         ENDCASE;                    ENDLOOP;          IF String.Empty[toolData.NSLisp] THEN               toolData.NSLisp _ String.CopyToNewString[                    s: NSFileName, z: Heap.systemZone];          IF String.Empty[toolData.PUPLisp] THEN               toolData.PUPLisp _ String.CopyToNewString[                    s: IFSFileName, z: Heap.systemZone];          IF String.Empty[toolData.FloppyLisp] THEN               toolData.FloppyLisp _ String.CopyToNewString[                    s: FloppyFileName, z: Heap.systemZone];          GetProfileInfo[];          [] _ CmFile.Close[cmFile];          EXITS return => NULL;          END;  --ProcessUserDotCM     ProfileExec: Exec.ExecProc =          BEGIN          execWrite: Format.StringProc _ Exec.OutputProc[h];          --execWrite["Creating tool window.."L];           --Process.Pause[Process.SecondsToTicks[5]];          IF (profileWindow # NIL) AND ~active THEN               ToolWindow.Activate[profileWindow]          ELSE profileWindow _ MakeTool[];          END;  --ProfileExec     ProfileToolActivate: PUBLIC PROCEDURE =          BEGIN          IF profileWindow = NIL THEN profileWindow _ MakeTool[];          ToolWindow.Activate[profileWindow];          Window.Stack[               profileWindow, Window.GetChild[Window.GetParent[profileWindow]]];  -- top me          Window.ValidateTree[];          END;  --ProfileToolActivate     ServerNotifyProc: FormSW.EnumeratedNotifyProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "ServerNotifyProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          --DisplayFile[];          END;  --ServerNotifyProc     Unload: Exec.ExecProc =          BEGIN          IF profileWindow # NIL THEN Tool.Destroy[profileWindow];          profileWindow _ NIL;          [] _ Exec.RemoveCommand[h, "SetProfile.~"L];          END;     ---- ---- ---- ---- ---- ---- ---- ---- ----  --     -- Mainline code     Init[];     END...