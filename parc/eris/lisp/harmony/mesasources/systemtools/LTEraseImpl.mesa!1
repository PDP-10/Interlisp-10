--LTEraseImpl.mesa--Created by--   JFung.PASA	  	19-Sep-83 17:06:11--last edited by--   JFung.PASA	   	27-Jul-84 10:37:25DIRECTORY     Cursor USING [Set],     LispToolOps,     Process USING [Pause, SecondsToTicks],     Put USING [CR, Line, LongString, Text],     String USING [EquivalentString],     Volume;LTEraseImpl: PROGRAM     IMPORTS          Cursor, LispToolOps, Process, Put, String, Volume	       EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;          debug: BOOLEAN _ FALSE;--toolData: PUBLIC ILT.DataHandle _ NIL;--Warning: Item 0 in interface LispToolOps is a duplicate export (in LTEraseImpl), at LispInstallationTool[1622]     EraseProc: PUBLIC PROCEDURE [vName: LONG STRING] =          BEGIN          volumeID: Volume.ID _ Volume.nullID;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Enter EraseProc..."L];               Process.Pause[Process.SecondsToTicks[10]];               Put.LongString[ILT.toolData.fileSW, vName];               Put.CR[ILT.toolData.fileSW];               };          [volumeID, ] _ ILT.GetVolumeID[vName];          IF debug THEN Put.Text[ILT.toolData.fileSW, "Volume = "L];          IF volumeID = Volume.nullID THEN               BEGIN               IF debug THEN Put.Line[ILT.toolData.fileSW, "Null ID"L];               RETURN;               END;          Put.Text[ILT.toolData.fileSW, " Erasing... "L];	  Cursor.Set[hourGlass];          Volume.Erase[volumeID];	  Cursor.Set[textPointer];          Put.Line[ILT.toolData.fileSW, " Done"L];          END;     GetVolumeID: PUBLIC PROCEDURE [volumeName: LONG STRING]          RETURNS [volumeID: Volume.ID _ Volume.nullID, volumeOpen: BOOLEAN] =          BEGIN OPEN Volume;          myType: Volume.Type = Volume.GetType[Volume.systemID];          <<all: Volume.TypeSet _ [               normal: TRUE,               debugger: myType = debugger OR myType = debuggerDebugger,               debuggerDebugger: myType = debuggerDebugger];	       >>	       	  all: Volume.TypeSet _ [               normal: TRUE,               --debugger: TRUE,	       debugger: myType = debugger OR myType = debuggerDebugger,               --debuggerDebugger: TRUE,	       debuggerDebugger: myType = debuggerDebugger,	       nonPilot: TRUE];               name: STRING = [maxNameLength];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Enter GetVolume..."L];               Process.Pause[Process.SecondsToTicks[5]];               Put.LongString[ILT.toolData.fileSW, volumeName];               Put.CR[ILT.toolData.fileSW];               };          volumeOpen _ FALSE;          FOR volumeID _ GetNext[Volume.nullID, all], GetNext[volumeID, all] WHILE               volumeID ~= Volume.nullID DO               name.length _ 0;               Volume.GetLabelString[volumeID, name];	       IF debug THEN {	      	 Put.Line[ILT.toolData.fileSW, name];	       	 Put.Line[ILT.toolData.fileSW, volumeName];		 Process.Pause[Process.SecondsToTicks[5]];		 };               IF String.EquivalentString[name, volumeName] THEN EXIT;               ENDLOOP;          SELECT volumeID FROM               nullID =>                    BEGIN                    Put.LongString[ILT.toolData.msgSW, volumeName];                    --Process.Pause[Process.SecondsToTicks[5]];                    Put.Line[ILT.toolData.msgSW, " volume not found!"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    RETURN;                    END;               Volume.systemID =>                    BEGIN		    <<                    Put.LongString[ILT.toolData.fileSW, volumeName];                    Put.Line[ILT.toolData.fileSW, " is your system volume!"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    --RETURN;		    >>                    END;               ENDCASE;	  IF debug THEN {	      	 Put.Line[ILT.toolData.fileSW, "Volume.Open"L];		 Process.Pause[Process.SecondsToTicks[5]];		 };	       	Volume.Open[               volume: volumeID !               Volume.NeedsScavenging => GOTO BadVolume];	       	                 volumeOpen _ TRUE;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "volume opened!"L];               Process.Pause[Process.SecondsToTicks[5]];               };          RETURN[volumeID, volumeOpen];          EXITS               BadVolume =>                    BEGIN                    Put.Line[ILT.toolData.msgSW, "Can not open volume "L];                    Put.LongString[ILT.toolData.fileSW, volumeName];                    Put.Line[ILT.toolData.fileSW, " needs scavenging."L];                    Process.Pause[Process.SecondsToTicks[10]];                    END;          END;     END...  