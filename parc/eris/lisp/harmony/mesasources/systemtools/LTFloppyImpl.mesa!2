-- LTFloppyImpl.mesa-- Created by--   JFung.pasa	  	14-Dec-83 12:37:04-- last edited by--   JFung.pasa	   	24-Sep-84 10:27:36DIRECTORY     AccessFloppy,     AccessFloppyUtil,     Ascii,     Environment,     Exec,     File,     FileName,     FileTypes USING [tUntypedFile],     Floppy,     Format,     FormSW,     Heap USING [systemZone],     Inline,     LispToolOps,     MFile,     MStream,     NSString,     OthelloDefs,     OthelloOps,     Process USING [Pause, SecondsToTicks],     Put,     Runtime,     Space,     SpecialMFile USING [GetCapaWithAccess, LeaderPages],     Storage,     Stream,     String,     StringLookUp,     Time,     Tool USING [          Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,          UnusedLogName],     ToolDriver,     ToolWindow,     Token,     UserInput,     Version,     Volume,     Window;LTFloppyImpl: PROGRAM     IMPORTS          AccessFloppy, File, FileName, Floppy, FormSW, Heap, Inline, LispToolOps,          MFile, NSString, OthelloOps, Process, Put, SpecialMFile, Storage, String,          Volume, Time, Tool, ToolDriver, Token, UserInput     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;     -- constant     nullNextFile: NextFile = [];     -- TYPEs     Indicator: TYPE = {off, left, right};     DataHandle: TYPE = LONG POINTER TO Data;     Data: TYPE = MACHINE DEPENDENT RECORD [          -- Message subwindow stuff          msgSW(0): Window.Handle _ NIL,          -- File subwindow stuff          fileSW(2): Window.Handle _ NIL,          -- Form subwindow stuff          -- Note: enumerateds and booleans must be word boundary          -- aligned as addresses for them must be generated          --formSW: Window.Handle _ NIL,          paramSW(4): Window.Handle _ NIL,          commandSW(6): Window.Handle _ NIL,          busy(8): BOOLEAN _ FALSE,  -- command is running          volName(9): LONG STRING _ NIL,          pattern(11): LONG STRING _ NIL,          indicator(13): Indicator _ left,          floppyName(14): LONG STRING _ NIL,          stream(16): MStream.Handle _ NIL,          from(18): LONG STRING _ NIL,          to(20): LONG STRING _ NIL,          numberOfFiles(22): INTEGER _ 0,          current(23): LptNextFile _ NIL,          fileList(25): LptNextFile _ NIL];     EnumProc: TYPE = PROCEDURE [          attributes: AccessFloppy.Attributes, fH: Floppy.FileHandle,          name: LONG STRING] RETURNS [stop: BOOLEAN _ FALSE];     LptNextFile: TYPE = LONG POINTER TO NextFile;     NextFile: TYPE = RECORD [          file: LONG STRING _ NIL,          size: LONG CARDINAL _ 0,  -- file size including leader page if it has one.          type: File.Type _ AccessFloppy.tFloppyLeaderPage,  -- specify whether it has leader page.          next: LptNextFile _ NIL];     VolHints: TYPE = RECORD [names: SEQUENCE length: CARDINAL OF LONG STRING];     SizeHints: TYPE = RECORD [names: SEQUENCE length: CARDINAL OF CARDINAL];     -- global variables     Abort: ERROR [s: STRING] = CODE;     active: BOOLEAN _ FALSE;     atSource: PUBLIC CARDINAL _ 0;     attributes: AccessFloppy.Attributes _ NIL;     bufferSize: Space.PageCount _ 30;     dataVersion: CARDINAL = 02222;  -- version of clientData     debug: BOOLEAN _ FALSE;     floppyWH: Window.Handle _ NIL;     formDisplay: ToolWindow.DisplayProcType _ NIL;     heraldName: STRING _ [50];     indicatorBox: Window.Box = [[10, 10], [16, 16]];     nullFile: Floppy.FileHandle;     opened: BOOLEAN _ FALSE;     --spaceHandle: Space.Handle _ Space.nullHandle;     toolData: DataHandle _ NIL;     vH: Floppy.VolumeHandle _ Floppy.nullVolumeHandle;     volumeID: Volume.ID _ Volume.nullID;     volumeOpen: BOOLEAN _ FALSE;     z: UNCOUNTED ZONE = Heap.systemZone;     SetOutcome: SIGNAL [value: Exec.Outcome] = CODE;     CleanUp: PROC =          BEGIN          current: LptNextFile _ toolData.fileList;          releaseData: MFile.ReleaseData _ [NIL, NIL];          WHILE current^ # nullNextFile DO               file: MFile.Handle _ NIL;               scratchName: LONG STRING _ [120];               String.AppendString[scratchName, current.file];               String.AppendString[scratchName, ".Scratch$"L];               toolData.current _ current.next;               file _ MFile.Acquire[                    scratchName, MFile.Access[delete], releaseData];               MFile.Delete[file];               --current.file _ Storage.FreeStringNil[current.file];               Storage.Free[current];               current _ toolData.current;               ENDLOOP;          toolData.fileList _ toolData.current _ Storage.FreeNodeNil[               toolData.current];          toolData.from _ Storage.FreeStringNil[toolData.from];          toolData.to _ Storage.FreeStringNil[toolData.to];          END;  -- CleanUp.     <<     CopyCmd: PROCEDURE =          BEGIN          END;       -- from AccessFloppyUtil     CreateBuffer: PUBLIC PROC [size: Space.PageCount]          RETURNS [spH: Space.Handle, spSize: Space.PageCount] =          BEGIN          END;  -- CreateBuffer.     DeleteBuffer: PUBLIC PROC [spH: Space.Handle] =          BEGIN 	  END;  -- DeleteBuffer.     DiskToFloppy: PROC =          BEGIN          END;  -- DiskToFloppy.>>     DisplayFloppyName: PROCEDURE [] =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "DisplayFile...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          FormSW.DisplayItem[toolData.paramSW, 3];          END;  --DisplayFloppyName     EnumerateFloppyFiles: PROCEDURE [          v: Floppy.VolumeHandle, proc: EnumProc, pattern: LONG STRING] =          BEGIN          nullFile: Floppy.FileHandle = [volume: v, file: Floppy.nullFileID];          attributes: AccessFloppy.Attributes _ Heap.systemZone.NEW[               AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];          name: LONG STRING = LOOPHOLE[@attributes.length];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "EnumerateFloppyFiles...."L];               --Process.Pause[Process.SecondsToTicks[5]];               };          FOR current: Floppy.FileHandle _ Floppy.GetNextFile[nullFile].nextFile,               Floppy.GetNextFile[current].nextFile WHILE current # nullFile DO               ENABLE UNWIND => Heap.systemZone.FREE[@attributes];               IF Floppy.GetFileAttributes[current].type #                    AccessFloppy.tFloppyLeaderPage THEN LOOP;               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "Floppy.GetNextFile"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    Put.Text[ILT.toolData.fileSW, "Pattern = "L];                    Put.Line[ILT.toolData.fileSW, pattern];                    };               AccessFloppy.GetAttributes[current, attributes];               IF                    --(pattern = NIL                    --OR Exec.MatchPattern[string: name, pattern: pattern]) OR                     proc[attributes, current, name] THEN {                    Put.Line[ILT.toolData.fileSW, "Exited loop."L]; EXIT; };               ENDLOOP;          Heap.systemZone.FREE[@attributes];          END;  --EnumerateFloppyFiles     FileLookUp: PROC [nsName: NSString.String]          RETURNS [fFile: Floppy.FileHandle, continue: BOOLEAN] =          BEGIN          continue _ TRUE;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FileLookUp"L];               --Put.Text[ILT.toolData.msgSW, nsName];               --Process.Pause[Process.SecondsToTicks[5]];               };          fFile _ AccessFloppy.LookUp[               nsName, attributes !               AccessFloppy.Error => {                    continue _ FALSE;                    Put.Line[ILT.toolData.fileSW, "Floppy Error"L];                    SELECT type FROM                         attributesNotAllowed => {                              Put.Line[                                   ILT.toolData.msgSW, "attributesNotAllowed"L];                              };                         fileNotFound => {                              --Put.Text[ILT.toolData.msgSW, name];                              Put.Line[ILT.toolData.msgSW, "File name not found"L];                              };                         invalidParameter => {                              Put.Line[ILT.toolData.msgSW, "invalidParameter"L]; };                         nameInUse => {                              Put.Line[ILT.toolData.msgSW, "nameInUse"L]; };                         volumeNotOpen => {                              Put.Line[ILT.toolData.msgSW, "volumeNotOpen"L]; };                         ENDCASE => Put.Line[ILT.toolData.msgSW, "others"L];                    IF debug THEN Process.Pause[Process.SecondsToTicks[10]];                    }];          RETURN[fFile, continue];          END;  --FileLookUp     FixDirectory: PUBLIC PROC [dir: LONG POINTER TO LONG STRING] =          BEGIN          IF dir^ = NIL THEN RETURN;          SELECT dir[dir.length - 1] FROM '>, '# => RETURN; ENDCASE;          String.AppendCharAndGrow[dir, '>, z];          END;  --FixDirectory     FloppyDelete: PUBLIC PROCEDURE [pattern: LONG STRING]          RETURNS [deleted: BOOLEAN] =          BEGIN          name: LONG STRING _ NIL;          vH: Floppy.VolumeHandle;          DeleteOne: EnumProc =               BEGIN               deleted _ TRUE;               Put.Text[ILT.toolData.msgSW, name];               Put.Text[ILT.toolData.msgSW, "... "L];               AccessFloppy.DeleteFile[                    NSString.StringFromMesaString[name] !                    AccessFloppy.Error =>                         SELECT type FROM                              fileNotFound => {                                   Put.Line[ILT.toolData.msgSW, "not found"L];                                   IF debug THEN                                        Process.Pause[Process.SecondsToTicks[5]];                                   GOTO error;                                   };                              ENDCASE];               Put.Line[ILT.toolData.msgSW, "deleted"L];               IF debug THEN Process.Pause[Process.SecondsToTicks[10]];               RETURN[];               EXITS error => {deleted _ FALSE; RETURN[]; };               END;  --DeleteOne          [vH] _ OpenFloppy[];          IF ~opened THEN RETURN;          BEGIN          ENABLE UNWIND => {AccessFloppy.Close[ ! Floppy.Error => CONTINUE]};          --name _ toolData.pattern;          --IF toolData.pattern = NIL THEN EXIT;          IF WildCards[pattern] THEN EnumerateFloppyFiles[vH, DeleteOne, pattern]          ELSE [] _ DeleteOne[NIL, [vH, Floppy.nullFileID], pattern];          END;          IF debug THEN {               Put.Text[ILT.toolData.fileSW, "AccessFloppy.Close"L];               Process.Pause[Process.SecondsToTicks[5]];               };          AccessFloppy.Close[];          END;  --FloppyDelete     FloppyDuplicate: PUBLIC PROCEDURE = BEGIN END;     FloppyFormat: PROCEDURE [          nFiles: CARDINAL, label: LONG STRING, sides: Floppy.Sides,          density: Floppy.Density] RETURNS [gotError: BOOLEAN] =          BEGIN          gotError: BOOLEAN _ FALSE;          BEGIN          v: Floppy.VolumeHandle;          v _ AccessFloppy.Open[               !               Floppy.Error =>                    SELECT error FROM                         invalidFormat => GOTO virgin;                         needsScavenging => {gotError _ TRUE; CONTINUE};                         ENDCASE => gotError _ TRUE; ];          IF ~gotError THEN {               [] _ Floppy.GetAttributes[v, label];               Floppy.Close[v];               Put.Text[ILT.toolData.fileSW, "Floppy volume """L];               Put.Text[ILT.toolData.fileSW, label];               Put.Line[ILT.toolData.fileSW, """ already formatted"L];               }          ELSE               Put.Line[                    toolData.fileSW,                    "Floppy probably contains valid information"L];          EXITS virgin => NULL;          END;          Put.Line[               toolData.fileSW,               "Formatting will DESTROY all contents, confirm to continue"L];          IF ~ILT.Confirm[] THEN RETURN;          --label.length _ 0;          IF label = NIL THEN {               Put.Line[toolData.fileSW, "Please supply floppy name"];               Process.Pause[Process.SecondsToTicks[5]];               RETURN;               };          <<	  IF label # NIL THEN  	  	toolData.floppyName _ String.CopyToNewString[                    s: label, z: Heap.systemZone]          ELSE toolData.floppyName _ String.CopyToNewString[                    s: "UnnamedFloppy"L, z: Heap.systemZone];>>          IF label # NIL OR toolData.floppyName # NIL THEN {               Put.Text[toolData.fileSW, "label # Nil:"L];               Put.Text[toolData.fileSW, label];               Put.Line[toolData.fileSW, "<"L];               Process.Pause[Process.SecondsToTicks[5]];               toolData.floppyName _ label;               Put.Text[toolData.fileSW, "floppyName:"L];               Put.Text[toolData.fileSW, toolData.floppyName];               Put.Line[toolData.fileSW, "<"L];               Process.Pause[Process.SecondsToTicks[5]];               toolData.floppyName _ String.CopyToNewString[                    s: label, z: Heap.systemZone];               Put.Text[toolData.fileSW, "floppyName:"L];               Put.Text[toolData.fileSW, toolData.floppyName];               Put.Line[toolData.fileSW, "<"L];               };          IF debug THEN {               Put.Line[ILT.toolData.fileSW, toolData.floppyName];               Process.Pause[Process.SecondsToTicks[5]];               };          IF ~ILT.Confirm[] THEN RETURN;  --temp          Put.Text[toolData.fileSW, "Formatting... "L];          Floppy.Format[               0, nFiles, toolData.floppyName, density, sides !               Floppy.Error =>                    SELECT error FROM                         onlyOneSide => {sides _ one; RETRY};                         onlySingleDensity => {density _ single; RETRY};                         badDisk => {                              Put.Line[                                   toolData.fileSW,                                   "Can't format this disk; may be write protecte"L];                              gotError _ TRUE;                              Process.Pause[Process.SecondsToTicks[5]];                              GOTO noGood;                              };                         ENDCASE;               -- ERROR Abort["Can't format this disk; may be write protected"L];               Floppy.AlreadyFormatted => RESUME ];          Put.Line[toolData.fileSW, "...done"L];          EXITS noGood => RETURN;          END;  -- FloppyFormat     FloppyInfo: PROCEDURE [] =          BEGIN          density: Floppy.Density;          sides: Floppy.Sides;          label: STRING _ [Floppy.maxCharactersInLabel];          freeSpace, largestBlock: LONG CARDINAL;          v: Floppy.VolumeHandle;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "InfoDisk...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [v] _ OpenFloppy[];          IF ~opened THEN RETURN;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "GetAttributes...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [freeSpace, largestBlock, , , density, sides] _ Floppy.GetAttributes[               v, label];          toolData.floppyName _ String.CopyToNewString[               s: label, z: Heap.systemZone];          Put.CR[toolData.fileSW];          Put.Text[toolData.fileSW, "Floppy """L];          Put.Text[toolData.fileSW, label];          Put.Text[toolData.fileSW, """; "L];          Put.Text[toolData.fileSW, IF sides = one THEN "single"L ELSE "double"L];          Put.Text[toolData.fileSW, " sided; "L];          Put.Text[               toolData.fileSW, IF density = single THEN "single"L ELSE "double"L];          Put.Line[toolData.fileSW, " density"L];          Put.LongDecimal[toolData.fileSW, freeSpace];          Put.Text[toolData.fileSW, " free pages; largest free block = "L];          Put.LongDecimal[toolData.fileSW, largestBlock];          Put.Line[toolData.fileSW, " pages"L];          AccessFloppy.Close[];          FormSW.DisplayItem[toolData.paramSW, 2];          END;  --FloppyInfo     FloppyList: PROCEDURE [] =          BEGIN          pattern: LONG STRING _ NIL;          v: Floppy.VolumeHandle;          ListOne: EnumProc =               BEGIN               Put.CR[toolData.fileSW];               Put.Text[toolData.fileSW, name];               FOR i: CARDINAL IN [name.length + WritePartial[attributes]..24) DO                    Put.Text[toolData.fileSW, " "]; ENDLOOP;               Put.Number[toolData.fileSW, attributes.type, [10, FALSE, TRUE, 5]];               Put.Text[toolData.fileSW, "  "L];               Put.LongNumber[                    toolData.fileSW, attributes.totalSizeInBytes, [                    10, FALSE, TRUE, 9]];               Put.Text[toolData.fileSW, "  "L];               Put.Date[toolData.fileSW, attributes.createDate, noSeconds];               Put.Text[toolData.fileSW, "  "L];               Put.Date[toolData.fileSW, attributes.lastWrittenDate, noSeconds];               END;  --ListOne          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "ListFiles: AccessFloppy.Open...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [v] _ OpenFloppy[];          IF ~opened THEN RETURN;          Put.Text[toolData.fileSW, " NAME                   "L];  --23           Put.Text[toolData.fileSW, " TYPE  "L];  -- 5+2          Put.Text[toolData.fileSW, "   LENGTH  "L];  -- 9+2          Put.Text[toolData.fileSW, "      CREATE          "L];  -- 20+2          Put.Line[toolData.fileSW, "  WRITE"L];          EnumerateFloppyFiles[               v, ListOne, "*"L !               UNWIND => {AccessFloppy.Close[ ! Floppy.Error => CONTINUE]}];          AccessFloppy.Close[];          END;  --FloppyList     FloppyReadSysout: PUBLIC PROCEDURE [pattern: LONG STRING] RETURNS [BOOLEAN] =          BEGIN          altName: LONG STRING _ NIL;          pagesRemaining: INTEGER _ 1;          created: BOOLEAN _ FALSE;          continue: BOOLEAN _ TRUE;          file: File.File;          firstTime: BOOLEAN _ TRUE;          fFile: Floppy.FileHandle;          firstPage: File.PageNumber;          freePages: Volume.PageCount;          loopCnt: CARDINAL _ 1;          nextFile: LONG STRING _ ILT.toolData.filePathName;          nsName: NSString.String;          readName: LONG STRING _ NIL;          switches: LONG STRING _ NIL;          v: Floppy.VolumeHandle;          volSize: Volume.PageCount;          --ReadOne: EnumProc =          ReadOne: PROCEDURE [               attributes: AccessFloppy.Attributes, fH: Floppy.FileHandle,               name: LONG STRING] RETURNS [stop: BOOLEAN _ FALSE] =               BEGIN               --mFile: MFile.Handle _ NIL;               type: MFile.Type _ unknown;               destName: LONG STRING _ NIL;               srcVFN, destVFN: FileName.VirtualFilename _ NIL;               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "ReadOne"L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               --InvertIndicator[];               IF name # NIL THEN srcVFN _ FileName.AllocVFN[name];               IF String.Length[altName] # 0 THEN                    destVFN _ FileName.AllocVFN[altName]               ELSE destVFN _ FileName.AllocVFN["[dummy]"L];               IF String.Length[destVFN.name] = 0 THEN {                    destName _ FileName.PackFilename[                         srcVFN, FALSE, FALSE, TRUE, FALSE];                    FileName.UnpackFilename[destName, destVFN];                    FileName.FreeFilename[destName];                    };               destName _ FileName.PackFilename[destVFN, FALSE, TRUE, TRUE, FALSE];               Put.Text[ILT.toolData.fileSW, name];               Put.Text[ILT.toolData.fileSW, "... "L];               IF attributes.clientDataLength = 2                    AND attributes.clientData[0] = dataVersion THEN                    type _ attributes.clientData[1];               Put.Text[ILT.toolData.fileSW, "copying to "L];               Put.Text[ILT.toolData.fileSW, destName];               [] _ WritePartial[attributes];               Put.Text[ILT.toolData.fileSW, "... "L];               IF debug THEN {                    Put.LongDecimal[                         ILT.toolData.fileSW, attributes.totalSizeInBytes];                    Process.Pause[Process.SecondsToTicks[5]];                    };               IF attributes.size # 0 THEN                    Floppy.CopyToPilotFile[                         floppyFile: fH, pilotFile: file,                         firstFloppyPage: AccessFloppy.leaderLength,                         firstPilotPage:                         SpecialMFile.LeaderPages[] + attributes.offset,                         count: attributes.size !                         Floppy.Error => {                              Put.Line[                                   ILT.toolData.msgSW,                                   "incompatibleSizes/Insufficient space for floppy file"L];                              continue _ FALSE;                              Process.Pause[Process.SecondsToTicks[5]];                              }];               Put.Line[ILT.toolData.fileSW, "copied"L];               --MFile.Release[mFile];               IF destVFN # NIL THEN FileName.FreeVFN[destVFN];               IF srcVFN # NIL THEN FileName.FreeVFN[srcVFN];               IF destName # NIL THEN FileName.FreeFilename[destName];               --EXITS return => NULL;               END;  --ReadOne;          [volumeID, volumeOpen] _ ILT.GetVolumeID[ILT.toolData.volName];          [volSize, freePages] _ Volume.GetAttributes[volumeID];          [file, firstPage] _ OthelloOps.GetVolumeBootFile[               volumeID, hardMicrocode];          Put.Text[ILT.toolData.fileSW, "Creating file."L];          IF (created _ file = File.nullFile) THEN {               file _ File.Create[                    volumeID, freePages, FileTypes.tUntypedFile !                    Volume.InsufficientSpace => {                         Put.Text[ILT.toolData.fileSW, "."L];                         freePages _ freePages - 100;                         RETRY;                         }];               Put.CR[ILT.toolData.fileSW];               }          ELSE {               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "MakeUnbootable.."L];                    --Process.Pause[Process.SecondsToTicks[10]];                    };               OthelloOps.MakeUnbootable[                    file, hardMicrocode, OthelloDefs.leaderPages];               };          WHILE pagesRemaining > 0 DO               SELECT loopCnt FROM                    1 =>                         Put.Line[                              ILT.toolData.fileSW, "Insert first (#1) floppy "L];                    2 =>                         Put.Line[                              ILT.toolData.fileSW, "Insert second (#2) floppy "L];                    3 =>                         Put.Line[                              ILT.toolData.fileSW, "Insert third (#3) floppy "L];                    4 =>                         Put.Line[                              ILT.toolData.fileSW, "Insert fourth (#4) floppy "L];                    5 =>                         Put.Line[                              ILT.toolData.fileSW, "Insert fifth (#5) floppy "L];                    6 =>                         Put.Line[                              ILT.toolData.fileSW, "Insert sixth (#6) floppy "L];                    ENDCASE =>                         Put.Line[ILT.toolData.fileSW, "Insert next floppy "L];               IF ~ILT.Confirm[] THEN {continue _ FALSE; EXIT; };               [v] _ OpenFloppy[];               IF ~opened THEN RETURN[FALSE];               IF String.Length[ILT.toolData.filePathName] # 0 THEN {                    Put.Text[ILT.toolData.fileSW, "Retrieving... "L];                    Put.Line[ILT.toolData.fileSW, ILT.toolData.filePathName];                    }               ELSE {                    AccessFloppy.Close[ ! Floppy.Error => CONTINUE];                    --ERROR Abort["Please enter source file name(s)."L];                    Put.Line[ILT.toolData.msgSW, "Please enter source file name"L];                    };               atSource _ 0;               IF attributes = NIL THEN                    attributes _ z.NEW[                         AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];               IF String.Length[altName] # 0 THEN FixDirectory[@altName];               readName _ String.MakeString[z, 80];               nextFile _ GetNextFilename[];               IF nextFile = NIL THEN EXIT;               String.AppendStringAndGrow[@readName, nextFile, z, 80];               [] _ Token.FreeTokenString[nextFile];               IF readName = NIL THEN EXIT;               [nsName] _ NSString.StringFromMesaString[readName];               IF WildCards[readName] THEN {                    Put.Line[ILT.toolData.msgSW, "Wild Cards not allowed here"L];                    continue _ FALSE;                    EXIT;                    };               [fFile, continue] _ FileLookUp[nsName];               IF ~continue THEN EXIT;               IF firstTime THEN {                    pagesRemaining _ attributes.totalSize; firstTime _ FALSE; };               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "Floppy.CopyToPilotFile"L];                    Put.Decimal[ILT.toolData.fileSW, AccessFloppy.leaderLength];                    Put.CR[ILT.toolData.fileSW];                    Put.LongDecimal[                         ILT.toolData.fileSW, SpecialMFile.LeaderPages[]];                    Put.CR[ILT.toolData.fileSW];                    Put.Text[ILT.toolData.fileSW, " attributes.offset"L];                    Put.LongDecimal[ILT.toolData.fileSW, attributes.offset];                    Put.CR[ILT.toolData.fileSW];                    Put.Text[ILT.toolData.fileSW, " attributes.size"L];                    Put.LongDecimal[ILT.toolData.fileSW, attributes.size];                    Put.CR[ILT.toolData.fileSW];                    Process.Pause[Process.SecondsToTicks[5]];                    };               [] _ ReadOne[attributes, fFile, NameFromAttributes[attributes]];               pagesRemaining _ pagesRemaining - attributes.size;               Put.LongDecimal[ILT.toolData.fileSW, pagesRemaining];               Put.Line[ILT.toolData.fileSW, " pages more"L];               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "UserInput.UserAbort"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    };               IF UserInput.UserAbort[ILT.windowHandle] THEN {                    Put.Text[ILT.toolData.fileSW, "User Abort! "L];                    Put.Line[ILT.toolData.fileSW, "Aborted"L];                    UserInput.ResetUserAbort[ILT.windowHandle];                    continue _ FALSE;                    };               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "z.FREE"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    };               z.FREE[@attributes];               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "String.FreeString"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    };               IF readName # NIL THEN String.FreeString[z, readName];               IF altName # NIL THEN String.FreeString[z, altName];               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "AccessFloppy.Close"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    };               AccessFloppy.Close[];               IF ~continue THEN EXIT;               loopCnt _ loopCnt + 1;               ENDLOOP;          IF continue THEN {               ILT.ExpandVMemSize[file, volumeID];               ILT.SetupBootFile[file, volumeID];               };          RETURN[continue];          END;  --FloppyReadSysout     FloppyStuff: PUBLIC PROCEDURE =          BEGIN          aborted: BOOLEAN _ FALSE;          IF toolData = NIL THEN toolData _ Heap.systemZone.NEW[Data _ []];          IF attributes = NIL THEN               attributes _ z.NEW[                    AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FloppyStuff...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          floppyWH _ MakeTool[];          BEGIN          ENABLE {               Abort => {Put.Line[toolData.fileSW, s]; aborted _ TRUE; };               AccessFloppy.Error => {                    Put.Text[toolData.fileSW, "unexpected "L];                    WriteAccessFloppyError[type];                    Put.CR[toolData.fileSW];                    aborted _ TRUE;                    };               AccessFloppy.InconsistentFile => {                    Put.Line[toolData.fileSW, "AccessFloppy.InconsistentFile"L];                    aborted _ TRUE;                    };               AccessFloppy.InvalidVersion => {                    Put.Line[toolData.fileSW, "AccessFloppy.InvalidVersion"L];                    aborted _ TRUE;                    };               AccessFloppy.NoRoomForClientData => {                    Put.Line[toolData.fileSW, "AccessFloppy.NoRoomForClientData"L];                    aborted _ TRUE;                    };               Floppy.Error => {                    IF error = writeInhibited THEN                         Put.Line[toolData.fileSW, "Floppy is write protected"L]                    ELSE {                         Put.Text[toolData.fileSW, "unexpected "L];                         WriteFloppyError[error];                         Put.CR[toolData.fileSW];                         };                    aborted _ TRUE;                    };               };          END;          END;  --FloppyStuff     <<     FloppyToDisk: PROC =          BEGIN          handle: MStream.Handle _ NIL;          releaseData: MStream.ReleaseData _ [];          FOR current: Floppy.FileHandle _ Floppy.GetNextFile[nullFile].nextFile,               Floppy.GetNextFile[current].nextFile WHILE current # nullFile DO               scratchName: LONG STRING _ [120];               IF debug THEN {                    Put.Line[toolData.fileSW, ".Floppy.GetFileAttributes...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               [toolData.current.size, toolData.current.type] _                    Floppy.GetFileAttributes[current];               IF debug THEN {                    Put.Line[                         toolData.fileSW, ".AccessFloppy.GetFileAttributes...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               AccessFloppy.GetAttributes[current, attributes];               IF debug THEN {                    Put.Line[toolData.fileSW, ".String.MakeString...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               toolData.current.file _ String.MakeString[                    z, AccessFloppy.maxNameLength];               IF debug THEN {                    Put.Line[                         toolData.fileSW,                         "AccessFloppyUtil.MesaStringFromAttributes...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               MesaStringFromAttributes[attributes, toolData.current.file];               IF debug THEN {                    Put.Line[toolData.fileSW, ".String.AppendString...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               String.AppendString[scratchName, toolData.current.file];               String.AppendString[scratchName, ".Scratch$"L];               IF debug THEN {                    Put.Line[toolData.fileSW, ".String.AppendString...."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               handle _ MStream.ReadWrite[                    name: scratchName, release: releaseData,                    type: MFile.Type[unknown]];               attributes.size _ toolData.current.size;  -- modify size to actual file size.               IF debug THEN {                    Put.Line[toolData.fileSW, "RetrieveFilePiece..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               RetrieveFilePiece[current, handle, attributes];               toolData.numberOfFiles _ toolData.numberOfFiles + 1;               toolData.current _ toolData.current.next _ z.NEW[NextFile _ []];               IF debug THEN {                    Put.Line[toolData.fileSW, "handle.delete..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               handle.delete[handle];               ENDLOOP;          -- will have current points to a NextFile[NIL, NIL].             END;  -- FloppyToDisk.>>     FloppyWrite: PUBLIC PROCEDURE [name: LONG STRING] =          BEGIN          attributes: AccessFloppy.Attributes _ NIL;          altName, switches: LONG STRING _ NIL;          fileType: File.Type _ FileTypes.tUntypedFile;          mFile: MFile.Handle;          --[] _ AccessFloppy.Open[! AccessFloppy.Error => ERROR Abort["Can't open floppy"L]];          [vH] _ OpenFloppy[];          IF ~opened THEN RETURN;          --  DO          BEGIN          ENABLE               UNWIND => {                    IF mFile # NIL THEN MFile.Release[mFile];                    Heap.systemZone.FREE[@attributes];                    AccessFloppy.Close[ ! Floppy.Error => CONTINUE]};          fFile: Floppy.FileHandle;          failed: BOOLEAN _ FALSE;          mFileError: MFile.ErrorCode;          offset, length: CARDINAL;          IF attributes = NIL THEN               attributes _ Heap.systemZone.NEW[                    AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];          mFile _ NIL;          IF name = NIL AND switches = NIL THEN GOTO done;          [offset, length] _ ParsePartial[               name !               Token.SyntaxError => {                    Put.Line[ILT.toolData.fileSW, name];                    Put.Line[ILT.toolData.fileSW, " - bad name syntax"L];                    --SetOutcome[error];                    --LOOP;                    }];          IF switches = NIL THEN altName _ name;          mFile _ MFile.ReadOnly[               name, [] ! MFile.Error => {mFileError _ code; CONTINUE}];          IF mFile = NIL THEN               SELECT mFileError FROM                    noSuchFile => {                         Put.Line[ILT.toolData.msgSW, " not found"L];                         --SetOutcome[error];                         --LOOP;                         };                    conflictingAccess => {                         Put.Line[ILT.toolData.msgSW, " conflicting access"L];                         --SetOutcome[error];                         --LOOP;                         };                    ENDCASE => ERROR Abort[" unexpected MFile.Error"L];          MakeAttributes[mFile, altName, attributes, fileType];          attributes.offset _ offset;          attributes.size _ MIN[length, attributes.totalSize - offset];          --Put.Text[ILT.toolData.msgSW, name];          [] _ WritePartial[attributes];          Put.Text[ILT.toolData.msgSW, "... "L];          Put.Text[ILT.toolData.msgSW, "copying to "L];          Put.Text[ILT.toolData.msgSW, altName];          Put.Text[ILT.toolData.msgSW, "... "L];          IF debug THEN Process.Pause[Process.SecondsToTicks[10]];          fFile _ AccessFloppy.CreateFile[               attributes !               AccessFloppy.Error =>                    IF type = nameInUse THEN {failed _ TRUE; CONTINUE};               Floppy.Error =>                    SELECT error FROM                         fileListFull => ERROR Abort["too many files"L];                         insufficientSpace => ERROR Abort["floppy is full"L];                         ENDCASE];          IF failed THEN {               Put.Line[                    ILT.toolData.msgSW, "floppy file already exists - skipped"L];               Process.Pause[Process.SecondsToTicks[5]];               --SetOutcome[error];               }          ELSE {               IF attributes.size # 0 THEN                    Floppy.CopyFromPilotFile[                         floppyFile: fFile,                         pilotFile: SpecialMFile.GetCapaWithAccess[mFile],                         firstFloppyPage: AccessFloppy.leaderLength,                         firstPilotPage: SpecialMFile.LeaderPages[] + offset,                         count: attributes.size];               Put.Line[ILT.toolData.msgSW, "copied"L]};          Process.Pause[Process.SecondsToTicks[5]];          MFile.Release[mFile];          --ENDLOOP;          EXITS done => NULL;          END;          Heap.systemZone.FREE[@attributes];          AccessFloppy.Close[];          END;  -- FloppyWrite     FormatAndOpen: PROC [] RETURNS [skip: BOOLEAN] =          BEGIN          density: Floppy.Density _ double;          sides: Floppy.Sides _ two;          nFile: CARDINAL _ 2 * toolData.numberOfFiles + 1;          ok: BOOLEAN;          skip _ TRUE;          Put.Line[toolData.fileSW, "Please Remove Floppy Disk, are you ready? "L];          IF ~ILT.Confirm[] THEN RETURN;          Put.Line[toolData.fileSW, "format..."L];          [ok] _ FloppyFormat[nFile, toolData.floppyName, sides, density];          IF ~ok THEN {CleanUp; RETURN};          Put.Line[toolData.fileSW, "...ted"L];          vH _ AccessFloppy.Open[];          nullFile _ [vH, Floppy.nullFileID];          skip _ FALSE;          END;  -- FormatAndOpen.     FormSWDeleteProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "FormSWDeleteProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [] _ FloppyDelete[toolData.pattern];          END;  --FormSWDeleteProc     FormSWDuplicateProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWDuplicateProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Put.Line[toolData.fileSW, "to be implemented"L];          FloppyDuplicate;          END;  --FormSWDuplicateProc     FormSWFormatProc: FormSW.ProcType =          BEGIN          ok: BOOLEAN;          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWFormatProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [ok] _ FloppyFormat[256, toolData.floppyName, default, default];          END;  --FormSWFormatProc     FormSWInfoProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWInfoProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          FloppyInfo;          END;  --FormSWInfoProc     FormSWListProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWListProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          FloppyList;          END;  --FormSWListProc     FormSWReadProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWReadProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Put.Line[toolData.fileSW, "to be implemented"L];          END;  --FormSWReadProc     FormSWWriteProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWWriteProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Put.Line[toolData.fileSW, "to be implemented"L];          FloppyWrite[toolData.pattern];          END;  --FormSWWriteProc     FormSWQuitProc: FormSW.ProcType =          BEGIN          IF toolData # NIL THEN               BEGIN Tool.Destroy[floppyWH]; Heap.systemZone.FREE[@toolData]; END;          END;  --FormSWQuitProc     FormSWVolHintsProc: FormSW.MenuProcType =          BEGIN          RETURN[               hints: DESCRIPTOR[               @ILT.toolData.volHints[0], ILT.toolData.volHints.length],                    freeHintsProc: HintsNoLongerBusy, replace: TRUE];          END;     GetNextFilename: PUBLIC PROC RETURNS [fn: LONG STRING _ NIL] =          BEGIN          MyGet: PROC [Token.Handle] RETURNS [c: CHARACTER] =               BEGIN               IF atSource >= ILT.toolData.filePathName.length THEN c _ Ascii.NUL               ELSE                    BEGIN                    c _ ILT.toolData.filePathName[atSource];                    atSource _ atSource + 1;                    END;               END;          getObject: Token.Object _ [getChar: MyGet, break: Ascii.NUL];          IF atSource >= ILT.toolData.filePathName.length THEN RETURN[NIL];          fn _ Token.Item[h: @getObject, temporary: FALSE];          END;  --GetNextFilename     HintsNoLongerBusy: FormSW.FreeHintsProcType = BEGIN END;     MesaStringFromAttributes: PUBLIC PROC [          attris: AccessFloppy.Attributes, name: LONG STRING] =          BEGIN  -- should protect against a bogus attris (i.e., one from a non AccessFloppy file).          name.length _ 0;          IF attris = NIL THEN               RETURN WITH ERROR AccessFloppy.Error[invalidParameter];          IF attris.length > attris.maxlength THEN  -- invalidAttributes?               RETURN WITH ERROR AccessFloppy.Error[invalidParameter];          IF name.maxlength < attris.length THEN               RETURN WITH ERROR AccessFloppy.Error[invalidParameter];          IF debug THEN {               Put.Line[toolData.fileSW, "Inline.LongCOPY...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [] _ Inline.LongCOPY[               to: @name.text, nwords: attris.length / 2, from: @attris.name];          name.length _ attris.length;          IF name.length # 0 THEN  -- pick up odd character.               name[name.length - 1] _ LOOPHOLE[attris.name[name.length - 1]];          END;  -- MesaStringFromAttributes.     MakeAttributes: PROCEDURE [          file: MFile.Handle, name: LONG STRING,          attributes: AccessFloppy.Attributes, type: File.Type] =          BEGIN          attributes.version _ AccessFloppy.currentVersion;          attributes.type _ type;          attributes.lastWrittenDate _ Time.Current[];          attributes.name _ ALL[0];          attributes.clientDataLength _ 2;          attributes.clientData[0] _ dataVersion;          [length: attributes.totalSizeInBytes, create: attributes.createDate,               type: attributes.clientData[1]] _ MFile.GetProperties[file];          attributes.totalSize _ PagesFromBytes[attributes.totalSizeInBytes];          attributes.size _ attributes.totalSize;          attributes.length _ MIN[name.length, AccessFloppy.maxNameLength];          FOR i: CARDINAL IN [0..attributes.length) DO               attributes.name[i] _ LOOPHOLE[name[i]]; ENDLOOP          END;  --MakeAttributes     MakeCommands: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..5) OF CARDINAL _ [0, 20, 40, 60, 70];          nItems: CARDINAL = 8;          items _ AllocateItemDescriptor[nItems];          items[0] _ CommandItem[               tag: "Info"L, place: newLine, proc: FormSWInfoProc];          items[1] _ CommandItem[tag: "List"L, proc: FormSWListProc];          items[2] _ CommandItem[tag: "Read"L, proc: FormSWReadProc];          items[3] _ CommandItem[tag: "Write"L, proc: FormSWWriteProc];          items[4] _ CommandItem[               tag: "Format"L, place: newLine, proc: FormSWFormatProc];          items[5] _ CommandItem[tag: "Delete"L, proc: FormSWDeleteProc];          items[6] _ CommandItem[tag: "Duplicate"L, proc: FormSWDuplicateProc];          items[7] _ CommandItem[tag: "Quit"L, proc: FormSWQuitProc];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE];          END;  --MakeCommands     MakeParams: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          i, nVols: CARDINAL;          tabs: ARRAY [0..4) OF CARDINAL _ [0, 30, 60, 75];          nItems: CARDINAL = 3;          items _ AllocateItemDescriptor[nItems];          nVols _ ILT.ListLogicalVolumes[];          String.Copy[toolData.volName, ILT.toolData.volHints[0]];          FOR i IN [0..nVols) DO               IF String.Equivalent[ILT.toolData.volHints[i], "Lisp"L] THEN                    BEGIN                    String.Replace[                         @toolData.volName, ILT.toolData.volHints[i],                         Heap.systemZone];                    EXIT;                    END;               ENDLOOP;          items[0] _ StringItem[               tag: "Source Volume"L, place: newLine, string: @toolData.volName,               inHeap: TRUE, menuProc: FormSWVolHintsProc];          items[1] _ StringItem[               tag: "Pattern"L, string: @toolData.pattern, inHeap: TRUE];          items[2] _ StringItem[               tag: "Floppy Name"L, string: @toolData.floppyName, place: newLine,               inHeap: TRUE];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE]          END;  --MakeParams     MakeSWs: Tool.MakeSWsProc =          BEGIN          addresses: ARRAY [0..4) OF ToolDriver.Address;          logName: STRING _ [20];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "MakeSWs...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Tool.UnusedLogName[unused: logName, root: "FloppyOptions.log"L];          toolData.msgSW _ Tool.MakeMsgSW[window: window, lines: 2];          toolData.paramSW _ Tool.MakeFormSW[window: window, formProc: MakeParams];          toolData.commandSW _ Tool.MakeFormSW[               window: window, formProc: MakeCommands];          --note: logName is compulsory, else it bombs               toolData.fileSW _ Tool.MakeFileSW[window: window, name: logName];          --Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];          -- do the ToolDriver stuff          addresses _ [               [name: "msgSW"L, sw: toolData.msgSW],               --[name: "formSW"L, sw: toolData.formSW],               [name: "ParamSW"L, sw: toolData.paramSW], [               name: "CmdSW"L, sw: toolData.commandSW], [               name: "fileSW"L, sw: toolData.fileSW]];          ToolDriver.NoteSWs[               tool: "FloppyOptions"L, subwindows: DESCRIPTOR[addresses]];          END;  --MakeSWs     MakeTool: PROCEDURE RETURNS [wh: Window.Handle] =          BEGIN          heraldName: STRING _ [80];          String.AppendString[heraldName, "XSIS:Xerox Floppy Option"L];          --String.AppendString[heraldName, " of "L];          --Time.Append[heraldName, Time.Unpack[Runtime.GetBcdTime[]]];          --heraldName.length _ heraldName.length - 3;          --String.AppendString[heraldName, " on Pilot Version "L];          --Version.Append[heraldName];          RETURN[               Tool.Create[                    makeSWsProc: MakeSWs, initialState: default,                    --clientTransition: Transit,                     name: heraldName]];          --initialBox: [          --place: sw.BitmapPlace[[10, hisBox.dims.h]],          --dims: [hisBox.dims.w - 20, 180]]];          END;  --MakeTool     NameFromAttributes: PROCEDURE [attributes: AccessFloppy.Attributes]          RETURNS [LONG STRING] = INLINE {RETURN[LOOPHOLE[@attributes.length]]};     OpenFloppy: PROCEDURE [] RETURNS [v: Floppy.VolumeHandle] =          BEGIN          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "OpenFloppy...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          opened _ TRUE;          v _ AccessFloppy.Open[               !               Floppy.Error =>                    SELECT error FROM                         notReady => {                              Put.Line[ILT.toolData.msgSW, "Floppy Not Closed"L];                              IF debug THEN                                   Process.Pause[Process.SecondsToTicks[10]];                              GOTO noGood;                              };                         invalidFormat => {                              Put.Line[                                   ILT.toolData.msgSW, "Invalid Floppy Format"L];                              GOTO noGood;                              };                         needsScavenging => {                              Put.Line[                                   ILT.toolData.msgSW, "Floppy Needs Scavenging"L];                              GOTO noGood;                              };                         ENDCASE];          EXITS noGood => opened _ FALSE;          END;  -- OpenFloppy     ParsePartial: PROCEDURE [name: LONG STRING]          RETURNS [offset: CARDINAL _ 0, length: CARDINAL _ LAST[CARDINAL]] =          BEGIN          h: Token.Handle;          i: CARDINAL;          IF name = NIL THEN RETURN;          FOR i IN [1..name.length) DO               IF name[i] = '[ THEN EXIT; REPEAT FINISHED => RETURN ENDLOOP;          h _ Token.StringToHandle[name, i + 1];          BEGIN          ENABLE UNWIND => [] _ Token.FreeStringHandle[h];          offset _ Token.Decimal[h];          SELECT h.break FROM               '. =>                    IF h.getChar[h] = '. THEN                         length _ Token.Decimal[h] - offset + 1                    ELSE ERROR Token.SyntaxError[NIL];               '! => length _ Token.Decimal[h];               '] => NULL;               ENDCASE => ERROR Token.SyntaxError[NIL];          END;          name.length _ i;          [] _ Token.FreeStringHandle[h];          END;  --ParsePartial     PagesFromBytes: PROCEDURE [bytes: LONG CARDINAL] RETURNS [LONG CARDINAL] =          BEGIN          RETURN[               (bytes + Environment.bytesPerPage - 1) / Environment.bytesPerPage];          END;  --PagesFromBytes     PutVolumeName: PROCEDURE [] =          BEGIN          Put.Text[toolData.fileSW, "Volume = "L];          Put.LongString[toolData.fileSW, toolData.volName];          Put.CR[toolData.fileSW];          END;  --PutVolumeName     <<     RetrieveFilePiece: PROC [          floppyFile: Floppy.FileHandle, mStream: MStream.Handle,          attributes: AccessFloppy.Attributes] =          BEGIN          mFile: MFile.Handle _ NIL;          block: Environment.Block;          bufferSizeInBytes, bytesRemaining, bytesToRead, bytesTransfered:               AccessFloppy.LengthInBytes;          start, pagesToRead: File.PageNumber;          bytesTransfered _ 0;          -- starting page number of the floppy file, page count of the floppy file, and byte count of the floppy file.          start _ 0;          bytesRemaining _ attributes.size*Environment.bytesPerPage;          bufferSizeInBytes _ bufferSize*Environment.bytesPerPage;          -- set attributes          mFile _ MStream.GetFile[mStream];          MFile.SetTimes[               file: mFile, create: attributes.createDate,               write: attributes.lastWrittenDate];          MFile.SetType[mFile, MFile.Type[binary]];          MStream.SetLength[mStream, bytesRemaining];          -- set up block          block.blockPointer _ Space.LongPointer[spaceHandle];          block.startIndex _ 0;          --copy as many chunks of the standard buffer size as possible.....          UNTIL bytesRemaining = 0 DO               bytesToRead _ MIN[bytesRemaining, bufferSizeInBytes];               pagesToRead _ PagesFromBytes[bytesToRead];               Floppy.Read[floppyFile, start, pagesToRead, block.blockPointer];               block.stopIndexPlusOne _ Inline.LowHalf[bytesToRead];               mStream.put[mStream, block, FALSE];               start _ start + pagesToRead;               bytesTransfered _ bytesTransfered + bytesToRead;               bytesRemaining _ bytesRemaining - bytesToRead;               ENDLOOP;          END;  -- RetrieveFilePiece.      StoreFilePiece: PROC [          mStream: MStream.Handle, floppyFile: Floppy.FileHandle,          size: File.PageNumber] =          BEGIN          -- store data from disk to floppy          block: Environment.Block;          bufferSizeInBytes, bytesRemaining, bytesToWrite, bytesTransfered:               AccessFloppy.LengthInBytes;          start, pagesToWrite: File.PageNumber;          why: Stream.CompletionCode _ normal;          bytesTransfered _ 0;          -- starting page number of the floppy file, page count of the floppy file, and byte count of the floppy file.          start _ 0;          bytesRemaining _ (size*Environment.bytesPerPage);          bufferSizeInBytes _ bufferSize*Environment.bytesPerPage;          -- set up block          block.blockPointer _ Space.LongPointer[spaceHandle];          block.startIndex _ 0;          bytesToWrite _ bytesRemaining;          --copy as many chunks of the standard buffer size as possible.....          UNTIL bytesRemaining = 0 OR why = endOfStream DO               bytesToWrite _ MIN[bytesRemaining, bufferSizeInBytes];               block.stopIndexPlusOne _ Inline.LowHalf[bytesToWrite];               [bytesToWrite, why, ] _ mStream.get[                    mStream, block, Stream.defaultInputOptions];               pagesToWrite _ PagesFromBytes[bytesToWrite];               Floppy.Write[floppyFile, start, pagesToWrite, block.blockPointer];               start _ start + pagesToWrite;               bytesTransfered _ bytesTransfered + bytesToWrite;               bytesRemaining _ bytesRemaining - bytesToWrite;               ENDLOOP;          END;  -- StoreFilePiece.>>     Transit: ToolWindow.TransitionProcType =          BEGIN          SELECT TRUE FROM               old = inactive =>                    BEGIN                    IF toolData = NIL THEN                         toolData _ Heap.systemZone.NEW[Data _ []];                    IF attributes = NIL THEN                         attributes _ z.NEW[                              AccessFloppy                              .AttributesRecord[AccessFloppy.maxDataSize]];                    --UserInput.ResetUserAbort[window];                    --data.logSW _ window;                    -- data.window _ ToolWindow.WindowForSubwindow[window];                    -- data.ttyWindow _ TTYSW.GetTTYHandle[window];                    -- destroy _ FALSE;                    active _ TRUE;                    END;               new = inactive =>                    BEGIN                    IF toolData # NIL THEN                         BEGIN                         FormSW.Destroy[toolData.paramSW];                         FormSW.Destroy[toolData.commandSW];                         Heap.systemZone.FREE[@toolData];                         END;                    IF attributes # NIL THEN {                         z.FREE[@attributes]; attributes _ NIL};                    --ToolDriver.RemoveSWs[tool: "LispTool"L];                    active _ FALSE;                    END;               ENDCASE;          END;  -- Transit     WriteAccessFloppyError: PROCEDURE [type: AccessFloppy.ErrorType] =          BEGIN          Put.Text[toolData.fileSW, "AccessFloppy.Error["L];          Put.Text[               toolData.fileSW,               SELECT type FROM                    attributesNotAllowed => "attributesNotAllowed"L,                    fileNotFound => "fileNotFound"L,                    invalidParameter => "invalidParameter"L,                    nameInUse => "nameInUse"L,                    volumeNotOpen => "volumeNotOpen"L,                    ENDCASE => "?"L];          Put.Text[toolData.fileSW, "]"L];          END;  --WriteAccessFloppyError     WriteFloppyError: PROCEDURE [error: Floppy.ErrorType] =          BEGIN          Put.Text[toolData.fileSW, "Floppy.Error["L];          Put.Text[               toolData.fileSW,               SELECT error FROM                    badDisk => "badDisk"L,                    badSectors => "badSectors"L,                    endOfFile => "endOfFile"L,                    fileListFull => "fileListFull"L,                    fileNotFound => "fileNotFound"L,                    hardwareError => "hardwareError"L,                    incompatibleSizes => "incompatibleSizes"L,                    invalidFormat => "invalidFormat"L,                    invalidPageNumber => "invalidPageNumber"L,                    invalidVolumeHandle => "invalidVolumeHandle"L,                    insufficientSpace => "insufficientSpace"L,                    needsScavenging => "needsScavenging"L,                    noSuchDrive => "noSuchDrive"L,                    notReady => "notReady"L,                    onlyOneSide => "onlyOneSide"L,                    onlySingleDensity => "onlySingleDensity"L,                    initialMicrocodeSpaceNotAvailable =>                         "initialMicrocodeSpaceNotAvailable"L,                    stringTooShort => "stringTooShort"L,                    volumeNotOpen => "volumeNotOpen"L,                    writeInhibited => "writeInhibited"L,                    zeroSizeFile => "zeroSizeFile"L,                    ENDCASE => "?"L];          Put.Line[toolData.fileSW, "]"L];          END;  --WriteFloppyError     -- used by both ILT and subwindows     WritePartial: PROCEDURE [attributes: AccessFloppy.Attributes]          RETURNS [chars: CARDINAL _ 0] =          BEGIN          CountedNumber: PROCEDURE [n: LONG CARDINAL] RETURNS [CARDINAL] = {               s: STRING = [12];               String.AppendLongDecimal[s, n];               Put.Text[ILT.toolData.fileSW, s];               RETURN[s.length]};          IF attributes.offset # 0 OR attributes.size # attributes.totalSize THEN {               chars _ 4;               Put.Char[ILT.toolData.fileSW, '[];               chars _ chars + CountedNumber[attributes.offset];               -- Write[".."L];               chars _                    chars + CountedNumber[attributes.offset + attributes.size - 1];               Put.Char[ILT.toolData.fileSW, ']]};          END;  --WritePartial     << 	WriteFiles: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =          BEGIN          attributes: AccessFloppy.Attributes _ NIL;          name, altName, switches: LONG STRING _ NIL;          fileType: File.Type _ FileTypes.tUntypedFile;          mFile: MFile.Handle;          Write: Format.StringProc = Exec.OutputProc[h];          IF gSwitches # NIL THEN               fileType _ [                    String.StringToNumber[                    gSwitches ! String.InvalidNumber => CONTINUE]];          [] _ AccessFloppy.Open[               ! AccessFloppy.Error => ERROR Abort["Can't open floppy"L]];          DO               ENABLE                    UNWIND => {                         IF altName # name THEN                              altName _ Exec.FreeTokenString[altName];                         name _ Exec.FreeTokenString[name];                         switches _ Exec.FreeTokenString[switches];                         IF mFile # NIL THEN MFile.Release[mFile];                         Heap.systemZone.FREE[@attributes];                         AccessFloppy.Close[ ! Floppy.Error => CONTINUE]};               fFile: Floppy.FileHandle;               failed: BOOLEAN _ FALSE;               mFileError: MFile.ErrorCode;               offset, length: CARDINAL;               IF attributes = NIL THEN                    attributes _ Heap.systemZone.NEW[                         AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];               mFile _ NIL;               IF altName # name THEN altName _ Exec.FreeTokenString[altName];               name _ Exec.FreeTokenString[name];               switches _ Exec.FreeTokenString[switches];               [name, switches] _ Exec.GetToken[h];               IF name = NIL AND switches = NIL THEN EXIT;               [offset, length] _ ParsePartial[                    name !                    Token.SyntaxError => {                         Write[name];                         Format.Line[Write, " - bad name syntax"L];                         SetOutcome[error];                         LOOP}];               IF switches # NIL AND switches.length # 0 THEN                    SELECT switches[0] FROM                         's => {                              switches _ Exec.FreeTokenString[switches];                              [altName, switches] _ Exec.GetToken[h]};                         't => {                              fileType _ [                                   String.StringToNumber[                                   name ! String.InvalidNumber => CONTINUE]];                              switches _ Exec.FreeTokenString[switches];                              LOOP};                         ENDCASE               ELSE altName _ name;               mFile _ MFile.ReadOnly[                    name, [] ! MFile.Error => {mFileError _ code; CONTINUE}];               IF mFile = NIL THEN                    SELECT mFileError FROM                         noSuchFile => {                              Format.Line[Write, " not found"L];                              SetOutcome[error];                              LOOP};                         conflictingAccess => {                              Format.Line[Write, " conflicting access"L];                              SetOutcome[error];                              LOOP};                         ENDCASE => ERROR Abort[" unexpected MFile.Error"L];               MakeAttributes[mFile, altName, attributes, fileType];               attributes.offset _ offset;               attributes.size _ MIN[length, attributes.totalSize - offset];               Write[name];               [] _ WritePartial[attributes];               Write["... "L];               Write["copying to "L];               Write[altName];               Write["... "L];               fFile _ AccessFloppy.CreateFile[                    attributes !                    AccessFloppy.Error =>                         IF type = nameInUse THEN {failed _ TRUE; CONTINUE};                    Floppy.Error =>                         SELECT error FROM                              fileListFull => ERROR Abort["too many files"L];                              insufficientSpace => ERROR Abort["floppy is full"L];                              ENDCASE];               IF failed THEN {                    Format.Line[Write, "floppy file already exists - skipped"L];                    SetOutcome[error]}               ELSE {                    IF attributes.size # 0 THEN                         Floppy.CopyFromPilotFile[                              floppyFile: fFile,                              pilotFile: SpecialMFile.GetCapaWithAccess[mFile],                              firstFloppyPage: AccessFloppy.leaderLength,                              firstPilotPage: SpecialMFile.LeaderPages[] + offset,                              count: attributes.size];                    Format.Line[Write, "copied"L]};               MFile.Release[mFile];               ENDLOOP;          Heap.systemZone.FREE[@attributes];          AccessFloppy.Close[];          END;  -- WriteFiles>>     WildCards: PROCEDURE [pattern: LONG STRING] RETURNS [BOOLEAN] =          BEGIN          IF pattern # NIL THEN               FOR i: CARDINAL IN [0..pattern.length) DO                    SELECT pattern[i] FROM '*, '# => RETURN[TRUE]; ENDCASE;                    ENDLOOP;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, " NOT WildCards"L];               Process.Pause[Process.SecondsToTicks[5]];               };          RETURN[FALSE];          END;     END.    