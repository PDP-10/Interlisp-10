<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>Prometheus>PROMOPSIMPL.MESA!1</title>
  </head>
  <body>
    <pre>
-- PromOpsImpl.mesa-- edited by: Masinter.pa on:     23-Aug-84 11:36:52-- edited by: Curbow on:      20-Jun-84 16:43:16DIRECTORY  AccessFloppy USING [    Attributes, AttributesRecord, Close, Error, ErrorType, leaderLength, LookUp,    maxDataSize, Open],  Device USING [PilotDisk, nullType, Type],  DeviceTypes USING [    cdc9730, q2000, q2010, q2020, q2030, q2040, q2080, sa1000, sa1004, sa4000, sa4008,    sa800, t300, t80],  Environment USING [PageCount],  File USING [    Create, Delete, GetAttributes, File, MakePermanent, nullFile, PageCount,    PageNumber, SetSize, Type, Unknown],  Floppy USING [    CopyToPilotFile, DataError, Error, ErrorType, FileHandle, GetAttributes,    nullFileID, nullVolumeHandle, PageCount, PageNumber, Read, VolumeHandle],  FloppyChannel USING [Drive, Error, ErrorType, GetHandle, Handle, Nop],  FormatPilotDisk, FormatPilotDiskExtras,  Heap USING [systemZone],  NSString USING [String, StringFromMesaString],  OthelloOps USING [    BadSwitches, BootFileType, DecodeSwitches, DeleteTempFiles, GetDriveSize,    GetPhysicalVolumeBootFile, GetSwitches, GetVolumeBootFile, MakeBootable,    MakeUnbootable, SetDebugger, SetDebuggerSuccess, SetGetSwitchesSuccess,    SetPhysicalVolumeBootFile, SetSwitches, SetVolumeBootFile,    VoidPhysicalVolumeBootFile, VoidVolumeBootFile],  OthelloDefs USING [LeaderPage, leaderPages, lpVersion, lpNoteLength],  PhysicalVolume USING [    AssertNotAPilotVolume, AssertPilotVolume, CreatePhysicalVolume, Error,    ErrorType, FinishWithNonPilotVolume, GetAttributes,    GetContainingPhysicalVolume, GetHandle, GetHints, GetNext, GetNextBadPage,    GetNextDrive, GetNextLogicalVolume, Handle, ID, InterpretHandle,    NeedsScavenging, MarkPageBad, maxNameLength, maxSubvolumesOnPhysicalVolume,    noProblems, nullBadPage, nullDeviceIndex, nullID, Offline, PageNumber,    RepairType, Scavenge, ScavengerStatus],  Process USING [MsecToTicks, Pause, SecondsToTicks],  PromCommand USING [    AbortOption, CommandTable, CommandTableRecord, workingDriveIndex],  PromIO USING [    ttyHandle, Filter, FormatError, HardError, InputError, ReadLine, ReadName,    ReadNumber, ReadShortNumber, ReadYes, SetIOFilter, WriteChar, WriteCR,    WriteFixedWidthNumber, WriteLine, WriteLongNumber, WriteString],  PromScript USING [AllowStateToBeSaved, GetRootFile, SaveState],  PromTime USING [RestoreTimeZone],  Scavenger USING [Scavenge, Error, ErrorType],  Space USING [Interval, Map, ScratchMap, Unmap],  String USING [    AppendChar, AppendCharAndGrow, AppendLongNumber, AppendString, Equivalent,    FreeString],  System USING [defaultSwitches, PowerOff, Switches],  TemporaryBooting USING [BootButton, BootFromVolume, InvalidParameters],  TextInput USING [GetYesNo],  Time USING [Append, Unpack],  UserTerminal USING [Beep],  Volume USING [    Close, Create, Erase, GetAttributes, GetLabelString, GetStatus, GetType, ID,    InsufficientSpace, nullID, Open, PageCount, Type];PromOpsImpl: PROGRAM  IMPORTS    AccessFloppy, File, Floppy, FloppyChannel, FormatPilotDisk, Heap, NSString,    OthelloOps, PhysicalVolume, Process, PromCommand, PromIO, PromScript, PromTime,    Scavenger, Space, String, System, TemporaryBooting, TextInput, Time,    UserTerminal, Volume  EXPORTS PromCommand  SHARES File, FormatPilotDisk =  BEGIN OPEN PromIO, OthelloOps;  z: UNCOUNTED ZONE &larr; Heap.systemZone;  -- Keep command table alphabetical  commandTable: ARRAY [0..32) OF PromCommand.CommandTableRecord &larr; [    ["--", CodeComment], ["Boot", BootBoot], ["Check Drive", CheckDrive], [    "Close", CloseCmd], ["Comment", WriteComment], ["Confirm", Confirm], [    "Create Physical Volume", CreateVolume], ["Debug", ShowDebugInfo], [    "Delete Boot File", DeleteBootFile], [    "Delete Temporary Files", DeleteTempFilesUser], [    "Diagnostic Microcode Fetch", FetchDiagnosticMicrocode], ["Erase", Erase], [    "Fetch", FetchBoot], ["Format", Format], ["Germ Fetch", FetchGerm], [    "Initial Microcode Fetch", FetchInitialMicrocode], [    "Logical Volume Scavenge", LVScavenge], ["Make Page Bad", MakeBad], [    "Offline", Offline], ["Online", Online], ["Pause", Pause], [    "Physical Volume Scavenge", PVScavenge], [    "Pilot Microcode Fetch", FetchPilotMicrocode], ["Power Off", PowerOff], [    "Quit", Quit], ["Request Floppy", RequestFloppy], [    "Root Fetch", FetchRootFile], ["Save", Save], [    "Set Boot File Default Switches", SetBootFileSwitches], [    "Set Debugger Pointers", SetDebuggerUser], [    "Set Physical Boot Files", SetPvBoot], [    "Specify Default Volume Sizes", SpecifyDefaultVolumeSizes]];  logicalVolumeTypeString: ARRAY Volume.Type OF STRING &larr; [    "normal", "debugger", "debuggerDebugger", "nonPilot"];  DefaultLVSizeData: TYPE = RECORD [    volumeName: StringBody &larr; [maxlength: maxNameLength, length: 0, text:],    txt: PACKED ARRAY [0..maxNameLength) OF CHARACTER &larr; NULL,    sizes: ARRAY [0..nSupportedDiskTypes) OF TypeAndSize];  DiskPageNumber: TYPE = PhysicalVolume.PageNumber;  Handle: TYPE = PhysicalVolume.Handle;  TypeAndSize: TYPE = RECORD [    type: Device.Type &larr; Device.nullType, size: LONG CARDINAL];  bufferPtr: LONG POINTER = Space.ScratchMap[1];  badTableSize: CARDINAL = 200;  carryVolumeOpen: BOOLEAN &larr; FALSE;  defaultLVSizeData: DefaultLVSizeData;  lastCarryName: STRING &larr; [10 + maxNameLength];  lastDriveName: STRING &larr; [10];  lastLvName: STRING &larr; [10 + maxNameLength];  lastPvName: STRING &larr; [10 + maxNameLength];  --  switches:              LONG STRING &larr; NIL;  logicalVolumeOverhead: CARDINAL = 1;  maxNameLength: CARDINAL = PhysicalVolume.maxNameLength;  minLogicalVolumeSize: CARDINAL = 50;  -- fudge + 1+1+6;  nSupportedDiskTypes: CARDINAL = 5;  fileName: STRING &larr; [100];  buffer: ARRAY [1..AccessFloppy.maxDataSize + SIZE[AccessFloppy.AttributesRecord]]    OF WORD &larr; ALL[0];  attributes: AccessFloppy.Attributes &larr; LOOPHOLE[LONG[@buffer]];  -- BUG! The following statement is wrong!  physicalVolumeOverhead should  -- be set based upon device type.  This will be necessary once Pilot  -- knows how to create bad page tables based upon device types.  For  -- the time being, we just KNOW that all bad page tables are one page  -- long, and that as a result there are always two  -- pages of physical volume overhead.  physicalVolumeOverhead: CARDINAL = 2;  LvRecord: TYPE = MACHINE DEPENDENT RECORD [    size: Volume.PageCount &larr; NULL,    type: Volume.Type &larr; NULL,    fill: [0..16000] &larr; 0,    name: StringBody &larr; [maxlength: maxNameLength, length: 0, text:],    txt: PACKED ARRAY [0..maxNameLength) OF CHARACTER &larr; NULL];  VolumeNotFound: ERROR = CODE;  BadSeal: ERROR = CODE;  WrongVersion: ERROR = CODE;  WrongIdOnMarkerPage: ERROR = CODE;  MarkerPageReadFailed: ERROR = CODE;  MarkerPageWriteFailed: ERROR = CODE;  GetCommandTable: PUBLIC PROC RETURNS [PromCommand.CommandTable] = {    RETURN[DESCRIPTOR[commandTable]]};  ---- ---- ---- ---- ---- ---- ---- ----  ----  -- individual commands.  BootBoot: PROC =    BEGIN    lvID: Volume.ID;    ts: System.Switches;    switches: LONG STRING &larr; [100];    lvID &larr; ReadLvID[].lvID;    GetSetBootFileSwitches[      get, lvID ! File.Unknown =&gt; InputError["(can't get default switches)"L]];    ReadLine["switches: "L, switches];    ts &larr; DecodeSwitches[switches ! BadSwitches =&gt; {InputError["Bad Switches"L]}];    PromScript.SaveState[];    TemporaryBooting.BootFromVolume[lvID, ts];    END;  -- of BootBoot  CheckDrive: PROC =    BEGIN    &lt;&lt; Othello version found in OthelloDeviceImplD0DLion.mesa &gt;&gt;    badSpots: CARDINAL;    badSpotArray: ARRAY [0..badTableSize) OF DiskPageNumber;    couldDo: BOOLEAN;    h: Handle;    p: PhysicalVolume.ID &larr; PhysicalVolume.nullID;    wasOnLine: BOOLEAN &larr; FALSE;    [couldDo, badSpots, h] &larr; FormatCheckDrive[@badSpotArray, check];    IF ~couldDo THEN {InputError["Can't check this device."L]; RETURN}    ELSE IF badSpots = 0 THEN {WriteLine["No bad pages found."L]; RETURN};    -- See if was on-line/put on line    DO      p &larr; PhysicalVolume.GetNext[p];      IF p = PhysicalVolume.nullID THEN {        p &larr; PhysicalVolume.AssertPilotVolume[h]; EXIT}      ELSE        IF h = PhysicalVolume.GetAttributes[p].instance THEN {          wasOnLine &larr; TRUE; EXIT};      ENDLOOP;    -- this code depends upon Pilot's bad spot table being smaller than ours,     -- and an error being raised when Pilot's table is full.    FOR i: CARDINAL IN [0..badSpots) DO      PhysicalVolume.MarkPageBad[        p, badSpotArray[i] !        PhysicalVolume.Error =&gt;          IF error = badSpotTableFull THEN {            HardError["Too many bad spots on the System Disk. Cannot proceed."L];            EXIT}];      ENDLOOP;    IF ~wasOnLine THEN PhysicalVolume.Offline[p];    WriteLine["Consider scavenging some volumes."L];    --should scavenger be called automatically? What do we tell the user?    END;  -- of CheckDrive  CloseCmd: PROC =    BEGIN    AccessFloppy.Close[ ! AccessFloppy.Error, Floppy.Error =&gt; CONTINUE];    WriteLine["closed"L];    END;  CodeComment: PROC = BEGIN PromIO.ReadLine[NIL, NIL]; END;  Confirm: PROC =    BEGIN    prompt: LONG STRING &larr; [80];    PromIO.ReadLine[NIL, prompt];    InternalConfirm[prompt];    END;  -- of Confirm  InternalConfirm: PROC [prompt: LONG STRING] =    BEGIN    defaultPrompt: LONG STRING = "OK to proceed? (Y/N)"L;    IF prompt = NIL THEN prompt &larr; defaultPrompt;    IF TextInput.GetYesNo[PromIO.ttyHandle, NSString.StringFromMesaString[prompt]]      # yes THEN ERROR PromCommand.AbortOption[];    END;  -- of InternalConfirm  CreateVolume: PROC =    BEGIN    &lt;&lt; Othello version is found in OthelloDeviceImplD0DLion.mesa &gt;&gt;    h: Handle = ReadDrive[];    badTable: ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber;    bad: CARDINAL &larr; 0;    broughtOnLine: BOOLEAN &larr; FALSE;    driveSize: LONG CARDINAL;    driveType: Device.Type;    nSubVols: CARDINAL;    lvID: Volume.ID;    lvsize: Volume.PageCount;    lvTable: ARRAY [0..10) OF LvRecord &larr; ALL[[]];    pvID: PhysicalVolume.ID &larr; PhysicalVolume.nullID;    pvName: STRING &larr; [maxNameLength];    retryCount: CARDINAL &larr; 0;    PagesRippedOff: PROC RETURNS [p: LONG CARDINAL] =      --we don't really lose pg 0      INLINE {p &larr; MinPilotPage[h]; IF p # 0 THEN p &larr; p - 1};    volumeFound: BOOLEAN &larr; TRUE;    DO      pvID &larr; PhysicalVolume.GetNext[pvID];      IF pvID = PhysicalVolume.nullID THEN        BEGIN        volumeFound &larr; ReadYes["Shall I try to find an old bad page Table? "L];        &lt;&lt; If the physical volume needs Scavenging, just ignore it. We will	be creating a new volume on top, and so there's no reason to waste 	time scavenging it. This is what Othello does. &gt;&gt;        IF volumeFound THEN          BEGIN          broughtOnLine &larr; TRUE;          pvID &larr; PhysicalVolume.AssertPilotVolume[            h !            PhysicalVolume.Error, PhysicalVolume.NeedsScavenging =&gt; {              volumeFound &larr; broughtOnLine &larr; FALSE; CONTINUE}];          END;        EXIT;        END;      IF h = PhysicalVolume.GetAttributes[pvID].instance THEN EXIT;      ENDLOOP;    IF volumeFound THEN      BEGIN OPEN PhysicalVolume;      badTable[bad] &larr; GetNextBadPage[pvID, nullBadPage];      WHILE badTable[bad] # nullBadPage DO        badTable[bad + 1] &larr; GetNextBadPage[pvID, badTable[bad]];        bad &larr; bad + 1;        ENDLOOP;      volumeFound &larr; PhysicalVolume.GetNextLogicalVolume[pvID, Volume.nullID] #        Volume.nullID;      END;    ReadName["New physical volume name: "L, pvName];    nSubVols &larr; ReadShortNumber[      "Number of logical volumes: "L, 1,      PhysicalVolume.maxSubvolumesOnPhysicalVolume, 3];    driveType &larr;      SELECT PhysicalVolume.InterpretHandle[h].type FROM        DeviceTypes.sa1004, DeviceTypes.sa1000 =&gt; DeviceTypes.sa1004,        DeviceTypes.sa4008, DeviceTypes.sa4000 =&gt; DeviceTypes.sa4008,        DeviceTypes.q2040, DeviceTypes.q2000 =&gt; DeviceTypes.q2040,        ENDCASE =&gt; PhysicalVolume.InterpretHandle[h].type;    driveSize &larr;      GetDriveSize[h] -        (physicalVolumeOverhead + nSubVols * logicalVolumeOverhead +           PagesRippedOff[] + LastCylinder[h]);    FOR i: CARDINAL IN [0..nSubVols) DO      OPEN lvTable[i];      defaultVolumeSize: LONG CARDINAL &larr; 0;      WriteString["Logical volume "L];      WriteLongNumber[LONG[i]];      WriteCR[];      DO        duplicate: BOOLEAN &larr; FALSE;        ReadName["  Name: "L, @name];        FOR j: CARDINAL IN [0..i) WHILE ~duplicate DO          duplicate &larr; String.Equivalent[@name, @lvTable[j].name]; ENDLOOP;        IF ~duplicate THEN EXIT;        InputError["Name is already in use; please choose another."L];        ENDLOOP;      --determine default size for this volume.      defaultVolumeSize &larr; driveSize / (nSubVols - i);      IF String.Equivalent[@name, @defaultLVSizeData.volumeName] THEN        FOR i: CARDINAL IN [0..nSupportedDiskTypes) DO          IF driveType = defaultLVSizeData.sizes[i].type THEN            defaultVolumeSize &larr; defaultLVSizeData.sizes[i].size;          ENDLOOP;      size &larr; ReadNumber[        "  Pages: "L, minLogicalVolumeSize,        driveSize - ((nSubVols - (i + 1)) * minLogicalVolumeSize),        defaultVolumeSize];      driveSize &larr; driveSize - size;      type &larr; ReadLvType["  Type: "L];      ENDLOOP;    IF broughtOnLine THEN PhysicalVolume.Offline[pvID];    PhysicalVolume.Offline[pvID ! ANY =&gt; CONTINUE];    pvID &larr; PhysicalVolume.CreatePhysicalVolume[h, pvName];    FOR i: CARDINAL IN [0..bad) DO      PhysicalVolume.MarkPageBad[pvID, badTable[i]] ENDLOOP;    FOR i: CARDINAL IN [0..nSubVols) DO      OPEN lvTable[i];      lvID &larr; Volume.Create[pvID, size, @name, type, MinPilotPage[h]];      IF (lvsize &larr; Volume.GetAttributes[lvID].volumeSize) # size THEN        BEGIN        WriteString[@name];        WriteString["'s size decreased (because of bad pages) to "L];        WriteLongNumber[lvsize];        WriteCR[];        END;      ENDLOOP;    PromTime.RestoreTimeZone[pvID];    END;  -- of CreateVolume      DeleteBootFile: PROC =    BEGIN    lvID: Volume.ID = ReadLvID[].lvID;    pvID: PhysicalVolume.ID = PhysicalVolume.GetContainingPhysicalVolume[lvID];    FOR t: BootFileType IN [hardMicrocode..pilot] DO      bootFile: File.File;      [bootFile] &larr; GetVolumeBootFile[lvID, t];      IF bootFile = File.nullFile THEN LOOP;      Volume.Open[lvID];      BEGIN ENABLE File.Unknown =&gt; CONTINUE; File.Delete[bootFile]; END;      VoidVolumeBootFile[lvID, t];      IF GetPhysicalVolumeBootFile[pvID, t].file = bootFile THEN        VoidPhysicalVolumeBootFile[pvID, t];      Volume.Close[lvID];      ENDLOOP;    END;  -- of DeleteBootFile  DeleteTempFilesUser: PROC = {DeleteTempFiles[ReadLvID[].lvID]};  Erase: PROC =    BEGIN    lvID: Volume.ID &larr; ReadLvID[].lvID;    Volume.Close[lvID];    WriteString["Erase...."L];    Volume.Erase[lvID];    WriteLine["complete"L];    END;  -- of Erase  FetchBoot: PROC = {Fetch[pilot, "Boot file name: "L]};  FetchGerm: PROC = {Fetch[germ, "Germ file name: "L]};  FetchPilotMicrocode: PROC = {    Fetch[softMicrocode, "Pilot microcode file name: "L]};  FetchDiagnosticMicrocode: PROC = {    Fetch[hardMicrocode, "Diagnostic microcode file name: "L]};  Fetch: PROC [type: OthelloOps.BootFileType, prompt: STRING] =    BEGIN    attr: AccessFloppy.Attributes &larr; attributes;    created: BOOLEAN;    bootFile: File.File;    fileHandle: Floppy.FileHandle;    lvID: Volume.ID;    firstPage: File.PageNumber;    FetchInternal: PROC =      BEGIN      fileHandle &larr; AccessFloppy.LookUp[        NSString.StringFromMesaString[fileName], attr];      -- IF a boot file exists on this logical volume already, and       -- not of the same TYPE then delete it.       -- Also remove it as the physical volume boot file as necessary.      IF bootFile # File.nullFile THEN        BEGIN        ENABLE File.Unknown =&gt; {bootFile &larr; File.nullFile; CONTINUE};        oldType: File.Type;        [oldType] &larr; File.GetAttributes[bootFile];        IF oldType # attr.type THEN          BEGIN          pvID: PhysicalVolume.ID = PhysicalVolume.GetContainingPhysicalVolume[            lvID];          File.Delete[bootFile];          OthelloOps.VoidVolumeBootFile[lvID, type];          IF OthelloOps.GetPhysicalVolumeBootFile[pvID, type].file = bootFile THEN            OthelloOps.VoidPhysicalVolumeBootFile[pvID, type];          bootFile &larr; File.nullFile;          END        END;      -- Retrieve the specified floppy file      -- NOTE: Allow OthelloDefs.leaderPages at front of file to contain      -- info about this file, i.e. filename, dates, size, etc.       IF (created &larr; (bootFile = File.nullFile)) THEN        bootFile &larr; File.Create[          lvID, attr.totalSize + OthelloDefs.leaderPages, attr.type]      ELSE        BEGIN        OthelloOps.MakeUnbootable[          bootFile, type, firstPage !          TemporaryBooting.InvalidParameters =&gt; {            PromIO.WriteLine["Warning: trouble making unbootable."L]; CONTINUE}];        File.SetSize[          bootFile, attr.totalSize + OthelloDefs.leaderPages !          Volume.InsufficientSpace =&gt; {            PromIO.WriteLine["Volume Full"L]; ERROR PromCommand.AbortOption[]}];        END;      PromIO.WriteString["Fetching..."L];      Floppy.CopyToPilotFile[        floppyFile: fileHandle, pilotFile: bootFile,        firstFloppyPage: AccessFloppy.leaderLength,        firstPilotPage: attr.offset + OthelloDefs.leaderPages, count: attr.size];      END;  --of FetchInternal    lvID &larr; ReadLvID[].lvID;    Volume.Open[lvID];    PromIO.ReadName[prompt, fileName];    [bootFile, firstPage] &larr; OthelloOps.GetVolumeBootFile[lvID, type];    fileHandle &larr; [Floppy.nullVolumeHandle, Floppy.nullFileID];    FetchInternal[      !      AccessFloppy.Error =&gt; {        SELECT type FROM          volumeNotOpen =&gt; PromIO.InputError["Floppy not open."L];          fileNotFound =&gt; PromIO.InputError["Floppy file not found."L];          ENDCASE =&gt; PromIO.InputError["AccessFloppy Error"L]};      Floppy.Error =&gt;        IF fileHandle.file = Floppy.nullFileID THEN {          SELECT error FROM            fileNotFound =&gt; PromIO.InputError["Floppy file not found."L];            ENDCASE =&gt; PromIO.InputError["Floppy Lookup Error"];          GO TO Return}        ELSE          SELECT error FROM            fileNotFound, endOfFile =&gt; {GetNewFloppy[fileHandle.volume]; RETRY};            ENDCASE; Floppy.DataError =&gt; {GetNewFloppy[fileHandle.volume]; RETRY}];    PromIO.WriteString["Installing..."L];    OthelloOps.SetVolumeBootFile[bootFile, type, OthelloDefs.leaderPages];    File.MakePermanent[bootFile];    IF attr.offset + attr.size = attr.totalSize THEN      BEGIN  &lt;&lt; at end of multiple piece file, or only single piece file&gt;&gt;      lp: LONG POINTER TO OthelloDefs.LeaderPage &larr; Space.Map[        [bootFile, 0, OthelloDefs.leaderPages]].pointer;      note: LONG STRING &larr; [OthelloDefs.lpNoteLength];      note.length &larr; 0;  -- just to be sure.      String.AppendString[to: note, from: fileName];      String.AppendString[to: note, from: "("L];      Time.Append[        s: note, unpacked: Time.Unpack[time: attr.createDate], zone: TRUE];      String.AppendString[to: note, from: ")"L];      lp.version &larr; OthelloDefs.lpVersion;      lp.length &larr; MIN[note.length, OthelloDefs.lpNoteLength];      FOR i: CARDINAL IN [0..lp.length) DO lp.note[i] &larr; note[i]; ENDLOOP;      [] &larr; Space.Unmap[lp];      OthelloOps.MakeBootable[        bootFile, type, OthelloDefs.leaderPages !        TemporaryBooting.InvalidParameters =&gt;          BEGIN          Volume.Close[lvID];          --what happens here if we are fetching the bootfile in pieces?          PromIO.InputError[            IF type # pilot THEN "Can't make file bootable."L            ELSE "Warning: File not complete."L];          GOTO Return;          END];      END;    PromIO.WriteLine["done"L];    IF type IN [hardMicrocode..germ]      AND PromIO.ReadYes["Shall I also use this for the Physical Volume? "L] THEN      OthelloOps.SetPhysicalVolumeBootFile[        bootFile, type, OthelloDefs.leaderPages];    Volume.Close[lvID];    EXITS Return =&gt; NULL;    END;  -- of Fetch  FetchInitialMicrocode: PROC =    BEGIN OPEN DeviceTypes;    &lt;&lt; Othello version found in OthelloDeviceImplD0DLion.mesa    This version very different from Othello one &gt;&gt;    h: Handle = ReadDrive[];    t: Device.Type = GetDriveType[h];    mapped: BOOLEAN &larr; FALSE;    attr: AccessFloppy.Attributes &larr; attributes;    fileHandle: Floppy.FileHandle;    -- Read file name and verify that it exists on Floppy    ReadName["File name: "L, fileName];    fileHandle &larr; AccessFloppy.LookUp[      NSString.StringFromMesaString[fileName], attr !      AccessFloppy.Error =&gt; {        SELECT type FROM          volumeNotOpen =&gt; PromIO.InputError["Floppy not open."L];          fileNotFound =&gt; PromIO.InputError["Floppy file not found."L];          ENDCASE =&gt; PromIO.InputError["AccessFloppy Error"L];        GO TO Return};      Floppy.Error =&gt; {        SELECT error FROM          fileNotFound =&gt; InputError["Floppy file not found."L];          ENDCASE =&gt; InputError["Floppy Lookup Error"];        GO TO Return}];    SELECT t FROM      q2000, q2040, q2080, sa1000, sa1004, sa4000, sa4008, t80, t300 =&gt;        BEGIN OPEN FSa: FormatPilotDisk;        currentPage: File.PageNumber &larr; AccessFloppy.leaderLength;        GetPage: PROC RETURNS [LONG POINTER] =          BEGIN          IF currentPage &gt; attr.size THEN RETURN[NIL];          Floppy.Read[fileHandle, currentPage, 1, bufferPtr];          currentPage &larr; currentPage + 1;          RETURN[bufferPtr];          END;  -- end of GetPage        wasOnline: BOOLEAN = ForceOffline[h];        PhysicalVolume.AssertNotAPilotVolume[h];        &lt;&lt; FormatBootMicrocodeArea may raise the NotAPilotDisk ERROR. &gt;&gt;        {        ENABLE UNWIND =&gt; PhysicalVolume.FinishWithNonPilotVolume[h];        FSa.FormatBootMicrocodeArea[          h: h, passes: 1, retries: 0 ! FSa.NotAPilotDisk =&gt; GOTO BadDevice;          FSa.BadPage =&gt;            BEGIN            WriteString["Warning: page "L];            WriteLongNumber[p];            WriteLine[" is bad (will be skipped). "L];            RESUME            ;            END];        WriteString["Fetching..."L];        FSa.InstallBootMicrocode[h, GetPage]} &lt;&lt; end ENABLE UNWIND&gt;&gt; ;        PhysicalVolume.FinishWithNonPilotVolume[h];        IF wasOnline THEN [] &larr; PhysicalVolume.AssertPilotVolume[h];        WriteLine["Done"L];        END;      ENDCASE =&gt; GOTO BadDevice;    EXITS      BadDevice =&gt; InputError["Cannot install microcode on that device."L];      Return =&gt; NULL;    END;  -- of FetchInitialMicrocode  FetchRootFile: PROC =    BEGIN    attr: AccessFloppy.Attributes &larr; attributes;    fileHandle: Floppy.FileHandle;    rootFile: File.File &larr; File.nullFile;    rootFileVolumeID: Volume.ID;    rootFileVolumeID &larr; ReadLvID[].lvID;    ReadName["Rootfile Name: ", fileName];    fileHandle &larr; AccessFloppy.LookUp[      NSString.StringFromMesaString[fileName], attr !      AccessFloppy.Error =&gt; {        SELECT type FROM          volumeNotOpen =&gt; PromIO.InputError["Floppy not open."L];          fileNotFound =&gt; PromIO.InputError["Floppy file not found."L];          ENDCASE =&gt; PromIO.InputError["AccessFloppy Error"L];        GO TO Return};      Floppy.Error =&gt; {        SELECT error FROM          fileNotFound =&gt; InputError["Floppy file not found."L];          ENDCASE =&gt; InputError["Floppy Lookup Error"];        GO TO Return}];    Volume.Open[rootFileVolumeID];    rootFile &larr; PromScript.GetRootFile[rootFileVolumeID, attr.type, attr.totalSize];    Floppy.CopyToPilotFile[      floppyFile: fileHandle, pilotFile: rootFile,      firstFloppyPage: AccessFloppy.leaderLength, firstPilotPage: attr.offset,      count: attr.size];    Volume.Close[rootFileVolumeID];    EXITS Return =&gt; NULL;    END;  -- of FetchRootFile  Format: PROC =    BEGIN    &lt;&lt; Othello version found in OthelloDeviceImplD0DLion.mesa &gt;&gt;    badSpots: CARDINAL;    badSpotArray: ARRAY [0..badTableSize) OF DiskPageNumber;    couldDo: BOOLEAN;    h: Handle;    p: PhysicalVolume.ID;    [couldDo, badSpots, h] &larr; FormatCheckDrive[@badSpotArray, format];    IF ~couldDo THEN {InputError["Cannot format this device."L]; RETURN};    FOR i: CARDINAL IN [0..MIN[badSpots, LENGTH[badSpotArray]]) DO      IF badSpotArray[i] = 0 THEN {        HardError["Critical System Disk pages bad. Cannot proceed"L]; RETURN};      ENDLOOP;    WriteCR[];    WriteLine["Creating Pilot volume named ""Empty"" to hold bad spot table"L];    p &larr; PhysicalVolume.CreatePhysicalVolume[h, "Empty"L];    FOR i: CARDINAL IN [0..badSpots) DO      PhysicalVolume.MarkPageBad[        p, badSpotArray[i] !        PhysicalVolume.Error =&gt;          IF error = badSpotTableFull THEN GOTO fullBadSpotTable];      ENDLOOP;    PromTime.RestoreTimeZone[p];    PhysicalVolume.Offline[p];    EXITS      fullBadSpotTable =&gt;        HardError["Too many bad spots on the disk. Cannot proceed."L];    END;  -- of Format  ForceOffline: PROC [h: PhysicalVolume.Handle]    RETURNS [wasOnline: BOOLEAN &larr; FALSE] = {    p: PhysicalVolume.ID &larr; PhysicalVolume.nullID;    DO      p &larr; PhysicalVolume.GetNext[p];      IF p = PhysicalVolume.nullID THEN EXIT;      IF h = PhysicalVolume.GetAttributes[p].instance THEN {        wasOnline &larr; TRUE; PhysicalVolume.Offline[p]; EXIT};      ENDLOOP};  FormatCheckDrive: PUBLIC PROC [    bs: POINTER TO ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber,    op: {format, check}]    RETURNS [couldDo: BOOLEAN, badSpots: CARDINAL, h: PhysicalVolume.Handle] = {    -- leaves pv offline for op = format; restores previous state for op = check    cbs: ARRAY [0..badTableSize) OF CARDINAL &larr; ALL[0];    tooManyMsg: BOOLEAN &larr; FALSE;    passes: CARDINAL &larr; 1;    NoteBad: PROC [p: PhysicalVolume.PageNumber] = {      FOR i: CARDINAL IN [0..badSpots) DO        IF bs[i] = p THEN {cbs[i] &larr; cbs[i] + 1; WriteBadSpot[p, cbs[i]]; RETURN}        ENDLOOP;      IF badSpots &lt; LENGTH[bs&uarr;] THEN {        bs[badSpots] &larr; p;        cbs[badSpots] &larr; cbs[badSpots] + 1;        badSpots &larr; badSpots + 1;        WriteBadSpot[p, 1]}      ELSE {        IF ~tooManyMsg THEN {          WriteLine["Too many bad pages"L]; tooManyMsg &larr; TRUE; column &larr; 0};        WriteBadSpot[p, 1]}};  -- end of NoteBad    FormatSummary: PROC = {      IF badSpots &gt; 0 THEN {        column &larr; 0;        WriteLine["\rSummary of bad pages: badPage(countTimesBad)"L];        FOR i: CARDINAL IN [0..badSpots) DO WriteBadSpot[bs[i], cbs[i]] ENDLOOP;        WriteCR[]}};    column: CARDINAL &larr; 0;    WriteBadSpot: PROC [p: PhysicalVolume.PageNumber, cnt: CARDINAL] = {      WriteFixedWidthNumber[p, 8];      WriteChar['(];      WriteFixedWidthNumber[        cnt, SELECT passes FROM IN [0..9] =&gt; 1, IN [10..99] =&gt; 2, ENDCASE =&gt; 3];      WriteChar[')];      IF (column MOD 5) = 4 THEN {column &larr; 0; WriteCR[]} ELSE column &larr; column + 1};    badSpots &larr; 0;    h &larr; ReadDrive[];    SELECT TRUE FROM      -- dam compiler won't coerce [CARDINAL] into CARDINAL      LOOPHOLE[GetDriveType[h], CARDINAL] IN Device.PilotDisk =&gt; {        OPEN FPD: FormatPilotDisk;        pilotStart: PhysicalVolume.PageNumber = MinPilotPage[h];        retries: FormatPilotDisk.RetryLimit &larr; 0;        -- number of retries on bad page        cylSize: CARDINAL = CylinderSize[h];        IF op = format THEN {          passes &larr; CARDINAL[ReadNumber["Number of passes: "L, 1, 200, 10]];          retries &larr; CARDINAL[            ReadNumber[            "Number of retries: "L, FPD.noRetries, FPD.retryLimit, FPD.noRetries]];          [] &larr; ForceOffline[h];          -- format zero'th cylinder separately          PhysicalVolume.AssertNotAPilotVolume[h];          {          ENABLE UNWIND =&gt; PhysicalVolume.FinishWithNonPilotVolume[h];          FPD.Format[            h, 0, cylSize, passes, retries ! FPD.BadPage =&gt; {NoteBad[p]; RESUME }];          -- format rest of disk possibly allowing for alto-type volume          -- or other device dependent dreck          FPD.Format[            h, pilotStart, GetDriveSize[h] - pilotStart, passes, retries !            FPD.BadPage =&gt; {NoteBad[p]; RESUME }]};  -- ENABLE          PhysicalVolume.FinishWithNonPilotVolume[h]}        ELSE {  -- op=scan          wasOnline: BOOLEAN;          wasOnline &larr; ForceOffline[h];          -- scan zero'th cylinder seperatly          FPD.Scan[h, 0, cylSize ! FPD.BadPage =&gt; {NoteBad[p]; RESUME }];          -- scan rest of disk possibly allowing for alto-type volume          -- or other device dependent dreck          FPD.Scan[            h, pilotStart, GetDriveSize[h] - pilotStart !            FPD.BadPage =&gt; {NoteBad[p]; RESUME }];          IF wasOnline THEN [] &larr; PhysicalVolume.AssertPilotVolume[h]};        FormatSummary[];        RETURN[TRUE, badSpots, h]};      ENDCASE =&gt; RETURN[FALSE, badSpots, h]};  -- end of FormatCheckDrive  UnknownCylSize: ERROR = CODE;  CylinderSize: PROC [h: PhysicalVolume.Handle] RETURNS [cylSize: CARDINAL] = {    OPEN FPD: FormatPilotDisk, FPDx: FormatPilotDiskExtras;    SELECT GetDriveType[h] FROM      DeviceTypes.sa1000, DeviceTypes.sa1004 =&gt;        cylSize &larr; FPD.SA1004pagesPerCylinder;      DeviceTypes.q2000 =&gt; cylSize &larr; FPD.Q2040pagesPerCylinder;      DeviceTypes.q2010 =&gt; cylSize &larr; FPD.Q2010pagesPerCylinder;      DeviceTypes.q2020 =&gt; cylSize &larr; FPD.Q2020pagesPerCylinder;      DeviceTypes.q2030 =&gt; cylSize &larr; FPD.Q2030pagesPerCylinder;      DeviceTypes.q2040 =&gt; cylSize &larr; FPD.Q2040pagesPerCylinder;      DeviceTypes.q2080 =&gt; cylSize &larr; FPDx.Q2080pagesPerCylinder;      DeviceTypes.sa4000, DeviceTypes.sa4008 =&gt;        cylSize &larr; FPD.SA4008pagesPerCylinder;      DeviceTypes.t80 =&gt; cylSize &larr; FPD.t80pagesPerCylinder;      DeviceTypes.t300 =&gt; cylSize &larr; FPD.t300pagesPerCylinder;      ENDCASE =&gt; ERROR UnknownCylSize};  GetNewFloppy: PROC [floppyHandle: Floppy.VolumeHandle] =    BEGIN    desiredFloppyName: STRING &larr; [maxNameLength];    [] &larr; Floppy.GetAttributes[floppyHandle, desiredFloppyName];    AccessFloppy.Close[ ! AccessFloppy.Error, Floppy.Error =&gt; CONTINUE];    UserTerminal.Beep[];    WriteCR[always];    WriteLine["Trouble reading this Floppy"L, always];    WriteString["Insert another Floppy Disk labeled """L, always];    WriteString[desiredFloppyName, always];    WriteLine[""" in Floppy Disk Drive."L, always];    UNTIL TextInput.GetYesNo[      PromIO.ttyHandle, NSString.StringFromMesaString[      "Indicate when Floppy Disk is ready"L]] = yes DO ENDLOOP;    RequestFloppyInternal[desiredFloppyName];    END;  LVScavenge: PROC =    BEGIN    lvID: Volume.ID &larr; ReadLvID[].lvID;    scavIfInconsistent: BOOLEAN &larr; ReadYes["Only if inconsistent? "L];    Volume.Close[lvID ! ANY =&gt; CONTINUE];    IF scavIfInconsistent AND Volume.GetStatus[lvID] # closedAndInconsistent THEN      RETURN;    WriteString["Scavenging...."L];    [] &larr; Scavenger.Scavenge[      lvID, lvID, safeRepair, FALSE !      Scavenger.Error =&gt;        SELECT error FROM          needsConversion =&gt; {            WriteLine[              "Needs conversion to current format. Conversion may not be reversible."L];            InternalConfirm[NIL];            [] &larr; Scavenger.Scavenge[lvID, lvID, safeRepair, TRUE]};          needsRiskyRepair =&gt; {            WriteLine["Needs risky repair. Results are not guarenteed."L];            InternalConfirm[NIL];            [] &larr; Scavenger.Scavenge[lvID, lvID, riskyRepair, FALSE]};          cannotWriteLog =&gt; WriteLine["cannotWriteLog"L];          noSuchPage =&gt; WriteLine["noSuchPage"L];          orphanNotFound =&gt; WriteLine["orphanNotFound"L];          volumeOpen =&gt; WriteLine["volumeOpen"L];          diskHardwareError =&gt; WriteLine["diskHardwareError"L];          diskNotReady =&gt; WriteLine["diskNotReady"L];          ENDCASE =&gt; WriteLine["UNKNOWN  ERROR"L]; ];    WriteLine["complete"L];    END;  -- of LVScavenge  MakeBad: PROC =    BEGIN    handle: PhysicalVolume.Handle;    id: PhysicalVolume.ID;    page: PhysicalVolume.PageNumber;    [id, handle] &larr; ReadPvID[];    page &larr; ReadNumber["Decimal Page Number: "L, 0, GetDriveSize[handle] - 1];    PhysicalVolume.MarkPageBad[id, page];    --consider scavenging some volumes    END;  -- of MakeBad  Offline: PROC =    BEGIN    id: PhysicalVolume.ID;    handle: Handle;    [id, handle] &larr; ReadPvID[];    PhysicalVolume.Offline[id];    END;  -- of Offline  Online: PROC =    BEGIN    handle: Handle = ReadDrive[];    [] &larr; PhysicalVolume.AssertPilotVolume[      handle !      PhysicalVolume.Error =&gt;        SELECT error FROM          alreadyAsserted =&gt; CONTINUE;          diskReadError =&gt; {FormatError["not Pilot Volume"L]; CONTINUE};          ENDCASE; ];    END;  -- of Online  Pause: PROC =    BEGIN    Process.Pause[      Process.SecondsToTicks[ReadShortNumber["Seconds: "L, 1, 120, 5]]];    END;  -- Pause  PVScavenge: PROC =    BEGIN OPEN PV: PhysicalVolume;    s: PV.ScavengerStatus;    h: PhysicalVolume.Handle;    verbose: PromIO.Filter;    repair: PV.RepairType;    p: PhysicalVolume.ID &larr; PhysicalVolume.nullID;    h &larr; ReadDrive[];    verbose &larr; IF ReadYes["Verbose? "L] THEN always ELSE debug;    repair &larr;      IF ~ReadYes["Repair? "L] THEN checkOnly      ELSE IF ReadYes["Risky repair? "L] THEN riskyRepair ELSE safeRepair;    DO      IF (p &larr; PhysicalVolume.GetNext[p]) = PhysicalVolume.nullID THEN EXIT;      IF h = PhysicalVolume.GetAttributes[p].instance THEN {        PhysicalVolume.Offline[p]; EXIT};      ENDLOOP;    WriteString["Scavenging...."L];    s &larr; PV.Scavenge[h, repair, TRUE];  &lt;&lt;okayToConvert&gt;&gt;    WriteLine["Complete"L];    IF s = PV.noProblems THEN {WriteLine["No problems detected"L]; RETURN};    SELECT s.internalStructures FROM      damaged =&gt;        WriteLine["Critical disk data structures appear to be damaged"L, always];      repaired =&gt; WriteLine["Critical disk data structures repaired"L, always];      ENDCASE;    SELECT s.badPageList FROM      damaged =&gt; WriteLine["Bad disk page list appears to be damaged"L, always];      lost =&gt; WriteLine["Bad disk page list was lost"L, always];      ENDCASE;    IF s.germ = damaged OR s.softMicrocode = damaged OR s.hardMicrocode = damaged      OR s.bootFile = damaged THEN      WriteLine["Installed software appears to be damaged"L, verbose]    ELSE      IF s.germ = lost OR s.softMicrocode = lost OR s.hardMicrocode = lost        OR s.bootFile = lost THEN        WriteLine["Installed software was lost"L, verbose];    IF s.internalStructures = damaged OR s.badPageList # okay THEN {      WriteLine["Cannot Proceed"L, always]; PromCommand.AbortOption[]; };    PromTime.RestoreTimeZone[];    END;  -- of PVScavenge  PowerOff: PROC = {CloseCmd[]; System.PowerOff[]};  Quit: PROC =    BEGIN    CloseCmd[];    PromScript.SaveState[];    TemporaryBooting.BootButton[];  --BootFromPhysicalVolume?    END;  -- of Quit  RequestFloppy: PROC =    BEGIN    desiredFloppyName: STRING &larr; [maxNameLength];    ReadLine["Label: "L, desiredFloppyName];    RequestFloppyInternal[desiredFloppyName];    END;  -- of RequestFloppy  RequestFloppyInternal: PROC [desiredFloppyName: STRING] =    BEGIN    actualFloppyName: STRING &larr; [maxNameLength];    floppyHandle: Floppy.VolumeHandle;    AwaitFloppyChange: PROC =      BEGIN OPEN FloppyChannel;      --if the floppy is ready, wait until it goes notReady first      UNTIL Nop[        GetHandle[0] ! Error =&gt; IF type = invalidHandle THEN RETRY].notReady DO        Process.Pause[Process.MsecToTicks[3000]]; ENDLOOP;      UNTIL ~Nop[        FloppyChannel.GetHandle[0] !        Error =&gt; IF type = invalidHandle THEN RETRY].notReady DO        Process.Pause[Process.MsecToTicks[3000]]; ENDLOOP;      END;  -- of AwaitFloppyChange    CheckFloppy: PROC =      BEGIN      floppyHandle &larr; AccessFloppy.Open[];      [] &larr; Floppy.GetAttributes[floppyHandle, actualFloppyName];      RestoreBlanks[actualFloppyName];      IF NOT String.Equivalent[desiredFloppyName, actualFloppyName] THEN        BEGIN        AccessFloppy.Close[ ! AccessFloppy.Error =&gt; CONTINUE];        ERROR Floppy.Error[volumeNotOpen];        END;      END;  -- of CheckFloppy    RestoreBlanks[desiredFloppyName];    CheckFloppy[      !      Floppy.Error =&gt;        BEGIN        SELECT error FROM          invalidFormat =&gt;            WriteLine["This Floppy Disk has invalid format."L, always];          needsScavenging =&gt;            WriteLine["This Floppy Disk is not well formed."L, always];          noSuchDrive =&gt; WriteLine["No Floppy Disk drive is known."L, always];          notReady =&gt;            WriteLine["Floppy Disk is not placed in drive properly."L, always];          volumeNotOpen =&gt;            BEGIN            WriteString["This Floppy Disk is labeled """L, always];            WriteString[actualFloppyName, always];            WriteLine[""".", always];            END;          ENDCASE =&gt; REJECT;        UserTerminal.Beep[];        WriteString["Insert Floppy Disk labeled """L, always];        WriteString[desiredFloppyName, always];        WriteLine[""" in Floppy Disk Drive."L, always];        AwaitFloppyChange[];        RETRY;        END];    END;  -- of RequestFloppyInternal  RestoreBlanks: PROC [s: STRING] =    --Replace arrows with blanks.    --Arrows are there to make the name one word.    BEGIN    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '&larr; THEN s[i] &larr; ' ; ENDLOOP;    END;  -- of RestoreBlanks  Save: PROC = {PromScript.AllowStateToBeSaved[ReadLvID[].lvID]; };  SetBootFileSwitches: PROC =    BEGIN    ts: System.Switches;    lvID: Volume.ID;    switches: STRING &larr; [100];    lvID &larr; ReadLvID[].lvID;    GetSetBootFileSwitches[get, lvID];  -- volume.needsScav (caught higher up)    DO      ReadName["switches: "L, switches];      ts &larr; DecodeSwitches[switches ! BadSwitches =&gt; {InputError["bad switches"L]}];      EXIT;      ENDLOOP;    GetSetBootFileSwitches[set, lvID, ts];    END;  SetDebuggerUser: PROC =    BEGIN    bootFile: File.File;    firstPage: File.PageNumber;    lvID: Volume.ID = ReadLvID["for debuggee Logical Volume: "L].lvID;    dLvID: Volume.ID;    dPvID: PhysicalVolume.ID;    dH: Handle;    [bootFile, firstPage] &larr; GetVolumeBootFile[lvID, pilot];    IF bootFile = File.nullFile THEN {InputError["No boot file found."]; RETURN};    [dPvID, dLvID, dH] &larr; ReadLvID["for debugger Logical Volume: "L];    Volume.Open[lvID];    BEGIN    ENABLE UNWIND =&gt; Volume.Close[lvID];    SELECT    (SetDebugger[      debuggeeFile: bootFile, debuggeeFirstPage: firstPage, debugger: dLvID,      debuggerType: GetDriveType[dH], debuggerOrdinal: GetDriveNumber[dH]]) FROM      success =&gt; NULL;      nullBootFile, cantWriteBootFile, notInitialBootFile =&gt;        InputError["Boot file broken."L];      cantFindStartListHeader, startListHeaderHasBadVersion =&gt;        InputError["Boot file header broken."L];      noDebugger =&gt; InputError["No debugger installed."L];      ENDCASE;    END;    Volume.Close[lvID];    END;  SetPvBoot: PROC =    BEGIN    lvID: Volume.ID = ReadLvID["Logical Volume Name: "L].lvID;    pvID: PhysicalVolume.ID = PhysicalVolume.GetContainingPhysicalVolume[lvID];    set: ARRAY BootFileType OF BOOLEAN &larr; ALL[FALSE];    found, changed: BOOLEAN &larr; FALSE;    Smash: PROC [s: STRING, t: BootFileType] =      BEGIN      IF GetVolumeBootFile[lvID, t].file = File.nullFile THEN RETURN;      found &larr; TRUE;      WriteString["Set physical volume "L];      WriteString[s];      IF (set[t] &larr; ReadYes[" from this logical volume? "L]) THEN changed &larr; TRUE;      END;    Smash["boot file"L, pilot];    Smash["pilot microcode"L, softMicrocode];    Smash["germ"L, germ];    Smash["diagnostic microcode"L, hardMicrocode];    IF ~found THEN {WriteLine["Logical volume has null boot files"L]; RETURN};    IF ~changed THEN RETURN;    Volume.Open[lvID];    FOR t: BootFileType IN [hardMicrocode..pilot] DO      IF set[t] THEN        BEGIN        bootFile: File.File;        firstPage: File.PageNumber;        [bootFile, firstPage] &larr; GetVolumeBootFile[lvID, t];        SetPhysicalVolumeBootFile[bootFile, t, firstPage]        END;      ENDLOOP;    Volume.Close[lvID];    END;  ShowDebugInfo: PROC = BEGIN PromIO.SetIOFilter[debug]; END;  SpecifyDefaultVolumeSizes: PROC =    BEGIN    ReadName["  volume name: "L, @defaultLVSizeData.volumeName];    defaultLVSizeData.sizes &larr; [      [      DeviceTypes.sa1004, ReadNumber[      prompt: "  size if sa1004: "L, min: 0, max: 37777777777B, default: 0]], [      DeviceTypes.sa4008, ReadNumber[      prompt: "  size if sa4008: "L, min: 0, max: 37777777777B, default: 0]], [      DeviceTypes.t300, ReadNumber[      prompt: "  size if t300: "L, min: 0, max: 37777777777B, default: 0]], [      DeviceTypes.t80, ReadNumber[      prompt: "  size if t80: "L, min: 0, max: 37777777777B, default: 0]], [      DeviceTypes.q2040, ReadNumber[      prompt: "  size if q2040: "L, min: 0, max: 37777777777B, default: 0]]]    END;  WriteComment: PROC =    BEGIN    s: STRING &larr; [80];    PromIO.ReadLine[NIL, s];    PromIO.WriteLine[s, always];    END;  -- Volume Init Supporting Procedures  unknown: STRING = "Unknown";  GetSetBootFileSwitches: PROC [    getSet: {get, set}, lvID: Volume.ID,    ts: System.Switches &larr; System.defaultSwitches] =    BEGIN    outcome: SetGetSwitchesSuccess;    bootFile: File.File;    firstPage: File.PageNumber;    switches: LONG STRING &larr; NIL;    -- ***** Think this can be deleted.    String.FreeString[z, switches];    Volume.Open[lvID];    [bootFile, firstPage] &larr; GetVolumeBootFile[lvID, pilot];    IF bootFile = File.nullFile THEN InputError["No boot file found."L];    IF getSet = get THEN [outcome, ts] &larr; GetSwitches[bootFile, firstPage]    ELSE outcome &larr; SetSwitches[bootFile, firstPage, ts];    Volume.Close[lvID];    WriteSetDebuggerSuccess[outcome];    IF getSet = set THEN RETURN;    FOR c: CHARACTER IN [0C..377C] DO      IF ts[c] = up THEN LOOP;      SELECT c FROM        '~, '-, '\\, '', '" =&gt; NULL;        IN ['a..'z], IN ['A..'Z], IN (' ..'?] =&gt; {          String.AppendCharAndGrow[@switches, c, z]; LOOP};        ENDCASE =&gt; NULL;      String.AppendCharAndGrow[@switches, '\\, z];      IF c &gt; 77C THEN String.AppendCharAndGrow[@switches, (c - 0C) / 64 + '0, z];      IF c &gt; 7C THEN        String.AppendCharAndGrow[@switches, ((c - 0C) / 8 MOD 8) + '0, z];      String.AppendCharAndGrow[@switches, ((c - 0C) MOD 8) + '0, z];      String.AppendCharAndGrow[@switches, '\\, z]      ENDLOOP;    END;  -- end of GetSetBootFileSwitches  LastCylinder: PROC [h: Handle] RETURNS [LONG CARDINAL] =    BEGIN OPEN FormatPilotDisk, FormatPilotDiskExtras, DeviceTypes;    RETURN[      SELECT PhysicalVolume.InterpretHandle[h].type FROM      sa1000, sa1004 =&gt; SA1004pagesPerCylinder,      q2000 =&gt; Q2040pagesPerCylinder,      q2010 =&gt; Q2010pagesPerCylinder,      q2020 =&gt; Q2020pagesPerCylinder,      q2030 =&gt; Q2030pagesPerCylinder,      q2040 =&gt; Q2040pagesPerCylinder,      q2080 =&gt; Q2080pagesPerCylinder,      sa4000, sa4008 =&gt; SA4008pagesPerCylinder,      t80   =&gt; t80pagesPerCylinder,      t300  =&gt; t300pagesPerCylinder,        ENDCASE =&gt; 0];    END;  --The "ReadMumble" procedures acquire some kind of object from the character stream. Characters are read until the name of a Mumble object is found, and converted to an object with a more usable Mesa type than STRING.  ReadDrive: PROC RETURNS [h: Handle] =    BEGIN    inString: STRING &larr; [20];    DO      index: CARDINAL &larr; PhysicalVolume.nullDeviceIndex;      ReadName["Drive Name: "L, inString, lastDriveName];      FOR i: CARDINAL IN [0..inString.length) DO        lastDriveName[i] &larr; inString[i]; ENDLOOP;      lastDriveName.length &larr; inString.length;      IF inString[inString.length - 1] = ': THEN        inString.length &larr; inString.length - 1;      DO        index &larr; PhysicalVolume.GetNextDrive[index];        IF index = PhysicalVolume.nullDeviceIndex THEN EXIT;        h &larr; PhysicalVolume.GetHandle[index];        IF String.Equivalent[GetDriveStringName[h], inString] THEN RETURN;        ENDLOOP;      FormatError["Drive not found!"L];  --running on the wrong hardware!!      ENDLOOP;    END;  ReadLvID: PROC [prompt: STRING &larr; NIL]    RETURNS [pvID: PhysicalVolume.ID, lvID: Volume.ID, drive: Handle] =    BEGIN    inString: STRING &larr; [10 + maxNameLength];    fullName: STRING &larr; [10 + maxNameLength];    s: LONG STRING &larr; [maxNameLength];    driveString: STRING;    matches: CARDINAL;    tempLvID: Volume.ID;    tempPvID: PhysicalVolume.ID;    IF prompt = NIL THEN prompt &larr; "Logical Volume Name: "L;    DO      ReadName[prompt, inString, lastLvName];      FOR i: CARDINAL IN [0..inString.length) DO        lastLvName[i] &larr; inString[i]; ENDLOOP;      lastLvName.length &larr; inString.length;      matches &larr; 0;      tempPvID &larr; PhysicalVolume.nullID;      DO        tempPvID &larr; PhysicalVolume.GetNext[tempPvID];        IF tempPvID = PhysicalVolume.nullID THEN EXIT;        driveString &larr; GetDriveStringName[          PhysicalVolume.GetAttributes[tempPvID].instance];        -- Form string Drive:LogicalName        FOR i: CARDINAL IN [0..driveString.length) DO          fullName[i] &larr; driveString[i]; ENDLOOP;        fullName[driveString.length] &larr; ':;        tempLvID &larr; Volume.nullID;        DO          match: BOOLEAN;          tempLvID &larr; PhysicalVolume.GetNextLogicalVolume[tempPvID, tempLvID];          IF tempLvID = Volume.nullID THEN EXIT;          GetLogicalVolumeName[tempLvID, s];          FOR i: CARDINAL IN [0..s.length) DO            fullName[i + driveString.length + 1] &larr; s[i]; ENDLOOP;          fullName.length &larr; driveString.length + s.length + 1;          match &larr; String.Equivalent[s, inString]            OR String.Equivalent[fullName, inString];          IF match THEN {matches &larr; matches + 1; lvID &larr; tempLvID; pvID &larr; tempPvID};          ENDLOOP;        ENDLOOP;      SELECT matches FROM        0 =&gt; FormatError["Not found"L];        1 =&gt; {drive &larr; PhysicalVolume.GetAttributes[pvID].instance; RETURN};        ENDCASE =&gt; FormatError["Ambigous; please specify Device:LogicalName"L];      ENDLOOP;    END;  ReadLvType: PROC [prompt: STRING] RETURNS [t: Volume.Type] =    BEGIN    inString: STRING &larr; [30];    DO      ReadName[prompt, inString];      FOR t IN [normal..nonPilot] DO        IF String.Equivalent[logicalVolumeTypeString[t], inString] THEN RETURN;        ENDLOOP;      InputError["Illegal type"L];      ENDLOOP;    END;  -- Accept string of Form LogicalVolumeName OR  --    Drive:LogicalVolumeName  ReadPvID: PROC RETURNS [id: PhysicalVolume.ID, drive: Handle] =    BEGIN    h: Handle;    inString: STRING &larr; [10 + maxNameLength];    fullName: STRING &larr; [10 + maxNameLength];    s: STRING &larr; [maxNameLength];    driveString: STRING;    matches: CARDINAL;    tmpID: PhysicalVolume.ID;    DO      ReadName["Physical Volume Name: "L, inString, lastPvName];      FOR i: CARDINAL IN [0..inString.length) DO        lastPvName[i] &larr; inString[i]; ENDLOOP;      lastPvName.length &larr; inString.length;      matches &larr; 0;      tmpID &larr; PhysicalVolume.nullID;      DO        match: BOOLEAN;        tmpID &larr; PhysicalVolume.GetNext[tmpID];        IF tmpID = PhysicalVolume.nullID THEN EXIT;        h &larr; PhysicalVolume.GetAttributes[tmpID, s].instance;        driveString &larr; GetDriveStringName[h];  -- Form string Drive:PhysicalName        FOR i: CARDINAL IN [0..driveString.length) DO          fullName[i] &larr; driveString[i]; ENDLOOP;        fullName[driveString.length] &larr; ':;        FOR i: CARDINAL IN [0..s.length) DO          fullName[i + driveString.length + 1] &larr; s[i]; ENDLOOP;        fullName.length &larr; driveString.length + s.length + 1;        match &larr; String.Equivalent[s, inString]          OR String.Equivalent[fullName, inString]          OR String.Equivalent[driveString, inString];        IF match THEN {matches &larr; matches + 1; id &larr; tmpID; drive &larr; h};        ENDLOOP;      SELECT matches FROM        0 =&gt; FormatError["Not Found"L];        1 =&gt; RETURN;        ENDCASE =&gt; FormatError["Ambigous; please specify Device:PhysicalName"L];      ENDLOOP;    END;  --The GetMumble routines take one kind of name for an object and convert it to another kind of name for that same object.  GetDriveNumber: PROC [h: Handle] RETURNS [CARDINAL] = {    RETURN[PhysicalVolume.InterpretHandle[h].index]};  GetDriveStringName: PROC [h: Handle] RETURNS [s: STRING] =    BEGIN OPEN DeviceTypes;    s &larr;      SELECT GetDriveType[h] FROM        sa800 =&gt; "Fp?",        q2000, q2010, q2030, q2040, q2080, sa1000, sa4000, sa1004, sa4008, t80, t300 =&gt; "Rd?",        cdc9730 =&gt; "Cd?",        ENDCASE =&gt; "UnknownType?";    s[s.length - 1] &larr; GetDriveNumber[h] + '0;    END;  GetDriveType: PROC [h: Handle] RETURNS [Device.Type] = {    RETURN[PhysicalVolume.InterpretHandle[h].type]};  GetLogicalVolumeName: PROC [vid: Volume.ID, s: LONG STRING] =    BEGIN    s.length &larr; 0;    Volume.GetLabelString[vid, s ! ANY =&gt; GOTO signal];    EXITS      signal =&gt;        BEGIN        f: POINTER TO ARRAY [0..4) OF WORD = LOOPHOLE[@vid];        s.length &larr; 0;        String.AppendChar[s, '[];        FOR i: CARDINAL IN [0..4) DO          String.AppendLongNumber[s, LONG[f[i]], 8];          String.AppendChar[s, ',];          String.AppendChar[s, ' ];          ENDLOOP;        String.AppendChar[s, ']];        END    END;  GetLogicalVolumeTypeName: PROC [vid: Volume.ID] RETURNS [STRING] =    BEGIN    t: Volume.Type;    t &larr; Volume.GetType[vid ! ANY =&gt; GOTO signal];    RETURN[logicalVolumeTypeString[t]];    EXITS signal =&gt; RETURN[unknown];    END;  MinPilotPage: PROC [h: Handle] RETURNS [DiskPageNumber] =    BEGIN OPEN FSa: FormatPilotDisk, DeviceTypes;    dn: CARDINAL = GetDriveNumber[h];    SELECT GetDriveType[h] FROM      q2000, q2010, q2020, q2030, q2040, q2080 =&gt; RETURN[FSa.FirstQ2000PageForPilot];      sa1000, sa1004 =&gt; RETURN[FSa.FirstSA1000PageForPilot];      sa4000, sa4008 =&gt; RETURN[FSa.SA4000FirstPageForPilot[0]];      t80 =&gt; RETURN[FSa.Firstt80PageForPilot];      t300 =&gt; RETURN[FSa.Firstt300PageForPilot];      ENDCASE =&gt; RETURN[0];    END;  WriteSetDebuggerSuccess: PROC [outcome: SetDebuggerSuccess] = {    SELECT outcome FROM      success =&gt; NULL;      nullBootFile, cantWriteBootFile, notInitialBootFile =&gt;        InputError["Boot file broken."L];      cantFindStartListHeader, startListHeaderHasBadVersion =&gt;        InputError["file built by incompatible version of StartPilot"L];      noDebugger =&gt; InputError["No debugger installed."L];      ENDCASE =&gt; ERROR};  Init: PROC =    BEGIN    driveString: STRING;    pvID: PhysicalVolume.ID;    handle: PhysicalVolume.Handle &larr; PhysicalVolume.GetHandle[      PromCommand.workingDriveIndex];    lastDriveName &larr; GetDriveStringName[handle];    pvID &larr; PhysicalVolume.GetHints[handle ! PhysicalVolume.Error =&gt; CONTINUE].pvID;    &lt;&lt; A Physical Volume Name may be     (1) drive name only,     (2) physical volume name only, or     (3) both 1 and 2 seperated by a colon.     Since the drive name is unique by itself, just use that. &gt;&gt;    driveString &larr; GetDriveStringName[handle];    FOR i: CARDINAL IN [0..driveString.length) DO      lastPvName[i] &larr; driveString[i]; ENDLOOP;    lastPvName.length &larr; driveString.length;    lastLvName.length &larr; 0;    END;  -- of Init  &lt;&lt;Main&gt;&gt;  Init[];  END.LOG [Time - Person - Action] 6-Apr-83 16:47:36 - Thorup - Update to Sierra 6-Sep-83 16:21:22 - Curbow - Converted to Klamath 6-Sep-83 16:21:25 - Curbow - Deleted ChangeVolumeType 27-Sep-83 10:16:41 - Curbow - Replaced FormatCheckDrive from Othello&gt;OthelloDeviceImplD0DLion 18-Oct-83 14:48:28 - Curbow - Cleanup Klamath conversion code 1-Nov-83 10:46:27 - Curbow - Catch errors from PhysicalVolume and handle.19-Dec-83 13:12:32 - Curbow - Convert to Services 8.0. Replace NSCommand with TextInput13-Feb-84 16:51:45 - Curbow - Add catchphrase for AccessFloppy calls.13-May-84 15:19:19 - Curbow - Fixed AccessFloppy.AttributesRecord being stomped (ar #6614).12-Jun-84 12:31:55 - Curbow - Changed all Floppy.Close calls to AccessFloppy.Close so that CACHE in AccessFloppy would work correctly.19-Jun-84 17:33:38 - Curbow - Fixed AR 7455 (Doesn't preserve create dates of installed files)20-Jun-84 16:35:58 - Curbow - Fixed AR 8382 - Handle multiple drives correctly.20-Jun-84 16:42:59 - Curbow - Purge log of Pre-1983 info.28-Jun-84 14:25:45 - Curbow - Update CreateVolume to handle PhysicalVolume.NeedsScavenging the same way as Othello does.28-Jun-84 14:25:49 - Curbow - Modify fix for AR 7455 to record the same info as Othello per Davirro.PA28-Jun-84 17:19:52 - Curbow - Make sure that all AccessFloppy calls catch Floppy.Error in addition to AccessFloppy.Error AR #921723-Aug-84 11:36:28 - Masinter - add q2080</pre>
  </body>
</html>
