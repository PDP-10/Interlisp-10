<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>InstallLisp>INSTALLLISPIMPL.MESA!2</title>
  </head>
  <body>
    <pre>
-- InstallImpl.mesa - last edit:-- Masinter, add comments-- Lichtenberg  Aug 1984, from Install-- Daniels	13-Jun-83 14:09:06-- Loretta	20-Apr-83 12:12:48-- Karlton	19-Aug-83 16:07:42-- Bruce	 2-Sep-81 15:25:10-- Johnsson	16-Jan-84  9:12:07DIRECTORY  Environment: TYPE USING [bytesPerPage, PageCount, PageNumber, PageOffset],  Exec: TYPE USING [    AddCommand, CheckForAbort, Confirm, EndOfCommandLine, ExecProc,    FreeTokenString, GetNameandPassword, GetToken, Handle, Outcome, OutputProc],  File: TYPE USING [    Create, Delete, File, MakePermanent, nullFile, PageCount, PageNumber,    SetSize, GetSize, Type, Unknown],  FileName: TYPE USING [AllocVFN, FreeVFN, NormalizeVFN, VFN],  FileTransfer: TYPE USING [    ClientProc, Connection, Create, Destroy, Error, GetStreamInfo, MessageProc,    ReadStream, SetPrimaryCredentials, SetProcs],  FileTypes: TYPE USING [tUntypedFile],  Format: TYPE USING [Line, StringProc],  Heap: TYPE USING [systemZone],  OthelloDefs: TYPE USING [LeaderPage, leaderPages, lpNoteLength, lpVersion],  OthelloOps: TYPE USING [    GetVolumeBootFile, MakeBootable, MakeUnbootable,    SetVolumeBootFile, SetPhysicalVolumeBootFile],  PrincOps: TYPE USING [Port],  Space: TYPE USING [CopyOut, Interval, Map, PageCount, PageOffset, Unmap],  SpecialVolume: TYPE USING [OpenVolume],  Stream: TYPE USING [Delete, GetBlock, Handle],  String: TYPE USING [    AppendCharAndGrow, AppendString, AppendStringAndGrow, CopyToNewString,    Empty, EqualString, EquivalentString, StringBoundsFault, Length],  TemporaryBooting: TYPE USING [InvalidParameters, BootButton],  Time: TYPE USING [Append, Unpack],  Volume: TYPE USING [    Close, GetLabelString, GetNext, GetStatus, GetType, ID, InsufficientSpace,    maxNameLength, NeedsScavenging, nullID, Status, systemID, Type, TypeSet,    GetAttributes];InstallLispImpl: MONITOR  IMPORTS    Exec, File, FileName, FileTransfer, Format, Heap, OthelloOps,    Space, SpecialVolume, Stream, String, Time, TemporaryBooting, Volume =  BEGIN  volumeName: STRING = [Volume.maxNameLength];  volume: Volume.ID &larr; Volume.nullID;  volumeOpened: BOOLEAN &larr; FALSE;  originalVolumeStatus: Volume.Status &larr; unknown;  write: Format.StringProc &larr; NIL;  exec: Exec.Handle &larr; NIL;    expandVolume: BOOLEAN &larr; FALSE;  setDefault: BOOLEAN &larr; FALSE;  startLisp: BOOLEAN &larr; FALSE;    InstallFiles: ENTRY Exec.ExecProc = {    ENABLE UNWIND =&gt; {volumeOpened &larr; FALSE};    token, switches: LONG STRING &larr; NIL;    haveOne: BOOLEAN &larr; FALSE;    FreeTokens: PROCEDURE = {      [] &larr; Exec.FreeTokenString[token]; [] &larr; Exec.FreeTokenString[switches]};    exec &larr; h;    write &larr; h.OutputProc[];    [] &larr; SetVolumeName["Extra"L];        expandVolume &larr; FALSE;    setDefault &larr; FALSE;    startLisp &larr; FALSE;    UNTIL h.EndOfCommandLine[] DO  -- parse command line      ENABLE UNWIND =&gt; FreeTokens[];      [token, switches] &larr; h.GetToken[];      CheckSwitches[switches];      IF String.Empty[token] THEN {        outcome &larr; IF haveOne THEN error ELSE InstallHelp[h]; EXIT};      IF ~SetVolumeName[token] THEN {        write["Error: volume "L];        write[token];        write[" not found!"L];        outcome &larr; error;        EXIT};      FreeTokens[];      [token, switches] &larr; h.GetToken[];      CheckSwitches[switches];      IF String.Empty[token] THEN IF ~DoNoFileOps[] THEN outcome &larr; abort;      IF outcome = abort THEN EXIT;      IF ~String.Empty[switches] OR ~String.EqualString[token, "&larr;"L] THEN {        write["Missing ""&larr;""; OK to continue?"L];        IF ~h.Confirm[] THEN {outcome &larr; abort; EXIT}}      ELSE {FreeTokens[]; [token, switches] &larr; h.GetToken[]};      CheckSwitches[switches];      IF h.CheckForAbort[] THEN {outcome &larr; abort; EXIT};      IF ~String.Empty[token] THEN        IF startLisp THEN Format.Line[write,"Will boot Lisp when done."L];	IF expandVolume THEN Format.Line[write,"Will expand VMem size"L];	IF setDefault THEN Format.Line[write,"Will make this default lisp"L];        outcome &larr; InstallFileOnVolume[token ! UNWIND =&gt; CloseVolume[]];      haveOne &larr; TRUE;      REPEAT FINISHED =&gt; IF ~haveOne THEN outcome &larr; InstallHelp[h]      ENDLOOP;    FreeTokens[];    IF startLisp THEN TemporaryBooting.BootButton[];    };      DoNoFileOps: PROC RETURNS [foo: BOOLEAN] = BEGIN    OPEN OthelloOps;     file: File.File;     firstPage: File.PageNumber;          IF ~(expandVolume OR setDefault OR startLisp) THEN RETURN[TRUE];     IF ~OpenVolume[] THEN RETURN[FALSE];     [file, firstPage] &larr; GetVolumeBootFile[volume,hardMicrocode];     IF file = File.nullFile THEN {     	    Format.Line[write,"No sysout on that volume"L];	    RETURN[FALSE]	    };     IF expandVolume THEN      	{MakeUnbootable[file,hardMicrocode,firstPage];	 SetBootFileSize[file,volume];	 MakeBootable[file,hardMicrocode,firstPage];	 };     IF startLisp OR setDefault THEN SetPhysicalVolumeBootFile[file,hardMicrocode, firstPage];     CloseVolume[];     IF startLisp THEN TemporaryBooting.BootButton[];   END;     CheckSwitches: PROC [switches: LONG STRING] = BEGIN      i: CARDINAL;      length: CARDINAL &larr; String.Length[switches];      IF ~String.Empty[switches] THEN       FOR i IN [0..length) DO          SELECT switches[i] FROM	   'x,'X =&gt; expandVolume &larr; TRUE;	   'd,'D =&gt; setDefault &larr; TRUE;	   's,'S =&gt; startLisp &larr; TRUE;	 ENDCASE =&gt; {};        ENDLOOP;   END;  SetVolumeName: PROCEDURE [v: LONG STRING] RETURNS [ok: BOOLEAN &larr; TRUE] = {    CloseVolume[];    volumeName.length &larr; 0;    String.AppendString[      volumeName, v !      String.StringBoundsFault =&gt; {        write["Volume name too long!"L]; ok &larr; FALSE; CONTINUE}]};  OpenVolume: PROCEDURE RETURNS [BOOLEAN] = {    OPEN Volume;    myType: Volume.Type = Volume.GetType[Volume.systemID];    all: TypeSet &larr; [      normal: TRUE, debugger: myType = debugger OR myType = debuggerDebugger,      debuggerDebugger: myType = debuggerDebugger];    name: STRING = [maxNameLength];    IF ~volumeOpened THEN {      FOR volume &larr; GetNext[nullID, all], GetNext[volume, all] UNTIL volume =        nullID DO        name.length &larr; 0;        GetLabelString[volume, name];        IF String.EquivalentString[name, volumeName] THEN EXIT;        ENDLOOP;      SELECT volume FROM        nullID =&gt; {          write[volumeName]; Format.Line[write, " not found!"L]; RETURN[FALSE]};        Volume.systemID =&gt; {          write[volumeName];          Format.Line[write, " is your system volume!"L];          RETURN[FALSE]};        ENDCASE;      SELECT (originalVolumeStatus &larr; Volume.GetStatus[volume]) FROM        openRead =&gt; Volume.Close[volume];        openReadWrite =&gt; RETURN[TRUE];        unknown, partiallyOnLine, closedAndInconsistent =&gt; RETURN[FALSE];        ENDCASE =&gt; NULL;      SpecialVolume.OpenVolume[volume: volume, access: readWrite        ! Volume.NeedsScavenging =&gt; GOTO YouLose];      volumeOpened &larr; TRUE};    RETURN[TRUE];    EXITS YouLose =&gt; {      write[volumeName];      Format.Line[write, " needs scavenging."L];      RETURN[FALSE]}};  CloseVolume: PROC = {    IF volumeOpened THEN {      Volume.Close[volume];      IF originalVolumeStatus = openRead THEN        SpecialVolume.OpenVolume[volume: volume, access: read];      volumeOpened &larr; FALSE}};  PortRep: TYPE = PrincOps.Port;  InstallFileOnVolume: PROC [name : LONG STRING]    RETURNS [outcome: Exec.Outcome &larr; normal] = { -- from OthelloFTP (sort of)    OPEN OthelloOps;    created: BOOLEAN &larr; FALSE;    file: File.File;    firstPage: File.PageNumber;    -- clean the PORT up from last time    LOOPHOLE[GetFile, PortRep].in &larr; 0;    -- CONNECT GetFile.out TO Retrieve;    LOOPHOLE[GetFile, PortRep].out &larr; LOOPHOLE[Retrieve];    write["Opening "];    write[volumeName];    write["... "L];    IF ~OpenVolume[] THEN RETURN[error] ELSE Format.Line[write, " open."L];    [file, firstPage] &larr; GetVolumeBootFile[volume, hardMicrocode];    IF NOT GetFile[name: name] THEN {CloseVolume[]; RETURN[error]};    IF (created &larr; file = File.nullFile) THEN      file &larr; File.Create[volume, 1, FileTypes.tUntypedFile]    ELSE      MakeUnbootable[        file, hardMicrocode, firstPage !	File.Unknown =&gt; CONTINUE;        TemporaryBooting.InvalidParameters =&gt; {	  outcome &larr; warning;          write["Warning: trouble making unbootable"L]; CONTINUE}];    write[" Fetching... "L];    IF NOT GetFile[      file: file ! UNWIND =&gt; {IF created THEN file.Delete; CloseVolume[]}]      THEN {IF created THEN file.Delete; CloseVolume[]; RETURN[error]};    write["Installing..."L];    SetVolumeBootFile[file, hardMicrocode, OthelloDefs.leaderPages];    file.MakePermanent;    File.SetSize[file,File.GetSize[file]+1];    IF expandVolume THEN {       write["Expanding..."L];       SetBootFileSize[file,volume];       write["OK..."L];       };    MakeBootable[      file, hardMicrocode, OthelloDefs.leaderPages !      TemporaryBooting.InvalidParameters =&gt; {	outcome &larr; warning;        write["Warning: trouble making bootable"L]; CONTINUE}];    IF setDefault THEN OthelloOps.SetPhysicalVolumeBootFile[file,hardMicrocode, OthelloDefs.leaderPages];    Format.Line[write, " installed."L];    CloseVolume[]};      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      SetBootFileSize: PRIVATE PROC[file: File.File, lvID: Volume.ID] = BEGIN    oldSize: File.PageCount &larr; File.GetSize[file];    newSize: File.PageCount &larr; oldSize + Volume.GetAttributes[lvID].freePageCount;    File.SetSize[file, newSize 	  ! File.Unknown =&gt; {write["Warning: Trouble making file fill volume - File.Unknown"L];	    CONTINUE};	    Volume.InsufficientSpace =&gt; {write["."L]; newSize &larr; newSize - 100;	    IF newSize &lt; oldSize THEN CONTINUE ELSE RETRY}];    END;       --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetFile: PORT [    file: File.File &larr; File.nullFile, name: LONG STRING &larr; NIL]    RETURNS [BOOLEAN];  Retrieve: PROC [file: File.File, name: LONG STRING]    RETURNS [gotIt: BOOLEAN &larr; TRUE] = {    OPEN FileName, FileTransfer;    ResumeSetup: PORT [BOOLEAN]      RETURNS [file: File.File, name: LONG STRING];    Cleanup: PROC = {      IF readStream # NIL THEN {readStream.Delete; readStream &larr; NIL};      IF buffer # NIL THEN buffer &larr; Space.Unmap[buffer];      IF vfn # NIL THEN {FreeVFN[vfn]; vfn &larr; NIL};      IF conn # NIL THEN {conn.Destroy; conn &larr; NIL}};    LoginUser: FileTransfer.ClientProc = {      user: STRING = [64];      password: STRING = [64];      exec.GetNameandPassword[user, password];      conn.SetPrimaryCredentials[user: user, password: password]};    Message: MessageProc = {write[s1]; write[s2]; write[s3]; write[s4]};    bufferPages: Space.PageCount = 64;    bufferBytes: CARDINAL = CARDINAL[bufferPages*Environment.bytesPerPage];    buffer: LONG POINTER &larr; NIL;    conn: Connection &larr; FileTransfer.Create[];    vfn: VFN &larr; NIL;    readStream: Stream.Handle &larr; NIL;    fileSize: File.PageCount;    -- CONNECT ResumeSetup.out TO GetFile    LOOPHOLE[ResumeSetup, PortRep].out &larr; @GetFile;    -- CONNECT GetFile.out TO ResumeSetup    LOOPHOLE[GetFile, PortRep].out &larr; @ResumeSetup;    conn.SetProcs[clientData: NIL, messages: Message, login: LoginUser];    vfn &larr; AllocVFN[name];    readStream &larr; conn.ReadStream[files: vfn ! Error =&gt; {Cleanup[]; GOTO noGood}];    file &larr; ResumeSetup[gotIt].file;    fileSize &larr;      (FileTransfer.GetStreamInfo[readStream].size + Environment.bytesPerPage -         1)/Environment.bytesPerPage + OthelloDefs.leaderPages;    file.SetSize[      fileSize !      Volume.InsufficientSpace =&gt; {        write["Not enough room for file!"L]; Cleanup[]; GOTO noGood}];    buffer &larr; Space.Map[      window: [file: File.nullFile, base: NULL, count: bufferPages],       class: data, swapUnits: [uniform[4]]].pointer;    SetLeaderPage[file, readStream, vfn];    FOR windowPage: Space.PageOffset &larr; OthelloDefs.leaderPages,      windowPage + bufferPages WHILE windowPage &lt; fileSize DO      bytesTransferred: CARDINAL &larr; readStream.GetBlock[        [buffer, 0, bufferBytes]].bytesTransferred;      [] &larr; Space.CopyOut[buffer, [file, windowPage, bufferPages]];      ENDLOOP;    Cleanup[];    RETURN[TRUE];    EXITS noGood =&gt; RETURN[FALSE]};   SetLeaderPage: PROC [    file: File.File, stream: Stream.Handle, vfn: FileName.VFN] = {    lp: LONG POINTER TO OthelloDefs.LeaderPage = Space.Map[      [file, 0, OthelloDefs.leaderPages]].pointer;    note: LONG STRING &larr; Heap.systemZone.NEW[StringBody[60]];    -- STARTKLUDGE: work around the FileTransfer not giving the host name    &lt;&lt;String.AppendStringAndGrow[      @note, FileTransfer.GetStreamName[stream], Heap.systemZone];&gt;&gt;    vfn.NormalizeVFN;    IF NOT String.Empty[vfn.host] THEN {      String.AppendStringAndGrow[@note, "["L, Heap.systemZone];      String.AppendStringAndGrow[@note, vfn.host, Heap.systemZone];      String.AppendStringAndGrow[@note, "]"L, Heap.systemZone]};    IF NOT String.Empty[vfn.directory] THEN {      String.AppendStringAndGrow[@note, vfn.directory, Heap.systemZone];      String.AppendStringAndGrow[@note, "&gt;"L, Heap.systemZone]};    IF NOT String.Empty[vfn.name] THEN      String.AppendStringAndGrow[@note, vfn.name, Heap.systemZone];    IF NOT String.Empty[vfn.version] THEN {      String.AppendStringAndGrow[@note, "!"L, Heap.systemZone];      String.AppendStringAndGrow[@note, vfn.version, Heap.systemZone]};    -- ENDKLUDGE    String.AppendStringAndGrow[@note, " ("L, Heap.systemZone];    -- STARTKLUDGE: Time.Append screws up on StringBoundsFault    {oldLength: CARDINAL = note.length;    Time.Append[      s: note, zone: TRUE,      unpacked: Time.Unpack[FileTransfer.GetStreamInfo[stream].create] !      String.StringBoundsFault =&gt; {        ns &larr; String.CopyToNewString[	  s: note, z: Heap.systemZone, longer: s.maxlength - s.length + 20];	Heap.systemZone.FREE[@note];	note &larr; ns;	note.length &larr; oldLength;        RETRY}];    };-- ENDKLUDGE    String.AppendCharAndGrow[@note, '), Heap.systemZone];    lp.version &larr; OthelloDefs.lpVersion;    lp.length &larr; MIN[note.length, OthelloDefs.lpNoteLength];    FOR i: CARDINAL IN [0..lp.length) DO      lp.note[i] &larr; note[i];      ENDLOOP;    [] &larr; Space.Unmap[lp];    Heap.systemZone.FREE[@note]};      InstallHelp: Exec.ExecProc = {    Format.Line[      h.OutputProc[],      "Command format: InstallLisp.~ volume &larr; sysoutfile          Switches: /x to expand volume file size	            /d to make this lisp the boot lisp	            /s to start lisp from this volume"L]};  {Exec.AddCommand["InstallLisp.~"L, InstallFiles, InstallHelp]};  END.</pre>
  </body>
</html>
