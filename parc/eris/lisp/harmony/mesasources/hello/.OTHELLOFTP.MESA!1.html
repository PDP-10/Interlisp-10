<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>Hello>OTHELLOFTP.MESA!1</title>
  </head>
  <body>
    <pre>
-- file: OthelloFTP.mesa-- Edited by-- Lichtenberg  6-Jul-84 18:54:38 - Lisp stuff-- Johnsson,  15-Sep-83 15:40:26-- Sandman,   October 11, 1979  8:33 AM-- Gobbel,    February 14, 1980  7:30 PM-- Forrest,   13-Jan-82 10:22:30-- Bruce,     28-Dec-81 10:19:42DIRECTORY  Environment USING [bytesPerPage, bytesPerWord],  Heap USING [systemZone],  File USING [    Create, Delete, File, MakePermanent, nullFile, PageNumber, PageCount, GetSize, SetSize, Unknown],  FileTypes USING [tUntypedFile],  OthelloDefs,  OthelloOps USING [    BootFileType, GetVolumeBootFile,    MakeBootable, MakeUnbootable, SetPhysicalVolumeBootFile,    SetVolumeBootFile],  PhysicalVolume USING [ID],  Process USING [Detach, Pause, SecondsToTicks],  Space USING [Map, ScratchMap, Unmap],  STP USING [    Close, Connect, Create, CreateRemoteStream, Enumerate, Error,    ErrorCode, FileInfo, GetFileInfo, Handle, IsOpen, Login, NextFileName,     NoteFileProcType, Open, SetDirectory, SetHost],  Stream USING [EndOfStream, GetBlock, Handle],  String USING [    AppendChar, AppendCharAndGrow, AppendExtensionIfNeeded,    AppendStringAndGrow, CopyToNewString, Length],  TemporaryBooting USING [InvalidParameters],  Volume USING [Close, ID, InsufficientSpace, Open, GetAttributes];OthelloFTP: PROGRAM  IMPORTS    File, Heap, OthelloDefs, OthelloOps,    Process, Space, STP, Stream, String, TemporaryBooting, Volume  EXPORTS OthelloDefs =  BEGIN OPEN OthelloOps;  host:            LONG STRING &larr; NIL;  userName:        LONG STRING &larr; NIL;  userPassword:    LONG STRING &larr; NIL;  connectName:     LONG STRING &larr; NIL;  connectPassword: LONG STRING &larr; NIL;  directory:       LONG STRING &larr; NIL;  cmFile:          LONG STRING &larr; NIL;  fileName:            LONG STRING &larr; NIL;    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- String/Credentials Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Directory: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Directory"L,      myHelpIs: "Set Default FTP directory"L];    OthelloDefs.GetName["Directory: "L, @directory]};  GetConnectNamePassword: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Connect"L, myHelpIs: "Set secondary Credentials"L];    OthelloDefs.GetName["Directory: "L, @connectName];    OthelloDefs.GetName["Password: "L,  @connectPassword, stars]};  GetUserNamePassword: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Login"L, myHelpIs: "Set user name-password"L];    OthelloDefs.GetName["User: "L,     @userName];    OthelloDefs.GetName["Password: "L, @userPassword, stars]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Basic Fetch Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  FetchBoot: PROC = {    Fetch[pilot, "Boot file name: "L, "Fetch Boot File"L, "Fetch Boot File"L, "boot"L, FALSE]};  FetchGerm: PROC = {    Fetch[germ,  "Germ file name: "L, "Germ Fetch"L, "Fetch Germ"L, "germ"L, FALSE]};  FetchPilotMicrocode: PROC = {    Fetch[      softMicrocode,      "Pilot microcode file name: "L,      "Pilot Microcode Fetch"L,      "Fetch and Install Pilot Microcode"L,      "db"L,      FALSE]};  -- Fetch Lisp sysout command: Installs a Lisp sysout on the volume.      FetchLispSysout: PROC = {    Fetch[      hardMicrocode,      "Lisp sysout file name: "L,      "Lisp Sysout Fetch"L,      "Fetch and Install Lisp Sysout"L,      "sysout"L,      TRUE]};  FetchDiagnosticMicrocode: PROC = {    Fetch[      hardMicrocode,      "Diagnostic microcode file name: "L,      "Diagnostic Microcode Fetch"L,      "Fetch and Install Diagnostic Microcode"L,      "db"L,      FALSE]};  Fetch: PROC [type: BootFileType, prompt, name, helpMsg, extension: STRING, lispSysout: BOOLEAN] =    BEGIN    created:   BOOLEAN &larr; FALSE;    file:       File.File;    firstPage: File.PageNumber;    lvID:      Volume.ID;    OthelloDefs.MyNameIs[myNameIs: name, myHelpIs: helpMsg];    IF ~ConnectionOpen[] AND ~ReOpen[] THEN      OthelloDefs.AbortingCommand["Please open a connection"L];    lvID &larr; OthelloDefs.GetLvIDFromUser[].lvID;    OthelloDefs.GetName[prompt, @fileName];    [] &larr; String.AppendExtensionIfNeeded[@fileName, extension, Heap.systemZone];    Volume.Open[lvID];    [file, firstPage] &larr; GetVolumeBootFile[lvID, type];    IF (created &larr; file = File.nullFile) THEN      file &larr; File.Create[lvID, 1, FileTypes.tUntypedFile]    ELSE MakeUnbootable[file, type, firstPage !       File.Unknown =&gt; CONTINUE;      TemporaryBooting.InvalidParameters =&gt; {        OthelloDefs.WriteLine["Warning, trouble making unbootable"L];	CONTINUE}];    Retrieve[destination: [pilotFileSystemWrite[file]]    ! UNWIND =&gt; {IF created THEN File.Delete[file]; Volume.Close[lvID]}];    OthelloDefs.WriteString["Installing..."L];    SetVolumeBootFile[file, type, OthelloDefs.leaderPages];    File.MakePermanent[file]; --   IF lispSysout THEN { --   	OthelloDefs.WriteString["Expanding to fill volume..."L]; --   	SetBootFileSize[file,lvID]; --  	OthelloDefs.WriteString["OK..."L]; --	};    MakeBootable[file, type, OthelloDefs.leaderPages    ! TemporaryBooting.InvalidParameters =&gt; {      OthelloDefs.WriteLine["Warning, trouble making bootable"L]; CONTINUE}];    OthelloDefs.WriteLine["Done."L];    IF lispSysout THEN OthelloDefs.WriteLine["[Remember to use Expand VMem command if necessary]"L];	          IF lispSysout THEN {IF OthelloDefs.Yes["Shall I also make this the default boot lisp? "L       ! UNWIND =&gt; Volume.Close[lvID]] THEN       SetPhysicalVolumeBootFile[file,type,OthelloDefs.leaderPages];       }    ELSE     IF type IN [hardMicrocode..germ] AND         OthelloDefs.Yes["Shall I also use this for the Physical Volume? "L         ! UNWIND =&gt; Volume.Close[lvID]] THEN         SetPhysicalVolumeBootFile[file, type, OthelloDefs.leaderPages];    Volume.Close[lvID];    END;-- UGH.. This kludge sets the file's size to be as big as Pilot will let it be, on 100 page increments.  SetBootFileSize: PRIVATE PROC[file: File.File, lvID: Volume.ID] = BEGIN    newSize: File.PageCount &larr; File.GetSize[file] + Volume.GetAttributes[lvID].freePageCount;    File.SetSize[file, newSize 	  ! File.Unknown =&gt; {OthelloDefs.WriteLine["Warning: Trouble making file fill volume - File.Unknown"L];	    CONTINUE};	    Volume.InsufficientSpace =&gt; {OthelloDefs.WriteString["."L]; newSize &larr; newSize - 100; RETRY}];    END;      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initial Ucode Fetch Command  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  FetchInitialMicrocode: PUBLIC PROC [    InstallProc: PROC [getPage: PROC RETURNS [LONG POINTER]]] = {    IF ~ConnectionOpen[] AND ~ReOpen[] THEN       OthelloDefs.AbortingCommand["Please open a connection"L];    OthelloDefs.GetName["File name: "L, @fileName];    OthelloDefs.Confirm[];    Retrieve[destination: [rawWrite[InstallProc]]]};      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Indirect command files  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AlternateGetCMFile: PUBLIC PROC [s: STRING] = {    Heap.systemZone.FREE[@cmFile];    cmFile &larr; Heap.systemZone.NEW[StringBody[s.length]];    FOR i: CARDINAL IN [1..s.length) DO      String.AppendChar[cmFile, s[i]] ENDLOOP;    DoIndirect[]};  Indirect: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "@", myHelpIs: "Run command file from IFS"L];    OthelloDefs.GetName["Command file: "L, @cmFile    ! OthelloDefs.Question =&gt; {      OthelloDefs.WriteLine["[Host]&lt;Dir&gt;Filename"L]; RESUME}];    [] &larr; String.AppendExtensionIfNeeded[@cmFile, "hello"L, Heap.systemZone];    DoIndirect[]};      DoIndirect: PROC =    BEGIN    ParseCmFileName: PROC = {      hostEnd: CARDINAL;      IF cmFile.length = 0 THEN RETURN;      FOR i: CARDINAL IN [0..cmFile.length) DO        c: CHARACTER = cmFile[i];        SELECT c FROM          '[ =&gt; LOOP; '] =&gt; {hostEnd &larr; i; EXIT};          ENDCASE =&gt; String.AppendCharAndGrow[@host, c, Heap.systemZone];        REPEAT FINISHED =&gt; {Heap.systemZone.FREE[@host]; RETURN}	ENDLOOP;      -- hostEnd points at ']       FOR i: CARDINAL IN (hostEnd..cmFile.length) DO        IF cmFile[i] = '&lt; AND directory#NIL THEN directory.length &larr; 0;        String.AppendCharAndGrow[@fileName, cmFile[i], Heap.systemZone];	IF cmFile[i] = '&gt; THEN {	  FOR j: CARDINAL IN [0..fileName.length) DO	    String.AppendCharAndGrow[@directory, fileName[j], Heap.systemZone] ENDLOOP;	  fileName.length &larr; 0};	ENDLOOP};    s:         LONG STRING &larr; NIL;    GetString: PROC [c: LONG STRING] = {s &larr; String.CopyToNewString[c, Heap.systemZone]};    Heap.systemZone.FREE[@host];    Heap.systemZone.FREE[@directory];    Heap.systemZone.FREE[@fileName];    ParseCmFileName[];    CloseCmd[]; Open[];    Retrieve[destination: [string[GetString]]    ! UNWIND =&gt; Heap.systemZone.FREE[@s]];    OthelloDefs.WriteLine["done"L];    OthelloDefs.SetCommandString[s];    Close[];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- MISC Stuff/Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  userOpened: BOOLEAN &larr; FALSE;  OpenCmd: PROC = {    OthelloDefs.MyNameIs[myNameIs: "Open"L, myHelpIs: "STP Open"L];    CloseCmd[];    OthelloDefs.GetName["Open connection to "L, @host];    Open[]; userOpened &larr; TRUE};  ReOpen: PROC RETURNS [BOOLEAN] = {    IF userOpened=FALSE THEN RETURN[FALSE];    Open[]; RETURN[TRUE]};      CloseCmd: PROC = {    OthelloDefs.MyNameIs[myNameIs: "Close"L, myHelpIs: "STP Close"L];    userOpened &larr; FALSE; Close[]};      RemoteList: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "List Remote Files"L, myHelpIs: "List Remote Files"L];    IF ~ConnectionOpen[] AND ~ReOpen[] THEN      OthelloDefs.AbortingCommand["Please open a connection"L];    OthelloDefs.GetName["Pattern: "L, @fileName];    IF String.Length[fileName] = 0 THEN      String.AppendCharAndGrow[@fileName, '*, Heap.systemZone];    ListFiles[]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Central commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  commandProcessor: OthelloDefs.CommandProcessor &larr; [FtpCommands];  FtpCommands: PROC [index: CARDINAL] = {    SELECT index FROM      0 =&gt; Indirect[];      1 =&gt; GetConnectNamePassword[];      2 =&gt; Directory[];      3 =&gt; GetUserNamePassword[];      4 =&gt; OpenCmd[];      5 =&gt; CloseCmd[];      6 =&gt; FetchBoot[];      7 =&gt; FetchDiagnosticMicrocode[];      8 =&gt; FetchGerm[];      9 =&gt; FetchPilotMicrocode[];     10 =&gt; RemoteList[];     11 =&gt; FetchLispSysout[];     ENDCASE =&gt; OthelloDefs.IndexTooLarge};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- STP Stuff/Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  stp: STP.Handle &larr; NIL;    ConnectionOpen: PROC RETURNS [BOOLEAN] = {    RETURN[stp # NIL AND STP.IsOpen[stp]]};      -- all callers close the connection first  Open: PROC = {    herald: LONG STRING &larr; NIL;    IF stp = NIL THEN stp &larr; STP.Create[];    DO      herald &larr; STP.Open[stp, host      ! STP.Error =&gt; SELECT code FROM          connectionTimedOut, connectionClosed, noRouteToNetwork,          noNameLookupResponse, connectionRejected =&gt; {	    OthelloDefs.WriteLine[error]; CONTINUE};          ENDCASE =&gt; OthelloDefs.AbortingCommand[error]];      IF herald # NIL THEN EXIT;      Process.Pause[Process.SecondsToTicks[10]];      OthelloDefs.CheckUserAbort[];      ENDLOOP;    OthelloDefs.WriteLine[herald];    Heap.systemZone.FREE[@herald];    STP.SetHost[stp, host]};    CloseFetch: PUBLIC PROC = {    Close[! OthelloDefs.AbortingCommand =&gt; {      OthelloDefs.WriteString[reason];      OthelloDefs.WriteLine[reasonOne];      CONTINUE}]};    Close: PROC = {    IF ~ConnectionOpen[] THEN RETURN;    STP.Close[stp ! STP.Error =&gt; OthelloDefs.AbortingCommand[error]];    OthelloDefs.WriteLine["connection closed"L]};    -- could mess with directories.  -- who cares  ListFiles: PROC = {    ListOne: STP.NoteFileProcType = {      info: STP.FileInfo = STP.GetFileInfo[stp];      OthelloDefs.WriteString[file];      THROUGH [file.length..80-info.create.length) DO        OthelloDefs.WriteChar[' ] ENDLOOP;      OthelloDefs.WriteLine[info.create];      --OthelloDefs.WriteChar[' ];      --OthelloDefs.WriteLine[info.author];      --OthelloDefs.WriteChar[' ];      --OthelloDefs.WriteLongNumber[info.size];      --OthelloDefs.WriteLine[" bytes]"L];      OthelloDefs.CheckUserAbort[];      RETURN[yes]};    STP.Login[stp, userName, userPassword];    STP.Connect[stp, connectName, connectPassword];    STP.SetDirectory[stp, directory];    STP.Enumerate[stp, fileName, ListOne    ! STP.Error =&gt; OthelloDefs.AbortingCommand[error]]};  Destination: TYPE = RECORD [    SELECT type: * FROM      pilotFileSystemWrite =&gt; [localFile: File.File],      string               =&gt; [stringProc: PROC [LONG STRING]],      rawWrite             =&gt; [        linkProc: PROC [getPage: PROC RETURNS [LONG POINTER]]],      ENDCASE];        StartFeedback: SIGNAL = CODE;  Retrieve: PROC [destination: Destination] = {    rs:     Stream.Handle;    rsSize: LONG CARDINAL;    note: LONG STRING &larr; NIL;    Cleanup: PROC = {      rs.delete[rs];      OthelloDefs.SetCursor[pointer];      Heap.systemZone.FREE[@note]};    [rs, rsSize, note] &larr; GetReadStream[    ! STP.Error =&gt; OthelloDefs.AbortingCommand[error]];    IF rs=NIL THEN RETURN;    GrabBits[rs, rsSize, destination, note    ! STP.Error =&gt; OthelloDefs.AbortingCommand[error];      StartFeedback =&gt; {        OthelloDefs.WriteString["Fetching..."L];        OthelloDefs.SetCursor[ftp];        RESUME};      UNWIND =&gt; Cleanup[]];    Cleanup[]};      HasWildCard: PROC [s: LONG STRING] RETURNS [BOOLEAN] = {    IF s#NIL THEN FOR i: CARDINAL IN [0..s.length) DO       IF s[i] = '* THEN RETURN[TRUE] ENDLOOP;    RETURN[FALSE]};  PagesForBytes: PROC [bytes: LONG CARDINAL] RETURNS [LONG CARDINAL] = INLINE {    OPEN Environment; RETURN[(bytes + bytesPerPage - 1)/bytesPerPage]};  GetReadStream: PROC RETURNS [rs: Stream.Handle, rsSize: LONG CARDINAL, note: LONG STRING &larr; NIL] = {    wild:   BOOLEAN = HasWildCard[directory] OR HasWildCard[fileName];    info: STP.FileInfo;        STP.Login[stp, userName, userPassword];    STP.Connect[stp, connectName, connectPassword];    STP.SetDirectory[stp, directory];    rs &larr; STP.CreateRemoteStream[stp, fileName, read];    rs.options.signalEndOfStream &larr; TRUE;    DO       s: LONG STRING &larr; STP.NextFileName[rs ! UNWIND =&gt; rs.delete[rs]];      IF s = NIL THEN {rs.delete[rs]; RETURN[NIL, 0, NIL]};      info &larr; STP.GetFileInfo[stp ! UNWIND =&gt; rs.delete[rs]];      rsSize &larr; PagesForBytes[info.size];      OthelloDefs.WriteString[s];      Heap.systemZone.FREE[@s];      OthelloDefs.WriteChar['[]; OthelloDefs.WriteString[info.create];      OthelloDefs.WriteString[", pages = "]; OthelloDefs.WriteLongNumber[rsSize];      OthelloDefs.WriteChar[']];      IF ~wild THEN {OthelloDefs.NewLine[]; EXIT};      IF OthelloDefs.Yes[" [Confirm]: "L ! UNWIND =&gt; rs.delete[rs]] THEN EXIT;      ENDLOOP;    note &larr; Heap.systemZone.NEW[StringBody[60]];    String.AppendChar[note, '[];    String.AppendStringAndGrow[@note, host, Heap.systemZone];    String.AppendCharAndGrow[@note, '], Heap.systemZone];    IF String.Length[info.directory] # 0 THEN {      String.AppendCharAndGrow[@note, '&lt;, Heap.systemZone];      String.AppendStringAndGrow[@note, info.directory, Heap.systemZone];      String.AppendCharAndGrow[@note, '&gt;, Heap.systemZone]};    String.AppendStringAndGrow[@note, info.body, Heap.systemZone];    String.AppendStringAndGrow[@note, " ("L, Heap.systemZone];    String.AppendStringAndGrow[@note, info.create, Heap.systemZone];    String.AppendCharAndGrow[@note, '), Heap.systemZone];    RETURN};      bufPages: CARDINAL = 8;  GrabBits: PROC [    rs: Stream.Handle, rsSizePages: LONG CARDINAL, destination: Destination, note: LONG STRING &larr; NIL] = {    WITH destination SELECT FROM      pilotFileSystemWrite =&gt; {	buffer: LONG POINTER &larr; NIL;        base: File.PageNumber &larr; 0;	got: CARDINAL;        File.SetSize[localFile, rsSizePages + OthelloDefs.leaderPages	! Volume.InsufficientSpace =&gt; OthelloDefs.AbortingCommand["Volume Full"L]];	SetLeaderPage[localFile, note];	SIGNAL StartFeedback;	WHILE base &lt; rsSizePages DO          thisPages: CARDINAL = CARDINAL[MIN[rsSizePages-base, bufPages]];	  size:      CARDINAL = thisPages*Environment.bytesPerPage;	  start:     CARDINAL &larr; 0;	  buffer &larr; Space.Map[	    window:[localFile, base+OthelloDefs.leaderPages, thisPages],	    life: dead].pointer;          DO	    [bytesTransferred: got] &larr; rs.GetBlock[[	      blockPointer: buffer, startIndex: start, stopIndexPlusOne: size] !	        Stream.EndOfStream =&gt; {	          got &larr; 0; start &larr; start + nextIndex; CONTINUE};	        UNWIND =&gt; [] &larr; Space.Unmap[buffer]];	    IF got = 0 THEN {[] &larr; Space.Unmap[buffer]; RETURN};            IF (start &larr; start + got) = size THEN EXIT;            ENDLOOP;          --buffer &larr; Space.Unmap[buffer, return];	  Process.Detach[LOOPHOLE[FORK Space.Unmap[buffer]]]; buffer &larr; NIL;          OthelloDefs.FlipCursor[];	  base &larr; base + thisPages;          ENDLOOP;	buffer &larr; Space.ScratchMap[1]; -- check for any leftover stuff	[bytesTransferred: got] &larr; rs.GetBlock[[	  blockPointer: buffer, startIndex: 0,	  stopIndexPlusOne: Environment.bytesPerPage] !	    Stream.EndOfStream =&gt; {got &larr; nextIndex; CONTINUE};	    UNWIND =&gt; [] &larr; Space.Unmap[buffer]];	[] &larr; Space.Unmap[buffer];	IF got # 0 THEN OthelloDefs.AbortingCommand[	  "File longer than advertised length"L]};      string =&gt; {	SIGNAL StartFeedback;	DO          stringOverhead: CARDINAL = SIZE[StringBody]*Environment.bytesPerWord;          string: LONG STRING = Space.ScratchMap[bufPages];          string&uarr; &larr; [	    length: 0,	    maxlength: bufPages*Environment.bytesPerPage - stringOverhead,	    text: ];	  WHILE string.length &lt; string.maxlength DO            got: CARDINAL;	    [bytesTransferred: got] &larr; rs.get[	      rs,	      [blockPointer: LOOPHOLE[@string.text],	       startIndex: string.length, stopIndexPlusOne: string.maxlength],	      rs.options	      ! Stream.EndOfStream =&gt; {	          got &larr; 0; string.length &larr; string.length + nextIndex; CONTINUE};                UNWIND =&gt; [] &larr; Space.Unmap[string]];	    IF got = 0 THEN {	      stringProc[string! UNWIND =&gt; [] &larr; Space.Unmap[string]];	      [] &larr; Space.Unmap[string]; RETURN};            string.length &larr; string.length + got;            ENDLOOP;          [] &larr; Space.Unmap[string];          OthelloDefs.AbortingCommand["Command file too long!"L];          ENDLOOP};      rawWrite =&gt;{	buffer: LONG POINTER = Space.ScratchMap[1];        done:  BOOLEAN &larr; FALSE;        first: BOOLEAN &larr; TRUE;	GetPage: PROC RETURNS [LONG POINTER] = {          got:   CARDINAL; index: CARDINAL &larr; 0;          IF first THEN {SIGNAL StartFeedback; first &larr; FALSE};	  WHILE ~done DO	    [bytesTransferred: got] &larr; rs.get[	      rs,	      [blockPointer: buffer, startIndex: index,	       stopIndexPlusOne: Environment.bytesPerPage],	      rs.options	      ! Stream.EndOfStream =&gt; {got &larr; nextIndex; done &larr; TRUE; CONTINUE}];            IF (index &larr; index + got) = Environment.bytesPerPage 	       OR done THEN {OthelloDefs.FlipCursor[]; EXIT}            ENDLOOP;          RETURN[IF done AND index = 0 THEN NIL ELSE buffer]};        linkProc[GetPage ! UNWIND =&gt; [] &larr; Space.Unmap[buffer]];        WHILE ~done DO [] &larr; GetPage[! UNWIND =&gt; [] &larr; Space.Unmap[buffer]] ENDLOOP;        [] &larr; Space.Unmap[buffer]};      ENDCASE =&gt; ERROR};     SetLeaderPage: PROCEDURE [file: File.File, note: LONG STRING] =    BEGIN    lp: LONG POINTER TO OthelloDefs.LeaderPage &larr; Space.Map[[file, 0, OthelloDefs.leaderPages]].pointer;    lp.version &larr; OthelloDefs.lpVersion;    lp.length &larr; MIN[note.length, OthelloDefs.lpNoteLength];    FOR i: CARDINAL IN [0..lp.length) DO      lp.note[i] &larr; note[i];      ENDLOOP;    [] &larr; Space.Unmap[lp];    END;     --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- initialization  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  StringInit: PROC = {    OthelloDefs.SetCommandString[String.CopyToNewString["Online RD0"L, Heap.systemZone]]};  OthelloDefs.RegisterCommandProc[@commandProcessor];  StringInit[];  END.....  -- November 13, 1979  10:16 AM By Forrest Changed to InitializeFTP once (and never Finalize), to use a bigger chunk in transfering (should use two buffers);  increased size of directory string to 60 from 50; Add twiddle cursor hack since people were worried about ftp dying; export Server*loaded and UserMailLoaded to eliminate 3 modules from FTP -- January 12, 1980  4:46 PM By Forrest Changed to used new Othello FTP and support calls to writing Raw Data-- February 14, 1980  7:30 PM By Gobbel Notice if we didn't really retrieve any files-- July 26, 1980  7:04 PM By Forrest Change name to OthelloFTP, export OthelloDefs-- April 14, 1981  1:53 PM By Bruce Added string variant to dest; fixed AR4051; Add twiddle cursor hack since people were worried about ftp dying; export Server*loaded and UserMailLoaded to eliminate 3 modules from FTP -- January 12, 1980  4:46 PM By Forrest Changed to used new Othello FTP and support calls to writing Raw Data-- February 14, 1980  7:30 PM By Gobbel Notice if we didn't really retrieve any files-- July 26, 1980  7:04 PM By Forrest Change name to OthelloFTP, export OthelloDefs-- April 14, 1981  1:53 PM By Bruce Added string variant to dest; fixed AR4051-- 11-Nov-81 16:54:09 By Forrest added missing catch phrase to Retrieve-- 28-Dec-81 10:21:01 By Bruce removed Guest Guest and set signalEndOfStream TRUE-- 13-Jan-82 10:23:20 By Forrest removed extra ! UNWIND =&gt; Space.Unmap[space] from Initial ucode fetch.-- 11-Dec-82 15:28:08 By Johnsson removed Storage; added default extensions.-- 13-Apr-83  9:38:39 By Johnsson Klamath conversion.</pre>
  </body>
</html>
