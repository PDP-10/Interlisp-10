<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>Hello>HELLODEVIMPLDLION.MESA!1</title>
  </head>
  <body>
    <pre>
-- HelloDevImplDLion.Mesa-- Contains Hello commands specific to DLion disks--	Masinter 22 Aug 84 from OthelloDeviceImplD0DLion--	Glassman  17-Jul-81 16:43:40--	Linda     10-Mar-82 16:17:10--	Forrest    7-Jan-82 17:40:00--	Johnsson   8-Nov-83  9:24:59-- there is a seperate version at least for dorados.DIRECTORY  Device,  DeviceTypes,  FormatPilotDisk, FormatPilotDiskExtras,  OthelloDefs,  OthelloOps,  PhysicalVolume,  String USING [EquivalentStrings],  Volume;HelloDevImplDLion: PROGRAM  IMPORTS    FormatPilotDisk, OthelloDefs, OthelloOps, PhysicalVolume, String, Volume =  BEGIN OPEN OthelloDefs, OthelloOps;  commandProcessor: CommandProcessor &larr; [DiskCommands];  DiskCommands: PROC [index: CARDINAL] = {    SELECT index FROM      0 =&gt; CheckDrive[];      1 =&gt; CreateVolume[];      2 =&gt; Format[];     -- =&gt; IndicateAltoness[];      3 =&gt; FetchInitialMicrocode[];      ENDCASE =&gt; IndexTooLarge};      badTableSize: CARDINAL = 200;  logicalVolumeOverhead: CARDINAL = 1;  minLogicalVolumeSize:  CARDINAL = 50;  -- fudge + 1+1+6;  maxNameLength:         CARDINAL = PhysicalVolume.maxNameLength;  -- BUG! The following statement is wrong!  physicalVolumeOverhead  -- should be set based upon device type.  This will be necessary once Pilot  -- knows how to create bad page tables based upon device types.  For the  --  time being, we just KNOW that all bad page tables are one page  --  long, and that as a result there  --  are always two pages of physical volume overhead.  physicalVolumeOverhead: CARDINAL = 2;  sa4000Flavor: PACKED ARRAY [0..8) OF [0..377B] &larr; ALL[377B];&lt;&lt;  IndicateAltoness: PUBLIC PROC = {    h: PhysicalVolume.Handle;    t: Device.Type;    MyNameIs[      myNameIs: "Reserve Alto Volume"L,      myHelpIs: "Reserve space for simulated Alto-mode partitions"L];    IF (t &larr; GetDriveType[(h &larr; GetDriveFromUser[])]) # DeviceTypes.sa4000       AND t # DeviceTypes.sa4008 THEN      AbortingCommand["Command is only for SA4000's."L]    ELSE IndicateAltoness1[h]};&gt;&gt;  CheckDrive: PROC =    BEGIN    badSpots:         CARDINAL;    badSpotArray:     ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber;    couldDo:          BOOLEAN;    h:                PhysicalVolume.Handle;    p:                PhysicalVolume.ID &larr; PhysicalVolume.nullID;    wasOnLine:        BOOLEAN &larr; FALSE;    badTableOverflow: BOOLEAN;    MyNameIs[      myNameIs: "Check Drive"L, myHelpIs: "Scan drive for unreadable pages"L];    [couldDo, badSpots, h] &larr; FormatCheckDrive[@badSpotArray, check];    IF ~couldDo THEN AbortingCommand["Command can't be done for this device."L]    ELSE IF badSpots = 0 THEN {WriteLine["No bad pages found."L]; RETURN}    ELSE IF ~Wizard[] OR ~Yes["\rShall I record these pages in the bad table? "L] THEN RETURN;    -- See if was on line/put on line    DO      p &larr; PhysicalVolume.GetNext[p];      IF p = PhysicalVolume.nullID THEN {        p &larr; PhysicalVolume.AssertPilotVolume[h]; EXIT}      ELSE IF h = PhysicalVolume.GetAttributes[p].instance THEN {        wasOnLine &larr; TRUE; EXIT};      ENDLOOP;    badTableOverflow &larr; FillBadTable[@badSpotArray, badSpots, p];    IF ~wasOnLine THEN PhysicalVolume.Offline[p];    IF badTableOverflow THEN AbortingCommand["Too many bad spots."L]    ELSE WriteLine["Consider scavenging some volumes."L];    END;  Format: PROC =    BEGIN    badSpots:         CARDINAL;    badSpotArray:     ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber;    couldDo:          BOOLEAN;    h:                PhysicalVolume.Handle;    p:                PhysicalVolume.ID;    badTableOverflow: BOOLEAN;    IF ~Wizard[] THEN RETURN;    MyNameIs[myNameIs: "Format"L, myHelpIs: "Format a disk drive"L];    [couldDo, badSpots, h] &larr; FormatCheckDrive[@badSpotArray, format];    IF ~couldDo THEN AbortingCommand["Command can't be done for this device."L];    FOR i: CARDINAL IN [0..MIN[badSpots, LENGTH[badSpotArray]]) DO      IF badSpotArray[i] = 0 THEN {WriteLine["Physical page zero bad"L]; RETURN}      ENDLOOP;    WriteLine["\rCreating Pilot volume named ""Empty"" to hold bad spot table"L];    p &larr; PhysicalVolume.CreatePhysicalVolume[h, "Empty"L];    badTableOverflow &larr; FillBadTable[@badSpotArray, badSpots, p];    PhysicalVolume.Offline[p];    IF badTableOverflow THEN AbortingCommand["Too many bad spots."L];    END;  lvTable: ARRAY [0..10) OF RECORD [    size: Volume.PageCount,    type: Volume.Type,    name: LONG STRING] &larr; ALL[[0, normal, NIL]];  newPvName:  LONG STRING &larr; NIL;  CreateVolume: PROC  =     BEGIN    h:              PhysicalVolume.Handle;    badTable:       ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber;    bad:            CARDINAL &larr; 0;    broughtOnLine:  BOOLEAN &larr; FALSE;    driveSize:      LONG CARDINAL;    nSubVols:       CARDINAL;    lvID:           Volume.ID;    lvsize:         Volume.PageCount;    pvID:           PhysicalVolume.ID &larr; PhysicalVolume.nullID;    PagesRippedOff: PROC RETURNS [p: LONG CARDINAL] = INLINE {      --we don't really lose physicalVolumeOverhead      p &larr; MinPilotPage[h]; IF p # 0 THEN p &larr; p - physicalVolumeOverhead};    volumeFound:    BOOLEAN &larr; TRUE;    MyNameIs[      myNameIs: "Create Physical Volume"L,      myHelpIs: "Format physical volume into logical volumes (old contents lost)"L];    h &larr; GetDriveFromUser[];    DO      pvID &larr; PhysicalVolume.GetNext[pvID];      IF pvID = PhysicalVolume.nullID THEN {        volumeFound &larr; TRUE; -- Yes["Shall I try to find an old bad page Table? "L];        IF volumeFound THEN {          broughtOnLine &larr; TRUE;          pvID &larr; PhysicalVolume.AssertPilotVolume[h !            PhysicalVolume.Error, PhysicalVolume.NeedsScavenging =&gt; {              volumeFound &larr; broughtOnLine &larr; FALSE; CONTINUE}]};        EXIT};      IF h = PhysicalVolume.GetAttributes[pvID].instance THEN EXIT;      ENDLOOP;    IF volumeFound THEN {      OPEN PhysicalVolume;      badTable[bad] &larr; GetNextBadPage[pvID, nullBadPage];      WHILE badTable[bad] # nullBadPage DO        badTable[bad + 1] &larr; GetNextBadPage[pvID, badTable[bad]]; bad &larr; bad + 1        ENDLOOP;      volumeFound &larr; PhysicalVolume.GetNextLogicalVolume[pvID, Volume.nullID]                    # Volume.nullID};    GetName["New physical volume name: "L, @newPvName];    nSubVols &larr; ReadShortNumber[      "Number of logical volumes: "L, 1,      PhysicalVolume.maxSubvolumesOnPhysicalVolume, 3];    driveSize &larr; GetDriveSize[h] -      (physicalVolumeOverhead + nSubVols*logicalVolumeOverhead       + PagesRippedOff[]);    driveSize &larr; driveSize - ReserveLastCylinderForDiag[h];    FOR i: CARDINAL IN [0..nSubVols) DO      OPEN lvTable[i];      WriteString["Logical volume "L];      WriteLongNumber[LONG[i]];      NewLine[];      DO        duplicate: BOOLEAN &larr; FALSE;        GetName["  Name: "L, @lvTable[i].name];        FOR j: CARDINAL IN [0..i) WHILE ~duplicate DO          duplicate &larr; String.EquivalentStrings[	    lvTable[i].name, lvTable[j].name] ENDLOOP;        IF ~duplicate THEN EXIT;        WriteLine["Name is already in use; please choose another"L];        ENDLOOP;      size &larr; ReadNumber[        "  Pages: "L, minLogicalVolumeSize,        driveSize - ((nSubVols - (i + 1))*minLogicalVolumeSize),        driveSize/(nSubVols - i)];      driveSize &larr; driveSize - size;      type &larr; GetLvTypeFromUser["  Type: "L, type];      ENDLOOP;    IF broughtOnLine THEN PhysicalVolume.Offline[pvID];    Confirm[IF volumeFound THEN twice ELSE once];    PhysicalVolume.Offline[pvID ! ANY =&gt; CONTINUE];    pvID &larr; PhysicalVolume.CreatePhysicalVolume[h, newPvName];    FOR i: CARDINAL IN [0..bad) DO      PhysicalVolume.MarkPageBad[pvID, badTable[i]] ENDLOOP;    FOR i: CARDINAL IN [0..nSubVols) DO      OPEN lvTable[i];      lvID &larr; Volume.Create[pvID, size, name, type, MinPilotPage[h]];      IF (lvsize &larr; Volume.GetAttributes[lvID].volumeSize) # size THEN {        WriteString[name];        WriteString["'s size decreased (because of bad pages) to "L];        WriteLongNumber[lvsize];        NewLine[]};      ENDLOOP;    END;  FetchInitialMicrocode: PROC = {    h: PhysicalVolume.Handle;    InstallProc: PROC [getPage: PROC RETURNS [LONG POINTER]] = {      WriteString["Formatting..."L];      PhysicalVolume.AssertNotAPilotVolume[h];      {ENABLE UNWIND =&gt; PhysicalVolume.FinishWithNonPilotVolume[h];      FormatPilotDisk.FormatBootMicrocodeArea[h: h, passes: 1, retries: 0 !	FormatPilotDisk.BadPage =&gt; {          WriteString["Warning: page "L]; WriteLongNumber[p];          WriteLine[" is bad (will be skipped). "L]; RESUME}];      FormatPilotDisk.InstallBootMicrocode[h, getPage]}; -- ENABLE      PhysicalVolume.FinishWithNonPilotVolume[h]};    MyNameIs[      myNameIs: "Initial Microcode Fetch"L,      myHelpIs: "Fetch and install initial microcode"L];    h &larr; GetDriveFromUser[];    SELECT TRUE FROM      LOOPHOLE[GetDriveType[h], CARDINAL] IN Device.PilotDisk =&gt;        BEGIN	wasOnline: BOOLEAN = ForceOffline[h];        OthelloDefs.FetchInitialMicrocode[InstallProc        ! FormatPilotDisk.MicrocodeInstallFailure =&gt;            SELECT m FROM              emptyFile       =&gt;	        AbortingCommand["That remote file is empty!"L];              firstPageBad    =&gt;	        AbortingCommand["First microcode page of this disk is bad."L];              flakeyPageFound =&gt; {	        WriteLine["Intermittent page in microcode area."L]; RESUME};              microcodeTooBig =&gt;	        AbortingCommand["Microcode too large."L];              ENDCASE         =&gt;	        AbortingCommand["Unknown Install microcode error."L];          FormatPilotDisk.CantInstallUCodeOnThisDevice =&gt; GOTO no];	IF wasOnline THEN [] &larr; PhysicalVolume.AssertPilotVolume[h];        WriteLine["Done"L]        END;      ENDCASE =&gt; GOTO no;    EXITS    no =&gt; AbortingCommand["microcode can't be installed on this disk"L]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- support Procs  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- this code depends upon Pilot's bad spot table being smaller than ours,   -- and an error being raised when Pilot's table is full.  FillBadTable: PROC [    badSpotArray: POINTER TO ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber,    badSpots: CARDINAL, p: PhysicalVolume.ID]    RETURNS [badSpotTableFull: BOOLEAN &larr; FALSE] = {    FOR i: CARDINAL IN [0..badSpots) DO      PhysicalVolume.MarkPageBad[p, badSpotArray[i]      ! PhysicalVolume.Error =&gt;        IF error = badSpotTableFull THEN {badSpotTableFull &larr; TRUE; EXIT}]      ENDLOOP};      ForceOffline: PROC [h: PhysicalVolume.Handle]    RETURNS [wasOnline: BOOLEAN &larr; FALSE] = {    p: PhysicalVolume.ID &larr; PhysicalVolume.nullID;    DO      p &larr; PhysicalVolume.GetNext[p];      IF p = PhysicalVolume.nullID THEN EXIT;      IF h = PhysicalVolume.GetAttributes[p].instance THEN {	wasOnline &larr; TRUE; PhysicalVolume.Offline[p]; EXIT};      ENDLOOP};      FormatCheckDrive: PUBLIC PROC [    bs: POINTER TO ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber,    op: {format, check}]    RETURNS [couldDo: BOOLEAN, badSpots: CARDINAL, h: PhysicalVolume.Handle] = {    -- leaves pv offline for op = format; restores previous state for op = check    cbs: ARRAY [0..badTableSize) OF CARDINAL &larr; ALL[0];    tooManyMsg: BOOLEAN &larr; FALSE;    passes:     CARDINAL &larr; 1;    NoteBad: PROC [p: PhysicalVolume.PageNumber] = {      FOR i: CARDINAL IN [0..badSpots) DO        IF bs[i] = p THEN {cbs[i] &larr; cbs[i] + 1; WriteBadSpot[p, cbs[i]]; RETURN}	ENDLOOP;      IF badSpots &lt; LENGTH[bs&uarr;] THEN {        bs[badSpots] &larr; p; cbs[badSpots] &larr; cbs[badSpots] + 1;	badSpots &larr; badSpots + 1; WriteBadSpot[p, 1]}      ELSE {        IF ~tooManyMsg THEN {	  WriteLine["Too many bad pages"L]; tooManyMsg &larr; TRUE; column &larr; 0};	WriteBadSpot[p, 1]};      CheckUserAbort[! UNWIND =&gt; FormatSummary[]]};    FormatSummary: PROC = {      IF badSpots &gt; 0 THEN {        column &larr; 0;        WriteLine["\rSummary of bad pages: badPage(countTimesBad)"L];        FOR i: CARDINAL IN [0..badSpots) DO	  WriteBadSpot[bs[i], cbs[i]] ENDLOOP;        NewLine[]}};    column: CARDINAL &larr; 0;    WriteBadSpot: PROC [p: PhysicalVolume.PageNumber, cnt: CARDINAL] = {      WriteFixedWidthNumber[p, 8]; WriteChar['(];      WriteFixedWidthNumber[	cnt, SELECT passes FROM IN [0..9] =&gt; 1, IN [10..99] =&gt; 2, ENDCASE =&gt; 3];      WriteChar[')];      IF (column MOD 5) = 4 THEN {column &larr; 0; NewLine[]}       ELSE column &larr; column+1};    badSpots &larr; 0;    h &larr; GetDriveFromUser[];    SELECT TRUE FROM      -- dam compiler won't coerce [CARDINAL] into CARDINAL      LOOPHOLE[GetDriveType[h], CARDINAL] IN Device.PilotDisk =&gt; {        OPEN FPD: FormatPilotDisk;        pilotStart: PhysicalVolume.PageNumber = MinPilotPage[h];        retries:    FormatPilotDisk.RetryLimit &larr; 0;	              -- number of retries on bad page        cylSize:    CARDINAL = CylinderSize[h];	IF op = format THEN {          passes  &larr; ReadShortNumber["Number of passes: "L, 1, 200, 10];          retries &larr; ReadShortNumber[            "Number of retries: "L, FPD.noRetries, FPD.retryLimit, FPD.noRetries];          Confirm[twice];	  [] &larr; ForceOffline[h];	  -- format zero'th cylinder separately	  PhysicalVolume.AssertNotAPilotVolume[h];	  {ENABLE UNWIND =&gt; PhysicalVolume.FinishWithNonPilotVolume[h];	  FPD.Format[h, 0, cylSize, passes, retries          ! FPD.BadPage =&gt; {NoteBad[p]; RESUME}];          -- format rest of disk possibly allowing for alto-type volume	  -- or other device dependent dreck	  FPD.Format[h, pilotStart, GetDriveSize[h] - pilotStart, passes, retries          ! FPD.BadPage =&gt; {NoteBad[p]; RESUME}]}; -- ENABLE	  PhysicalVolume.FinishWithNonPilotVolume[h]}        ELSE {  -- op=scan          wasOnline: BOOLEAN;          Confirm[once];          wasOnline &larr; ForceOffline[h];          -- scan zero'th cylinder seperatly	  FPD.Scan[h, 0, cylSize	  ! FPD.BadPage =&gt; {NoteBad[p]; RESUME}];          -- scan rest of disk possibly allowing for alto-type volume	  -- or other device dependent dreck	  FPD.Scan[h, pilotStart, GetDriveSize[h] - pilotStart          ! FPD.BadPage =&gt; {NoteBad[p]; RESUME}];	  IF wasOnline THEN [] &larr; PhysicalVolume.AssertPilotVolume[h]};        FormatSummary[];        RETURN[TRUE, badSpots, h]};      ENDCASE =&gt; RETURN[FALSE, badSpots, h]};&lt;&lt;  IndicateAltoness1: PROC [h: PhysicalVolume.Handle] = {    dn: CARDINAL = GetDriveNumber[h];    sa4000Flavor[dn] &larr; 377B;    IF ~Yes["Reserve space for alto volume? "L] THEN {      sa4000Flavor[dn] &larr; 0; RETURN};    sa4000Flavor[dn] &larr; ReadShortNumber[      "Number of Model 44's:"L, 1, LAST[FormatPilotDisk.SA4000Model44Count], 1]};&gt;&gt;  MinPilotPage: PROC [h: PhysicalVolume.Handle]    RETURNS [PhysicalVolume.PageNumber] = {    OPEN FPD: FormatPilotDisk;    SELECT GetDriveType[h] FROM      DeviceTypes.sa1000, DeviceTypes.sa1004 =&gt;         RETURN[FPD.FirstSA1000PageForPilot];      DeviceTypes.q2000, DeviceTypes.q2010, DeviceTypes.q2020,      DeviceTypes.q2030, DeviceTypes.q2040, DeviceTypes.q2080 =&gt;         RETURN[FPD.FirstQ2000PageForPilot];      DeviceTypes.sa4000, DeviceTypes.sa4008  =&gt;        DO          dn: CARDINAL = GetDriveNumber[h];          IF sa4000Flavor[dn] IN FPD.SA4000Model44Count THEN            RETURN[FPD.SA4000FirstPageForPilot[sa4000Flavor[dn]]];          -- IndicateAltoness1[h]          ENDLOOP;      DeviceTypes.t80    =&gt; RETURN[FPD.Firstt80PageForPilot];      DeviceTypes.t300   =&gt; RETURN[FPD.Firstt300PageForPilot];      ENDCASE =&gt; RETURN[0]};  UnknownCylSize: ERROR = CODE;  CylinderSize: PROC [h: PhysicalVolume.Handle] RETURNS [cylSize: CARDINAL] = {    OPEN FPD: FormatPilotDisk, FPDx: FormatPilotDiskExtras;    SELECT GetDriveType[h] FROM      DeviceTypes.sa1000, DeviceTypes.sa1004 =&gt;        cylSize &larr; FPD.SA1004pagesPerCylinder;      DeviceTypes.q2000 =&gt; cylSize &larr; FPD.Q2040pagesPerCylinder;      DeviceTypes.q2010 =&gt; cylSize &larr; FPD.Q2010pagesPerCylinder;      DeviceTypes.q2020 =&gt; cylSize &larr; FPD.Q2020pagesPerCylinder;      DeviceTypes.q2030 =&gt; cylSize &larr; FPD.Q2030pagesPerCylinder;      DeviceTypes.q2040 =&gt; cylSize &larr; FPD.Q2040pagesPerCylinder;      DeviceTypes.q2080 =&gt; cylSize &larr; FPDx.Q2080pagesPerCylinder;      DeviceTypes.sa4000, DeviceTypes.sa4008 =&gt;        cylSize &larr; FPD.SA4008pagesPerCylinder;      DeviceTypes.t80   =&gt; cylSize &larr; FPD.t80pagesPerCylinder;      DeviceTypes.t300  =&gt; cylSize &larr; FPD.t300pagesPerCylinder;      ENDCASE =&gt; ERROR UnknownCylSize};  ReserveLastCylinderForDiag: PROC [h: PhysicalVolume.Handle]    RETURNS [ripOff: CARDINAL] = {    ripOff &larr; CylinderSize[h ! UnknownCylSize =&gt; GOTO out];    IF Wizard[] AND ~Yes["Reserve last cylinder for diagnostics? "L] THEN ripOff &larr; 0;    EXITS out =&gt; RETURN[0]};    RegisterCommandProc[@commandProcessor];  END.....11-Jun-81 10:56:57  Taft  Created file using excerpts from VolumeInitImplA.mesa17-Jun-81 16:39:45  Glassman	Action: Prompt for passes and retries for formatting disk, summary after all passes done17-Jul-81 16:44:52 Glassman	Action: Change name of file and print more summary information, OthelloDevice merged into OthelloDefs11-Jun-81 10:56:57  Taft  Created file using excerpts from VolumeInitImplA.mesa26-Aug-81 18:34:22  Forrest  8.0c build14-Oct-81 20:17:53  Forrest  othello reorg/add trident stuff/add diag cylinder stuff13-Nov-81 16:24:41  Forrest  8.0e build23-Nov-81 19:10:16  Forrest  add stuff for t80, t30010-Dec-81 16:15:15  Forrest  add Quantum support; fix a couple of awful bugs in install ucode 7-Jan-82 17:39:36  Forrest  Change for new FormatPilotDisk.CantInstallUCodeOnThisDevice10-Mar-82 16:17:20  Linda    Formating ==&gt; formatting22-Aug-84 13:06:35  Masinter  remove Alto format command stuff</pre>
  </body>
</html>
