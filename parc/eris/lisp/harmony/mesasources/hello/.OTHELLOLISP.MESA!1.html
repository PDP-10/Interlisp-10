<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>MesaSources>Hello>OTHELLOLISP.MESA!1</title>
  </head>
  <body>
    <pre>
-- File: OthelloLisp.mesa-- Created  9-Jul-84 15:06:38 LichtenbergDIRECTORY  CommonSoftwareFileTypes USING [tCarryVolumeDirectory],  Environment USING [wordsPerPage, Byte],  File USING [Type,     Create, Delete, File, MakePermanent, nullFile, PageNumber, PageCount, GetSize, SetSize, Unknown ],  FileTypes USING [tUntypedFile],  Floppy USING [Open, Close, FileHandle, nullFileID,GetNextFile, ErrorType, Error,   		VolumeHandle, Read, PageCount, PageNumber],  Inline USING [LongCOPY],  OthelloDefs,  OthelloOps USING [    BootFileType,     MakeBootable, MakeUnbootable,     GetPhysicalVolumeBootFile, VoidPhysicalVolumeBootFile,    SetVolumeBootFile, GetVolumeBootFile, VoidVolumeBootFile    ],  PhysicalVolume USING [ID],  System USING [GreenwichMeanTime, gmtEpoch],  Space USING [Map, CopyIn, Unmap, Window],  TemporaryBooting USING [InvalidParameters],  Time USING [Unpacked,Unpack,Append],  Volume USING [Close, ID, GetAttributes, nullID, InsufficientSpace, Open ];-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=OthelloLisp: PROGRAM  IMPORTS   File, OthelloDefs, OthelloOps, Floppy,    Space, TemporaryBooting, Time, Volume, Inline =   BEGIN  -- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-- These definitions stolen from AccessFloppy-- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= Attributes: TYPE = LONG POINTER TO AttributesRecord;AttributesRecord: TYPE = MACHINE DEPENDENT RECORD[ -- used by directory or leader page.         -- identity attributes   seal: WORD &larr; sealValue, -- used to check consistency of a file.   version:  CARDINAL, -- version of attributes record type.   type: File.Type, -- file type of containing file.             -- activity attributes   createDate: FloppyTime, -- the creation data of the disk file.   lastWrittenDate: FloppyTime, -- the date the disk file was last modified prior to copying to the floppy.         -- file attributes   size: Floppy.PageCount &larr; 0, -- number of pages in the floppy file not including the leader page.   offset: Floppy.PageNumber &larr; 0, -- page number in the disk file correspoinding to the first page in the floppy file piece.   totalSize: Floppy.PageCount &larr; 0, -- number of pages in the disk file.   totalSizeInBytes: LengthInBytes &larr; 0, -- the number of bytes in the disk file   -- name attributes   length: CARDINAL &larr; 0,   maxLength: CARDINAL &larr; maxNameLength, -- so that @length is STRING.   name: PACKED ARRAY [0..maxNameLength) OF Environment.Byte,        -- client attributes   clientDataLength: CARDINAL &larr; 0 ,-- number of component in client's private data.   clientData: SEQUENCE maxlength: CARDINAL OF UNSPECIFIED  ];    LengthInBytes: TYPE = LONG CARDINAL;FloppyTime: TYPE = System.GreenwichMeanTime;tFloppyLeaderPage: File.Type = CommonSoftwareFileTypes.tCarryVolumeDirectory;   -- Constants    leaderLength: CARDINAL = 1;  -- leaderLength*Environment.wordsPerPage must be greater than SIZE[AttributesRecord]maxDataSize: CARDINAL = leaderLength*Environment.wordsPerPage - SIZE[AttributesRecord];maxNameLength: CARDINAL = 100;    -- includes words field.nullTime: FloppyTime = System.gmtEpoch;sealValue: WORD = 125252B; -- 1010101010101010 bits pattern   -- =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=    CopyVM: PROC = BEGIN    fromVolume, toVolume: Volume.ID;    fromFile, toFile: File.File;    pvID: PhysicalVolume.ID;    error: BOOLEAN &larr; FALSE;    currentBase: File.PageNumber;    nextCount: File.PageCount;    fromWindow,toWindow: Space.Window;    toPointer: LONG POINTER;    fromFileSize: File.PageCount;    tries: CARDINAL;    toFileSize: File.PageCount;    minFileSize: File.PageCount;        OthelloDefs.MyNameIs[      myNameIs: "Copy Lisp From Another Volume"L,      myHelpIs: "Copies lisp from one volume to another"L];            [pvID, fromVolume] &larr; OthelloDefs.GetLvIDFromUser[prompt:"Volume to copy from: "L];      IF fromVolume = Volume.nullID THEN OthelloDefs.AbortingCommand["Invalid volume."L];      toVolume &larr; OthelloDefs.GetLvIDFromUser[prompt:"Volume to copy to:  "L].lvID;      IF toVolume = Volume.nullID THEN OthelloDefs.AbortingCommand["Invalid volume."L];            -- Open up the volumes      Volume.Open[fromVolume];      Volume.Open[toVolume];            -- Is there a source file?      fromFile &larr; OthelloOps.GetVolumeBootFile[fromVolume,hardMicrocode].file;      IF fromFile = File.nullFile THEN {      		Volume.Close[fromVolume];      		Volume.Close[toVolume];      		OthelloDefs.AbortingCommand["No Lisp sysout on source volume"L];		};            -- Is there a dest file? Delete it if yes.            toFile &larr; OthelloOps.GetVolumeBootFile[toVolume,hardMicrocode].file;      IF toFile # File.nullFile THEN {      	   OthelloOps.VoidVolumeBootFile[toVolume,hardMicrocode];	   File.Delete[toFile];	   IF OthelloOps.GetPhysicalVolumeBootFile[pvID,hardMicrocode].file = toFile	   THEN OthelloOps.VoidPhysicalVolumeBootFile[pvID,hardMicrocode];	   };            -- Create the dest file            fromFileSize &larr; File.GetSize[fromFile];      toFileSize &larr; fromFileSize;      tries &larr; 20;      toFile &larr; File.Create[toVolume, toFileSize, FileTypes.tUntypedFile      			! Volume.InsufficientSpace =&gt; 			    { tries &larr; tries - 1;			      toFileSize &larr; toFileSize - 100;			      OthelloDefs.WriteString["."L];			      IF tries = 0 OR toFileSize &lt; 0 THEN {error &larr; TRUE;			    		CONTINUE}			      ELSE RETRY;};];						          IF error THEN {Volume.Close[fromVolume];      		     Volume.Close[toVolume];      		     OthelloDefs.AbortingCommand["Destination volume does not contain sufficient space!"L];};      File.MakePermanent[toFile];            -- Create windows onto the file      OthelloDefs.WriteString["Copying..."L];      currentBase &larr; 0;      nextCount &larr; 100;            minFileSize &larr; fromFileSize;      IF toFileSize &lt; fromFileSize THEN minFileSize &larr; toFileSize;            DO -- until file has been copied                fromWindow &larr; [file: fromFile,      		       base: currentBase,		       count: nextCount];         toWindow &larr; [file: toFile,      		     base: currentBase,		     count: nextCount];              toPointer &larr; Space.Map[toWindow].pointer;	 nextCount &larr; Space.CopyIn[toPointer,fromWindow];	 toPointer &larr; Space.Unmap[toPointer];	 	 currentBase &larr; currentBase + nextCount;	 	 OthelloDefs.WriteString["."L];         IF currentBase &gt;= minFileSize THEN EXIT; 	       ENDLOOP;            OthelloDefs.WriteString["Installing..."L];      OthelloOps.MakeBootable[toFile, hardMicrocode, OthelloDefs.leaderPages           ! TemporaryBooting.InvalidParameters =&gt; {             OthelloDefs.WriteLine["Warning, trouble making bootable"L]; CONTINUE}];      OthelloOps.SetVolumeBootFile[toFile,hardMicrocode,OthelloDefs.leaderPages];      OthelloDefs.WriteLine["done"L];                Volume.Close[fromVolume];      Volume.Close[toVolume];            END;      -- UGH.. This kludge sets the file's size to be as big as Pilot will let it be, on 100 page increments.  SetBootFileSize: PRIVATE PROC[file: File.File, lvID: Volume.ID] = BEGIN    tries: CARDINAL;     oldSize: File.PageCount &larr; File.GetSize[file];    newSize: File.PageCount &larr; oldSize + Volume.GetAttributes[lvID].freePageCount;    tries &larr; 20;    OthelloOps.MakeUnbootable[file, hardMicrocode, OthelloDefs.leaderPages];    File.SetSize[file, newSize 	  ! File.Unknown =&gt; {OthelloDefs.WriteLine["Warning: Trouble making file fill volume - File.Unknown"L];	    CONTINUE};	    Volume.InsufficientSpace =&gt; {OthelloDefs.WriteString["."L]; newSize &larr; newSize - 100;	    tries &larr; tries - 1; 	    IF tries = 0 OR newSize &lt; oldSize THEN {OthelloDefs.WriteLine["Warning: Expanding volume failed!"]; CONTINUE;} ELSE RETRY};];    OthelloOps.MakeBootable[file,hardMicrocode, OthelloDefs.leaderPages];    END;            ExpandVM: PROC = BEGIN      pvID: PhysicalVolume.ID;      exVolume: Volume.ID;      exFile: File.File;            OthelloDefs.MyNameIs[         myNameIs: "Expand Vmem File"L,	 myHelpIs: "Expand the lisp virtual mem file on a volume"L];            [pvID, exVolume] &larr; OthelloDefs.GetLvIDFromUser[prompt:"Volume to expand: "L];      IF exVolume = Volume.nullID THEN OthelloDefs.AbortingCommand["Invalid volume."L];      Volume.Open[exVolume];      exFile &larr; OthelloOps.GetVolumeBootFile[exVolume, hardMicrocode].file;      IF exFile = File.nullFile THEN OthelloDefs.AbortingCommand["No sysout on volume."L];      OthelloDefs.WriteString["Expanding file..."L];      SetBootFileSize[exFile,exVolume];      OthelloDefs.WriteLine["Done."L];      Volume.Close[exVolume];      END;       --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- FLOPPY commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ListFloppyFiles: PROC = BEGIN       floppyHandle: Floppy.VolumeHandle;     attRec: AttributesRecord;     floppyFileAttributes: Attributes &larr; @attRec;     currentFloppyFile: Floppy.FileHandle &larr; [floppyHandle,Floppy.nullFileID];     i: CARDINAL;     timeTemp: STRING;     unpackedTime: Time.Unpacked;          floppyFileAttributes &larr; @attRec;       -- Open floppy     OthelloDefs.MyNameIs[myNameIs: "List Floppy Files"L,     	myHelpIs: "List files on pilot floppy"L];     floppyHandle &larr; Floppy.Open[     	! Floppy.Error =&gt; {PrintNames: PROC [x: Floppy.ErrorType] =		{ShowFloppyError[x]};};];          -- Enumerate files     DO       currentFloppyFile &larr; Floppy.GetNextFile[currentFloppyFile];       IF currentFloppyFile.file = Floppy.nullFileID THEN EXIT;       ReadLeaderPage[currentFloppyFile, floppyFileAttributes];       FOR i IN [0..floppyFileAttributes.length) DO           OthelloDefs.WriteChar[LOOPHOLE[floppyFileAttributes.name[i]]];	  ENDLOOP;       THROUGH [0..(60-floppyFileAttributes.length)) DO        	  OthelloDefs.WriteChar[' ];	  ENDLOOP;       OthelloDefs.WriteLongNumber[floppyFileAttributes.size];       OthelloDefs.WriteString["   "L];       unpackedTime &larr; Time.Unpack[time: floppyFileAttributes.createDate];       timeTemp &larr; "    ";       Time.Append[timeTemp,unpackedTime];       OthelloDefs.WriteLine[timeTemp];     ENDLOOP;     Floppy.Close[floppyHandle];        END;                         ShowFloppyError:  PROC [error:Floppy.ErrorType] =  {       errString: ARRAY Floppy.ErrorType OF STRING = [        notReady: "Floppy drive not ready."L,        noSuchDrive: "noSuchDrive"L,        invalidFormat: "Floppy not in pilot format"L,        needsScavenging: "Floppy needs scavenging"L,        invalidVolumeHandle: "invalidVolumeHandle"L,	volumeNotOpen: "volumeNotOpen"L,	fileNotFound: "File Not Found"L,	endOfFile: "End of File"L,	writeInhibited: "Floppy is write-protected"L,        hardwareError: "Floppy hardware error"L,	incompatibleSizes: "incompatibleSizes"L,	insufficientSpace: "Floppy volume is full."L,	zeroSizeFile: "Floppy file is zero-size!"L,	fileListFull: "Floppy file list is full."L,	invalidPageNumber: "invalidPageNumber"L,	badDisk: "badDisk"L,	badSectors: "badSectors"L,	onlyOneSide: "onlyOneSide"L,	onlySingleDensity: "onlySingleDensity"L,	initialMicrocodeSpaceNotAvailable: "initialMicrocodeSpaceNotAvailable"L,	stringTooShort: "stringTooShort"L,	fileListLengthTooShort: "fileListLengthTooShort"L,	floppyImageInvalid: "floppyImageInvalid"L,	floppySpaceTooSmall: "floppySpaceTooSmall"L];      OthelloDefs.WriteString["Unexpected floppy problem: "L];      OthelloDefs.WriteString[errString[error]];      OthelloDefs.AbortingCommand["Floppy command aborted."L];      };            --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- The following procs were stolen (more or less) from AccessFloppyImpl  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ReadLeaderPage: PROC [    file: Floppy.FileHandle, attributes: Attributes] =    BEGIN    -- make the buffer for the AttributesRecord in full pages.    buffer: ARRAY [1..maxDataSize + SIZE[AttributesRecord]] OF WORD &larr; ALL[0];    length: CARDINAL &larr; 0;    localAttributes: Attributes &larr; LOOPHOLE[LONG[@buffer]];    Floppy.Read[file, 0, leaderLength, localAttributes];    IF localAttributes.clientDataLength &gt; attributes.maxlength THEN      localAttributes.clientDataLength &larr; 0;    length &larr; SIZE[AttributesRecord] + localAttributes.clientDataLength;    [] &larr; Inline.LongCOPY[to: attributes, nwords: length, from: localAttributes];  END;  -- ReadLeaderPage.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Central commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  commandProcessor: OthelloDefs.CommandProcessor &larr; [LispCommands];  LispCommands: PROC [index: CARDINAL] = {    SELECT index FROM     0 =&gt; CopyVM[];     1 =&gt; ExpandVM[];     2 =&gt; ListFloppyFiles[];    ENDCASE =&gt; OthelloDefs.IndexTooLarge};         -- Initialize  OthelloDefs.RegisterCommandProc[@commandProcessor];END...  </pre>
  </body>
</html>
