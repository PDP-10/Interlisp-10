<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>Library>TEDITFILE!10</title>
  </head>
  <body>
    <pre>
(FILECREATED " 4-Dec-84 10:01:11" {IVY}&lt;TEDIT&gt;TEDITFILE.;8 57053        changes to:  (FNS TEDIT.BUILD.PCTB)      previous date: "25-Nov-84 11:32:38" {IVY}&lt;TEDIT&gt;TEDITFILE.;7)(* Copyright (c) 1983, 1984 by John Sybalsky &amp; Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT TEDITFILECOMS)(RPAQQ TEDITFILECOMS ((FILES TEXTOFD TEDITABBREV TEDITLOOKS IMAGEOBJ TFBRAVO)	(FNS TEDIT.BUILD.PCTB \TEDIT.CONVERT.FOREIGN.FORMAT TEDIT.FORMATTEDFILEP TEDIT.GET 	     TEDIT.INCLUDE TEDIT.PUT TEDIT.PUT.PCTB TEDIT.PUT.PIECE.DESCRIPTOR \ARBIN \ARBOUT \ATMIN 	     \ATMOUT \DWIN \DWOUT \STRINGIN \STRINGOUT \TEDIT.FORMATTEDP1 \TEDIT.SET.WINDOW 	     TEDIT.RAW.INCLUDE \WATOM \WSTRING)	(GLOBALVARS TEDIT.INPUT.FORMATS)	(INITVARS (TEDIT.INPUT.FORMATS NIL))))(FILESLOAD TEXTOFD TEDITABBREV TEDITLOOKS IMAGEOBJ TFBRAVO)(DEFINEQ(TEDIT.BUILD.PCTB  [LAMBDA (TEXT TEXTOBJ START END DEFAULTLOOKS DEFAULTPARALOOKS CLEARGET?)                                                             (* jds " 3-Dec-84 17:20")                                                             (* START = 1st char of file to read from, if specified)                                                             (* END = use this as eofptr of file.							     For use in reading files within files.)    (PROG [SEL LINES PCTB PC OLDPC PCCOUNT TYPECODE PCLEN CHLOOKSSEEN NEWPC PARALOOKSSEEN 	       PIECEINFOCH# CACHE CACHE? TTEXTOBJ USER.CMFILE TSTREAM USERFILEFORMAT USERTEMP 	       EXISTINGCHARLOOKS EXLOOK EXISTINGFMTSPECS (CURFILECH# (OR START 0))	       (CURCH# 1)	       (TEXTSTREAM (AND TEXTOBJ (fetch STREAMHINT of TEXTOBJ]                                                             (* Get the number of pieces needed 							     (if AN formatted file), otherwise PCCOUNT will be NIL)          [SETQ DEFAULTPARALOOKS (OR DEFAULTPARALOOKS (COND				       (TEXTOBJ (fetch FMTSPEC of TEXTOBJ))				       (T (create FMTSPEC using TEDIT.DEFAULT.FMTSPEC]          (COND	    (TEXTOBJ (replace TXTFILE of TEXTOBJ with TEXT)))          (SETQ DEFAULTLOOKS (OR DEFAULTLOOKS (CHARLOOKS.FROM.FONT DEFAULTFONT)))          (SETQ TEXT (\CREATEPIECEORSTREAM TEXT DEFAULTLOOKS DEFAULTPARALOOKS START END))          (AND TEXTOBJ (replace TXTPAGEFRAMES of TEXTOBJ with NIL))                                                             (* Start by assuming no page formatting)          [COND	    ((STREAMP TEXT)	      (AND TEXTOBJ (replace TXTFILE of TEXTOBJ with TEXT))	      [COND		((OR [AND TEXTOBJ (SETQ CACHE? (TEXTPROP TEXTOBJ (QUOTE CACHE]		     (NOT (RANDACCESSP TEXT)))               (* If the file device isn't rancom access, cache the 							     file locally.)                                                             (* Also do this if he asks for a local cache.)		  (SETQ CACHE (OPENSTREAM (QUOTE {NODIRCORE})					  (QUOTE BOTH)					  (QUOTE NEW)))		  (COPYBYTES TEXT CACHE START END)		  (COND		    (CACHE?                                  (* for the folx who don't trust the connections, since 							     all their pcs will point to core, we can close the 							     txtfile connection)			    (CLOSEF TEXT)))		  (SETQ TEXT CACHE)		  (SETQ START (SETQ END NIL]	      (COND		((NEQ (fetch EOLCONVENTION of TEXT)		      CR.EOLC)                               (* This file has a foreign EOL convention.							     Convert it.)		  (SETQ CACHE (OPENSTREAM (QUOTE {NODIRCORE})					  (QUOTE BOTH)					  (QUOTE NEW)))		  (COPYCHARS TEXT CACHE 0 -1)		  (SETQ TEXT CACHE)))	      (SETQ PCCOUNT (\TEDIT.FORMATTEDP1 TEXT END]          [COND	    ((type? PIECE TEXT)                              (* If this isn't a text stream, build a piece table 							     with the one piece in it.)	      (SETQ PCTB (\MAKEPCTB TEXT)))	    (CLEARGET?                                       (* If the user wants an uninterpreted stream onto the 							     file , build a piece table with the one piece in it.)		       (SETQ TEXT (create PIECE					  PFILE &larr; TEXT					  PFPOS &larr;(COND					    (START START)					    (T 0))					  PLEN &larr;(IDIFFERENCE (OR END (GETEOFPTR TEXT))							     (COND							       (START START)							       (T 0)))					  PREVPIECE &larr; NIL					  PLOOKS &larr; DEFAULTLOOKS					  PPARALAST &larr; NIL					  PPARALOOKS &larr; DEFAULTPARALOOKS))		       (SETQ PCTB (\MAKEPCTB TEXT)))	    ((NOT PCCOUNT)                                   (* This is an unformatted file)	      [COND		((SETQ USERFILEFORMAT (for FILETYPE in TEDIT.INPUT.FORMATS					 when (SETQ USERTEMP (APPLY* (CAR FILETYPE)								     TEXT))					 do (RETURN FILETYPE)))                                                             (* The input file is in a user-sensible format, which 							     he is willing to convert for TEdit's use.)                                                             (* See if there are Bravo headers)		  (SETQ PCTB (\TEDIT.CONVERT.FOREIGN.FORMAT (CADR USERFILEFORMAT)							    TEXT USERTEMP TEXTOBJ DEFAULTLOOKS 							    DEFAULTPARALOOKS)))		(T                                           (* Nope--it's straight unformatted text)		   (SETQ PCTB (\MAKEPCTB (create PIECE						 PFILE &larr; TEXT						 PFPOS &larr; CURFILECH#						 PLEN &larr;(IDIFFERENCE (OR END (GETEOFPTR TEXT))								    CURFILECH#)						 PREVPIECE &larr; NIL						 PLOOKS &larr; DEFAULTLOOKS						 PPARALAST &larr; NIL						 PPARALOOKS &larr; DEFAULTPARALOOKS]                                                             (* So create a single piece to describe its contents)	      )	    ((LISTP PCCOUNT)                                 (* This is an obsolete version of the TEdit file 							     format.)	      (SELECTQ (CAR PCCOUNT)		       (0                                    (* VERSION 0)			  (SETQ PCTB (TEDIT.BUILD.PCTB0 TEXT TEXTOBJ (CDR PCCOUNT)							START END)))		       (SHOULDNT 			 "Impossible obsolete version ID while trying to convert old TEdit file.")))	    (T                                               (* This IS a TEdit-format file, so read in all the 							     parts.)	       (SETQ PCTB (\MAKEPCTB NIL PCCOUNT))	       (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))					     8))	       (SETQ PIECEINFOCH# (\DWIN TEXT))	       (SETFILEPTR TEXT PIECEINFOCH#)	       (bind (OLDPC &larr; NIL)		     (OLDPARALOOKS &larr; DEFAULTPARALOOKS) for I from 1 to PCCOUNT as PCN from 										\FirstPieceOffset		  by \EltsPerPiece		  do (SETQ PC NIL)                           (* This loop may not really read a piece, so we have to							     distinguish that case.)		     (SETQ PCLEN (\DWIN TEXT))		     (SETQ TYPECODE (\SMALLPIN TEXT))        (* What kind of piece is it?)		     (SELECTC TYPECODE			      (\PieceDescriptorPAGEFRAME     (* This is page layout info for the file)							 (AND TEXTOBJ (replace TXTPAGEFRAMES									 of TEXTOBJ									 with (TEDIT.GET.PAGEFRAMES										TEXT)))							 (add PCN (IMINUS \EltsPerPiece))                                                             (* This didn't create a piece -- don't count it in the 							     PCTB placement.)							 )			      (\PieceDescriptorPARA          (* Reading a new set of paragraph looks.)						    (AND OLDPC (replace PPARALAST of OLDPC								  with T))                                                             (* Mark the end of the preceding paragraph.)						    (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS TEXT))                                                             (* Get the new set of looks, for use by later pieces.)						    (AND TEXTOBJ (replace FORMATTEDP of TEXTOBJ								    with T))                                                             (* Mark the document as containing paragraph formatting							     info)						    (add PCN (IMINUS \EltsPerPiece))                                                             (* This didn't create a piece -- don't count it in the 							     PCTB placement.)						    )			      (\PieceDescriptorLOOKS         (* New character looks. Build a piece to describe those							     characters.)						     (SETQ PC						       (create PIECE							       PFILE &larr; TEXT							       PFPOS &larr; CURFILECH#							       PLEN &larr; PCLEN							       PREVPIECE &larr; OLDPC							       PPARALOOKS &larr; OLDPARALOOKS))                                                             (* Build the new piece)						     (COND						       (OLDPC                                                              (* If there's a prior piece, hook this one on the 							     chain.)							      (replace NEXTPIECE of OLDPC								 with PC)))						     (\TEDIT.GET.CHARLOOKS PC TEXT)                                                             (* Read the character looks for this guy.)						     (add CURFILECH# (fetch PLEN of PC))                                                             (* And note the passing of characters.)						     )			      (\PieceDescriptorOBJECT        (* It describes an object. Read that, and perhaps some 							     description of the charlooks to go with it.)						      (SETQ PC							(create PIECE								PFILE &larr; TEXT								PFPOS &larr; CURFILECH#								PLEN &larr; PCLEN								PREVPIECE &larr; OLDPC								PPARALOOKS &larr; OLDPARALOOKS))						      (COND							(OLDPC                                                              (* If there's a prior piece, hook this one on the 							     chain.)							       (replace NEXTPIECE of OLDPC								  with PC)))						      (TEDIT.GET.OBJECT TEXTSTREAM PC TEXT CURFILECH#)						      (add CURFILECH# (fetch PLEN of PC))						      [COND							((NOT (ZEROP (\BIN TEXT)))                                                             (* There are new character looks for this object.							     Read them in.)							  (\DWIN TEXT)							  (\WIN TEXT)                                                             (* Skip over the piece-type code we know has to be 							     here.)							  (\TEDIT.GET.CHARLOOKS PC TEXT))							(T                                                              (* No new looks; steal them from the prior piece.)							   (replace PLOOKS of PC							      with (OR (AND OLDPC									    (fetch PLOOKS									       of OLDPC))								       DEFAULTLOOKS]						      (replace PLEN of PC with 1)                                                             (* OBJECTs are officially one character long.)						      )			      (SHOULDNT "Impossible piece-type code in BUILD.PCTB"))		     (COND		       (PC                                   (* If we created a piece, save it in the table.)			   [COND			     ((SETQ EXLOOK (for LOOK in EXISTINGCHARLOOKS					      thereis (EQCLOOKS (fetch PLOOKS of PC)								LOOK)))                                                             (* These charlooks are a duplicate of pre-existing 							     ones. Re-use the old one.)			       (replace PLOOKS of PC with EXLOOK))			     (T (push EXISTINGCHARLOOKS (fetch PLOOKS of PC]			   [COND			     ((SETQ EXLOOK (for LOOK in EXISTINGFMTSPECS					      thereis (EQFMTSPEC (fetch PPARALOOKS of PC)								 LOOK)))                                                             (* These paralooks are a duplicate of pre-existing 							     ones. Re-use the old one.)			       (replace PPARALOOKS of PC with EXLOOK))			     (T (push EXISTINGFMTSPECS (fetch PPARALOOKS of PC]			   (\EDITSETA PCTB PCN CURCH#)			   (\EDITSETA PCTB (ADD1 PCN)				      PC)			   (add CURCH# (fetch PLEN of PC))			   (SETQ OLDPC PC)))		  finally (\EDITSETA PCTB PCN CURCH#)			  (\EDITSETA PCTB (ADD1 PCN)				     (QUOTE LASTPIECE))			  (\EDITSETA PCTB \PCTBLastPieceOffset (ADD1 PCN))			  (\EDITSETA PCTB \PCTBFreePieces 0]          (RETURN PCTB])(\TEDIT.CONVERT.FOREIGN.FORMAT  [LAMBDA (CONVERSIONFN FILE PREDICATERESULT TEXTOBJ DEFAULTLOOKS DEFAULTPARALOOKS)                                                             (* jds "29-Oct-84 12:46")                                                             (* Perform the conversion from a foreign file format 							     into TEdit-internal form as an open TextStream.)    (PROG (TSTREAM TTEXTOBJ SEL WORKINGSTREAM)               (* See if there are Bravo headers)          (SETQ WORKINGSTREAM (OPENTEXTSTREAM ""))          (RESETLST (RESETSAVE (\TEDIT.SET.WINDOW (CONS (TEXTOBJ WORKINGSTREAM)							NIL)))		    (SETQ TSTREAM (APPLY* CONVERSIONFN FILE PREDICATERESULT WORKINGSTREAM)))          (COND	    (TEXTOBJ                                         (* If we're filling in an existing TEXTOBJ, there are 							     fields that need to be copied.)		     [OR (fetch TXTPAGEFRAMES of TEXTOBJ)			 (replace (TEXTOBJ TXTPAGEFRAMES) of TEXTOBJ with (fetch TXTPAGEFRAMES									     of (TEXTOBJ TSTREAM]                                                             (* Such as the page formatting, which the converter may							     well set.)		     ))          (RETURN (fetch PCTB of (TEXTOBJ TSTREAM])(TEDIT.FORMATTEDFILEP  [LAMBDA (STREAM)                                           (* jds "12-Sep-84 15:32")                                                             (* Test to see if this stream's text would need a 							     TEdit-format file (T) or is just plain text 							     (NIL))    (PROG ((TEXTOBJ (TEXTOBJ STREAM))	   (FONTFILE NIL)	   OLDPARALOOKS PC OLDLOOKS PREVPC TENTATIVE)          (SETQ OLDPARALOOKS (fetch FMTSPEC of TEXTOBJ))          (SETQ TENTATIVE (TEXTPROP TEXTOBJ (QUOTE TEDIT.TENTATIVE)))                                                             (* If edits are to be shown)          (SETQ PC (\EDITELT (fetch PCTB of TEXTOBJ)			     (ADD1 \FirstPieceOffset)))      (* First piece in the document)          (SETQ OLDLOOKS (OR (fetch DEFAULTCHARLOOKS of TEXTOBJ)			     TEDIT.DEFAULT.CHARLOOKS))          (while (AND PC (NOT FONTFILE))	     do [COND		  ((fetch POBJ of PC)                        (* OBJECTS require the special format)		    (SETQ FONTFILE (QUOTE IMAGEOBJ)))		  ([AND (OR (NOT PREVPC)			    (fetch PPARALAST of PREVPC))			(NOT (EQUALALL (fetch PPARALOOKS of PC)				       (fetch FMTSPEC of TEXTOBJ]                                                             (* We just hit a paragraph break.)		    (SETQ FONTFILE (QUOTE PARALOOKS)))		  ([OR (NOT (EQCLOOKS OLDLOOKS (fetch PLOOKS of PC)))		       (AND TENTATIVE (OR (AND PREVPC (NEQ (fetch PNEW of PREVPC)							   (fetch PNEW of PC)))					  (AND (NOT PREVPC)					       (fetch PNEW of PC]                                                             (* Change in font, size, etc.)		    (SETQ FONTFILE (QUOTE CHARLOOKS]		(SETQ PREVPC PC)		(SETQ PC (fetch NEXTPIECE of PC)))          (RETURN FONTFILE])(TEDIT.GET  [LAMBDA (TEXTOBJ FILE)                                     (* jds "26-Sep-84 14:14")                                                             (* Get a new file (overwriting the one being edited.))    (PROG (OFILE OCURSOR LINES USER.CMFILE RESP TITLE FILENAME MENUSTREAM		 (SEL (fetch SEL of TEXTOBJ))		 (PCTB (fetch PCTB of TEXTOBJ))		 (TEDIT.GET.FINISHEDFORMS NIL))          (COND	    ([AND (fetch \DIRTY of TEXTOBJ)		  (NOT (MOUSECONFIRM "Not Saved Yet... " "LEFT to Get anyway." (fetch PROMPTWINDOW										  of TEXTOBJ]                                                             (* Only do the GET if he knows he'll zorch himself.)	      (RETURN)))          [SETQ OFILE (OR FILE (MKATOM (TEDIT.GETINPUT TEXTOBJ "File to GET:  "]          (COND	    [(AND OFILE (INFILEP OFILE))                     (* Only if there's a file to load and the file exists.)	      (RESETLST (RESETSAVE (TTYDISPLAYSTREAM (OR (fetch PROMPTWINDOW of TEXTOBJ)							 PROMPTWINDOW)))			(RESETSAVE (CURSOR WAITINGCURSOR))			(\SHOWSEL (fetch SEL of TEXTOBJ)				  NIL NIL)			(\TEXTCLOSEF (fetch STREAMHINT of TEXTOBJ))                                                             (* CLOSE the old files)			(SETQ OFILE (OPENSTREAM OFILE (QUOTE INPUT)))                                                             (* And open the new one.)			[SETQ PCTB (replace PCTB of TEXTOBJ with (TEDIT.BUILD.PCTB								   OFILE TEXTOBJ NIL NIL								   (fetch DEFAULTCHARLOOKS								      of TEXTOBJ)								   (fetch FMTSPEC of TEXTOBJ)								   (TEXTPROP TEXTOBJ (QUOTE CLEARGET]			(for FORM in TEDIT.GET.FINISHEDFORMS do (EVAL FORM))                                                             (* Do any necessary cleanup for outside packages)			(SETQ LINES (fetch LINES of TEXTOBJ))			(replace TXTFILE of TEXTOBJ with OFILE)			(replace \DIRTY of TEXTOBJ with NIL)			(replace NEXTLINE of LINES with NIL)			(replace \INSERTNEXTCH of TEXTOBJ with -1)			[replace TEXTLEN of TEXTOBJ with (SUB1 (\EDITELT PCTB									 (SUB1 (\EDITELT PCTB 									     \PCTBLastPieceOffset]			(replace CH# of SEL with (replace CHLIM of SEL with 1))			(replace DCH of SEL with 0)			(replace POINT of SEL with (QUOTE LEFT))			(replace SET of SEL with T)			(replace SET of (fetch SCRATCHSEL of TEXTOBJ) with NIL)			(replace SET of (fetch SHIFTEDSEL of TEXTOBJ) with NIL)			(replace SET of (fetch MOVESEL of TEXTOBJ) with NIL)			(replace SET of TEDIT.SELECTION with NIL)			(replace SET of TEDIT.SHIFTEDSELECTION with NIL)			(replace CARETLOOKS of TEXTOBJ with (\TEDIT.GET.INSERT.CHARLOOKS TEXTOBJ SEL))			(\FILLWINDOW (fetch YBOT of LINES)				     LINES TEXTOBJ)			(\FIXSEL SEL TEXTOBJ)			(\SHOWSEL SEL NIL T)			(SETQ TITLE (TEXTSTREAM.TITLE TEXTOBJ))                                                             (* find and set the title)			(\TEDIT.WINDOW.TITLE TEXTOBJ (\TEDIT.ORIGINAL.WINDOW.TITLE TITLE))			(SETQ MENUSTREAM (TEDITMENU.STREAM TEXTOBJ))			(COND			  ((AND MENUSTREAM (type? LITATOM TITLE))                                                             (* if we have a filename then put it in the GET and PUT							     fields of the menu)			    (SETQ FILENAME (PACKFILENAME (QUOTE VERSION)							 NIL							 (QUOTE BODY)							 TITLE))			    (MBUTTON.SET.FIELD MENUSTREAM (QUOTE Get)					       FILENAME)			    (MBUTTON.SET.FIELD MENUSTREAM (QUOTE Put)					       FILENAME)))			(\TEDIT.SET.WINDOW.EXTENT TEXTOBJ (\TEDIT.PRIMARYW TEXTOBJ))			(\TEDIT.HISTORYADD TEXTOBJ (create TEDITHISTORYEVENT							   THACTION &larr;(QUOTE Get]	    (OFILE (TEDIT.PROMPTPRINT TEXTOBJ "[File not found.]"))	    (T (TEDIT.PROMPTPRINT TEXTOBJ "[Get aborted.]" T])(TEDIT.INCLUDE  [LAMBDA (STREAM FILE START END)                            (* jds "17-Sep-84 15:50")                                                             (* Obtain a file name, and include that file's contents							     at the place where the caret is.)                                                             (* Returns T if the insertion happened, NIL if there 							     was no place to put it.)    (SETQ STREAM (TEXTOBJ STREAM))    (PROG ((SEL (fetch SEL of STREAM))	   PCTB TEXTLEN NFILE NNFILE INSERTCH# INSPC LEN INSPC# PCLST NPC WASOPEN PCCOUNT NSTREAM)          (COND	    ((fetch SET of SEL)                              (* There is a place to do the include.)	      [SETQ NFILE (OR FILE (MKATOM (TEDIT.GETINPUT STREAM "Name of the file to load:  "]	      (COND		((NOT NFILE)                                 (* If no file was given, don't bother INCLUDEing.)		  (TEDIT.PROMPTPRINT TEXTOBJ "[Include aborted.]" T)		  (RETURN))		((STREAMP NFILE))		((NOT (INFILEP NFILE))                       (* Can't find the file. Put out a message.)		  (TEDIT.PROMPTPRINT TEXTOBJ "[File not found.]")		  (RETURN)))	      (COND		(END                                         (* This is the copy-part-of-a-file case, with file 							     liable to be volatile. Copy it to core for protection)		     (SETQ NNFILE (OPENSTREAM (QUOTE {NODIRCORE})					      (QUOTE OUTPUT)					      (QUOTE NEW)))                                                             (* Create the holding file)		     [SETQ NFILE (COND			 ((OPENP NFILE)			   (SETQ WASOPEN T)			   NFILE)			 (T (OPENFILE NFILE (QUOTE INPUT]    (* And copy the file-section into it.)		     (COPYBYTES NFILE NNFILE START END)      (* must be copychars to respect eol conventions)		     (OR WASOPEN (CLOSEF NFILE))		     (CLOSEF NNFILE)		     (SETQ NFILE NNFILE)		     (SETQ START (SETQ END NIL))             (* Then pretend nothing happened.)		     ))	      (TEDIT.DO.BLUEPENDINGDELETE SEL STREAM)        (* Delete any text, if need be)	      (SETQ TEXTLEN (fetch TEXTLEN of STREAM))       (* We need the POST-deletion text length for later, so 							     this must come after the b-p-d.)	      (\SHOWSEL SEL NIL NIL)                         (* Turn off SELs before we go any further)	      [SETQ NFILE (TEXTOBJ (SETQ NSTREAM (OPENTEXTSTREAM (OPENSTREAM NFILE (QUOTE INPUT))								 NIL NIL NIL (LIST (QUOTE FONT)										   (\TEDIT.GET.INSERT.CHARLOOKS STREAM SEL]          (* Get a textobj to describe the include source file (need NSTREAM so that if we have to convert it to formatted, we	  won't have lost the textstream--and thus smash the free list.))	      (COND		((AND (fetch FORMATTEDP of NFILE)		      (NOT (fetch FORMATTEDP of STREAM)))    (* If the includED text is formatted but this file 							     isn't, let's format it!)		  (\TEDIT.CONVERT.TO.FORMATTED STREAM))		((AND (fetch FORMATTEDP of STREAM)		      (NOT (fetch FORMATTEDP of NFILE)))     (* The TARGET document is formatted, but the INCLUDEd 							     text isn't. Better format it before completing the 							     include.)		  (\TEDIT.CONVERT.TO.FORMATTED NFILE)))	      (SETQ PCTB (fetch PCTB of STREAM))             (* HERE, because the conversion to formatted will 							     lengthen the pctb)	      [SETQ INSERTCH# (COND		  ((EQ (fetch POINT of SEL)		       (QUOTE LEFT))		    (fetch CH# of SEL))		  (T (ADD1 (fetch CHLIM of SEL]              (* Find the place to make the insertion.)	      (SETQ INSPC# (OR (\CHTOPCNO INSERTCH# PCTB)			       (\EDITELT PCTB \PCTBLastPieceOffset)))                                                             (* Likewise, this is affected by the 							     convert-to-formatted)	      (SETQ INSPC (\EDITELT (fetch PCTB of STREAM)				    (ADD1 INSPC#)))          (* The piece to make the insertion in)	      [COND		((NEQ INSPC (QUOTE LASTPIECE))		  (COND		    ((IGREATERP INSERTCH# (\EDITELT PCTB INSPC#))                                                             (* Must split the piece.)		      (SETQ INSPC (\SPLITPIECE INSPC INSERTCH# STREAM INSPC#))		      (add INSPC# \EltsPerPiece)		      (SETQ PCTB (fetch PCTB of STREAM))     (* Refresh the PCTB in case it grew.)		      ]	      (SETQ PCLST (fetch PCTB of NFILE))             (* A temporary pctb, holding the pieces which describe 							     the INCLUDEd text)	      [SETQ LEN (SUB1 (\EDITELT PCLST (SUB1 (\EDITELT PCLST \PCTBLastPieceOffset]	      (SETQ PCCOUNT (IDIFFERENCE (SUB1 (\EDITELT PCLST \PCTBLastPieceOffset))					 \FirstPieceOffset))                                                             (* Remember how many slots in the PCTB we took up 							     (i.e. 2 x # of pieces))	      (\TEDIT.INSERT.PIECES STREAM INSERTCH# (SETQ PCLST (\EDITELT PCLST (ADD1 										\FirstPieceOffset)))				    LEN INSPC INSPC# NIL)	      [COND		((AND (fetch FORMATTEDP of STREAM)		      (NOT (fetch FORMATTEDP of NFILE)))     (* If the includED text is formatted but this file 							     isn't, let's format it!)		  (\TEDIT.CONVERT.TO.FORMATTED STREAM INSERTCH# (IPLUS INSERTCH# LEN]	      (\TEDIT.HISTORYADD STREAM (create TEDITHISTORYEVENT						THACTION &larr;(QUOTE Include)						THCH# &larr; INSERTCH#						THLEN &larr; LEN						THFIRSTPIECE &larr; PCLST))	      (replace TEXTLEN of STREAM with (IPLUS TEXTLEN LEN))	      (AND (fetch \WINDOW of STREAM)		   (\FIXILINES STREAM SEL INSERTCH# LEN TEXTLEN))	      (replace CHLIM of SEL with (IPLUS (replace CH# of SEL with INSERTCH#)						LEN -1))     (* Now fix up the selection to be the included text, 							     point&larr;left, character selection grain.)	      (replace DCH of SEL with LEN)	      (replace (SELECTION DX) of SEL with 0)	      (replace POINT of SEL with (QUOTE RIGHT))      (* So that several things INCLUDED in sequence fall in 							     sequence.)	      (replace SELKIND of SEL with (QUOTE CHAR))	      (replace SELOBJ of SEL with NIL)	      (COND		((fetch \WINDOW of STREAM)		  (TEDIT.UPDATE.SCREEN STREAM)		  (\FIXSEL SEL STREAM)		  (\SHOWSEL SEL NIL T)))	      (replace \DIRTY of STREAM with T)              (* Mark the document changed)	      (\SETUPGETCH (create EDITMARK				   PC &larr; INSPC				   PCOFF &larr; 0				   PCNO &larr;(IPLUS INSPC# PCCOUNT))			   STREAM)                           (* Set the fileptr to the end of the insertion.)	      T)	    (T (TEDIT.PROMPTPRINT STREAM "Please choose the place for the INCLUDE first." T])(TEDIT.PUT  [LAMBDA (STREAM FILE FORCENEW)                             (* jds " 1-Nov-84 16:40")                                                             (* If the guy was editing a file, make a new updated 							     version; else, ask for a file name)                                                             (* If FILE is specd, it's used;							     else the user must give us one)    (PROG ((TEXTOBJ (TEXTOBJ STREAM))	   (TEDIT.PUT.FINISHEDFORMS NIL)	   (TEDIT.GET.FINISHEDFORMS NIL)	   (OUTPUT.FILE.WRITTEN NIL)	   OCURSOR OFILE FONTFILEUSED PROPS WINDOW PUTFN CLEARPUT CACHE MENUSTREAM FILENAME TITLE 	   CH#S PC)          [COND	    (FILE                                            (* We were given a file to use.)		  (SETQ OFILE FILE))	    (FORCENEW                                        (* He insists on a new file.							     (without giving us one NIL))		      (SETQ OFILE (TEDIT.GETINPUT TEXTOBJ "File to PUT to:  ")))	    (T                                               (* Get a file to put the text into)	       (SETQ OFILE (TEDIT.GETINPUT TEXTOBJ "File to PUT to:  " (\TEXTSTREAM.FILENAME TEXTOBJ]          (SETQ PUTFN (TEXTPROP TEXTOBJ (QUOTE PUTFN)))          (SETQ CLEARPUT (TEXTPROP TEXTOBJ (QUOTE CLEARPUT)))          (SETQ CACHE (TEXTPROP TEXTOBJ (QUOTE CACHE)))          (COND	    ((NOT OFILE)                                     (* There's no file to put to;							     don't bother.)	      (RETURN))	    ((AND PUTFN (EQ (APPLY* PUTFN (fetch STREAMHINT of TEXTOBJ)				    (fetch FULLNAME of OFILE)				    (QUOTE BEFORE))			    (QUOTE DON'T)))                  (* He doesn't want this document put.							     Bail out.)	      (RETURN)))          (RESETLST [RESETSAVE [SETQ OFILE (OPENSTREAM (MKATOM OFILE)						       (QUOTE OUTPUT)						       (QUOTE NEW)						       NIL						       (COND							 [CLEARPUT                                                              (* If the user forced no formatting, respect his wish.)								   (QUOTE ((TYPE TEXT]							 [(TEDIT.FORMATTEDFILEP TEXTOBJ)                                                             (* If this file has objects, para looks, or font 							     changes, then we need a binary file.)							   (QUOTE ((TYPE BINARY]							 (T                                                              (* Otherwise, we can get by with a text file)							    (QUOTE ((TYPE TEXT]			       (QUOTE (AND RESETSTATE (DELFILE (CLOSEF? OLDVALUE]		    (replace DESC of (fetch THISLINE of TEXTOBJ) with NIL)		    (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT "PUTting file " (fetch FULLNAME of OFILE)						       "...")				       T)		    [COND		      ((IGREATERP (fetch TEXTLEN of TEXTOBJ)				  0)			(SETQ FONTFILEUSED (TEDIT.PUT.PCTB TEXTOBJ OFILE CLEARPUT]		    (CLOSEF OFILE)                           (* Close the file, to free it up.)		    [COND		      ((NOT CACHE)                           (* CSLI if caching do not need to reopen the output 							     file anyway)			(SETQ OFILE (OPENSTREAM (fetch FULLFILENAME of OFILE)						(QUOTE INPUT]                                                             (* changed TEMPORary for ns filing with caching.							     may not work in general)                                                             (* And re-open it for INPUT only)		    (CLOSEF? (fetch TXTFILE of TEXTOBJ))     (* Close the old text file)		    (replace TXTFILE of TEXTOBJ with OFILE)                                                             (* And remember the new one for next time.)		    (replace \DIRTY of TEXTOBJ with NIL)     (* We can safely QUIT now without losing anything.)		    )          (SETQ CH#S (REVERSE (CDR FONTFILEUSED)))           (* The true filepos's of the pieces in the output 							     file.)          (UNINTERRUPTABLY              (SETQ PC (ELT (fetch PCTB of TEXTOBJ)			    (ADD1 \FirstPieceOffset)))	      (while (AND PC CH#S)		 do                                          (* Run thru the pieces in the PCTB, pointing them to 							     the new file and their new locations.)		    (COND		      ((fetch POBJ of PC))		      (T (replace PFPOS of PC with (pop CH#S))			 (replace PFILE of PC with OFILE)			 (replace PSTR of PC with NIL)))		    (SETQ PC (fetch NEXTPIECE of PC))))          (TEDIT.PROMPTPRINT TEXTOBJ "done.")                (* Tell him we're finished.)          (SETQ TITLE (TEXTSTREAM.TITLE TEXTOBJ))            (* find and set the title)          (\TEDIT.WINDOW.TITLE TEXTOBJ (\TEDIT.ORIGINAL.WINDOW.TITLE TITLE))          (SETQ MENUSTREAM (TEDITMENU.STREAM TEXTOBJ))          (COND	    ((AND MENUSTREAM (type? LITATOM TITLE))          (* if we have a filename then put it in the GET and PUT							     fields of the menu)	      (SETQ FILENAME (PACKFILENAME (QUOTE VERSION)					   NIL					   (QUOTE BODY)					   TITLE))	      (MBUTTON.SET.FIELD MENUSTREAM (QUOTE Get)				 FILENAME)	      (MBUTTON.SET.FIELD MENUSTREAM (QUOTE Put)				 FILENAME)))          (replace \INSERTNEXTCH of TEXTOBJ with -1)         (* Make sure any new insertions happen for real, and 							     not as appends.)          (replace \INSERTPC of TEXTOBJ with NIL)            (* make sure that TEDIT doesn't try to just add to the 							     \INSERTPC since it will now have a pfile property)          (\TEDIT.HISTORYADD TEXTOBJ (create TEDITHISTORYEVENT					     THACTION &larr;(QUOTE Put)					     THCH# &larr; 0					     THLEN &larr; 0					     THFIRSTPIECE &larr; NIL))                                                             (* Remember we did this.)          (AND PUTFN (APPLY* PUTFN (fetch STREAMHINT of TEXTOBJ)			     (fetch FULLNAME of (fetch TXTFILE of TEXTOBJ))			     (QUOTE AFTER)))                 (* CSLI changed to not presume ofile is the txtfile 							     anymore)      ])(TEDIT.PUT.PCTB  [LAMBDA (TEXTOBJ OFILE CLEARPUT SEPARATEFORMAT)            (* jds "25-Nov-84 11:19")                                                             (* Put a representation of the piece table onto OFILE, 							     preserving font changes and paragraph looks.							     CLEARPUT means write no font or formatting info.)    (PROG (OCURSOR CH PC PFILE PSTR POBJ OFILELEN OLDLOOKS (OLDPARALOOKS (fetch FMTSPEC of TEXTOBJ))		   OLDCH# CURCH# PREVPC (FONTFILE NIL)		   (PCCOUNT 0)		   TRUEFILE		   (TEDIT.PUT.FINISHEDFORMS NIL)		   (EDITSTENTATIVE (TEXTPROP TEXTOBJ (QUOTE TEDIT.TENTATIVE)))		   (PARALOOKSSEEN NIL)		   (CACHE (TEXTPROP TEXTOBJ (QUOTE CACHE)))		   CH#S)          (SETQ PC (\EDITELT (fetch PCTB of TEXTOBJ)			     (ADD1 \FirstPieceOffset)))      (* First piece in the document)          (SETQ OLDLOOKS (OR (fetch DEFAULTCHARLOOKS of TEXTOBJ)			     TEDIT.DEFAULT.CHARLOOKS))          (COND	    ((NEQ (fetch EOLCONVENTION of OFILE)		  CR.EOLC)                                   (* This file is on a non-CR host;							     make a note to cache it)	      (SETQ TRUEFILE OFILE)                          (* Remember where the file should wind up.)	      (SETQ OFILE (OPENFILE (QUOTE {NODIRCORE})				    (QUOTE BOTH)				    (QUOTE NEW)))            (* And open a temp file to write it to.)	      ))          [SETQ CURCH# (SETQ OLDCH# (ADD1 (GETFILEPTR OFILE]          (COND	    ((fetch TXTPAGEFRAMES of TEXTOBJ)                (* There is layout info for this file.							     Save it)	      (SETQ FONTFILE (OPENFILE (QUOTE {NODIRCORE})				       (QUOTE BOTH)				       (QUOTE NEW)))	      (TEDIT.PUT.PAGEFRAMES FONTFILE (fetch TXTPAGEFRAMES of TEXTOBJ))	      (add PCCOUNT 1)))          [while PC	     do (COND		  ([AND (NOT (ZEROP (fetch PLEN of PC)))			(OR (NOT PREVPC)			    (fetch PPARALAST of PREVPC))			(OR PARALOOKSSEEN (NOT (EQUALALL (fetch PPARALOOKS of PC)							 (fetch FMTSPEC of TEXTOBJ]                                                             (* The last piece ended a paragraph, so send out new 							     para looks)		    [OR FONTFILE (SETQ FONTFILE (OPENFILE (QUOTE {NODIRCORE})							  (QUOTE BOTH)							  (QUOTE NEW]                                                             (* Create the formatting-info file, if it didn't exist 							     before.)		    (COND		      ((NEQ CURCH# OLDCH#)                   (* There were prior characters that hadn't been 							     described in a piece yet. Describe them)			(\TEDIT.PUT.CHARLOOKS FONTFILE OLDCH# CURCH# OLDLOOKS PREVPC EDITSTENTATIVE)			(add PCCOUNT 1)			(SETQ OLDCH# CURCH#)                 (* And now we've described all the characters up to the							     current one.)			))		    (\TEDIT.PUT.PARALOOKS FONTFILE PC)		    (SETQ PARALOOKSSEEN T)                   (* Remember that we've seen a foreign paralooks, and 							     must henceforth note para boundaries)		    (add PCCOUNT 1)))		(COND		  [(fetch POBJ of PC)                        (* It's an object -- go use its PUTFN)		    [OR FONTFILE (SETQ FONTFILE (OPENFILE (QUOTE {NODIRCORE})							  (QUOTE BOTH)							  (QUOTE NEW]                                                             (* Create the font-info file, if need be.)		    (COND		      ((AND (NEQ CURCH# OLDCH#)			    PREVPC)                          (* There were prior characters that hadn't been 							     described in a piece yet. Describe them)			(\TEDIT.PUT.CHARLOOKS FONTFILE OLDCH# CURCH# OLDLOOKS PREVPC EDITSTENTATIVE)			(add PCCOUNT 1)			(SETQ OLDCH# CURCH#)                 (* And now we've described all the characters up to the							     current one.)			))                                   (* If the prior thing was text, send along its 							     descriptor.)		    (add CURCH# (TEDIT.PUT.OBJECT PC OFILE FONTFILE CURCH#))                                                             (* Send out the object)		    (add PCCOUNT 1)		    (SETQ OLDCH# CURCH#)		    (COND		      ([OR (NOT (EQCLOOKS OLDLOOKS (fetch PLOOKS of PC)))			   [AND EDITSTENTATIVE (NEQ (fetch PNEW of PC)						    (AND PREVPC (fetch PNEW of PREVPC]			   (AND (OR (NOT PREVPC)				    (fetch PPARALAST of PREVPC))				(NOT (EQUALALL (fetch PPARALOOKS of PC)					       (fetch FMTSPEC of TEXTOBJ]                                                             (* The OBJECT has different ooks from before)			(\BOUT FONTFILE 1)			(\TEDIT.PUT.CHARLOOKS FONTFILE OLDCH# CURCH# (fetch PLOOKS of PC)					      PC EDITSTENTATIVE)			(SETQ OLDLOOKS (fetch PLOOKS of PC)))		      (T                                     (* No differences. Don't write any charlooks, and mark 							     that fact)			 (\BOUT FONTFILE 0)                  (* MAKE BLOODY SURE THAT THE NEXT RUN OF CHARACTERS 							     GETS ITS OWN LOOKS)			 ]		  (T                                         (* It's not an object.)		     (COND		       ([OR (NOT (EQCLOOKS OLDLOOKS (fetch PLOOKS of PC)))			    [AND EDITSTENTATIVE (NEQ (fetch PNEW of PC)						     (AND PREVPC (fetch PNEW of PREVPC]			    (AND (OR (NOT PREVPC)				     (fetch PPARALAST of PREVPC))				 (NOT (EQUALALL (fetch PPARALOOKS of PC)						(fetch FMTSPEC of TEXTOBJ]                                                             (* We have a piece with new looks.)			 [OR FONTFILE (SETQ FONTFILE (OPENFILE (QUOTE {NODIRCORE})							       (QUOTE BOTH)							       (QUOTE NEW]			 (COND			   ((NOT (IEQP OLDCH# CURCH#))       (* If there were looks past, and if the run was not 							     empty, save a piece for its looks)			     (\TEDIT.PUT.CHARLOOKS FONTFILE OLDCH# CURCH# OLDLOOKS PREVPC 						   EDITSTENTATIVE)			     (add PCCOUNT 1)))			 (SETQ OLDLOOKS (fetch PLOOKS of PC))			 (SETQ OLDCH# CURCH#)))              (* Now dump out the non-object contents of the piece.)		     [COND		       [(SETQ PFILE (fetch PFILE of PC))     (* It's on a file. Copy it.)			 [OR (OPENP PFILE)			     (replace PFILE of PC with (SETQ PFILE (OPENSTREAM (fetch FULLNAME										  of PFILE)									       (QUOTE INPUT]                                                             (* Make sure the file is open.)			 (COPYBYTES PFILE OFILE (fetch PFPOS of PC)				    (IPLUS (fetch PFPOS of PC)					   (fetch PLEN of PC]		       ((SETQ PSTR (fetch PSTR of PC))       (* It's in a string. Just print it.)			 (for I from 1 to (fetch PLEN of PC) as CH instring PSTR			    do (\BOUT OFILE CH]		     [COND		       ((AND (NOT CACHE)			     (RANDACCESSP OFILE))            (* CSLI leave the pieces and the pctb alone and just 							     write the file if its cached or not randomaccess)			 (push CH#S (SUB1 CURCH#]		     (add CURCH# (fetch PLEN of PC))         (* Keep running track of where in the file we are.)		     ))		(SETQ PREVPC PC)		(SETQ PC (fetch NEXTPIECE of PC))	     finally                                         (* Put out a piece describing the last characters in 							     the file.)		     (COND		       ((AND FONTFILE (NEQ OLDCH# CURCH#))   (* Only if there WERE characters, and only if there's a							     need for font information)			 (\TEDIT.PUT.CHARLOOKS FONTFILE OLDCH# CURCH# OLDLOOKS PREVPC EDITSTENTATIVE)                                                             (* Put out a description of the characters)			 (add PCCOUNT 1]          (for FORM in TEDIT.PUT.FINISHEDFORMS do (EVAL FORM))                                                             (* Do any user-specific cleanup)          (COND	    (TRUEFILE                                        (* This file needs to be converted to the right 							     convention)		      (COND			((AND FONTFILE (NOT CLEARPUT)			      (NOT SEPARATEFORMAT))          (* Formatted file: Copy without converting.)			  (COPYBYTES OFILE TRUEFILE 0 -1))			(T                                   (* Go ahead and convert the EOLCONVENTION, this is a 							     plain-text file)			   (COPYCHARS OFILE TRUEFILE 0 -1)))		      (SETQ OFILE TRUEFILE)))          [COND	    ((AND (OPENP OFILE)		  FONTFILE)                                  (* We need to write format info.)	      (\DWOUT FONTFILE (GETEOFPTR OFILE))            (* So remember the end of the plain-text part of the 							     file)	      (\SMALLPOUT FONTFILE PCCOUNT)                  (* # OF PIECES WE'' NEED TO RECONSTRUCT THIS FILE)	      (\SMALLPOUT FONTFILE 31416)                    (* Now the password for NEW format files: 31416)	      (COND		((AND (NOT CLEARPUT)		      (NOT SEPARATEFORMAT))                  (* Only write fmtg info at the end if we want it 							     there--not if we want plain text or want it kept 							     separate.)		  (COPYBYTES FONTFILE OFILE 0 (GETEOFPTR FONTFILE))                                                             (* Copy the font information to the file trailer)		  )		(T))	      (CLOSEF FONTFILE)	      (COND		((NOT SEPARATEFORMAT)                        (* Unless we want the formatting info separately, 							     delete the file)                                                             (* (since FONTFILE is a stream, we should not need to 							     delete it at all) (DELFILE FONTFILE))		  ]          (RETURN (CONS (COND			  (CLEARPUT NIL)			  (T FONTFILE))			CH#S])(TEDIT.PUT.PIECE.DESCRIPTOR  [LAMBDA (FILE CH1 CHLIM LOOKS)                             (* jds " 1-May-84 11:58")                                                             (* Put a description of LOOKS into FILE.							     LOOKS apply to characters CH1 thru CHLIM-1)    (PROG ((FONT (fetch CLFONT of LOOKS))	   STR)          (SETQ STR (CONCAT "(FONTCREATE " (KWOTE (FONTPROP FONT (QUOTE FAMILY)))			    " "			    (FONTPROP FONT (QUOTE SIZE))			    " "			    (KWOTE (FONTPROP FONT (QUOTE FACE)))			    " )"))          (\DWOUT FILE (IDIFFERENCE CHLIM CH1))              (* The length of this run of looks)          (\SMALLPOUT FILE (NCHARS STR))                     (* The length of the description which follows)          (PRIN1 STR FILE)                                   (* Print the form which can EVAL to re-create the font 							     information)          (\BOUT FILE (LOGOR (COND			       ((fetch CLPROTECTED of LOOKS)				 8)			       (T 0))			     (COND			       ((fetch CLINVISIBLE of LOOKS)				 NIL 4)			       (T 0))			     (COND			       ((fetch CLSELHERE of LOOKS)				 2)			       (T 0))			     (COND			       ((fetch CLCANCOPY of LOOKS)				 1)			       (T 0])(\ARBIN  [LAMBDA (STREAM)                                           (* jds "17-Aug-84 09:53")                                                             (* Read an arbitrary object from a file, parse it, and 							     return it.)    (PROG ((USERSTR (\STRINGIN STREAM)))          (COND	    ((NOT (ZEROP (NCHARS USERSTR)))                  (* There IS user info)	      (RETURN (PROG1 (READ USERSTR)			     (CLOSEF? USERSTR])(\ARBOUT  [LAMBDA (STREAM ITEM)                                      (* jds "28-Aug-84 14:44")                                                             (* Write an arbitrary MKSTRING-able thing in 							     length-contents form.)    (\SMALLPOUT STREAM (OR (AND ITEM (NCHARS ITEM))			   0))    (OR (NOT ITEM)	(ZEROP (NCHARS ITEM))	(PRIN3 ITEM STREAM])(\ATMIN  [LAMBDA (STREAM)                                           (* jds " 3-Apr-84 10:41")    (PROG ((LEN (\SMALLPIN STREAM)))          (RETURN (COND		    ((ZEROP LEN)		      NIL)		    (T (PACK (for I from 1 to LEN collect (CHARACTER (\BIN STREAM])(\ATMOUT  [LAMBDA (STREAM ATOM)                                      (* jds " 1-May-84 11:58")                                                             (* Write an atom's characters in length-contents form.)    (\SMALLPOUT STREAM (NCHARS ATOM))    (OR (ZEROP (NCHARS ATOM))	(for CH inatom ATOM do (\BOUT STREAM CH])(\DWIN  [LAMBDA (FILE)                                             (* jds " 3-JAN-83 16:08")    (IPLUS (LLSH (\BIN FILE)		 24)	   (LLSH (\BIN FILE)		 16)	   (LLSH (\BIN FILE)		 8)	   (\BIN FILE])(\DWOUT  [LAMBDA (FILE NUMBER)                                      (* jds " 3-JAN-83 15:30")    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 24)))    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 16)))    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 8)))    (\BOUT FILE (LOGAND 255 NUMBER])(\STRINGIN  [LAMBDA (STREAM)                                           (* jds " 3-Apr-84 10:41")                                                             (* Write a string on a file in length-contents form;							     one word for the length, and one byte per character 							     contained.)    (PROG ((LEN (\SMALLPIN STREAM))	   STR)          (SETQ STR (ALLOCSTRING LEN))          [OR (ZEROP LEN)	      (for I from 1 to LEN do (RPLCHARCODE STR I (\BIN STREAM]          (RETURN STR])(\STRINGOUT  [LAMBDA (STREAM STRING LEN)                                (* jds " 1-May-84 11:58")                                                             (* Write a string on a file in length-contents form;							     one word for the length, and one byte per character 							     contained.)    (SETQ LEN (OR LEN (NCHARS STRING)))    (\SMALLPOUT STREAM LEN)    (OR (ZEROP LEN)	(for CH instring STRING as I from 1 to LEN do (\BOUT STREAM CH])(\TEDIT.FORMATTEDP1  [LAMBDA (FILE LEN)                                         (* jds "24-Apr-84 17:53")                                                             (* Checks for a version-1 formatted file)          (* Returns NIL if it isn't a formatted file, or the # of pieces needed if it is; leaves file at start of text or 	  of piece descriptions, resp.)    (SETQ LEN (OR LEN (GETEOFPTR FILE)))    (PROG (DESCPTR NPIECES PASSWORD)          (COND	    ((ILEQ LEN 8)                                    (* Too short to be formatted.)	      (RETURN NIL))	    (T (SETFILEPTR FILE (IDIFFERENCE LEN 8))         (* Move to start of FILEPTR to descriptions)	       (SETQ DESCPTR (\DWIN FILE))                   (* Read the file pos of the descriptions)	       (SETQ NPIECES (\SMALLPIN FILE))	       (SETQ PASSWORD (\SMALLPIN FILE))	       (COND		 ((IEQP PASSWORD 31416)                      (* VERSION 1 TEDIT FORMAT)		   (SETFILEPTR FILE DESCPTR)		   (RETURN NPIECES))		 ((IEQP PASSWORD 31415)                      (* VERSION 0 TEDIT FORMAT)		   (SETFILEPTR FILE DESCPTR)		   (RETURN (CONS 0 NPIECES)))		 (T                                          (* NOT A FORMATTED FILE)		    (SETFILEPTR FILE 0)		    (RETURN NIL])(\TEDIT.SET.WINDOW  [LAMBDA (TOWIND)                                           (* jds "29-Oct-84 12:21")                                                             (* USED IN RESETSAVES TO NULL OUT A TEXTSTREAM'S WINDOW							     BRIEFLY.)    (PROG1 (CONS (CAR TOWIND)		 (fetch \WINDOW of (CAR TOWIND)))	   (replace \WINDOW of (CAR TOWIND) with (CDR TOWIND])(TEDIT.RAW.INCLUDE  [LAMBDA (STREAM INFILE START END)                          (* jds "28-Aug-84 16:01")                                                             (* takes a text stream and an OPEN stream to include.							     Note: Start and End are inclusive ptrs, unlike in 							     copybytes and friends)                                                             (* no interpretation (alternate file type e.g. Bravo) 							     takes place. Simply include the characters)                                                             (* Default character and paragraph looks are applied)                                                             (* (* Returns T if the insertion happened, NIL if there 							     was no place to put it.) WHAT DOES THAT MEAN? GBN)    (PROG ((STREAM (TEXTOBJ STREAM))	   (START START)	   (END END)	   SEL PCTB TEXTLEN HOLDING.FILE INSERTCH# INSPC LEN INSPC# PCLST NPC WASOPEN)          (SETQ SEL (fetch SEL of STREAM))          (COND	    ((NOT (fetch SET of SEL))	      (SHOULDNT "\TEDIT.INCLUDE.SPAN called with no selection set"))	    (T                                               (* There is a place to do the include.)	       (COND		 (END                                        (* This is the copy-part-of-a-file case, with file 							     liable to be volatile. Copy it to core for protection)		      (SETQ HOLDING.FILE (OPENSTREAM (QUOTE {NODIRCORE})						     (QUOTE OUTPUT)						     (QUOTE NEW)))                                                             (* Create the holding file)		      [SETQ INFILE (COND			  ((OPENP INFILE)			    (SETQ WASOPEN T)			    INFILE)			  (T (OPENFILE INFILE (QUOTE INPUT]                                                             (* And copy the file-section into it.)		      (COPYBYTES INFILE HOLDING.FILE START END)                                                             (* must be copychars to respect eol conventions)		      (COND			((NOT WASOPEN)			  (CLOSEF INFILE)))		      (CLOSEF HOLDING.FILE)		      (SETQ INFILE HOLDING.FILE)		      (SETQ START (SETQ END NIL))            (* Then pretend nothing happened.)		      ))	       (SETQ TEXTLEN (fetch TEXTLEN of STREAM))	       (SETQ PCTB (fetch PCTB of STREAM))	       [SETQ INSERTCH# (COND		   ((EQ (fetch POINT of SEL)			(QUOTE LEFT))		     (fetch CH# of SEL))		   (T (ADD1 (fetch CHLIM of SEL]             (* Find the place to make the insertion.)	       (SETQ INSPC# (OR (\CHTOPCNO INSERTCH# PCTB)				(\EDITELT PCTB \PCTBLastPieceOffset)))	       (SETQ INSPC (\EDITELT (fetch PCTB of STREAM)				     (ADD1 INSPC#)))         (* The piece to make the insertion in)	       [COND		 ((NEQ INSPC (QUOTE LASTPIECE))		   (COND		     ((IGREATERP INSERTCH# (\EDITELT PCTB INSPC#))                                                             (* Must split the piece.)		       (SETQ INSPC (\SPLITPIECE INSPC INSERTCH# STREAM INSPC#))		       (add INSPC# \EltsPerPiece)		       (SETQ PCTB (fetch PCTB of STREAM))    (* Refresh the PCTB in case it grew.)		       ]	       (SETQ PCLST (create PIECE				   PFILE &larr; INFILE				   PFPOS &larr;(COND				     (START START)				     (T 0))				   PLEN &larr;(IDIFFERENCE [COND							(END END)							(T                                                              (* get the eof pointer)							   (COND							     ((OPENP INFILE)							       (GETEOFPTR INFILE))							     (T (OPENSTREAM INFILE (QUOTE INPUT))								(PROG1 (GETEOFPTR INFILE)								       (CLOSEF INFILE]						      (COND							(START START)							(T 0)))				   PREVPIECE &larr; NIL				   NEXTPIECE &larr; NIL				   PLOOKS &larr;(CHARLOOKS.FROM.FONT TEDIT.DEFAULT.FONT)				   PPARALAST &larr; NIL				   PPARALOOKS &larr;(create FMTSPEC using TEDIT.DEFAULT.FMTSPEC)))	       (SETQ LEN (fetch PLEN of PCLST))	       (\TEDIT.INSERT.PIECES STREAM INSERTCH# PCLST LEN INSPC INSPC# NIL)	       (replace TEXTLEN of STREAM with (IPLUS TEXTLEN LEN))	       (AND (fetch \WINDOW of STREAM)		    (\FIXILINES STREAM SEL INSERTCH# LEN TEXTLEN))	       (replace CHLIM of SEL with (IPLUS (replace CH# of SEL with INSERTCH#)						 LEN -1))    (* Now fix up the selection to be the included text, 							     point&larr;left, character selection grain.)	       (replace DCH of SEL with LEN)	       (replace (SELECTION DX) of SEL with 0)	       (replace POINT of SEL with (QUOTE RIGHT))     (* So that several things INCLUDED in sequence fall in 							     sequence.)	       (replace SELKIND of SEL with (QUOTE CHAR))	       (replace SELOBJ of SEL with NIL)	       (COND		 ((fetch \WINDOW of STREAM)		   (TEDIT.UPDATE.SCREEN STREAM)		   (\FIXSEL SEL STREAM)		   (\SHOWSEL SEL NIL T)))	       (replace \DIRTY of STREAM with T)             (* Mark the document changed)	       (\SETUPGETCH (create EDITMARK				    PC &larr; INSPC				    PCOFF &larr; 0				    PCNO &larr;(IPLUS INSPC# \EltsPerPiece))			    STREAM)                          (* Set the fileptr to the end of the insertion.)	       T])(\WATOM  [LAMBDA (STREAM ATOM)                                      (* jds " 1-May-84 11:58")                                                             (* Write an atom's characters in length-contents form.)    (\SMALLPOUT STREAM (NCHARS ATOM))    (for CH inatom ATOM do (\BOUT STREAM CH])(\WSTRING  [LAMBDA (STREAM STRING LEN)                                (* jds " 1-May-84 11:58")                                                             (* Write a string on a file in length-contents form;							     one word for the length, and one byte per character 							     contained.)    (SETQ LEN (OR LEN (NCHARS STRING)))    (\SMALLPOUT STREAM LEN)    (for CH instring STRING as I from 1 to LEN do (\BOUT STREAM CH]))(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS TEDIT.INPUT.FORMATS))(RPAQ? TEDIT.INPUT.FORMATS NIL)(PUTPROPS TEDITFILE COPYRIGHT ("John Sybalsky &amp; Xerox Corporation" 1983 1984))(DECLARE: DONTCOPY  (FILEMAP (NIL (831 56845 (TEDIT.BUILD.PCTB 841 . 12793) (\TEDIT.CONVERT.FOREIGN.FORMAT 12795 . 14156) (TEDIT.FORMATTEDFILEP 14158 . 16033) (TEDIT.GET 16035 . 20343) (TEDIT.INCLUDE 20345 . 27650) (TEDIT.PUT 27652 . 34189) (TEDIT.PUT.PCTB 34191 . 44710) (TEDIT.PUT.PIECE.DESCRIPTOR 44712 . 45994) (\ARBIN 45996 . 46453) (\ARBOUT 46455 . 46834) (\ATMIN 46836 . 47117) (\ATMOUT 47119 . 47466) (\DWIN 47468 . 47679) (\DWOUT 47681 . 47960) (\STRINGIN 47962 . 48496) (\STRINGOUT 48498 . 48997) (\TEDIT.FORMATTEDP1 48999 . 50289) (\TEDIT.SET.WINDOW 50291 . 50717) (TEDIT.RAW.INCLUDE 50719 . 56040) (\WATOM 56042 . 56361) (\WSTRING 56363 . 56843)))))STOP</pre>
  </body>
</html>
