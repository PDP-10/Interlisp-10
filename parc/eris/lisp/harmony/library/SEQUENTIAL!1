(FILECREATED "21-Aug-84 00:43:18" {ERIS}<LISPCORE>LIBRARY>SEQUENTIAL.;3 17608        changes to:  (VARS SEQUENTIALCOMS)		   (FNS \SEQ.RUN)      previous date: "22-May-84 21:32:17" {ERIS}<LISPCORE>LIBRARY>SEQUENTIAL.;2)(* Copyright (c) 1984 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT SEQUENTIALCOMS)(RPAQQ SEQUENTIALCOMS ((COMS (* Temporary patch-up)			     (P (OR (STRPOS "foo" "FOO" NIL NIL NIL NIL UPPERCASEARRAY)				    (FILESLOAD (SYSLOAD FROM LISPUSERS)					       BSEARCH))))		       (RECORDS SEQUENTIALRUNS)		       (FNS DO.SEQUENTIAL.RUNS \SEQ.PRIN4 \SEQ.DEFAULTFILENAME \SEQ.WORDOUT 			    \SEQ.HOSTHASDIRECTORYSTRUCTUREP \SEQ.RELOAD \SEQ.RUN \SEQ.RUN1)		       (DECLARE: EVAL@COMPILE DONTCOPY (RECORDS INDEXREGION)				 (MACROS INDEXREGION.MOVETO READDBFILEWORD)				 (CONSTANTS INDEXREGION.OFFST RUNSREGION.OFFST))))(* Temporary patch-up)(OR (STRPOS "foo" "FOO" NIL NIL NIL NIL UPPERCASEARRAY)    (FILESLOAD (SYSLOAD FROM LISPUSERS)	       BSEARCH))[DECLARE: EVAL@COMPILE (TYPERECORD SEQUENTIALRUNS (INITFORMS CLEANUPFORMS FINALREM.CM . RELOADINGFORMS))](DEFINEQ(DO.SEQUENTIAL.RUNS  (LAMBDA (SEQUENTIALRUNS LISP.SYSOUTFILE SEQUENTIAL.DCOMFILE LOGFILE DATABASEFILE)                                                             (* JonL " 4-May-84 16:37")          (* * Creates and returns an open stream to a database file, which has the following structure: Word 16 	  (0 origin) contains n the number of "runs" to make, word 17 contains the index of the currently running form, word	  18 contains the file index of the LISP.SYSOUTFILE name, word 19 contains the index of the SEQUENTIAL.DCOMFILE 	  name, word 20 contains the name of the "logging" file, and word 21 contains the name of the database file.	  Word 32 contains the file index of the initialization form, and words 33 through n+33 contains the file indices of	  the s-expressions for each form to be run, and word n+34 contains the fileindex of the cleanup form.)    (OR (type? SEQUENTIALRUNS SEQUENTIALRUNS)	(\ILLEGAL.ARG SEQUENTIALRUNS))    (if (AND LISP.SYSOUTFILE (LITATOM LISP.SYSOUTFILE)	     (FILENAMEFIELD FILE (QUOTE VERSION)))	then (ERROR LISP.SYSOUTFILE 		    "Not possible to use explicit version numbers in LISP.SYSOUT file"))    (SETQ LISP.SYSOUTFILE (OR (\SEQ.DEFAULTFILENAME LISP.SYSOUTFILE (QUOTE <LISP>CURRENT>LISP.SYSOUT)						    T)			      (ERROR LISP.SYSOUTFILE "Can't find a LISP.SYSOUT file")))    (SETQ LISP.SYSOUTFILE (if (STRPOS "DSK" (FILENAMEFIELD LISP.SYSOUTFILE (QUOTE HOST))				      NIL NIL T NIL UPPERCASEARRAY)			      then                           (* Alto EXEC command parser can't accept 							     (DSK) as a host name -- rather it is the implicit 							     default.)				   (PACKFILENAME (QUOTE HOST)						 NIL						 (QUOTE VERSION)						 NIL						 (QUOTE BODY)						 LISP.SYSOUTFILE)			    else                             (* Strip off the version number, so that a random ";"							     won't appear in the REM.CM file.)				 (PACKFILENAME (QUOTE VERSION)					       NIL					       (QUOTE BODY)					       LISP.SYSOUTFILE)))    (SETQ SEQUENTIAL.DCOMFILE (OR (AND (NULL SEQUENTIAL.DCOMFILE)				       (FINDFILE (QUOTE {DSK}SEQUENTIAL.DCOM)))				  (RESETLST (RESETSAVE DIRECTORIES LISPUSERSDIRECTORIES)					    (\SEQ.DEFAULTFILENAME SEQUENTIAL.DCOMFILE (QUOTE 										  SEQUENTIAL.DCOM)								  T))				  (ERROR "Can't find a SEQUENTIAL.DCOM  file")))    (SETQ LOGFILE (OR (\SEQ.DEFAULTFILENAME LOGFILE (QUOTE SEQUENTIAL.LOG))		      (ERROR DATABASEFILE "Can't find a name for the LOG file")))    (if (NULL DATABASEFILE)	then                                                 (* Null case treated specially -- means use 							     {DSK}SEQUENTIALDATA and don't bother saving previous 							     versions)	     (until (NULL (PROG2 (CLOSEF? (QUOTE {DSK}SEQUENTIALDATA))				 (DELFILE (QUOTE {DSK}SEQUENTIALDATA)))))      else (SETQ DATABASEFILE (OR (\SEQ.DEFAULTFILENAME DATABASEFILE (QUOTE SEQUENTIALDATA))				  (ERROR DATABASEFILE "Can't find a name for the database file")))	   (PROG ((VERSIONP (FILENAMEFIELD DATABASEFILE (QUOTE VERSION)))		  (REALFILE (FINDFILE DATABASEFILE)))	         (if (STRPOS "DSK" (FILENAMEFIELD DATABASEFILE (QUOTE HOST))			     NIL NIL T NIL UPPERCASEARRAY)		     then                                    (* Sigh, no multiple versions of database files on 							     {DSK})			  (if VERSIONP			      then (ERROR DATABASEFILE "Can't use version numbers on local disk.")			    elseif REALFILE			      then (until (NULL (PROG2 (CLOSEF? DATABASEFILE)						       (DELFILE DATABASEFILE)))))		   elseif (AND REALFILE VERSIONP)		     then (CLOSEF? REALFILE)			  (DELFILE REALFILE))))    (PROG ((RELOADINGFORMS (fetch (SEQUENTIALRUNS RELOADINGFORMS) of SEQUENTIALRUNS))	   (DATAFILESTREAM (OPENSTREAM (OR DATABASEFILE (QUOTE {DSK}SEQUENTIALDATA))				       (QUOTE OUTPUT)))	   (LOGFILESTREAM (\OUTSTREAMARG (SETQ LOGFILE (OPENFILE LOGFILE (QUOTE OUTPUT)))))	   N INDICESLST TEM)          (DECLARE (SPECVARS DATAFILESTREAM))          (PRIN3 "***SEQUENTIAL.RUNS.DATA.FILE*** " DATAFILESTREAM)                                                             (* A semi-unique header, to act like an identifying 							     password for this kind of file)          (SETQ N (LENGTH RELOADINGFORMS))          (SETFILEPTR DATAFILESTREAM (CEIL (IPLUS RUNSREGION.OFFST (UNFOLD (IPLUS N 1)									   BYTESPERWORD))					   BYTESPERPAGE))    (* Move to S-expression data region, and write out some 							     data)          (SETQ INDICESLST (LIST N (MASK.1'S 0 BITSPERWORD)				 (\SEQ.PRIN4 LISP.SYSOUTFILE)				 (\SEQ.PRIN4 SEQUENTIAL.DCOMFILE)				 (\SEQ.PRIN4 LOGFILE)				 (\SEQ.PRIN4 DATABASEFILE)				 (\SEQ.PRIN4 (fetch (SEQUENTIALRUNS FINALREM.CM) of SEQUENTIALRUNS))				 (\SEQ.PRIN4 (fetch (SEQUENTIALRUNS INITFORMS) of SEQUENTIALRUNS))))          (SETFILEPTR DATAFILESTREAM (PROG1 (GETFILEPTR DATAFILESTREAM)                                                             (* Remember where next printout is to go and ...)					    (SETFILEPTR DATAFILESTREAM INDEXREGION.OFFST)                                                             (* Move to the index region, and fill in the slots)					    (MAPC INDICESLST (FUNCTION \SEQ.WORDOUT))))          (SETQ INDICESLST (NCONC1 (MAPCAR RELOADINGFORMS (FUNCTION \SEQ.PRIN4))				   (\SEQ.PRIN4 (fetch (SEQUENTIALRUNS CLEANUPFORMS) of SEQUENTIALRUNS)					       )))          (SETFILEPTR DATAFILESTREAM (PROG1 0 (SETFILEPTR DATAFILESTREAM RUNSREGION.OFFST)					    (MAPC INDICESLST (FUNCTION \SEQ.WORDOUT))                                                             (* Indices of initialization, reloading, and cleanup 							     forms)					    ))          (replace (STREAM ACCESS) of DATAFILESTREAM with (QUOTE BOTH))          (RESETFORM (RADIX 8)		     (printout LOGFILESTREAM T (GDATE)			       "  ****  Log file for SEQUENTIAL runs of " USERNAME .TAB 20 			       "Machine: "			       .TAB 40 (OR (ETHERHOSTNAME)					   (AND (type? NSADDRESS \MY.NSADDRESS)						(\PRINTNSADDRESS \MY.NSADDRESS LOGFILESTREAM))					   (ETHERHOSTNUMBER))			       " ("			       (L-CASE (MACHINETYPE)				       T)			       ")" .TAB 20 "Microcode Version: " .TAB 40 (QUOTE %[)			       (LOADBYTE (MICROCODEVERSION)					 8 8)			       ", "			       (LOADBYTE (MICROCODEVERSION)					 0 8)			       (QUOTE %])			       .TAB 20 "Lisp System Date: " .TAB 40 MAKESYSDATE .TAB 20 			       "Memory Size: "			       .TAB 40 (REALMEMORYSIZE)			       (QUOTE Q)			       T T))          (DRIBBLE LOGFILESTREAM)          (MAPC (fetch (SEQUENTIALRUNS INITFORMS) of SEQUENTIALRUNS)		(FUNCTION EVAL))                             (* Do the initilization forms)          (\SEQ.RELOAD 0 LOGFILESTREAM DATAFILESTREAM)       (* Begin at the beginning!)          (SHOULDNT "Not Supposed to return from \SEQ.RELOAD "))))(\SEQ.PRIN4  (LAMBDA (X)                                                (* JonL "28-Apr-84 22:02")    (DECLARE (USEDFREE DATAFILESTREAM))    (PROG1 (GETFILEPTR DATAFILESTREAM)	   (PRIN4 X DATAFILESTREAM)	   (BOUT DATAFILESTREAM (CHARCODE SPACE)))))(\SEQ.DEFAULTFILENAME  (LAMBDA (FILE DEFAULTNAME MUSTEXIST?)                      (* JonL " 2-May-84 20:45")    (PROG ((THISHOST (OR (for X HOST in LISPUSERSDIRECTORIES when (SETQ HOST (FILENAMEFIELD								      X								      (QUOTE HOST)))			    do (RETURN HOST))			 (QUOTE {DSK})))	   (XFILE (SELECTQ FILE			   (NIL (QUOTE {DSK}))			   (T (FILENAMEFIELD (DIRECTORYNAME T)					     (QUOTE HOST)))			   (if (LITATOM FILE)			       then FILE			     elseif (STREAMP FILE)			       then (PROG ((FULL (FULLNAME FILE (QUOTE OLD))))				          (if (LITATOM FULL)					      then (RETURN FULL)))))))          (OR XFILE (RETURN))                                (* Note hack below to dispense with the directory name 							     when the host doesn't support a directory structure.)          (SETQ XFILE (PACKFILENAME (QUOTE BODY)				    XFILE				    (QUOTE HOST)				    THISHOST				    (QUOTE DIRECTORY)				    (AND (\SEQ.HOSTHASDIRECTORYSTRUCTUREP (OR (FILENAMEFIELD										XFILE										(QUOTE HOST))									      THISHOST))					 (FILENAMEFIELD DEFAULTNAME (QUOTE DIRECTORY)))				    (QUOTE BODY)				    DEFAULTNAME))          (if MUSTEXIST?	      then (OR (SETQ XFILE (FINDFILE XFILE))		       (LISPERROR "FILE NOT FOUND" (SELECTQ FILE							    ((NIL T)							      XFILE)							    FILE))))          (RETURN XFILE))))(\SEQ.WORDOUT  (LAMBDA (X)                                                (* JonL "30-Apr-84 20:48")    (\WOUT DATAFILESTREAM X)))(\SEQ.HOSTHASDIRECTORYSTRUCTUREP  (LAMBDA (HOST)                                             (* JonL "27-Apr-84 17:42")                                                             (* The HOST argument should be the name without curly 							     braces)    (OR (HOSTNAMEP HOST)	(\ILLEGAL.ARG HOST))                                 (* Currently, we just screen out DSK type hosts.)    (OR (NOT (STRPOS "DSK" HOST NIL NIL T NIL UPPERCASEARRAY))	(find I from 4 suchthat (NOT (DIGITCHARP (OR (NTHCHARCODE HOST I)						     (RETURN))))))))(\SEQ.RELOAD  (LAMBDA (K LOGFILESTREAM DATAFILESTREAM)                   (* JonL " 4-May-84 16:46")          (* * Cons up the appropriate command line for the Alto EXEC so that after logout, the form at index K will be in a	  "fresh" Lisp.)    (DRIBBLE)    (CLOSEF? LOGFILESTREAM)                                  (* DRIBBLE should close the LOGFILESTREAM but who knows 							     if the user mucked with it somehow)    (SETFILEPTR DATAFILESTREAM 0)    (OR (STREQUAL "***SEQUENTIAL.RUNS.DATA.FILE***" (RSTRING DATAFILESTREAM))	(SHOULDNT (QUOTE {DSK}SEQUENTIALDATA)))    (RESETFORM (SETREADTABLE FILERDTBL)	       (PROG (N REMS SYSOUTFILENAME DCOMFILENAME DATABASEFILENAME)		     (SETQ N (READDBFILEWORD DATAFILESTREAM NUMBER.OF.RUNS))		     (OR (AND (ILESSP K N)			      (IGEQ K 0))			 (SHOULDNT "FORM index not in valid range"))                                                             (* K is 0-origin indexing; N now includes the cleanup 							     forms count.)		     (SETQ REMS (SIGNED (READDBFILEWORD DATAFILESTREAM CURRENT.RUN)					BITSPERWORD))		     (OR (EQ K (ADD1 REMS))			 (SHOULDNT (CONCAT "FORM index out of sequence (by amount " (IDIFFERENCE					     K REMS)					   ").")))		     (SETQ SYSOUTFILENAME (READDBFILEWORD DATAFILESTREAM LISP.SYSOUTFILE))		     (SETQ DCOMFILENAME (READDBFILEWORD DATAFILESTREAM SEQUENTIAL.DCOMFILE))		     (SETQ DATABASEFILENAME (READDBFILEWORD DATAFILESTREAM DATABASEFILE))		     (SETQ SYSOUTFILENAME (RSTRING (PROG2 (SETFILEPTR DATAFILESTREAM SYSOUTFILENAME)							  DATAFILESTREAM)))		     (for I C from 1 to (NCHARS SYSOUTFILENAME)			do                                   (* Change {'s to %['s in the file name, since it is read							     by the alto EXEC)			   (SELCHARQ (SETQ C (NTHCHARCODE SYSOUTFILENAME I))				     (({ })				       (RPLCHARCODE SYSOUTFILENAME I (SELCHARQ C									       ({ (CHARCODE %[))									       (} (CHARCODE %]))									       (SHOULDNT))))				     NIL))		     (SETQ DCOMFILENAME (RSTRING (PROG2 (SETFILEPTR DATAFILESTREAM DCOMFILENAME)							DATAFILESTREAM)))		     (SETQ DATABASEFILENAME (RATOM (PROG2 (SETFILEPTR DATAFILESTREAM DATABASEFILENAME)							  DATAFILESTREAM)))		     (until (NULL (PROG2 (CLOSEF? (QUOTE {DSK}REM.CM))					 (DELFILE (QUOTE {DSK}REM.CM)))))		     (SETQ REMS (OPENSTREAM (QUOTE {DSK}REM.CM)					    (QUOTE OUTPUT)))		     (PROGN                                  (* printout just isn't quite good enough for this one)			    (PRIN3 "Lisp " REMS)			    (PRIN3 SYSOUTFILENAME REMS)			    (PRIN3 " ;(PROGN (FILESLOAD (SYSLOAD) " REMS)			    (PRIN3 DCOMFILENAME REMS)			    (PRIN3 ") (\SEQ.RUN " REMS)			    (PRIN3 K REMS)			    (if DATABASEFILENAME				then (PRIN3 " " REMS)				     (PRIN3 DATABASEFILENAME REMS))			    (PRIN3 "]" REMS))		     (TERPRI REMS)		     (CLOSEF REMS)		     (LOGOUT T)))))(\SEQ.RUN  (LAMBDA (K DATABASEFILE)                                   (* JonL "21-Aug-84 00:39")          (* * Run the form at index K (0 origin) and if there are more, then continue reloading)    (PROG ((HELPFLAG NIL)	   (DATAFILESTREAM (OPENSTREAM (OR DATABASEFILE (QUOTE {DSK}SEQUENTIALDATA))				       (QUOTE BOTH)))	   N LOGFILESTREAM)          (DECLARE (SPECVARS HELPFLAG LOGFILESTREAM)		   (GLOBALVARS PAGE.WAIT.SECS))          (SETQ PAGE.WAIT.SECS 0)          (ADVISE (QUOTE PAGEFULLFN)		  (QUOTE BEFORE)		  (QUOTE (RETURN)))          (INDEXREGION.MOVETO DATAFILESTREAM NUMBER.OF.RUNS)          (SETQ N (\WIN DATAFILESTREAM))                     (* Haumany "runs" total)          (OR (ILESSP K N)	      (IGEQ K 0)	      (SHOULDNT "Non-existent FORM index"))          (INDEXREGION.MOVETO DATAFILESTREAM LOGFILE)          (SETFILEPTR DATAFILESTREAM (\WIN DATAFILESTREAM))          (DRIBBLE (SETQ LOGFILESTREAM (OPENSTREAM (READ DATAFILESTREAM FILERDTBL)						   (QUOTE APPEND)						   (QUOTE OLD))))                                                             (* Re-open the LOG/DRIBBLE file)          (\SEQ.RUN1 K DATAFILESTREAM)          (add K 1)          (if (ILESSP K N)	      then                                           (* Unless we just completed the last one, then reload.)		   (\SEQ.RELOAD K LOGFILESTREAM DATAFILESTREAM)	    else                                             (* But on the last K, which is the list of "cleanup" 							     forms, we map EVAL down it.)		 (\SEQ.RUN1 K DATAFILESTREAM T)		 (INDEXREGION.MOVETO DATAFILESTREAM CURRENT.RUN)		 (\WOUT DATAFILESTREAM (ADD1 K))             (* If "working" on the N+1'th form, then all done.)		 (DRIBBLE)		 (CLOSEF? LOGFILESTREAM)		 (INDEXREGION.MOVETO DATAFILESTREAM REM.CM)		 (SETFILEPTR DATAFILESTREAM (\WIN DATAFILESTREAM))                                                              (* Get the final REM.CM and stuff it into the {DSK} 							     file.)		 (until (NULL (PROG2 (CLOSEF? (QUOTE {DSK}REM.CM))				     (DELFILE (QUOTE {DSK}REM.CM)))))		 (PROG (FILE (REM.CM (READ DATAFILESTREAM FILERDTBL)))		       (if REM.CM			   then (SETQ FILE (OPENFILE (QUOTE {DSK}REM.CM)						     (QUOTE OUTPUT)))				(PRIN4 REM.CM FILE)				(CLOSEF FILE)))		 (LOGOUT)))))(\SEQ.RUN1  (LAMBDA (K DATAFILESTREAM EVLISP)                          (* JonL " 7-May-84 00:24")    (INDEXREGION.MOVETO DATAFILESTREAM CURRENT.RUN)    (\WOUT DATAFILESTREAM K)                                 (* Inform the database file of which one we are 							     beginning to evalueate.)    (SETFILEPTR DATAFILESTREAM (IPLUS RUNSREGION.OFFST (UNFOLD K BYTESPERWORD)))    (SETFILEPTR DATAFILESTREAM (\WIN DATAFILESTREAM))        (* So go to the place in the S-expression part of the 							     file)    (PROG ((FORM (LISTP (READ DATAFILESTREAM FILERDTBL)))	   (HELPFLAG NIL))          (DECLARE (SPECVARS HELPFLAG))          (if EVLISP	      then (ERSETQ (MAPC FORM (FUNCTION EVAL)))	    else (ERSETQ (EVAL FORM))))    NIL)))(DECLARE: EVAL@COMPILE DONTCOPY [DECLARE: EVAL@COMPILE (BLOCKRECORD INDEXREGION ((NUMBER.OF.RUNS WORD)			  (CURRENT.RUN WORD)			  (LISP.SYSOUTFILE WORD)			  (SEQUENTIAL.DCOMFILE WORD)			  (LOGFILE WORD)			  (DATABASEFILE WORD)			  (REM.CM WORD)			  (INITFORMSX WORD)			  (LASTFIELD WORD)))](DECLARE: EVAL@COMPILE (PUTPROPS INDEXREGION.MOVETO MACRO ((FILE FIELD)  (SETFILEPTR FILE (IPLUS INDEXREGION.OFFST (UNFOLD (INDEXF (fetch (INDEXREGION FIELD) of T))						    BYTESPERWORD)))))(PUTPROPS READDBFILEWORD MACRO ((STRM FIELD)  (INDEXREGION.MOVETO STRM FIELD)  (\WIN STRM))))(DECLARE: EVAL@COMPILE (RPAQQ INDEXREGION.OFFST 32)(RPAQQ RUNSREGION.OFFST 64)(CONSTANTS INDEXREGION.OFFST RUNSREGION.OFFST)))(PUTPROPS SEQUENTIAL COPYRIGHT ("Xerox Corporation" 1984))(DECLARE: DONTCOPY  (FILEMAP (NIL (1129 16761 (DO.SEQUENTIAL.RUNS 1139 . 8242) (\SEQ.PRIN4 8244 . 8509) (\SEQ.DEFAULTFILENAME 8511 . 9937) (\SEQ.WORDOUT 9939 . 10079) (\SEQ.HOSTHASDIRECTORYSTRUCTUREP 10081 . 10655) (\SEQ.RELOAD 10657 . 13596) (\SEQ.RUN 13598 . 15974) (\SEQ.RUN1 15976 . 16759)))))STOP