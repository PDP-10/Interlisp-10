<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>MPCodes.Mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:TITLE[MPCodes];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Dolphin Maintenance Panel codes.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ed Fiala 1 June 1982<br><br>%This file defines Alto.Eb MP codes.  The runtime error codes are compatible<br>with Pilot/Cedar microcode releases after 10 September 1981 except that task<br>numbers are different for Pilot/Cedar.  Although EPROM and Initial MP codes<br>are mentioned, full documentation for them is elsewhere.  In general codes<br>between 0 and 99 are from the EPROM, 700 to 799 from Initial, and<br>100 to 255 from Alto.Eb.<br><br>Booting takes place in four steps: First, the EPROM delivers a tiny<br>diagnostic and boot loader into the microstore--this program is necessarily<br>limited for the reasons discussed in the D0 Hardware Manual.  If the<br>processor test fails, it shows an error MP code briefly, waits 30 seconds,<br>and boots again.  If all is well, registers are initialized and the first<br>program on the disk boot record (normally Initial) is loaded directly into<br>IM; if the disk won&rsquo;t work, Initial is obtained from the Ethernet.  Storage<br>is not used during any part of the EPROM boot.<br><br>Next, Initial is started at either its disk or ether boot address.  It first<br>initializes storage and the map; on a disk boot, it then reads the rest of<br>the disk boot record into storage; on an ether boot, it places either<br>AltoCSL.Eb or AltoLF.Eb from the Ethernet (These files are now identical)<br>into storage.  Finally, it exits with LoadRAM.<br><br>Alto.Eb starts the third stage boot at either KGO or EGO.  It shows the final<br>MP code from Initial, then StartDeviceInit, StartEtherBoot, and<br>GotBreathOfLife for about 0.3 seconds each; other MP codes normally flash<br>past too quickly to view, unless an error is detected.  If the disk is ready<br>(which happens about ~ 2 min. after power on), StartDiskBoot is shown instead<br>of StartEtherBoot, but it normally flashes past too quickly to be seen.<br><br>At this point the final microcode overlay is loaded and the number of good<br>pages is shown on the MP.  Then the Alto emulator is started at the<br>Breath-of-life program&rsquo;s disk boot or Ether boot starting address.<br><br>With the Initial current on 16 October 1981, the viewable MP sequence for a<br>"normal" disk boot is 8888, 40, 700, 720, 104, NPages (see below).  Other MP<br>codes are not up long enough to see unless something goes wrong.<br>The viewable sequence for a "normal" ether boot is 8888, [46, 60], 700, 760,<br>104, 114, 118, NPages (see below), where "46, 60" may repeat several times<br>before continuing with the rest of the sequence.  The 760 will be 758 on an<br>LF Dolphin.  For both of these sequences, the "8888" only appears while you<br>are pushing the Start button, not at all if you keyboard boot.<br><br>After showing GotBreathOfLife (118) for .3 sec, the final microcode overlay<br>is loaded and MP then shows the number of pages found to be good during<br>storage init.  For perfect storage boards, the MP will show 96K/256<br>pages/board which is 384 x number of storage boards (i.e., 768, 1152, 1536,<br>1920, 2304, or 2688).  Some MPs will show this value plus 1 occasionally for<br>unknown reasons.  However, if the number of good pages is less than 256,<br>then the NotEnoughMemory code (101) will be shown instead.<br><br>Many machines malfunction briefly when first powered up, then work correctly.<br>If the EPROM diagnostic detects a malfunction it will show an error MP code<br>briefly, then show "46" for a long time (30 sec), then boot again.  If you<br>get impatient during such a wait, push the power on button again to retry<br>immediately.  If an error is detected after StartDeviceInit (104) or if the<br>NotEnoughMemory error (101) occurs, initialization will loop back to<br>StartDeviceInit after showing the MP code for .3 seconds.  It is improbable<br>that retrying will succeed, so push the power on button to reboot.<br>%<br><br>*INITIALIZATION MP CODES<br><br>MC[StartMapInit,144];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*100d (debugging only)<br>  MC[BadMap,146];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  *102d (debugging only)<br><br>  MC[NotEnoughMemory,145];</span><span class="tab" val="67"></span><span style="font: 10pt serif">  *101d (.ls. 512 functional storage pages)<br>MC[StartDeviceInit,150];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*104d<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*+1 (=105d started display init)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*+1 (=106d finish loading or flushing CSL<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span class="tab" val="67"></span><span style="font: 10pt serif">keyboard overlay)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*+1 (=107d ordinarily, 106d when debugging<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span class="tab" val="67"></span><span style="font: 10pt serif">with Midas--finished display init)<br>MC[StartDiskBoot,156];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*110d (usually invisible)<br>  MC[NoDiskStatus,157];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  *111d<br>  MC[BadBoot,160];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  *112d<br>MC[StartEtherBoot,162];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*114d<br>MC[GotBreathOfLife,166];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*118d (breath-of-life read successfully from<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*disk or Ethernet)<br><br>*Error Codes for Fault.Mc<br>MC[RMCSCrash,170];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*120d to 135d RM or CS parity error possibly in<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*combination with other errors.  MP code is 120d<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*plus:</span><span class="tab" val="67"></span><span style="font: 10pt serif">1  if MC1 or MC2 error<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span class="tab" val="67"></span><span style="font: 10pt serif">2  if RM parity error<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span class="tab" val="67"></span><span style="font: 10pt serif">4  if CS parity error<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span class="tab" val="67"></span><span style="font: 10pt serif">8  if Stack overflow or underflow<br><br>%The following codes imply that there was no RM or IM parity error.<br>Many of the following codes show a multiple of 20d + the task number<br>responsible for the error; e.g., if an MC1 error occurred on a reference<br>by task N, the code would be X+N.  NOTE: The codes which have the pipe task<br>added to them are offset by 15d because of the microcode&rsquo;s algorithm--the<br>comments are correct, however.<br>%<br>MC[MOBCrash,214];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*140d + current task.  Map Out of Bounds (Mesa handles<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*these itself, so should only occur for Alto emulator)<br>MC[H4PECrash,240];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*160d + current task.  H4PE (Never happens now)<br>MC[LPCrash,264];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*180d + current task.  Some fault when preceding mi<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*was a LoadPage (Indicates microcode bug--report it).<br><br>*The following codes imply that there was no RM, CS, H4PE, or MOB error<br>MC[MC2Crash,327];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*200d + pipe task.  MC2 error (Double bit failure or<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*microcode bug or single bit failure if specially<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*enabled)<br>MC[MC22Crash,165];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*117d 2 MC2 errors<br>MC[MCNoneCrash,210];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*136d--MC12 error with no error indication in the<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*pipe--possibly PFetch4 experienced error correction,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*next reference faulted, and third reference<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*slipped in erroneously.<br><br>*The following codes imply no RM, CS, H4PE, MOB, or MC2 errors in combination<br>MC[MC1Crash,353];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*220d + pipe task.  MC1 fault (Page fault or write<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*protect fault; Mesa emulator handles these itself,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*so this code should only occur for Alto emulator)<br><br>MC[BrkPCrash,360];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*240d + current task.  SetFault (i.e., breakpoint)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*by task, interpreted as follows:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0 emulator<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1 unused (bad wakeup)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 2 unused (bad wakeup)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 3 unused (bad wakeup)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 4 unused (bad wakeup)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 5 color display controller<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 6 ethernet output<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 7 ethernet input<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 8 SA4000 controller<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 9 unused (bad wakeup)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*10 display controller<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*11 unused (bad wakeup)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*12 unused (bad wakeup)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*13 unused (bad wakeup)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*14 timer (bad timer wakeup)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*15 fault<br><br>*The following codes imply that no other errors occurred in combination<br>MC[eoCrash,163];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*115d Unexpected Ethernet output wakeup<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*116d NoStateVectorError for Pilot/Cedar.<br></span><span style="font: 12pt serif">*MC[NextInstMPCode,?];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Hardware problem on some machines causing<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*ResetErrors executed at the onset of a fault to be<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*interpreted as a NextInst.  The consequence of this<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*is that SStkP &larr; StkP and PCX advance occurs. <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(NO LONGER DETECT THIS)<br>MC[StkCrash,167];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*119d Stack over/underflow<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
