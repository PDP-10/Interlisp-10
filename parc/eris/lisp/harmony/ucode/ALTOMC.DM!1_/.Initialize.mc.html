<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>Initialize.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 6pt; text-align: left">
<span style="font: 10pt serif">:TITLE[Initialize];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ed Fiala 3 June 1982<br><br>* placed PNIP October 15, 1982  5:52 PM<br>* added With3MB switch to device table June 30, 1982  9:51 PM<br><br>%RM assignments are subject to a number of constraints:<br><br>1) Must not smash the registers needed to continue LoadRAM; these are<br>LP, LPhi, and xfTemp (RM 66, 67, 72); RTemp1 must be set even (to believe<br>starting address) and xfTemp1 must be set odd (for normal tasking) before<br>continuing LoadRAM.<br>2) Registers needed valid after DeviceInit or used during DeviceInit must not<br>be in the range 40-57, which is used as a buffer during DeviceInit.<br>Registers constrained by this are AllOnes, R400, MDS, MDShi, PCB, BootType,<br>PageCount, xCNT, ?<br>3) BootType may not be in the range 0-17 because it is referenced by<br>BootTask (task 1, 2, or 3).<br>4) PCB (RM 30) must not be smashed on soft boot.<br><br>xCNT (35) is used throughout init; xBuf to xBuf3 (44 - 47),<br>RTemp and RTemp1 (52 - 53) are also used except during DeviceInit.<br>%<br>RV[PageCount,37];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Count of available real pages in system.<br>RV[BootType,36];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*even =&gt; hard boot, odd =&gt; soft boot, where<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*soft boot = hard boot except preserve disk<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*partition and PCB for start;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*negative =&gt; ether, positive =&gt; disk<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*200 disk partition 2<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RM address must not be &lt; 20b nor 40b to 57b.<br>RV4[iniBf0,iniBf1,iniBf2,iniBf3,14];<br><br>*Registers for map and storage initialization<br>RV[CompFlag,5];<br>RV2[ZWord,ZWordhi,6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Base reg<br>RV[MapAddr,10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*current map location<br>RV[RealPage,11];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*current real storage page<br><br>*In addition to the registers below, RTemp, RTemp1, and DMA are used prior<br>*to DiskBoot/EtherBoot code; xCNT, DevIndex, contemp, DMA, and DMAhi must<br>*not be in 40-57 area.<br><br>RV[RBuf1,34];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*used in DeviceInit<br>RV[Assigned,65];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*used in DeviceInit<br>RV[DevIndex,12];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*used in DeviceInit and DiskBoot<br>RM[ErrorCnt,IP[RTemp]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*used in DiskBoot<br>RM[ErrorCountx,IP[RTemp1]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*used in DiskBoot<br><br>MC[ReturnOnSE,100000];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*FFault bit 0=crash on MC2 errors, 1=return<br><br>*The DTab macro formats device table entries.  A DTab entry consists of the<br>*task and uPC value for the device&rsquo;s init routine (0 if no init routine).<br>*To add a new controller to the system, it is only necessary to add an entry<br>*to the device table (and add the controller&rsquo;s microcode).<br><br>M@[DTab,IMData[LH[#1] RH[LShift[#2,4],#3] At[DTabLoc]] Set[DTabLoc,Add[DTabLoc,1]]];<br><br>Set[DTabLoc,DTabBase];<br><br>DTab[12000,0,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*DES board<br>DTab[127000,0,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*FP board<br>**NOTE: The CDC is an optional device; perhaps we should require software to<br>**manually start the controller&rsquo;s microcode with JRAM 50000b+cdcInitLoc and<br>**not initialize the device here, so that this table won&rsquo;t change when the<br>**uCode is not present.<br>:IF[WithColor];<br>DTab[127400,cdcInitLoc,cdcTask];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Color display = 53400b;<br>:ENDIF;<br><br>:IF[With3MB]; **********<br>DTab[3400,EtherInitLoc,eiTask]; *New Ethernet input = 3400b<br>DTab[3000,0,eoTask];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*New Ethernet output=3000b(No init required)<br>:ENDIF; **********<br><br>:IF[With10MB]; **********<br></span><span style="font: 12pt serif">DTab[12400,enxInitLoc,enxTask];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*1st 10mb Ethernet<br></span><span style="font: 10pt serif">:ENDIF; **********<br><br>DTab[1000,DisplayInitLoc,DpTask]; *Display (UTVFC) = 1000b<br>DTab[1400,rdcInitLoc,rdcTask];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Disk (Alto RDC) = 1400b<br>DTab[2400,rdcInitLoc,rdcTask];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Disk (Alto RDC) = 2400b (kludge if service late is on)<br>DTab[0,0,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*final table entry must be zero<br><br>OnPage[InitPage]; <br><br>%KGO, EGO, and KGOP2 are Midas starting addresses which can be entered in<br>any task.  Initial sends control to KGO if the disk is ready, else to EGOx,<br>where EGOx and KGOP2x are suitable starting addresses only if the current<br>task is the emulator (or tasks 1 to 3).<br>***EGOx AND KGOx PLACEMENT IS KNOWN TO MAKELOADERFILE COMMAND FILES***<br><br>On keyboard boot, Display.Mc leaves KB0 word in BootTask&rsquo;s T register<br>(because T registers of unused tasks safely hold data across a boot).<br>1&rsquo;s in KB0 represent keys up, 0&rsquo;s keys down; bits are: 5, 4, 6, E, 7, D,<br>U, V, 0, K, -, P, /, \, LF, BS.<br>"0" (177577b) is interpreted here as a partition 2 disk boot;<br>BS (177776b) is ether boot;<br>all other values do a partition 1 disk boot.<br><br>Soft booting transfers control between variant microcode systems (e.g., Lisp,<br>Smalltalk, or Mesa each with an Alto emulator) without smashing storage; the<br>disk partition and PCB are also preserved.  The program initiating a soft<br>boot first cleans up the Map (if necessary), places the microcode image and<br>its overlays into storage, and calls xoLRJ.  LoadRAM then transfers control<br>to SoftGO (7202), the starting address; control eventually resumes at PCB+1<br>in the Alto emulator.  SoftGO is available only when NoOverlays is false<br>(i.e., it is available in release systems but not in debugging systems).<br>Note that no other entry points to the microcode will work when NoOverlays<br>is true because PageCount is invalid.<br>%<br><br>KGOP2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; LoA[Add[InitBase,0]], GoTo[.+3];<br>EGO:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; LoA[Add[InitBase,4]], Skip;<br>KGO:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; LoA[Add[InitBase,6]], At[InitBase,3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; (xBuf) or (HiA[InitBase,BootTask]);<br>XNotify:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; xBuf, GoTo[iniRET];<br>*BootTask .le. 3, so it can address all emulator RM registers except<br>*RM 0 to 17b, but SetTask here checks against illegal RM refs.<br>SetTask[BootTask];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BootType &larr; T, At[InitBase,6];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (BootType) xnor (200C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Must modify T so next boot not same<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (BootType) xnor (1C), Skip[ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Par 2 boot on "0" key<br>KGOP2x:</span><span class="tab" val="67"></span><span style="font: 10pt serif">  BootType &larr; 200C, GoTo[Start], At[InitBase,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*KGO on partition 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BootType &larr; T &larr; 0C, GoTo[Start,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ether boot on BS key<br>EGOx:</span><span class="tab" val="67"></span><span style="font: 10pt serif">  BootType &larr; 100000C, GoTo[Start], At[InitBase,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ether boot<br><br>:UNLESS[NoOverlays]; ***************************<br>SoftGO:</span><span class="tab" val="67"></span><span style="font: 10pt serif">BootType &larr; 1C, GoTo[Start], At[InitBase,2];<br>:ENDIF; ****************************************<br><br>*Boot failures halt and wait for reboot.<br>InitFail:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[iPNIP];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[.];<br><br>SetTask[0];<br><br>*Begin here as any task.  Quiesce tasks 15 to 1 by notifying each one at Qx,<br>*which clears device register 0 and notifies the next task until ctask is 0.<br>*All devices are supposed to be disabled by outputting 0 to register 0, but<br>*the EtherNet controller has a bug requiring an extra output, which is done<br>*first below for all tasks.<br><br>Start:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; IP[xBuf]C, At[InitBase,5];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; xBuf;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; HiA[Qloc,15];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) or (LoA[Qloc]);<br>QNotify:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; 0C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; 300C;<br>*Output a 300 to device 0 for this task (in case this is the ethernet task);<br>*then output a 0 to device 0; finally point task&rsquo;s TPC at BadWakeup.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[Stack,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[Stack,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; Stack;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPageExternal[InitPage], Return;<br><br>*Start and QNext notify here.<br>Qx:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[Stack,0,4], CallP[QNext], At[Qloc];<br>*BadWakeup on non-overlay page to remain intact after init ucode is<br>*overwritten.  Wakeup from a device that isn&rsquo;t reset properly comes here.<br>BadWakeup:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.];<br><br>OnPage[InitPage];<br><br>QNext:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) - (10000C), GoTo[QNotify,ALU#0];<br>*Now do notify for timer initialization.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; LoA[TimerInitLoc];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; (xBuf) or (HiA[TimerInitLoc,TTask]), Call[XNotify];<br>*Return here in task 0 after timer task blocks.<br><br>:IF[NoOverlays]; *******************************<br><br>*Test the map as a memory, then determine the amount of real storage and<br>*set up the first N map entries to point to this storage (initialize<br>*remaining map entries to VACANT), then clear storage.<br><br>iMap:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CompFlag &larr; (Zero) - 1;<br>*CompFlag is originally -1, so iRWMap tests map entries with LogSE=WP=0,<br>*Dirty=Ref=1, and complement of address; then CompFlag is 0 to test with<br>*these bits complemented.<br>imCompx:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MapAddr &larr; T &larr; 140000C;<br>imAloop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (CompFlag) xor T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; T, Call[iRWMap];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; xBuf on Return from iRWMap<br>*RealPage &larr; max real page + 1 for later; this second map write reads back<br>*what was written with the first map write.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RealPage &larr; 10000C, Call[iRWMap];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PageCount &larr; IP[FFault]C, Call[imCheckMap];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Crash if data bad<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; CompFlag, GoTo[imAloop,Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CompFlag &larr; Zero, GoTo[imCompx,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; PageCount, PageCount &larr; T, NoRegILockOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MapAddr &larr; 140000C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*carries beyond max VM cause ALUCY<br><br>*At this point the map has been tested somewhat with each bit correctly<br>*assuming both its 1 and 0 states.  Next, write each map entry with 0 flags<br>*and the corresponding real page number, and fill first 5 quadwords of each<br>*real page with their page numbers and complements and some constants<br>*selected to make all the check bits 1 and 0.  Go through storage backwards<br>*so that hole in 96k modules will not screw up non-hole banks.<br>imFloop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RealPage &larr; T &larr; (RealPage) - 1, Call[imFloop1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[BlockSet];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*fills iniBf with T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[ZWord,iniBf0,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*store page number<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Zero) xnor T, Call[BlockSet];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[ZWord,iniBf0,4], Call[ZBlockSet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Store page no. complement<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf0 &larr; 100000C, Call[iniRET];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Wait for ZWord write<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[ZWord,iniBf0,10], Call[ZBlockSet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Store 100000,0,0,0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf1 &larr; 1C, Call[iniRET];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Wait for ZWord1 write<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[ZWord,iniBf0,14], Call[ZBlockSet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Store 0,1,0,0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf2 &larr; 40000C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 20C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[ZWord,iniBf0], GoTo[imFloop];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Store 0,0,40000,0<br><br>imFloop1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; T, Skip[ALU&gt;=0];<br>***Patch this mi and one indicated below to allow imperfect storage.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; RealPage &larr; 170000C, GoTo[imTloop];<br>*SUBROUTINE iRWMap writes the data in xBuf into map location MapAddr<br>*and returns xBuf in T, map entry in xBuf1 to xBuf3.<br>iRWMap:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (MapAddr) and (37400C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ZWordhi &larr; T, LoadPage[17];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LSh[MapAddr,10], GoToP[.+1];<br>OnPage[17];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ZWord &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XMap[ZWord,xBuf,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; T &larr; xBuf, Return; *interlock<br>OnPage[InitPage];<br><br>*Sweep upward through storage and map and use any real pages discovered.<br>*Set up base register, set map entry, LogSE on (FFAULT[0] &larr; 1).  This informs<br>*the fault handler that the test program is willing to take the fault; the<br>*fault handler RETURNs rather than sending control to Midas.<br>imTloop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RealPage) and not (70000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; T, Call[iRWMap];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) or (ReturnOnSE), Call[iChkPg];<br><br>*Return here on fault, or when iChkPage detects a problem.<br>imPageBad:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RealPage &larr; (RealPage) + 1;<br>***Patch this mi and one indicated above to allow imperfect storage.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) and not (ReturnOnSE), GoTo[imTloop,Carry&rsquo;];<br>*Fall through here after handling the maximum amount of real storage<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br>*This loop marks that portion of the map with no corresponding storage vacant.<br>imMarkVacant:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; 60000C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[iRWMap];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MapAddr &larr; (MapAddr) + 1;<br>*Loop over all map entries<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LHMask[PageCount], GoTo[imMarkVacant,Carry&rsquo;];<br><br>*Zap all storage by filling with zeroes; initialize ZWord/ZWordhi to point<br>*one larger than the largest legal address.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ZWordhi &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LSh[PageCount,10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ZWord &larr; T, Call[ZBlockSet];<br>*Loop zeroing all storage<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ZWord &larr; (ZWord) - (4C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NotEnoughMemory, Skip[Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PStore4[ZWord,iniBf0,0], Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ZWordhi &larr; (ZWordhi) - (400C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (PageCount) - (MinPageCount), Skip[ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PStore4[ZWord,iniBf0,0], Return;<br>*Must copy PageCount into xPageCount for normal use and into StoragePages for<br>*backward compatibility.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; Sub[IP[StoragePages],1]C, GoTo[InitFail,ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PageCount, GoTo[RegInit0];<br><br>iChkPg:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[ZWord,iniBf0,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fetch will cause fault if page bad<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[RealPage,4,14];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*page address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (iniBf0) xor T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[ZWord,iniBf0,4], Skip[ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LU &larr; iniBf0, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*page number didn&rsquo;t compare<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (iniBf0) xnor T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*check page complement<br>*fetch from other 3 quadwords to provoke a fault<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[ZWord,iniBf0,10], Skip[ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LU &larr; iniBf0, Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[ZWord,iniBf0,14];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 20C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[ZWord,iniBf0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; iniBf0;<br>*Page is good. <br>***Remove the xBuf &larr; to enable single-error logging***<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; (xBuf) and not (100000C), Call[iRWMap]; *turn off LogSE<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MapAddr &larr; (MapAddr) + 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*go to the next map location<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PageCount &larr; (PageCount) + 1, GoTo[imPageBad];<br><br>*SUBROUTINE imCheckMap compares (MapAddr xor CompFlag) against xBuf<br>imCheckMap:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LSh[xBuf3,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*flags, card, blk.0 bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RHMask[xBuf1]) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (MapAddr) xor T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (CompFlag) xnor T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*note, Map data is complemented, so we xnor<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UseCTask, Skip[ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; BadMap, GoTo[InitFail]; *Some map entry was bad<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MapAddr &larr; T &larr; (MapAddr) + 1, Return;<br><br>RegInit0:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; RTemp, Call[IniSp1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; Sub[IP[xPageCount],1]C, Call[IniTS];<br><br>:ELSE; *****************************************<br><br>*Copy xPageCount (setup by Initial) into PageCount for use here and into<br>*StoragePages for backward compatibility with Lisp and Smalltalk.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PageCount &larr; IP[StoragePages]C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; PageCount;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PageCount &larr; IP[xPageCount]C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; PageCount, PageCount &larr; T, NoRegILockOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BootType, GoTo[HardContinueInit,R Even];<br>*Prepare to preserve the disk partition when disk initialization is called.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[XMiscPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; 0C, Call[MXPar];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Return default partition (1 or 2)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BootType &larr; T;<br>*Set bit 8 if partition 2; bit 15 indicates soft boot (garbage in bit 9 if<br>*partition 1 is don&rsquo;t care).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BootType &larr; (LSh[BootType,6]) + 1;<br>*Continue refresh from its state at the end of LoadRAM.<br>HardContinueInit:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (xfTemp1) and not (17C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xfTemp1 &larr; IP[Refr]C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; xfTemp1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xfTemp1 &larr; 1C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Setup LoadRAM arg for normal tasking.<br><br>*Memory initialization was completed by Initial.<br>*Wait for user to view MP left by Initial.<br>*Outer loop repeats 24k times, so wait is 24k * 123 cycles ~ 0.302 sec<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; 20000C, Call[MPWait];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; (xBuf) + 1, GoTo[MPWait,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (PageCount) - (MinPageCount);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[RegInit1,ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; NotEnoughMemory, GoTo[InitFail];<br><br>:ENDIF; ****************************************<br><br>*Here after devices are quiescent, RM is zeroed, timer task initialized, and<br>*(debugging system only) map and storage are initialized.  Initialize RM<br>*constants and start 256 us clock update.<br><br>RegInit1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllOnes &larr; (Zero) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R400 &larr; 400C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MDShi &larr; T &larr; 0C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MDS &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*MDS = RZero<br>**High Base registers = MDShi and common to both Alto and Mesa emulators are<br>**initialized here.<br>*TimerBasehi must be initialized before initializing RConstantHi/Lo.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; Sub[IP[TimerBasehi],1]C, Call[IniTS];<br><br>:IF[With3MB];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; Add[LShift[eiTask,4],6]C, Call[IniTS];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*eMDS600hi<br>:ENDIF;<br><br>:IF[WithColor];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; Add[LShift[cdcTask,4],12]C, Call[IniTS];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*cdcMDS400hi<br>:ENDIF;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; Add[LShift[And[DpTask,14],4],76]C, Call[IniTS];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*vMDShi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-2 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*vMDS420hi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-2 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*vMDS177000hi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; Add[LShift[rdcTask,4],16]C, Call[IniTS];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*rdcDCBhi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-2 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*rdcMDS520hi<br>%Timer.Mc zeroed RConstantHi/Lo earlier, so RTCLow wouldn&rsquo;t overflow and cause<br>a memory reference of VM 430 during storage init.  Now initialize to values<br>correct for a 40 mhz processor clock.  RConstantLo, RConstantHi, and<br>StoragePages are known to be in consecutive RM locations.  Processor clock<br>values for 2560 cycles timer:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">40 mhz</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">656,,012172b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">44.5 mhz</span><span class="tab" val="67"></span><span style="font: 10pt serif">602,,113274b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">50 mhz</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">530,,005330b<br>DisplayInit will change the 40 mhz value if the processor clock is 44.5 or 50<br>mhz, but we initialize here in case there is no attached display.<br>%<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; Sub[IP[RConstantLo],1]C, Call[IniTS];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; LoA[012172];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) or (HiA[012172]);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) + (LoA[656]), Call[IniSp1];<br>*StoragePages (RM 326) for the Lisp emulator and Alto MEMCFG opcode.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PageCount, Call[IniSp1];<br>DeviceInit:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; StartDeviceInit, CallP[iPNIP];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*MP code = 104d<br>:UNLESS[NoOverlays]; ***************************<br>*Wait ~.31 sec for user to view StartDeviceInit, indicating that Initial is<br>*complete and that this microcode has commenced.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; 20000C, Call[MPWait];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; (xBuf) + 1, Skip[R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  GoTo[MPWait];<br>:ENDIF; ****************************************<br><br>%RM 40-57 are a "slot table" with one entry per potential io controller.<br>First, the table is filled with dummy task numbers which are clocked out to<br>the controllers.  Then, each task is interrogated for it&rsquo;s Device ID, and<br>these names are put in the table.  Next, for each slot, the device ID is<br>looked up in the DTab table (in IM) of potential devices, and if a match is<br>found, the DTab entry is put into the slot table.  When all slots have been<br>looked up, the task numbers are clocked out to the controllers, and the<br>associated initialization routines are called in turn.<br>%<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; 57C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; T &larr; (StkP &larr; xCNT) + 1, Call[.+1];<br>*StkP = 57b, xCNT = T = 60b here; write 60-77 into RM 40-57 (StkP counts<br>*mod 20b, so StkP+1 when StkP .eq. 57 is 40b).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (xCNT) xor (77C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T, Skip[ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  xCNT &larr; T &larr; (xCNT) + 1, Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Assigned &larr; 0C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Bit mask of assigned tasks<br>*Send dummy controller addresses to devices; wind up with (n lsh 14b) + 3 in<br>*RM (40b+n).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; 57C, Call[ClockOutPattern]; <br>*StkP = 57b here; read controller ID&rsquo;s from register 0 of all devices<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; T &larr; 177400C, Call[iniRET];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*allow xCNT & T to be written<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[Stack];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; T &larr; (xCNT) + (20C), Skip[R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  DMA &larr; 400C, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Advance to next device; init DMA for later<br>*StkP is now back at 40b since it wraps around the last time it was bumped.<br>*Have 3000b, 3400b, 1055b, 1417b, etc. followed by 177777b for all undefined<br>*slots.<br><br>*Look up each slot table entry in the device table<br>*Scan devices nearest the CPU first<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; 17C;<br>DI4x:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DevIndex &larr; HiA[DTabBase];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*base of device table in IM<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DevIndex &larr; (DevIndex) or (LoA[DTabBase]);<br>DI4y:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 0C, Call[GetCon];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*get device ID from table<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (LHMask[Stack]) xor T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*compare to high 8 bits of slot table entry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; T, GoTo[DevFound,ALU=0];<br>*check for end of table (zero entry)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DevIndex &larr; (DevIndex) + 1, GoTo[DI4y,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; 17C; *end of table reached without match - set slot&rsquo;s task to 17 (unused)  <br>DI4z:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; (xCNT) - 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*check for all slots processed<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1, DblGoTo[DI4x,DI5,ALU&gt;=0]; *set to next slot<br><br>DevFound:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; (DMA) or (200C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 1C, Call[GetCon];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RBuf1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RBuf1 &larr; LSh[RBuf1,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*10:13b &larr; task number about to be assigned<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CycleControl &larr; RBuf1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; WFA[AllOnes];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Assigned) and T;<br>*Replace slot table entry with device table entry if task available, else<br>*keep looking if task already assigned.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Assigned &larr; (Assigned) or T, Skip[ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  DevIndex &larr; (DevIndex) + 1, GoTo[DI4y];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CSData;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; T, GoTo[DI4z];<br><br>*Have 6, 174427b, 174172b, 174070b, and 17b to end of table here<br>DI5:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; 57C, Call[ClockOutPattern];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Clock out new controller ID&rsquo;s<br><br>%Here the table has task and uPC for existing controllers and 170000b for<br>non-existent or undefined controllers.  NOTE: StkP is 57b, so entries are<br>handled in the order 57, 56, ..., 41.  Since DisplayInit may jump to LoadRAM,<br>**OLD LOADRAM**<br>RTemp1 (53) must be even and xBuf-xBuf3 and RTemp (44-47 and 52) will be<br>smashed, so the display controller must be in chasis slots 0 to 3 or LoadRAM<br>will smash table entries not yet handled, and there must be fewer than 13b<br>controllers mounted or RTemp1 might not be even.<br>**NEW LOADRAM**<br>RTemp1 (53) must be even and yBuf-yBuf2 (50-52) will be smashed,  so the<br>display controller must be in chasis slots 0 to 7, and there must be fewer<br>than 13b controllers mounted or RTemp1 might not be even.<br>%<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 17C;<br>*DpTask transfers to task 0 to roll in or pass over the CSL monitor overlay.<br>*It continues initialization by transferring to DI6 with xCNT in T rather<br>*than by simply returning as other device initialization routines do.<br>DI6:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; T, Call[.+1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Setup TPC for loop below<br>*Loop here to call all the init routines<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; xCNT &larr; (xCNT) - 1, Skip[R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ErrorCnt &larr; 10C, GoTo[BootEmulators];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Set up retry count<br>*Unless InitPC = 0 (no init required), call device init routine and loop<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; LdF[(Stack),4,14];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; Stack&-1, Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  MNBR &larr; BootType;<br>iniRET:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br><br>IniTS:</span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; RTemp;<br>IniSp1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T, Return;<br><br>ZBlockSet:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf0 &larr; T &larr; 0C, Skip;<br>BlockSet:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf0 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf2 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf3 &larr; T, GoTo[iniRET];<br><br>iPNIP:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[PNIPPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoToP[PNIP];<br><br>*Delay subroutine executes 121d (= 7+2*(56+1)) cycles before returning.<br>MPWait:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf1 &larr; 70C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf1 &larr; (xBuf1) - 1, GoTo[.,R&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Execute this mi 70b+2 times<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br><br>ClockOutPattern:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Call with 57C in xCNT<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; xCNT;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; 17C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*go through the slot table backwards<br>COP1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DevIndex &larr; 3C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*DevIndex used for loop count<br>COP2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Stack) xor (1C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*complement bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DevIndex &larr; (DevIndex) - 1, GenSRClock;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*send bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; RCy[Stack,1], GoTo[COP2,ALU&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*get next bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xCNT &larr; (xCNT) - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*all slot table entries done?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1, GoTo[COP1,ALU&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*get next word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMAhi &larr; 0C, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*DMAhi &larr; 0 for EtherBoot and DiskBoot<br><br>GetCon:</span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; DevIndex;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ReadCS;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CSData, Return, DispTable[1,1,0]; *Must be even placement<br><br>:IF[NoOverlays]; *******************************<br>BootEmulators:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BootType, T &larr; StartEtherBoot, NoRegILockOK, GoTo[DiskBoot,R&gt;=0];<br>:ELSE; *****************************************<br>BootEmulators:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BootType, GoTo[Booted,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BootType, T &larr; StartEtherBoot, NoRegILockOK, GoTo[DiskBoot,R&gt;=0];<br>:ENDIF; ****************************************<br><br>*Setup here is VM 604 &larr; 400, VM 605 &larr; 1, VM 610 &larr; 377, VM 600 &larr; 0;<br>*then start the Ethernet controller and wait for VM 600 # 0.<br>*DMAhi,,DMA were setup as 0,,600 earlier for this code.<br>EtherBoot:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf1 &larr; 1C, Call[iPNIP];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*114d MP code<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; 400C;<br><br>:IF[With3MB];<br>EtherBootx:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore2[DMA,xBuf,4], Task;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*VM 604 = eiCLoc &larr; 400, eiBLoc &larr; 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf2 &larr; 377C;<br>*ESLOC &larr; 377 (serial no. for breath-of-life packets)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[DMA,xBuf2,10], Call[iniRET];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[DMA,RZero,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*ePLoc &larr; 0 (status word)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp</span><span style="font: 8pt serif"> &larr; </span><span style="font: 10pt serif">LoA[</span><span style="font: 8pt serif">eiStartLoc], </span><span style="font: 10pt serif">Call[eStartRead];<br>*Here (in task 0) after Ether has started and tasked<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (DMA) + (2C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[DMA,AC1,0], Call[iniRET];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; AC1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (AC1)  xor (377C), GoTo[.-3,ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Wait for packet<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,AC2,2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC2 &larr; (AC2) - T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC2 &larr; (AC2) - (Breath-of-life)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; cEtherBoot, GoTo[EtherBootx,ALU#0];<br>*got the breath of life!!!! start Alto emulator with PC=5 and complement<br>*of KB1 word in AC0 (=10b for NetExec, =100b for MesaNetExec);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; 5C;<br>:ELSE;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">goto[.];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Shouldn&rsquo;t happen<br>:ENDIF;<br><br>:IF[NoOverlays]; *******************************<br>Booted:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PageCount, Call[iPNIP];<br>:ELSE; *****************************************<br>Booted:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; GotBreathOfLife, Call[iPNIP];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*118d MP code<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; 20000C, Call[MPWait];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Delay .31 sec<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; (xBuf) + 1, Skip[R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  GoTo[MPWait];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PageCount, Call[iPNIP];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*No. of good pages in MP<br>:ENDIF; ****************************************<br>:IF[FinalOverlay]; *****************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPageExternal[LRJPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; 0C, GoToExternal[LRJContinue];<br>:ELSE; *****************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[neStartPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoToP[StartNova];<br>:ENDIF; ****************************************<br></span><span style="font: 8pt serif"><br></span><span style="font: 10pt serif"><br>:IF[With3MB];<br></span><span style="font: 8pt serif">EStartRead:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp</span><span style="font: 8pt serif"> &larr; (</span><span style="font: 10pt serif">RTemp) or (HiA[eiStartLoc,eiTask]</span><span style="font: 8pt serif">);<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">LoadPage[eePage];<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RTemp1 &larr; 300C, </span><span style="font: 10pt serif">GoTo</span><span style="font: 8pt serif">[eIOReset];</span><span class="tab" val="67"></span><span style="font: 8pt serif">*Disable EtherNet input/output<br></span><span style="font: 10pt serif">:ENDIF;<br><br><br>DiskBoot:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; StartDiskBoot;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; 1000C, Call[iPNIP];<br>*Read disk Sector 0 into page 0 (starting at location 1).<br>DiskBootx:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ErrorCountx &larr; 20C, Call[ZBlockSet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*word 520 - not used by disk<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*word 521 - IOCB pointer<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*word 522 - disk status<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*word 523 = -1 to force a seek<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) or (120C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[MDS,iniBf0], Call[iniRET]; *520-523 &larr; 0,0,0,0<br><br>*Set up the IOCB at 1000b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf2 &larr; 44000C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*disk command goes at location 1002 (read, read, read)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf3 &larr; 2000C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*header goes at 2000 (unlike ALTO)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[DMA,iniBf0,0], Call[iniRET]; *1000-1003 &larr; 0,0,44000,2000<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf2 &larr; 400C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf2 &larr; (iniBf2) + (2C); *label goes at 402<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf3 &larr; 1C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*data goes at 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore2[DMA,iniBf2,4], Call[iniRET]; *1004-1005 &larr; 402,1<br><br>*Since we will initialize the interrupt system later, we do not need to worry<br>*about 1006 or 1007; 1008 is unused<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[DMA,iniBf3,11];<br>*iniBf1 = 1.. Disk address 0, with RESTORE bit at 1009<br>*Start the disk<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf1 &larr; 1000C, Call[iniRET];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*word 521 - IOCB pointer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">iniBf2 &larr; 0C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) + (120C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[MDS,iniBf0], Call[iniRET]; *520-523 &larr; 0,1000,0,1<br>*Wait for the disk to store good status in the DCB, retry if status is bad<br>DWSet:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DevIndex &larr; 40000C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*loop count for status wait<br>DiskWait:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[DMA,xCNT,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*fetch status word at 1001b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 17C, Call[iniRET];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (LdF[xCNT,4,4]) xor T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; LdF[xCNT,10,10], GoTo[StatusStored,ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DevIndex &larr; (DevIndex) - 1, GoTo[DiskWait,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ErrorCountx &larr; (ErrorCountx) - 1, GoTo[DWSet,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NoDiskStatus, GoTo[InitFail];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*timed out waiting for disk to store status<br><br>StatusStored:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ErrorCnt &larr; (ErrorCnt) - 1, Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCB &larr; 1C, GoTo[Booted];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Good status--send control to VM 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BadBoot, Skip[ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  GoTo[DiskBootx];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[InitFail];<br><br>%PNIP displays the number in T in the maintenance panel and returns,<br>where T is meaningfully in the range 0 to 9999d (0 to 23417b).<br>Does not task unless called from task 0.  Its registers (RTemp and RTemp1)<br>should not conflict with those for the Midas Kernel or with any used by<br>tasks 14 to 17 because of calls from Fault.Mc, which might subsequently<br>go to Midas; any io task that calls PNIP and expects to continue should be<br>wary of the fact that PNIP&rsquo;s registers are defined for task 0 and might<br>conflict.<br><br>The loop below uses the top bits of RTemp to space successive IncMPanel&rsquo;s.<br>**ClearMPanel and IncMPanel may be illegal in the same mi with branch burp.<br>**For large numbers, map/storage refresh may fail when called by an io task.<br><br>Timing: 16*T + 20 cycles.<br>%<br>OnPage[PNIPPage];<br><br>PNIP:</span><span class="tab" val="67"></span><span style="font: 10pt serif">UseCTask, RTemp &larr; T, at[PNIPLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">********** absolutely placed<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; APCTask&APC, ClearMPanel, Call[.+1];<br>PNIPl:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) + (40000C), GoTo[.,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (LdF[RTemp,2,16]) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; T, Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  APCTask&APC &larr; RTemp1, GoTo[PFExit];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; LdF[RTemp1,0,4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Skip[ALU=0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skip if emulator (tasking allowed)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  IncMPanel, GoTo[PNIPl];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*else non-skip (no tasking)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IncMPanel, Return;<br><br><br>%DoInt ORs bits from T into NWW and sets IntPending.  Uses registers 0 and 1<br>in whatever task calls.  DoIntR is the same, but with the bits from register<br>0 rather than T.<br>%<br>RV[IntTemp1,0];<br>RV[IntTemp2,1];<br><br>DoInt:</span><span class="tab" val="67"></span><span style="font: 10pt serif">IntTemp1 &larr; T, At[DoIntLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Abs placement for CSLKeyboard overlay<br>DoIntR:</span><span class="tab" val="67"></span><span style="font: 10pt serif">IntTemp2 &larr; IP[NWW]C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (SStkP&NStkP) xor (377C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; IntTemp2, IntTemp2 &larr; T, NoRegILockOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (IntTemp1) and not (100000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) or T, Skip[ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*set bits in NWW<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  StkP &larr; IntTemp2, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Restore StkP and return<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IntTemp1 &larr; IP[RSImage]C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; IntTemp1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; (Stack) or (IntPendingBit);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Set IntPending<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; StkP &larr; IntTemp2, RS232 &larr; T, Return;<br><br>:END[Initialize];</span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
