<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>Timer.Mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 6pt; text-align: left">
<span style="font: 10pt serif">:TITLE[Timer];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Last edited: 15 October 1981 by Fiala<br><br>* Placed MXRclk, added With10MB switch to table July 6, 1982  2:27 PM<br><br>%Occurrences of LoadTimer and AddToTimer must be separated by 7 mi, and branch<br>conditions are illegal with LoadToTimer and AddToTimer.  Here the 7 mi<br>requirement is fulfilled with 3 mi before LoadTimer/AddToTimer and 4 mi after.<br>OTHER MODULES MUST GUARANTEE 3 MI FROM WAKEUP TO LOADTIMER/ADDTOTIMER AND 4 MI<br>AFTER LOADTIMER/ADDTOTIMER BEFORE TASKING TO BE CONSISTENT.<br><br>In LoadTimer/AddToTimer, 0:3 are the new state, 4:11 new data, and 12:15<br>are the slot number.<br><br>Refresh must cycle fast enough to maintain storage.  16k RAMs are configured<br>as 128 rows x 128 columns; one Dolphin refresh reference refreshes four rows,<br>so 32 references are required per cycle; 64k RAMs are configured as 256 x 256<br>and would require 64 references per cycle.  Both 16k and 64k RAMs specify a<br>2 ms cycle at maximum operating temperature (80 deg C).<br><br>The primary leakage phenomenon necessitating refresh is exponential in<br>temperature, about exp(-44*(300/T)), so required refresh rate goes up by a<br>factor of 2 for every increase of 5 degrees C.  Refresh at a 2 ms period<br>is undesirable because about 4 percent of all cycles would be consumed by<br>the refresh timer; code below presently implements an 8 ms period, which<br>gives up about 10 degrees in temperature margin, possibly requiring some<br>marginal RAMs to be replaced, but the manufacturer&rsquo;s specification is<br>believed very conservative and we do not intend to operate anywhere near the<br>maximum operating temperature.  Parameters for other periods are given in the<br>table below.<br><br>Initialization must be particularly careful about refresh.  Initial uses a<br>640 cycle timer with the Refr register as a state variable for a period of<br>2 ms.  After putting AMesa and its overlays in storage, Initial exits with<br>LoadRAM.  During LoadRAM, inline refresh is done once every 8 mi (i.e.,<br>slightly faster than the 640 cycle timer), but xfTemp1 is used as the Refresh<br>base register, so an unrefreshed period of almost 4 ms might be experienced<br>by some RAMs, if xfTemp1 and Refr are maximally out of sync--however, this<br>is still less than the 8 ms refresh period used by AMesa.  AMesa immediately<br>starts a 2560 cycle refresh timer with Refr as the state variable;<br>Initialize.Mc sets Refr to the value in xfTemp1 immediately after this code<br>returns, so there is no significant refresh hickup between the end of<br>Initial&rsquo;s LoadRAM and AMesa&rsquo;s normal refresh.  LoadRAM calls during AMesa<br>init always allow normal refresh to avoid discontinuities in the refresh<br>cycle.  However, HRam init in DisplayInit.Mc goes about 7500 cycles without<br>tasking.<br><br>When a timer wakeup is deferred too long, wakeup and AddToTimer don&rsquo;t work<br>properly.  If a timer is able to occupy the wakeup slot, then, no matter how<br>long tasking is deferred, wakeup will happen as soon as tasking occurs.<br>However, if some other timer occupies the slot, then 8192 cycles after it<br>expired, the timer&rsquo;s data field will become positive and cease requesting a<br>wakeup--8192 cycles after that it will go negative again, etc.  So any<br>deferral of 8193 to 16384 cycles will delay wakeup at least 16384 cycles.<br>Even if an expiring timer immediately occupies the wakeup slot, AddToTimer<br>may leave the data field with an 8192 cycle wait for next time, if tasking<br>is defferred too long.<br><br>Slot 17b is used for refresh and realtime clock update.  The clock constant<br>should produce carries out of RTCLow at the rate expected by the Alto clock<br>software.  Since the 26d-bit Alto RTClock ticks every 38.09524 us, the<br>constant added each tick for a N-us clock should be N/38.09524; since this is<br>stored in a doubleword with 6 bits to the right of the low order RTClock bit,<br>the fraction added is (N/38.09524)*(2&uarr;6) = (4*2&uarr;6*C)/(H*38.09524) =<br>6.720000*C/H, where H is the processor clock crystal frequency in mhz and C<br>is the timer period in cycles.  Since timer periods are denominated in<br>processor cycles, microcode can control either the number of cycles between<br>timer wakeups or the constant added to the simulated RTClock each tick.<br><br>The table below shows values for 40 mhz (100 ns cycle), 44.5 mhz (89.886 ns<br>cycle), and 50 mhz (80 ns cycle) main system clocks.  Note that clock periods<br>larger than 5120 cyc require a double timer.  Equivalent constants for the<br>three frequencies using a 640 cycle timer are [4300.8/H] 107.52 (40 mhz),<br>96.6472d (44.5 mhz), and 86.0106d (50 mhz).<br><br>40 mhz<br>Refresh</span><span class="tab" val="67"></span><span style="font: 10pt serif"> Timer</span><span class="tab" val="67"></span><span style="font: 10pt serif">  RTimer      40 mhz</span><span class="tab" val="67"></span><span style="font: 10pt serif">       44.5 mhz</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">50 mhz<br>Period</span><span class="tab" val="67"></span><span style="font: 10pt serif"> Period</span><span class="tab" val="67"></span><span style="font: 10pt serif">  Value   RConstantHi/Lo   RConstantHi/Lo   RConstantHi/Lo<br> 2 ms</span><span class="tab" val="67"></span><span style="font: 10pt serif"> 640 cyc  50257b   153/102436b</span><span class="tab" val="67"></span><span style="font: 10pt serif">    140/122657b</span><span class="tab" val="67"></span><span style="font: 10pt serif">     126/001266b<br> 4 ms</span><span class="tab" val="67"></span><span style="font: 10pt serif">1280 cyc  50517b   327/005075b</span><span class="tab" val="67"></span><span style="font: 10pt serif">    301/045536b</span><span class="tab" val="67"></span><span style="font: 10pt serif">     254/002554b<br> 8 ms</span><span class="tab" val="67"></span><span style="font: 10pt serif">2560 cyc  51217b   656/012172b</span><span class="tab" val="67"></span><span style="font: 10pt serif">    602/113274b</span><span class="tab" val="67"></span><span style="font: 10pt serif">     530/005330b<br>16 ms</span><span class="tab" val="67"></span><span style="font: 10pt serif">5120 cyc  52417b  1534/024363b     1405/026570b</span><span class="tab" val="67"></span><span style="font: 10pt serif">    1260/012660b<br>%<br><br>SetTask[0];<br><br>OnPage[XMiscPage];<br><br>*Common subroutine for Mesa/Alto ReadClock.  Takes 430b in T, returns<br>*(VM 430) in RTemp, RTCLow in T and RTemp1.<br>MXRClk:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], at[mxRClkLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">****** placed for Lisp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; IP[RTCLow]C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (SStkP&NStkP) xor (377C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; RTemp1, RTemp1 &larr; T, NoRegILockOK;<br>***It is probably better not to zero the bits here.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Stack) and not (77C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Return Most Significant 10d bits<br>RestSP:</span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; RTemp1, RTemp1 &larr; T, NoRegILockOK, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Restore StkP<br><br>SetTask[TTask];<br><br>*Initialize Notifies here to set up timers (this is throwaway code)<br>InitTimers:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TimerTemp &larr; 100000C, At[TimerInitLoc];<br>ClrTimers:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TimerTemp &larr; (LoadTimer[TimerTemp]) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RSImage &larr; T &larr; 0C;<br>*Zero RConstant now preventing storage update; RConstant will be corrected to<br>*a value appropriate for 40 mhz processor clock by Initialize after storage<br>*init.  DisplayInit (if there is a UTVFC board and CSLOverlay=1) will<br>*determine the determine the processor clock crystal frequency and setup<br>*RConstantLo/Hi to a value appropriate for 40, 44.5, or 50 mhz crystals.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RConstantLo &larr; T, ResetMemErrs;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Clear any pending memory errors<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RConstantHi &larr; RS232 &larr; T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Zap RS232<br>***This mi isn&rsquo;t doing anything useful.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Refr &larr; (Refr) and not (17C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fixup refresh pointer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TimerBase &larr; HiA[430];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Partly init TOD base reg.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Timer;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Clear pending wakeup.<br>*Single precision clock error is about .00019 or 16.2 sec/day for this 40 mhz<br>*value; that&rsquo;s why we use double precision.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTimer &larr; HiA[51217];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Set up the Refresh time<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (TimerTemp) and (17C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*clear 20b timers<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTimer &larr; (RTimer) or (LoA[51217]), GoTo[ClrTimers,ALU#0];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Timer, LoadPage[TimerPage];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*read to clear pending wakeups<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadTimer[RTimer], GoToP[TimerSetTPC];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*load refresh timer<br><br>OnPage[TimerPage];<br><br>TimerSetTPC:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TimerBase &larr; (TimerBase) or (LoA[430]), Call[TimerRet];<br>TimerWakeup:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Timer wakeups come here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[Timer,14,4];<br>*Since Refresh timer has the greatest effect on performance, do something<br>*useful for it in this mi.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RConstantLo, Disp[.+1];<br>*Timer dispatch table for task 16.  Unused table entries are overwritten<br>*by MicOverlay.  NOTE: LoadPage cannot be used in TimerTable because this<br>*is the 3rd mi after wakeup, and a page fault might happen.  Code in<br>*MicOverlay overwrites the unused TimerTable entries.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Refresh[Refr], GoTo[RefreshNext], At[TimerTable,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*slot 17<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*16 (Jasmine scan start)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*15 (fast stage of scan start)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*14 (Jasmine ScanCB)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*13 (Jasmine PixelTimer)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,5];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*12<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,6];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*11<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,7];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*10<br></span><span style="font: 12pt serif">:IF[With10MB]; ***************************************<br></span><span style="font: 10pt serif">IFE[</span><span style="font: 12pt serif">enxTask</span><span style="font: 10pt serif">,7,,ER[Fixup.needed.for.TimerTable.enxTask]];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">APCTask&APC &larr; enxNotify, GoTo[TimerRet], At[TimerTable,</span><span style="font: 10pt serif">10</span><span style="font: 12pt serif">];<br></span><span style="font: 10pt serif">:ELSE;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*7<br></span><span style="font: 12pt serif">:ENDIF; **********************************************<br>:IF[With3MB]; ***************************************<br></span><span style="font: 10pt serif">*Ethernet Output Notify slot (Add copies with EOTask1, EOTask2 ... if<br>*multiple controllers).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TimerTemp &larr; </span><span style="font: 8pt serif">HiA[EOTimerDoneLoc,EOTask]</span><span style="font: 10pt serif">, GoTo[TEONotify], At[TimerTable,11]; *6<br>:ELSE;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,11];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*6<br></span><span style="font: 12pt serif">:ENDIF; **********************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*5<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,13];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*4<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,14];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*2 (Audio)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,16];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFault, GoTo[.], At[TimerTable,17];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*0<br><br>*Reserve locations that can be overwritten by non-resident overlays which<br>*use timers (reserve TimerTable 20 and 21 here; since 22 to 25 are used,<br>*26 is the next one available if more are needed).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IMReserve[0,Add[TimerTable,20],2];<br><br></span><span style="font: 12pt serif">:IF[With3MB]; ***************************************<br></span><span style="font: 10pt serif">*Notify for Ethernet output (Only one copy required)<br>TEONotify:</span><span class="tab" val="67"></span><span style="font: 8pt serif">*Notify Ethernet output task, don&rsquo;t restart timer<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">TimerTemp &larr; (TimerTemp) or (LoA[EOTimerDoneLoc]);<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">APCTask&APC &larr; TimerTemp, GoTo[TimerRet];<br></span><span style="font: 12pt serif">:ENDIF; **********************************************<br></span><span style="font: 10pt serif"><br>*NOTE: Return must not occur sooner than 4th mi after AddToTimer.<br>RefreshNext:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AddToTimer[RTimer];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTCLowLow &larr; (RTCLowLow) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RConstantHi) + 1, UseCOutAsCIn;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTCLow &larr; (RTCLow) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Refr &larr; (Refr) + (20C), Skip[Carry];<br>TimerRet:  Return, At[TimerTable,24];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*MouseHalt+1 for proper restart.<br>*Note: MC1 is busy for 20 cycles after Refresh, so the PFetch1 below will be<br>*held; hence the MouseHalt check is free.<br>:IF[WithMidas]; *******************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (FFault) and (10000C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Midas present<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Printer) and T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*and requesting interrupt?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[TimerBase,TimerTemp,0], Skip[ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Increment VM 430<br>*Midas mouse halt is a task 16 breakpoint not set by the user.<br>*Midas continues at MouseHalt+1 (i.e., at TimerTable+24).<br>MouseHalt:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  SetFault, GoTo[.], At[TimerTable,23];<br>:ELSE; ****************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[TimerBase,TimerTemp,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Increment VM 430<br>:ENDIF; ***************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TimerTemp &larr; (TimerTemp) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[TimerBase,TimerTemp,0], GoTo[TimerRet];<br><br>:END[Timer];</span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
