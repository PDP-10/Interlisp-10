<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>Ether.Mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:TITLE[Ether];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Last edited: 15 October 1981 by Fiala<br><br>*Ethernet I/O Address Registers<br>Set[eiData,3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Input data used with Input instructions<br>Set[eimData,Add[LShift[eiTask,4],3]]; *Input data used with memory references<br><br>Set[eiHost,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Input data<br>Set[eStatus,2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Status/State register (read)<br>Set[eoData,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output data used with Output instructions<br>Set[eomData,Add[LShift[eoTask,4],1]]; *Output data used with memory references<br>Set[eState,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*State register write<br>MC[eoState,Or[LShift[eoTask,4],eState]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output control reg from emu<br>MC[eiState,Or[LShift[eiTask,4],eState]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Input control reg from output task<br><br>*State Register command words<br>MC[eSetPurgeMode,260];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Enables input<br>MC[eSetOutputEOP,107];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Enables output, Jam<br>MC[eEnableInput,220];<br>MC[eEnableOutput,103];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Enables Jam<br>MC[eDisableInput,200];<br>MC[eDisableOutput,100];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Clears OutputEOP, disables Jam<br>MC[eDisableInputOutput,300];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Disables input, output, clears OutputEOP, Jam<br><br><br>*Status bits (left byte of hardware, right byte of status as posted in memory)<br>Set[esIColl,200];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Receiver-detected collision (Jam)<br>Set[esODL,100];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output data late (Underrun)<br>Set[esIDL,40];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Input data late (Overrun)<br>Set[esOColl,20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Transmitter-detected collision (Collision)<br>MC[eCollMask,10000];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Mask for collision detection<br>Set[esCRC,10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Bad CRC<br>Set[esOFault,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output DataFault (masked for now) <br>Set[esOPar,2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output Bad Parity (masked for now) <br>Set[esICmd,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Input command issued  **Not in hardware:<br>Set[esOCmd,2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output command issued  **for Alto emulation only<br>Set[esIT,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Incorrectly terminated packet (Bad Alignment)<br><br>MC[eiSMask,esIDL,esCRC,esIT];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Status bits reported for input command<br>MC[eoSMask,esODL,esOColl];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Status bits reported for output command<br>MC[eCmdBits,esICmd,esOCmd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Command bits<br><br><br>SetTask[eoTask];<br><br>*Registers for output task<br>Set[eoRB,LShift[And[eoTask,3],4]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*enforces reg allocation conventions<br>RV[eoTemp2,Add[eoRB,0]];<br>RV[eoCount,Add[eoRB,1]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Main loop counter<br>RV2[eoPtr,eoPtrHi,Add[eoRB,2]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Buffer base register<br>RV[eoTemp1,Add[eoRB,4]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Temporary registers<br>RV[eoTemp,Add[eoRB,5]];<br><br>SetTask[eiTask];<br><br>*RM registers for input task (eoTask+1)<br>Set[eiRB,LShift[And[eiTask,3],4]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*enforces allocation conventions<br>RV[eiTemp2,Add[eiRB,0]];<br>RV[eiCount,Add[eiRB,1]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Main loop counter<br>RV2[eiPtr,eiPtrHi,Add[eiRB,2]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Buffer base register<br>RV[eiTemp1,Add[eiRB,4]];</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br>RV[eiTemp,Add[eiRB,5]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Temporary registers<br>RV2[eMDS600,eMDS600hi,Add[eiRB,6]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Base reg MDS+600 (**Known to Initialize)<br>RV[eFlag,Add[eiRB,10]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*input under output flag (reg 10 of eiTask)<br><br>*Control block addresses (for Alto emulation, relative to 600)<br>Set[ePLoc,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Post location<br>Set[eBLoc,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Interrupt bit mask<br>Set[eELoc,2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ending word count<br>Set[eLLoc,3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Load mask<br>Set[eiCLoc,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Input count<br>Set[eiPLoc,5];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Input pointer<br>Set[eoCLoc,6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output count<br>Set[eoPLoc,7];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output pointer<br>Set[eHLoc,10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Host address for address recognition<br><br>*Timer masks (slot number is eoTask)<br>MC[eTimerMask,LShift[5,14]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Use Timer State 5 for simple timer<br><br>*Microcode post codes (small integer in left half, ones in right half for XOR).<br>*Note: value is complemented to get constant less than 8 bits.  Use XNOR for formation of post code.<br>MC[esIDon,Not[377]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Input done<br>MC[esODon,Not[777]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output done<br>MC[esIFul,Not[1377]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Input buffer overflowed<br>MC[esLoad,Not[1777]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Load overflow<br>MC[esCZer,Not[2377]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Word count zero in input or output command<br>MC[esAbrt,Not[2777]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Command aborted (by SIO)<br><br><br>%Folklore (HGM 22-Oct-80):<br><br>We are emulating a half duplex device with a full duplex controller.  That<br>means that the two portions of microcode have to cooperate.  They interact<br>in 3 places:<br> 1) Output enables Input during retransmission wait if there is a buffer ready.<br> 2) Input resets eFlag when it starts reading a packet.<br> 3) Output disables Input when the timer expires.<br>Of course, reset has to clear eFlag too.<br><br>We can get a timer notify when we don&rsquo;t want one for two reasons:<br> 1) A packet arrived while we were in retransmission wait (input under output).<br> 2) We were reset (by SIO[3]) during retransmission wait.<br>In either case, we simply ignore the notify without changing our TPC.<br>Don&rsquo;t try to restructure this kludgery without some thought.  There is no<br>way to turn a timer off.  It might have expired just as you reset it,<br>and the hardware doesn&rsquo;t forget the pending wakeup request in that case.<br><br>The silly NOPs in the input microcode are because the input hardware<br>generates H4 Parity errors.  I thought I had them fixed for the Rev P<br>boards, but they still seem to squeek through occasionally.  The fault<br>handler ingores H4PEs from eiTask.  (You can set a flag if you prefer<br>to crash.)  Successful recovery requires several non-memory mi after<br>Inputs or IOStore4s for three reasons:<br>  1) In the sequence Input (IOStore4) then PFetch, the MC1 microcode does<br>a wild branch if there is an H4PE.  To avoid this 3 non-memory mi are<br>needed after an Input and 4 after an IOStore4.  Interlocking an Input<br>allows another reference to be made on the mi following the interlock<br>(?or is one more intervening mi required?; if a PStore tries to store<br>the data which just got H4PE, is that fatal?).<br>  2) An H4PE may not fault for 2 more mi--i.e., 4 mi following Input or 6<br>mi following IOStore4 may be executed before the H4PE fault commences.<br>If an H4PE occurs immediately following LoadPage, it will be impossible<br>to continue from the fault.  Thus a task switch (i.e., Return) can occur<br>no sooner that the 4th mi following an Input or the 6th mi following IOStore4<br>because the 1st mi executed by the emulator may in fact be a LoadPage.<br>  3) The fault handler requires that eiTask still be running when the H4PE<br>fault occurs because it crashes unless current task .eq. eiTask; this<br>requires 1 mi more than for (2) because the emulator may do a LoadPage as<br>the 1st mi after wakeup (?Is this accurate--depends upon when CTask is<br>updated?).<br><br>Hence, the requirement is that eiTask task following IOStore4 no sooner<br>than the 7th mi and following Input no sooner than the 5th mi.  If the<br>Input is interlocked by reading its RM register on the 1st or 2nd following<br>mi, then the mi doing the interlock counts as the 3rd mi following the Input;<br>the following mi may then be a PStore1 (?maybe need one intervening mi?);<br>tasking may occur on the 2nd mi following the interlock.<br><br>You need at least 14 cycles (~7 mi) between loads/adds to timers.<br>The only other place that loads timers is memory refresh in Timer.Mc.  There<br>are 3 mi before that load, and 4 after it before a task switch.  Thus we<br>need at least 4 between our LoadTimer and a return, and 3 before our LoadTimer.<br><br>In the Rev N (and earlier) boards, an Output to the state register could set<br>either/both portions of the flipflops.  The 200 and/or 100 bits in the output data<br>word had to be to enable any action.  This causes some confusion since<br>storing 0 into register 0 of an Ethernet didn&rsquo;t reset anything.  (That&rsquo;s why<br>there is an extra loop storing 300 in various hunks of code that are trying<br>to quiesce all devices.)<br>For Rev O, the Output must be directed to register 0 of the appropiate task.<br>(Thus there is no way for the Input task (higher priority) to disable the<br>output task.)  This code will work with either type of board because<br>1) all the constants include the 100 or 200, and 2) all the Outputs are directed<br>to the appropiate task.  There are only 3 places where this happens:<br> 1) turning on Input from the Output task to enable Input under Output,<br> 2) turning off Input from the Output task because of a reset (SIO[3]) and<br> 3) Turning off things from the Emulator via SIO[3].<br><br>This microcode does not correctly emulate some of the fine print of the Alto,<br>but that doesn&rsquo;t seem to bother any known software.  Examples I have noticed:<br> 1) SIO[1] or SIO[2] during input or output acts like an SIO[3] on the Alto.<br> 2) SIO[1] then SIO[2] leaves input running on Rev P boards.<br>  (You could hear your own packets!)<br>%<br><br>*ETHERNET INITIALIZATION subroutine (executed at eiTask) is only called if<br>*an Ethernet board is in the machine.  It overwrites the mi at eeSIO+1 with:<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Add[HostN]C, GoToExternal[eeLocB];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; host number<br>*MEMINST, RMOD, RSEL[0:3], ALUF[0:3], BSEL[0:1], F1[0:3]<br>*MC[ee015hi,0]; MC[ee015lo,0];<br>*LR, LT, F2[0:3], JC[0:2], JA[0:5], ParITY (Require And[eeLocB,377] odd par)<br>MC[ee1631hi,041000]; MC[ee1631lo,RShift[And[eeLocB,377],2]];<br>MC[ee3235,And[eeLocB,3]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSEL[4:5]&rsquo;, JA[6:7]<br><br>*Build the mi "T &larr; HostNumber, GoToExternal[eeLocB]" from constants<br>*and the host number read from the controller; ensure that parity is<br>*correct by xoring F1 and F2 into RSEL[0:3], which are unused.<br><br>SetTask[eiTask];<br><br>EtherInit:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[eiTemp,eiHost], At[EtherInitLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*eiTemp &larr; host number<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp1 &larr; And[377,eeLocA]C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*eiTemp1 &larr; eeLocA<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp1 &larr; (eiTemp1) or (And[7400,eeLocA]C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[eiTemp,10,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; Host[0:3] (will be F1)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp2 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*F1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; LdF[eiTemp,14,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*F2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eiTemp &larr; LSh[eiTemp,12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*F2 in position of F2 and RSEL[0:3]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LSh[eiTemp2,12]) xor T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; F1 xor F2 in RSEL[0:3] field<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp2 &larr; (eiTemp2) xor T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fix parity in RSEL[0:3]<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp2 &larr; (eiTemp2) or (ee015hi);<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp2 &larr; (eiTemp2) or (ee015lo);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; (eiTemp) or (ee1631hi);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; (eiTemp) or (ee1631lo);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; ee3235;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; eiTemp2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; eiTemp1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">WriteCS0&2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; eiTemp, DispTable[1,1,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even placement to preserve TPC<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; eiTemp1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">WriteCS1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eMDS600 &larr; 400C, DispTable[1,1,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even placement<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eMDS600 &larr; (eMDS600) or (200C), Return;<br><br>SetTask[0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*EMULATOR TASK -- Alto SIO, Mesa STARTIO opcode<br><br>OnPage[eePage];<br><br>*For Alto emulator, return to next opcode after carrying out the action;<br>*for Mesa, return to caller who exits to next opcode.<br>**Note that Mesa must save/restore AC0, which is smashed by eeSIO.<br>*The SIO control bits are in T (bits 16,17).<br><br>*eeSIO is assembled in to return 77777b (no Ethernet board present);<br>*EtherInit overwrites this.<br>eeSIO:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T;<br>*Return 77777b if no Ethernet board in machine; overwritten with:<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Add[HostNum]C, GoToExternal[eeLocB], At[eeLocA];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[AllOnes,1,17], GoTo[eeNone], At[eeLocA];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[AC0,16,2], AC0 &larr; T, NoRegILockOK, At[eeLocB];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; eDisableInputOutput, Disp[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC0 &larr; host address<br>*00 -- Do nothing <br>eeNone:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T, Return, DispTable[4];<br>*01 -- Start transmitter; form APCTask&APC word to notify output microcode<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; LoA[eoStartLoc], GoTo[eeSIO1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Low 8 bits of APC<br>*10 -- Start receiver; form APCTask&APC word to notify input microcode<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; LoA[eiStartLoc], GoTo[eeSIO2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Low 8 bits of APC<br>*11 -- Reset interface, i.e. abort.  Reset Output here,<br>*  then notify Input task to reset Input and post abort.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; LoA[eiAbortLoc], GoTo[eeSIO2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Low 8 bits of APC<br><br>eeSIO1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) or (HiA[eoStartLoc,eoTask]), Skip;<br>eeSIO2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) or (HiA[eiStartLoc,eiTask]);<br>*Notify appropriate code; also jump here from Initialize.Mc.<br>eIOReset:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eoState;<br>*Control returns to caller of eeSIO when emulator runs next<br>****Long time to task here****<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; RTemp;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[RTemp1], Return;<br><br>*INPUT TASK MICROCODE<br><br>%Input microcode is notified at eiStart by the emulator (at SIO).<br>Some initialization is done, and the TPC set up to eiIdle.<br>Wake up at eiIdle or at eiPostA+1 when the 1st quadword of a new packet<br>arrives (or the entire packet if less than 4 words long).  The wakeup<br>will be reasserted after tasking whenever there are 4 or more words in<br>the input buffer or when the last word of a packet is in the buffer.<br><br>NOTE: An input data late condition can occur if the receiver is turned<br>on in the middle of a packet.<br>%<br>SetTask[eiTask];<br><br>eiStart:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; eEnableInput, Call[eInit], At[eiStartLoc];<br><br>*Set up eiPtr and eiCount for single word transfers; eiCount uneven is ok<br>*because it will be touched before eiPtr, invoking the interlock.<br>eiIdle:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[eMDS600,eiCount,eiCLoc], OddOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[eMDS600,eiTemp1,eHLoc], Call[ebSetup];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fetch host address<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[eiTemp2,eStatus];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Check status for malformed packet<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (eiTemp2) and (100400C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Jam and bad alignment bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; eSetPurgeMode, Skip[ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Read  in first word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Output[eiTemp,eState], GoTo[ERet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*flush bad packet<br>*Address filtering.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[eiTemp2,eiData];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eiTemp1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RSh[eiTemp2,10]) xor T, Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  eFlag &larr; 0C, GoTo[eiBegin];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*I am promiscuous host<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; RSh[eiTemp2,10], Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  eFlag &larr; 0C, GoTo[eiBegin];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Destination = me<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[eoWrSt,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eFlag &larr; 0C, GoTo[eiBegin];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Broadcast packet<br><br>*Packet accepted by filter.<br>*EFLAG is set to 0 to tell the output microcode that a packet came in <br>*(used for input under output).<br>*ebSetup returns with:  eiPtr = IPtr + ICount - 1, eiCount = - ICount<br>*Check if buffer count zero.<br>eiBegin:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eiCount &larr; (eiCount) + 1, Skip[R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*R&gt;=0 =&gt; count is 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; esCZer, GoTo[eiCount0Post];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[eiPtr,eiTemp2];<br>*Compute how many singles before 1st quadword; form loop counter in eiTemp1.<br>* </span><span class="tab" val="67"></span><span style="font: 10pt serif">Address:  x00 =&gt; no singles, loop count = -1<br>* </span><span class="tab" val="67"></span><span style="font: 10pt serif">Address:  x01 =&gt; 3 singles, loop count = 2<br>* </span><span class="tab" val="67"></span><span style="font: 10pt serif">Address:  x10 =&gt; 2 singles, loop count = 1<br>* </span><span class="tab" val="67"></span><span style="font: 10pt serif">Address:  x11 =&gt; 1 singles, loop count = 0<br>*Form start address in T (bypass kludge)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Zero) + T + 1, Call[ebAlign];<br>*Loop here until buffer address is quadaligned<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp1 &larr; (eiTemp1) - 1, GoTo[eiSingle,R&gt;=0];<br><br>*Now start quadword input; adjust eiPtr and eiCount for 4-word transfers.<br>eiQuad:</span><span class="tab" val="67"></span><span style="font: 10pt serif">eiCount &larr; (eiCount) + (3C), Task;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiPtr &larr; (eiPtr) - (6C);<br>*Loop here to read quadwords from buffer until buffer nearly full or<br>*IOAtten occurs.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eiCount &larr; (eiCount) + (4C), GoTo[eiQuadFull,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[eiAttn,IOAtten];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IOStore4[eiPtr,eimData];<br>*This is so that if the IOStore4 causes an H4PE, it won&rsquo;t cause a LoadPage<br>*error in another task.  When Return is the 5th mi after IOStore4, the<br>*6th mi (executed by another task) is aborted on an H4PE, but a LoadPage<br>*error will be impossible.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[ERet];<br><br>*Get here when no more room for quadwords; do singles to fill buffer.<br>*7-eiCount = number of singles remaining in buffer.<br>*Set up loop counter as (- No. singles), and read in singles.<br>eiQuadFull:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiCount &larr; (eiCount) - (7C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even placement<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiPtr &larr; (eiPtr) + (6C), Call[eiSingle];<br>*This Nop avoids bypass kludge after PStore1 below and guards against PStore1<br>*aborted by H4PE and reexecuted without UseCTask true; if that were done,<br>*IOAtten would be erroneously tested in first mi after tasking.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br>*Can&rsquo;t test IOAtten in 1st mi after wakeup, so UseCTask below is required.<br>*On IOAtten, words left in buffer = 1 (CRC) - eiCount<br>eiSingle:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (eiCount) - 1, GoTo[eiAttnS,IOAtten];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even placement<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[eiTemp,eiData];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; eiTemp;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">**Required interlock for H4PE problem<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">**Maybe need 1 mi after this before PStore1?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eiCount &larr; (eiCount) + 1, UseCTask, GoTo[eiBufFull,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[eiPtr,eiTemp], Return;<br><br>*We get here when IOAtten is detected while reading quadwords.<br>*Words left in buffer = 7 - eiCount + 1 (CRC) + Excess count.<br>eiAttn:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (eiCount) - (10C);<br>eiAttnS:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[eiTemp,eStatus];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Read Status<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Maybe (?) needed to avoid bypass kludge<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LdF[eiTemp,10,2]) - T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiCount &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*eiCount &larr; 8 - eiCount + excess count<br>eiAttn2:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; RSh[eiTemp,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Shift down status<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; (eiTemp) and (eiSMask);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Mask out uninteresting status bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; (eiTemp) xnor (esIDon);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Post input done status<br>*Store eeCLoc.<br>eiPost:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[eMDS600,eiCount,eELoc], Call[eTaskRet];<br><br>*Post status, disable interface (purge packet too), and TASK.<br>*Post status in eiTemp, disable value in eiCount.<br>eiPostA:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiCount &larr; eDisableInput, Call[ePost];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*End of packet.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[eiIdle];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Wakeup here if Input under Output<br><br>*We get here when the input buffer is exactly full.<br>*IOAtten indicates that the last word was the CRC.<br>eiBufFull:<br>*Last word input was CRC.  Read one more word to see if the next is the CRC<br>*word (which we will discard).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiCount &larr; 0C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*No words left in buffer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; esIFul, Call[eTaskRet];<br>*After wakeup, check IOAtten.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[eiTemp,eStatus];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Can&rsquo;t check IOAtten 1st mi after wakeup<br>*IOAtten =&gt; Word was CRC; else Input buffer overrun =&gt; post status<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[eiAttn2,IOAtten];<br>eiCount0Post:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; (Zero) xnor T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[eiPost];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">**For H4PE problem--one extra mi after<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">**interlocking Input before PStore1 (?)<br><br><br>*Input microcode is notified here by emulator SIO when AC0[16:17] = 3.<br>*Manufacture "Abort" status and post. Input hardware will be disabled in case it is on.<br>eiAbort:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eFlag &larr; 0C, At[eiAbortLoc];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; eCmdBits;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eiTemp &larr; (eiTemp) xnor (esAbrt), GoTo[eiPostA];<br><br>SetTask[eoTask];<br><br>*Output microcode is notified at eoStart by the emulator (at SIO).<br>* Also get here to try again after a collision.<br>eoStart:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp &larr; eEnableOutput, Call[eInit], At[eoStartLoc];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[eMDS600,eoTemp1,eLLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fetch current load<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp1 &larr; (LSh[eoTemp1,1]) + 1, Skip[R&gt;=0]; *Form new load, check if old overflowed<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  eoTemp &larr; esLoad, GoTo[eoCompPost];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Post Load overflow status<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[eMDS600,eoTemp1,eLLoc];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Store updated load in eLLoc<br>*Compute countdown interval<br>*Get random number from "random" register (REFR register used).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (</span><span style="font: 10pt serif">SStkP&NStkP</span><span style="font: 10pt serif">) xor (377C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Save StkP and <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp2 &larr; IP[REFR]C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*point to "random" register<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; eoTemp2, eoTemp2 &larr; T, NoRegILockOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[Stack,4,10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get bits 4-13 and restore<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; eoTemp2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp1 &larr; (RSh[eoTemp1,1]) and T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Mask random number<br>%eoTemp1 had new Load mask, now has desired random interval in Alto ticks.<br>We would like a tick size of 38 microseconds.  The timers on the D0 have a<br>basic tick size of 64 times the clock speed.  If the clock is 100ns, that&rsquo;s<br>6.4 microsec.  6*6.4 is 38.4 which is very close.  6*x=2*(2*x)+2*x, so<br>that&rsquo;s why there are all those crazy LSHs below.<br>%<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp1 &larr; T &larr; LSh[eoTemp1,1], Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  GoTo[eoSetup];<br>*Before starting timer, check if input is set up.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[eMDS600,eoTemp,eiCLoc];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eFlag &larr; 1C, Task;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Timer wakeups ok now<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp1 &larr; (LSh[eoTemp1,1]) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LdF[eoTemp1,7,2]) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoCount &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Save high part (minus 1) (2 bits)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; eoTemp;<br>*Disable output. If the input word count is nonzero, enable the receiver<br>*while waiting to transmit.  Put low 7 bits of random number in eoTemp1.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp1 &larr; LdF[eoTemp1,11,7], Skip[ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  eoTemp &larr; Or[eDisableOutput!,eEnableInput!]C, Skip;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  eoTemp &larr; eDisableOutput;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*No input set up<br>*Start simple timer with low 7 bits of random number.<br>*Timer slot is eoTask.<br>eoLoadTimer:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eTimerMask;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Compute timer word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (CTask) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp1 &larr; (LSh[eoTemp1,4]) or T;<br>*We don&rsquo;t need to have TPC correct here, since control returns to this task<br>*via a Timer notify.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadTimer[eoTemp1];<br>eoInToo:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eiState;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Set Input state<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[eoTemp], GoTo[eoWrSt];<br><br>*Timer has expired (notified here by task 16). <br>eoTimerDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eFlag &larr; 0C, Skip[R Odd], At[eoTimerDoneLoc];<br>eTaskRet:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Ignore this wakeup, don&rsquo;t change TPC<br><br>*Check if still more time to elapse before start of transmission<br>*(High part of random number &gt;=0).<br>eoMoreTime:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp1 &larr; 177C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Set up maximum timer value<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoCount &larr; (eoCount) - 1, GoTo[eoLoadTimer,R&gt;=0];<br>*Enable output and shut off the receiver (in case it was turned on).<br>eoSetup:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp &larr; Or[eDisableInput!,eEnableOutput!]C, Call[eoInToo];<br>*Set up eoPtr and eoCount for single word transfers; eoCount uneven is<br>*OK because it will be touched before eoPtr, invoking the interlock.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[eMDS600,eoCount,eoCLoc], OddOK, Call[ebSetup];<br>*Subroutine Returns with:  eoPtr = OPtr + OCount - 1,  eoCount = -OCount<br>*Check for zero count.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eoCount, Skip[R&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*R&lt;0 =&gt; count is zero<br>*Output buffer count is zero. Post (Not[esCZR]).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  eoTemp &larr; esCZer, GoTo[eoCompPost];<br>*Compute number singles before 1st quadword, and form loop counter in eoTemp1.<br>* </span><span class="tab" val="67"></span><span style="font: 10pt serif">Address:  x00 =&gt; no singles, loop count = -1<br>* </span><span class="tab" val="67"></span><span style="font: 10pt serif">Address:  x01 =&gt; 3 singles, loop count = 0<br>* </span><span class="tab" val="67"></span><span style="font: 10pt serif">Address:  x10 =&gt; 2 singles, loop count = 1<br>* </span><span class="tab" val="67"></span><span style="font: 10pt serif">Address:  x11 =&gt; 1 singles, loop count = 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (eoPtr) + T + 1, Call[ebAlign];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Form start address in T<br>*Loop here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp1 &larr; (eoTemp1) - 1, GoTo[eoSingles,R&gt;=0];<br>*Start quadword output; adjust eoPtr and eoCount for 4-word transfers.<br>eoQuad:</span><span class="tab" val="67"></span><span style="font: 10pt serif">eoCount &larr; (eoCount) + (3C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoPtr &larr; (eoPtr) - (6C), Call[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Setup loop<br>*Output from the Main Memory Output Buffer to the Hardware Output Buffer.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eoCount &larr; (eoCount) + (4C), GoTo[eoQuadEmpty,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[eoAbort,IOAtten];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IOFetch4[eoPtr,eomData], Return;<br><br>*Normal exit from Output Loop is here<br>*7 - eoCount = number of singles remaining<br>*T is set up for next location.<br>eoQuadEmpty:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoCount &larr; (eoCount) - (7C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoPtr &larr; (eoPtr) + (6C), Call[.+1];<br>*Final singles<br>eoSingles:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eoCount &larr; (eoCount) + 1, GoTo[eoNoMore,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[eoPtr,eoTemp];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[eoTemp,eoData], GoTo[ERet];<br><br>*We&rsquo;re done outputing words. Set OutputEOP.<br>eoNoMore:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp &larr; eSetOutputEOP;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[eoTemp,eState], Call[ERet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Set OutputEOP<br>*Should wake up here after hardware&rsquo;s done sending packet or an error<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[eoTemp,eStatus];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Read Status<br>eoEnd1:</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (eoTemp) and (eCollMask);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Look at collision bit<br>*Shift down status<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp &larr; RSh[eoTemp,10], GoTo[eoColl,ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*ALU#0 =&gt; Collision, try again<br>*If not collision, form status. Could be good packet or underrun (ODL).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoCount &larr; 0C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp &larr; (eoTemp) and (eoSMask);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Remove uninteresting bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp &larr; (eoTemp) xnor (esODon);<br>eoPost:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[eMDS600,eoCount,eELoc], Call[eTaskRet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Store end count<br>*No more wakeups after ePost returns.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoCount &larr; eDisableOutput, GoTo[ePost];<br><br>*We arrive here after an IOAtten is detected in the main loop, indicating<br>*an error condition (a collision or underrun has occurred).<br>eoAbort:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[eoTemp,eStatus], GoTo[eoEnd1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Now read status<br><br>*Collision encountered, disable hardware to clear collision, enable and try again.<br>eoColl:</span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp &larr; eDisableOutput;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[eoTemp,eState], GoTo[eoStart];<br><br>eoCompPost:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eoTemp &larr; (eoTemp) xnor (0C), GoTo[eoPost];<br><br>*Task-independent Subroutines.  These will work properly if called from<br>*eiTask or eoTask, due to identical register ordering in the two tasks.<br><br>SetTask[And[eiTask,14]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Task 0 mod 4 of ei/eoTask block<br><br>RV[exTemp2,0];<br>RV[exCount,1];<br>RV[exPtr,2];<br>RV[exPtrHi,3];<br>RV[exTemp1,4];<br>RV[exTemp,5];<br><br>*Subroutine [ePost] posts the command completion, and starts an interrupt.<br>*expects post code and status in exTemp; exCount has disable code to send<br>*to State register.<br>ePost:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[eMDS600,exTemp2,eBLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fetch wakeup mask<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[exCount,eState];<br>*Store ending status in ePLoc and wakeup driver.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[DoIntPage];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*exCount write completes here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[eMDS600,exTemp,ePLoc], GoToP[DoIntR];<br><br>*Subroutine [ebSetup] returns with:<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">EPtr = Buffer Pointer + Count - 1<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">ECount = - Count<br>ebSetup:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (exCount) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">exPtr &larr; (exPtr) + T, UseCTask;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ptr &larr; Ptr + count - 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">exCount &larr; (Zero) - T - 1, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Count &larr; - Count<br><br>ebAlign:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">exTemp1 &larr; (Zero) - T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Complement, increment<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">exTemp1 &larr; (LdF[exTemp1,16,2]) - 1, Return;<br><br>*Subroutine [eInit].<br>*Initialization subroutine called by both input and output task.<br>*exTemp contains the enable code to be used to enable the hardware.<br>eInit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; eMDS600hi;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">exPtrHi &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Set up high part of Buffer pointer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">eFlag &larr; 0C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* In case of strange sequence of SIOs<br>eoWrSt:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[exTemp,eState];<br>ERet:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">exTemp &larr; exTemp, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Interlock Outputs<br><br>:END[Ether];</span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
