<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>Displayinit.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">INSERT[DisplayDefs];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Defs file common to DisplayInit and Display<br><br>:TITLE[DisplayInit];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ed Fiala 3 June 1982<br></span><span style="font: 12pt serif"><br>%Jump to DisplayInit from DeviceInit running as DisplayTask.  Determine the<br>terminal configuration from bits 10..14b of the UTVFC ID register:<br>  LF</span><span class="tab" val="67"></span><span style="font: 12pt serif">Star keyboard/LF monitor = 3 (resident);<br>  CSLF</span><span class="tab" val="67"></span><span style="font: 12pt serif">CSL keyboard/LF monitor = 11b (1st overlay); and<br>  CSL</span><span class="tab" val="67"></span><span style="font: 12pt serif">CSL keyboard/CSL monitor = 5 (also 1st overlay).<br>Initialization for all of these is contained here.  When started by Initial,<br>Star keyboard microcode is resident and CSL keyboard microcode resides in<br>the next overlay--it overwrites the resident if loaded.  Initialization<br>begins by either loading the overlay into IMX or skipping LoadRAM&rsquo;s pointers<br>past the overlay.  </span><span style="font: 10pt serif">When running with Midas, no overlays are in core, and the<br>microcode is used as loaded.  The Star keyboard driver is larger, requiring<br>a 40b-word table and about 32b more mi on lfKBPage than the CSL keyboard.<br><br>The CSLOverlay integer controls assembly of this source to produce the<br>microcode configuration required.  This same initialization is used for<br>both LF and CSL keyboard drivers and monitors.  </span><span style="font: 12pt serif">Both drivers are built from<br>Display.Mc which contains conditional assemblies for code specific to a<br>keyboard; assembled as is, Display.Mc produces code for a CSL keyboard<br>(either monitor); LFDisplay.Mc changes assembly switches and does<br>INSERT[Display] to make the Star keyboard configuration.  The Star and CSL<br>keyboard drivers are entirely different, but the code for displaying a<br>scanline is independent of which monitor is used.  Also, HRAM initialization<br>below is different.<br></span><span style="font: 10pt serif"><br></span><span style="font: 12pt serif">Monitors require a certain time/scanline which must be divided in a specified<br>ratio between forward scan and horizontal sync--hardware adjustments cannot<br>compensate for much variation, and for a particular hardware adjustment,<br>all microcode systems should use the same operating parameters.  With a<br>50 mhz oscillator, the LF monitor requires 1088 bits forward scan and 352<br>bits horizontal sync totalling 28.8 us/scanline.  With a 20 mhz oscillator,<br>the CSL monitor requires 652 bits forward and 104 bits horizontal sync<br>totalling 38 us/scanline.  The forward scan consists of blanked area,<br>image, visible constant, and blanked area.  The UTVFC limits image size of<br>the image+visible constant to 1024 bits or less.  The visible constants would<br>be setup by initializing the pingpong buffers to some pattern, but this isn&rsquo;t<br>done below (i.e., the size of the visible constant is 0).<br><br>For the LF monitor, it was empirically determined that hardware adjustments<br>could compensate for substantial sweep rate variations by adding (invisible)<br>scanlines at the end of each field before vertical sync.  In DisplayDefs.Mc,<br>the vVSStart parameter may be varied between about 11b and 300b to control<br>field rate.  At 11b (77 fields/sec), no flicker is noticeable; at 140b (65<br>fields/sec), flicker is just barely noticeable; at 300b (55 fields/sec)<br>flicker definitely degrades the picture.  Increasing vVSStart without hardware<br>adjustments spreads the picture vertically, so not too much software<br>flexibility is permissible.  The ability to operate at less than maximum<br>field rate is potentially of interest because the display task averages<br>roughly 25 percent of all cycles at 77 fields/sec compared to 20 percent at<br>65 fields/sec, which improves the emulator&rsquo;s machine share from about 74<br>percent to 78 percent (= 6 percent faster).  However, at present all systems<br>use 77 fields/sec except when videotaping computer sesssions.  To obtain<br>60 Hz rate for videotaping, change lfVSStart to lvVSStart =<br>[1/28.8 us x 60 Hz] - [808/2] - lfSyncLength - lfBlankLength - 14 =<br>579 - 404 - 9 - 13 - 14 = 139d = 213b.<br><br>For the CSL monitor, very little variation in the vertical parameters is<br>possible; the current choice results in 60 fields/second.<br><br>A CSL monitor is 608 visible bits/scanline x 808 visible scanlines; the LF<br>monitor is 1088 x 861, but this microcode reduces its capability to<br>1024 x 808, compatible with the CSL display, by framing 608 visible bits by<br>equal size blanked areas to the left and right, so the monitors must be<br>adjusted to be full-screen at 808 scanlines.  Pilot also runs the monitors<br>at 808 scanlines for compatibility.<br><br>For the CSL monitor, vBufStart = 150b, so 230b nibbles (=608 bits =38 words)<br>of data are supplied by the task per scanline; an additional 5b nibbles of<br>forward scan occur while blanking just before and just after horizontal sync;<br>and there are 32b nibbles of horizonal sync.  The midline bit in HRam appears<br>1/2 x (230b+12b+32b) = 136b nibbles after the end of horizontal sync.  Since<br>data begins at AAR=150b, ML should appear at 150b+136b-5b = nibble 301b.<br><br>For the LF monitor, 1088 bits (= 420b nibbles) are in forward scan, 352<br>bits (= 130b nibbles) are horizontal sync; ML appears 1/2 * 550b nibbles<br>after ending horizontal sync.  Since data begins at AAR=150b, ML should<br>appear at 150b+264b-number of blanked nibbles following horizontal sync, or<br>at AAR=434b-number of nibbles following horizontal sync.<br><br>Total vert blanking = vVSStart + vSyncLength + vBlankLength + 14d scanlines.<br>%<br></span><span style="font: 10pt serif">*DisplayInitLoc must be odd; DisplayInitLoc to DisplayInitloc+6 are used<br>**NOTE: These are known to MakeLoaderFile command files.<br>Set[DpNotifyLoc,Add[DisplayInitLoc,1]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*7610b must be even<br>Set[DpContInitLoc,Add[DisplayInitLoc,4]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*7613<br>Set[DpOvlSkipLoc,Add[DisplayInitLoc,5]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*7614<br>Set[DpSLCountLoc,Add[DisplayInitLoc,6]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*7615<br><br>SetTask[DpTask];<br><br>*Get here from DeviceInit running at the Display&rsquo;s task level.<br>DisplayInit:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vCR &larr; ClrNC&Blank, At[DisplayInitLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Clear Nibble counter<br>*Suspicious that the nibble counter is only cleared when AllowWU is false,<br>*so do this output twice.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 104400C, Call[vCRout];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Start&larr;nibble 44b, ForceAARLoad&rsquo;&larr;0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vMDS420 &larr; 177000C, Call[vCRout];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vSLC,vBufStart];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">**5 mi after Output before PStore4<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; vDBuf0 &larr; IncNC&Blank, Call[vQIni];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vMDS420 &larr; (vMDS420) or (30C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[vMDS420,vDBuf0,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vMDS &larr; 0C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*vMDS = vZero, so both are initialized<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[vTemp,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Controller ID code in bits 10:14b<br><br>:IF[CSLOverlay]; *******************************<br><br>*ID code in bits 10:14b is 3 for LF keyboard with LF display, 11 for CSL<br>*keyboard with LF display, or 5 for CSL keyboard with CSL display.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (vTemp) and (140C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vCnt &larr; LoA[DpOvlSkipLoc], GoTo[.+3,ALU=0];<br>*Notify LoadRAM at its continue-loading address to read CSL keyboard overlay.<br>*LoadRAM reenters at DpNotifyLoc.<br>***RTemp1 (RM 53) has to be EVEN or be made even here, even though it lies<br>***within the device table manipulated by Initialize.  xBuf to xBuf3 are also<br>***smashed by LoadRAM ????.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  vCnt &larr; LoA[LRJContinue];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  vCnt &larr; (vCnt) or (HiA[LRJContinue]), Skip;<br>vMPBr:</span><span class="tab" val="67"></span><span style="font: 10pt serif">vCnt &larr; (vCnt) or (HiA[DpOvlSkipLoc]);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; vCnt;<br>vMPRet:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IncMPanel, Return;<br><br>%The code for skipping overlays must be compatible with both old and new<br>LoadRAM (which Pilot inherits from Initial), so it accepts the word<br>displacement in xfTemp+LP but leaves xfTemp .eq. 0 and the modified<br>displacement only in LP.<br>%<br>SetTask[0];<br><br>vLPCarry:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Skip[Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LPhi &larr; (LPhi) + (400C) + 1;<br>vAddr7777:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 170000C, Return;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; xfTemp, At[DpOvlSkipLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skip CSL keyboard overlay<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LP &larr; (LP) + T;<br>vSkpOv:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[LP,xfTemp,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LP &larr; (LP) + (3C), Call[vLPCarry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xfTemp &larr; (LdF[xfTemp,0,14]) xnor T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Check address .eq. 7777b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Skip[ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  GoTo[vSkpOv];<br><br>*CSL ucode has been skipped or loaded.  Notify display task to continue init.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; LoA[DpContInitLoc], At[DpNotifyLoc];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTemp &larr; (RTemp) or (HiA[DpContInitLoc,DpTask]);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (APCTask&APC &larr; RTemp) - T, Call[vMPRet];<br>*Emulator will continue here, but not until after HRAM init, when clock speed<br>*determination for the time-of-day clock and other timers will be carried out.<br>*The long comment later explains how this works.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Zero) + T + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) or (LoA[DpSLCountLoc]), Skip[Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  RTemp &larr; HiA[DpSLCountLoc,DpTask], Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; RTemp, Call[vMPRet];<br>*Next time emulator runs, pass control back to DeviceInit.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[InitPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; xCNT, GoToP[DI6];<br><br>SetTask[DpTask];<br>:ENDIF; ****************************************<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vDBuf0 &larr; 40000C, At[DpContInitLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*to load AAR<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vCR &larr; IncNC&Blank, Call[vNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Increment NClk bit; generate NClk<br>***Don&rsquo;t know why next mi is useful<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vZero,vHCRam], Call[vNClk];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vDBuf0,vBufStart];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*ForceAARLoad&rsquo;&larr;1, ForceIARLoad&rsquo;&larr;0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vDBuf0,vLdIAR];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (vTemp) and (40C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*vTemp[10:14b] = 3 LF, 5 CSL, or 11 LF<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vDBA &larr; 44C, GoTo[vLFInit,ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Load HRam, starting at nibble 44<br><br>*CSL display HRAM init<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 277C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 44 - 277 &larr; 0 (150 up data)<br>*ML at 150 + (1/2 * (230+46)) - 7 = 300<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 1C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*300</span><span class="tab" val="67"></span><span style="font: 10pt serif">   &larr; 1 (ML)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 376C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*301 - 376 &larr; 0 (data)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 10C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*377</span><span class="tab" val="67"></span><span style="font: 10pt serif">   &larr; 10 (SetC--start blanking)<br>*46b nibbles of blanking must have 32b words of horizontal sync; the other<br>*14b nibbles may be blanked either before or after horizontal sync; this<br>*positions the active image left or right on the screen.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 4C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*  0 -   4 &larr; 0 (blank, no sync)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 4C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 36C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*  5 -  36 &larr; 4 (blank, hor. sync)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 44C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 37 -  44 &larr; 0 (blank)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vFieldFill &larr; cslVSStart, GoTo[vSwiI];<br><br>%Since HRam is only 256 bits long, it is necessary to take advantage of the<br>fact that the Switch bit is ignored unless blanking is in force. On each<br>scanline, AAR is initialized to vBufSt (150b) and then cycles until SetC<br>is turned on to start blanking and then until the Switch bit occurs.<br>Hence, initialization must setup a total line time such that data bits+<br>blanking bits = 1088+352, where at least 608 of the bits must be data bits<br>and 352 of bits must be blanked with horizontal sync true; the other 480<br>bits may be displayed as a constant value or blanked, as chosen, and the<br>blanked bits may be divided arbitrarily between the left and right parts<br>of the display.  The code below shows 256 nibbles data, 16 nibbles blanking,<br>and 88 nibbles horizontal sync.<br>NOTE: Initializing HRam takes about 408*18 = 7344 cycles; during this time,<br>tasking doesn&rsquo;t take place, so refresh will not take place.<br>%<br>vLFInit:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vFieldFill &larr; lfVSStart;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Only for LF monitor<br>:IF[IFG[WordsPerLine!,46,0,1]]; ****************<br>*This code has the computed parameters for a 50 mhz crystal (i.e.,<br>*1088-bit forward scan, 352-bit horizontal sync with 608 bits of data):<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 336C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 44 - 336 &larr; 0 (partly redundant)<br>*ML at 150 + (.5*(416+130)) - 74 = 337<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 1C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*337       &larr; 1 (ML)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 376C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*340 - 376 &larr; 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 10C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*377       &larr; 10 (SetC)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 72C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*  0 -  72 &larr; 0 (blanking--74b)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 4C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 222C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 73 - 222 &larr; 4 (Hor. sync--130b)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 316C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*223 - 316 &larr; 0 (blanking--74b)<br>:ELSE; *****************************************<br>*This code has the computed parameters for a 50 mhz crystal (i.e.,<br>*1088-bit forward scan, 352-bit horizontal sync with 1024 bits of data):<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 251C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 44 - 251 &larr; 0 (partly redundant)<br>*ML at 0 + (.5*(416+130)) - 74 = 337<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 1C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*251       &larr; 1 (ML)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 376C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*252 - 376 &larr; 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 10C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*377       &larr; 10 (SetC)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 12C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*  0 -  12 &larr; 0 (blanking--13b)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 4C;<br>***This seems to be insufficient horizontal sync?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 135C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 13 - 135 &larr; 4 (Hor. sync--123b)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 145C, Call[vOutNClk0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*136 - 145 &larr; 0 (blanking--9b)<br>:ENDIF; ****************************************<br>vSwiI:</span><span class="tab" val="67"></span><span style="font: 10pt serif">vMDS177400 &larr; 177400C;<br>:IF[CSLOverlay]; *******************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vDBuf0 &larr; Add[140000,vStart]C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*ForceAARLoad&rsquo;&larr;1, ForceIARLoad&rsquo;&larr;1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 2C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*317       &larr; 2 (Switch--end blanking)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*or 45<br><br>%HRam has just been initialized to 652 forward and 104 reverse = 756<br>bits/scanline for CSL monitors or to 1088 forward and 352 reverse = 1440<br>bits/scanline for LF monitors.  This establishes a scanline time of 28.800 us<br>(LF) or 37.800 us (CSL).  We want to utilize these times to determine the<br>unknown processor clock period by counting cycles/scanline.  To discriminate<br>40 mhz (100 ns/cycle), 44.5 mhz (89.886 ns/cycle), and 50 mhz (80 ns/cycle)<br>processor clocks, DisplayTask counts scanlines in a six-cycle loop while the<br>emulator executes a six-cycle loop 65536d times.  The predicted scanline<br>count is 6*65536*C/(L-(6*C)-X), where L is time/scanline, C is processor clock<br>period, and X is other task overhead/scanline in 100 ns units. The computation<br>below ignores all components of X except the refresh timer at L*(18/2560).<br>So the computations are (393216*C)/(288-6*C-2) for LF monitors or<br>(393216*C)/(378-6*C-3) for CSL monitors.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Predicted  Predicted<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   CSL</span><span class="tab" val="67"></span><span style="font: 10pt serif">      LF</span><span class="tab" val="67"></span><span style="font: 10pt serif">  CSL</span><span class="tab" val="67"></span><span style="font: 10pt serif">      LF<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Scanlines  Scanlines   Threshold  Threshold<br>40.0 mhz</span><span class="tab" val="67"></span><span style="font: 10pt serif">  1066</span><span class="tab" val="67"></span><span style="font: 10pt serif">     1404</span><span class="tab" val="67"></span><span style="font: 10pt serif">.g. 1046   .g. 1375<br>44.5 mhz</span><span class="tab" val="67"></span><span style="font: 10pt serif">   955</span><span class="tab" val="67"></span><span style="font: 10pt serif">     1258</span><span class="tab" val="67"></span><span style="font: 10pt serif">.g.  935   .g. 1230<br>50.0 mhz</span><span class="tab" val="67"></span><span style="font: 10pt serif">   850</span><span class="tab" val="67"></span><span style="font: 10pt serif">     1119<br><br>Observed counts with 40.0 mhz processor clock 1066 on a CSL monitor, 1416<br>with an LF monitor.<br>%<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vDBuf0,vBufStart];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vDbuf0,vLdIAR];</span><span class="tab" val="67"></span><span style="font: 10pt serif">**This mi probably useless<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; (Zero) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vCR &larr; AllowWU&Blank, Call[vCRout];<br>*Count scanlines here until stopped by the emulator.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vTemp1 &larr; IP[RConstantLo]C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*IOStrobe in 1st mi won&rsquo;t work<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; vSLC &larr; (vSLC) + 1, IOStrobe, GoTo[vIRet];<br><br>*Emulator restarts DpTask here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Input[vTemp,0], At[DpSLCountLoc];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (SStkP&NStkP) xor (377C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; vTemp1, vTemp1 &larr; T, NoRegILockOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (vTemp) and (40C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; (vSLC) - (2000C), GoTo[vCSLThresholds,ALU#0];<br>*LF thresholds are now 351d and 206d, respectively.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; (vSLC) - (316C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*206d<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (vSLC) - (221C), DblGoTo[v50mhz,v40x,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*136d<br><br>*CSL thresholds are now 22d and -89d, respectively.<br>vCSLThresholds:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; (vSLC) + (131C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*69d<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (vSLC) - (157C), GoTo[v40x,ALU&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*111d<br>*See Timer.Mc for the determination of these constants.<br>v50mhz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; HiA[5330];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) or (LoA[5330]);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; 130C, GoTo[vSetTimer];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*50 mhz crystal (530b)<br><br>v40x:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; HiA[113274], GoTo[v44.5,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*44.5 mhz crystal (602b)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; HiA[12172];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) or (LoA[12172]);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; 256C, GoTo[vSetTimer];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*40 mhz crystal (656b)<br><br>v44.5:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) or (LoA[113274]);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; 202C, GoTo[vSetTimer];<br><br>vSetTimer:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; (Stack) or (400C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; vTemp1;<br>:ELSE; *****************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 2C, Call[vOutNClk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*272       &larr; 2 (Switch--end blanking)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vCR &larr; AllowWU&Blank, Call[vCRout];<br>:ENDIF; ****************************************<br><br>*Set keyboard words 177030-177043 to -1</span><span class="tab" val="67"></span><span style="font: 10pt serif">(177040-177043 unused by CSL keyboard)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; vDBuf0 &larr; (Zero) - 1, Call[vQIni];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; vMsgStatus &larr; 0C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Task sets up loop<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[vMDS420,vDBuf0,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[vMDS420,vDBuf0,4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[vMDS420,vDBuf0,10], Call[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Call sets up loop<br><br>%This code zeroes the two pingpong buffers (not needed unless a white area<br>*is shown to the right of the active display).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 140000C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vSLC,vBufStart];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; vMsgStatus &larr; 0C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vZero,vLdIAR], Call[vClrBf];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*IAR &larr; Start<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vButtons &larr; T, Call[vClrBf];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*This call sets up loop<br>%<br>*Clear cursor memory (32 bits/scanline x 32 scan lines) because in Alto<br>*compatible mode, only 16x16 of the hardware&rsquo;s 32x32 cursor is used.<br>**NOTE: Blanking must be on here.  The final overlay must not overwrite this<br>**code until it has finished.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 6C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*8 nibbles/scan line<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vMsgStatus,vCursor0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vMsgStatus &larr; (vMsgStatus) + (4C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vZero,vCursorMem0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; (vSLC) - 1, GoTo[.-3,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vMsgStatus &larr; (vMsgStatus) + (4000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vMsgStatus &larr; (vMsgStatus) and (174000C), Skip[Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  vMDS420 &larr; (vMDS420) or (20C), Return;<br>*Wind up here with vMsgStatus .eq. 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vMDS420 &larr; 400C, Call[.-1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vCR &larr; AllowWU;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vKeyBuffer &larr; T, LoadPage[DisplayPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vButtons &larr; T, GoToP[vFDone];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*End init<br><br>**NOTE: An NClk is produced with an IOFetch4 rather than four Output&rsquo;s so<br>**that display initialization doesn&rsquo;t defer memory refresh too long; as<br>**coded, initialization runs about 0.4 msec before tasking.<br><br>*SUBROUTINE vNClk generates one NClk.<br>vNClk:</span><span class="tab" val="67"></span><span style="font: 10pt serif">UseCTask;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IOFetch4[vMDS420,vfCReg,0], Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*vMDS420 holds 177030b here<br><br>vCRout:</span><span class="tab" val="67"></span><span style="font: 10pt serif">UseCTask;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vCR,vCReg], Return;<br><br>*SUBROUTINE vOutNClk sends the pattern in vSLC to the HCRam until the<br>*address = T; does T&larr;T+1 prior to Return for caller.<br>vOutNClk0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">vSLC &larr; 0C;<br>vOutNClk:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vDBA &larr; (vDBA) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RHMask[vDBA]) xor T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Output[vSLC,vHCRam], Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; (Zero) + T + 1, GoTo[vNClk];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IOFetch4[vMDS420,vfCReg,0], GoTo[vOutNClk];<br><br>vQIni:</span><span class="tab" val="67"></span><span style="font: 10pt serif">vDBuf1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">vTemp1 &larr; T, UseCTask;<br>vIRet:</span><span class="tab" val="67"></span><span style="font: 10pt serif">vTemp &larr; T, Return;<br><br>%vClrBf:</span><span class="tab" val="67"></span><span style="font: 10pt serif">IOFetch16[vMDS177400,vfBuf0,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IOStrobe;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IOFetch16[vMDS177400,vfBuf0,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IOFetch16[vMDS177400,vfBuf0,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IOFetch16[vMDS177400,vfBuf0,0], Return;<br>%<br><br>:END[DisplayInit];<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
