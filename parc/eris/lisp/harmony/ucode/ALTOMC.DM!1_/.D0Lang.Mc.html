<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>D0Lang.Mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif">% D0Lang.mc<br>Edit history:<br>29 Oct 81 by Fiala</span><span class="tab" val="77"></span><span style="font: 12pt serif">Fix Stack&+/-n &larr; Stack&+/-n F2.used.twice bug<br> 1 Sep 81 by Fiala</span><span class="tab" val="77"></span><span style="font: 12pt serif">Added other RM reg, F2 with ReadPipe<br> 6 Feb 81 by Fiala</span><span class="tab" val="77"></span><span style="font: 12pt serif">Added :UNLESS, HIA, LOA, NSALUF, ALURESULT&NSALUF<br> 9 Dec 80 by Fiala</span><span class="tab" val="77"></span><span style="font: 12pt serif">Add RV2, RV4, PSET macros<br>29 Oct 80 by Fiala</span><span class="tab" val="77"></span><span style="font: 12pt serif">Added ODDOK and NONQUADOK<br><br>Naming convention:  Internal symbols not used by programmers all end with<br>"@"; symbols defined in the "D0 MicroAssembler" document and Micro<br>builtins don&rsquo;t.<br>%<br>BUILTIN[MACRO,2];<br>BUILTIN[NEUTRAL,3];<br>BUILTIN[MEMORY,4];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Declare Memory[name,wordsize,length,srcmacro,<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*sinkmacro,tagmacro,postmacro]<br>BUILTIN[TARGET,5];<br>BUILTIN[DEFAULT,6];<br>BUILTIN[FIELD,7];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Declare field (#1 = bit1, #2 = bitn)<br>BUILTIN[PF,10];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Preassign value to field<br>BUILTIN[SET,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Declare integer and set value<br>BUILTIN[ADD,12];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Add up to 8 integers<br>BUILTIN[IP,13];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Integer part of address<br>BUILTIN[IFSE,14];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*If string equal (IFSE[s1,s2,true,false])<br>BUILTIN[IFA,15];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*If field assigned (IFA[field,true,false])<br>BUILTIN[IFE,16];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*If integers equal<br>BUILTIN[IFG,17];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*If integer 1 &gt; integer 2<br>BUILTIN[IDF,20];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*If symbol in symbol table and not unbound address<br>*BUILTIN[IFME,21];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*If memory part of address equals string<br>BUILTIN[ER,22];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Error message (ER[string,abortflag,integer])<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*abortflag = 0 message, 1 fatal, 2 error, 3 warning<br>BUILTIN[LIST,23];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Set listing mode for memory<br>*BUILTIN[INSERT,24];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Insert file (Micro predefines this name)<br>BUILTIN[NOT,25];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*1&rsquo;S complement<br>BUILTIN[REPEAT,26];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Repeat the text #2 #1 times<br>BUILTIN[OR,27];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Inclusive or up to 10 integers<br>BUILTIN[XOR,30];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Exclusive or up to 10 integers<br>BUILTIN[AND,31];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*And up to 10 integers<br>BUILTIN[COMCHAR,32];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Set comment char for conditional assemblies<br>*BUILTIN[BITTABLE,33];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Makes #1 a bit table of length #2 bits<br>*BUILTIN[GETBIT,34];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Is the bit in bittable #1 at pos. #2<br>*BUILTIN[SETBIT,35];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*SETBIT[table,bit1,nbits,distance,value]<br>*BUILTIN[FINDBIT,36];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*FINDBIT[table,bit1,nbits,distance,hopdistance,nhops]<br>*BUILTIN[MEMBT,37];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*MEMBT[memory,table] creates a bit table for memory<br>BUILTIN[LSHIFT,40];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Shifts the integer #1 left #2 positions<br>BUILTIN[RSHIFT,41];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Shifts the integer #1 right #2 positions<br>BUILTIN[FVAL,42];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*FVAL[field] is an integer whose value is the<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*current contents of the field<br>BUILTIN[SELECT,43];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*#1 is an integer .ge. 0 and .le. 7.  evaluates<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*#2 if #1 = 0, ..., #9 if #1 = 7.  Error if #1 &gt; 7<br>BUILTIN[SETPOST,44];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Set post-evaluation macro (SETPOST[mem,macro])<br>BUILTIN[LISTFIELDS,46];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*LISTFIELDS[mem,word] assembles word as for DEFAULT<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*and the 1-bits denote the right-most bits of fields<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*in the octal listing.<br>BUILTIN[SETMBEXT,47];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Set .mb file extension<br>BUILTIN[SUB,50];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*SUB[a1, a2, ... , an] = a1-a2-...-an<br>BUILTIN[EQUATE,51];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*EQUATE[new,old] gives new same definition as old<br>BUILTIN[ASMMODE,52];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*ASMMODE[0] is normal, ASMMODE[1] ignores all<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*statements except those beginning with ":"<br>BUILTIN[TRACEMODE,53];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*TRACEMODE[n,v] turns on tracing feature n if v ne 0,<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*off if v=0.  n = 0 is trace symbol insertions,<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*1 is trace all applications of the form name[args]<br>BUILTIN[WHILE,54];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*WHILE[expr,clause] repeatedly executes clause while<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*expr is non-zero.<br><br>BUILTIN[M@,2];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*=MACRO (internal use)<br>BUILTIN[F@,7];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*=FIELD<br>BUILTIN[EQ@,51];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*=EQUATE<br><br>SETMBEXT[DIB];<br><br>ER[29.Oct.81--D0Lang.version.14,0];<br><br>*IM field definitions<br>F@[MIRMOD@,0,1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*MEMINS@ and RMOD@<br>F@[RSEL@,2,5];<br>  F@[MR@,0,5];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*MEMINS@, RMOD@, and RSEL@<br>F@[F2@,22,25];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*FF[4:7]<br>F@[JC@,26,30];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Jump control<br>  F@[JC0@,26,26];<br>  F@[JC2@,30,30];<br>F@[JA2@,31,36];<br>  F@[JA7@,36,36];<br>*F@[IMPARITY@,37,37];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Parity bit<br>F@[RX@,120,121];<br>  F@[RX1@,121,121];<br>F@[JA1@,122,123];<br><br>*Fields in regular mi&rsquo;s<br>F@[ALF@,6,11];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*ALUF field<br>  F@[AF0@,6,6];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Sign of ALUF for constants<br>F@[BS@,12,13];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Source for B (0-1 = constants, 2 = T, 3 = other)<br>F@[F1@,14,17];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*FF[0:3]<br>  F@[BSF1@,12,17];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*BS@ and F1@<br>F@[LR@,20,20];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Load RM<br>F@[LT@,21,21];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Load T<br><br>*Fields in memory reference mi&rsquo;s<br>EQ@[TYPE@,ALF@];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Type of memory reference<br>F@[SRCDES@,12,21];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Source/destination<br>  F@[SRDS03@,12,15];<br>  F@[SRDS67@,20,21];<br>  F@[SRDS7@,21,21];<br>F@[MRTYP@,0,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Both MR@ and TYPE@<br><br>*Extra stuff for MicroD<br>F@[BRKP@,40,40];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Midas breakpoint<br>F@[@W0@,41,41];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Place at absolute loc. W0<br>*F@[GLB@,42,42];<br>F@[PW0@,43,43];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Bit 43=1 tells MicroD that 44:47 contain the page<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*on which the mi should be placed<br>F@[W0@,44,57];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*full address for placement<br>  F@[PGE@,44,47];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*page for mi placement<br><br>F@[RETCL@,60,61];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Bit encoded: 2 = don&rsquo;t constrain placement of this mi<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*1 = put W2@ at this mi&rsquo;s location + 1 mod 20 <br>F@[ODDCALL@,62,62];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Indicates that even though this mi encodes a CALL<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*in JC@, its inline successor is not constrained to<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*lie at .+1 in the microstore.<br>F@[SWPAGE@,63,63];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Loads the PAGE register (for MicroD error chk)<br>F@[W1@,64,77];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Imaginary address of unconditional or false branch<br><br>F@[CHPAGE@,101,101];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Predecessor did LOADPAGE (for MicroD error chk)<br>*F@[EMUL@,102,102];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Presently unused<br>F@[CND@,103,103];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Has a branch condition<br>F@[W2@,104,117];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Imaginary address of conditional branch when true<br><br>*M@[MRS@,MR@[XOR[RSHIFT[#1,2],14]] RX@[AND[#1,3]]]; *MEMINS@ RMOD@ & RSEL@<br>M@[BREAKPOINT,BRKP@[1]?];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Causes Midas to create a bp when loading<br>M@[NOP,PF[BS@,2]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*For no-op mi&rsquo;s<br><br>M@[F1T@,ER[F1.used.twice,2]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">M@[FF1@,IFA[F1@,F1T@[],F1@[#1] ]];<br>M@[F2T@,ER[F2.used.twice,2]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">M@[FF2@,IFA[F2@,F2T@[],F2@[#1] ]];<br>M@[FZ@,FF1@[RSHIFT[#1,4]] FF2@[AND[#1,17]]];<br>M@[BSF@,BSF1@[RSHIFT[#1,4]] FF2@[AND[#1,17]]];<br><br>M@[TMARGS@,ER[Too.many.args.for.#1,2]];<br>M@[TBIG@,ER[#1.count.too.big,2]];<br>M@[TSMALL@,ER[#1.count.too.small,2]];<br>M@[NOARGS@,ER[No.args.allowed.in.#1,2]];<br><br><br>*Fields for IMMASK assembly<br>F@[CONMSK@,0,17];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Constraint mask: bit n = 1 =&gt; can place at n mod 20<br>F@[DTLEN@,20,23];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Dispatch table length - 1<br><br>%Neutrals and connection macros:<br><br>A neutral "RB" distinct from "A" is needed so that expressions such as:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">DB[RAddr]&larr;(BBFBX[DB[RAddr]]) SALUFOP T, DISP[BBLOOP];<br>can be compiled.  In this case the DB[RAddr] macro cannot leave the<br>neutral "A" because that won&rsquo;t work in the destination part of the clause.<br>This is also the reason for the RB&larr; macro.<br>%<br>NEUTRAL[A];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*ALUA sources<br>NEUTRAL[A&larr;];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*ALUA destinations<br>NEUTRAL[RB];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*RM addresses or functions of RM addresses<br>NEUTRAL[B];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*H2 sources<br>NEUTRAL[B&larr;];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*H2 destinations<br>NEUTRAL[LU];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*ALU functions<br>NEUTRAL[LU&larr;];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*ALU destinations (RM, T)<br>NEUTRAL[T];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*T register<br>NEUTRAL[?];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Left by macros that cannot be connected to anything by "&larr;"<br><br>M@[B&larr;B,B];<br>M@[B&larr;T,B];<br>M@[LU&larr;LU,LU];<br>M@[T&larr;,LT@[1] LU&larr;];<br>M@[RB&larr;,LR@[1] LU&larr;];<br><br>*Micro is supposed to run faster if symbols such as these integers are<br>*defined prior to their appearance in a macro, so define them here.<br>SET[Z@,0]; SET[Z1@,0]; SET[Z2@,0]; SET[Z3@,0];<br>SET[TSKFLG@,0]; SET[CHPGFLG@,0]; SET[REGIFLAG@,0]; SET[RTNILL@,0];<br><br>%Memory reference interlocks only occur when the ALUA source participates in<br>the ALU operation, so default the ALU operation to LU&larr;A when an A destination<br>is loaded; if LU&larr;B appears in the mi, warn him of potential error unless he<br>has put a NOREGILOCKOK clause in the same mi.<br>%<br>M@[NOREGILOCKOK,SET[REGIFLAG@,IFE[REGIFLAG@,1,0,2]] ?];<br>M@[A&larr;A,PF[ALF@,1] SET[REGIFLAG@,IFG[REGIFLAG@,1,0,1]] A];<br>EQ@[A&larr;RB,A&larr;A];<br><br><br>*ALU operations defined for (A,RB) op (B,T)<br>M@[LU&larr;B,ALF@[0] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[LU&larr;T,LU&larr;B];<br>M@[LU&larr;A,ALF@[1] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[LU&larr;RB,LU&larr;A];<br>M@[AANDB,ALF@[2] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[AANDT,AANDB];<br>  EQ@[RBANDB,AANDB];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RBANDT,AANDB];<br>M@[AORB,ALF@[3] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[AORT,AORB];<br>  EQ@[RBORB,AORB];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RBORT,AORB];<br>M@[AXORB,ALF@[4] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[AXORT,AXORB];<br>  EQ@[RBXORB,AXORB];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RBXORT,AXORB];<br>  EQ@[A#B,AXORB];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[A#T,AXORB];<br>  EQ@[RB#B,AXORB];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RB#T,AXORB];<br>M@[AANDNOTB,ALF@[5] LU];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[AANDNOTT,AANDNOTB];<br>  EQ@[RBANDNOTB,AANDNOTB];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RBANDNOTT,AANDNOTB];<br>M@[AORNOTB,ALF@[6] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[AORNOTT,AORNOTB];<br>  EQ@[RBORNOTB,AORNOTB];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RBORNOTT,AORNOTB];<br>M@[AXNORB,ALF@[7] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[AXNORT,AXNORB];<br>  EQ@[RBXNORB,AXNORB];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RBXNORT,AXNORB];<br>  EQ@[A=B,AXNORB];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[A=T,AXNORB];<br>  EQ@[RB=B,AXNORB];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RB=T,AXNORB];<br>M@[A+1,ALF@[10] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RB+1,A+1];<br>M@[A+B,ALF@[11] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[A+T,A+B];<br>  EQ@[RB+B,A+B];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RB+T,A+B];<br>M@[A+B+1,ALF@[12] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[A+T+1,A+B+1];<br>  EQ@[RB+B+1,A+B+1];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RB+T+1,A+B+1];<br>M@[A-1,ALF@[13] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RB-1,A-1];<br>M@[A-B,ALF@[14] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[A-T,A-B];<br>  EQ@[RB-B,A-B];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RB-T,A-B];<br>M@[A-B-1,ALF@[15] LU];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[A-T-1,A-B-1];<br>  EQ@[RB-B-1,A-B-1];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RB-T-1,A-B-1];<br>*ALUF[16] UNASSIGNED<br>M@[ASALUFOPB,ALF@[17] LU];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[ASALUFOPT,ASALUFOPB];<br>  EQ@[RBSALUFOPB,ASALUFOPB];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[RBSALUFOPT,ASALUFOPB];<br><br>%Three macros define parameters from which constants, RM values, or<br>IM data can be constructed:<br>   MP[NAME,octalstring] makes a parameter of NAME;<br>   SP[NAME,P1,P2,P3,P4,P5,P6,P7,P8] makes a parameter NAME equal to the sum<br>of Pn, where the Pn may be parameters or addresses.<br>   NSP[NAME,P1,P2,P3,P4,P5,P6,P7,P8] is ones complement of SP.<br><br>The parameter "NAME" is defined by the integer "NAME!", so it is ok to<br>use "NAME" for a constant as well as a parameter.  However, it is illegal<br>to define constants, addresses, etc. with identical names.<br><br>"Literal" constants such as "322C", "177622C", or "32400C" may be<br>used in mi&rsquo;s without previous definition.<br><br>Alternatively, constants may be constructed from parameters, integers, and<br>addresses using the following macros:<br>   MC[NAME,P1,P2,P3,P4,P5,P6,P7,P8] defines name as a constant with value =<br>sum of parameters Pn;<br>   NMC[NAME,P1,P2,P3,P4,P5,P6,P7,P8] is the ones complement of MC.<br><br>Note:  MC and NMC also define NAME as a parameter.<br>%<br><br>*Fields for initializing 16-bit wide memories<br>F@[E0@,0,3]; F@[E1@,4,17];<br><br>*Macro to initialize (16-bit) variables in the target memory.  This is<br>*done by writing 32100V (i.e., as a literal).<br>M@[V,E1@[#1] E0@[#2]];<br><br>M@[!,0];<br>M@[MP,SET[#1!,#2]];<br><br>M@[PX@,IDF[#1!,#1!,#1]];<br>M@[DPS@,ADD[PX@[#1],PX@[#2],PX@[#3],PX@[#4],PX@[#5],PX@[#6],PX@[#7],PX@[#8]]];<br><br>M@[SP,IFG[#0,11,TMARGS@[#1],<br>  SET[#1!,DPS@[#2,#3,#4,#5,#6,#7,#8,#9]]]];<br><br>M@[NSP,IFG[#0,11,TMARGS@[#1],<br>  SET[#1!,NOT[DPS@[#2,#3,#4,#5,#6,#7,#8,#9]]]]];<br><br>M@[MC,IFG[#0,11,TMARGS@[#1],<br>  SET[#1!,DPS@[#2,#3,#4,#5,#6,#7,#8,#9]]<br>  M@[#1,ADD[#1!]C]]];<br><br>M@[NMC,IFG[#0,11,TMARGS@[#1],<br>  SET[#1!,NOT[DPS@[#2,#3,#4,#5,#6,#7,#8,#9]]]<br>  M@[#1,ADD[#1!]C]]];<br><br>M@[$RSETDISPLO,AND[#2,377]C];<br>M@[$RSETDISPHI,AND[ADD[LSHIFT[#1,14],#2],177400]C];<br><br><br>*For mmmmnnnnC, #1 = nnnn, #2 = mmmm<br>M@[C,IFE[AND[#1,377],0,BS@[1] FF1@[#2] FF2@[RSHIFT[#1,10]],<br>    BS@[0] FF1@[RSHIFT[#2#1,4]] FF2@[AND[#1,17]]] B<br>];<br><br>M@[-C,SUB[0,#2#1]C];<br><br>%Cycler-masker stuff:<br><br>Arguments to LDF and DISPATCH macros are POS and SIZE, where POS is the left<br>bit of the field and SIZE the number of bits in the field, identical to Mesa<br>read-field and write-field descriptors; RB is any R-bus source specifiable<br>without using F1 or F2.<br><br>LDF[RB,POS,SIZE] right-justifies any field.<br>   0</span><span class="tab" val="77"></span><span style="font: 12pt serif">- 17</span><span class="tab" val="77"></span><span style="font: 12pt serif">20  1-bit fields bit 0 to 17<br>  20</span><span class="tab" val="77"></span><span style="font: 12pt serif">- 36</span><span class="tab" val="77"></span><span style="font: 12pt serif">17  2-bit fields bit 0 to 16<br>  37</span><span class="tab" val="77"></span><span style="font: 12pt serif">- 54</span><span class="tab" val="77"></span><span style="font: 12pt serif">16  3-bit fields bit 0 to 15<br>  55</span><span class="tab" val="77"></span><span style="font: 12pt serif">- 71</span><span class="tab" val="77"></span><span style="font: 12pt serif">15  4-bit fields bit 0 to 14<br>  72</span><span class="tab" val="77"></span><span style="font: 12pt serif">-105</span><span class="tab" val="77"></span><span style="font: 12pt serif">14  5-bit fields bit 0 to 13<br> 106</span><span class="tab" val="77"></span><span style="font: 12pt serif">-120</span><span class="tab" val="77"></span><span style="font: 12pt serif">13  6-bit fields bit 0 to 12<br> 121</span><span class="tab" val="77"></span><span style="font: 12pt serif">-132</span><span class="tab" val="77"></span><span style="font: 12pt serif">12  7-bit fields bit 0 to 11<br> 133</span><span class="tab" val="77"></span><span style="font: 12pt serif">-143</span><span class="tab" val="77"></span><span style="font: 12pt serif">11 10-bit fields bit 0 to 10<br> 144</span><span class="tab" val="77"></span><span style="font: 12pt serif">-153</span><span class="tab" val="77"></span><span style="font: 12pt serif">10 11-bit fields bit 0 to  7<br> 154</span><span class="tab" val="77"></span><span style="font: 12pt serif">-162</span><span class="tab" val="77"></span><span style="font: 12pt serif"> 7 12-bit fields bit 0 to  6<br> 163</span><span class="tab" val="77"></span><span style="font: 12pt serif">-170</span><span class="tab" val="77"></span><span style="font: 12pt serif"> 6 13-bit fields bit 0 to  5<br> 171</span><span class="tab" val="77"></span><span style="font: 12pt serif">-175</span><span class="tab" val="77"></span><span style="font: 12pt serif"> 5 14-bit fields bit 0 to  4<br> 176</span><span class="tab" val="77"></span><span style="font: 12pt serif">-201</span><span class="tab" val="77"></span><span style="font: 12pt serif"> 4 15-bit fields bit 0 to  3<br> 202</span><span class="tab" val="77"></span><span style="font: 12pt serif">-204</span><span class="tab" val="77"></span><span style="font: 12pt serif"> 3 16-bit fields bit 0 to  2<br> 205</span><span class="tab" val="77"></span><span style="font: 12pt serif">-206</span><span class="tab" val="77"></span><span style="font: 12pt serif"> 2 17-bit fields bit 0 to  1<br><br>DISPATCH[RB,POS,SIZE] loads APC with a field of SIZE &lt;= 4 bits:<br> 207</span><span class="tab" val="77"></span><span style="font: 12pt serif">-226</span><span class="tab" val="77"></span><span style="font: 12pt serif">20  1-bit fields bit 0 to 17<br> 227</span><span class="tab" val="77"></span><span style="font: 12pt serif">-245</span><span class="tab" val="77"></span><span style="font: 12pt serif">17  2-bit fields bit 0 to 16<br> 246</span><span class="tab" val="77"></span><span style="font: 12pt serif">-263</span><span class="tab" val="77"></span><span style="font: 12pt serif">16  3-bit fields bit 0 to 15<br> 264</span><span class="tab" val="77"></span><span style="font: 12pt serif">-300</span><span class="tab" val="77"></span><span style="font: 12pt serif">15  4-bit fields bit 0 to 14<br><br>RSH[RB,shiftcount] right-shifts RB by shiftcount 1 to 17.<br> uses LDF[RBsource,0,(20 - shiftcount)]  codes<br><br>LSH[RB,shiftcount] left-shifts RB by shiftcount 1 to 17.<br> 301</span><span class="tab" val="77"></span><span style="font: 12pt serif">-317</span><span class="tab" val="77"></span><span style="font: 12pt serif">17 left shifts of 1, ..., 17 bits<br><br>LCY[RB,shiftcount] left-cycles RB by shiftcount 1 to 17.<br> 320</span><span class="tab" val="77"></span><span style="font: 12pt serif">-336</span><span class="tab" val="77"></span><span style="font: 12pt serif">17 left cycles of 1, ..., 17 bits<br><br>RCY[RB,shiftcount] right-cycles RB by shiftcount 1 to 17.<br> uses LCY[RB,(20 - shiftcount)]  codes<br><br>Other strange ones:<br> --</span><span class="tab" val="77"></span><span style="font: 12pt serif">RHMASK[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= LDF[RB,10,10]<br> 337</span><span class="tab" val="77"></span><span style="font: 12pt serif">LHMASK[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & 177400<br> 340</span><span class="tab" val="77"></span><span style="font: 12pt serif">ZERO</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">= 0<br> 341</span><span class="tab" val="77"></span><span style="font: 12pt serif">FIXVA[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RSH[RB,1] & 40100<br> --</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM1[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= LDF[RB,17,1]<br> 342</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM2[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & 2<br> --</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM3[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= LDF[RB,16,2]<br> 343</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM4[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & 4<br> 344</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM5[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & 5<br> 345</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM6[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & 6<br> --</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM7[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= LDF[RB,15,3]<br> 346</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM10[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & 10<br> 347</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM-2[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & -2<br> 350</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM-3[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & -3<br> 351</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM-4[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & -4<br> 352</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM-5[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & -5<br> 353</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM-6[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & -6<br> 354</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM-7[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & -7<br> 355</span><span class="tab" val="77"></span><span style="font: 12pt serif">FORM-10[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= RB & -10<br> 356</span><span class="tab" val="77"></span><span style="font: 12pt serif">NIB0RSH8[RB]</span><span class="tab" val="77"></span><span style="font: 12pt serif">= (RB rshift 10) & 360<br>%<br><br>M@[ILSIZ@,ER[Illegal.SIZE,2]];<br>M@[ILPS@,ER[Illegal.POS+SIZE,2]];<br><br>M@[LDF,IFG[ADD[#2,#3],20,ILPS@[],IFG[1,#3,ILSIZ@[],<br>  SET[Z@,ADD[#2,IFG[#3,7,<br>   SELECT[SUB[#3,10],1533,1544,1554,1563,1571,1576,1602,1605],<br>   SELECT[#3,100000,1400,1420,1437,1455,1472,1506,1521]]]]<br>  BSF@[Z@] #1]]];<br><br>*Impose register interlock only for this one<br>M@[DISPATCH,SET[RTNILL@,1]<br>  IFG[#3,4,ILSIZ@[],IFG[ADD[#2,#3],20,ILPS@[],<br>      SET[Z@,ADD[#2,SELECT[#3,100000,1607,1627,1646,1664]]]<br>  BSF@[Z@] A&larr;#1]]];<br><br>M@[RSH,IFG[#2,17,TBIG@[RSH],IFG[1,#2,TSMALL@[RSH],<br> SET[Z@,IFG[#2,7,SELECT[SUB[#2,10],1533,1521,1506,1472,1455,1437,1420,1400],<br>     SELECT[#2,100000,1605,1602,1576,1571,1563,1554,1544]]]<br>  BSF@[Z@] #1]]];<br><br>M@[LSH,IFG[#2,17,TBIG@[LSH],IFG[1,#2,TSMALL@[LSH],<br>    BSF1@[74] FF2@[#2] #1]]];<br><br>M@[RCY,IFG[#2,17,TBIG@[RCY],IFG[1,#2,TSMALL@[RCY],<br>    BSF1@[75] FF2@[SUB[17,#2]] #1]]];<br><br>M@[LCY,IFG[#2,17,TBIG@[LCY],IFG[1,#2,TSMALL@[LCY],<br>    BSF1@[75] FF2@[SUB[#2,1]] #1]]];<br><br>M@[RHMASK,BSF1@[66] FF2@[3] #1 ];<br><br>M@[LHMASK,BSF1@[75] FF2@[17] #1 ];<br><br>M@[ZERO,BSF1@[76] FF2@[0] A];<br><br>M@[FIXVA,BSF1@[76] FF2@[1] #1];<br>M@[FORM1,LDF[#1,17,1]];<br>M@[FORM2,BSF1@[76] FF2@[2] #1];<br>M@[FORM3,LDF[#1,16,2]];<br>M@[FORM4,BSF1@[76] FF2@[3] #1];<br>M@[FORM5,BSF1@[76] FF2@[4] #1];<br>M@[FORM6,BSF1@[76] FF2@[5] #1];<br>M@[FORM7,LDF[#1,15,3]];<br>M@[FORM10,BSF1@[76] FF2@[6] #1];<br>M@[FORM-2,BSF1@[76] FF2@[7] #1];<br>M@[FORM-3,BSF1@[76] FF2@[10] #1];<br>M@[FORM-4,BSF1@[76] FF2@[11] #1];<br>M@[FORM-5,BSF1@[76] FF2@[12] #1];<br>M@[FORM-6,BSF1@[76] FF2@[13] #1];<br>M@[FORM-7,BSF1@[76] FF2@[14] #1];<br>M@[FORM-10,BSF1@[76] FF2@[15] #1];<br>M@[NIB0RSH8,BSF1@[76] FF2@[16] #1];<br><br>SET[RL0@,177777]; SET[RL1@,177777];<br>SET[RL2@,177777]; SET[RL3@,177777];<br>SET[RL@,177777];<br>SET[CTASK@,0]; SET[QTASK@,0]; SET[SUBTSK@,0]; SET[RMBASE@,0];<br><br>M@[SETTASK,SET[CTASK@,#1]<br>  IFG[CTASK@,17,ER[Illegal.SETTASK,2],<br>    SELECT[QTASK@,SET[RL0@,RL@],SET[RL1@,RL@],SET[RL2@,RL@],SET[RL3@,RL@]]<br>    SET[QTASK@,RSHIFT[CTASK@,2]] SET[SUBTSK@,AND[3,CTASK@]]<br>    SET[RMBASE@,LSHIFT[QTASK@,6]]<br>    SET[RL@,SELECT[QTASK@,RL0@,RL1@,RL2@,RL3@]]]];<br><br>%RM addresses used as sources/destinations execute the RSRC@/RSINK@ macros.<br>RM address is legal if top two bits match QTASK and either the next two<br>address bits are non-0 or the SUBTSK is 0.  Below, unmatching quadtask causes<br>a "Value won&rsquo;t fit" error on the field store into RSEL@; the ILLRA@ macro<br>is evaluated when a task ne 0 mod 4 illegally accesses 0-17 in the RM region.<br>Note that RSEL[0:1] must be complemented for the hardware.<br>%<br>M@[ILLRA@,ER[#1.in.0.to.17.of.RM.region.unaddressable.by.task.,2,CTASK@]];<br><br>M@[RSINK@,MIRMOD@[0] SET[Z@,XOR[IP[#1],RMBASE@,60]]<br>  RX@[AND[Z@,3]] RSEL@[RSHIFT[Z@,2]]<br>  IFG[Z@,57,IFE[SUBTSK@,0,,ILLRA@[#1]]] LR@[1] LU&larr;];<br><br>M@[RSRC@,MIRMOD@[0] SET[Z@,XOR[IP[#1],RMBASE@,60]]<br>  RX@[AND[Z@,3]] RSEL@[RSHIFT[Z@,2]]<br>  IFG[Z@,57,IFE[SUBTSK@,0,,ILLRA@[#1]]] RB];<br><br><br>%Memory declarations must have names and sizes agreeing with those in<br>Midas, except that IM must agree with the form expected by MicroD.<br>%<br>M@[W@,];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Dummy macro required for memory definitions<br>MEMORY[IM,124,10000,W@,W@];<br>MEMORY[RM,20,400,RSRC@,RSINK@];<br>MEMORY[IMLOCK,1,10000,W@,W@];<br>MEMORY[VERSION,20,1,W@,W@];<br>*MEMORY[DISP,40,10000,W@,W@];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Dispatch table info passed to MicroD<br>MEMORY[IMMASK,24,10000,W@,W@];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Fake memory for IM placement constraints<br><br>%Second arg of LIST controls listing of memories as follows:<br>1 = (TAG) nnnn nnnn nnnn ...<br>2 = (TAG) F1&larr;3, F2&larr;4, ...<br>4 = numerically-ordered list of address symbols<br>10 = alphabetically-ordered list of address symbols<br>20 = (TAG) 1nnnnn 1nnnnn ... (16-bit printout iff 1 set also)<br>LISTFIELDS overrules the 1 and 20 numeric printout modes<br>%<br>*List IM in 20-bit units, RM as single word<br>F@[V0@,0,17]; F@[V1@,20,37];<br>LISTFIELDS[IM,(V0@[1] V1@[1] JA1@[1] W0@[1] W1@[1] W2@[1])];<br>LISTFIELDS[RM,V0@[1]];<br>LISTFIELDS[IMMASK,CONMSK@[1] DTLEN@[1]];<br>LIST[IM,27]; LIST[RM,25]; LIST[,25];<br><br>%RM words are allocated in two steps.  First, the group of 100 registers<br>that must contain the ones being allocated is declared by SETTASK.<br><br>Then registers in that group of 100 are allocated as follows:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[FOO,23,p1,...,p7];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Creates FOO = RM 23, value sum of params<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[FOO,23];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Creates FOO = RM 23, no value<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[FOO];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Creates FOO at last location + 1<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[FOO,,17575];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Creates address FOO at location after<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*last one allocated with value 17575<br>These macros leave the integer RLi, where i = 0 to 3 (the region)<br>bound to the last displacement allocated, and the integer RL is always<br>equal to RLi for the current region.<br>%<br><br>M@[RV,SET[RL@,IFSE[#2,,ADD[1,RL@],#2]]<br>  IFG[RL@,77,ER[RM.ovf,2]]<br>  IFG[#0,2,RM[RLC@,ADD[RMBASE@,RL@]]<br>      RLC@[#1: V0@[DPS@[#3,#4,#5,#6,#7,#8,#9]]],<br>    RM[#1,ADD[RMBASE@,RL@]]]<br>];<br><br>*Macros to define groups of four/two RM registers.<br>M@[RV4,RV[#1,#5] RV[#2,Add[1,#5]] RV[#3,Add[2,#5]] RV[#4,Add[3,#5]]];<br>M@[RV2,RV[#1,#3] RV[#2,Add[1,#3]]];<br><br>SET[NONQUADOK@,0];<br>M@[NONQUADOK,SET[NONQUADOK@,1]]; *Suppress next "Not.Quadaligned" warning<br>M@[MERNQ@,IFE[NONQUADOK@,0,ER[WARNING:.#1.not.quadaligned,3],<br>  SET[NONQUADOK@,0]]];<br>M@[QRS@,SET[Z@,XOR[60,IP[#1],RMBASE@]]<br>  IFE[AND[Z@,3],0,IFG[Z@,77,ILLRA@[#1],MR@[RSHIFT[ADD[Z@,100],2]]],MERNQ@[]]<br>RB];<br><br>*PCF[RMADDR], SB[RMADDR], and DB[RMADDR] are also A sources<br>M@[PCF,RX@[0] QRS@[#1]];<br>M@[SB, RX@[1] QRS@[#1]];<br>M@[DB, RX@[2] QRS@[#1]];<br><br>*Other register sources<br>*(open-coded MRS@[x] and LDF[RB,P,S] here for speed)<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*MRS@ LDF[RB,x,y]<br>M@[SSTKP&NSTKP,RX@[3] MR@[34] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*103<br>  M@[SSTKP,RX@[3]MR@[34]BSF1@[65]FF2@[13] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*103</span><span class="tab" val="77"></span><span style="font: 12pt serif">0,10<br>  M@[NSTKP,RX@[3]MR@[34]BSF1@[66]FF2@[3] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*103</span><span class="tab" val="77"></span><span style="font: 12pt serif">10,10<br>*aluresult = ovf,car,=0,&lt;0<br>**Note that SALUF is read COMPLEMENTED but not named that way here<br>M@[ALURESULT&NSALUF,RX@[3]MR@[35] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*107<br>  M@[ALURESULT,RX@[3]MR@[35]BSF1@[63]FF2@[1] A];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*107</span><span class="tab" val="77"></span><span style="font: 12pt serif">4,4<br>  M@[NSALUF,RX@[3]MR@[35]BSF1@[66]FF2@[3] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*107</span><span class="tab" val="77"></span><span style="font: 12pt serif">10,10<br>M@[MEMSYNDROME,RX@[3]MR@[36] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*113<br>M@[MEMERROR,RX@[3]MR@[37] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*117<br>M@[CYCLE&PCXF,RX@[3]MR@[31] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*127<br>  M@[CYCLECONTROL,RX@[3]MR@[31]BSF1@[65]FF2@[13] A];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*127</span><span class="tab" val="77"></span><span style="font: 12pt serif">0,10<br>    M@[DBXREG,RX@[3]MR@[31]BSF1@[62]FF2@[15] A];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*127</span><span class="tab" val="77"></span><span style="font: 12pt serif">0,4<br>    M@[MWXREG,RX@[3]MR@[31]BSF1@[63]FF2@[1] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*127</span><span class="tab" val="77"></span><span style="font: 12pt serif">4,4<br>  M@[PCXREG,RX@[3]MR@[31]BSF1@[63]FF2@[5] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*127</span><span class="tab" val="77"></span><span style="font: 12pt serif">10,4<br>  M@[PCFREG,RX@[3]MR@[31]BSF1@[63]FF2@[11] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*127</span><span class="tab" val="77"></span><span style="font: 12pt serif">14,4<br>    M@[PCF.WORD,RX@[3]MR@[31]BSF1@[62]FF2@[13] A];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*127</span><span class="tab" val="77"></span><span style="font: 12pt serif">14,3<br>M@[PRINTER,RX@[3]MR@[31]FF2@[0] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*127<br>M@[DBSB,RX@[3]MR@[32]FF2@[0] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*133<br>M@[TIMER,RX@[3]MR@[32] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*133<br>M@[RS232,RX@[3]MR@[33] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*137<br>M@[MNBR,FF2@[0]RX@[3]MR@[33] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*137<br>M@[APCTASK&APC,RX@[3]MR@[24] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*143<br>  M@[APCTASK,RX@[3]MR@[24]BSF1@[62]FF2@[15] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*143</span><span class="tab" val="77"></span><span style="font: 12pt serif">0,4<br>  M@[APC,RX@[3]MR@[24]BSF1@[67]FF2@[15] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*143</span><span class="tab" val="77"></span><span style="font: 12pt serif">4,14<br>M@[CTASK&NCIA,RX@[3]MR@[25] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*147<br>  M@[CTASK,RX@[3]MR@[25]BSF1@[62]FF2@[15] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*147</span><span class="tab" val="77"></span><span style="font: 12pt serif">0,4<br>  M@[NCIA,RX@[3]MR@[25]BSF1@[67]FF2@[15] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*147</span><span class="tab" val="77"></span><span style="font: 12pt serif">4,14<br>M@[CSDATA,RX@[3]MR@[26] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*153<br>M@[PAGE&PAR&BOOT,RX@[3]MR@[27] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*157<br>  M@[PAGE,RX@[3]MR@[27]BSF1@[62]FF2@[15] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*157</span><span class="tab" val="77"></span><span style="font: 12pt serif">0,4<br>  M@[PARITY,RX@[3]MR@[27]BSF1@[63]FF2@[1] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*157</span><span class="tab" val="77"></span><span style="font: 12pt serif">4,4<br>  M@[BOOTREASON,RX@[3]MR@[27]BSF1@[66]FF2@[3] A];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*157</span><span class="tab" val="77"></span><span style="font: 12pt serif">10,10<br><br>%To get a multi-field word using only one specification , use <br>GETRSPEC[mrs address].  Thus to load T with APCTASK and APC:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; GETRSPEC[143];<br>%<br>M@[GETRSPEC,MR@[XOR[RSHIFT[#1,2],14]] RX@[AND[#1,3]] A];<br><br>*StkP sources/destinations:<br>*(open-coded MRS@[x] here for speed)<br>M@[STACK,RX@[3] MR@[20] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*MRS@[163]<br>M@[STACK&larr;,RX@[3] MR@[20] LR@[1] LU&larr;];<br>M@[STACK&+1,RX@[3] MR@[21] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*167<br>M@[STACK&+1&larr;,RX@[3] MR@[21] LR@[1] LU&larr;];<br>M@[STACK&-1,RX@[3] MR@[22] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*173<br>M@[STACK&-1&larr;,RX@[3] MR@[22] LR@[1] LU&larr;];<br>M@[STACK&-2,RX@[3] MR@[23] A];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*177<br>M@[STACK&-2&larr;,RX@[3] MR@[23] LR@[1] LU&larr;];<br>M@[STACK&+2,RX@[3] MR@[20] F2@[3] A];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*163, STACKSHIFT<br>M@[STACK&+2&larr;,RX@[3] MR@[20] F2@[3] LR@[1] LU&larr;];<br>M@[STACK&+3,RX@[3] MR@[21] F2@[3] A];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*167, STACKSHIFT<br>M@[STACK&+3&larr;,RX@[3] MR@[21] F2@[3] LR@[1] LU&larr;];<br>M@[STACK&-3,RX@[3] MR@[23] F2@[3] A];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*177, STACKSHIFT<br>M@[STACK&-3&larr;,RX@[3] MR@[23] F2@[3] LR@[1] LU&larr;];<br><br>%Functions are divided into the following classes:<br><br>1.  Group A (currently none) and Group B--only in regular mi&rsquo;s,<br>    use F1 and F2.<br>2.  F1 only--only in regular mi&rsquo;s.<br>3.  F2 only--either memory reference or regular mi&rsquo;s.<br>%<br>*Group B functions<br>M@[SPAREFUNCTION,FF1@[7] FF2@[0] ?];<br>M@[RESETERRORS,FF1@[7] FF2@[1] ?];<br>M@[INCMPANEL,FF1@[7] FF2@[2] ?];<br>M@[CLEARMPANEL,FF1@[7] FF2@[3] ?];<br>M@[GENSRCLOCK,FF1@[7] FF2@[4] ?];<br>M@[RESETWDT,FF1@[7] FF2@[5] ?];<br>M@[BOOT,FF1@[7] FF2@[6] ?];<br>M@[SETFAULT,FF1@[7] FF2@[7] ?];<br>M@[APCTASK&APC&larr;,FF1@[7] FF2@[10] SET[RTNILL@,1] A&larr;];<br>M@[RESTORE,FF1@[7] FF2@[11] A&larr;];<br>M@[RESETFAULT,FF1@[7] FF2@[12] ?];<br>M@[USECTASK,FF1@[7] FF2@[13] ?];<br>M@[WRITECS0&2,FF2@[14] FF1@[7] JC@[6] ?];<br>M@[WRITECS1,FF2@[15] FF1@[7] JC@[6] ?];<br>M@[READCS,FF2@[16] FF1@[7] JC@[6] ?];<br>M@[D0OFF,FF1@[7] FF2@[17] ?];<br><br>*F1 only<br>*00 take an RM address as argument<br>M@[BBFA,FF2@[0] PF[ALF@,3] FF1@[00] #1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*A dispatch<br>M@[RS232&larr;,FF1@[1] B&larr; ];<br>*02-03 take an RM address as argument<br>M@[LOADTIMER,FF1@[2] A&larr;#1 ];<br>M@[ADDTOTIMER,FF1@[3] A&larr;#1 ];<br>*04 unused<br>M@[LOADPAGE,FF1@[5] FF2@[#1] SWPAGE@[1] IFE[CHPGFLG@,1,CHPAGE@[1]]<br>  SET[CHPGFLG@,2]];<br>*06 = Group A; 07 = Group B; 10 = no-op<br>*11-14 take an RM address as argument<br>M@[WFA,FF1@[11] #1];<br>M@[BBFB,FF1@[12] #1];<br>M@[WFB,FF1@[13] #1];<br>M@[RF,FF1@[14] #1];<br>M@[BBFBX,FF1@[15] #1];<br>%NEXTINST and NEXTDATA usually require a call in JC@ so that a quadword ovf<br>trap will return to the mi containing the NEXTINST/NEXTDATA; the "ODDCALL"<br>bit is set by these forms so that MicroD will not require the successor to<br>be at .+1.  However, sometimes one of the following situations exists:<br> (1) qovf trap is impossible (e.g., because PCF is odd);<br> (2) the value already in TPC is an appropriate return from a qovf trap;<br> (3) a real call is contained in the same mi.<br>In these situations, the CNEXTINST/CNEXTDATA forms are used which impose no<br>constraint upon the branch clause in the same mi.<br>SKIPDATA is like NEXTDATA and CSKIPDATA like CNEXTDATA except that they<br>discard the next byte.<br>%<br>M@[NEXTINST,FF1@[16] RETCL@[1] ODDCALL@[1] JC@[5] RX@[0] QRS@[#1]];<br>M@[CNEXTINST,FF1@[16] RX@[0] QRS@[#1]];<br>M@[NEXTDATA,FF1@[17] RETCL@[1] ODDCALL@[1] JC@[5] RX@[0] QRS@[#1]];<br>M@[CNEXTDATA,FF1@[17] RX@[0] QRS@[#1]];<br>M@[SKIPDATA,FF1@[17] JC@[5] ODDCALL@[1] ?];<br>M@[CSKIPDATA,FF1@[17] ?];<br><br>*F2 only<br>M@[REGSHIFT,FF2@[0] ?];<br>M@[STKP&larr;,FF2@[1] A&larr;];<br>M@[FREEZERESULT,FF2@[2] ?];<br>*3 is STACKSHIFT (used only by STACK, STACK&larr;, etc.)<br>M@[IOSTROBE,FF2@[3] ?]; *same as STACKSHIFT<br>M@[CYCLECONTROL&larr;,FF2@[4] A&larr;];<br>M@[SB&larr;,FF2@[5] A&larr;];<br>M@[DB&larr;,FF2@[6] A&larr;];<br>*7 is ???<br>*10 is BRANCHSHIFT<br>M@[SALUF&larr;,FF2@[11] B&larr; ];<br>*12 is a no-op<br>M@[MNBR&larr;,FF2@[13] A&larr; ];<br>M@[PCF&larr;,FF2@[14] A&larr; ];<br>M@[RESETMEMERRS,FF2@[15] ?];<br>M@[USECOUTASCIN,FF2@[16] ?];<br>M@[PRINTER&larr;,FF2@[17] A&larr; ];<br><br>%Memory reference clauses are encoded in one of the following forms:<br><br>PFETCHn[BaseReg,RAddr,F2];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*n = 1, 2, 4<br>PSTOREn[BaseReg,RAddr,F2];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*n = 1, 2, 4<br>IOFETCHn[BaseReg,Device,F2];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*n = 4, 20<br>IOSTOREn[BaseReg,Device,F2];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*n = 4, 20<br>XMAP[BaseReg,RAddr,F2];<br>*INPUT, OUTPUT, or READPIPE DevAddr is (H2[10,13] or CTASK[0,3]),,H2[14,17].<br>*RAddr is assembled into the srcdest mi field; OtherRAddr is not used by<br>*the operation, but will be assembled into the BaseReg field if supplied<br>*(useful for doing R&lt;0 b.c. in same mi or for ALU tests in the next mi).<br>*F2 is not used by READPIPE but will be assembled if supplied.<br>INPUT[RAddr,F2,OtherRAddr];<br>OUTPUT[RAddr,F2,OtherRAddr];<br>READPIPE[RAddr,F2,OtherRAddr];<br>REFRESH[RAddr];<br><br>BaseReg must normally be even and meet the same conditions as RSRC@/RSINK@;<br>in the event the programmer really wants to use an odd base register, which<br>will use the same RM word for both halves of the base register, he writes<br>ODDPFETCHn, ODDPSTOREn, ODDIOFETCHn, ODDIOSTOREn, or ODDXMAP.<br><br>raddr is legal if either it is STACK or (1) every 0 in the top four bits<br>must have a matching 0 in CTASK; (2) for PFETCH2/PSTORE2 raddr must be even;<br>for PFETCH4/PSTORE4 raddr must be quadaligned.<br><br>D0Lang outputs MEMINS=1; RMOD=1 if displacement from optional F2 arg<br>else RMOD=0 if displacement from T; RSEL=BaseReg & 77; TYPE=kind of reference;<br>SRCDES=0 if STACK else SRCDES=raddr.<br>%<br>M@[WN@,ER[Wrong.number.args.for.reference,2]];<br>M@[OB@,ER[Base.register.#1.is.odd,2]];<br>* #1 = basereg, #2 = type, #3 = nargs, #4 = optional F2<br>M@[BR@,TYPE@[#2] MIRMOD@[#3]<br>  SET[Z@,XOR[IP[#1],RMBASE@,60]] RX@[AND[Z@,3]] RSEL@[RSHIFT[Z@,2]]<br>  IFG[Z@,57,IFE[SUBTSK@,0,,ILLRA@[#1]]]<br>  SELECT[#3,WN@[],WN@[],,FF2@[#4]]<br>  IFE[FVAL[RX1@],1,OB@[#1]]<br>];<br><br>M@[EB@,ER[Base.register.#1.is.even,2]];<br>M@[OBR@,TYPE@[#2] MIRMOD@[#3]<br>  SET[Z@,XOR[IP[#1],RMBASE@,60]] RX@[AND[Z@,3]] RSEL@[RSHIFT[Z@,2]]<br>  IFG[Z@,57,IFE[SUBTSK@,0,,ILLRA@[#1]]]<br>  SELECT[#3,WN@[],WN@[],,FF2@[#4]]<br>  IFE[FVAL[RX1@],0,EB@[#1]]<br>];<br><br>M@[MERE0@,ER[#1=0..stack.will.be.used,2]];<br>M@[MEMR0@,IFSE[#1,STACK,SRCDES@[0],SRCDES@[#1]<br>  IFE[IP[#1],0,MERE0@[#1],<br>    IFE[OR[FVAL[SRDS03@],CTASK@],FVAL[SRDS03@],,ILLRA@[#1]]]]];<br><br>SET[ODDOK@,0];<br>M@[ODDOK,SET[ODDOK@,1]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Suppress next "Not.Even" warning<br>M@[MERNE@,IFE[ODDOK@,0,ER[WARNING:.#1.not.even,3],SET[ODDOK@,0]]];<br>M@[MEMR1@,IFSE[#1,STACK,SRCDES@[0],SRCDES@[#1]<br>  IFE[IP[#1],0,MERE0@[#1],<br>    IFE[OR[FVAL[SRDS03@],CTASK@],FVAL[SRDS03@],<br>      IFE[FVAL[SRDS7@],0,,MERNE@[#1]],ILLRA@[#1]]]]];<br><br>M@[MEMR3@,IFSE[#1,STACK,SRCDES@[0],SRCDES@[#1]<br>  IFE[IP[#1],0,MERE0@[#1],<br>    IFE[OR[FVAL[SRDS03@],CTASK@],FVAL[SRDS03@],<br>      IFE[FVAL[SRDS67@],0,,MERNQ@[#1]],ILLRA@[#1]]]]];<br><br>M@[IOUD@,ER[#1.unaddressable.device,2]];<br>M@[IODV@,SRCDES@[#1] IFE[OR[CTASK@,FVAL[SRDS03@]],FVAL[SRDS03@],,IOUD@[#1]]];<br><br>M@[ANYBR@,SET[Z@,XOR[IP[#1],RMBASE@,60]] RX@[AND[Z@,3]] RSEL@[RSHIFT[Z@,2]]<br>  IFG[Z@,57,IFE[SUBTSK@,0,,ILLRA@[#1]]]];<br><br>*type 0 is unused<br>M@[PFETCH1,  BR@[#1, 4,#0,#3] MEMR0@[#2] ?];<br>M@[PFETCH2,  BR@[#1, 5,#0,#3] MEMR1@[#2] ?];<br>M@[PFETCH4,  BR@[#1, 6,#0,#3] MEMR3@[#2] ?];<br>M@[PSTORE1,  BR@[#1,10,#0,#3] MEMR0@[#2] ?];<br>M@[PSTORE2,  BR@[#1,11,#0,#3] MEMR1@[#2] ?];<br>M@[PSTORE4,  BR@[#1,12,#0,#3] MEMR3@[#2] ?];<br>M@[XMAP,     BR@[#1,16,#0,#3] MEMR0@[#2] ?];<br>M@[IOFETCH4, BR@[#1, 1,#0,#3] IODV@[#2] ?];<br>M@[IOFETCH16,BR@[#1,14,#0,#3] IODV@[#2] ?];<br>M@[IOSTORE4, BR@[#1,15,#0,#3] IODV@[#2] ?];<br>M@[IOSTORE16,BR@[#1,17,#0,#3] IODV@[#2] ?];<br>*For T addressing in conjunction with an OtherRAddr, leave 2nd arg blank.<br>M@[INPUT,TYPE@[7] MIRMOD@[IFG[#0,1,IFSE[#2,,2,FF2@[#2]3],2]]<br>  MEMR0@[#1] IFG[#0,2,ANYBR@[#3]] ?];<br>M@[OUTPUT,TYPE@[13] MIRMOD@[IFG[#0,1,IFSE[#2,,2,FF2@[#2]3],2]]<br>  MEMR0@[#1] IFG[#0,2,ANYBR@[#3]] ?];<br>M@[READPIPE,TYPE@[2] MIRMOD@[IFG[#0,1,IFSE[#2,,2,FF2@[#2]3],2]]<br>  MEMR0@[#1] IFG[#0,2,ANYBR@[#3]] ?];<br>*No task checks on REFRESH; force displacement of 0<br>M@[REFRESH,FF2@[0] RX@[AND[IP[#1],3]]<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">MRTYP@[XOR[AND[360,LSHIFT[IP[#1],2]],1703]]?];<br><br>M@[ODDPFETCH1,  OBR@[#1, 4,#0,#3] MEMR0@[#2] ?];<br>M@[ODDPFETCH2,  OBR@[#1, 5,#0,#3] MEMR1@[#2] ?];<br>M@[ODDPFETCH4,  OBR@[#1, 6,#0,#3] MEMR3@[#2] ?];<br>M@[ODDPSTORE1,  OBR@[#1,10,#0,#3] MEMR0@[#2] ?];<br>M@[ODDPSTORE2,  OBR@[#1,11,#0,#3] MEMR1@[#2] ?];<br>M@[ODDPSTORE4,  OBR@[#1,12,#0,#3] MEMR3@[#2] ?];<br>M@[ODDXMAP,     OBR@[#1,16,#0,#3] MEMR0@[#2] ?];<br>M@[ODDIOFETCH4, OBR@[#1, 1,#0,#3] IODV@[#2] ?];<br>M@[ODDIOFETCH16,OBR@[#1,14,#0,#3] IODV@[#2] ?];<br>M@[ODDIOSTORE4, OBR@[#1,15,#0,#3] IODV@[#2] ?];<br>M@[ODDIOSTORE16,OBR@[#1,17,#0,#3] IODV@[#2] ?];<br><br>EQ@[IOFETCH20,IOFETCH16]; EQ@[IOSTORE20,IOSTORE16];<br>EQ@[ODDIOFETCH20,ODDIOFETCH16]; EQ@[ODDIOSTORE20,ODDIOSTORE16];<br><br>*Control stuff:<br><br>IM[.,0];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Location counter for IM<br>M@[.-3,SUB[IP[.],3]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">M@[.+3,ADD[IP[.],3]];<br>M@[.-2,SUB[IP[.],2]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">M@[.+2,ADD[IP[.],2]];<br>M@[.-1,SUB[IP[.],1]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">M@[.+1,ADD[IP[.],1]];<br><br>M@[ALUERRTST,IFE[TSKFLG@,1,ER[Alu.results.tested.following.RETURN,2]]];<br><br>*Macros insert "~@" or "~" before BC names in the program for type checks.<br>*Regular BC&rsquo;S</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Complementary<br>M@[~ALU#0,CND@[1] JC@[0] JA7@[0] ALUERRTST];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@ALU=0,~ALU#0];<br>M@[~CARRY,CND@[1] JC@[0] JA7@[1] ALUERRTST];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@CARRY&rsquo;,~CARRY];<br>M@[~ALU&lt;0,CND@[1] JC@[1] JA7@[0] ALUERRTST];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@ALU&gt;=0,~ALU&lt;0];<br>M@[~H2BIT8&rsquo;,CND@[1] JC@[1] JA7@[1]];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@H2BIT8,~H2BIT8&rsquo;];<br>M@[~R&lt;0,CND@[1] JC@[2] JA7@[0]];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@R&gt;=0,~R&lt;0];<br>M@[~R ODD,CND@[1] JC@[2] JA7@[1]];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@R EVEN,~R ODD];<br>M@[~IOATTEN&rsquo;,CND@[1] JC@[3] JA7@[0]];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@IOATTEN,~IOATTEN&rsquo;];<br>M@[~MB,CND@[1] JC@[3] JA7@[1]];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@MB&rsquo;,~MB];<br><br>M@[~INTPENDING,CND@[1]JC@[0] JA7@[0] FF2@[10]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@INTPENDING&rsquo;,~INTPENDING];<br>M@[~OVF&rsquo;,CND@[1]JC@[0]JA7@[1]FF2@[10]ALUERRTST];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@OVF,~OVF&rsquo;];<br>M@[~BPCCHK,CND@[1] JC@[1] JA7@[0] FF2@[10]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@BPCCHK&rsquo;,~BPCCHK];<br>*M@[~UNUSED,CND@[1] JC@[1] JA7@[1] FF2@[10]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@UNUSED&rsquo;,~UNUSED];<br>M@[~QUADOVF,CND@[1] JC@[2] JA7@[0] FF2@[10]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@QUADOVF&rsquo;,~QUADOVF];<br>M@[~TIMEOUT,CND@[1] JC@[2] JA7@[1] FF2@[10]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@TIMEOUT&rsquo;,~TIMEOUT];<br>M@[~,];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">EQ@[~@,~];<br><br>%Branch and goto macros are now identical and interchangeable.  If the next<br>mi to be executed is off-page, the macro must have a "P" following it.<br>Thus use GOTOP[xyz] when the page of xyz differs from that of the current<br>mi (only happens when the mi preceding the current one did LOADPAGE).<br>%<br><br>M@[DBLGOTO,IDF[~@#3,W1@[#1] W2@[#2] ~@#3,W2@[#1] W1@[#2] ~#3]];<br>M@[DBLGOTOP,CHPAGE@[1] DBLGOTO[#1,#2,#3]];<br><br>*Set only the high and low bits of JC so that a CS rd/wr can overrule with<br>*the value 6.<br>M@[GOTO,IFSE[#2,,W1@[#1] JC0@[1] JC2@[0],<br>    IDF[~@#2, W1@[#1] ~@#2, W2@[#1] ~#2 ]]];<br>M@[GOTOP,CHPAGE@[1] GOTO[#1,#2]];<br>M@[SKIP,GOTO[.+2,#1]];<br>M@[SKIPP,GOTOP[.+2,#1]];<br><br>*Calls return to (caller&rsquo;s address + 1) mod 20.<br>M@[CALL,IFSE[#2,,RETCL@[1] JC@[5] W1@[#1],NOARGS@[CALL&rsquo;s]]?];<br>M@[CALLP,CHPAGE@[1] CALL[#1,#2]];<br>M@[CALLX,ODDCALL@[1] CALL[#1]];<br><br>*TASK does a CALL[.+1] in the current mi and forces the next<br>*mi inline to do a RETURN.<br>M@[TASK, RETCL@[1] JC@[5] W2@[.+2] SET[TSKFLG@,4]];<br><br>M@[RETN@,IFSE[#1,,RETCL@[2] JC@[6] JA7@[#2],NOARGS@[#3&rsquo;s]]];<br>M@[RETURN,RETN@[#1#2,0,RETURN]];<br>M@[NIRET,RETN@[#1#2,1,NIRET]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Used after NextInst<br><br>*External References--argument is an integer<br>M@[GOTOEXTERNAL,IFSE[#2#3,,<br>  RETCL@[2] JC@[4] JA1@[AND[3,RSHIFT[#1,6]]] JA2@[AND[#1,77]],<br>  ER[No.conditional.external.goto,2]]];<br>M@[CALLEXTERNAL,IFSE[#2#3,,<br>  RETCL@[3] JC@[5] JA1@[AND[3,RSHIFT[#1,6]]] JA2@[AND[#1,77]],<br>  ER[no.args.allowed.in.external.call,2]]];<br>M@[LOADPAGEEXTERNAL,FF1@[5] FF2@[#1]];<br><br>M@[DISP,IFSE[#2#3,,JC@[7] W1@[#1],NOARGS@[DISP&rsquo;s]]?];<br>M@[DISPP,CHPAGE@[1] DISP[#1,#2,#3]];<br><br>*To prevent MicroD allocation in reserved locations:<br>*  IMRESERVE[page #,first address,number of addresses]<br>F@[LOCK@,0,0]; IMLOCK[LK@,0];<br>M@[IMRESERVE,IMLOCK[LK@,ADD[LSHIFT[#1,10],#2]] REPEAT[#3,LK@[LOCK@[1]]]];<br>M@[IMUNRESERVE,IMLOCK[LK@,ADD[LSHIFT[#1,10],#2]] REPEAT[#3,LK@[LOCK@[0]]]];<br><br>**??Check this??<br>M@[MIDASINIT,IMRESERVE[0,0,2] IMRESERVE[0,100,21] IMRESERVE[17,0,400]];<br><br>%DISPTABLE[LENGTH,MASK,VALUE] appearing in a statement causes that<br>statement to begin a group of LENGTH consecutively-placed statements,<br>1 &lt;= LENGTH &lt;= 20.  The first statement is placed so that<br>&lt;address AND MASK&gt; = VALUE.  MASK defaults to 17 and VALUE to 0.<br>Note: LENGTH+VALUE must be &lt;= 20.<br>%<br>IMMASK[MASKLC@,0];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Location counter for IMMASK<br>M@[DISPTABLE,SET[Z@,SUB[#1,1]]<br>  IFE[AND[Z@,177760],0,,ER[DISPTABLE.ill.length]]<br>  SET[Z1@,#2] IFE[Z1@,0,SET[Z1@,17]]<br>  IFE[AND[#3,Z1@],#3,,ER[DISPTABLE.impossible.constraint]]<br>  SET[Z2@,0] SET[Z3@,0]<br>  REPEAT[20,IFE[AND[Z2@,Z1@],#3,SET[Z3@,OR[Z3@,RSHIFT[100000,Z2@]]]]<br>    SET[Z2@,ADD[Z2@,1]]]<br>  IMMASK[MASKLC@,IP[.]] MASKLC@[CONMSK@[Z3@] DTLEN@[Z@]]<br>];<br><br>*The ONPAGE macro changes the default page number for address assignment.<br>M@[ONPAGE,DEFAULT[IM,PGE@[#1]]];<br><br>*Force absolute location and change default page<br>M@[AT,@W0@[1] W0@[ADD[#1,#2]]<br>  DEFAULT[IM,PGE@[RSHIFT[ADD[#1,#2],10]]]];<br><br>M@[OPCODE,@W0@[1] W0@[ADD[2001,LSHIFT[#1,2]]]<br>  DEFAULT[IM,PGE@[ADD[4,RSHIFT[#1,6]]]]];<br><br>*LOCA[Name,Page,Offset] creates an integer Name pointing at (Page*400)+Offset<br>M@[LOCA,SET[#1,ADD[LSHIFT[#2,10],#3]]];<br><br>*HIA[Name,Task] and LOA[Name] evaluate to the high and low constants which<br>*OR&rsquo;ed together produce the value for APCTask&APC&larr;.<br>M@[HIA,AND[177400,ADD[LSHIFT[#2,14],#1]]C];<br>M@[LOA,AND[377,#1]C];<br><br>%CHPGFLG@ is set to 2 by LOADPAGE (which sets CHPAGE@[1] if CHPGFLG@ was 1);<br>it is 1 here in the mi after the LOADPAGE.<br>TSKFLG@ is 2 in the instr after a TASK, 1 in the instr after that; when it<br>is 2 a RETURN is forced; when 1 the ALUERRTST macro will produce an error.<br>RTNILL@ is 1 when a DISPATCH or APC&APCTASK&larr; is done.<br>%<br>M@[XX1@,IFE[TSKFLG@,2,RETN@[,0]] SET[TSKFLG@,RSHIFT[TSKFLG@,1]]];<br>M@[XX2@,IFE[CHPGFLG@,1,CHPAGE@[1] SET[CHPGFLG@,0],<br>  SET[CHPGFLG@,IFA[W1@,0,1]]]];<br>M@[XX3@,IFE[REGIFLAG@,1,<br>  IFE[FVAL[ALF@],0,ER[WARNING:..no.register.interlock,3]]]<br>  SET[REGIFLAG@,0]];<br>M@[XX4@,SET[RTNILL@,0] IFE[FVAL[JC@],6,<br>  ER[APC.loaded.during.RETURN,2]]];<br><br>M@[IMX@,IFE[TSKFLG@,0,,XX1@[]]</span><span class="tab" val="77"></span><span style="font: 12pt serif">IFE[CHPGFLG@,0,,XX2@[]]<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">IFE[REGIFLAG@,0,,XX3@[]]</span><span class="tab" val="77"></span><span style="font: 12pt serif">IFE[RTNILL@,1,XX4@[]]];<br><br>*The default mi modified by ONPAGE<br>DEFAULT[IM,RSEL@[14] BSF1@[50] F2@[12] JC@[4] W1@[7777] W2@[7777] PW0@[1]];<br><br>*Macro executed after assembling each mi<br>SETPOST[IM,IMX@];<br><br>%IM used as data stuff<br><br>IM words can be assembled as data using the "LH" (left-half) and "RH"<br>(right-half) macros defined below.  Each of these takes up to 8 arguments<br>which are either parameters or integers summed to form the value stored.<br>NOTE: The parity must be correct or Midas will complement the IMParity bit<br>when loading.<br><br>Ways to assemble data are:<br>  TAG:</span><span class="tab" val="77"></span><span style="font: 12pt serif">DATA[LH[n1,n2,n3,n4] RH[n5,n6,n7,n8] FIXP@[] AT[...]]; *Obsolete<br>  TAG:</span><span class="tab" val="77"></span><span style="font: 12pt serif">IMDATA[LH[n1,n2,n3,n4] RH[n5,n6,n7,n8] AT[...]]; *Automatic FIXP@<br>%<br><br>M@[LH,IFG[#0,10,TMARGS@[LH]]<br>  V0@[DPS@[#1,#2,#3,#4,#5,#6,#7,#8]]];<br><br>M@[RH,IFG[#0,10,TMARGS@[RH]]<br>  V1@[DPS@[#1,#2,#3,#4,#5,#6,#7,#8]]];<br><br>*FIXP@[...] computes parity of data in 0..37 and puts 1 or 0 in RX@ to<br>*make the parity correct.<br>M@[FIXP@,SET[Z@,XOR[FVAL[V0@],FVAL[V1@]]]<br>  SET[Z@,XOR[Z@,RSHIFT[Z@,10]]]<br>  SET[Z@,XOR[Z@,RSHIFT[Z@,4]]]<br>  RX@[SELECT[AND[XOR[Z@,RSHIFT[Z@,2]],3],1,0,0,1]]];<br><br>M@[DATA,.[RETCL@[2] #1]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Indicate "Return" so no MicroD fixup<br>M@[IMDATA,.[(RETCL@[2] FIXP@[], #1)]];<br><br>*Conditional assemblies with :IF&rsquo;s nested to 4 levels<br><br>SET[ALEV@,0];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*No. nested IF&rsquo;s<br>SET[ASMF@,1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*1 if assembling, 0 if not assembling<br>SET[ASML@,1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*1 if assembling at this level, 0 if ignoring<br>SET[L1@,0]; SET[L2@,0]; SET[L3@,0]; SET[G1@,0]; SET[G2@,0]; SET[G3@,0];<br><br>M@[IF,SELECT[ALEV@,,SET[L1@,ASML@] SET[G1@,ASMF@],<br>    SET[L2@,ASML@] SET[G2@,ASMF@],</span><span class="tab" val="77"></span><span style="font: 12pt serif">SET[L3@,ASML@] SET[G3@,ASMF@],<br>    ER[:IF/UNLESS.nested.more.than.4.levels,1]]<br>  SET[ALEV@,ADD[ALEV@,1]] SET[ASML@,ASMF@]<br>  IFE[ASML@,1,<br>    IFE[#1,0,ASMMODE[1] SET[ASMF@,0],ASMMODE[0] SET[ASMF@,1]]]];<br><br>M@[UNLESS,IF[IFE[#1,0,1,0]]];<br><br>M@[NOIF@,ER[No.:IF.preceding.:#1,1]];<br>M@[ELSEIF,IFE[ALEV@,0,NOIF@[ELSEIF],<br>  IFE[ASML@,1,IFE[ASMF@,1,SET[ASMF@,0] SET[ASML@,0] ASMMODE[1],<br>    SET[ASMF@,#1] ASMMODE[IFE[ASMF@,0,1,0]]]]]];<br><br>M@[ELSE,IFE[ALEV@,0,NOIF@[ELSE],<br>  IFE[ASML@,1,IFE[ASMF@,1,SET[ASMF@,0] SET[ASML@,0] ASMMODE[1],<br>    ASMMODE[0] SET[ASMF@,1]]]]];<br><br>M@[ENDIF,SELECT[ALEV@,NOIF@[ENDIF],<br>    SET[ASMF@,1] SET[ASML@,1],</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">SET[ASML@,L1@] SET[ASMF@,G1@],<br>    SET[ASML@,L2@] SET[ASMF@,G2@],</span><span class="tab" val="77"></span><span style="font: 12pt serif">SET[ASML@,L3@] SET[ASMF@,G3@]]<br>  SET[ALEV@,SUB[ALEV@,1]] IFE[ASMF@,1,ASMMODE[0]]];<br><br><br>%:TITLE[s1] prints an error message beginning with s1 showing the IM<br>address at the beginning of assembly, which may help correlate errors with<br>source statements when several sources are assembled at once.  :TITLE also<br>resets assembly flags to standard states.  The leading ":" will cause an<br>appropriate message to be printed when the entire assembly is suppressed<br>inside a conditional.<br>%<br>M@[MSG@,ER[#1..IM.address.=.,0,IP[.]]];<br>M@[NAMSG@,ER[#1..not.assembled,0]];<br><br>M@[TITLE,IFE[ASMF@,1,<br>    SET[TSKFLG@,0] SET[CHPGFLG@,0] SET[REGIFLAG@,0] SET[RTNILL@,0]<br>    SET[NONQUADOK@,0] SET[ODDOK@,0]<br>    TARGET[.] SETTASK[0] MSG@[#1],<br>  NAMSG@[#1]]];<br><br>M@[END,IFE[ASMF@,1,MSG@[#1.END],NAMSG@[#1.END]]];<br><br><br>F@[VERS@,0,17]; VERSION[V@,0]; V@[VERS@[1]];<br><br>%Obsolete syntax still supported--programmers should convert so these<br>can be deleted eventually.<br>%<br>EQ@[FORMMINUS4,FORM-4];<br>EQ@[STKP,NSTKP];<br>EQ@[ALURESULT&SALUF,ALURESULT&NSALUF];<br>EQ@[SALUF,NSALUF];<br>EQ@[APC&APCTASK,APCTASK&APC];<br>EQ@[APC&APCTASK&larr;,APCTASK&APC&larr;];<br>EQ@[~NOH2BIT8,~H2BIT8&rsquo;];<br>EQ@[~@NOCARRY,~@CARRY&rsquo;];<br>EQ@[~NOATTEN,~IOATTEN&rsquo;];<br>EQ@[~@NOMB,~@MB&rsquo;];<br>EQ@[~@NOTINTPENDING,~@INTPENDING&rsquo;];<br>EQ@[~NOOVF,~OVF&rsquo;];<br>EQ@[~@BPCNOCHK,~@BPCCHK&rsquo;];<br>EQ@[~@INQUAD,~@QUADOVF&rsquo;];<br>EQ@[~@NOTIMEOUT,~@TIMEOUT&rsquo;];<br>M@[NOTASKRTN,RETN@[#1#2,0,NOTASKRTN]];<br><br>*Obsolete forms that must be fixed now<br>M@[OBS@,ER[Obsolete.#1,2]];<br><br>M@[IDF@,OBS@[IDF@--use.IDF]];<br>M@[NOT@,OBS@[NOT@--use.NOT]];<br>M@[REPEAT@,OBS@[REPEAT@--use.REPEAT]];<br>M@[OR@,OBS@[OR@--use.OR]];<br>M@[XOR@,OBS@[XOR@--use.XOR]];<br>M@[AND@,OBS@[AND@--use.AND]];<br>M@[FLX@,OBS@[FLX@--use.FIELD]];<br>M@[PSET,OBS@[PSET--use.LOCA]];<br><br>M@[NOMIDASINIT,OBS@[NOMIDASINIT--delete.it]];<br>M@[LANGVERSION,OBS@[LANGVERSION--delete.it]];<br>M@[MULTDIB,OBS@[MULTDIB--delete.it]];<br>M@[RCALL,OBS@[RCALL]];<br>M@[RCALLP,OBS@[RCALLP]];<br>M@[NEWINST,OBS@[NEWINST]];<br>M@[ODDBASEOK,OBS@[ODDBASEOK--use.ODDPFETCH1.etc.]];<br>M@[DBLBRANCH,OBS@[DBLBRANCH--use.DBLGOTO]];<br>M@[DBLBRANCHP,OBS@[DBLBRANCH--use.DBLGOTOP]];<br>M@[BRANCH,OBS@[BRANCH--use.GOTO]];<br>M@[BRANCHP,OBS@[BRANCHP--use.GOTOP]];<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
