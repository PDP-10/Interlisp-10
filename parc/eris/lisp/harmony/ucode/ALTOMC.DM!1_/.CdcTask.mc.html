<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>CdcTask.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif">:IF[WithCDC]; **********************************<br><br>  TITLE[CDCTask];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Color Display microcode<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Ed Fiala 1 June 1982<br><br>%The color display controller has a 256d-word buffer and consumes 160d<br>words per 63 (?) microsecond scanline.  It does not turn off its wakeup when<br>cdcTask is running, so only higher priority tasks will intervene on tasking.<br>It uses up about 27 percent of the machine at 100 ns/cycle and can run at<br>a very low priority because the 256d-word buffer allows about 100 us of<br>delay before the buffer goes empty.<br><br>The controller microcode loops reading the high part of the data long pointer<br>once each field until that word becomes non-zero.  Then it builds a base<br>register from the data long pointer, and a partial base register from the<br>color map long pointer.  Both the data and color map long pointers must be<br>16d-word aligned, and the 60d-word color map must not cross a 64k-word<br>boundary.  Page faults are also verboten.<br><br>To stop the controller, first store 0 in the data long pointer and wait<br>one field time; this ensures that the microcode will be in its idle loop<br>rather than somewhere else.  Then output a 0 to device 0 of cdcTask using<br>the Output opcode; this will stop wakeups for cdcTask.  To restart, output<br>a 6 to device 0 of cdcTask.  This will restart the idle loop running.  Then<br>to show data, first setup the color map long pointer and finally the data<br>long pointer, being certain to store into the high part of the data long<br>pointer last.<br>%<br><br>SetTask[cdcTask];<br><br>*Output Registers<br>Set[cdcCReg,0];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Control register<br>Set[cdcBuf,Add[LShift[cdcTask,4],1]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Data buffer - use with IOFetch<br><br>Set[cdcID,0];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Input register<br><br>*RM Registers<br>Set[cdcRB,LShift[And[cdcTask,3],4]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Enforce reg alloc convention<br><br>RV[cdcTemp,Add[cdcRB,0]];<br>RV[cdcTemp1,Add[cdcRB,1]];<br>*Long pointer to bitmap & to color map data (60d words)<br>RV4[cdcDPtr,cdcDPtrHi,cdcCMPtr,cdcCMPtrHi,Add[cdcRB,4]];<br>RV[cdcScanLineCount,Add[cdcRB,10]];<br>RV[cdcWordCount,Add[cdcRB,11]];<br>RV2[cdcMDSLoc,cdcMDSLochi,Add[cdcRB,12]];<br><br>:IF[AltoMode]; *********************************<br>Set[cdcBaseLoc,414];<br>:ELSE; *****************************************<br>*By convention the blocks of 20b locations on IOPage (177400b to 177777b)<br>*are reserved as core locations for tasks 0 to 16b.<br>Set[cdcBaseLoc,Add[177400,LShift[CDCTask,4]]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*177520b<br>:ENDIF; ****************************************<br><br>*Must turn off CDC before overwriting its microcode.<br>*Simply use the Mesa Output opcode with TOS = 0,,0,,cdcTask,,0 and 2OS =<br>*0 to turn off the CDC.<br>**Used to have here:<br>*cdcOff:</span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcTemp1 &larr; 0C, Skip, At[cdcOffLoc];<br><br>*Get to cdcIni during device initialization, or when the display has finished <br>*sending all words for a field.  Disable the data wakeup request, and wait<br>*for the sync wakeup.<br><br>cdcIni:</span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcTemp1 &larr; 6C, At[cdcInitLoc];<br>*Clear Sync wakeup, enable Sync wakeup, no data wakeup<br>:UNLESS[AltoMode]; *****************************<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcMDSLocHi &larr; 0C;<br>:ENDIF; ****************************************<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Output[cdcTemp1,cdcCReg];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcTemp1 &larr; 17C;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Interlock the output and<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcMDSLoc &larr; HiA[cdcBaseLoc];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*wait for wakeup pipe to empty<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcMDSLoc &larr; (cdcMDSLoc) or (LoA[cdcBaseLoc]), Call[cdcRTN];<br><br>*Wake up here due to sync wakeup (we hope).<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Input[cdcTemp,cdcID];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*gets FieldA into bit 15<br>*Fetch the Data and ColorMap (long) pointers from the cdcBaseLoc quadword<br>*and skip if SyncWakeup.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">PFetch4[cdcMDSLoc,cdcDPtr,0], Skip[IOAtten];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  GoTo[cdcIni];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*should have seen SyncWakeup.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; cdcDPtrHi;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*check for display on (pointer &gt;64k)<br>*Convert long pointer to base register format<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcDPtrHi &larr; T &larr; (LSh[cdcDPtrHi,10]) + T + 1, Skip[ALU#0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  GoTo[cdcIni];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*display is off<br>*clear sync wakeup, SWE, DWE, ForceBActive<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Output[cdcTemp1,cdcCReg];<br>*interlock and set up for next output: ForceAActive, SWE, DWE<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcTemp1 &larr; 23C;<br>*</span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcDPtrHi &larr; T &larr; (FixVA[cdcDPtrHi]) or T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; cdcTemp, IOStrobe, DblGoTo[cdcFieldA,cdcFieldB,R Odd]; *load the wakeup counter with 0<br><br>*Sync wakeups occur at end of field, so FieldB is about to start.<br>*Load the color map, and add 160d (one scan line) to the Data address.<br>*We cleared the wakeup request counter here, and will not increment it.  We<br>*are writing bufferA, and when we switch to sending data to buffer B, the<br>*wakeup counter will be zero.<br>***Color map must not cross 64k boundary.<br>cdcFieldA:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcCMPtrHi &larr; LSh[cdcCMPtrHi,10];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcScanLineCount &larr; 356C;</span><span class="tab" val="77"></span><span style="font: 12pt serif">*240d scanlines - 2<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">IOFetch16[cdcCMPtr,cdcBuf,0], Call[cdcIncCMPtr];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">IOFetch16[cdcCMPtr,cdcBuf,0], Call[cdcIncCMPtr];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">IOFetch16[cdcCMPtr,cdcBuf,0], Call[cdcIncCMPtr];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">IOFetch4[cdcCMPtr,cdcBuf,0];<br>*Offset the data pointer by one scanline (160d words).<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcDPtr &larr; (cdcDPtr) +  (240C), Call[cdcDPCarry];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">IOFetch4[cdcCMPtr,cdcBuf,4], Call[cdcRTN];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">IOFetch4[cdcCMPtr,cdcBuf,10];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcWordCount &larr; 10C, GoTo[cdcFieldCommon];<br><br>*FieldA is about to start.<br>*We will write 16 words into buffer A, then switch to buffer B and fill it.<br>cdcFieldB:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">IOFetch16[cdcDPtr,cdcBuf,0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcDPtr &larr; (cdcDPtr) + (20C), Call[cdcDPCarry];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcScanLineCount &larr; 357C;</span><span class="tab" val="77"></span><span style="font: 12pt serif">*241d scanlines - 2<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcWordCount &larr; 7C, GoTo[cdcFieldCommon];<br><br>cdcFieldCommon:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Output[cdcTemp1,cdcCReg];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*cdcTemp1 &larr; ForceAActive, SWE, DWE earlier.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcTemp &larr; 3C;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*SWE, DWE<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Output[cdcTemp,cdcCReg], Call[cdcRTN]; <br>*We are now set up to write into buffer A.  Buffer B has been loaded with the<br>*color map data or with the first 16 words of the first scan line, depending<br>*on the field.  Pump out the rest of the field.  Note that the hardware<br>*will display about 480.6 lines of data per frame, so the extra scanline<br>*output here will be only partly shown in one field and not shown at all in<br>*the other field, but storage has to be underneath it<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">IOFetch16[cdcDPtr,cdcBuf,0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcWordCount &larr; (cdcWordCount) - 1, IOStrobe, GoTo[cdcThisSL,R&gt;=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcScanLineCount &larr; (cdcScanLineCount) - 1, Skip[R&gt;=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  GoTo[cdcIni];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcWordCount &larr; 10C;<br>*Increment base by 160d for interlace + 16d for this IOFetch16.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcDPtr &larr; (cdcDPtr) + (260C), DblGoTo[cdcDPCarry,.+2,IOAtten&rsquo;];<br>cdcThisSL:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcDPtr &larr; (cdcDPtr) + (20C), Skip[IOAtten&rsquo;];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  GoTo[cdcIni];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Premature end of field<br>cdcDPCarry:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Skip[Carry&rsquo;];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  cdcDPtrHi &larr; (cdcDPtrHi) + (400C) + 1;</span><span class="tab" val="77"></span><span style="font: 12pt serif">*64k boundary<br>cdcRTN:</span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcTemp &larr; cdcTemp, Return;</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Interlock Output at cdcFieldCommon+2<br><br><br>cdcIncCMPtr:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">cdcCMPtr &larr; (cdcCMPtr) + (20C), Return;<br><br>  END[CDCTask];<br><br>:ELSE; *****************************************<br><br>  TITLE[No.color.display.microcode];<br><br>:ENDIF; ****************************************<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
