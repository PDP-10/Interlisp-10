<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>Kernel.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">INSERT[D0LANG];<br>TITLE[kernel];<br><br>%<br>Modified October 3, 1979 by CT.  Made bit 3 the &rsquo;Midas present&rsquo; bit in FFAULT<br>Modified August 1, 1979 by CT.  put one-time initialization on page 15<br>Modified July 26, 1979 by CT.  Added resetmemerrs at DoOverlay<br>Modified June 28, 1979 by CT.<br><br>This kernel consists of three parts:<br>1) A section that occupies part of pages 0 and 17, runs at task 17, and handles<br>all communication with Midas with the exception of Mouse halt testing<br>(which is done by a timer).  This section refreshes the memory frequently<br>without using a timer.<br><br>2) A section that occupies part of page 16, runs at task 16, and handles<br>kernel initialization, normal memory refresh and Mouse halt testing while a program is running.<br><br>3) An initialization section on page 15 that can be wiped out at will.<br><br>The idea is that if you have a simple program, you can use the page 16 and 17 parts of<br>this kernel, and you will get minimal memory refresh and mouse halt testing.<br>If you need something more complex, you overwrite the stuff on page 16,<br>but in this case you must supply the code for mouse halt testing.<br>%<br>SETTASK[17];<br><br>RV[REFR,77];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*memory refresh address<br><br>*The following registers hold the volatile state of the processor on a fault: <br>RV[RXALU,76];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*ALU result and SALUF<br>RV[RXAPC,75];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*APCTask&APC<br>RV[RXCTASK,74];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*CTASK.NCIA<br>RV[RXPPB,73];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Page,Parity,BootReason<br>RV[RXSTK,72];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Stackpointer<br><br>RV[RTMP,71];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*temporary<br><br>*The following registers are used for D0-Midas communication (RTMP is also used):<br>RV[RWSTAT,70];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*status register<br>RV[RDATA,67];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*holds data<br><br>*FFault determines how faults will be treated when programs are running.  If it is<br>*zero, all faults will be reported to Midas.  If FFault is nonzero, the kernel will<br>*send control through location 120 when a fault occurs and PARITY # 0 (faults with<br>*PARITY = 0 are breakpoints).<br>RV[FFAULT,66];<br><br>*Registers between 360 and 365 are used by the Midas overlays.  The following <br>*registers, used by WriteMI,  are also in this range.<br>RV[RADDR,65];<br>RV[RCNT,64];<br>RV[RW0,63];<br>RV[RW1,62];<br><br><br><br>*Constants for Recv and Send<br>MC[RecvByte,12];<br>MC[RecvWord,16];<br>MC[SendByte,21];<br>MC[SendWord,25];<br><br>IMRESERVE[,7501,11];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*space for Midas overlays (7500-7527)<br>IMRESERVE[,7513,15];<br><br>SET[CMDisp,7420];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*8-way dispatch on Midas command<br>SET[RWDisp, 7440];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*4-way dispatch on state bits of RWStat<br><br><br>*After loading kernel.mb, Midas starts it at 7000<br>Start:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; 6000c, AT[7000];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (RTMP) + (400C),goto[KNotify];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Notify Task 0, address 6400<br>KNotify:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APC&APCTASK &larr; RTMP;<br>Kn1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RETURN;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SETTASK[0];<br>*R definitions<br>RV[R0,0];<br>RV[R1,1];<br>RV[R2,2];<br>RV[R3,3];<br>RV[R4,4];<br>RV[R5,5];<br>RV[R6,6];<br>RV[R7,7];<br>RV[R10,10];<br>RV[R11,11];<br>RV[R12,12];<br>RV[R13,13];<br>RV[R14,14];<br>RV[R15,15];<br>RV[R16,16];<br>RV[R17,17];<br><br><br>*Clear R0-R17 to avoid R parity errors later<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R1 &larr; 0c, AT[6400];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R2 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R3 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R4 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R5 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R6 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R7 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R10 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R11 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R12 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R13 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R14 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R15 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R16 &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R17 &larr; 0c;<br>*Clear R20-R377 using Stkp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R0 &larr; 20c;<br>RClear:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stkp &larr; R0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (R0) xor (377c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R0 &larr; (R0) + 1, goto[RClear,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R0 &larr; 5c;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Notify task 17, location 6405<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R0 &larr; (R0) + (176400c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APC&APCTASK &larr; R0;<br>p15ret:</span><span class="tab" val="67"></span><span style="font: 10pt serif">return;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SETTASK[17];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (400C), AT[6405];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*set Printer idle, don&rsquo;t drive bus <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Printer &larr; RTMP;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (100000C);<br>ClrTimers:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LOADTIMER[RTMP];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Clear out all Timers<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RESETMEMERRS;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Clear any pending memory errors<br>*NOTE: FFAULT[2] DISABLES H4PARITY ERRORS IN THE NORMAL (non-diagnostic) FAULT HANDLER<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FFAULT &larr; 30000c;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Initialize so that Midas takes faults, indicate midas is present<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (RTMP) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RTMP) AND (17C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*there are 16d timers<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">REFR &larr; (0C), DBLGOTO[InitDone, ClrTimers, ALU=0];<br>InitDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; TIMER;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Set up the Refresh timer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (50000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (RTMP) OR (277C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*simple timer,value 11d,slot 17b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadTimer[RTMP];<br><br>*Notify task 16, address 7010 to set up timer task<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (167000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (RTMP) OR (10C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APC&APCTask &larr; RTMP, goto[p15ret];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[TimerInitDone], AT[7010]; *Set TPC[16] to TimerTask<br><br>*The simple timer task assumes slot 17 expired, since all others were cleared.<br>TimerTask:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Refresh[REFR];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; Timer;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*read timer to clear the wakeup<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">REFR &larr; (REFR) + (20c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (50000C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*build timer constant<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (RTMP) OR (277C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*simple timer,value 11d,slot 17b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AddToTimer[RTMP];<br>CheckStop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Printer;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RTMP) AND (10000C) ;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GOTO[MidasStop,ALU#0] ;<br>TimerRet:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RETURN;<br>MidasStop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; T, goto[MidasStop],SetFault, AT[7003]; *Midas recognizes a mouse halt as<br>*a task 16 breakpoint that was not set by the user.  It continues from (absolute) MidasStop+1<br>MidasRestart:</span><span class="tab" val="67"></span><span style="font: 10pt serif">return, AT[7004];<br><br>*return to task 17, address 7400<br>TimerInitDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (177400C), goto[KNotify];<br><br><br>*Page Zero stuff <br>*We put the instruction for BufferRefill here..<br>x377x:</span><span class="tab" val="67"></span><span style="font: 10pt serif">gotop[x377x], at[377];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*dummy instruction<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[0], goto[x377x], at[0]; *Emulator buffer refill code is on page 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; APCTASK&APC, AT[1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fault entry.  Save APC first, then the other volatile regs.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RXAPC &larr; T, AT[100];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; GETRSPEC[147], AT[101];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*ctask, ncia<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RXCTASK &larr; T, AT[102];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (GETRSPEC[103]) xor (377c), AT[103];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*sstkp, stkp (stkp is read complemented)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RXSTK &larr; T, AT[104];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; 20c, AT[105]; *Set stkp to 20 in case there was a stack overflow pending<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stkp &larr; RTMP, AT[106];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (GETRSPEC[107]) xnor (0c), AT[107];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*aluresult, saluf (both read complemented)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RXALU &larr; T, AT[110];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; GETRSPEC[157], LOADPAGE[0], AT[111]; *page, parity, bootreason<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RXPPB &larr; T, RESETERRORS, AT[112];<br>*Notify Task 17, address 7505 (breakpoint communication)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (177400C), AT[113];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (RTMP) OR (105C), AT[114];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APC&APCTASK &larr; RTMP, AT[115];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RETURN, AT[116];<br>*The go overlay will send control to UserFault (120) if PARITY # 0 and FFAULT&lt;0<br>UserFault:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[17], at[120]; *User may overwrite these instructions if desired<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">gotop[MidasFault], at[117];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br><br><br>*The following is the page 17 portion of the kernel.  We get here<br>*after setting up the timer task.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RDATA &larr; 40000C, AT[7400];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*send #100 to Midas<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; SendByte, CALL[Send];<br><br>NextCom:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvByte, CALL[Recv], AT[7404];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[RDATA,15,3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DISP[DoOverlay];<br><br>DoOverlay:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ResetMemErrs, GOTO[OverlayArea], AT[CMDisp,0]; *Midas overlay<br>OverlayArea:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">return, AT[7500];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*placeholder for overlay<br>MidasFault:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">return, AT[7512];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*placeholder for fault in Midas go overlay<br><br>WriteMI:</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvWord, CALL[Recv], AT[CMDisp,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Write Control Store<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RADDR &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvByte, CALL[Recv];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get Count (byte)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RCNT &larr; T;<br>WriteMILoop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NOP;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvWord, CALL[Recv];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get Data 0 (word)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RW0 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvWord, CALL[Recv];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get Data 1 (word)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RW1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvByte, CALL[Recv];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get Data 2 (byte)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; RW0;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*T has data 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APC&APCTASK &larr; RADDR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">WRITECS0&2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; RW1, AT[CMDisp,12]; *force writecs to have JA.7 = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APC&APCTASK &larr; RADDR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">WRITECS1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RADDR &larr; (RADDR) + 1, AT[CMDisp,14]; *force writecs to have JA.7 = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RCNT &larr; (RCNT) -1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GOTO[WriteMILoop, ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GOTO[NextCom];<br><br>*Read a single R register.  Midas will use an overlay to read RM 0 and RM 10 - RM 17,<br>*to avoid generating stack overflow.<br>ReadR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvByte, CALL[Recv], AT[CMDisp,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get Address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">STKP &larr; RDATA;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">nop;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; STACK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RDATA &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWStat &larr; SendWord, Call[Send];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GOTO[NextCom];<br><br>*Write a single R register.  Midas will use an overlay to write RM 0 and RM 10 - RM 17,<br>*to avoid generating stack overflow.<br>WriteR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvByte, CALL[Recv], AT[CMDisp,6];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get Address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">STKP &larr; RDATA;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvWord, CALL[Recv];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get (word) data<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">STACK &larr; T, GOTO[NextCom];<br><br><br>*SUBROUTINES Send and Receive communicate with Midas.<br><br>Send:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rsh[RDATA,10], AT[7460];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*get msbyte (location 7460 is known to overlays)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; T, goto[RPRT];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*will get WrStrb on<br>Recv:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RDATA &larr; Zero, AT[7464];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*location 7464 is known to overlays<br>RW:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Refresh[REFR];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Refresh the memory<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; 30c;<br>Dlyloop:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (RTMP) -1, goto[Dlyloop,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">REFR &larr; (REFR) + (20C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Printer; *Get Printer data<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Printer; *Insist that the printer yield the same data three times.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RTMP)-(T);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Printer, Goto[.+2,ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Goto[RW];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RTMP)-(T);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Goto[.+2,ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Goto[RW];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LDF[RTMP,0,2]; *Get strobe/ack bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (LDF[RWSTAT,16,2]) xor (T);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Compare to desired bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTMP, GOTO[RW,ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*if reached, clear all bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; 400C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Printer &larr; RTMP, RTMP &larr; T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*restore RTMP<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[RWSTAT,13,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*dispatch on state bits of rwstat<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RWSTAT) AND (4C), DISP[ReadStrobeOff];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*setup byte/word<br><br>ReadStrobeOff:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">USECTASK, GOTO[ReadMore, ALU#0], AT[RWDisp,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get Another byte if word set<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RDATA, RETURN;<br>ReadMore:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; RecvByte, GOTO[RW];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Go get another byte<br><br>ReadStrobeOn:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RHMask[RTMP], AT[RWDisp,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Get Data Byte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RDATA &larr; (LSH[RDATA,10]) OR (T);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Merge Byte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; (RWSTAT) AND (4C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*State&larr;0, Look for RDStrb off, retain byte/word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTMP &larr; (100400C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Set RdAck<br>RPRT:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Printer &larr; RTMP, GOTO[RW];</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br><br>*Here on Write Ack On - state &larr; 3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; (RWSTAT) XOR (11C), GOTO[RW], AT[RWDisp,2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br>*Here on Write Ack Off<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RDATA &larr; LSH[RDATA,10], goto[SendMore, ALU#0], AT[RWDisp,3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; Zero, goto[ReadStrobeOff]; *must do non-tasking return<br>SendMore:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RWSTAT &larr; SendByte, goto[Send];<br><br><br>END;<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
