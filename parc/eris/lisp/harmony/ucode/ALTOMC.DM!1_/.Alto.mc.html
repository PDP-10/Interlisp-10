<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>Alto.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 6pt; text-align: left">
<span style="font: 10pt serif">:TITLE[Alto];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alto/Nova emulator<br><br>* edited August 27, 1982  2:28 PM<br>* Conditionalized BitBlt on WithAltoBitBlt July 18, 1982  10:33 PM <br>* Conditionalized SIO on With3MB June 30, 1982  10:05 PM <br>*Ed Fiala 3 June 1982<br><br>%Naming conventions (not universally followed):  Labels use prefixes<br>"ne," "ao," "xo," and "br."  Opcode execution begins on nePage at "ne1st" or<br>at one of its duplicates.  Memory reference opcodes use only nePage; A-group<br>opcodes branch off to aoPage; opcodes in the extended instruction set branch<br>to xoPage; BCPL runtime opcodes are divided into three groups: JSR 300-337<br>are on brJsrPage, JSR @340-357 on br340Page, and JSR @360-377 on nePage.<br>%<br><br>*Start Alto/Nova emulator.  Initialize registers and start at PCB.  NOTE:<br>*R400, shared with Mesa, is initialized by Initialize.Mc at RegInit1 rather<br>*than here.<br>StartNova:</span><span class="tab" val="67"></span><span style="font: 10pt serif">*On neStartPage<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipPCF0 &larr; 4C, At[neStartLoc];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*4 in low 3 bits, 0 in sign<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipPCF1 &larr; 26C, Task;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*6 in low 3 bits, 0 in sign<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipPCF2 &larr; 10C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*0 in low 3 bits, 1 in sign<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R177400 &larr; T &larr; 177400C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipPCF2 &larr; (SkipPCF2) + T, LoadPage[neStartPage1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R177401 &larr; T &larr; (Zero) + T + 1;<br>OnPage[neStartPage1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R177402 &larr; T &larr; (Zero) + T + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipPCF3 &larr; 22C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipPCF3 &larr; (SkipPCF3) or T, LoadPage[neStartPage2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*2 in low 3 bits, 1 in sign<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R177403 &larr; (Zero) + T + 1;<br>OnPage[neStartPage2];<br>:IF[SmallTalkMode]; ****************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">R400 &larr; 400C;<br>:ENDIF; ****************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Carry &larr; 0C;<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">rwpAC0 &larr; IP[AC0]C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*coincident with SkipPCF2<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">rwpAC1 &larr; IP[AC1]C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*coincident with SkipPCF1<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">rwpAC2 &larr; IP[AC2]C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*coincident with SkipPCF0<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">rwpAC3 &larr; IP[AC3]C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*coincident with SkipPCF3<br>*rpACx contains a pointer to ACx-1 (i.e., (ACx & 360)+((ACx-1) & 17)<br>*since StkP counts mod 20b.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rpAC0 &larr; Or[And[IP[AC0],360],And[Sub[IP[AC0],1],17]]C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; MDShi, LoadPage[neFixBPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rpAC1 &larr; Or[And[IP[AC1],360],And[Sub[IP[AC1],1],17]]C, CallP[FixNBases];<br>*rpAC2 coincident with R177403<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">rpAC2 &larr; Or[And[IP[AC2],360],And[Sub[IP[AC2],1],17]]C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCB, LoadPage[nePage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rpAC3 &larr; Or[And[IP[AC3],360],And[Sub[IP[AC3],1],17]]C, GoToP[brJmpPz];<br><br>OnPage[neFixBPage];<br>FixNBases:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMAhi &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCBhi &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0hi &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1hi &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC2hi &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3hi &larr; T, Return;<br><br>%The mi at location 1 (BufferRefillTrap) is &rsquo;LoadPage[0], GoTo[377]&rsquo;,<br>which sends control to location 377 on the page that did the (aborted)<br>NextInst/NextData.  We would like the mi at 0 to be a PFetch4, but<br>alas, DF2 addressing doesn&rsquo;t work, since H2 is not loaded in the cycle<br>following an aborted mi (so the displacement won&rsquo;t be loaded).<br><br>Buffer refill every four non-jump opcodes adds 16 cycles or 4.0 cycles/opcode<br>(6 through PFetch4 + 12 after PFetch4 - 2 for ne1st which would have been<br>executed anyway); JMP and JSR independently refill the buffer, and are charged<br>for that refill.  LDA@ and STA@ check explicitly for buffer refill during<br>dead time of the indirect fetch, so that IBuf will be loaded by the end of<br>the opcode; STA also checks for refill prior to its PStore1 because MC1 is<br>busy for 15 cycles afterwards and buffer refill would be very slow.<br><br>Interrupts are checked for only on opcodes that jump or compute indefinitely<br>such as BLT/BLKS.<br><br>We task (i.e., Return) every 41 cycles by requiring each opcode to Return<br>within 41 cycles of starting and within 0 cycles of exiting, where ne1st<br>or one of its duplicates is the 1st mi.<br>%<br>:IF[neBCPLI340]; *******************************<br>xoRefill:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[PCB,IBuf,4], GoToP[neRefx], At[xoBase,377];<br>:ENDIF; ****************************************<br><br>neRefill:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[PCB,IBuf,4], GoToP[neRefx], At[neBase,377];<br><br>*PC contains a multiple of 4, and the low two bits of the PC are in PCF.<br>OnPage[0];<br>neRefx:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF &larr; RZero;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) + (4C), Return;<br><br>OnPage[nePage];<br><br>neMemI:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Dispatch[PCF[IBuf],5,4]) or not T, Disp[.+1];<br><br>*Timing = 6 cycles to here<br>*Main Instruction Dispatch for Memory Reference instructions<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF[IBuf] &larr; T &larr; PCF[IBuf] and T, FreezeResult, Disp[JmpJsr], At[OpTab,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*jmp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF[IBuf] &larr; T &larr; PCF[IBuf] and T, Disp[JmpJsr], At[OpTab,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*jsr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] and T, Disp[IszDsz], At[OpTab,2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*isz<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] and T, FreezeResult, Disp[IszDsz], At[OpTab,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*dsz<br><br>*rp&rsquo;s point to (reg-1) mod 20b because PFetch&rsquo;s do pushes.  rpACn registers<br>*may have garbage in left half when coincident with other constants, so must<br>*mask these.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (StkP &larr; rpAC0) and T, Disp[LdaSta], At[OpTab,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*lda 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (StkP &larr; rpAC1) and T, Disp[LdaSta], At[OpTab,5];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*lda 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (StkP &larr; rpAC2) and T, Disp[LdaSta], At[OpTab,6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*lda 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (StkP &larr; rpAC3) and T, Disp[LdaSta], At[OpTab,7];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*lda 3<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (StkP &larr; rwpAC0) or not T, Disp[LdaSta], At[OpTab,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*sta 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (StkP &larr; rwpAC1) or not T, Disp[LdaSta], At[OpTab,11];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*sta 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (StkP &larr; rwpAC2) or not T, Disp[LdaSta], At[OpTab,12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*sta 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (StkP &larr; rwpAC3) or not T, Disp[LdaSta], At[OpTab,13];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*sta 3<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[xoPage], Disp[Cycle], At[OpTab,14];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*60000-63777<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] and T, Disp[JSRIIp], At[OpTab,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*64000-67777<br>*Entries 16 and 17 in this dispatch table are in AltoX.Mc<br><br>*Dispatch for Jmp/Jsr instructions:<br>*T contains PCF[IBuf] and 377.<br><br>*Timing: JMP = 24, JSR = 33, JMP@ = 38, JSR@ = 40;<br>*+2 if negative eff. addr; +2 if PC-relative addressing<br><br>*Non-indirect Jmp/Jsr<br>JmpJsr:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[MDS,IBuf], DblGoTo[JmpFin,JsrFin,ALU&lt;0], DispTable[20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*pg 0<br>:IF[neBCPL300]; ********************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF[IBuf] - (300C), DblGoTo[brJmpPz,brJsrPz,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*pg 0<br>:ELSE; *****************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[MDS,IBuf], DblGoTo[JmpFin,JsrFin,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*pg 0<br>:ENDIF; ****************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + T, DblGoTo[PCJmp1,PCJsr1,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[R177400] + T, DblGoTo[PCJmp1,PCJsr1,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[AC2,IBuf], DblGoTo[JmpFin,JsrFin,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R177400) or T, FreezeResult, GoTo[.-1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[AC3,IBuf], DblGoTo[JmpFin,JsrFin,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*ac3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R177400) or T, FreezeResult, GoTo[.-1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-ac3<br><br>*Indirect Jmp/Jsr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], DblGoTo[JmpIndFin,JsrIndFin,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*@pg 0<br>:IF[neBCPLI340]; *******************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF[IBuf] - (340C), DblGoTo[JmpPzInd,JsrPzInd,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*@pg 0<br>:ELSEIF[neBCPLI360]; ***************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF[IBuf] - (360C), DblGoTo[JmpPzInd,JsrPzInd,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*@pg 0<br>:ELSE; *****************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], DblGoTo[JmpIndFin,JsrIndFin,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*@pg 0<br>:ENDIF; ****************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + T, DblGoTo[PCIndJmp,PCIndJsr,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[R177400] + T, DblGoTo[PCIndJmp,PCIndJsr,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,RTemp], DblGoTo[JmpIndFin,JsrIndFin,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R177400) or T, FreezeResult, GoTo[.-1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC3,RTemp], DblGoTo[JmpIndFin,JsrIndFin,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*ac3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R177400) or T, FreezeResult, GoTo[.-1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-ac3<br><br>PCtoAC3:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + T + 1;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; T, Return;<br><br>*Entry from EIR, brBranch<br>PCJmp1:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[PCB,IBuf], GoTo[JmpFin];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br><br>PCJsr1:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[PCB,IBuf];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br>JsrFin:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">MNBR &larr; PCB, PCB &larr; T &larr; T, NoRegILockOK;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even; bypass kludge<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; MNBR, Call[PCtoAC3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*PC&larr;new PC*2, AC3&larr;old PC+1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCB;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) + T, GoTo[JsrFin1];<br><br>PCIndJmp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[PCB,RTemp], GoTo[JmpIndFin];<br><br>PCIndJsr:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[PCB,RTemp];<br>JsrIndFin:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCB, Call[PCtoAC3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even; entry from JSRII/JSRIS<br>JmpIndFin:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTemp;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>*Entry from StartNova, BitBlt interrupt or exit, brReturn, brBranch<br>brJmpPz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[MDS,IBuf];<br>*Entry here on LRJ continue.<br>JmpFin:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCB &larr; T, Task, At[JmpFinLoc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd; bypass kludge<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) + T;<br>JsrFin1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; NWW, LoadPage[neIntPage0], Call[JmpFin3];<br><br>*Return here to start next inst with PCF pointing at even byte.<br>*Many opcodes finish by returning (which accomplishes the tasking requirement)<br><br>ne1st:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, T &larr; R177400;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; 377<br><br>ne2nd:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],1,4], DblGoTo[neRegI,neMemI,R&lt;0];<br><br>neRet:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br><br>JmpPzInd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], GoTo[JmpIndFin];<br>JsrPzIF:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], GoTo[JsrIndFin];<br><br>JmpFin3:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF &larr; PCB, PCB &larr; T, NoRegILockOK, SkipP[ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skip if possible int<br>OnPage[neIntPage0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCB &larr; (PCB) and not (3C), Return;<br>*BlksLp jumps to intSub.<br>intSub:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; NWW, Skip[R&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skip if interrupts enabled<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCB &larr; (PCB) and not (3C), Return;<br>*BLT/BLKS enter interrupts with DblGoTo[intEnt,int0Ret,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) and not (3C), Skip[ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skip if int requests<br>int0Ret:  Return;<br>*Begin an interrupt unless the interrupting device is inactive.<br>*Worst case timing from here to Return is 27 cycles.<br>intEnt:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) + (52C);<br>*xoCSum enters at intEnt1.<br>intEnt1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[MDS,WW];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd; fetch WW and ACTIVE<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; T, LoadPage[neIntPage1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NWW, GoToP[.+1];<br>OnPage[neIntPage1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">WW &larr; T &larr; (WW) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ACTIVE &larr; T &larr; (ACTIVE) and T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*ACTIVE now holds active int req&rsquo;s<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NWW &larr; T &larr; (Zero) - T, Skip[ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skip with NWW .eq. -ACTIVE<br>intPS2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">  PStore1[DMA,WW,0], Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Return with NWW .eq. 0<br>*Start an interrupt<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NWW &larr; 100000C, Task;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Disable interrupts<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (ACTIVE) and T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd; ACTIVE & -ACTIVE = right-most 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">WW &larr; (WW) and not T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF[IBuf] &larr; 1C, Call[intPS2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*PCF[IBuf] will contain int level<br><br>*loop to get number of the highest priority interrupt<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ACTIVE &larr; RSh[ACTIVE,1], Skip[R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF[IBuf] &larr; PCF[IBuf] + 1, Return;<br><br>*enter int routine - save other interrupts in WW (452)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF.word;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*recover the PC<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) or T, LoadPage[nePage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) or (100C), GoToP[.+1];<br>OnPage[nePage];<br>*Also enter here from IOUnIm<br>intXit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[MDS,PCB], Call[neRet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*save PC at 500b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] + T, GoTo[JmpPzInd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; address of new PC<br><br>*Dispatch for Isz/Dsz instructions:<br>*These opcodes are executed so rarely that speed is of little importance.<br>*T contains PCF[IBuf] and 377<br><br>*Non-indirect Isz/Dsz<br>IszDsz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], DblGoTo[Dsz1,Isz1,ALU&lt;0], DispTable[20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*pg 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], DblGoTo[Dsz1,Isz1,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*pg 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + T, DblGoTo[PCDsz,PCIsz,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[R177400] + T, DblGoTo[PCDsz,PCIsz,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,RTemp], DblGoTo[Dsz1,Isz1,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R177400) or T, FreezeResult, GoTo[.-1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC3,RTemp], DblGoTo[Dsz1,Isz1,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*ac3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R177400) or T, FreezeResult, GoTo[.-1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-ac3<br><br>*Indirect Isz/Dsz<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], FreezeResult, GoTo[IndDszIsz];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], FreezeResult, GoTo[IndDszIsz];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + T, DblGoTo[PCIndDsz,PCIndIsz,ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[R177400] + T, FreezeResult, GoTo[PCIndDszIsz];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,RTemp], FreezeResult, GoTo[IndDszIsz];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R177400) or T, FreezeResult, GoTo[.-1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC3,RTemp], FreezeResult, GoTo[IndDszIsz];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R177400) or T, FreezeResult, GoTo[.-1];<br><br>PCDsz:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[PCB,RTemp], GoTo[Dsz1];<br><br>PCIsz:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[PCB,RTemp];<br>Isz1:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; T, Task;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even; save efadr with bypass kludge<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) + (2C);<br>Dsz1:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; T, CSkipData, Call[neRet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd; save efadr with bypass kludge<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) - 1;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[MDS,RTemp], DblGoTo[neTask1st,neTaskSkp,ALU#0];<br><br>PCIndDsz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Zero) - 1, Skip;<br>PCIndIsz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Zero;<br>PCIndDszIsz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[PCB,RTemp], FreezeResult;<br>IndDszIsz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTemp, FreezeResult, GoTo[IszDsz];<br><br>neTaskSkp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipData, Call[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even; may cause refill (fake call)<br>neCS1st:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Call[neRet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skip even byte of opcode (no refill)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, T &larr; R177400, GoTo[ne2nd];<br><br>*Opcodes that smash TPC 0 by tasking or calling a subroutine exit at<br>*neTask1st to task immediately before starting the next opcode.<br>neTask1st:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[neRet];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, T &larr; R177400, GoTo[ne2nd];<br><br>*Average timing: LDA = 17, STA = 19.25, LDA@ = 30.25, STA@ = 30.75;<br>*+ 2 if PC-relative<br><br>*In addition, an A-group opcode referencing the AC of an immediately preceding<br>*LDA/LDA@ will be slowed by 2 cycles; a LDA, LDA@, or STA@ following a<br>*STA/STA@ will be slowed by 4 cycles (but slowed by 0 after buffer refill or<br>*by only 2 if PC-relative); a JSR, JMP, JSR@, or JMP@ will be slowed by<br>*4 (positive efadr) or 6 (negative efadr) cycles (but by only 0 or 2 cycles<br>*if buffer refill occurred).<br><br>**Maximum time to Return = 32 cycles on PC-rel STA@ barring error-correction.<br><br>*Non-indirect Lda/Sta (CNextData&rsquo;s obtain odd byte of opcode = efadr)<br>LdaSta:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf], DblGoTo[PzSta,PzLda,ALU&lt;0], DispTable[20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*pg 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf], DblGoTo[PzSta,PzLda,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*pg 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[R177400] and T, FreezeResult, GoTo[PCLdaSta];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[R177400], FreezeResult, GoTo[PCLdaSta];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf], DblGoTo[AC2Sta,AC2Lda,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf] or not T, DblGoTo[AC2Sta,AC2Lda,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*-ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf], DblGoTo[AC3Sta,AC3Lda,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*ac3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf] or not T, DblGoTo[AC3Sta,AC3Lda,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*-ac3<br><br>*Indirect Lda/Sta<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf], FreezeResult, GoTo[PzLdaStaInd];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*@pg 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf], FreezeResult, GoTo[PzLdaStaInd];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*@pg 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[R177400] and T, FreezeResult, GoTo[PCLdaStaInd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*@pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[R177400], FreezeResult, GoTo[PCLdaStaInd];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*@-pc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf], FreezeResult, GoTo[AC2LdaStaInd];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*@ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf] or not T, FreezeResult, GoTo[AC2LdaStaInd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*@-ac2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf], FreezeResult, GoTo[AC3LdaStaInd];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*@ac3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf] or not T, FreezeResult, GoTo[AC3LdaStaInd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*@-ac3<br><br>*The check for buffer refill costs 2 cycles 3/4 of the time, when refill<br>*doesn&rsquo;t occur but saves 14 cycles 1/4 of the time when refill occurs,<br>*for an average saving of 2 cycles/STA.<br>StaIFF:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[PCB,IBuf,4];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF &larr; RZero;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) + (4C);<br>PzStaF:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[MDS,Stack], Return;<br><br>PCSta:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCB) + T, DblGoTo[StaIFF,PzStaF,BPCChk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>AC2Sta:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC2) + T, DblGoTo[StaIFF,PzStaF,BPCChk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>AC3Sta:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC3) + T, DblGoTo[StaIFF,PzStaF,BPCChk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>PzSta:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">DblGoTo[StaIFF,PzStaF,BPCChk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br><br>PCLdaSta:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf] + T, DblGoTo[PCSta,PCLda,ALU&lt;0];<br><br>*Refill check saves 3.5 cycles/LDA@<br>LdaIndFin:</span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[LdaIndF1,BPCChk&rsquo;];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[PCB,IBuf,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF &larr; RZero;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) + (4C);<br>LdaIndF1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTemp;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br>PzLda:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,Stack], Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br>PCLda:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[PCB,Stack], Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br>AC2Lda:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,Stack], Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br>AC3Lda:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC3,Stack], Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br><br>*Refill check saves 5.75 cycles/STA@.<br>StaIndFin:</span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[StaIndF1,BPCChk&rsquo;];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[PCB,IBuf,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF &larr; RZero;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) + (4C);<br>StaIndF1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTemp, GoTo[PzStaF];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br><br>PCLdaStaInd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; CNextData[IBuf] + T, FreezeResult;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[PCB,RTemp], DblGoTo[StaIndFin,LdaIndFin,ALU&lt;0];<br>PzLdaStaInd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], DblGoTo[StaIndFin,LdaIndFin,ALU&lt;0];<br>AC2LdaStaInd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,RTemp], DblGoTo[StaIndFin,LdaIndFin,ALU&lt;0];<br>AC3LdaStaInd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC3,RTemp], DblGoTo[StaIndFin,LdaIndFin,ALU&lt;0];<br><br>*Dispatch table for register-register instructions.  16-way Dispatch on<br>*SrcAc,,DestAc is pending.<br><br>*Average timing: 29 to 34 cycles on logical; 31 to 36 cycles on arithmetic,<br>*including 4 cycles/opcode for buffer refill.<br>*Opcodes that skip average an additional 4.75 cycles.<br><br>**Max time to Return is 45 cycles on opcodes that skip and refill buffer.<br><br>neRegI:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF[IBuf] &larr; RCy[PCF[IBuf],3], Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC0, GoTo[neSrc0], DispTable[20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 0, DestAC = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC1, GoTo[neSrc0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 0, DestAC = 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC2, GoTo[neSrc0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 0, DestAC = 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC3, GoTo[neSrc0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 0, DestAC = 3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC0, GoTo[neSrc1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 1, DestAC = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC1, GoTo[neSrc1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 1, DestAC = 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC2, GoTo[neSrc1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 1, DestAC = 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC3, GoTo[neSrc1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 1, DestAC = 3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC0, GoTo[neSrc2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 2, DestAC = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC1, GoTo[neSrc2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 2, DestAC = 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC2, GoTo[neSrc2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 2, DestAC = 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC3, GoTo[neSrc2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 2, DestAC = 3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC0, GoTo[neSrc3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 3, DestAC = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC1, GoTo[neSrc3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 3, DestAC = 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC2, GoTo[neSrc3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 3, DestAC = 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC3, GoTo[neSrc3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SrcAC = 3, DestAC = 3<br><br>neSrc0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, LoadPage[aoPage], GoTo[neFnD];<br>neSrc1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1, LoadPage[aoPage], GoTo[neFnD];<br>neSrc2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC2, LoadPage[aoPage], GoTo[neFnD];<br>neSrc3:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC3, LoadPage[aoPage], GoTo[neFnD];<br><br>:IF[neFastAGroup]; *****************************<br>neFnD:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],10,3], GoToP[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Function field<br>OnPage[aoPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],13,4], Disp[aoFNC];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Shift and carry fields<br><br>%Put the function result in both T and the smashable temporary below the<br>destination AC.  Disp into either aoSHC (logical) or aoSHCc (arithmetic);<br>arithmetic operations complement the incoming carry if the ALU carry-out<br>is 1.<br>%<br>aoFNC:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Zero) xnor T, Disp[aoSHC], DispTable[10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*com<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Zero) - T, Disp[aoSHCc];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*neg<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; T, Disp[aoSHC];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*mov<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Zero) + T +1, Disp[aoSHCc];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*inc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Stack&-1) - T -1, Disp[aoSHCc];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*adc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Stack&-1) - T, Disp[aoSHCc];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*sub<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Stack&-1) + T, Disp[aoSHCc];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*add<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Stack&-1) and T, Disp[aoSHC];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*and<br><br>*We use Carry = 177777 for carry-in = 1, Carry = 0 for carry-in = 0<br>aoSHC:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Carry, DblGoTo[aoNN,aoNZ,ALU#0], DispTable[20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Nosh, Carry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DblGoTo[cZrN,cZrZ,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Nosh, 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DblGoTo[cNrN,cNrZ,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Nosh, 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Carry) xnor (0C), DblGoTo[aoNN,aoNZ,ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Nosh, Carry&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Carry, DblGoTo[aoL1,aoL0,R&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh, Carry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LSh[Stack,1], DblGoTo[aoFC1,aoFC0,R&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh, 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LSh[Stack,1])+1, DblGoTo[cNrNa,cZrNa,R&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh, 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Carry, DblGoTo[aoL1a,aoL0a,R&gt;=0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh, Carry&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Carry, T &larr; 100000C, DblGoTo[aoR1,aoR0,R&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh, Carry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RSh[Stack,1], DblGoTo[aoFC1,aoFC0,R Odd];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh, 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; RCy[Stack,1], DblGoTo[aoRO,aoRE,R Odd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh, 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Carry, T &larr; 100000C, DblGoTo[aoR1a,aoR0a,R&gt;=0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh, Carry&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Carry, DblGoTo[aoSN,aoSZ,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Swap, Carry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RCy[Stack,10], DblGoTo[cZrN,cZrZ,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Swap, 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RCy[Stack,10], DblGoTo[cNrN,cNrZ,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Swap, 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Carry) xnor (0C), DblGoTo[aoSN,aoSZ,ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Swap, Carry&rsquo;<br><br>*Arithmetic ALU operations use this table.<br>*The RSh-Carry&rsquo; and Swap-Carry&rsquo; table entries are never executed by the<br>*Executive, Bravo, or FTP.<br>aoSHCc:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Carry) + 1, UseCOutAsCIn, DblGoTo[aoNN,aoNZ,ALU#0], DispTable[20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Nosh, Carry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RZero) + 1, UseCOutAsCIn, DblGoTo[aoNN,aoNZ,ALU#0];*Nosh, 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RZero) - 1, UseCOutAsCIn, DblGoTo[aoNN,aoNZ,ALU#0];*Nosh, 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Carry, FreezeResult, GoTo[aoNX];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Nosh, Carry&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Carry) + 1, UseCOutAsCIn, DblGoTo[aoLS,aoLA,R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh, Carry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Stack) + T, UseCOutAsCIn, DblGoTo[aoFC1,aoFC0,R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh, 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RZero) - 1, UseCOutAsCIn, GoTo[aoLS];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh, 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Carry) + 1, UseCOutAsCIn, GoTo[aocL];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh, Carry&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Carry) + 1, UseCOutAsCIn, GoTo[aocR];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh, Carry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 100000C, DblGoTo[aoR1,aoR0,Carry];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh, 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 100000C, DblGoTo[aoR1a,aoR0a,Carry&rsquo;];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh, 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Carry) + 1, UseCOutAsCIn, GoTo[aocRa];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh, Carry&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Carry) + 1, UseCOutAsCIn, DblGoTo[aoSN,aoSZ,ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Swap, Carry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RZero) + 1, UseCOutAsCIn, DblGoTo[aoSN,aoSZ,ALU#0];*Swap, 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RZero) - 1, UseCOutAsCIn, DblGoTo[aoSN,aoSZ,ALU#0];*Swap, 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Carry, FreezeResult, GoTo[aoSX];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Swap, Carry&rsquo;<br><br>aoNN:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack, DblGoTo[cNrNa,cZrNa,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>aoNZ:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack, DblGoTo[cNrZa,cZrZa,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br><br>aoSN:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RCy[Stack,10], DblGoTo[cNrNa,cZrNa,ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>aoSZ:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RCy[Stack,10], DblGoTo[cNrZa,cZrZa,ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br><br>aoL1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LSh[Stack,1])+1, DblGoTo[cNrNa,cZrNa,R&lt;0];<br>aoL0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LSh[Stack,1], DblGoTo[aoFC1,aoFC0,R&lt;0];<br><br>aoL1a:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LSh[Stack,1])+1, DblGoTo[cNrNa,cZrNa,R&lt;0];<br>aoL0a:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LSh[Stack,1], DblGoTo[aoFC1,aoFC0,R&lt;0];<br><br>aoRO:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],2,1], DblGoTo[cNrNLd,cNrLd,R Odd];<br>aoRE:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Stack) or (100000C), GoTo[cZrN];<br><br>aoR1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RSh[Stack,1]) or T, DblGoTo[cNrNa,cZrNa,R Odd];<br>aoR0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RSh[Stack,1], DblGoTo[aoFC1,aoFC0,R Odd];<br><br>aoR1a:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RSh[Stack,1]) or T, DblGoTo[cNrNa,cZrNa,R Odd];<br>aoR0a:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RSh[Stack,1], DblGoTo[aoFC1,aoFC0,R Odd];<br><br>aoNX:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RZero) - T - 1, UseCOutAsCIn, DblGoTo[aoNN,aoNZ,ALU#0];<br><br>aoLS:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LSh[Stack,1]) - T, DblGoTo[aoFC1,aoFC0,R&lt;0];<br>aoLA:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LSh[Stack,1]) + T, DblGoTo[aoFC1,aoFC0,R&lt;0];<br><br>aocL:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DblGoTo[aoL1a,aoL0a,ALU=0];<br><br>aocR:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 100000C, DblGoTo[aoR1,aoR0,ALU#0];<br><br>aocRa:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 100000C, DblGoTo[aoR1a,aoR0a,ALU=0];<br><br>aoSX:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RZero) - T - 1, UseCOutAsCIn, DblGoTo[aoSN,aoSZ,ALU#0];<br><br>cNrZa:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],0,3], DblGoTo[cNrNLd,cNrLd,R Odd];<br>cZrZa:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],0,3], DblGoTo[cZrNLd,cZrLd,R Odd];<br>:ELSE; *****************************************<br>neFnD:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],15,2], GoToP[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Carry field<br>OnPage[aoPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],10,3], Disp[aoCRY];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Function field<br><br>aoCRY:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Carry, Disp[aoFNC], DispTable[4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*cin &larr; Carry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; 0C, Disp[aoFNC];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*cin &larr; 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; 100000C, Disp[aoFNC];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*cin &larr; 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Carry) xnor (0C), Disp[aoFNC];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*cin &larr; Carry&rsquo;<br><br>%Put the function result in both T and the smashable temporary below the<br>destination AC.  Disp into either neSHC (logical) or neSHCc (arithmetic);<br>arithmetic operations complement the incoming carry if the ALU carry-out<br>is 1.<br>%<br>aoFNC:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Zero) xnor T, DblGoTo[aoNTC1,aoNTC0,ALU&lt;0], DispTable[10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*com<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Zero) - T, DblGoTo[aoTC1,aoTC0,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*neg<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; T, DblGoTo[aoNTC1,aoNTC0,ALU&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*mov<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Zero) + T +1, DblGoTo[aoTC1,aoTC0,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*inc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Stack&-1) - T -1, DblGoTo[aoTC1,aoTC0,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*adc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Stack&-1) - T, DblGoTo[aoTC1,aoTC0,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*sub<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Stack&-1) + T, DblGoTo[aoTC1,aoTC0,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*add<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; (Stack&-1) and T, DblGoTo[aoNTC1,aoNTC0,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*and<br><br>*ALU carry out has no effect on carryin--dispatch on shift field<br>aoNTC0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],13,2], GoTo[aoCo0];<br>aoNTC1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],13,2], GoTo[aoCo1];<br><br>*ALU carry complements carryin--dispatch on shift field<br>aoTC0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],13,2], DblGoTo[aoCo1,aoCo0,Carry];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*carryin = 0<br>aoTC1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],13,2], DblGoTo[aoCo0x,aoCo1x,Carry];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*carryin = 1<br><br>aoCo0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Stack, Disp[aoSH00];<br>aoCo1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Stack, Disp[aoSH10];<br><br>aoCo0x:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Stack, Disp[aoSH00];<br>aoCo1x:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; Stack, Disp[aoSH10];<br><br>*Shift dispatch for final carry = 0<br>aoSH00:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DblGoTo[cZrZ,cZrN,ALU=0], DispTable[4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; LSh[Stack,1], DblGoTo[aoFC1,aoFC0,R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; RSh[Stack,1], DblGoTo[aoFC1,aoFC0,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; LCy[Stack,10], DblGoTo[cZrZ,cZrN,ALU=0];<br><br>aoSH10:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DblGoTo[cNrZ,cNrN,ALU=0], DispTable[4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; (LSh[Stack,1]) + 1, DblGoTo[cNrNa,cZrNa,R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; RCy[Stack,1], DblGoTo[aoF1r1,aoF0r1,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; LCy[Stack,10], DblGoTo[cNrZ,cNrN,ALU=0];<br><br>aoF0r1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; (Stack) or (100000C), GoTo[cZrN];<br>aoF1r1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],2,1], DblGoTo[cNrNLd,cNrLd,R Odd];<br>:ENDIF; ****************************************<br><br>aoFC1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DblGoTo[cNrN,cNrZ,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>aoFC0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DblGoTo[cZrN,cZrZ,ALU#0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br><br>cZrNa:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],1,2], DblGoTo[cZrNLd,cZrLd,R Odd];<br>cNrNa:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],2,1], DblGoTo[cNrNLd,cNrLd,R Odd];<br><br>cZrZ:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],0,3], DblGoTo[cZrNLd,cZrLd,R Odd];<br>cZrN:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],1,2], DblGoTo[cZrNLd,cZrLd,R Odd];<br><br>cNrZ:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],0,3], DblGoTo[cNrNLd,cNrLd,R Odd];<br>cNrN:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],2,1], DblGoTo[cNrNLd,cNrLd,R Odd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Either table ok<br><br>*NOTE: PCF &larr; PCF[SkipPCF0] will point PCF at the even byte of the word<br>*after the opcode being skipped.<br>cZrNLd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1, Disp[.+2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*No load<br>cZrLd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Carry &larr; 0C, Disp[.+1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Load<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Stack&+1 &larr; T, CSkipData, Return, DispTable[10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; PCF[SkipPCF0], DblGoTo[aoRfl,aoXit,R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; PCF[SkipPCF0], DblGoTo[aoRfl,aoXit,R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*szc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Stack&+1 &larr; T, CSkipData, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*snc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; PCF[SkipPCF0], DblGoTo[aoRfl,aoXit,R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*szr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Stack&+1 &larr; T, CSkipData, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*snr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; PCF[SkipPCF0], DblGoTo[aoRfl,aoXit,R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*sez<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Stack&+1 &larr; T, CSkipData, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*sbn<br><br>cNrNLd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1, Disp[.+2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*No load<br>cNrLd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Carry &larr; (Carry) or not (0C), Disp[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Load<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Stack&+1 &larr; T, CSkipData, Return, DispTable[10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; PCF[SkipPCF0], DblGoTo[aoRfl,aoXit,R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Stack&+1 &larr; T, CSkipData, Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; PCF[SkipPCF0], DblGoTo[aoRfl,aoXit,R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; PCF[SkipPCF0], DblGoTo[aoRfl,aoXit,R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Stack&+1 &larr; T, CSkipData, Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; PCF[SkipPCF0], DblGoTo[aoRfl,aoXit,R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Stack&+1 &larr; T, CSkipData, Return;<br><br>%The straightforward way of doing an A-group skip is as follows:<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T, CSkipData;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Can&rsquo;t cause refill<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Task;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Might refill<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Can&rsquo;t refill<br>ne1stx:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, T &larr; R177400, GoTo[ne2nd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Might refill<br><br>This method has the serious drawback that the A-group exit has to be on nePage<br>(else add another mi); also average timing for this sequence is 10 cycles<br>compared to 6.75 for the sequence using the SkipPCF registers;<br>worst case time to return is 5 cycles faster for SkipPCF also.<br>%<br>aoRfl:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[PCB,IBuf,4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) + (4C);<br>aoXit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T, Return;<br><br>%Alto augmented instruction set ([Indigo]&lt;DoradoDocs&gt;ExtendedOpcodes.Press)<br><br>60000</span><span class="tab" val="67"></span><span style="font: 10pt serif">CYCLE</span><span class="tab" val="67"></span><span style="font: 10pt serif">Left Rotate<br><br>61000</span><span class="tab" val="67"></span><span style="font: 10pt serif">DIR</span><span class="tab" val="67"></span><span style="font: 10pt serif">Disable interrupts<br>61001</span><span class="tab" val="67"></span><span style="font: 10pt serif">EIR</span><span class="tab" val="67"></span><span style="font: 10pt serif">Enable interrupts<br>61002</span><span class="tab" val="67"></span><span style="font: 10pt serif">BRI</span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch and Return from interrupt<br>61003</span><span class="tab" val="67"></span><span style="font: 10pt serif">RCLK</span><span class="tab" val="67"></span><span style="font: 10pt serif">Read Clock<br>61004</span><span class="tab" val="67"></span><span style="font: 10pt serif">SIO</span><span class="tab" val="67"></span><span style="font: 10pt serif">Start I/O<br>61005</span><span class="tab" val="67"></span><span style="font: 10pt serif">BLT</span><span class="tab" val="67"></span><span style="font: 10pt serif">Block Transfer<br>61006</span><span class="tab" val="67"></span><span style="font: 10pt serif">BLKS</span><span class="tab" val="67"></span><span style="font: 10pt serif">Block Store<br>61007</span><span class="tab" val="67"></span><span style="font: 10pt serif">*SIT</span><span class="tab" val="67"></span><span style="font: 10pt serif">Start Interval Timer - NOP<br>61010</span><span class="tab" val="67"></span><span style="font: 10pt serif">JMPRAM</span><span class="tab" val="67"></span><span style="font: 10pt serif">Jump to RAM - only works if AC1 = 420 (enters Mesa)<br>61011</span><span class="tab" val="67"></span><span style="font: 10pt serif">RDRAM</span><span class="tab" val="67"></span><span style="font: 10pt serif">Read RAM - Returns -1<br>61012</span><span class="tab" val="67"></span><span style="font: 10pt serif">WRTRAM</span><span class="tab" val="67"></span><span style="font: 10pt serif">Write RAM - NOP<br>61013</span><span class="tab" val="67"></span><span style="font: 10pt serif">DIRS</span><span class="tab" val="67"></span><span style="font: 10pt serif">Disable interrupts and skip if on<br>61014</span><span class="tab" val="67"></span><span style="font: 10pt serif">VERS</span><span class="tab" val="67"></span><span style="font: 10pt serif">Version - AC0 &larr; 40000C<br>61015</span><span class="tab" val="67"></span><span style="font: 10pt serif">*DREAD</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0&larr;$AC3; AC1&larr;$(AC3 xor 1) (Alto 2 n.i.)<br>61016</span><span class="tab" val="67"></span><span style="font: 10pt serif">*DWRITE</span><span class="tab" val="67"></span><span style="font: 10pt serif">$AC3&larr;AC0; $(AC3 xor 1)&larr;AC1 (Alto 2 n.i.)<br>61017</span><span class="tab" val="67"></span><span style="font: 10pt serif">*DEXCH</span><span class="tab" val="67"></span><span style="font: 10pt serif">Double-word exchange (Alto 2 n.i.)<br>61020</span><span class="tab" val="67"></span><span style="font: 10pt serif">MUL</span><span class="tab" val="67"></span><span style="font: 10pt serif">Unsigned Multiply<br>61021</span><span class="tab" val="67"></span><span style="font: 10pt serif">DIV</span><span class="tab" val="67"></span><span style="font: 10pt serif">Unsigned Divide<br>61022</span><span class="tab" val="67"></span><span style="font: 10pt serif">WPRINTER Printer&larr;AC0 (Alto 2 DIAGNOSE1 n.i.)<br>61023</span><span class="tab" val="67"></span><span style="font: 10pt serif">RPRINTER AC0&larr;Printer (Alto 2 DIAGNOSE2 n.i.)<br>61024</span><span class="tab" val="67"></span><span style="font: 10pt serif">BITBLT</span><span class="tab" val="67"></span><span style="font: 10pt serif">Bit Block Transfer<br>61025</span><span class="tab" val="67"></span><span style="font: 10pt serif">XMLDA</span><span class="tab" val="67"></span><span style="font: 10pt serif">Loads AC0 from the AC1th alternate bank location<br>61026</span><span class="tab" val="67"></span><span style="font: 10pt serif">XMSTA</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stores AC0 into the AC1th alternate bank location<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">VM 177740+n[12:13d] are the normal bank for task n<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">VM 177740+n[14:15d] are the alternate bank for task n<br>61027</span><span class="tab" val="67"></span><span style="font: 10pt serif">DSPRATE</span><span class="tab" val="67"></span><span style="font: 10pt serif">Accepts new end-of-field fill in AC0 and returns old value in<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0.  213b selects 60 Hz, 11b is normal 77 Hz.<br>61030</span><span class="tab" val="67"></span><span style="font: 10pt serif">---<br>61031</span><span class="tab" val="67"></span><span style="font: 10pt serif">---<br>61032</span><span class="tab" val="67"></span><span style="font: 10pt serif">DSPWID</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 = -1 makes full display width available; = 0 reverts to<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">standard Alto-size picture.  Width returned in AC0.<br>61033</span><span class="tab" val="67"></span><span style="font: 10pt serif">MEMCFG</span><span class="tab" val="67"></span><span style="font: 10pt serif">Returns no. of 400b-word pages of storage in AC0, number of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">64k-word banks of VM in AC1.<br>61034</span><span class="tab" val="67"></span><span style="font: 10pt serif">POWOFF</span><span class="tab" val="67"></span><span style="font: 10pt serif">Power off machine<br>61035</span><span class="tab" val="67"></span><span style="font: 10pt serif">CSUM</span><span class="tab" val="67"></span><span style="font: 10pt serif">Compute ethernet-style checksum<br>61036</span><span class="tab" val="67"></span><span style="font: 10pt serif">LOADRAM</span><span class="tab" val="67"></span><span style="font: 10pt serif">load microstore from memory and optional start<br>61037</span><span class="tab" val="67"></span><span style="font: 10pt serif">SDP</span><span class="tab" val="67"></span><span style="font: 10pt serif">SetDefaultPartition<br><br>61040</span><span class="tab" val="67"></span><span style="font: 10pt serif">IOB Input (Dorado only)<br>61041</span><span class="tab" val="67"></span><span style="font: 10pt serif">IOB Output (Dorado only)<br>61042</span><span class="tab" val="67"></span><span style="font: 10pt serif">Halt</span><span class="tab" val="67"></span><span style="font: 10pt serif">(n.i.)<br>61043</span><span class="tab" val="67"></span><span style="font: 10pt serif">Turn on PC sampling (Dorado only)<br>61044</span><span class="tab" val="67"></span><span style="font: 10pt serif">General Input (Dorado only)<br>61045</span><span class="tab" val="67"></span><span style="font: 10pt serif">General Output (Dorado only)<br><br>64400</span><span class="tab" val="67"></span><span style="font: 10pt serif">JSRII</span><span class="tab" val="67"></span><span style="font: 10pt serif">Jump to subroutine, double indirect, pc relative<br>65000</span><span class="tab" val="67"></span><span style="font: 10pt serif">JSRIS</span><span class="tab" val="67"></span><span style="font: 10pt serif">Jump to subroutine, double indirect, ac2 relative<br>67000</span><span class="tab" val="67"></span><span style="font: 10pt serif">CONVERT</span><span class="tab" val="67"></span><span style="font: 10pt serif">Scan conversion of characters<br><br>NOTE: operations with * are not implemented, and will trap if executed when<br>the xoTraps switch in GlobalDefs is 1 or will jump to undefined locations<br>in the microstore if xoTraps is 0.<br><br>Want WRS232 and RRS232 opcodes?<br>%<br><br>*Opcode 60000 - 60177<br>*Left cycle AC0 by inst[12-15d], or by AC1 if count is 0.<br>Cycle:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF[IBuf] and (17C), GoToP[.+1], At[IO0Tab,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Test cycle count = 0<br><br>OnPage[xoPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF[IBuf] &larr; LSh[PCF[IBuf],4], GoTo[.+3,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; LSh[AC1,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*cycle by AC1 if count=0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF[IBuf] &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF[IBuf] &larr; (PCF[IBuf]) or (17C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CycleControl &larr; CNextData[IBuf];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*DBX&larr;cycle count, MWX&larr;17b<br>xoAC0RF:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; RF[AC0], Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Return to next opcode<br><br>*Opcodes 61000 - 61177<br>xoDisp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],13,4], DblGoToP[NoParA,NoParB,R Even], At[IO0Tab,4];<br><br>OnPage[xoPage];<br><br>*StkP must point at AC1 for BitBlt<br>NoParA:</span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC1, Disp[xoDIR];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Timing 12 thru here<br>NoParB:</span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; rwpAC1, Disp[xoEIR];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Timing 13 thru here<br><br>*JSRII - 64400, 64600<br>*JSR double indirect, PC relative<br>JSRIIp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + T, Skip, At[IO1Tab,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*EfAddr positive<br>JSRIIn:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[R177400] + T, At[IO1Tab,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*EfAddr negative<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[PCB,RTemp], Call[neRet];<br>JSRIS:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTemp, GoTo[JsrPzIF];<br><br>*JSRIS - 65000, 65200<br>*JSR double indirect, AC2 relative<br>JSRISp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,RTemp], GoTo[JSRIS], At[IO1Tab,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*EfAddr positive<br>JSRISn:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] or not (377C), GoTo[.-1], At[IO1Tab,5];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*EfAddr negative<br><br>%CONVERT - Opcode 67000, 67200<br>Registers:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ac0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">destination word address (upper left corner) minus NWRDS<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ac2</span><span class="tab" val="67"></span><span style="font: 10pt serif">+ Disp points to two word block:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">word 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">NWRDS -- number of words per scanline (&lt; 200b)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">word 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">dba -- minus dest bit addr mod 20b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ac3:</span><span class="tab" val="67"></span><span style="font: 10pt serif">pointer to word xh of the character descriptor block<br><br>Character Descriptor Block:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">word 0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xh-1</span><span class="tab" val="67"></span><span style="font: 10pt serif">bit map for character<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">word xh:</span><span class="tab" val="67"></span><span style="font: 10pt serif">xw -- (2*width) + 1, or (2*pseudochar)</span><span class="tab" val="67"></span><span style="font: 10pt serif">if extension required<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">word xh+1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">hd,,xh -- (scan lines to skip),,(height of bit map)<br>%<br>Convertp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,RTemp1], Skip, At[IO1Tab,14];<br>Convertn:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] or not (377C), GoTo[.-1], At[IO1Tab,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*fetch NWRDS<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RZero) + T + 1, LoadPage[ConvertPage1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,AC1], GoToP[.+1];<br>OnPage[ConvertPage1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC3,RTemp,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*RTemp&larr;self-relative ptr to xw<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, Task;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; T, CSkipData;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*setup for later, advance PC<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RTemp) - 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*self-relative ptr to xw - 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) + T, Task;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*point AC3 to start of the block<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; 16C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC3,xnXH,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*fetch hd,,xh<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; T &larr; (AC1) and (17C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*mask dba<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) - T, Call[.+3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*DMA &larr; DMA + (hd*xnNWRDS)<br>*Point DMA to the first dest word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xnXH &larr; (xnXH) + (177400C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; (DMA) + T, Skip[ALU&lt;0];<br>cvRT1toT:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; RTemp1, Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xnXH &larr; T &larr; (LDF[xnXH,10,10]) - 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*also decrement xh<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC3) - T, LoadPage[ConvertPage2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SMA &larr; T, GoToP[.+1];<br>OnPage[ConvertPage2];<br>xnCVLOOP:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,AC3], Task; *fetch source<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XBI &larr; IP[xBuf]C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xnXH &larr; (xnXH) - 1, GoTo[xnCNVEND,R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*test count<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[DMA,xBuf,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*fetch dest<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[DMA,16,2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*use StkP to index xBuf<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XBI &larr; (XBI) + T, LoadPage[ConvertPage3]; <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; XBI, CallP[neCVor];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CycleControl &larr; RTemp, Skip[R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  GoTo[xnCVX];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*odd; source exhausted<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; WFA[AC3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*even; source contribution to 2nd dest word, done if 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; LdF[SStkP&NStkP,16,2], GoTo[xnCVX,ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1, GoTo[doSingleWord,ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Go if not still in quadword<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) or T, GoTo[xnCVX];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*odd; OR the second Dest word<br><br>doSingleWord:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[DMA,XBI,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*even; fetch 2nd dest word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XBI &larr; (XBI) or T, LoadPage[ConvertPage1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*so XBI will be written<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[DMA,XBI,1], Call[cvRT1toT];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*UGH<br>**I think this mi and the NextInst; PStore4 by Mesa are the only mi subject<br>**to the Output/Output/PStore4 gotcha; if so, might be profitable to enforce<br>**Output/Output/PStore4 gotcha by requiring some delay after returning rather<br>**than all of it after the O/O.<br>xnCVX:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[DMA,xBuf,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*even; store buffer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTemp1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*get NWRDS<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; (DMA) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SMA &larr; T &larr; (SMA) + 1, GoTo[xnCVLOOP];<br><br>xnCNVEND:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; AC3, LoadPage[nePage], GoTo[.+2,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; RSh[AC3,1], GoToP[neTask1st];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; RSh[AC3,1], GoToP[neTaskSkp];<br><br>OnPage[ConvertPage3];<br>neCVor:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CycleControl &larr; AC1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RF[AC3]; *source contribution to first dest word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) or T, Return;<br><br>*Extended Opcodes with no Displacement or parameter<br>OnPage[xoPage];<br><br>xoDIR:</span><span class="tab" val="67"></span><span style="font: 10pt serif">NWW &larr; (NWW) or (100000C), GoTo[xoWRTRAM], At[xoTab0,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61000b<br><br><br>xoEIR:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) or (52C), At[xoTab1,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61001b<br>xoBRI1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,WW], Task;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NWW &larr; (NWW) and not (100000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (WW) and not (100000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NWW &larr; (NWW) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF[IBuf], LoadPage[nePage], DblGoToP[xoEIRz,xoBRIy,R Odd];<br>*EIR must test for interrupts NOW.  We simulate JMP .+1<br>xoEIRz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + 1, GoToP[PCJmp1];<br>xoBRIy:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) or (100C), GoToP[JmpPzInd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*fetch PC from location 500<br><br>xoBRI:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) or (52C), GoTo[xoBRI1], At[xoTab0,1] ;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61002b<br><br><br>xoRCLK:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[XMiscPage], At[xoTab1,1] ;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61003b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) or (30C), CallP[MXRClk];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTemp, GoTo[RCLK1];<br><br>:IF[With3MB];<br>xoSIO:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, LoadPage[</span><span style="font: 8pt serif">eePage</span><span style="font: 10pt serif">], At[xoTab0,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61004b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, GoToP[</span><span style="font: 8pt serif">ee</span><span style="font: 10pt serif">SIO];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*returns to next opcode<br>:ELSE;<br>*Return 77777b if no Ethernet microcode:<br>xoSIO:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[AllOnes,1,17], At[xoTab0,2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*61004b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T, CSkipData, return;<br>:ENDIF;<br><br><br>%BLT and BLKS:<br>  AC0</span><span class="tab" val="67"></span><span style="font: 10pt serif">address of first source word - 1 (BLT), or data to be stored (BLKS)<br>  AC1</span><span class="tab" val="67"></span><span style="font: 10pt serif">address of last destination word (= destination+word count-1)<br>  AC2</span><span class="tab" val="67"></span><span style="font: 10pt serif">unused<br>  AC3</span><span class="tab" val="67"></span><span style="font: 10pt serif">negative word count<br>%<br>:IF[neFastBltBlks]; ****************************<br>*Fast versions moving quadwords<br>*Average timing for BLT&rsquo;s longer than 8 words ~= 100 + 7.25*nwords cycles,<br>*assuming random alignment of source and destination and non-overlap case.<br>xoBLT:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, At[xoTab1,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61005b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC3) - T, Task;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; - word count - source + 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (AC1) + T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC1 &larr; destination-source<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">(AC1) and not (3C);<br>*Move the words one-at-a-time if destination address is 0 to 3 larger than<br>*the source address; restore AC1.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1 &larr; (AC1) - T, LoadPage[neIntPage0], Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC3 &larr; (AC3) + (4C), GoToP[Blt1W];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) + T, GoToP[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC3 &larr; destination-1<br>OnPage[neIntPage0];<br>*Dispatch on two low bits of destination-1 to transfer single words until<br>*destination is quadaligned.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[AC3,16,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) - T, Disp[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Restore AC3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; T &larr; (AC0) + 1, Call[BltLp], DispTable[4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*01<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; T &larr; (AC0) + 1, Call[BltLp];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*10<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; T &larr; (AC0) + 1, Call[BltLp];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*11<br>*Destination quadaligned; setup loop.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LU &larr; AC3, Call[BltZT];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*00<br><br>*Loop begins here with AC3 .ne. 0<br>*Check for .gr. 4 words to transfer (i.e., AC3 # -4, -3, -2, or -1)<br>*Check for .ge. 4 is better but slows inner loop by 5 cycles.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) + (4C);<br>*Dispatch on low two bits of Source-1 to determine optimal fetch<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[AC0,16,2], GoTo[Blt1W,Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC1) - (3C), Disp[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br><br>*Smashes wBuf3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[AC0,wBuf3,0], NonQuadOK, GoTo[Blt4S1], DispTable[4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*01 (smashes wBuf3)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[AC0,xBuf,1], GoTo[Blt4S2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*10<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[AC0,xBuf1,2], NonQuadOK, GoTo[Blt4S3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*11 (smashes yBuf)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[AC0,xBuf,1], GoTo[Blt4S];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*00 (quadaligned)<br><br>Blt4S1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC0,xBuf3,4], GoTo[Blt4S];<br>Blt4S2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[AC0,xBuf2,3], GoTo[Blt4S];<br>Blt4S3:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC0,xBuf,1], GoTo[Blt4S];<br>Blt4S:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) + (4C), GoTo[Blks4S];<br><br>Blt1W:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) - (4C), Call[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T &larr; (AC0) + 1;<br>BltLp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,xBuf], GoTo[BlksLp];<br><br>BltZT:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LoadPage[nePage], GoTo[BltXit];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br><br>*Average timing ~= 112 + 2.5*nwords cycles for nwords &gt; 8<br>xoBLKS:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, LoadPage[neBlksPage0], At[xoTab0,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61006b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; T, GoToP[.+1];<br>OnPage[neBlksPage0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Remoted for page packing<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf2 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf3 &larr; T, Task;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) + T, LoadPage[neIntPage0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC3 &larr; destination-1<br>*Dispatch on two low bits of destination-1 to transfer single words until<br>*destination is quadaligned.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[AC3,16,2], GoToP[.+1];<br>OnPage[neIntPage0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) - T, Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LU &larr; AC3, Call[BlksLx], DispTable[4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*01<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LU &larr; AC3, Call[BlksLx];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*10<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LU &larr; AC3, Call[BlksLx];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*11<br>*Quadaligned; setup loop--ensure word count .ne. 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LU &larr; AC3, Call[BltZT];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*00<br>*Loop here while .gr. 4 words to do<br>Blks4:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) + (4C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC1) - (3C), GoTo[Blks1W,Carry];<br>Blks4S:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; NWW, Skip[R&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PStore4[AC3,xBuf], Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[AC3,xBuf], DblGoTo[intEnt,int0Ret,ALU#0];<br><br>*Store one word in xBuf, check for done, check for interrupts, and loop<br>Blks1W:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) - (4C), Call[BlksLx];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>BlksLp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; AC3;<br>BlksLx:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC3 &larr; (AC3) + 1, Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC3 &larr; (AC3) - 1, LoadPage[nePage], GoTo[BltXit];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[AC1,xBuf], GoTo[intSub];<br><br>:ELSE; *****************************************<br>*Slower, smaller versions using single-word transfers<br>*Average timing is about 32 + 19*nwords cycles.<br>xoBLT:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T &larr; (AC0) + 1, LoadPage[nePage], At[xoTab1,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61005b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[neRet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*For tasking<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,xBuf], Call[BlksLp];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T &larr; (AC0) + 1, GoTo[.-1];<br><br>*Average timing ~= 30 + 17*nwords cycles<br>xoBLKS:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, LoadPage[nePage], At[xoTab0,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61006b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; T, Call[neRet];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*For tasking<br>BlksLp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; AC3, LoadPage[neIntPage0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC3 &larr; (AC3) + 1, SkipP[ALU#0];<br>OnPage[neIntPage0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC3 &larr; (AC3) - 1, LoadPage[nePage], GoTo[BltXit];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[AC1,xBuf], GoTo[intSub];<br>:ENDIF; ****************************************<br><br>BltXit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, GoToP[neTask1st];<br><br><br>xoSIT:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Return, At[xoTab1,3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*61007b (nop)<br><br>*JMPRAM - 61010 is in AltoX.Mc<br><br>xoRDRAM:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (Zero) - 1, At[xoTab1,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*61011b (return -1)<br>xoWRTRAM:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Return, At[xoTab0,5];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61012b (nop)<br><br>xoDIRS:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, At[xoTab1,5];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[nePage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NWW &larr; (NWW) or (100000C), DblGoToP[neTask1st,neTaskSkp,R&lt;0];<br><br>*VERS - 61014 in AltoX.Mc<br>*DREAD - 61015 not implemented (Alto II only)<br>*DWRITE - 61016 not implemented<br>*DEXCH - 61017 not implemented<br><br><br>%AC0,,AC1 &larr; (AC1 * AC2) + (AC0)<br>Steps:<br>1</span><span class="tab" val="67"></span><span style="font: 10pt serif">test loop count for done<br>2</span><span class="tab" val="67"></span><span style="font: 10pt serif">test next mpr bit (AC1[17]), RSh AC1<br>2a</span><span class="tab" val="67"></span><span style="font: 10pt serif">if 1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; AC0 + T<br>3a</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">RSh AC0, or&rsquo;ing 100000 into AC0 if add carried<br>2b</span><span class="tab" val="67"></span><span style="font: 10pt serif">if 0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RSh AC0<br>4a,3b</span><span class="tab" val="67"></span><span style="font: 10pt serif">or 100000 into AC1 if shifted a 1 out of AC0<br>%<br>xoMul:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC2, LoadPage[neMulPage], At[xoTab0,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61020b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; 16C, GoToP[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*setup loop<br>OnPage[neMulPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[xoMul1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) - 1, GoTo[.+3,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LoadPage[nePage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  CSkipData, GoToP[neTask1st];<br>*Loop time: 8 to 9 cycles on multiplier zeroes, 13 to 15 on multiplier ones<br>xoMul1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; RSh[AC1,1], Skip[R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; RSh[AC0,1], DblGoTo[xoMula,xoMulb,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; RCy[AC0,1], Skip[Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; (AC0) and not (100000C), DblGoTo[xoMula,xoMulb,ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) or (100000C), DblGoTo[xoMula,xoMulb,ALU&lt;0];<br><br>xoMula:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (AC1) or (100000C), Return;<br>xoMulb:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br><br><br>*AC0,,AC1/AC2.  Quotient in AC1, remainder in AC0<br>*Timing xoDiv to exit = 19 + (9/quotient 1) + (12/quotient 0) cycles.<br>xoDiv:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[neDivPage], T &larr; AC2, At[xoTab1,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61021b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (AC0) - T, GoToP[.+1];<br>OnPage[neDivPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; 16C, GoTo[.+3,Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LoadPage[nePage];<br>xoDivX:</span><span class="tab" val="67"></span><span style="font: 10pt serif">  RTemp, CSkipData, DblGoTo[neTask1st,neTaskSkp,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 31C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC2, SALUF &larr; T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*SALUF &larr; A+A+1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; (Zero) - T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Save minus divisor<br>*1st bit shifted in is "don&rsquo;t care" (shifted out on the final step).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (AC1) SALUFOP T, Call[xoDvE];<br>%Shift the high dividend left 1 while subtracting the divisor and adding in<br>the bit shifted out of the low dividend; +1 compensates for -1 inserted at<br>end of loop, and this circumlocution makes the carry correct for the problem<br>divisors 1 and 177777b.<br>%<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (LSh[AC0,1]) + T + 1, Skip[R&gt;=0];<br>*Shift the low dividend while bringing in the quotient bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC1 &larr; (AC1) SALUFOP T, GoTo[xoDvSb];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (AC1) SALUFOP T, UseCOutAsCIn, GoTo[xoDvSb,Carry];<br>*Subtract failed.  We would like to use the fact that<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">((Divd+Divs) lshift 1) - Divs = (Divd lshift 1) + Divs<br>*I.e., we would like to add rather than subtract on the next step, but<br>*the carries get screwed up.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC2, FreezeResult;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) + T, FreezeResult;<br>*Subtract succeeded.<br>xoDvSb:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) - 1, FreezeResult, Skip[R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LoadPage[nePage], GoTo[xoDivX];<br>*Subtract divisor from high dividend on 1st/next step while adding in bit<br>*shifted out of low dividend<br>xoDvE:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RTemp1) - 1, UseCOutAsCIn, Return;<br><br>%Obsolete divide.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; 17C, GoTo[.+3,Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LoadPage[nePage];<br>xoDivX:</span><span class="tab" val="67"></span><span style="font: 10pt serif">  RTemp, CSkipData, DblGoTo[neTask1st,neTaskSkp,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 31C;<br>*1st bit shifted into AC1 is "don&rsquo;t care" because AC1 will be shifted an<br>*extra time at the end.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SALUF &larr; T, T &larr; AC2, Call[xoDvA1];<br>*Loop time 11 to 12 cycles/bit.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RSh[RTemp,1]) - 1, GoTo[xoDvCryT,R Even];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) - T, Skip[ALU&gt;=0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Subtract divisor<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC1 &larr; (AC1) SALUFOP T, GoTo[xoDvX0];<br>xoDvA1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (AC1) SALUFOP T, GoTo[xoDvSb];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Force quotient bit to 1<br>xoDvCryT:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) - T, GoTo[xoDvA0,ALU&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Subtract divisor<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC1 &larr; (AC1) SALUFOP T, UseCOutAsCIn, Skip[Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    AC0 &larr; (AC0) + T;<br>xoDvX0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">  RTemp &larr; (RTemp) + 1, LoadPage[nePage], GoTo[xoDivX];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skip exit<br>xoDvA0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (AC1) SALUFOP T, UseCOutAsCIn, Skip[Carry];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Successful?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; (AC0) + T, FreezeResult;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*No--undo<br>xoDvSb:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) SALUFOP T, UseCOutAsCIn;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) SALUFOP T, UseCOutAsCIn, Return;<br>%<br><br>xoPrinterGetsAC0:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Printer &larr; AC0, GoTo[xoWRTRAM], At[xoTab0,11];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61022b<br><br>xoAC0GetsPrinter:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Printer, GoTo[TtoAC0CSR], At[xoTab1,11];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61023b<br><br>**Enter bbBitBLT with StkP pointing at AC1 (icom*2), pointer to BitBlt table<br>*in AC2, and (Cycle&PCXF) and not (100000C) in T.<br>:IF[WithAltoBitBlt];<br>xoBitBlt:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[bbPage], At[xoTab0,12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61024b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Cycle&PCXF) and not (100000C), GoToP[bbBitBLT];<br>:ELSE;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Return, At[xoTab0,12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61024b<br>:ENDIF;<br><br><br>:IF[AltoXMMode]; *******************************<br>xoXMLDA:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RZero) or not (37C), GoTo[xoABSU], At[xoTab1,12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61025b<br><br>xoXMSTA:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RZero) or not (37C), GoTo[xoABSU], At[xoTab0,13];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61026b<br><br>xoABSU:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,LPhi];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1, Task;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LP &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LPhi &larr; LdF[LPhi,16,2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LPhi &larr; (LSh[LPhi,10]) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF[IBuf], LoadPage[nePage], Skip[R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PStore1[LP,AC0,0], GoToP[neCS1st];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[LP,AC0,0], GoToP[neCS1st];<br>:ELSEIF[xoTraps]; ******************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[nePage], GoTo[xoUnIm], At[xoTab1,12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61025b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[nePage], GoTo[xoUnIm], At[xoTab0,13];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61026b<br>:ENDIF; ****************************************<br><br>*Exchange AC0 with the end-of-field fill parameter for the display.<br>*11b is normal (77d Hz.); 213b is for videotaping (60 Hz.).  This works<br>*only for the LF monitor.  Code is completed in Display.Mc.<br>xoFrameRate:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, GoTo[vFrameRate], At[xoTab1,13];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61027b<br><br>xoDspWid:</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Put on DisplayPage to allow variant implementations<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPageExternal[DisplayPage], At[xoTab0,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61032b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, GoToExternal[dpWidthLoc];<br><br>xoMemCfg:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; IP[xPageCount]C, At[xoTab1,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61033b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP &larr; RTemp;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; 100C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*2&uarr;22-word VM = 2&uarr;6 * 2&uarr;16 = 100b banks<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack;<br>TtoAC0CSR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T, CSkipData, Return;<br><br>xoPOff:</span><span class="tab" val="67"></span><span style="font: 10pt serif">D0Off, GoTo[.], At[xoTab0,16];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*61034b<br><br>*AC0/ checksum (initialize to 0)<br>*AC1/ block pointer<br>*AC3/ word count<br>*Algorithm is CSum &larr; (CSum+Word) lcy 1 with 1&rsquo;s complement add<br>xoCSum:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; AC3, LoadPage[neCSPage], At[xoTab1,16];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61035b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[AC1,xBuf,0], DblGoToP[aCSbeg,aCSend,ALU#0];<br>OnPage[neCSPage];<br>aCSlp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (Zero) + T + 1, Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LCy[xBuf,1], Call[aCSwrd], DispTable[4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LCy[xBuf1,1], Call[aCSwrd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LCy[xBuf2,1], Call[aCSwrd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LCy[xBuf3,1], Call[aCSwrd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[AC1,xBuf,0];<br>aCSbeg:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; NWW, Skip[R&gt;=0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Skip if interrupts enabled<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; (AC1) or (3C), Skip;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC1) or (3C), Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Dispatch[AC1,16,2], GoTo[aCSlp];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*No int. requests<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[neIntPage0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (R400) + (52C), GoTo[intEnt1];<br><br>aCSwrd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC3 &larr; (AC3) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (LCy[AC0,1]) + T, Skip[ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; (AC0) + 1, UseCOutAsCIn, Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) + 1, UseCOutAsCIn;<br>aCSend:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (AC0) xnor (0C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RZero, LoadPage[nePage], Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; T, CSkipData, GoToP[neTask1st];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Change -1 result to 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, GoToP[neTask1st];<br><br>*AC0 pointer to array in MakeLoaderFile form<br>xoLRJ:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, LoadPage[neLRJPage], At[xoTab0,17];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61036b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LP &larr; T, CSkipData;<br>OnPage[neLRJPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; MDShi;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LPhi &larr; T;<br>*Setup PCB for continuation after SoftGo.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF.Word;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCB &larr; (PCB) + T;<br>*AC1 odd:  turn off tasking, do inline storage refresh; load control store,<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">   jump to starting address in the end item of the RAM image.<br>*AC1 even: normal tasking; ignore starting address, continue with next item.<br>*FFault should be even (to crash on MC1/Stk errors), but it is already even,<br>*so nothing special is required here.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RZero) + (100000C) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LdF[AC1,17,1]) xor T;<br>*RTemp1 &lt; 0 = call from Alto emulator<br>*odd = resume at JmpFin, even = jump to starting address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; T, LoadPageExternal[LRJPage];<br>**Low 4 bits of xfTemp1 should be 0 for inline refresh or 1 for normal tasking<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xfTemp1 &larr; T, GoToExternal[LRJStart];<br><br><br>xoSDP:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, LoadPage[XMiscPage], At[xoTab1,17];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*61037b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; T, CallP[MXPar];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*In Disk.Mc<br>RCLK1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T, LoadPage[nePage];<br>xoExit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, GoToP[neTask1st];<br><br>:IF[neBCPL300]; ********************************<br><br>OnPage[nePage];<br><br>*Arrive at brJsrPz on a JSR 200 to 377 with Efadr - 300 through the ALU.<br>brJsrPz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF[IBuf] - (333C), Skip[ALU&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch4[MDS,IBuf], GoTo[JsrFin];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*.ls. 300<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[brJsrPage], Skip[ALU&lt;0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LoadPage[nePage], GoToP[brJsrExit];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*.ge. 333<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],13,4], DblGoToP[br300Odd,br300Even,R Odd];<br><br>OnPage[brJsrPage];<br><br>brJsrExit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[MDS,IBuf], GoToP[JsrFin];<br><br>brJsrSNQ0:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[nePage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC1,RTemp,0], GoToP[brSNQ0jsr];<br><br>brJsrSNQ1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[nePage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC0,RTemp,0], GoToP[brSNQ1jsr];<br><br>br300Odd:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; RSh[AC1,6], Return, DispTable[15,17,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*301<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; RSh[AC1,5], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*303<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; RSh[AC1,4], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*305<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; RSh[AC1,3], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*307<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; RSh[AC1,2], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*311<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; RSh[AC1,1], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*313<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0 &larr; LSh[AC0,7], GoTo[brJsrSNQ0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*315<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0 &larr; LSh[AC0,6], GoTo[brJsrSNQ0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*317<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0 &larr; LSh[AC0,5], GoTo[brJsrSNQ0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*321<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0 &larr; LSh[AC0,4], GoTo[brJsrSNQ0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*323<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0 &larr; LSh[AC0,3], GoTo[brJsrSNQ0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*325<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0 &larr; LSh[AC0,2], GoTo[brJsrSNQ0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*327<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0 &larr; LSh[AC0,1], GoTo[brJsrSNQ0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*331<br><br>br300Even:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; RSh[AC0,6], Return, DispTable[16,17,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*300<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; RSh[AC0,5], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*302<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; RSh[AC0,4], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*304<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; RSh[AC0,3], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*306<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; RSh[AC0,2], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*310<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; RSh[AC0,1], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*312<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*314 (nop)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1 &larr; LSh[AC1,7], GoTo[brJsrSNQ1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*316<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1 &larr; LSh[AC1,6], GoTo[brJsrSNQ1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*320<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1 &larr; LSh[AC1,5], GoTo[brJsrSNQ1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*322<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1 &larr; LSh[AC1,4], GoTo[brJsrSNQ1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*324<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1 &larr; LSh[AC1,3], GoTo[brJsrSNQ1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*326<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1 &larr; LSh[AC1,2], GoTo[brJsrSNQ1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*330<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1 &larr; LSh[AC1,1], GoTo[brJsrSNQ1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*332<br><br>:ENDIF; ****************************************<br><br>:IF[neBCPLI340]; *******************************<br><br>OnPage[nePage];<br><br>*BCPL Runtime: JSR @ 340-357<br>br340Disp:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],14,4], GoToP[.+1];<br>OnPage[br340Page];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1, Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) or T, GoTo[xoWRTRAM], DispTable[20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC0&larr;AC0 or AC1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) xor T, GoTo[xoWRTRAM];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC0&larr;AC0 xor AC1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; (AC0) xnor T, GoTo[xoWRTRAM];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC0&larr;AC0 xnor AC1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[nePage], GoTo[br340NI];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Mult<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[nePage], GoTo[br340NI];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*DivRem<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[nePage], GoTo[br340NI];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*DivRem<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC1) - (20C), DblGoTo[brLShNeg,brLShPos,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC0 &larr; AC0 lsh AC1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC1) - (20C), DblGoTo[brRShNeg,brRShPos,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC0 &larr; AC0 rsh AC1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, GoTo[brBranch];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Switchon branch<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, GoTo[brLookup];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Switchon lookup<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[nePage], GoTo[br340NI]; *Util (swats)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[nePage], GoTo[br340NI]; *Finish<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[nePage], GoTo[br340NI]; *Abort<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, GoTo[brLongJump];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Long jump<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[nePage], GoTo[br340NI]; *GetLV (swats)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[nePage], GoTo[br340NI]; *MulPlus<br><br>br340NI:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], GoToP[JsrIndFin];<br><br>*These don&rsquo;t contribute significantly to performance.<br>brLShNeg:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (AC1) + (17C), GoTo[brLShNeg1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC1 &larr; 17b - RSh count<br>brLShPos:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (Zero) - T - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC1 &larr; 17b - LSh count<br>brRShNeg1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CycleControl &larr; AC1, CSkipData, Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; 0C, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh count &gt; 17b<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; WFA[AC0], Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LSh count = 0 to 17b<br><br>brRShNeg:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (AC1) + (17C), GoTo[brRShNeg1];<br>brRShPos:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; (Zero) - T - 1, Skip[ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC1 &larr; 17b - RSh count<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; 0C, GoTo[xoWRTRAM];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh count &gt; 17b<br>*Go if RSh count = 1 to 17b.<br>brLShNeg1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">CycleControl &larr; AC1, CSkipData, GoTo[xoAC0RF,ALU&gt;=0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; 0C, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*RSh count = 0, LSh count &lt; -17b<br><br>br340AC0toT:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0, Return;<br><br>%Branch: "switchon" implemented by dispatch.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">jsr @350</span><span class="tab" val="67"></span><span style="font: 10pt serif">; with case value in AC0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  value of last case<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  number of cases<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lastTarget-.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ...<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  firstTarget-.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">continue here if out of range, AC0 unchanged<br>%<br>brBranch:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Call[br340AC0toT];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Point PCF at odd byte of last case value<br>*T &larr; last case value - switchon value<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] - T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Skip[Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  SkipData, Call[brBrn1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*.gr. last case; fake call<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipData;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Point PCF at odd byte of no. cases; fake call<br>*LU &larr; no. cases - (last case value - switchon value) - 1 =<br>*LU &larr; switchon value - (last case value - no. cases + 1) =<br>*LU &larr; switchon value - first case value<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF[IBuf] - T - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + T + 1, GoTo[brBrn1,Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[PCB,RTemp];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fetch self-rel ptr to new address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; T, LoadPage[nePage];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Bypass kludge<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RTemp) + T, GoToP[brJmpPz];<br><br>brBrn1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] + 1, LoadPage[nePage];<br>brLk1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + T, GoToP[PCJmp1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Jump to out-of-range<br><br><br>%Switchon "lookup"; calling sequence as follows:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">jsr @351</span><span class="tab" val="67"></span><span style="font: 10pt serif">; with case value in AC0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  number of cases<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  case value 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  target1-.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ...<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  case value n<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  targetn-.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">continue here if not found, AC0 unchanged.<br>%<br>brLookup:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipData;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Point PCF at odd byte of no. cases; may refill<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; T, CSkipData, Call[br340AC0toT];<br>*Have PCF pointing at even byte of case value j, value being looked up in T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Point PCF at odd byte of case value j; may refill<br>brLookLp:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF[IBuf] - T, Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; RZero, LoadPage[nePage], GoTo[brLk1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, GoTo[.+3,ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Point PCF at even byte of targetj<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  CSkipData, Call[xoWRTRAM];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  CSkipData, GoTo[brLookLp];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Point PCF at odd byte of case value<br>%Long jump; calling sequence:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">jsr @355<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  target-.<br>%<br>brLongJump:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SkipData;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[nePage], GoTo[brLk1];<br><br>:ENDIF; ****************************************<br><br>:IF[neBCPLI360]; *******************************<br><br>%This code seems to be pinned to nePage by the following: (1) the SkipData<br>at brGetFrame+2; (2) the various CSkipData/SkipData&rsquo;s which might refill<br>IBuf (because only nePage has buffer refill at 377b of the page);<br>(3) The various GoTo[neCS1st]&rsquo;s.<br>%<br>OnPage[nePage];<br><br>*Arrive at JsrPzInd on Jsr @ 200-377; have EfAdr in T and in PCF[IBuf];<br>:IF[neBCPLI340]; *******************************<br>*LU &larr; PCF[IBuf] - (340C) is pending; check for BCPL runtime<br>JsrPzInd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF[IBuf] - (360C), Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch1[MDS,RTemp], GoTo[JsrIndFin];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*.ls. 340<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF[IBuf] - (371C), Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LoadPage[br340Page], GoTo[br340Disp];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*340-357<br>:ELSE; *****************************************<br>*LU &larr; PCF[IBuf] - (360C) is pending; check for BCPL runtime<br>JsrPzInd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF[IBuf] - (371C), Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch1[MDS,RTemp], GoTo[JsrIndFin];<br>:ENDIF; ****************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[PCF[IBuf],14,4], GoTo[JsrPzIF,ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CSkipData, Disp[brJsrI360];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*360-370<br><br>brJsrI360:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC1,RTemp,0], GoTo[brSNQ0], DispTable[11,17,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*SNQ0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC0,RTemp,0], GoTo[brSNQ1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SNQ1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC1) and (100000C), GoTo[brLY01];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LY01<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC0) and (100000C), GoTo[brLY10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*LY10<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,RTemp,3], GoTo[brSY01];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SY01<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,RTemp,3], GoTo[brSY10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*SY10<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,AC2,0], GoTo[brReturn];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Return<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], GoTo[JsrPzIF];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*StArgs (never xct)<br>%GetFrame/StArgs is usually in the context:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">sta 3 1 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">jsr @GetFrame<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Frame size<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">jsr @StArgs<br>and is equivalent to the following pseudo-program:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">oldAC2 &larr; AC2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC2 - [PC+1] - 2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if [335] le T then swat (normal runtime does the swat)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC2 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">sta 0 4 2</span><span class="tab" val="67"></span><span style="font: 10pt serif">; Save arg1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">sta 1 5 2</span><span class="tab" val="67"></span><span style="font: 10pt serif">; Save arg2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">sta oldAC2 0 2</span><span class="tab" val="67"></span><span style="font: 10pt serif">; Save old frame ptr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; [[oldAC2+1]]</span><span class="tab" val="67"></span><span style="font: 10pt serif">; AC0 &larr; nargs passed<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if AC0 &lt; 3 then dblskip exit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Temp &larr; [oldAC2+3]</span><span class="tab" val="67"></span><span style="font: 10pt serif">; Temp &larr; arg3/frame rel ptr to extra args<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if AC0 eq 3 then sta Temp 6 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">else Move AC0-2 words from oldAC2 + Temp + 3 to AC2 + 6.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dblskip exit<br>%<br>brGetFrame:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 335C, Call[brFetToRTemp];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*RTemp &larr; stack limit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC2;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*DMA &larr; oldAC2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; T, SkipData;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Point PCF at odd byte of frame size (fake call)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,RTemp1,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*RTemp1 &larr; [oldAC2+1]<br>*Allocated frame must be 2 larger for ancient BCPL programs<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf] + 1, LoadPage[brGarbPage1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; frame size + 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC2) - T - 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; AC2 - frame size - 2 = new frame ptr<br>OnPage[brGarbPage1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (RTemp) - T - 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*LU &larr; stklim - new frame pointer<br>*xBuf &larr; arg3/frel ptr to xargs<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[DMA,xBuf,3], GoTo[brGFok,Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCB &larr; (PCB) - 1, LoadPage[nePage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; 370C, GoToP[JsrPzIF];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Stack ovf--let software do it<br>brGFok:</span><span class="tab" val="67"></span><span style="font: 10pt serif">AC2 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[AC2,DMA,0], Call[brRTemp1ToT];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Save old frame ptr at [AC2]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[AC2,AC0,4], Call[brRTemp1ToT];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Save arg1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,AC0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*AC0 &larr; [[oldAC2+1]] = nargs passed<br>*PCF now points at the odd byte preceding the jsr @StArgs word<br>*Point PCF at the even byte of the opcode after jsr @StArgs and refill the<br>*buffer if necessary.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF &larr; PCF[SkipPCF0], GoTo[.+3,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch4[PCB,IBuf,4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCB &larr; (PCB) + (4C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[AC2,AC1,5];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even; Save arg2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC0) - (3C), Call[brSA];<br>brGFlp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[AC2,xBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) - 1;<br>***This is one of (many) LoadPage usages that prevents LogSE from being used<br>***because the PStore1 above might cause a fault if LogSE is true.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RZero) + T + 1, LoadPage[nePage], Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  GoToP[neTask1st];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Exit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[DMA,xBuf,1], GoToP[.+1];<br>OnPage[nePage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; (DMA) + 1, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Loop<br><br>OnPage[brGarbPage1];<br>brRTemp1ToT:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RTemp1, Return;<br><br>brSA:</span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; T, LoadPage[nePage], Skip[ALU&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*RTemp &larr; args to move<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  GoToP[neTask1st];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*&lt;=2 args--exit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (xBuf) + (3C), GoToP[.+3,ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even; skip if exactly 3 args<br>OnPage[nePage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch1[DMA,xBuf];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd; &gt;3 args<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  DMA &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Bypass kludge<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 6C, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Exactly 3 args<br><br>brSNQa:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[IBuf], LoadPage[brGarbPage0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; mask<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) and not T, GoToP[.+1];<br>OnPage[brGarbPage0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RTemp1) and T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp &larr; (RTemp) or T, Return;<br>OnPage[nePage];<br><br>*SNQ0 executes @AC1 &larr; (@AC1 & not mask) or (AC0 & mask) where the mask<br>*is [PC+1] and continues at PC+2.<br>brSNQ0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC0;<br>brSNQ0jsr:</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Enter here from JSR 300-332 opcodes also<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; T, CSkipData, Call[brSNQa];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*May refill IBuf<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[AC1,RTemp,0], GoTo[neCS1st];<br><br>*SNQ1 is like SNQ0 with AC0 and AC1 interchanged.<br>brSNQ1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; AC1;<br>brSNQ1jsr:</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Enter here from JSR 300-332 opcodes also<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; T, CSkipData, Call[brSNQa];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[AC0,RTemp,0], GoTo[neCS1st];<br><br>*Return right-justified in AC0 the AC1th byte from the array pointed to by<br>*AC0 (Note: AC1 may be negative).<br>brLY01:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RSh[AC1,1]) + T, GoTo[.+3,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch1[AC0,AC0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC0 &larr; LdF[AC0,0,10], Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC0,AC0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; LdF[AC0,10,10], Return;<br><br>*Like LY01 with AC0 and AC1 interchanged<br>brLY10:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RSh[AC0,1]) + T, GoTo[.+3,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch1[AC1,AC1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  AC1 &larr; LdF[AC1,0,10], Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC1,AC1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1 &larr; LdF[AC1,10,10], Return;<br><br>brFetToRTemp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,RTemp], Return;<br><br>*Return: AC2 &larr; AC2!0; PC &larr; (AC2!1)+1<br>brReturn:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC2) + 1, Call[brFetToRTemp];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RTemp) + 1, GoTo[brJmpPz];<br><br>*Store the byte at AC2!3 into the AC1th byte of the array pointed to by<br>*AC0 (Note: AC1 may be negative).<br>brSY01:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC1) and (100000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RSh[AC1,1]) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC0,RTemp1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; T, LoadPage[brGarbPage2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Bypass kludge<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1, DblGoToP[brSYo,brSYe,R Odd];<br><br>*Like SY01 with AC0 and AC1 interchanged.<br>brSY10:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (AC0) and (100000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RSh[AC0,1]) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC1,RTemp1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DMA &larr; T, LoadPage[brGarbPage2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0, DblGoToP[brSYo,brSYe,R Odd];<br><br>OnPage[brGarbPage2];<br><br>brSYe:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LSh[RTemp,10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; (RHMask[RTemp1]) or T;<br>brSYx:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[DMA,RTemp1,0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br>brSYo:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RHMask[RTemp];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RTemp1 &larr; (LHMask[RTemp1]) or T, GoTo[brSYx];<br><br>:ENDIF; ****************************************<br><br>:END[Alto];</span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
