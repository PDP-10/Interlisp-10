<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>BitBlt.Mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 6pt; text-align: left">
<span style="font: 10pt serif">:TITLE[BITBLT];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Last edited: 5 February 1981 by Fiala<br><br>%BBTable format<br><br>WORD</span><span class="tab" val="67"></span><span style="font: 10pt serif">  NAME</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br>  0</span><span class="tab" val="67"></span><span style="font: 10pt serif">Function</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">bit 0 Long; 14:17 function; for AltoXMMode <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">bit 12=alt bank src, 13=alt bank dest<br>  1</span><span class="tab" val="67"></span><span style="font: 10pt serif">unused<br>  2</span><span class="tab" val="67"></span><span style="font: 10pt serif">DBCA</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dest BCA</span><span class="tab" val="67"></span><span style="font: 10pt serif">Base Core Address of dest bit map<br>  3</span><span class="tab" val="67"></span><span style="font: 10pt serif">DBMR</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dest BMR</span><span class="tab" val="67"></span><span style="font: 10pt serif">Bit Map Raster width in words (&gt;=0)<br>  4</span><span class="tab" val="67"></span><span style="font: 10pt serif">DLX</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dest LX</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Block&rsquo;s Left X offset from 1st bit of scan-line (&gt;= 0)<br>  5</span><span class="tab" val="67"></span><span style="font: 10pt serif">DTY</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dest TY</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Block&rsquo;s Top Y offset from 1st scan-line (&gt;=0)<br>  6</span><span class="tab" val="67"></span><span style="font: 10pt serif">DW</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dest W</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Width in bits of block (&gt;=0)<br>  7</span><span class="tab" val="67"></span><span style="font: 10pt serif">DH</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dest H</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Height in scan-lines of block (&gt;=0)<br> 10</span><span class="tab" val="67"></span><span style="font: 10pt serif">SBCA</span><span class="tab" val="67"></span><span style="font: 10pt serif">Src BCA<br> 11</span><span class="tab" val="67"></span><span style="font: 10pt serif">SBMR</span><span class="tab" val="67"></span><span style="font: 10pt serif">Src BMR</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">(&gt;=0??)<br> 12</span><span class="tab" val="67"></span><span style="font: 10pt serif">SLX</span><span class="tab" val="67"></span><span style="font: 10pt serif">Src LX</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">(&gt;=0)<br> 13</span><span class="tab" val="67"></span><span style="font: 10pt serif">STY</span><span class="tab" val="67"></span><span style="font: 10pt serif">Src TY</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">(&gt;=0)<br> 14</span><span class="tab" val="67"></span><span style="font: 10pt serif">Gray0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">These four words are the Gray Block<br> 15</span><span class="tab" val="67"></span><span style="font: 10pt serif">Gray1</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Gray0 is used on last item transmitted,<br> 16</span><span class="tab" val="67"></span><span style="font: 10pt serif">Gray2</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Gray1 on next-to-last, etc., Gray0 on<br> 17</span><span class="tab" val="67"></span><span style="font: 10pt serif">Gray3</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">4th from last, etc.<br> 20</span><span class="tab" val="67"></span><span style="font: 10pt serif">LongSrcLo</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">This pair instead of MDShi/SBCA if long<br> 21</span><span class="tab" val="67"></span><span style="font: 10pt serif">LongSrcHi<br> 22</span><span class="tab" val="67"></span><span style="font: 10pt serif">LongDestLo</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">This pair instead of MDShi/DBCA if long<br> 23</span><span class="tab" val="67"></span><span style="font: 10pt serif">LongDestHi<br><br>BitBlt functions:<br>[X=0 uses BBFB (Dest & Mask&rsquo;), X=1 uses BBFBX (Dest unmasked)]<br>[MA=0 causes Src & Mask, MA=1 causes Src or Mask&rsquo;]<br><br>CODE</span><span class="tab" val="67"></span><span style="font: 10pt serif">MA  X</span><span class="tab" val="67"></span><span style="font: 10pt serif">SALUFOP</span><span class="tab" val="67"></span><span style="font: 10pt serif">Action</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Computation<br><br>  0</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   0</span><span class="tab" val="67"></span><span style="font: 10pt serif">R or T</span><span class="tab" val="67"></span><span style="font: 10pt serif">S</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">(D & M&rsquo;) or (S & M)<br>  1</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R or T</span><span class="tab" val="67"></span><span style="font: 10pt serif">D or S</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D or (S & M)<br>  2</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R # T</span><span class="tab" val="67"></span><span style="font: 10pt serif">D # S</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D # (S & M)<br>  3</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R & T&rsquo;</span><span class="tab" val="67"></span><span style="font: 10pt serif">D & S&rsquo;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D & (S & M)&rsquo;<br>  4</span><span class="tab" val="67"></span><span style="font: 10pt serif">1   0</span><span class="tab" val="67"></span><span style="font: 10pt serif">R or T&rsquo;</span><span class="tab" val="67"></span><span style="font: 10pt serif">S&rsquo;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">(D & M&rsquo;) or (S or M&rsquo;)&rsquo;<br>  5</span><span class="tab" val="67"></span><span style="font: 10pt serif">1   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R or T&rsquo;</span><span class="tab" val="67"></span><span style="font: 10pt serif">D or S&rsquo;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D or (S or M&rsquo;)&rsquo;<br>  6</span><span class="tab" val="67"></span><span style="font: 10pt serif">1   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R # T&rsquo;</span><span class="tab" val="67"></span><span style="font: 10pt serif">D # S&rsquo;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D # (S or M&rsquo;)&rsquo;<br>  7</span><span class="tab" val="67"></span><span style="font: 10pt serif">1   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R & T</span><span class="tab" val="67"></span><span style="font: 10pt serif">D & S</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D & (S or M&rsquo;)<br> 10</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R or T</span><span class="tab" val="67"></span><span style="font: 10pt serif">(D & S&rsquo;) or (S & G)</span><span class="tab" val="67"></span><span style="font: 10pt serif">(D & (S & M)&rsquo;) or (S & M & G)<br> 11</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R or T</span><span class="tab" val="67"></span><span style="font: 10pt serif">D or (S & G)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D or (S & M & G)<br> 12</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R # T</span><span class="tab" val="67"></span><span style="font: 10pt serif">D # (S & G)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D # (S & M & G)<br> 13</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R & T&rsquo;</span><span class="tab" val="67"></span><span style="font: 10pt serif">D & (S & G)&rsquo;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D & (S & M & G)&rsquo;<br> 14</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   0</span><span class="tab" val="67"></span><span style="font: 10pt serif">R or T</span><span class="tab" val="67"></span><span style="font: 10pt serif">G</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">(D & M&rsquo;) or (G & M)<br> 15</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R or T</span><span class="tab" val="67"></span><span style="font: 10pt serif">D or G</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D or (G & M)<br> 16</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R # T</span><span class="tab" val="67"></span><span style="font: 10pt serif">D # G</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D # (G & M)<br> 17</span><span class="tab" val="67"></span><span style="font: 10pt serif">0   1</span><span class="tab" val="67"></span><span style="font: 10pt serif">R & T&rsquo;</span><span class="tab" val="67"></span><span style="font: 10pt serif">D & G&rsquo;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">D & (G & M)&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br>bbFunction is in the following format:<br>   00</span><span class="tab" val="67"></span><span style="font: 10pt serif">mesa long pointer during early initialization;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">L-to-R = 0 / R-to-L = 1 after early init.<br>01-03</span><span class="tab" val="67"></span><span style="font: 10pt serif">unused<br>04-07</span><span class="tab" val="67"></span><span style="font: 10pt serif">which-innerloop index<br>10-11</span><span class="tab" val="67"></span><span style="font: 10pt serif">unused<br>   12</span><span class="tab" val="67"></span><span style="font: 10pt serif">For AltoXMMode alt bank src, else unused<br>   13</span><span class="tab" val="67"></span><span style="font: 10pt serif">For AltoXMMode alt bank dest, else unused<br>14-17</span><span class="tab" val="67"></span><span style="font: 10pt serif">Bitblt function code<br>%<br><br>*BBFA dispatch values<br>Set[bbItem,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*item refill<br>Set[bbSDRef,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*source and destination refill<br>Set[bbSRef,5];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*source refill<br>Set[bbDRef,6];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*destination refill<br>Set[bbNoRef,7];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*no refill<br><br>Set[bbILtype0,00];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*functions 1-3 and 5-7<br>Set[bbILtype1,02];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*functions 0 and 4<br>Set[bbILtype2,04];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*function 10<br>Set[bbILtype3,06];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*functions 11-13<br>Set[bbILtype4,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*function 14<br>Set[bbILtype5,12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*functions 15-17<br><br>:IF[AltoXMMode]; *****************************<br>OnPage[bbXMPage];<br>bbShortXM:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSrcQHi &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RZero) - (40C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*177740 addresses bank<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[MDS,bbGray];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[bbFunction,12,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alternate bank bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[bbGray,16,2], Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return, DispTable[4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDestQHi &larr; (bbDestQHi) + T, Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSrcQHi &larr; (bbSrcQHi) + T, Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSrcQHi &larr; (bbSrcQHi) + T, Goto[.-2];<br>:ENDIF; **************************************<br><br>OnPage[bbPage];<br><br>*Alto entry here with StkP pointing at AC1 (2*scan-lines completed),<br>*(Cycle&PCXF) and not (100000C) in T, and pointer to BitBlt table in AC2<br>*(a base reg.); the BitBlt table is known to start at an even address.<br>*Mesa entry with (Cycle&PCXF) or (100000C) in T, Stack holding 2*scan-lines<br>*completed and Stack0 in AC2 (a pointer to BitBlt table).<br>bbBitBlt:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[AC2,bbItemWid,6], Task;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*fetch dw and dh<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbGray1 &larr; (bbGray1) or not (0C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">*-1=don&rsquo;t touch pages; 0=do<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T, Skip[BPCChk&rsquo;];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Save PCF and Mesa/Alto flag in AC0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCB &larr; (PCB) + (4C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Advance PC on imminent refill<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,bbFunction,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbNegBitsLeft &larr; Zero;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*0 L-to-R, variable R-to-L<br><br>*Setup bbSrcQLo/Hi and bbDestQLo/Hi double-precision; in short mode, sbca/dbca<br>*are fetched into bbSrcQLo/bbDestQLo and MDShi rsh 8 is copied into<br>*bbSrcQHi/bbDestQHi; long pointers are fetched directly into bbSrcQLo/Hi and<br>*bbDestQLo/Hi.  Smalltalk simulates an XM Alto in which bbFunction[12:13]<br>*specify that the emulator alternate bank (bits 14-15 of 177740) should be<br>*added into bbSrcQHi/bbDestQHi respectively.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,bbGray2,3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*fetch dbmr<br>*The way bbItemsLeft and stack count is determined by gray mode requirements.<br>*Alto gray mode uses gray n mod 4 with n scanlines left to do, and the<br>*vertical direction of transfer must be the same here for compatibility.<br>**Aligning the gray pattern with the absolute or relative address of the<br>**destination bit map is superior to this algorithm but Alto incompatible.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Stack) + (2C);<br>*bbItemsLeft &larr; (scanlines left to do - 1) * 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbItemsLeft &larr; (Lsh[bbItemsLeft,1]) - T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Exit if no items<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[AC2,bbSlx,12], Goto[bbExit,ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fetch slx and sty<br>**Note incompatibility: on Alto, neg words/scanline reverses transfer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbItemWid, Skip[R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; AC0, DblGoto[bbMDone,bbNDone,R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Exit if width&lt;0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbNegItemWid &larr; (Zero) - T, Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; AC0, DblGoto[bbMDone,bbNDone,R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Exit if width=0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[AC2,bbDlx,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*fetch dlx and dty<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; (bbFunction) and not (177400C), Goto[bbShrt,R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; 22C, Task;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch2[AC2,bbDestQLo];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; 20C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch2[AC2,bbSrcQLo], Goto[bbDir];<br>bbShrt:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,bbDestQLo,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*bbDestQLo &larr; dbca<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Rsh[MDShi,10];<br>:IF[AltoXMMode]; *****************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDestQHi &larr; T, LoadPage[bbXMPage];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,bbSrcQLo,10], Call[bbShortXM];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*bbSrcQLo &larr; sbca<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; (bbFunction) and not (60C);<br>:ELSE; ***************************************<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDestQHi &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,bbSrcQLo,10], Task;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*bbSrcQLo &larr; sbca<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSrcQHi &larr; T;<br>:ENDIF; **************************************<br><br>%Determination of BitBlt directions (T=Top, B=Bottom, L=Left, R=Right):<br>T-to-B is slightly faster than B-to-T, so prefer T-to-B when possible, but<br>Alto compatibility on gray mode requires B-to-T on dty = sty.<br>L-to-R is much faster than R-to-L, which uses multiple item setups/scanline,<br>so avoid R-to-L when possible.  The heuristic here assumes src and dest bit<br>maps are disjoint except when sbca .eq. dbca (short mode) and sbmr .eq. dbmr.<br>Direction of transfer is don&rsquo;t care otherwise.  Page-touching prior to<br>inner loops is necessary only when src and dest bit maps are not disjoint or<br>when the BitBlt function is not restartable (xor/xnor) on a page fault.<br>In other situations it is safe to restart BitBlt at the beginning of the<br>scanline after a fault.<br>  T-to-B, L-to-R  dty &lt; sty<br>  B-to-T, R-to-L  (dty = sty) & (sbmr = dbmr) & (dlx - slx &gt;= 100b) &<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  (item &gt;= 100b wide) & (slx+scanlinewidth &gt; dlx)<br>  B-to-T, L-to-R  (dty &gt; sty) or (dty = sty when not doing R-to-L)<br>Timing from bbBitBlt to here: 47 short, 48 long (cycles).<br>%<br>bbDir:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[bbFunction,14,4], Call[bbFnSetup];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SALUF &larr; T, T &larr; bbDty;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (bbSty) - T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbGray2, FreezeResult, Goto[bbTtoB,ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDBMR &larr; (Zero) - T, Goto[.+3,MB];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; bbGray;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbSBMR &larr; (Zero) - T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Rsh[bbItemsLeft,1], Goto[bbGenlInit];<br><br>*Sty .ge. Dty: will go T-to-B if .g., B-to-T if .eq. for Alto compatibility<br>bbTtoB:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDBMR &larr; T, Goto[bbMaybeBTRL,ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; bbGray, Skip[MB];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    bbSBMR &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; Rsh[Stack,1], Goto[bbGenlInit];<br>*StY = Dty<br>bbMaybeBTRL:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDBMR &larr; (Zero) - T, Skip[MB&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; Rsh[bbItemsLeft,1], Goto[bbGenlInit];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbGray;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSBMR &larr; (Zero) - T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (bbDBMR) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbSlx, Skip[ALU=0];<br>bbTBLR:</span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; Rsh[bbItemsLeft,1], Goto[bbGenlInit];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*L-to-R dbmr .ne. sbmr<br>*bbGray1 &larr; 0 forces page touching because of possible S-D overlap.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (bbDlx) - T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; dlx - slx<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (Lsh[AllOnes,6]) and T, Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbGray1 &larr; Zero, Goto[bbTBLR];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*L-to-R if DestX &lt; SrcX<br>*DestX &gt;= SrcX; bbNegSDNonOverlap &larr; - (DestX - SrcX)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; LdF[bbItemWid,0,12], Skip[ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbGray1 &larr; Zero, Goto[bbTBLR];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*L-to-R if (DestX-SrcX) &lt; 100b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (bbItemWid) - T, Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbGray1 &larr; Zero, Goto[bbTBLR];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*L-to-R if item &lt; 100b long<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbGray1 &larr; Zero, Skip[Carry];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*or width &lt; non-overlap<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; Rsh[bbItemsLeft,1], Goto[bbGenlInit];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbNegSDNonOverlap &larr; (Zero) - T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; (bbFunction) or (100000C), Goto[bbTBLR]; *R-to-L<br><br>*General init: T has items completed if T-to-B, items remaining if B-to-T.<br>*Time: (71 T-to-B), (71 to 88 B-to-T, L-to-R), (93 to 95 R-to-L) + 1 if long<br>bbGenlInit:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDty &larr; (bbDty) + T, Skip[MB&rsquo;];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LU &larr; bbGray2, Goto[bbDestInit];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; bbGray;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSrcWLo &larr; Zero, Skip[ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*sbmr=0 not impossible<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; RHMask[bbSrcQHi], Goto[bbAddSF];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbSty &larr; (bbSty) + T, Call[bbYHi0];<br>*bbSrcQLo/QHi + (sty*sbmr) + (slx rsh 4); product may be &gt; 16 bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbGray &larr; Rsh[bbGray,1], Goto[bbNoAddS,R Even];<br>*Multiply timing: 6*nzeroes right of the left-most one + 14*nones in sbmr.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    bbSrcQLo &larr; (bbSrcQLo) + T, Goto[.+3,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      T &larr; (bbYHi) + 1, UseCOutAsCIn;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      T &larr; bbSrcQHi &larr; (bbSrcQHi) + T, Goto[bbAddSF];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    T &larr; (bbYHi) + 1, UseCOutAsCIn;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    bbSrcQHi &larr; (bbSrcQHi) + T;<br>bbNoAddS:   T &larr; bbSty &larr; Lsh[bbSty,1], DblGoto[bbLshyHi1,bbLshyHi0,R&lt;0];<br>bbAddSF:bbSrcQHi &larr; (Lsh[bbSrcQHi,10]) + T + 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*bbSrcQHi in base reg. format<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[bbSlx,14,4], Call[bbNegIWSub];<br>*bbSlast &larr; (Slx & 17) + ItemWid - 1 = displacement to last bit of scan-line<br>*Add (slx rsh 4) and copy WLo into QLo; point bbSlx at bit in 1st quadword.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSlast &larr; (Zero) - T - 1, Call[bbSBWQ];<br>*Time to here: (1 if long) + {(71 to 75 if no source) else multiply time +<br>* [(100 to 101 T-to-B), (100 to 118 B-to-T, L-to-R), (122 to 125 R-to-L)]}<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; bbGray2;<br>bbDestInit:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo &larr; Zero, Goto[bbAddDF,ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDty, Call[bbYHi0];<br>*bbDestQLo/QHi + (dty*dbmr) + (dlx rsh 4); product may be &gt; 16 bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbGray2 &larr; Rsh[bbGray2,1], Goto[bbNoAddD,R Even];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    bbDestQLo &larr; (bbDestQLo) + T, Goto[.+3,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      T &larr; (bbYHi) + 1, UseCOutAsCIn;<br>bbAddDF:      T &larr; bbDestQHi &larr; (bbDestQHi) + T, Goto[bbAddDF1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    T &larr; (bbYHi) + 1, UseCOutAsCIn;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    bbDestQHi &larr; (bbDestQHi) + T;<br>bbNoAddD:   T &larr; bbDty &larr; Lsh[bbDty,1], DblGoto[bbLshyHi1,bbLshyHi0,R&lt;0];<br>bbAddDF1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDestQHi &larr; (Lsh[bbDestQHi,10]) + T + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[AC2,bbGray2,16], Call[bbDBWQ];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; LdF[bbDlx,14,4], Call[bbNegIWSub];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*offset to last scan-line bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[AC2,bbGray,14], Skip[MB];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; Rsh[bbSlast,4], DblGoto[bbTS,bbNTS,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SB &larr; bbDlx, Goto[bbTchD];<br>%Time to bbTchD/S: (1 if long) + [(106 to 111 if no source) else<br>  (137 to 139 T-to-B), (137 to 156 B-to-T, L-to-R), (159 to 163 R-to-L)]<br>To this add entry/exit overhead less time between bbItemRefill and bbTchD/S:<br>  Alto--16 + 20; Alto Mesa--10 + 30; Pilot Mesa--10 + 20<br>  (-15 T-to-B), (-19 B-to-T), (-12 no source).<br>Total time: [148 to 150 T-to-B, 148 to 166 B-to-T L-to-R, 168 to 171 R-to-L,<br>  124 to 127 no source] + [0 Pilot, 8 Alto, or 10 Alto Mesa] + [1 if long].<br>To this add about 60 cycles/multiply (1 multiply if no source else 2).<br>%<br><br>bbyHi0:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Skip[ALU&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Nop exit if dty/sty &lt; 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  PCF &larr; AC0, DblGoto[bbMDone,bbNDone,R&lt;0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbYHi &larr; 0C, Return;<br><br>bbLshyHi0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbYHi &larr; Lsh[bbYHi,1], Return;<br>bbLshyHi1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbYHi &larr; (Lsh[bbYHi,1]) + 1, Return;<br><br>bbNegIWSub:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (MNBR &larr; bbNegItemWid) - T;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (bbGray1) or T, Skip[R Odd];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; (Lsh[AllOnes,1]) and T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Make bbLast be odd<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDlast &larr; (Zero) - T - 1, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Mask bbLast be 0<br><br>*T[08] &larr; MA&rsquo;, T[09] &larr; MB, T[10:15] &larr; ALU op<br>*The MB branch condition is used to indicate "no source."<br>bbFnSetup:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[AC2,bbGray,11], Disp[.+1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*fetch sbmr<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; 1000C, DispTable[20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R or T<br>bbOr:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 204C, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R or T<br>bbX:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 263C, Goto[bbForceTch];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R xor T<br>bbAN:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 227C, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R & T&rsquo;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; 1000C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*1,R or T&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 074C, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*1,R or T&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 054C, Goto[bbForceTch];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1,R xnor T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 056C, Return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*1,R & T<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; 2000C, Goto[bbOr];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R or T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; 3000C, Goto[bbOr];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R or T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; 3000C, Goto[bbX];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R xor T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; 3000C, Goto[bbAN];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R & T&rsquo;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 304C, Goto[bbTR4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R or T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 304C, Goto[bbTR5];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R or T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 363C, Goto[bbTR5Tch];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R xor T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 327C, Goto[bbTR5];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*0,R & T&rsquo;<br><br>bbTR5:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; 5000C, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*type 5; no source<br>bbTR4:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; 4000C, Return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*type 4; no source<br>bbTR5Tch:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbFunction &larr; 5000C;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*type 5; touch pages<br>bbForceTch:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbGray1 &larr; Zero, Return;<br><br><br>%Approx. item refill times starting at bbItemRefill are below; the inner-loop<br>dependent constant given in the comments before the inner loops must be<br>added to these and the time is 1 (Alto) or 9 (Mesa) cycles greater if<br>interrupts are disabled:<br>  L-to-R, src used:</span><span class="tab" val="67"></span><span style="font: 10pt serif">58 (T-to-B) or 61 (B-to-T) cycles<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">[+ 12 + 11*(NDestPages+NSrcPages-2) if xor/xnor functions or sty=dty]<br>  L-to-R, src unused:</span><span class="tab" val="67"></span><span style="font: 10pt serif">41 [+ 5 + 11*(NDestPages-1) if xor function]<br>  R-to-L:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">11*(NDestPages+NSrcPages) + 93 cycles<br>  R-to-L, continuing item:</span><span class="tab" val="67"></span><span style="font: 10pt serif">62 cycles, 47 or 63 on last continuation<br><br>When both src and dest are used the no-refill case will occur at<br>most 6 times followed by a src-refill, dest-refill, or item-refill.<br>If src and dest are word-aligned, at most 3 no-refill loops will occur<br>followed by a src-dest-refill or item refill.<br><br>When only the dest is used, at most 3 no-refill loops occur followed<br>by a src-dest-refill or item refill.<br>%<br><br>bbSrcFetch:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[bbSrcQLo,bbSrc], Return;<br><br>*Note: Doing PStore4 first allows both PFetch4&rsquo;s to be launched before<br>*transport for either occurs.  If the PFetch4 for the src were done first,<br>*the PFetch4 for the dest could not be launched before transport for both<br>*preceding references had finished.<br>bbSrcDestRfl:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[bbDestQLo,bbDest];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbSrcWLo &larr; (bbSrcWLo) + (4C);<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[bbSrcQLo,bbSrc], Skip;<br>bbDestRfl:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[bbDestQLo,bbDest];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo &larr; (bbDestWLo) + (4C);<br>bbDestFetch:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[bbDestQLo,bbDest], Return;<br><br>*The bbIA, bbIB, bbIE, and bbIF dispatch tables could be united by revising<br>*the SrcDestRefill subroutine to check MB; this would save 12b mi but slow<br>*inner loops by 2 to 3 cycles.<br><br>bbInnerLoops:<br>*functions 1-3 and 5-7; refill times: i=4+I, sd=32, s=20, d=26, n=4<br>bbIA1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDlx &larr; (DB &larr; bbDlx) + T, Call[bbFixG], At[bbI,bbILtype0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[SB[bbSrc]] or T;<br>bbIA2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; BBFBX[DB[bbDest]] SALUFOP T, Disp[.+1];<br>bbItemRefill:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbItemRfl], DispTable[5,17,3];<br>bbSrcDestRefill:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbSrcDestRfl];<br>bbSrcRefill:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbSrcWLo &larr; (bbSrcWLo) + (4C), Goto[bbSrcFetch];<br>bbDestRefill:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbDestRfl];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[SB[bbSrc]] or T, Goto[bbIA2];<br><br>*functions 0 and 4; refill times: i=4+I, sd=32, s=20, d=26, n=4<br>**Can improve by not fetching bbDest when MNBR &lt; -77 on dest refill.<br>bbIB1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDlx &larr; (DB &larr; bbDlx) + T, Call[bbFixG], At[bbI,bbILtype1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[SB[bbSrc]] or T;<br>bbIB2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; BBFB[DB[bbDest]] SALUFOP T, Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbItemRefill], DispTable[5,17,3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbSrcDestRfl];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbSrcWLo &larr; (bbSrcWLo) + (4C), Goto[bbSrcFetch];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbDestRfl];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[SB[bbSrc]] or T, Goto[bbIB2];<br><br>*function 10; refill times: i=8+I, sd=36, s=22, d=30, n=8<br>bbIC1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDlx &larr; (DB &larr; bbDlx) + T, Call[bbFixG], At[bbI,bbILtype2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[SB[bbSrc]] or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; (DB[bbDest]) and not T, Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[bbGray] and T, Goto[bbICi], DispTable[5,17,3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[bbGray] and T, Goto[bbICsd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[bbGray] and T, Goto[bbICs];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[bbGray] and T, Goto[bbICd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[bbGray] and T, Goto[bbICr];<br><br>*functions 11-13; refill times: i=6+I, sd=34, s=20, d=28, n=6<br>bbID1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDlx &larr; (DB &larr; bbDlx) + T, Call[bbFixG], At[bbI,bbILtype3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[SB[bbSrc]] or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCF[bbGray] and T, Disp[.+1];<br>bbICi:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; BBFBX[DB[bbDest]] SALUFOP T, Goto[bbItemRefill], DispTable[5,17,3];<br>bbICsd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; BBFBX[DB[bbDest]] SALUFOP T, Goto[bbSrcDestRefill];<br>bbICs:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; BBFBX[DB[bbDest]] SALUFOP T, Goto[bbSrcRefill];<br>bbICd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; BBFBX[DB[bbDest]] SALUFOP T, Goto[bbDestRefill];<br>bbICr:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; BBFBX[DB[bbDest]] SALUFOP T, Return;<br><br>*function 14; refill times: i=4+I, sd=26, s=never, d=never, n=4<br>**Can improve by not refilling dest and BLKSing bbGray when MNBR&lt;-77.<br>bbIE1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDlx &larr; (DB &larr; bbDlx) + T, Call[bbFixG], At[bbI,bbILtype4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[PCF[bbGray]];<br>bbIE2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; BBFB[DB[bbDest]] SALUFOP T, Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbItemRflNS], At[bbIE,bbItem];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbDestRfl], At[bbIE,bbSDRef];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[PCF[bbGray]], Goto[bbIE2], At[bbIE,bbNoRef];<br><br>*functions 15-17; refill times: i=4+I, sd=26, s=never, d=never, n=4<br>bbIF1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDlx &larr; (DB &larr; bbDlx) + T, Call[bbFixG], At[bbI,bbILtype5];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[PCF[bbGray]];<br>bbIF2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">DB[bbDest] &larr; BBFBX[DB[bbDest]] SALUFOP T, Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbItemRflNS], At[bbIF,bbItem];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestWLo, Goto[bbDestRfl], At[bbIF,bbSDRef];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; BBFA[PCF[bbGray]], Goto[bbIF2], At[bbIF,bbNoRef];<br><br>bbFixG:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF &larr; bbItemsLeft, BBFBX, Return;<br><br>bbItemRflNS:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[bbDestQLo,bbDest], Call[bbCntI];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; NWW, DblGoto[bbIntOff,bbIntOn,R&lt;0];<br><br>*Worst case time to return from bbIR1 is 42 (src used).<br>bbItemRfl:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[bbDestQLo,bbDest], Call[bbIR1];<br>*Test for interrupts and done:<br>*Item refill time: 12.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; NWW, Skip[R&gt;=0];<br>bbIntOff:  bbItemsLeft &larr; (bbItemsLeft) - (2C), Skip;<br>bbIntOn:bbItemsLeft &larr; (bbItemsLeft) - (2C), Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; bbDBMR, DblGoto[bbAdvD,bbExit1,ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; PCF &larr; AC0, Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  DblGoto[bbMDone,bbNDone,ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; xfWDC, DblGoto[bbMesaInt,bbNovaInt,ALU&lt;0];<br><br>bbIR1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; MNBR &larr; bbNegBitsLeft, Goto[bbRtoLCont,R&lt;0];<br>bbCntI:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) + (2C), Return;<br><br>*At bbMesaInt and bbNovaint, we have committed to taking an interrupt;<br>*control can only get back by restarting the opcode.<br><br>***The code at bbMesaInt and bbMDone is in AltoX.Mc<br><br>*Since the Alto only checks for interrupts during jumps, we simulate JMP .<br>**Could call intEnt here and handle the (rare) return, if WW, ACTIVE, and<br>**DMA (used by intEnt) did not clobber BitBlt registers other than<br>**bbSrc and bbDest.<br>bbNovaInt:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; PCB, LoadPage[nePage], Goto[bbNExit];<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPage[xoPage];<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[intEnt];<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDBMR, Goto[bbAdvD];<br>bbNDone:</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Time to next opcode = 20 cycles<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCB) + 1, LoadPage[nePage];<br>bbNExit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCF.word) + T, GotoP[brJmpPz];<br><br>bbExit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF &larr; AC0, DblGoto[bbMDone,bbNDone,R&lt;0];<br>bbExit1: PCF &larr; AC0, DblGoto[bbMDone,bbNDone,R&lt;0];<br><br>*Item refill time: 16 (no src), 18 (src used)<br>*bbDestW &larr; bbDestQ &larr; bbDestW + bbDBMR<br>bbAdvD:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestQLo &larr; (bbDestQLo) + T, Goto[bbAD1,ALU&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MNBR &larr; bbNegItemWid, Skip[Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbDestQHi &larr; (bbDestQHi) - (400C) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDestWLo &larr; Zero, Skip[MB&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  SB &larr; bbDlx, Goto[bbTchD];<br>*bbSrcW &larr; bbSrcQ &larr; bbSrcW + bbSBMR<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbSBMR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSrcQLo &larr; (bbSrcQLo) + T, Call[bbASn];<br>%Avoid page touching and simply refill bbSrc/bbDest except when either a<br>non-restartable function is being executed (xor, xnor) or dty=sty, in which<br>case there is possible src-dest overlap.  When touching, begin with the last<br>page of the scan-line and finish with a PFetch4 of the 1st quadword.<br>Initial displacement is [(ItemWidth - 1 + (startbit & 17)) rsh 4] + non-page<br>bits of start word, where the first term is computed during initialization.<br>The choice to touch/not-touch is indicated in bbSLast/bbDLast which contain<br>0 when not touching or some odd value when touching.<br>%<br>bbTchS:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Rsh[bbSlast,4], Skip[R Odd];<br>bbNTS:</span><span class="tab" val="67"></span><span style="font: 10pt serif">  PFetch4[bbSrcQLo,bbSrc], Goto[bbNTS1];<br>bbTS:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RHMask[bbSrcQLo]) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Lsh[AllOnes,10]) and T, Call[.+2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; (Lsh[AllOnes,10]) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[bbSrcQLo,bbSrc], Skip[ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Return;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSrcWLo &larr; Zero;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SB &larr; bbSlx, Goto[bbTchD];<br><br>bbAD1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">MNBR &larr; bbNegItemWid, Skip[Carry&rsquo;];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbDestQHi &larr; (bbDestQHi) + (400C) + 1;<br>bbNS1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDestWLo &larr; Zero, Goto[bbNoTchS,MB];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; bbSBMR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; bbSrcQLo &larr; (bbSrcQLo) + T, Call[bbASp];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; Rsh[bbSlast,4], DblGoto[bbNTS,bbTS,R Even];<br>bbNoTchS:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SB &larr; bbDlx;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>bbTchD:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Rsh[bbDlast,4], Goto[bbNTD,R Even];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (RHMask[bbDestQLo]) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Lsh[AllOnes,10]) and T, Call[.+2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; (Lsh[AllOnes,10]) + T;<br>bbNTD:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[bbDestQLo,bbDest], Skip[ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Return;<br>*Item refill time to here: 33 + [5 + 11*(NDPages-1) if xor function] (no src)<br>*50 (T-to-B), 53 (B-to-T) +<br>*[12 + 11*(NDPgs+NSPgs-2) if xor/xnor functions or sty=dty & sbmr=dbmr]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[bbFunction,4,4], Goto[bbItemSetup,R&gt;=0];<br>*New R-to-L item<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbNegItemWid;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (MNBR &larr; bbNegSDNonOverlap) - T, Call[bbSlxFix];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*T &larr; bits left<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbNegBitsLeft &larr; (bbNegBitsLeft) - T, Goto[bbRtoLNew];<br><br>bbRtoLCont:</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Here when continuing R-to-L item.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LU &larr; (bbNegSDNonOverlap) - T, Call[bbRtoLC1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Odd<br>*Initially T will contain ItemWidth-SDNonOverlap; subsequent iterations<br>*T will contain -SDNonOverlap until the last iteration for the scan-line, when<br>*T will contain -BitsLeft.  bbNegBitsLeft is 0 at onset of each scan-line.<br>bbRtoLNew:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDlx &larr; (LdF[bbDlx,14,4]) + T, Call[bbSBWQ];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[bbSrcQLo,bbSrc,0], Call[bbDBWQ];<br>bbNTS1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">SB &larr; bbSlx;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbSrcWLo &larr; Zero, Call[bbDestFetch];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dispatch[bbFunction,4,4];<br>bbItemSetup:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Lsh[bbDBMR,4], Disp[bbInnerLoops];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br><br>**Worst case time to return from bbSlxFix is 46 cycles.<br>bbRtoLC1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDestWLo &larr; Zero, Skip[Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; MNBR &larr; bbNegSDNonOverlap;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">bbNegBitsLeft &larr; (bbNegBitsLeft) - T, Goto[bbSlxFix];<br><br>%bbSBWQ and bbDBWQ are used both by initialization and in the R-to-L case.<br>bbASn/bbASp are called by item refill to advance QLo/QHi by a signed<br>word displacement, bbSBMR.  The equivalent code in bbDBWQ is open-coded<br>for item refill.<br>%<br>bbSBWQ:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Rsh[bbSlx,4], Skip[R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; (Lsh[AllOnes,14]) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbSrcQLo &larr; (bbSrcQLo) + T, Goto[bbASp,ALU&gt;=0];<br>bbASn:</span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; Lsh[bbSrcQLo,4], Skip[Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    bbSrcQHi &larr; (bbSrcQHi) - (400C) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbSlx &larr; (LdF[bbSlx,14,4]) + T, Return;<br>bbASp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Lsh[bbSrcQLo,4], Skip[Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbSrcQHi &larr; (bbSrcQHi) + (400C) + 1;<br>bbSlxFix:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbSlx &larr; (LdF[bbSlx,14,4]) + T, Return;<br><br>bbDBWQ:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Rsh[bbDlx,4], Skip[R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; (Lsh[AllOnes,14]) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; bbDestQLo &larr; (bbDestQLo) + T, Goto[bbADp,ALU&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; Lsh[bbDestQLo,4], Skip[Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    bbDestQHi &larr; (bbDestQHi) - (400C) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbDlx &larr; (LdF[bbDlx,14,4]) + T, Return;<br>bbADp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Lsh[bbDestQLo,4], Skip[Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  bbDestQHi &larr; (bbDestQHi) + (400C) + 1;<br>bbDlxFix:</span><span class="tab" val="67"></span><span style="font: 10pt serif">bbDlx &larr; (LdF[bbDlx,14,4]) + T, Return;<br><br>:END[BitBlt];</span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
