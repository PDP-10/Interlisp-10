<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>EnxTask.Mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif">:IF[With10MB]; **************************************<br><br>  TITLE[ENXTask];<br><br>* Last edited for Lisp July 7, 1982  10:20 PM van Melle<br>%<br>Fiala 1 April 1982: eliminate OnPage[EtherInitPage], reformat; absorb<br>  ENXDefs; use macro to eliminate all the duplicate register defs;<br>  eliminate pENXNotifyReg/2/3; conditionally assemble if With10MB.<br>HGM, November 29, 1981  10:57 PM, Patch for wakeup confusion<br>HGM, November 28, 1981  8:02 PM, Make IOCB Chaining Atomic<br>HGM, November 27, 1981  10:40 PM, Late Collision trap<br>HGM, November 20, 1981  3:26 PM, Merge into Fiala&rsquo;s world<br>HGM, October 27, 1981  4:22 PM, Use last few words in buffer<br>HGM, October 5, 1981  1:09 AM, Fixup Input end test<br>HGM, June 24, 1981  1:46 AM, Expand Runt filter to 4 data words<br>HGM, June 24, 1981  12:22 AM, Patch for wakeup pipeline delay<br>HGM, June 16, 1981  8:03 PM, Interlock  xxIndex @ xxSetup<br>HGM, May 27, 1981  12:51 PM, Merge dispatch tables<br>HGM, May 25, 1981  6:49 PM, massive fiddling<br>HGM, May 21, 1981  8:15 PM, IOATTEN vs Fault task fixes<br>HGM, May 7, 1981  11:02 PM, subtract off extra byte (anti dribble hardware change)<br>HGM, April 23, 1981  10:18 PM, Rubiconize and whatever<br><br>HGM, From Tom Henning&rsquo;s version of January 8, 1981  2:52 PM<br>%<br>Set[ZeroModFour,And[enxTask,14]];<br>SetTask[ZeroModFour];<br><br>%RM definitions<br>The ENXReg macro defines a register for task ZeroModFour which will be used<br>in the program, and the addressing mechanism will automatically displace<br>references to another group of 20b registers as appropriate for whatever<br>task is running.  In addition, ENXReg defines offset names for each of the enx<br>tasks for use when referencing the registers from Midas.<br><br>The names defined are: ENX#1, ENX1#1, ENX2#1, and ENX3#1, where one of the<br>last three names is suppressed if coincident with ENX#1.<br>%<br>Macro[TSReg,IFE[And[#1,3],0,,RV[enx#2,Add[LShift[And[#1,3],4],#3]]]];<br>Macro[ENXReg,(<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">TSReg[enxTask,1#1,#2],<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">TSReg[enxTask2,2#1,#2],<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">TSReg[enxTask3,3#1,#2],<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">RV[enx#1,#2])];<br><br>ENXReg[Temp1,0];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*quad temporary registers, also used by NotifyInterrupt<br>ENXReg[Temp2,1];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*quad temporary registers, also used by NotifyInterrupt<br>ENXReg[Temp3,2];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*quad temporary registers<br>ENXReg[Temp4,3];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*quad temporary registers<br><br>ENXReg[RcvIndex,4];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*receive buffer displacement, points to next word in buffer<br>ENXReg[RcvCount,5];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*receive buffer word counter, words left in buffer<br>ENXReg[RcvPtr,6];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*low base register pointer to receive buffer<br>ENXReg[RcvPtrHi,7];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*high base register pointer to receive buffer<br><br>ENXReg[XmtIndex,10];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*transmit buffer displacement, points to next word in buffer<br>ENXReg[XmtCount,11];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*transmit buffer word counter, words left in buffer<br>ENXReg[XmtPtr,12];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*low base register pointer to transmit buffer<br>ENXReg[XmtPtrHi,13];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*high base register pointer to transmit buffer<br><br>ENXReg[CSBPtr,14];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*short pointer to CSB<br>ENXReg[CSBPtrHi,15];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*high base pointer to CSB, set to zero<br>ENXReg[Link,16];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*linking register for saving APC&APCTASK<br>ENXReg[Temp,17];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*temporary register<br><br>*Additional overlay R Register definitions<br><br>ENXReg[InitialCSB,0];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*CSB pointer passed in this reg from initialize.mc<br><br>ENXReg[ICBPtr,2];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Short pointer to ICB<br>ENXReg[OCBPtr,2];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Short pointer to OCB<br><br>ENXReg[DestID1,0];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input Packet DestinationID, first word<br>ENXReg[DestID2,1];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input Packet DestinationID, second word<br>ENXReg[DestID3,2];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input Packet DestinationID, third word<br>ENXReg[DestID4,3];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input Packet, fourth word<br><br>ENXReg[NextICB,4];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Short pointer to next ICB<br>ENXReg[HostID1,5];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*First word of HostID  -- Sign bit on if promiscious<br>ENXReg[HostID2,6];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Second word of HostID<br>ENXReg[HostID3,7];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Third word of HostID<br><br>ENXReg[XmtMask,10];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Retransmission mask<br>ENXReg[XmtIntLo,10];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Retransmission interval, low bits<br>ENXReg[XmtIntHi,11];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Retransmission interval, high bits<br><br>ENXReg[ZeroBase,15];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*used to access ICB&rsquo;s and OCB&rsquo;s, value is always zero<br><br>ENXReg[Completion,17];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Completion word<br><br>*IOCB pointers<br><br>MC[ENXIndexNext,0];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Short Pointer to next ICB or OCB<br>MC[ENXIndexXmtMask,1];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Retransmission Mask<br>MC[ENXIndexCompletion,3];<br>MC[ENXIndexBuffer,4];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Long pointer and length (Quadword aligned)<br><br>*CSB pointers<br><br>MC[ENXIndexOCB,0];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*current OCB pointer<br>MC[ENXIndexIWake,2];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Wakeup Bitmask<br>MC[ENXIndexOWake,1];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Wakeup Bitmask<br>MC[ENXIndexICB,4];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*current ICB pointer<br>MC[ENXIndexNoICBCount,3]; *Count of times when no ICB chain (For test only)<br>MC[ENXIndexScratch,10];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Quadword scratch area<br><br>*Controller Hardware Input Registers address definitions<br><br>Set[ENXDevID,0];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Device I.D. number<br>Set[ENXStatus1,1];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Status1 register<br>Set[ENXXmtStatus,15];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Status1 register, sets Mode Latch to Xmt Mode<br>Set[ENXRcvStatus,11];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Status1 register, resets Mode Latch to Rcv Mode<br>Set[ENXStatus2,2];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Status2 register<br>Set[ENXReadState,2];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*read State register, via Status2 register<br>Set[ENXExcessCount,2];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Excess Count, via Status2 register<br>Set[ENXInData,3];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input data for INPUT operation<br>Set[ENXIData,Add[LShift[ZeroModFour,4],3]]; *Input data for IOSTORE16 operation<br><br>*Controller Hardware Output Registers address definitions<br><br>Set[ENXResetState,0];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*General Reset<br>Set[ENXIState,1];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*InState register<br>Set[ENXOState,2];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*OutState register<br>Set[ENXOutData,4];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Output data for OUTPUT operation<br>Set[ENXOData,Add[LShift[ZeroModFour,4],4]]; *Output data for IOFETCH16 operation<br><br>*Status bit definitions<br><br>Set[ENXSIBA,4000];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input Bad Alignment<br>Set[ENXSIORun,2000];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input overrun<br>Set[ENXSIBadPkt,1000];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input Bad Packet<br>Set[ENXSICRC,400];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input Bad CRC<br>Set[ENXSOPAR,200];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Output Bad Parity<br>Set[ENXSOURun,100];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Output Underrun  <br>Set[ENXSOCOLL,40];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Transmitter-detected collision (Collision)  <br>Set[ENXSOFAULT,20];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Output Data Fault<br><br>MC[ENXISMask,OR[ENXSIBadPkt,ENXSIORun,ENXSICRC,ENXSIBA]];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Status bits bits<br>MC[ENXOSMask,OR[ENXSOURun,ENXSOCOLL,ENXSOFAULT,ENXSOPAR]];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Output Status bits<br>MC[ENXOCollisionMask,ENXSOCOLL];<br><br>*Completion codes<br><br>MC[ENXGoodPacket,040000];<br>MC[ENXErrorZeroBuf,064000];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*On input (length&lt;3) and output (length=0)<br>MC[ENXPktBufOverrun,061000];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Input only<br>MC[ENXErrorCountOV,062000];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Output only<br>MC[ENXLateCollision,063000];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Output only<br><br><br>*State Register command words<br><br>MC[ENXResetAll,0];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Resets InState and OutState registers<br><br>*InState Register command words<br><br>MC[ENXDisableInput,Or[LShift[1,14],0]];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Resets: Enable Input<br>MC[ENXEnableInput,Or[LShift[11,14],0]];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Sets: Enable Input<br>MC[ENXSetPurgeMode,Or[LShift[15,14],0]];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Sets: Enable Input, PurgeMode<br><br>*OutState Register command words<br><br>MC[ENXSetOutputEOP,340];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Sets: Enable Output, OutputEOP<br>MC[ENXEnableOutput,300];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Sets: Enable Output, Output Buffer<br>MC[ENXDisableOutput,0];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Clears: Output state register, Reset Output Buffer<br>MC[ENXResetBuffer,200];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Clears: Reset Output Buffer<br><br>*Preamble word constant definition<br><br>MC[ENXPream,125];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Ethernet II preamble byte (0101010101010101)<br>MC[ENXPreamLast,200];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*to set bit for last preamble word (0101010111010101)<br><br>*Timer definitions<br><br>SetTask[TTask];<br>Set[TimerRunning,5];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*State 5 is simple timer<br>Set[TimerIdle,4];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*State 4 is idle<br>MC[ENXTimerMask,LShift[TimerRunning,14]];<br>MC[ENXIdleTimer,LShift[TimerIdle,14]];<br>*MC[pENXRandomReg,IP[ClockLo]];</span><span class="tab" val="52"></span><span style="font: 12pt serif">* random number<br>MC[pENXRandomReg,IP[</span><span style="font: 10pt serif">RTCLow</span><span style="font: 12pt serif">]];</span><span class="tab" val="52"></span><span style="font: 12pt serif">* random number<br><br>%<br>*CSB definitions<br><br>00</span><span class="tab" val="52"></span><span style="font: 12pt serif">Short pointer to First OCB<br>01</span><span class="tab" val="52"></span><span style="font: 12pt serif">Output wakeup bit mask<br>02</span><span class="tab" val="52"></span><span style="font: 12pt serif">Input wakeup bit mask<br>03</span><span class="tab" val="52"></span><span style="font: 12pt serif">Packets missed (for debugging)<br><br>04</span><span class="tab" val="52"></span><span style="font: 12pt serif">Short pointer to First ICB<br>05</span><span class="tab" val="52"></span><span style="font: 12pt serif">Host Address (MSB)<br>06</span><span class="tab" val="52"></span><span style="font: 12pt serif">Host Address<br>07</span><span class="tab" val="52"></span><span style="font: 12pt serif">Host Address (LSB)<br><br>10</span><span class="tab" val="52"></span><span style="font: 12pt serif">Quadword scratch buffer<br>11</span><span class="tab" val="52"></span><span style="font: 12pt serif">Quadword scratch buffer<br>12</span><span class="tab" val="52"></span><span style="font: 12pt serif">Quadword scratch buffer<br>13</span><span class="tab" val="52"></span><span style="font: 12pt serif">Quadword scratch buffer<br><br>14</span><span class="tab" val="52"></span><span style="font: 12pt serif">Used by test program<br>15</span><span class="tab" val="52"></span><span style="font: 12pt serif">Used by test program<br>16</span><span class="tab" val="52"></span><span style="font: 12pt serif">Used by test program<br>17</span><span class="tab" val="52"></span><span style="font: 12pt serif">Used by test program<br><br>*ICB definitions<br><br>00</span><span class="tab" val="52"></span><span style="font: 12pt serif">Link to next ICB<br>01</span><span class="tab" val="52"></span><span style="font: 12pt serif">Unused<br>02</span><span class="tab" val="52"></span><span style="font: 12pt serif">Unused<br>03</span><span class="tab" val="52"></span><span style="font: 12pt serif">Completion word (Ending Status)<br><br>04</span><span class="tab" val="52"></span><span style="font: 12pt serif">Bytes used in buffer<br>05</span><span class="tab" val="52"></span><span style="font: 12pt serif">Length of buffer (number of bytes)<br>06</span><span class="tab" val="52"></span><span style="font: 12pt serif">Low pointer to buffer<br>07</span><span class="tab" val="52"></span><span style="font: 12pt serif">High pointer to buffer<br><br>*OCB definitions<br><br>00</span><span class="tab" val="52"></span><span style="font: 12pt serif">Link to next OCB<br>01</span><span class="tab" val="52"></span><span style="font: 12pt serif">Retransmission Mask<br>02</span><span class="tab" val="52"></span><span style="font: 12pt serif">Unused<br>03</span><span class="tab" val="52"></span><span style="font: 12pt serif">Completion word (Ending Status)<br><br>04</span><span class="tab" val="52"></span><span style="font: 12pt serif">Unused<br>05</span><span class="tab" val="52"></span><span style="font: 12pt serif">Length of buffer (number of bytes)<br>06</span><span class="tab" val="52"></span><span style="font: 12pt serif">Low pointer to buffer<br>07</span><span class="tab" val="52"></span><span style="font: 12pt serif">High pointer to buffer<br>%<br><br>SetTask[ZeroModFOur];<br><br>********  INITIALIZATION  MICROCODE  ********</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif"><br>*Microcode is notified at ENXInitLoc (from Initialize) to setup things.<br><br>ENXInitSetup:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp3 &larr; IP[enxNotify]C, GoTo[ENXInitMain], At[ENXInitLoc];<br>*</span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp3 &larr; IP[enxNotify2]C, GoTo[ENXInitMain], At[ENXInitLoc2];<br>*</span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp3 &larr; IP[enxNotify3]C, GoTo[ENXInitMain], At[ENXInitLoc3];<br><br>ENXInitMain:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (SStkP&NStkP) xor (377C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">StkP &larr; ENXTemp3, ENXTemp3 &larr; T, NoRegILockOK;<br>*Compute value for ENXONotify register, used for notify after timer wakeup.<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (CTask&NCIA) and (170000C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; (ENXTemp) or (LoA[ENXOTimerDoneLoc]);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXTemp &larr; (ENXTemp) or (HiA[ENXOTimerDoneLoc]);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Stack &larr; T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">StkP &larr; ENXTemp3;<br>*</span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXInitialCSB;<br>*</span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXCSBPtr &larr; T;<br><br>* Pilot Initialize sets up this reg; we have to do it by hand<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXCSBPtr &larr; 177400c;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXCSBPtr &larr; (ENXCSBPtr) + (lshift[EnxTask,4]c);<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LoadPage[ENXPage];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXCSBPtrHi &larr; 0C, GoToP[ENXReset];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Also zeroes ENXZeroBase<br><br>*Microcode is notified at ENXReset (from StartIO) to reset things.<br><br>OnPage[ENXPage];<br><br>ENXReset:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXXmtStatus], At[ENXStartLoc];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; ENXResetAll;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXTemp, ENXResetState];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtPtrHi &larr; 1C;  *See comments at ENXOTimerDone<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; ENXIdleTimer, Call[ENXLoadTimer];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Call[ENXSetupLink];<br><br>%Sleep here until awaken by by an Input or Output wake request<br>microcode is set to Recv Mode whenever microcode is re-initialized<br><br>********  INPUT  MICROCODE  ********</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif"><br>set Purge Mode<br>We get here for 3 reasons:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">1) The filter rejected this packet,<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">2) We wanted it, but didn&rsquo;t have an IOCB setup yet, or<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">3) We just finished processing a packet.<br>%<br>ENXIPurge:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; ENXSetPurgeMode, Call[ENXWriteInState];<br></span><span style="font: bold 12pt serif">*</span><span class="tab" val="52"></span><span style="font: 12pt serif">Call</span><span style="font: bold 12pt serif">[ENXRet];  *Pipeline delay krock<br></span><span style="font: 12pt serif">*Idle state of input microcode<br>*Wait for the next packet to arrive<br>*or the driver to poke the output hardware<br>*or the the timer to go off and poke the output hardware<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXStatus1], Call[ENXDispatcher];<br><br><br>* ADDRESS RECOGNITION:<br>*</span><span class="tab" val="52"></span><span style="font: 12pt serif">Check if the packet,<br>*</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">is explicitly for this host (dest=us),<br>*</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">or is broadcast (dest bit 7 set),<br>*</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">or if we are promiscuous (sign bit of word is on).<br><br>ENXIBegin:<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">IOStore4[ENXCSBPtr,ENXIData,ENXIndexScratch!], Call[ENXRet];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PFetch4[ENXCSBPtr,ENXNextICB,ENXIndexICB!], Call[ENXRet]; *Host Address<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXHostID1;</span><span class="tab" val="52"></span><span style="font: 12pt serif"><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PFetch4[ENXCSBPtr, ENXDestID1, ENXIndexScratch!], Skip[ALU&gt;=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; ENXNextICB, GoTo[ENXIForMe];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*sign bit on =&gt; we are promiscuous <br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; LCy[ENXDestID1,7];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (LCy[ENXHostID1,7]) xor T, Skip[ALU&gt;=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; ENXNextICB, GoTo[ENXIMulticast];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Multicast Mode<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXDestID2, Skip[ALU=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  GoTo[ENXIPurge];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*First word didn&rsquo;t match<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXHostID2) xor T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXDestID3, Skip[ALU=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  GoTo[ENXIPurge];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Second word didn&rsquo;t match<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXHostID3) xor T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; ENXNextICB, Skip[ALU=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  GoTo[ENXIPurge];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Third word didn&rsquo;t match<br><br>ENXIMulticast:</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*take all Multicast for now<br>ENXIForMe:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">GoTo[ENXIRead,ALU#0];<br><br>* No buffer for this packet, bump counter for debugging<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PFetch1[ENXCSBPtr,ENXTemp,ENXIndexNoICBCount!];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; (ENXTemp) + 1;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PStore1[ENXCSBPtr,ENXTemp,ENXIndexNoICBCount!], GoTo[ENXIPurge];<br><br>ENXIRead:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXNextICB) + (ENXIndexBuffer), Call[ENXRcvSetup];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; (ENXRcvCount) - (22C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">* (4 for end test, 4 for first clump) * 2 for bytes<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXRcvCount &larr; (ENXRcvCount)-(20C), Skip[ALU&gt;=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  T &larr; ENXCompletion &larr; ENXErrorZeroBuf, GoTo[ENXIMark];<br><br></span><span style="font: bold 12pt serif">* Hackery for off-by-one buffer alignment<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">PStore1[ENXRcvPtr, ENXDestID1, 0];<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">PStore2[ENXRcvPtr, ENXDestID2, 1], ODDOK;<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">PStore1[ENXRcvPtr, ENXDestID4, 3], </span><span style="font: 12pt serif">Call</span><span style="font: bold 12pt serif">[ENXRet];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[</span><span style="font: bold 12pt serif">ENXTemp, ENXInData];<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">PStore1[ENXRcvPtr, ENXTemp, 4], </span><span style="font: 12pt serif">Call</span><span style="font: bold 12pt serif">[ENXRet];<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">ENXRcvCount &larr; (ENXRcvCount)-(2C);<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">(ENXRcvIndex) &larr; (ENXRcvIndex)+(1C);<br></span><span style="font: 12pt serif"><br></span><span style="font: bold 12pt serif">* Hackery to test Overrun:<br>*</span><span class="tab" val="52"></span><span style="font: bold 12pt serif">ENXTemp &larr; 10000C, </span><span style="font: 12pt serif">Call</span><span style="font: bold 12pt serif">[ENXRet];<br>*</span><span class="tab" val="52"></span><span style="font: bold 12pt serif">ENXTemp &larr; (ENXTemp)-1, </span><span style="font: 12pt serif">Skip[</span><span style="font: bold 12pt serif">R&lt;0];<br>*</span><span class="tab" val="52"></span><span style="font: bold 12pt serif"> </span><span style="font: 12pt serif">GoTo</span><span style="font: bold 12pt serif">[ENXRet];<br>*</span><span class="tab" val="52"></span><span style="font: bold 12pt serif">NOP;<br></span><span style="font: 12pt serif"><br>ENXIReLoop:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Call[ENXRet];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">* set up TPC for data transfer loop<br><br>ENXILoop:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXRcvCount &larr; (ENXRcvCount) - (10C), Skip[R&gt;=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  T &larr; ENXRcvIndex &larr; (ENXRcvIndex) + (4C), GoTo[ENXIFull];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXRcvIndex &larr; (ENXRcvIndex) + (4C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">IOStore4[ENXRcvPtr,ENXIData];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXRcvCount &larr; (ENXRcvCount) - (10C), Skip[R&gt;=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  T &larr; ENXRcvIndex &larr; (ENXRcvIndex) + (4C), GoTo[ENXIFull];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXRcvIndex &larr; (ENXRcvIndex) + (4C), GoTo[ENXILoopAttn,IOAtten&rsquo;];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">IOStore4[ENXRcvPtr,ENXIData], Return;<br><br>ENXILoopAttn:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXStatus1], Call[ENXDispatcher];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXRcvIndex;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">IOStore4[ENXRcvPtr,ENXIData], GoTo[ENXIReLoop];<br><br>*Finish up the receive packet<br>*Calculate packet length<br>ENXIEnd:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp1,ENXExcessCount], At[ENXDispTableLoc,1];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; LdF[ENXTemp1,13,5], Call[ENXRet];</span><span class="tab" val="52"></span><span style="font: 12pt serif">* Get excess byte count<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXRcvIndex &larr; LSh[ENXRcvIndex,1];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">* change words to bytes<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXRcvIndex &larr; (ENXRcvIndex) - T;</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*adjust total byte count<br><br>*Without this test, tiny packets look huge because of underflow<br>*Spec calls for min of 60 bytes (30 words)<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; (ENXRcvIndex) - (15C);</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*8 bytes is 4 data words<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXRcvIndex &larr; (ENXRcvIndex) - (5C), Skip[ALU&gt;=0];  * 4 CRC and 1 mumble<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  GoTo[ENXIPurge];<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp2, ENXRcvStatus];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXTemp2 &larr; (ENXTemp2) and (ENXISMask);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXCompletion &larr; T, Skip[ALU#0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  ENXCompletion &larr; ENXGoodPacket, GoTo[ENXIMark];<br><br>*Buffer is full.  Check for end of packet before posting error.<br>ENXIFull:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXStatus1], Call[ENXDispatcher];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXCompletion &larr; ENXPktBufOverrun, GoTo[ENXIMark];<br><br>ENXIMark:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXCompletion &larr; (ENXCompletion) or T, Call[ENXFetchICB];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXICBPtr) + (ENXIndexCompletion), Call[ENXStoreCompletion];</span><span class="tab" val="52"></span><span style="font: 12pt serif"><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXICBPtr) + (ENXIndexBuffer), Call[ENXStoreWordsUsed];<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXIndexIWake, Call[ENXInterrupt];<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXICBPtr) + (ENXIndexNext), Call[ENXChainToNextIOCB];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PStore1[ENXCSBPtr,ENXICBPtr,ENXIndexICB!], GoTo[ENXIPurge];<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif">********  OUTPUT  MICROCODE  ********</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif"><br><br>ENXSetupLink:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">UseCTask;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; APC&APCTASK;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXLink &larr; T, GoTo[ENXOIdle];<br><br>ENXNoWork:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; ENXDisableOutput, Call[ENXWriteOutState];<br></span><span style="font: bold 12pt serif">*</span><span class="tab" val="52"></span><span style="font: 12pt serif">Call</span><span style="font: bold 12pt serif">[ENXRet];  * Pipeline delay krock<br></span><span style="font: 12pt serif">* Idle state of output microcode.<br>* on a wakeup, is it a transmit wake or receive wake?<br>ENXOIdle:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp, ENXStatus1], Call[ENXDispatcher];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PFetch1[ENXCSBPtr, ENXOCBPtr, ENXIndexOCB!], GoTo[ENXOCheckNext];<br><br>ENXOCheck:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXOCBPtr)+(ENXIndexXmtMask), Skip[ALU#0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">* ALU=0 =&gt; no IOCB, no packet to transmit<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  GoTo[ENXNoWork];<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">OddPFetch1[ENXZeroBase,ENXXmtMask], Call[ENXRet];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtMask &larr; (LSh[ENXXmtMask,1])+1, Skip[R&gt;=0]; * R&lt;0 =&gt; overflow<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  T &larr; ENXCompletion &larr; ENXErrorCountOV, GoTo[ENXOMark];</span><span class="tab" val="52"></span><span style="font: 12pt serif"><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">OddPStore1[ENXZeroBase,ENXXmtMask];<br><br>%<br>We are about to start sending a packet.  In order to help hosts with half<br>duplex interfaces avoid missing packets in the window behind a packet we<br>just sent, we would like to delay for 1ms or so if we are sending them<br>another packet.  We approximate that by always waiting.<br>Taft+Dorado do it a bit better by remembering the time that the last packet<br>finished getting sent.  Maybe we should do that too.<br>%<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">NOP;  *Aviod bypass kludge<br>ENXOWait:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXXmtMask) xor (1C);</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*is this the first attemp to transmit?<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Skip[ALU#0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  ENXXmtIntLo &larr; 24C, GoTo[ENXOCountdown];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*yes, count 1 msec, 24B is 20D = 1000/50<br><br>*Compute countdown interval, Use high resolution clock for random number<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; GETRSPEC[103] XOR (377C);</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Stkp (reads inverted)<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; pENXRandomReg;</span><span class="tab" val="52"></span><span style="font: 12pt serif">*point to "random" register<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">StkP &larr; ENXTemp, ENXTemp &larr; T, NoRegILockOK; <br><br>*Form new transmission interval mask, check if old has overflowed<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; CTask;</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*in case we have 2 boards on the same machine<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (LdF[Stack,6,12]) xor T;</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Get low 10 bits<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">StkP &larr; ENXTemp;</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Restore stack-pointer<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; (RSH[ENXXmtMask,1]) and T;</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Mask random number with old value<br>*ENXXmtIntLo now has (10bit) number of Ethernet ticks to wait.<br><br>%<br>We need a tick size of 512 bit times.  The timers on the D0<br>have a basic tick size of 64 times the clock speed.  If the clock is 100ns,<br>thats 6.4 microsec.  8*6.4 is 51.2.  How convient.<br>8=2&uarr;3, so thats why there is this LSH by 3.<br>%<br>ENXOCountdown:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; LSH[ENXXmtIntLo,3], Skip[ALU#0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  GoTo[ENXOGo];<br><br>*At this point, ENXXmtIntLo contains the number of D0 ticks to wait. (13 bits)<br>*Unfortunately, that doesn&rsquo;t fit into a simple timer.<br>*We process the overflow with software.<br>*The timer holds 7 bits, but we use only 6 to save an instruction.<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtPtrHi &larr; 0C;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (LdF[ENXXmtIntLo,3,7]);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntHi &larr; T, Call[ENXRet];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; LdF[ENXXmtIntLo,12,6];<br><br>ENXOLoadTimer:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; LSh[ENXXmtIntLo,4];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; (ENXXmtIntLo) or (ENXTimerMask), Call[ENXLoadTimer];<br></span><span style="font: bold 12pt serif">*</span><span class="tab" val="52"></span><span style="font: 12pt serif">Call</span><span style="font: bold 12pt serif">[ENXRet];  * Pipeline delay krock<br></span><span style="font: 12pt serif"><br>*Get here if a packet arrives or the timer goes off and enables output<br>*(or a buggy driver enables output)<br>ENXODisp:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXStatus1], Call[ENXDispatcher];<br>*Return here when output enabled by timer<br><br></span><span style="font: bold 12pt serif">*Glitch Chasing<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[</span><span style="font: bold 12pt serif">ENXXmtIntLo, ENXStatus2];<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">LU &larr; (ENXXmtIntLo) AND (100000C);  * Reset Output&rsquo;<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">Skip[ALU=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  PFetch1[ENXCSBPtr, ENXOCBPtr, ENXIndexOCB!], GoTo[ENXOGo];<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">*Barf, input got turned off too late to back put of the pipeline<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">*This happens if the tail of a packet was generating wakeups and<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">*PktGap gets reset when another packet arrives.<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">NOP;  * Allocation<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Call</span><span style="font: bold 12pt serif">[ENXRet];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">GoTo</span><span style="font: bold 12pt serif">[ENXODisp];<br>*Glitch Chasing<br></span><span style="font: 12pt serif"><br>*</span><span class="tab" val="52"></span><span style="font: 12pt serif">PFetch1[ENXCSBPtr, ENXOCBPtr, ENXIndexOCB!], GoTo[ENXOGo];<br><br>*Timer has expired, Timer task notifies at ENXOTimerDoneLoc.  Note that we   <br>*can&rsquo;t smash our TPC, or any temp RM registers, or T because we may be in<br>*the middle of receiving a packet.<br><br>ENXOTimerDone:<br><br>*ENXXmtPtrHi=0 indicates we are expecting a Timer to go off.<br>*There is a race condition when trying to kill timers,<br>* and/or a buggy driver might wake us up at a bad time.<br>*Even if we are transferring into the first 64K, it will be non zero.<br><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; ENXXmtPtrHi, At[ENXOTimerDoneLoc];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntHi &larr; (ENXXmtIntHi) - 1, Skip[ALU=0];<br>PleaseTellHGMAboutThis:  *This is possible, but very unlikely<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  BreakPoint, ENXXmtIntHi &larr; (ENXXmtIntHi) + 1, Return;<br><br>*Check if still more time to elapse before start of transmission.<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; (2000C), Skip[ALU&lt;0]; *2000C is 100C LSH 4<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  ENXXmtIntLo &larr; (ENXXmtIntLo) or (ENXTimerMask), GoTo[ENXLoadTimer];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; ENXEnableOutput, GoTo[ENXWriteOutStateViaXmtIntLo];<br><br>*Load timer from data in ENXXmtIntLo, and disable the output hardware.<br>*Note: There must be at least 14 cycles between timer instructions.<br>*This code must be coordinated with Timer.mc and anything else that loads timers.<br>*Note that we ABORT for a long time after the OUTPUT.<br><br>ENXLoadTimer:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtPtr &larr; T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; CTask;</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Timer slot is same as task number.<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; (ENXXmtIntLo) or T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXXmtPtr;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LoadTimer[ENXXmtIntLo];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; ENXDisableOutput;<br>ENXWriteOutStateViaXmtIntLo:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXXmtIntLo, ENXOState];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIntLo &larr; ENXXmtIntLo, GoTo[ENXRet];  * Wakeup Pipeline<br><br><br>*Countdown interval is over<br>*Start to send words to the hardware.  The hardware will start<br>*the transmission to the Wire as soon as the buffer has<br>*&gt; 128 words in the hardware buffer, or the OutputEOP bit<br>*is set (for a packet of less than 127 words)<br><br>ENXOGo:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXOCBPtr) + (ENXIndexBuffer), Call[ENXXmtSetup];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Hackery below sends at least 5 words.  (spec calls for 30)<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXXmtCount) - (13C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXOCBPtr) + (ENXIndexXmtMask), Skip[ALU&gt;=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif"> T &larr; ENXCompletion &larr; ENXErrorZeroBuf, GoTo[ENXOMark]; *Buffer too small<br><br>*Send 4 word preamble (hardware doesn&rsquo;t compute CRC on first 4 words sent)<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXTemp &larr; ENXPream;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; (LSh[ENXTemp,10]) or T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXTemp,ENXOutData], Call[ENXILockENXTemp];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXTemp,ENXOutData], Call[ENXILockENXTemp];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXTemp,ENXOutData], Call[ENXILockENXTemp];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; (ENXTemp) or (ENXPreamLast);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXTemp,ENXOutData], Call[ENXILockENXTemp];<br><br></span><span style="font: bold 12pt serif">** Hackery for off-by-one buffer alignment<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">PFetch1[ENXXmtPtr,ENXTemp,0];<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">ENXXmtIndex &larr; (ENXXmtIndex)</span><span style="font: 12pt serif"> + </span><span style="font: bold 12pt serif">1;<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">ENXXmtCount &larr; (ENXXmtCount)</span><span style="font: 12pt serif"> - </span><span style="font: bold 12pt serif">(2C);<br></span><span class="tab" val="52"></span><span style="font: bold 12pt serif">LU &larr; ENXTemp;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[</span><span style="font: bold 12pt serif">ENXTemp,ENXOutData], </span><span style="font: 12pt serif">Call</span><span style="font: bold 12pt serif">[ENXILockENXTemp];<br></span><span style="font: 12pt serif"><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtCount &larr; (ENXXmtCount) - (11C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIndex &larr; (ENXXmtIndex) - (4C);<br>ENXOReLoop:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Call[ENXRet];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">* Leaves TPC setup for ENXOLoop<br>ENXOLoop:<br></span><span style="font: bold 12pt serif">* Do 12 word transfers to experiment with Overruns<br>*</span><span class="tab" val="52"></span><span style="font: bold 12pt serif">ENXXmtCount &larr; (ENXXmtCount)</span><span style="font: 12pt serif"> - </span><span style="font: bold 12pt serif">(10C), </span><span style="font: 12pt serif">Skip[</span><span style="font: bold 12pt serif">R&gt;=0];<br>*</span><span class="tab" val="52"></span><span style="font: bold 12pt serif"> ENXXmtCount &larr; (ENXXmtCount) + (20C), </span><span style="font: 12pt serif">GoTo</span><span style="font: bold 12pt serif">[ENXOLastXfer];<br>*</span><span class="tab" val="52"></span><span style="font: bold 12pt serif">T &larr; ENXXmtIndex &larr; (ENXXmtIndex) + (4C);<br>*</span><span class="tab" val="52"></span><span style="font: bold 12pt serif">IOFetch4[ENXXmtPtr,ENXOData];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtCount &larr; (ENXXmtCount) - (10C), Skip[R&gt;=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif"> ENXXmtCount &larr; (ENXXmtCount)</span><span style="font: bold 12pt serif"> + </span><span style="font: 12pt serif">(20C), GoTo[ENXOLastXfer];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXXmtIndex &larr; (ENXXmtIndex)</span><span style="font: bold 12pt serif"> + </span><span style="font: 12pt serif">(4C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">IOFetch4[ENXXmtPtr,ENXOData];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtCount &larr; (ENXXmtCount) - (10C), Skip[R&gt;=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif"> ENXXmtCount &larr; (ENXXmtCount)</span><span style="font: bold 12pt serif"> + </span><span style="font: 12pt serif">(20C), GoTo[ENXOLastXfer];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXXmtIndex &larr; (ENXXmtIndex)</span><span style="font: bold 12pt serif"> + </span><span style="font: 12pt serif">(4C), GoTo[ENXOLoopAttn,IOAtten&rsquo;];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">IOFetch4[ENXXmtPtr,ENXOData], Return;<br><br>ENXOLoopAttn:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">IOFetch4[ENXXmtPtr,ENXOData];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXStatus1], Call[ENXDispatcher];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">GoTo[ENXOReLoop];<br><br>*Normal exit from Output Loop is here<br><br>ENXOLastXfer:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtCount &larr; (ENXXmtCount) xor (377C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtCount &larr; (ENXXmtCount) and (37C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtCount &larr; (ENXXmtCount) or (ENXSetOutputEOP);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXXmtCount,ENXOState], Call[ENXILockENXXmtCount];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXXmtIndex) &larr; (ENXXmtIndex) + (4C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">IOFetch4[ENXXmtPtr,ENXOData], IOStrobe, Call[ENXRet];<br><br>*wakeup service requested when the packet is fully transmitted<br>*or a packet arrives.<br>ENXOAttn:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXStatus1], Call[ENXDispatcher];  * Shouldn&rsquo;t return<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">BreakPoint;<br><br>ENXOEnd:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXStatus1], At[ENXDispTableLoc,5];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Call[ENXFetchOCB];<br>*Beware: ENXCompletion is the same as ENXTemp<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXTemp &larr; (ENXTemp) and (ENXOSMask);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; (ENXTemp) xor (ENXOCollisionMask), Skip[ALU#0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  ENXCompletion &larr; ENXGoodPacket, GoTo[ENXOMark];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*No errors<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; (ENXXmtIndex) - (250C), Skip[ALU=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">  ENXCompletion &larr; T, GoTo[ENXOMark];</span><span class="tab" val="52"></span><span class="tab" val="52"></span><span style="font: 12pt serif">*Some error other than collision<br>*Collision only, check for a late one (hardware debugging)<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">*250C is 128 for buffer, 512bits=32 wds for collision, 8 slop<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXOCBPtr) + (ENXIndexBuffer), Skip[ALU&gt;=0];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif"> GoTo[ENXOFlap];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIndex &larr; LSh[ENXXmtIndex,1];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">OddPStore1[ENXZeroBase,ENXXmtIndex];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXCompletion &larr; ENXLateCollision;<br><br>ENXOMark:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXCompletion &larr; (ENXCompletion) or T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXOCBPtr)+(ENXIndexCompletion), Call[ENXStoreCompletion];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXIndexOWake, Call[ENXInterrupt];<br><br>ENXONextBuf:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXOCBPtr) + (ENXIndexNext), Call[ENXChainToNextIOCB];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PStore1[ENXCSBPtr,ENXOCBPtr,ENXIndexOCB!];<br><br>*Flap output enable to tell hardware that we have finished processing this packet<br>ENXOFlap:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; ENXDisableOutput;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXTemp,ENXOState];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; ENXTemp;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; ENXEnableOutput, Call[ENXWriteOutState];<br><br>ENXOCheckNext:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; ENXOCBPtr, GoTo[ENXOCheck];<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif"><br>********  SUBROUTINES  ********</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif"><br><br>ENXDispatcher:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">UseCTask;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; APCTask&APC;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Dispatch[ENXTemp,14,3];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Disp[ENXDispTable];<br><br>ENXDispTable:<br><br>*000  Receive Data wakeup from idle state (no Atten)<br>ENXRet:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Return, At[ENXDispTableLoc,0];<br><br>*ENXIEnd has an At[ENXDispTableLoc,1];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*001</span><span class="tab" val="52"></span><span style="font: 12pt serif">Receive End-of-packet<br><br>*010  Output Packet Done<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXXmtStatus], </span><span style="font: 10pt serif">At[</span><span style="font: 12pt serif">ENXDispTableLoc,2];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXLink &larr; T, GoTo[ENXOEnd];<br><br>*011  Transmit Data Wake Request<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXXmtStatus], </span><span style="font: 10pt serif">At[</span><span style="font: 12pt serif">ENXDispTableLoc,3];<br>ENXSwitch:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">APCTask&APC &larr; ENXLink, ENXLink &larr; T, NoRegILockOK, GoTo[ENXRet];<br><br><br>*100  Transmit Data wakeup from idle state or timer wait (no Atten)<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Return, </span><span style="font: 10pt serif">At[</span><span style="font: 12pt serif">ENXDispTableLoc,4];<br><br>*101  Output Packet Done<br>*</span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXOEnd has an </span><span style="font: 10pt serif">At[</span><span style="font: 12pt serif">ENXDispTableLoc,5];<br><br>*110  Receive End-of-Packet<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXRcvStatus], </span><span style="font: 10pt serif">At[</span><span style="font: 12pt serif">ENXDispTableLoc,6];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXLink &larr; T, GoTo[ENXIEnd];<br><br>*111  Receive Data Wake Request<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Input[ENXTemp,ENXRcvStatus], GoTo[ENXSwitch], </span><span style="font: 10pt serif">At[</span><span style="font: 12pt serif">ENXDispTableLoc,7];<br><br><br>*Notify the driver by generating appropiate interrupts.<br>*This could be merged with ENXChainToNextIOCB,<br>*  but that would be too long between TASKs.<br>*</span><span class="tab" val="52"></span><span style="font: 12pt serif">T=ENXIndexIWake notifies receive software with receive bit mask<br>*</span><span class="tab" val="52"></span><span style="font: 12pt serif">T=ENXIndexOWake notifies transmit software with transmit bit mask<br><br>ENXInterrupt:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PFetch1[ENXCSBPtr,ENXTemp];</span><span class="tab" val="52"></span><span style="font: 12pt serif">*Fetch wakeup bitmask<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LoadPage[DoIntPage];  <br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXTemp, GoToP[</span><span style="font: 10pt serif">DoInt</span><span style="font: 12pt serif">];<br><br>% Was (for Pilot world):<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LoadPage[NotifyInterruptPage];  <br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXTemp, GoToP[NotifyInterrupt];<br>%<br><br>* Head assumes that this is Atomic.<br>ENXChainToNextIOCB:<br>* assumes that ENXICBPtr is the same as ENXOCBPtr<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">OddPFetch1[ENXZeroBase,ENXOCBPtr];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">LU &larr; ENXOCBPtr, UseCTask, GoTo[ENXRet];<br><br><br>ENXWriteInState:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXTemp,ENXIState], GoTo[ENXILockENXTemp];<br><br>ENXWriteOutState:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">Output[ENXTemp,ENXOState], GoTo[ENXILockENXTemp];<br><br>ENXILockENXTemp:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXTemp &larr; ENXTemp, GoTo[ENXRet];  *Dally for Wakeup Pipeline<br><br>ENXILockENXXmtCount:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtCount &larr; ENXXmtCount, Return;<br><br><br>* Handy subroutines convient for tasking even if they are only called once.<br>* BEWARE of bypass problems<br><br>ENXStoreCompletion:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">OddPStore1[ENXZeroBase, ENXCompletion], GoTo[ENXRet];<br><br>ENXStoreWordsUsed:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">OddPStore1[ENXZeroBase, ENXRcvIndex], GoTo[ENXRet];<br><br>ENXFetchICB:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PFetch1[ENXCSBPtr,ENXICBPtr,ENXIndexICB!], GoTo[ENXRet];<br><br>ENXFetchOCB:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">PFetch1[ENXCSBPtr,ENXOCBPtr,ENXIndexOCB!], GoTo[ENXRet];<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif"><br>*Get buffer descriptor pointed to by T, fix base pointers<br>*(ENXxxxPtr,ENXxxxPtrHi) by transforming ENXxxxPtrHi from (0, x) to (x, x+1)<br>* zero out ENXxxxIndex<br><br>ENXXmtSetup:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">OddPFetch4[ENXZeroBase,ENXXmtIndex];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtIndex &larr; (ENXXmtIndex) and (0C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXXmtPtrHi) + 1;</span><span class="tab" val="52"></span><span style="font: 12pt serif"><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXXmtPtrHi &larr; (LSH[ENXXmtPtrHi,10]) or T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXXmtPtrHi &larr; (FixVA[ENXXmtPtrHi]) or T, Return;<br><br>ENXRcvSetup:<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">OddPFetch4[ENXZeroBase,ENXRcvIndex];<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXRcvIndex &larr; (ENXRcvIndex) and (0C);<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; (ENXRcvPtrHi)+1;</span><span class="tab" val="52"></span><span style="font: 12pt serif"><br></span><span class="tab" val="52"></span><span style="font: 12pt serif">T &larr; ENXRcvPtrHi &larr; (LSH[ENXRcvPtrHi,10]) or T;<br></span><span class="tab" val="52"></span><span style="font: 12pt serif">ENXRcvPtrHi &larr; (FixVA[ENXRcvPtrHi]) or T, Return;<br><br>  END[ENXTask];</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 12pt serif"><br>:ELSE; **********************************************<br><br>  TITLE[No.10MB.Ethernet.Microcode];<br><br>:ENDIF; *********************************************<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
