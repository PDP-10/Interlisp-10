<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>MesaDefs.Mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:TITLE[MesaDefs];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Definitions for Mesa code modules<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ed Fiala 3 June 1982<br><br>*ASSEMBLY SWITCHES<br><br>Set[AltoMode,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Default Mesa assemblies to Alto mode.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(Pilot mode = 0, but no longer supported)<br>Set[CacheLocals,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Indicate cache for Mesa locals 0 to 3<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(performance improvement affecting MesaLS and MesaX;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*presently, this MUST be 1 for AltoMode=1)<br>Set[WithFloatingPoint,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 assembles MesaFP.Mc in MicOverlay<br><br><br>*PAGE ASSIGNMENTS<br>*Set[opPage0,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*These cannot move since hardware forces the first mi<br>*Set[opPage1,5];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*of each bytecode to start at 2001 + (4 * opcode)<br>*Set[opPage2,6];<br>*Set[opPage3,7];<br>*  Loca[KFCRLoc,opPage3,76];<br>*  Loca[P7TailLoc,opPage3,27];</span><span class="tab" val="67"></span><span style="font: 10pt serif">**Don&rsquo;t move--used by LRJ<br><br><br>Set[xfPage1,10];<br>  Loca[xfPage1p,xfPage1,0];<br>  Loca[xfType,xfPage1,140];<br>  Loca[MiscDisp0,xfPage1,160];<br>  Loca[MiscDisp1,xfPage1,200];<br>  Loca[LoadGCLoc,xfPage1,220];<br><br>Set[RRPage,10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*07b mi in MesaX (not pages 4 to 7)<br>Set[RS232Page,6];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*07b mi in MesaX<br>Set[prPage,11];<br>Set[CSPage,10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*25b mi for CSum Misc opcode (not on pages 4 to 7)<br>Set[MStartPage,7];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*14b mi for MStart<br>Set[BLTPage,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*50b mi for various BLT opcodes in MesaX<br>Set[CBLPage,5];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*02b mi for subr used by WCBL and ICBL opcodes<br><br>IFE[And[CSPage,14],4,ER[CSPage.illegal.page.4.to.7]];<br><br>%Register definitions for Alto and Mesa emulators<br><br>For Mesa, RM 21, 44-53, 56-57, 66-73 are temps; RM 17, 25, and 64 are somewhat<br>temps (see comment later); RM 0 and 20 are unused; all other RM locations<br>have uses that must survive across opcodes.<br>**Maybe free RM 21 (CurrentTime) in MesaP.<br>%<br>*Mesa Stack cannot move because of hardware overflow/underflow checking.<br>RV[Stack0,1]; RV2[Stack1,Stack2,2]; RV4[Stack3,Stack4,Stack5,Stack6,4];<br>RV4[Stack7,Stack8,Stack9,Stack10,10]; RV2[Stack11,Stack12,14]; RV[Stack13,16];<br><br>RV2[CODE,CODEhi,22];<br>*RV[NWW,24];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Both Alto and Mesa<br>RV2[LOCAL,LOCALhi,26];<br>*RV2[PCB,PCBhi,30];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alto and Mesa<br>*RV2[MDS,MDShi,32];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alto and Mesa<br>*RM[RMZero,IP[MDS]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Contains 0 for both Mesa and Alto<br>*RM[RZero,IP[MDS]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Contains 0 for both Mesa and Alto<br>*RV4[IBuf,IBuf1,IBuf2,IBuf3,34];<br>*RV4[wBuf,wBuf1,wBuf2,wBuf3,40];<br>*RV4[xBuf,xBuf1,xBuf2,xBuf3,44];<br>*RV4[yBuf,yBuf1,yBuf2,yBuf3,50];<br><br>:IF[CacheLocals];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Cache Local0 to Local3 for Mesa<br>RV4[LocalCache0,LocalCache1,LocalCache2,LocalCache3,IP[wBuf]];<br>:ENDIF;<br><br>RV4[GLOBAL,GLOBALhi,xfMY,xfMX,54];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*For Mesa<br><br>*Constants<br>*RV[R400,60];<br>*RV[AllOnes,61];<br><br>*RV[MemStat,62];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Directs page fault handling by Fault.Mc<br><br>RV[xfWDC,63];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Wakeup disable counter<br><br>*RV2[LP,LPhi,66];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Long pointer base pair. (used by LRJ--cannot move)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(Used for Alto XMLDA & XMSTA)<br><br>*RV4[zBuf,zBuf1,zBuf2,zBuf3,70];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Quadword used by MesaFP<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(Don&rsquo;t move unless xfTemp def changed--see below)<br><br>*RV[RTemp,IP[yBuf2]];<br>*RV[RTemp1,IP[yBuf3]];<br><br>%These 1st 3 registers may be read by a MISC opcode.  They are used to pass<br>values through xfer to trap procedures, so the sequence is load-the-register,<br>do-an-xfer, disable-interrupts, and then simple code sequence to read the<br>register and save its value.  For this reason, these registers are reused in<br>the process code (because interrupts are off) and in BitBlt and the floating<br>point opcodes (because BitBlt is not in the trap sequence), but they may not<br>be used in opcodes which might appear in the trap procedure.<br>%<br>RV[xfXTPreg,25];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Xfer trap parameter<br>RV[xfATPreg,64];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alloc trap parameter<br>RV[xfOTPreg,17];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Other trap parameter<br><br>*These hold permanent state<br>RV[xfGFIWord,65];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Holds word 0 of global frame<br>RV[xfBrkByte,74];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Permanent--holds break byte<br></span><span style="font: 8pt serif">*75 used as &rsquo;Sticky&rsquo; by MesaFP.Mc<br></span><span style="font: 10pt serif">RV[TickCount,76];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*For process timeout (Valid for Mesa only)<br>RV[xfXTSreg,77];<br><br>RV[RLink,IP[zBuf1]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Used in MesaP and ?<br>*RV2[xfTemp,xfTemp1,IP[zBuf2]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*(used by LRJ--cannot move)<br><br>RV2[LPdest,LPdesthi,IP[xfMY]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Long BLT<br><br>*Process registers (also use RLink, RTemp, RTemp1, xfTemp, WW, and ?)<br>*Is zBuf available here?<br>RV2[PBase,PBasehi,IP[MDS]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*PSB base reg = MDS, NOT initialized anywhere<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(must change in the Post IME world)<br>RV[CurrentTime,21];<br>RV2[Queue1,Queue1hi,IP[xBuf]];<br>RV2[Queue2,Queue2hi,IP[xBuf2]];<br>RV[PRTime,IP[zBuf2]];<br>RV[Process,IP[zBuf3]];<br>RV[MQ,IP[LP]];<br>RV2[QTemp,QTemphi,IP[yBuf]];<br>RV[Prev,IP[xfXTPreg]];<br>RV[PRFlags,IP[xfATPreg]];<br>RV[EMLink,16];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Only used by ExitMon<br>RV[IntType,IP[LPhi]];<br>RV[IntLevel,IP[xfMX]];<br>RV[ITemp,IP[yBuf]];<br>RV[ITemp1,IP[yBuf1]];<br>*RV[WW,56];<br><br>*Temporaries for xfer (also xfTemp, xfTemp1, xfMY, xfMX, and ?)<br>*Are xBuf, xBuf1, xBuf2, xBuf3, yBuf, and yBuf1 available here?<br>RV[xfTemp2,IP[LP]];<br>RV[xfCount,IP[LP]];<br>RV[xfFSI,IP[LPhi]];<br>RV[xfRlink,IP[RLink]];<br>RV[xfFrame,IP[zBuf]];<br><br>MC[xfAV,1000];<br>MC[xfSDOffset,100];<br>MC[xfGFT,1400];<br><br>MC[Normal,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Things in MemStat<br>MC[FreeFrame,10];<br>MC[EarlyXfer,4];<br>MC[BltFixup,3];<br>MC[BltLFixup,2];<br>MC[XferFixup,1];<br><br>*Frame formats<br>MC[xfPcOffset,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*in L (unused)<br>MC[xfRetLinkOffset,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*in L (unused)<br>MC[LocalZeroOffset,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*in L (unused)<br>MC[xfGfiOffset,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*in G<br>MC[GlobalZeroOffset,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*in G (unused)<br><br>*StateVector format<br>MC[StkPOffset,10];<br>MC[DestOffset,11];<br>MC[SourceOffset,12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br><br>*SD indicies<br>MC[sStackError,2];<br>MC[sWakeupError,3];<br>MC[sXferTrap,4];<br>MC[sUnimplemented,5];<br>MC[sAllocListEmpty,6];<br>MC[sControlFault,7];<br>MC[sCsegSwappedOut,10];<br>MC[sPageFault,11];<br>MC[sWriteProtect,12];<br>MC[sUnbound,13];<br>MC[sZeroDivisor,14];<br>MC[sDivideCheck,15];<br>MC[sHardwareError,16];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br>MC[sProcessTrap,17];<br>MC[sBoundsFault,20];<br>MC[sPointerFault,21];<br>MC[sFloatingPoint,137];<br>MC[sWCBL,151];<br>MC[sICBL,152];<br>MC[sCedarTrap,156];<br><br>MC[FirstProcess,75];<br>MC[LastProcess,76];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br>MC[FirstStateVector,77];<br><br>MC[CurrentPSB,21];<br>MC[ReadyQ,22];<br>MC[CurrentState,23];<br>MC[ReadyQhi,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br><br>*Nova entry point constants<br>MC[IntStopPC,25];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br>MC[StopStopPC,26];<br>MC[MEStopPC,27];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br>MC[MXDStopPC,30];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br>MC[MREStopPC,31];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br>MC[MXWStopPC,32];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br>MC[NOTIFYStopPC,33];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br>MC[BCASTStopPC,34];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br>MC[REQUEUEStopPC,35];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*unused<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
