<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>ALTOMC.DM!1>Fault.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 12pt; text-align: left">
<span style="font: 12pt serif">:TITLE[Fault];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Fault handler.  1 June 1982 by Ed Fiala<br>* Edited October 2, 1982  5:19 PM van Melle<br>* Lisp conditional at MemFault fixed June 22, 1982  4:57 PM van Melle<br><br>%Problems:<br>1) PFetch4; NextInst will normally fault abort at MesaRefillLoc and will be<br>treated as a NextInst refill fault instead of ordinary reference; can<br>improve things by ensuring task 0 from PipeReg2 (almost in SALUF?).<br>2) Try to do ReadPipe only on MC12Err path, if that path not made longer.<br>3) Do something useful in the mi at MC12Err+2.<br>4) MP report of storage failures would be desirable.<br>5) If branch condition on first ReadPipe mi could be eliminated (2 above),<br>then could pick off MC1 crash in that mi by testing for FFault odd; then<br>test for CTask=0 in the bare Disp at MC12Err+2 and branch on ALU#0 in<br>the dispatch table to an mi that does RTMP&larr;.  This would save 2 cycles<br>on the slowest paths.<br><br>DELAY ON FAULTS until tasking MUST BE MINIMIZED to avoid data lates on io<br>devices.  Although present io devices eventually recover from data lates,<br>keyboard input is lost (primarily on Star keyboards--CSL keyboards are<br>rarely affected) and display jitter occurs; there are other potential<br>problems.<br><br>In computing time for an MC1 fault, allow ~6 cycles after the PFetch/PStore;<br>the mi after that is aborted until the fault starts; the abort lasts<br>~10 cycles, unaffected by suspended cycles while transport for previous<br>references takes place.  Then the code here beginning at "FaultOccurred"<br>is executed.  The assumption is made that only the emulator task can<br>legitimately have references that fault, but the fault may not occur until<br>another task is running.<br><br>In the event the emulator was running at the time of a fault, it is<br>restarted at a fault address and tasks after a delay of 51 to 69 cycles.<br>In this case, io task timing is worsened by ~61 to ~79 cycles minus the time<br>to the next normal emulator tasking point.  The next two emulator tasks<br>occur after 11 and 4 cycles, respectively, which somewhat mitigates the long<br>time to task.<br><br>If an io task was running, however, the emulator TPC is changed to a fault<br>address and the state of the io task is restored after ~83 to ~100 cycles;<br>in this case, time in the fault handler is totally additive to worst<br>case timing in the absence of a fault.<br><br>An even longer time in the fault handler (up to ~110 cycles) occurs when<br>an io task was running at the onset of the fault and doing a "Return" to<br>the emulator.  However, this only happens when no other io task was<br>requesting service at the onset of the fault, so it is not as bad as the<br>additive ~100 cycles.<br><br>Code here replaces that in Kernel or Initial performing the same function.<br>This code determines what to do based on the type of error, and bits in<br>FFault, which are:<br>  0: MC2 errors Return if 1, crash if 0.  The return option is used by<br>     Initialize.Mc during storage initialization when WithMidas=1 (i.e.,<br>     on debugging systems, not on release systems).  This bit is reserved<br>     for Initial&rsquo;s MemInit storage diagnostic on release systems.<br>  2: H4 parity errors ignored if 0, crash if 1<br>     (3 MB Ethernet generates them routinely)<br>  3: Midas is present (1), so "crash" means breakpoint, else put a code in MP<br>     and GoTo[.] until booted.<br> 15: MC1/StackOvf errors handled by notifying PFEntry in emulator (1), or by<br>     crashing (0); the Alto emulator crashes, the Mesa emulator uses a<br>     notify for these errors [On 1 June 1982, this bit wound up in the wrong<br>     state after LoadRAM.].<br>%<br><br>SetTask[17];<br><br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LoadPageExternal[0], GoToExternal[377], At[0];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Buffer refill trap<br><br>FaultOccurred:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; APCTask&APC, At[1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Must save APC first<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RXAPC &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (CTask&NCIA) xnor (170000C);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RXCTask &larr; T;<br>*It is necessary to ensure that StkP .ne. 17b here because, even though<br>*ResetErrors clears stack overflow, StkP .eq. 17b instantly regenerates it<br>*causing an endless loop back to location 1.  So set StkP to a value that<br>*will be used later.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; RCy[Page&Par&Boot,4];<br>*LoadPage is necessary because, after ResetErrors, the Page register will no<br>*longer be disabled by the error condition.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RXPPB &larr; T, LoadPage[FaultPage], GoTo[NotStkFault,H2Bit8&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; (SStkP&NStkP) xor (377C);<br><br>OnPage[FaultPage];<br><br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  RXSTK &larr; IP[RXCTask]C;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  StkP &larr; RXSTK, RXSTK &larr; T, NoRegILockOK;<br>*aluresult, saluf (both read complemented)<br>NotStkFault:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (ALUResult&NSALUF) xnor (0C);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RXALU &larr; T, ResetErrors;<br>*Test first for time critical MC1/2 error without any accompanying StkOvf,<br>*CSPE, or RMPE.  Can&rsquo;t change ALU branch conditions until after ResetErrors.<br>*The four bits tested here are the Parity register (Stack overflow, CS parity<br>*error, RM parity error, and Memory error.  Memory errors are time-critical,<br>*so test for them first.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (LdF[RXPPB,10,4]) - 1;<br>*Get pipe A (Timing for this mi = 8 cycles on MC12Err)<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ReadPipe[PipeReg], FreezeResult, GoTo[MC12Err,ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (RXPPB) and (140C), Skip[ALU&gt;=0];<br>*Assume Midas breakpoint--i.e., SetFault function executed.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; BrkPCrash, GoTo[CTaskCrash];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; RMCSCrash, GoTo[BadHWErr1,ALU#0];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Jump if CS or RM PE<br>*Have to do ResetMemErrs in case stack overflow occurred in conjunction with<br>*an MC1/MC2 error.<br>:UNLESS[LispMode]; *********************************<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  FFault, ResetMemErrs, GoTo[StackTrap,R Odd];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*StkOvf only<br>:ENDIF; ********************************************<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; StkCrash, GoTo[Crash];<br>*CS or RM parity error, possibly in combination with other errors.<br>BadHWErr1:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (LdF[RXPPB,10,4]) + T, GoTo[Crash];<br><br>CTaskCrash:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (LdF[RXCTask,0,4]) + T, GoTo[Crash];<br><br>*The computation here is CrashCode+PipeTask = CrashCode+(PipeTask&rsquo; xor 17b)<br>*= CrashCode+(17b-PipeTask&rsquo;) = (CrashCode+17b)-PipeTask&rsquo;.  The value in T<br>*when we get here is CrashCode+17b.<br>PipeTaskCrash:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (LdF[PipeReg2,10,4]) - T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (Zero) - T, GoTo[Crash];<br><br>%If Midas is not present, display the maintenance panel code in T and do<br>a GoTo[.] until booted.  Otherwise, do not modify the MP and transfer control<br>to the Midas Kernel.  Except on simple breakpoints, save the CrashCode and<br>memory error information in RM 100-107 (MP crash code must be .ls 400b  to<br>see it from Midas).<br>%<br>:IF[WithMidas]; *********************************<br>***NOTE: RM 352-353 will be smashed by PNIP.<br>Crash:</span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[FFault,3,1], Call[Crash1];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">GoTo[.];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Wait for boot...<br>Crash1:</span><span class="tab" val="67"></span><span style="font: 12pt serif">PipeReg5 &larr; (LSh[PipeReg5,10]) or T, GoTo[PNIP,ALU=0];<br>*Locate on page 17 with the Midas Kernel so that this code can be easily<br>*overwritten when Midas isn&rsquo;t present.  Reformat saved Pipe into RM 100-107<br>*for Midas.  Note that pipe info (other than crash code and Task number) is<br>*only interesting if CrashCode is 200d to 215d (an MC2 error).<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LoadPage[MidasPage];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[RXPPB,10,1];<br>OnPage[MidasPage];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RXPPB &larr; LCy[RXPPB,4], GoTo[.+3,ALU#0];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Unrotate RXPPB for Midas<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; (SStkP&NStkP) xor (377C);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  RXSTK &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[RXPPB,4,4];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RTMP &larr; Or[And[IP[MapEntry],360],And[Sub[IP[MapEntry],1],17]]C, GoTo[Crash2,ALU#0];<br>:IF[IFE[MidasPage,17,0,1]]; *********************<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  LoadPageExternal[17];<br>:ENDIF; *****************************************<br>**Unfixup RXCTask for Midas Kernel.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  RXCTask &larr; (RXCTask) xnor (170000C), GoToExternal[MidasBreakLoc];<br>Crash2:</span><span class="tab" val="67"></span><span style="font: 12pt serif">StkP &larr; RTMP;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LdF[PipeReg,11,7];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Map row address&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PipeReg1 &larr; (LSh[PipeReg1,7]) xnor T;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Map row&rsquo;&rsquo; u Map column&rsquo;&rsquo;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LdF[PipeReg1,2,16], Call[FltPsh];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MapEntry&larr;page no.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (LdF[PipeReg2,10,4]) xor T, Call[FltPsh]; *TaskNumber<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (LdF[PipeReg2,14,4]) xor T, Call[FltPsh]; *RefType<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; RHMask[PipeReg5], Call[FltPsh];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*CrashCode<br>*Card no. (0..7) into CardNumber; offset by 5 to get actual board<br>*number in card cage.  NOTE: 14b in Card implies that this part of<br>*the pipe is not filled by the reference. (X xor 7) + 5 = 14b - X.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; 14C;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (LdF[PipeReg5,4,3]) - T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (Zero) - T, Call[FltPsh];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*CardNumber<br>*Map Flags (LogSE, WP, Dirty, Ref) into MapFlags<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (LdF[PipeReg5,0,4]) xor T, Call[FltPsh];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LdF[PipeReg4,12,6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Main column address (6 bits)<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PipeReg3 &larr; (LSh[PipeReg3,6]) or T;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*x,x,Blk.1&rsquo;,,main row addr<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PipeReg5 &larr; LdF[PipeReg5,7,1];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LdF[PipeReg3,2,16];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PipeReg5 &larr; (LSh[PipeReg5,16]) or T;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*And Blk.0...<br>*This is the (15-bit) quadword number within a 128k card.<br>*Bits 1 and 2 give the block number.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (PipeReg5) xnor (100000C), Call[FltPsh];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*QuadAddr<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; RSh[PipeReg,10], Call[FltPsh];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Interesting syndrome into 107<br>:IF[IFE[MidasPage,17,0,1]]; *********************<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LoadPageExternal[17];<br>:ENDIF; *****************************************<br>**Unfixup RXCTask for Kernel.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RXCTask &larr; (RXCTask) xnor (170000C), GoToExternal[MidasFaultLoc];<br><br>FltPsh:</span><span class="tab" val="67"></span><span style="font: 12pt serif">UseCTask, Stack&+1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; 17C, Return;<br>:ELSE; ******************************************<br>Crash:</span><span class="tab" val="67"></span><span style="font: 12pt serif">Call[PNIP];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">GoTo[.];<br>:ENDIF; *****************************************<br><br>OnPage[FaultPage];<br><br>%<br>There are a number of bugs and non-features in the MC1/MC2 error reporting<br>hardware which account for the peculiar way things are done here; the<br>comments here are based upon my reading of the hardware drawings and might<br>be wrong:<br><br>1) ResetMemErrs resets the H4PE, MOB, MC1ErA, MC1ErB, MC2ErA, and MC2ErB<br>flipflops.  Also, the next reference reloads the MC1ErA and MC1ErB flipflops.<br>The next reference using the same pipe will reload the MC2ErA or MC2ErB<br>flipflop.  H4PE can only be reset by ResetMemErrs.<br><br>2) H4PE&rsquo;s do not set MC1ErA or MC1ErB, so it is impossible to report the<br>reference and task number for these with any certainty.  Hence, the MP code<br>uses +CTask rather than +PipeTask.<br><br>3) I am not sure whether or not MOB errors are indicated correctly in MC1ErA<br>and MC1ErB.  Hence, they report +CTask rather than +PipeTask in the MP.<br><br>4) MC2ErA and MC2ErB have pipe-specific clocks, so an error indication will<br>remain true until another reference uses the same pipe.  This means that the<br>reference after one causing an MC2 error won&rsquo;t disturb its error indication.<br><br>5) MC1ErA and MC1ErB have a common clock, and only one of these can be<br>indicated at a time.  The hardware is SUPPOSED to fault before another<br>reference starts, but if the preceding reference was a PFetch4 with error<br>correction which didn&rsquo;t fault, and if the transport for that reference<br>occurred between the faulting reference and the fault, then one more<br>instruction will be executed before the fault task executes at location 1.<br>This instruction could be another reference.  If an extraneous reference does<br>take place, the original MC1ErA/B indication would be replaced by the results<br>of the extraneous reference, possibly getting the MCNoneCrash MP code.<br><br>6) MC2 is never started if MC1 gets a fault, so it is impossible to have<br>both MC1ErX and MC2ErX indicated at one time.<br><br>Timing = 26 cycles from loc 1 to here.<br>%<br>MC12Err:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Dispatch[PipeReg,4,2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Dispatch on H4pe, MapBnd<br>***This Dispatch is only useful on the MC1/MC2 path.<br>*Dispatch on MC2ErA&rsquo;, MC2ErB&rsquo;, MC1ErA&rsquo;, and MC1ErB&rsquo; bits<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Dispatch[PipeReg,0,4], Disp[.+1];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Disp[MC2ErAB], DispTable[4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*None<br>*23rd? or 24th? bit of memory address = 1 causes MOB.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; MOBCrash, FFault, DblGoTo[MOBTrap,CTaskCrash,R Odd];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MOB<br>%Ignore improbably legit MOB&H4PE on IOStore4 to flush frequently occurring<br>fake MOB&H4PE by 3MB Ethernet input task.  Some 3MB Ethernet controllers cause<br>H4PE&rsquo;s on Input&rsquo;s and IOStore4&rsquo;s erroneously; XWTask keeps control in xiTask<br>so that the H4PE will be reported no later than the 1st mi of the next task<br>to run, so that LoadPage errors won&rsquo;t happen.  We could refine this check by<br>continuing from H4PE&rsquo;s only when xiTask is running, but this would require<br>one additional NOP in xiTask after IOStore4&rsquo;s or Input&rsquo;s, and it wouldn&rsquo;t<br>work on gateways with more than one Ethernet controller.<br>%<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[FFault,2,1], Skip;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*H4PE<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[FFault,2,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*H4PE&MOB<br>*Check &rsquo;ignore H4PE&rsquo; bit in FFault.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, Skip[ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; H4PECrash, GoTo[CTaskCrash];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LdF[RXCTask,4,4], GoTo[T17RestoreB];<br><br>MC2ErAB:<br>*</span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, GoTo[MC22Die], At[MC12,0];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2A/B & MC1A/B<br>*</span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, GoTo[MC22Die], At[MC12,1];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2A/B & MC1A<br>*</span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, GoTo[MC22Die], At[MC12,2];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2A/B & MC1B<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, GoTo[MC22Die], At[MC12,3];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2A/B<br>*</span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, FFault,<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">DblGoTo[MC2ErARet,MC2ErA,R&lt;0], At[MC12,4];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2A & MC1A/B<br>*</span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, FFault,<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">DblGoTo[MC2ErARet,MC2ErA,R&lt;0], At[MC12,5];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2A & MC1A<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, FFault,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">DblGoTo[MC2ErARet,MC2ErA,R&lt;0], At[MC12,6];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2A & MC1B<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, FFault,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">DblGoTo[MC2ErARet,MC2ErA,R&lt;0], At[MC12,7];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2A<br>*</span><span class="tab" val="67"></span><span style="font: 12pt serif">ReadPipe[PipeReg,,FFault], ResetMemErrs,<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">DblGoTo[MC2ErBRet,MC2ErB,R&lt;0], At[MC12,10];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2B & MC1A/B<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ReadPipe[PipeReg,,FFault], ResetMemErrs,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">DblGoTo[MC2ErBRet,MC2ErB,R&lt;0], At[MC12,11];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2B & MC1A<br>*</span><span class="tab" val="67"></span><span style="font: 12pt serif">ReadPipe[PipeReg,,FFault], ResetMemErrs,<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">DblGoTo[MC2ErBRet,MC2ErB,R&lt;0], At[MC12,12];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2B & MC1B<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ReadPipe[PipeReg,,FFault], ResetMemErrs,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">DblGoTo[MC2ErBRet,MC2ErB,R&lt;0], At[MC12,13];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC2B<br>*</span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, FFault,<br>*</span><span class="tab" val="67"></span><span style="font: 12pt serif">  DblGoTo[MC1Notify,MC1Die,R Odd], At[MC12,14];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC1A/B<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ResetMemErrs, FFault,<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  DblGoTo[MC1Notify,MC1Die,R Odd], At[MC12,15];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC1A<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ReadPipe[PipeReg,,FFault], ResetMemErrs,<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  DblGoTo[MC1Notify,MC1Die,R Odd], At[MC12,16];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*MC1B<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; MCNoneCrash, GoTo[Crash], At[MC12,17];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*None<br><br>MC22Die:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; MC22Crash, GoTo[Crash];<br>MC1Die:</span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; MC1Crash, GoTo[PipeTaskCrash];<br><br>%Set FaultParm to indicate cause of trap:<br>  -1 =&gt; Memory Out of Bounds<br>  negative =&gt; write protect<br>  positive =&gt; page fault<br>Reference type put in NSALUF for fault handling later.<br>NOTE: must not attempt to leave the fault results in PipeRegx because<br>another fault (H4PE or LogSE) might clobber PipeRegx when an io task runs<br>prior to servicing this fault.<br>%<br><br>MC1Notify:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (PipeReg) and (177C);</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Low 7 bits of VPage<br>*(High 7 bits of VPage&rsquo; or low 7 bits)&rsquo;; bits 0 and 1 wind up both 1.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PipeReg1 &larr; T &larr; (LSh[PipeReg1,7]) xnor T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[PipeReg5,12,1];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Test dirty&rsquo;: 0=&gt; page fault<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">FaultParm &larr; T, Skip[ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  FaultParm &larr; LdF[FaultParm,2,16], Skip;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*page fault<br>*Bits 0 and 1 in FaultParm are both 1 after the xnor and we want them to<br>*be 2 so that VPage = 37777b won&rsquo;t be confused with an MOB error.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  FaultParm &larr; (FaultParm) and not (40000C);</span><span class="tab" val="67"></span><span style="font: 12pt serif">*write protect fault<br>MFault:</span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[RXCTask,0,4];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (PipeReg2) or not (17C), DblGoTo[TestTA,TestTB,ALU#0];<br><br>MOBTrap:</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Set trap parameter for MOB<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">FaultParm &larr; (Zero) - 1, GoTo[MFault];</span><span class="tab" val="67"></span><span style="font: 12pt serif"><br><br>:UNLESS[LispMode]; *********************************<br>StackTrap:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[RXCTask,0,4];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; Xor[StkCrash!,377]C, DblGoTo[TestTA,TestTB,ALU#0];<br>:ENDIF; ********************************************<br><br>%Notify emulator at EmNotifyA if emulator was interrupted, else at EmNotifyB.<br>SALUF is used later at CheckStackTrap to distinguish Stack errors from<br>others and in other fault handling to give RefType.<br><br>Time from location 1 through this non-tasking return:<br> 45 or 46 cycles on MOB;<br> 51 or 52 cycles on Stack overflow or underflow;<br> 55 to 63 cycles on page fault;<br> 56 to 64 cycles on write protect fault.<br>%<br>TestTB:</span><span class="tab" val="67"></span><span style="font: 12pt serif">RTMP &larr; LoA[EmuNotifyLoc], Skip; <br>TestTA:</span><span class="tab" val="67"></span><span style="font: 12pt serif">RTMP &larr; LoA[NonEmuNotifyLoc];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">APCTask&APC &larr; RTMP;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">SALUF &larr; T, Return;<br><br>:IF[WithMidas]; *********************************<br>MC2ErARet:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Return;<br>MC2ErBRet:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Return;<br><br>MC2ErA:</span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LHMask[MemSyndrome], Skip;<br>MC2ErB:</span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LSh[MemSyndrome,10];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PipeReg &larr; (RHMask[PipeReg]) or T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; MC2Crash, GoTo[PipeTaskCrash];<br>:ELSE; ******************************************<br>MC2ErARet:<br>MC2ErBRet:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Return;<br>MC2ErA:<br>MC2ErB:</span><span class="tab" val="67"></span><span style="font: 12pt serif">GoTo[T17RestoreA];<br>:ENDIF; *****************************************<br><br>%T17CheckAPC resumes an interrupted non-emulator task after the emulator&rsquo;s<br>TPC has been changed; T17RestoreA and T17RestoreB are the entries used when<br>the emulator&rsquo;s TPC has not been changed.<br><br>Because APC is used not only for tasking and returning but also for<br>APCTask&APC&larr; and for dispatches, APC must sometimes be restored to the value<br>saved at the onset of the trap--otherwise, the mi after a Dispatch or<br>APCTask&APC&larr; would continue incorrectly.  However, if the mi being continued<br>contains a Return, and if APCTask=0, then control will go to the restored APC<br>rather than the emulator&rsquo;s new TPC.  Consequently, if APCTask=0, the code<br>below checks the mi at the continue address for a Return; if so, APC is<br>changed to the emulator&rsquo;s new TPC; if not, APC is restored to its trap value.<br><br>Delay from location 1 through the Restore below has been:<br> 44 cycles on H4PE;<br> 72 to 82 cycles on Stack overflow or underflow;<br> 73 to 82 cycles on MOB;<br> 83 to 99 cycles on page fault;<br> 84 to 100 cycles on write protect fault.<br>%<br>T17CheckAPC:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[RXAPC,0,4], At[ContNonEmuLoc]; *test saved APCTask<br>*Only the two low-order bits of T are significant for ReadCS.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; 5C, GoTo[T17RestoreA,ALU#0];<br>*Saved APC is for emulator, must read aborted mi.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">APCTask&APC &larr; RXCTask;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ReadCS;<br>*This mi need not be at an even mi because task 17b&rsquo;s TPC is unimportant.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (LdF[CSData,6,3]) - T - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*(JC field) - 6; Return = 6<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LdF[RXCTask,4,4], GoTo[T17RestoreB,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RXAPC &larr; LoA[NonEmuPFLoc], GoTo[T17RestoreB]; *aborted mi does Return.<br><br>%Restoring control to a task, as done here, is safe against every type of<br>interruption except between LoadPage and the subsequent mi or between a<br>reference and the next mi using the bypass kludge.  However, the error<br>check here will crash distinctively for a LoadPage problem, and since<br>a following reference is aborted if a page or write protect fault is about<br>to happen for a PREVIOUS reference, intervention between a reference and the<br>bypass kludge should only be possible in one of the following three<br>situations:<br>  1) A Preceding PFetch4 experiences error correction with all 8 cycles of<br>suspension for its transport occurring between a reference and the next mi<br>using the bypass kludge, and that reference itself page faults; but page<br>faults by io tasks aren&rsquo;t allowed, so this won&rsquo;t happen.<br>  2) Correctable error logging occurs between a reference and the bypass<br>kludge (we don&rsquo;t ever use LogSE).<br>  3) An H4PE intervenes between a reference and the bypass kludge; this is<br>illegal except for the 3mb Ethernet where enough Nop&rsquo;s after each Input and<br>IOStore4 ensure that any H4PE happens safely.<br>%<br>T17RestoreA:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LdF[RXCTask,4,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Compare page bits<br>T17RestoreB:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (LdF[RXPPB,4,4]) xor T;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*with saved page register<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; RXALU, Skip[ALU=0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*result register<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; LPCrash, GoTo[CTaskCrash];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*LoadPage error<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">APCTask&APC &larr; RXCTask;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Return, Restore, A &larr; RXAPC, LU &larr; T, NoRegILockOK; *back to faulted Task<br><br><br>SetTask[0];<br><br>NotifyBack:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf1 &larr; (xBuf1) or (HiA[ContNonEmuLoc,17]);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">APCTask&APC &larr; xBuf1, xBuf1 &larr; T, NoRegILockOK;<br>*GoTo[PFExit] by MesaRefill (MesaJ.Mc) and by PNIP (Initialize.Mc).<br>PFExit:</span><span class="tab" val="67"></span><span style="font: 12pt serif">Return;<br><br>EmNotifyB:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">UseCTask, xBuf &larr; T, At[NonEmuNotifyLoc];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; APCTask&APC;<br>*Prepare to notify back to Task 17, location T17CheckAPC<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf1 &larr; LoA[ContNonEmuLoc], Call[NotifyBack];<br>*PF handling starts here if non-emulator was interrupted.<br>*If page fault timing is not good enough to prevent UTVFC data lates in the<br>*worst case, tasking quickly here will help avoid data lates 2/3 of the time,<br>*so the next two calls are brief (11 cycles and 4 cycles).<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; StkCrash, Call[CheckStackTrap], At[NonEmuPFLoc];<br>*xBuf2 &larr; Saved CIA and restore StkP.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (Stack) and not (170000C), Call[StkPExch];<br>*Cannot be buffer refill trap or location 0 abort<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">GoTo[CheckMemStat];<br><br>%SALUF holds either [PipeReg2 u 360b] (on a page, write protect, or MOB fault)<br>or StkCrash&rsquo; (stack overflow (StkP=17b) or underflow (StkP=0)).  NSALUF then<br>reads either RefType or StkCrash.  First check for a stack error; if not,<br>save StkP in xBuf2 and point StkP at task 17&rsquo;s RXCTask register; the caller<br>will then save CIA of the aborted mi and restore StkP.  This is done in two<br>short subroutines rather than one longer one so io tasks which may have<br>fallen behind during the long page fault service will have a better<br>opportunity to catch up. <br>%<br>:IF[LispMode]; *************************************<br>CheckStackTrap:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf2 &larr; IP[RXCTask]C;<br>:ELSE; *********************************************<br>CheckStackTrap:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (NSALUF) xor T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf2 &larr; IP[RXCTask]C, GoTo[StackErrorz,ALU=0];<br>:ENDIF; ********************************************<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (SStkP&NStkP) xor (377C);<br>StkPExch:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">StkP &larr; xBuf2, xBuf2 &larr; T, NoRegILockOK, Return;<br><br>:UNLESS[LispMode]; *********************************<br>*We have a stack error.  Cause the trap immediately. Restore StkP to<br>*the value in SStkP saved at the beginning of the opcode.<br>***Let the PC fall where it may.<br>StackErrorz:</span><span class="tab" val="67"></span><span style="font: 12pt serif">*test SStkP for MaxStack+1 or more<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (SStkP&NStkP) - (LShift[Add[MaxStack!,1],10]C);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; SStkP, Skip[Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; MaxStack;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf2 &larr; T, LoadPage[opPage3];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">StkP &larr; xBuf2;<br>OnPage[opPage3];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; sStackError, GoTo[kfcr];<br>:ENDIF; ********************************************<br><br>EmNotifyA:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">UseCTask, xBuf &larr; T, At[EmuNotifyLoc];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*xBuf &larr; emulator&rsquo;s T<br>%FINALLY, task after the following delays:<br>  51 or 52 cycles on emulator MOB;<br>  57 or 58 cycles on stack overflow/underflow;<br>  61 to 68 cycles on page fault;<br>  62 to 69 cycles on write protect fault.<br>%<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; APCTask&APC, Task;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*xBuf1 &larr; emulator&rsquo;s TPC and Task<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf1 &larr; T;<br>*PF handling starts here if the emulator was interrupted.  Note that if the<br>*emulator was NOT interrupted, then the fault cannot have come from buffer<br>*refill.  Since control entered here, the emulator&rsquo;s PC is in RXCTask.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; StkCrash, Call[CheckStackTrap];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (Stack) and not (170000C), Call[StkPExch];<br>%At this point we have:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf</span><span class="tab" val="67"></span><span style="font: 12pt serif">emulator&rsquo;s T at the time of the fault;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf1</span><span class="tab" val="67"></span><span style="font: 12pt serif">emulator&rsquo;s TPC;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf2</span><span class="tab" val="67"></span><span style="font: 12pt serif">CIA of the aborted mi.<br>The major problem with faults is to determine the PC to store in the frame,<br>and whether to continue the opcode, or cause the trap immediately.<br>The cases are: <br><br>1) The fault was detected at location 0, the 1st mi of the buffer refill<br>trap.  In this case, buffer refill was just starting when some previous<br>reference faulted.  Treat this as in case 7 below.<br><br>2) A PFetch4 fault occurred on page 0 and the emulator&rsquo;s TPC points at the 1st<br>mi of a bytecode (TPC = 01xxxxxxxx01).  It is assumed that the fault is due to<br>a NextData/NextInst buffer refill; SStkP and PCX do not yet reflect advance<br>from the previous bytecode, so the trap is started with PC = 2*PCB - 1<br>(NextData/NextInst was accessing an operand from location 0 of the buffer, so<br>the opcode was byte 7 of the previous buffer, but PCB &larr; (PCB) + (4C) occurred<br>before the fault) and with the current value of StkP rather than SStkP.<br><br>3) A PFetch4 fault occurred on page 0 and the emulator&rsquo;s TPC points elsewhere<br>than as in case 2.  In this case, it is assumed that the fault is due to a<br>NextData or NextInst buffer refill which are differentiated by the low bit<br>of F1 in the mi pointed at by the emulator&rsquo;s TPC.  If the fault is due to a<br>NextData, nothing special is done, but for a NextInst, IBuf to IBuf3 are<br>set to -1, PCF to 0, and control is sent to the NextInst so other work done<br>by the mi containing the NextInst and the mi after that can be completed<br>before the trap.  Control then goes to opcode 377, which will cause the<br>trap with PC = 2*PCB + PCX - 1.<br><br>4) A PFetch4 fault occurred on page 6.  This is a jump opcode buffer refill<br>handled as in case 3 without zeroing PCF.<br><br>5) The fault was due to an Xfer buffer refill (MemStat[13:15] =<br>XferFixup).  This is handled just like a jump (case 4).<br><br>6) The fault occured during the early phases of Xfer.  We want to back<br>out and redo the opcode, but CODE may have changed and we need it<br>to compute the PC to save.  Call Loadc to reload from the current LOCAL.<br><br>7) If none of these situations hold, the PC is (PCB*2) + q, where q = if<br>(PCF&gt;=PCX) then PCX-1 else PCX-9 (if PCF&lt;PCX, then the buffer was<br>refilled between the NextInst and the fault, and PCB has been advanced<br>by 8 bytes).  In the normal case, the trap is started using this PC, and<br>it is not necessary to unwind the instruction.  If any special unwinding<br>is necessary,it is indicated by a value in MemStat[13:15].<br>%<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; 6C;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; LdF[xBuf2,4,4];<br>*Go if emulator page 0 fault; test for RefType=6 (PFetch4)<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (NSALUF) xor T, GoTo[CameFromPage0,ALU=0];<br>*GoTo CheckMemStat if not a PFetch4.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (LdF[xBuf2,4,4]) xor T, GoTo[CheckMemStat,ALU#0];<br>*The operation is a jump buffer refill if it is a PFetch4 from page 6.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">DblGoTo[CMSt1,ResumeBytecode,ALU#0];<br><br><br>CameFromPage0:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; xBuf2, GoTo[CMSt2,ALU#0];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*test for aborted CIA = 0<br>*The operation is a PFetch4 from page 0--ASSUME it is buffer refill.<br>*Test for emulator TPC = 01xxxxxxxx01; put the high 2 and low 2 bits of TPC<br>*in the right-half with task 0 in the middle.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf1 &larr; LCy[xBuf1,6], GoTo[CMSt3,ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; 101C;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (RHMask[xBuf1]) xor T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; RCy[xBuf1,6], GoTo[CIB1st,ALU=0];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*T &larr; original xBuf1<br>*Fault was NOT from 1st mi of bytecode; find out whether emulator&rsquo;s TPC<br>*points at a NextInst or NextData.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xBuf2 &larr; T;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*xBuf2 &larr; emulator&rsquo;s TPC instead of aborted CIA<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; RZero;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Does TPC point to a NextInst?<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">APCTask&APC &larr; xBuf2;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">ReadCS;<br>*Branch on probable NextData; fall through on probable NextInst.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">CSData, GoTo[CMSt0,R Odd];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PCF &larr; RZero; </span><span class="tab" val="67"></span><span style="font: 12pt serif">*PCF &larr; 0<br>%Jump to ResumeByteCode on a PFetch4 from page 6 (Mesa jumps all on page 6).<br>Continue the jump after filling IBuf with -1, and eventually get to<br>opcode 377, which will start the trap.<br>%<br>ResumeBytecode:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; xBuf;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Restore emulator&rsquo;s T register<br><br>%Jump to CIB1 on XferFixup (trap at the end of Xfer after PFetch4 to refill<br>IBuf has been launched).<br>***Try a single PCF[IBuf]&larr; here when everything seems solid.<br>%<br>CIB1:</span><span class="tab" val="67"></span><span style="font: 12pt serif">IBuf &larr; (Zero) - 1, Task;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">IBuf1 &larr; (Zero) - 1;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">IBuf2 &larr; (Zero) - 1;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">APCTask&APC &larr; xBuf2;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Return to the NextInst or whatever<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">IBuf3 &larr; (Zero) - 1, Return;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Force bytecode 377<br><br><br>:IF[LispMode]; *************************************<br></span><span style="font: 10pt serif"><br>*TPC = 01xxxxxxxx01, fault was from refill for NextData or NextInst in 1st mi<br>*of bytecode<br>CIB1st:</span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadPageExternal[7];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallExternal[3761];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Execute opcode 374 (return);<br><br>CMSt3:</span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[MemFault];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*PFetch4 from location 0<br>CMSt2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[MemFault];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span style="font: 12pt serif">Not a PFetch4, fault on pg 0</span><span style="font: 10pt serif"><br>CMSt1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[MemFault];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*PFetch4 not on pp 0 or 6</span><span style="font: 10pt serif"><br>CMSt0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[MemFault];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*NextData fault, not 1st mi of bytecode<br>CheckMemStat:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[MemFault];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Non-emu fault or non-page 0 or 6 fault<br><br>FPCOx:</span><span class="tab" val="67"></span><span style="font: 10pt serif">GoTo[MemFault];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Regular fault on page 0<br><br>:IFE[Add[IP[PipeReg4],3], IP[FaultParm],, ER[PipeReg4.and.FaultParm.changed]];<br><br>MemFault:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; SStkP;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Get saved StkP<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf2 &larr; IP[FaultParm]C, Call[StkPExch];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-3;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T &larr; FaultParm; Stkp points at PipeReg4<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC0 &larr; T, GoTo[lspMapFaultPunt];<br><br></span><span style="font: 12pt serif">:ELSE; *********************************************<br>*TPC = 01xxxxxxxx01, fault was from</span><span style="font: 10pt serif"> refill for NextData or NextInst in</span><span style="font: 12pt serif"> 1st mi<br>*of bytecode.<br>CIB1st:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PCB &larr; (PCB) - (4C);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PCF &larr; AllOnes;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*PCF &larr; 7<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (SStkP&NStkP) xor (377C), GoTo[SMTrpx];<br><br>CMSt3:</span><span class="tab" val="67"></span><span style="font: 12pt serif">Dispatch[MemStat,15,3], GoTo[CMStD];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*PFetch4 fault at location 0.<br>CMSt2:</span><span class="tab" val="67"></span><span style="font: 12pt serif">Dispatch[MemStat,15,3], GoTo[CMStD];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Not a PFetch4, fault on pg 0.<br>CMSt1:</span><span class="tab" val="67"></span><span style="font: 12pt serif">Dispatch[MemStat,15,3], GoTo[CMStD];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*PFetch4 not on pp 0 or 6.<br>CMSt0:</span><span class="tab" val="67"></span><span style="font: 12pt serif">Dispatch[MemStat,15,3], GoTo[CMStD];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*NextData refill fault, not<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*1st mi of bytecode.<br>CheckMemStat:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Dispatch[MemStat,15,3];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Non-emu fault or not a PFetch4, fault on pg#0<br>CMStD:</span><span class="tab" val="67"></span><span style="font: 12pt serif">Disp[FixPCOnly];<br><br><br></span><span style="font: 10pt serif">*The fault was due to an Xfer buffer refill (MemStat[13:15] = XferFixup).<br>*Handle just like a jump.<br></span><span style="font: 12pt serif">FixXfer:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; xBuf, GoTo[CIB1], At[FixDisp,XferFixup!];<br><br></span><span style="font: 10pt serif">*The fault occured during the early phases of Xfer.  We want to back out and<br>*redo the bytecode, but CODE may have changed and we need it to compute the PC<br>*to save.  Fetch G and the overhead, and call LoadC to reload from the<br>*current LOCAL.<br></span><span style="font: 12pt serif">FixEarlyXfer:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[LOCAL,GLOBAL,0]</span><span style="font: 12pt serif">, At[FixDisp,EarlyXfer!];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[FP1Ret];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; GLOBAL, LoadPage[xfPage1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[MDS,IBuf], Call[LoadC];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Fetch the global frame overhead<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xfGFIWord &larr; T, GoTo[FixPCOnly];</span><span style="font: 12pt serif"><br><br><br>*Prepare for fixup relative to SStkP.<br>FixBLTL:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; SStkP, At[FixDisp,BltLFixup!];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RTemp &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RTemp &larr; (RTemp) - (4C), Call[FSetStkP];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; xBuf, Call[BumpGlorp];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*source + T<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Stack&+1, Call[FBumpStk];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*count + 1<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Stack&+1, Call[BumpGlorp];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*dest + T<br></span><span style="font: 10pt serif">FPCOz:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCXReg) - 1, GoTo[FPCOx];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*one byte inst cannot have refilled buffer<br></span><span style="font: 12pt serif"><br>BumpGlorp:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Stack &larr; (Stack) + T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Stack&+1, Skip[Carry&rsquo;];<br>FBumpStk:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  Stack &larr; (Stack) + 1, Return;<br>FP1Ret:</span><span class="tab" val="67"></span><span style="font: 12pt serif">Return;<br><br>FSetStkP:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">StkP &larr; RTemp, RTemp &larr; T, NoRegILockOK, Return;<br><br><br>*Prepare for fixup relative to SStkP.<br>FixBlt:</span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (SStkP) - 1, At[FixDisp,BltFixup!];<br>*Stack points at operation<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RTemp &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">StkP &larr; RTemp;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Point StkP at Count<br>*Operation in low 4 bits of NSALUF was PFetch1 (type 4) or PStore1 (type 10b)<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; LdF[ALUResult&NSALUF,14,1];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*1=&gt; store, 0=&gt; fetch<br>*Count+1; if fetch, done with fixup.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Stack &larr; (Stack) + 1, GoTo[FPCOz,ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Stack&-1, Call[DecGlorp];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Source - 1<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Stack&+2, Call[DecGlorp];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Dest - 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCXReg) - 1, GoTo[FPCOx]</span><span style="font: 12pt serif">;<br><br>DecGlorp:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Stack &larr; (Stack) - 1, Return;<br><br>FixPCOnly:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCXReg) - 1</span><span style="font: 12pt serif">, At[FixDisp,Normal!]; *normal PC fixup<br>FPCOx:</span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (PCFreg) - T, Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; 7C, GoTo[.-1];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*PCX was 0; opcode started in prev. quadword<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*If PCF .eq. 7 then we already backed up PCB,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*so don&rsquo;t subtract 4 from PCB again.<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">RTemp &larr; T, Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  PCB &larr; (PCB) - (4C);</span><span class="tab" val="67"></span><span style="font: 12pt serif">*PCX large, PCF small = &gt; prev. quadword<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PCF &larr; RTemp;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*PCF is always PCX-1, only PCB is in doubt<br><br>%FaultParm has been set up by the Trap handler:<br>   -1 =&gt; Map Out of Bounds<br>   negative =&gt; write protect, page in low 14 bits<br>   positive =&gt; page fault, page in low 14 bits<br>Here PCB,PCF is correct pc to save for trap.  It will be done through KFCB.<br>%<br>StartMemTrap:<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; SStkP;<br>SMTrpx:</span><span class="tab" val="67"></span><span style="font: 12pt serif">RTemp &larr; IP[FaultParm]C, Call[FSetStkP];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (Stack) and not (140000C);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (Stack) + 1;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">xfOTPReg &larr; T, Skip[ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; sWriteProtect, Skip;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Write protect fault<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; sPageFault;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Page fault or MOB<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LoadPage[opPage3];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">StkP &larr; RTemp, GoToP[kfcr];<br>:ENDIF; ********************************************<br><br>:END[Fault];</span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
