<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>LISPDMC.DM!1>LFLOAT.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">:Title[LFloat];<br>*<br>* Edit history<br>* March 5, 1984  5:22 PM, JonL, opFGREATERP was not adjusting TSP enough<br>* January 12, 1984  3:54 AM, JonL, passed NARGS of 2 to TL.CREATECELL <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">in .storefloat<br>* January 4, 1984  10:40 PM, JonL, .storefloat tails into TL.CREATECELL,<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">and exits from FP code reset the HardWare stack to empty.<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Fleshed-out opFGREATERP.  floatfail becomes CallUFN<br>* November 29, 1983  2:14 PM, JonL<br>*  - - - , Masinter, Taft<br><br>*-----------------------------------------------------------<br>   InsSet[LispInsSet, 1];<br><br>:if[NOFLOATING];<br>ufnOPs[350];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* FPLUS<br>ufnOPs[351];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* FDIFFERENCE<br>ufnOPs[352];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* FTIMES<br>ufnOPs[353];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* FQUOTIENT<br>ufnOPs[362];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* FGREATERP<br><br>:else;<br><br>* Local R-register usage:<br>SetRMRegion[BBRegs];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Overlay BitBlt registers<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[ExpSign1];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Exponent and sign of argument 1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[Frac1H];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Fraction of argument 1 (high part)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[Frac1L];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* (low part)<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[ExpSign2];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Argument 2 ...<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[Frac2H];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[Frac2L];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[FTemp0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Temporaries<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[FTemp1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[FTemp2];<br><br><br>TOPLEVEL;<br>KnowRBase[LTEMP0];<br><br><br>regOP1[351, StackM2BR, opFDIFFERENCE, noNData];<br>*-----------------------------------------------------------<br>opFDIFFERENCE:<br>*-----------------------------------------------------------<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Just flip sign of 2nd arg and join fplus code<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br>KnowRBase[FTemp0];    <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign2&larr; (ExpSign2) + 1, Branch[FAddZeroR]; * one arg = 0<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign2&larr; (ExpSign2) + 1, Branch[FAddNonZero];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * both non-0<br><br>KnowRBase[LTEMP0];<br>regOP1[350, StackM2BR, opFPLUS2, noNData];<br>*-----------------------------------------------------------<br>opFPLUS2:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br>KnowRBase[FTemp0];<br>FAddZeroR:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * one arg = 0<br>    pd&larr; (Stack&+2) + (Stack&+2), Branch[FAddZero];<br><br>%<br>Difference between exponents is the amount of unnormalization required. The low 7 bits of ExpSign1 contain either 4 or 5, whereas the low 7 bits of ExpSign2 contain 0, 1, or 2.  Thus subtracting ExpSign2 from ExpSign1 cannot cause a carry out of the low 7 bits. Furthermore, the low bit gets the xor of the two signs, useful later when determining whether to add or subtract the fractions.<br>%<br><br>FAddNonZero:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ExpSign1;<br>FAddNZ2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign2&larr; T&larr; T - (Q&larr; ExpSign2);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp1&larr; A0, Q RSH 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + T, DblBranch[UnNorm1, UnNorm2, Carry&rsquo;];<br><br>* Un-normalize operand 1.  T[0:7] has negative of right-shift count.<br><br>UnNorm1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (B&larr; Q) LSH 1, Branch[.+2, R even]; * Result exponent is Exp2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)+1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* But preserve Sign1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T+(LShift[20, 10]C);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T+(LShift[20, 10]C), Branch[UnNorm1le20, Carry];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T+(LShift[20, 10]C), Branch[UnNorm1le40, Carry];<br><br>* Exponents differ by more than 40.<br>* Just zero operand 1, but be sure to set the sticky bit.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; 1C;<br>ZeroFrac1H:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; A0, Branch[UnNormDone];<br><br><br>* Exponent difference IN [1..20].  Let n = the difference.<br>* T[0:7] now has 40 - n, i.e., IN [20..37], so SHA=R, SHB=T.<br>* This is correct shift control for LCY[R, T, 20-n] = RCY[T, R, n]<br>UnNorm1le20:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac1L, ShC&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; ShiftNoMask[FTemp1];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PD&larr; RCY[Frac1L, 0, [1..20]]<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac1H, FreezeBC;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; ShiftNoMask[Frac1L],</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Frac1L&larr; RCY[Frac1H, Frac1L, [1..20]]<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, ALU=0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Test bits shifted out of Frac1L<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L) OR (1C);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Nonzero bits lost, set sticky bit<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, Q&larr; Frac2L;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; ShiftNoMask[Frac1H],</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Frac1H&larr; RCY[0, Frac1H, [1..20]]<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[UnNormDone1];<br><br>* Exponent difference IN [21..40].  Let n = the difference.<br>* T[0:7] now has 60 - n, i.e., IN [20..37], so SHA=R, SHB=T.<br>* This is correct shift control for LCY[R, T, 40-n] = RCY[T, R, n-20]<br>UnNorm1le40:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac1H, ShC&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ShiftNoMask[FTemp1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; RCY[Frac1H, 0, [1..20]]<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; T OR (Frac1L);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Bits lost from Frac1H and Frac1L<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, FreezeBC;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; ShiftNoMask[Frac1H],</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Frac1L&larr; RCY[0, Frac1H, [1..20]]<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[ZeroFrac1H, ALU=0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L) OR (1C),</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Nonzero bits lost, set sticky bit<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[ZeroFrac1H];<br><br>* Un-normalize operand 2.  T[0:7] has right-shift count, and T[8:15] is IN [0..12].<br>UnNorm2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (12S)-T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Negate count; ensure no borrow by ALU[8:15]<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T+(LShift[20, 10]C), Branch[UnNormDone, Carry]; * Branch if exponents equal<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T+(LShift[20, 10]C), Branch[UnNorm2le20, Carry];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T+(LShift[20, 10]C), Branch[UnNorm2le40, Carry];<br><br>* Exponents differ by more than 40.<br>* Just zero operand 2, but be sure to set the sticky bit.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; 1C, Branch[ZeroFrac2H];<br>UnNorm2gr40:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; 1C;<br>ZeroFrac2H:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H&larr; A0, Branch[UnNormDone];<br><br>* Exponent difference in [1..20].  Let n = the difference.<br>* T[0:7] now has 40 - n, i.e., in [20..37], so SHA=R, SHB=T.<br>* This is correct shift control for LCY[R, T, 20-n] = RCY[T, R, n]<br>UnNorm2le20:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac2L, ShC&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; ShiftNoMask[FTemp1];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PD&larr; RCY[Frac2L, 0, [1..20]]<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac2H, FreezeBC;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; ShiftNoMask[Frac2L],</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Frac2L&larr; RCY[Frac2H, Frac2L, [1..20]]<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, ALU=0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Test bits shifted out of Frac2L<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; (Frac2L) OR (1C);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Nonzero bits lost, set sticky bit<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, Q&larr; Frac2L;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac2H&larr; ShiftNoMask[Frac2H],</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Frac2H&larr; RCY[0, Frac2H, [1..20]]<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[UnNormDone2];<br><br>* Exponent difference IN [21..40].  Let n = the difference.<br>* T[0:7] now has 60 - n, i.e., IN [20..37], so SHA=R, SHB=T.<br>* This is correct shift control for LCY[R, T, 40-n] = RCY[T, R, n-20]<br>UnNorm2le40:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac2H, ShC&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ShiftNoMask[FTemp1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; RCY[Frac2H, 0, [1..20]]<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; T OR (Frac2L);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Bits lost from Frac2H and Frac2L<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, FreezeBC;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; ShiftNoMask[Frac2H],</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Frac1L&larr; RCY[0, Frac1H, [1..20]]<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[ZeroFrac2H, ALU=0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; (Frac2L) OR (1C),</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Nonzero bits lost, set sticky bit<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[ZeroFrac2H];<br><br>* Now decide whether fractions are to be added or subtracted.<br>UnNormDone:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q&larr; Frac2L;<br>UnNormDone1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac2H;<br>UnNormDone2:<br>* </span><span class="tab" val="24"></span><span style="font: 10pt monospace">Subtract if signs differ<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign2, DblBranch[SubFractions, AddFractions, R odd];<br>* Signs equal, add fractions.  T = Frac2H, Q = Frac2L.<br>AddFractions:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L)+Q;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; T&larr; (Frac1H)+T, XorSavedCarry;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; (Frac1L) AND (377C), Branch[FRePackNZ1, Carry&rsquo;];<br><br><br>* If carry out of high result, must normalize right 1 position.<br>* Need not restore leading "1", since rounding cannot cause a carry into this<br>* position, and the leading bit is otherwise ignored during repacking.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; (Frac1H) RSH 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; RCY[T, Frac1L, 1], Branch[.+2, R even];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L) OR (1C);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Preserve sticky bit<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)+(LShift[1, 7]C), Branch[FRePackNonzero];<br><br>* Signs differ, subtract fractions.  T = Frac2H, Q = Frac2L.<br>SubFractions:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L)-Q;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Frac1H)-T-1, XorSavedCarry;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; A0, FreezeBC, Branch[Normalize, Carry];<br><br>* If carry, Frac1 was &gt;= Frac2, so result sign is Sign1.<br>* If no carry, sign of the result changed.  Must negate fraction and<br>* complement sign to restore sign-magnitude representation.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)+1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (0S)-(Frac1L);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Frac1H)-T-1, XorSavedCarry, Branch[Normalize];<br><br><br>* Add/Subtract with zeroes:<br>* One or both of the operands is zero.  ALU = (high word of arg1) LSH 1.  This is<br>* zero iff arg1 is zero (note that we don&rsquo;t need to worry about denormalized numbers,<br>* since they have been filtered out already).<br>* StkP has been advanced to point to high word of arg2.<br>FAddZero:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Stack&-1)+(Q&larr; Stack&-1),</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; (high word of arg2) LSH 1<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[FAddArg2Zero, ALU#0]; * arg1#0 =&gt; arg2=0<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Cnt&larr; Stack&-1,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Cnt&larr; low word of arg2<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[FAddArg1Zero, ALU#0]; * arg2#0 =&gt; arg1=0<br><br>* Both args are zero: result is -0 if both args negative, else +0.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&larr; (Stack) AND Q, branch[.StoreFloat];<br><br>* Arg 1 is zero and arg 2 nonzero: result is arg 2.<br>* Note: must re-pack sign explicitly, since FSub might have flipped it.<br>FAddArg1Zero:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; RCY[ExpSign2, T, 1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Insert Sign2 into high result<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&-1&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&+1&larr; Cnt, branch[.StoreFloat];<br><br>* Arg 2 is zero and arg 1 nonzero: result is arg 1.<br>FAddArg2Zero:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP-1, branch[.StoreFloat];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Result already on stack<br><br><br>regOP1[352, StackM2BR, opFTIMES2, noNData];<br>KnowRBase[LTEMP0];<br>*-----------------------------------------------------------<br>opFTIMES2:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br>KnowRBase[FTemp0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ExpSign2, Branch[MulArgZero]; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* one arg = 0<br><br>* XOR signs and add exponents.  Subtract 200 from exponent to correct<br>*  for doubling bias, and add 1 to correct for 1-bit right shift of<br>*  binary point during multiply (binary point of product is between bits<br>*  1 and 2 rather than between 0 and 1).<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (ExpSign2)-(LShift[200, 7]C); </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Subtract 200 from ExpSign2[0:8]<br>MulNormal:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T+(LShift[1, 7]C);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  and add 1 <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)+T;<br><br>* Now do the multiplications.  Initial registers:<br>*   Frac1H = F1H (high 16 bits of arg 1)<br>*   Frac1L = F1L,,0 (low 8 bits of arg 1)<br>*   Frac2H = F2H (high 16 bits of arg 2)<br>*   Frac2L = F2L,,0 (low 8 bits of arg 2)<br>* Intermediate register usage:<br>*   Frac1L and FTemp0 accumulate sticky bits<br>*   FTemp2 is the initial product register for the Multiply subroutines.<br><br>* Do 8-step multiply of F1L*F2L, with initial product of zero.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; T&larr; RSH[Frac1L, 10];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Frac1L&larr; 0,,F1L<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; RSH[Frac2L, 10],</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Frac2L&larr; 0,,F2L<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Call[MultTx2L8I];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Force 8 iterations,initial product 0<br><br>* Low product is FTemp2[8:15],,Q[0:7].  FTemp2[0:7] = Q[8:15] = 0.<br>* Do 8-step multiply of F2H*F1L, using high 8 bits of previous result as initial product.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp0&larr; Q;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Save low 8 bits for later use as sticky bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac2H, Cnt&larr; 6S, Call[MultTx1L];<br><br>* Cross product is FTemp2[0:15]..Q[0:7].  Q[8:15] = 0.<br>* Do 8-step multiply of F1H*F2L, with initial product of zero.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; Q;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Frac1L&larr; low 8 bits of cross product<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac1H, ShC&larr; T,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* ShC&larr; high 16 bits of cross product<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Call[MultTx2L8I];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Force 8 iterations,initial product 0<br><br>* Cross product is FTemp2[0:15]..Q[0:7].  Q[8:15] = 0.<br>* Add cross products, propagate carries, and merge sticky bits.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Frac1L)+Q;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Add low 8 bits of cross products<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (FTemp0) OR T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Merge with sticky bits from low product<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ShC, Branch[.+2, ALU=0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Collapse to single sticky bit in Frac1L[15]<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; 1C;<br> * Add high 16 bits of cross products<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp2&larr; (FTemp2)+T, XorSavedCarry;<br><br><br>* Do 16-step multiply of F1H*F2H, using high 16 bits of previous result<br>*  as initial product.<br>* Frac1H&larr; (-1)+(carry out of sum of low and cross products).<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; B&larr; Frac1H, Cnt&larr; 16S;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; T-T-1, XorSavedCarry, Call[MultTx2H];<br><br>* Final result is T,,Q.  Merge in the sticky bit from low-order products<br>*  and exit.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L) OR Q, DispTable[1, 2, 2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Frac1H)+T+1, Branch[Normalize], DispTable[1, 2, 2];<br><br>* One or both arguments = zero.  Return zero with appropriate sign.<br>* T = ExpSign2<br>MulArgZero:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1) XOR T, Branch[FRePackZero];<br><br><br>*-----------------------------------------------------------<br>* Unsigned multiply subroutines<br>* Entry conditions (except as noted):<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Cnt = n-2, where n is the number of iterations<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">T = multiplicand<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">FracXX = multiplier (register depends on entry point);<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">leftmost (16D-n) bits must be zero.<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp2 = initial product (to be added to low 16 bits of final product)<br>* Exit conditions:<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Product right-justified in T[0:15],,Q[0:n-1]<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q[n:15] = 0<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp2 = copy of T<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Carry = 1 iff T[0] = 1<br>* If n = 16D, caller must squash Multiply dispatches in the 2 instructions<br>* following the Call.<br>* Timing: n+2<br>*-----------------------------------------------------------<br>SUBROUTINE;<br><br>* Entry point for multiplier = Frac1L<br>MultTx1L:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q&larr; Frac1L, DblBranch[MultiplierO, MultiplierE, R odd];<br><br>* Entry point for multiplier = Frac2L.<br>* This entry forces 8 iterations with an initial product of zero.<br>MultTx2L8I:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp2&larr; A0, Cnt&larr; 6S;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q&larr; Frac2L, DblBranch[MultiplierO, MultiplierE, R odd];<br><br>* Entry point for multiplier = Frac2H<br>MultTx2H:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q&larr; Frac2H, DblBranch[MultiplierO, MultiplierE, R odd];<br><br>* Execute first Multiply purely for side-effects (dispatch and shift Q)<br>MultiplierE:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; A0, Multiply, Branch[FM0];<br>MultiplierO:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; A0, Multiply, Branch[FM1];<br><br>DispTable[4];<br><br>* here after Q[14] was 0 (no add) and continue<br>FM0:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp2&larr; A&larr; FTemp2, Multiply, DblBranch[FM0E, FM0, Cnt=0&-1];<br>* here after Q[14] was 0 (no add) and exit<br>FM0E:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp2&larr; T&larr; A&larr; FTemp2, Multiply, Return;<br><br>* here after Q[14] was 1 (add) and continue<br>FM1:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp2&larr; (FTemp2)+T, Multiply, DblBranch[FM0E, FM0, Cnt=0&-1];<br>* here after Q[14] was 1 (add) and exit<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FTemp2&larr; T&larr; (FTemp2)+T, Multiply, Return;<br><br>TOPLEVEL;<br><br><br>regOP1[353, StackM2BR, opFQUOTIENT, noNData]; <br>KnowRBase[LTEMP0];<br>*-----------------------------------------------------------<br>opFQUOTIENT:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br>KnowRBase[FTemp0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> T&larr; ExpSign2, Branch[DivArgZero]; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* one arg = 0<br><br>* XOR signs and subtract exponents.<br>* Add 200 to resulting exponent to correct for cancellation of bias.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (ExpSign2)-(LShift[200, 7]C); * Subtract 200 from ExpSign2[0:8]<br>FDivNormal:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)-T;<br><br>* First, transfer dividend to Frac2H,,Frac2L and divisor to T,,Q, and<br>*  unnormalize both of them by one bit so that significant dividend bits<br>*  aren&rsquo;t lost during the division.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; (Frac1H) rsh 1, Branch[.+2, R odd];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Frac1L) RSH 1, Branch[.+2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ((Frac1L) + 1) rcy 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Know Frac1L is even here<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; T, Q&larr; Frac2L;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A&larr; Frac2H, Multiply;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T,,Q &larr; (Frac2H ,, Frac2L) RSH 1<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Know Q[14]=0, so can&rsquo;t dispatch<br><br>* Now do the division.<br>* Must do total of 26 iterations: 24 for quotient bits, plus one more<br>*  significant bit in case we need to normalize, +1 bit for rounding.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H&larr; Frac1H, Call[DivFrac];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Do 16 iterations<br>SUBROUTINE;<br>* Preserve high quotient; do 10 more iterations<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; Frac1L, CoReturn;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br><br>* We may have subtracted too much (or not added enough) in the last<br>*  iteration.  If so, adjust the remainder by adding back the divisor. <br>* Since the remainder got shifted left one bit, we must double the<br>*  divisor first.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A&larr; T, Divide, Frac1L, Branch[NoRemAdjust, R odd]; <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T,,Q &larr; (T,,Q) lsh 1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; (Frac2L) + Q;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H&larr; T&larr; (Frac2H) + T, XorSavedCarry, Branch[.+2];<br><br>* Left-justify low quotient bits and zero sticky bit.<br>* Then, if the remainder is nonzero, set the sticky bit.<br>* Then normalize if necessary.  Should have to left-shift at most once,<br>*  since the original operands were normalized.<br>NoRemAdjust:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac2H;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (Frac2L) or T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; LSH[Frac1L, 6], Branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Set sticky bit<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac1H, Branch[Normalize];<br><br>* Trap if divisor is zero; return zero with appropriate sign otherwise.<br>DivArgZero:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H, Branch[MulArgZero, R&lt;0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL; callUFN; SUBROUTINE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Division by zero<br><br>*-----------------------------------------------------------<br>DivFrac:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Divide fractions<br>* Enter: Frac2H ,, Frac2L = dividend (high-order bit must be zero)<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">T ,, Q = divisor (high-order bit must be zero)<br>* Exit:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H ,, Frac2L = remainder, left-justified<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L = quotient bits (see below)<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">T and Q unchanged<br>* When first called, executes 16 iterations and returns 16 high-order<br>*  quotient bits.<br>* When resumed with CoReturn, executes 10 more iterations and returns <br>*  10 low-order quotient bits right-justified (other bits garbage).<br>* Timing: first call: 66; resumption: 41<br>*-----------------------------------------------------------<br><br>SUBROUTINE;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Cnt&larr; 17S;<br>* Previous quotient bit was a 1, i.e., dividend was &gt;= divisor.<br>* Subtract divisor from dividend and left shift dividend.<br>DivSubStep:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; ((Frac2L)-Q) LSH 1;<br>DivSubStep1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H&larr; (Frac2H)-T-1, XorSavedCarry, <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DblBranch[DivSh1, DivSh0, ALU&lt;0];<br><br>* Previous quotient bit was a 0, i.e., dividend was &lt; divisor<br>*  (subtracted too much).  Add divisor to dividend and left shift<br>*  dividend.<br>DivAddStep:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; ((Frac2L)+Q) LSH 1;<br>DivAddStep1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H&larr; (Frac2H)+T, XorSavedCarry, DblBranch[DivSh1, DivSh0, ALU&lt;0];<br><br>* Shifted a zero out of low dividend (ALU&lt;0 tested unshifted result).<br>DivSh0:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H&larr; (Frac2H)+(Frac2H), DblBranch[DivQuot1, DivQuot0, Carry];<br><br>* Shifted a one out of low dividend (ALU&lt;0 tested unshifted result).<br>DivSh1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H&larr; (Frac2H)+(Frac2H)+1, DblBranch[DivQuot1, DivQuot0, Carry];<br><br>* If the operation generated no carry then we have subtracted too much.<br>* Shift a zero into the quotient and add the divisor next iteration.<br>DivQuot0:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L)+(Frac1L),</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Shift zero into quotient<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[DivAddStep, Cnt#0&-1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Cnt&larr; 11S, CoReturn;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; ((Frac2L)+Q) LSH 1, Branch[DivAddStep1];<br><br>* If the operation generated a carry then we haven&rsquo;t subtracted too much<br>* Shift a one into the quotient and subtract the divisor next iteration.<br>DivQuot1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L)+(Frac1L)+1,</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Shift one into quotient<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[DivSubStep, Cnt#0&-1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Cnt&larr; 11S, CoReturn;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; ((Frac2L)-Q) LSH 1, Branch[DivSubStep1];<br><br>TOPLEVEL;<br><br><br>KnowRBase[LTEMP0];<br>regOP1[362, StackM2BR, opFGREATERP, noNData];<br>*-----------------------------------------------------------<br>opFGREATERP:<br>*-----------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br>KnowRBase[FTemp0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Stack&+2, Branch[FGT2];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* one arg = 0<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Stack&+2;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; high arg1<br><br>* First compare the signs<br>FGT2:</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T xor (Q&larr; Stack&-1);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Q&larr; high arg2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Stack&-1, FreezeBC, </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; low arg2<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[FCompSignsDiff, alu&lt;0];<br>* Signs equal, compare magnitudes.  <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q = high arg2, T = low arg2, StkP -&gt; high arg1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (Stack&-1) - Q, Branch[.+2, alu#0]; * Compute high (arg1 - arg2)<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (Stack) - T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* If equal, compute low (arg1 - arg2)<br><br>* Carry = 1 if arg1 &gt;= arg2 when treated as unsigned numbers.<br>* The sense of this is inverted if the arguments are in fact negative,<br>*  since the representation is sign-magnitude rather than 2s-complement.<br>FCompTest:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)+1, XorSavedCarry, Branch[FCompE, alu=0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1, DblBranch[FCompL, FCompG, R odd];<br><br>* Signs unequal.  Unless both arguments are zero, return "less" if arg1<br>*  is negative, else "greater".  Q = high arg2.<br>FCompSignsDiff:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T - T, StkP-1, Q lsh 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Carry&larr; 1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (Frac1H) or Q, Branch[FCompTest];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* alu=0 iff both args are zero<br><br>FCompL:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&larr; A0, memBase&larr; StackBR, Branch[.fgtpret];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* arg1 &lt; arg2<br>FCompE:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&larr; A0, memBase&larr; StackBR, Branch[.fgtpret];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* arg1 = arg2<br>FCompG:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&larr; (Stack) - (Stack) - 1, <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR, Branch[.fgtpret];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* arg1 &gt; arg2<br><br>:if[StackEmpty!];<br>.fgtpret:</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (StackEmpty);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RBase&larr; RBase[LTEMP0];<br>:else;<br>.fgtpret:</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, RBase&larr; RBase[LTEMP0];<br>:endif;<br>KnowRBase[LTEMP0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) - (4c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  Adjust TSP back over args<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd &larr; (Stack) + 1, StkP&larr; T, Branch[TL.GREATERP];<br><br><br>KnowRBase[LTEMP0];<br><br>*-----------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">.FUNBOX2: GLOBAL, <br>*-----------------------------------------------------------<br>* "unpack" two floating-point arguments.<br>* Call: memBase&larr; StackM2BR;<br>*  </span><span class="tab" val="24"></span><span style="font: 10pt monospace">  T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br><br>* Exit:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign2, Frac2H, Frac2L set up with argument 2 (right);<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> ExpSign2[13:14]=00<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1, Frac1H, Frac1L set up with argument 1 (left);<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> ExpSign1[13:14]=10<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP addresses high word of arg 1 (i.e., =2 if minimal stack)<br><br>* Returns +1: at least one argument is zero<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> +2: both arguments are nonzero<br>* Returns only for normal numbers or true zero.<br>* Traps if denormalized, infinity, or Not-a-Number.<br>* Clobbers Q<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; Md, T&larr; (fetch&larr; T) - (3c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP2&larr; YHi<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; Md, T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP3&larr; YLo<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T, LTEMP0&larr; XHi<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, memBase&larr; tyBaseBR; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP1&larr; XLo<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; rcy[T, LTEMP1, 11];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T &larr; type table ptr for X<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T, T&larr; (2c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Also shuffle a 2 into Q<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">stkP&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, memBase&larr; ScratchLZBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T &larr; ntypx(X)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (T) xor (floatptype);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], BrHi&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL; CallUFN; SUBROUTINE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* nope, not floatp<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FETCH&larr; LTEMP1) + 1;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&-1&larr; MD, fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&+3&larr; Md;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* push unboxed X<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP2, memBase&larr; tyBaseBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; YHi<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; rcy[T, LTEMP3, 11];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T &larr; type table ptr for Y<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, memBase&larr; ScratchLZBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (T) xor (floatptype);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], BrHi&larr; LTEMP2;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL; CallUFN; SUBROUTINE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* nope, not floatp<br>PAGEFAULTOK;<br>   T&larr; (FETCH&larr; LTEMP3) + 1;<br>   T&larr; Stack&-1&larr; MD, fetch&larr; T;<br>PAGEFAULTNOTOK;<br>   Stack&larr; Md, RBase&larr; RBase[FTEMP0], branch[FunPack2];<br><br><br>KnowRBase[LTEMP0];<br>*-----------------------------------------------------------<br>.FUNPACK:<br>*-----------------------------------------------------------<br>* "unpack" two floating-point arguments.<br>* Call:<br>*   memBase&larr; StackM2BR;<br>*   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNPACK];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (2c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&-1&larr; Md, T&larr; (fetch&larr; T) - (3c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&+3&larr; Md, T&larr; (fetch&larr; T) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Stack&-1&larr; Md, fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&larr; Md, RBase&larr; RBase[FTEMP0];<br>FUnPack2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign2&larr; T AND (177600C);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; RCY[T, Stack, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Garbage bit and top 15 fraction bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&lt;0], ExpSign2&larr; (ExpSign2) and (77777C);</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Exponent in bits 1:8, all else zero.<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign2&larr; (ExpSign2)+(200C),</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Positive, +1 exponent, B15 &larr; 0<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DblBranch[Exp2Zero, .+2, ALU=0]; * exponent = 0 ?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign2&larr; (ExpSign2)+(201C),</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Negative, +1 exponent, B15 &larr; 1<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[Exp2Zero, alu=0];* exponent = 0 ?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H&larr; T or (100000C),</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Prefix explicit "1." to fraction<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[Exp2NaN, ALU&lt;0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* exponent = 377 ?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[Stack&-1, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Left-justify low 8 fraction bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Stack&-1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Now do arg 1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; T AND (177600C), Branch[FUnPack1a];<br><br>Exp2Zero:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2H&larr; (Stack&-1) or T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Is entire fraction zero ?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac2L&larr; A0, Branch[Arg2DeNorm, alu#0]; * Branch if not true zero<br>TopLevel;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Stack&-1, Q&larr; Link, SCall[FUnPack1]; * Zero, unpack other arg<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Return +1 regardless of what FUnpack1 did<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Link&larr; Q, Branch[.+2];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Link&larr; Q;<br>Subroutine;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign2&larr; (ExpSign2) AND (1C), Return;<br><br>TOPLEVEL;<br>Arg2DeNorm:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Denormalized number<br>Exp2NaN:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Not-a-Number<br>SUBROUTINE;<br><br><br>*-----------------------------------------------------------<br>FUnPack1:<br>*-----------------------------------------------------------<br>* Pop and unpack one floating-point argument.<br>* Enter: T = top-of-stack, StkP points to TOS-1<br>* Exit:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1, Frac1H, Frac1L set up with argument<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP addresses high word of arg 1 (i.e., =2 if minimal stack)<br>* Call by: SCall[FUnPack1]<br>* Returns +1: argument is zero<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">+2: argument is nonzero<br>* Returns only for normal numbers or true zero.<br>* Traps if denormalized, infinity, or Not-a-Number.<br>* Timing: 7 cycles normally.<br>*-----------------------------------------------------------<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; T AND (177600C), Global;<br>FUnPack1a:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; RCY[T, Stack, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Garbage bit and top 15 fraction bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1) AND (77777C), * Exponent in bits 1:8, all else zero<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&lt;0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Branch if negative<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)+(204C),</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Positive, add 1 to exponent, [13:14]&larr;10, [15]&larr;0<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DblBranch[Exp1Zero, .+2, ALU=0]; * Branch if exponent zero<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)+(205C),</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Negative, add 1 to exponent, [13:14]&larr;10, [15]&larr;1<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[Exp1Zero, ALU=0]; * Branch if exponent zero<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; T OR (100000C),</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Prefix explicit "1" to fraction<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[Exp1NaN, ALU&lt;0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Branch if exponent was 377<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[Stack&+1, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Left-justify low 8 fraction bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; T, Return[Carry&rsquo;];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Always skip (carry is always zero here)<br><br>Exp1Zero:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; (Stack&+1) OR T;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* See if entire fraction is zero<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; A0, Branch[Arg1DeNorm, ALU#0]; * Branch if not true zero<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1) AND (1C), Return; * Zero, return +1<br><br>TOPLEVEL;<br>Arg1DeNorm:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Denormalized number<br>Exp1NaN:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Not-a-Number<br><br>*-----------------------------------------------------------<br>Normalize:<br>* Normalize and re-pack floating-point result.<br>* Enter: ExpSign1, T, Frac1L contain unpacked result<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T = ALU = high fraction.<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP addresses high word of result (i.e., =2 if minimal stack)<br>* Timing: for nonzero result: 11 cycles minimum, +3 if need to normalize<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> at all, +2*(n MOD 16) if n&gt;1, where n is the number of<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> normalization steps, +3 if n&gt;15, +5 if need to round, +2 if<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> rounding causes a carry out of Frac1L, +1 or 2 in extremely<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> rare cases.</span><span class="tab" val="24"></span><span style="font: 10pt monospace">For zero result: 6 cycles<br>*-----------------------------------------------------------<br><br>* See if result is already normalized or entirely zero.<br>* Note that we want the cases of no normalization, one-step<br>*  normalization, and result entirely zero to be the fastest, since they<br>*  are by far the most common. So, do the first left shift in-line while<br>*  branching on the other conditions.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; T OR (Q&larr; Frac1L),</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* ALU&larr; 0 iff entire fraction is 0<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[NormAlready, ALU&lt;0]; * Branch if already normalized<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; A&larr; T, Divide,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* (Frac1H,,Q) &larr; (T,,Q) LSH 1<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[NormalizeZero, ALU=0]; * Branch if fraction is zero<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)-(LShift[1, 7]C), * Subtract one from exponent<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[NormBegin, ALU#0]; * Branch if high fraction was nonzero<br><br>* If the high word of the fraction was zero, we discover that after<br>*  having left-shifted the fraction once.  Effectively, left-shift the<br>*  fraction 16 bits and subtract 16D from the exponent.  Actually, undo<br>*  the first left shift and subtract only 15D from the exponent, in case<br>*  the first left shift moved a one into the high fraction.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)+(LShift[1, 7]C);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)-(LShift[20, 7]C);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; Frac1L;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Left-shift original fraction 16 bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q&larr; T, Branch[NormLoop];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Q&larr; 0<br><br>* In this loop, the exponent is in ExpSign1[0:8] and the fraction in<br>*  Frac1H ,, Q.  Left shift the fraction and decrement the exponent<br>*  until the high-order bit of the fraction is a one.<br>NormBegin:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, Frac1H, Branch[NormDone1, R&lt;0]; * One shift enough ?<br>NormLoop:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; A&larr; Frac1H, Divide, Branch[NormDone, R&lt;0]; <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* (Frac1H,,Q) &larr; (Frac1H,,Q) LSH 1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1) - (LShift[1, 7]C), Branch[NormLoop];<br><br>* When we bail out of the loop, the exponent is correct, but we have<br>*  left-shifted the fraction one too many times.  Right-shift the<br>*  fraction and exit.<br>NormDone:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; (Frac1H)-T, Multiply;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* (Frac1H,,Q) &larr; 1,,((Frac1H,,Q) RSH 1)<br>NormDone1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; Q, Branch[FRePackNonzero]; * Multiply dispatch pending!!<br><br>NormAlready:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; T, Branch[FRePackNonzero]; * Placement (sigh)<br>* Result was exactly zero: push +0 as answer.<br>NormalizeZero:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; A0, Branch[FRePackZero];<br><br>*-----------------------------------------------------------<br>FRePackNonzero:<br>* Re-pack nonzero floating-point result.<br>* Enter: ExpSign1, Frac1H, Frac1L contain unpacked result, which must <br>*  be normalized but need not have its leading "1" so long as rounding<br>*  can&rsquo;t carry into this bit.<br>* StkP addresses high word of result (i.e., =2 if minimal stack)<br>* Timing: 9 cycles minimum, <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">+5 if need to round, +2 if rounding causes a carry<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">out of Frac1L, +1 or 2 in extremely rare cases.<br>*-----------------------------------------------------------<br><br>* Prepare to round according to Round-to-Nearest convention. <br>*  Frac1L[8:15] are fraction bits that will be rounded off; result <br>*  is exact only if these bits are zero.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; (Frac1L) AND (377C), DispTable[1, 2, 2];<br>FRePackNZ1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1) OR (176C),</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* unused bits of ExpSign1 get 1&rsquo;s<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[NoRounding, ALU=0];<br><br>* Inexact result.  Round up if result is greater than halfway between<br>*  representable numbers, down if less than halfway.  If exactly<br>*  halfway, round in direction that makes least significant bit of<br>*  result zero. Adding 1 at the Frac1L[8] position causes a carry into<br>*  bit 7 iff the result is &gt;= halfway between representable numbers.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; (Frac1L) AND (177C);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L)+(200C), Branch[.+2, ALU#0];<br><br>* Exactly halfway.  But we have already rounded up.<br>* If the least significant bit was 1, it is now 0 (correct).<br>* If it was 0, it is now 1 (incorrect).  But in the latter case, no<br>*  carries have propagated beyond the least significant bit, so...<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1L&larr; (Frac1L) AND NOT (400C); * Just zero the bit to fix it<br><br>* Now set the sticky flag and trap if appropriate.<br>* Note we have not propagated the carry out of the low word yet, so <br>*  we must perform only logical ALU operations that don&rsquo;t clobber the<br>*  carry flag.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; B&larr; Frac1H;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T+1, RBase&larr; RBase[FTemp0],</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Prepare to do carry if appropriate<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[DoneRounding, Carry&rsquo;];<br><br>* There was a carry out of Frac1L.  Propagate it to Frac1H.<br>* If this causes a carry out of Frac1H, the rounded fraction is <br>*  exactly 2.0, which we must normalize to 1.0; i.e., set fraction <br>*  to 1.0 and increment exponent.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Frac1H&larr; T, Branch[.+2, Carry&rsquo;];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)+(LShift[1, 7]C);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)-(LShift[2, 7]C), <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DblBranch[ExpOverflow, .+3, R&lt;0];<br><br><br>* Done rounding.  Check for exponent over/underflow, and repack and <br>*  push result.<br>DoneRounding:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)-(LShift[2, 7]C), <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DblBranch[ExpOverflow, .+2, R&lt;0];<br>NoRounding:<br>* Subtract 2 from exponent; Branch if exponent &gt; 377B originally<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ExpSign1&larr; (ExpSign1)-(LShift[2, 7]C), </span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[ExpOverflow, R&lt;0]; <br>* Extract high 7 fraction bits, exclude leading 1, <br>*  Branch if exponent &lt; 2 originally<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LDF[Frac1H, 7, 10], Branch[ExpUnderflow, ALU&lt;0];  <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>* Here, ExpSign1[1:8] = desired exponent -1, and [9:15] = 176 if<br>*  the sign is positive, 177 if negative.  Thus adding 2 (if positive)<br>*  or 1 (negative) will correctly adjust the exponent and clear [9:15].<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Merge exponent with fraction and add 1.  Branch if negative<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (ExpSign1)+T+1, Branch[.+2, R odd];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Positive, add 1 more to finish fixing exponent<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&-1&larr; T+1, Branch[.+2];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&-1&larr; T or (signBit);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Negative, set sign bit of result<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Frac1H;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Construct low fraction<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; rcy[T, Frac1L, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&+1&larr; T, branch[.StoreFloat];<br><br>ExpOverflow:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;<br>ExpUnderflow:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;<br><br>*-----------------------------------------------------------<br>FRePackZero:<br>* Push a result of zero with the correct sign<br>* Enter: ExpSign1 has correct sign<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP addresses high word of result (i.e., =2 if minimal stack)<br>*-----------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[ExpSign1, 17];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Slide sign to bit 0<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&-1&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Push true zero with correct sign<br>FRePackZ2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&+1&larr; A0, branch[.StoreFloat];<br><br>*-----------------------------------------------------------<br>* .StoreFloat:   * StackBr in effect<br>*-----------------------------------------------------------<br><br>:if[StackEmpty!];<br>.StoreFloat:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (StackEmpty);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RBase&larr; RBase[LTEMP0];<br>:else;<br>.StoreFloat:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, RBase&larr; RBase[LTEMP0];<br>:endif;<br>KnowRBase[LTEMP0];<br><br>:if[NotReduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CELLHINUM&larr; Stack&-1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CELLLONUM&larr; Stack;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Resets the hardware stack<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; 2c;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* All floating ops have two args, or 4<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; dtdBR; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  wds on stack;  2c must come off.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LShift[floatpType!, 4]c), Branch[TL.CREATECELL];<br>:else;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; T, T&larr; Link, Call[SAVEUCODESTATE];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (TSP) - (4c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; Stack&-1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; T) + 1, dbuf&larr; Stack;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; HighByte[AT.MAKEFLOAT];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; (DEFLO) + (LowByte[AT.MAKEFLOAT]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; 2c, Branch[DOCALLPUNT];<br><br>:endif; * NotReduced<br><br>:ENDIF; * NOFLOATING;<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
