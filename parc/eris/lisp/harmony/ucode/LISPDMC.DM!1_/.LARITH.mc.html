<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>LISPDMC.DM!1>LARITH.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">:Title[LARITH];<br>*<br>* Edit History<br>* February 2, 1984  10:06 AM, JonL, fix all CallUFN&rsquo;s to be alone <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">on line (permits new def of CallUFN)<br>* January 13, 1984  10:44 PM, JonL, spawned this file off LOW.mc<br>* January 12, 1984  12:22 AM, JonL, fix wrong-parity branches at<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> .unboxB1 and .unboxA1, and straighten out mess at .unboxAcl<br>* January 6, 1984  8:16 AM, JonL, fixed .BOX2 and .BOX to account for<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP height when tailing into TL.CREATECELL<br>* January 5, 1984  1:02 AM, JonL, fixed bug caused by no comments in<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">kludgy .STOREBOX code!<br>* January 4, 1984  7:08 PM, JonL, added label TL.GREATERP for<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> opFGREATERP to use.<br>* January 3, 1984  10:59 PM, JonL, Mucked with .UNBOX* some more,<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">finding several bugs<br>* December 30, 1983  4:53 PM JonL& Masinter, fix TSP on entry to<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TL.CREATECELL, fix TT.** in .UNBOX2<br>* December 29, 1983  8:42 PM, JonL, added opMAKENUMBER<br>* December 29, 1983  12:21 PM, JonL, Re-format some (flushing CR&rsquo;s), <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">add .numfail as a place to UFN out rather than .unboxfail; fix bug<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">of LRSH sometimes entering .BOX with ALU bad branch conditions<br>* December 27, 1983  9:50 PM, JonL, let .BOX tail into TL.CREATECELL<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">instead of punting out; cleanup .UNBOX2 to flush TT.*** bits etc.<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Used symbolic (sub[SmallNeg!, SmallHi!]c) instead of 1 in .unbox.<br>* December 26, 1983  6:46 PM, JonL, moved opEQ and opNOP to LOPS;<br>* December 26, 1983  1:22 PM, JonL, LLSH and LRSH use LCY and RCY;<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">cause .UNBOX* to flush TT.*** bits from type table <br>* December 21, 1983  5:08 AM, JonL, Move opSWAP to LSTACK, opGCSCAN to<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LGC, opRCLK to LOPS.<br>*   - - -                   , Masinter<br><br>   TOP LEVEL;<br>   knowrbase[LTEMP0];<br>   InsSet[LispInsSet, 1];<br><br><br>*--------------------------------------------------------------------<br>opLOGAND2:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX2];<br>   LTEMP1&larr; (LTEMP1) and Q;<br>   LTEMP0&larr; (LTEMP0) and T, branch[.BOX2];<br><br>regOP1[345, StackM2BR, opLOGAND2, noNData];<br><br>*--------------------------------------------------------------------<br>opLOGOR2:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX2];<br>   LTEMP1&larr; (LTEMP1) or Q;<br>   LTEMP0&larr; (LTEMP0) or T, branch[.BOX2];<br><br>regOP1[344, StackM2BR, opLOGOR2, noNData];<br><br>*--------------------------------------------------------------------<br>opLOGXOR2:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX2];<br>   LTEMP1&larr; (LTEMP1) xor Q;<br>   LTEMP0&larr; (LTEMP0) xor T, branch[.BOX2];<br><br>regOP1[346, StackM2BR, opLOGXOR2, noNData];<br><br><br>*--------------------------------------------------------------------<br>opLLSH1:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Replace TOS with fixp shifted left one<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX1];<br>   LTEMP1&larr; (LTEMP1) + (LTEMP1);<br>   LTEMP0&larr; T + T, XorSavedCarry, branch[.BOX];<br><br>regOP1[340, StackM2BR, opLLSH1, noNData];<br><br>*--------------------------------------------------------------------<br>opLRSH1:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Replace TOS with fixp shifted right one<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1 &larr; RCY[T,LTEMP1,1];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Masking may cause a false "No" answer to the alu=0 question in <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   .BOX, but it will recuperate by testing LTEMP0 again.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0 &larr; RSH[LTEMP0,1], branch[.BOX];<br><br>regOP1[342, StackM2BR, opLRSH1, noNData];<br><br>*--------------------------------------------------------------------<br>opLRSH8:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1 &larr; RCY[T,LTEMP1,10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0 &larr; RSH[LTEMP0,10], branch[.BOX];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* See comment at opLRSH1<br><br>regOP1[343, StackM2BR, opLRSH8, noNData];<br><br>*--------------------------------------------------------------------<br>opLLSH8:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1 &larr; LSH[LTEMP1,10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T &larr; Q;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Can&rsquo;t specify Q in shifts<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0 &larr; LCY[T,LTEMP0,10], branch[.BOX];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* See comment at opLRSH1<br><br>regOP1[341, StackM2BR, opLLSH8, noNData];<br><br><br><br>*--------------------------------------------------------------------<br>opIPLUS2:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];<br>   LTEMP1&larr; (LTEMP1) + Q;<br>   LTEMP0&larr; (LTEMP0) + T, XorSavedCarry, branch[.BOX2];<br><br>regOP1[330, StackM2BR, opIPLUS2, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* IPLUS<br><br>*--------------------------------------------------------------------<br>opIDIFFERENCE:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];<br>   LTEMP1&larr; (Q) - (LTEMP1);<br>   LTEMP0&larr; (T) - (LTEMP0) - 1, XorSavedCarry, branch[.BOX2];<br><br>regOP1[331, StackM2BR, opIDIFFERENCE, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* IDIFFERENCE<br><br>:if[NotReduced];<br><br>*--------------------------------------------------------------------<br>opBOXIPLUS:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; 1s;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>* When .UNBOX2 unboxes two args, it does the first one last, and leaves<br>*  its lo.word address LTEMP4.  That address must have the low-order bit<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">zero, since it will be a cell-aligned address.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; (LTEMP1) + Q;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (LTEMP0) + T, XorSavedCarry, branch[.STOREBOX2];<br><br>regOP1[366, StackM2BR, opBOXIPLUS, noNData];<br><br>*--------------------------------------------------------------------<br>opBOXIDIFFERENCE:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; 1s;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* See comment above<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; (Q) - (LTEMP1);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (T) - (LTEMP0) - 1, XorSavedCarry, branch[.STOREBOX2];<br><br>regOP1[367, StackM2BR, opBOXIDIFFERENCE, noNData];<br><br>.STOREBOX2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R even], T&larr; (LTEMP4), memBase&larr; ScratchLZBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + (4c), Goto[.arithpunt];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* First arg wasn&rsquo;t fixp type<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Smash results from LTEMP0,1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  into the first arg&rsquo;s loc<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + (2c), NextOpCode;<br><br>:else; </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Reduced<br>UfnOps[366];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[367];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* BOXIPLUS and BOXIDIFFERENCE<br>:endif;<br><br><br>:if[NotReduced];<br><br>*--------------------------------------------------------------------<br>opITIMES2:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];<br>   pd&larr; T or (LTEMP0);<br>   branch[.+2, alu=0], T&larr; LTEMP1;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + (4c), Goto[.arithpunt];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* More than 32 bits =&gt; punt<br>   call[MulSub];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T * Q -&gt; (T, Q)<br>   LTEMP1&larr; Q;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  MulSub is "unsigned" op<br>   LTEMP0&larr; T, branch[.BOX2];<br><br>regOP1[332, StackM2BR, opITIMES2, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* ITIMES<br><br>*--------------------------------------------------------------------<br>opIQUOTIENT:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T or (LTEMP0);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* (could handle big positives)<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + (4c), Goto[.arithpunt];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DivTEMP1&larr; LTEMP1, SCall[DivSub];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T,,Q / DivTEMP1<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2], TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + (4c), Goto[.arithpunt];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Failure return<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; Q, NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Q has quotient<br><br>regOP1[333, StackM2BR, opIQUOTIENT, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* IQUOTIENT<br><br>*--------------------------------------------------------------------<br>opIREMAINDER:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T or (LTEMP0);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + (4c), Goto[.arithpunt];<br>   DivTEMP1&larr; LTEMP1, SCall[DivSub];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T,,Q / DivTEMP1<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2], TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + (4c), Goto[.arithpunt];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* failure return<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T has remainder<br><br>regOP1[334, StackM2BR, opIREMAINDER, noNData];<br><br>:else;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Reduced<br>* ITIMES, IQUOTIENT, and IREMAINDER<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[332]; UfnOps[333]; UfnOps[334];<br>:endif;<br><br><br>*--------------------------------------------------------------------<br>opIGREATERP:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX2];<br>   pd&larr; T - (LTEMP0);<br>   branch[TL.GREATERP, alu=0], pd&larr; (Q) - (LTEMP1) - 1;<br>   T&larr; T xor (100000c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* hi parts differ, so complement <br>   LTEMP0&larr; (LTEMP0) xor (100000c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* sign, and try again<br>   pd&larr; T - (LTEMP0) - 1;<br>TL.GREATERP:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* opFGREATERP also comes here<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, carry], TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; AT.NIL, NextOpCode;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* push NIL<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; AT.T, NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* push T<br><br>regOP1[361, StackM2BR, opIGREATERP, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* IGREATERP<br><br>*--------------------------------------------------------------------<br>* Generic arithmetic entries<br>*--------------------------------------------------------------------<br>:if[Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[324];   UfnOps[325];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PLUS and DIFFERENCE<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[326];   UfnOps[327];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* TIMES and QUOTIENT<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[334];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* REMAINDER<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[363];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* GREATERP<br>:else;<br>regOP1[324, StackM2BR, opIPLUS2, noNData];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PLUS<br>regOP1[325, StackM2BR, opIDIFFERENCE, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* DIFFERENCE<br>regOP1[326, StackM2BR, opITIMES2, noNData];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* TIMES<br>regOP1[327, StackM2BR, opIQUOTIENT, noNData];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* QUOTIENT<br>regOP1[363, StackM2BR, opIGREATERP, noNData];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* GREATERP<br>:endif;<br><br>*--------------------------------------------------------------------<br>opMAKENUMBER:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T or (LTEMP0);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Ascertain that both args are SmallPosp&rsquo;s<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + (4c), Goto[.arithpunt];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; LTEMP0&larr; Q, branch[.BOX2];<br><br>regOP1[365, StackM2BR, opMAKENUMBER, noNdata];<br><br>.arithpunt:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* "Goto" here, so as to preserve Link for<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  SAVEUCODESTATE<br><br><br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">.UNBOX1:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">GLOBAL, <br>*--------------------------------------------------------------------<br><br>* Enter with one argument A on top of stack<br>*            memBase set to StackM2BR, then do<br>*            T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX1];<br>* Exit with A hi.word in LTEMP0, T<br>*           A lo.word in LTEMP1, Q<br>*           TSP "pulled back" over the the argument<br>*           memBase set to StackBR<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">clobbers LTEMP2, SaveLink<br><br>   LTEMP2&larr; T&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Now memBase is StackBR<br>   LTEMP0&larr; T&larr; T - (SmallHi);<br>.unbox1.0:<br>   branch[.unbox1.1, alu#0], Q&larr; LTEMP1&larr; Md;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Note how the branch falls thru on SmallHi with LTEMP0 and<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  T set to 0;  This is a "fast case" exit for SmallPosp&rsquo;s<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) - (2c), return;<br><br>:if[NotReduced];<br><br>.unbox1.1:<br>   T&larr; T - (sub[SmallNeg!, SmallHi!]c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* This "sub" had better be 1<br>   branch[.+2, alu#0], LTEMP0&larr; T&larr; T - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP0&larr; -1 in case A is a<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) - (2c), return;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  SmallNeg (and fast exit)<br>.unbox1cl:<br>* "A" may be stored in a cell -- check it out<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP2, memBase&larr; tyBaseBR;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> </span><span style="font: 10pt serif"> </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Otherwise, restore T<br><br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Think of the following as a subroutine:<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2,T have hi.word, LTEMP1 has lo.word, memBase is tyBaseBr<br>   T&larr; RCY[T, LTEMP1, 11];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Fetch the type table entry<br>   fetch&larr; T;<br>   T&larr; Md, memBase&larr; ScratchLZBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (T) and (rhmask); </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Foo on TT.*** bits<br>   pd&larr; (T) xor (fixptype);<br>   branch[.+2, alu=0], BrHi&larr; LTEMP2;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL; CallUFN; SUBROUTINE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* not fixp type<br>PAGEFAULTOK;<br>   T&larr; (FETCH&larr; LTEMP1) + 1;<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">This would be the subroutine exit<br><br>   LTEMP0&larr; T&larr; MD, fetch&larr; T;<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T - T, memBase&larr; StackBr, Branch[.unbox1.0];<br><br>:else;<br>.unbox1.1: TOPLEVEL; CallUFN; SUBROUTINE;<br>:endif;<br><br><br>*--------------------------------------------------------------------<br>.UNBOX2: GLOBAL, <br>*--------------------------------------------------------------------<br>*<br>* Enter with two arguments A and B on top of stack (B on top)<br>*            memBase set to StackM2BR<br>*            T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];<br>* Exit with  A hi.word in T<br>*            A lo.word in Q<br>*            B hi.word in LTEMP0<br>*            B lo.word in LTEMP1<br>*            TSP "pulled back" over both A and B,  LEFT&larr; LEFT - 1<br>*            memBase set to StackBR<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">clobbers LTEMP2, LTEMP3, LTEMP4 and SaveLink<br><br>   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * LTEMP0&larr; Bhi<br>   LTEMP1&larr; Md, T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * LTEMP1&larr; Blo<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (LTEMP0) - (SmallHi);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * LTEMP0&larr; Bhi-SmallHi<br><br>:if[NotReduced];<br><br>.unboxB:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * B is unboxed first<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.unboxB1, alu#0], LTEMP3&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * LTEMP3&larr; Ahi (unbox)<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP3) - (SmallHi), branch[.unboxA];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * B done if SmallPosp<br>.unboxB1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (LTEMP0) - (sub[SmallNeg!, SmallHi!]c); * LTEMP0&larr; -1 if B is<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0], LTEMP0&larr; (LTEMP0) - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> *  a SmallNeg<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP3) - (SmallHi), branch[.unboxA];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * B done if SmallNeg<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.unboxBcl], Q&larr; Md, LEFT&larr; (LEFT) + 1; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * Q&larr; Alo word <br><br>.unboxA:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * pd has Ahi-SmallHi<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DblBranch[.ubxBothdone, .unboxA1, alu=0],</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * A done if SmallPosp<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> Q&larr; Md, LEFT&larr; (LEFT) + 1;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * Q&larr; Alo word<br>.ubxBothdone:<br>   TSP&larr; (TSP) - (4c), return;<br><br>.unboxA1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T - (sub[SmallNeg!, SmallHi!]c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * T&larr; -1 if A is<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.unboxAcl, alu#0], T&larr; T - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> *  SmallNeg<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) - (4c), return;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * A done if SmallNeg<br><br>.unboxBcl:<br>*  "B" may be stored in a cell -- check it out.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP0) + (add[SmallNeg!, 1]c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * Restore Bhi & <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; T, memBase&larr; tyBaseBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> *  put in T & LTEMP2<br><br>* This could be a subroutine<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; RCY[T, LTEMP1, 11];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, memBase&larr; ScratchLZBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* flush TT.*** bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (T) xor (fixptype);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], BrHi&larr; LTEMP2;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL; CallUFN; SUBROUTINE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* not fixp type<br>PAGEFAULTOK;<br>   T&larr; (FETCH&larr; LTEMP1) + 1;<br>* This would be the end of the subroutine<br><br>   fetch&larr; T, LTEMP0&larr; MD;<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP3) - (SmallHi);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * Unbox Ahi, and<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DblBranch[.ubxBothdone, .unboxA1, alu=0],</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * re-join code to<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, memBase&larr; StackBR; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * finish unboxing "A"<br><br><br>.unboxAcl:<br>*  "A" may be stored in a cell -- check it out.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; T&larr; LTEMP3;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP2&larr; Ahi, freeing<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; Q, memBase&larr; tyBaseBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  LTEMP3 <br><br>* This would be the subroutine<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; RCY[T, LTEMP3, 11];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, memBase&larr; ScratchLZBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (T) and (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* flush TT.*** bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (T) xor (fixptype);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], BrHi&larr; LTEMP2;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL; CallUFN; SUBROUTINE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* not fixp type<br>PAGEFAULTOK;<br>   T&larr; (FETCH&larr; LTEMP3) + 1;<br>* End of subroutine<br><br>   T&larr; MD, fetch&larr; T, LTEMP4&larr; Q;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Kludge for .STOREBOX <br>PAGEFAULTNOTOK;<br>   Q&larr; Md; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Q&larr; lo.word of A, and<br>   memBase&larr; StackBR, branch[.ubxBothdone]; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  restore memBase <br><br><br>:else; * Reduced<br><br>.unboxB:</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0],T&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * T&larr; Ahi<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL; CallUFN; SUBROUTINE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * B not SmallPosp<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T - (SmallHi);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0], Q&larr;Md, LEFT&larr; (LEFT) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * Q&larr; Alo<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL; CallUFN; SUBROUTINE;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) - (4c), Return;<br><br>:endif; <br><br>TOP LEVEL;<br><br>*--------------------------------------------------------------------<br>* BOX results</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Make a fixp of result in LTEMP0,,LTEMP1<br>*--------------------------------------------------------------------<br>:if[NotReduced];<br><br>.BOX2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], NARGS&larr; (2c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* NARGS "adjusts" TSP <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (LTEMP0) + 1, Branch[.box.1]; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  in CreateCell (cant<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  punt or fault when<br>.BOXretsmp:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  TSP is wrong)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Easy, when SMALLP<br><br>.BOX: GLOBAL,<br>* Enter with Hi word in LTEMP0 (and generally on Pd -- see "ALU" below)<br>*            Lo word in LTEMP1<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> memBase is StackBR<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">and with TSP "pulled back" over inputs, and LEFT decremented by 1<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], NARGS&larr; T - T; <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (LTEMP0) + 1, Branch[.box.1]; <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Trivial, if result is a non-negative SMALLP<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, Branch[.BOXretsmp];<br><br>.box.1:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Check for negative <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0], pd&larr; CELLHINUM&larr; LTEMP0; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  smallp&rsquo;s too<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallNegHi, <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.BOXretsmp];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0], CELLLONUM&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Check hi.word again  <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Shift masking can =&gt; <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.BOXretsmp];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* false non-0 alu test <br><br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Since TSP was "pulled back" upon entry, it must be restored.  So add<br>*  4 in the case of .BOX2 (4 words for 2 args), or 2 for .BOX<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (NARGS) + 1, membase&larr; dtdBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + T + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LShift[fixpType!, 4]c), branch[TL.CREATECELL];<br><br><br>:else;<br><br>.BOX2:</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>* If this code were to CallUFN, it would have to know exactly how many <br>* </span><span class="tab" val="24"></span><span style="font: 10pt monospace">args were originally passed in, in order to un-"pull-back" the stack. <br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Hence .BOX2 for 2 args, and .BOX for 1<br>.BOX:</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.box1b, alu#0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">.box1a:<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;<br>.box1b:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu#0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Check hi.word once more -- ALU problems on <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.box1a];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  LRSH might have it wrong upon entry</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; T, T&larr; Link, Call[SAVEUCODESTATE];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* This punt code just calls<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  MAKENUMBER<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; AT.MAKENUMBER, Goto[2ARGPUNT]; <br><br>:endif; <br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
