<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>LISPDMC.DM!1>LISPDEFS.mc</title>
  </head>
  <body>
    <div style="width: 489pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">:Title[LISPDEFS.mc];<br>*<br>* Edit History<br>* February 2, 1984  9:53 AM, JonL, let CallUFN also do SaveLink&larr; Link<br>* January 19, 1984  8:53 PM, JonL, added PS.INBLT flag<br>* January 13, 1984  11:25 PM, JonL, RME&rsquo;s for Fvar lookup, new RAM number<br>* January 9, 1984  9:17 PM, JonL, moved "DebugEachInst" conditional stuff<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">to under "Debugging".<br>* January 3, 1984  9:20 PM, JonL, added both "switched" GC punt names, <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">so this file can server both pre Dec 15 and Post Jan 3 files<br>* December 31, 1983  1:20 PM, JonL, CallUFN only branches to ufnPC,<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">for simpler usage; added RM defs for SignQR and SaveLink<br>* December 30, 1983  1:16 PM, JonL, Added NotReduced flag, and signBit constant<br>* December 20, 1983  8:54 AM, JonL, renamed AT.GCMAPTABLE and AT.HANDLEOVERFLOW<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">and added rme&rsquo;s for CELLHINUM, CELLLONUM<br>* November 9, 1983  4:18 PM, JonL, updated RamVersion number<br>*<br>:insert[LParams.mc];<br>set[Debugging, 0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 0 means NOT debugging, 1 means debugging<br>set[BreakPoints, 0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* debugging with midas<br>set[FNStats, sub[1,Debugging]];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* can gather function stats unless debugging<br>set[UPCStats, sub[1,Debugging]];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* cant gather microcode pc stats if debugging<br>set[Reduced,0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* reduced instruction set<br><br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">set[NOFLOATING, add[Reduced, Debugging]];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">set[NOFLOATING, 0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">set[NOBIN, Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">set[NOCREATECELL, Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">set[NORPLACS, Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">set[NotReduced, sub[1,Reduced]];<br>*--------------------------------------------------------------------<br>* version numbers - VERSION PILOTBITBLT + 0<br>*--------------------------------------------------------------------<br>set[RamVersion, add[12004, Debugging]];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* version number (+ 1 if debugging)<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fix StampD1uCode.cm when these change<br>set[RamMinBcplVersion, 21000];<br>set[RamMinLispVersion, 110400];<br><br><br>* check against values imported from LPARAMS.dmc<br><br>IFG[MinRamVersion!,RamVersion,ER[RamVersionTooLow]];<br>IFG[MinBcplVersion!,RamMinBcplVersion,set[RamMinBcplVersion,MinBcplVersion!]];<br>IFG[RamMinLispVersion, LispVersion!, ER[LispVersionTooLow]];<br><br>*--------------------------------------------------------------------<br>* RM regions<br>*--------------------------------------------------------------------<br>   SetRMRegion[RMForIFU];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*Lisp Emulator Registers<br><br>rvn[ESP];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 0</span><span class="tab" val="24"></span><span style="font: 10pt monospace">next stack block<br>rvn[FNStatsPtr];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 1</span><span class="tab" val="24"></span><span style="font: 10pt monospace">pointer to fn stat buffer<br>rvn[AllOnes];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 2    always -1 (not used much)<br>rvn[PSTATE];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 3<br>rvn[NARGS];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 4</span><span class="tab" val="24"></span><span style="font: 10pt monospace">#args<br>rvn[DEFHI];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 5</span><span class="tab" val="24"></span><span style="font: 10pt monospace">virtual address of function called<br>rvn[DEFLO];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 6<br>rvn[TSP];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 7</span><span class="tab" val="24"></span><span style="font: 10pt monospace">pointer to next available stack region<br>rvn[IVAR];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 10</span><span class="tab" val="24"></span><span style="font: 10pt monospace">pointer to current IVAR area<br>rvn[LEFT];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 11</span><span class="tab" val="24"></span><span style="font: 10pt monospace">number of (double words) of stack left<br>rvn[PVAR];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 12</span><span class="tab" val="24"></span><span style="font: 10pt monospace">pointer to current PVAR area<br>rvn[LTEMP4];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 13<br>rvn[LTEMP3];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 14 <br>rvn[LTEMP2];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 15<br>rvn[LTEMP1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 16</span><span class="tab" val="24"></span><span style="font: 10pt monospace">= DivTemp2  in DivSub from AEmu code<br>rvn[LTEMP0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 17</span><span class="tab" val="24"></span><span style="font: 10pt monospace">= MulTemp, DivTemp1<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[DivTemp1, LTEMP0];   <br><br>* for GC<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[PROBE, NARGS];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[CASE, DEFHI];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[ENTRY, DEFLO];<br><br>* for CREATECELL<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[CELLHINUM, DEFHI];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[CELLLONUM, DEFLO];<br><br>* for Free Variable lookup<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[FVEP, LTEMP1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[FVNAME, LTEMP2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[FVTMP, LTEMP3];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[FVCHAIN, LTEMP4];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[FVINDEX, NARGS];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[FVHI, DEFHI];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[FVLO, DEFLO];<br><br>* for numerical routines<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[SignQR, DEFLO];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Remembers the Sign of result in Mul and Div usages<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rme[SaveLink, DEFHI]; </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* unboxing subroutines need to save link over call<br><br>SetRMRegion[Region14]; <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[InstCount];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[InstBreak];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RVN[RANDNUM];<br><br>* REGISTER CONVENTIONS:<br>*  at "safe" points (i.e., after every opcode, whenever a page fault<br>*  can occur, and whenever a punt can occur,<br>*  the following conventions<br>*  hold:<br><br>*  IVAR  points to first IVAR word in basic frame<br>*  PVAR  points to first PVAR word in frame extension<br>*  TSP   points to the left word of the next slot in the current stack<br>*  ESP   points to the first (left) word of the next stack block<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> (i.e., tsp1+1 = esp means stack is empty)<br>*  PSTATE is 0 normally: -1 means in call, <br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">If debugging, </span><span class="tab" val="24"></span><span style="font: 10pt monospace">1 means PCX is invalid, <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">2 means that a page fault is ok<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[PS.HTCNTFULL, 20];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[PS.HTOVERFLOW, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[PS.INBCPL, 4];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[PS.PFOK, 2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[PS.PCXBAD, 1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[PS.INBITBLT, 40];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[PS.INBLT, 100];<br><br>*   In addition, between opcodes, <br>*   Left = (((ESP)-(TSP)) rsh 1) - LeftOffset;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[LeftOffset, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[MyFrameOffset, 100];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[BfPadded, 400];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[BfResidual, 1000];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FXFastReturn, 4000];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FXInCall, 2000];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FXNTValid, 1000];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FXNoPushReturn, 400];<br><br>* FX Fields:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.BFLAGS, -2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.IVAR, -1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.FLAGS, 0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.ALINK, 1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.DEFLO, 2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.DEFHI, 3];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.NEXT, 4];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.PC, 5];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.NTLO, 6];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.NTHI, 7];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.BLINK, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.CLINK, 11];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FX.PVAR, 12];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[FXDIF, sub[FX.#1!, FX.#2!]c];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[FXBACK, sub[FX.PVAR!, FX.#1!]c];<br><br>* FNHEADER fields<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FNH.STK, 0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FNH.NA, 1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FNH.PV, 2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FNH.START, 3];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FNH.NTSIZE, 6];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FNH.NLFV, 7];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[FNH.FIRSTNAME, 10];<br><br>*  DTD fields<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[DTD.NAME, 0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[DTD.SIZE, 1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[DTD.FREE, 2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[DTD.COUNTER, 14];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[DTD.NEXTPAGE, 15];<br><br>*--------------------------------------------------------------------<br>* Base Registers<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">brx[StackBR, 0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* beginning of stack<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">brx[StackM2BR, 1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* StackBR-2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">brx[ScratchLZBR, 2];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* BrLo= 0<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">brx[unused, 3];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* <br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[DefBR, 4];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* beginning of Def space<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[dtdBR, 5];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* pointer to DTD space<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[ufnBR, 6];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* UFN table<br> </span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[ListpDTDBR, 7];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* pointer to LISTP&rsquo;s DTD<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[tybaseBR, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* MDS type table<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[ZeroBR, 11];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* always zero<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[interfaceBR, 12];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* points to interface page<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[BBTableBR, 13];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* pointer to bitblt table<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[, 14];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* unused<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[, 15];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* unused<br><br>* the following must be an even-odd pair<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[htMainBR, 16];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* GC main reference count table<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[htOfloBR, 17];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* GC overflow table<br><br><br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[AChannelBR, 20];<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[TChannelBR, 21];   <br><br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[BBDstBR, 22];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* BitBlt destination base register<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[BBSrcBR, 23];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* BitBlt source base register<br><br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[BChannelBR, 24];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* used by display<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[Page1BR, 25];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* {mds, 400b},<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[ScratchBR, 26];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* general-purpose scratch register<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[PCHistBR, 27];<br><br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[DiskBR, 30];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Disk task base register<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[ECBR, 31];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Ethernet Command base register<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[EIBR, 32];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Ethernet Input base register<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[EOBR, 33];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Ethernet Output base register<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[LScratchBR, 34];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Lisp scratch register<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[ValSpaceBR, 35];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* point to value space<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[MDS, 36];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* {mds, 0} for Alto and Mesa<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">br[ifuBR, 37];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* code base (used by IFU)<br><br>*--------------------------------------------------------------------<br>* Various constants<br>*--------------------------------------------------------------------<br><br>* RESERVED ATOM NUMBERS<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.NIL, 0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.NOBIND, 1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.T, 114];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.EVALFORM, 370];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.GCMAPTABLE, 377];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.MAKENUMBER, 374];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.SETFVAR, 376];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.HANDLEOVERFLOW, 371];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.INTERPRETER, 400];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.MAKEFLOAT, 401];<br><br>* for GC<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[htStkCnt, add[htstkbit!, htcntmask!]];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.GCSCAN, 371];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Former "switched" meaning<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AT.GCOVERFLOW, 377];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Former "switched" meaning<br><br>* number spaces:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[SmallHi, smallpl!];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[SmallNegHi, smallneg!];<br><br><br>* other random things<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[MaxConsCount, 10000];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[StackEmpty, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Stkp for Stack Empty<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[signBit, 100000];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[rhmask, 377];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[lhmask, 177400];<br><br>* bcpl communication area<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[StatsBufferPtr, 200];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[StatsBufferBoundary, 1400];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[AemuRestartLoc, 206];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[SubrArgArea, 210];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[CALL.EVENT, 140000];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* hi pointer for a fn call<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[RETURN.EVENT, 177400];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* hi pointer for a return<br>*--------------------------------------------------------------------<br>* IFU definitions<br>*--------------------------------------------------------------------<br><br><br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[NextOpCode, Branch[NextOp]];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* go check PSTATE<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[PAGEFAULTOK, PSTATE&larr; (PSTATE) or (PS.PFOK)];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[PAGEFAULTNOTOK, PSTATE&larr; (PSTATE) and (not[PS.PFOK!]c)];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[PCXBAD, PSTATE&larr; (PSTATE) or (PS.PCXBAD)];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[CHECKPCX, Call[CHECKPCXSUBR]];<br>:else;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[NextOpCode, IFUjump[0]];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* dispatch to next instruction<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[PAGEFAULTOK,];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[PAGEFAULTNOTOK,];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[PCXBAD,];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[CHECKPCX,];<br>:endif;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[NoNdata, 17];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* no encoded data in IFU<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[regOP1, ifuREG[#1, 1, #2, 0, #3, #4, 0, 0]];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* reg. 1 byte <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[regOP2, ifuREG[#1, 2, #2, 0, #3, #4, 0, 0]];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* reg. 2 byte <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[regOP3, ifuREG[#1, 3, #2, 0, #3, #4, 0, 0]];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* reg. 3 byte <br><br>* ufn opcode - no microcode<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">M[UfnOps, IFUpause[#1, 1, ifuBR, 0, opUFN, NoNData, 0, 0]];<br><br>   Set[LispInsSet, 1];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">M[CallUFN, (SaveLink&larr; Link, Branch[ufnPC])];<br><br>:if[breakpoints];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">M[StackCheck, (Breakpoint) (RESCHEDULE)];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">M[UCodeCheck, (Breakpoint) Branch[UCODECHECKPUNT]];<br><br>:else;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">M[StackCheck, RESCHEDULE];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">M[UCodeCheck, (SaveLink&larr; Link, Branch[UCODECHECKPUNT])];<br><br>:endif;<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
