<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>LISPDMC.DM!1>LOPS.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">   :Title[LOPS];<br>* Edit history:<br>* March 5, 1984  7:30 PM, JonL, added opMISC1 (alpha 9) for opRWMufMan<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> (and retracted opRWMufMan as an opcode).  GLOBALized REPSMALLT<br>* February 18, 1984  2:47 PM, JonL, added opRWMufMan<br>* February 18, 1984  12:53 PM, JonL, fix parity of branch condition for<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> opEVAL of litatom; tried BDispatch in opEVAL again<br>* February 2, 1984  5:08 PM, JonL, opBIN checks bits[4:7] of BR for zero<br>* January 26, 1984  7:40 PM, JonL, spawned LLISTP off from this file;<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">opEVAL uses BDispatch.<br>* January 26, 1984  6:59 PM, JonL, opNOP and NEXTOP to LJUMP<br>* January 7, 1984  5:38 PM, JonL, added commentary on TYPEP<br>* January 6, 1984, 8:18 AM, JonL, fixed TL.CREATECELL to take an arg in<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS which is the number of words to "pull back" on TSP<br>* December 29, 1983  6:59 PM, JonL, "bubbled" inst in CREATECELL <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">{memBase&larr; StackM2BR, T&larr; TSP} into previous inst, and replaced <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">a few "0c"&rsquo;s with (atomHiVal)&rsquo;s;  changed (MaxConsCount) test in<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CREATECELL to use carry&rsquo;; TYPEP tails into REPSMT2; shortened BIN <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">by saving CCOFF in T over DOGETBYTE, and tailing into REPSMALLT<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Put error checking into WRITEPRINTERPORT; CDR tails into<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TL.PUSHNIL etc<br>* December 27, 1983  6:30 PM, JonL, changed calls to GCLOOKT1 into calls <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">to GCADDREF or GCDELREF<br>* December 26, 1983  6:53 PM, JonL, move in opEQ and opNOP from LOW,<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">let opEQ call ABFETCH and tail-out into TL.PUSHTRUE (or NIL)<br>* December 26, 1983  6:40 PM, JonL, fixed callers of TYPREV to watch out <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">for non-zero TT.*** bits<br>* December 21, 1983  5:15 AM, JonL, opRCLK from LOW, NEXTOP from from <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LSTACK, moved opPOP to LSTACK, tailed opNTYPX into REPSMALLT<br>* December 19, 1983  1:01 PM, JonL, TL.CREATECELL. Args in CELLHINUM and<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CELLLONUM <br>* December 15, 1983  3:42 PM, JonL, Put in labels REPSMALLT and TL.REPT<br>* November 29, 1983  4:42 PM, Masinter, change carry to &lt; on createcell<br><br>   KnowRBase[LTEMP0];<br>   TOP LEVEL;<br>   InsSet[LispInsSet, 1];<br><br><br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">TYPREV:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Get type of datum from cell being fetched from T<br>*--------------------------------------------------------------------<br>* Enter having done <br>*  T&larr; (fetch&larr; &lt;someLoc&gt;) + 1,   call[TYPREV];<br>* Exit with Ahi in LTEMP0<br>*           Alo in LTEMP1<br>*           typenumber in T<br><br>   T&larr; LTEMP0&larr; Md, fetch&larr; T;<br>   LTEMP1&larr; Md, memBase&larr; tybaseBR;<br>   T&larr; RCY[T, LTEMP1, 11];<br>   fetch&larr; T;<br>   T&larr; Md, memBase&larr; StackM2BR, return;<br><br>TOP LEVEL;<br><br><br><br>*--------------------------------------------------------------------<br>opEQ:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[ABFETCH];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, TSP&larr; (fetch&larr; T) - 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, pd&larr; T xor (LTEMP0);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], pd&larr; (T) xor (LTEMP1);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; (LEFT) + 1, branch[.neq];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.neq, alu#0], LEFT&larr; (LEFT) + 1;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), branch[TL.PUSHTRUE];<br>.neq:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), branch[TL.PUSHNIL];<br><br>regOP1[360, StackM2BR, opEQ, noNData];<br><br>*--------------------------------------------------------------------<br>opNTYPX:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1,   call[TYPREV];<br>   T&larr; T and (rhmask), Branch[</span><span style="font: 10pt monospace">REPSMALLT</span><span style="font: 10pt monospace">];<br><br><br>*--------------------------------------------------------------------<br></span><span style="font: 10pt monospace">REPSMALLT:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">GLOBAL,<br></span><span style="font: 10pt monospace">*--------------------------------------------------------------------<br>*  Smashes a smallp into the Top-of-Stack slot;<br>* </span><span class="tab" val="24"></span><span style="font: 10pt monospace">Assumes TSP is correct and StackM2BR is memBase<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; smallHi;<br>REPSMT2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;<br><br></span><span style="font: 10pt monospace">regOP1[4, StackM2BR, opNTYPX, noNData];<br><br><br>*--------------------------------------------------------------------<br>opDTEST:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* test if type name of tos = arg, ufn if not<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1, call[TYPREV];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; dtdBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch type name of DTD<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[T, 4];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* shifts TT.*** bits out<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FETCH&larr; T, T &larr; LTEMP0, RisID;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* This is really T&larr; (Id);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[T, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Get the litatom index<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Id) + T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T - (MD);<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* type disagree<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;<br><br>regOP3[6, StackM2BR, opDTEST, noNData];<br><br><br>*--------------------------------------------------------------------<br>opTYPEP:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* TYPEP, LISTP same code<br>*--------------------------------------------------------------------<br><br>%<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1, call[TYPREV];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and (rhmask);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (Id) xor T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0], T&larr; AT.NIL;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpcode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Continue if type same<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Otherwise, return NIL<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[TL.REPNIL2];<br>%<br><br>*  Try this code, if a huge speedup and space savings for LITATOM is<br>*   worth a 10% slowdown in the "true" cases of STRINGP, LISTP, etc<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1, call[TYPREV];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and (rhmask);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (Id) xor T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.typep1, alu#0], pd&larr; (LTEMP0) xor (atomHiVal);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], T&larr; AT.T;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpcode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Return arg if right type<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; smallHi, </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* But on LITATOMs, return T<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[REPSMT2];<br><br></span><span style="font: 10pt monospace"> .typep1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Return NIL when not of <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[TL.REPNIL2];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  the selected type<br><br><br>regOP1[3, StackM2BR, opTYPEP, listType!];<br>regOP2[5, StackM2BR, opTYPEP, noNData];<br><br><br>:if[Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UFNOPS[37];<br>:else;<br>*--------------------------------------------------------------------<br>opCREATECELL:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, CELLHINUM &larr; (fetch&larr; T) - T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* TOS = typenumber<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; NARGS&larr; T - (SmallHi);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Kludgy way to set <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], T&larr; Md, memBase&larr; dtdBR, </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  NARGS to 0 in the<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CELLLONUM &larr; T - T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  normal case.<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[T, 4];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 2&uarr;4 wds per entry<br><br>TL.CREATECELL:<br>* Enter with T has the datatype number multiplied by the number of <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">words per DTD entry;<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> DEFHI has hiword value for first cell<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> DEFLO has loword value for first cell<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> NARGS has the number of words to "pull back" on TSP<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> memBase is dtdBR<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + (DTD.FREE);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch free list<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch head of free list<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, T&larr; (fetch&larr; T) + <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">(sub[DTD.SIZE!, add[DTD.FREE!, 1]]c); <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP0, 1 &larr; freelist head<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; Cnt&larr; Md;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP3, Cnt &larr; size in wds<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, Cnt#0&-1], memBase&larr; ScratchLZBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UCodeCheck[allocateZeroSizeCell];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrHi&larr; LTEMP0;<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FETCH&larr; LTEMP1) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch contents of free<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, Cnt#0&-1], LTEMP4&larr; MD, T&larr; (fetch&larr; T) - (2c);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UCodeCheck[allocateOneSizeCell];<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; Md, T&larr; T + (LTEMP3);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* loloc+size-1<br><br>.clearnew:<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (STORE&larr; T) - 1, dbuf&larr; 0c, branch[., Cnt#0&-1];<br>PAGEFAULTNOTOK;<br>.cleardone:<br><br>* All but first word has been cleared. Store args into 1st and 2nd word<br>   T&larr; (store&larr; T) +1, dbuf&larr; CELLHINUM;<br>   store&larr; T, dbuf&larr; CELLLONUM;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP2, memBase&larr; dtdBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* store new free cell<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) - 1, dbuf&larr; LTEMP3;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, pd&larr; dbuf&larr; LTEMP4;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0], LTEMP2&larr; (LTEMP2) +<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> (sub[DTD.COUNTER!,add[1,DTD.FREE!]]c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   PSTATE&larr; (PSTATE) or (PS.HTCNTFULL);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* freelist became empty ?<br>   fetch&larr; LTEMP2;<br>   T&larr; (Md) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Add 1 to conscounter<br>   store&larr; LTEMP2, dbuf&larr; T;<br>   pd&larr; T - (MaxConsCount);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; NARGS, FreezeBC;<br>   branch[.+2, carry&rsquo;], T&larr; TSP&larr; (TSP) - T, memBase&larr; StackM2BR;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Exceeded MaxConsCount allocations of this type ?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   PSTATE&larr; (PSTATE) or (PS.HTCNTFULL);</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br><br>* Result is address of newly allocated cell, which is smashed onto TOS<br>   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;<br>   store&larr; T, dbuf&larr; LTEMP1;<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DELREF on new cell, so implicit refcnt of 1 goes to 0<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Case&larr; 1c, Call[GCLOOKUP1];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>   LTEMP4&larr; (4c), Branch[GCOPTAIL];<br><br>regOP1[37, StackM2BR, opCREATECELL, noNData];<br>:endif;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br><br><br>:if[Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[40];<br>:else;<br><br>*--------------------------------------------------------------------<br>opBIN:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1, call[TYPREV];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* returns with type in T<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Flush TT.*** bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; (Id) xor T, memBase&larr; ScratchLZBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Set ScratchLZR to base of<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0], BrHi&larr; LTEMP0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  segment containg STREAMP<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Arg not a STREAMP ?<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FETCH&larr; LTEMP1) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; MD, T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP0 &larr; CCOFF<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, LTEMP2&larr; (fetch&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T &larr; NCCHARS<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, pd&larr; T - (Q&larr; LTEMP0) - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP0 &larr; HiBuf, Q  &larr; CCOFF<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* also pd&larr; NCCHARS-CCOFF-1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, carry], LTEMP2&larr; (fetch&larr; LTEMP2) - (3c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Punt -- end of bufload<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&lt;0], LTEMP0, memBase&larr; ScratchBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Punt -- readable bit off<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, pd&larr; (LTEMP0) and (7400c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0], BrHi&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[ExtraBitsInBufferAddress];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* BR setup to base of buffer<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrLo&larr; T, T&larr; LTEMP1&larr; Q, Call[.getByte];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  and actually fetch byte<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; ScratchLZBR, T&larr; T + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Now increment CCOFF<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; LTEMP2, dbuf&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackM2BR, T&larr; LTEMP1, Branch[REPSMALLT];<br><br>regOP1[40, StackM2BR, opBIN, streamType!];<br><br>:endif; <br><br>*--------------------------------------------------------------------<br>opMISC1:<br>*--------------------------------------------------------------------<br>* One arg miscellaneous opcode<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ID;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (T) - (11c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[opRWMufMan, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ucodeCheck[BadMISC1AlphaByte];<br><br>regOP2[170, StackM2BR, opMISC1, noNData];<br><br>*--------------------------------------------------------------------<br>opRWMufMan:<br>*--------------------------------------------------------------------<br>* One arg, a PosSMALLP, whose low-order 11 bits are a Muffler/Manifold<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">address.  If the high-order bit (i.e., 2&uarr;15) is off, then read the<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">the addressed muffler and return it&rsquo;s bit as the high-order bit of<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">a PosSMALLP; if it is on, then execute the corresponding Manifold<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">operation and return NIL.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; 13s;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; LTEMP0, Cnt&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0],TSP&larr; (TSP) + (2c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Restore TSP<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUfn;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">flipMemBase;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Both exits expect memBase <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  to be StackM2Br<br>.rwmmlp:</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">MidasStrobe&larr; Q;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 11. iterations of strobe<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q lsh 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  and shift<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">nop;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.rwmmlp, Cnt#0&-1];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&gt;=0], LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Don&rsquo;t do flipMembase here, <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UseDMD, Branch[REPNIL];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  because that constrains <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ALUFMEM, Branch[REPSMALLT];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  too many locations<br><br><br><br><br>*--------------------------------------------------------------------<br>opRCLK:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1;<br>   LTEMP0&larr; Md, fetch&larr; T, T&larr; (30c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP0 &larr; HiAddr to clobber<br>   LTEMP1&larr; Md, memBase&larr; MDS;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP1 &larr; LoAddr to clobber<br>   T&larr; T + (400c);<br>   taskingOff;<br>   fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch word 430 for hi part of clock<br>   LTEMP2&larr; Md, rbase&larr; rbase[RTClock];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP2 &larr; hiword of clock<br>   T&larr; RTClock;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T &larr; loword of clock<br>   taskingOn;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>   rbase&larr; rbase[LTEMP0];<br>   memBase&larr; ScratchLZBR;<br>   BrHi&larr; LTEMP0;<br>PAGEFAULTOK;<br>   LTEMP1&larr; (store&larr; LTEMP1) + 1, dbuf&larr; Md;<br>PAGEFAULTNOTOK;<br>   store&larr; LTEMP1, dbuf&larr; T, nextOpCode;<br><br>regOP1[167, StackM2BR, opRCLK, noNData];<br><br><br>*--------------------------------------------------------------------<br>opREADPRINTERPORT:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; NOT(EventCntA&rsquo;), branch[PUSHSMALLT];<br>regOP1[164, StackM2BR, opREADPRINTERPORT, noNData];<br><br>*--------------------------------------------------------------------<br>opWRITEPRINTERPORT:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Using .UNBOX1 here <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  would only save 1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T - (SmallHi), T&larr; Md;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  IM loc, but cost<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  an extra 3 cycles<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUfn;<br>   EventCntB&larr; T, NextOpCode;<br><br>regOP1[165, StackM2BR, opWRITEPRINTERPORT, noNData];<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace"><br>:if[Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[54];<br>:else;<br><br>regOP1[54, StackM2BR, opEVAL, noNData];<br>*--------------------------------------------------------------------<br>opEVAL:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1, call[TYPREV];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T and (370c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Only the first 8 type codes <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0], T&larr; T and (7c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  are handled by ucode<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BDispatch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.evdispatch];<br>.evdispatch:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">DispTable[10],<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUfn;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Type 0 is randomness<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Smallp<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Fixp<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Floatp<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FVNAME&larr; pd&larr; (LTEMP1), Branch[.evatom];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Litatom.  "xor (AT.NIL)"<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; (1c), Branch[.evListp];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Listp<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Arrayp<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Stringp<br><br>%<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T - (atomType);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.evalatom, alu=0], pd&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.evalother, alu=0], pd&larr; T - (add[FixpType!, 1]c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.evalret, alu&lt;0], pd&larr; T - (ListType);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.evListp, alu=0], NARGS&larr; 1c;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* not atom, fixp, listp<br>.evalother:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* let UFN decide<br>.evalret: NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* return self<br>.evalatom:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FVNAME&larr; pd&larr; (LTEMP1);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* "xor (AT.NIL)"<br>%<br><br>.evatom:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu#0], pd&larr; (FVNAME) xor (AT.T);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* eval of NIL=NIL<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu#0], T&larr; (FX.PVAR);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* eval of T=T<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">nop;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Call can be false target of conditional branch<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FVEP&larr; (PVAR) - T, Call[DOLOOKUP];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; ScratchLZBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrHi&larr; FVHI;<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FETCH&larr; FVLO) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Might fault, since it <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  may be global cell<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (FVHI) - (StackHi);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu#0], memBase&larr; StackM2BR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[REPTMD1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Stack-bound value is OK<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (add[AT.NOBIND!]s) xor (Md);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[REPTMD1, alu#0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Global binding ok<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Hmmm, NOBIND in topcell<br><br>.evListp:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; AT.EVALFORM, Branch[DOCALLPUNT];<br><br>:endif;<br><br><br>REPTMD:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackM2BR;<br>* Replace value on top of stack with value in T,,MD<br>:if[Debugging];<br>REPTMD1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T and not (77c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[badpushval];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T;<br>:else;<br>REPTMD1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T;<br>:endif;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpcode;<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
