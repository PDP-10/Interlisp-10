<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>uCode>LISPDMC.DM!1>LISP0.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">:Title[Lisp0];<br>*<br>* Edit History<br>* February 18, 1984  4:54 PM, JonL, SAVEUCODESTATE uses SubrArgArea<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">instead of statsBuffer<br>* January 31, 1984  7:31 PM, JonL, embellish SAVEUCODESTATE<br>* January 31, 1984  5:05 PM, Masinter, add SAVEUCODESTATE as subroutine<br>* January 23, 1984  6:51 PM, JonL, debugging previous change<br>* January 20, 1984  6:26 AM, JonL, added check for BLT in pageFault<br>* January 4, 1983  2:48 PM, Masinter<br>*  - - -  Willie-Sue<br><br>:insert[DisplayDefs.mc];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">mc[max.pvar.for.fault, 3000];<br>* Code for Interface with BCPL<br><br>   KnowRBase[LTEMP0];<br>   TOP LEVEL;<br>   InsSet[LispInsSet, 1];<br><br>   mc[UCODE.CHECK, 0];<br>   mc[STKOV.PUNT, sub[0,SubovFXP!]]; * says context switch to Subov<br>   mc[NWW.INTERRUPT, 2];<br>   mc[PAGE.FAULT, sub[0,FAULTFXP!]];<br>   mc[STATS.PUNT, 4];<br><br>*--------------------------------------------------------------------<br>opSUBR:   <br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Id; <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP2&larr; Id;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Beta byte is # args<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; TSP&larr; (TSP) - (Cnt&larr; T);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Move args from stack<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; SubrArgArea, Branch[.subr1];<br><br>.subr0:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Tight loop to move args <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; MDS;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  from stackframe to the<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; (store&larr; LTEMP1)+ 1, dbuf&larr; Md;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  BCPL subr arg area<br>.subr1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR, branch[.subr0, Cnt#0&-1];<br><br>   LTEMP1&larr; (Id) - (PCX&rsquo;) - 1, branch[.storepuntpc];<br><br>IFUpause[175, 3, StackBR, 0, opSUBR, noNData, 0, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*SUBRCALL<br><br>*--------------------------------------------------------------------<br>opCNTXTSWITCH:<br>*--------------------------------------------------------------------<br>   T&larr; (TSP) - 1;<br>   TSP&larr; (fetch&larr; T) - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch arg<br>   rbase&larr; rbase[NWW];<br>   T&larr; Md, NWW&larr; (NWW) and not (100000c);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* turn on interrupts<br>   pd&larr; NWW, rbase&larr; rbase[LTEMP0];<br>   branch[.+2, alu=0], LTEMP0&larr; (0s) - T; * LTEMP0&larr; - (context#)<br>   pd&larr; LTEMP0, RescheduleNow;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* reschedule if int pending...<br>   LTEMP1&larr; (Id) - (PCX&rsquo;) - 1, branch[.storepuntpc];<br><br>IFUpause[176, 1, StackBR, 0, opCNTXTSWITCH, noNData, 0, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*CNTXTSWITCH<br><br>*--------------------------------------------------------------------<br>UCODECHECKPUNT: GLOBAL,  <br>*--------------------------------------------------------------------<br><br>* call: SaveLink&larr; Link, Branch[uCodeCheckPunt];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; T, T&larr; Link, Call[SAVEUCODESTATE];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* First, save state;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; SubrArgArea;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Then, set up ucode<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; (store&larr; LTEMP4) + 1, dbuf&larr; SmallHi;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  address of punter<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; (store&larr; LTEMP4) + 1, dbuf&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  as arg to BCPL subr<br>   LTEMP2&larr; 1c;<br>   LTEMP0&larr; UCODE.CHECK, branch[BCPLEXIT];<br><br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">SAVEUCODESTATE: GLOBAL,<br>*--------------------------------------------------------------------<br>* Clobbers LTEMP4 and BR<br>* Called by<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rbase&larr; rbase[LTEMP0];<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">KnowRBase[LTEMP0];<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; T, T&larr; Link, Call[SAVEUCODESTATE];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; MDS;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Save some volatile<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q&larr; LTEMP4;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  ucode regs in stats<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; (220c); <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; (store&larr; LTEMP4) + 1, dbuf&larr; (125377c);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 0  PassWord<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; (store&larr; LTEMP4) + 1, dbuf&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 1  Link at call here<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Link;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; LTEMP4) + 1, dbuf&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 2  ucode.addr + 1 of<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RBase&larr;rbase[FLTEMUPC];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*     of call to here<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr;(store&larr; T) + 1, dbuf&larr; FLTEMUPC;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 3  PC at fault<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RBase&larr;rbase[LTEMP0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; SaveLink;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 4  maybe saved link<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP3;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 5  T register<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 6  LTEMP0<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 7  LTEMP1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; PVAR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 10 PVAR<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; TSP;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 11 TSP<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; PSTATE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 12 PSTATE<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; DEFLO;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 13 DEFLO<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; NARGS;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 14 NARGS<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; Q;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 15 LTEMP4<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP3, Return;<br>TOP LEVEL;<br><br>*--------------------------------------------------------------------<br>RAIDPUNT:<br>*--------------------------------------------------------------------<br><br>* like UCODEPUNT, but registers are OK;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RBase&larr; rbase[LTEMP0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; MDS;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; SubrArgArea;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (store&larr; LTEMP0) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; LTEMP0, dbuf&larr; 0c;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; 1c;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; UCODE.CHECK, Branch[PUNT];<br><br>*--------------------------------------------------------------------<br>STKOVPUNT:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; STKOV.PUNT, branch[.puntz];<br><br>*--------------------------------------------------------------------<br>STATSPUNT:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; STATS.PUNT, branch[.puntz];<br><br>*--------------------------------------------------------------------<br>NWWPUNT:* old NWW: exit to BCPL w/reschedule still set<br>*--------------------------------------------------------------------<br>   rbase&larr; rbase[LTEMP0];<br>   LTEMP0&larr; NWW.INTERRUPT, branch[.puntz]; <br><br>*--------------------------------------------------------------------<br>KEYPUNT: KnowRBase[NWW]; * new NWW: context switch to KBD context<br>*--------------------------------------------------------------------<br>   NWW&larr; (100000c); * turn off interrupts<br>   rbase&larr; rbase[LTEMP0];<br>   LTEMP0&larr; sub[0, KbdFXP!]c, branch[.puntz];<br><br>.puntz:<br>   LTEMP2&larr; A0, branch[PUNT];<br><br>*--------------------------------------------------------------------<br>PAGEFAULTPUNT:<br>*--------------------------------------------------------------------<br>   rbase&larr; rbase[FltPipe0];<br>   memBase&larr; InterfaceBR;<br>   T&larr; IFPFAULTHI;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; FltPipe0;<br>   store&larr; T, dbuf&larr; FltPipe1;<br>   rbase&larr; rbase[LTEMP0];<br>* Check first for pagefault while "in function call" (which is OK).<br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&gt;=0], pd&larr; (PSTATE) and (PS.PFOK);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.pfp1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* OK to fault in fn call. No constraint on .pfp1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu#0], pd&larr; (PSTATE) and (add[PS.INBITBLT!, PS.INBLT!]c);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[PageFaultWhenNotOK];<br>:else;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (PSTATE) and (add[PS.INBITBLT!, PS.INBLT!]c), </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PSTATE is -1<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&gt;=0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  in fn call<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.pfp1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* OK to fault in fn call. No constraint on .pfp1<br>:endif;<br>* Check also for fault in BLT or BITBLT (which need stack patchup).<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.pfp1, alu=0], PSTATE, pd&larr; (PSTATE) and (PS.INBLT);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0], memBase&larr; StackBR, T&larr; (TSP) - 1; <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">stack&larr; (stack) + 1;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PSTATE&larr; A0, store&larr; T, dbuf&larr; Stack, Branch[.pfp1]; <br>.pfp1:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">** check for page fault in page fault context<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (PVAR) - (max.pvar.for.fault);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, carry], LTEMP0&larr; PAGE.FAULT;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[PageFaultRecursion];<br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rbase&larr; rbase[NWW];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&gt;=0], NWW, rbase&larr; rbase[LTEMP0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[NWW?];<br>:endif;<br>.pfp2:<br>   LTEMP2&larr; A0, branch[PUNT];<br><br><br><br>*--------------------------------------------------------------------<br>* common punt code<br>*--------------------------------------------------------------------<br>PUNT:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[FLAGS]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR, PSTATE, branch[.normalpunt, R&gt;=0];<br><br>* punt in call<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T, LTEMP1&larr; FXInCall;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; (LTEMP1) or Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; LTEMP1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; NARGS;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; 0c;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* can&rsquo;t fault if DEFHI nonzero<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; T) + 1, dbuf&larr; DEFLO, branch[.puntfixstack];<br><br>.normalpunt:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T, LTEMP1&larr; FXNoPushReturn;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; (LTEMP1) or Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; LTEMP1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; not (PCX&rsquo;);<br><br>.storepuntpc: </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* from SUBR and context switch, too<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[PC]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; LTEMP1;<br><br>   <br>.puntfixstack:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[NEXT]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, T&larr; dbuf&larr; TSP;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* store NEXT<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (ESP) - T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, carry], TSP&larr; (store&larr; TSP) + 1, dbuf&larr; FreeStackBlock;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[NoStackAtPunt];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; TSP, dbuf&larr; T;<br><br>* LTEMP0 = punt or subr#, or else (- context#)<br>* LTEMP2  = number of args<br>* PVAR ok<br><br>BCPLEXIT:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; interfaceBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PVAR&larr; (PVAR) - (FX.PVAR);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.ctxswitch, R&lt;0], Q&larr; LTEMP0;<br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PSTATE&larr; (PS.INBCPL);<br>:endif;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; add[CurrentFXP!]s, dbuf&larr; PVAR;<br>:if[FNStats];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], FnStatsPtr;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.bcplxend];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">nop;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Following Call constrains addresses<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; Q, Call[.subrstat];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; MDS;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; StatsBufferPtr;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; FnStatsPtr, Branch[.bcplxend];<br>:endif; * FNStats<br><br>.bcplxend:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP2, rbase&larr; rbase[spAC0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP&larr; spAC2;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&+1&larr; Q;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* value for AC2 Punt or subr #<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&-1&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* # of args<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; AemuRestartLoc, branch[start];<br><br>KnowRBase[LTEMP0];<br><br>.ctxswitch:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (0s) - (LTEMP0);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* context#<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;<br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PSTATE&larr; (PS.PCXBAD);<br>:else;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PSTATE&larr; A0;<br>:endif;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PVAR&larr; Md, store&larr; T, dbuf&larr; PVAR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PVAR&larr; (PVAR) + (FX.PVAR), branch[RTN2];<br><br><br>:if[FNStats];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">SUBROUTINE;<br><br>*--------------------------------------------------------------------<br>* Stats writing<br>*--------------------------------------------------------------------<br><br>.subrstat:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFHI&larr; A0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[LTEMP2, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T or (CALL.EVENT), branch[.storestat];<br><br>FNSTAT: * fn in LTEMP0, 1, NARGS set.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0, memBase&larr; MDS;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LCY[T, NARGS, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T or (CALL.EVENT);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; FnStatsPtr) + 1, dbuf&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, branch[.stattail];<br><br>.storeretstat:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (RETURN.EVENT), branch[.storestat];<br><br>.storestat:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T or (DEFHI), memBase&larr; MDS;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; FnStatsPtr) + 1, dbuf&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; DEFLO;<br>.stattail:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FnStatsPtr&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; 30c;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + (400c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TaskingOFF;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; FnStatsPtr) + 1, dbuf&larr; Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RBase&larr; RBase[RTClock];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; RTClock;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TaskingON;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RBase&larr; RBase[FnStatsPtr];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FnStatsPtr&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T - (StatsBufferBoundary);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu&lt;=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ReSchedule;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Return;<br><br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOP LEVEL;<br><br>:endif; * FNStats<br><br><br>*--------------------------------------------------------------------<br><br>   KnowRBase[AEmRegs];<br>   m[MBXI, KnowRBase[AEmRegs]<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   Top level];<br><br>LTrap:<br>   ETEMP2&larr; Id, call[GetPC];<br>   pd&larr; (ETEMP2) - (20c);<br>   branch[.+2, alu&lt;0], ETEMP4&larr; T + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[NPTrap]; <br>   BigBdispatch&larr; ETEMP2;<br>   branch[LTrapDispatch], StkP&larr; spAC0;<br><br><br>EmuNext:<br>   rbase&larr; rbase[AEmRegs], global;<br>   T&larr; ETEMP4, branch[start];<br><br>EmuSkip:<br>   rbase&larr; rbase[AEmRegs];<br>   T&larr; (ETEMP4) + 1, branch[start];<br><br>*--------------------------------------------------------------------<br>* arrive at the Lisp dispatch locations with StkP&larr; spAC0 <br>*--------------------------------------------------------------------<br><br>LTrapDispatch:<br>   branch[MBIX], dispTable[20];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   00<br>   branch[ReadFlags];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   01<br>   branch[SetFlags];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   02<br>   branch[XferPage];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   03<br>   branch[BGetBase];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   04<br>   branch[BPutBase];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   05<br>   branch[BGetBase32];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   06<br>   branch[BGetBasePtr];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   07<br>   branch[BPutBase32];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   10<br>   branch[InitLispRegs];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   11<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&larr; A0, branch[EmuNext];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   12   GetRamVersion<br>   branch[NPTrap];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   13   was GetFXP<br>   branch[NPTrap];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   14   was SetFXP<br>   branch[uPCTrace];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   15<br>   branch[XBitBlt];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   16<br>   branch[NPTrap];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   17 was CallFN<br><br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>MBIX:   rbase&larr; rbase[LTEMP1];<br>   LTEMP0&larr; Stack&+1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* AC0: hi part of return value<br>   LTEMP1&larr; Stack;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* AC1: lo part of return value<br><br>:if[Debugging];<br>   PSTATE&larr; (PS.PCXBAD);<br>:else;<br>   PSTATE&larr; A0;<br>:endif;<br><br>:if[FNStats];<br>   rbase&larr; rbase[PVAR];<br>   T&larr; StatsBufferPtr;<br>   memBase&larr; MDS;<br>   fetch&larr; T;<br>   FnStatsPtr&larr; Md;<br>   pd&larr; FnStatsPtr;<br>   branch[.+2, alu#0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FnStatsPtr&larr; -1c;<br><br>:else;<br>   FnStatsPtr&larr; T-T-1;<br>   memBase&larr; MDS;<br>:endif;<br><br>* memBase=MDS<br>   rbase&larr; rbase[NWW];<br>   T&larr; (R400) + (52C);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* WW (= 452B)<br>   fetch&larr; T, T&larr; (100000C);<br>   T&larr; (Md) and not (T);<br>   NWW &larr; (NWW) or T;<br>   branch[.+2, alu=0], rbase&larr; rbase[LTEMP0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Reschedule;<br><br>   T&larr; add[100000, LShift[LispInsSet, 10]]c;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* set InsSet<br>   InsSetOrEvent&larr; T;<br><br>   MemBX&larr; 0s;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* SET MemBX<br><br>   T&larr; StackEmpty;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* set StkP<br>   StkP&larr; T;<br><br>   memBase&larr; interfaceBR;<br>   fetch&larr; add[CurrentFXP!]s;<br>   PVAR&larr; Md;<br>   PVAR&larr; (PVAR) + (FX.PVAR), branch[RTN2];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>ReadFlags:<br>   call[flushVp], T&larr; Stack;<br>   RMap&larr; ETEMP3, call[waitforMapBuf];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* uses T only<br>   Stack&+1&larr; not (Map&rsquo;);<br>   T&larr; not (Pipe4&rsquo;);<br>   Stack&-1&larr; T and (m1pipe4.wpdref),</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* wp, d, & ref from pipe4<br>   branch[EmuNext];<br><br><br>   KnowRBase[LTEMP0];<br><br>*--------------------------------------------------------------<br>opREADFLAGS:<br>   T&larr; (TSP) - 1;<br>   fetch&larr; T;<br>   call[flushVp], T&larr; Md, rbase&larr;rbase[ETEMP3]; <br>   RMap&larr; ETEMP3, call[waitforMapBuf];<br><br>   pd&larr; Id, rbase&larr; rbase[TSP];<br>   branch[.+2, alu=0], LTEMP0&larr; not (Pipe4&rsquo;);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; not (Map&rsquo;), branch[.readtail];<br>   LTEMP0&larr; (LTEMP0) and (m1pipe4.wpdref), branch[.readtail];<br><br>.readtail:<br><br>   T&larr; (Id) - (PCX&rsquo;) - 1;<br>   PCF&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* restart IFU<br>   T&larr; (TSP) - 1, memBase&larr; StackBR;<br>   store&larr; T, dbuf&larr; LTEMP0, NextOpCode;<br><br>regOP1[161, StackBR, opREADFLAGS, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* readflags<br>regOP1[162, StackBR, opREADFLAGS, 1];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* readrp<br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>SetFlags:<br>   StkP&larr; spAC2; <br>   T&larr; (Stack&-2) + (3c);<br>   fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch flags<br>   ETEMP2&larr; Md, T&larr; Stack&+1, call[flushVP];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*flush cache<br>   T&larr; lsh [ETEMP2, 2];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* position the wp&dirty bits<br>   T&larr; T and (TIOAvacantMapEntry);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* mask out any extra bits<br>   T&larr; Stack&-1, TIOA&larr; T;<br>   B&larr; T, TASKINGOFF;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* get bmux stable for Map&larr;<br>   Map&larr; ETEMP3, B&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* write the map<br>   TASKINGON;<br>   call[waitforMapBuf], TIOA&larr; ETEMP3;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* clear TIOA<br><br>* flushVp did one IFUReset, must do a second<br><br>   branch[.+2, R&gt;=0], ETEMP2, IFUReset;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* check for ref bit<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; ETEMP3;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* reference it<br>   branch[EmuNext];<br><br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>FlushVP:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* vp is in T, uses ETEMP3, sets memBase<br>   memBase&larr; LScratchBR, B&larr; Md;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* finish any stores<br>   IFUreset;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* stop IFU from making refs<br>   ETEMP3&larr; lsh[T, 10];<br>   T&larr; rsh[T, 10];<br>   BrHi&larr; T;<br>   BrLo&larr; ETEMP3;<br>   T&larr; 360C;<br><br> FlushVPLoop:   flush&larr; T;<br>   T&larr; T - (20C);<br>   branch[FlushVPLoop, alu&gt;=0];<br>   B&larr; Md, ETEMP3&larr; A0, return;<br><br>TOP LEVEL;<br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>XferPage: <br>   call[setXferBR], memBase&larr; BBDSTBR, T&larr; Stack&+1;<br>   call[setXferBR], memBase&larr; BBSRCBR, T&larr; Stack&-1;<br>   T&larr; rhmask;<br>   Cnt&larr; T;<br>   fetch&larr; T, flipMemBase;<br>   T&larr; (store&larr; T) - 1, dbuf&larr; Md, flipMemBase, branch[.-1, Cnt#0&-1];<br>   branch[EmuSkip];<br><br>SUBROUTINE;<br><br>setXferBR:<br>   ETEMP3&larr; RSH[T, 10];<br>   BrHi&larr; ETEMP3;<br>   ETEMP3&larr; LSH [T, 10];<br>   BrLo&larr; ETEMP3, return;<br>TOP LEVEL;<br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>BGetBase: <br>   call[BFetch];<br>   Stack&larr; Md, branch[EmuSkip];<br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>BGetBase32:<br>   call[BFetch];<br>   Stack&+1&larr; Md;<br>   fetch&larr; 1s;<br>   Stack&larr; Md, branch[EmuSkip];<br><br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>BGetBasePtr: T&larr; rhmask;<br>   call[BFetch];<br>   Stack&+1&larr; T and (Md);<br>   fetch&larr; 1s;<br>   Stack&larr; Md, branch[EmuSkip];<br><br>SUBROUTINE;<br>BFetch:<br>   memBase&larr; LScratchBR;<br>   BrHi&larr; Stack&+1;<br>   BrLo&larr; Stack&-1;<br>   fetch&larr; 0s, return;<br>TOP LEVEL;<br><br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>BPutBase: <br>   StkP&larr; spAC2;<br>   T&larr; (Stack&-2) + (3c);<br>   fetch&larr; T;<br>   T&larr; Md, call[BStore], memBase&larr; LScratchBR;<br>   B&larr; Md, branch[EmuSkip];<br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>BPutBase32: <br>   StkP&larr; spAC2;<br>   T&larr; (Stack&-2) + (3c);<br>   fetch&larr; T;   <br>   T&larr; Md;<br>   T&larr; (fetch&larr; T) + 1;<br>   T&larr; Md, fetch&larr; T;<br>   call[BStore], ETEMP2&larr; Md, memBase&larr; LScratchBR;<br>   T&larr; ETEMP2;<br>   store&larr; 1s, dbuf&larr; T, branch[EmuSkip];<br><br>*--------------------------------------------------------------------<br>SUBROUTINE;<br>BStore:<br>   BrHi&larr; Stack&+1;<br>   BrLo&larr; Stack&-1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* restore to AC0<br>   store&larr; 0s, dbuf&larr; T, return;<br>TOP LEVEL;<br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>InitLispRegs:<br><br>   rbase&larr; rbase[RMForIFU];<br><br>   MemBX&larr; 0s;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* SET MemBX<br><br>   AllOnes&larr; T-T-1;<br><br>:if[Debugging];<br>   PSTATE&larr; (PS.INBCPL);<br>:endif;<br><br>   T&larr; DTDspace;<br>   LTEMP0&larr; DTDbase;<br>   memBase&larr; dtdBR, call[setBR];<br><br>   LTEMP0&larr; (LTEMP0) + (lshift[ListType!, 4]c);<br>   memBase&larr; ListpDTDBR, call[setBR];<br><br>   T&larr; STATSspace;<br>   LTEMP0 &larr; MDSTYPEbase;<br>   memBase&larr; tybaseBR, call[setBR];<br><br>   LTEMP0 &larr; UFNTablebase;<br>   memBase&larr; ufnBR, call[setBR];<br><br>   T&larr; stackHI;<br>   LTEMP0 &larr; A0,<br>   memBase&larr; StackBR, call[setBR];<br><br>   T&larr; T - 1;<br>   LTEMP0&larr; (LTEMP0) - (2c);<br>   memBase&larr; StackM2BR, call[setBR];<br><br>   T&larr; VALspace;<br>   LTEMP0&larr; A0,<br>   memBase&larr; ValSpaceBR, call[setBR];<br><br>   T&larr; A0;<br>   LTEMP0&larr; A0,<br>   memBase&larr; ZeroBR, call[setBR];<br><br>   LTEMP0&larr; A0,<br>   memBase&larr; ScratchLZBR, call[setBR];<br><br>   T&larr; DEFspace;<br>   LTEMP0&larr; A0,<br>   memBase&larr; DefBR, call[setBR];   <br><br>   T&larr; HTMAINspace;<br>   LTEMP0&larr; HTMAINbase;<br>   memBase&larr; htMainBR, call[setBR];<br><br>   LTEMP0&larr; HTOVERFLOWbase;<br>   memBase&larr; HTOfloBR, call[setBR];<br><br>   T&larr; INTERFACEspace;<br>   LTEMP0&larr; INTERFACEbase;<br>   memBase&larr; interfaceBR, call[setBR];<br><br>   memBase&larr; MDS;<br>   T&larr; and[RamVersion, 177400]c;<br>   T&larr; T + (and[RamVersion, 377]c);<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;<br><br>   T&larr; and[RamMinBcplVersion, 177400]c;<br>   T&larr; T + (and[RamMinBcplVersion, 377]c);<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;<br><br>   T&larr; and[RamMinLispVersion, 177400]c;<br>   T&larr; T + (and[RamMinLispVersion, 377]c);<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;<br><br>* now initialize/find out display width<br><br>   rbase&larr; rbase[DisplayConfig];<br>   T&larr; OR[177400, MaxWidthWordsAlto!]C, DisplayConfig,<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[ILRDisp, R even];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Branch if Alto monitor<br><br>* Switch to using the entire width of the LF monitor:<br><br>   DisplayConfig&larr; (DisplayConfig) OR (2C);<br>   T&larr; Or[177400, MaxWidthWordsLF!]C;<br><br>* T has the new words/scanline<br>* 377 in the LH to signal DHT to reinitialize.<br><br>   MaxWidthWords&larr; T;<br><br>ILRDisp:<br>   T&larr; T AND (377C);<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;<br><br>   rbase&larr; rbase[RealPages];<br>   T&larr; RealPages;<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* # pages<br>   T&larr; 2000c;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* "dummy" #pages/module <br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T,</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* (doesn&rsquo;t matter)<br>   branch[EmuNext];<br><br>SUBROUTINE;<br><br>   KnowRBase[LTEMP0];<br>setBR:<br>   BrHi&larr; T;<br>   BrLo&larr; LTEMP0, return;<br>TOP LEVEL;<br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>uPCTrace:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* ignore<br>   branch[EmuNext];<br><br>MBXI;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*--------------------------------------------------------------<br>XBitBlt:<br>   T&larr; (fetch&larr; Stack&+2) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* get pointer from Ac0<br>   T&larr; Md, fetch&larr; T;<br>   Stack&+1&larr; A0, memBase&larr; LScratchBR;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* TOS == AC3, BBTable (AC2) = 0<br>   BrHi&larr; T, T&larr; Md;<br>   BrLo&larr; T;<br>   ETEMP4&larr; (ETEMP4) + 1, SCall[BitBltSub];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* increment PC<br>   ETEMP4&larr; (ETEMP4) - 1, branch[EmuNext];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* interrupt, return .+1<br>   ETEMP4&larr; (ETEMP4) + 1, branch[EmuNext];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* normal exit, return .+3<br><br><br>*--------------------------------------------------------------<br>   TOP LEVEL;<br>   knowrbase[LTEMP0];<br>   InsSet[LispInsSet, 1];<br><br>opUPCTRACE:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T; rbase&larr; rbase[Events];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q&larr; Md, call[SetPCHistAddr];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;<br><br>regOP1[377, StackM2BR, opUPCTRACE, noNData];<br><br><br>*--------------------------------------------------------------<br>* Memory system initialization stubs for lisp<br><br><br><br>InitMapWarm:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[ResumeEmulator]; * i.e., don&rsquo;t do anything<br><br>*-----------------------------------------------------------<br>WaitForMapBuf:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Wait for map operation to complete<br>* Clobbers nothing<br>*-----------------------------------------------------------<br>Subroutine;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; T-T-1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; PRef, Branch[., ALU&lt;0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* MapBufBusy is sign bit<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Return;<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
