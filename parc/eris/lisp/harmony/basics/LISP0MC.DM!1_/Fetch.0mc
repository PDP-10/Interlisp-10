:TITLE[Fetch.0mc...January 12, 1983  10:50 AM, van Melle];Set[FetchDebug, 0];Set[NoInterrupts, 0];*	GOTO[REFILLY],LOADPAGE[0],at[0001];*	only required on pages that contain NextInst/NextData'sREFILLY:*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[0377] ;*page  0 alto*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[0777] ;*page  1 alto*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[1377] ;*page  2 alto*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[1777] ;*page  3 alto	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[2377] ;*page  4lspNextInstP4:	lu _ NextInst[IBuf];lnixP4:		NIRET;	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[2777] ;*page  5lspNextInstP5:	lu _ NextInst[IBuf];lnixP5:		NIRET;	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[3377] ;*page  6lspNextInstP6:	lu _ NextInst[IBuf];lnixP6:		NIRET;	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[3777] ;*page  7lspNextInstP7:	lu _ NextInst[IBuf], at[P7TailLoc];	* placed for overlayslnixP7:		NIRET;*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[4377] ;*page 10*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[4777] ;*page 11	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[5377] ;*page 12lspNextInstP12:	lu _ NextInst[IBuf];lnixP12: 	NIRET;*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[5777] ;*page 13 alto*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[6377] ;*page 14 alto	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[6777] ;*page 15lspNextInstP15:	lu _ NextInst[IBuf];lnixP15: 	NIRET;	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[7377] ;*page 16lspNextInstP16:	lu _ NextInst[IBuf];lnixP16: 	NIRET;*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[7777] ;*page 17 - can't	onpage[17];lspNextInstP17:	loadpage[7];		gotop[lspNextInstP7];	OnPage[0];RefillIBuf:	PCB _ (PCB) + (4c), at[340];	PCF _ Rzero, at[341];	nop, at[342];	return, at[343];		* Wait for page faultonpage[pgJump];* If the PFETCH4 faults, the fault handler will set IBUF to -1s and* continue as if nothing happened.  The fault happens after the 3rd* instruction past the pfetch is executed.  The fault handler destroys* the return link.  The micro instruction being executed must be on* pgJump for this special action to occur.ReturnOp:	return, opcode[374];	* Used by Fault for first mi NextData casePFop:	PFETCH4[PCB, IBUF, 0], opcode[377];	* This will page fault	IBUF _ IBUF, goto[nxiLBL];* Come here when IntPending instead of to next opcode	onpage[opPage0];TakeInterrupt:	T _ (SStkP&NStkP) xor (377c), skip;	* maybe these can be the sameNwwOp:	T _ (SStkP&NStkP) xor (377c), opcode[000];	lspL1 _ IP[RSImage]c;			* RS232 Image Register	Stkp _ lspL1, lspL1 _ T, NoRegILockOK;	T _ Stack _ (Stack) and not (IntPendingBit);	Stkp _ lspL1, RS232 _ T;:IF[WindFlg];	lu _ (NWW) and not (BothKeyMasks), goto[NoInterrupt, R<0];				* test for interrupts other than lisp/bcpl key	NWW _ (NWW) and not (BcplKeyMask), goto[NWWPunt, alu#0];				* yes, do them by punting to bcpl	AC2 _ KbdFXP, skip[alu#0];	* Skip if no interrupts: shouldn't happen?	  goto[NoInterrupt];			* spurious	NWW _ 100000c;			* turn off interrupts before switching	loadpage[pgLisp0];	AC3 _ 177400c, gotop[CheckForBackup];	* AC3<0 signals contextswitchNoInterrupt:	T _ (PCXReg) - 1;	* need to back up the PC before resuming	lspL1 _ T;	PCF _ lspL1;			* wait for PCF to get written	goto[nxiLBL];:ELSE;				* pre-Wind, always do Nww	LoadPage[pgLisp0];	gotop[lspNWWInt];:ENDIF;%:IF[NoInterrupts];	T _ (PCXReg);	lspL1 _ T;	lspL1 _ (lspL1) - (1c);	nop;	PCF _ (lspL1);	nop;	lu _ NextInst[IBuf];	NIRET;:ELSE;	LoadPage[pgLisp0];	gotop[lspNWWInt];:ENDIF;%	onpage[4];lspRetP4: return;	onpage[5];lspRetP5: return;	onpage[6];lspRetP6: return;	onpage[10];lspRetP10: return;	onpage[11];lspRetP11: return;	onpage[15];lspRetP15: return;	onpage[16];lspRetP16: return;	onpage[17];lspRetP17: return;	onpage[5];lspUfnxP5:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[6];lspUfnxP6:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[7];lspUfnxP7:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[10];lspUfnxP10:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[11];lspUfnxP11:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[12];lspUfnxP12:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[15];lspUfnxP15:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[16];lspUfnxP16:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[17];lspUfnxP17:	loadpage[pgUfnx];	gotop[lspUfnxP4];	:END[Fetch];