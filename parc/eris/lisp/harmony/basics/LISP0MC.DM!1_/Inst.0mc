:TITLE[Inst.0mc...October 20, 1983  8:38 PM, van Melle];* IvarsIvars:	T _ (lspIbasex), goto[lspPushT1], opcode[100];	T _ (lspIbasex) + (02c), goto[lspPushT1], opcode[101];	T _ (lspIbasex) + (04c), goto[lspPushT1], opcode[102];	T _ (lspIbasex) + (06c), goto[lspPushT1], opcode[103];	T _ (lspIbasex) + (10c), goto[lspPushT1], opcode[104];	T _ (lspIbasex) + (12c), goto[lspPushT1], opcode[105];	T _ (lspIbasex) + (14c), goto[lspPushT1], opcode[106];@IvarX:	T _ lspIbasex, opcode[107];Ivarx1:	T _ (NextData[IBuf]) + T;lspPushT1:	PFetch2[lspStkBr, Stack], goto[PushChkP5];* PvarsPvars:	PFetch2[lspEp, Stack, 0], goto[PushChkP5], opcode[110];	PFetch2[lspEp, Stack, 2], goto[PushChkP5], opcode[111];	PFetch2[lspEp, Stack, 4], goto[PushChkP5], opcode[112];	PFetch2[lspEp, Stack, 6], goto[PushChkP5], opcode[113];	PFetch2[lspEp, Stack, 10], goto[PushChkP5], opcode[114];	PFetch2[lspEp, Stack, 12], goto[PushChkP5], opcode[115];	PFetch2[lspEp, Stack, 14], goto[PushChkP5], opcode[116];@PvarX:	T _ lspEp, goto[Ivarx1], opcode[117];Fvars:	T _ (lspEp) + (00c), goto[FVarCommon], opcode[120];	T _ (lspEp) + (02c), goto[FVarCommon], opcode[121];	T _ (lspEp) + (04c), goto[FVarCommon], opcode[122];	T _ (lspEp) + (06c), goto[FVarCommon], opcode[123];	T _ (lspEp) + (10c), goto[FVarCommon], opcode[124];	T _ (lspEp) + (12c), goto[FVarCommon], opcode[125];	T _ (lspEp) + (14c), goto[FVarCommon], opcode[126];	T _ lspEp, opcode[127];	T _ (NextData[IBuf]) + T;FVarCommon:	PFetch2[lspStkBr, lspGenBr], call[retLBL];					* fetch contents of binding slot	lu _ lspGenBr, goto[FVarUnbound, R Odd];	PFetch2[lspGenBr, Stack, 0];	* Fetch value in slot.					* This can page faultWaitForStackFaultPush:	lu _ Stack, goto[PushChkP5];FVarUnbound:				* not looked up yet				* T = offset of binding slot at this point	SavedFvarOffset _ T, call[FVarLookup];	PStore2[lspStkBr, FVarBinding], goto[FVarCommon];					* store binding ptr, try again* GVAR -- access value cell of atom whose index is in next two bytes@Gvar:	lspGenBrHi _ (VALspace), opcode[140];	lspGenBr _ (VALbase);	T _ NextData[IBuf];	lspL0 _ T;	T _ NextData[IBuf];	lspL0 _ (lsh[lspL0, 10]) or T;	T _ lsh[lspL0, 1];	PFetch2[lspGenBr, Stack], goto[WaitForStackFaultPush];SetPvars:	PStore2[lspEp, Stack, 0], goto[UnPopStack], opcode[130];	PStore2[lspEp, Stack, 2], goto[UnPopStack], opcode[131];	PStore2[lspEp, Stack, 4], goto[UnPopStack], opcode[132];	PStore2[lspEp, Stack, 6], goto[UnPopStack], opcode[133];	PStore2[lspEp, Stack, 10], goto[UnPopStack], opcode[134];	PStore2[lspEp, Stack, 12], goto[UnPopStack], opcode[135];	PStore2[lspEp, Stack, 14], goto[UnPopStack], opcode[136];UnPopStack:	Stack&+2, goto[nxiLBL];SetPvarPops:	PStore2[lspEp, Stack, 0], goto[PopChk6], opcode[270];	PStore2[lspEp, Stack, 2], goto[PopChk6], opcode[271];	PStore2[lspEp, Stack, 4], goto[PopChk6], opcode[272];	PStore2[lspEp, Stack, 6], goto[PopChk6], opcode[273];	PStore2[lspEp, Stack, 10], goto[PopChk6], opcode[274];	PStore2[lspEp, Stack, 12], goto[PopChk6], opcode[275];	PStore2[lspEp, Stack, 14], goto[PopChk6], opcode[276];* SetI, op 142, Set IVar N to TOS where N=following byte, dont pop stack@SetI:	T _ lspIbasex, goto[Svrx0], opcode[142];* SetP, op 137, Set PVar N to TOS where N=following byte, dont pop stack@SetP:	T _ lspEp, goto[Svrx0], opcode[137];Svrx0:	T _ (NextData[IBuf]) + T;	PStore2[lspStkBr, Stack], goto[UnPopStack];* SetF, op 143, Set Free var N to TOS, dont pop stack@SetF:	T _ lspEp, opcode[143];	T _ (NextData[IBuf]) + T;SetF1:	PFetch2[lspStkBr, lspGenBr], call[retLBL];	* fetch contents of binding slot	lu _ lspGenBr, goto[SetFUnbound, R Odd];	T _ (StackSpaceR);	lu _ (rsh[lspGenBrHi, 10]) xor T;	* is binding slot on stack?	T _ lspGenBrHi, goto[SetFtop, alu#0];	PStore2[lspGenBr, Stack, 0], goto[UnPopStack];SetFUnbound:				* not looked up yet				* T = offset of binding slot at this point	SavedFvarOffset _ T, call[FVarLookup];	PStore2[lspStkBr, FVarBinding], goto[SetF1];					* store ptr in slot and try againSetFtop:		* binding slot not on stack, need to refcnt			* Move base to L2,3.  Should fix RplPtr instead	lspL3 _ T;	T _ lspGenBr, loadpage[pgRplPtr];	lspL2 _ T, gotop[SetGvar1];	* do gvar_ on this atom** Called with T pointing to Fvar binding slot*FVarLookup:	PFetch1[lspIfuBr, lspL1, 7];	* lspL1 _ Nlocals,,FvarOffset	T _ lspEp;	T _ (SavedFvarOffset) - T, loadPage[pgFvar];	lspL0 _ T;			* word offset of binding slot past Eponpage[pgFvar];	T _ rsh[lspL1, 10];		* T _ NLocals	lspL1 _ (rhmask[lspL1]) - T;	* lspL1 _ -NLocals + Fvaroffset	T _ rsh[lspL0, 1];		* cell offset of binding slot	T _ (lspL1) + T;	* T _ (SavedFvarOffset - Ep)/2 - NLocals + Fvaroffset				*    = nametable offset	PFetch1[lspIfuBr, FVarName], goto[FVarLookupName];* Nil, op 150, Push Nil onto stack@Nil:	T _ Stack&+1 _ 0c, goto[PushTChkP5], opcode[150];* Kt, op 151, Push T onto stack@Kt:	Stack&+1 _ 0c, opcode[151];	Stack&+1 _ (KtVal), goto[PushChkP5];* Zero, op 152, Push zero onto stack@Zero:	Stack&+1 _ (smallpl), opcode[152];	Stack&+1 _ 0c, goto[PushChkP5];* One, op 153, Push small int one onto stack@One:	Stack&+1 _ (smallpl), opcode[153];	Stack&+1 _ 1c, goto[PushChkP5];* Sic, op 154, Push 2nd byte onto stack as small integer@SIC:	Stack&+1 _ (smallpl), opcode[154];	T _ NextData[IBuf], CallX[PushTChkP5];* Snic, op 155, Push 2nd byte onto stack as small negative integer@SNIC:	Stack&+1 _ (smallneg), opcode[155];	T _ 177400c;	T _ (NextData[IBuf]) or T, CallX[PushTChkP5];* Sicx, op 154, Push next two bytes onto stack as small integer@SICX:	Stack&+1 _ (smallpl), opcode[156];Sicx1:				* push word formed from next two bytes	lu _ CycleControl _ NextData[IBuf];	* Load from ALUA[10:17],...	T _ lhmask[Cycle&PCXF];		* CycleControl is read to R[0:7]	T _ (NextData[IBuf]) or T, CallX[PushTChkP5];* AtomNumber, op 160, Same as SICX, except for its use@AtomNumber:	Stack&+1 _ (smallpl), goto[Sicx1], opcode[160];* AConst, op 147, Push the following 2 bytes onto stack as an atom@AConst:	Stack&+1 _ 0c, goto[Sicx1], opcode[147];* GConst, op 157, Push the 3 following bytes onto stack as a constant@GConst:	T _ NextData[IBuf], opcode[157];	Stack&+1 _ T, goto[Sicx1];* Copy, op 144, Copy top of stack onto stack again@Copy:	Stack&-1, opcode[144];	Stack&+2 _ Stack;	Stack&-1;	Stack&+2 _ Stack, goto[PushChkP5];	:END[inst];