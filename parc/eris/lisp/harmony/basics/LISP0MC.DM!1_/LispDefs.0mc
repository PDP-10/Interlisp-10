:TITLE[LispDefs, October 23, 1983  4:48 PM, van Melle];INSERT[GlobalDefs];mc[DolphinMcVersion, 1];set[WindFlg, 1];set[FaultFlg, WindFlg];set[WithAudio, IFE[WithMidas, 0, 0, 0]];		* never with Midasset[WithFloatingPoint, XOR[And[With3MB, With10MB], 1]];set[WithBin, IFE[WithMidas, 0, 1, 0]];set[WithCons, IFE[WithMidas, 0, 1, 0]];set[WithCreateCell, 1];set[WithPPBlt, 0];mc[RamRelease, 12000];mc[MinBcplVersion, 21000];mc[MinLispVersion, 106400];set[StatsMode, IFE[WithMidas, 0, 1, 0]];	* must be zero if WithMidasset[FvarStatsMode, And[StatsMode, 0]];set[CdrCoding, 1];set[Debugging, 1];set[BreakPoints, WithMidas];set[StkDebug, 0];****** These are declarations for alto that are also used by LispRV2[AC0, AC0hi, 10];			* emulator Ac's, with hi part = MDShiRV[AC1, 26];RV2[AC2, AC2hi, 4];RV[AC3, 22];RV2[PCB, PCBhi, 30];			* Code base for Lisp, BcplRV2[MDS, MDShi, 32];			* Basereg for alto space (lo = hi = 0)RV[NWW, 24];RV[R177400, 14];RV[R400, 60];RV[AllOnes, 61];RV[RZero, IP[MDS]];RV4[IBuf, IBuf1, IBuf2, IBuf3, 34];	* instruction buf, both Alto and LispRV4[xBuf, xBuf1, xBuf2, xBuf3, 44];	*Temporary bufRV[XBufRow, IP[XBuf1]];			* for XMapRV[XBufFC, IP[XBuf3]];			* for XMapRV2[RTemp, RTemp1, 52];		* temp/pair***** Lisp permanent registersRV2[lspEp, lspEpHi, 66];		* Perm/pair, hi = StackSpaceRV2[lspStkBr, lspStkBrHi, 62];	* Const/pair = StackSpace, 0RV2[lspTsp, lspTspHi, 12];	* Setfe/pair, hi = StackSpaceRV[lspEsp, 07];			* SetfeRV4[lspIfuBr, lspIfuBrHi, lspNext, lspPC, 40];	* Setfe/quad 				* lspNext, lspPC used as tempRV[StkState, 56];RV[lspIBasex, 57];		* These two coincident with WW, ACTIVERV[lspInstFlag, 00];		* State tested at page fault  Mc[NormalState, 0];  Mc[InBcplState, 1];  Mc[InBitBltState, 2];  Mc[InAltoBitBltState, 2];  Mc[InBltState, 3];  Mc[InPPBltState, 4];  Mc[InBltState4, 5];  Mc[InCallState, 100000];	* sign bitRV[lspStatsPtr, 06];		* Perm.  Sign bit = off; otherwise is mds ptrSettask[10];RV4[HStack0, HStack1, HStack2, HStack3, 20];RV4[HStack4, HStack5, HStack6, HStack7, 24];RV4[HStack10, HStack11, HStack12, HStack13, 30];RV4[HStack14, HStack15, HStack16, HStack17, 34];Settask[0];***** Lisp temporary registersRV[lspLN, IP[lspPC]];RV2[lspDefx0, lspDefx1, 54];	* temp/pair -- function callRV[lspNargs, 20];		* tempRV2[lspL0, lspL1, 70];		* temporary pairRV2[lspL2, lspL3, 72];		* temporary pairRV[lspL4, 03];			* tempRV[lspL5, 25];			* tempRV2[lspGenBr, lspGenBrHi, 50];	* temp/pair***** Lisp temporary registers that are used by Alto alsoRV[lspL6, 1];RV[lspL7, 2];RV2[MDSTypeBaseBr, MDSTypeBaseBrHi, 64];RV4[qBuf, qBuf1, qBuf2, qBuf3, 74];	* overlays RWPAC0-3RV4[uBuf, uBuf1, uBuf2, uBuf3, 14];	* overlays R177400-3***** Other overlaysRV[lspType, IP[lspL4]];		* type # returned by lspTyp subroutineRV[lspUFN, IP[AC3]];		* ufn # for calls to ufnLBL				* For FVar lookupRV[SavedFvarOffset, IP[AC0]];RV[FVarName, IP[AC1]];RV[FVarReturnAddress, IP[lspL7]];RV2[FVarBinding, FVarBindingHi, IP[lspL0]];%  These could also be assigned:RV[, 21];* Could also use the AC's !!%:IF[WithPilotBitBlt];*BitBlt temporaries.  10b of these have to be preserved over interrupts.* Pilot puts them on the stack, but we can't do that, so just assign them to* two quad group regs for easy storing* RTemp is also used here.* beware that these first 8 regs are not ones smashed by Fault!!!*RV[bbArgPtr,1];			*pointer to BitBltArg table*RM[bbGrayWordIndex,IP[bbArgPtr]];	*Low order 4 bitsRM[bbGrayWordIndex,IP[uBuf1]];	*Low order 4 bits are usedRV2[bbDestQLo,bbDestQHi,IP[uBuf2]];	*Dest Quad word addressRV2[bbSourceQLo,bbSourceQHi,IP[qBuf]];	*Source Quadword address.  QuadRV[bbSourceBitOffset,IP[qBuf2]];RV[bbItemsRemaining,IP[qBuf3]];RV[bbDestBitOffset,IP[lspDefx0]];		* even			* End of regs needing savingRV[bbDestBpl,IP[lspDefx1]];		* = bbDestBitOffset + 1RV[bbItemWidth,IP[lspL5]]; RV[bbSubitemDestBitOffset,IP[lspL6]];RV[bbFlags,IP[lspL7]];RV[bbGrayWord,IP[xBuf]];		*Gray wordRV[bbNegItemWidth,IP[AC2hi]]; RV[bbDest,IP[lspNargs]];	*Quadword buffer -- gets also 21, AC3, AC3hiRV[bbSDNonOverlap,IP[AC2]];		* Can coincide with bbDestRV[bbNegSDNonOverlap,IP[AC0hi]];RV[bbDestWordOffset,IP[lspGenBr]];RV[bbSourceBpl,IP[lspGenBrHi]];		*source bits per lineRV[bbSourceWordOffset,IP[xBuf1]]; RV[bbTouchPages,IP[lspLN]];RV[bbSubitemSourceBitOffset,IP[AC0]];RV[bbSource,IP[lspL0]];		*Quadword bufferRV2[bbArgLo,bbArgHi,IP[xBuf2]];	*Points to BitBltArg table				* Can coincide with bbSource*End of bitblt registers:ENDIF;* Bcpl common addressesMC[SubrArgArea, 210];MC[BcplStartAddress, 206];MC[StatsPointerLocation, 200];MC[StatsBufferBoundary, 1400];MC[BitBltStash, 250];		* 10b words for saving BitBlt state* Bit masksMC[FreeStackBlock, 120000];MC[BfBlock, 100000];MC[BfBlockPad, 100400];MC[FxtnBlock, 140000];MC[FXFastReturn, 4000];MC[FXInCall, 2000];MC[FXNoPushReturn, 400];MC[ht1Cnt, 2000];MC[ht2Cnt, 4000];MC[htStkBit, 1000];MC[htCntMask, 176000];MC[htStkCnt, 177000];MC[unboundPvar, 100000];MC[fxtnOverhead, 12];MC[LispKeyMask, 20000];MC[BcplKeyMask, 10400];MC[BothKeyMasks, 30400];MC[IFPFAULTHI, 37];MC[IFPFAULTLO, 40];* Atom constantsMC[ExprApplyAtom, 400];MC[Dummy370, 370];MC[MakeNumber, 374];MC[SetGlobal, 375];MC[KtVal, 114];Mc[atomNOBIND, 1]Mc[atomEVALFORM, 370]Mc[atomGCOVERFLOW, 371]Mc[atomGCGENPUNT, 377]Mc[atomDTESTFAIL, 372]Mc[atomOVERFLOWMAKENUMBER, 373]Mc[atomSETFVAR, 376]Mc[MakeFloatNumber, 401]* Punt indexesMC[UcodeCheckCodex, 0];*MC[StackOvflCodex, 1];MC[LispExitCodex, 2];*MC[PageFaultCodex, 3];MC[StatsOvflCodex, 4];* uCodeCheck argsmc[FaultWithoutInterrupts, 301];mc[NullFreeListPunt, 302];mc[FaultInFault, 303];  mc[minFaultPvar, 3000];mc[SubovFXP,2];mc[KbdFXP,3];mc[FAULTFXP,6];* Type constantsmc[SmallType, 1];mc[FixpType, 2];mc[FloatpType, 3];mc[AtomType, 4];mc[ListType, 5];mc[ArrayType, 6];mc[VMemPagePType, 12];mc[StreamType, 13];* Misc constants*mc[StackNeeded, 14];mc[StackRequested, 54];mc[StackRequestedDelta, 40];Mc[BltInterruptableMinWords, 10];Mc[MaxNewCellCount, 10000];Mc[CreateCellPunt, 20000];Mc[GcOverflowPunt, 40000];Mc[GcPunts, Or[CreateCellPunt!, GcOverflowPunt!]];M@[mbx, AT[lspmbxDisp,#1]];M@[LBLPG,IFG[FVAL[PGE@],7,SELECT[SUB[FVAL[PGE@],10],#1P10,#1P11,#1P12,#1P13,#1P14,#1P15,#1P16,#1P17],SELECT[FVAL[PGE@],#1P0,#1P1,#1P2,#1P3,#1P4,#1P5,#1P6,#1P7]]];	* Generates label from current page#, e.g.	* GOTO[LBLPG[lspUfnx]];M@[CatLBL,IFG[#2,7,SELECT[SUB[#2,10],#1P10,#1P11,#1P12,#1P13,#1P14,#1P15,#1P16,#1P17],SELECT[#2,#1P0,#1P1,#1P2,#1P3,#1P4,#1P5,#1P6,#1P7]]];	* Generates label from specified page#, e.g.	* GOTO[CatLBL[lspUfnx, pgArith]];M@[MaybeLoadPage, IFE[FVAL[PGE@],#1,,LoadPage[#1]]];M@[UFNLBL,LBLPG[LSPUFNX]];	* Ufn dispatchM@[NXILBL,LBLPG[LSPNEXTINST]];	* NextInst fetchM@[PUSHLBL,LBLPG[PushChk]];	* for opcodes that have net pushM@[POPLBL,LBLPG[PopChk]];	* for opcodes that have net popM@[RETLBL,LBLPG[lspRET]];	* mainly for taskingMacro[NextOpCode, IFE[FVAL[PGE@], 17,	(goto[lspNextInstP17]),	(lu _ NextInst[IBuf], CallX[LBLPG[lnix]])]];				* goto[nxiLBL], but 2 cycles faster* Fixed page locationsset[pgUfnx, 4];		* Ufn code: Same as function call opcodesset[pgTyp, 4]; 		* lspTyp subroutine: Same as typechecking opcodesset[pgJump, 6];		* All pfetch4 that cause ibuf refills are hereset[pgArithOps, 7];	* Same as arith opcodesset[pgMapOps, 5];	* Same as vmem map opcodesset[pgCallOps, 4];	* Same as fncall opcodesset[pgSetBase, 7];	* lspSetBase subroutine: same as PutBase etc.* Movable page locationsset[pgReturn, 15];				* 41b mi [35 Return + 4 Lisp0]set[pgReturnA, 6];				* 47b miset[pgFrame, 11];				* 43b mi; not 6set[pgFrame2, 6];				* 23b miset[pgFrame3, 10];				* 31b mi + 5 if Stats; not 4-7set[pgFrame4, 5];				* 17b mi; not 4-7set[pgBind, 16];				* 54b miset[pgFvar, 15];set[pgHStack, 16];				* 61b miset[pgHtFind, 17];				* 60b miset[pgArith, 15];				* not 4-7set[pgLisp0, 10];				* not 4-7set[pgEval, 16];				* 26b mi - 1 if on pgFvar or 4set[pgGcScan, 17];				* 34b mi; not 4-7set[pgRplPtr, 16];set[pgBin, 12];					* 25b mi; not 6set[pgCons, 17];				* 142b miset[pgReclaim, 16];set[pgRplacd, 6];set[pgStats, 17];				* 26b mi; not 4-7set[pgBlt, 7];					* not 6set[pgMisc, IFE[WithMidas, 0, 17, 15]];		* not 4-7,  16b mi						*   plus 36b mi if WithPPBltset[pgUfnxA, 6];				* 25b miset[pgCreateCell, 16];				* not 6?Set[pgBitBlt,12];	* 332b mi from PBitBlt, 13b from Misc = 345b mi  Set[bbP1,12];Loca[audGoLoc,10,2];	*10b mi on page of this starting addressSet[audPage,17];	*37b miset[IntfaceBase, 200];set[IntfaceCnt, IFE[WithPilotBitBlt, 0, 10, 5]];			* In Interface.0mc:loca[lneTask1stLoc, pgLisp0, 200];loca[lneTaskSkpLoc, pgLisp0, 201];loca[lStartNovaLoc, pgLisp0, 202];loca[lStartNovaLoc1, pgLisp0, 203];:IF[WithPilotBitBlt];loca[lTrapLoc, pgLisp0, 204];		* only when WithPilotBitBlt:ELSE;loca[lBitBltDoneLoc, pgLisp0, 204];loca[lBitBltDoneLoc1, pgLisp0, 205];loca[lBBBitBltLoc, pgLisp0, 206];loca[lBBBitBltLoc1, pgLisp0, 207];			* In Lisp0.0mcloca[BBMDoneLoc, pgLisp0, 210];loca[BBMesaIntLoc, pgLisp0, 211];:ENDIF;loca[LispInstLoc, pgLisp0, 212];			* In LFaults.0mcloca[MapFaultPuntLoc, pgLisp0, 213];set[pgLisp0Base, lshift[pgLisp0, 10]];set[lspmbxDisp, ADD[pgLisp0Base, 100]];Loca[FaultDisp, pgLisp0, 300];		* Dispatch in page faultLoca[ArithDisp, pgArith, 200];		* Dispatch for 2-arg arith opsLoca[MiscDisp, pgMisc, 240];		* Dispatch for misc opcodes* The space constants should be turned into macros which generate* 377 in the right half.mc[smallpl, 16];mc[smallNeg, 17];mc[ArraySpace, 40];mc[STATSspace, LSHIFT[26, 10]];	mc[UFNTablebase, 123000];mc[MDSTypeSpace, LSHIFT[26, 10]];	mc[MDSTypebase, 100000];mc[DTDspace, LSHIFT[26, 10]];	mc[DTDBase, 124000];mc[VALspace, LSHIFT[22, 10]];	mc[VALspaceR, 22];	mc[VALbase, 0];mc[DEFSpace, LSHIFT[21, 10]];	mc[DEFBase, 0];mc[htMainSpace, LSHIFT[73, 10]];	mc[htMainBase, 0];mc[StackSpace, LSHIFT[27, 10]];	mc [StackSpaceR, 27];mc[INTERFACEspace, LSHIFT[26, 10]];	mc[INTERFACEbase, 10000];:END[Lispdefs];(1792)\209f5 17f0 39f5 7f0 32f5 8f0 32f5 14f0 1176v5V36v5V1578f5 658f0 8f5 60f0 8f5 135f0 4f5 37f0 5f5 18f0 8f5 70f0 3f5 56f0 5f5 27f0 8f5 22f0 10f5 52f0 5f5 24f0 5f5 35f0 3f5 165f0 931f5 15f0 2987f5 4f0 8f5 60f0 4f5 93f0