<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Harmony>BCPL>BCPLENV.DM!1>RaidProcs.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">// RaidProcs.bcpl. Supplementary procedures for RAID<br>// Last modified September 19, 1981  2:01 PM by Bill van Melle<br>// Last modified August 4, 1981  12:47 PM by Beau Sheil<br>// Last modified March 16, 1981  12:56 PM by Beau Sheil<br>// Last modified July 27, 1980  6:56 PM by Beau Sheil<br>// Last modified May 27, 1980  4:36 PM by Beau Sheil<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "AltoDefs.d"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Raid.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Pup0.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Pup1.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Stats.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Streams.d"<br><br>external [         // defined here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AtomNum; ShowRealCore; TeleRaid; uPCTracing; @uPCTraceAddr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DisplayVMinBitMap; DisplayVMbit; VMDisplay<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>external [         // procedures used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Zero; VirtualPage; CallSwat; CRLF; Ws; Wo; Bytes2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StealFromBcplDisplay; AddToBcplDisplay; DumpBlockToStats<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RaidReset; UPCTrace; ShowDisplayStream<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@BGetBase; @BGetBasePtr; @XPutBase; @XSetBR; @RRead; @RWrite<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Dequeue; MoveWords; CompletePup; ExchangePorts; ReleasePBI<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetTimer; TimerHasExpired; EmAddr; Block<br>                  // statics used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EmulatorSpace; LastRealPageNo; @lvVPtr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dsp; @DisplayAddrHi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>static  [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMDisplay = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@uPCTraceAddr = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>manifest [ LastSegment = 63</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// 22-bit address space<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IMSize = #20000; DummyHeight = 32<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMbitMapOffset = 2+2*lDCB</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// bitmap within VMDisplay<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMDisplayWidth = 16; VMDisplayHeight = LastSegment+1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMDisplayScanLines = DummyHeight + VMDisplayHeight<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMDisplaySize = VMbitMapOffset + VMDisplayWidth*VMDisplayHeight<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRRead       = #201</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// teleRaid constants<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRHereIsPage = #301<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRStore      = #200<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRStoreDone  = #300<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRGo         = #202<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRGoAck      = #302<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRGoReply    = #203<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRShow       = #210<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRShown      = #310<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRError      = #304<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>let AtomNum(S) = valof<br>// Finds atom number for BCPL string. pn char format is that of bcpl strings<br> [ <br>   let LEN = S&gt;&gt;String.length<br>   let NW = LEN rshift 1<br><br>// Compute the hash code for the name. Mimic the behavior of LISP<br>   let SS = 0<br>   for i = 1 to LEN do<br>     [ let h1 = ((SS & #7777) lshift 2) + SS<br>       SS = (h1 lshift 8) + h1 + S&gt;&gt;String.char&uarr;i<br>     ]<br><br>   [<br>   let H = ((SS&#77777) rem (AHTSIZE lshift 8)) + AHTbase<br><br>// H is the virtual address in the AtomHashTable <br>   let P = BGetBase(AHTspace, H)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// P is address of hash table entry <br>   if P eq 0 then RaidReset("No such atom")<br><br>// since P was non zero, it is the virtual address of an atom+1<br>   P = P-1<br><br>// fetch atom and check its pname. Check its characters (word-by-word)<br>// with those in pname. Count is first byte, and pad byte (if any) is 0.<br>   XSetBR(BGetBasePtr(PNPspace, PNPbase+(P lshift 1)))<br>   for i = 0 to NW do if RRead(i) ne S!i goto reprobe<br><br>   resultis P</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// pnames are the same; return virtual address<br><br>reprobe: SS = SS+HashInc<br>   ] repeat</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// comparison failed so reprobe<br> ]<br><br>and ShowRealCore() be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Displays a segment page usage map<br> [<br>   let base = vec LastSegment+2; Zero(base, LastSegment+3)<br>   for i = 0 to LastRealPageNo-1-PagesPerSegment do<br>     [ let bucket = VirtualPage(i)&lt;&lt;VP.segment<br>       base!bucket = base!bucket + 1<br>     ]<br>   base!EmulatorSpace = PagesPerSegment</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Emulator done specially<br>   Ws(" Segment   Pages Contents*N")<br>   let total = 0<br>   for i = 0 to LastSegment do unless base!i eq 0<br>       do [ Ws("  "); Wo(i); Ws("  "); Wo(base!i)<br>            // The following is not a SELECT as the choices are not exclusive<br>            if i ge MDSLo & i le MDSHi then Ws(" Main data space")<br>            if i eq PNPspace then Ws(" PName pointers")<br>            if i eq DEFspace then Ws(" Definitions")<br>            if i eq TOPVALspace then Ws(" TopVals")<br>            if i eq PLISTspace then Ws(" Property lists")<br>            if i eq AHTspace then Ws(" Atom Hash Table")<br>            if i eq PMTspace then Ws(" Primary Page Map (PMT)")<br>            if i eq PAGEMAPspace then Ws(" Secondary Page Map")<br>            if i eq INTERFACEspace then Ws(" Interface page")<br>            if i eq MDSTYPEspace then Ws(" MDS type table")<br>            if i eq STATSspace then Ws(" Statistics")<br>            if i eq STACKspace then Ws(" Stack")<br>            if i eq EmulatorSpace then Ws(" Alto emulator")<br>            if i eq DisplayAddrHi & DisplayAddrHi ne 0<br>               then Ws(" Lisp display bitmap")<br>            if i ge PncLo & i le PncHi then Ws(" PName characters")<br>            if i ge ArrayLo & i le ArrayHi then Ws(" Arrays and strings")<br>            if i eq GCMainspace then Ws(" GC main table")<br>            if i eq GCCollspace then Ws(" GC collision table")<br>            CRLF()<br>            total = total + base!i ]<br>   Ws("   Total  "); Wo(total); CRLF() <br>   let sp = "          "<br>   Ws(sp); Wo(base!(LastSegment+1)); Ws(" Empty"); CRLF()<br>   Ws(sp); Wo(base!(LastSegment+2)); Ws(" Unavailable"); CRLF()<br>   Ws(sp); Wo(LastRealPageNo); Ws(" Total pages"); CRLF()<br>  ]<br><br>and TeleRaid(s) = valof<br>  [ <br>    Block()</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// let inbound packets in<br>    let pb = Dequeue(lv s&gt;&gt;PupSoc.iQ)<br>    unless pb do resultis 0<br>    let pup = lv pb&gt;&gt;PBI.pup<br>//    let lastid = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// cache low order bits of id<br>//    test lastid eq pup&gt;&gt;Pup.id&uarr;2<br>//      ifso  [ ReleasePBI(pb); resultis 0 ]</span><span class="tab" val="67"></span><span style="font: 10pt serif">// duplicate suppression<br>//      ifnot [ lastid = pup&gt;&gt;Pup.id&uarr;2 ]<br>    switchon pup&gt;&gt;Pup.type into<br>      [ case TRRead:  [ TellUser("Read")</span><span class="tab" val="67"></span><span style="font: 10pt serif">// ID is virtual addr of desired page<br>                        MoveWords(lv pup&gt;&gt;Pup.id&uarr;1, EmAddr(lv pup&gt;&gt;Pup.words&uarr;1),<br>                                  WordsPerPage)<br>                        ExchangePorts(pb)<br>                        CompletePup(pb, TRHereIsPage, WordsPerPage lshift 1 + pupOvBytes)<br>                        endcase<br>                      ]<br>        case TRStore: [ TellUser("Store")</span><span class="tab" val="67"></span><span style="font: 10pt serif">// First two words are VA, third word is value to store<br>                        XPutBase(lv pup&gt;&gt;Pup.words&uarr;1, pup&gt;&gt;Pup.words&uarr;3)<br>                        ExchangePorts(pb)<br>                        CompletePup(pb, TRStoreDone, pupOvBytes)<br>                        endcase<br>                      ]<br>        case TRGo:    [ TellUser("Go")<br>                        ExchangePorts(pb)<br>                        CompletePup(pb, TRGoAck, pupOvBytes)<br>                        let Timer = nil<br>                        SetTimer(lv Timer, 1000)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// 10 sec timeout<br>                        [ pb = Dequeue(lv s&gt;&gt;PupSoc.iQ)<br>                          if pb % TimerHasExpired(lv Timer) then break<br>                          Block() ] repeat<br>                        test pb & (pb&gt;&gt;PBI.pup.type eq TRGoReply)<br>                          ifso  [ </span><span class="tab" val="67"></span><span style="font: 10pt serif">// &uarr;N = go!<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ReleasePBI(pb)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">resultis #16 ]<br>                          ifnot [ TellUser("Go abort")<br>                                  if pb then [ ExchangePorts(pb)<br>                                               CompletePup(pb, TRError, pupOvBytes) ] ]<br>                        endcase<br>                      ]<br>        case TRShow:  [ </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Body is a bcpl string to print<br>                        Ws(lv pup&gt;&gt;Pup.bytes&uarr;1)<br>                        ExchangePorts(pb)<br>                        CompletePup(pb, TRShown, pupOvBytes)<br>                        endcase<br>                      ]<br>        default:      [ TellUser("Error")<br>                        ExchangePorts(pb)<br>                        CompletePup(pb, TRError, 0)<br>                        ]<br>     ]<br>    resultis 0<br>  ]<br><br>and TellUser(s) be [ Ws("["); Ws(s); Ws("]") ]<br><br>and uPCTracing(flg) be<br>  [<br>   test uPCTraceAddr eq 0<br>    ifso [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// turn tracing on<br>         uPCTraceAddr = StealFromBcplDisplay(IMSize, 0)<br>         UPCTrace(uPCTraceAddr)<br>        ]<br>    ifnot [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// turn tracing off and dump to lisp.stats<br>         UPCTrace(0)<br>         DumpBlockToStats(uPCevent, uPCTraceAddr, IMSize/128, 128)<br>         if flg then AddToBcplDisplay(uPCTraceAddr, IMSize, 0)<br>         uPCTraceAddr = 0<br>        ]<br>  ]<br><br>and DisplayVMinBitMap() be<br>  [<br>   if VMDisplay then<br>    [ VMDisplay = 0<br>      AddToBcplDisplay(VMDisplay, VMDisplaySize, VMDisplayScanLines)<br>      return<br>    ]<br><br>   VMDisplay = StealFromBcplDisplay(VMDisplaySize, VMDisplayScanLines)<br><br>   let VMDisplayDCB = VMDisplay + 2<br>// insert a null dcb DummyHeight/2 scan lines high first<br>   VMDisplay&gt;&gt;DS.fdcb = VMDisplayDCB<br>   VMDisplayDCB&gt;&gt;DCB.next = VMDisplayDCB + lDCB<br>   VMDisplayDCB&gt;&gt;DCB.width = 0<br>   VMDisplayDCB&gt;&gt;DCB.bitmap = 0<br>   VMDisplayDCB&gt;&gt;DCB.height = DummyHeight/2<br><br>   VMDisplayDCB = VMDisplayDCB + lDCB<br>   VMDisplay&gt;&gt;DS.ldcb = VMDisplayDCB<br>   VMDisplayDCB&gt;&gt;DCB.next = 0<br>   VMDisplayDCB&gt;&gt;DCB.height = VMDisplayHeight/2<br>   VMDisplayDCB&gt;&gt;DCB.indentation = 1<br>   VMDisplayDCB&gt;&gt;DCB.width = VMDisplayWidth<br>   VMDisplayDCB&gt;&gt;DCB.bitmap = VMDisplay + VMbitMapOffset<br><br>   // Turn on bits for pages already in core. Emulator done specially.<br>   for i=0 to PagesPerSegment-1 do DisplayVMbit(Bytes2(EmulatorSpace,i), true)<br>   for i=0 to LastRealPageNo-1-PagesPerSegment do<br>     [ let vp = VirtualPage(i)<br>       unless vp&lt;&lt;VP.segment gr LastSegment do DisplayVMbit(vp, true)<br>     ]<br>   ShowDisplayStream(VMDisplay, DSabove, dsp)<br>  ]<br><br>and DisplayVMbit(vp, turnOnBit) be<br>  [<br>    // segement selects row; hi order 4 bits address word; lo order 4 get bit<br>    let bitInWord = #100000 rshift (vp&lt;&lt;VP.page & #17)<br>    let Addr = VMDisplay + VMbitMapOffset + (vp&lt;&lt;VP.segment*VMDisplayWidth) +<br>               vp&lt;&lt;VP.page rshift 4<br>    @Addr = turnOnBit ? @Addr % bitInWord, @Addr & not bitInWord<br>  ]<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
