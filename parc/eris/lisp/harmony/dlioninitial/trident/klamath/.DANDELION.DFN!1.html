<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>DlionInitial>Trident>Klamath>DANDELION.DFN!1</title>
  </head>
  <body>
    <pre>
{File name:  Dandelion.dfnDescription: Definitions for all Dandelion Microcode,Created: 3 Jan 80,Last Edited:Amy Fasnacht 23-Jan-84 17:30:00	Move uSourceOffset from 6A to 0CD.Amy Fasnacht 17-Jan-84 15:39:43	Change keyBitsm1 to 3C from 3D.murage.pa	30-Nov-83 10:38:16	Set up Virtual Memory Map constants to more easily support sizes 32kb, 64kb, and 128kb of VMM.Amy Fasnacht/Andy Daniels, 18-Nov-83 12:11:42: Shuffle Xfer and BandBLT U registers; change comments.Daniels, 25-Oct-83 18:32:30: Move uXferType from 6D to 63 for BandBLT.Amy Fasnacht, 28-Sep-83  9:43:31: Add support for 24-bit VA spaceGrundler, 20-Sep-83 20:42:27  Changed name to .dfn.Murage, 19-Sep-83 18:35:05  Deleted Ethernet contants for Germ that are no longer used.Daniels, 15-Aug-83 13:46:36: Move uFrame from u25 to u19 to have rA = TMurage, 1983 July 21st.  3:03 PM: Accomodate changes for Germ as a result of going				  over to 32-bit procedures.Daniels, 14-Jun-83 15:31:23: Change emulator reg defs for 32-bit control links.Amy Fasnacht, 24-Mar-83 11:49:22: Add MagTpe definitions and constants, change assignments of uClockHigh, uBandStatusAmy Fasnacht,  9-Mar-83 16:58:32: Add uBufMaxHigh and uBufMaxLow for IOPMain taskAmy Fasnacht, November 1, 1982  10:49 AM: Added uDestHighSave, uSourceHighSaveTemp, uDestLowSave, delete uBLTTemp Amy Fasnacht, September 30, 1982  1:36 PM: Added uRegsKern Amy Fasnacht, September 22, 1982  2:45 PM: Delete some LSEP URegs, add uLsepTemporary Ev Neely, 27-Aug-82 10:14:33: Modified trident's CHDelRdSet to 8(was 0C) and  CHDelWrSet to 1(was 3) and removed CHdrDelRdSet from boot area. Amy Fasnacht, August 5, 1982  1:48 PM:  Modify for new IOPage layout, move all IOPage definitions to this module Amy Fasnacht, July 9, 1982  6:15 PM: Add alternate ethernet boot file numbers Chuck Fay, July 7, 1982  3:10 PM: Added TempWpl, UDstRA, and USrcWpl for BandBLTBBInit; uQuantumSA1000MaxHeadNum for SAx000Initial (for Forrest).Amy Fasnacht, July 6, 1982  11:45 AM: Add WakeupMaskOffset for Raven, move uOtherListLow, uRefreshLine, uClockHigh, uPicLength Amy Fasnacht, June 30, 1982  11:34 AM: Add definitions for new display.mc and LSEP56 Jim Frandeen, April 11, 1982  4:42 PM: Add uIOPVirtLow, High for IOP. Ev Neely, March 29, 1982  7:24 PM: Modified tridents CMemError to 0E (was 8) Ev Neely, March 24, 1982  7:39 AM: Modified tridents CRetry to 90 (was 30) Jim Frandeen, March 3, 1982  1:47 PM: Move Xfer temp registers where they will not disturb BandBlt. Jim Frandeen, February 23, 1982  5:01 PM: Add UtbCoordHigh. Amy Fasnacht, February 4, 1982  3:40 PM: Delete source socket ureg and constants, add Trident boot file number constant for EtherInitial. Neely, February 3, 1982  9:46 AM: Add uDevOrd (U 2) for TridentInitial. Jim Frandeen, February 2, 1982  2:13 PM: Add uXmitInterrupt and uE3FF for Ether. Amy Fasnacht, January 27, 1982  4:36 PM: Add uFileNumber2, add Etherinitial constants. Neely, January 14, 1982  3:01 PM: Added some TridentInitial usage comments. Amy Fasnacht, January 14, 1982  1:09 PM: Comment out tridentboot constants common to trident constants. Neely, January 13, 1982  2:01 PM: change 5 constants for 30 sector trident. Neely, January 6, 1982  4:21 PM: Add TridentInitial Registers. Jim Frandeen, January 7, 1982  2:35 PM: Rearrange registers for new TextBlt FontBody.  Register block 5. Amy Fasnacht, January 5, 1982  11:58 AM: Rearrange booting registers. Amy Fasnacht, December 21, 1981  4:08 PM: Add CPBootDevice register. Amy Fasnacht, December 14, 1981  1:57 PM: Merged Boot.df into Dandelion.df, change U0C00 to U register 0A8. Furst, December 8, 1981  1:57 PM: Add new U register UF000 (0A7).Sandman, November 17, 1981  3:36 PM: New instruction set.Jim Frandeen, November 8, 1981  5:45 PM: Rearrange display registers for smooth scrolling.Ev. Neely, October 9, 1981  2:41 PM: Merged Trident Register Defs.Jim Frandeen, July 2, 1981  9:48 AM: Rearrange registers for TextBlt.Olmstead, March 23, 1981  5:11 PM:  Remove multiple definition of uCurrentFlags introduced by last edit.Olmstead, March 23, 1981  4:05 PM:  Changed spelling of all occurrences of "uregMumble" to "uMumble"Olmstead, March 18, 1981  5:41 PM:  Re-did BandBLT's U registersOlmstead, March 18, 1981  5:40 PM:  Reserved U regs 0AB-0AF for Disk taskJim Frandeen, March 11, 1981  4:13 PM: Major reorganization.Jim Frandeen, February 26, 1981  2:49 PM: Changes for BitBlt to use more stack registers.Jim Frandeen, February 20, 1981  3:16 PM: Changes for Block}{R AND RH REGISTER DEFINITIONSSince there are no task specific registers in the machine, task identifiers are not bound to the register numbers with which they are shown.Q is reserved for the Emulator Task.Also, the stackP, STK, ib, and pc16 registers are reserved for the Emulator task.}{REGISTERS 0 - 6: EMULATOR}RegDef[TOS,	R,	0];RegDef[Hold,	R,	0];	{BBLoops}RegDef[Rbb0,	R,	0];	{BitBlt and TextBlt}RegDef[VS,	R,	0];	{BitBlt}RegDef[Mask2,	R,	0];	{BitBlt}RegDef[rYheight,	R,	0];	{BandBLT}RegDef[rCC,	R,	0];	{BandBLT}RegDef[acR,	R,	0];	{Protected, Phase0, CoreInitial, SAxx00Initial, EtherInitial, TridentInitial}RegDef[rhMDS,	RH,	0];	{top element of stack (rhMDS is VA of 64K aligned MDS)}RegDef[rhVS,	RH,	0];	{BitBlt uses fact that rhVS = rhMDS}RegDef[acRrh,	RH,	0];	{base register for IOPage for Phase0, CoreInitial, Saxx00Initial, EtherInitial, TridentInitial}RegDef[T,	R,	1];RegDef[Save,	R,	1];	{BitBlt}RegDef[VD,	R,	1];	{BitBlt}RegDef[Rbb1,	R,	1];	{BitBlt and TextBlt}RegDef[Mask1,	R,	1];	{BitBlt}RegDef[rScratch,	R,	1];	{BandBLT}RegDef[rXDisp,	R,	1];	{BandBLT}RegDef[rXwidth,	R,	1];	{BandBLT}RegDef[rB,	R,	1];	{Protected, CoreInitial, SAxx00Initial, TridentInitial}RegDef[rP,	R,	1];	{EtherBooting}RegDef[rhT,	RH,	1];	{temporary}RegDef[rhVD,	RH,	1];	{BitBlt}RegDef[rBrh,	RH,	1];	{Protected, CoreInitial, SAxx00Initial, TridentInitial}RegDef[TT,	R,	2];RegDef[Src,	R,	2];	{BitBlt}RegDef[Rbb2,	R,	2];	{BitBlt and TextBlt Rbb2 must equal TT to share MaskTbl}RegDef[rS,	R,	2];	{EtherBooting}RegDef[Temp,	R,	2];	{BitBlt}RegDef[TempDelta,	R,	2];	{BitBlt}RegDef[rYloc,	R,	2];	{BandBLT paired with u1FFF}RegDef[rLOwriteP,	R,	2];	{BandBLT paired with u1FFF}RegDef[rhTT,	RH,	2];	{temporary}RegDef[rhType,	RH,	2];	{BitBlt}RegDef[rhLOwriteP,	RH,	2];	{BandBLT}RegDef[Srh,	RH,	2];	{EtherBooting}RegDef[L,	R,	3];RegDef[Dst,	R,	3];	{BitBlt}RegDef[TempBpl,	R,	3];	{BitBlt}RegDef[TempWpl,	R,	3];	{BandBLT's special BitBlt (words per line)}RegDef[Rbb3,	R,	3];	{BitBlt and TextBlt}RegDef[rLOwriteV,	R,	3];	{BandBLT}RegDef[rUindex,	R,	3];	{BandBLT}RegDef[rLoop,	R,	3];	{BandBLT}RegDef[rFont,	R,	3];	{BandBLT}RegDef[rC,	R,	3];	{Phase0, CoreInitial, SAxx00Initial, EtherInitial, TridentInitial}RegDef[rCrh,	RH,	3];	{base register for first 64K for Phase0, CoreInitial, SAxx00Initial, EtherInitial, TridentInitial}RegDef[rhL,	RH,	3];	{local frame (RA, extended by rhL=real rhMDS)}RegDef[rhWho,	RH,	3];	{BitBlt}RegDef[rhLOwriteV,	RH,	3];	{BandBLT}RegDef[G,	R,	4];RegDef[SrcA,	R,	4];	{BitBlt}RegDef[Rbb4,	R,	4];	{BitBlt and TextBlt}RegDef[rNlines,	R,	4];	{BandBLT}RegDef[rReadP,	R,	4];	{BandBLT}RegDef[rD,	R,	4];	{Booting - Phase0, CoreInitial, SAxx00Initial, TridentInitial}RegDef[rL,	R,	4];	{Booting - EtherInitial}RegDef[rDrh,	RH,	4];	{base register for second 64K}RegDef[rhG,	RH,	4];	{global frame (RA, extended by rhG=real rhMDS)}RegDef[rhSrcA,	RH,	4];	{BitBlt}RegDef[rhReadP,	RH,	4];	{BandBLT}RegDef[rLrh,	RH,	4];	{Booting - EtherInitial}RegDef[PC,	R,	5];RegDef[DstA,	R,	5];	{BitBlt}RegDef[rReadV,	R,	5];	{BandBLT}RegDef[rDest,	R,	5];	{BandBLT}RegDef[rJunk,	R,	5];	{BandBLT--paired with uCurrentLevelCmd, but only to do u &larr; r xor ~r}RegDef[rE,	R,	5];	{Booting - Phase0, CoreInitial, SAxx00Initial, TridentInitial}RegDef[rMM,	R,	5];	{EtherInitial}RegDef[rhPC,	RH,	5];	{word address of next inst (RA, extended by rhPC=real UvChigh)}RegDef[rhDstA,	RH,	5];	{BitBlt}RegDef[rhReadV,	RH,	5];	{BandBLT}RegDef[rhDest,	RH,	5];	{BandBLT}RegDef[rErh,	RH,	5];	{Booting - Phase0, CoreInitial, SAxx00Initial, TridentInitial}RegDef[MMrh,	RH,	5];	{EtherInitial}RegDef[Rx,	R,	6];RegDef[Lcount,	R,	6];	{BitBlt}RegDef[TempB,	R,	6];	{BitBlt}RegDef[RtbChar,	R,	6];	{TextBlt Character pointed to by TextLo,Hi[Index]}RegDef[rTemp,	R,	6];	{BandBLT}RegDef[rG,	R,	6];	{Booting clock high - Protected, Etherbooting, Phase0}RegDef[rhRx,	RH,	6];	{temporary}RegDef[rhRet,	RH,	6];	{BitBlt}RegDef[rhTemp,	RH,	6];	{BandBLT}{REGISTERS 7 - 8: DISK(x000&amp;Trident)}RegDef[RAdr,	R,	7];	{Disk(x000&amp;Trident)}RegDef[rY,	R,	7];	{EtherBooting}RegDef[RHRAdr,	RH,	7];	{Disk x000}RegDef[RHAdr,	RH,	7];	{DiskTrident}RegDef[Yrh,	RH,	7];	{EtherBooting}RegDef[RCnt,	R,	8];	{Disk(x000&amp;Trident)}RegDef[rCount,	R,	8];	{EtherBooting}RegDef[RHRCnt,	RH,	8];	{Diskx000}RegDef[RHCnt,	RH,	8];	{DiskTrident}{REGISTERS 9 - B: DISPLAY/Raven/MagTape}RegDef[Line,	R,	9];	{Display}RegDef[dZ,	R,	9];	{Display}RegDef[rD0,	R,	9];	{Display}RegDef[rM,	R,	9];	{Etherbooting}RegDef[rTMa,	R,	9];	{MagTape}RegDef[rhLine,	RH,	9];	{Display}RegDef[rhdZ,	RH,	9];	{Display}RegDef[displayBase0,	RH,	9];	{Display}RegDef[Mrh,	RH,	9];	{Etherbooting}RegDef[rhTMa,	RH,	9];	{MagTape}RegDef[dX,	R,	0A];	{Display}RegDef[rD1,	R,	0A];	{Display}RegDef[rJ,	R,	0A];	{Booting clock low - Protected, Phase0, Etherbooting}RegDef[rTRfsh,	R,	0A];	{MagTape Refresh}RegDef[rhdX,	RH,	0A];	{Display}RegDef[displayBase1,	RH,	0A];	{Display}RegDef[rhTRfsh,	RH,	0A];	{MagTape Refresh}RegDef[dY,	R,	0B];	{Display}RegDef[rD2,	R,	0B];	{Display}RegDef[rEtherBootRetries,	R,	0B];	{Number of times we have attempted to boot}RegDef[RPageCount,	R,	0B];	{TridentBootDLion}RegDef[rTWc,	R,	0B];	{MagTape}RegDef[rhdY,	RH,	0B];	{Display}RegDef[displayBase2,	RH,	0B];	{Display}RegDef[rhTWc,	RH,	0B];	{MagTape}{REGISTERS C - D: ETHER}RegDef[E,	R,	0C];	{Ether}RegDef[rF,	R,	0C];	{Booting - SAxx00Initial, TridentInitial}RegDef[rWord,	R,	0C];	{EtherBooting}RegDef[rhE,	RH,	0C];	{Ether}RegDef[rFrh,	RH,	0C];	{Booting - SAxx00Initial, TridentInitial}RegDef[EE,	R,	0D];	{Ether}RegDef[rN,	R,	0D];	{Protected}RegDef[rhEE,	RH,	0D];	{Ether}{REGISTER E: IOP}RegDef[rIAd,	R,	0E];	{IOP Port}RegDef[rIOP,	R,	0E];	{IOP Port}RegDef[RHrIAd,	RH,	0E];	{IOP Port}RegDef[rhIOP,	RH,	0E];	{IOP Port}{REGISTER F: IOP/KERNEL}RegDef[rK,	R,	0F];RegDef[rTmp,	R,	0F];	{IOP Port}RegDef[RPgCnt,	R,	0F];	{TridentBoot}RegDef[RHrK,	RH,	0F];{The allocation of Link registers:#    task0    Emulator1    Emulator2    Emulator3    Emulator4    Disk5    Display/LSEP6    Ethernet7    IOP}{U REGISTER DEFINITIONSRegisters indicated by ** contain Emulator state and must not be modified.}{U REGISTER BLOCK 0 -- EMULATOR STACK}RegDef[uBlock0,	U,	0]:RegDef[passTraps,	U,	0];	{Booting}RegDef[uStack1,	U,	1];RegDef[uBadBits,	U,	1];	{SAxx00Initial - disk transfer error bits}RegDef[tiUnumHeads,	U,	1];	{TridentInitial}RegDef[stepCount,	U,	1];	{Booting}RegDef[uStack2,	U,	2];RegDef[UBitBltArg,	U,	2];	{BitBlt}RegDef[transferIOCB, U,	2];	{SAxx00Initial - base of transfer IOCB}RegDef[uDevOrd,	U,	2];	{TridentInitial}RegDef[uStack3,	U,	3];RegDef[UHeight,	U,	3];	{BitBlt}RegDef[currentCylinder,	U,	3];	{SAxx00Initial}RegDef[uStack4,	U,	4];RegDef[UDstVALo,	U,	4];	{BitBlt}RegDef[uStack5,	U,	5];RegDef[UDstBit,	U,	5];	{BitBlt}RegDef[nextPage,	U,	5];	{SAxx00Initial, TridentInitial - next page to write}RegDef[uStack6,	U,	6];RegDef[USrcVALo,	U,	6];	{BitBlt}RegDef[transferCount,	U,	6];	{SAxx00Initial, TridentInitial - number of pages requested for transfer}RegDef[uStack7,	U,	7];RegDef[USrcBit,	U,	7];	{BitBlt}RegDef[filePage,	U,	7];	{SAxx00Initial, TridentInitial - page number of file used in label}RegDef[uStack8,	U,	8];RegDef[UGray,	U,	8];	{BitBlt -- shares with USrcBpl}RegDef[USrcBpl,	U,	8];	{BitBlt -- shares with UGray}RegDef[USrcWpl,	U,	8];	{BandBLT's special BitBlt -- shares with UGray (source words per line}RegDef[germStart,	U,	8];	{SAxx00Initial, TridentInitial - first page of germ, 0=&gt; germ not yet read or not in progress}RegDef[uStack9,	U,	9];RegDef[UDstBpl,	U,	9];	{BitBlt}RegDef[seekMask,	U,	9];	{SAxx00Initial - firmware enable or driveSelect -- paired with acR -- }RegDef[uStackA,	U,	0A];RegDef[UrhVS,	U,	0A];	{BitBlt}RegDef[headMask,	U,	0A];	{SAxx00Initial - F800, head field mask in haltWord and findWord -- paired with acR -- }RegDef[uStackB,	U,	0B];RegDef[UrhVD,	U,	0B];	{BitBlt}RegDef[haltBits,	U,	0B];	{SAxx00Initial - 420 -- paired with acR -- }RegDef[uStackC,	U,	0C];RegDef[UFlags,	U,	0C];	{BitBlt}RegDef[UFindSect,	U,	0C];	{SAxx00Initial - holds 6 if SA4000, 0 if SA1000 = Find Sector mark bits}RegDef[uStackD,	U,	0D];RegDef[UWidth,	U,	0D];	{BitBlt}RegDef[topPage,	U,	0D];	{CoreInitial, SAxx00Initial, TridentInitial - next available page in map}RegDef[uStackE,	U,	0E];RegDef[uQuantumSA1000MaxHeadNum,	U,	0E];	{SAxx00Initial}RegDef[uStackF,	U,	0F];{U REGISTER BLOCK 1 -- EMULATOR}RegDef[uHeaderBlock,	UY,	1]:RegDef[uBlock1,	U,	10]:RegDef[uWP,	U,	10];	{** wakeups pending}RegDef[UvC,	U,	11];	{** rA = T low half of code (VA, extended by UvChigh)}RegDef[uPCCross,	U,	12];	{**}RegDef[uPPMask,	U,	13];	{** rA = T, constant = E000 (and BandBLT depends on it)}RegDef[uWW,	U,	14];RegDef[CPBootDevice,	U,	14];	{Booting - Phase0}RegDef[UtbWidth,	U,	14];	{TextBlt temporary}RegDef[u3FFF,	U,	15];	{** constant, rA = T}RegDef[uPMask,	U,	16];	{** rA = T; constant = 1FF8}RegDef[uChar0,	U,	17];	{BandBLT}RegDef[uRect0,	U,	17];	{BandBLT}RegDef[UtbRgFlags,	U,	17];	{TextBlt Used to save RgFlags[Char], rA = T}RegDef[uWDC,	U,	18];	{** wakeup disable counter}RegDef[uFrame,	U,	19];	{rA = T}RegDef[UGsave,	U,	19];RegDef[uDestLo,	U,	1A];	{rA = T; destination link of Xfer in progress}RegDef[UtbCount,	U,	1A];	{TextBlt Count parameter, rA = T fZ = ErrnIBnStkp}RegDef[uPsbLink,	U,	1B];	{rA = T, fZ = &larr;RH}RegDef[UvLPhigh,	U,	1B];RegDef[uT,	U,	1C];	{rA = T}RegDef[uTemp,	U,	1D];	{rA = T, fZ = &larr;ib}RegDef[UtbArgPtr,	U,	1D];	{TextBlt ArgPtr parameter from Stack, rA = T, }RegDef[UrhMDSsave,	U,	1E];RegDef[uDestHighSave,	U,	1F];	{Block}{U REGISTER BLOCK 2 -- EMULATOR}RegDef[uBlock2,	U,	20]:RegDef[uEtherBootDone,	U,	20];	{Booting - Set by EtherBoot when done}RegDef[uXTS,	U,	20];	{** Xfer Trap Status}RegDef[UvG,	U,	21];	{** rA = TT, global frame address  (VA)}RegDef[uEtherBootStatus,	U,	21];	{Booting - Nonzero = failed, 0 = successful}RegDef[UvChigh,	U,	22];	{** rA = TT, high address bits of code segment (VA)}RegDef[uTimeout,	U,	22];	{Booting - =1 if Etherboot timeout}RegDef[UvMDS,	U,	23];	{** rA = TT; MDS pointer (VA)}RegDef[uBootFileType,	U,	23];	{EtherBooting}RegDef[uBackoffMask,	U,	24];	{EtherBooting}RegDef[uSourceHighSaveTemp,	U,	24];	{Block}RegDef[uTT,	U,	24];	{rA = TT; Temp}RegDef[UtbIndex,	U,	25];	{TextBlt Index parameter from Stack, rA = TT}RegDef[uOldMask,	U,	25];	{EtherBooting}RegDef[uFaultParm0	,U,	26];	{** rA = TT; fault parameter}RegDef[uTTemp,	U,	27];	{rA = TT}RegDef[uSourceHighSave,	U,	27];	{rA = TT = 2. }RegDef[uPacketType,	U,	28];	{EtherBooting}RegDef[UBrkByte,	U,	28];	{** loaded by LST, used by Xfer}RegDef[uTrapParm0,	U,	29];	{**}RegDef[uFileNumber2,	U,	29];	{Etherbooting}RegDef[UtbMicaPos,	U,	2A];	{TextBlt parameter, rA = TT, fZ = ErrnIBnStkp}RegDef[uDestHi,	U,	2A];RegDef[uTicks,	U,	2A];RegDef[uGotFirstCode,	U,	2A];	{EtherInitial}RegDef[uNextAddress,	U,	2B];	{EtherInitial}RegDef[UvL,	U,	2B];	{** rA = TT, fZ = &larr;RH; local frame address  (VA)}RegDef[Ufsi,	U,	2C];	{rA = TT; temp used in Xfer}RegDef[UvPCpage,	U,	2D];	{** rA = TT, fZ = &larr;ib; (PC page address)}RegDef[uSourceLo,	U,	2E];	{rA = TT}RegDef[u7FF,	U,	2F];	{** constant}{U REGISTER BLOCK 3 -- EMULATOR}RegDef[uBlock3,	U,	30];RegDef[uLastInkLOwritten,	U,	30];	{BandBLT -- rA = rLoop}	RegDef[UQSave,	U,	31];	{BitBlt temp}	RegDef[uStackPSave,	U,	31];	{used by Block rA = L = 3}  RegDef[uPTC,	U,	32];	{** Process Tick Count}RegDef[uStkDepth,	U,	33]	{temp in Process, Xfer}RegDef[UWidthM1,	U,	34];	{BitBlt temp}	RegDef[Umask1,	U,	35];	{BitBlt temp}	RegDef[u1FFF,	U,	36]	{** constant}RegDef[uFaultParm1,	U,	37];	{fault parameter}RegDef[Umask2,	U,	37];	{BitBlt temp}	RegDef[UmaskL,	U,	38];	{BitBlt temp}	RegDef[uPSB,	U,	39];	{** Current PSB}RegDef[ULsave,	U,	3A];	{rA = L = 3. fZ = ErrnIBnStkp = A}RegDef[UrL,	U,	3B];	{rA = L, fZ = &larr;RH}RegDef[UrhLsave,	U,	3B];	{bank 3, 'B' = &larr; rh }		RegDef[UrLHi,	U,	3C];RegDef[uLastLevelLOwritten,	U,	3C];	{BandBLT -- rA = rLoop}RegDef[UtbFlags,	U,	3D];	{** TextBlt constant = 6400}RegDef[uCrSaveStkp,	U,	3E];	{**}RegDef[uTickCount,	U,	3F];	{** process tick interval}{U REGISTER BLOCK 4 -- EMULATOR}RegDef[uBlock4,	U,	40]:RegDef[uCrSaveTOS,	U,	40];	{**}RegDef[uCrSavePC,	U,	41];	{**}RegDef[UvQ1Hi,	U,	42];RegDef[UXsave,	U,	42];	{BitBlt temp}RegDef[UvQ1,	U,	43];RegDef[UVSsave,	U,	43];	{BitBlt temp}RegDef[UvQ2Hi,	U,	44];RegDef[USrcVALoSav,	U,	44];	{BitBlt temp}RegDef[UvQ2,	U,	45];	{rA = G}RegDef[UtbNewMicaPos,	U,	45];	{TextBlt temp}RegDef[UvQTempHi,	U,	46];RegDef[UvQTemp,	U,	47];RegDef[uIntLevel,	U,	48];	{rA = G; used in interrupts}RegDef[uOtherVirtPage,	U,	4A];	{BandBLT}RegDef[UtbBitPos,	U,	4A];	{TextBlt BitPos parameter, rA = G, fZ = ErrnIBnStkp}RegDef[UrG,	U,	4B];	{rA = G, fZ = &larr;RH}RegDef[UrhGsave,	U,	4B];	{rA = G, fZ = &larr;RH}RegDef[UrGHi,	U,	4C];RegDef[UtbMicaWidth,	U,	4D];	{TextBlt Used to save MicaWidth[Char]}RegDef[uInkHigh,	U,	4D];	{BandBLT}RegDef[uInkLow,	U,	4E];	{BandBLT}RegDef[uCurrentInkwell,	U,	4F];	{BandBLT}{U REGISTER BLOCK 5 -- EMULATOR}RegDef[uBlock5,	U,	50]:RegDef[UtbFontData	,UY,	5];	{TextBlt tbFetchFontDataLoop}RegDef[uSaveLOwritePLow	,U,	50];	{BandBLT rA = rJunk}RegDef[UtbFontBitsLo	,U,	51];	{TextBlt FontBody 0}RegDef[UtbFontBitsHi	,U,	52];	{TextBlt FontBody 1}RegDef[UtbFontWidthLo	,U,	53];	{TextBlt FontBody 2}RegDef[UtbFontWidthHi	,U,	54];	{TextBlt FontBody 3}RegDef[UtbFontCharLo	,U,	55];	{TextBlt FontBody 4}RegDef[uSaveList	,U,	56];	{BandBLT}RegDef[UtbFontCharHi	,U,	56];	{TextBlt FontBody 5}RegDef[UtbFlagsLo	,U,	57];	{TextBlt FontBody 6}RegDef[uCurrentLevelCmd	,U,	58];	{BandBLT--rA = rJunk, but any r-reg will work (u &larr; r xor ~r)}RegDef[UtbFlagsHi	,U,	58];	{TextBlt FontBody 7}RegDef[uOtherListHigh	,U,	59];	{BandBLT}RegDef[UtbHeight	,U,	59];	{TextBlt FontRecord 8}RegDef[uSaveReadPHigh	,U,	5A];	{BandBLT}RegDef[UrPC	,U,	5B];	{rA = PC, fZ = &larr;RH}RegDef[UrhPCsave	,U,	5B];	{rA = PC, fZ = &larr;RH}RegDef[UrPCHi	,U,	5C];RegDef[UDstVALoSav	,U,	5C];	{BitBlt temp}RegDef[UreturnPC	,U,	5D];	{rA = PC, fZ = &larr;ib}RegDef[UWidthW	,U,	5D];	{BitBlt temp}RegDef[uPCValid	,U,	5E];	{** rA = PC; flag for faults}{U REGISTER BLOCK 6 -- EMULATOR}RegDef[uBlock6,	U,	60];{All but 61 and 62 are destroyed by TextBlt tbFetchArg}{NOTE: BandBlt Arg registers must not be distrubed, for example, by a page fault.}RegDef[uyBlk,	UY,	6];	{BandBLT}RegDef[tbParmBlock,	UY,	6];	{TextBlt tbFetchArgLoop}RegDef[ULcntsav,	U,	60];	{BitBlt temp rA = Lcount}RegDef[uRx,	U,	60];	{Xfer temp rA = Rx}RegDef[u8000,	U,	61];	{** rA = Rx; constant = 8000, must be 61 for tbFetchArg}RegDef[uPMask2,	U,	62];	{** rA = Rx; constant = 1FF8, must be 62 for tbFetchArg}RegDef[uXferType,	U,	63];	{Type of Xfer, rA = Rx}RegDef[UtbFunction,	U,	63];	{Function parameter from TextBltArg, must be 63}RegDef[UtbLast,	U,	64];	{Last parameter from TextBltArg, must be 64}RegDef[uRect1,	U,	64];	{BandBLT, rA = rTemp = 6}RegDef[uChar1,	U,	64];	{BandBLT, rA = rTemp = 6}RegDef[UtbTextLo,	U,	65];	{TextLo parameter from TextBltArg, must be 65}RegDef[uRect2,	U,	65];	{BandBLT, rA = rTemp = 6}RegDef[uChar2,	U,	65];	{BandBLT, rA = rTemp = 6}RegDef[uRetC	,U,	66];	{Xfer Temp, rA = Rx}RegDef[UtbTextHi,	U,	66];	{TextHi parameter from TextBltArg, must be 66}RegDef[uSourceLowSave,	U,	66];	{used by Block rA = Rx = 6}RegDef[UtbFontLo,	U,	67];	{FontLo parameter from TextBltArg, must be 67}RegDef[uRetPChi,	U,	67];	{Xfer Temp, rA = Rx}RegDef[UtbFontHi,	U,	68];	{FontHi parameter from TextBltArg, must be 68}RegDef[uLOreadV,	U,	68];	{BandBLT Arg0}RegDef[UtbDstLo,	U,	69];	{DestLo parameter from TextBltArg, must be 69}RegDef[uBLreadLow,	U,	69];	{BandBLT Arg1}RegDef[UtbDstHi,	U,	6A];	{DestHi parameter from TextBltArg, must be 6A}RegDef[uBLreadHigh,	U,	6A];	{BandBLT Arg2}RegDef[UtbDstBpl,	U,	6B];	{DestBpl parameter from TextBltArg, must be 6B}RegDef[uLOwriteV,	U,	6B];	{BandBLT Arg3}RegDef[UtbMargin,	U,	6C];	{Margin parameter from TextBltArg, must be 6C}RegDef[uBandBufLow,	U,	6C];	{BandBLT Arg4}RegDef[UtbSpace,	U,	6D];	{TextBlt Space parameter from TextBltArg, must be 6D}RegDef[uBandBufHigh,	U,	6D];	{BandBLT Arg5}RegDef[UtbCoordLo,	U,	6E];	{CoordLo parameter from TextBltArg, must be 6E}RegDef[uFPTPage,	U,	6E];	{BandBLT Arg6}RegDef[uBitmapMemPage,	U,	6F];	{BandBLT Arg7}RegDef[UtbCoordHigh,	U,	6F];	{CoordHigh parameter from TextBltArg, must be 6F}{U REGISTER BLOCK 7 -- DISK(x000) &amp; TRIDENT}RegDef[uGSourceBlock,	UY,	7];RegDef[uBlock7,	U,	70];RegDef[URAdrBlk,	UY,	7];	RegDef[uSourceBlock,	UY,	7];	{EtherBooting}RegDef[bU0400,	U,	70];	{TridentBootDLion}RegDef[ULblWd5,	U,	70];	{Trident}RegDef[UFreezeCmd,	U,	70];	{Disk Transfer Run of Pages parameters}RegDef[dbUDataAddr,	U,	70];	{DiskBootDLion - Address of Data buffer in 1st 64k of real memory}RegDef[uSource2,	U,	70];	{EtherBooting - this cannot change from 70}RegDef[USaveRAdr,	U,	71];	{Disk}RegDef[dbUFindIndexMkCmd,	U,	71];	{DiskBootDLion - command used to find the Index Mark on the disk}RegDef[bUMask,	U,	71]; {TridentBootDLion}RegDef[USIP,	U,	71];	{Trident - Set in InitDLion to 0}	RegDef[UWaitCmd,	U,	72];	{Disk Transfer subroutine parameters}RegDef[dbUFindSectMkCmd,	U,	72];	{DiskBootDLion - Command used to find the sector mark on the disk}RegDef[bU0C00,	U,	72]; {TridentBootDLion}RegDef[UCStatMask,	U,	72];	{Trident - Set in InitDLion to 1E07}RegDef[bU0C04,	U,	73];	{TridentBootDLion} RegDef[USvAdrLo,	U,	73];	{Trident}	RegDef[UWdCount,	U,	73];	{Disk Transfer subroutine parameters}RegDef[dbUFreezeCmd,	U,	73];	{DiskBootDLion - Command used to stop the controller after each field}RegDef[UXferCmd,	U,	74];	{Disk Transfer subroutine parameters}RegDef[dbUHeaderAddr,	U,	74];	{DiskBootDLion - address of Header Template in bottom 64k or real memory}RegDef[bU0C0A,	U,	74];	{TridentBootDLion}RegDef[USvAdrHi,	U,	74];	{Trident}RegDef[USyncAdrMk,	U,	75];	{Disk used to optimize the code for speed}RegDef[dbUHeaderQuitMsk,	U,	75];{DiskBootDLion - mask used to detect error flags after Header Read}RegDef[UDtPtrLo,	U,	75];	{Trident}	RegDef[bU2C04,	U,	75];	{TridentBootDLion}RegDef[UMaxSectTst,	U,	76];	{Disk used to optimize the code for speed}RegDef[dbUHeadIncr,	U,	76];	{DiskBootDLion - constant used to increment head number in command words}RegDef[bUF000,	U,	76];	{TridentBootDLion }RegDef[UDtPtrHi,	U,	76];	{Trident}RegDef[UHeadSectorAddr,	U,	77];	{Disk used to optimize the code for speed}RegDef[dbULabelAddr,	U,	77];	{DiskBootDLion - address of Label template in bottom 64 k or real memory}RegDef[bUDtPtrLo,	U,	77];	{TridentBootDLion - Initialized with 100}RegDef[UScratch,	U,	77];	{Trident}RegDef[ULabelCmd,	U,	78];	{Disk Transfer Run of Pages parameters}RegDef[dbULabelDataQuitMsk,	U,	78];	{DiskBootDLion - mask used to detect error flags after Label or Data Read}RegDef[bUBitSignAdr,	U,	78];   {TridentBootDLion, TridentInitial}RegDef[UPgCnt,	U,	78];	{Trident}RegDef[ULabelLen,	U,	79];	{Disk Transfer Run of Pages parameters}RegDef[dbUReadCmd,	U,	79];	{DiskBootDLion - command word causing read operation on one field of the sector}RegDef[UCStat,	U,	79];	{Trident}RegDef[ULabelAddr,	U,	7A];	{Disk Transfer Run of Pages parameters}RegDef[dbUSectorCount,	U,	7A];	{DiskBootDLion - number of sectors to be read}RegDef[UDStat,	U,	7A];	{Trident}RegDef[ULabelQuitMsk,	U,	7B];	{Disk Transfer Run of Pages parameters}RegDef[dbUSectorsLeftInTrack,	U,	7B];	{DiskBootDLion - number of sectors left in the track being read}RegDef[UCurCyl,	U,	7B];	{Trident}RegDef[UDataCmd,	U,	7C];	{Disk Transfer Run of Pages parameters}RegDef[dbUSectorsPerTrack,	U,	7C];	{DiskBootDLion - number of Sectors per track on the disk connected to the controller}RegDef[UCurHdSec,	U,	7C];	{Trident}RegDef[UDataLen,	U,	7D];	{Disk Transfer Run of Pages parameters}RegDef[dbUSeekCompleteWaitCmd,	U,	7D];	{DiskBootDLion - command word causing the hardware to generate a service request 			while Seek complete  is true (heads have settled and drive is selected)}RegDef[URetry,	U,	7D];	{Trident}RegDef[UDataPgNum,	U,	7E];	{Disk Transfer Run of Pages parameters}RegDef[dbUVerifyCmd,	U,	7E];	{DiskBootDLion - command used to verify Headers on SA1000}RegDef[uSource0,	U,	7E];	{EtherBooting - this cannot change from 7E}RegDef[UIOCBLink,	U,	7E];	{Trident}RegDef[UDataQuitMsk,	U,	7F];	{Disk Transfer Run of Pages parameters}RegDef[dbUHeadSect,	U,	7F];	{DiskBootDLion - Head and Sector numbers for first sector of file}RegDef[uSource1,	U,	7F];	{EtherBooting - this cannot change from 7F}RegDef[UDskAdr,	U,	7F];	{Trident}{U REGISTER BLOCK 8 -- DISK(x000)}RegDef[uBlock8,	U,	80];RegDef[URCntBlk,	UY,	8];	RegDef[UFindSectMkCmd,	U,	80];	{Disk Transfer Run of Pages parameters}RegDef[dbUField,	U,	80];	{DiskBootDLion - indicates which field being processed (80=&gt;Header, 100=&gt;Label, 180=&gt;Data)}RegDef[UDMask,	U,	80];	{Trident}RegDef[USectorCount,	U,	81];	{Disk Transfer Run of Pages parameters}RegDef[dbUFieldCmd,	U,	81];	{DiskBootDLion - command for field being transferred (ReadCmd OR FreezeCmd (which has Head 			#))}RegDef[UIntMask,	U,	81];	{Trident}RegDef[UFailCount,	U,	82];	{Disk Transfer Run of Pages parameters}RegDef[dbUStatus,	U,	82];	{DiskBootDLion - final status of read of run of pages, 0=&gt;all OK.  Else field num in bits 7,8, error in 			9..15}RegDef[UBitSignAdr,	U,	82];	{Trident}RegDef[UHeaderCmd,	U,	83];	{Disk Transfer Run of Pages parameters}RegDef[dbUWdCount,	U,	83];	{DiskBootDLion - length of field being read (Header=&gt;2, Label=&gt;0C, Data=&gt;100'X)}RegDef[UCylAdr,	U,	83];	{Trident}RegDef[UHeaderLen,	U,	84];	{Disk Transfer Run of Pages parameters}RegDef[UHdOffset,	U,	84];	{Trident}RegDef[UHeaderAddr,	U,	85];	{Disk Transfer Run of Pages parameters}RegDef[UHdrOp,	U,	85];	{Trident}RegDef[UHeaderQuitMsk,	U,	86];	{Disk Transfer Run of Pages parameters}RegDef[UHCmd,	U,	86];	{Trident}RegDef[UHeaderLoopMsk,	U,	87];	{Disk Transfer Run of Pages parameters}RegDef[UHCntl,	U,	87];	{Trident}RegDef[UHeaderNotOkMsk,	U,	88];	{Disk used to optimize the code for speed}RegDef[UHMask,	U,	88];	{Trident}RegDef[UStatus,	U,	89];	RegDef[ULblOp,	U,	89];	{Trident}RegDef[UField,	U,	8A];	{Disk FinishIOCB parameters}RegDef[ULCmd,	U,	8A];	{Trident}RegDef[UInterruptMsk,	U,	8B];	{Disk FinishIOCB parameters}RegDef[ULCntl,	U,	8B];	{Trident}RegDef[ULabPgLo,	U,	8C];	{Disk used to optimize the code for speed}RegDef[ULMask,	U,	8C];	{Trident}RegDef[ULabPgAddr,	U,	8D];	{Disk used to optimize the code for speed}RegDef[UDtOp,	U,	8D];	{Trident}RegDef[USectorCntAddr,	U,	8E];	RegDef[UDCmd,	U,	8E];	{Trident}RegDef[UHeadSector,	U,	8F];	{Disk used to optimize the code for speed}RegDef[UDCntl,	U,	8F];	{Trident}{U REGISTER BLOCK 9 -- DISPLAY/BandBLT/MagTape}RegDef[uBlock9,	U,	90];RegDef[DisplayIOCBblock,	UY,	9];	{Display IOCB parameters}RegDef[uTBlock,	UY,	9];	{MagTape IOCB parameters}RegDef[uyParamBase,	UY,	9];	{Raven}RegDef[uClockHigh,	U,	90];	{Display  rA = dZ, Refresh tasks}RegDef[uBandStatus,	U,	91];	{Raven rA = rD0 -- pointer to band status word}RegDef[uPatchOffset,	U,	91];	{Display}RegDef[uTNxtIOCB,	U,	91];	{MagTape}RegDef[uLineAddress,	U,	92];	{Raven pointer to base of current scan line}RegDef[uCopyCount,	U,	92];	{Display rA = dZ}RegDef[uTCmd,	U,	92];	{MagTape}RegDef[uScrollWakeupMask,	U,	93];	{Display rA = dZ}RegDef[uTCmdNP,	U,	93];	{MagTape}RegDef[uThis,	U,	94];	{Raven pointer band record}RegDef[uPatchFlags,	U,	94];	{Display rA = dZ}RegDef[uTCmdP,	U,	94];	{MagTape}RegDef[uPatchCount,	U,	95];	{Display rA = dZ}RegDef[uTCmdWE,	U,	95];	{MagTape}RegDef[uFifoA,	U,	96];	{Display rA = dZ}RegDef[uRefreshLine,	U,	96];	{Refresh task}RegDef[uTCmdDaNF,	U,	96];	{MagTape}RegDef[uCurrentInkCmd,	U,	97];	{BandBLT}RegDef[uFifoB,	U,	97];	{Display rA = dZ}RegDef[uTCmdWc,	U,	97];	{MagTape}RegDef[uPatchSize,	U,	98];	{Display rA = dZ}RegDef[uTVirtAddrLo,	U,	98];	{MagTape}RegDef[uOtherLevelCmd,	U,	99];	{BandBLT }RegDef[uPatchLine,	U,	99];	{Display rA = dZ}RegDef[uTVirtAddrHi,	U,	99];	{MagTape}RegDef[uInterruptMask,	U,	9A];	{Raven/LSEP (contiguous CSB) paired with rD0 -- interrupt mask word}RegDef[uCurMapAddr,	U,	9A];	{Display rA = dZ}RegDef[uTSMsk,	U,	9A];	{MagTape}RegDef[uBandSize,	U,	9B];	{Raven (contiguous CSB) number of scan lines in a band}RegDef[uOddField,	U,	9B];	{Display rA = dZ}RegDef[uTSCmp,	U,	9B];	{MagTape}RegDef[uActiveScan,	U,	9C];	{Raven (contiguous CSB) number of words with image data on a line}RegDef[uCurBufAddr,	U,	9C];	{Display rA = dZ}RegDef[uTStat0,	U,	9C];	{MagTape}RegDef[uLineSize,	U,	9D];	{Raven (contiguous CSB) number of words in line buffer}RegDef[uPicLength,	U,	9D];	{Display rA = dZ}RegDef[uTStat1,	U,	9D];	{MagTape}RegDef[uTabCnt,	U,	9E];	{Raven (contiguous CSB) number of wakeups to skip after line sync}RegDef[uInitCurBufAddr,	U,	9E];	{Display}RegDef[uTLastMa,	U,	9E];	{MagTape}RegDef[uScans,	U,	9F];	{Raven (contiguous CSB) number of blank scan lines after page sync --must be last}RegDef[u3F0,	U,	9F];	{Display rA = dZ}RegDef[uTIntBitHld,	U,	9F];	{MagTape}{U REGISTER BLOCK A -- DISPLAY/BandBLT/Disk/MagTape}RegDef[uBlockA,	U,	0A0];RegDef[uOtherInkCmd,	U,	0A0];	{BandBLT}RegDef[uPatchPtr,	U,	0A0];	{Display}RegDef[uTHld,	U,	0A0];   {MagTape}RegDef[uBitmapMemLow,	U,	0A1];	{BandBLT}RegDef[uLsepInterruptMask,	U,	0A1];	{LSEP rA = dX}RegDef[uRetPage,	U,	0A2];	{BandBLT}RegDef[uInitCurMapAddr,	U,	0A2];	{Display}RegDef[uRetWord,	U,	0A3];	{BandBLT}RegDef[u3FF,	U,	0A3];	{Display}RegDef[uCurrentFlags,	U,	0A4];	{BandBLT}RegDef[uInitBorder,	U,	0A4];	{Display}RegDef[uTWakeup,	U,	0A4];   {MagTape Refresh}RegDef[uInitPicLength,	U,	0A5];	{Display }RegDef[uCursorShifted,	U,	0A6];	{Display }RegDef[DiskReserved0A7,	U,	0A7];	{Reserved for Disk task}RegDef[UF000,	U,	0A7];	{Trident - Sequence constant}RegDef[UNxtIOCBLnk,	U,	0A8];	{Disk FinishIOCB parameters}RegDef[U4000,	U,	0A8];          {Trident}RegDef[U0C00,	U,	0A9];	{Disk used to optimize the code for speed}RegDef[UStatusMsk,	U,	0AA];	{Disk FinishIOCB parameters}RegDef[UF001,	U,	0AA];          {Trident}RegDef[DiskReserved0AB,	U,	0AB];	{Reserved for Disk task}RegDef[U0400,	U,	0AB];          {Trident}RegDef[DiskReserved0AC,	U,	0AC];	{Reserved for Disk task}RegDef[U0100,	U,	0AC];          {Trident}RegDef[DiskReserved0AD,	U,	0AD];	{Reserved for Disk task}RegDef[U0C04,	U,	0AD];          {Trident}RegDef[DiskReserved0AE,	U,	0AE];	{Reserved for Disk task}RegDef[U2C04,	U,	0AE];          {Trident}RegDef[DiskReserved0AF,	U,	0AF];	{Reserved for Disk task}RegDef[U2C05,	U,	0AF];          {Trident}{U REGISTER BLOCK B -- DISPLAY/LSEP/Refresh/BandBLT/MagTape}RegDef[uBlockB,	U,	0B0];RegDef[DisplayParmBlock,	UY,	0B];	{Display CSB parameters}RegDef[uBorder,	U,	0B0];	{Display CSB parameter 8}RegDef[uTHldData,	U,	0B0];	{MagTape}RegDef[uClockLow,	U,	0B1];	{Display rA = dY, Refresh tasks}RegDef[uRefreshTemp,	U,	0B2];	{Raven Refresh task}RegDef[uNormalFifo,	U,	0B2];	{Display constant=FC00 rA = dY}RegDef[uTRefreshTemp,	U,	0B2];	{MagTape Refresh}RegDef[uClockBits,	U,	0B3];	{Display rA = dY, Refresh tasks}RegDef[uPWakeup,	U,	0B4];	{Raven Refresh task}RegDef[uLastPatchLine,	U,	0B4];	{Display rA = dY}RegDef[uTIntBit,	U,	0B4];	{MagTape}RegDef[uSaveReadPLow,	U,	0B5];	{BandBLT}RegDef[uThisIOCBAdr,	U,	0B5];	{MagTape rA=rTWc}RegDef[uSaveLOwritePHigh,	U,	0B6];	{BandBLT}RegDef[uCursorMask,	U,	0B6];	{Display rA = dY}RegDef[uThisIOCBAdrHi,	U,	0B6];	{MagTape}RegDef[uCurVisAddr,	U,	0B7];	{Display rA = dY}RegDef[uLineCount,	U,	0B7];	{Raven band line counter}RegDef[uTRefreshLine,	U,	0B7];	{MagTape Refresh}RegDef[uSaveVirtPage,	U,	0B8];	{BandBLT}RegDef[uDisplayJunk,	U,	0B8];	{Display stores here}RegDef[uFPTHigh,	U,	0B9];	{BandBLT}RegDef[uCurrentIOCBLow,	U,	0B9];	{Display CSB parameter 1}RegDef[uTMErRst,	U,	0B9];	{MagTape}RegDef[uRasterHigh,	U,	0BA];	{BandBLT}RegDef[uCurrentIOCBHi,	U,	0BA];	{Display CSB parameter 2}RegDef[uFieldCmd,	U,	0BB];	{Display CSB parameter 3}RegDef[uBitmapMemHigh,	U,	0BB];	{BandBLT}RegDef[uTWc,	U,	0BB];	{MagTape}RegDef[uOtherInkwell,	U,	0BC];	{BandBLT}RegDef[uWakeupMask,	U,	0BC];	{Display CSB parameter 4}RegDef[uFPTLow,	U,	0BD];	{BandBLT}RegDef[uSyncCmd,	U,	0BD];	{Display CSB parameter 5}RegDef[uCursorX,	U,	0BE];		{Display CSB parameter 6}RegDef[uOtherListLow,	U,	0BE];	{BandBLT}RegDef[uCursorY,	U,	0BF];		{Display CSB parameter 7}RegDef[uOtherFlags,	U,	0BF];	{BandBLT}{U REGISTER BLOCK C -- ETHER/LSEP}RegDef[uBlockC,	U,	0C0];RegDef[uEPreamble,	U,	0C2];	{Ether constant = 0AAAA}RegDef[uELastPreamble,	U,	0C3];	{Ether constant = 0AADA}RegDef[uESize,	U,	0C4];	{Ether}RegDef[uEIOCB,	U,	0C5];	{Ether}RegDef[uEBufferHi,	U,	0C6];	{Ether rA = E}RegDef[uEBuffer,	U,	0C7];	{Ether rA = E, fZ = EStrobe}RegDef[uE3FF,	U,	0C8];	{Ether constant 3FF rA = E}RegDef[uEDest0,	U,	0C9];	{Ether rA = E}RegDef[uEDest1,	U,	0CA];	{Ether}RegDef[uEDest2,	U,	0CB];	{Ether}RegDef[uDestLowSave,	U,	0CC];	{Block}RegDef[uSourceOffset,	U,	0CD];	{Block}{U REGISTER BLOCK D -- ETHER/LSEP}RegDef[uBlockD,	U,	0D0];RegDef[uETemp2,	U,	0D0];	{Ether rA = EE, fZ = &larr;EIData}RegDef[uETemp,	U,	0D1];	{Ether}RegDef[uEStatus,	U,	0D2];	{Ether}RegDef[uLsepLineCount,	U,	0D3];	{LSEP}RegDef[uEHost0,	U,	0D4];	{Ether rA = EE}RegDef[uEHost1,	U,	0D5];	{Ether rA = EE}RegDef[uEHost2,	U,	0D6];	{Ether rA = EE}RegDef[uXmitInterrupt,	U,	0D7];	{Ether fZ = EStrobe = 7}RegDef[uEOldMask,	U,	0D8];	{Ether rA = EE}RegDef[uLsepInterrupMask,	U,	0D9];	{LSEP}RegDef[uEndBandScan,	U,	0DB];	{LSEP}RegDef[uBandBufAddrLow,	U,	0DC];	{LSEP}RegDef[uLsepTemporary,	U,	0DD];	{LSEP}RegDef[uTrapParm1,	U,	0DE];	{Xfer trap parameter}RegDef[uTrapParm2,	U,	0DF];	{Xfer trap parameter}{U REGISTER BLOCK E -- ETHER/KERNEL/EMULATOR/IOP}RegDef[uBlockE,	U,	0E0];RegDef[uBufMax,	U,	0E0];	{IOP Port -- constrained by WHiByte+2}RegDef[uBufMaxLow,	U,	0E0];	{IOP Port -- constrained by WHiByte+2}RegDef[uIOPVirtLow,	U,	0E1];	{IOP}RegDef[uIOPVirtHigh,	U,	0E2];	{IOP}RegDef[uStartActive,	U,	0E3];	{LSEP}RegDef[uIOPage,	U,	0E4];		{**Do not modify}RegDef[uDisableLSEP,	U,	0E5];	{LSEP}RegDef[UKSaveDisp,	U,	0EF];RegDef[uBufMaxHigh,	U,	0E6];	{IOP}RegDef[uBootStart,	U,	0EA];	{starting memory address of boot file, IOP looks for high byte # 0}RegDef[uPFlags,	U,	0EB];	{Emulator -- fZ = &larr;RH; flags for process}RegDef[ uDiagnostic	,U,	0EC];	{IOP #0=&gt; diagnostic boot, =0&gt; emulator and germ boot}RegDef[bootDevice,	U,	0ED];	{IOP 0=&gt; wait, 1=&gt; SA4000, 2=&gt; SA1000, 3=&gt; ether, 4=&gt; floppy}RegDef[uBootBlock,	U,	0EE];	{IOP Port -- base of loaded U register block}{U REGISTER BLOCK F -- KERNEL/EMULATOR/IOP}RegDef[uBlockF,	U,	0F0];RegDef[UPCsave,	U,	0F0];	{Emulator}RegDef[UDstRA,	U,	0F1];	{BandBLT's special BitBlt; replaces UrefillType}RegDef[UrefillType,	U,	0F1];	{BitBlt}RegDef[uVirtPage,	U,	0F2];	{BandBLT}RegDef[uRasterLow,	U,	0F3];	{BandBLT}RegDef[uKSaveR,	U,	0F4];RegDef[uIOPStatusSave,	U,	0F5];RegDef[uKSaveQ,	U,	0F6];RegDef[uKernAC,	U,	0F7];RegDef[uData,	U,	0F8];	{IOP Port -- constrained by WLo+1}RegDef[uIOPIDataSave,	U,	0F9];	{rA = rK, fZ = &larr;IOPStatus}RegDef[uKTRefCnt,	U,	0F9];	{uIOPIDataSave = uKTRefCnt}RegDef[uIOPCtlSave,	U,	0FA];RegDef[u1F,	U,	0FB];	{01F'x}RegDef[uKAddr,	U,	0FC];RegDef[uRegsKern,	U,	0FC];RegDef[uKCount,	U,	0FD];RegDef[UKernMD,	U,	0FE];RegDef[UBreakID,	U,	0FF];	{UBreakID[0-3] = rK}RegDef[UKTemp,	U,	0FF];	{UBreakID = UKTemp}{KERNEL Author: R. Garner Created: 4 Oct 79, Last Edited: R. Garner, October 28, 1980  2:16 PM}Set[IOPAttnInMode, 5];Set[IOPInMode, 1];Set[IOPDisableMode, 0];Set[KBufferLoc, 0FF4], Set[KBufferEnd, 0FFF];  {First location of overlay area, had better be even!}Set[GetIOPByteLoc, 0FD0];Set[KBufferExtenLoc, Add[GetIOPByteLoc, 8]], Set[KBufferExtenEnd, Add[GetIOPByteLoc, 0F]];Set[KWaitLoc, 0FE0];Set[K1EntryLoc, 0F80];Set[K2EntryLoc, 0FBF];Set[K3EntryLoc, 0FCF];Set[KcLoc, 0FA0];  {WriteLink exploits the fact that IA.7=0}Set[K1ELoc, 0FB8];Set[KBELoc, 0FB9];MacroDef[SuppressTimingWarning, LOOPHOLE[stw]];MacroDef[WriteOK, LOOPHOLE[wok]];Set[PicLenShifted, 0CA];	{PicLength = 328'x = 808'd}{EMULATOR}{BitBlt definitions}	{BitBlt must have the following registers be distinct sets}	{Set1: VS, VD, TempDelta, TempBpl, SrcA, DstA, TempB}	{Set2: Hold, Save, Src, Dst, SrcA, DstA, Lcount}	{Set3: Rbb0, Rbb1, Rbb2, SrcA, DstA, Lcount}	{Set4: Mask1, Mask2, Src, Dst, SrcA, DstA, Lcount}	{Set5: Rbb0, Rbb1, Rbb2, Rbb3, Rbb4}{Other BitBlt definitions moved to Mesa.df}Set[X32kb,  04000];Set[X64kb,  08000];Set[X128kb, 10000]; Set[VMMSize,  X32kb];   {Uncomment the appropriate Virt. Mem. size}{Set[VMMSize,  X64kb];}  {Uncomment the appropriate Virt. Mem. size}{Set[VMMSize, X128kb];}  {Uncomment the appropriate Virt. Mem. size}Set[MapRealAddrLow, 0];Set[MapRealAddrHigh, 1];IfEqual[VMMSize, X32kb,Set[FirstRealPageToMap, 40],];  {this is the    }IfEqual[VMMSize, X64kb,Set[FirstRealPageToMap, 80],];  {next page after}IfEqual[VMMSize, X128kb,Set[FirstRealPageToMap, 00],];  {the memory map ends}IfEqual[VMMSize, X32kb,Set[FirstRealPageToMapHigh, 1],];IfEqual[VMMSize, X64kb,Set[FirstRealPageToMapHigh, 1],];IfEqual[VMMSize, X128kb,Set[FirstRealPageToMapHigh, 2],];Set[IOPageVirtual, 0FF];Set[IOPageVirtualHigh, 0];{IO PAGE LAYOUT}{Real address of the IOPage}Set[IOPage, 0];	{page number - this is rotated by 8 to get real address}Set[IOPageHigh, 2];{The IOPage is designed in this fashion for the benefit of the IOP code.  With all of the flags for the various devices located contiguously, the IOP can read them in much faster.}{DISK CSB (Trident/Shugart/Quantum) - from 20000 to 2000F hex}  Set[DiskCSBOffsetIOCB, 1];{IOP Flags Block - from 20010 to 2001F hex}  {See DLionInputOutput.mesa for a complete description.  The CP microcode is not concerned with these locations except for the maintenance panel.}  Set[MaintenancePanelOffset, 12];{LSEP Control and Status Masks - from 2001F to 20020 hex}{FLOPPY CSB - 20021 hex}{TTY CSBs - from 20022 hex to 20025 hex}{PROCESSOR CSB - from 20026 hex to 20028 hex}{MOUSE CHANGE CSB - from 20029 hex to 2002A hex}{TONE GENERATOR CSB - 2002B hex}{RS232C CSB and Parameters - from 2002C to 20036 hex}{TIME OF DAY Clock - from 20037 to 2003A hex}{MOUSE POSITION - from 2003B to 2003C hex}{KEYBOARD SPACE - from 2003D to 20043 hex}Set[IOPage.keyBitsm1, 3C];{LSEP CSB and Band Record Space - from 20044 to 20063 hex}Set[RavenRunOffset, 44];Set[RavenOverrunOffset, 45];Set[LsepRunOffset, 44];Set[LsepLowAddressOffset, 45];Set[LsepHiAddressOffset, 46];Set[LsepInterruptMaskOffset, 47];{IOP HARDWARE CONFIG SPACE - 20064 hex}{UNUSED SPACE - from 20065 to 200BB hex}{MAGTAPE CSB - from 200BC to 200BF hex}Set[CTCSBOffset, 0BC];Set[CTCSBOffset1, 0BD];	{Running word}{ETHERNET CSB - from 200C0 to 200CB hex}Set[IOPage.ECSB, 0C0];Set[ECSB.host0, 0];Set[ECSB.host1, 1];Set[ECSB.host2, 2];Set[ECSB.icb, 3];Set[ECSB.iWakeup, 4];Set[ECSB.ocb, 5];Set[ECSB.oWakeup, 6];Set[ECSB.lost, 7];Set[IOPage.ECSB.host0, Add[IOPage.ECSB, ECSB.host0]];Set[IOPage.ECSB.host1, Add[IOPage.ECSB, ECSB.host1]];Set[IOPage.ECSB.host2, Add[IOPage.ECSB, ECSB.host2]];Set[IOPage.ECSB.icb, Add[IOPage.ECSB, ECSB.icb]];Set[IOPage.ECSB.iWakeup, Add[IOPage.ECSB, ECSB.iWakeup]];Set[IOPage.ECSB.ocb, Add[IOPage.ECSB, ECSB.ocb]];Set[IOPage.ECSB.oWakeup, Add[IOPage.ECSB, ECSB.oWakeup]];Set[IOPage.ECSB.lost, Add[IOPage.ECSB, ECSB.lost]];{UNUSED SPACE - from 200CC to 200E6 hex}{DISPLAY CSB - from 200E7 to 200FF hex}  Set[DisplayCSBOffset, 0E7];  Set[IOPage.DSCB.fieldCmd, 0E9];  Set[WakeupMaskOffset, 0EA]; {used by MagTape.mc and Raven.mc}  Set[IOPage.DSCB.syncCmd, 0EB];  Set[IOPage.DCSB.cursorMap, 0F0];Set[ParamBlkSize, 9];Set[Arg0, Sub[17'd, ParamBlkSize]];MacroDef[PgCrBRANCH, BRANCH[#1, #2, 1]];MacroDef[CancelPgCross, IfEqual[#0, 1, CANCELBR[#1, 2], CANCELBR[#1, #2]]];MacroDef[CancelDisp, CANCELBR[#1, 0F]];{Trident constants}Set[CCSB64k, 1];Set[CCSBHi, 40]; {set addr of CSB for Device0 to be physical loc 20000}Set[CCSBLo, 1];Set[CNextDev, 4];Set[CCSBNextDev, 4];Set[CLastDev, 10];Set[CDsk3, 0C];Set[CDsk2, 8];Set[CDsk1, 4];Set[CDisplIOCB, 4];Set[CDisplCHdSec, 1];Set[CDisplDtPtr, 4];Set[CDisplPgCnt, 7];Set[CDisplCStat, 8];Set[CDisplDStat, 9]:Set[CDisplDHdr, 0A];Set[CDisplBSAdr, 11];Set[CDisplLblWd5, 25];Set[CDisplClntLbl, 20];Set[CRelDisplDskLbl, 10];Set[CDisplECC, 3C];Set[CNotRdy, 8];Set[CTstRecalEr, 0B];Set[CTstSkEr, 0B];Set[CRecal, 0A];Set[CTstRecal, 1];Set[CTstFirstIOCB, 10];Set[CDskCheck, 1];Set[CTestForVrf, 7];Set[CECCXfer, 0C8];Set[CWURdy, 60];Set[CWUAnyAtt, 10];Set[CWUIndxFnd, 20];Set[CWUSecFnd, 30];Set[CWUDtReq, 40];Set[CHDelRdSet, 8];Set[CHDelWrSet, 1];Set[CLDelRdSet, 2]; Set[CDDelRdSet, 2]; 		{Constants may have to  be redefined}Set[CHNRDelRdRst, 2]; Set[CHWVDelRdRst, 5]; Set[CLWVDelRdRst, 3];Set[CCtlTag, 20];Set[CHdTag, 40];Set[CCylTag, 80];Set[CHdAdv, 1];Set[CRead, 40];Set[CRstAtt, 40]; 		{this is actually the Read bit}Set[CMaxSec, 1D];Set[CRetry, 5A]; 		{look at 90 headers before giving up}Set[CMemError, 0E];Set[CHdrNotFnd, 10];Set[CRecalError, 20];Set[CGoodCompl, 40];Set[CInProgress, 80];{MAGTAPE CONSTANTS}Set[CTForceRqOff, 20];	{Turn ForceReq bit off}Set[CTImmediateHalt, 1];	{Locate ImmediateHalt bit in Stat0}Set[CTImmediateHaltStatBit, 42];	{ImmediateHalt bit in Stat1}Set[CTDataMode, 10];	{Set DataMode in command word}Set[CTIFENBit, 40];	{IFEN bit for command word}Set[CT0Idby, 8];	{Location of IDBY in Stat0}Set[CTContClr, 8];	{Used to turn ControllerClear on}Set[CTIlgCmd, 6];	{IllegalCmd = 1, LastIOCB = 1}Set[CTImprEnd, 12];	{ImproperEnd = 1, LastIOCB = 1}Set[CTLastIOCB, 2];	{LastIOCB = 1}Set[CTStrtErr, 22];	{StartError = 1, LastIOCB = 1}Set[CTCmdWasRwnd, 0A];	{CmdWasRwnd = 1, LastIOCB = 1}Set[CTContIOCB, 1];	{ContIOCB = 1, Finished with this IOCB, continuing with next one}Set[CTClrMEr, 9];	{ClearMemError bit}Set[CTMETst, 40];	{Test for mem error}Set[CTMemEr, 82]; 	{MemErrorFound, LastIOCB bits}Set[CTEnReq, 1]; 	{Enable Req only on}{BOOTING CONSTANTSAuthor:  Amy FasnachtCreated:  December 3, 1981  11:02 AM}{Boot Time Error Codes}Set[bootDeviceError, 1];Set[bootNullGerm, 2];Set[bootBrokenChain, 3];	{boot chain broken}Set[bootIllegalCommand, 4];	{IOP sent illegal command}Set[bootTrap, 5];	{trapped through control store 0}Set[bootNoDiagnostics, 6];Set[bootNoEmulator, 7];Set[bootNoGerm, 8];{CoreInitial, SAxx00Initial constants}IfEqual[VMMSize, X32kb,Set[mapPages, 40],];	{number pages dedicated to map}IfEqual[VMMSize, X64kb,Set[mapPages, 80],];	{number pages dedicated to map}IfEqual[VMMSize, X128kb,Set[mapPages, 00],];	{number pages dedicated to map}{Notice that these values are left rotated into the high byte and a 1 is then subtracted form the resulting value; hence we have 3FFF,7FFF, &amp; FFFF. }Set[virtualIOPage, 0FF];	{virtual page number of IO page}Set[vacant, 60];	{map flags for a vacant page}Set[present, 10];	{map flags for a referenced and present page}{DiskBootDLion constants}Set[CDataField, 0C0];	{UField&larr;2*CDataField =&gt; DataField being read}Set[CDataLen, 0FF];	{Length of data field-1 (can't have a 9 bit constant)}Set[CHeaderField, 40];	{UField&larr;2*CHeaderField =&gt; Header Field being read}Set[CHeaderLen, 2];	{Length of header field}Set[CLabelField, 80];	{UField&larr;2*LabelField =&gt; label Field being read}Set[CLabelLen, 0C];	{Length of Label field}Set[CVerifyErrMsk, 5F];	{Verify Error Mask for SA1000 Headers}{TridentBoot Constants}{Set[CWURdy, 60];Set[CWUIndxFnd, 20];Set[CWUSecFnd, 30];Set[CWUDtReq, 40];}Set[CDelRdSet, 2]; Set[CDelRdRst, 2]; {Set[CCtlTag, 20];Set[CHdTag, 40];Set[CRecal, 0A];Set[CRead, 40];}{EtherBootDLion, EtherInitial Constants}Set[Off, 0];Set[EnableTransmit, 1];Set[EnableTransmitLastWord, 3];Set[EnableTransmitDefer, 5];Set[EnableReceive, 1]; Set[Other, 0];Set[UnderRun, 1];Set[Collision, 2];Set[CollisionUnderRun, 3]; Set[InitialCountdown, 14];	{14 hex = 20 decimal, 20 x 51.2 us ~ 1 ms for delay before retransmission}Set[germMapOffset, 2];Set[sFirstGermRequestHigh, 001'b];	{start of germ request in SD - high byte}Set[sFirstGermRequestLow, 240'b];	{start of germ request in SD - low byte}Set[Request.version, Add[sFirstGermRequestLow, 00'b]];	Set[RequestVersionHigh, 7];	Set[RequestVersionLow, 56'b];Set[Request.action, Add[sFirstGermRequestLow, 01'b]];	Set[inLoad, 0];Set[Request.location.deviceType, Add[sFirstGermRequestLow, 02'b]];	Set[germEthernet, 6];Set[Request.location.devOrd, Add[sFirstGermRequestLow, 03'b]];	Set[ethernetDeviceOrdinal, 0];Set[Request.location.ethernetBootFileNumber0, Add[sFirstGermRequestLow, 04'b]];	Set[ethernetBootFileNumberHigh, 0];Set[Request.location.ethernetBootFileNumber1, Add[sFirstGermRequestLow, 05'b]];	Set[ethernetBootFileNumberMiddle, 0AA];Set[Request.location.ethernetBootFileNumber2, Add[sFirstGermRequestLow, 06'b]];	Set[ethernetBootFileNumberLowShugart, 40'b];	Set[ethernetBootFileNumberLowTrident, 41'b];	Set[ethernetBootFileNumberLowShugartAlternate, 42'b];	Set[ethernetBootFileNumberLowTridentAlternate, 43'b];Set[Request.location.ethernetNetworkNumber0, Add[sFirstGermRequestLow, 07'b]];	Set[ethernetBootNetworkNumberHigh, 0];Set[Request.location.ethernetNetworkNumber1, Add[sFirstGermRequestLow, 10'b]];	Set[ethernetBootNetworkNumberLow, 0];Set[Request.location.ethernetHostNumber0, Add[sFirstGermRequestLow, 11'b]];Set[Request.location.ethernetHostNumber1, Add[sFirstGermRequestLow, 12'b]];Set[Request.location.ethernetHostNumber2, Add[sFirstGermRequestLow, 13'b]];Set[Request.location.ethernetSocket, Add[sFirstGermRequestLow, 14'b]];	Set[ethernetBootSocket, 12'b];Set[germPageHigh, 0];Set[germPageLow, 1];{InitDLion.mc Constants}Set[CClearMemError, 0C];	{constant used to signal that a memory error has occured- put into the final device status}Set[CHeadMsk, 0F9];	{Mask used to detect Read operations.}Set[CSA4MaxSectTst, 227'D];	{256 - number of sectors in a track = 256-16-1 = 239 for the SA1000.  Used to cause PgCarryBr  &lt;=&gt; sector number+UMaxSectTst+1 &gt;= 256.  The "+1" comes from the fact that a U register is being stored in the same instruction as the test is being done.}Set[CSA1MaxSectTst, 239'D];Set[CSA1ErrMsk, 7F];{mask used to turn off irrelevant error flags in raw status for the SA4000 drive (does not include Header Tag)}Set[CSA4ErrMsk, 3F];{256 - number of sectors in a track = 256-28-1 = 227 for the SA4000.  Used to cause PgCarryBr  &lt;=&gt; sector number+UMaxSectTst+1 &gt;= 256.  The "+1" comes from the fact that a U register is being stored in the same instruction as the test is being done.}Set[CAddrMkHi, 0A1];	{constants which define the address mark for the SA1000}Set[CAddrMkLo, 041];{Phase0 Constants}Set[stepBit, 80];	{control bits, low byte}Set[inBit, 40];Set[firmwareEnable, 20];Set[driveSelectBit, 4];	{control bits, high byte}Set[faultClearBit, 2];Set[faultClearCmd, Or[driveSelectBit, faultClearBit]];	{useful combinations}Set[SA1000Bit, 20];	{status bits}{IOP Constants}Set[IOPOutMode, 2];	{IOP port output mode}Set[IOPInMode, 1];	{IOP port input mode}Set[IOPAWMode, 3];	{IOP port alwaysWU mode}{Protected Area DefinitionsThe protected area of control store holds those microinstructions that must not be disturbed while the IOP interprets the boot file residing in main storage.  In particular, the IOP task, the memory refresh task, the emulator idle loop, the error trap location (location 0), and maintenance panel routines}Set[ProtectStart, 0], Set[ProtectFence, 0FF];Set[IdleLoc, 1], Set[Maintenance1Loc, 2], Set[Maintenance2Loc, 3], Set[Maintenance3Loc, 4];Set[ErrorHandlerLoc, 100];</pre>
  </body>
</html>
