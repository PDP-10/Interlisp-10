{File name Lisp.mc -- modified for Punt testingDescription:  DandeLion InterLisp EmulatorAuthor: PurcellCreated: June 8, 1981 on mem content trapLast edited: Charnley,  23-Mar-84 10:34:55 added L1 set in FNXLast edited: Charnley,  8-Dec-83 14:12:11 added sink1 orgLast edited: Charnley, 17-Oct-83 16:50:25Last edited: Purcell 31-Jul-83 17:32:28 fix FNXCross not to depend on S which may be distorted by SCar5Last Edited: Lichtenberg  31-Jul-83 18:13:40 :: Steve: read comment where you made last change - had to add a clickLast edited: Charnley, 20-Jul-83 11:45:32Last edited: Charnley, April 14, 1983  11:04 AM; MUL tail addedLast edited: Purcell, April 6, 1983  6:34 PM; FugatoLast edited: Purcell, March 6, 1983  6:18 PM  pad base of stack twice not onceLast edited: Purcell, February 5, 1983  11:42 AM;Last edited: Purcell, December 27, 1982  9:52 PM; segmentcrossingLast edited: Purcell, July 27, 1982  12:34 PM}{use DandeLisp.df, Dandelion.df and Mesa.df for defs}SetTask[0];{*************************}{Traps and Errors:   do hard reset}{*************************}sink2:	c2;sink3:	c3;sink1:	at[B1sink1],	uRx _ Rx, CANCELBR[$, 0F],	c1;	uTT _ TT,	c2;	Rx _ 23,	c3;	Rx _ Rx LRot8, 	c1;	Rx{9000=2328h} _ Rx +28,	c2;	Q _ Rx +Q{error#}, GOTO[MPWait],	c3;ErrTrap:	Rx _ RRot1 ErrnIBnStkp, ClrIntErr, CANCELBR[$, 0F],	c1, at[0];ErrLoop:	Xbus _ Rx LRot0, XwdDisp,	c2;	Q _ MStatus, XLDisp, DISP2[CSParErr],	c3;CSParErr:	Q _ 0+1, KCtl _ 0, CANCELBR[sink2, 3],	c1, at[0,4,CSParErr];{MP9001}LMemErr:	Noop, BRANCH[VirtAddrErr, EmuMemErr, 1],	c1, at[1,4,CSParErr];StackErr:	Q _ 2, CANCELBR[sink2, 3],	c1, at[2,4,CSParErr];{MP9002}IBEmptyErr:	Q _ 3, CANCELBR[sink2, 3],	c1, at[3,4,CSParErr];{MP9003}VirtAddrErr:	Q _ 4, GOTO[sink3],	c2;{MP9004}EmuMemErr:	Q _ 5, GOTO[sink3],	c2;{MP9005}{*************************	IVAR, IVARX, PVAR, PVARX, FVAR, FVARX, STOREN	25%  4 clicks**************************}{L0 set to low nible of opcode; set L3 to 0-3 for I,P,F or S var}IVAR:	MAR _ S _ [rhS, S + 1], GOTO[IVar1], L3 _ 0,	c1, opcode[100'b];{40}	MAR _ S _ [rhS, S + 1], GOTO[IVar1], L3 _ 0,	c1, opcode[101'b];	MAR _ S _ [rhS, S + 1], GOTO[IVar1], L3 _ 0,	c1, opcode[102'b];	MAR _ S _ [rhS, S + 1], GOTO[IVar1], L3 _ 0,	c1, opcode[103'b];	MAR _ S _ [rhS, S + 1], GOTO[IVar1], L3 _ 0,	c1, opcode[104'b];	MAR _ S _ [rhS, S + 1], GOTO[IVar1], L3 _ 0,	c1, opcode[105'b];	MAR _ S _ [rhS, S + 1], GOTO[IVar1], L3 _ 0,	c1, opcode[106'b];IVARX:	MAR _ S _ [rhS, S + 1], GOTO[IVar1], L3 _ 0,	c1, opcode[107'b];PVAR:	MAR _ S _ [rhS, S + 1], GOTO[PVar1], L3 _ 1,	c1, opcode[110'b];{48}	MAR _ S _ [rhS, S + 1], GOTO[PVar1], L3 _ 1,	c1, opcode[111'b];	MAR _ S _ [rhS, S + 1], GOTO[PVar1], L3 _ 1,	c1, opcode[112'b];	MAR _ S _ [rhS, S + 1], GOTO[PVar1], L3 _ 1,	c1, opcode[113'b];	MAR _ S _ [rhS, S + 1], GOTO[PVar1], L3 _ 1,	c1, opcode[114'b];	MAR _ S _ [rhS, S + 1], GOTO[PVar1], L3 _ 1,	c1, opcode[115'b];	MAR _ S _ [rhS, S + 1], GOTO[PVar1], L3 _ 1,	c1, opcode[116'b];PVARX:	MAR _ S _ [rhS, S + 1], GOTO[PVar1], L3 _ 1,	c1, opcode[117'b];FVAR:	MAR _ S _ [rhS, S + 1], L2 _ 0,	c1, opcode[120'b];{50}	 uTOSH _ MDR _ TOSH, DISP3[VnoCar0, 4], L3 _ 4,	c2;	MAR _ S _ [rhS, S + 1], L2 _ 1,	c1, opcode[121'b];	 uTOSH _ MDR _ TOSH, DISP3[VnoCar0, 4], L3 _ 4,	c2;	MAR _ S _ [rhS, S + 1], L2 _ 2,	c1, opcode[122'b];	 uTOSH _ MDR _ TOSH, DISP3[VnoCar0, 4], L3 _ 4,	c2;	MAR _ S _ [rhS, S + 1], L2 _ 3,	c1, opcode[123'b];	 uTOSH _ MDR _ TOSH, DISP3[VnoCar0, 4], L3 _ 4,	c2;	MAR _ S _ [rhS, S + 1], L2 _ 4,	c1, opcode[124'b];	 uTOSH _ MDR _ TOSH, DISP3[VnoCar0, 4], L3 _ 4,	c2;	MAR _ S _ [rhS, S + 1], L2 _ 5,	c1, opcode[125'b];	 uTOSH _ MDR _ TOSH, DISP3[VnoCar0, 4], L3 _ 4,	c2;	MAR _ S _ [rhS, S + 1], L2 _ 6,	c1, opcode[126'b];	 uTOSH _ MDR _ TOSH, DISP3[VnoCar0, 4], L3 _ 4,	c2;FVARX:	MAR _ S _ [rhS, S + 1], L2 _ 7,	c1, opcode[127'b];	 uTOSH _ MDR _ TOSH, DISP3[VnoCar0, 4], L3 _ 4,	c2;STOREN:	MAR _ S _ [rhS, S + 1], GOTO[SVar1],  L3 _ 5,	c1, opcode[74'b];{3C}IVar1:	MDR _ TOSH, DISP3[VnoCar0],	c2;PVar1:	MDR _ TOSH, DISP3[VnoCar0, 1],	c2;SVar1:	MDR _ TOSH, DISP3[VnoCar0, 5],	c2;{place these intructions for dispatch at VCar1 and for pageCross dispatch}	S _ S + 0FF + 1, GOTO[VCar1],	c3, at[2,8,VnoCar0];	S _ S + 0FF + 1, GOTO[VCar1],	c3, at[3,8,VnoCar0];	S _ S + 0FF + 1, GOTO[VCar1], L3 _ 4,	c3, at[6,8,VnoCar0];	S _ S + 0FF + 1, GOTO[VCar1],	c3, at[7,8,VnoCar0];VCar1:	MAR _ [rhS, S + 0], L3Disp, {retry the stack ref}	c1;	MDR _ TOSH, DISP3[VnoCar0],	c2;	Q _ uIVar, L2Disp, GOTO[V2],	c3, at[0,8,VnoCar0];	Q _ PV, L2Disp, GOTO[V2],	c3, at[1,8,VnoCar0];	Q _ PV, L2Disp, GOTO[V2],	c3, at[4,8,VnoCar0];	Q _ S - ib,{ever tested %?}	c3, at[5,8,VnoCar0];{	MAR _ S _ [rhS, S + 1], GOTO[VoffX],	c1;}V2:	MAR _ S _ [rhS, S + 1], DISP4[Voff, 8],	c1;Voff:	 MDR_TOS, Rx_Q+ 0, L2_2, CANCELBR[Var, 2],WriteOK,	c2, at[8, 10, Voff];	 MDR_TOS, Rx_Q+2, L2_2, CANCELBR[Var,2],WriteOK,	c2, at[9,10, Voff];	 MDR_TOS, Rx_Q+4, L2_2, CANCELBR[Var,2],WriteOK,	c2, at[0A,10, Voff];	 MDR_TOS, Rx_Q+ 6, L2_2, CANCELBR[Var,2],WriteOK,	c2, at[0B,10, Voff];	 MDR_TOS, Rx_Q+8, L2_2, CANCELBR[Var,2],WriteOK,	c2, at[0C,10, Voff];	 MDR_TOS, Rx_Q+0A, L2_2,CANCELBR[Var,2],WriteOK, c2, at[0D,10, Voff];	 MDR_TOS, Rx_Q+0C, L2_2, CANCELBR[Var,2],WriteOK, c2, at[0E,10, Voff];VoffX:	 MDR_TOS, Rx_Q+ ib, L2_3, CANCELBR[VarX, 3],WriteOK, c2, at[0F,10, Voff];Var:	rhRx _ nRhS, GOTO[Var2],	c3;VarX:	rhRx _ nRhS, GOTO[Var2],	c3;Var2:	MAR _ [rhRx, Rx + 0], L3Disp,	c1;	[] _ S xor uStkLimO, ZeroBranch, DISP3[IVar3, 2],	c2;IVar3:	TOSH _ MD, L2Disp, BRANCH[Var4, StkOvr1],	c3, at[2, 8, IVar3];PVar3:	TOSH _ MD, L2Disp, BRANCH[Var4, StkOvr1],	c3, at[3, 8, IVar3];SVar3:	TOSH _ MD, L2Disp, BRANCH[Var4, StkOvr1],	c3, at[7, 8, IVar3];Var4:	MAR _ Q _ [rhRx, Rx + 1], BRANCH[$, varPcX, 0E{2}],	c1;	PC _ PC + PC16, L2 _ L2.0, IBDisp, DISP2[varEnd],	c2;varPcX:	PC _ PC + 1, L2 _ L2.0, IBDisp, DISP2[varEnd],	c2;DNI.TOSg: {common tail}varEnd:	TOS _ MD, L2 _ L2.0, DISPNI[OpTable],	c3, at[0, 4, varEnd];varEndCar:	Q _ 80'd, GOTO[sink1], {"impossible"}	c3, at[2, 4, varEnd];{MP9080}{Stack Limit:}StkOvr1:	MAR _ Q _ [rhRx, Rx + 1],  BRANCH[$, varPcXov, 0E{2}],	c1;	PC _ PC + PC16, CANCELBR[varEndOv, 2],	c2;varPcXov:	PC _ PC + 1, CANCELBR[varEndOv, 2],	c2;varEndOv:	TOS _ MD, GOTO[StackOverflow],	c3;{*******************************	PVAR_, PVARX_, IVARX_	4%  2 clicks*******************************}SPVAR:	MAR _ Q _ [rhPV, PV + 0 + 1], GOTO[SVar],	c1, opcode[130'b];{58}	MAR _ Q _ [rhPV, PV + 2 + 1], GOTO[SVar],	c1, opcode[131'b];	MAR _ Q _ [rhPV, PV + 4 + 1], GOTO[SVar],	c1, opcode[132'b];	MAR _ Q _ [rhPV, PV + 6 + 1], GOTO[SVar],	c1, opcode[133'b];	MAR _ Q _ [rhPV, PV + 8 + 1], GOTO[SVar],	c1, opcode[134'b];	MAR _ Q _ [rhPV, PV + 0A + 1], GOTO[SVar],	c1, opcode[135'b];	MAR _ Q _ [rhPV, PV + 0C + 1], GOTO[SVar],	c1, opcode[136'b];SVar:	MDR _ TOS, Rx_Q, rhRx_nRhS, BRANCH[SVNoCar, SVCarry, 1],	c2;SVCarry:	Rx _ Q + 0FF +1,	c3;	MAR _ [rhRx, Rx + 0],	c1;	MDR _ TOS,	c2;SVNoCar:	PC _ PC + PC16, GOTO[SVTail],	c3;SPVARX:	MAR _ Q _ [rhPV, PV + ib + 1],	c1, opcode[137'b];{5F}	MDR _ TOS, Rx_Q, rhRx_nRhS, BRANCH[SVXNoC, SVXCar, 1],	c2;SVXCar:	Rx _ Q + 0FF +1, GOTO[SVCar1],	c3;SIVARX:	rhRx_nRhS,     {1% 3 clicks}	c1, opcode[142'b];{62}	Rx _ uIVar,	c2;	Rx _ Rx + ib + 1, GOTO[SVCar1],	c3;SVCar1:	MAR _ [rhRx, Rx + 0],	c1;	MDR _ TOS,	c2;SVXNoC:	PC _ PC + 1,	c3;SVTail:	MAR _ [rhRx, Rx - 1], L2 _ L2.0,	c1;	MDR _ TOSH, IBDisp, DISP2[DNI.nop], WriteOK,	c2;DNI.nop: {common tail}	L2 _ L2.0, DISPNI[OpTable],	c3;CantGetHere:	Q _ 88'd, GOTO[sink1],	c3, at[2, 4, DNI.nop];{*******************************	GVAR	3%  5 clicks*******************************}GVAR:	MAR _ S _ [rhS, S + 1],	c1, opcode[140'b];{60}	MDR _ TOSH, TT _ ib, BRANCH[$, GVCross, 1],	c2;GVnoCross:	TT _ TT LRot8,	c3;	MAR _ S _ [rhS, S + 1],	c1;	MDR _ TOS, rhTT _ uValHigh, CANCELBR[$, 2], WriteOK,	c2;	TT _ (TT or ib) LShift1,	c3;	Map _ Q _ [rhTT,TT], L0 _ L0.RedoGV,	c1;	L1 _ L1.PopOnly,	c2;	Rx _ rhRx _ MD, XRefBr,	c3;RedoGV:	MAR_ [rhRx, Q + 0], BRANCH[GVMap,$],	c1, at[L0.RedoGV,10,RMapFixCaller];	[] _ S xor uStkLimO, ZeroBranch,	c2;	TOSH _ MD, BRANCH[$, GVStkOvr],	c3;	MAR _ Q _ [rhRx, Q + 1],  L2 _ L2.0,	c1;	PC _ PC + 1 + PC16, IBDisp, CANCELBR[DNI.TOSg, 0],	c2;GVMap:	CALL[RLMapFix]{will return to RedoGV},	c2;{Stack Limit:}GVStkOvr:	MAR _ Q _ [rhRx, Q + 1], 	c1;	PC _ PC + 1 + PC16, CANCELBR[$,2],	c2;	TOS _ MD, GOTO[StackOverflow],	c3;{page cross}GVCross:	S _ S + 0FF + 1,	c3;	MAR _ [rhS, S + 0],	c1;	MDR _ TOSH, GOTO[GVnoCross],	c2;{*******************************	GVAR_  (UFN)*******************************}{*******************************	PVARd_	2%  4 clicks*******************************}SPVARd:	MAR _ Q _ [rhPV, PV + 0 + 1], GOTO[SVarD],	c1, opcode[270'b];{B8}	MAR _ Q _ [rhPV, PV + 2 + 1], GOTO[SVarD],	c1, opcode[271'b];	MAR _ Q _ [rhPV, PV + 4 + 1], GOTO[SVarD],	c1, opcode[272'b];	MAR _ Q _ [rhPV, PV + 6 + 1], GOTO[SVarD],	c1, opcode[273'b];	MAR _ Q _ [rhPV, PV + 8 + 1], GOTO[SVarD],	c1, opcode[274'b];	MAR _ Q _ [rhPV, PV + 0A + 1], GOTO[SVarD],	c1, opcode[275'b];	MAR _ Q _ [rhPV, PV + 0C + 1], GOTO[SVarD],	c1, opcode[276'b];SVarD:	MDR _ TOS, Rx _ Q, rhRx _ nRhS, BRANCH[$, SVDCarry, 1],	c2;SVDcont:	PC _ PC + PC16,	c3;	MAR _ [rhRx, Rx - 1],	c1;	MDR _ TOSH, CANCELBR[$, 2], WriteOK,	c2;	Noop,	c3;	MAR _ [rhS, S + 0],	c1;	S _ S - 1,	c2;	TOS _ MD,	c3;	MAR _ [rhS, S + 0], L2 _ L2.0,	c1;	S _ S - 1, IBDisp,	c2;DNI.TOSHg: {common tail}	TOSH _ MD, L2 _ L2.0, DISPNI[OpTable],	c3;SVDCarry:	Rx _ Rx + 0FF +1,	c3;	MAR _ [rhRx, Rx + 0],	c1;	MDR _ TOS, GOTO[SVDcont],	c2;{*************************	GETBASEN	3%  3 clicks**************************}GETBASEN:		TT _ TOS + ib, CarryBr, L2 _ L2.0,	c1, opcode[310'b];{C8}	Rx{TOSH+1} _ TOSH+1, BRANCH[$, GBNseg],	c2;	rhTT _ TOSH LRot0,	c3;MapGBN:	Map _ Q _ [rhTT,TT], L0 _ L0.RedoGBN,	c1;	PC _ PC + 1, L1 _ L1.DecDec,	c2;	Rx _ rhRx _ MD, XRefBr,	c3;RedoGBN:	MAR_ [rhRx,Q+0], BRANCH[GBNMap,$],	c1,at[L0.RedoGBN,10,RMapFixCaller];	TOSH _ smallpl, IBDisp, GOTO[DNI.TOSg],	c2;{	TOS _ MD, L2 _ L2.0, DISPNI[OpTable],	c3;}GBNMap:	CANCELBR[RLMapFix, 3]{will return to RedoGBN},	c2;GBNseg:	rhTT _ Rx{TOSH+1} LRot0,  GOTO[MapGBN],	c3;{*************************	GETBASEPTRN (base, 1st byte=offset)**************************}GETBASEPTRN:		TT _ TOS + ib, CarryBr, 	c1, opcode[311'b];{C9}	Rx{TOSH+1} _ TOSH+1, BRANCH[$, BPseg],	c2;	rhTT _ TOSH LRot0,	c3;MapBP:	Map _ Q _ [rhTT,TT], L0 _ L0.RedoBP,	c1;	PC _ PC + 1, L1 _ L1.DecDec,	c2;	Rx _ rhRx _ MD, XRefBr,	c3;RedoBP:	MAR_ [rhRx, Q + 0], BRANCH[BPMap,$],	c1,at[L0.RedoBP,10,RMapFixCaller];	TOSH _ 0FF,	c2;	TOSH _ MD and TOSH,	c3;	MAR_ [rhRx, Q + 1], L2 _ L2.0,	c1;	IBDisp, CANCELBR[DNI.TOSg, 0],	c2;BPMap:	CALL[RLMapFix]{will return to RedoBP},	c2;BPseg:	rhTT _ Rx{TOSH+1} LRot0, GOTO[MapBP],	c3;{*************************	GETBASEBYTE:  {ptr, disp}	3%  4.5 clicks**************************}GETBASEBYTE:   {ptr, disp}	MAR _ [rhS, S], S _ S -1,	c1, opcode[302'b];{C2}	Ybus _ TOSH xor smallpl, NZeroBr, CANCELBR[$,2],	c2;	TT _ MD{ptr}, BRANCH[$, ufnBY],	c3;	MAR _ [rhS, S], S _ S - 1, L1 _ L1.PushOnly,	c1;	Rx _ TOS RShift1, YDisp, BRANCH[$, BYCarry, 1],	c2;BYret:	rhTT _ MD{ptrH}, TT _ TT + Rx, CarryBr, BRANCH[BYeven, $, 0E],	c3;BYodd:	Map _ [rhTT, TT], {L0 _ L0.BYRedoO,} BRANCH[$, BYOseg],	c1;	Q _ {u}0FF,  L0 _ L0.BYRedoO,	c2;	Rx _ rhRx _ MD, XRefBr, 	c3;BYRedoO:	MAR _ [rhRx, TT + 0],  BRANCH[BYMapUDO,$],	c1, at[L0.BYRedoO,10, RMapFixCaller];	PC _ PC + PC16, L2 _ L2.0, IBDisp,	c2;	TOS _ MD and Q, L2 _ L2.0, DISPNI[OpTable],	c3;{**}BYeven:	Map _ [rhTT, TT],  BRANCH[$, BYEseg],	c1;	Noop,	c2;	Rx _ rhRx _ MD, XRefBr,	c3;{**}BYedoE:	MAR_ [rhRx, TT + 0], L0 _ L0.BYRedoE, BRANCH[BYMapUDE,$],	c1, at[L0.BYRedoE,10, RMapFixCaller];	Q _ ~0FF, L2 _ L2.0,	c2;	TOS _ MD and Q,	c3;	TOS _ TOS LRot8,	c1;	PC _ PC + PC16, IBDisp, GOTO[DNI.nop],	c2;ufnBY:	Rx _ 302'b, CANCELBR[ufn2incS, 3]	c1;BYMapUDE:	CALL[RLMapFix],	c2;BYMapUDO: CALL[RLMapFix],	c2;{page cross:}BYCarry:	S _ S - 0FF, CANCELBR[$, 0F],	c3;	MAR _ [rhS, S + 0],	c1;	S _ S - 1, GOTO[BYret], Ybus _ TOS, YDisp,	c2;BYOseg:	Q _ rhTT + 1, LOOPHOLE[byteTiming],	c2;	rhTT _ Q LRot0, GOTO[BYodd],	c3;BYEseg:	Q _ rhTT + 1, LOOPHOLE[byteTiming],	c2;	rhTT _ Q LRot0, GOTO[BYeven],	c3;{*************************PUTBASEN:   {ptr, val => ptr}	1%  4 clicks**************************}PUTBASEN:	MAR _ [rhS, S], S _ S - 1,	c1, opcode[315'b];{CD}	Ybus _ TOSH xor smallpl, NZeroBr, CANCELBR[$, 2],	c2;	Rx _ MD{ptr}, BRANCH[$, ufnPUTB],	c3;	MAR _ [rhS, S], S _ S - 1, L0 _ L0.RedoW,	c1;	{uuRx _}TT _ Rx + ib {+1}, CarryBr, BRANCH[$, PBCar, 1],	c2;PBCont:	Q{ptrH} _ rhTT _ MD{ptrH}, BRANCH[$, PBSeg],	c3;PBsegok:	Map _ {TT _}  [rhTT, TT +0{- 1}], {Xbus _ ib,}	c1;	uuRx{ptr} _ Rx, PC _ PC + 1, L1 _ L1.PushDec2,	c2;	Rx _ rhRx _ MD, XwdDisp{XDirtyDisp},	c3;RedoW:	MAR _ [rhRx, TT + 0], DISP2[PBMap],	c1,at[L0.RedoW,10,WMapFixCaller];	MDR _ TOS, TOSH _ Q{ptrH}, IBDisp, L2 _ L2.0,	c2, at[1, 4, PBMap];DNI.funny:	TOS _ uuRx{ptr}, L2 _ L2.0, DISPNI[OpTable],	c3;	CALL[WLMapFix], {will return to RedoW}	c2, at[0, 4, PBMap];	CALL[WLMapFix], {will return to RedoW}	c2, at[2, 4, PBMap];	CALL[WLMapFix], {will return to RedoW}	c2, at[3, 4, PBMap];ufnPUTB:	Rx _ 315'b, GOTO[ufn2incS]	c1;{memory reference is good, but S is +0FF instead of -1}PBCar:	Noop, BRANCH[$, PBCarSeg],	c3;	MAR _ S{S - 0FF} _ [rhS, 0 + 0],	c1;	S _ S - 1, GOTO[PBCont],	c2;PBCarSeg:	MAR _ S{S - 0FF} _ [rhS, 0 + 0],	c1;	S _ S - 1, Xbus _ 1, XDisp, GOTO[PBCont],	c2;PBSeg:	Q _ Q+1,	c1;	rhTT _ Q{ptrH+1} LRot0,	c2;	Q _ Q - 1, GOTO[PBsegok],	c3;{*************************}PUTBASEPTRN:   {(ptr, val => ptr)	2%  5 clicks}	MAR _ [rhS, S], S _ S -1,	c1, opcode[316'b];{CE}	PC _ PC + 1, CANCELBR[$, 2],	c2;	Rx _ MD{ptr},	c3;	MAR _ [rhS, S + 0], L0 _ L0.RedoPBP, 	c1;	{uuRx _ Rx,} TT _ Rx + ib {+ 1},CarryBr, 	c2;	Q{ptrH} _  rhTT _ MD{ptrH}, BRANCH[$, PBPSeg],	c3;PBPok:	Map _ [rhTT, TT+0],	c1;	uuRx _ Rx, S _ S +{-} 1, L1 _ L1.DecDec{PushDec2},	c2;	Rx _ rhRx _ MD, XwdDisp{XDirtyDisp},	c3;{fiddle with S to make Cin one for uuRx _ Rx}RedoPBP:	MAR _ [rhRx, TT + 1], DISP2[PBPMap],	c1,at[L0.RedoPBP,10,WMapFixCaller];	MDR _ TOS, CANCELBR[$, 2], WriteOK,	c2, at[1, 4, PBPMap];	S _ S-2,	c3;	MAR _ [rhRx, TT + 0], L2 _ L2.0,	c1;	MDR _ TOSH, TOSH _ Q{ptrH}, IBDisp, GOTO[DNI.funny],	c2;{	TOS _ uuRx{ptr}, DISPNI[OpTable],	c3;}	CANCELBR[WLMapFix, 3], {return to RedoPBP}	c2, at[0, 4, PBPMap];	CANCELBR[WLMapFix, 3], {return to RedoPBP}	c2, at[2, 4, PBPMap];	CANCELBR[WLMapFix, 3], {return to RedoPBP}	c2, at[3, 4, PBPMap];PBPSeg:	Q _ Q+1,	c1;	rhTT _ Q{ptrH+1} LRot0,	c2;	Q _ Q - 1, GOTO[PBPok],	c3;{*************************}PUTBASEBYTE:   {ptr, disp, val => val}	{3%  9{7}clicks}	MAR _ [rhS, S], S _ S -1,	c1, opcode[307'b];{C7}{S = S - 1}	Ybus _ TOSH xor smallpl, NZeroBr, CANCELBR[$, 2],	c2;	Rx _ MD{disp}, BRANCH[$, ufnPBY],	c3;	MAR _ [rhS, S + 0],	c1;	S _ S -1,	c2;{S = S - 2}	Q _ MD{dispH},	c3;	MAR _ [rhS, S], S _ S -1,	c1;{S = S - 3}	Ybus _ Q xor smallpl, NZeroBr, CANCELBR[$,2],	c2;	uRx _ Rx, TT _ MD{ptr}, BRANCH[$, ufnPBY1],	c3;	MAR _ [rhS, S], S _ S - 1, L1 _ L1.Push2OK,	c1;{S = S - 4}	Rx _ Rx RShift1, YDisp, BRANCH[$, PBYCarry, 1],	c2;PBYret:	rhTT _ MD{ptrH}, TT _ TT + Rx, CarryBr, BRANCH[$, oddS, 0E],	c3;evenS:	Map _ [rhTT, TT], BRANCH[$, PBYESeg],	c1;	Q _ 0FF, L0 _ L0.WBYRedoE,	c2;	Rx _ rhRx _ MD, XwdDisp{XDirtyDisp},	c3;WBYRedoE:	MAR _ [rhRx, TT + 0], DISP2[WBYMapUDE],	c1, at[L0.WBYRedoE,10,WMapFixCaller];	TOS _ TOS LRot8,	c2, at[1, 4, WBYMapUDE];joinY:	Q _ MD and Q,	c3;	Q _ Q or TOS,	c1;	TOS _ TOS LRot8 xor TOS,	c2;	TOS _ TOS and 0FF,	c3;		MAR _ [rhRx, TT + 0], L2 _ L2.0,	c1;	MDR _ Q, IBDisp, GOTO[DNI.pc1],	c2;{	PC _ PC + PC16, L2 _ L2.0, DISPNI[OpTable],	c3;}oddS:	Map _ {Q _} [rhTT, TT], BRANCH[$, PBYOSeg],	c1;	L0 _ L0.WBYRedoO,	c2;	Rx _ rhRx _ MD, XwdDisp{XDirtyDisp},	c3;WBYRedoO:	MAR _ [rhRx, TT + 0], DISP2[WBYMapUDO],	c1, at[L0.WBYRedoO,10,WMapFixCaller];	Q _ ~0FF, GOTO[joinY],	c2, at[1, 4, WBYMapUDO];ufnPBY:	Rx _ 307'b, CANCELBR[ufn2incS, 3]	c1;ufnPBY1:	Rx _ 307'b, GOTO[ufn2inc3S],	c1;	CALL[WLMapFix],	c2, at[0, 4, WBYMapUDE];	CALL[WLMapFix],	c2, at[2, 4, WBYMapUDE];	CALL[WLMapFix],	c2, at[3, 4, WBYMapUDE];		CALL[WLMapFix],	c2, at[0, 4, WBYMapUDO];	CALL[WLMapFix],	c2, at[2, 4, WBYMapUDO];	CALL[WLMapFix],	c2, at[3, 4, WBYMapUDO];{page cross:}PBYCarry:	S _ S - 0FF, CANCELBR[$, 0F],	c3;	MAR _ [rhS, S + 0],	c1;	S _ S - 1, GOTO[PBYret], Xbus _ uRx, XDisp,	c2;PBYESeg:	Q _ rhTT + 1, LOOPHOLE[byteTiming],	c2;	rhTT _ Q LRot0, GOTO[evenS],	c3;PBYOSeg:	Q _ rhTT + 1, LOOPHOLE[byteTiming],	c2;	rhTT _ Q LRot0, GOTO[oddS],	c3;{*************************	ADDBASE (ptr, disp)	1%  3 clicks**************************}ADDBASE:	MAR _ [rhS, S], S _ S -1,	c1, opcode[320'b];{D0}	Ybus _ TOSH xor smallpl, NZeroBr, CANCELBR[$,2],	c2;	Rx _ MD, BRANCH[$, ufnAB],	c3;	MAR _ [rhS, S + 0], {S _ S -1,}	c1;	TOS _ TOS + Rx, CarryBr,	c2;	TOSH _ MD, BRANCH[adBnoc, adBcar],	c3;adBnoc:	L2 _ L2.0, GOTO[addBtail],	c1;adBcar:	TOSH _ TOSH + 1, L2 _ L2.0, GOTO[addBtail],	c1;addBtail:	S _ S - 1, IBDisp,	c2;DNI.pc1: {common tail}	PC _ PC + PC16, L2 _ L2.0, DISPNI[OpTable]	c3;ufnAB:	Rx _ 320'b, GOTO[ufn2incS],	c1;{*************************	HILOC, LOLOC	2%  1 click**************************}HILOC:	TOS _ TOSH, GOTO[LoLoc1],	c1, opcode[322'b];{D2}LOLOC:	Noop,	c1, opcode[323'b];{D3}LoLoc1:	TOSH _ smallpl, IBDisp, L2 _ L2.0, GOTO[DNI.pc1],	c2;{*************************	COPY	3% 2 clicks**************************}COPY:	MAR _ S _ [rhS, S + 1],	c1, opcode[144'b];{64}CopyRet:	MDR _ TOSH, S _ S + 1, BRANCH[$, CopyCarry, 1],	c2;	Ybus _ S xor uStkLimO, ZeroBranch,	c3;	MAR _ [rhS, S + 0], BRANCH[$, CopyStkLim],	c1;	MDR _ TOS, IBDisp, L2 _ L2.0, GOTO[DNI.pc1],	c2;{page cross:}CopyCarry:	S _ S + 0FF,	c3;	MAR _ [rhS, S + 0], GOTO[CopyRet],	c1;{Stack Limit:}CopyStkLim:	MDR _ TOS, 	c2;	PC _ PC + PC16, GOTO[StackOverflow],	c3;{*************************	NIL, KT, ZERO, ONE, SIC, SNIC	15 %  2 clicks	SICX, ACONST, ATOMNUMBER	 5 %  3 clicks**************************}LinkCross:	PV _ Q{PV - 9 + 100h} - 0FF - 1, 	c3;	MAR _ Q{PV- 9} _ [rhPV, PV + 0], GOTO[link2],	c1;MYALINK:	MAR _ Q{PV- 9} _ [rhPV, PV - 9], L3 _ L3.pls1,	c1, opcode[146'b];link2:	PV _ Q + 9, BRANCH[$, LinkCross, 1],	c2;	Q _ MD, XLDisp, L2 _ L2.0,	c3;	MAR _ S _ [rhS, S + 2], BRANCH[linkE, linkO, 0E],	c1;linkE:	STK _ MDR _ TOS, TOS _ Q - 0A, DISP2[NoCar],	c2;linkO:	STK _ MDR _ TOS, TOS _ Q - 0B, DISP2[NoCar],	c2;ACONST:	Rx _ ib, L3 _ L3.atm3,	c1, opcode[147'b];{67}	Rx _ Rx LRot8, GOTO[xx],	c2;ATOMN:	Rx _ ib, L3 _ L3.pls3, GOTO[sic2],	c1, opcode[160'b];{70}SICX:	Rx _ ib, L3 _ L3.pls3,	c1, opcode[156'b];{6E}sic2:	Rx _ Rx LRot8, GOTO[xx],	c2;xx:	Q _ Rx or ib, Cin_pc16,  {prepare for inc3}	c3;	MAR _ S _ [rhS, S + 2],	c1;	STK _ MDR _ TOS, TOS _ Q, L2 _ L2.0, DISP2[NoCar],	c2;NIL:	MAR _ S _ [rhS, S + 2], L3 _ L3.atm1,	c1, opcode[150'b];{68}L3Zero:	STK _ MDR _ TOS, TOS _ 0, L2 _ L2.0, DISP2[NoCar],	c2;KT:	MAR _ S _ [rhS, S + 2], L3 _ L3.atm1,	c1, opcode[151'b];{69}	STK _ MDR _ TOS, TOS _ 114'b{KTval}, L2 _ L2.0, DISP2[NoCar],	c2;ZERO:	MAR _ S _ [rhS, S + 2], L3 _ L3.pls1,	c1, opcode[152'b];{6A}	STK _ MDR _ TOS, TOS _ 0, L2 _ L2.0, DISP2[NoCar],	c2;ONE:	MAR _ S _ [rhS, S + 2], L3 _ L3.pls1,	c1, opcode[153'b];{6B}	STK _ MDR _ TOS, TOS _ 1, L2 _ L2.0, DISP2[NoCar],	c2;SIC:	MAR _ S _ [rhS, S + 2], L3 _ L3.pls2,	c1, opcode[154'b];{6C}	uTOS _ MDR _ TOS, TOS _ ib, L2 _ L2.0, DISP2[NoCar],	c2;SNIC:	Q _ ib,     {shorten ?%!}	c1, opcode[155'b];{6D}	Q _ Q - 0FF - 1,	c2;	Noop,	c3;	MAR _ S _ [rhS, S + 2], L3 _ L3.neg2,	c1;	uTOS _ MDR _ TOS, TOS _ Q, L2 _ L2.0, DISP2[NoCar],	c2;Carry:	S _ S + 0FF + 1, L3Disp,	c3, at[2,4,NoCar];	MAR _ [rhS, S + 0], BRANCH[saveS, saveU, 0B],	c1;saveU:	MDR _ uTOS, L2 _ L2.0, GOTO[NoCar],	c2;saveS:	MDR _ STK, L2 _ L2.0, GOTO[NoCar],	c2;NoCar:	Ybus _ S xor uStkLimO, ZeroBranch, L3Disp,	c3, at[0,4,NoCar];	MAR _ [rhS, S - 1], Xbus_0, XC2npcDisp, L3Disp, DISP4[SicTosh, 8],	c1;	MDR _ TOSH, TOSH _ 0{atom}, IBDisp, DISP4[Kinc, 6], WriteOK,	c2, at[8, 10, SicTosh];	MDR _ TOSH, TOSH _ 0{atom},  DISP4[KincL, 6], WriteOK,	c2, at[9, 10, SicTosh];	MDR _ TOSH, TOSH _ smallpl, IBDisp, DISP4[Kinc, 6], WriteOK,	c2, at[0A, 10, SicTosh];	MDR _ TOSH, TOSH _ smallpl, DISP4[KincL, 6], WriteOK,	c2, at[0B, 10, SicTosh];	MDR _ TOSH, TOSH _ smallpl, IBDisp, CANCELBR[inc2, 0F], WriteOK,	c2, at[0C, 10, SicTosh];	MDR _ TOSH, TOSH _ smallpl, CANCELBR[incL2, 0F], WriteOK,	c2, at[0D, 10, SicTosh];	MDR _ TOSH, TOSH _ smallneg, IBDisp, CANCELBR[inc2, 0F], WriteOK, c2, at[0E, 10, SicTosh];	MDR _ TOSH, TOSH _ smallneg, CANCELBR[incL2, 0F], WriteOK,	c2, at[0F, 10, SicTosh];inc2:	PC _ PC + 1, L2 _ L2.0, DISPNI[OpTable],	c3;incL2:	PC _ PC + 1, L2 _ L2.0, GOTO[StackOverflow],	c3;inc1:	PC _ PC + PC16, L2 _ L2.0, DISPNI[OpTable],	c3, at[6,10, Kinc];	PC _ PC + PC16, L2 _ L2.0, DISPNI[OpTable],	c3, at[7,10, Kinc];incL1:	PC _ PC + PC16, GOTO[StackOverflow],	c3, at[6,10, KincL];	PC _ PC + PC16, GOTO[StackOverflow],	c3, at[7,10, KincL];inc3:	PC _ PC + 1, L2 _ L2.0, DISPNI[OpTable],	c3, at[0E,10, Kinc];	PC _ PC + 2, L2 _ L2.0, DISPNI[OpTable],	c3, at[0F,10, Kinc];incL3:	PC _ PC + 1, GOTO[StackOverflow],	c3, at[0E,10, KincL];	PC _ PC + 2, GOTO[StackOverflow],	c3, at[0F,10, KincL];{*************************	GCONST**************************}{uPCCrossL will be off no matter what: suceed, fault, stkOver}GCONST:	MAR _ S _ [rhS, S + 1],	c1, opcode[157'b];{6F}	uTOSH _ MDR _ TOSH, TOSH _ ib, BRANCH[$, GCCarry, 1],	c2;GCNoCarry:	Rx _ ib, L0 _ L0.RedoGC,	c3;	MAR _ PC _ [rhPC, PC + 2], L1 _ L1.TrapGC{fault trap},	c1;	Rx _ Rx LRot8, BRANCH[$, GCPCCarry, 1],	c2;GCPCNoC:	IB _ MD, Q _ Rx,	c3;GCok:	MAR _ S _ [rhS, S + 1],	c1;	MDR _ TOS, TOS _ Q or ib, CANCELBR[$, 2], WriteOK,	c2;	Ybus _ S xor uStkLimO, ZeroBranch, L2 _ L2.0,	c3;	MAR _ [rhPC, PC + 1], BRANCH[$, GConStkLim],	c1;RefillNE1:	AlwaysIBDisp, L0 _ L0.NERefill.Set, DISP2[NoRCross],	c2;{exceptions:}{if page cross succeedes update UvPCpageL and uPCCrossL}GCCarry:	S _ S + 0FF + 1,	c3;	MAR _ [rhS, S + 0],	c1;	MDR _ uTOSH, GOTO[GCNoCarry],	c2;GCPCCarry:	Q _ 0FF + 1, L1 _ L1.TrapGC{fault trap},	c3;	TT _ UvPCpageL, GOTO[UpdatePC2],	c1;{uPCCrossL will be off no matter what: suceed, fault, stkOver}GCCross:	uPCCrossL _ TT{0 low}, PC _ MD, rhPC _ MD, XRefBr,	c3, at[L0.RedoGC,10,ECross];	MAR _ Q _ [rhPC, Q + 0], BRANCH[GCMap, $],	c1;	UvPCpageL _ TT, PC _ Q, GOTO[GCPCNoC],	c2;{PC page cross plus map update: save Rx}GCMap:	uRx _ Rx,  {returns at GCRedo}	c2;	Rx _ PC, Xbus _ PC LRot0,XwdDisp, GOTO[RLMapFix1],	c3;GCRedo:	MAR _ PC _ [rhPC, Q + 0], CANCELBR[$],	c1, at[L0.RedoGC, 10, RMapFixCaller];	Q _ uRx,	c2;	UvPCpageL _ TT, IB _ MD, GOTO[GCok],	c3;GCTrap:	TOSH _ uTOSH,	c1, at[L1.TrapGC,10,Fix];	PC _ Q{PC}{++} - 2,	c2;	S _ S -1, GOTO[NoFixes],	c3;{Stack Limit:}GConStkLim:	Noop, CANCELBR[$, 2],	c2;	Noop, GOTO[StackOverflow],	c3;{{UpdatePC:}	TT _ UvPCpageL, L1 _ L1.TrapGC{fault trap}, 	c1;	TT _ TT + Q, rhTT _ UvChighL, {GOTO[UpdatePC3],}	c2;	Q _ PC,	c3;	Map _ MAR _ TT _ [rhTT, 0 + 0],	c1;	{Noop,} L0 _ L0.RedoGC, GOTO[GCCross],	c2;}{*************************	POP	5%  2 click**************************}POP:	MAR _ [rhS, S], S _ S - 1,	c1, opcode[277'b];{BF}	PC _ PC + PC16, CANCELBR[$, 2],	c2;	TOS _ MD,	c3;	MAR _ [rhS, S + 0],	c1;	S _ S - 1, IBDisp, L2 _ L2.0, GOTO[DNI.TOSHg],	c2;{*************************	SWAP**************************}SWAP:	MAR _ [rhS, S - 1],	c1, opcode[375'b];{FD}	PC _ PC + PC16, MDR _ TOSH, CANCELBR[$, 2], WriteOK,	c2;	TOSH _ MD,	c3;	MAR _ [rhS, S + 0],	c1;	MDR _ TOS, IBDisp, L2 _ L2.0, GOTO[DNI.TOSg],	c2;{*************************	NOP**************************}NOP:	PC _ PC + PC16, GOTO[IB.nop],	c1, opcode[376'b];{FE}{	IBDisp, L2 _ L2.0, GOTO[DNI.nop],	c2;}{*************************	EQ		3%  3 clicks**************************}EQ:	MAR _ [rhS, S], S _ S - 1,	c1, opcode[360'b];{F0}	PC _ PC + PC16, CANCELBR[$, 2],	c2;	Rx _ MD xor TOS,	c3;	MAR _ [rhS, S + 0],	c1;	S _ S - 1,	c2;	TT _ MD xor TOSH,	c3;	Ybus _ Rx or TT, ZeroBr, L2 _ L2.0,	c1;	TOSH _ 0{atm}, IBDisp, BRANCH[eqNIL, eqKT],	c2;eqNIL:	TOS _ 0{NIL}, L2 _ L2.0, DISPNI[OpTable],	c3;eqKT:	TOS _ KTval, L2 _ L2.0, DISPNI[OpTable],	c3;{*************************	FUNCTION CALL		3%  22+ clicks**************************}{traps:}{DoCall:	Q _ 254'd, GOTO[sink2],{used by interrupt}	c1;{MP9254}}{***********************}APPLY:  {(S) Flush top of  stack}	opcode[016'b],{0E}	MAR _ [rhS, S - 1], L3{ib's}_0,	c1;applyTl:	TT _ 0FF + 1{400=AT.INTERPRETER%}, CANCELBR[$ ,2],	c2;	Q _ MD{nargsHi},	c3;	MAR _ [rhS, S + 0],	c1;	Ybus _ Q xor smallpl, NZeroBr,	c2;	{TOSH _ }rhTOSH _ MD{nargs}, BRANCH[$, appUfn],	c3;	rhTT _ TOSH{defHi} LRot0, ZeroBr,	c1;	TOSH{args2} _ rhTOSH{args} LShift1, BRANCH[$, applyCode],	c2;notCCode:	PV _ PV - 6,	c3;	MAR _ [rhPV, PV + 0],	c1;	MDR _ TOSH{iVar} _ S - TOSH{arg2} - 1,	c2;	PV _ PV + 6,	c3;	MAR _ [rhS, S - 1],	c1;	MDR _ rhTT, CANCELBR[interpret3, 2], WriteOK,	c2;applyCode:	TT _ TOS, GOTO[apply2],	c3;appUfn:	Q _ 14'd, GOTO[sink2],	c1;{MP9014}{***********************}FNX:	MAR _ Q _ [rhS, S + 1], L0 _ L0.RefillFNX,	c1, opcode[015'b];{0D}	STK _ MDR _ TOSH, rhTT _ DEFspace, BRANCH[Cont5, SCar5, 1],	c2;Cont5:	TOSH _ ib LShift1, XC2npcDisp,	c3;	MAR _ [rhPC, PC + 2], BRANCH[$, noNeed, 0E], L1 _ L1.FNX,	c1;	TOSH _ TOSH - 2, BRANCH[$, FNXCross, 1],	c2;	TOSH _ Q - TOSH, IB _ MD, GOTO[fnIV], L3{ib's}_3,	c3;noNeed:	TOSH _ TOSH - 2, CANCELBR[$, 0E], L1 _ L1.FNX,	c2;	TOSH _ Q - TOSH, GOTO[fnIV], L3{ib's}_3,	c3;{***********************}FN0:	MAR _ Q _ [rhS, S + 1], L3{ib's}_2,	c1, opcode[010'b];{08}	STK _ TOSH, MDR _ TOSH, TOSH _ 1 + Q +1, BRANCH[Cont1, SCar1, 1],	c2;FN1:	MAR _ Q _ [rhS, S + 1], L3{ib's}_2,	c1, opcode[011'b];{09}FN1Ext:	STK _ MDR _ TOSH, TOSH _ Q - 0, BRANCH[Cont1, SCar1, 1],	c2;FN2:	MAR _ Q _ [rhS, S + 1], L3{ib's}_2,	c1, opcode[012'b];{0A}FVcall:	STK _ MDR _ TOSH, TOSH _ Q - 2, BRANCH[Cont1, SCar1, 1],	c2;FN3:	MAR _ Q _ [rhS, S + 1], L3{ib's}_2,	c1, opcode[013'b];{0B}	STK _ MDR _ TOSH, TOSH _ Q - 4, BRANCH[Cont1, SCar1, 1],	c2;FN4:	MAR _ Q _ [rhS, S + 1], L3{ib's}_2,	c1, opcode[014'b];{0C}	STK _ MDR _ TOSH, TOSH{iVar} _ Q -6, BRANCH[Cont1, SCar1, 1],	c2;Cont1:	rhTT _ DEFspace{11},	c3;fnIV:  {iVar (new) stored as end of old frame}{High half of S to match  Q}{Q: Sev; TOSH: iVar(new)}	MAR _ [rhPV, PV - 6],	c1;	MDR _ TOSH{iVar}, TT _ ib, BRANCH[$, SCar6, 1],	c2;SC6Cont:	TT _ TT LRot8,	c3;fnS: {Flush top of stack}	{Q: S even}{High half of S to match  Q}	MAR _ Q _ [rhS, Q+1],{High half of S to match  Q}	c1; {Q _ odd}	MDR _ TOS,  S _ Q + 2, CANCELBR[$, 2], WriteOK,	c2;	TT _ TT or ib LShift1,	c3;{***********************}fnMD: {MapDef;   rhTT,TT{FunDef} S{oddEmpty} L3{ib's} PV.iVar=TOSH{iVar} PC:+0}	uTT{FunDef} _ Map _ [rhTT{FunDefs}, TT], L0 _ L0.FCRedo, 	c1;	TOS _ UvCL, L1 _ L1.FC,	c2;	uIVar _ TOSH, Rx _ rhRx _ MD, XRefBr,	c3;fnD: {Get def cell high}	MAR _ [rhRx, TT + 0], BRANCH[FCMap, $], c1, at[L0.FCRedo, 10,RMapFixCaller];	Q _ PC and 0FF, L1 _ L1.FCH,	c2;	Q _ Q - TOS{UvCL}, rhTT{UvChighL} _ MD, XHDisp{compiled?},	c3;fnD0: {Get def cell low}	MAR _ [rhRx, TT+1], BRANCH[interpret, $, 2],	c1;	Rx{uStkLimO} _ uStkLimO, CANCELBR[$, 2], L0 _ L0.FCHRedo,	c2;	uPC _ PC, TT{UvCL} _ MD, L3Disp{deltaPC},	c3;fnMH: {Map function header}	Map _ [rhTT, TT], BRANCH[incPC1, incPC2, 0E],	c1;incPC1:	uTOS{savUvCL} _ TOS, TOS{pc} _ Q + PC16, GOTO[jMH],	c2;incPC2:	uTOS{savUvCL} _ TOS, TOS _ Q + 1, GOTO[jMH],	c2;jMH:	uTOSH{iVar} _ TOSH, PC _ rhPC _ MD, XRefBr,	c3;fnH0: {Fetch function header 0}	{S: odd, empty}FCHred:	MAR _ Q _ [rhPC, TT + 0], L1 _ L1.FCH, BRANCH[FCHMap, $],	c1{, at[L0.FCHRedo, 10,RMapFixCaller]};	TOSH{args} _ RShift1 (S-TOSH{iVar}-1), SE_0,	c2;	UvCL _ TT, TT{stk} _ MD,	c3;fnH1: {Fetch function header 1}	{TOSH{args} non-neg}	MAR _ PC _ [rhPC, Q + 1],	c1;	Q{stkNeed} _ TT{stk} + S, CANCELBR[$, 2],	c2;	TT{na} _ MD, XHDisp, GOTO[fnH2],	c3;fnH2: {Regs:  TOSH{args}, TOS{PC-UvCL}, Rx{uStkLim0}, Q{stkNeed}, TT{na}, PC{header}, PV{pv},  S{s} }	MAR _ [rhPC, PC + 1], BRANCH[$, LamStar, 2],	c1;	Ybus _ Rx{uStkLim0} - Q{stkNeed}, CarryBr, CANCELBR[$, 2],	c2;	Rx{pv#} _ MD, XHDisp, BRANCH[FnStkOvr, fnH3],	c3;fnH3: {Fetch function header 3}	MAR _ [rhPC, PC + 2], L0_2, BRANCH[h30, h31, 2],	c1;h30:	TOSH{wdsXtr+1} _ TOSH{args} - TT{na} LShift1, SE_1, NegBr, CANCELBR[h4, 2],	c2;h31:	TOSH{wdsXtr+1} _ TOSH{args} - TT{na} LShift1,  SE_1,NegBr, CANCELBR[h4, 2],	c2;h4:	Q{start} _ MD, BRANCH[enough, grow],	c3;grow: {grow the stack if necessary}	MAR _ [rhS, S-1],	c1;	MDR _ TT _ 0, CANCELBR[$, 2], WriteOK,	c2;	TOSH _ TOSH + 1,	c3;fnG:	MAR _ S _ [rhS, S+0],	c1;	MDR_TT{zero}, TOSH{wdsXtr}_TOSH+1, NegBr,	c2;	S _ S+2, BRANCH[enough, grow],	c3;{(N) trim stack and push uBFmark (once was nargs)}	{TOSH{argsXtr} non-neg}enough:	MAR _ S _ [rhS, S - TOSH{wdsXtr+1}],	c1;FnNCont:	MDR _ uBFmark, BRANCH[$, FnNCar, 1],	c2;	TOSH{UvPCpageLOld} _ UvPCpageL,	c3;fnB: {push IVar)}	MAR _ S _ [rhS, S+1],	c1;	MDR _ uIVar, CANCELBR[$, 2], WriteOK,	c2;	S _ S+1,	c3;fnF: {push uFXmark}	MAR _ S _ [rhS, S+0], L3Disp{deltaPC},	c1;	MDR _ uFXmark, BRANCH[pcInc0, pcInc2, 0D], WriteOK,	c2;pcInc0:	TOSH{pc} _ TOSH{UvPCpageLOld} + TOS{PC+UvCL}, NegBr,  GOTO[savPv],	c3;pcInc2:	TOSH{pc} _ TOSH{UvPCpageLOld} + TOS{PC+UvCL}+1, NegBr,  GOTO[savPv],	c3;savPv: {Alink _ oldPvar}	MAR _ S _ [rhS, S+1], BRANCH[$, NegPcError],	c1;	MDR _ PV{old}, S _ S+1, CANCELBR[$, 2], WriteOK,	c2;	TOS{start-1} _ (Q{start} - 1) RShift1, SE_0,	c3;{(P) Clear PC16, Store relative byte PC  = 2*[UvPCpageL-UvCL+(PC and 0FF)]+PC16}{	MD	    TOS _ UvCL,	}{	D:	    Q _ PC and 0FF,	}{		    Q{PC-UvCL} _ Q - TOS,	}{	MH	    TOS{PC-UvCL} _ Q + PC16 {+PC16},	}{ 	N:	    TOSH _ UvPCpageL,	}{	F:	    TOSH{relWdPC} _ TOSH{UvPCpageL} + TOS{PC-UvCL} {+ 1},	}{		    MDR _ TOSH + TOSH + pc16,	}fnP:	MAR{PC} _ PV _ [rhPV, PV - 5],	c1;	MDR _ TOSH _ TOSH{pc}+TOSH+PC16, BRANCH[$, FnPCar, 1],	c2;FnPCont:	PV{new} _ S + 8{empty fields}, XC2npcDisp,	c3;fnC: {push code base low}	MAR _ [rhS, S+0], IB _ 6{constant}, BRANCH[fnPcOdd, fnPcEv, 0E],	c1;fnPcOdd:	MDR _ TOSH _ UvCL, GOTO[fnC0], Cin_pc16,	c2;fnPcEv:	MDR _ TOSH _ UvCL, GOTO[fnC0],	c2;fnC0:	TOSH{UvPCpageL} _ TOSH and ~0FF,	c3;fnC1: {push code base high}	MAR _ Q _ [rhS, S+1], IBPtr _ 1, L0Disp{pv# zero},	c1;	MDR _ TT _ rhTT, WriteOK, BRANCH[plp, plpD, 0E],	c2;plpD:	UvChighL _ TT, S _ Q{S} + ib{6} + 1, GOTO[loopDone],	c3;plp:	UvChighL _ TT, S _ Q{S} + ib{6} + 1, {room for next, PC, nameTable, Blink and, Clink}	c3;{(V) push #pvar unbound pointers}loopP:	MAR _ S _ [rhS, S+0],	c1;	MDR _ TT{ones}_ ~TT xor TT,	c2;	S _ S + 2,	c3;	MAR _ S _ [rhS, S+0],	c1;	MDR _ TT{ones},Rx{pv#}_Rx-1, NegBr,	c2;	S _ S + 2, BRANCH[loopP, loopDone],	c3;{(F) start fetch from the byte PC, PC16 cleared previously}loopDone:	MAR _ PC _ [rhPC, PC{+1} + TOS{start-1}],	c1;	S _ S + 1, BRANCH[$, CCross,1],	c2;	UvPCpageL _ TOSH, IB _ MD,	c3;	MAR _ [rhPC, PC + 1], IBPtr_0, L2 _ L2.0,	c1; 	AlwaysIBDisp, TOSH _ 0, L0_ L0.NERefill.Set, DISP2[NoRCross],	c2;CCross:	UvPCpageL _ TOSH,	c3;	TOSH _ 0,	c1;	Noop,	c2;	Q _ 0FF + 1, L0 _ L0.JRemap, GOTO[UpdatePC],	c3;{2 more clicks}{exceptions:}SCar1:	Noop,	c3;	Noop, 	c1;	TOSH _ TOSH + 0FF + 1, {derived from Q}	c2;	S _ S + 1, {High half of S to match  Q}	c3;	MAR _ Q _ [rhS, S + 0],	c1;	MDR _ STK, GOTO[Cont1],	c2;SCar5:	S _ Q + 0FF + 1,	c3;	MAR _ Q _ [rhS, S + 0],{High half of S to match  Q}	c1;	MDR _ TOSH, {S _ S - 1,}{High half of S to match  Q} GOTO[Cont5],	c2;NegPcError:	Q _ 13'd,  CANCELBR[sink3, 3],	c2;{MP9013}FNXCross:	uPCCrossL _ (~TT xor TT),	c3;	TOSH _ Q - TOSH,	c1;	uRx{savQ} _ Q,  c2;	Q _ 0FF +  1, {GOTO[UpdatePC],} {L1 _ L1.FNX,}	c3;FNXCross1:{UpdatePC:}	TT _ UvPCpageL, GOTO[UpdatePC2],	c1;FCross:	Rx _ rhRx _ MD, XRefBr,	c3, at[L0.RefillFNX,10,ECross];FXRedo:	MAR _ [rhRx, PC + 2], BRANCH[FXMapUD, $],	c1, at[L0.RefillFNX,10,RMapFixCaller];	 rhTT _ DEFspace, CANCELBR[$,2],	c2;	IB _ MD, L3{ib's}_3,	c3;	Q _ uRx{SavQ}, c1;	c2;	GOTO[fnIV],c3;FXMapUD:	Noop, CANCELBR[RLMapFix, 3], {returns at FXRedo}	c2;FXFix:	TOSH _ STK, GOTO[NoMoreFix],	c1, at[L1.FNX,10,Fix];SCar6:	STK _ PV, PV _ PV - 6,	c3;	MAR _ [rhPV, PV + 0],	c1;	MDR _ TOSH, PV _ STK, GOTO[SC6Cont],	c2;SCar9:	STK _ PV, PV _ PV - 6,	c3;	MAR _ [rhPV, PV + 0],	c1;	MDR _ TOSH, PV _ STK, GOTO[SC9Cont],	c2;FnNCar:	S _ S -0FF - 1, 	c3;	MAR _ [rhS, S + 0], GOTO[FnNCont],	c1;FnPCar:	PV _ PV -0FF - 1, 	c3;	MAR _ [rhPV, PV + 0],	c1;	MDR _ TOSH, GOTO[FnPCont],	c2;{S odd empty}interpret:	TOS{atm} _ TT RShift1, CANCELBR[$, 2],	c2;	TT _ 0FF + 1{400=AT.INTERPRETER%},	c3;{interpret:	TT _ 0FF + 1{400=AT.INTERPRETER%}, CANCELBR[$, 2],	c2;	TOS{UvCL} _ MD,	c3;}interpret1:	MAR _ [rhS, S - 1],	c1;	MDR _ 0{rhTT}, CANCELBR[$, 2], WriteOK,	c2;interpret3:	TT _ TT + TT, rhTT _ DEFspace,	c3;	MAR _ [rhS, S + 0],	c1;	MDR _ TOS{atm}, 	c2;	S _ S + 2, GOTO[fnMD],	c3;LamStar:	TT{na} _ TOSH{args}, CANCELBR[$, 2],	c2;	Noop, GOTO[fnH2], {try again}	c3;FCMap:	CANCELBR[RLMapFix, 3],	c2;FCHMap:	Rx _ PC, CALL[RLMapFix],	c2;	Noop, CANCELBR[$, 1],	c1, at[L0.FCHRedo, 10,RMapFixCaller];	Rx{uStkLimO} _ uStkLimO, 	c2;	Xbus _ 1, XDisp, GOTO[FCHred],	c3;FnStkOvr:	TOSH{iVar} _ uTOSH, CANCELBR[$, 3],	c1;	TT{UvCL} _ uTOS,	c2;	UvCL _ TT, 	c3;	Rx _ {0 -} SubovFXP, L3Disp{deltaPC}, GOTO[fchFix2],	c1; {*************************}FCHFix:  	{preserves Rx:FXP#}	{Noop,} L3Disp{deltaPC},	c1, at[L1.FCH,10,Fix];fchFix2:	Noop, BRANCH[decPC1, decPC2, 0E],	c2;decPC1:	PC _ uPC, GOTO[FCFix], Cin_pc16,	c3;decPC2:	PC _ uPC, GOTO[FCFix],	c3;FCFix:	L3Disp,	c1, at[L1.FC,10,Fix];	TOS _ uTT, DISP4[PCdelt, 0C],	c2;	PC _ PC + PC16, GOTO[FCFix1],	c3, at[0C, 10, PCdelt];	PC _ PC + 1, GOTO[FCFix1],	c3, at[0D, 10, PCdelt];	PC _ 1 + PC + PC16, GOTO[FCFix1],	c3, at[0E, 10, PCdelt];	PC _ PC + 2, GOTO[FCFix1],	c3, at[0F, 10, PCdelt];FCFix1:	MAR _ [rhS, S - 1],	c1;	MDR _ smallpl, CANCELBR[$, 2], WriteOK,	c2;	TOSH{args} _ RShift1 (S-TOSH{iVar}-1), SE_0,	c3;	MAR _ [rhS, S + 0],	c1;	MDR _ TOSH{args}, TOSH _ 0, L2 _ 1{InCall},	c2;	TOS _ TOS RShift1, GOTO[PuntFor],	c3;