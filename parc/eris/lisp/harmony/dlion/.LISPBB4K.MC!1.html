<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>Dlion>LISPBB4K.MC!1</title>
  </head>
  <body>
    <pre>
{File name LispBB4K.mcDescription: BitBlt op-codeAuthor: don charnleyLast edited: October 8, 1980  6:35 PMCreated: October 1983}{*****************************************************************************	BITBLT*****************************************************************************}{OLD: {CAUTION: there is a delicate sharing of .u+D by uTOS and UWidth; during faults UWidth is stored in TOS; at restart {BBpart} it is tested for nonZero and restorted}}{.u+2 thru .u+C must be preserved accross faults; in particular no bitBlt by fault handler}{TOS=0 if virgin BB call;  else suspended with saved state on stack under TOS}{2 args one usually 0 in TOS; S points to ptr to BBtable}	MAR &larr; [rhS, S+0],	c1, at[BBEntry];	{UWidth}Ybus &larr; TOS, NZeroBr,	c2;	TOS &larr; MD, BRANCH[$, BBpart],	c3;	MAR &larr; S &larr; [rhS, S - 1],	c1;	S&larr;S-1, CANCELBR[$, 2],	c2;	TOSH &larr; MD,	c3;{S points to some stack entry that has nothing to do with BB}{BBInit vs BBInit1 differ on advacing PC}	PC &larr; PC + 1{PC16}{1}{%?}{saveRegs does PC&larr;PC-1},	c1;	stackP &larr; 2,	c2;	Noop,	c3;	uPCCross &larr; TOSH xor ~TOSH,{uPCCross#uPCCrossL}	c1;	STK{UBitBltArg} &larr; TOS, pop,	c2;	rhMDS &larr; TOSH LRot0, GOTO[@BITBLT],	c3;{@BITBLT returns directly to IBDispOnly; saves and restores L, G, PC}BBpart:	{Q &larr; 166'b, GOTO[sink2],	c1;}	uPCCross &larr; TOSH xor ~TOSH,{uPCCross#uPCCrossL}	c1;	PC &larr; PC + 1{PC16}{1}{%?}{undone by saveRegs},	c2;	stackP &larr; 0C{vestigial}, {GOTO[@BITBLT],}	c3;{restore 12 uRegs from memory stack: u2 thru u0D } 	stackP &larr; 0D,	c1;	Rx &larr; 0C,	c2;BBLp:	Noop,	c3;{Stack pointer points to full odd word } 	MAR &larr; S &larr; [rhS, S +0], 	c1;	S &larr; S - 2,	c2;	TT &larr; MD,	c3;	Rx &larr; Rx - 1, ZeroBr,	c1;	STK &larr; TT, pop, BRANCH[BBLp, BBLpD],	c2;BBLpD:	stackP &larr; 0C{not vestigial}, GOTO[@BITBLT],	c3;{@BITBLT returns  to IBDispOnly normally or to SaveRegs if fault {or interrupt}}{interupts are temporarily disabled in BB}{S points to some stack entry that has nothing to do with BB}{if faulting save 12 uRegs to memory stack: u2 thru u0D } {then set TOSH,TOS to nonzero to indicate BB suspended (PFault saves TOS)} {at PFault TOS is nonzero and under that is saved regs } SaveRegs: {come here on pageFault}{{state held in stack (faults can't bitblt)}}	rhTT &larr; uFaultParm1, 	c2;	TT &larr; uFaultParm0,	c3;{Stack pointer points to full odd word } {save 12 uRegs from memory stack: u2 thru u0D } 	stackP &larr; 02,	c1;	Rx &larr; 0C,	c2;BBsLp:	S{even empty} &larr; S{odd full} + 1,	c3;	MAR &larr; S &larr; [rhS, S +0], 	c1;	MDR &larr; smallpl,	c2;	S &larr; S + 1,	c3;	MAR &larr; S &larr; [rhS, S +0], 	c1;	MDR &larr; STK, push,	c2;	Noop,	c3;	Rx &larr; Rx - 1, ZeroBr,	c1;	BRANCH[BBsLp, BBsLpD],	c2;BBsLpD:	stackP &larr; 0C{not vestigial},	c3;	TOSH &larr; smallpl,	c1;	TOS &larr; 1{UWidth}{uTOS}, L1 &larr; L1.NoFixes{DecOnly?},	c2;	stackP &larr; 0, CROSS[BBFault],	c3;{S points to some stack entry that has nothing to do with BB}{Normal BB returns undefined : set TOSH, TOS to any valid object (use smallpl)}{@BITBLT returns directly to IBDispOnly; saves and restores L{PV}, G{S}, PC}{stackP was set to zero by BB as we return here; any thing below .u+D is ok}BBThru:	,	c1;	,	c2;	CROSS[BBExit],	c3;	{ E N D }</pre>
  </body>
</html>
