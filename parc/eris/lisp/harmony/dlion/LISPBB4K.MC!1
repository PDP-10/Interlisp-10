{File name LispBB4K.mcDescription: BitBlt op-codeAuthor: don charnleyLast edited: October 8, 1980  6:35 PMCreated: October 1983}{*****************************************************************************	BITBLT*****************************************************************************}{OLD: {CAUTION: there is a delicate sharing of .u+D by uTOS and UWidth; during faults UWidth is stored in TOS; at restart {BBpart} it is tested for nonZero and restorted}}{.u+2 thru .u+C must be preserved accross faults; in particular no bitBlt by fault handler}{TOS=0 if virgin BB call;  else suspended with saved state on stack under TOS}{2 args one usually 0 in TOS; S points to ptr to BBtable}	MAR _ [rhS, S+0],	c1, at[BBEntry];	{UWidth}Ybus _ TOS, NZeroBr,	c2;	TOS _ MD, BRANCH[$, BBpart],	c3;	MAR _ S _ [rhS, S - 1],	c1;	S_S-1, CANCELBR[$, 2],	c2;	TOSH _ MD,	c3;{S points to some stack entry that has nothing to do with BB}{BBInit vs BBInit1 differ on advacing PC}	PC _ PC + 1{PC16}{1}{%?}{saveRegs does PC_PC-1},	c1;	stackP _ 2,	c2;	Noop,	c3;	uPCCross _ TOSH xor ~TOSH,{uPCCross#uPCCrossL}	c1;	STK{UBitBltArg} _ TOS, pop,	c2;	rhMDS _ TOSH LRot0, GOTO[@BITBLT],	c3;{@BITBLT returns directly to IBDispOnly; saves and restores L, G, PC}BBpart:	{Q _ 166'b, GOTO[sink2],	c1;}	uPCCross _ TOSH xor ~TOSH,{uPCCross#uPCCrossL}	c1;	PC _ PC + 1{PC16}{1}{%?}{undone by saveRegs},	c2;	stackP _ 0C{vestigial}, {GOTO[@BITBLT],}	c3;{restore 12 uRegs from memory stack: u2 thru u0D } 	stackP _ 0D,	c1;	Rx _ 0C,	c2;BBLp:	Noop,	c3;{Stack pointer points to full odd word } 	MAR _ S _ [rhS, S +0], 	c1;	S _ S - 2,	c2;	TT _ MD,	c3;	Rx _ Rx - 1, ZeroBr,	c1;	STK _ TT, pop, BRANCH[BBLp, BBLpD],	c2;BBLpD:	stackP _ 0C{not vestigial}, GOTO[@BITBLT],	c3;{@BITBLT returns  to IBDispOnly normally or to SaveRegs if fault {or interrupt}}{interupts are temporarily disabled in BB}{S points to some stack entry that has nothing to do with BB}{if faulting save 12 uRegs to memory stack: u2 thru u0D } {then set TOSH,TOS to nonzero to indicate BB suspended (PFault saves TOS)} {at PFault TOS is nonzero and under that is saved regs } SaveRegs: {come here on pageFault}{{state held in stack (faults can't bitblt)}}	rhTT _ uFaultParm1, 	c2;	TT _ uFaultParm0,	c3;{Stack pointer points to full odd word } {save 12 uRegs from memory stack: u2 thru u0D } 	stackP _ 02,	c1;	Rx _ 0C,	c2;BBsLp:	S{even empty} _ S{odd full} + 1,	c3;	MAR _ S _ [rhS, S +0], 	c1;	MDR _ smallpl,	c2;	S _ S + 1,	c3;	MAR _ S _ [rhS, S +0], 	c1;	MDR _ STK, push,	c2;	Noop,	c3;	Rx _ Rx - 1, ZeroBr,	c1;	BRANCH[BBsLp, BBsLpD],	c2;BBsLpD:	stackP _ 0C{not vestigial},	c3;	TOSH _ smallpl,	c1;	TOS _ 1{UWidth}{uTOS}, L1 _ L1.NoFixes{DecOnly?},	c2;	stackP _ 0, CROSS[BBFault],	c3;{S points to some stack entry that has nothing to do with BB}{Normal BB returns undefined : set TOSH, TOS to any valid object (use smallpl)}{@BITBLT returns directly to IBDispOnly; saves and restores L{PV}, G{S}, PC}{stackP was set to zero by BB as we return here; any thing below .u+D is ok}BBThru:	,	c1;	,	c2;	CROSS[BBExit],	c3;	{ E N D }