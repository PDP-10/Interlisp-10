<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Harmony>Dlion>LISPFPTSUBS.MC!1</title>
  </head>
  <body>
    <pre>
{File name LispFPTSubs.mcDescription:  DandeLion InterLisp Emulator Floating Point OpCodesAuthor: CharnleyLast modified: Charnley                7-Aug-84 11:02:42Created:    7-Aug-84 11:02:39}{	FloatIt	Convert TOSH,,TOS to an unboxed floating point number in TOSH,,TOS	can page fault getting data, will restore TOSH and TOS from uTOSH and uTOS	will coerce smallp, smallneg, and Fixp to floating point}{	TIMINGS	FloatP   8  1/3	FixP(long: top 9 bits not the same)   21  1/3	FixP(short: top 9 bits the same)   14  1/3	Smallp   5  1/3	Smallneg   5  1/3}{	trashes Rx, L0, L1	leaves TOSH LRot1 in TT (for fpt ucode)	returns thru L3}Set[L0.RedoCreate, 5];Set[L0.RedoFLFix, 6];FloatIt:	Ybus &larr; TOSH xor smallpl, ZeroBr,	c3;	Ybus &larr; TOSH xor smallneg, ZeroBr, BRANCH[$, FLsmp],	c1;	TT &larr; TOS, BRANCH[$, FLsmn], FloatNop,	c2;{clear pending unloads}	Rx &larr; TOSH, GOTO[CreateFPT], FloatNop,	c3;CreateFPT:	MAR &larr; Q &larr; [TT, Rx + 0],	c1;{not mem ref, byte merge}	rhTT &larr; Rx LRot0, 	c2;	Rx &larr; Q, rhRx &larr; MDSTYPEspaceReal,	c3;	Rx &larr; Rx LRot8,	c1;	Rx &larr; Rx RShift1, SE&larr;1, 	c2;	,	c3;	MAR &larr; [rhRx, Rx + 0],	c1;	Q &larr; 0FF,	c2;	Q &larr; MD and Q,	c3;	Ybus &larr; Q xor FloatpType, ZeroBr,	c1;	Ybus &larr; Q xor FixpType, ZeroBr, BRANCH[GetXnonFpt, $],	c2;	CANCELBR[$],	c3;	Map &larr; [rhTT,TT], L0 &larr; L0.RedoCreate,	c1;	Q &larr; 0FF, L1 &larr; L1.RestoreTosB2, 	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;	MAR &larr; [rhRx, TT + 0], BRANCH[FLptRemap, $],	c1, at[L0.RedoCreate, 10, RMapFixCallerB2];	Q &larr; 0FF,	c2;	TOSH &larr; MD,	c3;	MAR &larr; [rhRx, TT + 1],	c1;	TT &larr; LRot1 TOSH, CANCELBR[$, 2], L3Disp,	c2;	TOS &larr; MD, RET[FloatItRet],	c3;FLptRemap:	CALL[RLMapFixB2],	c2;GetXnonFpt:	{non-FloatType arg}	BRANCH[ArgNotFixp, ArgIsFixp],	c3;ArgNotFixp:	GOTO[ufnX2],	c1;ArgIsFixp:	Map &larr; [rhTT,TT], L0 &larr; L0.RedoFLFix,	c1;	L1 &larr; L1.RestoreTosB2, 	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;	MAR &larr; [rhRx, TT + 0], BRANCH[FxptRemap, $],	c1, at[L0.RedoFLFix, 10, RMapFixCallerB2];	,	c2;	TOSH &larr; MD,	c3;	MAR &larr; [rhRx, TT + 1],	c1;	CANCELBR[$, 2],	c2;	TOS &larr; MD, GOTO[ChipConvFixp],	c3;FxptRemap:	CALL[RLMapFixB2],	c2;FLsmp:	CANCELBR[$], FloatNop,	c2;	ufloat &larr; 0, GOTO[ChipConvShort],	c3;FLsmn:	ufloat &larr; S xor ~S, GOTO[ChipConvShort],	c3;ChipConvShort:	FloatMode.RN.AI.FAST, FloatFLOW,	c1;	FloatA &larr; ufloat, FLFloatA,	c2;	FloatA &larr; TOS LRot0,	c3;	FloatStartFlow,	c1;	Noop,	c2;	Noop,	c3;	Q &larr; 0FF,	c1;	FloatUnloadS, Float.M,	c2;	FloatUnloadS, Float.L,	c3;	TOSH &larr; FloatResult,	c1;	TOS &larr; FloatResult, L3Disp,	c2;	TT &larr; LRot1 TOSH, RET[FloatItRet],	c3;ChipConvFixp:	Q &larr; 80,	c1;	Ybus &larr; TOSH - Q, CarryBr,	c2;	Ybus &larr; TOSH + Q, CarryBr, BRANCH[IsShortp, $],	c3;	Ybus &larr; TOSH, NegBr, BRANCH[IsNotShort, IsShortn],	c1;IsShortp:	CANCELBR[$],	c1;IsShortn:	CANCELBR[$], ufloat &larr; TOSH,	c2;	GOTO[ChipConvShort],	c3;IsNotShort:	Q &larr; 8, BRANCH[itispos, itisneg],	c2;{Q &larr; 100}itispos:	ufloat &larr; 0, GOTO[ChipConvLong],	c3;itisneg:	ufloat &larr; S xor ~S, GOTO[ChipConvLong],	c3;ChipConvLong:	FloatMode.RN.AI.FAST, FloatPIPE,	c1;	FloatAB &larr; ufloat, FLFloatA,	c2;	FloatAB &larr; TOS LRot0,	c3;{has unload side effect}	FloatPump,	c1;	FloatPump,	c2;	FloatA &larr; ufloat, FLFloatA,	c3;	FloatA &larr; TOSH LRot0,	c1;	FloatPump,	c2;	FloatPump,	c3;	FloatUnloadS, Float.M, FloatPump,	c1;	FloatUnloadS, Float.L, FloatPump,	c2;	FloatAB &larr; FloatResult,	c3;	FloatAB &larr; FloatResult,	c1;	FloatUnloadS, Float.M, FloatPump,	c2;	FloatUnloadS, Float.L, FloatPump,	c3;	Rx &larr; Q,	c1;	Rx &larr; Rx LRot8,	c2;	Q &larr; Rx,	c3;	Rx &larr; FloatResult, FloatPump,	c1;	TT &larr; FloatResult, FloatPump,	c2;	Rx &larr; Rx + Q,	c3;	Q &larr; 0FF,	c1;	ufloatplus &larr; Rx,	c2;	FloatA &larr; ufloatplus, FLPlus,	c3;	FloatA &larr; TT LRot0,	c1;	FloatPump,	c2;	FloatPump,	c3;	FloatPump,	c1;	FloatPump,	c2;	FloatPump,	c3;	FloatPump,	c1;	FloatPump, FloatUnloadS, Float.M,	c2;	FloatPump, FloatUnloadS, Float.L,	c3;	TOSH &larr; FloatResult,	c1;	TOS &larr; FloatResult, L3Disp,	c2;	TT &larr; LRot1 TOSH, RET[FloatItRet],	c3;{	subroutines to save, turn around and restore the PPort	PPprepin:	save old PP value, set to input	PPrestore:	restore old PP value}{PPprepin:	Q &larr; 0FF + 1,	c*;	Q &larr; uPPsave and ~Q, L?Disp	c*;	PPort &larr; Q, RET[PPprepinret],	c*;}{PPrestore:	PPort &larr; uPPsave,	c*;}{SetFLMode:	Q &larr; uFLMode,	c3/c1;	AltUaddr, Ybus &larr; Q,	c1/c2;	FloatMode, {FloatFLOW/FloatPIPE},	c2/c3;}	{ E N D }</pre>
  </body>
</html>
