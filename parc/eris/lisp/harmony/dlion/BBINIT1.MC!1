{File name bbInit1.mcDescription: Modified for Lisp, Mesa BitBlt op-codePurcell July 14, 1982  10:38 PM Bit offset correction + PC correct (see ***)Description: Mesa BitBlt op-codeSandman November 2, 1981  2:28 PM New Instruction SetLast edited by Jim August 20, 1981  2:20 PM: Fix for new assembler. Last edited by Jim Frandeen: March 31, 1981  8:39 AM: Change SrcMapRet from Mod 8 to Mod 10.Last edited by Don Charnley: March 6, 1981  1:48 PM: Fixed PageFault/64K cross interaction problem.Last edited by Don Charnley: March 3, 1981  4:08 PM: Moved UWidth into stack, no memory reads after int and pf, stack now has 12'd things.Last edited by Olmstead: February 27, 1981  2:51 PMLast edited by Don Charnley: February 26, 1981  2:35 PM: Add changes for new stack size to save 10 instructions.Author: don charnleyCreated: January, 1980}(1764)\f7@BITBLT:	{Save R and RH registers}	ULsave _ L, L2 _ 0, CALL[SavebbRegs],	,c1;	{SaveRegs subroutine here {2 2/3 Clicks}	,c2-c3;}	 rhType _ Type.normal, push	,c1, at[0,10,SavebbRegsRet];	Xbus _ ErrnIBnStkp, XDisp	,c2;	Noop, DISP4[HowBigStack,06]	,c3;	{move BitBltArg to stack and rh}bbNormEntry: {non-interrupts come here}	{get real address of BitBltArg}	{and insure that it is 0 mod 16}	VS _ UBitBltArg,	,c1, at[hbs.2,10,HowBigStack];	{rhVS = rhMDS, so no need to load it}	VS _ VS and ~0{F***}, L2 _ sd.spec	,c2;	rhRet _ argMap, CALL[SrcMapSpec]	,c3;	{SrcMapSpec subroutine here {2 Clicks}	,c1-c3;}bbGetArg:	{move BitBltArg to U registers}{rtn here}	MAR _ [rhSrcA,SrcA + 8], L0 _ 0	,c1, at[argMap,10,SrcMapRet];	CANCELBR[$,0], L0Disp	,c2;MDtoRbb0:	Rbb0 _ MD{UWidth}, DISP4[MDtoRbb0Ret]	,c3;	MAR _ [rhSrcA,SrcA + 0A], L0 _ 1	,c1, at[0,10,MDtoRbb0Ret];	UWidth _ Rbb0, CANCELBR[MDtoRbb0,0], L0Disp	,c2;{MDtoRbb0:	Rbb0 _ MD{UFlags}, DISP4[MDtoRbb0Ret]	,c3;}	MAR _ [rhSrcA,SrcA + 3], L0 _ 2	,c1, at[1,10,MDtoRbb0Ret];	UFlags _ Rbb0, CANCELBR[MDtoRbb0,0], L0Disp	,c2;{MDtoRbb0:	Rbb0 _ MD{UDstBpl}, DISP4[MDtoRbb0Ret]	,c3;}	MAR _ [rhSrcA,SrcA + 7], L0 _ 3	,c1, at[2,10,MDtoRbb0Ret];	UDstBpl _ Rbb0, CANCELBR[MDtoRbb0,0], L0Disp	,c2;{MDtoRbb0:	Rbb0 _ MD{SrcBpl}, DISP4[MDtoRbb0Ret]	,c3;}	MAR _ [rhSrcA,SrcA + 9], L0 _ 4	,c1, at[3,10,MDtoRbb0Ret];	USrcBpl _ Rbb0, CANCELBR[MDtoRbb0,0], L0Disp	,c2;{MDtoRbb0:	Rbb0 _ MD{Height}, DISP4[MDtoRbb0Ret]	,c3;}	MAR _ [rhSrcA,SrcA + 0], L0 _ 5	,c1, at[4,10,MDtoRbb0Ret];	UHeight _ Rbb0, CANCELBR[MDtoRbb0,0], L0Disp	,c2;{MDtoRbb0:	Rbb0 _ MD{DLo}, DISP4[MDtoRbb0Ret]	,c3;}	MAR _ [rhSrcA,SrcA + 2], L0 _ 6	,c1, at[5,10,MDtoRbb0Ret];	UDstVALo _ Rbb0, CANCELBR[MDtoRbb0,0], L0Disp	,c2;{MDtoRbb0:	Rbb0 _ MD{DBit}, DISP4[MDtoRbb0Ret]	,c3;}	MAR _ [rhSrcA,SrcA + 4], L0 _ 7	,c1, at[6,10,MDtoRbb0Ret];	UDstBit _ Rbb0, CANCELBR[MDtoRbb0,0], L0Disp	,c2;{MDtoRbb0:	Rbb0 _ MD{SLo}, DISP4[MDtoRbb0Ret]	,c3;}	MAR _ [rhSrcA,SrcA + 6], L0 _ 8	,c1, at[7,10,MDtoRbb0Ret];	USrcVALo _ Rbb0, CANCELBR[MDtoRbb0,0], L0Disp	,c2;{MDtoRbb0:	Rbb0 _ MD{SBit}, DISP4[MDtoRbb0Ret]	,c3;}	MAR _ [rhSrcA,SrcA + 5]	,c1, at[8,10,MDtoRbb0Ret];	USrcBit _ Rbb0, CANCELBR[$,0]	,c2;	VS _ rhVS _ MD{SHi}	,c3;{***correct Src}{assume VD and Q avail}	VD _ USrcBit,	c1;	Q _ VD and 0F,	c2;	USrcBit _ Q,	c3;	VD _ VD and ~0F,	c1;	VD _ VD LRot12,	c2;	Q _ USrcVALo,	c3;	VD _ VD + Q,	c1;	USrcVALo _ VD,	c2;	Noop,	c3;{***correct Dst}	VD _ UDstBit,	c1;	Q _ VD and 0F,	c2;	UDstBit _ Q,	c3;	VD _ VD and ~0F,	c1;	VD _ VD LRot12,	c2;	Q _ UDstVALo,	c3;	VD _ VD + Q,	c1;	UDstVALo _ VD,	c2;	Noop,	c3;{***correct done}	MAR _ [rhSrcA,SrcA + 1]	,c1;	UrhVS _ VS, CANCELBR[$,0]	,c2;	VD _ rhVD _ MD{DHi}	,c3;	[] _ UFlags, NegBr	,c1;	UrhVD _ VD, BRANCH[FsetUp,$]	,c2;	{if direction backward, mod SrcVA and DstVA}	{Note:  gray is always forward}	{Backwards SetUp}	TempBpl _ UWidth	,c3;	TempBpl _ TempBpl - 1, rhWho _ sdWidth, CALL[DstVAMod]	,c1;	{DstVAMod subroutine here {4 clicks}	,c2-c1;}	TempBpl _ UWidth	,c2, at[sdWidth,4,DstVAModRet];	TempBpl _ TempBpl - 1, CALL[SrcVAMod]	,c3;	{SrcVAMod subroutine here {4 clicks}	,c1-c3;}	{interrupt entry goes thru this code}	{restore rh from u regs}BandBLTNormEntry:	rhVS _ UrhVS, GOTO[rhfromu]	,c1, at[hbs.C,10,HowBigStack];	rhVS _ UrhVS, GOTO[rhfromu]	,c1, at[hbs.D,10,HowBigStack];rhfromu:	rhVD _ UrhVD	,c2;FsetUp:	Noop	,c3;TextBltToBitBltEntry:	Rbb3{W} _ UWidth	,c1, at[sdWidth,4,SrcVAModRet];	Rbb0{W-1} _ Rbb3{W} - 1, NegBr {test if width = 0}	,c2;	Rbb2 _ 0F, BRANCH[$,Widtheq0]	,c3;	Rbb2 _ Rbb2 LRot12	,c1;	[] _ Rbb2 and Rbb3, ZeroBr	,c2;	Rbb1 _ 8, BRANCH[wnotsmall,wsmall]	,c3;wnotsmall:	Q _ 2	,c1;	Q _ Q or rhType	,c2;	rhType _ Q LRot0	,c3;wsmall:	Rbb4 _ UFlags, NegBr	,c1;	Rbb3 _ Rbb4 LRot4, BRANCH[DirFor,DirBack]	,c2;DirFor:	Rbb1 _ 0	,c3;	Rbb2{W-1} _ Rbb0{W-1}, GOTO[uwwpos]	,c1;DirBack:	Rbb0 _ 0 - Rbb0, NegBr	,c3;	Rbb2{0-(W-1)} _ 0 - Rbb0{W-1}, BRANCH[uwwpos,uwwneg]	,c1;uwwpos:	Rbb2 _ Rbb2 and ~0F, GOTO[conL13]	,c2;uwwneg:	Rbb2 _ Rbb2 or 0F, GOTO[conL13]	,c2;conL13:	Rbb2 _ Rbb2 LRot12{this only used for PgCarry and sign check}	,c3;	UWidthM1 _ Rbb0	,c1;	UWidthW _ Rbb2	,c2;	[] _ UHeight, ZeroBr {test if height = 0}	,c3;	{L3 _ 0,,gr,,0,,sF}	{gr and srcFunc}	Rbb0 _ LRot1 Rbb3, BRANCH[$,Heighteq0]	,c1;	Rbb0 _ Rbb0 and 3	,c2;	Rbb0 _ Rbb0 + 6	,c3;	[] _ Rbb0 and 5, YDisp	,c1;	Xbus _ dtRet.L3, L3 _ 0, XDisp, DISP4[dT]	,c2;	{dT subroutine here {1 cycle}	,c3;}	{dstFunc and dir}	Rbb0 _ Rbb4 LRot8	,c1, at[dtRet.L3,10,dTRets];	Rbb0 _ Rbb0 and 6	,c2;	[] _ Rbb0 or Rbb1, YDisp	,c3;	Xbus _ dtRet.L1, L1 _ 0, XDisp, DISP4[dT]	,c1;	{dT subroutine here {1 cycle}	,c2;}	Rbb0 _ UDstBpl	,c3, at[dtRet.L1,10,dTRets];	[] _ Rbb0 and 0F, ZeroBr	,c1;	Rbb1 _ dbneq0, grDisp, BRANCH[dstwn0,$]	,c2;	Rbb0 _ USrcBpl, grDISP[srcgrchk]	,c3;	Xbus _ 1, XDisp, GOTO[srcchk]	,c1, at[gr.gray,grM,srcgrchk];	[] _ Rbb0 and 0F, ZeroBr, GOTO[srcchk]	,c1, at[gr.notgray,grM,srcgrchk];srcchk:	Rbb1 _ sbneq0, BRANCH[sbnot0,sbis0]	,c2;sbis0:	UrefillType _ dbsb0, GOTO[SetUpAllC1]	,c3;sbnot0:	UrefillType _ Rbb1{sbneq0}, GOTO[SetUpAllC1]	,c3;dstwn0:	UrefillType _ Rbb1{dbneq0}, CANCELBR[SetUpAllC1,0F]	,c3;{	ITEM REFILL	}	{updateHeight, test if thru}ItemRefill3:	Rbb0 _ UHeight, L2 _ sd.src	,c3;	Rbb0 _ Rbb0 - 1, ZeroBr	,c1;	UHeight _ Rbb0, grDisp, BRANCH[$,bbNormExit]	,c2;	rhWho _ sdBpl, grDISP[srcgrayornot]	,c3;{notGray}	TempBpl _ USrcBpl, CALL[SrcVAMod]	,c1, at[gr.notgray,grM,srcgrayornot];	{SrcVAMod subroutine {4 clicks}	,c2-c1;}	{will return to dstUphere}	{update Src address}{gray}	Rbb0{max} _ UGray	,c1, at[gr.gray,grM,srcgrayornot];	Rbb1{cur} _ Rbb0 LRot8	,c2;	Rbb0{max} _ Rbb0 and 0F, ZeroBr	,c3;	Rbb1{cur} _ Rbb1 and 0F, BRANCH[$,dstUphere]	,c1;	Rbb1{cur+1} _ Rbb1{cur} + 1	,c2;	[] _ Rbb0{max} - Rbb1{cur+1}, NegBr	,c3;	Rbb1 _ Rbb1 LRot8, BRANCH[$,GrayWrap]	,c1;	{not gray wrap}	UGray _ Rbb1 xor Rbb0	,c2;	Rbb2{usva} _ USrcVALo	,c3;	Rbb2{usva+1} _ Rbb2{usva} + 1, PgCarryBr	,c1;	Noop, BRANCH[$,GrayNewPage]	,c2;	USrcVALo _ Rbb2{usva+1}	,c3;	GOTO[dstUphere]	,c1;GrayNewPage:	Noop ,c3;	TempBpl _ 10, CALL[SrcVAMod]	,c1;GrayWrap:	UGray _ Rbb0	,c2;	Rbb1{maxX10} _ Rbb0{max} LRot4	,c3;	Rbb2{usva} _ USrcVALo	,c1;	Rbb2{usva-max} _ Rbb2{usva} - Rbb0{max}, PgCarryBr	,c2;	Noop, BRANCH[GrayWrapNewPage,$]	,c3;	USrcVALo _ Rbb2{usva-max}, GOTO[dstUphere]	,c1;GrayWrapNewPage:	TempBpl _ 0 - Rbb1{maxX10}, CALL[SrcVAMod]	,c1;	{update Dst address}dstUphere:	TempBpl _ UDstBpl, CALL[DstVAMod]	,c2, at[sdBpl,4,SrcVAModRet];	{DstVAMod subroutine {4 clicks}	,c3-c2;}	{will return to IntTest}IntTest:	Q _ UWidthM1{, MesaIntBr}{***}	,c3, at[sdBpl,4,DstVAModRet];wdcTest:	[] _ uWDC, ZeroBr, BRANCH[bbNoInt, MaybeInt]	,c1;MaybeInt:	[] _ uWP, ZeroBr, BRANCH[bbNoWDC, bbWDC]	,c2;bbWDC:	ClrIntErr, BRANCH[bbDoInt, $]	,c3;	Noop, GOTO[bbNoInt]	,c1;	{no mesa interrupt}bbNoWDC:	ClrIntErr, CANCELBR[$]	,c3;	Noop	,c1;bbNoInt:	Xbus _ UrefillType, XDisp, CANCELBR[SetUpTest]	,c2;SetUpTest:	[] _ USrcBit + Q, NibCarryBr, LOOPHOLE[niblTiming], DISP2[SetUpAllC1]	,c3;SetUpAllC1:	{Lcount _ number of dest words to be written minus 1 }	Rbb1 _ UDstBit, dirDisp, CANCELBR[$]	,c1, at[dbneq0,4,SetUpAllC1];	Lcount _ Rbb1 and 0F, dirDISP[lcx]	,c2;	Lcount _ 10 - Lcount	,c3, at[dir.backwards,dirM,lcx];	Rbb0 _ ~UWidthM1, GOTO[lccont]	,c1;	Rbb0 _ UWidthM1	,c3, at[dir.forward,dirM,lcx];	Noop, GOTO[lccont]	,c1;lccont:	Lcount _ Lcount + Rbb0	,c2;	Lcount _ Lcount and ~0F	,c3;	{Umask1 _ Rmask[0 - DstBit]}	[] _ 0F - Rbb1{db}, YDisp	,c1;	Xbus _ maskRet.f1, XDisp, DISP4[MaskTbl]	,c2;	{MaskTbl subroutine here {1 cycle}	,c3;}	Lcount _ Lcount LRot12, dirDisp	,c1, at[maskRet.f1,10,MaskRet];	ULcntsav _ Lcount, dirDISP[m2set]	,c2;	{FORWARD MASKS HERE}	Umask1 _ Rbb2	,c3, at[dir.forward,dirM,m2set];	Rbb0{-w+1} _ 0 - Rbb0{w-1}	,c1;	[] _ Rbb0{-w+1} - Rbb1{db} - 1, YDisp	,c2;	Xbus _ maskRet.f2, XDisp, DISP4[MaskTbl]	,c3;	{MaskTbl subroutine here {1 cycle}	,c1;}	Rbb2 _ RShift1 ~Rbb2, SE _ 1, GOTO[stum2]	,c2, at[maskRet.f2,10,MaskRet];	{BACKWARDS MASKS HERE}	Rbb2 _ RShift1 ~Rbb2, SE _ 1	,c3, at[dir.backwards,dirM,m2set];	Noop	,c1;	Umask1 _ Rbb2	,c2;	{Umask2 _ Rmask[width - DstBit - 1]}	[] _ Rbb0{w-2} - Rbb1{db}, YDisp	,c3;	Xbus _ maskRet.b2, XDisp, DISP4[MaskTbl]	,c1;	{MaskTbl subroutine here	,c2;}stum2:	Umask2 _ Rbb2	,c3, at[maskRet.b2,10,MaskRet];	{L0 _ skew + 2}	Rbb0{sb} _ USrcBit, dirDisp, CANCELBR[$]	,c1, at[sbneq0,4,SetUpAllC1];	Rbb1{db} _ UDstBit, dirDISP[WhichMasks]	,c2;	{Q _ Rmask[SrcBit - DstBit]}	[] _ Rbb0{sb} - Rbb1{db} - 1, YDisp	,c3, at[dir.forward,dirM,WhichMasks];	Xbus _ maskRet.fQ, XDisp, DISP4[MaskTbl]	,c1;	{MaskTbl subroutine here {1 cycle}	,c2;}	GOTO[setL0] {leave pre-Qmask in Rbb2}	,c3, at[maskRet.fQ,10,MaskRet];	{Q _ Lmask[DstBit - SrcBit]}	[] _ Rbb0{sb} - Rbb1{db}, YDisp	,c3, at[dir.backwards,dirM,WhichMasks];	Xbus _ maskRet.bQ, XDisp, DISP4[MaskTbl]	,c1;	{MaskTbl subroutine here {1 cycle}	,c2;}	Rbb2 _ RShift1 ~Rbb2, SE _ 1, GOTO[setL0] {leave pre-Qmask in Rbb2}	,c3, at[maskRet.bQ,10,MaskRet];setL0:	Rbb0{skew} _ Rbb0{sb} - Rbb1{db}	,c1;	[]{skew+2} _ Rbb0{skew} + 2, YDisp	,c2;	[] _ dtRet.L0, L0 _ 0, XDisp, DISP4[dT]	,c3;	{dT subroutine here {1 cycle}	,c1;}	scDisp	,c2, at[dtRet.L0,10,dTRets];	Q _ UWidthM1, sc3DISP[FixQ]	,c3;	Rbb2 _ LRot1 Rbb2, GOTO[SavQval]	,c1, at[0D,10,FixQ];	Rbb2 _ RRot1 Rbb2, GOTO[SavQval]	,c1, at[0F,10,FixQ];SavQval:	UmaskL _ Rbb2, L2 _ sd.src	,c2;	[] _ USrcBit + Q, NibCarryBr, {L2 _ sd.src},  LOOPHOLE[niblTiming]	,c3;TouchSourcePages:	Q _ UWidthW, NegBr, BRANCH[oldWords,newWords]	,c1, at[dbsb0,4,SetUpAllC1];oldWords:	BRANCH[oldposchks,oldnegchks]	,c2;newWords:	Q _ Q + 1, PgCarryBr, BRANCH[newposchks1,newnegchks1]	,c2;oldposchks:	[] _ rhType, XDisp, GOTO[oldposs1]	,c3;oldnegchks:	[] _ rhType, XDisp, GOTO[oldnegs1]	,c3;newposchks1:	[] _ rhType, XDisp, BRANCH[oldposs1,newposs1]	,c3;newnegchks1:	[] _ rhType, XDisp, BRANCH[newnegs1,oldnegs1]	,c3;oldposs1:	[] _ USrcVALo + Q, PgCarryBr, DISP3[SrcsmallP,5], LOOPHOLE[byteTiming]	,c1;newposs1:	CANCELBR[$,7]	,c1;	Noop, CANCELBR[pospgs,1]	,c2, at[type.notsmall,typeM,SrcsmallP];	rhRet _ MapOne, BRANCH[posnopgs,pospgs]	,c2, at[type.small,typeM,SrcsmallP];newnegs1:	[] _ USrcVALo + Q , PgCarryBr, DISP3[SrcsmallN,5], LOOPHOLE[byteTiming]	,c1;oldnegs1:	Xbus _ 1, XDisp, DISP3[SrcsmallN,5]	,c1;	rhRet _ MapOne, BRANCH[negpgs,negnopgs]	,c2, at[type.small,typeM,SrcsmallN];	Noop, CANCELBR[pospgs,1]	,c2, at[type.notsmall,typeM,SrcsmallN];pospgs:	Q _ USrcVALo, grDisp, GOTO[smapmore]	,c3;negpgs:	Q _ USrcVALo, grDisp, GOTO[smapmore]	,c3;smapmore:	TempB _ USrcBit, grDISP[schkgray]	,c1;	rhRet _ srcTP	,c2, at[gr.notgray,grM,schkgray];callva:	TempBpl _ UWidthM1, CALL[VAMod]	,c3;	{VAMod subroutine here {2 or 3 clicks}	,c1-c3;}	VS _ rhVS + TempBpl, GOTO[fixrhVS], LOOPHOLE[byteTiming]	,c1, at[Or[srcTP,1],8,VAModRet];	TempB{old} _ USrcVALo, GOTO[comA]	,c1, at[srcTP,8,VAModRet];comA:	Q{new hi} _ Q and ~0FF, dirDisp	,c2;	TempBpl{old hi} _ TempB and ~0FF, dirDISP[comA.1]	,c3;	TempBpl{num hi} _ Q{new hi} - TempBpl{old hi}, GOTO[comX]	,c1, at[dir.forward,dirM,comA.1];	TempBpl{num hi} _ TempBpl{old hi} - Q{new hi}, GOTO[comX]	,c1, at[dir.backwards,dirM,comA.1];comX:	TempB{old low} _ TempB{old} and 0FF	,c2;	TempB _ TempB{old low} or Q{new hi}, sdDisp	,c3;	TempBpl{num low} _ TempBpl LRot8, sdDISP[comB]	,c1;	VS _ TempB	,c2, at[sd.src,sdM,comB];csrc:	rhRet _ sdMap, CALL[SrcMapSpec]	,c3;sSnonewrhF:	VS _ USrcVALoSav, CALL[SrcMapSpec]	,c3;sSnonewrhB:	VS _ USrcVALoSav, CALL[SrcMapSpec]	,c3;{	SrcMapSpec subroutine here  2  clicks	,c1-c3;}	TempBpl _ TempBpl - 1, NegBr	,c1, at[sdMap,10,SrcMapRet];	VS _ 0FF + 1, dirDisp, BRANCH[srcmore,srcthru]	,c2;srcmore:	TempB _ USrcVALoSav, dirDISP[y.f]	,c3;	TempB _ TempB - VS, CarryBr	,c1, at[dir.forward,dirM,y.f];	USrcVALoSav _ TempB, BRANCH[sSnewrhF,sSnonewrhF]	,c2;sSnewrhF:	VS _ rhVS - 1, LOOPHOLE[byteTiming]	,c3;y.c:	rhVS _ VS LRot0	,c1;	CALL[SrcMap]	,c2;	TempB _ TempB + VS, CarryBr	,c1, at[dir.backwards,dirM,y.f];	USrcVALoSav _ TempB, BRANCH[sSnonewrhB,sSnewrhB]	,c2;sSnewrhB:	VS _ rhVS + 1, GOTO[y.c], LOOPHOLE[byteTiming]	,c3;srcthru:	CANCELBR[$,Sub[dirM,2]]	,c3;	Mask2 _ Umask2 {Mask2 = VS}, GOTO[sss]	,c1;	rhRet _ MapOne, GOTO[posnopgs]	,c2, at[gr.gray,grM,schkgray];posnopgs:	VS _ USrcVALo, CALL[SrcMapSpec]	,c3;negnopgs:	VS _ USrcVALo, CALL[SrcMapSpec]	,c3;{	SrcMapSpec subroutine here  2 clicks	,c1-c3;}srcFin:	Mask2 _ Umask2 {Mask2 = VS}, GOTO[sss]	,c1, at[MapOne,10,SrcMapRet];sss:	Q _ UWidthM1	,c2;	[] _ UDstBit + Q, NibCarryBr, L2 _ sd.dst, LOOPHOLE[niblTiming]	,c3;TouchDestPages:	Q _ UWidthW, NegBr, BRANCH[oldWordd,newWordd]	,c1;oldWordd:	BRANCH[oldposchkd,oldnegchkd]	,c2;newWordd:	Q _ Q + 1, PgCarryBr, BRANCH[newposchkd1,newnegchkd1]	,c2;oldposchkd:	[] _ rhType, XDisp, GOTO[oldposd1]	,c3;oldnegchkd:	[] _ rhType, XDisp, GOTO[oldnegd1]	,c3;newposchkd1:	[] _ rhType, XDisp, BRANCH[oldposd1,newposd1]	,c3;newnegchkd1:	[] _ rhType, XDisp, BRANCH[newnegd1,oldnegd1]	,c3;oldposd1:	[] _ UDstVALo + Q, PgCarryBr, DISP3[DstsmallP,5], LOOPHOLE[byteTiming]	,c1;newposd1:	CANCELBR[$,7]	,c1;	Noop, CANCELBR[pospgd,1]	,c2, at[type.notsmall,typeM,DstsmallP];	rhRet _ MapOne, BRANCH[posnopgd,pospgd]	,c2, at[type.small,typeM,DstsmallP];newnegd1:	[] _ UDstVALo + Q, PgCarryBr, DISP3[DstsmallN,5], LOOPHOLE[byteTiming]	,c1;oldnegd1:	Xbus _ 1, XDisp, DISP3[DstsmallN,5]	,c1;	rhRet _ MapOne, BRANCH[negpgd,negnopgd]	,c2, at[type.small,typeM,DstsmallN];	Noop, CANCELBR[pospgd,1]	,c2, at[type.notsmall,typeM,DstsmallN];pospgd:	Q _ UDstVALo, GOTO[dmapmore]	,c3;negpgd:	Q _ UDstVALo, GOTO[dmapmore]	,c3;dmapmore:	TempB _ UDstBit	,c1;	rhRet _ dstTP, GOTO[callva]	,c2;{callva:	TempBpl _ UWidthM1, CALL[VAMod]	,c3;}	{VAMod subroutine here {2 or 3 clicks}	,c1-c3;}	VD _ rhVD + TempBpl, GOTO[fixrhVD], LOOPHOLE[byteTiming]	,c1, at[Or[dstTP,1],8,VAModRet];	TempB{old} _ UDstVALo, GOTO[comA]	,c1, at[dstTP,8,VAModRet];{comA:	Q{new hi} _ Q and ~0FF, dirDisp	,c2;}{	TempBpl{old hi} _ TempB and ~0FF, sdDisp, dirDISP[comA.1]	,c3;}{	TempBpl{num hi} _ Q{new hi} - TempBpl{old hi}, GOTO[comX]	,c1, at[dir.forward,dirM,comA.1];}{	TempBpl{num hi} _ TempBpl{old hi} - Q{new hi}, GOTO[comX]	,c1, at[dir.backwards,dirM,comA.1];}{comX:	TempB{old low} _ TempB{old} and 0FF	,c2;}{	TempB _ TempB{old low} or Q{new hi}, sdDisp	,c3;}{	TempBpl{num low} _ TempBpl LRot8, sdDISP[comB]	,c1;}	VD _ TempB{first touch address}	,c2, at[sd.dst,sdM,comB];cdst:	rhRet _ sdMap, CALL[DstMapSpec]	,c3;dSnonewrhF:	VD _ UDstVALoSav, CALL[DstMapSpec]	,c3;dSnonewrhB:	VD _ UDstVALoSav, CALL[DstMapSpec]	,c3;{	DstMapSpec subroutine here  2 clicks	,c1-c3;}	TempBpl _ TempBpl - 1, NegBr	,c1, at[sdMap,4,DstMapRet];	VD _ 0FF + 1, dirDisp, BRANCH[dstmore,dstthru]	,c2;dstmore:	TempB _ UDstVALoSav, dirDISP[y.fx]	,c3;	TempB _ TempB - VD, CarryBr	,c1, at[dir.forward,dirM,y.fx];	UDstVALoSav _ TempB, BRANCH[dSnewrhF,dSnonewrhF]	,c2;dSnewrhF:	VD _ rhVD - 1, LOOPHOLE[byteTiming]	,c3;y.cx:	rhVD _ VD LRot0	,c1;	CALL[DstMap]	,c2;	TempB _ TempB + VD, CarryBr	,c1, at[dir.backwards,dirM,y.fx];	UDstVALoSav _ TempB, BRANCH[dSnonewrhB,dSnewrhB]	,c2;dSnewrhB:	VD _ rhVD + 1, GOTO[y.cx], LOOPHOLE[byteTiming]	,c3;dstthru:	CANCELBR[$,Sub[dirM,2]]	,c3;	Lcount _ ULcntsav, GOTO[detLoop]	,c1;posnopgd:	VD _ UDstVALo, CALL[DstMapSpec]	,c3;negnopgd:	VD _ UDstVALo, CALL[DstMapSpec]	,c3;{	DstMapSpec subroutine here  2 clicks	,c1-c3;}dstFin:	Lcount _ ULcntsav, GOTO[detLoop]	,c1, at[MapOne,4,DstMapRet];	{determine loop and entry point}detLoop:	Mask1 _ Umask1, grDisp	,c2;	Q _ UmaskL, grDISP[chooseLoop]	,c3;	{if gray then Entry to L1 and L2D at L1I1lsar}	{Entry to L4}L4SetUp:	dirDisp, Dst _ UDstBit{Dbit}	,c1, at[gr.notgray,grM,chooseLoop];	Src _ USrcBit{Sbit}, dirDISP[CheckL4Init]	,c2;	{forward: fetch 1 if Dbit >= Sbit, else fetch 2}	[] _ Dst{Dbit} - Src{Sbit}, NibCarryBr, GOTO[L4I1lsar]	,c3, at[dir.forward,dirM,CheckL4Init];	{backwards: fetch 1 if Sbit >= Dbit, else fetch 2}	[] _ Src{Sbit} - Dst{Dbit}, NibCarryBr, GOTO[L4I1lsar]	,c3, at[dir.backwards,dirM,CheckL4Init];	{Exits}Heighteq0:	Noop	,c2;bbNormExit:	CANCELBR[$,Sub[grM,1]]	,c3;Widtheq0:	[] _ rhType, XDisp, L0 _ restore.term	,c1;	stackP _ 0, DISP3[LSEPReturn,2]	,c2;	{will go to RestoreRandRHRegs if not LSEP}	{RestoreRandRHRegs subroutine {2 1/3 clicks}	,c3-c3;}BBExit:	Xbus _ uPCCross, XRefBr	,c1, at[restore.term,10,RestoreCallers];	Noop, BRANCH[$,BBSetInt]	,c2;	Noop, GOTO[BBThru]	,c3;BBSetInt:	MesaIntRq, GOTO[BBThru]	,c3;	{Mesa Interrupt}bbDoInt:	stackP _ 0C	,c1;	L0 _ restore.int	,c2;	Xbus _ rhType, XDisp	,c3;	DISP3[MoverhVToStkandRestore,3]	,c1;	{RestoreRandRHRegs subroutine {2 1/3 clicks}	,c2-c2;}	Rx _ pInt, push	,c3, at[restore.int,10,RestoreCallers];	TOS _ STK, pop, GOTO[SaveRegs]	,c1;	{PAGE FAULTS}DFault:	UVSsave _ Q	,c3;	uFaultParm0 _ VD	,c1;	Q _ rhVD, GOTO[pfCom]	,c2;SFault:	UVSsave _ Q	,c3;	uFaultParm0 _ VS, sdDisp	,c1;	Q _ rhVS, sdDISP[pfCom]	,c2;pfCom:	stackP _ 0C, GOTO[bbDoFault]	,c3, at[sd.src,sdM,pfCom];	stackP _ 1, GOTO[bbDoFault]	,c3, at[sd.spec,sdM,pfCom];bbDoFault:	uFaultParm1 _ Q	,c1;	L0 _ restore.pf	,c2;	Xbus _ rhType, XDisp	,c3;	DISP3[MoverhVToStkandRestore,3]	,c1;	{RestoreRandRHRegs subroutine {2 1/3 clicks}	,c2-c2;}	T _ UVSsave {Trap index}	,c3, at[restore.pf,10,RestoreCallers];	Rx _ pFault, GOTO[SaveRegs]	,c1;		{END}(0,5080)(1,5842)(2,15240)(3,16510)(4,17780)\f7(0,5588)(1,6350)(2,17018)(3,65535)(4,65535)\f7