{File name NewBLT.mcDescription: new BLT codeAuthor: CharnleyCreated:  9-Jun-83 11:01:00Last edit by Charnley:    20-Jul-83 10:44:09}SetTask[0];{*******************************************************************	BLT {daddr, saddr, nwords}********************************************************************}{	this code uses a two click inner loop to transfer words.	the loop is exited when either the source or the dest	cross a page boundary {and require remapping}	or the required number of words has been moved.	a test for pending interrupts is performed whenever	the source is remapped {care must be taken to 	ignore uPCCrossL}	AT ENTRY	tos  :  number of words	tos-1:  virtual address of first source word	tos-2:  virtual address of first dest word	AT INTERRUPT EXIT	tos  :  number of words remaining	tos-1:  virtual address of first source word	tos-2:  virtual address of first dest word	AT COMPLETION EXIT	stkcnt _ stkcnt - 2}{	REGISTER USAGE	Within Inner Loop:	  Q		cnt of words to go	  TOSH	Src Real Address	  TOS	Dst Real Address	  TT		Move Data	  rhTOSH	High Src Real Address	  rhTOS	High Dst Real Address}{	BLTInnerLoop }BLTS1:	MAR _ {SrcRA}TOSH _ [rhTOSH,TOSH - 1], BRANCH[BLTdone, $],	c1;BLTS2:	BRANCH[$, BLTSrcRemap, 1],	c2;BLTS3:	{Data}TT _ MD,	c3;BLTD1:	MAR _ {DstRA}TOS _ [rhTOS, TOS - 1],	c1;BLTD2:	uSaveTT _ MDR _ {Data}TT, BRANCH[$, BLTDstRemap, 1],	c2;BLTD3:	Q{BLTcnt} _ Q - 1, CarryBr, GOTO[BLTS1],	c3;{	Loop Exits}BLTSrcRemap:	{restore state first}	uSaveTOS _ TOS, L2 _ 1,	c3;{save DstRA, set L2 for Src Remap}{	test for interrupt}	TOS _ Q + 1, L1 _ L1.NoFixes,	c1;{restore TOS}	Ybus _ Q and ~0F, ZeroBr,	c2;{small counts don't interrupt}	TOSH _ smallpl, MesaIntBr, BRANCH[$, BLTnoint0],	c3;{restore TOSH}	Ybus _ uWDC, NZeroBr, BRANCH[BLTnoint1, $],	c1;	Ybus _ uWP, ZeroBr, BRANCH[$, BLTnoint2],	c2;	uWP _ 0, BRANCH[BLTIntNow, BLTnoint3],	c3;BLTIntNow:	ClrIntErr, Rx _ 1,	c1;	uWDC _ Rx,{off interrupts}	c2;	Rx _  KbdFXP, L2 _ 0, GOTO[PUNT],	c3;BLTnoint1:	CANCELBR[$],	c2;BLTnoint2:	CANCELBR[BLTRemap],	c3;BLTSrc:	{BLTRemap returns here}	Rx _ rhRx _ MD, XRefBr,	c3;	Q _ rhRx, BRANCH[BLTSMap, $],	c1,at[L0.RedoBLT,10,RxMapFixCaller];{move rhRx,,Rx to rhTOSH,,TOSH}	rhTOSH _ Q LRot0,	c2;	TOSH _ Rx,	c3;	Q _ TOS - 1,	c1;{restore loop count}	TOS _ uSaveTOS,	c2;{restore DstRA}	c3;	MAR _ {SrcRA}TOSH _ [rhTOSH, TT + 0], GOTO[BLTS2],	c1;BLTSMap:	CALL[RLxMapFix],	c2;BLTDstRemap:{	restore state, prepare for Remap}	uSaveTOSH _ TOSH, L2 _ 3,	c3;{save SrcRA, set L2 for Dst Remap}	TOS _ Q + 1, L1 _ L1.PushOnly,	c1;{restore TOS}	TOSH _ smallpl,	c2;{restore TOSH}	S _ S - 2, GOTO[BLTRemap],	c3;{point stack at Dest}	BLTDst:	{BLTRemap returns here}	Rx _ rhRx _ MD, XwdDisp{XDirtyDisp},	c3;	Q _ rhRx, DISP2[BLTDMap],	c1,at[L0.RedoBLT,10,WMapFixCaller];	rhTOS _ Q LRot0,	c2, at[1, 4, BLTDMap];{move rhRx,,Rx to rhTOS,,TOS}	Q _ TOS - 1,	c3;{restore loop count}	TOS _ Rx,	c1;	TOSH _ uSaveTOSH,	c2;{restore SrcRA}	S _ S + 2,	c3;{restore stack}	MAR _ {DstRA}TOS _ [rhTOS, TT + 0],	c1;	MDR _ uSaveTT, GOTO[BLTD3],	c2;{store saved data}BLTDMap:	CALL[WLMapFix],	c2, at[0, 4, BLTDMap];	CALL[WLMapFix],	c2, at[2, 4, BLTDMap];	CALL[WLMapFix],	c2, at[3, 4, BLTDMap];{****************************************************}BLTnoint0:	MAR _ [rhS, S + 0], L0 _ L0.RedoBLT, CANCELBR[BLTReX],	c1;BLTnoint3:	MAR _ [rhS, S + 0], L0 _ L0.RedoBLT, CANCELBR[BLTReX],	c1;{	Remap Subroutine }BLTRemap:	MAR _ [rhS, S + 0], L0 _ L0.RedoBLT,	c1;BLTReX:	TOS _ TOS - 1, CarryBr,	c2;	TT _ MD{addr}, L2Disp, BRANCH[BLTdone1, $],	c3;	MAR _ [rhS, S - 1], BRANCH[$, BLTsavedest, 1],	c1;	TT _ TT + TOS, CarryBr, CANCELBR[$, 2],	c2;	rhTT _ MD{addrH}, BRANCH[BLT64NoCross, BLT64Cross],	c3;BLTsavedest:	uTOS _ TT, CANCELBR[$, 2],	c2;	Q _ rhTT _ MD,	c3;	uTOSH _ Q,	c1;	TT _ TT + TOS, CarryBr,	c2;	BRANCH[BLT64NoCross, BLT64Cross],	c3;BLT64Cross:	Q _ rhTT + 1, LOOPHOLE[byteTiming],	c1;	rhTT _ Q LRot0,	c2;	GOTO[BLT64NoCross],	c3;BLT64NoCross:	Map _ [rhTT,TT], L2Disp,	c1;	TOS _ TOS + 1, BRANCH[BLTSrc, BLTDst, 1],	c2;{restore count}{****************************************************}BLTdone1:	CANCELBR[$, 3],	c1;	TOSH _ uTOSH, GOTO[BLTdone2],	c2;BLTdone:	TOSH _ uTOSH, CANCELBR[$, 2],	c2;BLTdone2:	TOS _ uTOS,	c3;	PC _ PC + PC16,  MesaIntRq,	c1;	S _ S - 4, IBDisp, L2 _ L2.0, GOTO[DISPNIonly],	c2;BLTufn:	 Rx _ 304'b, GOTO[ufn2],	c1;@BLT:	uSaveTOS _ 0, L2 _ 1,	c1, opcode[304'b];	Ybus _ TOSH xor smallpl, ZeroBr, L1 _ L1.NoFixes,	c2;	rhTOS _ 0, BRANCH[BLTufn, BLTRemap],	c3;	{ E N D }