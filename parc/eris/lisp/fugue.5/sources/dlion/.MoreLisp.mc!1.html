<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>fugue.5>Sources>dlion>MoreLisp.mc!1</title>
  </head>
  <body>
    <pre>
{File name MoreLisp.mcDescription: DandeLion Interlisp EmulatorAuthor: PurcellCreated: June 8, 1981Charnley:   26-Aug-83 14:49:09Charnley:  25-Jun-83 11:54:56 {fixed FVAR&larr; looping}Purcell: April 12, 1983  6:06 PM ; logout uLispBootMsg=55 to mesaPurcell: April 12, 1983  1:15 PM ; BBlt reentrant by state on stackRCLK writes: March 14, 1983  7:31 PMLast edited: February 24, 1983  5:04 PMfixes BLT exit S ok, Last edited: February 24, 1983  5:04 PMfixes to faultable FVAR, Last edited: February 23, 1983  12:58 PMfaultable BitBlt, Last edited: January 7, 1983  6:14 PMnew SUBR #s, Last edited: December 28, 1982  6:39 PMHard Reset, Last edited: December 15, 1982  11:17 PMMPWait, Last edited: December 9, 1982  12:54 AMsubrs, Last edited: August 1, 1982  4:44 PM}SetTask[0];{*******************************************************************	CAR 2%, CDR 2%, LISTP 1%, TYPEP 1%, DTEST, NTYPX		%  ? clicks*******************************************************************}{type table unpacked  at 18000, same segment as map}	MAR &larr; Q &larr; [TOS, TOSH + 0], CALL[typ],	c1, opcode[4'b];{NTYPX}{typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry}ntypex1:	MAR &larr; [rhRx, Rx + 0], L2 &larr; L2.0,	c1, at[4,10, NewTypRet];	TOSH &larr; smallpl, IBDisp, L2 &larr; L2.0,	c2;	TOS &larr; MD and Q,  L2 &larr; L2.0, DISPNI[OpTable],	c3;{*******************************************************************}{	MAR &larr; Q &larr; [TOS, TOSH + 0], CALL[typ{&uarr;}],	c1, opcode[3'b];{LISTP}}	TT &larr; 03'b, CALL[NewTyp],	c1, opcode[3'b];{LISTP}{		NIL will replace the top-of-stack if tos is not a valid LISP pointer (i.e. if it is larger than a 22 bit number).	ELSE: typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry. }	MAR &larr; [rhRx, Rx], Rx &larr; 5 + 0,	c1, at[3,10, NewTypRet];	PC &larr; PC + 0, GOTO[typep3],	c2;	TT &larr; 05'b, CALL[NewTyp],	c1, opcode[5'b];{TYPEP}{		NIL will replace the top-of-stack if tos is not a valid LISP pointer (i.e. if it is larger than a 22 bit number).	ELSE: typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry. }typep1:	MAR &larr; [rhRx, Rx], Rx &larr; ib + 0	c1, at[5,10, NewTypRet];	PC &larr; PC + PC16,	c2;typep3:	Q &larr; MD xor Rx,	c3;	Q &larr; Q - 1, PgCarryBr, L2 &larr; L2.0,	c1;	uTOSH &larr; TOSH, TOSH &larr; 0{nil}, IBDisp, BRANCH[$, noL],	c2; {% reverse?}	TOSH &larr; uTOSH, L2 &larr; L2.0, DISPNI[OpTable],	c3;noL:	TOS &larr; 0{nil}, L2 &larr; L2.0, DISPNI[OpTable],	c3;listpretnil:	L2Disp,	c2;	DISP4[listpdisp],	c3;		GOTO[makeTosNil],	c1, at[3,10,listpdisp];	PC &larr; PC + PC16, Xbus &larr; ib, GOTO[makeTosNil],	c1, at[5,10,listpdisp];makeTosNil:	TOSH &larr; 0{nil}, IBDisp, L2 &larr; L2.0,	c2;	TOS &larr; 0{nil}, L2 &larr; L2.0, DISPNI[OpTable],	c3;{*******************************************************************}	TT &larr; 06'b, CALL[NewTyp],	c1, opcode[6'b];{DTEST}{		NewTyp will call ufn[TT] if tos is not a valid LISP pointer (i.e. if it is larger than a 22 bit number).	ELSE: typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry. }	MAR &larr; [rhRx, Rx + 0],	c1, at[6,10, NewTypRet];	Rx &larr; DTDbasePage,	c2;	TT &larr; MD and Q,	c3;	Rx &larr; Rx LRot8,	c1;	Noop,	c2;	Noop,	c3;	TT &larr; TT LRot4,	c1;	TT &larr; Rx + TT, rhTT &larr; DTDspace,	c2;	Rx &larr; ib,	c3;	Map &larr; Q &larr; [rhTT, TT],	c1;	TT &larr; Rx LRot8,	c2;	rhRx &larr; Rx &larr; MD, {XRefBr,}	c3;	MAR &larr; [rhRx, Q + 0], {BRANCH[dtestMap, $],}	c1;	TT{type} &larr; ib or TT,	c2;	Rx  &larr; MD xor TT, L2 &larr; L2.0,	c3;{??	{MAR &larr;} Rx &larr; Rx and (Rx LRot8), Xbus &larr; Rx LRot8, NZeroBr,	c1;	??}	Ybus &larr; Rx, NZeroBr,	c1;	Rx &larr; 6, BRANCH[$, notOK{, 1}], 	c2;	Noop,	c3;	Noop,	c1;	IBDisp,	c2;	PC &larr; PC + 1, L2 &larr; L2.0, DISPNI[OpTable],	c3;notOK:	IB &larr; TT{type} LRot0,	c3;	PC &larr; PC - PC16, IBPtr&larr;0, GOTO[ufn2],	c1;{dtestMap:	Q &larr; 8'd, GOTO[sink3], 	c2;{MP9008}}{*******************************************************************}car:	TT &larr; 01'b, CALL[NewTyp],	c1, opcode[1'b];{CAR}cdr:	TT &larr; 02'b, CALL[NewTyp],	c1, opcode[2'b];{CDR}{		NewTyp will call ufn[TT] if tos is not a valid LISP pointer (i.e. if it is larger than a 22 bit number).	ELSE: typ increments PC by a byte, returns Q:0FF; Rx: real address of type table entry. }NewTyp:	Xbus &larr; TOSH LRot12, XDisp,	c2;	Rx &larr; TT, NegBr, DISP4[NewTypDisp, 3],	c3;	MAR &larr; Q &larr; [TOS, TOSH + 0], CANCELBR[$],	c1, at[03,10,NewTypDisp];typ:	Rx &larr; Q, rhRx &larr; MDSTYPEspaceReal, 	c2;	Rx &larr; Rx LRot8, L1 &larr; L1.DecOnly,	c3;	Rx &larr; Rx RShift1, SE&larr;1,	c1;	PC &larr; PC + PC16, L2Disp, 	c2;	Q &larr; 0FF, DISP4[NewTypRet],	c3;	BRANCH[carcdrufn, listpretnil],	c1, at[07,10,NewTypDisp];	BRANCH[carcdrufn, listpretnil],	c1, at[0B,10,NewTypDisp];	BRANCH[carcdrufn, listpretnil],	c1, at[0F,10,NewTypDisp];carcdrufn:	GOTO[ufn3],	c2;	MAR &larr; [rhRx, Rx], Rx &larr; 5 + 0, L0&larr;L0.xRedoCdr, GOTO[cadr],	c1, at[1,10, NewTypRet];	MAR &larr; [rhRx, Rx], Rx &larr; 5 + 0, L0&larr;L0.xRedoCdr, GOTO[cadr],	c1, at[2,10, NewTypRet];cadr:	rhTT &larr; TOSH LRot0, ZeroBr,	c2;	Q &larr; MD xor Rx, BRANCH[$, cadrN],	c3;	Map &larr; TT &larr; [rhTT, TOS], GOTO[cadr1],	c1;cadrN:	Map &larr; TT &larr; [rhTT, TOS], ZeroBr,	c1;cadr1:	Q &larr; Q - 1, PgCarryBr, BRANCH[$, tosNil],	c2;cadr3:	uTOSH &larr; TOSH, rhRx &larr; Rx &larr; MD, XRefBr, BRANCH[$, cadrUfn],	c3;cadrH:	MAR &larr; Q &larr; [rhRx, TOS], L2Disp, BRANCH[cadrMap, $],	c1, at[L0.xRedoCdr, 10, RxMapFixCaller];	rhTT &larr; Rx LRot0, TT &larr; Q + 1, BRANCH[$, carTail, 0E],	c2;	Rx &larr; ~MD, XHDisp,	c3;{****************cdr cases: cdrLoc, cdrIndLoc, indCell****************}cdrL:	MAR &larr; [rhRx, TT], Rx{~,=} &larr; -Rx-1, CarryBr{0#MDhigh}, BRANCH[cdrInd, cdrDir, 2], LOOPHOLE[pci],	c1;cdrInd:	rhTOSH &larr; Rx LRot0, TOSH &larr; Rx LRot1, BRANCH[indCell, cdrIndLoc, 2],	c2;cdrDir:	TOSH &larr; ~Rx LRot8, CANCELBR[$, 3],	c2;{Regs:	         TOSH{cdr},   uTOSH{tosH}, TOS{tos}	cdrLoc	         TOSH{cdr},   rhTT{rhRx}, TT{Rx}	cdrIndLoc	         rhTOSH{carH}, MD{car}	indCell }cdrLoc:	TOSH &larr; (TOSH and u7F) LShift1, ZeroBr, CANCELBR[$, 1],	c3;	MAR &larr; TOS &larr; [TOS, TOSH + 0], BRANCH[$, cdrNil, 2],	c1;{rhTOS?%}	TOSH &larr; uTOSH, L2 &larr; L2.0, IBDisp,	c2;	TOSH &larr; TOSH and 0FF, L2 &larr; L2.0, DISPNI[OpTable],	c3;tosNil:	Noop, CANCELBR[$, 1],	c3;	Noop,	c1;cdrNil:	TOS &larr; 0, L2 &larr; L2.0, IBDisp,	c2;	TOSH &larr; 0, L2 &larr; L2.0, DISPNI[OpTable],	c3;cdrIndLoc:	TOSH &larr; ~(TOSH LRot8),	c3;	MAR &larr; Q &larr; [rhTT{rhRx}, TOSH{cdr} or 1],	c1;	TOSH &larr; 0FF , CANCELBR[$, 2],	c2;	TOS &larr; MD,	c3;	MAR &larr; [rhTT, Q - 1], L2 &larr; L2.0, 	c1;	IBDisp, CANCELBR[$, 2],	c2;	TOSH &larr; MD and TOSH, L2 &larr; L2.0, DISPNI[OpTable],	c3;{**************** car cases: indCell, other ****************}carTail:	TOSH &larr; MD, rhTOSH &larr; MD, XHDisp,	c3;carL:	MAR &larr; [rhRx, TOS + 1], BRANCH[$, carDir, 2],	c1;	Ybus &larr; TOSH and ~u0FF, NZeroBr, CANCELBR[$, 2],	c2;indCell:	TOS &larr; MD{car}, BRANCH[$, carIndLoc],	c3;	Map &larr; [rhTOSH, TOS], TOSH &larr; rhTOSH, L0&larr;L0.xRedoCdr,	c1;	rhTT &larr; TOSH LRot0, {{*}TT &larr; Q,{*}}GOTO[cadr3], {L0 still set}	c2;carIndLoc:	TOSH &larr; rhTOSH,	c1;	L2 &larr; L2.0, IBDisp,	c2;	L2 &larr; L2.0, DISPNI[OpTable],	c3;carDir:	TOSH &larr; rhTOSH, L2 &larr; L2.0, IBDisp, DISP2[dumb],	c2;dumb:	TOS &larr; MD, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0, 10, dumb];	Q &larr; 9'd, GOTO[sink1],	c3, at[2, 10, dumb];{MP9009}{**************** exceptions                   ****************}cadrMap:	TT &larr; TOS, CANCELBR[RLxMapFix, 0F], {returns to cdrH}	c2;cadrUfn:	PC &larr; PC - PC16, CANCELBR[ufnX2, 1],	c1;{*******************************************************************	RAID	? %  ? clicks*******************************************************************}{display function name in MP; wait for right shift}RAID:	opcode[76'b],{3E}	Q &larr; TOS + 0FF + 1,	c1;	Q{TOS + 300'd} &larr; Q + 2C,	c2;	PC &larr; PC + PC16, GOTO[sink1],	c3;{display Q in MP; wait for right shift key; noop}MPWait:	Noop,	c1;MPWait2:	rhRx &larr; 41, Rx &larr; 41-1,	c2;	Rx{14000} &larr; Rx LRot8,	c3;	MAR &larr; [rhRx, 41+0],	c1;	Noop,	c2;	TT{saveMP} &larr; MD,	c3;	MAR &larr; [rhRx, 41+0],	c1;	MDR &larr; Q,	c2;	uTT{saveMP} &larr; TT, TT &larr; TT xor ~TT, NZeroBr,	c3;	{TESTING  - - END OLD }{"stop" key hard reset}raidLp1:	MAR &larr; [rhRx, 3E+0],  BRANCH[raidEnd1, $, 2]	c1;	Noop ,	c2;	Xbus &larr; MD, XDisp,	c3;{"undo" key down}	MAR &larr; [rhRx, 3E+0],  BRANCH[StopK, $, 0B]	c1;	Noop ,	c2;	Xbus &larr; MD, XLDisp, GOTO[raidLp1],	c3;raidEnd1:	rhRx &larr; nRhS,	c2;	Rx &larr; PV - 09,	c3;	MAR &larr; [rhRx, Rx+0],	c1;	Noop,	c2;	Rx{Alink} &larr; MD,	c3;	Rx &larr; Rx and ~1,	c1;	Rx &larr; Rx - 8,	c2;	 Noop,	c3;	MAR &larr; [rhRx, Rx+0],	c1;	Noop,	c2;	TT{code lo} &larr; MD,	c3;	MAR &larr; [rhRx, Rx+1],	c1;	Noop, CANCELBR[$ ,2]	c2;	rhTT{code hi} &larr; MD,	c3;	Map &larr; [rhTT, TT+0],	c1;	Noop,	c2;	 rhRx &larr; Rx &larr; MD,	c3;	MAR &larr; [rhRx, TT+5],	c1;	Noop, CANCELBR[$ ,2]	c2;	Q{fn name} &larr; MD,	c3;{restore Rx to iopage for MP}	Noop,	c1;	rhRx &larr; 41, Rx &larr; 41-1,	c2;	Rx{14000} &larr; Rx LRot8,	c3;	MAR &larr; [rhRx, 41+0],	c1;	MDR &larr; Q,	c2;	Noop,	c3;{"undo" key up}raidLp2:	MAR &larr; [rhRx, 3E+0],  BRANCH[$, raidEnd2, 2]	c1;	Noop ,	c2;	TT &larr; MD, XLDisp, GOTO[raidLp2],	c3;raidEnd2:	Ybus &larr; TT, YDisp,	c2;	BRANCH[Burdx, $, 0B],	c3;raidEnd:	MAR &larr; [rhRx, 41+0], CANCELBR[$, 0F],	c1;	MDR &larr; uTT{saveMP},	c2;	L2&larr;0,	c3;	Rx &larr; 1,	c1;	uWDC &larr; Rx,	c2;	Rx &larr; {TeleRaidFXP}30'b, GOTO[PUNT],	c3;Burdx:	MAR &larr; [rhRx, 41+0], CANCELBR[$, 0F],	c1;	MDR &larr; uTT{saveMP},L2&larr;0, IBDisp,	c2;	IOPCtl &larr; 1, L2&larr;0, DISPNI[OpTable],	c3;StopK:	TT &larr; UvCL,	c2;	rhTT &larr; UvChighL,	c3;	Map &larr; [rhTT, TT+0],	c1;	Noop,	c2;	 rhRx &larr; Rx &larr; MD,	c3;	MAR &larr; [rhRx, TT+5],	c1;	Noop, CANCELBR[$ ,2]	c2;	Q{fn name} &larr; MD,	c3;	Noop,	c1;	rhRx &larr; 41, Rx &larr; 41-1,	c2;	Rx{14000} &larr; Rx LRot8,	c3;	MAR &larr; [rhRx, 41+0],	c1;	MDR &larr; Q,	c2;	Noop,	c3;{"stop" key up}stopLp2:	MAR &larr; [rhRx, 3E+0],  BRANCH[$, stopEnd2, 0B]	c1;	Noop ,	c2;	Xbus &larr; MD, XDisp, GOTO[stopLp2],	c3;stopEnd2:	Noop,	c2;	Noop,	c3;	MAR &larr; [rhRx, 41+0],	c1;	MDR &larr; uTT{saveMP},	c2;	Noop, GOTO[Reset],	c3;{*******************************************************************	SUBRCALL	? %  ? clicks*******************************************************************}{pop "b" items and push 1 item}SUBR:	TT &larr; ib, L2&larr;L2.0,	c1, opcode[175'b];{7D}	Ybus &larr; TT xor 12'b, {ZeroBr,}	c2;	Noop,{ BRANCH[$, Clock],}	c3;	Rx &larr; TT xor 0F{1C},	c1;	Ybus &larr; Rx, ZeroBr{=0F{1C}},	c2;	Noop, BRANCH[$, RaidS],	c3;	Rx &larr; TT xor 12{23}, GOTO[subrM],	c1;subrM:	Ybus &larr; Rx, ZeroBr{=12{23}},	c2;	Noop, BRANCH[$, SETSCREENCOLOR],	c3;	Rx &larr; TT xor 20'b,	c1;	Ybus &larr; Rx, ZeroBr{=20'b},	c2;	Noop, BRANCH[$, Pup],	c3;	Rx &larr; TT xor 15'b,	c1;	Ybus &larr; Rx, ZeroBr{=15'b},	c2;	Noop, BRANCH[$, logout],	c3;	Rx &larr; TT xor 6{7},	c1;	Ybus &larr; Rx, ZeroBr{=6{7}},	c2;	Rx &larr; TT xor 9{21'b}, BRANCH[$, BackGround],	c3;	Ybus &larr; Rx, ZeroBr{=9{21'b}},	c1;	Rx &larr; TT xor 13{44'b}, BRANCH[$, DspBout3],	c2;	Ybus &larr; Rx, ZeroBr{=13{44'b}},	c3;	Rx &larr; ib, ZeroBr, BRANCH[$, ShowDisplay],	c1;	PC &larr; PC + 1, BRANCH[$, subrPush],	c2;	Rx &larr; (Rx -1) LShift1, SE&larr;0,	c3;Subrs:	S &larr; S - Rx,	c1;	PC &larr; PC + PC16, L2&larr;L2.0, {IBDisp,}	c2;	Rx &larr; 26,	c3;	Rx &larr; Rx LRot8,	c1;	Rx{9900=26ACh} &larr; Rx +0AC,	c2;	Q &larr; Rx +TT{raid#}, GOTO[MPWait{sink1}],	c3;subrPush:	Noop,	c3;	MAR &larr; S &larr; [rhS, S + 1], GOTO[CopyRet],	c1;RaidS:	Rx &larr; TT xor 12{23}, GOTO[subrM],	c1;{error}{RaidS:	Rx &larr; ib, ZeroBr, GOTO[NoopS2],	c1;}DspBout3:	Noop,	c3;SETSCREENCOLOR: Rx &larr; ib, ZeroBr, GOTO[NoopS2],	c1;Pup:	Rx &larr; ib, ZeroBr, GOTO[NoopS2],	c1;NoopS2:	PC &larr; PC + 1, BRANCH[$, subrPush3],	c2;	Rx &larr; (Rx -1) LShift1, SE&larr;0,	c3;	S &larr; S - Rx,	c1;	PC &larr; PC + PC16, L2&larr;L2.0, IBDisp,	c2;	L2&larr;L2.0, DISPNI[OpTable],	c3;subrPush3:	Noop,	c3;	MAR &larr; S &larr; [rhS, S + 1], GOTO[CopyRet],	c1;logout:	TT &larr; 55{password to mesa},	c1;	uLispBootMsg &larr; TT,	c2;	Noop,	c3;	TT &larr; 0 RShift1, SE &larr; 1,	c1;	rhRx &larr; 41, Rx &larr; 41-1,	c2;	Rx{14000} &larr; Rx LRot8,	c3;Off:	MAR &larr; [rhRx, 5A+0],	c1;	MDR{8004} &larr; TT or 4,	c2;	Noop,  GOTO[Off],	c3;{*******************************************************************}BackGround:	Rx &larr; ib, ZeroBr,	c1;	PC &larr; PC + 1, BRANCH[$, subrPushBG],	c2;	Rx &larr; (Rx -1) LShift1, SE&larr;0,	c3;	S &larr; S - Rx,	c1;	PC &larr; PC + PC16, L2&larr;L2.0, IBDisp,	c2;	L2&larr;L2.0, DISPNI[OpTable],	c3;subrPushBG:	Noop,	c3;	MAR &larr; S &larr; [rhS, S + 1], GOTO[CopyRet],	c1;{*******************************************************************}ShowDisplay:	Rx &larr; 1 RRot1, rhRx &larr; 1, CANCELBR[$, 1],	c2;	Rx{4000} &larr; Rx RShift1,	c3;	Noop, {MAR &larr; [rhRx, 0EA+0],}	c1;	Noop, {MDR &larr; 45,}	c2;	S &larr; S - 2{(2 args -1)*2},	c3;	MAR &larr; [rhRx, 0EB+0],	c1;	Noop{MDR &larr; 0},{wakeup}	c2;	TT &larr; 88,	c3;	MAR &larr; [rhRx, 0EC+0],	c1;	MDR &larr; 0{Q &larr; 41},	c2;	TT &larr; TT LRot8,	c3;	MAR &larr; [rhRx, 0ED{0EF}+0],	c1;	MDR &larr; TT{88} or 22,	c2;	PC &larr; 1 + PC + PC16,	c3;	Noop, {MAR &larr; [rhRx, 0E9+0],}	c1;	Q &larr; 41, {MDR &larr; 0, IBDisp,}	c2;	DCtl&larr;Q LRot0, L2 &larr; L2.0, DISPNI[OpTable],	c3;{*******************************************************************}{Clock:	PC &larr; PC + 1, L1 &larr; L1.Dec3,	c1;	uTOSH &larr; TOSH, Xbus &larr; ib{=1}, GOTO[Clock3],	c2;}RCLK:	L1 &larr; L1.DecOnly,	c1, opcode[167'b]; {77}	uTOSH &larr; TOSH, GOTO[Clock3],	c2;Clock3:	rhTT &larr; TOSH LRot0,	c3;	Map &larr; TT &larr; [rhTT, TOS], L0 &larr; L0.RedoClk,	c1;	PC &larr; PC + PC16,	c2;	Rx &larr; rhRx &larr; MD, XDirtyDisp,	c3;at[L0.RedoClk,10,WMapFixCaller],	Q &larr; uClockHigh, BRANCH[ClkMap,$,1],	c1;	TOSH &larr; RShift1 uClockBits, SE&larr;0,	c2;	TT &larr; uClockLow,	c3;	MAR &larr; [rhRx, TOS+1], L2 &larr; L2.0,	c1;	MDR &larr; TOSH +TT, CANCELBR[$, 2], WriteOK,	c2;	Ybus &larr; TOSH +TT, CarryBr,	c3;	MAR &larr; [rhRx, TOS+0], BRANCH[ClkNoCar, ClkCar],	c1;ClkNoCar:	MDR &larr; Q, IBDisp, GOTO[reTosh],	c2;ClkCar:	MDR &larr; Q+1, IBDisp, GOTO[reTosh],	c2;reTosh:	TOSH &larr; uTOSH, L2 &larr; L2.0, DISPNI[OpTable],	c3;ClkMap:	CALL[WLMapFix]{will return at RedoClk},	c2;{*******************************************************************}{is this used?SClock:	Noop,	c1;	uTOSH &larr; TOSH,	c2;	rhTT &larr; TOSH LRot0,	c3;	Map &larr; TT &larr; [rhTT, TOS], L0 &larr; L0.xRedoSClk,	c1;	PC &larr; PC + 1, L1 &larr; L1.DecDec,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;at[L0.xRedoSClk,10,RxMapFixCaller],	MAR &larr; [rhRx, TOS+1], BRANCH[SClkMap,$],	c1;	Noop, CANCELBR[$, 2],	c2;	TT &larr; MD, L2 &larr; L2.0,	c3;	MAR &larr; [rhRx, TOS+0],	c1;	Noop,	c2;	Rx &larr; MD,	c3;	uClockHigh &larr; Rx,	c1;	uClockLow &larr; TT, IBDisp, L2 &larr; L2.0,	c2;	uClockBits &larr; 0, L2 &larr; L2.0, DISPNI[OpTable],	c3;SClkMap:	CANCELBR[RLxMapFix, 3]{will return at RedoSClk},	c2;is this used?}{*****************************************************************************	BITBLT*****************************************************************************}{OLD: {CAUTION: there is a delicate sharing of .u+D by uTOS and UWidth; during faults UWidth is stored in TOS; at restart {BBpart} it is tested for nonZero and restorted}}{.u+2 thru .u+C must be preserved accross faults; in particular no bitBlt by fault handler}{TOS=0 if virgin BB call;  else suspended with saved state on stack under TOS}{2 args one usually 0 in TOS; S points to ptr to BBtable}BITBLT:	MAR &larr; [rhS, S+0],	c1, opcode[166'b];	{UWidth}Ybus &larr; TOS, NZeroBr,	c2;	TOS &larr; MD, BRANCH[$, BBpart],	c3;	MAR &larr; S &larr; [rhS, S - 1],	c1;	S&larr;S-1, CANCELBR[$, 2],	c2;	TOSH &larr; MD,	c3;{S points to some stack entry that has nothing to do with BB}{BBInit vs BBInit1 differ on advacing PC}	PC &larr; PC + 1{PC16}{1}{%?}{saveRegs does PC&larr;PC-1},	c1;	stackP &larr; 2,	c2;	Noop,	c3;	uPCCross &larr; TOSH xor ~TOSH,{uPCCross#uPCCrossL}	c1;	STK{UBitBltArg} &larr; TOS, pop,	c2;	rhMDS &larr; TOSH LRot0, GOTO[@BITBLT],	c3;{@BITBLT returns directly to IBDispOnly; saves and restores L, G, PC}BBpart:	{Q &larr; 166'b, GOTO[sink2],	c1;}	uPCCross &larr; TOSH xor ~TOSH,{uPCCross#uPCCrossL}	c1;	PC &larr; PC + 1{PC16}{1}{%?}{undone by saveRegs},	c2;	stackP &larr; 0C{vestigial}, {GOTO[@BITBLT],}	c3;{restore 12 uRegs from memory stack: u2 thru u0D } 	stackP &larr; 0D,	c1;	Rx &larr; 0C,	c2;BBLp:	Noop,	c3;{Stack pointer points to full odd word } 	MAR &larr; S &larr; [rhS, S +0], 	c1;	S &larr; S - 2,	c2;	TT &larr; MD,	c3;	Rx &larr; Rx - 1, ZeroBr,	c1;	STK &larr; TT, pop, BRANCH[BBLp, BBLpD],	c2;BBLpD:	stackP &larr; 0C{not vestigial}, GOTO[@BITBLT],	c3;bbDummy:	Noop, DISP4[ESC2n],	c3;{@BITBLT returns  to IBDispOnly normally or to SaveRegs if fault {or interrupt}}{interupts are temporarily disabled in BB}{S points to some stack entry that has nothing to do with BB}{if faulting save 12 uRegs to memory stack: u2 thru u0D } {then set TOSH,TOS to nonzero to indicate BB suspended (PFault saves TOS)} {at PFault TOS is nonzero and under that is saved regs } SaveRegs: {come here on pageFault}{{state held in stack (faults can't bitblt)}}	rhTT &larr; uFaultParm1, 	c2;	TT &larr; uFaultParm0,	c3;{Stack pointer points to full odd word } {save 12 uRegs from memory stack: u2 thru u0D } 	stackP &larr; 02,	c1;	Rx &larr; 0C,	c2;BBsLp:	S{even empty} &larr; S{odd full} + 1,	c3;	MAR &larr; S &larr; [rhS, S +0], 	c1;	MDR &larr; smallpl,	c2;	S &larr; S + 1,	c3;	MAR &larr; S &larr; [rhS, S +0], 	c1;	MDR &larr; STK, push,	c2;	Noop,	c3;	Rx &larr; Rx - 1, ZeroBr,	c1;	BRANCH[BBsLp, BBsLpD],	c2;BBsLpD:	stackP &larr; 0C{not vestigial},	c3;BBFault:	TOSH &larr; smallpl,	c1;	TOS &larr; 1{UWidth}{uTOS}, L1 &larr; L1.NoFixes{DecOnly?},	c2;	stackP &larr; 0,  GOTO[PFault],	c3;{S points to some stack entry that has nothing to do with BB}{Normal BB returns undefined : set TOSH, TOS to any valid object (use smallpl)}{@BITBLT returns directly to IBDispOnly; saves and restores L{PV}, G{S}, PC}{stackP was set to zero by BB as we return here; any thing below .u+D is ok}IBDispOnly: {stackP &larr; 0} IBDisp, L2 &larr; L2.0,	c2;	TOSH &larr; smallpl, L2 &larr; L2.0, DISPNI[OpTable],	c3;{*****************************************************************************	MISC	Input*****************************************************************************}MISC1:	L2 &larr; L2.0, GOTO[Misc],	c1, opcode[170'b];MISC2:	L2 &larr; L2.0,	c1, opcode[171'b];Misc:	PC &larr; PC + 1, Xbus &larr; ib, XDisp,	c2;	uTOS &larr; TOS, DISP4[MiscDisp, 0C],	c3;Misc0:	Q &larr; 121'd, GOTO[sink2],	c1, at[0C,10, MiscDisp];{MP9121}Misc3:	Q &larr; 121'd, GOTO[sink2],	c1, at[0F,10, MiscDisp];{MP9121}{*****************************************************************************	INPUT	Input*****************************************************************************}INPUT:	Ybus &larr; TOS, YDisp,	c1, at[0D,10, MiscDisp];	TOSH &larr; smallpl, IBDisp, DISP4[Inpt, 8],	c2;Inpt:	TOS &larr; EIData, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[8,10,Inpt];	TOS &larr; EStatus, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[9,10,Inpt];	TOS &larr; KIData, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0A,10,Inpt];	TOS &larr; KStatus, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0B,10,Inpt];	   Q &larr; 120'd, GOTO[sink1],	c3, at[0C,10,Inpt];{MP9120}	TOS &larr; MStatus, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0D,10,Inpt];	TOS &larr; KTest, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0E,10,Inpt];	TOS &larr; PPort, L2 &larr; L2.0, DISPNI[OpTable],	c3, at[0F,10,Inpt];{*****************************************************************************	OUTPUT	Output*****************************************************************************}OUTPUT:	MAR &larr; S &larr; [rhS, S + 0], Xbus &larr; uTOS, XDisp,	c1, at[0E,10, MiscDisp];	S &larr; S - 2, DISP4[Outpt],	c2;Outpt:	IOPOData &larr; MD, GOTO[OutEnd],	c3, at[0,10,Outpt];	IOPCtl &larr; MD, GOTO[OutEnd],	c3, at[1,10,Outpt];	KOData &larr; MD, GOTO[OutEnd],	c3, at[2,10,Outpt];	KCtl &larr; MD, GOTO[OutEnd],	c3, at[3,10,Outpt];	EOData &larr; MD, GOTO[OutEnd],	c3, at[4,10,Outpt];	EICtl &larr; MD, GOTO[OutEnd],	c3, at[5,10,Outpt];	DCtl &larr; MD, GOTO[OutEnd],	c3, at[6,10,Outpt];	TT &larr; MD, GOTO[OutSetBBTime],	c3, at[7,10,Outpt];	TT &larr; MD, GOTO[OutSetOpt],	c3, at[8,10,Outpt];	PCtl &larr; MD, GOTO[OutEnd],	c3, at[9,10,Outpt];	TT &larr; MD, GOTO[OutMCtl],	c3, at[0A,10,Outpt];	  Q &larr; 120'd, GOTO[sink1],		c3, at[0B,10,Outpt];{MP9120}	EOCtl &larr; MD, GOTO[OutEnd],	c3, at[0C,10,Outpt];	KCmd &larr; MD, GOTO[OutEnd],	c3, at[0D,10,Outpt];	TT &larr; MD, GOTO[OutPPort],	c3, at[0E,10,Outpt];	POData &larr; MD, GOTO[OutEnd],	c3, at[0F,10,Outpt];OutSetBBTime:	uBBTime &larr; TT, GOTO[IB.nop],	c1;OutEnd:	Noop, GOTO[IB.nop],	c1;OutPPort:	PPort &larr; TT, GOTO[IB.nop],	c1;OutSetOpt:	uLispOptions &larr; TT, GOTO[IB.nop],	c1;OutMCtl:	MCtl &larr; TT, GOTO[IB.nop],	c1;IB.nop:	L2 &larr; L2.0, IBDisp, GOTO[DNI.nop],	c2;		{*******************************************************************	FVAR		? %  ? clicks*******************************************************************}	uTOS &larr; TOS, TT &larr; MD, XLDisp, {L1 &larr; L1.PopOnly,} CANCELBR[$, 1],	c3, at[6, 8, IVar3];{checks for stack overflow later}{(Bh) binding pointer high}	MAR &larr; Q{chain} &larr; [rhRx, Rx + 1],  BRANCH[$, FVunfilled, 2],	c1;	{uPV &larr; PV,} CANCELBR[$, 2],	c2;	{Q &larr;} rhTT &larr; MD, {L1 &larr; L1.PopOnly,}	c3;{(MV) map bound val}fvFilled:	Map &larr; [rhTT, TT], CANCELBR[$, 07], L1 &larr; L1.PopOnly,	c1, at[L3.FVAR,10, fvCaller];	TOS &larr; uTOS, L0 &larr; L0.xRedoFV0,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;{(V) fetch bound val}RedoFV0:	MAR &larr; [rhRx, TT + 1],  BRANCH[fvMap0, $],	c1, at[L0.xRedoFV0,10, RxMapFixCaller];	[] &larr; S xor uStkLimO, ZeroBranch, CANCELBR[$,2],	c2;	TOS &larr; MD, BRANCH[$, StkOvr2], L2Disp,	c3;{Var4:}	MAR &larr; [rhRx, TT + 0], BRANCH[fvPC1, fvPC2, 2],	c1;fvPC1:	PC &larr; PC + PC16, IBDisp, GOTO[fvEnd], L2 &larr; L2.0,	c2;fvPC2:	PC &larr; PC + 1, IBDisp, GOTO[fvEnd], L2 &larr; L2.0,	c2;fvEnd:	TOSH &larr; MD, L2 &larr; L2.0, DISPNI[OpTable],	c3;StkOvr2:	MAR &larr; [rhRx, TT + 0], BRANCH[fvPC1ov, fvPC2ov, 2],	c1;fvPC1ov:	PC &larr; PC + PC16, GOTO[fvEndov], L2 &larr; L2.0,	c2;fvPC2ov:	PC &larr; PC + 1, GOTO[fvEndov], L2 &larr; L2.0,	c2;fvEndov:	TOSH &larr; MD, GOTO[StackOverflow],	c3;FVunfilled:	TT &larr; UvCL, L3 &larr; L3.FVAR, CANCELBR[$,2],	c2;	rhTT &larr; UvChighL, CALL[FVLookUp],	c3;fvMap0:	TOSH &larr; uTOSH, CANCELBR[RLxMapFix, 3]{will return to RedoFV0},	c2;{*******************************************************************	FREE VAR LOOKUP		? %  ? clicks*******************************************************************}{	look up variable in current frame; fill in binding pointer	(chaining not implemented)on Entry:	c1uTOS	restored to TOS if faultuTOSH	restored to TOSH if faultPV	current frame (point to PV region)Q	{uChain}  (odd) stack pointer to variable to be looked up (Pv + ib + 1)rhTT, TT	virtual address of name table (usually function header)L3	caller's return link at[L3, 10, fvCaller]uses during subroutine:rhRx, Rx	real address of name tablePV	frame extension pointers (point to PV region)(travel up alinks)uPV	save local PVTOS	useduChain	TOSH{chain}rhTOSH	nRhS {set once at odd time; must be left}{*} used with TOSH{chain}uName	TOSH{name} &larr; [UvCL + T/2 {- UvCL.nlocals} + UvCL.fvaroffset]ntSize, offset, L0, L1on Return:	c1	preserves S, PV, PC, L2, uTOS, uTOSH	smashes TOS, TOSH {but preserved in uTOS, uTOSH}rhTT, TT	virtual address of free value@(chain)	filled in binding pointerL1	binding type{fvStack, fvGlobal, fvUnbound} Dispatch pendingon Fault:	S &larr; S - 2, TOS &larr; uTOS, TOSH &larr; uTOSH}FVLookUp: {map header}	Map &larr; [rhTT, TT], L0 &larr; L0.xRedoFV,	c1;	TOS{name} &larr; RShift1 (Q{chain} - PV - 1), SE&larr;0,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;fvOff: {fvoffset from fn header}	MAR &larr; [rhRx, TT + 7{fnh.nlfv}], BRANCH[fvMap, $],	c1, at[L0.xRedoFV,10, RxMapFixCaller];	TT &larr; TT + TOS{name}, {PgCarryBr ok *} {BRANCH[$, FVLUfix1,  1],}CANCELBR[$, 2],	c2;FVLUret1:	TOS{fvoff} &larr; MD{fvoffset},	c3;{(L) correct by nlocals}{should be unnecessary}	uChain &larr; Q{chain},	c1;	TOSH{nlocs} &larr; TOS{fvoff} LRot8,	c2;	Q{fvoff} &larr; TOS{fvoff} - TOSH{nlocs},	c3;fvN: {name from fn header} {*ASSUMES name on same page}	MAR &larr; Rx &larr; [rhRx, TT + Q{fvoff}],	c1;	uPV &larr; PV{too late?%}, CANCELBR[$, 2],	c2;	TOSH{name} &larr; MD{name}, GOTO[newFrame],	c3;{************************************}newFrame: {PV &larr; PV.alink} {TOSH{name}, PV}	MAR &larr; PV &larr; [rhPV, PV - 9],	c1;fvA2:	Q &larr; ~1, BRANCH[$, fvACross, 1],	c2;	uName &larr; TOSH{name}, PV{alink} &larr; MD and Q, {XLDisp,}	c3;fvFF: {check flags for name table valid}	MAR &larr; PV &larr; [rhPV, PV - 0A{flags-pvar}],	c1;fvF2:	Q{PVflags} &larr; PV, ZeroBr, BRANCH[$, fvFCross, 1],	c2;	Rx &larr; MD{flags}, BRANCH[$, endStack],	c3;fvH: {header lo}	MAR &larr; PV &larr; [rhPV, PV + 2{deflo-flags}],	c1;fvH2:	Xbus &larr; Rx LRot8, XDisp, BRANCH[$, fvHCross, 1],	c2;fvH3:	TT &larr; MD{deflo}, BRANCH[fvH1, ntValid, 0D],	c3;ntValid:	MAR &larr; PV &larr; [rhPV, PV + 4{ntlo-deflo}],	c1;	Rx &larr; 0, BRANCH[fvH3, fvHCross, 1],	c2;{fvH1:} {header hi}fvH1:	MAR &larr; [rhPV, PV + 1],	c1;	PV &larr; Q{PVflags} + 0A{pvar-flags}, CANCELBR[$, 2],	c2;	rhTT &larr; MD{defhi},	c3;fvMH: {map header}	Map &larr; [rhTT, TT], L0 &larr; L0.xRedoFVN,	c1;	TOS{mask} &larr; ~3, L1 &larr; L1.fixFV{maybe smashed},	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;{fvN: ntSize}{#this click could be eliminated possibly by testing for zero (vs ntSize)}RedoFVN:	MAR &larr; Q &larr; [rhRx, TT + 6], BRANCH[fvMapN, $],	c1, at[L0.xRedoFVN,10, RxMapFixCaller];	Rx &larr; Q + 2, CANCELBR[$, 2],	c2;	TOS{cnt} &larr; TOS{mask} and MD{ntSize}, GOTO[lookFor],	c3;lookFor: {match?}	MAR &larr; Rx &larr; [rhRx, Rx + 0],	c1;	Q{ntSize-1} &larr; TOS{cnt} - 1, {*}rhTOSH &larr; nRhS, GOTO[matJoin],	c2;matLp:	MAR &larr; Rx &larr; [rhRx, Rx + 0],	c1, at[6, 10, Mat];	Ybus &larr; TOS{cnt} - 1, NegBr,	c2;matJoin:	TT &larr; TOSH{name} xor MD, BRANCH[$, newFrame],	c3;{fvM1:  match?}	MAR &larr; Rx &larr; [rhRx, Rx + 1], L0 &larr; 0,	c1;	TT &larr; TT, ZeroBr, CANCELBR[$, 2], 	c2;	TT &larr; TOSH{name} xor MD, BRANCH[$, Val0],	c3;fvM2: {match?}	MAR &larr; Rx &larr; [rhRx, Rx + 1], L0 &larr; 2, 	c1, at[0, 10, Mat];	TT &larr; TT, ZeroBr, CANCELBR[$, 2],	c2;	TT &larr; TOSH{name} xor MD, BRANCH[$, Val1],	c3;{fvM3: match?}	MAR &larr; Rx &larr; [rhRx, Rx + 1], L0 &larr; 4,	c1, at[2, 10, Mat];	TT &larr; TT, ZeroBr, CANCELBR[$, 2],	c2;	TT &larr; TOSH{name} xor MD, BRANCH[$, Val2],	c3;{fvM4: done?}	Rx &larr; Rx + 1,	c1, at[4, 10, Mat];	TT &larr; TT, ZeroBr, L0 &larr; 6,	c2;	TOS{cnt} &larr; TOS - 4, BRANCH[matLp, Val3],	c3;{value; fvfound}  {preserve Rx{realNames}, TOS{cnt}, TOSH{name}, Q{ntSize-1}}Val0:	MAR &larr; [rhRx, Rx + Q{ntSize-1}], GOTO[Vtail],	c1;Val1:	MAR &larr; [rhRx, Rx + Q], GOTO[Vtail],	c1;Val2:	MAR &larr; [rhRx, Rx + Q], GOTO[Vtail],	c1;Val3:	MAR &larr; [rhRx, Rx + Q], GOTO[Vtail],	c1;Vtail:	rhTT &larr; STACKspace, CANCELBR[$, 2],	c2;	TT{vtyOffset} &larr; MD, XHDisp, L1 &larr; L1.fvStack,	c3;{##% maybe save a click if offset is words not doublewords}	TOSH{offset} &larr; (TT and 0FF) LShift1, BRANCH[fvIVar, $, 2],	c1;	TOSH{ptrToVal} &larr; PV{pvar} + TOSH, rhTOSH &larr; nRhS,	c2;	Noop{TOSH{chain} &larr; uChain},	c3;fvFP: {FVar or PVar}	MAR &larr; [rhTOSH, TOSH{ptrToVal} + 0{TT}], {BRANCH[fvIVar, ${, 2}],}	c1;fvFP2:	Ybus &larr; TT + TT{varType}, NegBr,	c2;	TT &larr;  MD, XLDisp{undefinedF}, BRANCH[fvPvar, fvFvar],	c3;{***********************} {rhTT &larr; STACKspace}fvPvar:	Ybus &larr; TT, NegBr{undefP}, CANCELBR[$, 3],	c1;	TT &larr; TOSH{ptrToVal}, BRANCH[$, lookMore], L0Disp,	c2;	TOSH{chain} &larr; uChain, XLDisp, CANCELBR[donefv, 0F],	c3;{preserved Rx{realNames}, TOS{cnt}, Q{ntSize-1}}lookMore:	{TT#0} TOSH{name} &larr; uName, DISP4[Mat],{back}	c3;{***********************} {free to smash Rx and TOS below here}fvFvar:	MAR &larr; [rhTOSH, TOSH{ptrToVal} + 1], BRANCH[$, fvUnbF, 2],	c1;	TOSH{chain} &larr; uChain, CANCELBR[$, 2],	c2;	rhTT &larr; MD, 	c3;	Q &larr; STACKspace,	c1;	Ybus &larr; Q xor rhTT, ZeroBr,	c2;fvFcon:	Ybus &larr; TOSH{chain}, YDisp, BRANCH[$, donefvX],	c3;	CANCELBR[$, 0F],	c1;	L1 &larr; L1.fvGlobal,	c2;	Ybus &larr; TOSH{chain}, YDisp, GOTO[donefvX],	c3;fvUnbF:	Noop, CANCELBR[$, 2],	c2;	TOSH{name} &larr; uName, GOTO[newFrame],	c3;{***********************} fvIVar:	{rhTT &larr; uSTACKspace}	TOS{offset} &larr; (TT and 0FF) LShift1, CANCELBR[$, 2],	c2;	PV &larr; PV - 0B{ivar-pvar},	c3;	MAR &larr; [rhPV, PV + 0],	c1;	TOSH{chain} &larr; uChain,	c2;	TT &larr; MD{ivar}, Ybus &larr; TOSH{chain}, YDisp,	c3;	MAR &larr; [rhTOSH, TOSH{chain} + 0], BRANCH[fvRet2, $, 0E],	c1;	MDR &larr; TT &larr; TT + TOS{offset}, CANCELBR[donefv3, 2], WriteOK,	c2;fvRet2:	L3Disp, GOTO[fvRet3],	c2;{***********************}endStack:	TT &larr; uName, L1 &larr; L1.fvGlobal, GOTO[endStk2],	c1;endStk1:	TT &larr; uName, L1 &larr; L1.fvGlobal,	c1;endStk2:	TT &larr; TT + TT, rhTT &larr; VALspace,	c2;	TOSH{chain} &larr; uChain, XLDisp, GOTO[donefv]	c3;{***********************}{	TOSH{chain} &larr; uChain, YDisp, GOTO[donefv]	c3;}donefvX:	MAR &larr; [rhTOSH, TOSH{chain} - 1], BRANCH[donefvY, donefv2, 0E],	c1;donefv:	MAR &larr; [rhTOSH, TOSH{chain} - 1], BRANCH[donefvY, donefv2, 0E],	c1;donefvY:		L3Disp, CANCELBR[fvRet3, 2],	c2;donefv2:	MDR &larr; TT, CANCELBR[$, 2], WriteOK,	c2;donefv3:	Noop,	c3;fvRet: {donefvlookup}{double up bindptr high}	Q &larr; rhTT,	c1;	Rx &larr; Q,	c2;	Rx{rhTT LRot8} &larr; Rx LRot8,	c3;	MAR &larr; [rhTOSH, TOSH{chain} + 0],	c1;	MDR &larr; rhTT or Rx{rhTT LRot8}, L3Disp,	c2;fvRet3:	PV &larr; uPV, L1Disp, RET[fvCaller],{restore PV}	c3;{**********************  exceptions:  ***********************}{trial faster inner loop?}{	MAR &larr; [rhB, A], B &larr; Q, ZeroBr,	c1;}{	Ybus &larr; name xor Q, ZeroBr, BRANCH[$, done],	c2;}{	Q &larr; MD, BRANCH[$, match],	c3;}{exceptions:}fvMap:	uPV &larr; PV, CANCELBR[RLxMapFix, 3], L1 &larr; L1.fixFV,{return to RedoFV},	c2;fvMapN:	CANCELBR[RLxMapFix, 3], L1 &larr; L1.fixFV,{return to RedoFVN}	c2;fvFCross:	PV &larr; PV - 0FF -1, CANCELBR[$, 1],	c3;	MAR &larr; PV &larr; [rhPV, PV + 0], GOTO[fvF2],	c1;fvACross:	PV &larr; PV - 0FF -1,	c3;	MAR &larr; PV &larr; [rhPV, PV + 0], GOTO[fvA2],	c1;fvHCross:	PV &larr; PV + 0FF + 1, CANCELBR[$, 0F],	c3;	MAR &larr; PV &larr; [rhPV, PV + 0], GOTO[fvH2],	c1;fvFPCross:	PV &larr; PV + 0FF + 1, CANCELBR[$, 0F],	c3;	MAR &larr; PV &larr; [rhPV, PV + 0], GOTO[fvFP2],	c1;fvFix:	TOSH &larr; uTOSH, L3Disp,	c1, at[L1.fixFV,10,Fix];	TOS &larr; uTOS, DISP4[fvfixup],	c2;	PV &larr; uPV,{ GOTO[popFix],}	c3,at[L3.FVAR,10,fvfixup];	S &larr; S - 2, GOTO[NoMoreFix],	c1;	PV &larr; uPV, GOTO[NoFixes],	c3, at[L3.FVARg,10,fvfixup];{*******************************	FVAR&larr;	4 clicks ?%*******************************}FVARg:		opcode[143'b],	MAR &larr; Q &larr; [rhPV, PV + ibNA + 1], L3 &larr; L3.FVARg,	c1{, opcode[143'b]};{63}FVGcont:	Rx &larr; Q, rhRx &larr; nRhS, BRANCH[$, FVGCar,1],	c2;	uTOSH &larr; TOSH, TT &larr; rhTT &larr; MD{address high},	c3;{compliance: using uSTACKspace with duplicated high byte for bind ptr}	MAR &larr; [rhRx, Rx - 1],	c1;	Ybus &larr; TT xor uSTACKspace, NZeroBr, CANCELBR[$, 2],	c2; {% incompatable}	uTOS &larr; TOS, TT &larr; MD{address low},		XLDisp {dispatch if not looked up},		BRANCH[$, fvgStore1] {branch if not on stack},	c3;{TOS and TOSH saved in case freeVarLookup is invoked}fvgStore:	MAR &larr; [rhS, TT], S &larr; S + 0, DISP4[fvType, 2],	c1, at[L3.FVARg,10, fvCaller];fvgStore1:	MAR &larr; [rhS, TT], S &larr; S + 0, DISP4[fvType, 6],	c1;{var bound on stack}	MDR &larr; TOSH &larr; uTOSH,	c2, at[L1.fvStack{2}, 10, fvType];fvgStore3:	rhTT &larr; nRhS,	c3;	MAR &larr; [rhTT, TT + 1], Xbus &larr; ib, L2 &larr; L2.0,	c1;	MDR &larr; TOS &larr; uTOS, IBDisp, CANCELBR[$, 2], WriteOK,	c2;	PC &larr; PC + 1, L2 &larr; L2.0, DISPNI[OpTable],	c3;fvgUnbnd:	TT &larr; UvCL, CANCELBR[fvLook, 3],	c2, at[L1.fvUnbound{3}, 10, fvType];	TT &larr; UvCL, CANCELBR[fvLook, 3],	c2, at[{L1.fvUnbound1}7, 10, fvType];fvLook:	rhTT &larr; UvChighL, CALL[FVLookUp],	c3;fvgGlobal:TOS &larr; uTOS,	c2, at[L1.fvGlobal{6}, 10, fvType];	TOSH &larr; uTOSH,	c3;{real version:}	S&larr; S+1,	c1;	Q&larr; rhTT,	c2;	Rx&larr; AtomSETFVAR {376'b},  	c3;	MAR&larr; [rhS, S + 0],	c1;	MDR&larr; uTOSH, 	c2;	TOSH&larr; Q {address high}, IB&larr; Rx LRot0,	c3;	MAR&larr; S&larr; [rhS, S + 1], IBPtr&larr;0,	c1;	MDR&larr; uTOS, CANCELBR[$,2], WriteOK,	c2;	TOS&larr; TT {address low}, L3{ib's}&larr;1,	c3;	MAR &larr; Q &larr; [rhS, S + 1], GOTO[FVcall],	c1;FVGCar:	Rx &larr; Q + 0FF +1,	c3;	MAR &larr; Q &larr; [rhRx, Rx + 0], GOTO[FVGcont],	c1;{*******************************************************************	GETBITS.N.FD		? %  5 clicks*******************************************************************}GBITS:	TT &larr; TOS + ib, CarryBr, L1 &larr; L1.Dec3,	c1, opcode[312'b];{CA}	rhTT &larr; TOSH LRot0, BRANCH[$, GBrhnok],	c2;GBcont:	PC &larr; 1 + PC + PC16,	c3;	Map &larr; [rhTT,TT], L0 &larr; L0.xRedoGF,	c1;	Q{fd.pos} &larr; ibHigh{fd.pos}, L2 &larr; L2.0,	c2;	Rx &larr; rhRx &larr; MD, XRefBr,	c3;RedoGF:	MAR &larr; [rhRx, TT + 0], BRANCH[GFMap,$],	c1, at[L0.xRedoGF,10, RxMapFixCaller];	Rx &larr; Q{fd.pos} + ib{fd.size} + 1, rhRx &larr; ib{fd.size},	c2;	Rx &larr; MD{data}, Ybus &larr; Rx{shift}, YDisp, L2 &larr; L2.GFRet,	c3;	TT &larr; LRot1 Rx, DISP4[CycleMask],	c1;	{CycleMask Subroutine Here}GFRet:	TOS &larr; TOS and TT, IBDisp, L2 &larr; L2.0,	c2, at[L2.GFRet,10,MaskRet];	TOSH &larr; smallpl, L2 &larr; L2.0, DISPNI[OpTable],	c3;GBrhnok:	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c3;	rhTT &larr; Q LRot0,	c1;	GOTO[GBcont],	c2;GFMap:	Noop, CANCELBR[RLxMapFix, 3]{will return to RedoGF},	c2;{*******************************************************************	PUTBITS.N.FD (ptr, newval =&gt; ptr)		? %  7 clicks*******************************************************************}PUTBITS:	MAR &larr; [rhS, S + 0], L1 &larr; L1.fixWF,	c1, opcode[317'b];{CF}	Ybus &larr; TOSH xor smallpl, NZeroBr,	c2;	TT &larr; MD{ptr}, BRANCH[$, ufnWF],	c3;	MAR &larr; [rhS, S - 1], L0&larr; L0.RedoWF,	c1;	TT &larr; TT + ib, CarryBr, CANCELBR[$, 2],	c2;	rhTT &larr; MD{ptrH}, BRANCH[PBrhok, $],	c3;	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c1;	rhTT &larr; Q LRot0,	c2;	c3;PBrhok:	Map &larr; Q &larr; [rhTT, TT], L2 &larr; L2.WFRet{0},	c1;{% segCross}	TOSH{-pos-1} &larr; 0 - ibHigh - 1, YDisp, {L2&larr;0,}	c2;	Rx &larr; rhRx &larr; MD, XDirtyDisp, DISP4[MaskTbl], {L2Disp,}	c3;{MaskTbl:	TT &larr; mask, RET[MaskRet],	c1, at[0, 10, MaskTbl];}RedoWF2:	Ybus{pos+size} &larr; ib{size} - TOSH{-pos-1} - 1, YDisp, GOTO[joinWF],	c2, at[L2.WFRet, 10, MaskRet];RedoWF3:	Ybus{pos+size} &larr; ib{size} - TOSH{-pos-1} - 1, YDisp, GOTO[joinWF],	c2, at[L2.WFRetOdd, 10, MaskRet];joinWF:	TOSH &larr; smallpl, L2&larr;0, DISP4[Mask],	c3;Mask:	TT &larr; ~TT xor u7FFF, L2Disp, GOTO[Left0],{17b}	c*, at[0,10,Mask];	TT &larr; ~TT xor uTT3FFF, L2Disp, GOTO[Left12],{0}	c*, at[1,10,Mask];	TT &larr; ~TT xor u1FFF, L2Disp, GOTO[Left12],	c*, at[2,10,Mask];	TT &larr; ~TT xor u0FFF, L2Disp, GOTO[Left12],	c*, at[3,10,Mask];	TT &larr; ~TT xor u7FF, L2Disp, GOTO[Left12],	c*, at[4,10,Mask];	TT &larr; ~TT xor uTT3FF, L2Disp, GOTO[Left8],	c*, at[5,10,Mask];	TT &larr; ~TT xor u1FF, L2Disp, GOTO[Left8],	c*, at[6,10,Mask];	TT &larr; ~TT xor 0FF, L2Disp, GOTO[Left8],	c*, at[7,10,Mask];	TT &larr; ~TT xor 7F, L2Disp, GOTO[Left8],	c*, at[8,10,Mask];	TT &larr; ~TT xor 3F, L2Disp, GOTO[Left4],	c*, at[9,10,Mask];	TT &larr; ~TT xor 1F, L2Disp, GOTO[Left4],	c*, at[0A,10,Mask];	TT &larr; ~TT xor 0F, L2Disp, GOTO[Left4],	c*, at[0B,10,Mask];	TT &larr; ~TT xor 7, L2Disp, GOTO[Left4],	c*, at[0C,10,Mask];	TT &larr; ~TT xor 3, L2Disp, GOTO[Left0],	c*, at[0D,10,Mask];	TT &larr; ~TT xor 1, L2Disp, GOTO[Left0],	c*, at[0E,10,Mask];	TT &larr; ~TT xor 0, L2Disp, GOTO[Left0],{16b}	c*, at[0F,10,Mask];Left0:	TOS &larr; TOS LRot0, DISP4[FinCycle, 0C],	c2;Left4:	TOS &larr; TOS LRot4, DISP4[FinCycle, 0C],	c2;Left8:	TOS &larr; TOS LRot8, DISP4[FinCycle, 0C],	c2;Left12:	TOS &larr; TOS LRot12, DISP4[FinCycle, 0C],	c2;	TOS &larr; TOS RRot1, GOTO[wfDo],	c3, at[0C, 10, FinCycle];	TOS &larr; TOS + TOS LShift1, GOTO[wfDo],	c3, at[0D, 10, FinCycle];	TOS &larr; TOS LShift1, GOTO[wfDo],	c3, at[0E, 10, FinCycle];	TOS &larr; TOS, GOTO[wfDo],	c3, at[0F, 10, FinCycle];wfDo:	MAR &larr; [rhRx, Q + 0],	c1;	TOS &larr; TOS and ~TT{mask},	c2;	TT &larr; MD and TT{mask},	c3;	MAR &larr; [rhRx, Q + 0],	c1;	MDR &larr; TOS or TT,	c2;	PC &larr; PC + 1, GOTO[POP],	c3;WFMap:	uTT &larr; TT, TT &larr; Q, CALL[WLMapFix], {will return to RedoWF}	c2, at[L2.WFRetMap, 10, MaskRet];WFMapOdd:	uTT &larr; TT, TT &larr; Q, CALL[WLMapFix], {will return to RedoWF}	c2, at[L2.WFRetMapOdd, 10, MaskRet];RedoWF:	TT &larr; uTT, BRANCH[RedoWF2, RedoWF3],	c1, at[L0.RedoWF,10, WMapFixCaller];ufnWF:	Rx &larr; 317'b, GOTO[ufn2incS]	c1;FixWF:	TOSH &larr; smallpl, GOTO[NoMoreFix],	c1, at[L1.fixWF,10,Fix];{*******************************************************************	CycleMask		? %  1 clicks*******************************************************************}{Entry:	Rx = data to be rotated &amp; masked,	TT = pre-rotated version of Rx	a DISP4 pending which determines left rotation: (0 =&gt; no rotation)	rhRx = value to be dispatched on to determine mask (0=&gt;1, F=&gt;FFFF)Exit:	TT holds the mask,	TOS holds the rotated data,	Rx does not contain the original data,  rhRx is untouched}CycleMask:	Xbus &larr; rhRx, XDisp, GOTO[ShiftOK0],	c*, at[0,10,CycleMask];	Rx &larr; TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK0],	c*, at[1,10,CycleMask];	Rx &larr; LRot1 TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK0],	c*, at[2,10,CycleMask];	Rx &larr; RRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK4],	c*, at[3,10,CycleMask];	Xbus &larr; rhRx, XDisp, GOTO[ShiftOK4],	c*, at[4,10,CycleMask];	Rx &larr; LRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK4],	c*, at[5,10,CycleMask];	Rx &larr; LRot1 TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK4],	c*, at[6,10,CycleMask];	Rx &larr; RRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK8],	c*, at[7,10,CycleMask];	Xbus &larr; rhRx, XDisp, GOTO[ShiftOK8],	c*, at[8,10,CycleMask];	Rx &larr; LRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK8],	c*, at[9,10,CycleMask];	Rx &larr; LRot1 TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK8],	c*, at[0A,10,CycleMask];	Rx &larr; RRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK12],	c*, at[0B,10,CycleMask];	Xbus &larr; rhRx, XDisp, GOTO[ShiftOK12],	c*, at[0C,10,CycleMask];	Rx &larr; LRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK12],	c*, at[0D,10,CycleMask];	Rx &larr; LRot1 TT, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK12],	c*, at[0E,10,CycleMask];	Rx &larr; RRot1 Rx, Xbus &larr; rhRx, XDisp, GOTO[ShiftOK0],	c*, at[0F,10,CycleMask];ShiftOK0:	TOS &larr; Rx, L2Disp, DISP4[MaskTbl],	c*;ShiftOK4:	TOS &larr; Rx LRot4, L2Disp, DISP4[MaskTbl],	c*;ShiftOK8:	TOS &larr; Rx LRot8, L2Disp, DISP4[MaskTbl],	c*;ShiftOK12:	TOS &larr; Rx LRot12, L2Disp, DISP4[MaskTbl],	c*;{*********************************************	MaskTbl  SUBROUTINE	1 cycle*********************************************}{	first cycle = c* , one cycle longThis subroutine generates a right justified mask. of n onesRETURNS THRU MaskRet}MaskTbl:	TT &larr; 1, RET[MaskRet],	c*, at[0,10,MaskTbl];	TT &larr; 3, RET[MaskRet],	c*, at[1,10,MaskTbl];	TT &larr; 7, RET[MaskRet],	c*, at[2,10,MaskTbl];	TT &larr; 0F, RET[MaskRet],	c*, at[3,10,MaskTbl];	TT &larr; 1F, RET[MaskRet],	c*, at[4,10,MaskTbl];	TT &larr; 3F, RET[MaskRet],	c*, at[5,10,MaskTbl];	TT &larr; 7F, RET[MaskRet],	c*, at[6,10,MaskTbl];	TT &larr; 0FF, RET[MaskRet],	c*, at[7,10,MaskTbl];	TT &larr; LShift1 0FF, SE&larr;1, RET[MaskRet] {TT &larr; 1FF},	c*, at[8,10,MaskTbl];	TT &larr; RShift1 u7FF, RET[MaskRet] {TT &larr; 3FF},	c*, at[9,10,MaskTbl];	TT &larr; u7FF, RET[MaskRet] {TT &larr; 7FF},	c*, at[0A,10,MaskTbl];	TT &larr; RShift1 u1FFF, RET[MaskRet] {TT &larr; FFF},	c*, at[0B,10,MaskTbl];	TT &larr; u1FFF, RET[MaskRet] {TT &larr; 1FFF},	c*, at[0C,10,MaskTbl];	TT &larr; uTT3FFF, RET[MaskRet] {TT &larr; 3FFF},	c*, at[0D,10,MaskTbl];	TT &larr; RShift1 (~TT xor TT), RET[MaskRet] {TT &larr; 7FFF},	c*, at[0E,10,MaskTbl];	TT &larr; ~TT xor TT, RET[MaskRet] {TT &larr; FFFF},	c*, at[0F,10,MaskTbl];{*******************************************************************	BIND		%  ? clicks*******************************************************************}{(B) Bind}Bind:	uPCib &larr; PC, Rx{n1,n2} &larr; ib, ZeroBr, L2&larr;L2.0,	c1, opcode[21'b];	TT &larr; ibNA LShift1, BRANCH[$, prePush],	c2;	TT &larr; PV + TT + 1, rhTT &larr; nRhS,	c3;	MAR &larr; Q &larr; [rhTT, TT + 0], GOTO[Nloop1],	c1;{(N) bind var to Nil}	{Q odd,  TT odd}Nloop:	MAR &larr; [rhTT, TT + 0],	c1;Nloop1:	MDR &larr; PC{nil} &larr; 0, CANCELBR[$, 2], WriteOK,	c2;	Rx &larr; Rx - 0F - 1, CarryBr, {decr n1, &lt;0?}	c3;	MAR &larr; [rhTT, TT - 1], BRANCH[VarOdd{n1=-1}, $],	c1;	MDR &larr; PC{nil}, Rx &larr; Rx, ZeroBr{n2}, CANCELBR[$, 2], WriteOK,	c2;	TT &larr; TT - 2, BRANCH[Nloop, push],	c3;{(P) push stack if n2=0}push:	MAR &larr; S &larr; [rhS, S + 1],	c1;bindCont:	MDR &larr; TOSH, BRANCH[$, bindCar, 1],	c2;	Noop,	c3;	MAR &larr; S &larr; [rhS, S + 1],	c1;	MDR &larr; TOS, CANCELBR[$, 2], WriteOK,	c2;	PC &larr; uPCib, GOTO[endBind],	c3;{(V) bind var to Val{top of stack}}	{get to VarOdd n1=-1}VarOdd:	MDR &larr; TOSH, Rx{n2-1} &larr; Rx - 1, CANCELBR[VarOdd3, 2], WriteOK,	c2;Vloop:	MAR &larr; [rhTT, TT - 1],	c1;	MDR &larr; TOSH, CANCELBR[$, 2], WriteOK,	c2;VarOdd3:	PC &larr; uPCib,	c3;	MAR &larr; [rhTT, TT + 0],	c1;	MDR &larr; TOS, Rx &larr; Rx - 1, NibCarryBr{pos},	c2;	TT &larr; TT - 2, BRANCH[endBind{n2-1&lt;0}, $],	c3;{(P) pop stack}bdP:	MAR &larr; [rhS, S], S &larr; S - 1	c1;	Noop, CANCELBR[$, 2],	c2;	TOS &larr; MD,	c3;{(P) pop stack}	MAR &larr; [rhS, S + 0],	c1;	S &larr; S - 1,	c2;	TOSH &larr; MD, GOTO[Vloop],	c3;{(M) push binding mark}endBind:	TOS &larr; ib LShift1,	c1;	PC &larr; PC + 1 + PC16, IBDisp,	c2;	TOSH &larr; RRot1 (TT - Q - 1), L2&larr;L2.0, DISPNI[OpTable],	c3;{exceptions:}prePush:	Q &larr; TT, GOTO[push],	c3;bindCar:	S &larr; S + 0FF + 1,	c3;	MAR &larr; S &larr; [rhS, S + 0], GOTO[bindCont],	c1;{*******************************************************************	UNBIND, DUNBIND*******************************************************************}{n1:Nils   n2:Var   N:last pvar    mark[-(n1+n2)-1,, 2*N]}{check for n1n2=0  ??!!  also N&gt;127}{(M) check TOS for bind mark in sign bit}dunbind:			opcode[23'b],	Rx &larr; TOSH LRot0 xor ~TOSH, XHDisp, L3 &larr; 3,	c1;	TT{cnt} &larr; ~TOSH, ZeroBr, BRANCH[tosNot, tosMark, 2],	c2;tosNot:	CANCELBR[again],	c3;{(M) find bind mark by sign bit}unbind:	MAR &larr; [rhS, S - 1], L3 &larr; 2, GOTO[nomark],	c1, opcode[22'b];again:	MAR &larr; [rhS, S - 1], BRANCH[nomark, mark, 2],	c1;nomark:	S &larr; S - 2, CANCELBR[$, 2],	c2;	STK &larr; TOS, TT{cnt} &larr; ~MD, XHDisp, GOTO[again],	c3;mark:	TOS &larr; PV, rhTOS &larr; nRhS, CANCELBR[$, 2],	c2;	Rx{allOnes} &larr; Rx xor ~Rx, L2 &larr; L2.0,	c3;{(M) fetch other word of bind mark}	{S even full}	MAR &larr; [rhS, S + 2],	c1;	TT{cnt} &larr; TT, ZeroBr, BRANCH[$, dunCross, 1],	c2;dunCon:	Q{NN} &larr; MD, L3Disp, BRANCH[Uloop1, dunPop1],	c3;{(L) loop making vars unbound=-1}tosMark:	TOS{var} &larr;TOS + PV, rhTOS &larr; nRhS, CANCELBR[$],	c3;	c1;	Ybus &larr; TT, ZeroBr,	c2;	L3Disp, BRANCH[Uloop, dunPop],	c3;Uloop1:	MAR &larr;  TOS &larr; [rhTOS, TOS + Q{NN}], CANCELBR[Uloop2, 3],	c1;Uloop:	CANCELBR[$, 3],	MAR &larr; [rhTOS, TOS + 0],	c1;Uloop2:	MDR &larr; Rx{allOnes}, TT{cnt} &larr; TT - 1, ZeroBr, BRANCH[$, unbCros, 1],	c2;Uloop3:	TOS{var} &larr; TOS - 2, BRANCH[Uloop, $], L3Disp,	c3;{(P) pop stack if dunbind}	{S:odd full}dunPop:	MAR &larr; [rhS, S + 0], BRANCH[unbEnd, Pop2, 2],	c1;dunPop1:	MAR &larr; [rhS, S + 0], BRANCH[unbEnd, Pop2, 2],	c1;Pop2:	PC &larr; PC + PC16, CANCELBR[$, 2],	c2;	TOS &larr; MD,	c3;{(P) pop stack}	MAR &larr; [rhS, S - 1], L2&larr;L2.0, 	c1;	S &larr; S - 2, IBDisp, CANCELBR[$, 2],	c2;	TOSH &larr; MD, L2&larr;L2.0, DISPNI[OpTable],	c3;{(U) don't pop stack if unbind}unbEnd:	PC &larr; PC + PC16, IBDisp, CANCELBR[$, 2],	c2;	TOS &larr; STK, L2&larr;L2.0, DISPNI[OpTable],	c3;{Exceptions:}dunCross:	S &larr; S + 2, CANCELBR[$], 	c3;	MAR &larr; [rhS, S + 0],	c1;	S &larr; S - 2,	c2;	Q{NN} &larr; MD,	c3;	c1;	TT{cnt} &larr; TT, ZeroBr,	c2;	L3Disp, BRANCH[Uloop1, dunPop1],	c3;unbCros:	TOS &larr; TOS + 0FF + 1, CANCELBR[$, 1],	c3;	MAR &larr; [rhTOS, TOS + 0],	c1;	MDR &larr; Rx{allOnes}, TT{cnt} &larr; TT, ZeroBr, GOTO[Uloop3],	c2;	{ E N D }</pre>
  </body>
</html>
