<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>fugue.5>Sources>dlion>LispCons.mc!1</title>
  </head>
  <body>
    <pre>
{LispCons.mcCreated:  10-Aug-83 20:35:27 by donLast edit:  2-Sep-83 11:00:55 by don}	Set[L2.ConsNil,  8],SetTask[0];{*******************************************************************	CONS	*******************************************************************}{	CONS ( X , Y )  returns cons with X as car	  Y is initially on top of stack}{ConsNot:	Rx &larr; 32'b, GOTO[ufn2],	c1;}Cons:		opcode[32'b],	{optionally hooked up}{	TT &larr; uLispOptions,	c1;	TT &larr; TT and 4, ZeroBr,	c2;	BRANCH[$, ConsNot],	c3;}{	test if Y {top of stack} is NIL}	Ybus &larr; TOS or TOSH, ZeroBr, L2 &larr; L2.ConsNil,	c1;	Q &larr; ConsNxtPg, BRANCH[ConsList, ConsNil],	c2;ConsNil:	PC &larr; PC + PC16, CALL[ConsMapDTD]	c3;{	SUBROUTINE ConsMapDTD}ConsMapDTD:	rhTT &larr; DTDspace,	c1;	TT &larr; DTDbasePage,	c2;	TT &larr; TT LRot8,	c3;	Map &larr; [rhTT,TT], L0 &larr; L0.RedoCons1,	c1;	L1 &larr; L1.DecOnly, 	c2;	Rx &larr; rhRx &larr; MD, XDirtyDisp,	c3;{	fetch ListpDTD:NextPage/Counter}	MAR &larr; [rhRx, Q + 0], BRANCH[ConsMap1, $, 1],	c1,at[L0.RedoCons1,10,WMapFixCaller];	L2Disp,	c2;	TT{NextPage/Counter} &larr; MD, RET[ConsMapDTDRet],	c3;	Ybus &larr; TT{NextPage}, ZeroBr,	c1,at[L2.ConsNil,10,ConsMapDTDRet];	rhTT &larr; TT &larr; TT LRot8, BRANCH[$, ConsNxtPg0],	c2;	TT &larr; TT and ~0FF, CALL[ConsMakeCell],	c3;ConsMakeCell:	{	map it}	Map &larr; [rhTT,TT], L0 &larr; L0.RedoCons2,	c1;	uAddrNewCellLo &larr; TT, L1 &larr; L1.DecOnly, 	c2;{u &larr; hi part of Vaddr of cons cell}	Rx &larr; rhRx &larr; MD, XDirtyDisp,	c3;{	get first word from cons page	this is: [count,,next]}	MAR &larr; [rhRx, 0 + 0], BRANCH[ConsMap2, $, 1],	c1,at[L0.RedoCons2,10,WMapFixCaller];	Rx &larr; Rx and ~0FF,	c2;	TT{cnt,,next} &larr; MD,	c3;{	MakeConsCell}	Q{next} &larr; TT and 0FF,	c1;{lo part of Vaddr of cons cell}	Rx &larr; Rx or Q,	c2;{Raddr of cons cell}	TT &larr; TT LRot8,	c3;	TT{cnt} &larr; TT and 0FF,	c1;{TT now has cnt}	Q &larr; Q or uAddrNewCellLo,	c2;{merge hi and lo Vaddr of cons cell}	TT{cnt-1} &larr; TT - 1,	NegBr,	c3;{test if more space}	TT &larr; TT LRot8, BRANCH[$, ConsNoRoom1],	c1;	uNewCount &larr; TT,	c2;	uGcLov &larr; 0,	c3;{	get first word of cons cell}	MAR &larr; [rhRx, Rx + 0],	c1;	uAddrNewCellLo &larr; Q,	c2;	Q &larr; MD,	c3;	TT{newnext} &larr; Q and ~0FF,	c1;	TT &larr; TT LRot8,	c2;	Q &larr; uNewCount,	c3;{	rewrite first word of cons page with new [count,,nextcell]}	MAR &larr; [rhRx, 0 + 0],	c1;	MDR &larr; TT{Lo: newnext} or Q{Hi: cnt-1},	c2;	Q &larr; rhTT,	c3;{saves rh of Vaddr of cons cell}{	build new cons}{	get second word of X, put to TOS and conspage}	MAR &larr; [rhS, S + 0],	c1;	uConsTemp &larr; Q,	c2;	TOS{X.Lo} &larr; MD,	c3;	MAR &larr; [rhRx, Rx + 1],	c1;	MDR &larr; TOS, CANCELBR[$, 2], LOOPHOLE[wok],	c2;		c3;{	get first word of X}	MAR &larr; [rhS, S - 1],	c1;	TOSH &larr; 0FF, CANCELBR[$, 0], L2Disp,	c2;	TOSH{X.Hi} &larr; MD and TOSH, RET[ConsCMCRet],	c3;{	change cdrcode to nil (= 200B), put to TOSH and conspage}	TOSH &larr; LShift1 TOSH, SE &larr; 0,	c1,at[L2.ConsNil,10,ConsCMCRet];	TOSH &larr; RShift1 TOSH, SE &larr; 1,	c2;	Q &larr; Q.AddRef,	c3;	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TOSH,	c2;	{goto AddRef X, DelRef newconscell,increment ListpDTD:counter, fix stack and exit}{	there is one abnormal exit from this section	  if entries are added to the overflow table}	{setup for GcLookup:	  Rx &larr; addrHi &amp; 0FF	  TT &larr; addrLo	  uGcLov &larr; 0 {before first call only}	  L2 &larr; subr #	  Q &larr; 0 if addref, 1 if delref, 2 if stkref	  Trashes rhTT and rhRx	  }ConsCom:	{Q set to Q.AddRef previously}	TT &larr; TOS, L2 &larr; L2.ConsAdd,	c3;	Rx &larr; TOSH and 0FF, CALL[GcLookup],	c1;	{GcLookup Subroutine here}	{setup for GcLookup:	  Rx &larr; addrHi &amp; 0FF	  TT &larr; addrLo	  uGcLov &larr; 0 {before first call only}	  L2 &larr; subr #	  Q &larr; 0 if addref, 1 if delref, 2 if stkref	  Trashes rhTT and rhRx	  }	TT &larr; uAddrNewCellLo,	c2,at[L2.ConsAdd,10,GcLookRet];	TOS &larr; TT,	c3;	TOSH &larr; uConsTemp,	c1;	c2;	Rx &larr; uConsTemp, L2 &larr; L2.ConsDel,	c3;	Q &larr; Q.DelRef, CALL[GcLookup],	c1;	{GcLookup Subroutine here}	Q &larr; ConsCnt,	c2,at[L2.ConsDel,10,GcLookRet];	CALL[ConsMapDTD],	c3;{	increment ListpDTD:COUNTER}	MAR &larr; [rhRx, Q + 0],	c1,at[L2.ConsDel,10,ConsMapDTDRet];	MDR &larr; TT + 1,	c2;	,	c3;	S &larr; S - 2,	c1;	TT &larr; uGcLov{set by GcLookup},	c2;	Ybus &larr; TT, NZeroBr,	c3;	Rx &larr; AtomGCSCAN {371'b}, BRANCH[ConsNoOvXit, ConsOvXit],	c1;ConsNoOvXit:	L2 &larr; L2.0, IBDisp, GOTO[DNI.nop],	c2;ConsOvXit:	IB &larr; Rx LRot0, L3{ib's} &larr; 0,	c2;	PC &larr; PC - PC16, IBPtr &larr; 0,	c3;	MAR &larr; Q &larr; [rhS, S + 1], GOTO[FN1Ext],	c1;{	Cons List}{ConsNoList:	Rx &larr; 32'b, GOTO[ufn1],	c3;}ConsList:{	optionable}{	Q &larr; uLispOptions,	c3;	Ybus &larr; Q and 1, ZeroBr,	c1;	BRANCH[$, ConsNoList],	c2;}	uGcLov &larr; 0, L2 &larr; L2.ConsList,	c3;{	get real address of type table entry}	TT &larr; 32'b, CALL[NewTyp],	c1;{	pc bumped by one in subroutine}{	get type table entry}	MAR &larr; [rhRx, Rx + 0],	c1,at[L2.ConsList,10,NewTypRet];	Q &larr; 0FF,	c2;	Rx{entry} &larr; MD and Q{0FF},	c3;{	test if Y is of type list}	Ybus &larr; Rx xor ListType, ZeroBr,	c1;	BRANCH[ConsOther, $],	c2;	rhTT &larr; TOSH LRot0,	c3;	TT &larr; TOS and ~0FF,	c1;	uKeepTOS &larr; TOS,	c2;	uKeepTOSH &larr; TOSH, CALL[ConsMakeCell],	c3;	TT &larr; uKeepTOS,	c1,at[L2.ConsList,10,ConsCMCRet];	TT &larr; TT and 0FE,	c2;	TT &larr; TT LRot8,	c3;	TOSH &larr; LShift1 TOSH, SE &larr; 0,	c1;	TOSH &larr; TOSH or TT,	c2;	TOSH &larr; RShift1 TOSH, SE &larr; 1,	c3;	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TOSH,	c2;	{setup for GcLookup:	  Rx &larr; addrHi &amp; 0FF	  TT &larr; addrLo	  uGcLov &larr; 0 {before first call only}	  L2 &larr; subr #	  Q &larr; 0 if addref, 1 if delref, 2 if stkref	  Trashes rhTT and rhRx	  }	L2 &larr; L2.ConsListAdd,	c3;	TT &larr; uKeepTOS ,	c1;	Rx &larr; uKeepTOSH,	c2;	Rx &larr; Rx and 0FF,	c3;	Q &larr; Q.AddRef, CALL[GcLookup],	c1;	{GcLookup Subroutine here}	Q &larr; Q.AddRef, GOTO[ConsCom],	c2,at[L2.ConsListAdd,10,GcLookRet];ConsMap1:	CALL[WLMapFix],	c2;ConsMap2:	CALL[WLMapFix],	c2;ConsNoRoom1:	GOTO[ConsUfn3],	c2;ConsNxtPg0:	PC &larr; PC - PC16, GOTO[ConsUfn1],	c3;ConsOther:	{ufn for now}ConsUfn3:	PC &larr; PC - PC16,	c3;ConsUfn1:	Rx &larr; 32'b, GOTO[ufn2],	c1;	{ E N D }</pre>
  </body>
</html>
