<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>fugue.5>Sources>dlion>GcRef.mc!1</title>
  </head>
  <body>
    <pre>
{file: GcRef.mclast edit:     25-Aug-83 14:30:28 by cal, added non-lisp ptr check{virtual range}last edit:     5-Aug-83 15:33:49 by charnleyput into system: 28-Jun-83 11:12:18created:  2-Jun-83 14:36:05 by charnley}SetTask[0];{*******************************************************************	GCREF	*******************************************************************}{	alpha contains code: 0 addRef, 1 delRef, 2 stkRef	TOSH contains high address bits	TOS contains low address bits	replaces TOSH,,TOS with NIL except in the case that  the new value	has stk = 0, and refcnt = 0, in which case stack left alone}GcRef:	opcode[25'b],	TT &larr; RShift1 0, SE &larr; 1,	c1; {set sign bit of Q}	Q &larr; TT + ibNA, L1 &larr; L1.NoFixes,	c2;	Rx &larr; TOSH and 0FF, L2 &larr; L2.gcref,	c3;	TT &larr; TOS, CALL[GcLookup],	c1;{*******************************************************************	GCLOOKUP SUBROUTINE	*******************************************************************}{	Q contains code: 0 addRef, 1 delRef, 2 stkRef {sign bit = 1 if opcode}	Rx contains high address bits {will be put into uGcLhi}	  if Rx = 0, then treat as atom	TT has low address bits {will be put in uGcLlo}	uGcLov returns non-zero if overflow entry added {for non-opcode}	TT returns 0 in the case that  the new value	has stk = 0, and refcnt = 0	L2 contains caller}{	The address of a type table word is:	   PageTableBase + Top 15 address bits	The format of a type table word is:	   bit 0 -- Atom	   bit 1 -- Don't RefCnt, goto ufn	The address of a hash table entry is:	   HashTableBase + ( Low 16 address bits ) / 2	The format of a hash table entry is:	   bits	   0..5    -- Count {63 = max count, if count is one	                     entry is not in hash table}	   6       -- Stack Ref bit	   7..14   -- eight high address bits	   15      -- Collision bit, goto ufn}GcLookup:	uGcLlo &larr; TT,	c2;	TT &larr; TT and ~0FF,	c3;	uGcLhi &larr; Rx, ZeroBr,	c1;	rhRx &larr; crhHashTable, BRANCH[$, GcLHighZero],	c2;	rhTT &larr; crhTypeTable, TT &larr; TT or Rx,	c3;		Xbus &larr; Rx LRot12, XDisp,	c1;	TT &larr; TT LRot8, DISP4[GcLTest, 3],	c2;	TT &larr; RShift1 TT, SE &larr; 1,{or 80 with page},	c3, at[03, 10, GcLTest];	MAR &larr; [rhTT, TT + 0],	c1;{read Type table}	Rx &larr; uGcLlo,	c2;	TT{Probe} &larr; MD,	c3;	TT &larr; LShift1 TT, NegBr,{test sign bit}	c1;	Ybus &larr; TT, NegBr, BRANCH[$, GcLatom],	c2;{test 4000 bit}	Rx &larr; RShift1 Rx, SE &larr; 0, BRANCH[$, GcLpunt1],	c3;	MAR &larr; [rhRx, Rx + 0],	c1;{read hash table}	uGcLTem &larr; Rx,	c2;{save HT addr}	TT{Entry} &larr; MD,	c3;	Ybus &larr; TT and 1, NZeroBr,	c1;{test coll bit}	Ybus &larr; TT, ZeroBr, BRANCH[$, GcLcoll],	c2;{test empty}	Rx &larr; uGcLhi, BRANCH[$, GcLempty],	c3;	Rx &larr; LShift1 Rx, SE &larr; 0,	c1;	Rx &larr; RShift1 Rx xor TT, SE &larr; 0,	c2;	Rx &larr; Rx - 1, PgCarryBr,	c3;{compare hi addr}	Rx &larr; 4, BRANCH[$, GcLdifptr],	c1;{sub has PgCarry compl}	Rx &larr; Rx LRot8,	c2;{Rx &larr; 0400}	Ybus &larr; TT + Rx, CarryBr,	c3;{cnt = max?}GcLSel:	Ybus &larr; Q, YDisp, BRANCH[$, GcLcntovf],	c1;	Noop, DISP2[GcLdisp],	c2;	Rx &larr; RShift1 Rx, SE &larr; 0,{stkRef}	c3,at[2,4,GcLdisp];	Q &larr; TT or Rx,	c1;	Noop, GOTO[GcLpw],	c2;	Q &larr; TT + Rx, GOTO[GcLcom], {addRef}	c3,at[0,4,GcLdisp];	Q &larr; TT - Rx, GOTO[GcLcom], {delRef}	c3,at[1,4,GcLdisp];GcLcom:	TT &larr; Q and ~u1FF,	c1;{TT &larr; cnt,,stk}	Ybus &larr; TT xor Rx, ZeroBr,	c2;{TT = 1,,0 ?}GcLpw:	Rx &larr; uGcLTem, BRANCH[$, GcLc1s0],	c3;{get HT addr}	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TT &larr; Q,	c2;GcLfin:	TT &larr; TT and ~u1FF, L2Disp, GOTO[GcLend],	c3;	{EXCEPTIONS}GcLc1s0:	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TT &larr; 0, GOTO[GcLatom],	c2;{store 0}GcLatom:	TT &larr; TT xor ~TT{non-zero}, L2Disp, CANCELBR[GcLend],	c3;GcLHighZero:	TT &larr; TT xor ~TT{non-zero}, L2Disp, CANCELBR[GcLend],	c3;GcLcntovf:	Noop, CANCELBR[GcLatom, 3],	c2;GcLempty:	{build a new entry with a cnt of 1}	Rx &larr; 4,	c1;	Rx &larr; Rx LRot8,	c2;{leave Rx setup for GcLSel}	TT &larr; uGcLhi ,	c3;	TT &larr; LShift1 TT , SE &larr; 0,	c1;	TT &larr; TT or Rx ,	c2;	Noop, GOTO[GcLSel],	c3;{	Entry into overflow table here	}GcLpunt1:	Noop,	c1;GcLdifptr:	Noop,	c2;GcLcoll:	Rx &larr; Q, NegBr, CANCELBR[$],	c3;{test if opcode}	Rx &larr; Rx LRot8, BRANCH[$, GcLufn],	c1;	TT &larr; 0A0,	c2;	TT &larr; TT LRot8	c3;{build ov table addr}GcLfov:	MAR &larr; [rhTT, TT + 0],	c1;	Noop,	c2;	Q &larr; MD,	c3;	Ybus &larr; Q, ZeroBr,	c1;{is ov empty?}	uGcLov &larr; TT, BRANCH[GcLnext, $],	c2;{uGcLov # 0}	Q &larr; uGcLhi,	c3;	MAR &larr; [rhTT, TT + 0],	c1;	MDR &larr; Rx or Q,	c2;	Rx &larr; uGcLlo,	c3;	MAR &larr; [rhTT, TT + 1],	c1;	MDR &larr; Rx, LOOPHOLE[wok], CANCELBR[$, 0],	c2;GcLret:	L2Disp, GOTO[GcLend],	c3;GcLnext:	TT &larr; TT + 2, GOTO[GcLfov],	c3;GcLufn:	Rx &larr; 25'b, GOTO[ufn3], {only occurs if GcRef opcode}	c2;GcLend:	RET[GcLookRet],{** EXIT HERE **} 	c1;	Ybus &larr; TT, ZeroBr, Xbus &larr; ib,	c2,at[L2.gcref,10,GcLookRet];	PC &larr; PC + 1, BRANCH[$, GcRlvTOS],	c3;	TOS &larr; 0,	c1;	TOSH &larr; 0, IBDisp, L2 &larr; L2.0, GOTO[DNI.nop],	c2;GcRlvTOS:	Noop, GOTO[IB.nop],	c1;	Ybus &larr; Q, NegBr, GOTO[GcLOut],	c3, at[07, 10, GcLTest];	Ybus &larr; Q, NegBr, GOTO[GcLOut],	c3, at[0B, 10, GcLTest];	Ybus &larr; Q, NegBr, GOTO[GcLOut],	c3, at[0F, 10, GcLTest];GcLOut:	BRANCH[GcLnotop, GcLop],	c1;GcLop:	Rx &larr; 25'b, GOTO[ufn3],	c2;GcLnotop:	GOTO[GcLret],	c2;		{ E N D }</pre>
  </body>
</html>
