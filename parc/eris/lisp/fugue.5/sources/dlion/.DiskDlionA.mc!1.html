<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>fugue.5>Sources>dlion>DiskDlionA.mc!1</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 8pt serif">{File name: DiskDlionA.mc<br> Description: Dandelion Disk Controller microcode, Version 2.0<br> Author: D. Davies<br> Created: October 30, 1979<br> Last Edited: November 19, 1979  4:19 PM<br> Last Edited: November 19, 1979  4:19 PM<br> Last Edited: November 21, 1979  2:55 PM, "minimum code" version completed<br> Last Edited: January 9, 1980  8:09 PM, create "transfer run of pages command"<br> Last Edited: February 1, 1980  10:48 AM, complies with standard Dandelion register assignments in Dandelion.df<br> Last Edited: March 14, 1980  11:14 AM, renamed to SA4DiskDlion from DiskDlion so a new version of the<br></span><span class="tab" val="79"></span><span style="font: 8pt serif">microcode may be produced for the SA1000/SA4000 controller.<br> Last Edited: March 18, 1980  10:07 AM, update to Rev D CP board which cancels MDR&larr; following an automatic<br></span><span class="tab" val="79"></span><span style="font: 8pt serif">PgCrossBr.  Extra code now inserted to make sure last word in page is stored anyway.<br> Last Edited: April 11, 1980  1:50 PM, to comply with the new standards for the composite SA1000/SA4000 controller which<br></span><span class="tab" val="79"></span><span style="font: 8pt serif">has longer label fields (code overhead reduced).</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 8pt serif"> Last Edited: April 18, 1980  3:07 PM, take out features that depend on IgnorePgCr.<br> Last Edited: April 30, 1980  11:06 AM, perform combined test on Header Field.<br> Last Edited: May 16, 1980  4:19 PM, add extra delay before Read or Verify on SA1000 drive to account for extra delay<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">after writing a field on that drive.<br> Last Edited: May 22, 1980  3:27 PM, add extra two pattern words for SA1000 drive to account for extra delay added above.<br> Last Edited: June 11, 1980  7:13 PM add extra word to sync pattern for SA4000 drive to try to decrease intermitent errors.<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Decrease length of sync pattern on SA1000 by one word to make room for 10 word labels eventually.<br> Last Edited: June 18, 1980  8:19 PM, modify to work with SA4000HeadDLion.<br> Last Edited: June 25, 1980  12:48 PM, fix ancient Inr bug and delete absolute starting address.<br> Last Edited: June 27, 1980  2:29 PM, fix ancient bug in FinishIOCB.<br> Last Edited: June 30, 1980  4:40 PM, reduce code overhead in an attempt to allow 10 word labels.<br> Last Edited: June 30, 1980  10:29 PM, reduce code overhead further and ensure that read headers and labels are not incremented.<br> Last Edited: July 1, 1980  1:12 AM, show final Sector Count after a transfer command. <br> Last Edited: July 1, 1980  12:46 PM, detect memory error in midst of run of pages.<br> Last Edited: July 2, 1980  9:29 AM, complement KStatus for new HSIO board.<br> Last Edited: July 1, 1980  4:51 PM, split into DiskDlionA.mc and DiskDlionB.mc<br> Last Edited: July 1, 1980  9:47 PM, Fix bug in logic that doesn&rsquo;t change value read in label read.<br> Last Edited: August 2, 1980  3:07 PM, Use AltUaddr and trim down code.<br> Last Edited: September 19, 1980  2:24 PM, re-code Inr instruction and discard initialization of constants and page cross<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">detection.<br> Last Edited: October 8, 1980  4:53 PM, add CANCELBRs found by new burdock.<br> Last Edited: October 16, 1980  6:03 PM, take out MDR&larr; not preceeded by MAR&larr;.<br> Last Edited: November 4, 1980  11:09 AM, trap illegal instructions.<br> Last Edited: March 20, 1981  3:02 PM, Move "incrementDataPage" flag to UDataLen.<br> Last Edited: September 9, 1981  1:25 PM, Insert Kludge to work with old Rubicon Head (code looks for "IncrementDataPage"<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">flag in UDataPgNum.  If it&rsquo;s there it is moved to UDataLen and UDataPgNum is pre-decremented).<br> Last Edited: Jim Frandeen November 9, 1981  10:17 AM, Delete kludge for old head. delete bad inst addresses that could result from DISP4[Inr,8]<br> Last Edited: Amy Fasnacht August 3, 1982  1:02 PM, Modify references to IOPage<br>}<br><br>{-----------------------------------  Start of Code  ----------------------------------------}<br><br>{ </span><span style="font: bold 8pt serif">THIS CODE WILL NOT RUN PROPERLY UNLESS InitDLion HAS INITIALIZED REGISTERS U0C00, UMaxSectTst, UStatusMsk and USyncAddrMk!!</span><span style="font: 8pt serif">}<br><br>{Initially, the microcode is in the dormant state.  Upon awakening, it constructs the CSB address and looks there for a pointer to an IOCB}<br><br>GetCSB:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RHRAdr &larr; RAdr &larr; uIOPage, SetTask[4], StartAddress[GetCSB],</span><span class="tab" val="67"></span><span style="font: 8pt serif"> c1;<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Noop,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[0F,10];<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Noop,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3;<br><br>{Get IOCB physical address from CSB}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr + DiskCSBOffsetIOCB],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {fet IOCB Addr from<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">     CSB}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RHRAdr &larr; 0, CANCELBR[GetCSB2C3,2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {IOCB in 0th 64k<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">     block of virt mem}<br>GetCSB2C3:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr&larr;MD,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get Lo 16 bits of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">     IOCB address}<br><br>{Find the physical address of the IOCB from its virtual address}<br>NewIOCB: </span><span class="tab" val="67"></span><span style="font: 8pt serif">Map &larr; [RHRAdr, RAdr+0], ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start map ref, is this a nil IOCB?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RAdr, BRANCH[GoodIOCB, NilIOCB],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {save lo 8 bits of IOCB address, decide about<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      IOCB Addr}<br>GoodIOCB:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; MD, RHRAdr &larr; MD, GOTO[StartIOCB],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0,2,NilIOCB]; {get hi 10 bits of IOCB address}<br>NilIOCB:</span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; 0, GOTO[GetCSB],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[1,2,GoodIOCB]; {turn off hardware and wait<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      again.}<br><br>{ Re-assemble the IOCB&rsquo;s address in RAdr}<br>StartIOCB:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr&larr;MAR&larr;[RHRAdr, RCnt+0],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; <br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; U0C00,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {clear the memory error flags before the IOCB<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      starts with constant reg.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MCtl &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3;  {and do the actual clearing}<br><br>{Now in executing state, instruction fetch is first.  Since all instructions require at least one operand, It is fetched also before branching to each command routine}<br>GetCmd:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,DoInc];<br>GetCmdC2:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr+1, CANCELBR[GetCmdC3, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {set next IOCB addr}<br>GetCmdC3:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; MD,XHDisp,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {Decode command<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">     from bits 0 and 4, there are only four possible<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      actions that may be taken in the first C2 of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      a command}<br><br>FetArg:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr], RAdr &larr; RAdr+1,DISP2[SameC2s],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0F,10]; {Start fetch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">     of 1st operand and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">     jump to cmd routine}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif"><br>{to save code, the Increment memory, TestStatus, Jump, Set word, Memory to Memory move, Load Parameters, FinishIOCB and InitRegs commands are lumped together here.  All do nothing in their first C2 and RCnt &larr; MD in the following C3.}<br>SameC2s:</span><span class="tab" val="67"></span><span style="font: 8pt serif">[] &larr; RCnt, YDisp, CANCELBR[SameC3s, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[0,4,SameC2s]; {decide which command it is}<br>SameC3s:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; MD, USaveRAdr &larr; RAdr, DISP4[Inr, 8],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get first arg and continue with command}<br><br><br>{-------------------  Command Routines  -------------------------------------}<br><br><br>{</span><span style="font: italic 8pt serif">Increment memory location, skip if zero</span><span style="font: 8pt serif"><br>This routine is used both to count during loops and to increment label and header addresses.  The word following the command contains the physical address of the location to be incremented.  In the remainder of this click, the address is fetched.  In the next click, the location&rsquo;s contents are fetched.  The value is then incremented and tested for zero.  In the final click, the location is updated and the IOCB pointer incremented if the location&rsquo;s new value is zero.}<br>{fetch the location&rsquo;s contents}<br>Inr:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; MAR &larr; [RHRAdr, RCnt+0],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[8,10,Inr]; {get address of loc to be<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      incremented}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Noop,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2;<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; MD,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get value, MD too slow to Incr and test now}<br><br>{Increment, test and restore the value}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr+0],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start store cycle}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MDR &larr; RCnt +1, ZeroBr, </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {increment and Update location}<br>IncBr:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; USaveRAdr, BRANCH[GetCmd, DoInc],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {restore IOCB ptr and decide whether to get<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the next command or the one after it.}<br><br>{Now start fetch of new command two words beyond the present one, can&rsquo;t incremetn ptr on reading it from RSaveRAdr}<br>DoInc:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr+2], RAdr &larr; RAdr+2, GOTO[GetCmdC2],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,GetCmd];<br><br>{</span><span style="font: italic 8pt serif">Jump</span><span style="font: 8pt serif"><br>This instruction is used to unconditionally transfer control from one point in the IOCB to another.  The low 16 bits of the physical address follows the command word.  Note we can do RAdr &larr; RCnt  while MAR&larr; forces the upper half of the ALU to RAdr or 0 because the IOCB does not cross page boundries.  Hence, only the least significant 8 bits are useful.}<br>Jump:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; MAR &larr; [RHRAdr, RCnt], GOTO[GetCmdC2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0A,10,Inr];<br><br>{</span><span style="font: italic 8pt serif">Send Control Word</span><span style="font: 8pt serif"><br>This instruction is used generally to send particular commands to the drive, like HeadSelect or Step and also to control when the hardware send the service requests that enable the microcode.  The control word to be sent follows the command word.}<br>SndCtlWd:</span><span class="tab" val="67"></span><span style="font: 8pt serif">ClrKFlags, CANCELBR[$, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[1,4,SameC2s]; {reset the latched<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      flags first so a wakeup depending<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      on them will be valid. }<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; MD, GOTO[GetCmd],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {send control wd and get next cmd}<br><br></span><span style="font: italic 8pt serif">{Load Transfer parameters</span><span style="font: 8pt serif"><br>It is desirable to separate the loading of the Transfer Command&rsquo;s parameters from the start of the command itself.  This allows one to start the transfer immediately after sensing some condition on the disk (like index mark plus n sector pulses).  This command loads the transfer command&rsquo;s parameters from The location given in RCnt in the IOCB into U registers.  Note that the parameter list must begin on a 16 word boundry.  Only the fact that the parameters lie in U registers instead of main memory allows the transfer command to proceed quickly enough.  The command word is followed by the address of the start of the parameter list.<br>     To optimize the code for speed, dupicates of some quantities are held in U registers.  These are the addresses of the file page numbers in the Label template and the address of the Head/Sector word in the Header, the file page number and the Head/Sector number.<br>     It is also necessary to load 256 - the number of sectors/track into UMaxSectTst.  This is done to speed the check for end of track.}<br>LoadPar:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; MAR &larr; [RHRAdr, RCnt], GOTO[LoadRCLpC2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0D,10,Inr]; {start fet of sector<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      count, put the mem addr into RAdr.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      This will load trash into U reg88 (fZ(Noop)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      equals 8, U Reg 88 =ULabelLen) but<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      that&rsquo;s ok since it will be fixed up in this loop.}<br>{this is the start of a loop to store the parameters.  The mem addr register (RAdr) serves as the index into memory, the index into the U Registers and the loop index.  This is why the parameters must begin at word 0 mod 16 in the IOCB.  Note the NibCarryBr condition only detects the lower nibble of RAdr being zero, so all the 8x U regs are loaded here.  URegs 81-88 are loaded correctly and 89 - 80 are loaded incorrectly.  This is ok though because they will all be either loaded again below or in the transfer command.}<br>LoadRCLp:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr+1], RAdr &larr; RAdr+1, NibCarryBr, AltUaddr,</span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start fetch of  next parameter, address Ureg<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      for prev. parm.  Done with this loop?}<br>LoadRCLpC2: URCntBlk &larr; RCnt,  BRANCH[LoadRCLpC3, StartRALp,2],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {store previous parm, decide ifdone with this<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      loop.}<br>LoadRCLpC3: RCnt &larr; MD, GOTO[LoadRCLp],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[2,4,StartRALp]; {get next parm from list.,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      loop back to store it.}<br><br>{Now that all the 8x parameters have been loaded, load the 7x parameters, or those belonging in U registers numbered 78 to 70.  This is done by setting RAdr to x7 and starting to fetch again.  note register 77 (UHeadSectorAddr) is loaded with trash in the first pass through the loop.  This is ok, it is loaded correctly below anyway.}<br>StartRALp:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr-0A,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[3,4,LoadRCLpC3]; {RAdr&larr;xxx6, so first<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      parameter fetched is one in addr xxx7}<br><br>LoadRALp:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr+1], RAdr &larr; RAdr+1, NibCarryBr, AltUaddr,</span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {fet next parm, see if it<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      is the last one and address the U Reg needed to<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      store the previous parm.}<br>LoadRALpC2: URAdrBlk &larr; RCnt, BRANCH[LoadRALpC3, FinLd,2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {store previous parm, decide whether one<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      now being fetched is the last one}<br>LoadRALpC3: RCnt &larr; MD, GOTO[LoadRALp],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[2,4,FinLd]; {fet parm, not the last one}<br><br>FinLd:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; MD,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[3,4,LoadRALpC3]; {fetch last parameter}<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UFindSectMkCmd &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {store last parameter}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr-10,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {get address of SectorCount (beginning of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      parm list, RAdr always =beginning of list +10<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      because of end conditions).  USectorCntAddr<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      was trashed in loop that loaded RCnt U regs. <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       We will fix it below.}<br><br>{If the Header operation is a Read, it shouldn&rsquo;t be incremented.  This is signalled by having the saved HeadSector word be 8000.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; CReadMask,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get mask used to detect read operation}<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">[] &larr; RCnt and UHeaderCmd, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {is the header op a read?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">USectorCntAddr &larr; RAdr, BRANCH[SaveHeadSect, IsHeaderRead],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {fix up the address of the Sector Count.}<br><br>{The header operation is a Read, so don&rsquo;t increment it after reading it.  Flag this condition by seting UHeadSector to 8000.}<br>IsHeaderRead: RAdr &larr; RShift1 0, SE &larr; 1, GOTO[SetUHeadSect],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[1,2,SaveHeadSect]; {load 8000 into<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      RCnt}<br><br>{The Header operation is not read so find the address of the HeadSector word in the Header}<br>SaveHeadSect: RAdr &larr; UHeaderAddr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0,2,IsHeaderRead]; {get addr of beginning<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      of Header in IOCB}<br><br>{Load the Head/Sector word itself so it may be updated without reading the original for each update.  Save its address for later update}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; MAR &larr; [RHRAdr, RAdr+1],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start read of the HeadSector word, note<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      The IOCB is on a single page so RHRAdr and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the upper byte of RAdr are still valid.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UHeadSectorAddr &larr; RAdr, CANCELBR[LdHeadSectC3,2],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c2;  {save Head sector address}<br>LdHeadSectC3: RAdr &larr; MD,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {load the Head/Sector word into RAdr}<br><br>{Save the Head/Sector word, either the real one or 8000 =&gt; don&rsquo;t change the one in memory since it will be read.}<br>SetUHeadSect: UHeadSector &larr; RAdr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {save Head Sector word}<br><br>{Now decide if the Label operation is a read.  If so, save the address of the Page number in the label as 0.  this is a flag that the label is not be incremented.}<br>FixupDone:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; CReadMask,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {get mask used to detect read operations}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">[] &larr; RAdr and ULabelCmd, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {Is the Label operation a Read? (Zero=&gt;Yes)}<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; USectorCntAddr , BRANCH[SavePgNum, IsLabelRead],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {Decide whether Label operation is a read.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      Also put page address back into RAdr.}<br>IsLabelRead: ULabPgAddr &larr; 0, GOTO[FormHdNotOkMsk],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[1,2,SavePgNum]; {the label operation is a<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      Read, so don&rsquo;t increment the read value.}<br><br>SavePgNum:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; ULabelAddr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[0,2,IsLabelRead]; {RCnt &larr; addr of Label<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      Template in IOCB}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt + CLabPgOffset,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {RCnt&larr;addr of file pg num in IOCB}<br><br>{Save the address of the file page number and get the lo 16 bits of the file page number, it is also duplicated for speed}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">ULabPgAddr &larr; MAR &larr; [RHRAdr, RCnt],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {save addr of page num and get page num}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">CANCELBR[LoadPgC3,2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2;<br>LoadPgC3:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; MD,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get lo 16 bits of file page num}<br><br>{store a pre-incremented version of the file page number}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {pre-increment for easy storage when time<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      is critical later}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">ULabPgLo &larr; RCnt</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {save label}<br><br>{form and save a single mask used to test the Header field of each sector.  This mask combines the HeaderQuit and HeaderLoop masks.  Doing this means that a good header need only pass one test, not two.}<br>FormHdNotOkMsk: RCnt &larr; UHeaderQuitMsk,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get first Header mask}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt or UHeaderLoopMsk,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {combine with second mask}<br><br>{Can also here from the Init regs command.}<br>FinLdReg:</span><span class="tab" val="67"></span><span style="font: 8pt serif">UHeaderNotOkMsk &larr; RCnt, GOTO[IncBr],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {If status passes this mask, Header is ok,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      if not, either quit or loop}<br><br><br></span><span style="font: italic 8pt serif">{Transfer Run of Pages<br></span><span style="font: 8pt serif">This command is used to read, write or verify the Header, Label and Data fields of a run of sectors on the disk.   A run of sectors occupies consecutive sectors on consecutive tracks.  The same operation is done to each sector.  With the LoadTransfer Pararmeters command, the Device Head or diagnostic client has complete control over the operation to be performed on each field and the status bits to be tested.  This command has no arguments following it.  If an error condition is encountered during the transfer, control is returned immediately to the command following this one.  If this command completes successfully, the two words following this command are skipped.  Thus by putting a JUMP to an abort instruction immediately after this command, one may catch all error conditions.  Bits specifying the error will be left in UStatus.  The single exception to this rule is found when a Memory error is encountered.  In that case, the page number in the Label template is still incremented before control is returned and UStatus is left cleared.  The Memory fault will be detected again in the FinishIOCB command and the proper status posted.  The error is detected here so an IOCB may be aborted with some hope of knowing where to begin a retry.<br>     It is assumed that no run of pages may cross a cylinder boundry.  A run may cross a track boundry, causing the microcode to switch heads.  Hence the maximum number of pages read by this command is (#of heads) * 28 sectors/track when connected to an SA4000 drive.  It is (# of heads) * 16 sectors/track when connected to an SA1000 drive.<br>     Processing begins by loading the parameters for transferring a header and finding the first sector mark.  The Header field is then processed and the results tested using first the HeaderNotOKMsk.  If this test is passed, we proceed to the Label field.  If it fails, we test first against HeaderQuitMsk then the HeaderLoopMsk.  If any status bits indicated by the Header Quit mask are enabled, control returns to the IOCB "program".  If any status bits indicated by the HeaderLoop mask are set, the command decrements the FailCount.  If non-zero, control is passed back to the start of the command to look for another header.  If the FailCount is zero,  a Header meeting the requirements cannot be found on this track so the command is aborted.  Note one of hte bits tested when connected to an SA1000 drive should be the HeaderTag/SectorFound bit.  This is set by a bit in the address mark of  the Label and Data fields.  It acts an error bit when looking for Header fields.  If the status passed the HeaderNotOKMsk test, parameters are loaded for the label field and it is processed.  If it passes the test specified in ULabelQuitMsk, the process is repeated for the Data section, otherwise the command is aborted.  One difference between the Header and Label fields on the one hand and the Data field on the other is that the same two buffers are used to process the Header and Label fields of every page while each data page may require a new data buffer.  Addresses of the string of data buffers are found by incrementing and mapping a virtual address in UDataPgNum.  If the most significant bit of UDataLen is a zero, the same virtual data page is used for all sectors in the run.  Only if it was set is UDataPgNum incremented for each page.  If the status resulting from processing the Data field is meets the conditions specified in UDataQuitMsk, one sector has been processed and we usually increment the HeadSector number in the Header and the lo 16 bits of the file page number in the label.  If the Header was just read, is is not changed, the same is true of the Label.  First, the sector number in the low byte of the second Header template word is incremented.  If less than 28 (0-27) for the SA4000 drive or 16 (0-15) for the SA1000 drive, we decide whether to increment the Label.  If the sector number is greater than or equal to the number of sectors per track, the Head number is incremented in the Header Template and both command words where it appears (UFreezeCmd, UFindSectMkCmd).  No test is made to see if the maximum head number has been exceeded as it is assumed this will never happen.  The lower 16 bits of the page number is in the Label field template word 5.  The upper 8 bits of file page number and the flags are not touched by this code.  This means runs of pages may not cross page 0 to page 1 boundries of a file (the flags change) or 64k page boundries.  After this, the sector count is decremented.  If it becomes zero, we finish.  Otherwise, control passes to NewSector.}<br>TransferRun:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr-1, CANCELBR[$, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[2,4,SameC2s]; {no args for this cmd}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">USaveRAdr &larr; RAdr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {so save RAdr pointing to next IOCB wd}<br><br>NewSector:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; CHeaderField,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,DoneQuit]; {set partial status to say}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UField &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; { starting the Header Field}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; UHeaderLen,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {load the word count for the Header field}<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UWdCount &larr; RAdr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {pass it to TransferField}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RHRAdr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {get hi bits of IOCB addr}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RHRCnt &larr; RAdr LRot0,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {set up for TransferField}<br><br>{return here when looking for another header}<br>NewHeader:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UHeaderAddr, ClrKFlags,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,NotFound];  {start hardware looking<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      for another header, clear SectorFounf flag}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; UHeaderCmd, pCall4,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {get control wd for Header field}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">KCtl &larr; UFindSectMkCmd, CALL[TransferField],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[0,10]; {start transferring as soon as the<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      sector mark is found.}<br><br>HeaderRet:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UHeaderNotOkMsk,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,10,HeaderRet]; {get incorrect Header<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       status mask}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt and ~KStatus, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {any reason not to proceed with Label?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UStatus &larr; RCnt , BRANCH[HeaderWrong, DoLabel],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {stop if so, else process Label Field}<br><br>HeaderWrong: RCnt &larr; UHeaderQuitMsk,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,DoLabel]; {get abort after Header<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       status mask}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt and ~KStatus, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {should we quit now?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">BRANCH[HeaderQuit, TstSeenAll],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {quit if so, test FailCount if not since that was<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">       not a fatal error.}<br><br>HeaderQuit:</span><span class="tab" val="67"></span><span style="font: 8pt serif">GOTO[FinXferRun],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,TstSeenAll]; {set up error br and quit}<br><br>{When we reach here, the field just read was a fine field, but not the header we wanted.  Test FailCount to see if we have exhausted the number of sectors on this track.  If so, quit.  If not, try the next one.}<br>TstSeenAll:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UFailCount,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,HeaderQuit]; {get # sectors left before}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt-1, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {out of sectors now?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UFailCount &larr; RCnt, BRANCH[NewHeader, NotFound],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {quit if so, look at next if not}<br><br>{At this point, we have run out of sectors to inspect, so load the final error flags and quit}<br>NotFound:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UStatus, GOTO[FinXferRun],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,NewHeader];<br><br>{Here, the header was processed successfully, we proceed with the Label field.  This is done by loading its parameters, setting the partial status to know the field being processed and calling TransferField}<br>DoLabel:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; ULabelLen,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,HeaderWrong]; {get word count}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UWdCount &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {set up for TransferField}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; CLabelField,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {get field number in case we die here}<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UField &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {save it for FinishIOCB}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; ULabelCmd, pCall4,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {get control word for label field}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; ULabelAddr, CALL[TransferField],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[1,10]; {go transfer the label field. }<br><br>{Return here after processing the label field}<br>LabelRet:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; ULabelQuitMsk,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,10,HeaderRet]; {get quit status mask}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt and ~KStatus, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {anything wrong with this label?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RRot1 ~1, BRANCH[LabelQuit, DoData],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {quit if so, else proceed.  Load mask used to <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      separate "incrementDataPgNum" flag from<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      length of data field.  The status is<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      not updated at this point because it must be<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the same as the Header status if good and will<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      be set if bad.  The data length is loaded now<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      so setup for the data field will fit into 3 clicks}<br><br>{At this point, we know there was something wrong with the processing of the label field, so we quit here}<br>LabelQuit:</span><span class="tab" val="67"></span><span style="font: 8pt serif">GOTO[FinXferRun],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,DoData];<br><br>{The Header and label were ok, set up to do the Data field.  In addition to setting the partial status and passing the word count and control word, we must map the virtual address before passing it.  We also conditionally increment the virtual address.  It is incremented if a new page is to be used for each sector transferred, left unchanged if the same virtual page is always to be used.  The flag used to decide is in the most significant bit of the data field word count.  It was placed there by the Head.}<br>DoData:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr and UDataLen, XHDisp,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,LabelQuit]; {get the word count, incr<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the virtual page number?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UDataPgNum, BRANCH[NoIncrDatPtr, IncrDatPtr,2],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {get the virtual page number, decide whether<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      to increment it after use.}<br>NoIncrDatPtr: RHRCnt &larr; 1, GOTO[MapDataAddr],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[2,4,IncrDatPtr]; {just point to Map in mem}<br>IncrDatPtr:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RHRCnt &larr; 1, RCnt &larr; RCnt+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[3,4,NoIncrDatPtr]; {also increment virt page<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      number before use}<br><br>MapDataAddr: MAR &larr; UDataPgNum &larr; [RHRCnt, RCnt], </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {Start Mapping to get physical data page<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      address.  Store incremented (or not) data page<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      number.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; CDataField, CANCELBR[GetPhysDatAddr, 2],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {Get constant used to say we are<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      now processing the data field.}<br>GetPhysDatAddr: UField &larr; RCnt, RHRCnt &larr; RCnt &larr; MD,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {update the state of the microcode<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      w.r.t. this page and get the physical page #<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      of this data page}<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; MAR &larr; [RHRCnt, 0+0],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {get address of the first word in the data page.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif"> UWdCount &larr; RAdr, pCall4,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2;  {finally store the word count}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; UDataCmd, CALL[TransferField],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[2,10]; {go transfer the data (finally!)}<br><br>{Return here after processing the data field.  Test to see if there was a fatal error in processing it}<br>DataRet:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UDataQuitMsk,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[2,10,HeaderRet]; {get msk specifying fatal<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      errors in the data field}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt and ~KStatus, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {any fatal errors?}<br>{arrive here after testing the data status above (obviously) and after setting the memory error bit after a memory error}<br>DataAndMemErrBr: RAdr &larr; ULabPgAddr, ZeroBr, BRANCH[DataQuit, NextSector], c3; {quit if so, else load addr of Page number and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      see if done with Run. If addr =0, we did a label<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      read, so don&rsquo;t increment the read value.}<br><br>{there was an fatal error in processing the Data field, so quit now}<br>DataQuit:</span><span class="tab" val="67"></span><span style="font: 8pt serif">CANCELBR[FinXferRun],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,NextSector]; {set up error br and quit}<br><br>{At least one sector has been successfully transferred and more may follow.  If necessary, the pointer to the next virtual memory page was incremented when it was used above.  Increment the page number found in word 4 of the label.  Only the low 16 bits of this page label will be incremented.  The Head guarantees never to specify a run of pages that crosses a page-0-to-page-1 boundry or a 64K page boundry.  Thus the most significant word of the label will be taken care of in the Head, not here.}<br>NextSector:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr], RAdr &larr; UHeadSectorAddr+0, SuppressTimingWarning, BRANCH[StoLabel, NoStoLabel],<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      c1, at[1,2,DataQuit]; {start store of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      l.s. 16 bits of page #, can never get<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      pageCarry here. Decide if L.S. 16 bits to be<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      stored at all.  Note that a bogus mem operation<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      will be done here is the pg addr was set to zero.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      Can this cause a Memory error?}<br>StoLabel:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MDR &larr; RCnt &larr; ULabPgLo, GOTO[IncLabel],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[0,2,NoStoLabel];  {update page num in<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      Label template}<br>NoStoLabel:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; UHeadSectorAddr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[1,2,StoLabel]; {don&rsquo;t update the number in<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the label that as read.  Do fixup address of Head-<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      Sector Word in RAdr.  The RAdr&larr; in the MAR&larr;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      above onlyloads the bottom half and the top half<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      will havebeen zeroed bythe test value.  This load<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      loads all 16 bits of physical address properly.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      RCnt is lift with trash, but its value is never used<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      so that&rsquo;s ok.}<br>IncLabel:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt+1, Xbus &larr; MStatus, XDisp,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[2,4]; {pre-increment for next store, got a<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      memory error on last page transferred? Must<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      check now so the Head can restore the proper<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      file page num, sector count, etc and retry without<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      remembering the initial parameters for each<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      transfer in each IOCB.</span><span style="font: bold 8pt serif">  This instruction is at<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: bold 8pt serif">      [2,4] in case the Timing for the U+0 doesn&rsquo;t<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: bold 8pt serif">      work.</span><span style="font: 8pt serif">}<br><br>{save the low 16 bits of the page number and fetch the Head/Sector word so it can be updated}<br>SaveLoLabl:</span><span class="tab" val="67"></span><span style="font: 8pt serif">ULabPgLo &larr; RCnt, RCnt &larr; 0, DISP4[NoMemErr,7],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {save l.s. 16 bits of page num, decide about<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      memory error. }<br>MemErr:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; CMemError, GOTO[DataAndMemErrBr],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[0F,10,NoMemErr]; {set mem error status and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      kill time until we can quit}<br>NoMemErr:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UHeadSector, NegBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2, at[7,10,MemErr]; {get the old Head/Sector<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      word, Is the "no increment" flag on?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt+1, BRANCH[IncSect, NoIncSect],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {increment the sector number and decide<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      whether to store it or not.}<br><br>{update the new Head/Sector word in the Header Template}<br>IncSect:</span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr], RAdr &larr; UMaxSectTst+0, SuppressTimingWarning, c1; {start store of Head/Sector wordand<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      increment the sector number}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MDR &larr; UHeadSector &larr; RCnt, RAdr &larr; RAdr+RCnt+1, PgCarryBr, GOTO[UpDtHdSctC3],  c2; {update new Head/<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      Sector word, assume its ok and check to<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      see if the last sector was just stored.  Note<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the "+1" exists so the U register may be<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      written.  Because of it, the number in<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      UMaxSectTst is one less than the desired<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      value.}<br>NoIncSect:</span><span class="tab" val="67"></span><span style="font: 8pt serif">Noop,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,IncSect]; {leave the Head/Sector<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      number just read unchanged.}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">Noop,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {Note we may only read Headers in runs of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      one page, soalways take the SectorTest<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      branch below.}<br>UpDtHdSctC3: RAdr &larr; UHeadSectorAddr, BRANCH[SectorTest, NewHead],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c3, at[2,4]; {prepare to update Head # in Header if<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      necessary and and decide whether that was<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      the last sector in the track.</span><span style="font: bold 8pt serif">  This instruction is<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: bold 8pt serif">      at  [2,4] in case the Timing for the U+0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: bold 8pt serif">     doesn&rsquo;t work.</span><span style="font: 8pt serif">}<br><br>{The run of pages has just crossed a track boundry, so the Head number must be incremented everywhere it exists.  The most obvious place is in the Header word just stored.  We create the proper HeadSector word by setting the Sector number to zero and incrementing the Head number, then store the correct head and sector numbers.  Then we go through both  commands that contains a Head number.  The Freeze command is done first, so the disk has the longest time to change heads.  After this command is changed, is sent to the hardware.}<br>NewHead:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt and ~0FF,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,SectorTest]; {set sector number to 0}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt  + 0FF + 1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {increment the head number}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UHeadSector &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {update the U reg version of the word also}<br><br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MAR &larr; [RHRAdr, RAdr+0],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start update of head# in Template}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">MDR &larr; RCnt, RAdr &larr; CHeadIncr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {store new head#, sector 0.  load byte-<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      swapped version of field used to incr head #<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      in the commands}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RAdr &larr; RAdr LRot8,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {set up const to increment head # in control<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      words}<br><br>{increment the head number in both control words}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UFreezeCmd,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {start with the Freeze command}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt+RAdr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {incr head #, Can&rsquo;t send command here<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      because of timing problems}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UFreezeCmd &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {save new version of Freeze control word}<br><br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; UFindSectMkCmd,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1; {update control wd for header field}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt+RAdr, KCtl &larr; UFreezeCmd,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {incr Head # and sent new command so<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      disk can switch heads}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">UFindSectMkCmd &larr; RCnt,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {save new Header field control wd}<br><br>{One sector has been successfully processed.  Was that the last sector?  Decrement the sector count and find out.}<br>SectorTest:</span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; USectorCount,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[0,2,NewHead]; {get old # remaining sects}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">RCnt &larr; RCnt-1, ZeroBr,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {get new # sectors left, are we done?}<br></span><span class="tab" val="67"></span><span style="font: 8pt serif">USectorCount &larr; RCnt, BRANCH[NewSector, DoneQuit],</span><span class="tab" val="67"></span><span style="font: 8pt serif">c3; {update count, quit if all done}<br><br>{This is the exit taken if all pages were transferred sucessfully.}<br>DoneQuit:</span><span class="tab" val="67"></span><span style="font: 8pt serif">Noop,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c1, at[1,2,NewSector]; {set up no error br and quit}<br><br>{finish up the run of pages command.  Coming into the statement, each statement did a test of the error status.  The command will skip the next two bytes if it complleted error free, otherwise it continues directly on.}<br>FinXferRun:</span><span class="tab" val="67"></span><span style="font: 8pt serif">UStatus &larr; RCnt, ZeroBr, GOTO[IncBr],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">c2; {goto restore IOCB ptr and get next command<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">      or the one after that}<br><br>{---------------------------  End of main body of Transfer Run of Pages Command -------------------------}<br></span><span style="font: 10pt serif"><br></span><span style="font: 8pt serif">{ Rest of Code in DiskDlionB.mc }</span><span style="font: 10pt serif"><br><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
