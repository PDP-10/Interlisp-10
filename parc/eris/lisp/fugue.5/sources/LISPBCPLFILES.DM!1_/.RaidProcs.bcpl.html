<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>fugue.5>Sources>LISPBCPLFILES.DM!1>RaidProcs.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">// RaidProcs.bcpl. Supplementary procedures for RAID<br>// Flushed TeleRaid July 20, 1983  2:49 PM by Bill van Melle<br>// Last modified March 30, 1983  11:31 AM by Bill van Melle<br>// Last modified December 16, 1982  10:15 PM by Bill van Melle<br>// Last modified July 21, 1982  9:32 PM by Bill van Melle<br>// Last modified September 19, 1981  2:01 PM by Bill van Melle<br>// Last modified August 4, 1981  12:47 PM by Beau Sheil<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "AltoDefs.d"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Raid.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Stats.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Vmem.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Streams.d"<br><br>external [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures defined here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ReadNum; ReadAtom; AtomNum; ShowRealCore<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DisplayVMinBitMap; DisplayVMbit; DoYankDef <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMDisplay<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>external [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CRLF; Ws; Wo; Wc; Bytes2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StealFromBcplDisplay; AddToBcplDisplay; DumpBlockToStats<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RaidReset; RAIDCode; ReadStrng; PrintAddrs; Confirm<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@BGetBase; @BGetBasePtr; @XPutBase; @BGetBase32; @BPutBase32<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@XSetReadBR; @RRead; @RWrite<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BP; ReadFlags; VirtualPage; EmAddr; MkSmallPos; IGetBase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">InitStats; CloseStats; IndexedPageIO; LookupPage; EqNIL<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// OS procs used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Zero; ShowDisplayStream; CreateDiskStream<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EmulatorSpace; LastRealPageNo; @lvVPtr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dsp; @DisplayAddrHi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">statsFP; statsFile; LispFmap<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>static  [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMDisplay = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>manifest [ LastSegment = 63</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// 22-bit address space<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IMSize = #20000; DummyHeight = 32<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMbitMapOffset = 2+2*lDCB</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// bitmap within VMDisplay<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMDisplayWidth = 16; VMDisplayHeight = LastSegment+1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMDisplayScanLines = DummyHeight + VMDisplayHeight<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VMDisplaySize = VMbitMapOffset + VMDisplayWidth*VMDisplayHeight<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>structure String: [ length byte; char&uarr;1,255 byte ]<br><br>let AtomNum(S) = valof<br>// Finds atom number for BCPL string. pn char format is that of bcpl strings<br> [ <br>   let LEN = S&gt;&gt;String.length<br>   let NW = LEN rshift 1<br><br>// Compute the hash code for the name. Mimic the behavior of LISP<br>   let SS = 0<br>   for i = 1 to LEN do<br>     [ let h1 = ((SS & #7777) lshift 2) + SS<br>       SS = (h1 lshift 8) + h1 + S&gt;&gt;String.char&uarr;i<br>     ]<br><br>   [<br>   let H = ((SS&#77777) rem (AHTSIZE lshift 8)) + AHTbase<br><br>// H is the virtual address in the AtomHashTable <br>   let P = BGetBase(AHTspace, H)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// P is address of hash table entry <br>   if P eq 0 then RaidReset("No such atom")<br><br>// since P was non zero, it is the virtual address of an atom+1<br>   P = P-1<br><br>// fetch atom and check its pname. Check its characters (word-by-word)<br>// with those in pname. Count is first byte, and pad byte (if any) is 0.<br>   XSetReadBR(BGetBasePtr(PNPspace, PNPbase+(P lshift 1)))<br>   for i = 0 to NW do if RRead(i) ne S!i goto reprobe<br><br>   resultis P</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// pnames are the same; return virtual address<br><br>reprobe: SS = SS+HashInc<br>   ] repeat</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// comparison failed so reprobe<br> ]<br><br>and ReadAtom() = valof</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// obtains atom number from typein<br>  [ let s = vec 50<br>    unless ReadStrng(s) do RaidReset(" XXX")<br>    let num=0<br>    for i=1 to s&gt;&gt;String.length do<br>        [ let c = (s&gt;&gt;String.char&uarr;i)-$0<br>          test (c ge 0) & (c le 7)<br>            ifso  num=num*8+c<br>            ifnot resultis AtomNum(s)<br>        ]<br>    resultis num<br>  ]<br><br>and ReadNum(radix) = valof</span><span class="tab" val="67"></span><span style="font: 10pt serif">// read number in given radix<br>  [<br>   let s = vec 50<br>   unless ReadStrng(s) do RaidReset(" XXX")<br>   let num=0<br>   for i=1 to s&gt;&gt;String.length do<br>        [ let c = (s&gt;&gt;String.char&uarr;i)-$0<br>          test (c ge 0) & (c ls radix)<br>            ifso  num=num*radix+c<br>            ifnot RaidReset(" XXX")<br>        ]<br>   resultis num<br>  ]<br><br>and ShowRealCore() be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Displays a segment page usage map<br> [<br>   CRLF()<br>   Ws (" State of virtual memory file: ")<br>   Ws (IGetBase(IFPKey) eq IFPValidKey? "C", "Inc")<br>   Ws ("onsistent")<br>   CRLF(); CRLF()<br>   let base = vec LastSegment+2; Zero(base, LastSegment+3)<br>   let ndirty, nlocked = 0, 0<br>   let bp = BP(0)<br>   for i = 2 to BptSize do<br>     [</span><span class="tab" val="67"></span><span style="font: 10pt serif">bp = bp+3</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// next one.  Skips the dummy header<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if bp&gt;&gt;BPT.LOCK<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then nlocked = nlocked+1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let vp = bp&gt;&gt;BPT.VP<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let bucket = vp&lt;&lt;VP.segment<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if (bucket le LastSegment) & ((ReadFlags(vp) & DIRTYbit) ne 0)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then ndirty = ndirty+1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">base!bucket = base!bucket + 1<br>     ]<br>   base!EmulatorSpace = PagesPerSegment</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Emulator done specially<br>   Ws(" Segment   Pages Contents*N")<br>   let total = 0<br>   for i = 0 to LastSegment do unless base!i eq 0<br>       do [ Ws("  "); Wo(i); Ws("  "); Wo(base!i)<br>            // The following is not a SELECT as the choices are not exclusive<br>            if i ge MDSLo & i le MDSHi then Ws(" Main data space")<br>            if i eq PNPspace then Ws(" PName pointers")<br>            if i eq DEFspace then Ws(" Definitions")<br>            if i eq TOPVALspace then Ws(" TopVals")<br>            if i eq PLISTspace then Ws(" Property lists")<br>            if i eq AHTspace then Ws(" Atom Hash Table")<br>            if i eq PMTspace then Ws(" Primary Page Map (PMT)")<br>            if i eq PAGEMAPspace then Ws(" Secondary Page Map")<br>            if i eq INTERFACEspace then Ws(" Interface page")<br>            if i eq MDSTYPEspace then Ws(" MDS type table")<br>            if i eq STATSspace then Ws(" Statistics")<br>            if i eq STACKspace then Ws(" Stack")<br>            if i eq EmulatorSpace then Ws(" Alto emulator")<br>            if i eq DisplayAddrHi & DisplayAddrHi ne 0<br>               then Ws(" Lisp display bitmap")<br>            if i ge PncLo & i le PncHi then Ws(" PName characters")<br>            if i ge ArrayLo & i le ArrayHi then Ws(" Arrays and strings")<br>            if i eq GCMainspace then Ws(" GC main table")<br>            if i eq GCCollspace then Ws(" GC collision table")<br>            CRLF()<br>            total = total + base!i ]<br>   Ws("   Total  "); Wo(total); Ws(" pages in use"); CRLF() <br>   let sp = "          "<br>   Ws(sp); Wo(base!(LastSegment+1)); Ws(" Empty"); CRLF()<br>   Ws(sp); Wo(LastRealPageNo-base!(LastSegment+2))<br>     Ws(" Total available pages"); CRLF()<br>   Ws(sp); Wo(nlocked); Ws(" pages locked"); CRLF()<br>   Ws(sp); Wo(ndirty); Ws(" pages dirty"); CRLF()<br>  ]<br><br>and DisplayVMinBitMap() be<br>  [<br>   if VMDisplay then<br>    [ VMDisplay = 0<br>      AddToBcplDisplay(VMDisplay, VMDisplaySize, VMDisplayScanLines)<br>      return<br>    ]<br><br>   VMDisplay = StealFromBcplDisplay(VMDisplaySize, VMDisplayScanLines)<br><br>   let VMDisplayDCB = VMDisplay + 2<br>// insert a null dcb DummyHeight/2 scan lines high first<br>   VMDisplay&gt;&gt;DS.fdcb = VMDisplayDCB<br>   VMDisplayDCB&gt;&gt;DCB.next = VMDisplayDCB + lDCB<br>   VMDisplayDCB&gt;&gt;DCB.width = 0<br>   VMDisplayDCB&gt;&gt;DCB.bitmap = 0<br>   VMDisplayDCB&gt;&gt;DCB.height = DummyHeight/2<br><br>   VMDisplayDCB = VMDisplayDCB + lDCB<br>   VMDisplay&gt;&gt;DS.ldcb = VMDisplayDCB<br>   VMDisplayDCB&gt;&gt;DCB.next = 0<br>   VMDisplayDCB&gt;&gt;DCB.height = VMDisplayHeight/2<br>   VMDisplayDCB&gt;&gt;DCB.indentation = 1<br>   VMDisplayDCB&gt;&gt;DCB.width = VMDisplayWidth<br>   VMDisplayDCB&gt;&gt;DCB.bitmap = VMDisplay + VMbitMapOffset<br><br>   // Turn on bits for pages already in core. Emulator done specially.<br>   for i=0 to PagesPerSegment-1 do DisplayVMbit(Bytes2(EmulatorSpace,i), true)<br>   for i=0 to LastRealPageNo-1-PagesPerSegment do<br>     [ let vp = VirtualPage(i)<br>       unless vp&lt;&lt;VP.segment gr LastSegment do DisplayVMbit(vp, true)<br>     ]<br>   ShowDisplayStream(VMDisplay, DSabove, dsp)<br>  ]<br><br>and DisplayVMbit(vp, turnOnBit) be<br>  [<br>    // segement selects row; hi order 4 bits address word; lo order 4 get bit<br>    let bitInWord = #100000 rshift (vp&lt;&lt;VP.page & #17)<br>    let Addr = VMDisplay + VMbitMapOffset + (vp&lt;&lt;VP.segment*VMDisplayWidth) +<br>               vp&lt;&lt;VP.page rshift 4<br>    @Addr = turnOnBit ? @Addr % bitInWord, @Addr & not bitInWord<br>  ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and DoYankDef() be<br>  [<br>  Ws(" from atom ")<br>  let a = ReadAtom()<br>  BGetBase32(DEFspace, DEFbase+(a lshift 1))<br>  test EqNIL(lvVPtr)<br>    ifso Ws ("[no definition")<br>    ifnot [ Wc($[); PrintAddrs(DEFspace,DEFbase+(a lshift 1), 2) ]<br>  Ws("] and smash it into definition cell of atom ")<br>  let b = ReadAtom()<br>  Ws("[was ")<br>  PrintAddrs(DEFspace,DEFbase+(b lshift 1), 2)<br>  Wc($])<br>  if Confirm()<br>    then [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// since lvVPtr has been smashed by now...<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BGetBase32(DEFspace, DEFbase+(a lshift 1))<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BPutBase32(DEFspace,DEFbase+(b lshift 1), lvVPtr)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>  ]<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
