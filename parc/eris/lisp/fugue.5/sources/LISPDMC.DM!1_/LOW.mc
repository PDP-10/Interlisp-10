:Title[LOW.dmc, February 23, 1983  5:28 PM, Masinter];   TOP LEVEL;   knowrbase[LTEMP0];   InsSet[LispInsSet, 1];*--------------------------------------------------------------------opLLSH1:	* Replace TOS with it shifted left one*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX1];   LTEMP1_ (LTEMP1) + (LTEMP1);   LTEMP0_ T + T, XorSavedCarry, branch[.BOX];regOP1[340, StackM2BR, opLLSH1, noNData];*--------------------------------------------------------------------opLRSH1:	* Replace TOS with it shifted right one*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX1];   LTEMP1_ (LTEMP1) rsh 1;   LTEMP0_ (LTEMP0) rsh 1, branch[.+2, R even];	LTEMP1_ (LTEMP1) or (100000c);   pd_ LTEMP0, branch[.BOX];regOP1[342, StackM2BR, opLRSH1, noNData];*--------------------------------------------------------------------opLRSH8:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX1];   LTEMP1_ RSH[LTEMP1, 10];   T_ LSH[LTEMP0, 10];   LTEMP1_ (LTEMP1) + T;   LTEMP0_ RSH[LTEMP0, 10], branch[.BOX];regOP1[343, StackM2BR, opLRSH8, noNData];*--------------------------------------------------------------------opLLSH8:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX1];   LTEMP0_ LSH[T, 10];   T_ RSH[LTEMP1, 10];   LTEMP1_ LSH[LTEMP1, 10];   LTEMP0_ (LTEMP0) + T, branch[.BOX];regOP1[341, StackM2BR, opLLSH8, noNData];*--------------------------------------------------------------------opLOGAND2:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1_ (LTEMP1) and Q;   LTEMP0_ (LTEMP0) and T, branch[.BOX2];regOP1[345, StackM2BR, opLOGAND2, noNData];*--------------------------------------------------------------------opLOGOR2:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1_ (LTEMP1) or Q;   LTEMP0_ (LTEMP0) or T, branch[.BOX2];regOP1[344, StackM2BR, opLOGOR2, noNData];*--------------------------------------------------------------------opLOGXOR2:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1_ (LTEMP1) xor Q;   LTEMP0_ (LTEMP0) xor T, branch[.BOX2];regOP1[346, StackM2BR, opLOGXOR2, noNData];*--------------------------------------------------------------------opIDIFFERENCE:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1_ (Q) - (LTEMP1);   LTEMP0_ (T) - (LTEMP0) - 1, XorSavedCarry, branch[.BOX2];regOP1[331, StackM2BR, opIDIFFERENCE, noNData];	* IDIFFERENCE:if[Reduced];	UfnOps[325];:else;regOP1[325, StackM2BR, opIDIFFERENCE, noNData];	* DIFFERENCE:endif;*--------------------------------------------------------------------opIPLUS2:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1_ (LTEMP1) + Q;   LTEMP0_ (LTEMP0) + T, XorSavedCarry, branch[.BOX2];regOP1[330, StackM2BR, opIPLUS2, noNData];	* IPLUS:if[Reduced];   UfnOps[324];:else;regOP1[324, StackM2BR, opIPLUS2, noNData];	* PLUS:endif;:if[Reduced];   UfnOps[366];:else;*--------------------------------------------------------------------opBOXIPLUS:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1_ (LTEMP1) + Q;   LTEMP0_ (LTEMP0) + T, XorSavedCarry, branch[.STOREBOX2];regOP1[366, StackM2BR, opBOXIPLUS, noNData];:endif;:if[Reduced];   UfnOps[367];:else;*--------------------------------------------------------------------opBOXIDIFFERENCE:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1_ (Q) - (LTEMP1);   LTEMP0_ (T) - (LTEMP0) - 1, XorSavedCarry, branch[.STOREBOX2];regOP1[367, StackM2BR, opBOXIDIFFERENCE, noNData];:endif;*--------------------------------------------------------------------* TIMES*--------------------------------------------------------------------:if[Reduced];	UfnOps[332];	UfnOps[326];:else;opITIMES2:   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   pd_ T or (LTEMP0);   branch[.+2, alu=0], T_ LTEMP1;	TSP_ (TSP) + (4c), branch[.unboxfail];	* can't handle 32 bit   call[MulSub];			* unsigned multiply T * Q -> (T, Q)   LTEMP1_ Q;   LTEMP0_ T, branch[.BOX2];regOP1[332, StackM2BR, opITIMES2, noNData];	* ITIMESregOP1[326, StackM2BR, opITIMES2, noNData];	* TIMES:endif;*--------------------------------------------------------------------* QUOTIENT*--------------------------------------------------------------------:if[Reduced];	UfnOps[333];	UfnOps[327];:else;opIQUOTIENT:   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   pd_ T or (LTEMP0);   branch[.+2, alu=0];			* (could handle big positives)	TSP_ (TSP) + (4c), branch[.unboxfail];		* failure return   DivTEMP1_ LTEMP1, SCall[DivSub];	* unsigned divide T,,Q by DivTEMP1   TSP_ (store_ TSP) + 1, dbuf_ SmallHi, branch[.+2];	TSP_ (TSP) + (4c), branch[.unboxfail];		* failure return   TSP_ (store_ TSP) + 1, dbuf_ Q, NextOpCode;regOP1[333, StackM2BR, opIQUOTIENT, noNData];	* IQUOTIENTregOP1[327, StackM2BR, opIQUOTIENT, noNData];	* QUOTIENT:endif;*--------------------------------------------------------------------* REMAINDER*--------------------------------------------------------------------:if[Reduced];	UfnOps[334];:else;opIREMAINDER:   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   pd_ T or (LTEMP0);   branch[.+2, alu=0];	TSP_ (TSP) + (4c), branch[.unboxfail];		* failure return   DivTEMP1_ LTEMP1, SCall[DivSub];	* unsigned divide T,,Q by DivTEMP1   TSP_ (store_ TSP) + 1, dbuf_ SmallHi, branch[.+2];	TSP_ (TSP) + (4c), branch[.unboxfail];		* failure return   TSP_ (store_ TSP) + 1, dbuf_ T, NextOpCode;	* T = remainderregOP1[334, StackM2BR, opIREMAINDER, noNData];:endif;*--------------------------------------------------------------------opIGREATERP:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];   pd_ T - (LTEMP0);   branch[.ig2, alu=0], pd_ (Q) - (LTEMP1) - 1;* hi parts differ   T_ T xor (100000c);   LTEMP0_ (LTEMP0) xor (100000c);	* complement sign   pd_ T - (LTEMP0) - 1;.ig2:   branch[.+2, carry], TSP_ (store_ TSP) + 1, dbuf_ 0c;   TSP_ (store_ TSP) + 1, dbuf_ AT.NIL, NextOpCode;	* push NIL   TSP_ (store_ TSP) + 1, dbuf_ AT.T, NextOpCode;	* push TregOP1[361, StackM2BR, opIGREATERP, noNData];	* IGREATERP:if[Reduced]; UfnOps[363];:else;regOP1[363, StackM2BR, opIGREATERP, noNData];	* GREATERP:endif;*--------------------------------------------------------------------opSWAP:*--------------------------------------------------------------------   T_ (TSP) - 1;   T_ (fetch_ T) - 1;   LTEMP1_ Md, T_ (fetch_ T) - 1;   LTEMP0_ Md, T_ (fetch_ T) - 1;   LTEMP2_ Md, fetch_ T;   LTEMP0_ Md, T_ (store_ T) + 1, dbuf_ LTEMP0;   T_ (store_ T) + 1, dbuf_ LTEMP1;   T_ (store_ T) + 1, dbuf_ LTEMP0;   store_ T, dbuf_ LTEMP2, NextOpcode;regOP1[375, StackBR, opSWAP, noNData];*--------------------------------------------------------------------opEQ:*--------------------------------------------------------------------   T_ (fetch_ TSP) - 1, flipMemBase;   LTEMP0_ Md, T_ (fetch_ T) - (3c);   LTEMP1_ Md, T_ (fetch_ T) + 1;   T_ Md, TSP_ (fetch_ T) - 1;   T_ Md, pd_ T xor (LTEMP0);   branch[.+2, alu=0], pd_ (T) xor (LTEMP1);	LEFT_ (LEFT) + 1, branch[.neq];   branch[.neq, alu#0], LEFT_ (LEFT) + 1;   TSP_ (store_ TSP) + 1, dbuf_ 0c;   TSP_ (store_ TSP) + 1, dbuf_ AT.T, NextOpCode;.neq:   TSP_ (store_ TSP) + 1, dbuf_ 0c;   TSP_ (store_ TSP) + 1, dbuf_ 0c, NextOpCode;regOP1[360, StackM2BR, opEQ, noNData];*--------------------------------------------------------------------opNOP:*--------------------------------------------------------------------   NextOpcode;regOP1[376, ifuBR, opNOP, noNData];*--------------------------------------------------------------------opBLT: * (destinationaddr sourceaddr nwords)*--------------------------------------------------------------------* Move nwords from source to destination.  If nwords < tbd,* then operation is uninterruptable, else must be prepared to* service interrupts.  On page fault or interrupt, update* stack according to how much is moved, and back up pc.* Result is unspecified.  Behavior if source and destination* overlap is unspecified	T_ (fetch_ TSP) + 1;	LTEMP0_ Md, T_ (fetch_ T) - (2c);	pd_ (LTEMP0) xor (SmallHi);	branch[.+2, alu=0], LTEMP2_ Md, T_ (fetch_ T) - 1;		CallUFN;	LTEMP1_ Md, T_ (fetch_ T) - 1;	LTEMP0_ Md, T_ (fetch_ T) - 1;	LTEMP3_ Md, fetch_ T, pd _ T_ (LTEMP2);	branch[.+2, alu#0], LTEMP2_ Md, memBase_ BBDSTBR, T_ T - 1;		branch[.bltdone];	* no words to copy	Cnt_ T;  			* number of words to transfer - 1	BRHi_ LTEMP2;	BRLo_ LTEMP3;	memBase_ BBSRCBR;	BRHi_ LTEMP0;	BRLo_ LTEMP1;* and now for the loop. This should really keep state in Stack a la BITBLT:	PAGEFAULTOK;	FETCH_ T, flipMemBase;	T_ (store_ T) - 1, dbuf_ MD, flipMembase, branch[.-1, Cnt#0&-1];	PAGEFAULTNOTOK;.bltdone:	Left_ (Left) + (2c);	TSP_ (TSP) - (4c), NextOpCode;regOP1[304, StackM2BR, opBLT, noNData];*--------------------------------------------------------------------opGETBASEN:*--------------------------------------------------------------------   T_ (fetch_ TSP) + 1;   T_ Md, fetch_ T;   LTEMP0_ Md, memBase_ ScratchLZBR;   BrHi_ T;	PAGEFAULTOK;   IFETCH_ LTEMP0;   memBase_ StackM2BR;   T_ MD, TSP_ (store_ TSP) + 1, dbuf_ SmallHi;	PAGEFAULTNOTOK;   TSP_ (store_ TSP) - 1, dbuf_ T, NextOpCode;regOP2[310, StackM2BR, opGETBASEN, noNData];*--------------------------------------------------------------------opGETBASEPTRN: *--------------------------------------------------------------------   T_ (fetch_ TSP) + 1;   T_ Md, fetch_ T, LTEMP1_ (rhmask);   LTEMP0_ Md, memBase_ ScratchLZBR;   BrHi_ T;	PAGEFAULTOK;   LTEMP0_ (IFETCH_ LTEMP0) + 1;   T_ MD, ifetch_ LTEMP0;	PAGEFAULTNOTOK;   T_ T and (LTEMP1), memBase_ StackM2BR;   T_ Md, TSP_ (store_ TSP) + 1, dbuf_ T;   TSP_ (store_ TSP) - 1, dbuf_ T, NextOpCode;regOP2[311, StackM2BR, opGETBASEPTRN, noNData];*--------------------------------------------------------------------opGETBASE32N: *--------------------------------------------------------------------   T_ (fetch_ TSP) + 1;   T_ Md, fetch_ T;   LTEMP0_ Md, memBase_ ScratchLZBR;   BrHi_ T;	PAGEFAULTOK;   LTEMP0_ (IFETCH_ LTEMP0) + 1;   T_ MD, ifetch_ LTEMP0;	PAGEFAULTNOTOK;   memBase_ StackM2BR;   T_ Md, TSP_ (store_ TSP) + 1, dbuf_ T;   TSP_ (store_ TSP) - 1, dbuf_ T, NextOpCode;regOP2[313, StackM2BR, opGETBASE32N, noNData];*--------------------------------------------------------------------opGETBITS: *--------------------------------------------------------------------   T_ (fetch_ TSP) + 1;   T_ Md, fetch_ T;   LTEMP0_ Md, memBase_ ScratchLZBR;   BrHi_ T;	PAGEFAULTOK;   IFETCH_ LTEMP0, TisID;   memBase_ StackM2BR;   LTEMP0_ MD, RF_ Id;	PAGEFAULTNOTOK;   T_ ShiftLMask[LTEMP0], memBase_ StackM2BR;   TSP_ (store_ TSP) + 1, dbuf_ SmallHi;   TSP_ (store_ TSP) - 1, dbuf_ T, NextOpCode;regOP3[312, StackM2BR, opGETBITS, noNData];*--------------------------------------------------------------------opGETBASEBYTE:*--------------------------------------------------------------------   T_ (TSP) - 1;   T_ (fetch_ T) - 1;   LTEMP0_ Md, T_ (fetch_ T) - 1;	* LTEMP0_ offset   LTEMP1_ Md, T_ (fetch_ T) - 1;   LTEMP1_ Md, pd_ (LTEMP1) xor (SmallHi);   branch[.+2, alu=0],   fetch_ T;	CallUFN;   memBase_ LScratchBR;   LTEMP1_ Md, BrLo_ LTEMP1;   BrHi_ LTEMP1, call[DOGETBYTE];   memBase_ StackBR, LEFT_ (LEFT) + 1;   T_ (store_ T) + 1, dbuf_ SmallHi;   TSP_ (store_ T) + 1, dbuf_ LTEMP0, NextOpCode;regOP1[302, StackBR, opGETBASEBYTE, noNData];SUBROUTINE;*--------------------------------------------------------------------* DOGETBYTE:	* called by BIN, GETBASEBYTE*--------------------------------------------------------------------*	assumes current memBase is pointer, LTEMP0 is byte offset*	returns byte in LTEMP0DOGETBYTE:   dblbranch[.gbev, .gbod, R even], LTEMP0_ (LTEMP0) rsh 1;.gbev:	PAGEFAULTOK;   FETCH_ LTEMP0;   LTEMP0_ MD;	PAGEFAULTNOTOK;   LTEMP0_ RSH [LTEMP0, 10], return;.gbod:	PAGEFAULTOK;   FETCH_ LTEMP0;   LTEMP0_ MD;	PAGEFAULTNOTOK;   LTEMP0_ (LTEMP0) AND (rhmask), return;TOP LEVEL;*--------------------------------------------------------------------opRCLK:*--------------------------------------------------------------------   T_ (fetch_ TSP) + 1;   LTEMP0_ Md, fetch_ T, T_ (30c);   LTEMP1_ Md, memBase_ MDS;   T_ T + (400c);   taskingOff;   fetch_ T;			* fetch word 430 for hi part of clock   LTEMP2_ Md, rbase_ rbase[RTClock];   T_ RTClock;   taskingOn;	* turn on tasking again;   rbase_ rbase[LTEMP0];   memBase_ ScratchLZBR;   BrHi_ LTEMP0;      	PAGEFAULTOK;   LTEMP1_ (store_ LTEMP1) + 1, dbuf_ Md;   	PAGEFAULTNOTOK;   store_ LTEMP1, dbuf_ T, nextOpCode;regOP1[167, StackM2BR, opRCLK, noNData];*--------------------------------------------------------------------* scan GC tables*--------------------------------------------------------------------:if[Reduced];	UfnOps[173];	UfnOps[174];:else;opGCSCAN1:   T_ (TSP) - 1;   fetch_ T, LTEMP0_ (-2c), branch[.gcscan];opGCSCAN2:   T_ (TSP) - 1;   fetch_ T, LTEMP0_ (HTSTKBIT), branch[.gcscan];.gcscan:   LTEMP1_ Md, memBase_ htMainBR;   LTEMP1_ (LTEMP1) - 1, Q_ LTEMP1;.gcscanlp:   branch[.gcscanfail, R<0], LTEMP1;   LTEMP1_ (fetch_ LTEMP1) - 1, Q_ LTEMP1;   LTEMP2_ Md, T_ LTEMP0;   branch[.+2, R even], pd_ (LTEMP2) and T;	memBase_ StackBR, TSP_ (TSP) - 1, branch[.gcfoundret];   branch[.gcscanlp, alu=0], pd_ T;   dblbranch[.gcfound1, .gcfound2, alu<0], pd_ (LTEMP2) and (HTSTKCNT);.gcfound1:   branch[.gcfoundret, alu=0], memBase_ StackBR, TSP_ (TSP) - 1;   memBase_ htMainBR, TSP_ (TSP) + 1, branch[.gcscanlp];.gcfound2:   LTEMP2_ (LTEMP2) and not T, memBase_htMainBR;	* turn off stkbit   T_ (LTEMP2) and (HTSTKCNT);   T_ T - (HT1CNT);   branch[.+2, alu#0];	store_ Q, dbuf_ T, branch[.gcscanlp];		* ref cnt went to 1	store_ Q, dbuf_ LTEMP2, branch[.gcscanlp];	* restore word.gcfoundret:   TSP_ (store_ TSP) + 1, dbuf_ Q, NextOpCode;.gcscanfail:   memBase_ StackBR, T_ (TSP) - 1;   T_ (store_ T) - 1, dbuf_ 0c;   store_ T, dbuf_ 0c, NextOpCode; regOP1[173, StackBR, opGCSCAN1, NoNData];regOP1[174, StackBR, opGCSCAN2, NoNData];:endif; * reduced*--------------------------------------------------------------------opPUTBASEN:*--------------------------------------------------------------------   T_ (fetch_ TSP) + 1;			* fetch val hi   LTEMP0_ Md, T_ (fetch_ T) - (3c);	* fetch val lo   pd_ (LTEMP0) xor (SmallHi);		* check val hi   branch[.+2, alu=0],   Q_ Md, T_ (fetch_ T) + 1;	* fetch addrhi	callUFN;* Q= value   LTEMP2_ Md, fetch_ T;   LEFT_ (LEFT) + 1, memBase_ ScratchLZBR;   T_ (Id) + (Md);   branch[.+2, carry'], BrHi_ LTEMP2;	LTEMP2_ (LTEMP2) + 1, branch[.-1];   PAGEFAULTOK;   STORE_ T, dbuf_ Q;:if[Debugging];   T_ Md, PAGEFAULTNOTOK;:endif;   T_ Md, TSP _ (TSP) - (2c), NextOpCode;	* wait for faultsregOP2[315, StackM2BR, opPUTBASEN, noNData];*--------------------------------------------------------------------opPUTBASEPTRN:*--------------------------------------------------------------------   T_ (fetch_ TSP) + 1;			* fetch val hi   LTEMP0_ Md, T_ (fetch_ T) - (3c);	* fetch val lo   Q_ Md, T_ (fetch_ T) + 1;		* fetch addrhi* LTEMP0, Q= value   LTEMP2_ Md, fetch_ T;   memBase_ ScratchLZBR, LEFT_ (LEFT) + 1;   T_ (Id) + (Md);   branch[.+2, carry'], BrHi_ LTEMP2;	LTEMP2_ (LTEMP2) + 1, branch[.-1];	PAGEFAULTOK;   T_ (STORE_ T) + 1, dbuf_ LTEMP0;   STORE_ T, dbuf_ Q;	PAGEFAULTNOTOK;   TSP _ (TSP) - (2c), NextOpCode;regOP2[316, StackM2BR, opPUTBASEPTRN, noNData];*--------------------------------------------------------------------opPUTBITS:*--------------------------------------------------------------------   T_ (fetch_ TSP) + 1;			* fetch val hi   LTEMP0_ Md, T_ (fetch_ T) - (3c);	* fetch val lo   pd_ (LTEMP0) xor (SmallHi);		* check val hi   branch[.+2, alu=0],   LTEMP0_ Md, T_ (fetch_ T) + 1;	* fetch addrhi	callUFN;* LTEMP0= value   LTEMP2_ Md, fetch_ T;   LEFT_ (LEFT) + 1, memBase_ ScratchLZBR;   T_ (Id) + (Md);   branch[.+2, carry'], BrHi_ LTEMP2;	LTEMP2_ (LTEMP2) + 1, branch[.-1];	PAGEFAULTOK;   FETCH_ T;   WF_ Id, LTEMP1_ T;   T_ ShMdBothMasks[LTEMP0];	PAGEFAULTNOTOK;   store_ LTEMP1, dbuf_ T;   TSP _ (TSP) - (2c), NextOpCode;regOP3[317, StackM2BR, opPUTBITS, noNData];*--------------------------------------------------------------------opPUTBASEBYTE:	* PUTBASEBYTE(base, displacement, value)*--------------------------------------------------------------------   T_ (TSP) - 1;   T_ (fetch_ T) - 1;   LTEMP0_ Md, T_ (fetch_ T) - 1;	* LTEMP0 has new byte   pd_ (LTEMP0) and not (rhmask);   LTEMP1_ Md, T_ (fetch_ T) - 1, branch[.+2, alu=0];   	CallUFN;   pd_ (LTEMP1) xor (SmallHi);   LTEMP1_ Md, T_ (fetch_ T) - 1, branch[.+2, alu=0];* LTEMP1_offset	CallUFN;   LTEMP2_ Md, T_ (fetch_ T) - 1;	pd_ (LTEMP2) xor (SmallHi);   LTEMP2_ Md, fetch_ T, branch[.+2, alu=0];	CallUFN;   LEFT_ (LEFT) + 1, memBase_ LScratchBR;   LTEMP2_ Md, BrLo_ LTEMP2;   BrHi_ LTEMP2;	PAGEFAULTOK;   branch[.putRight, R odd], LTEMP1_ (LTEMP1) rsh 1;   FETCH_ LTEMP1;   T_ Md, TSP_ T;	* CAN FAULT   T_ T and (rhmask);   Q_ LTEMP0;   LTEMP0_ LSH[LTEMP0, 10];   T_ T + (LTEMP0), branch[.restoreByte];.putRight:   FETCH_ LTEMP1;   T_ Md, TSP_ T;	* CAN FAULT   T_ T and (lhmask);   T_ T + (LTEMP0), Q_ LTEMP0, branch[.restoreByte];.restoreByte:   store_ LTEMP1, dbuf_ T;	PAGEFAULTNOTOK;   LEFT_ (LEFT) + 1, memBase_ StackBR;   TSP_ (store_ TSP) + 1, dbuf_ SmallHi;   TSP_ (store_ TSP) + 1, dbuf_ Q, NextOpCode;regOP1[307, StackBR, opPUTBASEBYTE, noNData];*--------------------------------------------------------------------opADDBASE:*--------------------------------------------------------------------   T_ (TSP) - 1;   T_ (fetch_ T) - 1;   LTEMP0_ Md, T_ (fetch_ T) - 1;   LTEMP1_ Md, fetch_ T;   pd_ (LTEMP1) xor (SmallHi);   branch[.+2, alu=0], LTEMP0_ (LTEMP0) + (Md);	CallUFN;   branch[.addbasecarry, carry], LEFT_ (LEFT) + 1;   TSP_ (store_ T) + 1, dbuf_ LTEMP0, NextOpCode;.addbasecarry:   T_ (store_ T) - 1, dbuf_ LTEMP0;   TSP_ (fetch_ T) + (2c);   LTEMP0_ (1s) + (Md);   store_ T, dbuf_ LTEMP0, NextOpCode;regOP1[320, StackBR, opADDBASE, noNData];*--------------------------------------------------------------------opVAG2:*--------------------------------------------------------------------   T_ (TSP) - 1;   T_ (fetch_ T) - (2c);   LTEMP1_ Md, T_ (fetch_ T) - 1;   LEFT_ (LEFT) + 1;   T_ (store_ T) + 1, dbuf_ Md;   TSP_ (store_ T) + 1, dbuf_ LTEMP1, NextOpCode;regOP1[321, StackBR, opVAG2, noNData];*--------------------------------------------------------------------opHILOC:*--------------------------------------------------------------------   fetch_ TSP;   T_ Md, TSP_ (store_ TSP) + 1, dbuf_ SmallHi;   TSP_ (store_ TSP) - 1, dbuf_ T, NextOpcode;regOP1[322, StackM2BR, opHILOC, noNData];*--------------------------------------------------------------------opLOLOC:*--------------------------------------------------------------------   store_ TSP, dbuf_ SmallHi, NextOpCode;regOP1[323, StackM2BR, opLOLOC, noNData];*--------------------------------------------------------------------* BOX results	*   box result in LTEMP0, LTEMP1*--------------------------------------------------------------------:if[Reduced];.BOX2:	branch[.box2fail, alu#0];    T_ (store_ TSP) + 1, dbuf_ SmallHi;    TSP_ (store_ T) + 1, dbuf_ LTEMP1, NextOpCode;.BOX:	branch[.box1fail, alu#0];    T_ (store_ TSP) + 1, dbuf_ SmallHi;    TSP_ (store_ T) + 1, dbuf_ LTEMP1, NextOpCode;.box2fail:   TSP_ (TSP) + (4c), branch[.unboxfail];.box1fail:   TSP_ (TSP) + (2c), branch[.unboxfail];:else; * not reduced.BOX2:.BOX: GLOBAL,	   branch[.boxt2, alu#0], T_ (store_ TSP) + 1, dbuf_ SmallHi;   TSP_ (store_ T) + 1, dbuf_ LTEMP1, NextOpCode;.boxt2:   pd_ (LTEMP0) + 1;   branch[.ARITHPUNT, alu#0],	T_ (store_ TSP) + 1, dbuf_ SmallNegHi;   TSP_ (store_ T) + 1, dbuf_ LTEMP1, NextOpCode;.STOREBOX2:	memBase_ ScratchLZBR, T_ (LTEMP2);	T_ (store_ T) + 1, dbuf_ LTEMP0;   store_ T, dbuf_ LTEMP1;   TSP_ (TSP) + (2c), NextOpCode;.ARITHPUNT:	* push halves and call MAKENUMBER   T_ (store_ TSP) + 1, dbuf_ SmallHi;   T_ (store_ T) + 1, dbuf_ LTEMP0;   T_ (store_ T) + 1, dbuf_ SmallHi;   TSP_ (store_ T) + 1, dbuf_ LTEMP1;   NARGS_ 2c;   DEFLO_ AT.MAKENUMBER, branch[DOCALLPUNT];:endif; * not reduced*--------------------------------------------------------------------SUBROUTINE;		.UNBOX1:		GLOBAL, *--------------------------------------------------------------------*   memBase_ StackM2BR;*   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX1];*   returns result in LTEMP0 & T,, Q & LTEMP1 with TSP - 2*   and memBase_ StackBR   T_ Md, fetch_ T;   LTEMP0_ T_ T - (SmallHi);   branch[.unbox1X, alu#0], Q_ LTEMP1_ Md;.unbox1ret:   TSP_ (TSP) - (2c), return;:if[Reduced];.unbox1x: branch[.unboxfail];:else;.unbox1X:   T_ T - 1;   branch[.+2, alu#0], LTEMP0_ T_ T - 1;	TSP_ (TSP) - (2c), return;   T_ T + (add[SmallHi!, 2]c);   memBase_ tyBaseBR;   LTEMP1_ rcy[T, LTEMP1, 11];   fetch_ LTEMP1;   LTEMP1_ Md, memBase_ ScratchLZBR;   pd_ (LTEMP1) - (fixptype);   branch[.+2, alu=0], BrHi_ T, T_ Q;	branch[.unboxfail];	PAGEFAULTOK;   T_ (FETCH_ T) + 1;   LTEMP0_ T_ MD, fetch_ T;	PAGEFAULTNOTOK;   LTEMP1_ Md, memBase_ StackBR;   Q_ LTEMP1, branch[.unbox1ret];:endif; * not reduced*--------------------------------------------------------------------.UNBOX2: GLOBAL, *--------------------------------------------------------------------*   memBase_ StackM2BR;*   T_ (fetch_ TSP) - 1, flipMemBase, call[.UNBOX2];* sets results to be LTEMP0, LTEMP1;  T, Q* sets TSP_ TSP-4, LEFT_ LEFT - 1;* returns w/ memBase_ StackBR   LTEMP0_ Md, T_ (fetch_ T) - (3c);	* LTEMP0_ YHi, T_ (oldTSP) - 4   LTEMP1_ Md, T_ (fetch_ T) + 1;		* LTEMP1_ YLo, T_ (oldTSP) - 3   LTEMP0_ (LTEMP0) - (SmallHi);		* LTEMP0_ YHi (unboxed)   dblbranch[.unboxAX, .unboxB, alu#0],			T_ Md, fetch_ T;	* T_ XHi .unboxB:   T_ T - (SmallHi);				* T_ XHi (unboxed).unboxB1:   dblbranch[.unboxBX, .unbox2ret, alu#0],		Q_ Md, LEFT_ (LEFT) + 1;	* Q_ XLo.unbox2ret:   TSP_ (TSP) - (4c), return;:if[Reduced];.unboxAX:   branch[.unboxfail];.unboxBX:   branch[.unboxfail];:else; * not reduced.unboxBX:   T_ T - 1;					* T was really neg?   branch[.+2, alu#0], T_ T - 1;		* make -1	TSP_ (TSP) - (4c), return;   T_ T + (add[SmallHi!, 2]c);			* put T back   LTEMP2_ Q, memBase_ tyBaseBR;   LTEMP2_ rcy[T, LTEMP2, 11];   fetch_ LTEMP2;   LTEMP2_ Md, memBase_ ScratchLZBR;   pd_ (LTEMP2) - (fixptype);   branch[.+2, alu=0], BrHi_ T, T_ Q;	branch[.unboxfail];			* nope, not fixp	PAGEFAULTOK;   T_ (FETCH_ T) + 1;   T_ MD, fetch_ T;	PAGEFAULTNOTOK;   LTEMP2_ Q, memBase_ StackBR; * save loloc   Q_ Md, branch[.unbox2ret];.unboxAX:   LTEMP0_ (LTEMP0) - 1;			* LTEMP0 was really neg?   branch[.+2, alu#0], LTEMP0_ (LTEMP0) - 1;	* make -1   T_ T - (SmallHi), branch[.unboxB1];   Q_ Md, LEFT_ (LEFT) + 1;   LTEMP2_ T, memBase_ tyBaseBR;		* save T   LTEMP0_ T_ (LTEMP0) + (add[SmallHi!, 2]c);	* restore LTEMP0   T_ rcy[T, LTEMP1, 11];   fetch_ T;   T_ Md, memBase_ ScratchLZBR;   pd_ (T) - (fixptype);   branch[.+2, alu=0], BrHi_ LTEMP0;	branch[.unboxfail];			* nope, not fixp	PAGEFAULTOK;   LTEMP1_ (FETCH_ LTEMP1) + 1;   LTEMP0_ MD, fetch_ LTEMP1;	PAGEFAULTNOTOK;   T_ (LTEMP2) - (SmallHi);   LTEMP1_ Md, memBase_ StackBR, dblbranch[.unboxBX, .unbox2ret, alu#0];:endif; * not reducedTOP LEVEL;.unboxfail:   CallUFN;