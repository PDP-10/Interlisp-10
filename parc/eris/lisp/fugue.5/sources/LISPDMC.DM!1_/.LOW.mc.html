<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>fugue.5>Sources>LISPDMC.DM!1>LOW.mc</title>
  </head>
  <body>
    <pre>
:Title[LOW.dmc, February 23, 1983  5:28 PM, Masinter];   TOP LEVEL;   knowrbase[LTEMP0];   InsSet[LispInsSet, 1];*--------------------------------------------------------------------opLLSH1:	* Replace TOS with it shifted left one*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX1];   LTEMP1&larr; (LTEMP1) + (LTEMP1);   LTEMP0&larr; T + T, XorSavedCarry, branch[.BOX];regOP1[340, StackM2BR, opLLSH1, noNData];*--------------------------------------------------------------------opLRSH1:	* Replace TOS with it shifted right one*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX1];   LTEMP1&larr; (LTEMP1) rsh 1;   LTEMP0&larr; (LTEMP0) rsh 1, branch[.+2, R even];	LTEMP1&larr; (LTEMP1) or (100000c);   pd&larr; LTEMP0, branch[.BOX];regOP1[342, StackM2BR, opLRSH1, noNData];*--------------------------------------------------------------------opLRSH8:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX1];   LTEMP1&larr; RSH[LTEMP1, 10];   T&larr; LSH[LTEMP0, 10];   LTEMP1&larr; (LTEMP1) + T;   LTEMP0&larr; RSH[LTEMP0, 10], branch[.BOX];regOP1[343, StackM2BR, opLRSH8, noNData];*--------------------------------------------------------------------opLLSH8:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX1];   LTEMP0&larr; LSH[T, 10];   T&larr; RSH[LTEMP1, 10];   LTEMP1&larr; LSH[LTEMP1, 10];   LTEMP0&larr; (LTEMP0) + T, branch[.BOX];regOP1[341, StackM2BR, opLLSH8, noNData];*--------------------------------------------------------------------opLOGAND2:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1&larr; (LTEMP1) and Q;   LTEMP0&larr; (LTEMP0) and T, branch[.BOX2];regOP1[345, StackM2BR, opLOGAND2, noNData];*--------------------------------------------------------------------opLOGOR2:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1&larr; (LTEMP1) or Q;   LTEMP0&larr; (LTEMP0) or T, branch[.BOX2];regOP1[344, StackM2BR, opLOGOR2, noNData];*--------------------------------------------------------------------opLOGXOR2:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1&larr; (LTEMP1) xor Q;   LTEMP0&larr; (LTEMP0) xor T, branch[.BOX2];regOP1[346, StackM2BR, opLOGXOR2, noNData];*--------------------------------------------------------------------opIDIFFERENCE:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1&larr; (Q) - (LTEMP1);   LTEMP0&larr; (T) - (LTEMP0) - 1, XorSavedCarry, branch[.BOX2];regOP1[331, StackM2BR, opIDIFFERENCE, noNData];	* IDIFFERENCE:if[Reduced];	UfnOps[325];:else;regOP1[325, StackM2BR, opIDIFFERENCE, noNData];	* DIFFERENCE:endif;*--------------------------------------------------------------------opIPLUS2:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1&larr; (LTEMP1) + Q;   LTEMP0&larr; (LTEMP0) + T, XorSavedCarry, branch[.BOX2];regOP1[330, StackM2BR, opIPLUS2, noNData];	* IPLUS:if[Reduced];   UfnOps[324];:else;regOP1[324, StackM2BR, opIPLUS2, noNData];	* PLUS:endif;:if[Reduced];   UfnOps[366];:else;*--------------------------------------------------------------------opBOXIPLUS:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1&larr; (LTEMP1) + Q;   LTEMP0&larr; (LTEMP0) + T, XorSavedCarry, branch[.STOREBOX2];regOP1[366, StackM2BR, opBOXIPLUS, noNData];:endif;:if[Reduced];   UfnOps[367];:else;*--------------------------------------------------------------------opBOXIDIFFERENCE:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   LTEMP1&larr; (Q) - (LTEMP1);   LTEMP0&larr; (T) - (LTEMP0) - 1, XorSavedCarry, branch[.STOREBOX2];regOP1[367, StackM2BR, opBOXIDIFFERENCE, noNData];:endif;*--------------------------------------------------------------------* TIMES*--------------------------------------------------------------------:if[Reduced];	UfnOps[332];	UfnOps[326];:else;opITIMES2:   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   pd&larr; T or (LTEMP0);   branch[.+2, alu=0], T&larr; LTEMP1;	TSP&larr; (TSP) + (4c), branch[.unboxfail];	* can't handle 32 bit   call[MulSub];			* unsigned multiply T * Q -&gt; (T, Q)   LTEMP1&larr; Q;   LTEMP0&larr; T, branch[.BOX2];regOP1[332, StackM2BR, opITIMES2, noNData];	* ITIMESregOP1[326, StackM2BR, opITIMES2, noNData];	* TIMES:endif;*--------------------------------------------------------------------* QUOTIENT*--------------------------------------------------------------------:if[Reduced];	UfnOps[333];	UfnOps[327];:else;opIQUOTIENT:   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   pd&larr; T or (LTEMP0);   branch[.+2, alu=0];			* (could handle big positives)	TSP&larr; (TSP) + (4c), branch[.unboxfail];		* failure return   DivTEMP1&larr; LTEMP1, SCall[DivSub];	* unsigned divide T,,Q by DivTEMP1   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[.+2];	TSP&larr; (TSP) + (4c), branch[.unboxfail];		* failure return   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; Q, NextOpCode;regOP1[333, StackM2BR, opIQUOTIENT, noNData];	* IQUOTIENTregOP1[327, StackM2BR, opIQUOTIENT, noNData];	* QUOTIENT:endif;*--------------------------------------------------------------------* REMAINDER*--------------------------------------------------------------------:if[Reduced];	UfnOps[334];:else;opIREMAINDER:   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   pd&larr; T or (LTEMP0);   branch[.+2, alu=0];	TSP&larr; (TSP) + (4c), branch[.unboxfail];		* failure return   DivTEMP1&larr; LTEMP1, SCall[DivSub];	* unsigned divide T,,Q by DivTEMP1   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[.+2];	TSP&larr; (TSP) + (4c), branch[.unboxfail];		* failure return   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, NextOpCode;	* T = remainderregOP1[334, StackM2BR, opIREMAINDER, noNData];:endif;*--------------------------------------------------------------------opIGREATERP:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];   pd&larr; T - (LTEMP0);   branch[.ig2, alu=0], pd&larr; (Q) - (LTEMP1) - 1;* hi parts differ   T&larr; T xor (100000c);   LTEMP0&larr; (LTEMP0) xor (100000c);	* complement sign   pd&larr; T - (LTEMP0) - 1;.ig2:   branch[.+2, carry], TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; AT.NIL, NextOpCode;	* push NIL   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; AT.T, NextOpCode;	* push TregOP1[361, StackM2BR, opIGREATERP, noNData];	* IGREATERP:if[Reduced]; UfnOps[363];:else;regOP1[363, StackM2BR, opIGREATERP, noNData];	* GREATERP:endif;*--------------------------------------------------------------------opSWAP:*--------------------------------------------------------------------   T&larr; (TSP) - 1;   T&larr; (fetch&larr; T) - 1;   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1;   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;   LTEMP2&larr; Md, fetch&larr; T;   LTEMP0&larr; Md, T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;   store&larr; T, dbuf&larr; LTEMP2, NextOpcode;regOP1[375, StackBR, opSWAP, noNData];*--------------------------------------------------------------------opEQ:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) - 1, flipMemBase;   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);   LTEMP1&larr; Md, T&larr; (fetch&larr; T) + 1;   T&larr; Md, TSP&larr; (fetch&larr; T) - 1;   T&larr; Md, pd&larr; T xor (LTEMP0);   branch[.+2, alu=0], pd&larr; (T) xor (LTEMP1);	LEFT&larr; (LEFT) + 1, branch[.neq];   branch[.neq, alu#0], LEFT&larr; (LEFT) + 1;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; AT.T, NextOpCode;.neq:   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c, NextOpCode;regOP1[360, StackM2BR, opEQ, noNData];*--------------------------------------------------------------------opNOP:*--------------------------------------------------------------------   NextOpcode;regOP1[376, ifuBR, opNOP, noNData];*--------------------------------------------------------------------opBLT: * (destinationaddr sourceaddr nwords)*--------------------------------------------------------------------* Move nwords from source to destination.  If nwords &lt; tbd,* then operation is uninterruptable, else must be prepared to* service interrupts.  On page fault or interrupt, update* stack according to how much is moved, and back up pc.* Result is unspecified.  Behavior if source and destination* overlap is unspecified	T&larr; (fetch&larr; TSP) + 1;	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (2c);	pd&larr; (LTEMP0) xor (SmallHi);	branch[.+2, alu=0], LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;		CallUFN;	LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1;	LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;	LTEMP3&larr; Md, fetch&larr; T, pd &larr; T&larr; (LTEMP2);	branch[.+2, alu#0], LTEMP2&larr; Md, memBase&larr; BBDSTBR, T&larr; T - 1;		branch[.bltdone];	* no words to copy	Cnt&larr; T;  			* number of words to transfer - 1	BRHi&larr; LTEMP2;	BRLo&larr; LTEMP3;	memBase&larr; BBSRCBR;	BRHi&larr; LTEMP0;	BRLo&larr; LTEMP1;* and now for the loop. This should really keep state in Stack a la BITBLT:	PAGEFAULTOK;	FETCH&larr; T, flipMemBase;	T&larr; (store&larr; T) - 1, dbuf&larr; MD, flipMembase, branch[.-1, Cnt#0&amp;-1];	PAGEFAULTNOTOK;.bltdone:	Left&larr; (Left) + (2c);	TSP&larr; (TSP) - (4c), NextOpCode;regOP1[304, StackM2BR, opBLT, noNData];*--------------------------------------------------------------------opGETBASEN:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;   T&larr; Md, fetch&larr; T;   LTEMP0&larr; Md, memBase&larr; ScratchLZBR;   BrHi&larr; T;	PAGEFAULTOK;   IFETCH&larr; LTEMP0;   memBase&larr; StackM2BR;   T&larr; MD, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;	PAGEFAULTNOTOK;   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;regOP2[310, StackM2BR, opGETBASEN, noNData];*--------------------------------------------------------------------opGETBASEPTRN: *--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;   T&larr; Md, fetch&larr; T, LTEMP1&larr; (rhmask);   LTEMP0&larr; Md, memBase&larr; ScratchLZBR;   BrHi&larr; T;	PAGEFAULTOK;   LTEMP0&larr; (IFETCH&larr; LTEMP0) + 1;   T&larr; MD, ifetch&larr; LTEMP0;	PAGEFAULTNOTOK;   T&larr; T and (LTEMP1), memBase&larr; StackM2BR;   T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T;   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;regOP2[311, StackM2BR, opGETBASEPTRN, noNData];*--------------------------------------------------------------------opGETBASE32N: *--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;   T&larr; Md, fetch&larr; T;   LTEMP0&larr; Md, memBase&larr; ScratchLZBR;   BrHi&larr; T;	PAGEFAULTOK;   LTEMP0&larr; (IFETCH&larr; LTEMP0) + 1;   T&larr; MD, ifetch&larr; LTEMP0;	PAGEFAULTNOTOK;   memBase&larr; StackM2BR;   T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T;   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;regOP2[313, StackM2BR, opGETBASE32N, noNData];*--------------------------------------------------------------------opGETBITS: *--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;   T&larr; Md, fetch&larr; T;   LTEMP0&larr; Md, memBase&larr; ScratchLZBR;   BrHi&larr; T;	PAGEFAULTOK;   IFETCH&larr; LTEMP0, TisID;   memBase&larr; StackM2BR;   LTEMP0&larr; MD, RF&larr; Id;	PAGEFAULTNOTOK;   T&larr; ShiftLMask[LTEMP0], memBase&larr; StackM2BR;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;regOP3[312, StackM2BR, opGETBITS, noNData];*--------------------------------------------------------------------opGETBASEBYTE:*--------------------------------------------------------------------   T&larr; (TSP) - 1;   T&larr; (fetch&larr; T) - 1;   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;	* LTEMP0&larr; offset   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1;   LTEMP1&larr; Md, pd&larr; (LTEMP1) xor (SmallHi);   branch[.+2, alu=0],   fetch&larr; T;	CallUFN;   memBase&larr; LScratchBR;   LTEMP1&larr; Md, BrLo&larr; LTEMP1;   BrHi&larr; LTEMP1, call[DOGETBYTE];   memBase&larr; StackBR, LEFT&larr; (LEFT) + 1;   T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0, NextOpCode;regOP1[302, StackBR, opGETBASEBYTE, noNData];SUBROUTINE;*--------------------------------------------------------------------* DOGETBYTE:	* called by BIN, GETBASEBYTE*--------------------------------------------------------------------*	assumes current memBase is pointer, LTEMP0 is byte offset*	returns byte in LTEMP0DOGETBYTE:   dblbranch[.gbev, .gbod, R even], LTEMP0&larr; (LTEMP0) rsh 1;.gbev:	PAGEFAULTOK;   FETCH&larr; LTEMP0;   LTEMP0&larr; MD;	PAGEFAULTNOTOK;   LTEMP0&larr; RSH [LTEMP0, 10], return;.gbod:	PAGEFAULTOK;   FETCH&larr; LTEMP0;   LTEMP0&larr; MD;	PAGEFAULTNOTOK;   LTEMP0&larr; (LTEMP0) AND (rhmask), return;TOP LEVEL;*--------------------------------------------------------------------opRCLK:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;   LTEMP0&larr; Md, fetch&larr; T, T&larr; (30c);   LTEMP1&larr; Md, memBase&larr; MDS;   T&larr; T + (400c);   taskingOff;   fetch&larr; T;			* fetch word 430 for hi part of clock   LTEMP2&larr; Md, rbase&larr; rbase[RTClock];   T&larr; RTClock;   taskingOn;	* turn on tasking again;   rbase&larr; rbase[LTEMP0];   memBase&larr; ScratchLZBR;   BrHi&larr; LTEMP0;      	PAGEFAULTOK;   LTEMP1&larr; (store&larr; LTEMP1) + 1, dbuf&larr; Md;   	PAGEFAULTNOTOK;   store&larr; LTEMP1, dbuf&larr; T, nextOpCode;regOP1[167, StackM2BR, opRCLK, noNData];*--------------------------------------------------------------------* scan GC tables*--------------------------------------------------------------------:if[Reduced];	UfnOps[173];	UfnOps[174];:else;opGCSCAN1:   T&larr; (TSP) - 1;   fetch&larr; T, LTEMP0&larr; (-2c), branch[.gcscan];opGCSCAN2:   T&larr; (TSP) - 1;   fetch&larr; T, LTEMP0&larr; (HTSTKBIT), branch[.gcscan];.gcscan:   LTEMP1&larr; Md, memBase&larr; htMainBR;   LTEMP1&larr; (LTEMP1) - 1, Q&larr; LTEMP1;.gcscanlp:   branch[.gcscanfail, R&lt;0], LTEMP1;   LTEMP1&larr; (fetch&larr; LTEMP1) - 1, Q&larr; LTEMP1;   LTEMP2&larr; Md, T&larr; LTEMP0;   branch[.+2, R even], pd&larr; (LTEMP2) and T;	memBase&larr; StackBR, TSP&larr; (TSP) - 1, branch[.gcfoundret];   branch[.gcscanlp, alu=0], pd&larr; T;   dblbranch[.gcfound1, .gcfound2, alu&lt;0], pd&larr; (LTEMP2) and (HTSTKCNT);.gcfound1:   branch[.gcfoundret, alu=0], memBase&larr; StackBR, TSP&larr; (TSP) - 1;   memBase&larr; htMainBR, TSP&larr; (TSP) + 1, branch[.gcscanlp];.gcfound2:   LTEMP2&larr; (LTEMP2) and not T, memBase&larr;htMainBR;	* turn off stkbit   T&larr; (LTEMP2) and (HTSTKCNT);   T&larr; T - (HT1CNT);   branch[.+2, alu#0];	store&larr; Q, dbuf&larr; T, branch[.gcscanlp];		* ref cnt went to 1	store&larr; Q, dbuf&larr; LTEMP2, branch[.gcscanlp];	* restore word.gcfoundret:   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; Q, NextOpCode;.gcscanfail:   memBase&larr; StackBR, T&larr; (TSP) - 1;   T&larr; (store&larr; T) - 1, dbuf&larr; 0c;   store&larr; T, dbuf&larr; 0c, NextOpCode; regOP1[173, StackBR, opGCSCAN1, NoNData];regOP1[174, StackBR, opGCSCAN2, NoNData];:endif; * reduced*--------------------------------------------------------------------opPUTBASEN:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;			* fetch val hi   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);	* fetch val lo   pd&larr; (LTEMP0) xor (SmallHi);		* check val hi   branch[.+2, alu=0],   Q&larr; Md, T&larr; (fetch&larr; T) + 1;	* fetch addrhi	callUFN;* Q= value   LTEMP2&larr; Md, fetch&larr; T;   LEFT&larr; (LEFT) + 1, memBase&larr; ScratchLZBR;   T&larr; (Id) + (Md);   branch[.+2, carry'], BrHi&larr; LTEMP2;	LTEMP2&larr; (LTEMP2) + 1, branch[.-1];   PAGEFAULTOK;   STORE&larr; T, dbuf&larr; Q;:if[Debugging];   T&larr; Md, PAGEFAULTNOTOK;:endif;   T&larr; Md, TSP &larr; (TSP) - (2c), NextOpCode;	* wait for faultsregOP2[315, StackM2BR, opPUTBASEN, noNData];*--------------------------------------------------------------------opPUTBASEPTRN:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;			* fetch val hi   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);	* fetch val lo   Q&larr; Md, T&larr; (fetch&larr; T) + 1;		* fetch addrhi* LTEMP0, Q= value   LTEMP2&larr; Md, fetch&larr; T;   memBase&larr; ScratchLZBR, LEFT&larr; (LEFT) + 1;   T&larr; (Id) + (Md);   branch[.+2, carry'], BrHi&larr; LTEMP2;	LTEMP2&larr; (LTEMP2) + 1, branch[.-1];	PAGEFAULTOK;   T&larr; (STORE&larr; T) + 1, dbuf&larr; LTEMP0;   STORE&larr; T, dbuf&larr; Q;	PAGEFAULTNOTOK;   TSP &larr; (TSP) - (2c), NextOpCode;regOP2[316, StackM2BR, opPUTBASEPTRN, noNData];*--------------------------------------------------------------------opPUTBITS:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;			* fetch val hi   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);	* fetch val lo   pd&larr; (LTEMP0) xor (SmallHi);		* check val hi   branch[.+2, alu=0],   LTEMP0&larr; Md, T&larr; (fetch&larr; T) + 1;	* fetch addrhi	callUFN;* LTEMP0= value   LTEMP2&larr; Md, fetch&larr; T;   LEFT&larr; (LEFT) + 1, memBase&larr; ScratchLZBR;   T&larr; (Id) + (Md);   branch[.+2, carry'], BrHi&larr; LTEMP2;	LTEMP2&larr; (LTEMP2) + 1, branch[.-1];	PAGEFAULTOK;   FETCH&larr; T;   WF&larr; Id, LTEMP1&larr; T;   T&larr; ShMdBothMasks[LTEMP0];	PAGEFAULTNOTOK;   store&larr; LTEMP1, dbuf&larr; T;   TSP &larr; (TSP) - (2c), NextOpCode;regOP3[317, StackM2BR, opPUTBITS, noNData];*--------------------------------------------------------------------opPUTBASEBYTE:	* PUTBASEBYTE(base, displacement, value)*--------------------------------------------------------------------   T&larr; (TSP) - 1;   T&larr; (fetch&larr; T) - 1;   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;	* LTEMP0 has new byte   pd&larr; (LTEMP0) and not (rhmask);   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1, branch[.+2, alu=0];   	CallUFN;   pd&larr; (LTEMP1) xor (SmallHi);   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1, branch[.+2, alu=0];* LTEMP1&larr;offset	CallUFN;   LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;	pd&larr; (LTEMP2) xor (SmallHi);   LTEMP2&larr; Md, fetch&larr; T, branch[.+2, alu=0];	CallUFN;   LEFT&larr; (LEFT) + 1, memBase&larr; LScratchBR;   LTEMP2&larr; Md, BrLo&larr; LTEMP2;   BrHi&larr; LTEMP2;	PAGEFAULTOK;   branch[.putRight, R odd], LTEMP1&larr; (LTEMP1) rsh 1;   FETCH&larr; LTEMP1;   T&larr; Md, TSP&larr; T;	* CAN FAULT   T&larr; T and (rhmask);   Q&larr; LTEMP0;   LTEMP0&larr; LSH[LTEMP0, 10];   T&larr; T + (LTEMP0), branch[.restoreByte];.putRight:   FETCH&larr; LTEMP1;   T&larr; Md, TSP&larr; T;	* CAN FAULT   T&larr; T and (lhmask);   T&larr; T + (LTEMP0), Q&larr; LTEMP0, branch[.restoreByte];.restoreByte:   store&larr; LTEMP1, dbuf&larr; T;	PAGEFAULTNOTOK;   LEFT&larr; (LEFT) + 1, memBase&larr; StackBR;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; Q, NextOpCode;regOP1[307, StackBR, opPUTBASEBYTE, noNData];*--------------------------------------------------------------------opADDBASE:*--------------------------------------------------------------------   T&larr; (TSP) - 1;   T&larr; (fetch&larr; T) - 1;   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;   LTEMP1&larr; Md, fetch&larr; T;   pd&larr; (LTEMP1) xor (SmallHi);   branch[.+2, alu=0], LTEMP0&larr; (LTEMP0) + (Md);	CallUFN;   branch[.addbasecarry, carry], LEFT&larr; (LEFT) + 1;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0, NextOpCode;.addbasecarry:   T&larr; (store&larr; T) - 1, dbuf&larr; LTEMP0;   TSP&larr; (fetch&larr; T) + (2c);   LTEMP0&larr; (1s) + (Md);   store&larr; T, dbuf&larr; LTEMP0, NextOpCode;regOP1[320, StackBR, opADDBASE, noNData];*--------------------------------------------------------------------opVAG2:*--------------------------------------------------------------------   T&larr; (TSP) - 1;   T&larr; (fetch&larr; T) - (2c);   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1;   LEFT&larr; (LEFT) + 1;   T&larr; (store&larr; T) + 1, dbuf&larr; Md;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;regOP1[321, StackBR, opVAG2, noNData];*--------------------------------------------------------------------opHILOC:*--------------------------------------------------------------------   fetch&larr; TSP;   T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpcode;regOP1[322, StackM2BR, opHILOC, noNData];*--------------------------------------------------------------------opLOLOC:*--------------------------------------------------------------------   store&larr; TSP, dbuf&larr; SmallHi, NextOpCode;regOP1[323, StackM2BR, opLOLOC, noNData];*--------------------------------------------------------------------* BOX results	*   box result in LTEMP0, LTEMP1*--------------------------------------------------------------------:if[Reduced];.BOX2:	branch[.box2fail, alu#0];    T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;    TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;.BOX:	branch[.box1fail, alu#0];    T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;    TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;.box2fail:   TSP&larr; (TSP) + (4c), branch[.unboxfail];.box1fail:   TSP&larr; (TSP) + (2c), branch[.unboxfail];:else; * not reduced.BOX2:.BOX: GLOBAL,	   branch[.boxt2, alu#0], T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;.boxt2:   pd&larr; (LTEMP0) + 1;   branch[.ARITHPUNT, alu#0],	T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallNegHi;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;.STOREBOX2:	memBase&larr; ScratchLZBR, T&larr; (LTEMP2);	T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;   store&larr; T, dbuf&larr; LTEMP1;   TSP&larr; (TSP) + (2c), NextOpCode;.ARITHPUNT:	* push halves and call MAKENUMBER   T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;   T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;   NARGS&larr; 2c;   DEFLO&larr; AT.MAKENUMBER, branch[DOCALLPUNT];:endif; * not reduced*--------------------------------------------------------------------SUBROUTINE;		.UNBOX1:		GLOBAL, *--------------------------------------------------------------------*   memBase&larr; StackM2BR;*   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX1];*   returns result in LTEMP0 &amp; T,, Q &amp; LTEMP1 with TSP - 2*   and memBase&larr; StackBR   T&larr; Md, fetch&larr; T;   LTEMP0&larr; T&larr; T - (SmallHi);   branch[.unbox1X, alu#0], Q&larr; LTEMP1&larr; Md;.unbox1ret:   TSP&larr; (TSP) - (2c), return;:if[Reduced];.unbox1x: branch[.unboxfail];:else;.unbox1X:   T&larr; T - 1;   branch[.+2, alu#0], LTEMP0&larr; T&larr; T - 1;	TSP&larr; (TSP) - (2c), return;   T&larr; T + (add[SmallHi!, 2]c);   memBase&larr; tyBaseBR;   LTEMP1&larr; rcy[T, LTEMP1, 11];   fetch&larr; LTEMP1;   LTEMP1&larr; Md, memBase&larr; ScratchLZBR;   pd&larr; (LTEMP1) - (fixptype);   branch[.+2, alu=0], BrHi&larr; T, T&larr; Q;	branch[.unboxfail];	PAGEFAULTOK;   T&larr; (FETCH&larr; T) + 1;   LTEMP0&larr; T&larr; MD, fetch&larr; T;	PAGEFAULTNOTOK;   LTEMP1&larr; Md, memBase&larr; StackBR;   Q&larr; LTEMP1, branch[.unbox1ret];:endif; * not reduced*--------------------------------------------------------------------.UNBOX2: GLOBAL, *--------------------------------------------------------------------*   memBase&larr; StackM2BR;*   T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[.UNBOX2];* sets results to be LTEMP0, LTEMP1;  T, Q* sets TSP&larr; TSP-4, LEFT&larr; LEFT - 1;* returns w/ memBase&larr; StackBR   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);	* LTEMP0&larr; YHi, T&larr; (oldTSP) - 4   LTEMP1&larr; Md, T&larr; (fetch&larr; T) + 1;		* LTEMP1&larr; YLo, T&larr; (oldTSP) - 3   LTEMP0&larr; (LTEMP0) - (SmallHi);		* LTEMP0&larr; YHi (unboxed)   dblbranch[.unboxAX, .unboxB, alu#0],			T&larr; Md, fetch&larr; T;	* T&larr; XHi .unboxB:   T&larr; T - (SmallHi);				* T&larr; XHi (unboxed).unboxB1:   dblbranch[.unboxBX, .unbox2ret, alu#0],		Q&larr; Md, LEFT&larr; (LEFT) + 1;	* Q&larr; XLo.unbox2ret:   TSP&larr; (TSP) - (4c), return;:if[Reduced];.unboxAX:   branch[.unboxfail];.unboxBX:   branch[.unboxfail];:else; * not reduced.unboxBX:   T&larr; T - 1;					* T was really neg?   branch[.+2, alu#0], T&larr; T - 1;		* make -1	TSP&larr; (TSP) - (4c), return;   T&larr; T + (add[SmallHi!, 2]c);			* put T back   LTEMP2&larr; Q, memBase&larr; tyBaseBR;   LTEMP2&larr; rcy[T, LTEMP2, 11];   fetch&larr; LTEMP2;   LTEMP2&larr; Md, memBase&larr; ScratchLZBR;   pd&larr; (LTEMP2) - (fixptype);   branch[.+2, alu=0], BrHi&larr; T, T&larr; Q;	branch[.unboxfail];			* nope, not fixp	PAGEFAULTOK;   T&larr; (FETCH&larr; T) + 1;   T&larr; MD, fetch&larr; T;	PAGEFAULTNOTOK;   LTEMP2&larr; Q, memBase&larr; StackBR; * save loloc   Q&larr; Md, branch[.unbox2ret];.unboxAX:   LTEMP0&larr; (LTEMP0) - 1;			* LTEMP0 was really neg?   branch[.+2, alu#0], LTEMP0&larr; (LTEMP0) - 1;	* make -1   T&larr; T - (SmallHi), branch[.unboxB1];   Q&larr; Md, LEFT&larr; (LEFT) + 1;   LTEMP2&larr; T, memBase&larr; tyBaseBR;		* save T   LTEMP0&larr; T&larr; (LTEMP0) + (add[SmallHi!, 2]c);	* restore LTEMP0   T&larr; rcy[T, LTEMP1, 11];   fetch&larr; T;   T&larr; Md, memBase&larr; ScratchLZBR;   pd&larr; (T) - (fixptype);   branch[.+2, alu=0], BrHi&larr; LTEMP0;	branch[.unboxfail];			* nope, not fixp	PAGEFAULTOK;   LTEMP1&larr; (FETCH&larr; LTEMP1) + 1;   LTEMP0&larr; MD, fetch&larr; LTEMP1;	PAGEFAULTNOTOK;   T&larr; (LTEMP2) - (SmallHi);   LTEMP1&larr; Md, memBase&larr; StackBR, dblbranch[.unboxBX, .unbox2ret, alu#0];:endif; * not reducedTOP LEVEL;.unboxfail:   CallUFN;</pre>
  </body>
</html>
