<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>fugue.5>Sources>LISPDMC.DM!1>LINST.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">   :Title[linst.mc, December 6, 1982  1:43 PM, Masinter];<br><br>* variable opcodes, including free variable lookup<br><br>   knowrbase[LTEMP0];<br>   TOP LEVEL;<br>   InsSet[LispInsSet, 1];<br>*--------------------------------------------------------------------<br>opIVAR:<br>*--------------------------------------------------------------------<br>   T&larr; (ifetch&larr; IVAR) + 1;<br>   T&larr; Md, ifetch&larr; T, branch[</span><span style="font: 10pt monospace">PUSHTMD</span><span style="font: 10pt serif">];<br><br>regOP1[100, StackBR, opIVAR, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* IVAR<br>regOP1[101, StackBR, opIVAR, 2];<br>regOP1[102, StackBR, opIVAR, 4];<br>regOP1[103, StackBR, opIVAR, 6];<br>regOP1[104, StackBR, opIVAR, 10];<br>regOP1[105, StackBR, opIVAR, 12];<br>regOP1[106, StackBR, opIVAR, 14];<br>regOP2[107, StackBR, opIVAR, noNData];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* PVARX<br><br>*--------------------------------------------------------------------<br>opPVAR:<br>*--------------------------------------------------------------------<br>   T&larr; (ifetch&larr; PVAR) + 1;<br>   T&larr; Md, ifetch&larr; T, branch[</span><span style="font: 10pt monospace">PUSHTMD</span><span style="font: 10pt serif">];<br><br>regOP1[110, StackBR, opPVAR, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* PVAR<br>regOP1[111, StackBR, opPVAR, 2];<br>regOP1[112, StackBR, opPVAR, 4];<br>regOP1[113, StackBR, opPVAR, 6];<br>regOP1[114, StackBR, opPVAR, 10];<br>regOP1[115, StackBR, opPVAR, 12];<br>regOP1[116, StackBR, opPVAR, 14];<br>regOP2[117, StackBR, opPVAR, noNData];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* PVARX<br><br>*--------------------------------------------------------------------<br>opFVAR:<br>*--------------------------------------------------------------------<br>   T&larr; (ifetch&larr; PVAR) + 1;<br>   LTEMP0&larr; Md, ifetch&larr; T;<br>.retryfvar:<br>   memBase&larr; ScratchLZBR, branch[.+2, R even], T&larr; Md, LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Id, branch[.FVFAIL];<br><br>* KLUDGE: LH IS DUPLICATED!!!!<br>   T&larr; T and (rhmask);<br>   BRHi&larr; T;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   LTEMP0&larr; (FETCH&larr; LTEMP0) + 1;<br>   T&larr; MD, fetch&larr; LTEMP0, branch[</span><span style="font: 10pt monospace">PUSHTMD</span><span style="font: 10pt serif">];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* can fault<br><br>.FVFAIL:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T = offset of free variable, fill in and continue<br>   LTEMP0&larr; T, call[FVLOOKUP];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* T passed and smashed by FVLOOKUP<br>   T&larr; LTEMP0;<br>   T&larr; T + (PVAR);<br>   T&larr; (fetch&larr; T) + 1;<br>   LTEMP0&larr; Md, fetch&larr; T, branch[.retryfvar];<br><br>regOP1[120, StackBR, opFVAR, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* FVAR<br>regOP1[121, StackBR, opFVAR, 2];<br>regOP1[122, StackBR, opFVAR, 4];<br>regOP1[123, StackBR, opFVAR, 6];<br>regOP1[124, StackBR, opFVAR, 10];<br>regOP1[125, StackBR, opFVAR, 12];<br>regOP1[126, StackBR, opFVAR, 14];<br><br>regOP2[127, StackBR, opFVAR, noNData];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* FVARX<br>*--------------------------------------------------------------------<br>opGVAR:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* alpha + beta form atom number of global to fetch<br>*--------------------------------------------------------------------<br>   T&larr; Id;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* hi bits<br>   T&larr; LSH[T,10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* shift left<br>   LTEMP0&larr; ((Id) + T) lsh 1;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   LTEMP0&larr; (FETCH&larr; LTEMP0) + 1;<br>   T&larr; MD, fetch&larr; LTEMP0, branch[</span><span style="font: 10pt monospace">PUSHTMD</span><span style="font: 10pt serif">];<br><br>regOP3[140, ValSpaceBR, opGVAR, noNData];<br>*--------------------------------------------------------------------<br>opSETPVAR:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase;<br>   T&larr; Md, fetch&larr; T;<br>   LTEMP0&larr; (Id) + (PVAR), branch[TL.ST0TMD];<br><br>regOP1[130, StackM2BR, opSETPVAR, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* PVAR&larr;<br>regOP1[131, StackM2BR, opSETPVAR, 2];<br>regOP1[132, StackM2BR, opSETPVAR, 4];<br>regOP1[133, StackM2BR, opSETPVAR, 6];<br>regOP1[134, StackM2BR, opSETPVAR, 10];<br>regOP1[135, StackM2BR, opSETPVAR, 12];<br>regOP1[136, StackM2BR, opSETPVAR, 14];<br><br>regOP2[137, StackM2BR, opSETPVAR, noNData];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* PVARX&larr;<br><br>*--------------------------------------------------------------------<br>opSETPVARPOP:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch TSP-2<br>   T&larr; Md, TSP&larr; (fetch&larr; T) - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch TSP-1, TSP&larr; TSP-2<br>   LTEMP0&larr; (Id) + (PVAR);<br>   LEFT&larr; (LEFT) + 1, BRANCH[TL.ST0TMD];<br><br>regOP1[270, StackM2BR, opSETPVARPOP, 0];<br>regOP1[271, StackM2BR, opSETPVARPOP, 2];<br>regOP1[272, StackM2BR, opSETPVARPOP, 4];<br>regOP1[273, StackM2BR, opSETPVARPOP, 6];<br>regOP1[274, StackM2BR, opSETPVARPOP, 10];<br>regOP1[275, StackM2BR, opSETPVARPOP, 12];<br>regOP1[276, StackM2BR, opSETPVARPOP, 14];<br><br>*--------------------------------------------------------------------<br>opSETIVAR:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase;<br>   T&larr; Md, fetch&larr; T;<br>   LTEMP0&larr; (Id) + (IVAR), branch[TL.ST0TMD];<br><br>regOP2[142, StackM2BR, opSETIVAR, noNData];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* IVARX&larr;<br><br><br>*--------------------------------------------------------------------<br>opFVARgets: <br>*--------------------------------------------------------------------<br>   T&larr; (ifetch&larr; PVAR) + 1;<br>   LTEMP0&larr; Md, ifetch&larr; T;<br><br>.retrysetfvar:<br>   branch[.+2, R even], T&larr; Md, LTEMP0, memBase&larr; StackM2BR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Id, branch[.setffail];<br><br><br>*   KLUDGE</span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span class="tab" val="67"></span><span style="font: 10pt serif">* TOP BYTE IS FILLED IN TOO<br><br>   T&larr; T and (rhmask);<br>   pd&larr; T xor (StackHi);<br>   branch[.setfglobal, alu#0], TSP&larr; (fetch&larr; TSP) - 1, flipMemBase;<br>   T&larr; Md, TSP&larr; (fetch&larr; TSP) + 1, branch[TL.ST0TMD];<br><br>:if[Reduced];<br>.setfglobal:<br>   TSP&larr; (TSP) + 1, memBase&larr; StackBR, call[SUB.PUSHT];<br>   T&larr; LTEMP0, call[SUB.PUSHT];<br>   DEFLO&larr; AT.SETFVAR;<br>   NARGS &larr; 2c, branch[DOCALLPUNT];<br><br>:else;<br>.setfglobal:<br>   TSP&larr; (TSP) + 1, memBase&larr; LScratchBR, branch[.setglobal];<br>:endif;<br>   <br>.setffail:<br>   LTEMP0&larr; T, call[FVLOOKUP];<br>   T&larr; LTEMP0;<br>   T&larr; T + (PVAR);<br>   T&larr; (fetch&larr; T) + 1;<br>   LTEMP0&larr; Md, fetch&larr; T, branch[.retrysetfvar];<br><br>regOP2[143, StackBR, opFVARgets, noNData];<br><br>*--------------------------------------------------------------------<br>*   GVAR&larr;</span><span class="tab" val="67"></span><span style="font: 10pt serif"> alpha + beta form atom number of global to store TOS<br>*--------------------------------------------------------------------<br><br>:if[Reduced];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UfnOps[27];<br>:else;<br><br>opGVARgets:<br>   LTEMP0&larr; Id, memBase&larr; LScratchBR;<br>   LTEMP0&larr; LSH[LTEMP0, 10];<br>   LTEMP0&larr; ((Id) + (LTEMP0)) lsh 1;<br>   T&larr; VALspace;<br><br>.setglobal:<br>   BrLo&larr; LTEMP0;<br>   BrHi&larr; T;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (FETCH&larr; 0s) + 1;<br>   Case&larr; 1c, call[GCLOOKUP];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* deleteref old pointer<br><br>   memBase&larr; StackM2BR, branch[RPLPTRTAIL];<br><br>regOP3[27, ifuBR, opGVARgets, noNData];<br>:endif;<br><br><br>*--------------------------------------------------------------------<br>opNIL:<br>*--------------------------------------------------------------------<br>   branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  StackCheck;<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c, branch[TL.PUSHNIL];<br><br>regOP1[150, StackBR, opNIL, noNData];<br><br>*--------------------------------------------------------------------<br>opKT:<br>*--------------------------------------------------------------------<br>   branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">StackCheck;<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c, branch[TL.PUSHTRUE];<br><br>regOP1[151, StackBR, opKT, noNData];<br><br>*--------------------------------------------------------------------<br>op01SIC:<br>*--------------------------------------------------------------------<br>   branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">StackCheck;<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, TisID, NextOpCode;<br><br>regOP1[152, StackBR, op01SIC, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* &rsquo;0<br>regOP1[153, StackBR, op01SIC, 1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* &rsquo;1<br>regOP2[154, StackBR, op01SIC, noNData];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* SIC<br><br>*--------------------------------------------------------------------<br>opSNIC:<br>*--------------------------------------------------------------------<br>   T&larr; (Id) - (400c);<br>   branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">StackCheck;<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallNegHi, branch[TL.PUSHT];<br><br>regOP2[155, StackBR, opSNIC, noNData];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* SNIC<br><br>*--------------------------------------------------------------------<br>opSICX:<br>*--------------------------------------------------------------------<br>   T&larr; Id;<br>   T&larr; LSH[T,10];<br>   T&larr; Id or T, branch[PUSHSMALLT];<br><br>regOP3[156, StackBR, opSICX, noNData];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* SICX<br>regOP3[160, StackBR, opSICX, noNData];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* ATOMNUMBER<br>*--------------------------------------------------------------------<br>opACONST: <br>*--------------------------------------------------------------------<br>   T&larr; Id;<br>   T&larr; LSH[T,10];<br>   T&larr; (Id) + (T);<br>   branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">StackCheck;<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c, branch[TL.PUSHT];<br><br>regOP3[147, StackBR, opACONST, noNData];<br><br>*--------------------------------------------------------------------<br>opGCONST:<br>*--------------------------------------------------------------------<br>* push 24 bit inline constant<br>* coded as a one byte jump opcode which jumps to .+4<br><br>   LTEMP0&larr; not (PCX&rsquo;);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* current pc<br>   LTEMP0&larr; (LTEMP0) + 1;* byte# of hi byte<br>   T&larr; (LTEMP0) rsh 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* word# of hi byte<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (FETCH&larr; T) + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch it & next word<br>   branch[.GConstOdd, R even], LTEMP0, T&larr; MD, FETCH&larr; T;<br><br>.GConstEven:<br>   T&larr; T and (rhmask), branch[</span><span style="font: 10pt monospace">PUSHTMD</span><span style="font: 10pt serif">];<br><br>.GConstOdd:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* rh T,,lh Md has low word, lh T has hi word.<br>   LTEMP0&larr; MD;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   LTEMP0&larr; rcy[T, LTEMP0, 10];<br>   T&larr; rsh[T, 10], branch[PUSHT0];<br><br>IFUjmp[157, 1, ifuBR, 0, opGCONST, 4];<br><br>*--------------------------------------------------------------------<br>opCOPY:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase;<br>   T&larr; Md, fetch&larr; T, branch[</span><span style="font: 10pt monospace">PUSHTMD</span><span style="font: 10pt serif">];<br><br>regOP1[144, StackM2BR, opCOPY, noNData];<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
