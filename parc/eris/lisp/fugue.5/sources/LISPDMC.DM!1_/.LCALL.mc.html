<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>fugue.5>Sources>LISPDMC.DM!1>LCALL.mc</title>
  </head>
  <body>
    <pre>
:Title[LCALL.mc, December 7, 1982  4:38 PM, Masinter];*--------------------------------------------------------------------* Function call*--------------------------------------------------------------------   KnowRBase[LTemp0];   top level;   InsSet[LispInsSet, 1];*--------------------------------------------------------------------* UFN entries*--------------------------------------------------------------------* Utility functions; fetch defindex and arg count from UFNtable* format of table:	defindex[0:15] left word;*			nargs[8:15] right word* call UFN according to byte at PC* branched to from various placesopUFN:   T&larr; LTEMP1&larr; not(PCX'), branch[.ufnPC1];ufnPC:   GLOBAL,   T&larr; LTEMP1&larr; not(PCX'), branch[.ufnPC1];	* T, LTEMP0 &larr; current PC.ufnPC1:   LTEMP0&larr; T rsh 1;	* word address	CHECKPCX;	PAGEFAULTOK;   LTEMP0&larr; (fetch&larr; LTEMP0) + 1;	* fetch word containing current instruction   T&larr; Md, fetch&larr; LTEMP0;   branch[.ufnPCR, R odd], LTEMP1, LTEMP1&larr; Md;.ufnPCL:   LTEMP1&larr; RCY[T, LTEMP1, 10];   T&larr; RSH[T, 10], branch[.ufnPC2];.ufnPCR:   T&larr; (T) and (rhmask), branch[.ufnPC2];.ufnPC2:   memBase&larr; ufnBR, T&larr; T + T;	PAGEFAULTNOTOK;   T&larr; (fetch&larr; T) + 1;   DEFLO&larr; Md, fetch&larr; T;   NARGS&larr; Md, memBase&larr; StackBR;   T&larr; RSH[NARGS, 10];   LTEMP0&larr; BDispatch&larr; T;   NARGS&larr; (NARGS) and (rhmask), branch[.ufns];.ufns:   DISPTABLE[3],   branch[.ufnPC3];   T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[.ufnpsh1];   T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[.ufnpsh2];.ufnpsh2:   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, branch[.ufnPC3];.ufnpsh1:   LTEMP1&larr; RSH[LTEMP1, 10], branch[.ufnpsh2];.ufnPC3:   LTEMP0&larr; (LTEMP0) - (PCX'), call[FIXLEFT];   memBase&larr; StackBR, branch[.DOF1];DOCALLPUNT:		* from unbox, etc. enter with DEFLO, NARGS set   T&larr; Id, call[FIXLEFT];   T&larr; Id, memBase&larr; StackBR, branch[.DOF0];*--------------------------------------------------------------------* FN0-4 operators*--------------------------------------------------------------------opFN:   NARGS&larr; Id;   T&larr; Id;				* High bits of fnname   T&larr; LSH[T,10];   DEFLO&larr; (Id) + T;			* 16 bit function number.DOF0:   LTEMP0&larr; Id - (PCX') - 1;		* return PC	CHECKPCX;.DOF1:   T&larr; (PVAR) - (FXBACK[PC]);   store&larr; T, dbuf&larr; LTEMP0;		* store FX.pc &larr; PCRESTARTCALL0:   PSTATE&larr; T-T-1, memBase&larr; DefBR;.DOF2:   T&larr; (DEFLO) + (DEFLO);   T&larr; (FETCH&larr; T) + 1;			* CAN FAULT   LTEMP0&larr; MD, fetch&larr; T, T&larr; (rhmask);	* LTEMP0&larr; hi def   branch[.+2, R&lt;0], T&larr; Md, LTEMP0&larr; T and (LTEMP0), memBase&larr; ifuBR;	DEFHI&larr; A0, branch[.notCCODE];   BrHi&larr; LTEMP0;   LTEMP1&larr; BrLo&larr; T;				* LTEMP1&larr; fnLo   FETCH&larr; 0s;					* CAN FAULT!!!   T&larr; LSH[LTEMP0, 10];   LTEMP0&larr; (LTEMP0) + T;			* recompute fnheader   T&larr; MD, fetch&larr; 1s;   T&larr; (ESP) - T;   pd&larr; T - (TSP);				* ESP - #WORDS - TSP   branch[.+2, carry], LTEMP2&larr; Md, T&larr; (fetch&larr; 2s) + 1;	* LTEMP2&larr; def.na	DEFHI&larr; A0, branch[.fnstkov];:if[FNStats];   LTEMP3&larr; Md, fetch&larr; T, branch[.nofnstat, R&lt;0], FnStatsPtr;  * LTEMP3&larr; def.pv   PCF&larr; Md, PSTATE&larr; A0; call[FNSTAT];   branch[.afterfnstat];:else;   LTEMP3&larr; Md, fetch&larr; T;			* LTEMP3&larr; def.pv:endif;.nofnstat:   PCF&larr; Md, PSTATE&larr; A0;		* start IFU early, no faults after here.afterfnstat:* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **    KLUDGE FOR FINDING OUT WHO IS CALLED: SMASH DEF WITH BIT     **    FETCH&larr; (4S); IVAR&larr; MD;                                       **    BRANCH[.+2, R&lt;0], IVAR&larr; IVAR OR (100000C);                   **    STORE&larr; (4S), DBUF&larr; IVAR;                                     ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   T&larr; (NARGS) + (NARGS), memBase&larr; StackBR;	PCXBAD;   IVAR&larr; (TSP) - T;   T&larr; (PVAR) - (FXBACK[NEXT]);   store&larr; T, dbuf&larr; IVAR;			* store FX.next   branch[.NoAdj, R&lt;0], T&larr; LTEMP2;   T&larr; (NARGS) - T;.tryagain:   branch[.NoAdj', alu=0], pd&larr; T;   branch[.TooMany, alu&gt;0];   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;   T&larr; T+1, branch[.tryagain];.TooMany:   TSP&larr; (TSP) - (2c);   T&larr; T-1, branch[.tryagain];.NoAdj':   pd&larr; (TSP) and (2c), branch[.+2];.NoAdj:   pd&larr; (TSP) and (2c);   branch[.QuadP,  alu=0], T&larr; (store&larr; TSP) + 1, dbuf&larr; BFBlock;   T&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;   T&larr; (store&larr; T) + 1, dbuf&larr; 0c;   T&larr; (store&larr; T) + 1, dbuf&larr; (add[BFBlock!, BFPadded!]c);.QuadP:   T&larr; (store&larr; T) + 1, dbuf&larr; IVAR;		* new IVAR   T&larr; (store&larr; T) + 1, dbuf&larr; FxtnBlock;		* default flags   T&larr; (store&larr; T) + 1, dbuf&larr; PVAR;		* old PVAR   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;		* fn address hi   store&larr; T, dbuf&larr; LTEMP0;			* fn address lo   T&larr; PVAR&larr; T + (FXDIF[PVAR, DEFHI]);   dblbranch[.StorePVS, .endfn, R&gt;=0], Cnt&larr; LTEMP3;.StorePVS:   T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes;   T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes;   T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes;   T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes, dblbranch[.StorePVS, .endfn, Cnt#0&amp;-1];.endfn:   T&larr; TSP&larr; T + (4c);   T&larr; ((ESP) - T) rsh 1;   LEFT&larr; T - (LeftOffset), NextOpCode;.notCCODE:   T&larr; (TSP), memBase&larr; StackBR;   T&larr; (store&larr; T) + 1, dbuf&larr; DEFHI;   TSP&larr; (store&larr; T) + 1, dbuf&larr; DEFLO;   NARGS&larr; (NARGS) + 1;   DEFLO&larr; AT.INTERPRETER, branch[RESTARTCALL0];.fnstkov:   memBase&larr; StackBR, Call[ADDSTK];   branch[RESTARTCALL0];IFUpause[10, 3, StackBR, 0, opFN, 0, 0, 0];	*FN0IFUpause[11, 3, StackBR, 0, opFN, 1, 0, 0];	*FN1IFUpause[12, 3, StackBR, 0, opFN, 2, 0, 0];	*FN2IFUpause[13, 3, StackBR, 0, opFN, 3, 0, 0];	*FN3IFUpause[14, 3, StackBR, 0, opFN, 4, 0, 0];	*FN4*--------------------------------------------------------------------opFNX:*--------------------------------------------------------------------* Takes 3 argument bytes; first is NARGS, 2nd and 3rd are fn #.* since IFU won't handle 4 byte instructions, the first arg is* gotten from the IFU, and the fn is fetched directly. Things are* much simpler if the opcode happens to be word aligned.    NARGS&larr; Id;   DEFLO&larr; T&larr; (Id)-(PCX')-1;	* Id is length- get byte# of 3rd byte   LTEMP0&larr; T rsh 1;		* word which contains hi byte of fn	PAGEFAULTOK;   LTEMP0&larr; (FETCH&larr; LTEMP0) + 1;   branch[.+2, R odd], DEFLO&larr; MD, T&larr; T+(2c);	* T has new PC	LTEMP0&larr; T, memBase&larr; StackBR, branch[.DOF1];FNXsplit:   LTEMP0&larr; T, FETCH&larr; LTEMP0;	* save PC, fetch lo byte   memBase&larr; StackBR, T&larr; MD;	* T has lo byte of fn in hi byte	PAGEFAULTNOTOK;   DEFLO&larr; Rcy[DEFLO, T, 10], branch[.DOF1];	* and fix upIFUpause[15, 2, ifuBR, 0, opFNX, noNData, 0, 0];*--------------------------------------------------------------------opAPPLYFN:*--------------------------------------------------------------------* TOS = FN TO CALL, TOS- = NARGS   T&larr; (fetch&larr; TSP) + 1;			* fetch defhi   DEFHI&larr; Md, T&larr; (fetch&larr; T) - (3c);	* fetch deflo   DEFLO&larr; Md, T&larr; (fetch&larr; T) + 1;	* fetch narghi   T&larr; Md, fetch&larr; T, flipMemBase;   NARGS&larr; Md, pd&larr; T xor (SmallHi);   branch[.+2, alu=0], TSP&larr; (TSP) - (4c);	UCodeCheck[BadRetCall];   LTEMP0&larr; Id - (PCX') - 1;   T&larr; (PVAR) - (FXBACK[PC]);   store&larr; T, dbuf&larr; LTEMP0;   PSTATE&larr; T-T-1, memBase&larr; DefBR;   pd&larr; DEFHI;   branch[.+2, alu=0];	branch[.notCCODE];   branch[.DOF2];IFUpause[16, 1, StackM2BR, 0, opAPPLYFN, NoNData, 0, 0];	*APPLYFN:if[Reduced];	UfnOps[17];:else;*--------------------------------------------------------------------opCKAPPLY:*--------------------------------------------------------------------* TOS = FN TO CALL   T&larr; (fetch&larr; TSP) + 1;	   LTEMP0&larr; Md, fetch&larr; T;		* hiloc   T&larr; Md, memBase&larr; DefBR, pd&larr; LTEMP0;   branch[.+2, alu=0], T&larr; T + T;   	CallUFN;			* not litatom	PAGEFAULTOK;   FETCH&larr; T;   LTEMP0&larr; MD;	PAGEFAULTNOTOK;   branch[.+2, R&lt;0], pd&larr; (LTEMP0) and (20000c);	CallUFN;			* not CCODEP   branch[.+2, alu=0];   	CallUFN;	* not argtype=0, 2   NextOpCode;regOP1[17, StackM2BR, opCKAPPLY, NoNData];	*CKAPPLY:endif;</pre>
  </body>
</html>
