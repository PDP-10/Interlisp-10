<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>fugue.5>Sources>LISPDMC.DM!1>LISPDEFS.mc</title>
  </head>
  <body>
    <div style="width: 489pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:Title[LISPDEFS.mc, July 9, 1983  11:32 AM, Masinter];<br>:insert[LParams.mc];<br>set[Debugging, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0 means NOT debugging, 1 means debugging<br>set[DebugEachInst, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1 means execute stuff at end of each inst<br>set[BreakPoints, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* debugging with midas<br>set[FNStats, sub[1,Debugging]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* can gather function stats unless debugging<br>set[UPCStats, sub[1,Debugging]]; * can gather microcode pc stats unless debugging<br>set[Reduced,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* reduced instruction set<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">set[NOFLOATING, Reduced];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">set[NOBIN, Reduced];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">set[NOCREATECELL, Reduced];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">set[NORPLACS, Reduced];<br>*--------------------------------------------------------------------<br>* version numbers - VERSION PILOTBITBLT + 0<br>*--------------------------------------------------------------------<br>set[RamVersion, add[10412, Debugging]];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* version number (+ 1 if debugging)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fix StampD1uCode.cm when these change<br>set[RamMinBcplVersion, 21000];<br>set[RamMinLispVersion, 106400];<br><br><br>* check against values imported from LPARAMS.dmc<br><br>IFG[MinRamVersion!,RamVersion,ER[RamVersionTooLow]];<br>IFG[MinBcplVersion!,RamMinBcplVersion,set[RamMinBcplVersion,MinBcplVersion!]];<br>IFG[RamMinLispVersion, LispVersion!, ER[LispVersionTooLow]];<br><br>*--------------------------------------------------------------------<br>* RM regions<br>*--------------------------------------------------------------------<br>   SetRMRegion[RMForIFU];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Lisp Emulator Registers<br><br>rvn[ESP];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">next stack block<br>rvn[FNStatsPtr];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">pointer to fn stat buffer<br>rvn[AllOnes];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 2    always -1 (not used much)<br>rvn[PSTATE];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 3<br>rvn[NARGS];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 4</span><span class="tab" val="67"></span><span style="font: 10pt serif">#args<br>rvn[DEFHI];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 5</span><span class="tab" val="67"></span><span style="font: 10pt serif">virtual address of function called<br>rvn[DEFLO];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 6<br>rvn[TSP];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 7</span><span class="tab" val="67"></span><span style="font: 10pt serif">pointer to next available stack region<br>rvn[IVAR];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 10</span><span class="tab" val="67"></span><span style="font: 10pt serif">pointer to current IVAR area<br>rvn[LEFT];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 11</span><span class="tab" val="67"></span><span style="font: 10pt serif">number of (double words) of stack left<br>rvn[PVAR];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 12</span><span class="tab" val="67"></span><span style="font: 10pt serif">pointer to current PVAR area<br>rvn[LTEMP4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 13<br>rvn[LTEMP3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 14<br>rvn[LTEMP2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 15<br>rvn[LTEMP1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 16</span><span class="tab" val="67"></span><span style="font: 10pt serif">= DivTemp2<br>rvn[LTEMP0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 17</span><span class="tab" val="67"></span><span style="font: 10pt serif">= MulTemp, DivTemp1<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rme[DivTemp1, LTEMP0];   <br><br>* for GC<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rme[PROBE, NARGS];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rme[CASE, DEFHI];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rme[ENTRY, DEFLO];<br><br>SetRMRegion[Region14]; <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[InstCount];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[InstBreak];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[RANDNUM];<br><br>* REGISTER CONVENTIONS:<br>*  at "safe" points (i.e., after every opcode, whenever a page fault<br>*  can occur, and whenever a punt can occur,<br>*  the following conventions<br>*  hold:<br><br>*  TSP   points to the left word of the next slot in the current stack<br>*  ESP   points to the first (left) word of the next stack block<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif"> (i.e., tsp1+1 = esp means stack is empty)<br>*  PSTATE is 0 normally: -1 means in call, 1 (if debugging) means PCX is <br>* invalid, 2 means that a page fault is ok<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[PS.HTCNTFULL, 20];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[PS.HTOVERFLOW, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[PS.INBCPL, 4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[PS.PFOK, 2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[PS.PCXBAD, 1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[PS.INBITBLT, 40];<br><br>*   In addition, between opcodes, <br>*   Left = (((ESP)-(TSP)) rsh 1) - LeftOffset;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[LeftOffset, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[MyFrameOffset, 100];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[BfPadded, 400];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[BfResidual, 1000];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FXFastReturn, 4000];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FXInCall, 2000];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FXNTValid, 1000];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FXNoPushReturn, 400];<br><br>* FX Fields:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.BFLAGS, -2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.IVAR, -1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.FLAGS, 0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.ALINK, 1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.DEFLO, 2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.DEFHI, 3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.NEXT, 4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.PC, 5];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.NTLO, 6];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.NTHI, 7];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.BLINK, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.CLINK, 11];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FX.PVAR, 12];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[FXDIF, sub[FX.#1!, FX.#2!]c];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[FXBACK, sub[FX.PVAR!, FX.#1!]c];<br><br>* FNHEADER fields<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FNH.STK, 0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FNH.NA, 1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FNH.PV, 2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FNH.START, 3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FNH.NTSIZE, 6];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FNH.NLFV, 7];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[FNH.FIRSTNAME, 10];<br><br>*  DTD fields<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[DTD.NAME, 0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[DTD.SIZE, 1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[DTD.FREE, 2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[DTD.COUNTER, 14];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[DTD.NEXTPAGE, 15];<br><br>*--------------------------------------------------------------------<br>* Base Registers<br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">brx[StackBR, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* beginning of stack<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">brx[StackM2BR, 1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* StackBR-2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">brx[ScratchLZBR, 2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BrLo= 0<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">brx[unused, 3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* <br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[DefBR, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* beginning of Def space<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[dtdBR, 5];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* pointer to DTD space<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[ufnBR, 6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* UFN table<br> </span><span class="tab" val="67"></span><span style="font: 10pt serif">br[ListpDTDBR, 7];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* pointer to LISTP&rsquo;s DTD<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[tybaseBR, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* MDS type table<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[ZeroBR, 11];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* always zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[interfaceBR, 12];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* points to interface page<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[BBTableBR, 13];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* pointer to bitblt table<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[, 14];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* unused<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[, 15];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* unused<br><br>* the following must be an even-odd pair<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[htMainBR, 16];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* GC main reference count table<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[htOfloBR, 17];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* GC overflow table<br><br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[AChannelBR, 20];<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[TChannelBR, 21];   <br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[BBDstBR, 22];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BitBlt destination base register<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[BBSrcBR, 23];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BitBlt source base register<br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[BChannelBR, 24];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* used by display<br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[Page1BR, 25];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* {mds, 400b},<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[ScratchBR, 26];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* general-purpose scratch register<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[PCHistBR, 27];<br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[DiskBR, 30];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Disk task base register<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[ECBR, 31];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Ethernet Command base register<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[EIBR, 32];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Ethernet Input base register<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">br[EOBR, 33];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Ethernet Output base register<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[LScratchBR, 34];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Lisp scratch register<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[ValSpaceBR, 35];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* point to value space<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[MDS, 36];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* {mds, 0} for Alto and Mesa<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">br[ifuBR, 37];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* code base (used by IFU)<br><br>*--------------------------------------------------------------------<br>* Various constants<br>*--------------------------------------------------------------------<br><br>* RESERVED ATOM NUMBERS<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.NIL, 0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.NOBIND, 1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.T, 114];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.EVALFORM, 370];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.GCSCAN, 371];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.MAKENUMBER, 374];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.SETFVAR, 376];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.GCOVERFLOW, 377];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.INTERPRETER, 400];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AT.MAKEFLOAT, 401];<br><br>* for GC<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[htStkCnt, add[htstkbit!, htcntmask!]];<br><br><br>* number spaces:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[SmallHi, smallpl!];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[SmallNegHi, smallneg!];<br><br><br>* other random things<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[MaxConsCount, 10000];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[StackEmpty, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Stkp for Stack Empty<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[rhmask, 377];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[lhmask, 177400];<br><br>* bcpl communication area<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[StatsBufferPtr, 200];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[StatsBufferBoundary, 1400];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[AemuRestartLoc, 206];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[SubrArgArea, 210];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[CALL.EVENT, 140000];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* hi pointer for a fn call<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[RETURN.EVENT, 177400];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* hi pointer for a return<br>*--------------------------------------------------------------------<br>* IFU definitions<br>*--------------------------------------------------------------------<br><br>:if[DebugEachInst];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[NextOpCode, branch[NextOp]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* go check stack<br>:else;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[NextOpCode, ifujump[0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* dispatch to next instruction<br>:endif;<br><br><br>:if[Debugging];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[PAGEFAULTOK, PSTATE&larr; (PSTATE) or (PS.PFOK)];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[PAGEFAULTNOTOK, PSTATE&larr; (PSTATE) and (not[PS.PFOK!]c)];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[PCXBAD, PSTATE&larr; (PSTATE) or (PS.PCXBAD)];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[CHECKPCX, call[CHECKPCXSUBR]];<br>:else;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[PAGEFAULTOK,];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[PAGEFAULTNOTOK,];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[PCXBAD,];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[CHECKPCX,];<br><br>:endif;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[NoNdata, 17];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* no encoded data in IFU<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[regOP1, ifuREG[#1, 1, #2, 0, #3, #4, 0, 0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* reg. 1 byte <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[regOP2, ifuREG[#1, 2, #2, 0, #3, #4, 0, 0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* reg. 2 byte <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">m[regOP3, ifuREG[#1, 3, #2, 0, #3, #4, 0, 0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* reg. 3 byte <br><br>* ufn opcode - no microcode<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">M[UfnOps, IFUpause[#1, 1, ifuBR, 0, opUFN, NoNData, 0, 0]];<br><br>   Set[LispInsSet, 1];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">M[CallUFN, branch[ufnPC] memBase&larr; ifuBR];<br><br>:if[breakpoints];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">M[StackCheck, (Breakpoint) (RESCHEDULE)];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">M[UCodeCheck, (Breakpoint) branch[UCODECHECKPUNT]];<br><br>:else;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">M[StackCheck, RESCHEDULE];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">M[UCodeCheck, branch[UCODECHECKPUNT]];<br><br>:endif;<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
