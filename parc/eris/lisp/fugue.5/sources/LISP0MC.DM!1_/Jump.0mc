:TITLE[Jump.mc...June 21, 1982  9:36 PM, van Melle];* A few more instructions can be removed by putting the jump distance*  directly into lspLN and doing the pfetch sooner.* NILPOP can be expanded.* The only use of the stack is in NILPOP.Jumps:	T _ 1c, goto[lspDojump], opcode[200];	T _ 2c, goto[lspDojump], opcode[201];	T _ 3c, goto[lspDojump], opcode[202];	T _ 4c, goto[lspDojump], opcode[203];	T _ 5c, goto[lspDojump], opcode[204];	T _ 6c, goto[lspDojump], opcode[205];	T _ 7c, goto[lspDojump], opcode[206];	T _ 10c, goto[lspDojump], opcode[207];	T _ 11c, goto[lspDojump], opcode[210];	T _ 12c, goto[lspDojump], opcode[211];	T _ 13c, goto[lspDojump], opcode[212];	T _ 14c, goto[lspDojump], opcode[213];	T _ 15c, goto[lspDojump], opcode[214];	T _ 16c, goto[lspDojump], opcode[215];	T _ 17c, goto[lspDojump], opcode[216];	T _ 20c, goto[lspDojump], opcode[217];Fjumps:	T _ 1c, goto[lspFjump], opcode[220];	T _ 2c, goto[lspFjump], opcode[221];	T _ 3c, goto[lspFjump], opcode[222];	T _ 4c, goto[lspFjump], opcode[223];	T _ 5c, goto[lspFjump], opcode[224];	T _ 6c, goto[lspFjump], opcode[225];	T _ 7c, goto[lspFjump], opcode[226];	T _ 10c, goto[lspFjump], opcode[227];	T _ 11c, goto[lspFjump], opcode[230];	T _ 12c, goto[lspFjump], opcode[231];	T _ 13c, goto[lspFjump], opcode[232];	T _ 14c, goto[lspFjump], opcode[233];	T _ 15c, goto[lspFjump], opcode[234];	T _ 16c, goto[lspFjump], opcode[235];	T _ 17c, goto[lspFjump], opcode[236];	T _ 20c, goto[lspFjump], opcode[237];Tjumps:	T _ 1c, goto[lspTJump], opcode[240];	T _ 2c, goto[lspTJump], opcode[241];	T _ 3c, goto[lspTJump], opcode[242];	T _ 4c, goto[lspTJump], opcode[243];	T _ 5c, goto[lspTJump], opcode[244];	T _ 6c, goto[lspTJump], opcode[245];	T _ 7c, goto[lspTJump], opcode[246];	T _ 10c, goto[lspTJump], opcode[247];	T _ 11c, goto[lspTJump], opcode[250];	T _ 12c, goto[lspTJump], opcode[251];	T _ 13c, goto[lspTJump], opcode[252];	T _ 14c, goto[lspTJump], opcode[253];	T _ 15c, goto[lspTJump], opcode[254];	T _ 16c, goto[lspTJump], opcode[255];	T _ 17c, goto[lspTJump], opcode[256];	T _ 20c, goto[lspTJump], opcode[257];@FJumpx:*	nop, opcode[262];	T _ NextData[IBuf], opcode[262];	T _ (Form-2[AllOnes]) + T, skip[noH2bit8];	* T_T-2	T _ (lhmask[AllOnes]) + T;			* Signextend TlspFJump:	lspLN _ T, call[lspNilpop];	T _ lspLN, skip[alu=0];			* Skip if TOS = NIL	  goto[PopChk6];	goto[lspDojumpPop];@TJumpx:*	nop, opcode[263];	T _ NextData[IBuf], opcode[263];	T _ (Form-2[AllOnes]) + T, skip[noH2bit8];	T _ (lhmask[AllOnes]) + T;lspTJump:	lspLN _ T, call[lspNilpop];	T _ lspLN, skip[alu#0];			* Skip if TOS # NIL	  goto[PopChk6];	goto[lspDojumpPop];@Jumpx:*	nop, opcode[260];			* Unconditional jump	T _ NextData[IBuf], opcode[260];	T _ (Form-2[AllOnes]) + T, skip[noH2bit8];	T _ (lhmask[AllOnes]) + T, goto[lspDojump];	goto[lspDojump];@NFJumpx:*	nop, opcode[264];		* Jump if TOS = NIL, pop if no branch	T _ NextData[IBuf], opcode[264]; * Jump if TOS = NIL, pop if no branch	T _ (Form-2[AllOnes]) + T, skip[noH2bit8];	T _ (lhmask[AllOnes]) + T;	call[lspNilpop], lspLN _ T;	skip[alu=0], T _ lspLN;	  goto[PopChk6];	Stack&+2, goto[lspDojump];@NTJumpx:*	nop, opcode[265];		* Jump if TOS # NIL, pop if no branch	T _ NextData[IBuf], opcode[265]; * Jump if TOS # NIL, pop if no branch	T _ (Form-2[AllOnes]) + T, skip[noH2bit8];	T _ (lhmask[AllOnes]) + T;	call[lspNilpop], lspLN _ T;	skip[alu#0], T _ lspLN;	  goto[PopChk6];	Stack&+2, goto[lspDojump];@Jumpxx:*	nop, opcode[261];		* Jump offset in alpha,beta	T _ NextData[IBuf], opcode[261];	* Jump offset in alpha,beta	lspLN _ T;	T _ 3c;	T _ (NextData[IBuf]) - T;	T _ (lsh[lspLN, 10]) + T, goto[lspDojump];lspNilpop:	T _ Stack&-1, useCtask;		* No task, because alu result tested	T _ (Stack&-1) or T, return;lspDojump:	T _ (PCFReg) + T;	lspLN _ T, goto[AddIlx1, alu>=0];	T _ 100000c;	T _ (rsh[lspLN, 1]) or T, goto[AddIlx2];AddIlx1:	T _ rsh[lspLN, 1];AddIlx2:	PFetch4[PCB, IBuf];		* See comment in FETCH.0mc	PCB _ T;	PCF _ lspLN;	PCB _ (PCB) and not (3c), goto[lspNextInstP6];				* Fault will happen right after this instlspDojumpPop:	T _ (PCFReg) + T;	lspLN _ T, goto[AddIlx3, alu>=0];	T _ 100000c;	T _ (rsh[lspLN, 1]) or T, goto[AddIlx4];AddIlx3:	T _ rsh[lspLN, 1];AddIlx4:	PFetch4[PCB, IBuf];		* See comment in FETCH.0mc	PCB _ T;	PCF _ lspLN;	PCB _ (PCB) and not (3c), goto[PopChk6];				* Fault will happen right after this inst	:END[Jump];