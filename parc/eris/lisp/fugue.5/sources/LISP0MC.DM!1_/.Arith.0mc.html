<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>fugue.5>Sources>LISP0MC.DM!1>Arith.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Arith.0mc...September 13, 1982  3:37 PM, van Melle];* LLSH1, op 340:* Replace TOS with it shifted left one, aborts to UFN on overlow@LLSH1:	call[CheckSmallp], lspUFN &larr; 340c, opcode[340];		* Ufn index	T &larr; lsh[Stack, 1], dblgoto[lshFails, lshGetsT, R&lt;0];lshGetsT:	Stack &larr; T, goto[nxiLBL];lshFails:	goto[ufnLBL];* LLSH8, op 341, Replace TOS with it shifted left 8, abort on overflow@LLSH8:	call[CheckSmallp], lspUFN &larr; 341c, opcode[341];	lu &larr; lhmask[Stack];	T &larr; lsh[Stack, 10], dblgoto[lshFails, lshGetsT, alu#0];* LRSH1, op 342, Replace TOS with it shifted right one@LRSH1:	call[CheckSmallp], lspUFN &larr; 342c, opcode[342];	Stack &larr; rsh[Stack, 1], goto[nxiLBL];* LRSH8, op 343, Replace TOS with it shifted right 8@LRSH8:	call[CheckSmallp], lspUFN &larr; 343c, opcode[343];	Stack &larr; rsh[Stack, 10], goto[nxiLBL];* Smallpos unbox* returns TOS in T as integer if it is smallposp, punts otherwise	onpage[pgArithOps];CheckSmallp:	T &larr; Stack&amp;-1;	lu &larr; (Stack&amp;+1) xor (smallpl);	skip[alu=0];	  goto[ufnLBL];lspRetP7:	return;* Two arg arithmetic opcodes.  These all go to Unbox to unbox TOS-1 and TOS* into Int1Hi/Lo and Int2Hi/Lo, then come back here by dispatching thru lspUFN* For compactness, UFN encodes two 4 bit fields:* &lt;low 4 bits of opcode&gt;,,&lt;function&gt;* where &lt;function&gt; provides a (up to) 16-way dispatch on logical function,* and the low 2 bits are a 4-way dispatch on the possible hi 4 bits of opcode* (320, 340, 360, with 320 twice).M@[ArithOp, Or[LShift[And[#1,17],4], #2]];	* ArithOp[opcode, fn]RV2[Int1Hi, Int1Lo, IP[AC0]];RV2[Int2Hi, Int2Lo, IP[lspL2]];* Logical ops.  No overflow.  Low 2 bits = 1@Logor2:	goto[Unbox], lspUFN &larr; ArithOp[344,1]c, opcode[344];	Int1Lo &larr; (Int1Lo) or T, at[ArithDisp, 1];	T &larr; Int2Hi;	Int1Hi &larr; (Int1Hi) or T, goto[IntBoxEasy];@Logand2:	goto[Unbox], lspUFN &larr; ArithOp[345,5]c, opcode[345];	Int1Lo &larr; (Int1Lo) and T, at[ArithDisp, 5];	T &larr; Int2Hi;	Int1Hi &larr; (Int1Hi) and T, goto[IntBoxEasy];@Logxor2:	goto[Unbox], lspUFN &larr; ArithOp[346,11]c, opcode[346];	Int1Lo &larr; (Int1Lo) xor T, at[ArithDisp, 11];	T &larr; Int2Hi;	Int1Hi &larr; (Int1Hi) xor T, goto[IntBoxEasy];* IGREATERP, op 361; GREATERP, op 363@IGTRP:	goto[Unbox], lspUFN &larr; ArithOp[361,6]c, opcode[361];	* IGREATERP	goto[Unbox], lspUFN &larr; ArithOp[363,6]c, opcode[363];	* GREATERP**	Want to see if L0,1 &gt; L2,3.  Do this by subtracting L2,3 - L0,1*	and testing Carry'.*	Int2Hi &larr; (Int2Hi) xor (100000c), at[ArithDisp, 6];						* complement sign bits	T &larr; (Int1Hi) xor (100000c);		* so compare comes out right	lu &larr; (Int2Hi) - T;			* Compare hi halves	T &larr; Int1Lo, FreezeResult, skip[alu=0];	  Stack&amp;-1 &larr; 0c, dblgoto[Igt, Ilt, No Carry];	lu &larr; (Int2Lo) - T;			* if hi equal, compare lo	Stack&amp;-1 &larr; 0c, dblgoto[Igt, Ilt, No Carry];Ilt:	Stack&amp;+1 &larr; 0c, goto[ArithExit];Igt:	Stack&amp;+1 &larr; (KtVal), goto[ArithExit];* Arithmetic Ops.  Overflow possible.  Low 2 bits = 0@IPLUS2:	goto[Unbox], lspUFN &larr; ArithOp[330,0]c, opcode[330];	* IPLUS2	goto[Unbox], lspUFN &larr; ArithOp[324,0]c, opcode[324];	* PLUS2ArithOps:	Int1Lo &larr; (Int1Lo) + T, at[ArithDisp, 0];	T &larr; Int2Hi, FreezeResult;	Int1Hi &larr; (Int1Hi) + T, UseCoutasCin, goto[IntBox];@IDIFFERENCE:	goto[Unbox], lspUFN &larr; ArithOp[331,4]c, opcode[331];	* IDIFFERENCE	goto[Unbox], lspUFN &larr; ArithOp[325,4]c, opcode[325];	* DIFFERENCE	Int1Lo &larr; (Int1Lo) - T, at[ArithDisp, 4];	T &larr; Int2Hi, FreezeResult;	Int1Hi &larr; (Int1Hi) - T, UseCoutasCin, goto[IntBox];@BOXIPLUS:	goto[Unbox], lspUFN &larr; ArithOp[366,2]c, opcode[366];	Int1Lo &larr; (Int1Lo) + T, at[ArithDisp, 2];	T &larr; Int2Hi, FreezeResult;	Int1Hi &larr; (Int1Hi) + T, UseCoutasCin, goto[StuffBox];@BOXIDIFFERENCE:	goto[Unbox], lspUFN &larr; ArithOp[367,12]c, opcode[367];	Int1Lo &larr; (Int1Lo) - T, at[ArithDisp, 12];	T &larr; Int2Hi, FreezeResult;	Int1Hi &larr; (Int1Hi) - T, UseCoutasCin, goto[StuffBox];StuffBox:	* Check that first arg is large (Unbox set sign bit if so)	lspUFN, skip[R&lt;0];	  goto[ArithUfn];	PStore2[XBuf2, Int1Hi, 0], goto[ArithExit];				* any fault here has already happened@MAKENUMBER:	lspUFN &larr; 365c, goto[lspUfnxP7], opcode[365];	* MakeNumber* ITIMES2, op 332; TIMES2, op 326* This assumes that the hi words are 0 @ITIMES2:	goto[Unbox], lspUFN &larr; ArithOp[332,10]c, opcode[332];	* ITIMES2	goto[Unbox], lspUFN &larr; ArithOp[326,10]c, opcode[326];	* TIMES2*	Algorithm taken from Fiala's alto microcode:*	On each iteration, shift L0,1 right by one, testing the multiplier*	bits as they fall out the right.  For each 1 bit, add multiplicand*	into L0.  Shifting L0,1 right is thus analogous to shifting the*	multiplicand left (but much easier).  Double-length result is* 	left in L0,1 when last multiplier bit is shifted out* Loop time: 8 to 9 cycles on multiplier zeroes, 13 to 15 on multiplier ones	T &larr; Int1Hi, at[ArithDisp, 10];		* check that hi words are zero	lu &larr; (Int2Hi) or T;	T &larr; Int2Lo, goto[MulPunta, alu#0];	* T &larr; multiplicand	lspL4 &larr; 16c;				* set loop counter [even loc]	call[MulLoop1];				* allocation constraintMulLoop:	lspL4 &larr; (lspL4) - 1, GoTo[MulDone, R&lt;0];MulLoop1:	Int1Lo &larr; RSh[Int1Lo,1], Skip[R Odd];	* shift out a multiplier bit	  Int1Hi &larr; RSh[Int1Hi,1], DblGoTo[Mula,Mulb,R Odd];	* no add	Int1Hi &larr; (Int1Hi) + T;			* mpr bit=1, do add	Int1Hi &larr; RCy[Int1Hi,1], Skip[Carry];	* cycle right, saving low bit						* as sign bit for one mi	  Int1Hi &larr; (Int1Hi) and not (100000C), DblGoTo[Mula,Mulb,ALU&lt;0];					* no carry, so sign bit is off	Int1Hi &larr; (Int1Hi) or (100000C), DblGoTo[Mula,Mulb,ALU&lt;0];					* carry, or it into signMula:	Int1Lo &larr; (Int1Lo) or (100000C), Return;	* or lowbit of L0 into signMulb:	Return;					* lowbit of L0 was 0MulDone:	lu &larr; Int1Hi, goto[IntBoxEasy, R&gt;=0];	* Box the result	  goto[ArithUfn];			* OverflowMulPunta: goto[ArithUfn];			* not smallpos*smallpos%  Old version	lu&larr; (Int1Hi), at[ArithDisp, 5];	lu&larr; (Int2Hi), goto[ITimes5, alu#0]; 	goto[ITimes6, alu#0];		* allocation constraint	T &larr; (Int2Lo);	lspL4&larr; (0c), call[.+1];	Int1Lo &larr; rsh[Int1Lo, 1], goto[Itimes1, ROdd];	goto[ItimesDN, alu=0];ITimes3:	T &larr; Int2Lo&larr; lsh[Int2Lo, 1], goto[Itimes4, R&lt;0];	return;ITimes1:	lspL4&larr; (lspL4) + T;	goto[ITimes2, carry];	goto[ITimes3];ITimes2: goto[ArithUfn];ITimes4: goto[ArithUfn];ITimes5: goto[ArithUfn];ITimes6: goto[ArithUfn];ITimesDN:	T &larr; lspL4;	Int1Lo &larr; T;	T &larr; Int2Hi;	Int1Hi &larr; (Int1Hi) xor T, goto[IntBoxEasy];%* IQUOTIENT, IREMAINDER, ops 333, 334; QUOTIENT, op 327@IQuotient:	goto[Unbox], lspUFN &larr; ArithOp[333,14]c, opcode[333];	* IQuotient@IRemainder:	goto[Unbox], lspUFN &larr; ArithOp[334,13]c, opcode[334];	* IRemainder	goto[Unbox], lspUFN &larr; ArithOp[327,14]c, opcode[327];	* Quotient* Divide L0,,L1 by L3, quotient in L1, remainder in L0* Punt if dividend is negative, divisor is not small, or result is not small* The compact inner loop here is taken from Fiala's alto microcode*	goto[retDiv], at[ArithDisp, 13];retDiv:	T &larr; Int2Hi, at[ArithDisp, 14];		* get hi divisor	lu &larr; (ldf[Int1Hi, 0, 1]) or T;		* and check sign of dividend	T &larr; Int2Lo, goto[DivPunta, alu#0];	* punt if either bad	lu &larr; (Int1Hi) - T;					* compare hi dividend : divisor	lspL4 &larr; 16c, goto[DivPuntc, Carry];				* punt if L0 ge L3, i.e. result is large				* note this is true if zero divisor, too	T &larr; 31c;	SALUF &larr; T, T &larr; Int2Lo;			* SALUF &larr; A+A+Cy1	Int2Hi &larr; (Zero) - T;			* L2 &larr; -(divisor)* Algorithm: shift L0,1 left one, subtracting divisor from L0.  If* subtraction succeeds, shift a 1 quotient bit in on the right of L1, else* zero.  The instruction at DivLoop shifts L0 and subtracts L3 at the* same time; the instruction at DivRet has set T the negation of the divisor* plus the sign bit shifted out of L1 in the previous instruction.  The -1* at DivRet and the +1 at DivLoop cancel each other, but makes the carry* come out right for divisor 1 or 177777.* Loop time: 9 cycles for quotient 1's, 12 for quotient 0's* Setting up before the loop, L1 gets a "don't care" 1 bit shifted in on* the right, which will be shifted out the top on the last iteration.	Int1Lo &larr; (Int1Lo) SALUFOP T, Call[DivRet];DivLoop:		* Shift hi dividend left, subtracting divisor	Int1Hi &larr; (LSh[Int1Hi,1]) + T + 1, Skip[R&gt;=0];			* Shift low dividend, bringing in quotient bit 1	  Int1Lo &larr; (Int1Lo) SALUFOP T, GoTo[DivSub];			* Shift low dividend, bringing in quotient bit = 1			* if subtract carried (hi dividend was ge divisor)	Int1Lo &larr; (Int1Lo) SALUFOP T, UseCOutAsCIn, GoTo[DivSub,Carry];*Subtract failed.  Undo it, lovingly preserving the carry bit down to DivRet.	T &larr; Int2Lo, FreezeResult;	Int1Hi &larr; (Int1Hi) + T, FreezeResult;DivSub:			* decrement loop counter, quit if done	lspL4 &larr; (lspL4) - 1, FreezeResult, goto[DivDone, R&lt;0];DivRet:			* T &larr; -(divisor) + (old sign bit of L1) - 1	T &larr; (Int2Hi) - 1, UseCOutAsCIn, Return;		* return to DivLoopDivDone:				* push result (a smallp) on stack	lspUFN, skip[R Odd];		* which case was it?	  T &larr; Int1Lo, goto[BoxSmallPl];	* even, get quotient	  T &larr; Int1Hi, goto[BoxSmallPl];	* odd, get remainderDivPunta: goto[ArithUfn];DivPuntc: goto[ArithUfn];	onpage[pgArithOps];* Main unboxing routine.  Put TOS into Int2Hi/Lo, TOS-1 into Int1Hi/Lo.* Punt if necessary.  Return thru Arithops dispatch with T = L3.* Cycles thru final disp: 10 + 2 unboxes + upto 6 cycles if Int1 interlocks* for large Int1Hi/Lo.  Unbox time: 11/Smallpos, 10/SmallNeg, 60/largepUnbox:	loadpage[pgHStack], call[CheckElt2P7];	T &larr; Stack&amp;-1, loadpage[pgArith];	Int2Lo &larr; T;onpage[pgArith];	lu &larr; (Stack) xor (smallNeg);	lu &larr; (Stack&amp;-1) xor (smallpl), skip[alu#0];	  Int2Hi &larr; (Zero) - 1, goto[UnBoxTopDone];	Int2Hi &larr; 0c, goto[UnBoxTopDone, alu=0];	Stack&amp;+2, call[UnboxType];	PFetch2[XBuf2, Int2Hi, 0], goto[UnBoxTopDone];UnBoxTopDone:	T &larr; Stack&amp;-1;	Int1Lo &larr; T;	lu &larr; (Stack) xor (smallNeg);	lu &larr; (Stack&amp;+1) xor (smallpl), skip[alu#0];	  Int1Hi &larr; (Zero) - 1, goto[UnBoxBotDone];	Int1Hi &larr; 0c, goto[UnBoxBotDone, alu=0];	lspUFN &larr; (lspUFN) or (100000c), call[UnboxType];	PFetch2[XBuf2, Int1Hi, 0];	Stack&amp;+2, goto[UnBoxBotDone];UnBoxBotDone:	dispatch[lspUFN, 14, 4];	T &larr; Int2Lo, disp[ArithOps];UnboxType:		* Pop TOS into XBuf2,3 as basereg, punt if not fixp	T &larr; Stack&amp;-1;	XBuf2 &larr; T;	T &larr; lsh[Stack&amp;-1, 10];	XBuf3 &larr; T;	T &larr; rsh[XBuf2, 11];	T &larr; (rsh[XBuf3, 1]) or T;	PFetch1[MDSTypeBaseBr, lspType];	T &larr; (fixpType);			* Doesn't save space, but time	lu &larr; (rhmask[lspType]) xor T;	skip[alu=0];	  goto[ArithUfn];	return;onpage[pgArith];* Come here to box result.  Alu = Int1Hi at IntBoxEasy, BoxCheckIntBox:					* check for overflow before boxing	T &larr; Int1Lo, skip[no ovf];	* T &larr; lo half of result	  goto[ArithUfn];	lu &larr; Int1Hi, goto[BoxCheck];IntBoxEasy:				* Here if no overflow possible	T &larr; Int1Lo, FreezeResult, goto[BoxCheck];BoxCheck:	* Check for smallpos (Int1Hi = 0) and smallneg (Int1Hi = -1)	lu &larr; (Int1Hi) + 1, goto[BoxSmallpl, alu=0];	lspNargs &larr; 2c, goto[BoxSmallneg, alu=0];:IF[WithCreateCell];BoxBig:	loadpage[opPage0];		* Create a new fixp cell	qBuf &larr; lshift[fixpType!, 4]c, callp[DoCreateCell];	PStore2[lspGenBr, Int1Hi, 0];	* Can't fault now	loadpage[pgRplPtr];	StkState &larr; rsh[StkState, 1], gotop[GcExit];:ELSE;BoxBig:	* Box big result by pushing halves as smallps and calling Makenumber	Stack&amp;-1 &larr; (smallpl);	T &larr; Int1Hi;	Stack&amp;+1 &larr; T;	Stack&amp;+1 &larr; (smallpl);	T &larr; Int1Lo;	Stack&amp;+1 &larr; T, loadpage[pgFrame];	lspDefx1 &larr; (MakeNumber), goto[lspCallFn0];:ENDIF;BoxSmallPl:	Stack&amp;-1 &larr; (smallpl), goto[box1];BoxSmallneg:	Stack&amp;-1 &larr; (smallNeg), goto[box1];box1:	Stack&amp;+1 &larr; T;ArithExit:	StkState &larr; rsh[StkState, 1], goto[nxiLBL];* Punt here: Dispatch lspUFN thru a table of ufns* Low 2 bits selects the appropriate hi 4 bitsArithUfn:	dispatch[lspUFN, 16, 2];	lspUFN &larr; ldf[lspUFN, 10, 4], disp[.+1];	lspUFN &larr; (lspUFN) or (320c), goto[ufnLBL], disptable[4];	* 00	lspUFN &larr; (lspUFN) or (340c), goto[ufnLBL];			* 01	lspUFN &larr; (lspUFN) or (360c), goto[ufnLBL];			* 10	lspUFN &larr; (lspUFN) or (320c), goto[ufnLBL];			* 11% Dispatches are set as follows:op	  code	disp			op	  code	dispIPLUS2    330	0			LOGOR	  344	1 PLUS2    324	0IDIFFRNCE 331	4			LOGAND	  345	5 DIFFRNCE 325	4ITIMES    332	10			LOGXOR	  346	11 TIMES    326	10IQUOTIENT 333	14			 ---		15 QUOTIENT 327	14BOXIPLUS  366	2			 ---		3IGREATERP 361	6			 ---		7 GREATERP 363	6BOXIDIFF  367	12			IREMAINDER 334	13 ---		16			 ---		17%	:END[Arith];</pre>
  </body>
</html>
