<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>fugue.5>Sources>LISP0MC.DM!1>Return.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Return.0mc, August 12, 1982  3:10 PM, van Melle];* Things to do when returning from one frame to its caller:* 	Free my FX* 	Free my BF, if I am its sole user** Ordinarily, the caller, my BF and my FX are contiguous and all usecounts* are zero.  In this case, all I have to do is turn my BF/FX into a big* free block and set up to resume execution in the caller.* It is this case that we optimize for.* If things are at all out of the ordinary, my slow return flag is on.@Return:	T &larr; (lspEp) - (11c), opcode[020];	PFetch1[lspStkBr, lspEp];		* Get my alink, slow flg	lspL4 &larr; T, loadpage[pgReturn];		* Save FX+1 for hard return				* (No bypass effect because lspStkBr=0)	T &larr; Stack&amp;-1;				* Save return value in L0,1onpage[pgReturn];	lspL1 &larr; T;	* memory is busy fetching lspEp, so this is free...	T &larr; Stack&amp;-1;	lspL0 &larr; T;	lspEp &larr; (lspEp) - (14c), goto[SlowReturn, R Odd];					* Ep -&gt; ALink-2 (quad aligned)	lspDefx0 &larr; 0c, goto[RetnTail];	* no flags for fast returnRV2[Blink, Clink, IP[lspDefx0]];SlowReturn:	* Come here with slow bit on	* lspL4 = returner's FX+1	* lspEp = my Alink field - 14 (= returnee's FX-2 + 1 for slow bit)	* L0, 1 have return value to save!** Things to worry about: my alink and clink must be the same* (if not, punt to software to patch things up).* Returnee's usecount must be zero (we can never run in a frame* with nonzero usecount; punt will copy frame).* returnee must be followed by a free block (possibly created by the return,* when my BF immediately follows returnee).	T &larr; (lspL4) + (7c);	PFetch2[lspStkBr, Blink], call[retLBL];	* Get returner's b/clinks	T &larr; (lspEp) + 1, loadpage[pgReturnA];	* returnee's FX (my adjusted alink)	lspLN &larr; T;				* save it for lspRtn2onpage[pgReturnA];	PFetch1[lspStkBr, lspL2], call[retLBL];	* L2 &larr; returnee's FX flags	CLink &larr; (CLink) - (12c);		* My clink, adjusted to FX	T &larr; (CLink) xor T;			* is it same as my alink?	lu &larr; (rhmask[lspL2]) or T;		* &amp; returnee's usecount zero?	T &larr; BLink, skip[alu=0];	   goto[RetUfn];   * Alink # Clink, or returnee's FX usecount not zero	PFetch2[lspStkBr, lspL2];	* Fetch returner's BF base words:					* L2 = flags,,usecount, L3 = ivar	T &larr; (lspLN) + (4c), call[retLBL];	PFetch1[lspStkBr, RTemp], call[retLBL];	* Get returnee's Next	T &larr; RTemp;	lu &larr; (lspL3) xor T;		* is my BF start = Returnee's Next?	lu &larr; rhmask[lspL2], skip[alu#0];	  dblgoto[RetUfn, DoReturn, alu#0];			* if usecount zero, is fine, since it will then			* become a free block; if nonzero, is hard	PFetch1[lspStkBr, RTemp];	* fetch first word beyond returnee	lu &larr; (RTemp) xor (FreeStackBlock);	* is it a free block?	dblgoto[RetUfn, DoReturn, alu#0];	* if so, fine, else hardRetUfn:	* Punt	T &larr; (lspL4) + (11c);		* Restore my Ep	lspEp &larr; T, loadpage[pgUfnx];	lspUFN &larr; 20c, gotop[lspUfnxP4];DoReturn:	* At this point, Blink points at my BF, LspL2 are its flags,,count,	* L3 is my Ivar.  L4 is still my FX+1	T &larr; (lspL4) - (3c);	PFetch2[lspStkBr, xBuf];	* Fetch the two words before my FX					* Either my BF or a residual BF	lu &larr; rhmask[lspL2];		* Test BF usecount	T &larr; (lspL3) - (2c), goto[BFinUse, alu#0];	T &larr; (BLink) - T;		* Usecount is zero, here is BF length	RTemp1 &larr; T;	RTemp &larr; (freeStackBlock);	* Construct free block of right length	T &larr; lspL3;	PStore2[lspStkBr, RTemp], goto[freeFX];	* Store it in front of BFBFinUse:			* If BF usecount &gt; 0, just decrement it	lspL2 &larr; (lspL2) - 1;	T &larr; BLink;	PStore1[lspStkBr, lspL2], goto[freeFX];freeFX:	* Time to turn my FX, and possibly my dummy BF, into a free block	T &larr; lspEsp;			* end of stack	xBuf3 &larr; T;	T &larr; xBuf &larr; ldf[xBuf, 6, 1];	* Fetch residual bit	T &larr; xBuf &larr; (xBuf) + T;		* Times 2 =&gt; 0 or 2	T &larr; (lspL4) - T - 1;		* Point at my FX or FX-2	xBuf2 &larr; (freeStackBlock);	xBuf3 &larr; (xBuf3) - T, loadpage[pgReturn];	* length of FX or FX+dummyBF	PStore2[lspStkBr, xBuf2], gotop[lspRtn2];					* make a free block of out of someone**** General Return to frame.  LspLN = FX, L0,1 = value	onpage[pgReturn];lspRtn2:	T &larr; (lspLN) - (2c);		* Get FX-2 (= BF)	lspEp &larr; T, call[retLBL];	* Wait for Ep writeback	PFetch1[lspEp, lspEsp, 6], call[retLBL];   * fetch Next of returnee	PFetch1[lspEp, lspDefx0, 2];	* Get FX flags,,usecount for later	T &larr; lspEsp, call[.+1];ExtendStk:	PFetch2[lspStkBr, lspL2];	* get next stack block	lu &larr; (lspL2) xor (freeStackBlock);	T &larr; lspL3, skip[alu#0];		* if it's free, gobble it	  T &larr; lspEsp &larr; (lspEsp) + T, return; * to ExtendStk*	goto[RetnTail];**** Common Return tail.**** Come here with lspEp pointing at returnee's FX-2 = BF**** lspDefx0 has FX flags, if it is possible that InCall or NoPush is ononpage[pgReturn];RetnTail:	PFetch4[lspEp, lspIfuBr, 4];	* Get IfuBr, Next, PC of returnee					* MC1 busy for 4 cycles, MC2 4 more	StkState &larr; 377c;	StkState &larr; (StkState) or (140000c);	* StkState &larr; rcy[1777,2]	PFetch1[lspEp, lspIbasex, 1];	* Get IVAR pointer	lspEp &larr; (lspEp) + (14c);	* Returnee's EP	T &larr; (lspNext) - (2c);		* TOS	lspTsp &larr; T;	T &larr; rhmask[lspIfuBrHi], task;	T &larr; lspIfuBrHi &larr; (lsh[lspIfuBrHi, 10]) or T;	* maybe redundant	PCBhi &larr; T, loadpage[pgJump];	T &larr; rsh[lspPC, 1];onpage[pgJump];	PFetch4[lspIfuBr, IBUF];	* Must be on page pgJump	PCB &larr; T;	* Bypass kludge: PCB&larr; addr of what we just fetched	PCB &larr; (PCB) and not (3c);	* Remove low-order bits of PCB	PCF &larr; lspPC;	* since IfuBr is quad-aligned, PC's low bits are correct for PCF:IF[StatsMode];	lspStatsPtr, goto[ReturnStat, R&gt;=0];:ENDIF;ReturnStatDone:		* Tsp now points at top element of stack.  We want		* it to be quadodd; if it is, we will start out with		* 2 elts on stack (StkState = 3776), else one (1777)	lu &larr; (lspTsp) and (2c);	T &larr; IP[HStack0]c, goto[rsodd2, alu#0];	lspTsp &larr; (lspTsp) + (2c);	* Do a push	T &larr; (ldf[lspTsp, 14, 4]) + T + 1;	lspL4 &larr; T, loadpage[pgHstack];	Stkp &larr; lspL4, callp[HStkUndflw];  * Get 2 elements, 1 of them garbage	Stack&amp;-2, goto[rsodd3];		* compensate for the LspTsp+2					* StkState = 1777 = 1 eltrsodd2:					* tsp is odd, as we like it	T &larr; (ldf[lspTsp, 14, 4]) + T + 1;	lspL4 &larr; T, loadpage[pgHstack];	Stkp &larr; lspL4, callp[HStkUndflw];	* Get 2 elements	StkState &larr; lsh[StkState, 1], goto[rsodd3];					* StkState = 3776 = 2 eltsrsodd3:					* stack fine, now check cases	lu &larr; (lspDefx0) and (OR[FxInCall!, FxNoPushReturn!]c);	T &larr; lspL0, goto[RetFunny, alu#0];	Stack&amp;+1 &larr; T;			* Push result (L0,1) and return	T &larr; lspL1;	Stack&amp;+1 &larr; T;	StkState &larr; lcy[StkState, 1], goto[IFE[StatsMode, 1, CheckStatOvfl, nxiLBL]];RetFunny:	lu &larr; (lspDefx0) and (FxInCall);	T &larr; (lspEp) - (12c), goto[RetCall, alu#0];					* no push case	lspDefx0 &larr; (lspDefx0) and not (FxNoPushReturn);					* turn off bit, store back	PStore1[lspStkBr, lspDefx0], goto[IFE[StatsMode, 1, CheckStatOvfl, nxiLBL]];					* Point back at PvarsRetCall:				* Call in progress	lspDefx0 &larr; (lspDefx0) and not (FxInCall);	loadpage[pgCallOps];	PStore1[lspStkBr, lspDefx0], gotop[ApplyFn];	* store updated flags	:END[Return];</pre>
  </body>
</html>
