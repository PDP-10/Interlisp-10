<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>fugue.5>Sources>LISP0MC.DM!1>FVarlookup.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Fvarlookup.0mc, August 11, 1982  5:24 PM, van Melle];onpage[pgFvar];RM[FVep, IP[lspDefx1]];RM[Name, IP[lspL2]];RM[Loc, IP[lspL3]];RM[Cnt, IP[lspDefx0]];RM[Value, IP[lspL0]];RM[ValueHi, IP[lspL1]];RM[NamePtr, IP[lspGenBr]];RM[NamePtrHi, IP[lspGenBrHi]];* Called with T pointing to Fvar binding slotLookup:	Loc &larr; T;	PFetch1[lspIfuBr, Cnt, 7];	* Cnt &larr; Nlocals,,FvarOffset	T &larr; lspEp;	T &larr; (Loc) - T;	Value &larr; T;			* word offset of binding slot past Ep	T &larr; rsh[Cnt, 10];		* T &larr; NLocals	Cnt &larr; (rhmask[Cnt]) - T;	* Cnt &larr; -NLocals + Fvaroffset	T &larr; rsh[Value, 1];		* cell offset of binding slot	T &larr; (Cnt) + T;		* T &larr; (Loc - Ep)/2 - NLocals + Fvaroffset				*    = nametable offset	PFetch1[lspIfuBr, Name];* Called with name to lookup in NameLookup1:	T &larr; (lspEp) - (12c);	FVep &larr; T, UseCtask;		* FVep &larr; current FX	T &larr; APC&amp;APCTask;	lspL5 &larr; T;			* save return linkNewFrame:	T &larr; (FVep) + (1c);	PFetch1[lspStkBr, FVep], task;	* FVep &larr; FVep:#Alink	FVep &larr; (FVep) - (12c);	T &larr; FVep &larr; (FVep) and not (1c);	* FVEp &larr; FX base	goto[EndOfStack, alu=0];	PFetch1[lspStkBr, Cnt];		* get frame flags,,usecount	lu &larr; (Cnt) and (10000c);		* Test F bit	lu &larr; (Cnt) and (1000c), skip[alu=0];	* test V = nametab valid bit	  goto[NewFrame];		* skip frame if binds no vars	T &larr; (FVep) + (2c), skip[alu=0];	* T &larr; offset of Fnheader (V=0)	  T &larr; (FVep) + (6c);		* T &larr; offset of name table (V=1)	PFetch2[lspStkBr, NamePtr];	* get one or the other	T &larr; rhmask[NamePtrHi];	NamePtrHi &larr; (lsh[NamePtrHi, 10]) or T;				* why bother putting it in both halves?	Cnt &larr; 4c, call[.+1];SearchLoop:	T &larr; Cnt &larr; (Cnt) + (4c);	PFetch4[NamePtr, XBuf];		* Fetch next 4 words of nametable	T &larr; Name;			* Name to compare against	lu &larr; (XBuf) xor T;Look1:	lu &larr; (XBuf1) xor T, goto[Found0, alu=0];Look2:	lu &larr; (XBuf2) xor T, goto[Found1, alu=0];Look3:	lu &larr; (XBuf3) xor T, goto[Found2, alu=0];	lu &larr; (XBuf3), goto[Found3, alu=0];	goto[NewFrame, alu=0];		* Nametable ends in zero's	return;				* ...to SearchLoopFound0:	T &larr; Cnt, goto[Found];Found1:	T &larr; Cnt &larr; (Cnt) + (1c), goto[Found];Found2:	T &larr; Cnt &larr; (Cnt) + (2c), goto[Found];Found3:	T &larr; Cnt &larr; (Cnt) + (3c), goto[Found];Found:	PFetch1[NamePtr, lspL4, 6], call[retLBL];	* L4 &larr; NTSIZE,					* avoiding passaround failure	T &larr; (lspL4) + T;			* offset of second NT slot	PFetch1[NamePtr, lspL4];		* L4 &larr; flag,,offset	T &larr; rhmask[lspL4];			* offset of var wherever	lspL4 &larr; (lspL4) + T, goto[Ivar, R&gt;=0];	* word offsetFPvar:						* L4[0:1] = 10 or 11	T &larr; (FVep) + (12c);			* Find start of Pvars	T &larr; (rhmask[lspL4]) + T;			* Look at Nth Pvar	PFetch2[lspStkBr, Value];	* Fetch pvar value or fvar binding	lu &larr; (lspL4) and (40000c);		* which are we looking at?	goto[Pvar, alu=0];	lu &larr; Value, goto[FoundVal, Reven];	* Value = fvar binding						* May want to create chain	goto[NewFrame];PVar:					* fetched Value out of a PVAR slot	lu &larr; Value, goto[Pvar1, R&lt;0];	* unbound if high bit on	Value &larr; T;			* return pointer to this bindingLookStackPtr:	ValueHi &larr; (StackSpace);	ValueHi &larr; (ValueHi) or (StackSpaceR), goto[FoundVal];Pvar1:	* unbound pvar--loop, 'cause there may be a bound one in same frame	T &larr; (Cnt) and not (3c);	PFetch4[NamePtr, XBuf];		* is this redundant?	T &larr; Name, call[.+2];	  goto[SearchLoop];	* Return at end of searchloop returns here	Dispatch[Cnt, 16, 2];	Cnt &larr; (Cnt) and not (3c), Disp[.+1];	goto[Look1], DispTable[4];	goto[Look2];	goto[Look3];	goto[SearchLoop];Ivar:	T &larr; (FVep) - 1;	PFetch1[lspStkBr, Value];		* Fetch ptr to Ivar start	T &larr; rhmask[lspL4];			* Add in offset	Value&larr; (Value) + T, goto[LookStackPtr];EndOfStack:				* stack exhausted, point at value cell	T &larr; lsh[Name, 1];		* atomnumber * 2	Value &larr; T;	ValueHi &larr; (VALspace);		* Say it is global	ValueHi &larr; (ValueHi) or (VALspaceR), goto[FoundVal];					* Combine this with LookStackPtr+1FoundVal:	APC&amp;APCTask &larr; lspL5;	T &larr; Loc, return;* Eval, op 54Eval:	call[lspTyp], opcode[54];	* get type in LN, pop TOS into L3,2	loadpage[pgEval];	T &larr; (lspType) - (listType);	* is it Listp?onpage[pgEval];	FreezeResult, goto[EvalList, alu=0];	* yes, do evalform	skip[alu&lt;0], lu &larr; (lspType) - (atomType);	* is TOS atom or less?	  lspUFN &larr; 54c, goto[ufnLBL];	* types greater than listp punt	T &larr; lspL2, skip[alu=0];		* Skip if type atom	  NextOpCode;			* Smallp, fixp, floatp eval to self					* TOS is atom.  Thus L3=0, L2 = atom#	lu &larr; (lspL2) - (KtVal), skip[alu#0];	  NextOpCode;			* NIL evals to self	skip[alu#0];	  NextOpCode;			* so does T	loadpage[pgFvar];	Name &larr; T, callp[Lookup1];	* "Name" is really lspL2, so noop					* Returns Value = binding slot	PFETCH2[Value, lspL2, 0];	T &larr; lspL2;			* test L2,3 = NOBIND	lu &larr; (lspL3) - (atomNOBIND), goto[EvalOk, alu#0];	skip[alu#0];	  lspUFN &larr; (54c), goto[ufnLBL];	* punt if var's value is NOBIND				* Note this is not right if var is				* actually BOUND to NOBIND, but who cares?	nop;			* allocation constraintEvalOk:	Stack&amp;-1 &larr; T;		* = L2, hi half of value	T &larr; lspL3;	Stack&amp;+1 &larr; T, goto[nxiLBL];EvalList:			* Eval a list.  Do this by calling a				* special fn, rather than normal ufn, thus				* saving a frame in the interpreter.				* T is conveniently zero from previous lu	lspDefx1 &larr; atomEVALFORM;	lspDefx0 &larr; T, loadpage[pgFrame];	* &larr; 0	lspNargs &larr; 1c, gotop[lspCallFn];* StkScan, op 57: TOS -&gt; binding pointer of TOSStkScan:	T &larr; Stack&amp;-1, opcode[057];	lu &larr; Stack&amp;-1, goto[StkScanNil, alu=0];	skip[alu=0];				* Is hiloc of TOS zero?	  lspUFN &larr; 57c, goto[ufnLBL];		* no, punt	loadpage[pgFvar];	Name &larr; T, callp[Lookup1];	T &larr; rsh[ValueHi, 10];			* hiloc of binding ptr	Stack&amp;+1 &larr; T;	T &larr; Value;StkScanPush:	Stack&amp;+1 &larr; T, goto[nxiLBL];StkScanNil:	Stack&amp;+1 &larr; (ValSpaceR), goto[StkScanPush];	* Note that T = 0	:END[Fvarlookup];</pre>
  </body>
</html>
