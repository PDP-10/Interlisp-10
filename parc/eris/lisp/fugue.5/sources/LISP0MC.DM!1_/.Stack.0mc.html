<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>fugue.5>Sources>LISP0MC.DM!1>Stack.0mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:TITLE[Stack.0mc...August 11, 1982  5:27 PM, van Melle];<br><br><br>************************<br>* Overflow is checked by looking at B0 (R&lt;0).<br>* If set then overflow has occured.<br>* This should probably rshift 1 more to begin with.<br>* Push is done by lsh 1.<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[5];<br>PushTChkP5:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T, loadpage[pgHStack], goto[PushChkxP5];<br>PushChkP5:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack];<br>PushChkxP5:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; lcy[StkState, 1],  dblgotop[HStkOverflow, PushChkRet, R&lt;0];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[15];<br>PushChkP15:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; lcy[StkState, 1],  dblgotop[HStkOverflow, PushChkRet, R&lt;0];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[pgHStack];<br>PushChkP16:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; lcy[StkState, 1],  dblgoto[HStkOverflow, PushChkRet, R&lt;0];<br><br>PushChkRet:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This pair branched to from other pages also<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NextOpCode</span><span style="font: 10pt serif">;<br><br>HStkOverflow:<br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspTsp) and (2c);<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu#0];<br>*breakpoint;<br><br>* lspTsp is quadodd and points at the cell below the bottom of hstack.<br>* We store bottom 4 cells (8 words) of Hstack at lspTsp+2 thru +8.<br>* Low 2 bits of tsp rshift 2 indicate what piece of<br>* hstack we are dealing with.<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dispatch[lspTsp, 14, 2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rcy[StkState, 4], disp[OvfHStkDisp0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* account for 4 pops<br><br>OvfHStkDisp0:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack4, 2], goto[Ov0], disptable[4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack10, 2], goto[Ov1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack14, 2], goto[Ov2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack0, 2], goto[Ov3];<br><br>Ov0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack10, 6], goto[OvfDone];<br>Ov1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack14, 6], goto[OvfDone];<br>Ov2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack0, 6], goto[OvfDone];<br>Ov3:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack4, 6], goto[OvfDone];<br><br>OvfDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspTsp &larr; (lspTsp) + (10c), task;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 8 cells were stored<br><br>* Now check for overflow.  We need to make sure there is enough room for<br>* another hstack overflow (10b words) plus the StackFullPunt that could<br>* follow it (10b words to flush the rest of the stack plus 2 words to<br>* make a Fsb after it).<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (lspTsp) + (22c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This could overflow!!<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspEsp) - T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[nocarry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  </span><span style="font: 10pt serif">NextOpCode</span><span style="font: 10pt serif">;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgLisp0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* could be in skip instr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AC1&larr; (StackRequested), gotop[StackFullPunt];<br><br>***********************<br>* Underflow is checked by looking at B15 (Rodd).  More than one bit may<br>* need to be examined for more than the 1 element functions.<br>* Pop is done by rsh 1<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[6];<br>PopChk6:<br>PopChkP6:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rcy[StkState, 1], dblgotop[PopChkUndflow, PopchkRet, R Odd];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[pgHStack];<br>PopChkP16:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rcy[StkState, 1], dblgoto[PopChkUndflow, PopchkRet, R Odd];<br><br>PopChkUndflow:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This pair branched to from other pages, too<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[HStkUndflw];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">nop;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* alloc constraint<br>PopchkRet:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NextOpCode</span><span style="font: 10pt serif">;<br><br><br>* Check for 2 or 3 elements on stack.  Caller did loadpage[pgHStack]<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[4];<br>CheckElt2P4:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; StkState, dblgotop[HStkUndflw, ChkRet, R Odd];<br><br>CheckElt3P4:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (StkState) and (3c), gotop[CE3Tail];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[5];<br>CheckElt2P5:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; StkState, dblgotop[HStkUndflw, ChkRet, R Odd];<br><br>CheckElt3P5:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (StkState) and (3c), gotop[CE3Tail];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[7];<br>CheckElt2P7:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; StkState, dblgotop[HStkUndflw, ChkRet, R Odd];<br><br>CheckElt3P7:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (StkState) and (3c), gotop[CE3Tail];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[pgHStack];<br>CE3Tail:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dblgoto[HStkUndflw, ChkRet, alu#0];<br>ChkRet: return;<br><br>HStkUndflw:<br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch a quadword to the stack, thus putting two more cells on<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">*** Bind assumes this subroutine does not disturb T<br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspTsp) and (2c);<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu#0];<br>*breakpoint;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspTsp&larr; (lspTsp) - (2c);<br> </span><span class="tab" val="67"></span><span style="font: 10pt serif">dispatch[lspTsp, 14, 2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; lcy[StkState, 2], disp[UndHStkDisp0];<br><br>UndHStkDisp0:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[lspTsp, Hstack0, 0], goto[UndHStkLoop], disptable[4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[lspTsp, Hstack4, 0], goto[UndHStkLoop];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[lspTsp, Hstack10, 0], goto[UndHStkLoop];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[lspTsp, Hstack14, 0], goto[UndHStkLoop];<br><br>UndHStkLoop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspTsp &larr; (lspTsp) - (2c), return;<br><br><br>ClrHStk:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* called from LspSubr, LspPuntStore<br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspTsp) and (2c);<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu#0];<br>*breakpoint;<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">nop;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UseCtask;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* save return link<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; APC&APCTASK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL5 &larr; T;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rcy[StkState, 1], call[.+1];<br><br>*** Stkstate now is odd if this is the last quad to store, i.e.<br>*** there are 1 or 2 cells on stack left.<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dispatch[lspTsp, 14, 2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">disp[ClrHStkDisp0];<br><br>ClrHStkDisp0:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack4, 2], goto[ClrHStack1], disptable[4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack10, 2], goto[ClrHStack1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack14, 2], goto[ClrHStack1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspTsp, Hstack0, 2], goto[ClrHStack1];<br><br>ClrHStack1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rcy[StkState, 2], goto[ClrDone, R Odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lspTsp &larr; (lspTsp) + (4c), return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* to dispatch<br>ClrDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; lcy[StkState, 2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* undo last rcy<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspTsp &larr; (lspTsp) + (4c), skip[alu&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lspTsp &larr; (lspTsp) - (2c);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* really stored odd number of cells<br><br>:IF[StkDebug];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">nop;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* alloc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[ChkStk];<br>:ENDIF;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APC&APCTask &larr; lspL5, goto[retLBL];<br><br>MyAlink:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; (smallpl), opcode[146];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (lspEp) - (11c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Offset of Alink word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspStkBr, Stack];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) and not (1c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Turn off Xbit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) - (12c), goto[PushLBL];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Point at FX (not PVar)<br><br>:IF[StkDebug];<br><br>onpage[pgHStack];<br>ChkStk:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 7c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LDF[SSTKP&NSTKP, 14, 3]) xor T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (LDF[lspTsp, 14, 3]) xor T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  breakpoint;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">INCMPANEL, return;<br>:ENDIF;<br><br>:END[Stack];<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
