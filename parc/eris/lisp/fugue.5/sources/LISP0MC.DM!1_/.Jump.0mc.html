<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>fugue.5>Sources>LISP0MC.DM!1>Jump.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Jump.mc...June 21, 1982  9:36 PM, van Melle];* A few more instructions can be removed by putting the jump distance*  directly into lspLN and doing the pfetch sooner.* NILPOP can be expanded.* The only use of the stack is in NILPOP.Jumps:	T &larr; 1c, goto[lspDojump], opcode[200];	T &larr; 2c, goto[lspDojump], opcode[201];	T &larr; 3c, goto[lspDojump], opcode[202];	T &larr; 4c, goto[lspDojump], opcode[203];	T &larr; 5c, goto[lspDojump], opcode[204];	T &larr; 6c, goto[lspDojump], opcode[205];	T &larr; 7c, goto[lspDojump], opcode[206];	T &larr; 10c, goto[lspDojump], opcode[207];	T &larr; 11c, goto[lspDojump], opcode[210];	T &larr; 12c, goto[lspDojump], opcode[211];	T &larr; 13c, goto[lspDojump], opcode[212];	T &larr; 14c, goto[lspDojump], opcode[213];	T &larr; 15c, goto[lspDojump], opcode[214];	T &larr; 16c, goto[lspDojump], opcode[215];	T &larr; 17c, goto[lspDojump], opcode[216];	T &larr; 20c, goto[lspDojump], opcode[217];Fjumps:	T &larr; 1c, goto[lspFjump], opcode[220];	T &larr; 2c, goto[lspFjump], opcode[221];	T &larr; 3c, goto[lspFjump], opcode[222];	T &larr; 4c, goto[lspFjump], opcode[223];	T &larr; 5c, goto[lspFjump], opcode[224];	T &larr; 6c, goto[lspFjump], opcode[225];	T &larr; 7c, goto[lspFjump], opcode[226];	T &larr; 10c, goto[lspFjump], opcode[227];	T &larr; 11c, goto[lspFjump], opcode[230];	T &larr; 12c, goto[lspFjump], opcode[231];	T &larr; 13c, goto[lspFjump], opcode[232];	T &larr; 14c, goto[lspFjump], opcode[233];	T &larr; 15c, goto[lspFjump], opcode[234];	T &larr; 16c, goto[lspFjump], opcode[235];	T &larr; 17c, goto[lspFjump], opcode[236];	T &larr; 20c, goto[lspFjump], opcode[237];Tjumps:	T &larr; 1c, goto[lspTJump], opcode[240];	T &larr; 2c, goto[lspTJump], opcode[241];	T &larr; 3c, goto[lspTJump], opcode[242];	T &larr; 4c, goto[lspTJump], opcode[243];	T &larr; 5c, goto[lspTJump], opcode[244];	T &larr; 6c, goto[lspTJump], opcode[245];	T &larr; 7c, goto[lspTJump], opcode[246];	T &larr; 10c, goto[lspTJump], opcode[247];	T &larr; 11c, goto[lspTJump], opcode[250];	T &larr; 12c, goto[lspTJump], opcode[251];	T &larr; 13c, goto[lspTJump], opcode[252];	T &larr; 14c, goto[lspTJump], opcode[253];	T &larr; 15c, goto[lspTJump], opcode[254];	T &larr; 16c, goto[lspTJump], opcode[255];	T &larr; 17c, goto[lspTJump], opcode[256];	T &larr; 20c, goto[lspTJump], opcode[257];@FJumpx:*	nop, opcode[262];	T &larr; NextData[IBuf], opcode[262];	T &larr; (Form-2[AllOnes]) + T, skip[noH2bit8];	* T&larr;T-2	T &larr; (lhmask[AllOnes]) + T;			* Signextend TlspFJump:	lspLN &larr; T, call[lspNilpop];	T &larr; lspLN, skip[alu=0];			* Skip if TOS = NIL	  goto[PopChk6];	goto[lspDojumpPop];@TJumpx:*	nop, opcode[263];	T &larr; NextData[IBuf], opcode[263];	T &larr; (Form-2[AllOnes]) + T, skip[noH2bit8];	T &larr; (lhmask[AllOnes]) + T;lspTJump:	lspLN &larr; T, call[lspNilpop];	T &larr; lspLN, skip[alu#0];			* Skip if TOS # NIL	  goto[PopChk6];	goto[lspDojumpPop];@Jumpx:*	nop, opcode[260];			* Unconditional jump	T &larr; NextData[IBuf], opcode[260];	T &larr; (Form-2[AllOnes]) + T, skip[noH2bit8];	T &larr; (lhmask[AllOnes]) + T, goto[lspDojump];	goto[lspDojump];@NFJumpx:*	nop, opcode[264];		* Jump if TOS = NIL, pop if no branch	T &larr; NextData[IBuf], opcode[264]; * Jump if TOS = NIL, pop if no branch	T &larr; (Form-2[AllOnes]) + T, skip[noH2bit8];	T &larr; (lhmask[AllOnes]) + T;	call[lspNilpop], lspLN &larr; T;	skip[alu=0], T &larr; lspLN;	  goto[PopChk6];	Stack&amp;+2, goto[lspDojump];@NTJumpx:*	nop, opcode[265];		* Jump if TOS # NIL, pop if no branch	T &larr; NextData[IBuf], opcode[265]; * Jump if TOS # NIL, pop if no branch	T &larr; (Form-2[AllOnes]) + T, skip[noH2bit8];	T &larr; (lhmask[AllOnes]) + T;	call[lspNilpop], lspLN &larr; T;	skip[alu#0], T &larr; lspLN;	  goto[PopChk6];	Stack&amp;+2, goto[lspDojump];@Jumpxx:*	nop, opcode[261];		* Jump offset in alpha,beta	T &larr; NextData[IBuf], opcode[261];	* Jump offset in alpha,beta	lspLN &larr; T;	T &larr; 3c;	T &larr; (NextData[IBuf]) - T;	T &larr; (lsh[lspLN, 10]) + T, goto[lspDojump];lspNilpop:	T &larr; Stack&amp;-1, useCtask;		* No task, because alu result tested	T &larr; (Stack&amp;-1) or T, return;lspDojump:	T &larr; (PCFReg) + T;	lspLN &larr; T, goto[AddIlx1, alu&gt;=0];	T &larr; 100000c;	T &larr; (rsh[lspLN, 1]) or T, goto[AddIlx2];AddIlx1:	T &larr; rsh[lspLN, 1];AddIlx2:	PFetch4[PCB, IBuf];		* See comment in FETCH.0mc	PCB &larr; T;	PCF &larr; lspLN;	PCB &larr; (PCB) and not (3c), goto[lspNextInstP6];				* Fault will happen right after this instlspDojumpPop:	T &larr; (PCFReg) + T;	lspLN &larr; T, goto[AddIlx3, alu&gt;=0];	T &larr; 100000c;	T &larr; (rsh[lspLN, 1]) or T, goto[AddIlx4];AddIlx3:	T &larr; rsh[lspLN, 1];AddIlx4:	PFetch4[PCB, IBuf];		* See comment in FETCH.0mc	PCB &larr; T;	PCF &larr; lspLN;	PCB &larr; (PCB) and not (3c), goto[PopChk6];				* Fault will happen right after this inst	:END[Jump];</pre>
  </body>
</html>
