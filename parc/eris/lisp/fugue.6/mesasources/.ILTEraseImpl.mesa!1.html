<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Fugue.6>MesaSources>ILTEraseImpl.mesa!1</title>
  </head>
  <body>
    <pre>
--ILTEraseImpl.mesa--Created by--   JFung.PASA	  	19-Sep-83 17:06:11--last edited by--   JFung.PASA	   	19-Dec-83 16:54:33DIRECTORY     Cursor USING [Set],     LispToolOps USING [Data, DataHandle, toolData, GetVolumeID],     PhysicalVolume USING [EraseLogicalVolume],     Process USING [Pause, SecondsToTicks],     Put USING [CR, Line, LongString, Text],     SpecialVolume USING [OpenVolume],     String USING [EquivalentString],     Volume USING [          GetLabelString, GetNext, GetType, ID, maxNameLength, NeedsScavenging,          nullID, systemID, Type, TypeSet];ILTEraseImpl: PROGRAM     IMPORTS          Cursor, LispToolOps, PhysicalVolume, Process, Put, 	  SpecialVolume, String, Volume     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;          debug: BOOLEAN &larr; FALSE;     EraseProc: PUBLIC PROCEDURE [vName: LONG STRING] =          BEGIN          volumeID: Volume.ID &larr; Volume.nullID;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Enter EraseProc..."L];               --Process.Pause[Process.SecondsToTicks[5]];               Put.LongString[ILT.toolData.fileSW, vName];               Put.CR[ILT.toolData.fileSW];               };          [volumeID, ] &larr; ILT.GetVolumeID[vName];          IF debug THEN Put.Text[ILT.toolData.fileSW, "Volume = "L];          IF volumeID = Volume.nullID THEN               BEGIN               IF debug THEN Put.Line[ILT.toolData.fileSW, "Null ID"L];               RETURN;               END;          Put.Text[ILT.toolData.fileSW, " Erasing... "L];	  Cursor.Set[hourGlass];          PhysicalVolume.EraseLogicalVolume[volumeID];	  Cursor.Set[textPointer];          Put.Line[ILT.toolData.fileSW, " Done"L];          END;     GetVolumeID: PUBLIC PROCEDURE [volumeName: LONG STRING]          RETURNS [volumeID: Volume.ID &larr; Volume.nullID, volumeOpen: BOOLEAN] =          BEGIN OPEN Volume;          myType: Volume.Type = Volume.GetType[Volume.systemID];          all: Volume.TypeSet &larr; [               normal: TRUE,               debugger: myType = debugger OR myType = debuggerDebugger,               debuggerDebugger: myType = debuggerDebugger];          name: STRING = [maxNameLength];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "Enter GetVolume..."L];               --Process.Pause[Process.SecondsToTicks[10]];               Put.LongString[ILT.toolData.fileSW, volumeName];               Put.CR[ILT.toolData.fileSW];               };          volumeOpen &larr; FALSE;          FOR volumeID &larr; GetNext[nullID, all], GetNext[volumeID, all] UNTIL               volumeID = nullID DO               name.length &larr; 0;               Volume.GetLabelString[volumeID, name];               IF String.EquivalentString[name, volumeName] THEN EXIT;               ENDLOOP;          SELECT volumeID FROM               nullID =&gt;                    BEGIN                    Put.LongString[ILT.toolData.msgSW, volumeName];                    --Process.Pause[Process.SecondsToTicks[5]];                    Put.Line[ILT.toolData.msgSW, "Volume not found!"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    RETURN;                    END;               Volume.systemID =&gt;                    BEGIN                    Put.LongString[ILT.toolData.fileSW, volumeName];                    Put.Line[ILT.toolData.fileSW, " is your system volume!"L];                    --Process.Pause[Process.SecondsToTicks[5]];                    --RETURN;                    END;               ENDCASE;          SpecialVolume.OpenVolume[               volume: volumeID, access: readWrite !               Volume.NeedsScavenging =&gt; GOTO BadVolume];          volumeOpen &larr; TRUE;          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "volume opened!"L];               --Process.Pause[Process.SecondsToTicks[5]];               };          RETURN[volumeID, volumeOpen];          EXITS               BadVolume =&gt;                    BEGIN                    Put.Line[ILT.toolData.msgSW, "Can not open volume "L];                    Put.LongString[ILT.toolData.fileSW, volumeName];                    Put.Line[ILT.toolData.fileSW, " needs scavenging."L];                    Process.Pause[Process.SecondsToTicks[10]];                    END;          END;     END...  </pre>
  </body>
</html>
