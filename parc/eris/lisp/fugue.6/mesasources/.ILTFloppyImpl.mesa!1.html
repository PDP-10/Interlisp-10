<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Fugue.6>MesaSources>ILTFloppyImpl.mesa!1</title>
  </head>
  <body>
    <pre>
--ILTFloppyImpl.mesa--Created by--   JFung.PASA	  	14-Dec-83 12:37:04--	a modified version taken from FloppyStuff.mesa--last edited by--   JFung.PASA	   	20-Dec-83 15:22:23DIRECTORY     AccessFloppy USING [          Attributes, AttributesRecord, Close, CreateFile, currentVersion,          DeleteFile, Error, ErrorType, GetAttributes, InconsistentFile,          InvalidVersion, leaderLength, LookUp, maxDataSize, maxNameLength,          NoRoomForClientData, Open, tFloppyLeaderPage],     Environment USING [bytesPerPage],     Exec USING [          Confirm, ExecProc, FreeTokenString, GetToken, Handle, MatchPattern,          Outcome, OutputProc],     File USING [Type],     FileTypes USING [tUntypedFile],     Floppy USING [          AlreadyFormatted, Close, CopyFromPilotFile, CopyToPilotFile, Density,          Error, ErrorType, FileHandle, Format, GetAttributes, GetFileAttributes,          GetNextFile, maxCharactersInLabel, nullFileID, Open, Sides,          VolumeHandle],     Format USING [Char, Date, Line, LongDecimal, LongNumber, Number, StringProc],     FormSW USING [          AllocateItemDescriptor, ClientItemsProcType, CommandItem, Destroy,          Display, DisplayItem, Enumerated, EnumeratedItem, FindItem,          FreeHintsProcType, ItemHandle, newLine, MenuProcType, ProcType,          SetTagPlaces, StringItem],     Heap USING [systemZone],     LispToolOps,     MFile USING [          Error, ErrorCode, GetProperties, Handle, ReadOnly, Release,          SetProperties, Type, WriteOnly],     NSString USING [StringFromMesaString],     Process USING [Pause, SecondsToTicks],     Put,     SpecialMFile USING [GetCapaWithAccess, LeaderPages],     String USING [          AppendLongDecimal, AppendString, Copy, Equivalent, InvalidNumber,          Replace, StringToNumber],     StringLookUp USING [InTable, noMatch],     Time USING [Current],     Tool USING [          Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,          UnusedLogName],     ToolDriver USING [Address, NoteSWs, RemoveSWs],     ToolWindow USING [Activate, Deactivate, DisplayProcType, TransitionProcType],     Token USING [Decimal, FreeStringHandle, Handle, StringToHandle, SyntaxError],     Volume,     Window USING [          BitmapPlace, Box, GetChild, GetDisplayProc, GetParent, Handle,          SetDisplayProc, Stack, ValidateTree];ILTFloppyImpl: PROGRAM     IMPORTS          AccessFloppy, Exec, Floppy, Format, FormSW, Heap, LispToolOps, MFile,          NSString, Process, Put, SpecialMFile, String, StringLookUp, Time, Tool,          ToolDriver, ToolWindow, Token, Volume, Window     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;     -- TYPEs     Indicator: TYPE = {off, left, right};     VolHints: TYPE = RECORD [names: SEQUENCE length: CARDINAL OF LONG STRING];     SizeHints: TYPE = RECORD [names: SEQUENCE length: CARDINAL OF CARDINAL];     DataHandle: TYPE = LONG POINTER TO Data;     Data: TYPE = MACHINE DEPENDENT RECORD [          -- Message subwindow stuff          msgSW(0): Window.Handle &larr; NIL,          -- File subwindow stuff          fileSW(2): Window.Handle &larr; NIL,          -- Form subwindow stuff          -- Note: enumerateds and booleans must be word boundary          -- aligned as addresses for them must be generated          --formSW: Window.Handle &larr; NIL,          paramSW(4): Window.Handle &larr; NIL,          commandSW(6): Window.Handle &larr; NIL,          busy(8): BOOLEAN &larr; FALSE,  -- command is running          volName(9): LONG STRING &larr; NIL,          pattern(11): LONG STRING &larr; NIL,          indicator(13): Indicator &larr; left];     EnumProc: TYPE = PROCEDURE [          attributes: AccessFloppy.Attributes, fH: Floppy.FileHandle,          name: LONG STRING] RETURNS [stop: BOOLEAN &larr; FALSE];     active: BOOLEAN &larr; FALSE;     floppyWH: Window.Handle &larr; NIL;     debug: BOOLEAN &larr; TRUE;     toolData: DataHandle &larr; NIL;     formDisplay: ToolWindow.DisplayProcType &larr; NIL;     heraldName: STRING &larr; [50];     indicatorBox: Window.Box = [[10, 10], [16, 16]];     volume: Volume.ID &larr; Volume.nullID;     dataVersion: CARDINAL = 02222;  -- version of clientData     Abort: ERROR [s: STRING] = CODE;     SetOutcome: SIGNAL [value: Exec.Outcome] = CODE;     DeleteFiles: PROCEDURE[] =          BEGIN          name: LONG STRING &larr; NIL;          v: Floppy.VolumeHandle;          DeleteOne: EnumProc =               BEGIN               Put.Text[toolData.fileSW, name];               Put.Text[toolData.fileSW, "... "L];               AccessFloppy.DeleteFile[NSString.StringFromMesaString[name] !                    AccessFloppy.Error =&gt;                         SELECT type FROM                              fileNotFound =&gt; {                                   Put.Line[toolData.fileSW, "not found"L];				  -- Process.Pause[Process.SecondsToTicks[10]];                                   GOTO error};                              ENDCASE];               Put.Line[toolData.fileSW, "deleted"L];	      --Process.Pause[Process.SecondsToTicks[10]];               EXITS error =&gt; Put.Line[toolData.fileSW, "error"L];               END;  --DeleteOne          v &larr; AccessFloppy.Open[               ! AccessFloppy.Error =&gt; ERROR Abort["Can't open floppy"L]];	  BEGIN               ENABLE UNWIND =&gt; {AccessFloppy.Close[ ! Floppy.Error =&gt; CONTINUE]};               --name &larr; toolData.pattern;               --IF toolData.pattern = NIL THEN EXIT;               IF WildCards[toolData.pattern] THEN EnumerateFloppyFiles[v, DeleteOne, toolData.pattern]               ELSE [] &larr; DeleteOne[NIL, [v, Floppy.nullFileID], toolData.pattern];          END;          AccessFloppy.Close[];          END;  --DeleteFiles     EnumerateFloppyFiles: PROCEDURE [          v: Floppy.VolumeHandle, proc: EnumProc, pattern: LONG STRING &larr; NIL] =          BEGIN          nullFile: Floppy.FileHandle = [volume: v, file: Floppy.nullFileID];          attributes: AccessFloppy.Attributes &larr; Heap.systemZone.NEW[               AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];          name: LONG STRING = LOOPHOLE[@attributes.length];          IF debug THEN {               Put.Line[toolData.fileSW, "EnumerateFloppyFiles...."L];               --Process.Pause[Process.SecondsToTicks[5]];               };          FOR current: Floppy.FileHandle &larr; Floppy.GetNextFile[nullFile].nextFile,               Floppy.GetNextFile[current].nextFile WHILE current # nullFile DO               ENABLE UNWIND =&gt; Heap.systemZone.FREE[@attributes];               IF Floppy.GetFileAttributes[current].type #                    AccessFloppy.tFloppyLeaderPage THEN LOOP;	       IF debug THEN {               Put.Line[toolData.fileSW, "Floppy.GetNextFile"L];               --Process.Pause[Process.SecondsToTicks[5]];               };               AccessFloppy.GetAttributes[current, attributes];	       Put.Text[toolData.fileSW, "Pattern = "L];	       Put.Line[toolData.fileSW, pattern];               IF                    --(                    pattern = NIL                    --OR Exec.MatchPattern[string: name, pattern: pattern])                    OR proc[attributes, current, name] THEN {		    	Put.Line[toolData.fileSW, "Exited loop."L];			EXIT;			};               ENDLOOP;          Heap.systemZone.FREE[@attributes];          END;  --EnumerateFloppyFiles     FloppyStuff: PUBLIC PROCEDURE =          BEGIN          aborted: BOOLEAN &larr; FALSE;          IF toolData = NIL THEN toolData &larr; Heap.systemZone.NEW[Data &larr; []];          IF debug THEN {               --Put.Line[ILT.toolData.fileSW, "FloppyStuff...."L];               --Process.Pause[Process.SecondsToTicks[5]];               };          floppyWH &larr; MakeTool[];          BEGIN          ENABLE {               Abort =&gt; {Put.Line[toolData.fileSW, s]; aborted &larr; TRUE; };               AccessFloppy.Error =&gt; {                    Put.Text[toolData.fileSW, "unexpected "L];                    WriteAccessFloppyError[type];                    Put.CR[toolData.fileSW];                    aborted &larr; TRUE;                    };               AccessFloppy.InconsistentFile =&gt; {                    Put.Line[toolData.fileSW, "AccessFloppy.InconsistentFile"L];                    aborted &larr; TRUE;                    };               AccessFloppy.InvalidVersion =&gt; {                    Put.Line[toolData.fileSW, "AccessFloppy.InvalidVersion"L];                    aborted &larr; TRUE;                    };               AccessFloppy.NoRoomForClientData =&gt; {                    Put.Line[toolData.fileSW, "AccessFloppy.NoRoomForClientData"L];                    aborted &larr; TRUE;                    };               Floppy.Error =&gt; {                    IF error = writeInhibited THEN                         Put.Line[toolData.fileSW, "Floppy is write protected"L]                    ELSE {                         Put.Text[toolData.fileSW, "unexpected "L];                         --WriteFloppyError[error];                         Put.CR[toolData.fileSW];                         };                    aborted &larr; TRUE;                    };               };          END;          END;  --FloppyStuff     &lt;&lt;     FormatDisk: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =          BEGIN          Write: Format.StringProc = Exec.OutputProc[h];          density: Floppy.Density &larr; default;          sides: Floppy.Sides &larr; default;          label: STRING &larr; [Floppy.maxCharactersInLabel];          arg, switches: LONG STRING &larr; NIL;          nFiles: CARDINAL &larr; 64;          BEGIN          gotError: BOOLEAN &larr; FALSE;          v: Floppy.VolumeHandle;          v &larr; Floppy.Open[               !               Floppy.Error =&gt;                    SELECT error FROM                         invalidFormat =&gt; GOTO virgin;                         needsScavenging =&gt; {gotError &larr; TRUE; CONTINUE};                         ENDCASE];          IF ~gotError THEN {               [] &larr; Floppy.GetAttributes[v, label];               Floppy.Close[v];               Write["Floppy volume """L];               Write[label];               Write[""" already formatted"L]}          ELSE Write["Floppy probably contains valid information"L];          Write["; formatting will destroy previous contents"L];          IF ~Exec.Confirm[h] THEN ERROR Abort[NIL];          Format.Line[Write, " yes"L];          EXITS virgin =&gt; NULL;          END;          label.length &larr; 0;          String.AppendString[label, "UnnamedFloppy"L];          DO               arg &larr; Exec.FreeTokenString[arg];               switches &larr; Exec.FreeTokenString[switches];               [arg, switches] &larr; Exec.GetToken[h];               IF arg = NIL AND switches = NIL THEN EXIT;               IF switches = NIL THEN LOOP;               FOR i: CARDINAL IN [0..switches.length) DO                    SELECT switches[i] FROM                         'n =&gt; {                              label.length &larr; 0;                              FOR j: CARDINAL IN                                   [0..label.length &larr; MIN[                                         arg.length, label.maxlength]) DO                                   label[j] &larr; arg[j]; ENDLOOP};                         'f =&gt;                              nFiles &larr; String.StringToNumber[                                   arg ! String.InvalidNumber =&gt; CONTINUE];                         ENDCASE;                    ENDLOOP;               ENDLOOP;          Write["Formatting... "L];          Floppy.Format[               0, nFiles, label, density, sides !               Floppy.Error =&gt;                    IF error = badDisk THEN                         ERROR Abort[                              "Can't format this disk; may be write protected"L];               Floppy.AlreadyFormatted =&gt; RESUME ];          Format.Line[Write, "...done"L];          InfoDisk[];          END;&gt;&gt;     FormSWDeleteProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWDeleteProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          DeleteFiles;          END;  --FormSWDeleteProc     FormSWDuplicateProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWDuplicateProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          --InfoDisk;          END;  --FormSWDuplicateProc     FormSWFormatProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWFormatProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };                    END;  --FormSWFormatProc     FormSWInfoProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWInfoProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          InfoDisk;          END;  --FormSWInfoProc     FormSWListProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "FormSWListProc...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          ListFiles;          END;  --FormSWListProc     FormSWReadProc: FormSW.ProcType =          BEGIN          IF toolData # NIL THEN               BEGIN Tool.Destroy[floppyWH]; Heap.systemZone.FREE[@toolData]; END;          END;  --FormSWReadProc     FormSWWriteProc: FormSW.ProcType =          BEGIN          IF toolData # NIL THEN               BEGIN Tool.Destroy[floppyWH]; Heap.systemZone.FREE[@toolData]; END;          END;  --FormSWWriteProc     FormSWQuitProc: FormSW.ProcType =          BEGIN          IF toolData # NIL THEN               BEGIN Tool.Destroy[floppyWH]; Heap.systemZone.FREE[@toolData]; END;          END;  --FormSWQuitProc     FormSWVolHintsProc: FormSW.MenuProcType =          BEGIN          RETURN[               hints: DESCRIPTOR[               @ILT.toolData.volHints[0], ILT.toolData.volHints.length],                    freeHintsProc: HintsNoLongerBusy, replace: TRUE];          END;     HintsNoLongerBusy: FormSW.FreeHintsProcType = BEGIN END;     InfoDisk: PROCEDURE[] =          BEGIN          density: Floppy.Density;          sides: Floppy.Sides;          label: STRING &larr; [Floppy.maxCharactersInLabel];          freeSpace, largestBlock: LONG CARDINAL;          v: Floppy.VolumeHandle;          IF debug THEN {               Put.Line[toolData.fileSW, "AccessFloppy.Open...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          v &larr; AccessFloppy.Open[               ! AccessFloppy.Error =&gt; ERROR Abort["Can't open floppy"L]];          IF debug THEN {               Put.Line[toolData.fileSW, "GetAttributes...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          [freeSpace, largestBlock, , , density, sides] &larr; Floppy.GetAttributes[               v, label];          Put.Text[toolData.fileSW, "Floppy """L];          Put.Text[toolData.fileSW, label];          Put.Text[toolData.fileSW, """; "L];          Put.Text[toolData.fileSW, IF sides = one THEN "single"L ELSE "double"L];          Put.Text[toolData.fileSW, " sided; "L];          Put.Text[toolData.fileSW, IF density = single THEN "single"L ELSE "double"L];          Put.Line[toolData.fileSW, " density"L];          Put.LongDecimal[toolData.fileSW, freeSpace];          Put.Text[toolData.fileSW, " free pages; largest free block = "L];          Put.LongDecimal[toolData.fileSW, largestBlock];          Put.Line[toolData.fileSW, " pages"L];          AccessFloppy.Close[];          END;  --InfoDisk     ListFiles: PROCEDURE[] =          BEGIN          pattern: LONG STRING &larr; NIL;          v: Floppy.VolumeHandle;	            ListOne: EnumProc =               BEGIN               Put.CR[toolData.fileSW];               Put.Text[toolData.fileSW, name];               FOR i: CARDINAL IN [name.length + WritePartial[attributes]..24) DO                    Put.Text[toolData.fileSW, " "]; ENDLOOP;               Put.Number[toolData.fileSW, attributes.type, [10, FALSE, TRUE, 5]];               Put.Text[toolData.fileSW, "  "L];               Put.LongNumber[                    toolData.fileSW, attributes.totalSizeInBytes, [                    10, FALSE, TRUE, 9]];               Put.Text[toolData.fileSW, "  "L];               Put.Date[toolData.fileSW, attributes.createDate, noSeconds];               Put.Text[toolData.fileSW, "  "L];               Put.Date[toolData.fileSW, attributes.lastWrittenDate, noSeconds];               END;  --ListOne          IF debug THEN {               Put.Line[toolData.fileSW, "ListFiles: AccessFloppy.Open...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          v &larr; AccessFloppy.Open[               ! AccessFloppy.Error =&gt; ERROR Abort["Can't open floppy"L]];                    Put.Text[toolData.fileSW, " NAME                   "L]; --23           Put.Text[toolData.fileSW, " TYPE  "L];  -- 5+2          Put.Text[toolData.fileSW, "   LENGTH  "L];  -- 9+2          Put.Text[toolData.fileSW, "      CREATE          "L];  -- 20+2          Put.Line[toolData.fileSW, "  WRITE"L];          EnumerateFloppyFiles[               v, ListOne, pattern !               UNWIND =&gt; {AccessFloppy.Close[ ! Floppy.Error =&gt; CONTINUE]}];          AccessFloppy.Close[];          END;  --ListFiles     MakeAttributes: PROCEDURE [          file: MFile.Handle, name: LONG STRING,          attributes: AccessFloppy.Attributes, type: File.Type] =          BEGIN          attributes.version &larr; AccessFloppy.currentVersion;          attributes.type &larr; type;          attributes.lastWrittenDate &larr; Time.Current[];          attributes.name &larr; ALL[0];          attributes.clientDataLength &larr; 2;          attributes.clientData[0] &larr; dataVersion;          [length: attributes.totalSizeInBytes, create: attributes.createDate,               type: attributes.clientData[1]] &larr; MFile.GetProperties[file];          attributes.totalSize &larr; PagesFromBytes[attributes.totalSizeInBytes];          attributes.size &larr; attributes.totalSize;          attributes.length &larr; MIN[name.length, AccessFloppy.maxNameLength];          FOR i: CARDINAL IN [0..attributes.length) DO               attributes.name[i] &larr; LOOPHOLE[name[i]]; ENDLOOP          END;  --MakeAttributes     MakeCommands: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..5) OF CARDINAL &larr; [0, 20, 40, 60, 70];          nItems: CARDINAL = 8;          items &larr; AllocateItemDescriptor[nItems];          items[0] &larr; CommandItem[               tag: "Info"L, place: newLine, proc: FormSWInfoProc];          items[1] &larr; CommandItem[tag: "List"L, proc: FormSWListProc];          items[2] &larr; CommandItem[tag: "Read"L, proc: FormSWReadProc];          items[3] &larr; CommandItem[tag: "Write"L, proc: FormSWWriteProc];          items[4] &larr; CommandItem[               tag: "Format"L, place: newLine, proc: FormSWFormatProc];          items[5] &larr; CommandItem[tag: "Delete"L, proc: FormSWDeleteProc];          items[6] &larr; CommandItem[tag: "Duplicate"L, proc: FormSWDuplicateProc];          items[7] &larr; CommandItem[tag: "Quit"L, proc: FormSWQuitProc];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE];          END;  --MakeCommands     MakeParams: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          i, nVols: CARDINAL;          tabs: ARRAY [0..4) OF CARDINAL &larr; [0, 30, 60, 75];          nItems: CARDINAL = 2;          items &larr; AllocateItemDescriptor[nItems];          nVols &larr; ILT.ListLogicalVolumes[];          String.Copy[toolData.volName, ILT.toolData.volHints[0]];          FOR i IN [0..nVols) DO               IF String.Equivalent[ILT.toolData.volHints[i], "Lisp"L] THEN                    BEGIN                    String.Replace[                         @toolData.volName, ILT.toolData.volHints[i],                         Heap.systemZone];                    EXIT;                    END;               ENDLOOP;          items[0] &larr; StringItem[               tag: "Source Volume"L, place: newLine, string: @toolData.volName,               inHeap: TRUE, menuProc: FormSWVolHintsProc];          items[1] &larr; StringItem[               tag: "Pattern"L, string: @toolData.pattern, inHeap: TRUE];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE]          END;  --MakeParams     MakeSWs: Tool.MakeSWsProc =          BEGIN          addresses: ARRAY [0..4) OF ToolDriver.Address;          logName: STRING &larr; [20];          IF debug THEN {               Put.Line[ILT.toolData.fileSW, "MakeSWs...."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Tool.UnusedLogName[unused: logName, root: "FloppyOptions.log"L];          toolData.msgSW &larr; Tool.MakeMsgSW[window: window, lines: 1];          toolData.paramSW &larr; Tool.MakeFormSW[window: window, formProc: MakeParams];          toolData.commandSW &larr; Tool.MakeFormSW[               window: window, formProc: MakeCommands];          --note: logName is compulsory, else it bombs               toolData.fileSW &larr; Tool.MakeFileSW[window: window, name: logName];          --Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];          -- do the ToolDriver stuff          addresses &larr; [               [name: "msgSW"L, sw: toolData.msgSW],               --[name: "formSW"L, sw: toolData.formSW],               [name: "ParamSW"L, sw: toolData.paramSW], [               name: "CmdSW"L, sw: toolData.commandSW], [               name: "fileSW"L, sw: toolData.fileSW]];          ToolDriver.NoteSWs[               tool: "FloppyOptions"L, subwindows: DESCRIPTOR[addresses]];          END;  --MakeSWs     MakeTool: PROCEDURE RETURNS [wh: Window.Handle] =          BEGIN          RETURN[               Tool.Create[                    makeSWsProc: MakeSWs, initialState: default,                    --clientTransition: ClientTransition,                    name: "Floppy Options"L]];          --initialBox: [          --place: sw.BitmapPlace[[10, hisBox.dims.h]],          --dims: [hisBox.dims.w - 20, 180]]];          END;  --MakeTool     NameFromAttributes: PROCEDURE [attributes: AccessFloppy.Attributes]          RETURNS [LONG STRING] = INLINE {RETURN[LOOPHOLE[@attributes.length]]};     ParsePartial: PROCEDURE [name: LONG STRING]          RETURNS [offset: CARDINAL &larr; 0, length: CARDINAL &larr; LAST[CARDINAL]] =          BEGIN          h: Token.Handle;          i: CARDINAL;          IF name = NIL THEN RETURN;          FOR i IN [1..name.length) DO               IF name[i] = '[ THEN EXIT; REPEAT FINISHED =&gt; RETURN ENDLOOP;          h &larr; Token.StringToHandle[name, i + 1];          BEGIN          ENABLE UNWIND =&gt; [] &larr; Token.FreeStringHandle[h];          offset &larr; Token.Decimal[h];          SELECT h.break FROM               '. =&gt;                    IF h.getChar[h] = '. THEN                         length &larr; Token.Decimal[h] - offset + 1                    ELSE ERROR Token.SyntaxError[NIL];               '! =&gt; length &larr; Token.Decimal[h];               '] =&gt; NULL;               ENDCASE =&gt; ERROR Token.SyntaxError[NIL];          END;          name.length &larr; i;          [] &larr; Token.FreeStringHandle[h];          END;  --ParsePartial     PagesFromBytes: PROCEDURE [bytes: LONG CARDINAL] RETURNS [LONG CARDINAL] =          BEGIN          RETURN[(bytes + Environment.bytesPerPage - 1)/Environment.bytesPerPage];          END;  --PagesFromBytes     ReadFiles: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =          BEGIN          attributes: AccessFloppy.Attributes &larr; NIL;          name, altName, switches: LONG STRING &larr; NIL;          Write: Format.StringProc = Exec.OutputProc[h];          v: Floppy.VolumeHandle;          ReadOne: EnumProc =               BEGIN               mFile: MFile.Handle;               type: MFile.Type &larr; unknown;               destName: LONG STRING = IF altName = NIL THEN name ELSE altName;               Write[name];               Write["... "L];               IF attributes.clientDataLength = 2                    AND attributes.clientData[0] = dataVersion THEN                    type &larr; attributes.clientData[1];               Write["copying to "L];               Write[destName];               [] &larr; WritePartial[attributes];               Write["... "L];               mFile &larr; MFile.WriteOnly[                    destName, [], type, attributes.totalSizeInBytes !                    MFile.Error =&gt; {                         Format.Line[Write, "can't write on destination file"L];                         SetOutcome[error];                         GOTO return}];               MFile.SetProperties[                    file: mFile, type: type, length: attributes.totalSizeInBytes,                    create: attributes.createDate];               IF attributes.size # 0 THEN                    Floppy.CopyToPilotFile[                         floppyFile: fH,                         pilotFile: SpecialMFile.GetCapaWithAccess[mFile],                         firstFloppyPage: AccessFloppy.leaderLength,                         firstPilotPage:                         SpecialMFile.LeaderPages[] + attributes.offset,                         count: attributes.size];               Format.Line[Write, "copied"L];               MFile.Release[mFile];               EXITS return =&gt; NULL;               END;          v &larr; AccessFloppy.Open[               ! AccessFloppy.Error =&gt; ERROR Abort["Can't open floppy"L]];          DO               ENABLE                    UNWIND =&gt; {                         altName &larr; Exec.FreeTokenString[altName];                         name &larr; Exec.FreeTokenString[name];                         switches &larr; Exec.FreeTokenString[switches];                         Heap.systemZone.FREE[@attributes];                         AccessFloppy.Close[ ! Floppy.Error =&gt; CONTINUE]};               fFile: Floppy.FileHandle;               failed: BOOLEAN &larr; FALSE;               IF attributes = NIL THEN                    attributes &larr; Heap.systemZone.NEW[                         AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];               altName &larr; Exec.FreeTokenString[altName];               name &larr; Exec.FreeTokenString[name];               switches &larr; Exec.FreeTokenString[switches];               [name, switches] &larr; Exec.GetToken[h];               IF name = NIL AND switches = NIL THEN EXIT;               IF WildCards[name] THEN {                    EnumerateFloppyFiles[v, ReadOne, name]; LOOP};               IF switches # NIL AND switches.length # 0 AND switches[0] = 's THEN                    {                    switches &larr; Exec.FreeTokenString[switches];                    [altName, switches] &larr; Exec.GetToken[h]};               fFile &larr; AccessFloppy.LookUp[                    NSString.StringFromMesaString[name], attributes !                    AccessFloppy.Error =&gt;                         IF type = fileNotFound THEN {failed &larr; TRUE; CONTINUE}                         ELSE ERROR Abort["Floppy Error"L]];               IF failed THEN {                    Write[name];                    Format.Line[Write, " not found"L];                    SetOutcome[error];                    LOOP}               ELSE                    [] &larr; ReadOne[                         attributes, fFile, NameFromAttributes[attributes]];               ENDLOOP;          Heap.systemZone.FREE[@attributes];          AccessFloppy.Close[];          END;  -- ReadFile     WriteAccessFloppyError: PROCEDURE [type: AccessFloppy.ErrorType] =          BEGIN          Put.Text[toolData.fileSW, "AccessFloppy.Error["L];          Put.Text[               toolData.fileSW,               SELECT type FROM                    attributesNotAllowed =&gt; "attributesNotAllowed"L,                    fileNotFound =&gt; "fileNotFound"L,                    invalidParameter =&gt; "invalidParameter"L,                    nameInUse =&gt; "nameInUse"L,                    volumeNotOpen =&gt; "volumeNotOpen"L,                    ENDCASE =&gt; "?"L];          Put.Text[toolData.fileSW, "]"L];          END;  --WriteAccessFloppyError     WriteFloppyError: PROCEDURE [          Write: Format.StringProc, error: Floppy.ErrorType] =          BEGIN          Write["Floppy.Error["L];          Write[               SELECT error FROM                    badDisk =&gt; "badDisk"L,                    badSectors =&gt; "badSectors"L,                    endOfFile =&gt; "endOfFile"L,                    fileListFull =&gt; "fileListFull"L,                    fileNotFound =&gt; "fileNotFound"L,                    hardwareError =&gt; "hardwareError"L,                    incompatibleSizes =&gt; "incompatibleSizes"L,                    invalidFormat =&gt; "invalidFormat"L,                    invalidPageNumber =&gt; "invalidPageNumber"L,                    invalidVolumeHandle =&gt; "invalidVolumeHandle"L,                    insufficientSpace =&gt; "insufficientSpace"L,                    needsScavenging =&gt; "needsScavenging"L,                    noSuchDrive =&gt; "noSuchDrive"L,                    notReady =&gt; "notReady"L,                    onlyOneSide =&gt; "onlyOneSide"L,                    onlySingleDensity =&gt; "onlySingleDensity"L,                    initialMicrocodeSpaceNotAvailable =&gt;                         "initialMicrocodeSpaceNotAvailable"L,                    stringTooShort =&gt; "stringTooShort"L,                    volumeNotOpen =&gt; "volumeNotOpen"L,                    writeInhibited =&gt; "writeInhibited"L,                    zeroSizeFile =&gt; "zeroSizeFile"L,                    ENDCASE =&gt; "?"L];          Format.Char[Write, ']];          END;  --WriteFloppyError     WritePartial: PROCEDURE [attributes: AccessFloppy.Attributes]          RETURNS [chars: CARDINAL &larr; 0] =          BEGIN          CountedNumber: PROCEDURE [n: LONG CARDINAL] RETURNS [CARDINAL] = {               s: STRING = [12];               String.AppendLongDecimal[s, n];               Put.Text[toolData.fileSW, s];               RETURN[s.length]};          IF attributes.offset # 0 OR attributes.size # attributes.totalSize THEN {               chars &larr; 4;               Put.Char[toolData.fileSW, '[];               chars &larr; chars + CountedNumber[attributes.offset];               -- Write[".."L];               chars &larr;                    chars + CountedNumber[attributes.offset + attributes.size - 1];               Put.Char[toolData.fileSW, ']]};          END;  --WritePartial     WriteFiles: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =          BEGIN          attributes: AccessFloppy.Attributes &larr; NIL;          name, altName, switches: LONG STRING &larr; NIL;          fileType: File.Type &larr; FileTypes.tUntypedFile;          mFile: MFile.Handle;          Write: Format.StringProc = Exec.OutputProc[h];          IF gSwitches # NIL THEN               fileType &larr; [                    String.StringToNumber[                    gSwitches ! String.InvalidNumber =&gt; CONTINUE]];          [] &larr; AccessFloppy.Open[               ! AccessFloppy.Error =&gt; ERROR Abort["Can't open floppy"L]];          DO               ENABLE                    UNWIND =&gt; {                         IF altName # name THEN                              altName &larr; Exec.FreeTokenString[altName];                         name &larr; Exec.FreeTokenString[name];                         switches &larr; Exec.FreeTokenString[switches];                         IF mFile # NIL THEN MFile.Release[mFile];                         Heap.systemZone.FREE[@attributes];                         AccessFloppy.Close[ ! Floppy.Error =&gt; CONTINUE]};               fFile: Floppy.FileHandle;               failed: BOOLEAN &larr; FALSE;               mFileError: MFile.ErrorCode;               offset, length: CARDINAL;               IF attributes = NIL THEN                    attributes &larr; Heap.systemZone.NEW[                         AccessFloppy .AttributesRecord[AccessFloppy.maxDataSize]];               mFile &larr; NIL;               IF altName # name THEN altName &larr; Exec.FreeTokenString[altName];               name &larr; Exec.FreeTokenString[name];               switches &larr; Exec.FreeTokenString[switches];               [name, switches] &larr; Exec.GetToken[h];               IF name = NIL AND switches = NIL THEN EXIT;               [offset, length] &larr; ParsePartial[                    name !                    Token.SyntaxError =&gt; {                         Write[name];                         Format.Line[Write, " - bad name syntax"L];                         SetOutcome[error];                         LOOP}];               IF switches # NIL AND switches.length # 0 THEN                    SELECT switches[0] FROM                         's =&gt; {                              switches &larr; Exec.FreeTokenString[switches];                              [altName, switches] &larr; Exec.GetToken[h]};                         't =&gt; {                              fileType &larr; [                                   String.StringToNumber[                                   name ! String.InvalidNumber =&gt; CONTINUE]];                              switches &larr; Exec.FreeTokenString[switches];                              LOOP};                         ENDCASE               ELSE altName &larr; name;               mFile &larr; MFile.ReadOnly[                    name, [] ! MFile.Error =&gt; {mFileError &larr; code; CONTINUE}];               IF mFile = NIL THEN                    SELECT mFileError FROM                         noSuchFile =&gt; {                              Format.Line[Write, " not found"L];                              SetOutcome[error];                              LOOP};                         conflictingAccess =&gt; {                              Format.Line[Write, " conflicting access"L];                              SetOutcome[error];                              LOOP};                         ENDCASE =&gt; ERROR Abort[" unexpected MFile.Error"L];               MakeAttributes[mFile, altName, attributes, fileType];               attributes.offset &larr; offset;               attributes.size &larr; MIN[length, attributes.totalSize - offset];               Write[name];               [] &larr; WritePartial[attributes];               Write["... "L];               Write["copying to "L];               Write[altName];               Write["... "L];               fFile &larr; AccessFloppy.CreateFile[                    attributes !                    AccessFloppy.Error =&gt;                         IF type = nameInUse THEN {failed &larr; TRUE; CONTINUE};                    Floppy.Error =&gt;                         SELECT error FROM                              fileListFull =&gt; ERROR Abort["too many files"L];                              insufficientSpace =&gt; ERROR Abort["floppy is full"L];                              ENDCASE];               IF failed THEN {                    Format.Line[Write, "floppy file already exists - skipped"L];                    SetOutcome[error]}               ELSE {                    IF attributes.size # 0 THEN                         Floppy.CopyFromPilotFile[                              floppyFile: fFile,                              pilotFile: SpecialMFile.GetCapaWithAccess[mFile],                              firstFloppyPage: AccessFloppy.leaderLength,                              firstPilotPage: SpecialMFile.LeaderPages[] + offset,                              count: attributes.size];                    Format.Line[Write, "copied"L]};               MFile.Release[mFile];               ENDLOOP;          Heap.systemZone.FREE[@attributes];          AccessFloppy.Close[];          END;  -- WriteFiles     WildCards: PROCEDURE [pattern: LONG STRING] RETURNS [BOOLEAN] =          BEGIN          IF pattern # NIL THEN               FOR i: CARDINAL IN [0..pattern.length) DO                    SELECT pattern[i] FROM '*, '# =&gt; RETURN[TRUE]; ENDCASE;                    ENDLOOP;	  IF debug THEN {	  	Put.Line[toolData.fileSW, " NOT WildCards"L];		};          RETURN[FALSE];          END;     &lt;&lt;	       DoIt: Exec.ExecProc =          BEGIN          MyCommands: TYPE = MACHINE DEPENDENT{               read(0), write, list, delete, information, format,               noMatch(StringLookUp.noMatch)};          DefinedOptions: TYPE = MyCommands [read..format];          commandTable: ARRAY DefinedOptions OF LONG STRING &larr; [               read: "Read"L, write: "Write"L, list: "List"L, delete: "Delete"L,               information: "Information"L, format: "Format"L];          index: MyCommands;          Write: Format.StringProc = Exec.OutputProc[h];          command, switches: LONG STRING &larr; NIL;          WHILE outcome = normal DO               ENABLE                    UNWIND =&gt; {                         command &larr; Exec.FreeTokenString[command];                         switches &larr; Exec.FreeTokenString[switches]};               [command, switches] &larr; Exec.GetToken[h];               IF command = NIL AND switches = NIL THEN EXIT;               BEGIN               ENABLE {                    Abort =&gt; {Format.Line[Write, s]; GOTO abort};                    AccessFloppy.Error =&gt; {                         Write["unexpected "L];                         WriteAccessFloppyError[Write, type];                         Format.Char[Write, Ascii.CR];                         GOTO abort};                    AccessFloppy.InconsistentFile =&gt; {                         Format.Line[Write, "AccessFloppy.InconsistentFile"L];                         GOTO abort};                    AccessFloppy.InvalidVersion =&gt; {                         Format.Line[Write, "AccessFloppy.InvalidVersion"L];                         GOTO abort};                    AccessFloppy.NoRoomForClientData =&gt; {                         Format.Line[Write, "AccessFloppy.NoRoomForClientData"L];                         GOTO abort};                    Floppy.Error =&gt; {                         IF error = writeInhibited THEN                              Format.Line[Write, "Floppy is write protected"L]                         ELSE {                              Write["unexpected "L];                              WriteFloppyError[Write, error];                              Format.Char[Write, Ascii.CR]};                         GOTO abort};                    SetOutcome =&gt; {                         IF outcome &lt; value THEN outcome &larr; value; RESUME }};               index &larr; LOOPHOLE[StringLookUp.InTable[                    key: command,                    table: DESCRIPTOR[BASE[commandTable], LENGTH[commandTable]]]];               SELECT index FROM                    read =&gt; ReadFiles[switches, h];                    write =&gt; WriteFiles[switches, h];                    list =&gt; ListFiles[switches, h];                    delete =&gt; DeleteFiles[switches, h];                    information =&gt; InfoDisk[switches, h];                    format =&gt; FormatDisk[switches, h];                    ENDCASE =&gt; {Write["Unknown command"L]; GOTO abort};               EXITS abort =&gt; outcome &larr; abort;               END;               command &larr; Exec.FreeTokenString[command];               switches &larr; Exec.FreeTokenString[switches];               ENDLOOP;          END;&gt;&gt;     Help: Exec.ExecProc =          BEGIN          Write: Format.StringProc = Exec.OutputProc[h];          Write[               "Floppy.~ &lt;command&gt; &lt;args&gt;&lt;args&gt;:    &lt;fileList&gt;: list of file names; /s on a name uses next name as destination    &lt;wildList&gt;: names may contain * and #&lt;command&gt;:  Read &lt;fileList&gt; | &lt;wildList&gt; - copies files from floppy  Write &lt;fileList&gt; - copies files to floppy    number/t sets File.Type for following files (default tUntypedFile)    add [firstPage..lastPage] to name for writing partial files  List/ltdwv &lt;wildList&gt; - shows files on floppy; switches show:    l =&gt; length, t =&gt; type, d =&gt; create date, w =&gt; write date, v =&gt; everything  Delete &lt;wildList&gt; - deletes files from floppy  Info - gives information about the floppy volume  Format - formats floppy destroying previous contents, args are:    name/n gives the volume a name (quote names with special characters)    number/f sets max number of files to number (default 64)"L]          END;     END.    </pre>
  </body>
</html>
