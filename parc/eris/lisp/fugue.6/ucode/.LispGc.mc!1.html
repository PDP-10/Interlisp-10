<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Fugue.6>Ucode>LispGc.mc!1</title>
  </head>
  <body>
    <pre>
{File name LispGc.mcDescription:  part of DandeLion InterLisp EmulatorAuthor: CharnleyLast edited by Charnley: 16-Aug-83 14:39:35 Created by Charnley: April 18, 1983  9:45 AM}SetTask[0];{*******************************************************************	GCSCAN1, GCSCAN2	1 or 2 clicks per entry*******************************************************************}{	GCScan opcodes:	on entry, TOS contains (index + 1)  into the HashTable	index is first entry tested.	on exit, TOS contains (index) found, or NIL if table exhausted.	GcScan1 finds (collision = 1) or (stk = cnt = 0).	GcScan2 finds (collision = 1) or (stk = 1).	L2 = 0 if GcScan1, L2 = 2 if GcScan2	L1 = 0 if more to scan, L1 = 2 if on last entry	Interrupts are tested every 256 entries if no entry found by then}GcScan1:	Q &larr; 0, {L2 = 0 for GcScan1} GOTO[GcSCom],	c1,opcode[173'b];GcScan2:	Q &larr; 0, L2 &larr; 2, {L2 &larr; 2 for GcScan2}	c1,opcode[174'b];GcSCom:	TT &larr; TOS - 1, NegBr, L1 &larr; 0,	c2;	rhTT &larr; crhHashTable, BRANCH[GcScanStart, GcZero],	c3;GcScanStart:	MAR &larr; [rhTT, TT  + 0], GOTO[GcSmarP1],	c1;GcScanLoop:	TT &larr; MAR &larr; [rhTT, TT - 1],	c1;GcSmarP1:	Rx &larr; Q, ZeroBr, BRANCH[$, GcSPgC, 1],	c2, at[1,4,GcSDispX];	Q &larr; MD, BRANCH[GcStest, GcScanLoop],	c3;{	Through here if Entry is non-zero	}GcStest:	Ybus &larr; Rx and 1, ZeroBr{test coll bit}, L2Disp,	c1;GcST1:	Rx &larr; Rx LRot8, DISP2[GcSdisp],	c2;{GcS1,coll}	GOTO[GcScanFound],	c3,at[0,4,GcSdisp];{GcS1,no coll}	Ybus &larr; Rx - 2, PgCarryBr, L1Disp, GOTO[GcSchmore],	c3,at[1,4,GcSdisp];GcSF:{GcS2,coll}	GOTO[GcScanFound],	c3,at[2,4,GcSdisp];{GcS2,no coll}	Ybus &larr; Rx and 2, ZeroBr, L1Disp, GOTO[GcSchmore],	c3,at[3,4,GcSdisp];GcSchmore:	{passing thru here makes TT one too small}	TT &larr; MAR &larr; [rhTT, TT - 1], DISP2[GcSDispX],	c1;	BRANCH[GcFoundFix,GcFoundPg,1],	c2, at[0,4,GcSDispX];	CANCELBR[GcSAllThru,2],	c2, at[3,4,GcSDispX];	BRANCH[GcFoundFix,GcFoundPg,1],	c2, at[2,4,GcSDispX];GcFoundFix:	TT &larr; TT + 1, GOTO[GcScanFound],	c3;GcFoundPg:	TT &larr; TT - 0FF, GOTO[GcScanFound],	c3;GcSPgC:	TT &larr; TT - 0FF - 1, CANCELBR[$],	c3; {fix TT}	Ybus &larr; TT, NegBr,	c1;{test for end}	BRANCH[$, GcSLastRx],	c2;{	INTERRUPT TESTING DISABLED}	GOTO[GcScanStart],	c3;{GcSinttest:	{gc Interrupt test here,}	Noop,	c1;	Q &larr; Rx, MesaIntBr,	c2;	Rx &larr; 0, BRANCH[GcScanStart, $],	c3;	Ybus &larr; uWDC, NZeroBr,	c1;	Ybus &larr; uWP, ZeroBr, BRANCH[$, GcSIgnoreInt],	c2;	uWP &larr; Rx, ClrIntErr, BRANCH[GcSIntHere, GcSS1],	c3;GcSIntHere:	Rx &larr; 1,	c1;	uWDC &larr; Rx,	c2;	Rx &larr; KbdFXP, L2 &larr; 0, GOTO[GcSpunt],	c3;GcSpunt:	{*****}Noop, GOTO[ufn2],	c1;GcSIgnoreInt:	ClrIntErr, CANCELBR[GcSS1],	c3;GcSS1:	MAR &larr; [rhTT, TT  + 0], GOTO[GcSmarP1],	c1;}GcSLastRx:	Noop,	c3;	Noop,	c1;	Ybus &larr; Rx, ZeroBr, L1 &larr; 2,{L1 = 2 during last test}	c2;	BRANCH[GcSTestX, GcSExit],	c3;GcSTestX:	Ybus &larr; Rx and 1, ZeroBr, L2Disp, GOTO[GcST1],	c1;GcZero:	TOSH &larr; 0, L2 &larr; 0, GOTO[GcSExit2],	c1;GcScanFound:	L2 &larr; 0, GOTO[GcSExit2],	c1;GcSAllThru:	TT &larr; TT + 1, GOTO[GcSExit],	c3;GcSExit:	TOSH &larr; 0, L2 &larr; 0, GOTO[GcSExit2],	c1;GcSExit2:	PC &larr; PC + PC16, IBDisp,	c2;	TOS &larr; TT + 1, L2 &larr; 0, DISPNI[OpTable],	c3;	{END}</pre>
  </body>
</html>
