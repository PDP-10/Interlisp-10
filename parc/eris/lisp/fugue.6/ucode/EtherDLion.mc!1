{File name:  EtherDLion.mc Description: Dandelion Ethernet Microcode, Author: Sandman, Created: October 23, 1980  10:42 AM, Last Edited:	Jim Frandeen, March 16, 1982  11:49 AM,		Fix bug that was storing the mask into the wrong word.	Jim Frandeen, March 5, 1982  3:01 PM,		Fix bug encountered if 1st word of receive packet buffer		lies in last word page.	Amy Fasnacht, February 18, 1982  12:02 PM,		Call EMap to restore register E after MAR on second word of input buffer	Dan Davies, February 17, 1982  3:38 PM,		Fix bug encountered if 1st word of receive packet buffer		lies in last word of 64K space.  Also shorten code.	Jim Frandeen, February 3, 1982  9:53 AM,		If waiting to transmit is interrupted, remember where we		we were so we can continue there next time.		Limit random number to 10 bits.	HGM, August 28, 1981  10:45 AM,		Flap transmitter after sending (2000ft bug) (1mi)	HGM, June 25, 1981  11:30 PM,		Load host number if transmit first		Move Purge EStrobe to c2 for hardware InUnderOut fix (1 mi)	HGM, June 11, 1981  12:40 AM, Runt filter (4 mi)	Sandman, November 12, 1980  11:42 AM	HGM, June 10, 1981  9:38 PM, NegBr @EDeferLoop to avoid long delays	Garner, April 21, 1981  8:01 PM:  rhEE_0 @EFullMask}k40(0,4939)(1,5644)(2,6350)(3,7056)(4,14817)\f1{*****************************************************************************Definitions*****************************************************************************}{Offsets and Magic locations}Set[IOPage.ECSB, 0C0];Set[ECSB.host0, 0];Set[ECSB.host1, 1];Set[ECSB.host2, 2];Set[ECSB.icb, 3];Set[ECSB.iWakeup, 4];Set[ECSB.ocb, 5];Set[ECSB.oWakeup, 6];Set[ECSB.lost, 7];Set[IOPage.ECSB.host0, Add[IOPage.ECSB, ECSB.host0]];Set[IOPage.ECSB.host1, Add[IOPage.ECSB, ECSB.host1]];Set[IOPage.ECSB.host2, Add[IOPage.ECSB, ECSB.host2]];Set[IOPage.ECSB.icb, Add[IOPage.ECSB, ECSB.icb]];Set[IOPage.ECSB.iWakeup, Add[IOPage.ECSB, ECSB.iWakeup]];Set[IOPage.ECSB.ocb, Add[IOPage.ECSB, ECSB.ocb]];Set[IOPage.ECSB.oWakeup, Add[IOPage.ECSB, ECSB.oWakeup]];Set[IOPage.ECSB.lost, Add[IOPage.ECSB, ECSB.lost]];Set[IOCB.size, 0];Set[IOCB.buffer, 1];Set[IOCB.bufferHi, 2];Set[IOCB.mask, 3];Set[IOCB.used, 4];Set[IOCB.completion, 5];Set[IOCB.next, 6];Set[IOCB.spare, 7];Set[eEnableRcv, 1];Set[eTurnOff, 2];Set[eLocalLoop, 4];Set[eLoopBack, 8];Set[eOff, 0];Set[eEnableTrn, 1];Set[eLastWord, 2];Set[eDefer, 4];Set[eEnableTrnDefer, 5];Set[eEnableTrnLastWord, 3];Set[eInitialCountdown, 14]; {14X = 20D; 51.2us*20 ~ 1ms}k40\f1Set[L6.EReceive, 0];Set[L6.EXmit, 1];Set[L6.Host0, 2];Set[L6.Host1, 3];Set[L6.Host2, 4];Set[L6.NoICB, 5];k40\f1Set[L6.Remap, 1];Set[L6.ERMap, 2];Set[L6.ETMap, 3];Set[L6.EREndMap, 4];Set[L6.EXmitAbort, 5]; {1 MOD 2}Set[L6.ETEndMap, 6];Set[L6.ETCross, 7]; {1 MOD 2}Set[L6.ERCross, 0C]; {in instruction with GOTO[ERead]}Set[L6.ERCrossEnd, 9];k40\f1	SetTask[2];	StartAddress[EColdStart];{*****************************************************************************Initial code*****************************************************************************}k40\f1EColdStart:	rhE _ E _ uIOPage, CANCELBR[$,0F],	c1;	Xbus _ EStatus, XLDisp,	c2;	rhEE _ 0, BRANCH[EHostTR, EStop, 2],	c3;{Fetch host and input IOCB from CSB}EHostTR:	MAR _ [rhE, IOPage.ECSB.host0+0], L6_L6.Host0,	c1, at[2,4,EStop];EHost:	uXmitInterrupt _ 0, L6Disp, CALL[EFetch3],	c2;	MAR _ [rhE, IOPage.ECSB.host1+0], L6_L6.Host1,	c1, at[L6.Host0,10,EFetch];	uEHost0 _ EE, L6Disp, CALL[EFetch3],	c2;	MAR _ [rhE, IOPage.ECSB.host2+0], L6_L6.Host2,	c1, at[L6.Host1,10,EFetch];	uEHost1 _ EE, L6Disp, CALL[EFetch3],	c2;	MAR _ [rhE, IOPage.ECSB.icb+0]	c1, at[L6.Host2,10,EFetch];	uEHost2 _ EE, L6_L6.EReceive, GOTO[EDone],	c2;EStart:	rhE _ E _ uIOPage, CANCELBR[$,0F],	c1;	Xbus _ EStatus, XLDisp,	c2;	rhEE _ 0, DISP2[EGo],	c3;ERecieve:	MAR _ [rhE, IOPage.ECSB.icb+0],	c1, at[2,4,EGo];	L6_L6.EReceive, CALL[ECBFetch],	c2;{map input buffer}ERGotIOCB:	Map _ [rhEE, EE], CALL[EMap2],	c1, at[L6.EReceive,10,EFetch];	MAR _ [rhE, EE+0],	c1, at[L6.EReceive,10,EMapRets];	MDR _ E _ EIData, L6 _ L6.ERMap,	c2;	uEDest0 _ E, CALL[EMap], {to restore E only}	c3; {be prepared for page cross}	MAR _ E _ [rhE, EE+1], L6 _ L6.Remap,	c1, at[L6.ERMap, 10, EMapRets];	MDR _ EE _ EIData, BRANCH[$, RemapWord2, 1],	c2;NoWd2Remap:	uEDest1 _ EE, GOTO[StoreWord3],	c3, at[1,4,RemapWord2];{Get here if the second word of the packet was on a new page.  Packets buffers begin at addresses ending in 3 MOD 4.  A page boundry can only occur after the first word.uEBuffer contains the value of EE at the time of the MAR _ above.}RemapWord2:		uEDest1 _ EE, 	c3, at[3,4,NoWd2Remap];	E _ 0,			c1;	Noop,CALL[ECNextPage],	c2;	MAR _ E _ [rhE,0+0],	c1, at[L6.Remap,10, EMapRets];	MDR _ EE _ uEDest1, GOTO[NoWd2Remap],	c2;{Get here whether or not the second word was on a new page.  Store the third packet word which is also the final destination address word.}StoreWord3:	MAR _ E _ [rhE, E+1],	c1;	MDR _ EE _ EIData, CANCELBR[$,0],	c2;	[] _ EE xor uEHost2, NZeroBr,	c3; {start check for correct address}	EE _ uEDest1, BRANCH[$,ECheckBCast2],	c1;	[] _ EE xor uEHost1, NZeroBr,	c2, at[0,2,ECheckBCast2];	EE _ uEDest0, BRANCH[ECheckAddr0, $],	c3;	GOTO[ECheckBCast2],	c1, at[1,2,ECheckAddr0];ECheckAddr0:	[] _ EE xor uEHost0, ZeroBr,	c1, at[0,2,ECheckAddr0];ECheckBCast2:	EE _ ~uEDest0, ZeroBr, BRANCH[$, MyAddr],	c2, at[1,2,ECheckBCast2];	EE _ ~uEHost0, ZeroBr, BRANCH[ECheckAny, EInput],	c3, at[0,2,MyAddr];MyAddr:	CANCELBR[EInput,1],	c3, at[1,2,MyAddr];ECheckAny:	EE _ uESize, BRANCH[NotMeC2, EInputC2],	c1, at[0,2,EInput];EInput:	EE _ uESize, CANCELBR[$,1],	c1, at[1,2,EInput];EInputC2:	EE _ EE-2, L6 _ L6.ERCross, GOTO[ERead],	c2, at[1,2,NotMeC2];NotMeC2:	EStrobe, GOTO[EDone],	c2, at[0,2,NotMeC2]; {purge rest of					      packet and quit}{main input loop}EInLoop:	MAR _ E _ [rhE, E + 1], EtherDisp, BRANCH[$,EITooLong],	c1;	MDR _ EIData, DISP4[ERead, 0C],	c2;ERead:	EE _ EE - 1, ZeroBr, GOTO[EInLoop],	c3, at[0C,10,ERead];	E _ uESize, GOTO[EReadEnd],	c3, at[0D,10,ERead];	E _ EIData, uETemp2 _ EE, GOTO[ERCross],	c3, at[0E,10,ERead];	E _ EIData, uETemp2 _ EE, L6_L6.ERCrossEnd, GOTO[ERCross],	c3, at[0F,10,ERead];k40\f1{remap buffer page}ERCross:	uETemp _ E, CALL[ECMap],	c1;	MAR _ E _ [rhE, 0+0],	c1, at[L6.ERCross,10,EMapRets];ERCrossStore:	MDR _ uETemp, DISP4[ERead, 0C],	c2;k40\f1	MAR _ E _ [rhE, 0+0], EtherDisp, GOTO[ERCrossStore],	c1, at[L6.ERCrossEnd,10,EMapRets];k40\f1{packet too big.  make it look like size was -1}EITooLong:	E _ 0, CANCELBR[$,0F],	c2;	EE _ 0, GOTO[EReadEnd],	c3;EReadEnd:	EE _ E - EE - 1, rhEE _ 0,	c1;	EE _ EE - 6,		c2;	[] _ EE, NegBr,		c3;	EE _ EE + 6, BRANCH[$,EReadPurgeC2],	c1;	uETemp _ EE, L6_L6.EREndMap, CALL[EMapIOCB],	c2;{store final count, update csb, set interrupt, return to EReadPurge}	MAR _ [rhE, EE+IOCB.used],	c1, at[L6.EREndMap,10,EMapRets];	MDR _ uETemp, CANCELBR[$,0],	c2;	L6_L6.EReceive, CALL[EFinish],	c3;{set purge mode, EStrobe must be in c1 or c2, for wakeup pipeline}EReadPurge:	Noop,			c1;{EStrobe in c2 means purge (rest of) input packet}EReadPurgeC2: EStrobe,			c2;EDone:	GOTO[EStart],		c3;	k40\f1{*****************************************************************************Tranmit Code*****************************************************************************}k40\f1ETransmit:	MAR _ [rhE, IOPage.ECSB.ocb+0], L6_L6.EXmit,	c1, at[0,4,EGo];EXmitx:	CALL[ECBFetch],	c2;{get backoff mask}ETGotIOCB:	MAR _ [rhE, E+IOCB.mask],	c1, at[L6.EXmit,10,EFetch]; {save addr of						mask}	uEBuffer _ EE, CANCELBR[$,0],	c2;	EE _ MD, XHDisp,	c3;	MAR _ [rhE, E+IOCB.mask], BRANCH[$,EFullMask,1],	c1;	MDR _ EE+EE+1, CANCELBR[$,0],		c2; {write back shifted mask}	uEOldMask _ EE, EE _ EE LShift1, SE _ 1, ZeroBr,	c3; {save old mask and shift it.  If						it was zero, this is the first time						for this packet.}	E _ eInitialCountdown, BRANCH[ERandom,EFirst],	c1; {load time to wait before first packet						in case it is needed and decide.						NOTE rhEE was loaded in ECBFetch.}ERandom:	E _ uClockLow, GOTO[EHaveCntAndMsk],	c2, at[0,2,EFirst]; {load random number}EFirst:	EE _ 0FF,			c2, at[1,2,ERandom]; {Load Noop mask}EHaveCntAndMsk: [] _ uXmitInterrupt, ZeroBr,	c3; {do we want the calculated mask						at all?}EHaveCount:	EOCtl _ eEnableTrnDefer, E _ E and EE, BRANCH[EContinueLoop, EStartDeferLoop], c1; {start wait, finish mask						calculation and decide if calculated						mask is needed.}{Come here if we are we got interrupted by a packet during the defer loop. We continue where we left off.}EContinueLoop: E _ uXmitInterrupt, GOTO[EDeferLoopx],	c2, at[0,2,EStartDeferLoop];EStartDeferLoop: E _ E and uE3FF, GOTO[EDeferLoopx],	c2, at[1,2,EContinueLoop]; {limit defer						count to 10 bits.}{This loop tests Attn from the previous wakeup.If Attn is on, we will get another wakeup right away.If the timer counts out at the wrong time we will (slowly) discover itafter trying to send the preamble. (The hardware will ignore that.)}EDeferLoop:	E _ E - 1, NegBr, BRANCH[$, ERecieveUnder,0E],	c1;	EOCtl _ eEnableTrnDefer, BRANCH[$,EStartXmit],	c2;EDeferLoopx:	EE _ uEBuffer, EtherDisp, GOTO[EDeferLoop],	c3;EStartXmit:	EOCtl _ eEnableTrn,	c3;{send preamble}	E _ 3,			c1;EPreamble:	E _ E - 1, ZeroBr,	c2;	EOData _ uEPreamble, BRANCH[$, ELastPreamble],	c3;	uXmitInterrupt _ 0, EStrobe, GOTO[EPreamble],	c1;ELastPreamble:	Map _ [rhEE, EE], EStrobe, L6_L6.ETMap,	c1;	EOData _ uELastPreamble, L6Disp, CALL[EMapFetch],	c2;	MAR _ E _ [rhE, EE + 0], EStrobe,	c1, at[L6.ETMap,10,EMapRets];	EE _ uESize, GOTO[EXmit],	c2;EOutLoop:	MAR _ E _ [rhE, E + 1], EtherDisp, EStrobe,	c1;EOutLoopx:	EE _ EE - 1, rhEE _ 0, ZeroBr, DISP4[EXmit, 0C],	c2;EXmit:	EOData _ MD, BRANCH[EOutLoop, EOutDone],	c3, at[0C,10,EXmit];	Xbus _ EStatus, XwdDisp, L6_L6.EXmitAbort, CANCELBR[EXmitAttn,1],	c3, at[0D,10,EXmit];	EE _ EE + 1, L6_L6.ETCross, CANCELBR[EXmitCross,1],	c3, at[0E,10,EXmit];EXmitQuit:	Xbus _ EStatus, XwdDisp, L6_L6.EXmitAbort, CANCELBR[EXmitAttn,1],	c3, at[0F,10,EXmit];EOutDone:	EStrobe,			c1;	EOCtl _ eEnableTrnLastWord,	c2;	EStrobe,			c3;EXmitEnd:	Xbus _ EStatus, XwdDisp,	c1;	EOCtl _ eEnableTrn, BRANCH[ENoColl, EColl, 1],	c2;EColl:	GOTO[ECollision],	c3;ENoColl:	EE _ uEIOCB, L6_L6.ETEndMap, GOTO[EMap],	c3;k40\f1{store status, update csb, set interrupt, return to EStart}EXmitEndx:	MAR _ [rhE, EE + IOCB.completion], L6_L6.EXmit, CALL[EFinish2],	c1, at[L6.ETEndMap,10,EMapRets];{Turn tran off to reset transmitter, and  back on for more wakeups in case there is another IOCB to process}EXmitDone:	EOCtl _ eOff, GOTO[EXmitColl],	c1;{page cross on transmit}EXmitCross:	uETemp2 _ EE, CALL[ECMap],	c1;	MAR _ E _ [rhE, 0+0], GOTO[EOutLoopx],	c1, at[L6.ETCross,10,EMapRets];k40\f1{attention during transmit loop}EXmitAttn:	EOCtl _ eOff, rhEE _ 0, DISP2[EXmitA],	c1;EXmitA:	EOCtl _ eEnableTrn, GOTO[EMapIOCB],	c2, at[0,4,EXmitA];k40\f1	EOCtl _ eEnableTrn, GOTO[ENoColl],	c2, at[1,4,EXmitA];EXmitColl:	EOCtl _ eEnableTrn, GOTO[EDone],	c2, at[2,4,EXmitA];	EOCtl _ eEnableTrn, GOTO[EDone],	c2, at[3,4,EXmitA];{Come here if we are interrupted while waiting to transmit. Save the count so that we can continue where we left off.}ERecieveUnder:	uXmitInterrupt _ E, CANCELBR[EXmitQuit,1],	c2;EXmitAbortx:	MAR _ [rhE, EE + IOCB.mask],	c1, at[L6.EXmitAbort,10,EMapRets];	MDR _ uEOldMask, CANCELBR[EDone,0],	c2;{backoff mask full}EFullMask:	rhEE _ 0, CANCELBR[$,0],	c2;	Noop,	c3;	MAR _ [rhE, E + IOCB.mask],	c1;	MDR _ EE, CANCELBR[ENoColl,0],	c2;ECollision:	EOCtl _ eOff, GOTO[EXmitColl],	c1;k40\f1{*****************************************************************************Stopping code*****************************************************************************}k40\f1EStop:	EOCtl _ eOff, GOTO[EStopx],	c1, at[3,4,EStop];	EOCtl _ eOff, GOTO[EStopx],	c1, at[1,4,EGo];	EOCtl _ eOff, GOTO[EStopx],	c1, at[3,4,EGo];EStopx:	EICtl _ eOff,	c2;	GOTO[EColdStart],	c3;k40\f1{*****************************************************************************Common Code*****************************************************************************}k40\f1{Store status, fetch next iocb}EFinish:	MAR _ [rhE, EE+IOCB.completion],	c1;EFinish2:	MDR _ EStatus, CANCELBR[$,0],	c2;	Noop,	c3;	MAR _ [rhE, EE+IOCB.next], L6Disp,	c1;	rhE _ E _ uIOPage, BRANCH[EREnd, ETEnd, 2],	c2;EREnd:	EE _ MD,	c3;	MAR _ E _ [rhE, IOPage.ECSB.icb+0], GOTO[ECSBUpdate],	c1;ETEnd:	EE _ MD,	c3;	MAR _ E _ [rhE, IOPage.ECSB.ocb+0], GOTO[ECSBUpdate],	c1;ECSBUpdate:	MDR _ EE,	c2;	Noop,	c3;	MAR _ [rhE, E+1],	c1;	CANCELBR[$,0],	c2;	E _ MD,	c3;	EE _ uWP, MesaIntRq,	c1;	EE _ E or EE, L6Disp,	c2;	uWP _ EE, BRANCH[EReadPurge, EXmitDone],	c3;k40\f1{page cross map update for inner loops}ECMap:	E _ 0FF,		c2;ECNextPage:	EE _ uEBuffer,	c3;	E _ EE + E + 1, CarryBr,	c1;	uEBuffer _ E, BRANCH[$, ECrossCarry],	c2;ECMapx:	rhEE _ uEBufferHi,	c3;	Map _ [rhEE, E],	c1;	EE _ uETemp2, L6Disp, GOTO[EMapFetch],	c2;ECrossCarry:	EE _ uEBufferHi,	c3;	EE _ EE + 1,	c1;	uEBufferHi _ EE, GOTO[ECMapx],	c2;{general mapping; don't care if uEBuffer smashed if mapping IOCB}EMapIOCB:	EE _ uEIOCB,	c3;EMap:	Map _ [rhEE, EE],	c1;EMap2:	uEBuffer _ EE, L6Disp,	c2;EMapFetch:	rhE _ E _ MD, RET[EMapRets],	c3;{IOCB fetch}ECBFetch:	EE _ MD,	c3;	Map _ uEIOCB _ [rhEE, EE], ZeroBr,	c1;	L6Disp, BRANCH[$, ENoCB],	c2;	rhE _ E _ MD, CANCELBR[$,1],	c3;	MAR _ E _ [rhE, EE+IOCB.size],	c1;	CANCELBR[$,0],	c2;	EE _ MD,	c3;	MAR _ [rhE, E+IOCB.bufferHi],	c1;	uESize _ EE, CANCELBR[$,0],	c2;	rhEE _ EE _ MD,	c3;	MAR _ [rhE, E+IOCB.buffer],	c1;EFetch2:	uEBufferHi _ EE, L6Disp, CANCELBR[$,0],	c2;EFetch3:	EE _ MD, RET[EFetch],	c3;ENoCB:	BRANCH[ENoICB, ENoOCB],	c3;ENoOCB:	EOCtl _ eOff,	c1;	Noop, GOTO[EDone],	c2;k40\f1ENoICB:	MAR _ [rhE, IOPage.ECSB.lost+0], L6_L6.NoICB, GOTO[EFetch2],	c1;	MAR _ [rhE, IOPage.ECSB.lost+0],	c1, at[L6.NoICB,10,EFetch];	MDR _ EE + 1, EStrobe, GOTO[EDone],	c2;k40\f1{END}k40\f1k40\f1