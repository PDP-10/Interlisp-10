<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Fugue.6>BCPL>LispBCPLSources.dm!1>RaidStack.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">// RaidStack.bcpl. Raid printing routines for Lisp stack<br>// last edited May 31, 1983  9:46 PM by Bill van Melle<br>// last edited March 24, 1983  9:28 PM by Bill van Melle<br>// last edited December 14, 1982  3:27 PM by Bill van Melle<br>// last edited November 16, 1982  2:42 PM by Bill van Melle<br>// last edited June 15, 1982  11:09 PM by Bill van Melle<br>// last edited September 19, 1981  3:05 PM by Bill van Melle<br>// From RaidPrint.bcpl August 26, 1981 by Bill van Melle<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Raid.decl"<br><br>external [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures defined<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LispStack; LispFrame; ShowStackBlocks<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrintFxtn; PrintBF; PrintAddrs; PrintBytes <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GetFXP</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Get current frame extension<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GetStkBlkType<br>        <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics defined<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lastFrame; linkUsed; raidStackFX<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dsp; keys; @lvNIL; @lvVPtr; @VPtr0; @VPtr1<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrintPtr; PrintName; Lprint; RaidReset; CRLF; ReadNum; ReadChar<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Negate; Divide; Usc; Min;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wc; Ws; Wo; Wn; Wb; <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EqNIL; VP; Gets; UCase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@BGetBasePtr; @XGetBasePtr; @XGetBase32; IGetBase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@SGetBase; @RRead; @BGetBase; @XGetBase; @XGetBase1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GetLmarg; SetLmarg; GetBitPos<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>static [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">raidStackFX = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lastFrame = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">linkUsed = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>manifest [ usedClink = 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   usedAlink = 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> ]<br><br>manifest [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">firstContext = 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">// these really ought to come from Lisp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">maxContext = 6<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkBlkType = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Offsets in stack blocks<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> ]<br><br>let LispStack(FX; numargs na) be<br> [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// backtrace Lisp stack from FX, or current fx if none<br> test na ls 1 % FX eq 0<br>   ifso [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FX = GetFXP()<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let sbase = IGetBase(IFPStackBase)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// where user context starts<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if Usc(FX, sbase) ls 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// in system context, ask which stack desired<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">let uFX = 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">test Usc(IGetBase(IFPMiscFXP), sbase) gr 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso uFX = IGetBase(IFPMiscFXP)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> ifnot for i = firstContext to maxContext<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   do   if Usc(IGetBase(i), sbase) gr 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// ah, here is where user was<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">uFX = IGetBase(i); break<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if uFX<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then</span><span class="tab" val="67"></span><span style="font: 10pt serif">[</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// ask question<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws (" in context of (User or System): ")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">switchon ReadChar() into<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  [ case $U: case $u:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws("ser")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FX = uFX<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">break<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">    case $S: case $s:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws("ystem")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">break<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">    default: Ws("XXX - User or System*N")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">] repeat<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> ]<br>  ifnot if (Usc(FX, maxContext) le 0) &<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">(GetStkBlkType(IGetBase(FX)) eq FxtnBlock)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// means print in that context<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws ("*NLisp Stack in context ")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wn (FX, 10)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws (" (")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FX = IGetBase (FX)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wn (FX, 8)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wc ($))<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br> let p = CheckFXP(FX)<br> raidStackFX = FX</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// now working on this stack<br> lastFrame = 0<br> let r = p</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// do the two link chains differ?<br>  [ if (GetAlink(r) ne GetClink(r))<br>        then [ r = UseCLink(); break ]<br>      r = GetAlink(r)<br>  ] repeatwhile r<br> CRLF()<br> let n = 0<br>  [ n = n + 1<br>     Wn(n, 10); Ws(": ")<br>     PrintFXName(p)<br>     p = r ? GetClink(p), GetAlink(p)<br>  ] repeatwhile p<br> ]<br> <br>and UseCLink() = valof<br>   [<br>   [ Ws(" following ")<br>     switchon ReadChar() into<br>        [ case $A: case $a:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws("ccess links")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">linkUsed = usedAlink<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">resultis false; endcase<br>          case $C: case $c:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws("ontrol links")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">linkUsed = usedClink<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">resultis true; endcase<br>          default: Ws("XXX - either Access or Control ") ]<br>   ] repeat<br>   ]<br> <br>and CheckFXP(nfx, cl, ofx; numargs n) = valof<br>  [ unless (nfx eq 0) % (GetStkBlkType(nfx) eq FxtnBlock) do<br>      [ Wo(nfx, true); Ws(" invalid frame extension")<br>        if n gr 1 then<br>           [ Ws(" at "); Ws(cl ? "C", "A"); Ws("Link of "); Wo(ofx, true) ]<br>        RaidReset("") ]<br>    resultis nfx<br>  ]<br><br>and GetAlink(fx) = CheckFXP((SGetBase(fx + FXalink) & (not FXXMask)) - FXPvar,<br>                            false, fx)<br> <br>and GetBlink(fx) = GetSlow(fx) ? SGetBase(fx + FXblink), fx-2<br> <br>and GetClink(fx) = CheckFXP(SGetBase(fx + (GetSlow(fx) ? FXclink, FXalink)) - FXPvar,<br>                            false, fx)<br> <br>and GetNameT(fx, lvNT) = valof <br>  [ </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// store address of name table of fx into lvNT<br>    let v = (SGetBase(fx + flagword) & FXVMask) ne 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Name table valid?<br>    lvNT&gt;&gt;VA.vahi = SGetBase(fx + (v ? FXNThi, FXFHhi))&lt;&lt;LoByte<br>    lvNT&gt;&gt;VA.valo = SGetBase(fx + (v ? FXNTlo, FXFHlo))<br>    resultis lvNT<br>  ]<br> <br>and GetNVars (fx, lvnp, lvnf) be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// number of pvars, fvars<br>  [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// use fn header, not name table, because nt does not guarantee PV field<br>    let fnhd = vec 1<br>    fnhd&gt;&gt;VA.vahi = SGetBase(fx + FXFHhi)&lt;&lt;LoByte<br>    fnhd&gt;&gt;VA.valo = SGetBase(fx + FXFHlo)<br>    @lvnp = BGetBase(fnhd!0, fnhd!1 + NTnPV)&lt;&lt;HiByte<br>    @lvnf = (BGetBase(fnhd!0, fnhd!1 + NTPV)+1)*2 - @lvnp<br>  ]<br> <br><br>and GetSlow(fx) = (SGetBase(fx + FXalink) & FXXMask) ne 0<br> <br>and LispFrame(num, linkType; numargs na) be<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Displays both basic frame and extension.<br>   [<br>   let P = CheckFXP(raidStackFX)<br>   test na ls 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso num = ReadNum(10)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// get frame number<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot [ if num le 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">    then [ Ws (" at top of stack")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   lastFrame = 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   return ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws(" ("); Wn(num, 10); Ws(") ") ]<br>   let useCL = false</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Default until we have to choose<br>   let LinkChosen = false</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Which hasn&rsquo;t happened yet<br>   lastFrame = num</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// save for LF, &uarr; commands<br>   while num gr 1 do<br>   [ let r = useCL ? GetClink(P), GetAlink(P)<br>      unless LinkChosen<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  do [ let x = GetClink(P)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if x ne r<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [ test (na gr 1) & linkType<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">     ifso [ Ws (" following ")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">    useCL = linkType eq usedClink<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">    Wc (useCL ? $C , $A)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">    Ws ("links")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">    ifnot useCL = UseCLink()<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  if useCL then r = x<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  LinkChosen = true<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     ]<br>      unless r<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">do [ test na ge 2<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso [ Ws (" at bottom of stack")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">lastFrame = lastFrame-1 ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot Ws(" Invalid frame number")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   return ]<br>      num = num - 1<br>      P = r<br>    ]<br>   PrintBF(GetBlink(P), P)<br>   PrintFxtn(P)<br>   ]<br><br>and PrintBF(BF, fx; numargs na) be<br>  [<br>   let residual = (SGetBase(BF+flagword) & BFRmask)<br>   let ivar = residual ne 0 ? BF, SGetBase(BF+BFIvar)<br>   // ivar -&gt; start of BF<br>   if GetStkBlkType(BF) ne BFBlock % (Usc(ivar, BF) gr 0)<br>      then [ CRLF(); Wo(BF, true);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      Ws(" is not a basic frame"); return]<br>   test residual<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso Ws ("*NResidual ")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot Ws ("*N")<br>   Ws("Basic Frame at "); Wo(BF, true); CRLF()<br>   if BF ne ivar<br>      then [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   let padded = SGetBase(BF + flagword) & BFPmask<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   let nvars = ((BF-ivar)-(padded ? 2, 0)) rshift 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   test na gr 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// names are available<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">let NT = vec 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">GetNameT (fx, NT)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrintVars (ivar, 0, nvars, NT, ivarCode, false)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot PrintVals(ivar, nvars)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   if padded <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">then </span><span class="tab" val="67"></span><span style="font: 10pt serif">[</span><span class="tab" val="67"></span><span style="font: 10pt serif">// one 2word pad<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrintStk(BF-2)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CRLF()<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ]<br>   PrintStk(BF)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// the BF word itself<br>  ]<br><br>and PrintFxtn(P) be<br>  [<br>   CheckFXP(P)<br>   let NT = vec 1<br>   GetNameT (P, NT)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// get name table into NT<br>   Ws("*NFrame Extension at "); Wo(P, true);<br>   Ws(" Frame Name is: "); PrintFXName(P)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// print Fx header<br>   PrintStk(P); Ws (" ["); PrintFXFlags (P); Ws (", alink]"); CRLF()<br>   PrintStk(P+2); Ws (" [fn header]"); CRLF()<br>   PrintStk(P+4); Ws (" [next, PC]"); CRLF()<br>   PrintStk(P+6); Ws (" [name table]"); CRLF()<br>   PrintStk(P+8); Ws (" [blink, clink]"); CRLF()<br><br>   let npv, nfv = nil, nil<br>   GetNVars (P, lv npv, lv nfv)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// find out how many of each<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// print PVars<br>   let pvStart = P+FXPvar<br>   PrintVars(pvStart, 0, npv, NT, pvarCode, false)<br><br>   let start = pvStart + npv lshift 1<br>   </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// print FVars<br>   PrintFVars(start, nfv, npv, NT)<br><br>   start = start + nfv lshift 1 + 4<br>   PrintStk(start-4); CRLF()</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// 2 junk cells<br>   PrintStk(start-2); CRLF()<br><br>   let nextblk = SGetBase(P + FXnxt)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   // print temporary values<br>   if (NT!0 eq STACKspace) & (NT!1 gr P) & (NT!1 ls nextblk)<br>     then [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// name table is on stack, so we must be sure to skip over it<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    nfv = (NT!1 - start) rshift 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    if nfv gr 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">then PrintVars (start, (start-pvStart) rshift 1, nfv, NT, pvarCode, true)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// print stuff before nt.  Use PrintVars because there may be funny PVars in here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    start = NT!1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    let ntlen = SGetBase (NT!1+offNtSize) + (ntOvheadWords rshift 1)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// number of double words in nt<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    for i = 1 to ntlen</span><span class="tab" val="67"></span><span style="font: 10pt serif">// print nt simply<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">do [ PrintStk(start); CRLF()<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">     start = start+2 ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ] <br>   test nextblk ls start<br>      ifso [ Ws ("Next blk too soon??"); CRLF() ]<br>     ifnot PrintVals(start, (nextblk-start) rshift 1)<br>  ]<br><br>and PrintFXName(s) be <br>  [ let ntp = vec 1<br>    GetNameT(s, ntp) <br>    ntp&gt;&gt;VA.valo = ntp&gt;&gt;VA.valo + NTfname<br>    Lprint(XGetBasePtr(ntp))<br>  ]<br><br>and PrintFXFlags(FX) be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// interpret the FX flags<br>  [ let flags = SGetBase(FX+flagword)<br>    if (flags & FXFMask) ne 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then Wc ($F)<br>    if (flags & FXLMask) ne 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then Wc ($L)<br>    if (flags & FXCMask) ne 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then Wc ($C)<br>    if (flags & FXVMask) ne 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then Wc ($V)<br>    if (flags & FXNMask) ne 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then Wc ($N)<br>    let X = SGetBase(FX+FXalink) & FXXMask<br>    test X<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso Wc ($X)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot if (flags & (FXFMask % FXLMask % FXCMask % FXVMask % FXNMask)) eq 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">then Wc ($-)<br>  ]<br><br>and PrintStk(i) be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// print the two stack words at i,i+1<br>  [ Ws("   "); Wo(i); Ws(": ")<br>    Wo(SGetBase(i)); Wc($*S); Wo(SGetBase(i+1))<br>  ]<br><br>and PrintVals(p, n) be</span><span class="tab" val="67"></span><span style="font: 10pt serif">// print n val ptrs starting at p<br>  for i = 1 to n<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> do [ PrintStk(p)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      test SGetBase(p)&lt;&lt;HiByte eq 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifso [ Wc($*S)<br>                       Lprint(BGetBasePtr(STACKspace, p))]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot CRLF()<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">      p = p + 2 ]<br><br>and PrintVars(s, off0, nvars, lvNT, varcode, namesOptional) be<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// prints PVars and IVars, together with their names<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// off0 is offset of s in nt sense, nvars how many to print<br>  for j = off0 to off0+nvars-1 do<br>      [ PrintStk(s); Wc($*S)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let name = FindName(lvNT, varcode+j)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">test name ne 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifso [ PrintName (name); Wc($*s) ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot unless namesOptional do Ws ("**local** ")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">test SGetBase(s)&lt;&lt;HiByte eq 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// is var bound?<br>         ifso Lprint(BGetBasePtr(STACKspace, s))<br>         ifnot  [ unless namesOptional do Ws("unbound")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  CRLF() ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">s = s+2<br>      ]<br><br>and PrintFVars(s, nf, nlocals, lvNT) be<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// prints FVars, together with their names<br>  for j = 1 to nf do<br>     [ PrintStk(s); Wc($*S)<br>       let name = FindName(lvNT, fvarCode+j-1+nlocals)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">test name ne 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifso PrintName (name)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot test (j eq nf) & ((SGetBase(s) & fvarmask) ne 0) <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// not really a fvar, just the final padding of the pvar region<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CRLF(); return<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">     ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot Ws ("??")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wc ($*s)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws ((SGetBase(s) & fvarmask) ne 0?</span><span class="tab" val="67"></span><span style="font: 10pt serif">// is var looked up?<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">"not looked up", <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  SGetBase(s+1)&lt;&lt;LoByte eq STACKspace?<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">"stack binding",<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  SGetBase(s+1)&lt;&lt;LoByte eq TOPVALspace?<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">"top value", "off-stack binding")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CRLF()<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">s = s+2<br>     ]<br><br>and FindName (lvNT, entry) = valof<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">// looks for a name table entry, and if found returns the atom number of the var so named<br>  [<br>   let nthi = lvNT!0<br>   let ntlo = lvNT!1<br>   let NT1 = ntlo + ntOvheadWords</span><span class="tab" val="67"></span><span style="font: 10pt serif">// where first part starts<br>   let NT2 = NT1 + BGetBase (nthi, ntlo+offNtSize)<br>    [</span><span class="tab" val="67"></span><span style="font: 10pt serif">let atom = BGetBase (nthi, NT1)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if atom eq 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then resultis 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// table terminates on a zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if BGetBase (nthi, NT2) eq entry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then resultis atom<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NT1 = NT1 + 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NT2 = NT2 + 1<br>    ] repeat<br>   ]<br><br>and ShowStackBlocks(px, wait) be<br>  [<br>   let easp = IGetBase(IFPEndOfStack)<br>   [ switchon GetStkBlkType(px) into<br>         [ case FreeStackBlock:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ShowStackEntry("Free Block ", px); CRLF()<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">px=px+SGetBase(px+FreeBlkLen)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">endcase<br>           case GuardBlock:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ShowStackEntry("Guard Block", px); CRLF()<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">px=px+SGetBase(px+GrdBlkLen)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">endcase<br>           case FxtnBlock:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ShowStackEntry("Frame Xtnsn", px); Ws(" = ")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrintFXName(px)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// does its own crlf<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">px=SGetBase(px+FXnxt)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">endcase<br>           default:  let start = px</span><span class="tab" val="67"></span><span style="font: 10pt serif">// save start for consistency check<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">until SGetBase(px) ls 0 do px=px+2</span><span class="tab" val="67"></span><span style="font: 10pt serif">// skip to end<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless GetStkBlkType(px) eq BFBlock do<br>                      [ ShowStackEntry("Garbage    ", start); Wc($*N); break ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">let r = (SGetBase(px+flagword)&BFRmask)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">test r<br>                       ifso [ ShowStackEntry("Residual BF", px)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Ws(" with IVar at ")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Wo(SGetBase(px+BFIvar), true)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>                       ifnot [ ShowStackEntry("Basic Frame", px)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless start eq SGetBase(px+BFIvar)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   do Ws(" preceded by garbage")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CRLF()<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">px=px+2</span><span class="tab" val="67"></span><span style="font: 10pt serif">// skip over BF double word<br>         ]<br>   ] repeatuntil (Usc(px, easp) gr 0) % (px eq 0) % (wait & (Gets(keys) eq DEL))<br>  ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
</div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and ShowStackEntry(s, p) be [ Ws(s); Ws(" at "); Wo(p) ]<br><br>and PrintAddrs(hi, lo, N; numargs na) be<br>  [<br>    if na ne 3<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then [ lo = ReadNum(8); Ws(" showing "); N = ReadNum(8) ]<br>    let end = lo+N-1<br>    Wn(N, 8); Ws(" words from "); PrintPtr(hi, lo)<br>    Ws(" to "); PrintPtr(hi, end); CRLF()<br>    for i = 1 to 8 do Wc($*S)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// print labeling line<br>    for i = 0 to 7 do [ Wc($*S); Wo(i) ]<br>    for i = (lo & #177770) to end<br>       do [ if (i&7) eq 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">do [ CRLF(); Wo(i); Ws(": ") ]<br>            Wc($*S)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    test i ls lo<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso Ws ("      ")</span><span class="tab" val="67"></span><span style="font: 10pt serif">// don&rsquo;t print data yet<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot Wo(BGetBase(hi, i))<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>    CRLF()<br>  ]<br><br>and PrintBytes() be<br>  [ <br>    let hi = ReadNum(8); let lo = ReadNum(8)<br>    Ws(" showing "); let N = ReadNum(8)<br>    Wn(N, 8); Ws(" words, as bytes, starting at ")<br>    PrintPtr(hi, lo); CRLF()<br>    for i = 0 to N-1 do<br>      [ let w = BGetBase(hi, lo+i)<br>        Wb(w&lt;&lt;HiByte); Wc($*S); Wb(w); Ws("  ")<br>        if (i&7) eq 7 then CRLF()<br>      ]<br>    CRLF()<br>  ]<br><br>and GetFXP() = IGetBase(IFPCurrentFXP)<br><br>and GetStkBlkType(s) = SGetBase(s+StkBlkType)&StackMask<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
