<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>PATCHES>IPBITMAPPATCH!1</title>
  </head>
  <body>
    <pre>
(FILECREATED "12-Jun-84 11:02:45" {ERIS}&lt;LISPNEW&gt;PATCHES&gt;IPBITMAPPATCH.;1              changes to:  (VARS IPBITMAPPATCHCOMS))(PRETTYCOMPRINT IPBITMAPPATCHCOMS)(RPAQQ IPBITMAPPATCHCOMS ((* The patch file for Interpressing large bitmaps. Makes HARDCOPYW of full 			     screen bitmaps work, among other things.)			  (FNS SHOWBITMAP.IP SHOWBITMAP1.IP)))(* The patch file for Interpressing large bitmaps. Makes HARDCOPYW of full screen bitmaps work, among other things.)(DEFINEQ(SHOWBITMAP.IP  [LAMBDA (IPSTREAM BITMAP REGION SCALE ROTATION)            (* jds " 7-Jun-84 14:43")                                                             (* Puts out bit map with lower-left corner at current 							     position. If given, REGION is a clipping region on the 							     bitmap.)    (SHOW.IP IPSTREAM)    (PROG (XPIXELS YPIXELS XBYTES)          [COND	    (REGION [SETQ REGION (INTERSECTREGIONS REGION						   (create REGION							   LEFT &larr; 0							   BOTTOM &larr; 0							   WIDTH &larr;(fetch BITMAPWIDTH of BITMAP)							   HEIGHT &larr;(fetch BITMAPHEIGHT of BITMAP]		    (SETQ XPIXELS (fetch WIDTH of REGION))		    (SETQ YPIXELS (fetch HEIGHT of REGION)))	    (T (SETQ XPIXELS (fetch BITMAPWIDTH of BITMAP))	       (SETQ YPIXELS (fetch BITMAPHEIGHT of BITMAP]          (SETQ XBYTES (CEIL (FOLDHI XPIXELS BITSPERBYTE)			     BYTESPERWORD))                  (* Lines must be padded to multiples of 32bits 							     (cells))          (COND	    ((IGREATERP XBYTES MAXLONGSEQUENCEBYTES)         (* We should really start breaking it up in the X 							     direction as well)	      (ERROR "Bitmap line too long for Interpress printing")))          (SETQ SCALE [COND	      [SCALE (\RTIMES2 SCALE (CONSTANT (\RTIMES2 4 MICASPERRAVENSPOT]	      (T (CONSTANT (\RTIMES2 4 MICASPERRAVENSPOT]    (* Go to unit of 4 raven spots ~= 1 screen point)	    )          (bind LEFT CHUNKYPOS (BOTTOM &larr; 0)		(MAXYPIXELSPERCHUNK &larr;(IQUOTIENT MAXLONGSEQUENCEBYTES XBYTES))	     while (IGREATERP YPIXELS 0) first [COND						 (REGION (SETQ LEFT (fetch LEFT of REGION))							 (SETQ BOTTOM (fetch BOTTOM of REGION]	     do (SHOWBITMAP1.IP IPSTREAM BITMAP LEFT BOTTOM XPIXELS (IMIN YPIXELS MAXYPIXELSPERCHUNK)				SCALE ROTATION CHUNKYPOS XBYTES)		(SETQ YPIXELS (IDIFFERENCE YPIXELS MAXYPIXELSPERCHUNK))		(SETQ BOTTOM (IPLUS BOTTOM MAXYPIXELSPERCHUNK])(SHOWBITMAP1.IP  [LAMBDA (IPSTREAM BITMAP LEFT BOTTOM XPIXELS YPIXELS SCALEFACTOR ROTATION CHUNKYPOS XBYTES)                                                             (* jds " 7-Jun-84 15:26")    (PROG [(TOTALBYTES (ITIMES XBYTES YPIXELS))	   (SCRATCHBM (BITMAPCREATE (CEIL XPIXELS BITSPERCELL)				    1))	   (BMBASE (\ADDBASE (fetch (BITMAP BITMAPBASE) of BITMAP)			     (ITIMES BOTTOM (fetch (BITMAP BITMAPRASTERWIDTH) of BITMAP]          (APPENDOP.IP IPSTREAM DOSAVESIMPLEBODY)          (APPENDOP.IP IPSTREAM {)                           (* Start the SIMPLEBODY for displaying this part of the 							     bitmap.)          (TRANS.IP IPSTREAM)                                (* Translate to the current position)          (APPENDNUMBER.IP IPSTREAM YPIXELS)                 (* For the master, this is the number of pixels in the 							     slow direction)          (APPENDNUMBER.IP IPSTREAM XPIXELS)                 (* Number of pixels in the master's fast direction)          (APPENDINTEGER.IP IPSTREAM 1)                      (* Reserved for future expansion)          (APPENDINTEGER.IP IPSTREAM 1)          (APPENDINTEGER.IP IPSTREAM 1)          (SELECTQ (IMOD (OR ROTATION 0)			 360)		   (0                                        (* Bitmaps are really shown on their sides, hanging from							     the upper left corner (I think--JDS))		      (ROTATE.IP IPSTREAM -90)		      (TRANSLATE.IP IPSTREAM 0 (IPLUS BOTTOM YPIXELS))		      (CONCAT.IP IPSTREAM))		   (90                                       (* need nop)		       (TRANSLATE.IP IPSTREAM BOTTOM 0))		   (180 (ROTATE.IP IPSTREAM 90)			(TRANSLATE.IP IPSTREAM XPIXELS (IPLUS BOTTOM YPIXELS))			(CONCAT.IP IPSTREAM))		   (270 (ROTATE.IP IPSTREAM 180)			(TRANSLATE.IP IPSTREAM XPIXELS BOTTOM)			(CONCAT.IP IPSTREAM))		   (ERROR ROTATION "rotation by other than multiples of 90 degrees not implemented"))          (SCALE.IP IPSTREAM SCALEFACTOR)                    (* Scale the bitmap to its final size)          (CONCAT.IP IPSTREAM)          (APPENDSEQUENCEDESCRIPTOR.IP IPSTREAM SEQPACKEDPIXELVECTOR (IPLUS 4 TOTALBYTES))          (APPENDINT.IP IPSTREAM 1 2)          (APPENDINT.IP IPSTREAM XPIXELS 2)          (COND	    [LEFT                                            (* We are working on a subregion in the X direction -- 							     the hard case)		  (for Y (XWORDS &larr;(FOLDLO XBYTES BYTESPERWORD)) from 1 to YPIXELS		     do (\BLT (fetch (BITMAP BITMAPBASE) of SCRATCHBM)			      BMBASE XWORDS)			(\BOUTS IPSTREAM (fetch (BITMAP BITMAPBASE) of SCRATCHBM)				0 XBYTES)			(SETQ BMBASE (\ADDBASE BMBASE XWORDS]	    (T                                               (* We can put out the whole bitmap 							     (i.e., from the starting Y pixel position on down.))	       (\BOUTS IPSTREAM BMBASE 0 TOTALBYTES)))          (APPENDOP.IP IPSTREAM MAKEPIXELARRAY)          (APPENDOP.IP IPSTREAM MASKPIXEL)          (APPENDOP.IP IPSTREAM }]))(DECLARE: DONTCOPY  (FILEMAP (NIL (494 5571 (SHOWBITMAP.IP 504 . 2504) (SHOWBITMAP1.IP 2506 . 5569)))))STOP</pre>
  </body>
</html>
