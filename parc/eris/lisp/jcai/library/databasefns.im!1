{Begin SubSec Databasefns}{Title Databasefns}{Text{note The databasefns package was written by R. M. Kaplan.}{Tag Databasefns}{itNote:  Databasefns is a LispUsers package that is contained on the file {lisp DATABASEFNS.DCOM}.}{index *BEGIN* databasefns package}{index databasefns package}Databasefns is a very small package whose purpose is to make the construction and maintenance of {fn MASTERSCOPE} databases an essentially automatic process.  It modifies {fn MAKEFILE}, {fn LOAD}, and {fn LOADFROM} to behave in the following way:{index DATABASE Prop}A database will be maintained automatically for any file (containing functions) whose file name has the property {prop DATABASE} with value {lisp YES}.  Whenever such a file is dumped via {fn MAKEFILE}, {fn MASTERSCOPE} will analyse any new or changed functions on the file, and a database for all of the functions on the file will be written on a separate file whose name is of the form {lisp {arg FILE}.DATABASE}.  Whenever a file which has a {prop DATABASE} property with value {lisp YES} is loaded via {fn LOAD} or {fn LOADFROM}, then the corresponding {lisp .DATABASE} file, if any, is also loaded.  The database will not be dumped or loaded if the value of the {prop DATABASE} property for the file is {lisp NO}.  The {prop DATABASE} property is considered to be {lisp NO} if the file is loaded with {arg LDFLG}={lisp SYSLOAD}.If the {lisp DATABASE} property is not {lisp YES} or {lisp NO}, then {fn MAKEFILE}, {fn LOAD}, and {fn LOADFROM} will ask the user whether he wants automatic database maintenance.  The user's answer will be stored on the {prop DATABASE} property so that he will not be asked again.  Thus when a file is dumped for the first time, the user will be asked "Do you want a Masterscope Database for this file?".  Similarly, if the user loads a file which has an associated database, the user will be asked "load database for {arg FILE}?".The above interactions may be controlled via the global variables {var SAVEDBFLG}{index SAVEDBFLG Var} and {var LOADDBFLG}{index LOADDBFLG Var}.  When a file which has neither a {lisp YES} or {lisp NO} database property is being dumped, {fn MAKEFILE} will assume (and store) a {lisp YES} value if the value of {var SAVEDBLFG} is {lisp YES}, and a {lisp NO} value if {var SAVEDBFLG} is {lisp NO}.  The user will be queried only if {var SAVEDBFLG} is {lisp ASK} (its initial value).  Similarly, if {var LOADDBFLG} is {lisp YES}, {fn LOAD} and {fn LOADFROM} will automatically load an existing {lisp .DATABASE} file for a file which does not have a {lisp YES} or {lisp NO} value for its {prop DATABASE} property.  The database will not be loaded if {var LOADDBFLG} is {lisp NO}, and the user will be interrogated as described above if {var LOADDBFLG} is {lisp ASK} (its initial value).The user can dump and restore databases explicitly via the following functions:{FnDef {FnName DUMPDB} {FnArgs FILE}{TextDumps a database for {arg FILE} then sets the {prop DATABASE} property to {lisp YES}, so that database maintenance for {arg FILE} will subsequently be automatic.}}{FnDef {FnName LOADDB} {FnArgs FILE}{TextLoads the file {lisp {arg FILE}.DATABASE} if one exists.  After the database is loaded, the {prop DATABASE} property for {arg FILE} is set to {lisp YES}, so that maintenance will thereafter be automatic.Database files include the date and full filename of the file to which they correspond.  {fn LOADDB} will print out a warning message if it loads a database that does not correspond to the in-core version of the file, and ask the user if he approves.Note that {fn LOADDB} is the only approved way of loading a database:  Attempting to {fn LOAD} a database file will cause an error.}}{index *END* databasefns package}}{End SubSec Databasefns}