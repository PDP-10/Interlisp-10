<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>JCAI>library>Chat.im!1</title>
  </head>
  <body>
    <pre>
{Begin SubSec CHAT}{Title CHAT}{Text{index *PRIMARY* CHAT}{Tag CHAT}{fn CHAT} is a "remote terminal" facility, that allows one to communicate with other machines while inside Interlisp-D.  The function {fn CHAT} sets up a "Chat connection" to a remote machine, so that everything you type is sent to the a remote machine, and everything the remote machine prints is displayed in a "Chat window".  The remote machine must support the Pup Telnet protocol.Multiple simultaneous Chat connections are possible.  To switch between typing to different Chat connections, simply button within the Chat window you want to use.  {fn CHAT} prompts for a new window for each new connection, except that it saves the first window to reuse once the connection in that window is closed (other windows just go away when their connections are closed).{fn CHAT} behaves as if its Chat window is a Datamedia-2500 terminal of the dimensions determined by the size of the window.  Hence, you can talk to hosts that supply Datamedia service and expect something reasonable to happen.  If the host does not pay attention to the {fn CHAT} terminal specification protocol, or you go through that host to another host, you may need to inform the host of the dimensions of your "screen"; these are given in the title bar of the chat window.  The font should be Gacha10 or other fixed-width font for proper Datamedia emulation.{FnDef {Name CHAT} {Args HOST LOGOPTION INITSTREAM WINDOW {anonarg}}{TextOpens a Chat connection to {arg HOST}, or to the value of {var DEFAULTCHATHOST}{index DEFAULTCHATHOST Var}.  If {arg HOST} requires login, as determined by whether it responds to the "where is user" protocol, {fn CHAT} supplies a login sequence, or if it determines that you have a single detached job, an attach sequence.  If you have more than one detached job, it simply performs a {lisp WHEREIS} command for you and allows you to select the job.  You may alternatively specify one of the following values for {arg LOGOPTION}:{Begin LabeledList LOGOPTION values}{Label {lisp LOGIN}}{Text Always perform a login.}{Label {lisp ATTACH}}{Text Always perform an attach.  This will fail if you do not have exactly one detached job.}{Label {lisp GUEST}}{Text Login as user GUEST, password GUEST.}{Label {lisp NONE}}{Text Do not attempt to login or attach.}{End LabeledList LOGOPTION values}If {arg INITSTREAM} is supplied, it is either a string or the name of a file whose contents will be read as typein.  When the string/file is exhausted, input is taken from {lisp T}.If {arg WINDOW} is supplied, it is a window to use for the connection; otherwise, the user is prompted for a window.}}While {fn CHAT} is in control, all Lisp interrupts are turned off, so that control characters can be transmitted to the remote host.  Chat does not turn off interrupt characters until AFTER creating the Chat window, so the user can abort the call to Chat by typing control-E while specifying the Chat window region.Commands can be given to an active Chat connection by bugging the {lisp MIDDLE} button in the Chat window to get a command menu.  Current commands are:{Begin LabeledList Chat commands}{Label {lisp Close}}{TextClose this connection.  Once the connection is closed, control is handed over to the main tty window.  Closes the window unless this is the primary Chat window.}{Label {lisp Suspend}}{TextSame as Close, but always leaves the window open.}{Label {lisp New}}{TextCloses the current connection and prompts for a new host to which to open a connection in the same window.}{Label {lisp Freeze}}{TextHold typeout from this Chat window.  Bugging the window in any way releases the hold.  This is most useful if you want to switch to another, overlapping window and there is typeout in this window that would compete for screen space.}{Label {lisp Dribble}}{TextOpen a typescript file for this Chat connection (closing any previous dribble file for the window).  The user is prompted for a file name; a name of {lisp NIL} just closes the old dribble file.}{Label {lisp Input}}{TextPrompts for a file to take input from.  When the end of the file is reached, input reverts to {lisp T}.}{Label {lisp Clear}}{TextClears the window and resets the simulated terminal to its default state.   This is useful if undesired terminal commands have been received from the remote host that place the simulated terminal into a funny state.}{End LabeledList Chat commands}In an inactive Chat window, the {lisp MIDDLE} button brings up a menu of one item, {lisp ReConnect}, whose selection reopens a connection to the same host as was last in the window.  This is the primary motivation for the {lisp Suspend} menu command.  A new Chat connection can also be opened from the Background menu.The mouse button {lisp LEFT}, when inside {fn CHAT}, holds output as long as the button is down.  Holding down {lisp MIDDLE} coincidentally does this, too, but not on purpose: since the menu handler does not yield control to other processes, it is possible to kill the connection by keeping the menu up too long.Chat windows are a little bit knowledgable about window operations.  If you reshape a Chat window, Chat informs your partner of the new dimensions.  And if you close the window, the connection is also closed.The following variables control aspects of Chat's behavior:{VarDef {Name CHAT.DISPLAYTYPE}{TextThe type of display (a number) that Chat should tell the remote host the user is on.  If Datamedia emulation is desired, this variable should be set to the number corresponding to the terminal type Datamedia for the remote host.  If the remote host does not respond to the terminal type protocol in Pup Telnet, this variable is irrelevant.}}{VarDef {Name CHAT.ALLHOSTS}{TextA list of host names, as uppercase litatoms, that the user desires to Chat to.  Chatting to a host not on the list adds it to the list.  These names are placed in the menu that the background Chat command prompts with.}}{VarDef {Name CLOSECHATWINDOWFLG}{TextIf true, every Chat window is closed on exit.  If {lisp NIL}, the initial setting, then the primary Chat window is not closed.}}{VarDef {Name DEFAULTCHATHOST}{TextThe host to which {fn CHAT} connects when it is called with no {arg HOST} argument.}}{VarDef {Name CHAT.FONT}{TextIf non-{lisp NIL}, the font that Chat windows are created with.  If {var CHAT.FONT} is {lisp NIL}, Chat windows are created with {lisp (DEFAULTFONT 'DISPLAY)}.}}{Begin Note}From Intermezzo Release Notes:Chat can now be used to communicate with NS hosts using the normal Chat interface.  The only visible difference from communicating with PUP hosts is that the NS Chat protocol differentiates among a number of virtual terminal services.  Calling CHAT on an NS host will pop up a menu to allow you to choose the terminal service you want to use:	Any	Remote System Administration	Remote System Executive	Interactive Terminal ServiceThe "Any" option in the menu will eventually allow using any terminal service is available on the specified host, but no hosts currently support it.The "Remote System Administration" service lets you log onto print servers and clearinghouse servers, and issue appropriate commands.The "Remote System Executive" service is currently only supported by Tajo/Mesa workstations with appropriate software loaded.The "Interactive Terminal Service" is the TTY-based interface to NS mail.If you select an invalid service type, you'll get an "ERROR ServiceNotFound" message in the promptwindow.  In a future release, Interlisp will be able to discover which services a particular host supports.{End Note}}{End SubSec CHAT}</pre>
  </body>
</html>
