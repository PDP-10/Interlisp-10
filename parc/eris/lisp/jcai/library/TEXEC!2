(FILECREATED "15-Aug-85 15:59:01" {DSK}<LISPFILES>TEXEC.;45 44782        changes to:  (FNS TEXEC.FILLBUFFER TEXEC.FILLBUFFER.TCLASS TEXEC \TEDITSTREAMBOUT TEXEC.\CHDEL1 			TEXEC.FLASHCARET TEXEC.INSERTCHAR TEXEC.GETKEY)		   (VARS TEXECCOMS)      previous date: " 8-Aug-85 17:19:13" {DSK}<LISPFILES>TEXEC.;36)(* Copyright (c) 1985, 1900 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT TEXECCOMS)(RPAQQ TEXECCOMS ((COMS (* THE FILLBUFFER REPLACEMENT CODE)			(FNS OPENTEDITSTREAM TEXEC.FILLBUFFER TEXEC.FILLBUFFER.TCLASS 			     TEXEC.FILLBUFFER.CHSELPENDING TEXEC.FILLBUFFER.CHARDELETE 			     TEXEC.FILLBUFFER.WORDDELETE TEXEC.PARENCOUNT TEXEC.PARENMATCH 			     TEXEC.FLASHCARET TEXEC.TEXTSTREAM.TO.LINEBUF TEXEC.NTHBUFCHARBACK 			     TEXEC.NTHBACKCHNUM TEXEC.EOTP TEXEC.GETKEY TEXEC.INSERTCHAR 			     TEXEC.\CHDEL1 TEXEC.?EQUAL \TEDITSTREAMBOUT))	(COMS (* Code to support a TEXEC lisp "listener")	      (FNS TEXEC)	      (APPENDVARS (BackgroundMenuCommands (TEXEC (QUOTE (TEXEC))							 "Starts TEXEC in a new window.")))	      (VARS (BackgroundMenu NIL)))	(FILES TEDITCHAT)))(* THE FILLBUFFER REPLACEMENT CODE)(DEFINEQ(OPENTEDITSTREAM  [LAMBDA (WINDOW MENUFN)                                    (* AJB " 3-Jul-85 11:08")                                                             (* Initialize and return TEDIT TEXTSTREAM)    (PROG* ((TEXSTREAM (OPENTEXTSTREAM NIL WINDOW NIL NIL))	    (TEXOBJ (TEXTOBJ TEXSTREAM))	    (TEXLEN (fetch TEXTLEN TEXOBJ)))                 (* force shift select typein to be put in keyboard 							     buffer)           (TEXTPROP TEXSTREAM (QUOTE STARTINGEOF)		     TEXLEN)           (TEXTPROP TEXSTREAM (QUOTE COPYBYBKSYSBUF)		     T)           (replace STRMBOUTFN of TEXSTREAM with (QUOTE \TEDITSTREAMBOUT))           (replace SET of (fetch SEL of TEXOBJ) with T)           [replace L1 of (fetch SEL of TEXOBJ) with (LIST (fetch DESC of (fetch THISLINE									     of TEXOBJ]                                                             (* hookup middle button menu instead of TEDIT menu)           (WINDOWPROP WINDOW (QUOTE TEDIT.TITLEMENUFN)		       MENUFN)           (RETURN TEXSTREAM])(TEXEC.FILLBUFFER  [LAMBDA (FILLTYPE)                                         (* AJB "15-Aug-85 15:57")          (* While filling the line, the current file pointer is the end of the line. When the line is closed, this is made 	  the eof. -	  #CURRENTRDTBL# is used for syntactic delimiters and paren counting on READ and RATOM calls but isn't referenced 	  (or bound) for READC)    (DECLARE (USEDFREE #CURRENTRDTBL# \PRIMTERMTABLE FLG \TERM.OFD)	     (SPECVARS TEXOBJ SEL RSNX TCLASS RTBLSA RAISEDCHAR FILLTYPE RAISEDCHAR PEEKEDECHOED C))    (\RESETLINE)          (* * If ERROR or RESET, move STARTINGEOF to end of text (TEXTLEN))    (RESETLST [RESETSAVE NIL (LIST (FUNCTION (LAMBDA NIL				       (COND					 (RESETSTATE         (* Point to end of text and clearout linebuffer on 							     RESET or ERROR)						     (PROG* ((TEXOBJ (fetch (TEXTSTREAM TEXTOBJ)									of \TERM.OFD))							     (SEL (fetch SEL of TEXOBJ)))							    (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)								      (fetch TEXTLEN of TEXOBJ))							    (replace (STREAM REVALIDATEFLG)							       of \LINEBUF.OFD)							    (\RESETTERMINAL)							    (\SHOWSEL SEL)							    (replace CH# of SEL							       with (ADD1 (fetch TEXTLEN									     of TEXOBJ)))							    (replace CHLIM of SEL							       with (ADD1 (fetch TEXTLEN									     of TEXOBJ)))							    (replace POINT of SEL							       with (QUOTE LEFT))							    (replace DCH of SEL with 0)							    (replace SET of SEL with T)							    (\FIXSEL SEL TEXOBJ]	      (PROG* ((RTBLSA (AND (NEQ FILLTYPE READC.FT)				   (fetch READSA of #CURRENTRDTBL#)))		      (CONTROLTON (fetch CONTROLFLG of \PRIMTERMTABLE))		      (TEXOBJ (fetch (TEXTSTREAM TEXTOBJ) of \TERM.OFD))		      (SEL (fetch SEL of TEXOBJ))		      (WINDOW (fetch \WINDOW of TEXOBJ))		      (LINES (fetch LINES of TEXOBJ))		      RSNX TCLASS C RAISEDCHAR PEEKEDECHOED TTYWINDOW FN TCH INSCH# CHNO ADDEDEOL)          (* * STARTINGEOF is the beginning of the current text being entered which gets returned to READ so that 	  \TEDITSTREAMBOUT knows where to output any text including ^T)          (* * TCLASS is terminal syntax class, RSNX is read-table code)		     (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)			       (fetch TEXTLEN of TEXOBJ))    (* Keep STARTINGEOF in sync)		     (COND		       ((SETQ C (fetch (LINEBUFFER PEEKEDCHAR) of \LINEBUF.OFD))                                                             (* Account for peeked character)			 (SETQ C (IABS C))                   (* The peeked char may be negative because it was 							     BIN'ed earlier. Make sure it is positive.)			 (replace (LINEBUFFER PEEKEDCHAR) of \LINEBUF.OFD with NIL)			 (SETQ PEEKEDECHOED T)			 (SETQ RAISEDCHAR (\RAISECHAR C))			 [COND			   ((EQ FILLTYPE READ.FT)			     (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)				       (SUB1 (TEXTPROP TEXOBJ (QUOTE STARTINGEOF]                                                             (* Backup one in textstream to start the input before 							     the peeked and echoed character if doing a READ)			 ))		     [COND		       ((EQ FILLTYPE READC.FT)			 (TEXEC.INSERTCHAR C)                (* Read single char and check for echoing)			 (COND			   (CONTROLTON (GO EXIT]             (* If in CONTROL T mode and reading a single char)		     (COND		       (C (GO NEXTTCLASS)))		 NEXT(SETQ C (TEXEC.GETKEY))                 (* read next character from keyboard)		 NEXTTCLASS		     [SETQ TCLASS (fetch TERMCLASS of (\SYNCODE \PRIMTERMSA (SETQ RAISEDCHAR								  (\RAISECHAR C]		 REDO          (* (while (OR TEDIT.SELPENDING (fetch EDITOPACTIVE of TEXOBJ)) do (* Don't do anything while he's selecting or one 	  of the lock-out ops is active.) (BLOCK)))		     (COND		       ((fetch TXTNEEDSUPDATE of TEXOBJ)     (* We got here somehow with the window not in sync with							     the text. Run an update.)			 (\SHOWSEL SEL NIL NIL)			 (TEDIT.UPDATE.SCREEN TEXOBJ NIL T)			 (\FIXSEL SEL TEXOBJ)			 (\SHOWSEL SEL NIL T)))              (* (replace EDITOPACTIVE of TEXOBJ with T))		     (TEXEC.FILLBUFFER.CHSELPENDING)         (* Check for SHIFT/COPY/MOVE active)          (* * Handle Terminal Class characters)		     (SELECTQ (TEXEC.FILLBUFFER.TCLASS)			      (NEXT (GO NEXT))			      (EXIT (GO EXIT))			      NIL)          (* * Here if it isn't a terminal class.)		     (COND		       (PEEKEDECHOED (SETQ PEEKEDECHOED NIL))		       (T (TEXEC.INSERTCHAR C)))		     (AND (EQ FILLTYPE READC.FT)			  (GO NEXT))		     (COND		       ((EQ ESCAPE.RC (SETQ RSNX (\SYNCODE RTBLSA RAISEDCHAR)))			 (COND			   ([EQ CTRLV.TC (SETQ TCLASS (fetch TERMCLASS of (\SYNCODE \PRIMTERMSA										    (SETQ RAISEDCHAR										      (\GETCHAR]			     (GO REDO)))			 (GO NEXT)))		     (SELECTC FILLTYPE			      [RATOM/RSTRING.FT (COND						  ((AND CONTROLTON (fetch STOPATOM of RSNX))						    (GO EXIT]			      [READ.FT (SELECTC RSNX						((LIST RIGHTPAREN.RC RIGHTBRACKET.RC)						  (TEXEC.FLASHCARET (TEXEC.PARENMATCH RSNX)))						NIL)				       (COND					 ([AND CONTROLTON (ZEROP (fetch (LINEBUFFER LBRKCOUNT)								    of \LINEBUF.OFD))					       (ZEROP (fetch (LINEBUFFER LPARCOUNT) of \LINEBUF.OFD))					       (fetch STOPATOM of RSNX)					       (SELECTC RSNX							((LIST LEFTPAREN.RC LEFTBRACKET.RC 							       RIGHTBRACKET.RC RIGHTPAREN.RC)							  NIL)							(STRINGDELIM.RC (COND									  ((fetch (LINEBUFFER 											INSTRINGP)									      of \LINEBUF.OFD)									    (replace (LINEBUFFER										       INSTRINGP)									       of \LINEBUF.OFD									       with NIL)									    T)))							(NOT (fetch (LINEBUFFER INSTRINGP)								of \LINEBUF.OFD]                                                             (* READ is reading an atom. Return when atom ends, but 							     also obey bracket/paren exception noted on page 14.33 							     of manual.)					   (GO EXIT)))				       (COND					 ((TEXEC.EOTP)					   (COND					     ((fetch (STREAM REVALIDATEFLG) of \LINEBUF.OFD)					       (TEXEC.PARENCOUNT)                                                             (* text needs recount of parens/brackets)					       ))					   (COND					     ((\INCPARENCOUNT RSNX)          (* Parens balance--throw the carriage if the closing paren or bracket character was not a CR, and if FLG argument of	  READ is NIL. (We know we are under a READ call because of FILLTYPE))                                                             (* copy the chars from the textstream into the 							     linebuffer)					       (TEXEC.TEXTSTREAM.TO.LINEBUF TEXOBJ									    (TEXTPROP TEXOBJ										      (QUOTE 										      STARTINGEOF))									    \LINEBUF.OFD FILLTYPE)                                                             (* Protect all of the chars from being edited since 							     they are about to become the past)                                                             (* now reset the new STARTINGEOF to start at the end of							     the text)					       (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)							 (fetch TEXTLEN of TEXOBJ))					       (\CLOSELINE)                                                             (* \CLOSELINE first so dribble happens before EOL)					       (AND (NEQ RAISEDCHAR (CHARCODE EOL))						    (NOT FLG)						    (\OUTCHAR \TERM.OFD (CHARCODE EOL)))					       (RETURN))					     ((EQ IMMEDIATE.RMW (fetch WAKEUP of RSNX))                                                             (* Immediate read-macro)					       (RETURN]			      (SHOULDNT))		     (GO NEXT)		 EXIT(COND		       ([AND (EQ FILLTYPE READ.FT)			     (EQ RAISEDCHAR (CHARCODE EOL))			     (EQ (SUB1 (fetch TEXTLEN of TEXOBJ))				 (TEXTPROP TEXOBJ (QUOTE STARTINGEOF]			 (\LINEBUFBOUT \LINEBUF.OFD (CAR (GETSYNTAX (QUOTE RIGHTBRACKET)								    #CURRENTRDTBL#)))                                                             (* If doing a READ, force a lone CR to terminate the 							     READ by handing back a RIGHTBRACKET into the 							     LINEBUFFER)			 )		       (T (TEXEC.TEXTSTREAM.TO.LINEBUF TEXOBJ (TEXTPROP TEXOBJ (QUOTE STARTINGEOF))						       \LINEBUF.OFD FILLTYPE)))		     (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)			       (fetch TEXTLEN of TEXOBJ))		     (\CLOSELINE)		     (AND (NEQ RAISEDCHAR (CHARCODE EOL))			  (NOT CONTROLTON)			  (NOT FLG)			  (\OUTCHAR \TERM.OFD (CHARCODE EOL])(TEXEC.FILLBUFFER.TCLASS  [LAMBDA NIL                                                (* AJB "15-Aug-85 14:32")          (* * Handle special terminal class characters)    (DECLARE (USEDFREE TEXOBJ \LINEBUF.OFD PEEKEDECHOED SEL C FILLTYPE TCLASS))    (PROG NIL          (SELECTC TCLASS		   (RETYPE.TC (RETURN (QUOTE NEXT))          (* Ignore ^R since the user can rescroll the line)			      )		   (LINEDELETE.TC (COND				    ((IGREATERP (fetch CH# of (fetch SEL of TEXOBJ))						(TEXTPROP TEXOBJ (QUOTE STARTINGEOF)))                                                             (* Only allow deletion of selection if left side of 							     selection is after start of current input)				      (TEDIT.DO.BLUEPENDINGDELETE (fetch SEL of TEXOBJ)								  TEXOBJ)				      (replace (STREAM REVALIDATEFLG) of \LINEBUF.OFD with T)))                                                             (* invalidate paren/bracket count)				  (RETURN (QUOTE NEXT)))		   (CHARDELETE.TC (TEXEC.FILLBUFFER.CHARDELETE)				  (RETURN (QUOTE NEXT)))		   (WORDDELETE.TC (TEXEC.FILLBUFFER.WORDDELETE)				  (RETURN (QUOTE NEXT)))		   (CTRLV.TC (COND			       (PEEKEDECHOED (SETQ PEEKEDECHOED NIL)))			     (TEXEC.INSERTCHAR C)			     [COND			       ((NEQ FILLTYPE READC.FT)				 (SETQ C (TEXEC.GETKEY]			     (SETQQ TCLASS NONE.TC))		   [EOL.TC (AND (EQ FILLTYPE READ.FT)				(TEXEC.?EQUAL)				(RETURN (QUOTE NEXT))        (* If ?= handle it and go for more input)				)			   (TEXEC.INSERTCHAR C)			   (COND			     ((EQ FILLTYPE READ.FT)          (* If we are doing a "READ")                                                             (* If we are at the end of the input now, update 							     parencount if invalid, and test for matching 							     paren/bracket count)			       (AND (TEXEC.EOTP)				    (COND				      ((fetch (STREAM REVALIDATEFLG) of \LINEBUF.OFD)					(TEXEC.PARENCOUNT))				      (T T))				    (ZEROP (fetch (LINEBUFFER LBRKCOUNT) of \LINEBUF.OFD))				    (ZEROP (fetch (LINEBUFFER LPARCOUNT) of \LINEBUF.OFD))				    (NOT (fetch (LINEBUFFER INSTRINGP) of \LINEBUF.OFD))				    (RETURN (QUOTE EXIT))    (* Proper termination of READ)				    )			       (RETURN (QUOTE NEXT))         (* Else go for more input)			       )			     (T (RETURN (QUOTE EXIT))        (* Exit always if not in "READ" mode)				]		   NIL)          (COND	    ((EQ C (CHARCODE ^X))                            (* ^X positions to end of text)	      (\SETUPGETCH (fetch TEXTLEN of TEXOBJ)			   TEXOBJ)	      (replace CH# of SEL with (ADD1 (fetch TEXTLEN of TEXOBJ)))	      (replace CHLIM of SEL with (fetch CH# of SEL))	      (replace POINT of SEL with (QUOTE LEFT))	      (replace DCH of SEL with 0)	      (replace SET of SEL with T)	      (replace HASCARET of SEL with T)	      (UNINTERRUPTABLY                  (\CHECKCARET)		  (for CARET inside (fetch CARET of TEXOBJ) as WIN inside (fetch (TEXTOBJ \WINDOW)									     of TEXOBJ)		     do (\FIXSEL SEL TEXOBJ WIN)			(MOVETO (fetch X0 of SEL)				(fetch Y0 of SEL)				WIN)			(replace TCCARETX of CARET with (fetch X0 of SEL))			(replace TCCARETY of CARET with (fetch Y0 of SEL))))	      (RETURN (QUOTE NEXT])(TEXEC.FILLBUFFER.CHSELPENDING  [LAMBDA NIL                                                (* AJB " 3-Jul-85 16:48")                                                             (* Before starting to work, note that we're doing 							     something.)    (DECLARE (USEDFREE TEXOBJ))    (ERSETQ (COND	      (TEDIT.COPY.PENDING                            (* Have to copy the shifted SEL to caret.)				  (SETQ TEDIT.COPY.PENDING NIL)				  (\COPYSEL TEDIT.SHIFTEDSELECTION (fetch SHIFTEDSEL of TEXOBJ))				  (TEDIT.COPY (fetch SHIFTEDSEL of TEXOBJ)					      (fetch SEL of TEXOBJ))				  (replace SET of TEDIT.SHIFTEDSELECTION with NIL)				  (replace L1 of TEDIT.SHIFTEDSELECTION with NIL)				  (replace LN of TEDIT.SHIFTEDSELECTION with NIL)				  (\COPYSEL TEDIT.SHIFTEDSELECTION (fetch SHIFTEDSEL of TEXOBJ)))	      (TEDIT.COPYLOOKS.PENDING                       (* Have to copy the shifted SEL to caret.)				       (SETQ TEDIT.COPYLOOKS.PENDING NIL)				       (\COPYSEL TEDIT.COPYLOOKSSELECTION (fetch SHIFTEDSEL									     of TEXOBJ))				       [COND					 ((EQ (QUOTE PARA)					      (fetch SELKIND of (fetch SHIFTEDSEL of TEXOBJ)))                                                             (* copy the paragraph looks, since the source selection							     type was paragraph)					   (TEDIT.COPY.PARALOOKS TEXOBJ (fetch SHIFTEDSEL									   of TEXOBJ)								 (fetch SEL of TEXOBJ)))					 (T                  (* copy the character looks)					    (TEDIT.COPY.LOOKS TEXOBJ (fetch SHIFTEDSEL of TEXOBJ)							      (fetch SEL of TEXOBJ]				       (\SHOWSEL (fetch SHIFTEDSEL of TEXOBJ)						 NIL NIL)				       (replace SET of TEDIT.COPYLOOKSSELECTION with NIL)				       (replace L1 of TEDIT.COPYLOOKSSELECTION with NIL)				       (replace LN of TEDIT.COPYLOOKSSELECTION with NIL)				       (\COPYSEL TEDIT.COPYLOOKSSELECTION (fetch SHIFTEDSEL									     of TEXOBJ)))	      (TEDIT.MOVE.PENDING                            (* Have to move the ctrl-shift SEL to caret.)				  (SETQ TEDIT.MOVE.PENDING NIL)				  (\COPYSEL TEDIT.MOVESELECTION (fetch MOVESEL of TEXOBJ))				  (TEDIT.DO.BLUEPENDINGDELETE SEL TEXOBJ)				  (TEDIT.MOVE (fetch MOVESEL of TEXOBJ)					      (fetch SEL of TEXOBJ))				  (replace SET of TEDIT.MOVESELECTION with NIL)				  (replace L1 of TEDIT.MOVESELECTION with NIL)				  (replace LN of TEDIT.MOVESELECTION with NIL)				  (\COPYSEL TEDIT.MOVESELECTION (fetch MOVESEL of TEXOBJ)))	      (TEDIT.DEL.PENDING                             (* Delete the current selection.)				 (SETQ TEDIT.DEL.PENDING NIL)                                                             (* Above all, reset the demand flag first)				 (COND				   ((fetch SET of TEDIT.DELETESELECTION)                                                             (* Only try the deletion if he really set the 							     selection.)				     (\SHOWSEL (fetch DELETESEL of TEXOBJ)					       NIL NIL)      (* Turn off the selection highlights)				     (\SHOWSEL (fetch SEL of TEXOBJ)					       NIL NIL)				     (replace SET of (fetch DELETESEL of TEXOBJ) with NIL)				     (\COPYSEL TEDIT.DELETESELECTION (fetch SEL of TEXOBJ))				     (\TEDIT.SET.SEL.LOOKS (fetch SEL of TEXOBJ)							   (QUOTE NORMAL))                                                             (* Grab the selection we're to use)				     (\TEDIT.DELETE (fetch SEL of TEXOBJ)						    (fetch \TEXTOBJ of (fetch SEL of TEXOBJ))						    NIL)				     (replace L1 of TEDIT.DELETESELECTION with NIL)				     (replace LN of TEDIT.DELETESELECTION with NIL])(TEXEC.FILLBUFFER.CHARDELETE  [LAMBDA NIL                                                (* edited: " 8-Aug-85 16:43")    (DECLARE (USEDFREE FILLTYPE RSNX TCLASS RTBLSA RAISEDCHAR #CURRENTRDTBL#))    (PROG (C)          (COND	    ((NULL (SETQ C (TEXEC.\CHDEL1)))          (* Try deleting a character (put the deleted char in C and RETURN C). If there was no character to delete 	  (ie, we're at start of line), (RETURN NIL))	      (FLASHWINDOW WINDOW)	      (RETURN)))          [PROG (C1 (ESCAPE? (AND (NEQ FILLTYPE READC.FT)				  (fetch ESCAPEFLG of #CURRENTRDTBL#)				  ESCAPE.RC)))	        (COND		  ((NEQ FILLTYPE READC.FT)                   (* Don't process escapes if READC)		    (SETQ RSNX (\SYNCODE RTBLSA C))		    [COND		      ((SETQ C1 (TEXEC.NTHBUFCHARBACK 0))    (* Check preceding char C1 for escape)			(COND			  ((EQ ESCAPE? (\SYNCODE RTBLSA C1))			    (SETQ RSNX OTHER.RC)			    (SETQ C (TEXEC.\CHDEL1))         (* Delete the ESCAPE char also)			    ]		    (COND		      ((NULL (fetch (STREAM REVALIDATEFLG) of \LINEBUF.OFD))			(\DECPARENCOUNT RSNX)                (* no need to update parencount if deleting chars in 							     the middle of the text)			]          (RETURN C)                                         (* Successful delete)      ])(TEXEC.FILLBUFFER.WORDDELETE  [LAMBDA NIL                                                (* AJB "19-Jun-85 18:20")          (* Delete chars until first non-sepr/non-other, or first non-other after sepr string and other string.	  Note that a terminal wordsepr is treated as if it were a read-sepr)    (DECLARE (USEDFREE RSNX RTBLSA \PRIMTERMSA TCLASS FILLTYPE #CURRENTRDTBL#))    (PROG (C)          (COND	    ((TEXEC.FILLBUFFER.CHARDELETE)                   (* Delete first character always)	      )	    (T (RETURN)                                      (* No chars in buffer, return)	       ))      AGAIN          (COND	    ((SETQ C (TEXEC.NTHBUFCHARBACK 0))	      (SELECTC RSNX		       [SEPRCHAR.RC (COND				      ((TEXEC.FILLBUFFER.CHARDELETE)					(GO AGAIN)           (* cont until first non-sepr)					)				      (T (RETURN)            (* No more chars in buffer, return)					 ]		       [OTHER.RC [COND				   ((EQ WORDSEPR.TC (\SYNCODE \PRIMTERMSA C))				     (COND				       ((TEXEC.FILLBUFFER.CHARDELETE)					 (GO AGAIN)          (* cont until first non-sepr)					 )				       (T (RETURN)           (* No more chars in buffer, return)					  ]				 (PROG (C1 (ESCAPE? (AND (NEQ FILLTYPE READC.FT)							 (fetch ESCAPEFLG of #CURRENTRDTBL#)							 ESCAPE.RC)))                                                             (* The first OTHER)				   TRY (COND					 ((NULL (TEXEC.FILLBUFFER.CHARDELETE))					   (RETURN)))				       (COND					 ((SETQ C (TEXEC.NTHBUFCHARBACK 0))                                                             (* look at previous char)					   (SETQ RSNX (\SYNCODE RTBLSA C))					   (SETQ TCLASS (\SYNCODE \PRIMTERMSA C))					   [COND					     ((SETQ C1 (TEXEC.NTHBUFCHARBACK 1))					       (COND						 ((EQ ESCAPE? (\SYNCODE RTBLSA C1))						   (SETQ RSNX OTHER.RC)						   (SETQ TCLASS NONE.TC]					   (COND					     ((AND (NEQ TCLASS WORDSEPR.TC)						   (EQ OTHER.RC RSNX))                                                             (* Erase it)					       (GO TRY]		       (RETURN])(TEXEC.PARENCOUNT  [LAMBDA NIL                                                (* AJB " 6-Aug-85 12:41")    (DECLARE (USEDFREE \LINEBUF.OFD TEXOBJ))    (PROG ((STREAM (fetch STREAMHINT of TEXOBJ)))          (replace (LINEBUFFER LPARCOUNT) of \LINEBUF.OFD with 0)          (replace (LINEBUFFER LBRKCOUNT) of \LINEBUF.OFD with 0)          (replace (LINEBUFFER LPARCOUNT) of \LINEBUF.OFD with 0)          (replace (LINEBUFFER INSTRINGP) of \LINEBUF.OFD with NIL)          (\SETUPGETCH (TEXTPROP TEXOBJ (QUOTE STARTINGEOF))		       TEXOBJ)          [for I from (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)) to (fetch TEXTLEN of TEXOBJ)	     do (\INCPARENCOUNT (\SYNCODE RTBLSA (\BIN STREAM]          (replace (STREAM REVALIDATEFLG) of \LINEBUF.OFD with NIL)                                                             (* Last thing is to reset the validation flag, and 							     always RETURN T for AND's to work)          (RETURN T])(TEXEC.PARENMATCH  [LAMBDA (RSNX)                                             (* AJB "30-Jul-85 11:47")          (* * Returns CH# if matching left paren/bracket is found, else NIL)    (DECLARE (USEDFREE #CURRENTRDTBL# \TERM.OFD TEXOBJ))    (PROG (MATCH? N CH CH1 CH2 (PCOUNT 1))          (SELECTC RSNX		   [RIGHTPAREN.RC (SETQ CH (CAR (GETSYNTAX (QUOTE LEFTPAREN)							   #CURRENTRDTBL#)))				  (SETQ CH1 (CAR (GETSYNTAX (QUOTE RIGHTPAREN)							    #CURRENTRDTBL#]		   [RIGHTBRACKET.RC (SETQ CH (CAR (GETSYNTAX (QUOTE LEFTBRACKET)							     #CURRENTRDTBL#)))				    (SETQ CH1 (CAR (GETSYNTAX (QUOTE RIGHTBRACKET)							      #CURRENTRDTBL#]		   0)          [for I from 1 to (IDIFFERENCE (fetch TEXTLEN of TEXOBJ)					(TEXTPROP TEXOBJ (QUOTE STARTINGEOF)))	     do (SETQ CH2 (TEXEC.NTHBUFCHARBACK I))		[COND		  ((EQ CH2 CH1)		    (SETQ PCOUNT (ADD1 PCOUNT)))		  ((EQ CH2 CH)		    (SETQ PCOUNT (SUB1 PCOUNT]	     until (SETQ MATCH? (EQ PCOUNT 0)) finally (COND							 (MATCH? (\CARET.DOWN \TERM.OFD)								 (SETQ N (TEXEC.NTHBACKCHNUM								     (SUB1 I]          (RETURN N])(TEXEC.FLASHCARET  [LAMBDA (N)                                                (* AJB "14-Aug-85 18:24")          (* * Flashes caret at char# N, used for flashing caret at matching paren/bracket If N is NIL, simply returns)    (DECLARE (USEDFREE TEXOBJ))    (PROG (TSEL)          (COND	    ((NOT N)	      (RETURN)))          (SETQ TSEL (create SELECTION			using (fetch SEL of TEXOBJ)			      CH# _ N CHLIM _ N DCH _ 0 POINT _(QUOTE LEFT)			      \TEXTOBJ _ TEXOBJ SET _ T))          (UNINTERRUPTABLY              (\CHECKCARET)	      [bind (FIRSTTIME _ T) for CARET inside (fetch CARET of TEXOBJ) as WIN		 inside (fetch (TEXTOBJ \WINDOW) of TEXOBJ)		 do (\FIXSEL TSEL TEXOBJ WIN)		    (COND		      (FIRSTTIME (SETQ FIRSTTIME NIL)				 (\CARET.FLASH? (fetch TCCARETDS of CARET)						(fetch TCCARET of CARET)						NIL NIL (fetch X0 of TSEL)						(fetch Y0 of TSEL)))		      (T (\CARET.FLASH.AGAIN (fetch TCCARET of CARET)					     (fetch TCCARETDS of CARET)					     (fetch X0 of TSEL)					     (fetch Y0 of TSEL]	      (DISMISS 500))])(TEXEC.TEXTSTREAM.TO.LINEBUF  [LAMBDA (TEXOBJ STARTINGEOF LINEBUF FILLTYPE)              (* AJB " 1-Aug-85 11:01")                                                             (* Copy the contents of the current edit line into the 							     line buffer, for transmission to the system.)    (\SETUPGETCH (IMIN (fetch TEXTLEN of TEXOBJ)		       (ADD1 STARTINGEOF))		 TEXOBJ)    (SETFILEPTR LINEBUF 0)    (\SETEOFPTR LINEBUF 0)    (while (NOT (EOFP (fetch STREAMHINT of TEXOBJ)))       do (\LINEBUFBOUT LINEBUF (PROG [(C (\BIN (fetch STREAMHINT of TEXOBJ]				      [COND					((AND (NEQ FILLTYPE READC.FT)					      (EQ (CHARCODE ^V)						  C))        (* convert ^Vx to real CONTROL char)					  (SETQ C					    (COND					      ([OR (AND (IGEQ (SETQ C (\BIN (fetch STREAMHINT									       of TEXOBJ)))							      (CHARCODE A))							(ILEQ C (CHARCODE Z)))						   (AND (IGEQ C (CHARCODE a))							(ILEQ C (CHARCODE z]                                                             (* CONVERT TO CONTROL CHAR)						(LOGAND C 31))					      (T C]				      (RETURN C])(TEXEC.NTHBUFCHARBACK  [LAMBDA (N)                                                (* AJB "11-Jul-85 17:05")                                                             (* Return the Nth character back from the current end 							     of text. Puts the pointer back at the end of the 							     buffer)    (DECLARE (USEDFREE TEXOBJ))    (PROG ((CHPOS (TEXEC.NTHBACKCHNUM N)))                   (* CHPOS is the actual char position in the text.)          (COND	    ((OR (ILEQ CHPOS (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)))		 (ILEQ CHPOS 1))                             (* returns NIL if there is no char at that position)	      (RETURN)))          (\SETUPGETCH CHPOS TEXOBJ)                         (* Setup position to BIN character)          (RETURN (\BIN (fetch STREAMHINT of TEXOBJ])(TEXEC.NTHBACKCHNUM  [LAMBDA (N)                                                (* AJB "10-Jul-85 13:09")                                                             (* Converts N chars back from the end of the selection 							     to a CH#)    (DECLARE (USEDFREE TEXOBJ))    (IDIFFERENCE (IMIN (fetch TEXTLEN of TEXOBJ)		       (SELECTQ (fetch POINT of (fetch SEL of TEXOBJ))				(LEFT (fetch CH# of (fetch SEL of TEXOBJ)))				(RIGHT (fetch CHLIM of (fetch SEL of TEXOBJ)))				NIL))		 N])(TEXEC.EOTP  [LAMBDA NIL                                                (* AJB " 3-Jul-85 16:54")                                                             (* Test if the caret is at the end of the text)    (DECLARE (USEDFREE TEXOBJ))    (PROG ((SEL (fetch SEL of TEXOBJ)))          (RETURN (ILESSP (fetch TEXTLEN of TEXOBJ)			  (SELECTQ (fetch POINT of SEL)				   (LEFT (fetch CH# of SEL))				   (RIGHT (fetch CHLIM of SEL))				   NIL])(TEXEC.GETKEY  [LAMBDA NIL                                                (* AJB "14-Aug-85 13:33")          (* * Return a character from the keyboard without echoing. If no key has been typed flash the caret in all of the 	  attached windows if the keyboard is attached to this process, ie, is the TTYDISPLAYSTREAM. Blocks until a key is 	  typed with the keyboard attached to this process)    (PROG NIL          (until (\WAITFORSYSBUFP 100)	     do (TEDIT.FLASHCARET (fetch CARET of TEXOBJ))		(BLOCK))                                     (* Flash carets in all windows until a key is entered)          (RETURN (\GETKEY])(TEXEC.INSERTCHAR  [LAMBDA (C)                                                (* AJB "14-Aug-85 11:47")          (* * Inserts a character into the textstream. If the character is being inserted prior to the current input then the	  start of the current input pointer, STARTINGEOF is incremented. If echoing is off, then the character is inserted as	  "invisible")    (DECLARE (USEDFREE TEXOBJ SEL \PRIMTERMTABLE \TERM.OFD))    [COND      ((ILEQ (SELECTQ (fetch POINT of SEL)		      (LEFT (fetch CH# of SEL))		      (RIGHT (fetch CHLIM of SEL))		      NIL)	     (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)))	[TEXTPROP TEXOBJ (QUOTE STARTINGEOF)		  (ADD1 (TEXTPROP TEXOBJ (QUOTE STARTINGEOF]                                                             (* If inserting text prior to current input move the 							     start of input down 1 to compensate)	)      (T (AND (IGREATERP (IMIN (fetch CH# of SEL)			       (fetch CHLIM of SEL))			 (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)))	      (TEDIT.DO.BLUEPENDINGDELETE SEL TEXOBJ]        (* Only allow deletion of seletected text if after 							     start of current input)    (COND      ((fetch ECHOFLG of \PRIMTERMTABLE)	(TEDIT.\INSERT (OR C (TEXEC.GETKEY))		       SEL \TERM.OFD))      (T (TEDIT.CARETLOOKS TEXOBJ (QUOTE (INVISIBLE ON)))	 (TEDIT.\INSERT (OR C (TEXEC.GETKEY))			SEL \TERM.OFD)	 (TEDIT.CARETLOOKS TEXOBJ (QUOTE (INVISIBLE OFF])(TEXEC.\CHDEL1  [LAMBDA NIL                                                (* AJB "14-Aug-85 18:54")                                                             (* Delete the last character in the text stream, and 							     return it, so we can decide what to do with it.)    (DECLARE (USEDFREE TEXOBJ \LINEBUF.OFD))    (LET* [(SEL (fetch SEL of TEXOBJ))	   (TEXTLEN (fetch TEXTLEN of TEXOBJ))	   (CH (COND		 ((SELECTQ (fetch POINT of SEL)			   (LEFT (IDIFFERENCE (fetch CH# of SEL)					      1))			   (RIGHT (fetch CH# of SEL))			   NIL]                              (* CH = character position at current location of 							     caret)          (COND	    ((NEQ CH (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)))                                                             (* don't allow deletion of text if at beginning of 							     current input)	      (COND		((ILEQ (SELECTQ (fetch POINT of (fetch SEL of TEXOBJ))				(LEFT (fetch CH# of (fetch SEL of TEXOBJ)))				[RIGHT (SUB1 (fetch CHLIM of (fetch SEL of TEXOBJ]				NIL)		       (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)))		  [TEXTPROP TEXOBJ (QUOTE STARTINGEOF)			    (SUB1 (TEXTPROP TEXOBJ (QUOTE STARTINGEOF]                                                             (* If deleting text prior to current input move the 							     start of input up 1 to compensate)		  ))	      (COND		((TEXEC.EOTP))		(T (replace (STREAM REVALIDATEFLG) of \LINEBUF.OFD with T)                                                             (* Invalidate paren/bracket count since we are no 							     longer at the end of the text)		   ))	      (PROG1 (PROGN (\SETUPGETCH CH TEXOBJ)			    (\BIN (fetch STREAMHINT of TEXOBJ)))		     (\TEDIT.CHARDELETE TEXOBJ "" (fetch SEL of TEXOBJ])(TEXEC.?EQUAL  [LAMBDA NIL                                                (* AJB " 5-Aug-85 09:47")          (* * Test for ?= and if so handle it and RETURN T else RETURN NIL)    (DECLARE (USEDFREE #CURRENTRDTBL# TEXOBJ))    (PROG [(CH# 0)	   (TS (fetch STREAMHINT of TEXOBJ))	   LST PTR FNAME TAIL TEMPFILE (STARTINGEOF (TEXTPROP TEXOBJ (QUOTE STARTINGEOF]          (COND	    ((AND (EQ (TEXEC.NTHBUFCHARBACK 0)		      (CHARCODE =))		  (EQ (TEXEC.NTHBUFCHARBACK 1)		      (CHARCODE ?))		  (EQ (TEXEC.NTHBUFCHARBACK 2)		      (CHARCODE % )))	      (TEXEC.FILLBUFFER.CHARDELETE)                  (* Delete ?= from input stream)	      (TEXEC.FILLBUFFER.CHARDELETE)	      (SETQ CH# (IMAX (OR (TEXEC.PARENMATCH RIGHTBRACKET.RC)				  0)			      (OR (TEXEC.PARENMATCH RIGHTPAREN.RC)				  0)))	      (COND		((ZEROP CH#)		  (RETURN)                                   (* No left paren/bracket, return NIL)		  ))	      (\SETUPGETCH CH# TEXOBJ)	      (RESETLST (RESETSAVE NIL (LIST (FUNCTION CLOSEF)					     TEMPFILE))			(SETQ TEMPFILE (OPENSTREAM (QUOTE {NODIRCORE})						   (QUOTE BOTH)						   (QUOTE OLD/NEW)						   NIL))			(for I from CH# to (fetch TEXTLEN of TEXOBJ) do (\BOUT TEMPFILE (\BIN TS)))			(SETFILEPTR TEMPFILE 0)			(READC TEMPFILE)                     (* Skip first left paren/bracket)			(SETQ FNAME (READ TEMPFILE T T))			(SETQ TAIL (TCONC NIL FNAME))			[NLSETQ (repeatuntil (EOFP TEMPFILE) do (TCONC TAIL (READ TEMPFILE T T]			(DO?= (LIST FNAME)			      (CAR TAIL)			      \TERM.OFD)			(\OUTCHAR \TERM.OFD (CHARCODE EOL))			(\OUTCHAR \TERM.OFD (CHARCODE EOL))			(\TEDIT.MARK.LINES.DIRTY TEXOBJ STARTINGEOF (fetch TEXTLEN of TEXOBJ))			(TEDIT.UPDATE.SCREEN TEXOBJ))	      (RETURN T))	    (T (RETURN])(\TEDITSTREAMBOUT  [LAMBDA (STREAM BYTE)                                      (* AJB "15-Aug-85 10:22")                                                             (* Do BOUT to a text stream, which is an insertion at 							     the end of text pointer)    (PROG ((TEXOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM))	   CH# WINDOW TEXTLEN PS PC PSTR OFFST SEL STARTINGEOF)          [SETQ STARTINGEOF (ADD1 (TEXTPROP TEXOBJ (QUOTE STARTINGEOF]                                                             (* Insertion point for output -							     is actually the beginning of the next/current text 							     being entered to return to READ)          (TEXTPROP TEXOBJ (QUOTE STARTINGEOF)		    STARTINGEOF)                             (* This adds 1 to the previous value on the property 							     list)          (SETQ TEXTLEN (fetch TEXTLEN of TEXOBJ))           (* The length of the total text in chars)          (SETQ WINDOW (fetch \WINDOW of TEXOBJ))          (SETQ SEL (fetch SEL of TEXOBJ))                   (* The current selection)          (COND	    ([NOT (LDIFFERENCE (fetch L1 of SEL)			       (QUOTE (NIL]	      (RETURN)))                                     (* Return if caret out of bounds, ie, user scrolls past							     end of text)          (SETQ CH# (OR STARTINGEOF (fetch CH# of SEL)))          [for WIN inside WINDOW do (\CARET.DOWN (WINDOWPROP WIN (QUOTE DSP]          (AND WINDOW (\TEDIT.MARK.LINES.DIRTY TEXOBJ CH# CH#))          (\INSERTCH BYTE CH# TEXOBJ)          (AND WINDOW	       (PROG ((THISLINE (fetch THISLINE of TEXOBJ))		      EOLFLAG CHORIG CHWIDTH OXLIM OCHLIM OCR\END PREVSPACE FIXEDLINE NEXTLINE LINES 		      NEWLINEFLG DX PREVLINE SAVEWIDTH OFLOWFN OLHEIGHT DY TABSEEN IMAGECACHE FONT		      (LOOKS (\TEDIT.APPLY.STYLES (fetch CARETLOOKS of TEXOBJ)						  (fetch \INSERTPC of TEXOBJ)						  TEXOBJ)))		     (add (fetch CH# of SEL)			  1)                                 (* These must be here, since SELs are valid even 							     without a window.)		     (replace CHLIM of SEL with (fetch CH# of SEL))		     (replace POINT of SEL with (QUOTE LEFT))		     (replace DCH of SEL with 0)		     (replace SELKIND of SEL with (QUOTE CHAR))		     (SETQ FONT (fetch CLFONT of LOOKS))          (* * Update stream CHARPOSITION for calls to POSITION ie, GAINSPACE)		     [SELECTC BYTE			      ((CHARCODE (EOL CR))				(POSITION STREAM 0)          (* Carriage Return, set CHARPOSITION to 0)				)			      (POSITION STREAM (ADD1 (POSITION STREAM]		     (for WIN inside WINDOW as L1 inside (fetch L1 of SEL) as LN			inside (fetch LN of SEL)			do (COND			     (L1 (add (fetch CHARLIM of L1)				      1)				 (add (fetch CHARTOP of L1)				      1)))			   (DSPFONT FONT WIN))		     [COND		       ((OR (IGREATERP (PLUS (fetch X0 of SEL)					     (CHARWIDTH BYTE FONT))				       (IDIFFERENCE (fetch WRIGHT of TEXOBJ)						    8))			    (IEQP BYTE (CHARCODE EOL))			    (IEQP BYTE (CHARCODE CR))			    (ILESSP CH# TEXTLEN))            (* gone off the edge of the line reformat and add new 							     line)                                                             (* Or not at end of text)			 (POSITION STREAM 0)                 (* Update X position for callers of POSITION)			 (\SHOWSEL SEL NIL NIL)			 (TEDIT.UPDATE.SCREEN TEXOBJ)			 (\FIXSEL SEL TEXOBJ NIL)			 [for WIN inside WINDOW as L1 inside (fetch L1 of SEL) as LN			    inside (fetch LN of SEL)			    do (COND				 ([AND (SELECTQ (fetch POINT of SEL)						(LEFT L1)						(RIGHT LN)						NIL)				       (ILEQ (SELECTQ (fetch POINT of SEL)						      (LEFT (fetch YBOT of L1))						      (RIGHT (fetch YBOT of LN))						      0)					     (fetch BOTTOM of (DSPCLIPPINGREGION NIL WIN]                                                             (* The caret is off-window in the selection window.							     Need to scroll it up so the caret is visible.)				   (while (OR (ILESSP (SELECTQ (fetch POINT of SEL)							       (LEFT (fetch YBOT of L1))							       (RIGHT (fetch YBOT of LN))							       0)						      (fetch WBOTTOM of TEXOBJ))					      (IGEQ (fetch Y0 of SEL)						    (fetch WTOP of TEXOBJ)))				      do                     (* The caret just went off-screen.							     Move it up some.)					 (replace EDITOPACTIVE of TEXOBJ with NIL)					 (SCROLLW WIN 0						  (LLSH (COND							  [(SELECTQ (fetch POINT of SEL)								    (LEFT L1)								    (RIGHT LN)								    NIL)							    (fetch LHEIGHT							       of (SELECTQ (fetch POINT of SEL)									   (LEFT L1)									   (RIGHT LN)									   (SHOULDNT]							  (T 12))							1]			 (\SHOWSEL SEL NIL T))		       (T (for WIN inside WINDOW as L1 inside (fetch L1 of SEL) as LN			     inside (fetch LN of SEL) as CARET inside (fetch CARET of TEXOBJ)			     do (COND				  (L1 (TEDIT.DISPLAYTEXT TEXOBJ BYTE (CHARWIDTH BYTE FONT)							 L1							 (DSPXPOSITION NIL WIN)							 WIN SEL)                                                             (* Print out the character on the screen)				      ))				(replace X0 of SEL with (DSPXPOSITION NIL WIN))				(replace XLIM of SEL with (DSPXPOSITION NIL WIN))				(\EDIT.DOWNCARET CARET]		     (replace ONFLG of SEL with T)		     (replace DESC of THISLINE with NIL)          (* SO that this line of text is run thru the formatter again before anything interesting that depends on it being 	  right (like scrolling the window))          (* * Fix up the TEXTSTREAM so that the FILEPTR looks like it ought to after the BOUT, even though we've been 	  updating the screen (which usually moves the fileptr....))		     [SETQ PS (ffetch PSTR of (SETQ PC (fetch \INSERTPC of TEXOBJ]                                                             (* This piece resides in a STRING.							     Because it's newly "typed" material.)		     (replace (TEXTSTREAM PIECE) of STREAM with PC)                                                             (* Remember the current piece for others.)		     (replace (TEXTSTREAM PCNO) of STREAM with (fetch \INSERTPCNO of TEXOBJ))                                                             (* And which number piece this is.)		     (freplace CPPTR of STREAM with (ADDBASE (ffetch (STRINGP BASE) of PS)							     (LRSH (SETQ OFFST (ffetch (STRINGP											 OFFST)										  of PS))								   1)))                                                             (* Pointer to the actual characters in the string 							     (allowing for substrings.))		     (freplace CPAGE of STREAM with 0)		     (freplace COFFSET of STREAM with (IPLUS (freplace (TEXTSTREAM PCSTARTCH)								of STREAM with (LOGAND 1 OFFST))							     (fetch \INSERTLEN of TEXOBJ)))		     (freplace (TEXTSTREAM PCSTARTPG) of STREAM with 0)                                                             (* Page # within the "file" where this piece starts)		     (freplace CBUFSIZE of STREAM with (fetch COFFSET of STREAM))		     (freplace EPAGE of STREAM with 1)		     (freplace (TEXTSTREAM CHARSLEFT) of STREAM with 0)                                                             (* We're, perforce, at the end of the piece.)		     (freplace (TEXTSTREAM REALFILE) of STREAM with NIL)                                                             (* We're not on a file....)		 ]))(* Code to support a TEXEC lisp "listener")(DEFINEQ(TEXEC  [LAMBDA (Prompt)                                           (* AJB "15-Aug-85 15:58")                                                             (* Create an Interlisp executive window with TEdit as 							     the editor behind it.)    (PROG (handle window teditstream)          (SETQ window (CREATEW NIL "TEXEC (Version 7.0)"))                                                             (* Create a window for the TEdit-based listener)          (SETQ teditstream (OPENTEDITSTREAM window (QUOTE NULL)))                                                             (* Create a TEdit stream for the listeer, and fill in 							     our non-standard fields)          (SETQ handle (ADD.PROCESS [BQUOTE (PROGN (TTYDISPLAYSTREAM (QUOTE , teditstream))						   (EVALQT (QUOTE , (OR Prompt (QUOTE #]				    (QUOTE NAME)				    (QUOTE TEXEC)				    (QUOTE RESTARTABLE)				    T))                      (* Create the listener process)          (WINDOWPROP window (QUOTE TITLE)		      (PROCESSPROP handle (QUOTE NAME)))          [WINDOWADDPROP window (QUOTE CLOSEFN)			 (FUNCTION (LAMBDA (window)			     (PROG [(proc (WINDOWPROP window (QUOTE PROCESS]			           (RETURN (COND					     ((EQ (THIS.PROCESS)						  proc)					       (ADD.PROCESS (LIST (QUOTE CLOSEW)								  (KWOTE window)))					       (QUOTE DON'T))					     ((PROCESSP proc)					       (DEL.PROCESS proc)					       NIL]          (TTY.PROCESS handle]))(APPENDTOVAR BackgroundMenuCommands (TEXEC (QUOTE (TEXEC))					   "Starts TEXEC in a new window."))(RPAQQ BackgroundMenu NIL)(FILESLOAD TEDITCHAT)(PUTPROPS TEXEC COPYRIGHT ("Xerox Corporation" 1985 1900))(DECLARE: DONTCOPY  (FILEMAP (NIL (1170 42993 (OPENTEDITSTREAM 1180 . 2297) (TEXEC.FILLBUFFER 2299 . 11264) (TEXEC.FILLBUFFER.TCLASS 11266 . 14823) (TEXEC.FILLBUFFER.CHSELPENDING 14825 . 18809) (TEXEC.FILLBUFFER.CHARDELETE 18811 . 20174) (TEXEC.FILLBUFFER.WORDDELETE 20176 . 22335) (TEXEC.PARENCOUNT 22337 . 23387) (TEXEC.PARENMATCH 23389 . 24553) (TEXEC.FLASHCARET 24555 . 25752) (TEXEC.TEXTSTREAM.TO.LINEBUF 25754 . 26905) (TEXEC.NTHBUFCHARBACK 26907 . 27751) (TEXEC.NTHBACKCHNUM 27753 . 28328) (TEXEC.EOTP 28330 . 28834) (TEXEC.GETKEY 28836 . 29510) (TEXEC.INSERTCHAR 29512 . 31020) (TEXEC.\CHDEL1 31022 . 32945) (TEXEC.?EQUAL 32947 . 34807) (\TEDITSTREAMBOUT 34809 . 42991)) (43046 44541 (TEXEC 43056 . 44539)))))STOP