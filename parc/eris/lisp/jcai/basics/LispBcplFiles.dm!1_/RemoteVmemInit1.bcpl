// RemoteVMemInit1.bcpl - handles pulling in remote sysout// Last change January 21, 1985  2:28 PM by Bill van Melle// Last change May 20, 1984  7:13 PM by Bill van Melle// Last change August 1, 1983  5:50 PM by Bill van Melle// Last change January 21, 1983  11:10 AM by Bill van Melle// Last change June 8, 1982  10:42 PM by Bill van Melle// Last change April 11, 1982  5:40 PM by Bill van Melle// Last change December 29, 1981  11:50 AM by Bill van Melle// Last change November 30, 1981  9:59 PM by Bill van Melle// Last change September 7, 1981  1:04 PM by Bill van Melle	get "LispBcpl.decl"	get "VMem.decl"	get "FtpProt.decl"	get "AltoDefs.d"external [	// procedures defined here	Retrieve; Wss; FixPassword		// O.S. procedures	CallSwat; Puts; Ws		// misc procedures used	ReadStrng; AppendString; RetrieveVmem; ShowSysoutName 		// pup procs	BSPReadBlock; UserClose; ReleasePBI		// statics used	LispFmap 	CtxRunning	UserName; UserPassword; dsp; SysinName; SysinHostName		// statics from RemoteVMemInit.bcpl	sysoutFailed; ftpBadPup	]manifest [	firstMouseY = 50	lastMouseY = 800	]//----------------------------------------------------------------------------structure String: [ length byte; char^1,255 byte ]//----------------------------------------------------------------------------let Retrieve (remotePL, localPL) = valof[		// this two-level action needed to approve the file,		// then retrieve itSysinName>>String.length = 0		// fill in correct name now.  remotePL is ephemeral, so copyAppendString(SysinName, remotePL>>PL.SFIL)ShowSysoutName (lv remotePL>>PL.CDAT)resultis LispRetrieveFile]and LispRetrieveFile (remotePL, localPL) = valof[ let bspStream = CtxRunning>>FtpCtx.bspStream let buffer = CtxRunning>>FtpCtx.buffer let bufferLength = CtxRunning>>FtpCtx.bufferLength for i = 1 to FirstVmemBlock-1 		// start at page 1--IFS has no leader page    do BSPReadBlock (bspStream, buffer, 0, WordsPerPage lshift 1)		// skip over the silly pages before the good stuff RetrieveVmem (bspStream, buffer, bufferLength, FtpReadFn, FtpFinishFn)  resultis true]and FtpReadFn(stream, buffer, bufferLength)  = valof[FlipCursor()resultis BSPReadBlock (stream, buffer, 0, bufferLength lshift 1) rshift 1]and FtpFinishFn(stream, buffer) be[   sysoutFailed = false   if ftpBadPup	then [ ReleasePBI(ftpBadPup); ftpBadPup = 0 ]		// or else BSPCloseSocket will hang   if BSPReadBlock (stream, buffer, 0, 512) gr 0	then // still stuff to read	     [	     UserClose(true)	// abort connection	     ]]and FlipCursor () be[ for i = 0 to 15 do cursorBitMap!i = not cursorBitMap!i ]and Wss (stream, str) be[ for i = 1 to str>>String.length     do Puts(stream, str>>String.char^i)]and FixPassword (host) be[Ws ("*n{")Ws (host)Ws ("} Login user: ")let haveDefaultName = UserName>>String.length gr 0unless ReadStrng (UserName, (UserName!-1 lshift 1) - 1, haveDefaultName) loopWs (" (password) ")if ReadStrng (UserPassword, (UserPassword!-1 lshift 1) - 1, false, true)    then return] repeat