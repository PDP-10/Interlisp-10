<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>JCAI>BASICS>LISP0MC.DM!1>LispDefs.0mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:TITLE[LispDefs, January 14, 1985  5:18 PM, van Melle];<br><br>INSERT[GlobalDefs];<br><br>mc[DolphinMcVersion, 1];<br>set[WindFlg, 1];<br>set[FaultFlg, WindFlg];<br>set[WithAudio, IFE[WithMidas, 0, 0, 0]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* never with Midas<br>set[</span><span style="font: 12pt serif">WithFloatingPoint</span><span style="font: 10pt serif">, XOR[And[With3MB, With10MB], 1]];<br>set[</span><span style="font: 12pt serif">WithBin</span><span style="font: 10pt serif">, IFE[WithMidas, 0, 1, 0]];<br>set[</span><span style="font: 12pt serif">WithCons</span><span style="font: 10pt serif">, IFE[WithMidas, 0, 1, 0]];<br>set[</span><span style="font: 12pt serif">WithCreateCell</span><span style="font: 10pt serif">, 1];<br>set[WithPPBlt, 0];<br><br>mc[RamRelease, 13000];<br>mc[MinBcplVersion, 24000];<br>mc[MinLispVersion, 113000];<br><br>set[StatsMode, IFE[WithMidas, 0, 1, 0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* must be zero if WithMidas<br>set[FvarStatsMode, And[StatsMode, 0]];<br>set[CdrCoding, 1];<br>set[Debugging, 1];<br>set[BreakPoints, WithMidas];<br>set[StkDebug, 0];<br><br>****** These are declarations for alto that are also used by Lisp<br><br>RV2[AC0, AC0hi, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* emulator Ac&rsquo;s, with hi part = MDShi<br>RV[AC1, 26];<br>RV2[AC2, AC2hi, 4];<br>RV[AC3, 22];<br><br>RV2[PCB, PCBhi, 30];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Code base for Lisp, Bcpl<br><br>RV2[MDS, MDShi, 32];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Basereg for alto space (lo = hi = 0)<br><br>RV[NWW, 24];<br><br>RV[R177400, 14];<br>RV[R400, 60];<br>RV[AllOnes, 61];<br>RV[RZero, IP[MDS]];<br><br>RV4[IBuf, IBuf1, IBuf2, IBuf3, 34];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* instruction buf, both Alto and Lisp<br><br>RV4[xBuf, xBuf1, xBuf2, xBuf3, 44];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Temporary buf<br>RV[XBufRow, IP[XBuf1]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* for XMap<br>RV[XBufFC, IP[XBuf3]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* for XMap<br>RV2[RTemp, RTemp1, 52];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* temp/pair<br><br>***** Lisp permanent registers<br><br>RV2[lspEp, lspEpHi, 66];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Perm/pair, hi = StackSpace<br><br>RV2[lspStkBr, lspStkBrHi, 62];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Const/pair = StackSpace, 0<br><br>RV2[lspTsp, lspTspHi, 12];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Setfe/pair, hi = StackSpace<br>RV[lspEsp, 07];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Setfe<br><br>RV4[lspIfuBr, lspIfuBrHi, lspNext, </span><span style="font: 10pt serif">lspPC</span><span style="font: 10pt serif">, 40];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Setfe/quad <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* lspNext, </span><span style="font: 10pt serif">lspPC</span><span style="font: 10pt serif"> used as temp<br>RV[StkState, 56];<br>RV[lspIBasex, 57];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* These two coincident with WW, ACTIVE<br><br>RV[lspInstFlag, 00];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* State tested at page fault<br>  Mc[NormalState, 0];<br>  Mc[InBcplState, 1];<br>  Mc[InBitBltState, 2];<br>  Mc[InAltoBitBltState, 2];<br>  Mc[InBltState, 3];<br>  Mc[InPPBltState, 4];<br>  Mc[InBltState4, 5];<br>  Mc[InCallState, 100000];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* sign bit<br><br><br>RV[lspStatsPtr, 06];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Perm.  Sign bit = off; otherwise is mds ptr<br><br>Settask[10];<br>RV4[HStack0, HStack1, HStack2, HStack3, 20];<br>RV4[HStack4, HStack5, HStack6, HStack7, 24];<br>RV4[HStack10, HStack11, HStack12, HStack13, 30];<br>RV4[HStack14, HStack15, HStack16, HStack17, 34];<br>Settask[0];<br><br>***** Lisp temporary registers<br><br>RV[lspLN, IP[lspPC]];<br><br>RV2[lspDefx0, lspDefx1, 54];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* temp/pair -- function call<br>RV[lspNargs, 20];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* temp<br><br>RV2[lspL0, lspL1, 70];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* temporary pair<br>RV2[lspL2, lspL3, 72];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* temporary pair<br><br>RV[lspL4, 03];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* temp<br>RV[lspL5, 25];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* temp<br><br>RV2[lspGenBr, lspGenBrHi, 50];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* temp/pair<br><br>***** Lisp temporary registers that are used by Alto also<br><br>RV[lspL6, 1];<br>RV[lspL7, 2];<br>RV2[MDSTypeBaseBr, MDSTypeBaseBrHi, 64];<br>RV4[qBuf, qBuf1, qBuf2, qBuf3, 74];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* overlays RWPAC0-3<br>RV4[uBuf, uBuf1, uBuf2, uBuf3, 14];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* overlays R177400-3<br><br>***** Other overlays<br><br>RV[lspType, IP[lspL4]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* type # returned by lspTyp subroutine<br>RV[lspUFN, IP[AC3]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* ufn # for calls to ufnLBL<br><br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* For FVar lookup<br>RV[SavedFvarOffset, IP[AC0]];<br>RV[FVarName, IP[AC1]];<br>RV[FVarReturnAddress, IP[lspL7]];<br>RV2[FVarBinding, FVarBindingHi, IP[lspL0]];<br><br><br>%  These could also be assigned:<br>RV[, 21];<br><br>* Could also use the AC&rsquo;s !!<br>%<br><br>:IF[WithPilotBitBlt];<br></span><span style="font: 12pt serif">*BitBlt temporaries.  10b of these have to be preserved over interrupts.<br>* Pilot puts them on the stack, but we can&rsquo;t do that, so just assign them to<br>* two quad group regs for easy storing<br>* RTemp is also used here.<br>* beware that these first 8 regs are not ones smashed by Fault!!!<br>*RV[bbArgPtr,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*pointer to BitBltArg table<br>*RM[bbGrayWordIndex,IP[bbArgPtr]];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Low order 4 bits<br>RM[bbGrayWordIndex,IP[uBuf1]];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Low order 4 bits are used<br>RV2[bbDestQLo,bbDestQHi,IP[uBuf2]];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Dest Quad word address<br>RV2[bbSourceQLo,bbSourceQHi,IP[qBuf]];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Source Quadword address.  Quad<br>RV[bbSourceBitOffset,IP[qBuf2]];<br>RV[bbItemsRemaining,IP[qBuf3]];<br>RV[bbDestBitOffset,IP[</span><span style="font: 10pt serif">lspDefx0</span><span style="font: 12pt serif">]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">* even<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">* End of regs needing saving<br>RV[bbDestBpl,IP[</span><span style="font: 10pt serif">lspDefx1</span><span style="font: 12pt serif">]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">* = bbDestBitOffset + 1<br>RV[bbItemWidth,IP[lspL5]]; <br>RV[bbSubitemDestBitOffset,IP[lspL6]];<br>RV[bbFlags,IP[lspL7]];<br>RV[bbGrayWord,IP[</span><span style="font: 10pt serif">xBuf</span><span style="font: 12pt serif">]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Gray word<br>RV[bbNegItemWidth,IP[</span><span style="font: 10pt serif">AC2hi</span><span style="font: 12pt serif">]]; <br>RV[bbDest,IP[</span><span style="font: 10pt serif">lspNargs</span><span style="font: 12pt serif">]];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Quadword buffer -- gets also 21, AC3, AC3hi<br>RV[bbSDNonOverlap,IP[</span><span style="font: 10pt serif">AC2</span><span style="font: 12pt serif">]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">* Can coincide with bbDest<br>RV[bbNegSDNonOverlap,IP[</span><span style="font: 10pt serif">AC0hi</span><span style="font: 12pt serif">]];<br>RV[bbDestWordOffset,IP[</span><span style="font: 10pt serif">lspGenBr</span><span style="font: 12pt serif">]];<br>RV[bbSourceBpl,IP[</span><span style="font: 10pt serif">lspGenBrHi</span><span style="font: 12pt serif">]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*source bits per line<br>RV[bbSourceWordOffset,IP[</span><span style="font: 10pt serif">xBuf1</span><span style="font: 12pt serif">]]; <br>RV[bbTouchPages,IP[</span><span style="font: 10pt serif">lspLN</span><span style="font: 12pt serif">]];<br>RV[bbSubitemSourceBitOffset,IP[</span><span style="font: 10pt serif">AC0</span><span style="font: 12pt serif">]];<br>RV[bbSource,IP[lspL0]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Quadword buffer<br>RV2[bbArgLo,bbArgHi,IP[xBuf2]];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Points to BitBltArg table<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">* Can coincide with bbSource<br><br><br>*End of bitblt registers<br></span><span style="font: 10pt serif">:ENDIF;<br><br><br>* Bcpl common addresses<br>MC[SubrArgArea, 210];<br>MC[BcplStartAddress, 206];<br>MC[StatsPointerLocation, 200];<br>MC[StatsBufferBoundary, 1400];<br>MC[BitBltStash, 250];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 10b words for saving BitBlt state<br><br>* Bit masks<br>MC[FreeStackBlock, 120000];<br>MC[BfBlock, 100000];<br>MC[BfBlockPad, 100400];<br>MC[FxtnBlock, 140000];<br>MC[FXFastReturn, 4000];<br>MC[FXInCall, 2000];<br>MC[FXNoPushReturn, 400];<br><br>MC[ht1Cnt, 2000];<br>MC[ht2Cnt, 4000];<br>MC[htStkBit, 1000];<br>MC[htCntMask, 176000];<br>MC[htStkCnt, 177000];<br><br>MC[unboundPvar, 100000];<br>MC[fxtnOverhead, 12];<br><br>MC[LispKeyMask, 20000];<br>MC[BcplKeyMask, 10400];<br>MC[BothKeyMasks, 30400];<br>MC[IFPFAULTHI, 37];<br>MC[IFPFAULTLO, 40];<br><br>* Atom constants<br>MC[ExprApplyAtom, 400];<br>MC[Dummy370, 370];<br>MC[MakeNumber, 374];<br>MC[SetGlobal, 375];<br>MC[KtVal, 114];<br>Mc[atomNOBIND, 1]<br>Mc[atomEVALFORM, 370]<br>Mc[atomGCOVERFLOW, 371]<br>Mc[atomGCGENPUNT, 377]<br>Mc[atomDTESTFAIL, 372]<br>Mc[atomOVERFLOWMAKENUMBER, 373]<br>Mc[atomSETFVAR, 376]<br>Mc[</span><span style="font: 12pt serif">MakeFloatNumber</span><span style="font: 10pt serif">, 401]<br><br>* Punt indexes<br>MC[UcodeCheckCodex, 0];<br>*MC[StackOvflCodex, 1];<br>MC[LispExitCodex, 2];<br>*MC[PageFaultCodex, 3];<br>MC[StatsOvflCodex, 4];<br><br>* uCodeCheck args<br>mc[FaultWithoutInterrupts, 301];<br>mc[NullFreeListPunt, 302];<br>mc[FaultInFault, 303];<br>  mc[minFaultPvar, 3000];<br><br>mc[SubovFXP,2];<br>mc[KbdFXP,3];<br>mc[FAULTFXP,6];<br><br>* Type constants<br>mc[SmallType, 1];<br>mc[FixpType, 2];<br>mc[FloatpType, 3];<br>mc[AtomType, 4];<br>mc[ListType, 5];<br>mc[ArrayType, 6];<br>mc[VMemPagePType, 12];<br>mc[StreamType, 13];<br><br>* Misc constants<br>*mc[StackNeeded, 14];<br>mc[StackRequested, 54];<br>mc[StackRequestedDelta, 40];<br>Mc[BltInterruptableMinWords, 10];<br>Mc[MaxNewCellCount, 10000];<br>Mc[CreateCellPunt, 20000];<br>Mc[GcOverflowPunt, 40000];<br>Mc[GcPunts, Or[CreateCellPunt!, GcOverflowPunt!]];<br><br><br>* The space constants should be turned into macros which generate<br>* 377 in the right half.<br><br>mc[smallpl, 16];<br>mc[smallNeg, 17];<br>mc[STATSspace, LSHIFT[6, 10]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[UFNTablebase, 6000];<br>mc[MDSTypeSpace, LSHIFT[6, 10]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[MDSTypebase, 100000];<br>mc[DTDspace, LSHIFT[6, 10]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[DTDBase, 10000];<br>mc[VALspace, LSHIFT[14, 10]];<br>mc[VALspace2, LSHIFT[15, 10]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[VALspaceR, 14];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[VALspace2R, 15];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[VALbase, 0];<br>mc[DEFSpace, LSHIFT[12, 10]];<br>mc[DEFSpace2, LSHIFT[13, 10]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[DEFBase, 0];<br>mc[htMainSpace, LSHIFT[20, 10]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[htMainBase, 0];<br>mc[StackSpace, LSHIFT[1, 10]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc [StackSpaceR, 1];<br>mc[INTERFACEspace, LSHIFT[6, 10]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[INTERFACEbase, 0];<br><br>M@[mbx, AT[lspmbxDisp,#1]];<br><br>M@[LBLPG,IFG[FVAL[PGE@],7,<br>SELECT[SUB[FVAL[PGE@],10],#1P10,#1P11,#1P12,#1P13,#1P14,#1P15,#1P16,#1P17],<br>SELECT[FVAL[PGE@],#1P0,#1P1,#1P2,#1P3,#1P4,#1P5,#1P6,#1P7]<br>]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Generates label from current page#, e.g.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* GOTO[LBLPG[lspUfnx]];<br><br>M@[CatLBL,IFG[#2,7,<br>SELECT[SUB[#2,10],#1P10,#1P11,#1P12,#1P13,#1P14,#1P15,#1P16,#1P17],<br>SELECT[#2,#1P0,#1P1,#1P2,#1P3,#1P4,#1P5,#1P6,#1P7]<br>]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Generates label from specified page#, e.g.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* GOTO[CatLBL[lspUfnx, pgArith]];<br><br>M@[MaybeLoadPage, IFE[FVAL[PGE@],#1,,LoadPage[#1]]];<br><br>M@[UFNLBL,LBLPG[LSPUFNX]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Ufn dispatch<br><br>M@[NXILBL,LBLPG[LSPNEXTINST]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* NextInst fetch<br><br>M@[PUSHLBL,LBLPG[PushChk]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* for opcodes that have net push<br><br>M@[POPLBL,LBLPG[PopChk]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* for opcodes that have net pop<br><br>M@[RETLBL,LBLPG[lspRET]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* mainly for tasking<br><br>Macro[NextOpCode, IFE[FVAL[PGE@], 17,<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">(goto[lspNextInstP17]),<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">(lu &larr; NextInst[IBuf], CallX[LBLPG[lnix]])]];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* goto[nxiLBL], but 2 cycles faster<br>* Fixed page locations<br>set[pgUfnx, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Ufn code: Same as function call opcodes<br>set[pgTyp, 4]; </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* lspTyp subroutine: Same as typechecking opcodes<br>set[pgJump, 6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* All pfetch4 that cause ibuf refills are here<br>set[pgArithOps, 7];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Same as arith opcodes<br>set[pgMapOps, 5];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Same as vmem map opcodes<br>set[pgCallOps, 4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Same as fncall opcodes<br>set[pgSetBase, 7];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* lspSetBase subroutine: same as PutBase etc.<br><br>* Movable page locations<br>set[pgReturn, 15];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 41b mi [35 Return + 4 Lisp0]<br>set[pgReturnA, 6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 47b mi<br>set[pgFrame, 11];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 43b mi; not 6<br>set[pgFrame2, 6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 23b mi<br>set[pgFrame3, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 31b mi + 5 if Stats; not 4-7<br>set[pgFrame4, 5];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 17b mi; not 4-7<br>set[pgBind, 16];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 54b mi<br>set[pgFvar, 15];<br>set[pgHStack, 16];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 61b mi<br>set[pgHtFind, 17];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 60b mi<br>set[pgArith, 15];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* not 4-7<br>set[pgLisp0, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* not 4-7<br>set[pgEval, 16];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 26b mi - 1 if on pgFvar or 4<br>set[pgGcScan, 17];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 34b mi; not 4-7<br>set[pgRplPtr, 16];<br>set[pgBin, 12];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 25b mi; not 6<br>set[pgCons, 17];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 142b mi<br>set[pgReclaim, 16];<br>set[pgRplacd, 6];<br>set[pgStats, 17];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 26b mi; not 4-7<br>set[pgBlt, 7];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* not 6<br>set[pgMisc, IFE[WithMidas, 0, 17, 15]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* not 4-7,  16b mi<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   plus 36b mi if WithPPBlt<br>set[pgUfnxA, 6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 25b mi<br>set[pgCreateCell, 16];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* not 6?<br></span><span style="font: 12pt serif">Set[</span><span style="font: 10pt serif">pgBitBlt</span><span style="font: 12pt serif">,12];</span><span class="tab" val="67"></span><span style="font: 12pt serif">* 332b mi from PBitBlt, 13b from Misc = 345b mi<br>  Set[</span><span style="font: 10pt serif">bbP1</span><span style="font: 12pt serif">,12];<br>Loca[audGoLoc,10,2];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*10b mi on page of this starting address<br>Set[audPage,17];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*37b mi<br></span><span style="font: 10pt serif"><br>set[IntfaceBase, 200];<br>set[IntfaceCnt, IFE[WithPilotBitBlt, 0, 10, 5]];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* In Interface.0mc:<br>loca[lneTask1stLoc, pgLisp0, 200];<br>loca[lneTaskSkpLoc, pgLisp0, 201];<br>loca[lStartNovaLoc, pgLisp0, 202];<br>loca[lStartNovaLoc1, pgLisp0, 203];<br><br>:IF[WithPilotBitBlt];<br>loca[lTrapLoc, pgLisp0, 204];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* only when WithPilotBitBlt<br>:ELSE;<br>loca[lBitBltDoneLoc, pgLisp0, 204];<br>loca[lBitBltDoneLoc1, pgLisp0, 205];<br>loca[lBBBitBltLoc, pgLisp0, 206];<br>loca[lBBBitBltLoc1, pgLisp0, 207];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* In Lisp0.0mc<br>loca[BBMDoneLoc, pgLisp0, 210];<br>loca[BBMesaIntLoc, pgLisp0, 211];<br>:ENDIF;<br><br>loca[LispInstLoc, pgLisp0, 212];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* In LFaults.0mc<br>loca[MapFaultPuntLoc, pgLisp0, 213];<br><br><br>set[pgLisp0Base, lshift[pgLisp0, 10]];<br><br>set[lspmbxDisp, ADD[pgLisp0Base, 100]];<br><br>Loca[FaultDisp, pgLisp0, 300];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Dispatch in page fault<br>Loca[ArithDisp, pgArith, 200];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Dispatch for 2-arg arith ops<br>Loca[MiscDisp, pgMisc, 240];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Dispatch for misc opcodes<br><br><br>:END[Lispdefs];<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
