<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>JCAI>BASICS>LISP0MC.DM!1>Bindings.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Bindings.0mc...June 9, 1982  2:51 PM, van Melle];********* BIND   byte 1 (lspLN) = n,v   Byte2 (lspL2) = N*   n = number of PVARS bound to NIL*   v = number of PVARS bound to values popped off stack*   N =&gt; last PVAR is stored into slot NlspBind:	loadpage[pgBind], opcode[021];	gotop[.+1];onpage[pgBind];	T &larr; NextData[IBuf];	lspLN &larr; T;	T &larr; NextData[IBuf];	lspL2 &larr; T;					* LN = 0,0,n,v	T &larr; (ldf[lspLN, 10, 4]) - 1;	* T &larr; n-1	lspL4 &larr; T;	T &larr; (ldf[lspLN, 14, 4]) - 1;	* T &larr; v-1	lspL3 &larr; T;	T &larr; lspL2 &larr; lsh[lspL2, 1], task;	* N*2	lspL0 &larr; 0C;			* T0&larr;NIL	lspL1 &larr; 0C, call[.+1];		* T0&larr;NILlspBNil:	lspL4 &larr; (lspL4) - 1, goto[lspBNilFin, R&lt;0];	PStore2[lspEp, lspL0];		* Push NIL	T &larr; (Form-2[AllOnes]) + T, return;	* T &larr; T-2, return to lspBNillspBNilFin:				* Odd placementlspBVal:			*** this loop may need tasking	lspL3 &larr; (lspL3) - 1, goto[lspBValFin, R&lt;0];	PStore2[lspEp, Stack];		* Pop Stack into next pvar	StkState &larr; rcy[StkState, 1], goto[lspBVal1, Reven];	loadpage[pgHStack];	callp[HStkUndFlw];		* Assumes T undisturbed!!!lspBVal1:	T &larr; (Form-2[AllOnes]) + T, goto[lspBVal];	* T &larr; T-2lspBValFin:	T &larr; (ldf[lspLN, 10, 4]);	T &larr; (ldf[lspLN, 14, 4]) + T, task;	* T &larr; n+v	Stack&amp;+1 &larr; (zero) - T - 1;		* push -(n+v) -1	T &larr; lspL2;	Stack&amp;+1 &larr; T, goto[PushLBL];		* push 2*N******* UNBIND, DUNBINDlspDUnBind:					* unbind, discard value	loadpage[pgBind], opcode[023];	lspL0 &larr; (unboundPvar), gotop[lspUnbPop0];lspUnBind:					* unbind, preserve TOS	loadpage[pgBind],opcode[022];	T &larr; Stack&amp;-1;onpage[pgBind];	lspL1 &larr; T;				* Pop TOS into L0,1	T &larr; Stack&amp;-1;	lspL0 &larr; T, goto[lspUnbPop];lspUnbPop:					* Pop check	StkState &larr; rcy[StkState, 1], goto[lspUnbPop0, R Even];	loadpage[pgHStack];	callp[HStkUndFlw];lspUnbPop0:	MNBR &larr; Stack&amp;-1;			* offset of last var to unbind	T &larr; (Stack&amp;-1) + 1, goto[lspUnbPop, R&gt;=0];			* T &larr; #vars to unbind; if non-negative, this was not a			* binding mark, so keep popping until it is	lspL2 &larr; T;	T &larr; MNBR;	lspLN &larr; (unboundPvar), call[.+1];lspUnbPop2:	lspL2 &larr; (lspL2) + 1, goto[lspUnbPop3, R&gt;=0];	PStore1[lspEp, lspLN];	T &larr; (Form-2[AllOnes]) + T, return;      * T &larr; T-2, return to lspUnbPop2lspUnbPop3:	T &larr; lspL0, skip[R&gt;=0];	  goto[PopLBL];	Stack&amp;+1 &larr; T;				* Push L0,1 back on	T &larr; lspL1;	Stack&amp;+1 &larr; T, goto[nxiLBL];		* no overflow possible, since we popped at least one thing:END[Bindings];</pre>
  </body>
</html>
