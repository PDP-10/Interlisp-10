<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>JCAI>sources>BYTECOMPILER!1</title>
  </head>
  <body>
    <pre>
(FILECREATED "18-Jun-85 18:12:18" {ERIS}&lt;LISPCORE&gt;SOURCES&gt;BYTECOMPILER.;31 173358       changes to:  (FNS COMP.AREF)      previous date: "29-Apr-85 19:28:14" {ERIS}&lt;LISPCORE&gt;SOURCES&gt;BYTECOMPILER.;30)(* Copyright (c) 1981, 1982, 1983, 1984, 1985 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT BYTECOMPILERCOMS)(RPAQQ BYTECOMPILERCOMS [(* THE BYTE LISP COMPILER)	(COMS (FNS BYTEBLOCKCOMPILE2 BYTECOMPILE2 COMP.ATTEMPT.COMPILE COMP.RETFROM.POINT COMPERROR 		   COMPPRINT COMPERRM)	      (FNS COMP.TOPLEVEL.COMPILE COMP.BINDLIST COMP.CHECK.VAR COMP.BIND.VARS COMP.UNBIND.VARS)	      (FNS COMP.VALN COMP.PROGN COMP.PROGLST COMP.EXP1 COMP.EXPR COMP.TRYUSERFN COMP.USERFN 		   COMP.CONST COMP.CALL COMP.VAR COMP.VAL1 COMP.PROG1 COMP.EFFECT COMP.VAL COMP.MACRO)	      (FNS COMP.VARTYPE COMP.LOOKUPVAR COMP.LOOKUPCONST)	      (FNS COMP.ST COMP.STFN COMP.STCONST COMP.STVAR COMP.STPOP COMP.DELFN COMP.STRETURN 		   COMP.STTAG COMP.STJUMP COMP.STSETQ COMP.STCOPY COMP.DELPUSH COMP.DELPOP 		   COMP.STBIND COMP.STUNBIND)	      (FNS COMP.ARGTYPE COMP.CLEANEXPP COMP.CLEANFNP COMP.CLEANFNOP COMP.GLOBALVARP 		   COMP.LINKCALLP COMP.ANONP)	      (FNS COMP.CPI COMP.CPI1 COMP.PICOUNT)	      (PROP BYTEMACRO EVQ)	      (FNS COMP.EVQ)	      (PROP BYTEMACRO AND OR)	      (FNS COMP.BOOL)	      (FNS COMP.APPLYFNP)	      (PROP BYTEMACRO AC ASSEMBLE ASSEM FLOC)	      (FNS COMP.AC COMP.PUNT)	      (PROP BYTEMACRO FUNCTION)	      (FNS COMP.FUNCTION COMP.LAM1 COMP.GENFN)	      (INITVARS (COMP.GENFN.NUM 0)			(COMP.GENFN.BUF (ALLOCSTRING 100)))	      (GLOBALVARS COMP.GENFN.NUM COMP.GENFN.BUF COMP.UNBOXED.TAG)	      (PROP BYTEMACRO COND SELECTQ)	      (FNS COMP.COND COMP.SELECTQ)	      (PROP BYTEMACRO PROGN PROG1)	      (PROP BYTEMACRO QUOTE *)	      (FNS COMP.QUOTE COMP.COMMENT)	      (PROP BYTEMACRO DECLARE)	      (FNS COMP.DECLARE COMP.DECLARE1)	      (PROP (BYTEMACRO CROPS)		    * MCROPS)	      (FNS COMP.CARCDR COMP.STCROP)	      (PROP BYTEMACRO NOT NULL)	      (FNS COMP.NOT)	      (PROP BYTEMACRO SETQ SETN)	      (FNS COMP.SETQ COMP.SETN)	      (FNS COMP.LAMBDA)	      (PROP BYTEMACRO PROG GO RETURN)	      (FNS COMP.PROG COMP.GO COMP.RETURN)	      (VARS COMP.UNBOXED.TAG NUMBERFNS (GLOBALVARFLG T)		    (NEWOPTFLG)		    (COMPVERSION (DATE)))	      (MACROS IPLUS ITIMES LOGOR LOGXOR LOGAND IDIFFERENCE IQUOTIENT IREMAINDER IMINUS LSH 		      LLSH RSH LRSH FIX PLUS DIFFERENCE TIMES QUOTIENT FPLUS FDIFFERENCE FTIMES 		      FQUOTIENT FABS FGREATERP FLESSP FREMAINDER)	      (FNS COMP.NUMERIC COMP.NUMBERCALL COMP.FIX COMP.STFIX COMP.DELFIX)	      (PROP BYTEMACRO EQ EQUAL EQP)	      (FNS COMP.EQ)	      (PROP BYTEMACRO .TEST.)	      (FNS COMP.NUMBERTEST)	      (PROP BYTEMACRO * MAPFNS)	      (PROP BYTEMACRO .DOCOLLECT. .DOJOIN.)	      (FNS COMP.MAP)	      (PROP BYTEMACRO LISPXWATCH)	      (PROP BYTEMACRO FETCHFIELD REPLACEFIELD FFETCHFIELD FREPLACEFIELD REPLACEFIELDVAL 		    FREPLACEFIELDVAL)	      (PROP BYTEMACRO GETPROP)	      (PROP BYTEMACRO BLKAPPLY BLKAPPLY*)	      (PROP BYTEMACRO ADD1VAR SUB1VAR KWOTE FRPLNODE RPLNODE LISTGET1 FRPLNODE2)	      (PROP BYTEMACRO JSYS)	      (PROP BYTEMACRO EQMEMB MKLIST)	      (COMS (* Pass 1 listing)		    (FNS COMP.MLLIST COMP.MLL COMP.MLLVAR COMP.MLLFN)		    (VARS COPS)		    (IFPROP MLSYM * (PROGN COPS)))	      (COMS (* ARJ - JUMP LENGTH RESOLVER)		    (FNS OPT.RESOLVEJUMPS OPT.JLENPASS OPT.JFIXPASS OPT.JSIZE))	      (COMS (* utilities used by all files)		    (FNS OPT.CALLP OPT.JUMPCHECK OPT.DREV OPT.CHLEV OPT.CHECKTAG OPT.NOTJUMP 			 OPT.INITHASH OPT.COMPINIT))	      (P (MOVD? (QUOTE NILL)			(QUOTE REFRAME))		 (AND (GETD (QUOTE OPT.COMPINIT))		      (OPT.COMPINIT)))	      (PROP BYTEMACRO LOADTIMECONSTANT)	      (PROP BYTEMACRO FRPTQ)	      (FNS OPT.CFRPTQ)	      (DECLARE: EVAL@COMPILE DONTCOPY			(SPECVARS AC ALAMS1 ALLVARS ARGS ARGVARS BLKDEFS BLKFLG CODE COMFN COMFNS 				  COMTYPE CONSTS EMFLAG EXP FRAME FREELST FREEVARS LAPFLG LBCNT LEVEL 				  LOCALVARS LOCALVARS LSTFIL MACEXP NLAMS1 PIFN COMPILE.CONTEXT 				  PROGCONTEXT RETURNLABEL SPECVARS SPECVARS SUBFNFREEVARS TAGS TOPFN 				  TOPFRAME TOPLAB VARS INTERNALBLKFNS)			(SPECVARS PLVLFILEFLG))	      (PROP BYTEMACRO IMAX2 IMIN2)	      (PROP BOGUSMACRO AREF ASET)	      (PROP BOX FLOAT)	      (FNS COMP.AREF COMP.ASET COMP.BOX COMP.LOOKFORDECLARE COMP.DECLARETYPE COMP.FLOATBOX 		   COMP.FLOATUNBOX COMP.PREDP COMP.UBFLOAT2 COMP.UNBOX))	(ADDVARS (COMPILETYPELST))	(COMS (* POST OPTIMIZATION)	      (FNS OPT.POSTOPT OPT.SETUPOPT OPT.SCANOPT OPT.XVARSCAN OPT.XVARSCAN1 OPT.JUMPOPT 		   OPT.JUMPTHRU OPT.LBMERGE OPT.PRDEL OPT.UBDEL OPT.LBDEL OPT.LABELNTHPR OPT.JUMPREV 		   OPT.COMMONBACK OPT.DELTAGREF OPT.FINDEND OPT.RETOPT OPT.RETFIND OPT.RETPOP 		   OPT.RETOPT1 OPT.RETTEST OPT.RETMERGE OPT.CODELEV OPT.CODEFRAME OPT.DEFREFS 		   OPT.SETDEFREFS)	      (FNS OPT.FRAMEOPT OPT.FRAMEMERGE OPT.NONILVAR OPT.MERGEFRAMEP OPT.FRAMELOCAL 		   OPT.CLEANFRAME OPT.FRAMEDEL OPT.FRAMEVAR OPT.DELETEFRAMECHECK OPT.ONLYMEMB)	      (VARS MERGEFRAMETYPES (OPTIMIZATIONSOFF))	      (FNS OPT.SKIPPUSH OPT.DELCODE OPT.PRATTACH OPT.JUMPCOPYTEST OPT.EQOP OPT.EQVALUE 		   OPT.DELCOPYFN)	      (FNS OPT.DEADSETQP OPT.DS1)	      (DECLARE: EVAL@COMPILE DONTCOPY (SPECVARS CODE LEVEL)			(SPECVARS LABELS PASS ANY CODE FRAME FRAMES)			(GLOBALVARS MERGEFRAMEMAX MERGEFRAMEFLG MERGEFRAMETYPES)			(SPECVARS VARS ANY FRAME)			(SPECVARS ICNT TAG)			(SPECVARS FRAME LEVEL ANY)			(SPECVARS FRAME LEVEL ANY)			(SPECVARS TAGS ANY)))	(COMS (* CONSISTENCY CHECKS)	      (DECLARE: EVAL@COMPILE DONTCOPY (MACROS OPT.CCHECK)			(VARS (COMPILECOMPILERCHECKS NIL)))	      (FNS OPT.COMPILERERROR OPT.OPTCHECK OPT.CCHECK))	(GLOBALVARS ALAMS BLKLIBRARY BYTE.EXT BYTEASSEMFN BYTECOMPFLG COMPILERMACROPROPS CIA 		    CLEANFNLIST COMP.SCRATCH COMPILETYPELST COMPILEUSERFN COMPSTATLST COMPSTATS 		    CONDITIONALS CONST.FNS CONSTOPS DONOTHING FILERDTBL FNA FORSHALLOW FRA GLOBALVARS 		    HEADERBYTES HOKEYDEFPROP LAMBDANOBIND LAMS LBA LEVELARRAY LINKEDFNS LINKFNS 		    LOADTIMECONSTANT MAXBNILS MAXBVALS MCONSTOPS MERGEFRAMEFLG MERGEFRAMEMAX 		    MERGEFRAMETYPES MOPARRAY MOPCODES NLAMA NLAML NODARR NOLINKFNS NOSTATSFLG 		    NUMBERFNS OPCOPY OPNIL OPPOP OPRETURN PRA SELECTQFMEMB SELECTVARTYPES STATAR 		    STATMAX STATN SYSSPECVARS UNIQUE#ARRAY VCA VCONDITIONALS VREFFRA COUTFILE XVARFLG 		    MERGEFRAMEFLG OPTIMIZATIONSOFF NOFREEVARSFNS EQCONSTFN NEWOPTFLG)	(DECLARE: DONTCOPY (* for compiling compiler)		  EVAL@COMPILE		  (RECORDS CODELST)		  (PROP MACRO OASSOC)		  (RECORDS OP JUMP TAG VAR)		  (RECORDS FRAME COMINFO COMP JD))	(MACROS THETYPE)	(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)									      (NLAML OPT.INITHASH)									      (LAMA])(* THE BYTE LISP COMPILER)(DEFINEQ(BYTEBLOCKCOMPILE2  (LAMBDA (BLKNAME BLKDEFS ENTRIES)                          (* JonL "17-Dec-83 03:41")    (COND      ((EQ BYTECOMPFLG (QUOTE NOBLOCK))                      (* use PDP-10 compiler for blocks)	(RESETVARS (BYTECOMPFLG)	           (RETURN (BLOCKCOMPILE2 BLKNAME BLKDEFS ENTRIES))))      (T (PROG ((BLKFLG T)		(INTERNALBLKFNS (AND (NEQ BYTECOMPFLG (QUOTE RETRY))				     (for X in BLKDEFS					when (NOT (OR (FMEMB (CAR X)							     ENTRIES)						      (EQ (CAR X)							  BLKNAME)						      (FMEMB (CAR X)							     RETFNS)						      (AND (LISTP NOLINKFNS)							   (FMEMB (CAR X)								  NOLINKFNS))						      (FMEMB (CAR X)							     BLKAPPLYFNS)))					collect (CONS (CAR X)						      (PACK* (QUOTE \)							     BLKNAME							     (QUOTE /)							     (CAR X)))))))                                                             (* this is a dummy block compiler)	       (SETQ COMP.GENFN.NUM 0)	       (RETURN (MAPCONC BLKDEFS (FUNCTION (LAMBDA (X)				    (PROG1 (COMP.ATTEMPT.COMPILE (OR (CDR (FASSOC (CAR X)										  INTERNALBLKFNS))								     (CAR X))								 (CADDR X)								 (CAR X))          (* The FRPLACA allows the function definitions to be reclaimed. This is written to parallel BLOCKCOMPILE2 which 	  needs the list of BLKDEFS for something. -	  rrb)					   (FRPLACA (CDDR X)						    (LIST (CAR (CADDR X))							  (CADR (CADDR X))))))))))))))(BYTECOMPILE2  (LAMBDA (FN DEF)                                           (* JonL "17-Dec-83 03:41")    (PROG ((BLKFLG NIL))          (SETQ COMP.GENFN.NUM 0)          (COMP.ATTEMPT.COMPILE FN DEF)          (RETURN FN))))(COMP.ATTEMPT.COMPILE  [LAMBDA (TOPFN DEF RECNAME)                                (* lmm "13-Jul-84 21:18")    (PROG ((EMFLAG TOPFN)	   COMFNS FLG SUBFNFREEVARS)                         (* compile attempt)          (SETQ FLG (COMP.RETFROM.POINT TOPFN DEF RECNAME))          [COND	    ((NULL EMFLAG)	      (LISPXPRIN1 (QUOTE "-----")			  T)	      (COND		((NEQ COUTFILE T)		  (LISPXPRIN1 (QUOTE "-----")			      COUTFILE]          (COND	    (FLG                                             (* compile succeed)		 (RETURN COMFNS))	    ((AND (GETD (QUOTE COMPILE2))		  (NEQ BYTECOMPFLG T))                       (* retry with COMPILE2)	      (LISPXPRINT (CONS TOPFN (QUOTE (-- retrying with PDP-10 compiler)))			  T T)	      [COND		(BLKFLG (OR (EQ SPECVARS T)			    (EVAL (CONS (QUOTE SPECVARS)					LOCALFREEVARS]	      (RETURN (COMPILE2 TOPFN DEF)))	    (T (LISPXPRINT [LIST (CONS TOPFN (QUOTE (not compiled]			   T T)	       (RETURN])(COMP.RETFROM.POINT  [LAMBDA (COMFN DEF RECNAME)                                (* lmm "13-MAR-81 09:29")    (PROG ((LBCNT 0))                                        (* This is the RETFROM point in case of an error while 							     compiling COMFN or any of its generated subfunctions.)          (fetch (COMP CLEAR) of T)          (* CLEAR is an accessfn which clears all of the hash tables used by any HASHLINK field in the compiler;	  done this way so that the program need not know which hash tables are used)          (RETURN (PROG1 (COMP.TOPLEVEL.COMPILE COMFN DEF RECNAME)			 (fetch (COMP CLEAR) of T])(COMPERROR  [LAMBDA (X)                                                (* jds " 1-Feb-84 15:35")                                                             (* Terminal-error handler: Aborts the compilation of 							     this function.)    (AND X (COMPERRM X))                                     (* After issuing the proper message, of course.)    (RETFROM (QUOTE COMP.RETFROM.POINT)	     NIL])(COMPPRINT  [LAMBDA (X)                                                (* wt: " 9-JUL-79 21:09")                                                             (* A separate function so it can be broken or advised)    (PRINT X COUTFILE T])(COMPERRM  [LAMBDA (X FL)                                             (* jds " 1-Feb-84 15:34")                                                             (* Emit an error message for the compiler)    (AND (NULL FL)	 (SETQ FL COUTFILE))                                 (* If he specified no file, use the compiler-message 							     file.)    (COND      (EMFLAG (LISPXTAB 0 0 FL)	      (LISPXPRIN1 (QUOTE "-----In ")			  FL)	      (LISPXPRIN2 EMFLAG FL T)	      (LISPXPRINT (QUOTE :)			  FL)))    [COND      (X (LISPXPRIN1 (QUOTE *****)		     FL T)	 (PROG ((PLVLFILEFLG T))	       (RESETFORM (PRINTLEVEL 2 20)			  (LISPXPRINT X FL T]    (COND      ((NEQ FL T)                                            (* so message gets printed in both places)                                                             (* i.e., force the message to go to the terminal as 							     well.)	(COMPERRM X T)))    (SETQ EMFLAG NIL]))(DEFINEQ(COMP.TOPLEVEL.COMPILE  [LAMBDA (COMFN DEF RECNAME)                                (* lmm "13-Jul-84 21:18")    (PROG (ALAMS1 NLAMS1 CONSTS ALLVARS ALLDECLS ARGVARS ARGS COMTYPE CODE FREEVARS CI (LEVEL 0)		  FRAME PIFN TOPLAB (LOCALVARS LOCALVARS)		  (SPECVARS SPECVARS)		  TOPFRAME MACEXP AC FRELST (COMPILE.DUNBIND.POP.MERGE.FLG T))      RETRY          [OR [AND (LISTP DEF)		   (LISTP (CDR DEF))		   (SETQ COMTYPE (COND		       [(OR (LISTP (SETQ ARGS (CADR DEF)))			    (NULL ARGS))			 (SELECTQ (CAR DEF)				  [NLAMBDA 1]				  [LAMBDA 0]				  (COND				    ((AND COMPILEUSERFN (SETQ DEF (APPLY* COMPILEUSERFN NIL DEF)))				      (GO RETRY]		       (T (COND			    ((AND LAMBDANOBIND (EQ ARGS (QUOTE NOBIND)))			      (SETQ ARGS NIL)			      2)			    (T (SETQ ARGS (LIST ARGS))			       (SELECTQ (CAR DEF)					[LAMBDA 2]					[NLAMBDA 3]					(COND					  ((AND COMPILEUSERFN (SETQ DEF (APPLY* COMPILEUSERFN NIL DEF)						  ))					    (GO RETRY]	      (COMPERROR (CONS COMFN (QUOTE (not compilable]          (SETQ PIFN (COND	      ((EQ PIFN T)                                   (* compile as call to self)		0)	      ((GETPROP COMFN OPCODEPROP)		0)	      ((EQ 0 COMTYPE)		(OR RECNAME COMFN))	      (T 0)))          (SETQ FRAME (SETQ TOPFRAME (create FRAME					     VARS &larr;(SETQ ARGVARS (SETQ ALLVARS (COMP.BINDLIST ARGS)))					     NNILS &larr; 0)))          (COMP.STTAG (SETQ TOPLAB (create TAG)))          (COMP.VALN (CDDR DEF)		     (QUOTE RETURN))          (COMP.UNBIND.VARS TOPFRAME T)          (SETQ CI (create COMINFO			   COMTYPE &larr; COMTYPE			   CODE &larr;(OPT.POSTOPT CODE)			   TOPFRAME &larr; TOPFRAME			   ARGS &larr; ARGVARS))          [COMPPRINT (CONS COMFN (CONS (CADR DEF)				       (NCONC (AND (SETQ FREELST (for X in FREEVARS								    when (EQ (fetch OPNAME										of X)									     (QUOTE FVAR))								    collect (fetch OPARG									       of X)))						   (LIST (CONS (QUOTE uses:)							       FREELST)))					      [COND						([SETQ ALAMS1 (SUBSET ALAMS1								      (FUNCTION (LAMBDA (X)									  (NOT (GETPROP X OPCODEPROP]						  (LIST (CONS (QUOTE calls:)							      ALAMS1]					      (COND						(NLAMS1 (LIST (CONS (QUOTE nlams:)								    NLAMS1]          (SELECTQ LAPFLG		   ((1 T)		     (RESETFORM (OUTPUT LSTFIL)				(COMP.MLLIST COMFN CI)))		   NIL)                                      (* ASSERT: (CALLS: MASSEM))          (APPLY* BYTEASSEMFN COMFN CI)          [COND	    ((NEQ COMFN TOPFN)                               (* generated subfunction)	      (SETQ SUBFNFREEVARS (APPEND SUBFNFREEVARS FREELST]          (SETQ COMFNS (CONS COMFN COMFNS))          (RETURN COMFN])(COMP.BINDLIST  [LAMBDA (VARS)                                             (* lmm " 1-Jul-84 17:00")    (for VAR in VARS collect (create VAR				     VARNAME &larr;(COMP.CHECK.VAR VAR T)				     COMP.VARTYPE &larr;(COMP.VARTYPE VAR])(COMP.CHECK.VAR  [LAMBDA (X BIND)                                           (* lmm " 6-Apr-84 17:49")    [COND      (BIND [COND	      ((NEQ X (COMP.USERFN X))		(COMPERRM (APPEND (QUOTE (Attempt to bind CONSTANT))				  X]	    (COND	      ((COMP.GLOBALVARP X)		(COMPERRM (CONS X (QUOTE (- is global]    (OR (AND (LITATOM X)	     (NEQ X T)	     X)	(COMPERROR (CONS X (QUOTE (is not a legal variable name])(COMP.BIND.VARS  [LAMBDA (ARGS VALS TYPE DECLARATIONS)                      (* lmm "14-Aug-84 14:50")    (PROG (VLV VLN NVALS NNILS DECL X VAR DECLS VAL)          (for VARNAME in ARGS	     do (SETQ VAR (create VAR				  VARNAME &larr;(COMP.CHECK.VAR VARNAME T)				  COMP.VARTYPE &larr;(COMP.VARTYPE VARNAME)))		(if (SETQ X (CDR (FASSOC VARNAME DECLARATIONS)))		    then                                     (* variable declared to be of a given type)			 (COMP.EXPR (SETQ VAL (pop VALS))				    (AND VAL X))			 (replace (VAR COMP.VARTYPE) of VAR with (QUOTE HVAR))			 (push DECLS (CONS VAR X))			 (push VLV VAR)		  elseif [OR (NULL (SETQ X (pop VALS)))			     (PROGN (COMP.VAL X)				    (COND				      ((EQ (CAR CODE)					   OPNIL)					(NULL                (* prog var value))					(COMP.DELPUSH)					T]		    then (push VLN VAR)		  else (push VLV VAR)))          (for X in VALS do (COMP.EFFECT X))          (SETQ NNILS (LENGTH VLN))          [COND	    ((IGREATERP (SETQ NVALS (LENGTH VLV))			MAXBVALS)	      (COMPERROR (CONS EXP (QUOTE (-- too many variables with values]          (RETURN (create FRAME			  PARENT &larr; FRAME			  NVALS &larr;(LENGTH VLV)			  VARS &larr;(OPT.DREV VLV (OPT.DREV VLN))			  FRAMETYPE &larr; TYPE			  NNILS &larr; NNILS			  DECLS &larr; DECLS])(COMP.UNBIND.VARS  [LAMBDA (F TOPFLG)                                         (* lmm "29-Jun-84 09:34")    (COND      ((NOT (OR TOPFLG (EQ COMPILE.CONTEXT (QUOTE RETURN))		(OPT.JUMPCHECK CODE)))	(OPT.CCHECK (EQ F FRAME))	(COMP.STUNBIND (EQ COMPILE.CONTEXT (QUOTE EFFECT)))	(replace (FRAME PRIMARYRETURN) of (CAR CODE) with T)))    (QUOTE NOVALUE]))(DEFINEQ(COMP.VALN  [LAMBDA (L COMPILE.CONTEXT)                                (* lmm "29-Jun-84 08:25")    (COMP.PROGN L])(COMP.PROGN  [LAMBDA (A)                                                (* lmm "13-Jul-84 21:18")    (COND      ((NULL (CDR A))	(COMP.EXP1 (CAR A)))      (T (PROG [(FLG (AND (NOT OPTIMIZATIONSOFF)			  (EQ COMPILE.CONTEXT (QUOTE RETURN]	   LP  (COMP.EFFECT (CAR A))	       (AND FLG (while (EQ (CAR CODE)				   OPPOP)			   do                                (* delete POP in PROGN)			      (COMP.DELPOP)))	       (COND		 ((OPT.JUMPCHECK CODE))		 ((CDR (SETQ A (CDR A)))		   (GO LP))		 (T (RETURN (COMP.EXP1 (CAR A])(COMP.PROGLST  [LAMBDA (LST N CONTEXT)                                    (* lmm "18-Sep-84 16:28")    (PROG (VAL)          (while (IGREATERP N 0)	     do (SETQ VAL (COMP.EXPR (pop LST)				     (AND (EQ N 1)					  CONTEXT)))		(add N -1))          (while (EQ (CAR (LISTP (CAR LST)))		     (QUOTE *))	     do (pop LST))          [if LST	      then (COMPERRM (BQUOTE (extraneous arguments to , (CAR EXP): ., LST)))		   (SELECTQ CONTEXT			    ((NIL EFFECT)                    (* ok NIL)			      (MAPC LST (FUNCTION COMP.EFFECT)))			    (COMPERRM (QUOTE (not compiled]          (RETURN VAL])(COMP.EXP1  [LAMBDA (E)                                                (* lmm "29-Jun-84 08:25")    (COMP.EXPR E COMPILE.CONTEXT])(COMP.EXPR  [LAMBDA (EXP COMPILE.CONTEXT)                              (* lmm "13-Jul-84 22:23")    (PROG (M V)          [COND	    ((NULL FRAME)	      (COND		[(OPT.JUMPCHECK CODE)		  (RETURN (COND			    ((COMP.PREDP COMPILE.CONTEXT)			      (QUOTE PREDVALUE))			    (T (QUOTE NOVALUE]		(T (OPT.COMPILERERROR]      TOP [SETQ V (COND	      [(NLISTP EXP)		(COND		  ((LITATOM EXP)		    (SELECTQ EXP			     ((T NIL)			       (COMP.CONST EXP))			     (COMP.VAR EXP)))		  ([OR (NUMBERP EXP)		       (PROGN                                (* non-quoted string)			      (OR [NULL (SETQ M (CDR (FASSOC (TYPENAME EXP)							     COMPILETYPELST]				  (EQ EXP (SETQ EXP (APPLY* M EXP]		    (COMP.CONST EXP))		  (T (GO TOP]	      [[NOT (LITATOM (SETQ M (CAR EXP]		(SELECTQ (CAR (LISTP M))			 ([LAMBDA NLAMBDA OPENLAMBDA]			   (COMP.LAMBDA M (CDR EXP)))			 (OPCODES (COMP.STFN (CAR EXP)					     (for X in (CDR EXP) sum (COMP.VAL X)								     1)))			 (COND			   ((SETQ M (COMP.TRYUSERFN EXP))			     (SETQ EXP M)			     (GO TOP))			   (T (COMPERROR (CONS M (QUOTE (- non-atomic CAR of form]	      ((AND (SETQ V (GETMACROPROP M COMPILERMACROPROPS))		    (NEQ V T))		(COMP.MACRO EXP V))	      ((AND (EQ COMPILE.CONTEXT (QUOTE RETURN))		    (EQ M PIFN))		(COMP.CPI M (CDR EXP)))	      ((SETQ V (COMP.ARGTYPE M))		(COMP.CALL M (CDR EXP)			   V))	      ((SETQ V (COMP.TRYUSERFN EXP))		(SETQ EXP V)		(GO TOP))	      (T (COMP.CALL M (CDR EXP]          (RETURN (SELECTQ COMPILE.CONTEXT			   (NIL NIL)			   (EFFECT (OR (EQ V (QUOTE NOVALUE))				       (COMP.STPOP))				   (QUOTE NOVALUE))			   (RETURN (OR (OPT.JUMPCHECK CODE)				       (COMP.STRETURN))				   (QUOTE NOVALUE))			   (COND			     ((COMP.PREDP COMPILE.CONTEXT)			       (COND				 ((NEQ V (QUOTE PREDVALUE))                                                             (* in this case, COMPILE.CONTEXT is a jump instruction)				   (COMP.STJUMP COMPILE.CONTEXT)))			       (QUOTE PREDVALUE))			     ((EQ (CAR (LISTP COMPILE.CONTEXT))				  (QUOTE TYPE))			       NIL)			     ((EQ (CAR (LISTP COMPILE.CONTEXT))				  (QUOTE UNBOXED))			       (OR (EQ V (QUOTE UNBOXED))				   (COMP.UNBOX (CDR COMPILE.CONTEXT)))			       (QUOTE UNBOXED])(COMP.TRYUSERFN  [LAMBDA (EXP M)    (AND COMPILEUSERFN (COND	   ((EQ (SETQ M (COMP.USERFN EXP))		(QUOTE INSTRUCTIONS))	     [COMPERRM (CONS EXP (QUOTE (COMPILEUSERFN returned INSTRUCTIONS]	     NIL)	   (T M])(COMP.USERFN  [LAMBDA (X)                                                (* lmm " 1-Jul-84 16:49")    (COND      ((LITATOM X)	(OR (AND COMPVARMACROHASH (GETHASH X COMPVARMACROHASH))	    X))      (T (PROG [(FN TOPFN)		(OTHERVARS (for X in ALLVARS collect (fetch OPARG of X]	       (DECLARE (SPECVARS FN OTHERVARS))             (* uses FN DEF ARGS OTHERVARS)	       (RETURN (APPLY* COMPILEUSERFN (CDR X)			       X])(COMP.CONST  [LAMBDA (X)                                                (* lmm "13-Jul-84 21:18")    (COND      ((AND (NOT OPTIMIZATIONSOFF)	    (EQ COMPILE.CONTEXT (QUOTE EFFECT)))             (* CONST in (EQ COMPILE.CONTEXT 							     (QUOTE EFFECT)))	(QUOTE NOVALUE))      ((AND (NOT OPTIMIZATIONSOFF)	    (COMP.PREDP COMPILE.CONTEXT))	[AND (SELECTQ (fetch OPNAME of COMPILE.CONTEXT)		      (TJUMP X)		      (NTJUMP (COND				(X (COMP.STCONST X)				   T)))		      (FJUMP (NOT X))		      (NFJUMP (COND				((NOT X)				  (COMP.STCONST X)				  T)))		      (SHOULDNT))	     (COMP.STJUMP (QUOTE JUMP)			  (CAR (fetch OPARG of COMPILE.CONTEXT))			  (CDR (fetch OPARG of COMPILE.CONTEXT]	(QUOTE PREDVALUE))      (T (COMP.STCONST X])(COMP.CALL  [LAMBDA (F A TYP)                                          (* lmm "13-Jul-84 21:18")    (PROG ((N 0))          (OR (fetch EXTCALL of FRAME)	      (COMP.CLEANFNOP F (QUOTE FREEVARS))	      (replace EXTCALL of FRAME with F))          (SELECTQ TYP		   (3                                        (* call nlambda by applying with entire arglist as first							     arg)		      (pushnew NLAMS1 F)		      (COMP.STCONST A)		      (RETURN (COMP.STFN F 1)))		   (1                                        (* call NLAMBDA spread merely by not compiling 							     arguments)		      (pushnew NLAMS1 F))		   (NIL                                      (* unknown argtype, assume lambda, but warn user)			(pushnew ALAMS1 F))		   NIL)      LP  (COND	    ((LISTP A)	      (SELECTQ TYP		       (1 (COMP.STCONST (CAR A)))		       (COMP.VAL (CAR A)))	      (SETQ N (ADD1 N))	      (SETQ A (CDR A))	      (GO LP))	    [A (COMPERROR (CONS A (QUOTE (- unusual CDR arg list]	    ((OR (NULL TYP)		 (EQ TYP 2))                                 (* for LAMBDA* or unknown types, don't remove extra 							     NIL's)	      (GO ST)))      NON (COND	    ((AND (IGREATERP N 1)		  (EQ (CAR CODE)		      OPNIL))                                (* delete NIL before fn call)	      (COMP.DELPUSH)	      (SUB1VAR N)	      (GO NON)))      ST  (RETURN (COMP.STFN F N])(COMP.VAR  [LAMBDA (VAR)                                              (* lmm "24-Jan-85 18:40")    (COND      ((EQ COMPILE.CONTEXT (QUOTE EFFECT))                   (* VAR in EFFECT)	(QUOTE NOVALUE))      (T (SETQ VAR (COMP.LOOKUPVAR VAR T))	 (COMP.STVAR VAR)	 (LET [(DECL (CDR (ASSOC VAR ALLDECLS]	   (if (EQ (CAR (LISTP DECL))		   (QUOTE UNBOXED))	       then (COMP.BOX (CDR DECL])(COMP.VAL1  [LAMBDA (L COMPILE.CONTEXT)                                (* lmm "29-Jun-84 08:25")    (COMP.PROG1 L])(COMP.PROG1  [LAMBDA (A)                                                (* lmm "29-Jun-84 08:25")    (COND      ((NULL (CDR A))	(COMP.EXP1 (CAR A)))      (T (PROG1 (COMP.EXPR (CAR A)			   (COND			     ((EQ COMPILE.CONTEXT (QUOTE EFFECT))			       COMPILE.CONTEXT)))		(MAPC (CDR A)		      (FUNCTION COMP.EFFECT])(COMP.EFFECT  [LAMBDA (E)                                                (* lmm "13-Jul-84 21:18")    (PROG ((LV LEVEL))          (COND	    ((OPT.JUMPCHECK CODE)                            (* code for effect eliminated after JUMP or RETURN)	      (RETURN))	    (T (OPT.CCHECK LV)))          (RETURN (PROG1 (COMP.EXPR E (QUOTE EFFECT))			 (OPT.CCHECK (OR AC (EQ LEVEL LV)					 (OPT.JUMPCHECK CODE])(COMP.VAL  [LAMBDA (X)                                                (* lmm "13-Jul-84 21:18")    (PROG ((LV LEVEL))          (COND	    ((OPT.JUMPCHECK CODE)                            (* code for value eliminated after JUMP or RETURN)	      (RETURN)))          (RETURN (PROG1 (COMP.EXPR X)			 (OPT.CCHECK (OR (EQ (ADD1 LV)					     LEVEL)					 AC					 (OPT.JUMPCHECK CODE])(COMP.MACRO(LAMBDA (EXP MAC) (* lmm "29-Mar-85 22:45") (COND ((NLISTP MAC) (SELECTQ MAC (T (* MACRO is T) (COMP.CALL (CAR EXP) (CDR EXP) (COMP.ARGTYPE (CAR EXP)))) (COMP.PUNT (COMP.PUNT)) (BLKAPPLY* MAC (CDR EXP)))) (T (SELECTQ (CAR MAC) (APPLY (APPLY (CADR MAC) (CDR EXP))) (APPLY* (APPLY (CADR MAC) (CONS (CDR EXP) (CDDR MAC)))) (OPENLAMBDA (COMP.LAMBDA MAC (CDR EXP))) (LET ((EXPANSION (MACROEXPANSION EXP MAC T COMPILE.CONTEXT))) (if (EQ EXPANSION EXP) then (* can't expand, e.g. returns IGNOREMACRO) (COMP.CALL (CAR EXP) (CDR EXP) (COMP.ARGTYPE (CAR EXP))) else (COMP.EXP1 EXPANSION)))))))))(DEFINEQ(COMP.VARTYPE  [LAMBDA (VAR)                                              (* lmm "13-MAR-81 09:36")    (OPT.CCHECK (AND VAR (LITATOM VAR)))    (COND      ((COMP.ANONP VAR)	(QUOTE HVAR))      (T (QUOTE AVAR])(COMP.LOOKUPVAR  [LAMBDA (V FORVALUE)                                       (* jds " 1-Feb-84 15:08")    (PROG (X)          (COND	    ((SETQ X (find VAR in ALLVARS suchthat (EQ (fetch VARNAME of VAR)						       V)))	      (RETURN X)))          (COND	    ((SETQ X (find VAR in FREEVARS suchthat (EQ (fetch VARNAME of VAR)							V)))	      (RETURN X)))          [COND	    ((NEQ V (SETQ X (COMP.USERFN V)))	      (COND		(FORVALUE (RETAPPLY (QUOTE COMP.VAR)				    (FUNCTION COMP.VAL)				    (LIST X)				    T))		(T (COMPERRM (CONS V " - is compile time constant, yet is bound or set."]          (SETQ FREEVARS (CONS (SETQ X (create VAR					       COMP.VARTYPE &larr;(COND						 ((AND GLOBALVARFLG (COMP.GLOBALVARP V))						   (QUOTE GVAR))						 (T (QUOTE FVAR)))					       VARNAME &larr;(COMP.CHECK.VAR V)))			       FREEVARS))          (RETURN X])(COMP.LOOKUPCONST  [LAMBDA (X)                                                (* lmm "24-JUN-78 22:56")    (COND      ((NULL X)	OPNIL)      (T (OR [CAR (SOME CONSTS (FUNCTION (LAMBDA (Y)			    (EQ X (fetch OPARG of Y]	     (PROG1 (SETQ X (create OP				    OPNAME &larr;(QUOTE CONST)				    OPARG &larr; X))		    (SETQ CONSTS (NCONC1 CONSTS X]))(DEFINEQ(COMP.ST  [LAMBDA (X DL)                                             (* lmm "13-Jul-84 21:18")    (OPT.CCHECK DL)    (COND      [(OR LEVEL (EQ DL T))	(SETQ CODE (CONS X CODE))	(SETQ LEVEL (COND	    ((FIXP DL)	      (IPLUS LEVEL DL]      (T (OPT.CCHECK (OPT.JUMPCHECK CODE))                   (* didn't store code after JUMP or RETURN)	 NIL])(COMP.STFN  [LAMBDA (FN N)                                             (* lmm "16-APR-82 00:14")    (COMP.ST (create OP		     OPNAME &larr;(QUOTE FN)		     OPARG &larr;(CONS N (OR (AND BLKFLG (LITATOM FN)					     (CDR (FASSOC FN INTERNALBLKFNS)))					FN)))	     (IDIFFERENCE 1 N])(COMP.STCONST  [LAMBDA (X)                                                (* lmm "16-APR-82 00:14")    (COMP.ST (COMP.LOOKUPCONST X)	     1])(COMP.STVAR  [LAMBDA (VREF)                                             (* lmm "16-APR-82 00:14")    (COMP.ST VREF 1])(COMP.STPOP  [LAMBDA (N)                                                (* lmm "16-APR-82 00:14")    (RPTQ (OR N 1)	  (COMP.ST OPPOP -1])(COMP.DELFN  [LAMBDA NIL                                                (* lmm: "22-JUL-77 02:40")    [SETQ LEVEL (IPLUS (SUB1 LEVEL)		       (CAR (fetch OPARG of (CAR CODE]    (SETQ CODE (CDR CODE])(COMP.STRETURN  [LAMBDA NIL                                                (* lmm "16-APR-82 00:13")    (COMP.ST OPRETURN T)    (SETQ LEVEL (SETQ FRAME])(COMP.STTAG  [LAMBDA (TAG)                                              (* lmm "13-Jul-84 21:18")    (PROG ((NLV (fetch (TAG LEVEL) of TAG))	   (NF (fetch (TAG FRAME) of TAG)))          (OR (COND		[(OR NLV NF)		  (AND (EQ NLV (OR LEVEL (SETQ LEVEL NLV)))		       (EQ NF (OR FRAME (SETQ FRAME NF]		((OR LEVEL FRAME)		  (AND (replace (TAG LEVEL) of TAG with LEVEL)		       (replace (TAG FRAME) of TAG with FRAME)))		(T T))	      (OPT.COMPILERERROR))          [COND	    ((AND (EQ (fetch OPNAME of (CAR CODE))		      (QUOTE JUMP))		  (EQ (fetch (JUMP TAG) of (CAR CODE))		      TAG))                                  (* delete JUMP to next in COMP.STTAG)	      (SETQ CODE (CDR CODE]          (COMP.ST TAG 0])(COMP.STJUMP  [LAMBDA (OP TAG JT)                                        (* lmm "13-Jul-84 21:18")    (COND      ((OPT.JUMPCHECK CODE)                                  (* JUMP not stored after JUMP or RETURN)	NIL)      (T [COND	   ((NULL TAG)                                       (* even if OP is given and in correct format, re-cons it							     up since OPT.POSTOPT might smash it)	     (SETQ TAG (CAR (fetch OPARG of OP)))	     (SETQ JT (CDR (fetch OPARG of OP)))	     (SETQ OP (fetch OPNAME of OP]	 (COMP.ST (create JUMP			  OPNAME &larr; OP			  TAG &larr; TAG			  JT &larr; JT)		  0)	 (PROG ((F (fetch FRAME of TAG))		(V (fetch (TAG LEVEL) of TAG))		NV)	       (COND		 (F (OPT.CCHECK (EQ F FRAME)))		 (T (replace (TAG FRAME) of TAG with FRAME)))	       (SETQ NV (SELECTQ OP				 [JUMP (PROG1 LEVEL (SETQ FRAME (SETQ LEVEL]				 ((FJUMP TJUMP)				   (SETQ LEVEL (SUB1 LEVEL)))				 [(NFJUMP NTJUMP)				   (PROG1 LEVEL (SETQ LEVEL (SUB1 LEVEL]				 (ERRORSET (PROG1 (SUB1 LEVEL)						  (SETQ FRAME JT)						  (SETQ LEVEL 0)))				 (OPT.COMPILERERROR)))	       (OPT.CCHECK (OR (NULL NV)			       (IGEQ NV 0)))	       (OPT.CCHECK (OR (NULL LEVEL)			       (IGEQ LEVEL 0)))	       (COND		 (V (OPT.CCHECK (EQ V NV)))		 (T (replace (TAG LEVEL) of TAG with NV])(COMP.STSETQ  [LAMBDA (VREF)                                             (* lmm "16-APR-82 00:14")    (OPT.CCHECK (IGREATERP LEVEL 0))    (COMP.ST (create OP		     OPNAME &larr;(QUOTE SETQ)		     OPARG &larr; VREF)	     0])(COMP.STCOPY  [LAMBDA NIL                                                (* lmm "16-APR-82 00:14")    (OPT.CCHECK (IGREATERP LEVEL 0))    (COMP.ST OPCOPY 1])(COMP.DELPUSH  [LAMBDA NIL                                                (* lmm: " 9-AUG-76 21:50:49")    (SUB1VAR LEVEL)    (SETQ CODE (CDR CODE])(COMP.DELPOP  [LAMBDA NIL                                                (* lmm "28-OCT-77 15:23")    (SETQ LEVEL (ADD1 LEVEL))    (SETQ CODE (CDR CODE])(COMP.STBIND  [LAMBDA (F)                                                (* lmm " 1-Jul-84 14:48")    [COND      ((NULL (fetch PARENT of F))	(replace PARENT of F with FRAME))      (T (OPT.CCHECK (EQ (fetch PARENT of F)			 FRAME]    [COND      [(NULL (fetch (FRAME LEVEL) of F))	(replace (FRAME LEVEL) of F with (IDIFFERENCE LEVEL (fetch NVALS of F]      (T (OPT.CCHECK (EQ (fetch (FRAME LEVEL) of F)			 (IDIFFERENCE LEVEL (fetch NVALS of F]    (COND      ([EVERY CODE (FUNCTION (LAMBDA (X)		  (SELECTQ (fetch OPNAME of X)			   ((TAG HVAR AVAR GVAR CONST)			     T)			   [FN (OR (NULL (fetch (FRAME VARS) of F))				   (COMP.CLEANFNOP (CDR (fetch OPARG of X))						   (QUOTE FREEVARS]			   NIL]                              (* PROG is first thing in function)	(replace CPIOK of F with T)))    (COMP.ST (create OP		     OPNAME &larr;(QUOTE BIND)		     OPARG &larr;(CONS NIL F))	     0)    (SETQ FRAME F)    (SETQ LEVEL 0])(COMP.STUNBIND  [LAMBDA (D)                                                (* lmm "16-APR-82 00:14")    (COMP.ST (create OP		     OPNAME &larr;(COND		       (D (QUOTE DUNBIND))		       (T (QUOTE UNBIND)))		     OPARG &larr;(CONS LEVEL FRAME))	     0)    [SETQ LEVEL (IPLUS (fetch (FRAME LEVEL) of FRAME)		       (COND			 (D 0)			 (T 1]    (SETQ FRAME (fetch PARENT of FRAME]))(DEFINEQ(COMP.ARGTYPE  [LAMBDA (FN)                                               (* lmm "25-FEB-82 16:29")    (PROG NIL          (RETURN (COND		    ((NOT (LITATOM FN))		      (ARGTYPE FN))		    ((FMEMB FN LAMA)		      2)		    ((FMEMB FN LAMS)		      0)		    ((FMEMB FN NLAML)		      1)		    ((FMEMB FN NLAMA)		      3)		    (T (ARGTYPE (OR [AND BLKFLG (OR (CADDR (FASSOC FN BLKDEFS))						    (AND (FMEMB FN BLKLIBRARY)							 (GETP FN (QUOTE BLKLIBRARYDEF]				    (GETPROP FN (QUOTE BROKEN))				    (AND (GETD FN)					 FN)				    (GETPROP FN (QUOTE EXPR))				    (RETURN (COND					      ((FMEMB FN NOFIXFNSLST)						2)					      (T NIL])(COMP.CLEANEXPP  [LAMBDA (X TYPE)                                           (* lmm "15-APR-82 23:01")    (COND      ((NLISTP X))      ((COMP.CLEANFNP (CAR X)		      TYPE)	(EVERY (CDR X)	       (FUNCTION (LAMBDA (X)		   (COMP.CLEANEXPP X TYPE])(COMP.CLEANFNP  [LAMBDA (X TYPE)                                           (* lmm "15-APR-82 23:02")    (COND      ((LITATOM X)	(APPLY* CLEANFNTEST X))      ((LISTP X)	(SELECTQ (CAR X)		 [[LAMBDA OPENLAMBDA]		   (EVERY (CDDR X)			  (FUNCTION (LAMBDA (X)			      (COMP.CLEANEXPP X TYPE]		 NIL])(COMP.CLEANFNOP  [LAMBDA (FN TYPE)                                          (* lmm "15-APR-82 23:07")    (APPLY* CLEANFNTEST FN TYPE])(COMP.GLOBALVARP  [LAMBDA (X)                                                (* lmm: " 9-AUG-76 20:34:14")    (OR (GETP X (QUOTE GLOBALVAR))	(FMEMB X GLOBALVARS])(COMP.LINKCALLP  [LAMBDA (FN)                                               (* edited (18-NOV-75 . 2341))    (COND      ((AND (LISTP NOLINKFNS)	    (FMEMB FN NOLINKFNS))	NIL)      ((AND BLKFLG (OR (FASSOC FN BLKDEFS)		       (FMEMB FN BLKLIBRARY)))	T)      ((AND (LISTP LINKFNS)	    (FMEMB FN LINKFNS))	T)      ((EQ NOLINKFNS T)	NIL)      ((OR BLKFLG (EQ LINKFNS T))	T])(COMP.ANONP  [LAMBDA (E)                                                (* lmm "31-MAR-78 01:34")    (COND      ((NEQ LOCALVARS T)	(FMEMB E LOCALVARS))      (T (NOT (OR (EQ SPECVARS T)		  (FMEMB E SPECVARS)		  (AND BLKFLG (FMEMB E LOCALFREEVARS]))(DEFINEQ(COMP.CPI  [LAMBDA (FN ARGS)                                          (* lmm "13-Jul-84 21:18")    (PROG ((F FRAME))      LP  (COND	    ((EQ F TOPFRAME)	      (COMP.CPI1 ARGS ARGVARS (COMP.PICOUNT ARGS))	      (while (NEQ FRAME TOPFRAME)		 do                                          (* unbind localvar FRAME before recursion)		    (COMP.STUNBIND T))	      (COND		((NEQ LEVEL 0)                               (* pop stack before recursion)		  (COMP.STPOP LEVEL)))	      (COMP.STJUMP (QUOTE JUMP)			   TOPLAB)                           (* COMP.CPI succeeds)	      (RETURN (QUOTE NOVALUE)))	    ((SELECTQ (fetch FRAMETYPE of F)		      [(PROG LAMBDA)			(COND			  ((OASSOC (QUOTE AVAR)				   (fetch VARS of F))			    (COND			      ((NOT (fetch CPIOK of F))      (* can't remove recursion inside frame with SPECVARS)				T)			      (T                             (* COMP.CPI can succeed because SPECVARS bound first 							     thing in function)				 NIL]		      (PROGN                                 (* can't remove recursion inside ERRORSET)			     T))	      (COMP.CALL FN ARGS 0))	    ((SETQ F (fetch PARENT of F))	      (GO LP))	    (T (OPT.COMPILERERROR])(COMP.CPI1  [LAMBDA (ARGS VARS N)                                      (* lmm "16-APR-82 00:28")    (COND      [(NULL VARS)	(COND	  ((LISTP ARGS)	    (COMP.EFFECT (CAR ARGS))	    (COMP.CPI1 (CDR ARGS)		       VARS		       (SUB1 N]      ([OR (IGREATERP N 0)	   (NOT (LITATOM (CAR ARGS)))	   (NEQ (CAR ARGS)		(fetch OPARG of (CAR VARS]	(COMP.VAL (CAR ARGS))	(COMP.CPI1 (CDR ARGS)		   (CDR VARS)		   (SUB1 N))	(COMP.STSETQ (CAR VARS))	(COMP.STPOP))      (T (COMP.CPI1 (CDR ARGS)		    (CDR VARS)		    (SUB1 N])(COMP.PICOUNT  [LAMBDA (ARGS)                                             (* lmm "27-OCT-81 20:57")    (PROG ((N 0)	   (ND 0)	   (VARS ARGVARS))      LP  (COND	    (VARS (SETQ N (ADD1 N))		  (COND		    [(AND (LITATOM (CAR ARGS))			  (EQ (CAR ARGS)			      (fetch OPARG of (CAR VARS]		    ((NOT (COMP.CLEANEXPP (CAR ARGS)					  (QUOTE COMP.PICOUNT)))		      (SETQ ND N)))		  (SETQ VARS (CDR VARS))		  (SETQ ARGS (CDR ARGS))		  (GO LP)))          (RETURN ND]))(PUTPROPS EVQ BYTEMACRO COMP.EVQ)(DEFINEQ(COMP.EVQ  [LAMBDA (X)                                                (* lmm "18-Sep-84 16:06")    (RESETVARS (COMPVARMACROHASH)	       (RETURN (COMP.PROGLST X 1]))(PUTPROPS AND BYTEMACRO (APPLY* COMP.BOOL T))(PUTPROPS OR BYTEMACRO (APPLY* COMP.BOOL NIL))(DEFINEQ(COMP.BOOL  [LAMBDA (A FLAG)                                           (* lmm "29-Apr-85 13:33")    (COND      ((NULL A)                                              (* (AND/OR))	(COMP.CONST FLAG))      ((NULL (CDR A))                                        (* (AND/OR expr))	(COMP.EXP1 (CAR A)))      (T (PROG ((END (create TAG))		P)	       (SETQ P (create JUMP			       OPNAME &larr;[COND				 ((COMP.PREDP COMPILE.CONTEXT)                                                             (* AND/OR in PREDF)				   (SELECTQ (fetch OPNAME of (SETQ P COMPILE.CONTEXT))					    [(TJUMP NTJUMP)					      (COND						(FLAG (QUOTE FJUMP))						(T (GO LP]					    [(FJUMP NFJUMP)					      (COND						(FLAG (GO LP))						(T (QUOTE TJUMP]					    (OPT.COMPILERERROR)))				 [(EQ COMPILE.CONTEXT (QUOTE EFFECT))                                                             (* AND/OR in EFFECT)				   (COND				     (FLAG (QUOTE FJUMP))				     (T (QUOTE TJUMP]				 (T                          (* other AND/OR)				    (COND				      (FLAG (QUOTE NFJUMP))				      (T (QUOTE NTJUMP]			       TAG &larr; END))	   LP  (COND		 ((CDR A)		   (COMP.EXPR (CAR A)			      P)		   (SETQ A (CDR A))		   (GO LP)))	       (RETURN (PROG1 [COMP.EXPR (CAR A)					 (SELECTQ COMPILE.CONTEXT						  ((EFFECT RETURN NIL)						    COMPILE.CONTEXT)						  (COND						    ((COMP.PREDP COMPILE.CONTEXT)						      COMPILE.CONTEXT)						    (T NIL]			      (COMP.STTAG END]))(DEFINEQ(COMP.APPLYFNP  [LAMBDA (X)                                                (* edited: "21-MAY-80 09:38")    (AND (LISTP X)	 (SELECTQ (CAR X)		  ((FUNCTION QUOTE)		    (AND (NULL (CDDR X))			 (SELECTQ (COMP.ARGTYPE (CADR X))				  (NIL (pushnew ALAMS1 (CADR X))				       T)				  ((0 1 2)				    T)				  NIL)))		  NIL]))(PUTPROPS AC BYTEMACRO COMP.AC)(PUTPROPS ASSEMBLE BYTEMACRO COMP.PUNT)(PUTPROPS ASSEM BYTEMACRO COMP.PUNT)(PUTPROPS FLOC BYTEMACRO COMP.PUNT)(DEFINEQ(COMP.AC  [LAMBDA NIL                                                (* lmm: " 1-OCT-76 12:41:01")    (OR (EQ (SETQ AC EXP)	    DONOTHING)	(COMP.PUNT))    NIL])(COMP.PUNT  [LAMBDA NIL                                                (* lmm "22-OCT-79 12:44")    (PROG [(EM (CONS (CAR EXP)		     (QUOTE (-- can't compile]          (COMPERROR (COND		       [MACEXP (CONS (QUOTE Under)				     (CONS (CAR MACEXP)					   (CONS (QUOTE -)						 EM]		       (T EM]))(PUTPROPS FUNCTION BYTEMACRO COMP.FUNCTION)(DEFINEQ(COMP.FUNCTION  [LAMBDA (A)                                                (* lmm "16-APR-82 00:18")    (PROG ((FN (CAR A)))          [COND	    ((LISTP FN)	      (SETQ FN (COMP.LAM1 FN]          (RETURN (COND		    ((CDR A)		      (COMP.CALL (QUOTE FUNCTION)				 (CONS FN (CDR A))				 1))		    (T (COMP.STCONST FN])(COMP.LAM1  [LAMBDA (DEF)                                              (* lmm " 1-Jul-84 16:50")    (PROG ((FN (COMP.GENFN)))          (COMP.TOPLEVEL.COMPILE FN DEF)          (for X in ALLVARS	     do                                              (* change LOCALVAR to SPECVAR because subfn uses it 							     free)		(replace OPNAME of X with (QUOTE AVAR))	     when (AND (NEQ (fetch OPNAME of X)			    (QUOTE AVAR))		       (FMEMB (fetch OPARG of X)			      SUBFNFREEVARS)))          (RETURN FN])(COMP.GENFN  [LAMBDA NIL                                                (* lmm "29-Jun-84 08:34")    (DECLARE (SPECVARS COMP.GENFN)	     (USEDFREE COMP.GENFN))    [COND      ((ILEQ (NCHARS COMP.GENFN.BUF)	     (IPLUS 12 (NCHARS COMFN)))	(SETQ COMP.GENFN.BUF (ALLOCSTRING (IPLUS 16 (NCHARS COMP.GENFN.BUF]    (COND      ((IGEQ COMP.GENFN.NUM 9999)	(SETQ COMP.GENFN.NUM 0)))    (GENSYM COMFN (add COMP.GENFN.NUM 1)	    COMP.GENFN.BUF NIL (CHARCODE A]))(RPAQ? COMP.GENFN.NUM 0)(RPAQ? COMP.GENFN.BUF (ALLOCSTRING 100))(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS COMP.GENFN.NUM COMP.GENFN.BUF COMP.UNBOXED.TAG))(PUTPROPS COND BYTEMACRO COMP.COND)(PUTPROPS SELECTQ BYTEMACRO COMP.SELECTQ)(DEFINEQ(COMP.COND  [LAMBDA (A)                                                (* lmm "12-Mar-85 07:04")    (PROG (TEST CLAUSE (END (create TAG))		ENDF NEXT [CONTEXT (SELECTQ COMPILE.CONTEXT					    ((EFFECT RETURN NIL)					      COMPILE.CONTEXT)					    (COND					      ((COMP.PREDP COMPILE.CONTEXT)						NIL)					      ((EVERY A (FUNCTION CDR))						COMPILE.CONTEXT)					      (T NIL]		COMPVAL)      LP  [SETQ TEST (CAR (SETQ CLAUSE (CAR A]          (COND	    [(CDR CLAUSE)                                    (* is there anything after the test?)          (* * compile the test in a context where, if false, it will jump to NEXT)	      (LET [(MORE (LET ((HERE CODE))			    [COMP.EXPR TEST (create JUMP						    OPNAME &larr;(QUOTE FJUMP)						    TAG &larr;(SETQ NEXT (create TAG]			    (OR OPTIMIZATIONSOFF				(for (X &larr; CODE) by (CDR X) while (AND X (NEQ X HERE))				   do (AND (EQ [CAR (LISTP (fetch OPARG of (CAR X]					       NEXT)					   (RETURN T]		[COND		  ((NOT (OPT.JUMPCHECK CODE))                (* it doesn't ALWAYS jump to next)		    (SETQ COMPVAL (COMP.VALN (CDR CLAUSE)					     CONTEXT))		    (OR (OPT.JUMPCHECK CODE)			(COMP.STJUMP (QUOTE JUMP)				     (SETQ ENDF END]		(COND		  (MORE (COMP.STTAG NEXT))		  (T (GO OUT]	    [(CDR A)                                         (* this is a form (COND (TEST) --) where there is more 							     to come)	      (COMP.EXPR TEST (create JUMP				      OPNAME &larr;(COND					((EQ CONTEXT (QUOTE EFFECT))					  (QUOTE TJUMP))					(T (QUOTE NTJUMP)))				      TAG &larr;(SETQ ENDF END]	    (T                                               (* (COND -- (A)) is equivalent to 							     (COND -- (T A)))	       (SETQ COMPVAL (COMP.EXPR TEST CONTEXT))	       (GO OUT)))          (COND	    ((SETQ A (CDR A))	      (GO LP)))          (AND (NEQ CONTEXT (QUOTE EFFECT))	       (COMP.EXPR NIL))      OUT (AND ENDF (COMP.STTAG END))          (RETURN (COND		    ((EQ CONTEXT (QUOTE EFFECT))		      (QUOTE NOVALUE))		    (T COMPVAL])(COMP.SELECTQ  [LAMBDA (A)                                                (* lmm "13-Jul-84 21:18")    (PROG ((END (create TAG))	   VAR THISLABEL NEXT TEST CLAUSE)                   (* compile SELECTQ)          (COMP.VAL (CAR A))          (SETQ A (CDR A))          (COND	    ((FMEMB (fetch OPNAME of (CAR CODE))		    SELECTVARTYPES)                          (* SELECTQVARTYPES is (AVAR HVAR) for Alto and NIL for 							     maxc)                                                             (* SELECTQ var)	      (SETQ VAR (CAR CODE))	      (COMP.DELPUSH))	    ((AND (EQ (fetch OPNAME of (CAR CODE))		      (QUOTE SETQ))		  (FMEMB (fetch OPNAME of (fetch OPARG of (CAR CODE)))			 SELECTVARTYPES))                    (* SELECTQ SETQ)	      (SETQ VAR (fetch OPARG of (CAR CODE)))	      (COMP.STPOP))	    [(EQ (fetch OPNAME of (CAR CODE))		 (QUOTE CONST))                              (* SELECTQ of constant)	      (RETURN (COMP.PROGN (PROG [(C (fetch OPARG of (CAR CODE]				        (COMP.DELPUSH)				    ALP (COND					  ((NULL (CDR A))					    (RETURN A)))				        [COND					  ((COND					      ((LISTP (CAAR A))						(FMEMB C (CAAR A)))					      (T (EQ (CAAR A)						     C)))					    (RETURN (CDAR A]				        (SETQ A (CDR A))				        (GO ALP]	    (T (SETQ THISLABEL T)))      LP  [COND	    ((NULL (CDR A))	      (AND THISLABEL (NULL VAR)		   (COMP.STPOP))	      (RETURN (PROG1 (COMP.EXPR (CAR A)					(COND					  ((COMP.PREDP COMPILE.CONTEXT)					    NIL)					  (T COMPILE.CONTEXT)))			     (OR (EQ COMPILE.CONTEXT (QUOTE RETURN))				 (COMP.STTAG END]          (SETQ THISLABEL)          [COND	    ([LISTP (SETQ TEST (CAR (SETQ CLAUSE (PROG1 (CAR A)							(SETQ A (CDR A]	      (COND		((NLISTP (CDR TEST))		  (SETQ TEST (CAR TEST)))		(SELECTQFMEMB                                (* FMEMB in SELECTQ)			      (COND				(VAR (COMP.STVAR VAR))				((CDR A)				  (COMP.STCOPY)))			      (COMP.STCONST (APPEND TEST))			      (COMP.STFN (QUOTE FMEMB)					 2)			      (GO DUN))		(T (SETQ THISLABEL (create TAG))		   (MAP TEST (FUNCTION (LAMBDA (Y)			    (COND			      ((CDR Y)				(COND				  (VAR (COMP.STVAR VAR))				  (T (COMP.STCOPY)))				(COMP.STCONST (CAR Y))				(COMP.STFN (QUOTE EQ)					   2)				(COMP.STJUMP (QUOTE TJUMP)					     THISLABEL))			      (T (SETQ TEST (CAR Y]          (COND	    (VAR (COMP.STVAR VAR))	    ((OR THISLABEL (CDR A))	      (COMP.STCOPY)))          (COMP.STCONST TEST)          (COMP.STFN (QUOTE EQ)		     2)      DUN [COND	    ((AND (NULL THISLABEL)		  (NULL (CDR A))		  (NULL (CAR A)))                            (* SELECTQ ends in NIL)	      (COMP.STJUMP (COND			     ((EQ COMPILE.CONTEXT (QUOTE EFFECT))			       (QUOTE FJUMP))			     (T (QUOTE NFJUMP)))			   END)	      (RETURN (PROG1 (COMP.VALN (CDR CLAUSE)					(COND					  ((EQ COMPILE.CONTEXT (QUOTE EFFECT))					    COMPILE.CONTEXT)))			     (COMP.STTAG END]          (COMP.STJUMP (QUOTE FJUMP)		       (SETQ NEXT (create TAG)))          (COND	    (THISLABEL (COMP.STTAG THISLABEL)))          (COND	    ((AND (OR THISLABEL (CDR A))		  (NULL VAR))	      (COMP.STPOP)))          (COMP.VALN (CDR CLAUSE)		     (SELECTQ COMPILE.CONTEXT			      ((EFFECT RETURN)				COMPILE.CONTEXT)			      NIL))          (OR (EQ COMPILE.CONTEXT (QUOTE RETURN))	      (COMP.STJUMP (QUOTE JUMP)			   END))          (COMP.STTAG NEXT)          (GO LP]))(PUTPROPS PROGN BYTEMACRO COMP.PROGN)(PUTPROPS PROG1 BYTEMACRO COMP.PROG1)(PUTPROPS QUOTE BYTEMACRO COMP.QUOTE)(PUTPROPS * BYTEMACRO COMP.COMMENT)(DEFINEQ(COMP.QUOTE  [LAMBDA (A)                                                (* lmm: " 9-AUG-76 22:04:49")    [COND      ((CDR A)	(COMPERRM (CONS EXP (QUOTE (- probable parenthesis error]    (COMP.CONST (CAR A])(COMP.COMMENT  [LAMBDA (A)                                                (* lmm "29-Jun-84 08:25")    (COND      ((NOT (EQ COMPILE.CONTEXT (QUOTE EFFECT)))	[COMPERRM (CONS EXP (QUOTE (- value of comment used?]	(COMP.STCONST (CAR A)))      (T (QUOTE NOVALUE]))(PUTPROPS DECLARE BYTEMACRO COMP.DECLARE)(DEFINEQ(COMP.DECLARE  [LAMBDA (A)                                                (* lmm "26-Aug-84 16:01")                                                             (* compile DECLARE)    [MAPC A (FUNCTION (LAMBDA (B)	      (SELECTQ (CAR B)		       (LOCALVARS (COMP.DECLARE1 (CDR B)						 (QUOTE LOCALVARS)						 (QUOTE SPECVARS)						 SYSSPECVARS))		       (SPECVARS (COMP.DECLARE1 (CDR B)						(QUOTE SPECVARS)						(QUOTE LOCALVARS)						SYSLOCALVARS))		       (USEDFREE NIL)		       ((ADDTOVAR DEFLIST PUTPROPS CONSTANTS SETQQ USEDFREE GLOBALVARS)			 (EVAL B))		       (UNBOXED (push ALLDECLS COMP.UNBOXED.TAG))		       (TYPE                                 (* handled elsewhere))		       (COMPERRM (CONS B (QUOTE (- used in DECLARE]    (COMP.CONST (CAR A])(COMP.DECLARE1  [LAMBDA (VAL VAR OTHERVAR SYSOTHERVAR)                     (* lmm "31-MAR-78 02:47")    (SET VAR (COND	   ((LISTP VAL)	     (COND	       ((LISTP (SETQ VAR (EVALV VAR)))		 (APPEND VAL VAR))	       ((EQ VAR T))	       (T VAL)))	   ((EQ VAL T)	     (SET OTHERVAR SYSOTHERVAR)	     T)	   (T VAL)))    (MAPC (fetch VARS of FRAME)	  (FUNCTION (LAMBDA (V VTAG)	      (COND		((NEQ (SETQ VTAG (COMP.VARTYPE (fetch OPARG of V)))		      (fetch OPNAME of V))                   (* Already made some decision based on localvars 							     (COMPERRM (CONS EXP (QUOTE (- illegal DECLARE)))))		  (replace OPNAME of V with VTAG]))(RPAQQ MCROPS (CAR CDR CAAR CDAR CADR CDDR CAAAR CDAAR CADAR CDDAR CAADR CDADR CADDR CDDDR CAAAAR 		   CDAAAR CADAAR CDDAAR CAADAR CDADAR CADDAR CDDDAR CAAADR CDAADR CADADR CDDADR 		   CAADDR CDADDR CADDDR CDDDDR))(PUTPROPS CAR BYTEMACRO COMP.CARCDR)(PUTPROPS CDR BYTEMACRO COMP.CARCDR)(PUTPROPS CAAR BYTEMACRO COMP.CARCDR)(PUTPROPS CDAR BYTEMACRO COMP.CARCDR)(PUTPROPS CADR BYTEMACRO COMP.CARCDR)(PUTPROPS CDDR BYTEMACRO COMP.CARCDR)(PUTPROPS CAAAR BYTEMACRO COMP.CARCDR)(PUTPROPS CDAAR BYTEMACRO COMP.CARCDR)(PUTPROPS CADAR BYTEMACRO COMP.CARCDR)(PUTPROPS CDDAR BYTEMACRO COMP.CARCDR)(PUTPROPS CAADR BYTEMACRO COMP.CARCDR)(PUTPROPS CDADR BYTEMACRO COMP.CARCDR)(PUTPROPS CADDR BYTEMACRO COMP.CARCDR)(PUTPROPS CDDDR BYTEMACRO COMP.CARCDR)(PUTPROPS CAAAAR BYTEMACRO COMP.CARCDR)(PUTPROPS CDAAAR BYTEMACRO COMP.CARCDR)(PUTPROPS CADAAR BYTEMACRO COMP.CARCDR)(PUTPROPS CDDAAR BYTEMACRO COMP.CARCDR)(PUTPROPS CAADAR BYTEMACRO COMP.CARCDR)(PUTPROPS CDADAR BYTEMACRO COMP.CARCDR)(PUTPROPS CADDAR BYTEMACRO COMP.CARCDR)(PUTPROPS CDDDAR BYTEMACRO COMP.CARCDR)(PUTPROPS CAAADR BYTEMACRO COMP.CARCDR)(PUTPROPS CDAADR BYTEMACRO COMP.CARCDR)(PUTPROPS CADADR BYTEMACRO COMP.CARCDR)(PUTPROPS CDDADR BYTEMACRO COMP.CARCDR)(PUTPROPS CAADDR BYTEMACRO COMP.CARCDR)(PUTPROPS CDADDR BYTEMACRO COMP.CARCDR)(PUTPROPS CADDDR BYTEMACRO COMP.CARCDR)(PUTPROPS CDDDDR BYTEMACRO COMP.CARCDR)(PUTPROPS CAR CROPS (A))(PUTPROPS CDR CROPS (D))(PUTPROPS CAAR CROPS (A A))(PUTPROPS CDAR CROPS (A D))(PUTPROPS CADR CROPS (D A))(PUTPROPS CDDR CROPS (D D))(PUTPROPS CAAAR CROPS (A A A))(PUTPROPS CDAAR CROPS (A A D))(PUTPROPS CADAR CROPS (A D A))(PUTPROPS CDDAR CROPS (A D D))(PUTPROPS CAADR CROPS (D A A))(PUTPROPS CDADR CROPS (D A D))(PUTPROPS CADDR CROPS (D D A))(PUTPROPS CDDDR CROPS (D D D))(PUTPROPS CAAAAR CROPS (A A A A))(PUTPROPS CDAAAR CROPS (A A A D))(PUTPROPS CADAAR CROPS (A A D A))(PUTPROPS CDDAAR CROPS (A A D D))(PUTPROPS CAADAR CROPS (A D A A))(PUTPROPS CDADAR CROPS (A D A D))(PUTPROPS CADDAR CROPS (A D D A))(PUTPROPS CDDDAR CROPS (A D D D))(PUTPROPS CAAADR CROPS (D A A A))(PUTPROPS CDAADR CROPS (D A A D))(PUTPROPS CADADR CROPS (D A D A))(PUTPROPS CDDADR CROPS (D A D D))(PUTPROPS CAADDR CROPS (D D A A))(PUTPROPS CDADDR CROPS (D D A D))(PUTPROPS CADDDR CROPS (D D D A))(PUTPROPS CDDDDR CROPS (D D D D))(DEFINEQ(COMP.CARCDR  [LAMBDA (A)                                                (* lmm "18-Sep-84 16:13")                                                             (* Used for compiling CAR/CDR etc)    (COND      ((EQ COMPILE.CONTEXT (QUOTE EFFECT))                   (* CAR/CDR in EFF)	(COMP.PROGLST A 1 COMPILE.CONTEXT))      (T (COMP.PROGLST A 1)	 (MAPC (GETPROP (CAR EXP)			(QUOTE CROPS))	       (FUNCTION (LAMBDA (X)		   (COMP.STFN (SELECTQ X				       (A (QUOTE CAR))				       (QUOTE CDR))			      1])(COMP.STCROP  [LAMBDA (X)                                                (* lmm "16-APR-82 00:16")    (COMP.STFN (SELECTQ X			(A (QUOTE CAR))			(QUOTE CDR))	       1]))(PUTPROPS NOT BYTEMACRO COMP.NOT)(PUTPROPS NULL BYTEMACRO COMP.NOT)(DEFINEQ(COMP.NOT  [LAMBDA (A TMP)                                            (* lmm "18-Sep-84 16:30")    (COND      ((AND (COMP.PREDP COMPILE.CONTEXT)	    (SETQ TMP (OPT.NOTJUMP COMPILE.CONTEXT)))	(COMP.PROGLST A 1 TMP))      (T (COMP.PROGLST A 1)	 (COMP.STFN (QUOTE NULL)		    1]))(PUTPROPS SETQ BYTEMACRO COMP.SETQ)(PUTPROPS SETN BYTEMACRO COMP.SETN)(DEFINEQ(COMP.SETQ  [LAMBDA (A)                                                (* lmm "29-Oct-84 15:23")    (PROG (VAR DECL)          (SETQ VAR (COMP.LOOKUPVAR (CAR A)))          [SETQ DECL (LISTP (CDR (ASSOC VAR ALLDECLS]          (COMP.PROGLST (CDR A)			1 DECL)          (COMP.STSETQ VAR)          (IF (AND (NEQ COMPILE.CONTEXT (QUOTE EFFECT))		   (EQ (CAR DECL)		       (QUOTE UNBOXED)))	      THEN (COMP.BOX (CDR DECL])(COMP.SETN  [LAMBDA (A)                                                (* lmm: "20-OCT-76 01:33:55")    [COMPERRM (CONS (CAR A)		    (QUOTE (- warning: SETN compiled as SETQ]    (COMP.SETQ A]))(DEFINEQ(COMP.LAMBDA  [LAMBDA (FN VALS)                                          (* lmm "13-Jul-84 21:29")    (PROG ((VARS (CADR FN))	   F	   (EXPS (CDDR FN))	   V E (I 0)	   SUBOLD SUBNEW VAR)          [if (EQ (CAR FN)		  (QUOTE OPENLAMBDA))	      then                                           (* compile OPENLAMBDA expression)		   [while VARS		      do (COMP.VAL (pop VALS))			 (COND			   ((EQ (fetch OPNAME of (CAR CODE))				(QUOTE CONST))			     (push SUBOLD (pop VARS))			     [push SUBNEW (KWOTE (fetch OPARG of (CAR CODE]			     (COMP.DELPUSH))			   (T (push V (pop VARS]		   (for X in VALS do (COMP.EFFECT X))		   (while (AND V (SETQ VAR (SELECTQ (fetch OPNAME of (CAR CODE))						    ((AVAR HVAR FVAR GVAR)						      (PROG1 (fetch OPARG of (CAR CODE))							     (COMP.DELPUSH)))						    (SETQ (PROG1 (fetch OPARG								    of (fetch OPARG									  of (CAR CODE)))								 (COMP.STPOP)))						    NIL)))		      do                                     (* substitute for variable in OPENLAMBDA)			 (push SUBNEW VAR)			 (push SUBOLD (pop V)))		   [if (NULL V)		       then                                  (* OPENLAMBDA with all variables substituted for)			    (RETURN (COMP.PROGN (SUBPAIR SUBOLD SUBNEW EXPS]		   (while V		      do [push SUBNEW (CAR (push VARS (COMP.GENFN]			 (push SUBOLD (pop V))			 (push VALS DONOTHING))		   (SETQ EXPS (CONS (QUOTE (DECLARE (LOCALVARS . T)))				    (SUBPAIR SUBOLD SUBNEW EXPS)))	    else (SELECTQ (ARGTYPE FN)			  (0)			  [1                                 (* open NLAMBDA nospread)			     (SETQ VALS (MAPCAR VALS (FUNCTION KWOTE]			  (2                                 (* open LAMBDA nospread)			     (RETURN (COMP.CALL (COMP.LAM1 FN)						VALS 2)))			  [3                                 (* open NLAMBDA spread)			     (SETQ VARS (LIST VARS))			     (SETQ VALS (LIST (KWOTE VALS]			  (COMPERROR (CONS FN (QUOTE (- illegal open function]          (SETQ F (COMP.BIND.VARS VARS VALS (QUOTE LAMBDA)				  (COMP.LOOKFORDECLARE EXPS)))          (PROG ((ALLVARS (APPEND (fetch VARS of F)				  ALLVARS))		 (ALLDECLS (APPEND (fetch DECLS of F)				   ALLDECLS))		 (LOCALVARS LOCALVARS)		 (SPECVARS SPECVARS))	        (COMP.STBIND F)	        (COMP.VALN EXPS (SELECTQ COMPILE.CONTEXT					 ((EFFECT RETURN)					   COMPILE.CONTEXT)					 NIL)))          (RETURN (COMP.UNBIND.VARS F]))(PUTPROPS PROG BYTEMACRO COMP.PROG)(PUTPROPS GO BYTEMACRO COMP.GO)(PUTPROPS RETURN BYTEMACRO COMP.RETURN)(DEFINEQ(COMP.PROG  [LAMBDA (A)                                                (* lmm "13-Jul-84 21:18")    (PROG ([VARS (for X in (CAR A) collect (COND					     ((LITATOM X)					       X)					     [(NLISTP X)					       (COMPERROR (CONS X (QUOTE (- bad PROG variable]					     (T (CAR X]	   [VALS (for X in (CAR A) collect (AND (LISTP X)						(COND						  ((CDDR X)						    (CONS (QUOTE PROG1)							  (CDR X)))						  (T (CADR X]	   F)          [SETQ F (COMP.BIND.VARS VARS VALS (QUOTE PROG)				  (COMP.LOOKFORDECLARE (SETQ A (CDR A]          (PROG ((ALLVARS (APPEND (fetch VARS of F)				  ALLVARS))		 (ALLDECLS (APPEND (fetch DECLS of F)				   ALLDECLS))		 (LOCALVARS LOCALVARS)		 (SPECVARS SPECVARS)		 TAGS		 (RETURNLABEL (create TAG				      LEVEL &larr;(COND					((EQ COMPILE.CONTEXT (QUOTE EFFECT))					  0)					(T 1))				      FRAME &larr; F))		 PROGLEVEL		 (PROGCONTEXT (SELECTQ COMPILE.CONTEXT				       ((EFFECT RETURN)					 COMPILE.CONTEXT)				       NIL))		 FLG)	        (COMP.STBIND F)	        [for X in A do (COND				 ((LISTP X))				 [(NOT (LITATOM X))				   (COMPERROR (CONS X (QUOTE (- illegal tag]				 [(FASSOC X TAGS)				   (COMPERROR (CONS X (QUOTE (- multiply defined tag]				 (T (SETQ TAGS (CONS (CONS X (SETQ X (create TAG									     LBNO &larr; X)))						     TAGS))				    (replace (TAG FRAME) of X with FRAME)				    (replace (TAG LEVEL) of X with 0]	        (replace PROGLABELS of F with TAGS)	        [SETQ FLG (AND (NOT OPTIMIZATIONSOFF)			       (NULL TAGS)			       (EQ PROGCONTEXT (QUOTE RETURN]                                                             (* Check if can delete extra POP's)	        [for X in A do (COND				 [(LITATOM X)				   (COMP.STTAG (CDR (FASSOC X TAGS]				 (T (COMP.EFFECT X)				    (AND FLG (while (EQ (CAR CODE)							OPPOP)						do           (* delete POP in PROG)						   (COMP.DELPOP]	        (COND		  ((NOT (OR (EQ COMPILE.CONTEXT (QUOTE EFFECT))			    (OPT.JUMPCHECK CODE)))           (* PROG dropped off)		    (COMP.EXPR NIL)))	        (OR (EQ COMPILE.CONTEXT (QUOTE RETURN))		    (COMP.STTAG RETURNLABEL)))          (RETURN (COMP.UNBIND.VARS F])(COMP.GO  [LAMBDA (A)                                                (* lmm "13-Jul-84 21:18")    (PROG (D ANYPROG)          [COND	    ((OPT.JUMPCHECK CODE)                            (* UNREACHABLE GO -- DON'T COMPILE)	      (RETURN (QUOTE NOVALUE]      LP  [SELECTQ (fetch FRAMETYPE of FRAME)		   (PROG [COND			   ((SETQ D (FASSOC (CAR A)					    (fetch PROGLABELS of FRAME)))			     (COND			       ((NOT (ZEROP LEVEL))          (* GO needs to POP)				 (COMP.STPOP LEVEL)))			     (COMP.STJUMP (QUOTE JUMP)					  (CDR D))			     (RETURN (QUOTE NOVALUE]			 (SETQ ANYPROG T))		   [LAMBDA]		   (COMPERROR (CONS (CAR A)				    (COND				      (ANYPROG (QUOTE (- undefined tag)))				      (T (QUOTE (- illegal GO]                                                             (* non local GO)          (COMP.STUNBIND T)          (GO LP])(COMP.RETURN  [LAMBDA (A)                                                (* lmm "18-Sep-84 16:31")    (PROG ((PROGFRAME FRAME))          [COND	    ((NEQ PROGCONTEXT (QUOTE RETURN))	      (COND		([NOT (OR (EQ PROGCONTEXT (QUOTE EFFECT))			  (EQ LEVEL 0)			  (NEQ (fetch FRAMETYPE of FRAME)			       (QUOTE PROG]                  (* RETURN POPs beforehand)		  (COMP.STPOP LEVEL]      CHKLP          [SELECTQ (fetch FRAMETYPE of PROGFRAME)		   (PROG)		   [LAMBDA (SETQ PROGFRAME (fetch PARENT of PROGFRAME))			   (GO CHKLP]		   (COMPERROR (CONS COMFN (QUOTE (- illegal RETURN]          (COMP.PROGLST A 1 PROGCONTEXT)          [COND	    ((OPT.JUMPCHECK CODE)	      (RETURN (QUOTE NOVALUE]          (COND	    ((NEQ PROGCONTEXT (QUOTE RETURN))	      [PROG NIL		LP  (SELECTQ (fetch FRAMETYPE of FRAME)			     (PROG (OPT.CCHECK (EQ FRAME PROGFRAME)))			     [LAMBDA                         (* RETURN inside LAMBDA)				     (COMP.STUNBIND (EQ PROGCONTEXT (QUOTE EFFECT)))				     (GO LP]			     (COMPERROR (CONS COMFN (QUOTE (- illegal RETURN]	      [COND		((EQ PROGCONTEXT (QUOTE EFFECT))		  (COMP.STPOP LEVEL))		((NEQ LEVEL 1)		  (OPT.COMPILERERROR (QUOTE (unimplemented RETURN]	      (COMP.STJUMP (QUOTE JUMP)			   RETURNLABEL)))          (RETURN (QUOTE NOVALUE]))(RPAQQ COMP.UNBOXED.TAG ("I'm on ALLDECLS if FPLUS compiles with unboxed arithmetic"))(RPAQQ NUMBERFNS (ITIMES2 LOGOR2 LOGXOR2 LOGAND2 LLSH1 LRSH1 LLSH8 LRSH8 IPLUS ITIMES LOGOR LOGXOR 			  LOGAND IDIFFERENCE IQUOTIENT IREMAINDER IMINUS LSH LLSH RSH LRSH FIX))(RPAQQ GLOBALVARFLG T)(RPAQQ NEWOPTFLG NIL)(RPAQ COMPVERSION (DATE))(DECLARE: EVAL@COMPILE (PUTPROPS IPLUS BYTEMACRO (APPLY* COMP.NUMERIC IPLUS))(PUTPROPS ITIMES BYTEMACRO (APPLY* COMP.NUMERIC ITIMES FIX 0))(PUTPROPS LOGOR BYTEMACRO (APPLY* COMP.NUMERIC LOGOR FIX -1))(PUTPROPS LOGXOR BYTEMACRO (APPLY* COMP.NUMERIC LOGXOR))(PUTPROPS LOGAND BYTEMACRO (APPLY* COMP.NUMERIC LOGAND FIX 0))(PUTPROPS IDIFFERENCE BYTEMACRO COMP.NUMBERCALL)(PUTPROPS IQUOTIENT BYTEMACRO COMP.NUMBERCALL)(PUTPROPS IREMAINDER BYTEMACRO COMP.NUMBERCALL)(PUTPROPS IMINUS BYTEMACRO ((X)	   (IDIFFERENCE 0 X)))(PUTPROPS LSH BYTEMACRO COMP.NUMBERCALL)(PUTPROPS LLSH DMACRO COMP.SHIFT)(PUTPROPS RSH BYTEMACRO COMP.NUMBERCALL)(PUTPROPS LRSH DMACRO COMP.SHIFT)(PUTPROPS FIX BYTEMACRO COMP.FIX)[PUTPROPS PLUS DMACRO (APPLY* COMP.NUMERIC PLUS PLUS NIL ((FLOAT FPLUS (OPCODES UBFLOAT2 0][PUTPROPS DIFFERENCE DMACRO (APPLY* COMP.NUMBERCALL PLUS ((FLOAT FDIFFERENCE (OPCODES UBFLOAT2 1][PUTPROPS TIMES DMACRO (APPLY* COMP.NUMERIC TIMES PLUS 0 ((FLOAT FTIMES (OPCODES UBFLOAT2 3](PUTPROPS QUOTIENT DMACRO (APPLY* COMP.NUMBERCALL PLUS))[PUTPROPS FPLUS DMACRO (APPLY* COMP.NUMERIC FPLUS FLOAT NIL ((FLOAT FPLUS (OPCODES UBFLOAT2 0][PUTPROPS FDIFFERENCE DMACRO (APPLY* COMP.NUMBERCALL FLOAT ((FLOAT FDIFFERENCE (OPCODES UBFLOAT2 1][PUTPROPS FTIMES DMACRO (APPLY* COMP.NUMERIC FTIMES FLOAT 0 ((FLOAT FTIMES (OPCODES UBFLOAT2 3][PUTPROPS FQUOTIENT DMACRO (APPLY* COMP.NUMBERCALL FLOAT ((FLOAT FQUOTIENT (OPCODES UBFLOAT2 4][PUTPROPS FABS DMACRO ((X)	   (\FLOATBOX ((OPCODES UBFLOAT1 2)		       (\FLOATUNBOX X](PUTPROPS FGREATERP DMACRO (APPLY* COMP.COMPARENUM FLOAT FGREATERP NIL (OPCODES UBFLOAT2 5)))[PROGN (PUTPROPS FLESSP MACRO [LAMBDA (X Y)				      (FGREATERP Y X])       (PUTPROPS FLESSP DMACRO (APPLY* COMP.COMPARENUM FLOAT FLESSP FGREATERP (OPCODES SWAP UBFLOAT2 										       5][PUTPROPS FREMAINDER DMACRO (APPLY* COMP.NUMBERCALL FLOAT ((FLOAT FREMAINDER (OPCODES UBFLOAT2 8])(DEFINEQ(COMP.NUMERIC  [LAMBDA (A 2FN TYPE ZERO COERSIONS)                        (* lmm "29-Dec-84 11:44")                                                             (* compile call to number function of arbitrary args.							     2FN is holder of opcode. TYPE is FIX, FLOAT, PLUS 							     (NIL-&gt;FIX))                                                             (* ZERO IF GIVEN IS ZERO OF FUNCTION, E.G. 0 FOR TIMES,							     -1 FOR LOGOR)                                                             (* coercions say what to do if compile context is other							     numeric type)    (PROG ((N 0)	   V	   (FN (CAR EXP))	   TMP)          [COND	    ((AND (EQ COMPILE.CONTEXT (QUOTE EFFECT))		  (NOT OPTIMIZATIONSOFF))	      (RETURN (COMP.PROGN A]          (OR 2FN (SETQ 2FN FN))          (SELECTQ (CAR (LISTP COMPILE.CONTEXT))		   [TYPE (COND			   ((AND (NEQ (CDR COMPILE.CONTEXT)				      TYPE)				 (SETQ TMP (FASSOC (CDR COMPILE.CONTEXT)						   COERSIONS)))			     (SETQ TYPE (CAR TMP))			     (SETQ 2FN (CADR TMP]		   [UNBOXED (if (SETQ TMP (CADDR (FASSOC (CDR COMPILE.CONTEXT)							 COERSIONS)))				then (while A					do (COMP.EXPR (pop A)						      COMPILE.CONTEXT)					   (SETQ N (ADD1 N)))				     (FRPTQ (SUB1 N)					    (COMP.STFN TMP 2))				     (RETURN (QUOTE UNBOXED]		   NIL)          (if (AND (SETQ TMP (CADDR (FASSOC TYPE COERSIONS)))		   (FMEMB COMP.UNBOXED.TAG ALLDECLS))	      then (while A		      do (COMP.EXPR (pop A)				    (CONS (QUOTE UNBOXED)					  TYPE))			 (SETQ N (ADD1 N)))		   (FRPTQ (SUB1 N)			  (COMP.STFN TMP 2))		   (RETURN (COMP.FLOATBOX)))          [while A	     do [COMP.EXPR (pop A)			   (CONS (QUOTE TYPE)				 (OR TYPE (SETQ TYPE (QUOTE FIX]		(SETQ N (ADD1 N))		(COND		  ((NOT OPTIMIZATIONSOFF)		    (COMP.DELFIX TYPE)		    (while (OPT.CALLP (CAR CODE)				      2FN)		       do (SETQ N (IPLUS N (CAR (fetch OPARG of (CAR CODE)))					 -1))                (* merge nested arithmetic calls)			  (COMP.DELFN))		    (COND		      ((AND (EQ (fetch OPNAME of (CAR CODE))				(QUOTE CONST))			    (IGREATERP N 0))			[SETQ V (COND			    [V                               (* combine number args)			       (APPLY* FN V (fetch OPARG of (CAR CODE]			    (T                               (* move number constants to end)			       (APPLY* (OR TYPE (FUNCTION FIX))				       (fetch OPARG of (CAR CODE]			(COMP.DELPUSH)			(SETQ N (SUB1 N]          [COND	    (V (COND		 ((EQUAL (APPLY* FN V)			 (APPLY* FN))                        (* I.E., IS UNIT OF FUNCTION: 1 FOR TIMES, ETC)		   )		 ((EQUAL V ZERO)		   (FRPTQ N (COMP.STPOP))		   (RETURN (COMP.STCONST V)))		 ((AND (IGREATERP N 0)		       (MINUSP V)		       (EQ 2FN (QUOTE IPLUS)))               (* turn IPLUS of negative to IDIFFERENCE)		   (COMP.STCONST (IMINUS V))		   (COMP.STFN (QUOTE IDIFFERENCE)			      2))		 (T (COMP.STCONST V)		    (add N 1]          (COND	    ((EQ N 0)                                        (* number function, 0 args)	      (COMP.STCONST (APPLY* FN)))	    ((EQ N 1)                                        (* number fn, 1 arg)	      (COMP.STFIX TYPE))	    (T (FRPTQ (SUB1 N)		      (COMP.STFN 2FN 2])(COMP.NUMBERCALL  [LAMBDA (A TYPE COERSIONS)                                 (* lmm " 9-Mar-85 14:55")    (PROG ((N 0)	   TMP	   (2FN (CAR EXP)))          [COND	    ((AND (EQ COMPILE.CONTEXT (QUOTE EFFECT))		  (NOT OPTIMIZATIONSOFF))	      (RETURN (COMP.PROGN A]          (SELECTQ (CAR (LISTP COMPILE.CONTEXT))		   [TYPE (COND			   ((AND (NEQ (CDR COMPILE.CONTEXT)				      TYPE)				 (SETQ TMP (FASSOC (CDR COMPILE.CONTEXT)						   COERSIONS)))			     (SETQ TYPE (CAR TMP))			     (SETQ 2FN (CADR TMP]		   [UNBOXED (if (SETQ TMP (CADDR (FASSOC (CDR COMPILE.CONTEXT)							 COERSIONS)))				then (while A					do (COMP.EXPR (pop A)						      COMPILE.CONTEXT)					   (SETQ N (ADD1 N)))				     (FRPTQ (SUB1 N)					    (COMP.STFN TMP 2))				     (RETURN (QUOTE UNBOXED]		   NIL)          (if (AND (SETQ TMP (CADDR (FASSOC TYPE COERSIONS)))		   (FMEMB COMP.UNBOXED.TAG ALLDECLS))	      then (while A		      do (COMP.EXPR (pop A)				    (CONS (QUOTE UNBOXED)					  TYPE))			 (SETQ N (ADD1 N)))		   (FRPTQ (SUB1 N)			  (COMP.STFN TMP 2))		   (RETURN (COMP.FLOATBOX)))          (while A	     do (COMP.VAL (pop A))		[COND		  ((NOT OPTIMIZATIONSOFF)		    (COMP.DELFIX TYPE)                       (* remove extraneous FIX, FLOAT calls)		    (COND		      ((AND (NEQ TYPE (QUOTE PLUS))			    (EQ (fetch OPNAME of (CAR CODE))				(QUOTE CONST)))              (* if FIX or FLOAT type and arg is constant, then 							     coerce.)			(COMP.STCONST (APPLY* (OR TYPE (QUOTE FIX))					      (PROG1 (fetch OPARG of (CAR CODE))						     (COMP.DELPUSH]		(SETQ N (ADD1 N)))          [COND	    ((AND (NOT OPTIMIZATIONSOFF)		  (EQ (fetch OPNAME of (CAR CODE))		      (QUOTE CONST))		  (EQ N 2))	      (COND		((EQ (fetch OPNAME of (CAR (fetch PREV of CODE)))		     (QUOTE CONST))		  (COMP.STCONST (PROG1 (APPLY* (CAR EXP)					       (fetch OPARG of (CAR (fetch PREV of CODE)))					       (fetch OPARG of (CAR CODE)))				       (COMP.DELPUSH)				       (COMP.DELPUSH)))		  (RETURN (COMP.STFIX TYPE)))		((FMEMB 2FN (SELECTQ (fetch OPARG of (CAR CODE))				     (0 (QUOTE (IDIFFERENCE LSH RSH LLSH LRSH)))				     (1 (QUOTE (IQUOTIENT)))				     NIL))		  (COMP.DELPUSH)		  (RETURN (COMP.STFIX TYPE]          (RETURN (COMP.STFN 2FN N])(COMP.FIX  [LAMBDA (A)                                                (* lmm "18-APR-80 18:28")    (COMP.VAL1 A)    (COMP.STFIX])(COMP.STFIX  [LAMBDA (TYPE)                                             (* lmm "13-Jul-84 21:18")    (OR TYPE (SETQ TYPE (QUOTE FIX)))    (COND      [[AND (EQ (fetch OPNAME of (CAR CODE))		(QUOTE CONST))	    (NUMBERP (fetch OPARG of (CAR CODE]              (* COMPILE TIME FIX)	(COMP.STCONST (PROG1 (APPLY* TYPE (fetch OPARG of (CAR CODE)))			     (COMP.DELPUSH]      ((AND (EQ TYPE (QUOTE FIX))	    (OPT.CALLP (CAR CODE)		       NUMBERFNS)))      (T (COMP.STFN TYPE 1])(COMP.DELFIX  [LAMBDA (TYPE)                                             (* lmm "16-APR-82 00:19")                                                             (* have compiled call to number function;							     delete any coersions-to-TYPE)    (while (OPT.CALLP (CAR CODE)		      (SELECTQ TYPE			       ((FIX NIL)				 (QUOTE (IPLUS FIX)))			       (FLOAT (QUOTE FLOAT))			       (QUOTE PLUS))		      1)       do (COMP.DELFN]))(PUTPROPS EQ BYTEMACRO COMP.EQ)(PUTPROPS EQUAL BYTEMACRO COMP.EQ)(PUTPROPS EQP BYTEMACRO COMP.EQ)(DEFINEQ(COMP.EQ  [LAMBDA (A)                                                (* lmm " 2-Jan-85 00:23")    (COND      ((EQ COMPILE.CONTEXT (QUOTE EFFECT))	(COMP.PROGN A))      (T (PROG (C)	       (COMP.VAL (pop A))	       [COND		 ((OR OPTIMIZATIONSOFF (NEQ (fetch OPNAME of (CAR CODE))					    (QUOTE CONST)))		   (COMP.PROGLST A 1))		 ([NULL (SETQ C (fetch OPARG of (CAR CODE]   (* (EQ NIL --))		   (COMP.DELPUSH)		   (RETURN (COMP.NOT A)))		 (T (COMP.DELPUSH)		    (COMP.PROGLST A 1)		    (COND		      [(EQ (fetch OPNAME of (CAR CODE))			   (QUOTE CONST))                    (* (EQ CONST CONST))			(RETURN (COMP.STCONST (PROG1 (APPLY* (CAR EXP)							     C							     (fetch OPARG of (CAR CODE)))						     (COMP.DELPUSH]		      (T                                     (* (EQ CONST EXPRESSION))			 (COMP.STCONST C]	       (RETURN (COMP.STFN (COND				    ([AND (EQ (fetch OPNAME of (CAR CODE))					      (QUOTE CONST))					  (LITATOM (fetch OPARG of (CAR CODE]                                                             (* EQ IFF EQUAL)				      (QUOTE EQ))				    (T (CAR EXP)))				  2]))(PUTPROPS .TEST. BYTEMACRO (APPLY COMP.NUMBERTEST))(DEFINEQ(COMP.NUMBERTEST  [LAMBDA (X FORM FLG)                                       (* lmm "13-Jul-84 21:18")    (PROG (EXIT (TEST (SUBPAIR (QUOTE (*))			       (LIST DONOTHING)			       FORM))		A)          (COMP.EXPR X)          (RETURN (SELECTQ (AND (COMP.PREDP COMPILE.CONTEXT)				(fetch OPNAME of COMPILE.CONTEXT))			   ((FJUMP TJUMP NFJUMP)             (* .TEST. in PREDF)			     (COMP.EXPR TEST COMPILE.CONTEXT))			   [NTJUMP (COND				     ((OR (FMEMB (fetch OPNAME of (SETQ A (CAR CODE)))						 (QUOTE (AVAR HVAR GVAR FVAR)))					  (AND (EQ (fetch OPNAME of A)						   (QUOTE SETQ))					       (PROGN (SETQ A (fetch OPARG of A))						      T)))   (* .TEST. VAR in NTJUMP)				       [COMP.EXPR TEST (create JUMP							       OPNAME &larr;(QUOTE FJUMP)							       TAG &larr;(SETQ EXIT (create TAG]				       (COMP.STVAR A)				       (COMP.STJUMP (QUOTE JUMP)						    (fetch (JUMP TAG) of COMPILE.CONTEXT))				       (COMP.STTAG EXIT)				       (RETURN (QUOTE PREDVALUE)))				     (T                      (* .TEST. in NTJUMP PREDF)					(COMP.STCOPY)					[COMP.EXPR TEST (create JUMP								OPNAME &larr;(QUOTE FJUMP)								TAG &larr;(SETQ EXIT (create TAG]					(COMP.STJUMP (QUOTE JUMP)						     (fetch (JUMP TAG) of COMPILE.CONTEXT))					(COMP.STTAG EXIT)					(COMP.STPOP)					(RETURN (QUOTE PREDVALUE]			   (COND			     ((OR (FMEMB (fetch OPNAME of (SETQ A (CAR CODE)))					 (QUOTE (AVAR HVAR GVAR FVAR)))				  (AND (EQ (fetch OPNAME of A)					   (QUOTE SETQ))				       (PROGN (SETQ A (fetch OPARG of A))					      T)))           (* .TEST. VAR not in PREDF)			       [COMP.EXPR TEST (create JUMP						       OPNAME &larr;(QUOTE NFJUMP)						       TAG &larr;(SETQ EXIT (create TAG]			       (COMP.STVAR A)			       (COMP.STTAG EXIT))			     (T                              (* .TEST. not in PREDF)				(COMP.STCOPY)				[COMP.EXPR TEST (create JUMP							OPNAME &larr;(QUOTE TJUMP)							TAG &larr;(SETQ EXIT (create TAG]				(COMP.STPOP)				(COMP.STCONST)				(COMP.STTAG EXIT]))(RPAQQ MAPFNS (MAP MAPC MAPLIST MAPCAR MAPCON MAPCONC SUBSET SOME EVERY NOTANY NOTEVERY))(PUTPROPS MAP BYTEMACRO (APPLY* COMP.MAP))(PUTPROPS MAPC BYTEMACRO (APPLY* COMP.MAP T))(PUTPROPS MAPLIST BYTEMACRO (APPLY* COMP.MAP NIL T))(PUTPROPS MAPCAR BYTEMACRO (APPLY* COMP.MAP T T))(PUTPROPS MAPCON BYTEMACRO (APPLY* COMP.MAP NIL J))(PUTPROPS MAPCONC BYTEMACRO (APPLY* COMP.MAP T J))(PUTPROPS SUBSET BYTEMACRO (APPLY* COMP.MAP T S))(PUTPROPS SOME BYTEMACRO (APPLY* COMP.MAP BOTH NIL TJUMP))(PUTPROPS EVERY BYTEMACRO (APPLY* COMP.MAP BOTH NIL FJUMP T))(PUTPROPS NOTANY BYTEMACRO (APPLY* COMP.MAP BOTH NIL TJUMP T))(PUTPROPS NOTEVERY BYTEMACRO (APPLY* COMP.MAP BOTH NIL FJUMP NIL))(PUTPROPS .DOCOLLECT. BYTEMACRO [(VAL TAIL ITEM)				 (COND [(NOT TAIL)					(SETQ TAIL (SETQ VAL (LIST ITEM]				       (T (FRPLACD TAIL (SETQ TAIL (LIST ITEM])(PUTPROPS .DOJOIN. BYTEMACRO [(VAL TAIL ITEM)			      (AND (LISTP ITEM)				   (COND (TAIL (FRPLACD (SETQ TAIL (LAST TAIL))							ITEM))					 (T (SETQ TAIL (SETQ VAL ITEM])(DEFINEQ(COMP.MAP  [LAMBDA (L CARFLG COLLECT PRED NEG WHILEF)                 (* lmm "18-Sep-84 17:05")                                                             (* compile call to mapping function)    (PROG [(FROMFORM (CAR L))	   (DOF (CADR L))	   (BYF (CADDR L))	   BOUNDVARS BINDVALS F VAL (XARG (QUOTE ($X]          (COMP.PROGLST (CDDDR L)			0)          [COND	    [(COMP.APPLYFNP DOF)	      (SETQ DOF (CADR DOF))	      (COND		((AND (NOT CARFLG)		      (EQ (CAR (LISTP DOF))			  (QUOTE LAMBDA)))                   (* leave DOF alone)		  NIL)		(T (SETQ DOF (LIST (QUOTE LAMBDA)				   XARG				   (CONS DOF (COND					   ([AND (EQ CARFLG (QUOTE BOTH))						 (NOT (AND (COMP.CLEANFNP DOF (QUOTE NARGS))							   (EQ (NARGS DOF)							       1]					     (QUOTE ((CAR $X)						      $X)))					   [CARFLG (QUOTE ((CAR $X]					   (T (QUOTE ($X]	    (T                                               (* map function with computed functional arg)	       (SETQ BINDVALS (LIST DOF FROMFORM))	       [SETQ BOUNDVARS (LIST (QUOTE $F1)				     (SETQ FROMFORM (QUOTE $L]	       (SETQ DOF (LIST (QUOTE LAMBDA)			       XARG			       (SELECTQ CARFLG					(BOTH (QUOTE (APPLY* $F1 (CAR $X)							     $X)))					(NIL (QUOTE (APPLY* $F1 $X)))					(QUOTE (APPLY* $F1 (CAR $X]          [COND	    ((NULL BYF)	      (SETQ BYF (QUOTE CDR)))	    [(COMP.APPLYFNP BYF)                             (* mapping function with BY argument)	      (OR (EQ [CAR (LISTP (SETQ BYF (CADR BYF]		      (QUOTE LAMBDA))		  (SETQ BYF (LIST (QUOTE LAMBDA)				  XARG				  (LIST BYF (QUOTE $X]	    (T                                               (* mapping function with computed BY argument)	       (SETQ BINDVALS (CONS BYF BINDVALS))	       (SETQ BOUNDVARS (CONS (QUOTE $F2)				     BOUNDVARS))	       (SETQ BYF (QUOTE (LAMBDA ($X)					(COND					  ((NULL $F2)					    (CDR $X))					  (T (APPLY* $F2 $X]          [COND	    ((NULL WHILEF)	      (SETQ WHILEF (QUOTE LISTP)))	    [(COMP.APPLYFNP WHILEF)	      (OR (EQ [CAR (LISTP (SETQ WHILEF (CADR WHILEF]		      (QUOTE LAMBDA))		  (SETQ WHILEF (LIST (QUOTE LAMBDA)				     XARG				     (LIST WHILEF (QUOTE $X]	    (T (SETQ BINDVALS (CONS (LIST (QUOTE OR)					  WHILEF					  (QUOTE (QUOTE LISTP)))				    BINDVALS))	       (SETQ BOUNDVARS (CONS (QUOTE $F3)				     BOUNDVARS))	       (SETQ WHILEF (QUOTE (LAMBDA ($X)					   (APPLY* $F3 $X]          [COND	    (COLLECT (push BINDVALS NIL NIL NIL NIL)		     (push BOUNDVARS (SETQ VAL (QUOTE $V))			   (QUOTE $Z)			   (QUOTE $W)			   (QUOTE $X]                        (* bind extra vars)          (SETQ F (COMP.BIND.VARS (OPT.DREV BOUNDVARS)				  (OPT.DREV BINDVALS)				  (QUOTE MAP)))          [PROG ((ALLVARS (APPEND (fetch VARS of F)				  ALLVARS))		 (SPECVARS SPECVARS)		 (LOCALVARS LOCALVARS)		 (LP (create TAG))		 (ENDLP (create TAG))		 (OUT (create TAG))		 NXT)	        (COMP.STBIND F)	        [COMP.EFFECT (QUOTE (DECLARE (LOCALVARS $F1 $F2 $X $V $Z $W $F3]	        (COMP.VAL FROMFORM)	        (OPT.CCHECK (AND (EQ LEVEL 1)				 (EQ FRAME F)))	        (COMP.STJUMP (QUOTE JUMP)			     ENDLP)	        (SETQ LEVEL 1)	        (SETQ FRAME F)	        (COMP.STTAG LP)	        (COMP.STCOPY)	        [COND		  (COLLECT (OPT.CCHECK (NOT PRED))			   (SELECTQ COLLECT				    [(T J)                   (* collect or join)				      (COMP.EFFECT (LIST (QUOTE SETQ)							 (QUOTE $X)							 DONOTHING))				      [COMP.EFFECT (LIST (QUOTE SETQ)							 (QUOTE $W)							 (COND							   ((EQ (CADR DOF)								XARG)							     (CADDR DOF))							   (T (LIST DOF (QUOTE $X]				      (COMP.EFFECT (SELECTQ COLLECT							    (J (QUOTE (.DOJOIN. $V $Z $W)))							    (QUOTE (.DOCOLLECT. $V $Z $W]				    (S                       (* SUBSET)				       [COMP.EXPR (LIST DOF DONOTHING)						  (create JUMP							  OPNAME &larr;(QUOTE FJUMP)							  TAG &larr;(SETQ NXT (create TAG]				       (COMP.STCOPY)				       (COMP.EFFECT (LIST (QUOTE SETQ)							  (QUOTE $W)							  (LIST (QUOTE CAR)								DONOTHING)))				       (COMP.EFFECT (QUOTE (.DOCOLLECT. $V $Z $W)))				       (COMP.STTAG NXT))				    (SHOULDNT)))		  (PRED (COMP.EXPR (LIST DOF DONOTHING)				   (create JUMP					   OPNAME &larr; PRED					   TAG &larr; OUT)))		  (T (COMP.EFFECT (LIST DOF DONOTHING]	        (OPT.CCHECK (EQ LEVEL 1))	        (COMP.EXPR (LIST BYF DONOTHING))             (* get next element)	        (COMP.STTAG ENDLP)	        (COMP.EXPR (LIST WHILEF DONOTHING))	        (COMP.STJUMP (QUOTE NTJUMP)			     LP)	        (COND		  [PRED (COND			  ((AND (EQ PRED (QUOTE TJUMP))				(NULL NEG))			    (COMP.VAL NIL)			    (COMP.STTAG OUT))			  (T (COMP.VAL NEG)			     (COMP.STJUMP (QUOTE JUMP)					  (SETQ NXT (create TAG)))			     (COMP.STTAG OUT)			     (COMP.STPOP)			     (COMP.VAL (NULL NEG))			     (COMP.STTAG NXT]		  (T (COMP.VAL VAL]          (RETURN (COMP.UNBIND.VARS F]))(PUTPROPS LISPXWATCH BYTEMACRO T)(PUTPROPS FETCHFIELD BYTEMACRO T)(PUTPROPS REPLACEFIELD BYTEMACRO T)(PUTPROPS FFETCHFIELD BYTEMACRO (= . FETCHFIELD))(PUTPROPS FREPLACEFIELD BYTEMACRO (= . REPLACEFIELD))(PUTPROPS REPLACEFIELDVAL BYTEMACRO T)(PUTPROPS FREPLACEFIELDVAL BYTEMACRO (= . REPLACEFIELDVAL))(PUTPROPS GETPROP BYTEMACRO (= . GETP))(PUTPROPS BLKAPPLY BYTEMACRO (= . APPLY))(PUTPROPS BLKAPPLY* BYTEMACRO (= . APPLY*))(PUTPROPS ADD1VAR BYTEMACRO ((X)			     (SETQ X (ADD1 X))))(PUTPROPS SUB1VAR BYTEMACRO ((X)			     (SETQ X (SUB1 X))))(PUTPROPS KWOTE BYTEMACRO (OPENLAMBDA (Q)				      (COND ((AND Q (NEQ Q T)						  (NOT (NUMBERP Q)))					     (LIST (QUOTE QUOTE)						   Q))					    (T Q))))(PUTPROPS FRPLNODE BYTEMACRO (OPENLAMBDA (X A D)					 (FRPLACD (FRPLACA X A)						  D)))(PUTPROPS RPLNODE BYTEMACRO (OPENLAMBDA (X A D)					(RPLACD (RPLACA X A)						D)))(PUTPROPS LISTGET1 BYTEMACRO (OPENLAMBDA (X Y)					 (CADR (MEMB Y X))))(PUTPROPS FRPLNODE2 BYTEMACRO (OPENLAMBDA (X Y)					  (FRPLACD (FRPLACA X (CAR Y))						   (CDR Y))))(PUTPROPS JSYS BYTEMACRO COMP.PUNT)(PUTPROPS EQMEMB BYTEMACRO (OPENLAMBDA (X Y)				       (OR (EQ X Y)					   (AND (LISTP Y)						(FMEMB X Y)						T))))(PUTPROPS MKLIST BYTEMACRO [OPENLAMBDA (X)				       (OR (LISTP X)					   (AND X (LIST X])(* Pass 1 listing)(DEFINEQ(COMP.MLLIST  [LAMBDA (FN CC)                                            (* lmm: "13-NOV-76 06:56:28")    (RESETLST (RESETSAVE (RADIX 10))	      (RESETSAVE (LINELENGTH 72))	      (PRIN2 FN)	      (MAPRINT (fetch ARGS of CC)		       NIL "(" ")" " " (FUNCTION COMP.MLLVAR))	      (SPACES 5)	      [PRINT (CDR (FASSOC (fetch COMTYPE of CC)				  (QUOTE ((0 . LAMBDA)					   (2 . LAMBDA*)					   (1 . NLAMBDA)					   (2 . NLAMBDA*)					   (NIL . ???]	      (COMP.MLL (fetch CODE of CC])(COMP.MLL(LAMBDA (LL) (* lmm " 8-MAY-81 23:29") (for X in LL do (if (type? TAG X) then (if (NOT (ZEROP (POSITION))) then (TERPRI)) (PRIN2 (fetch (TAG LBNO) of X)) (PRIN1 (QUOTE :)) else (PROG ((S (GETPROP (fetch OPNAME of X) (QUOTE MLSYM))) (P (POSITION))) (if (ILESSP P 5) then (SPACES (IDIFFERENCE 6 P)) elseif (IGREATERP P 60) then (TERPRI) (SPACES 6) else (SPACES 1)) (AND (CAR S) (PRIN1 (CAR S))) (SELECTQ (CDDR S) (CONST (PRIN2 (fetch OPARG of X))) (VAR (COMP.MLLVAR X)) (FN (* FN and LINKEDFN) (COMP.MLLFN X)) (VREF (* SETQ ARG) (COMP.MLLVAR (fetch OPARG of X))) (JUMP (PRIN2 (fetch (TAG LBNO) of (fetch (JUMP TAG) of X)))) (BIND (PROG (NN N (F (CDR (fetch OPARG of X)))) (SETQ N (SETQ NN (fetch NVALS of F))) (for V in (fetch VARS of F) do (PRIN1 (if (EQ N NN) then (* 1st one) "" elseif (ZEROP N) then (QUOTE ;) else (QUOTE ,))) (SETQ N (IPLUS N -1)) (COMP.MLLVAR V)) (if (ZEROP N) then (* All val-bound) (PRIN1 ";")))) (UNBIND (PRIN1 (CAR (fetch OPARG of X)))) (PROGN (PRIN1 (fetch OPNAME of X)) (AND (fetch OPARG of X) (PRIN1 (LIST (fetch OPARG of X)))))) (AND (CADR S) (PRIN1 (CADR S)))))) (TERPRI) (TERPRI)))(COMP.MLLVAR  [LAMBDA (X N)                                              (* lmm "30-AUG-83 10:48")    (SETQ N (fetch (VAR VARNAME) of X))    (PRIN2 (SELECTQ (fetch OPNAME of X)		    (HVAR (PRIN1 "@")			  N)		    (XVAR (QUOTE XVAR))		    N])(COMP.MLLFN  [LAMBDA (X FN)                                             (* lmm "27-OCT-81 20:26")    [PRIN2 (SETQ FN (CDR (fetch OPARG of X]    (SETQ X (CAR (fetch OPARG of X)))    (AND (LITATOM FN)	 (OR (AND (ZEROP (ARGTYPE FN))		  (EQ (NARGS FN)		      X))	     (PROGN (SPACES 1)		    (PRIN2 X]))(RPAQQ COPS (BIND UNBIND DUNBIND ERRORSET JUMP TJUMP FJUMP NTJUMP NFJUMP POP COPY RETURN TAG FN CONST 		  SETQ AVAR HVAR GVAR FVAR STORE))(PUTPROPS BIND MLSYM ("BIND[" %] . BIND))(PUTPROPS UNBIND MLSYM ("UNBIND(" %) . UNBIND))(PUTPROPS DUNBIND MLSYM ("DUNBIND(" %) . UNBIND))(PUTPROPS ERRORSET MLSYM ("ERRORSET " % . JUMP))(PUTPROPS JUMP MLSYM ("JUMP " % . JUMP))(PUTPROPS TJUMP MLSYM ("TJUMP " % . JUMP))(PUTPROPS FJUMP MLSYM ("FJUMP " % . JUMP))(PUTPROPS NTJUMP MLSYM ("NTJUMP " % . JUMP))(PUTPROPS NFJUMP MLSYM ("NFJUMP " % . JUMP))(PUTPROPS FN MLSYM (%[ %] . FN))(PUTPROPS CONST MLSYM ("'" NIL . CONST))(PUTPROPS SETQ MLSYM ("SETQ&lt;" &gt; . VREF))(PUTPROPS AVAR MLSYM (&lt; &gt; . VAR))(PUTPROPS HVAR MLSYM (&lt; &gt; . VAR))(PUTPROPS GVAR MLSYM (&lt; &gt; . VAR))(PUTPROPS FVAR MLSYM (&lt; &gt; . VAR))(* ARJ - JUMP LENGTH RESOLVER)(DEFINEQ(OPT.RESOLVEJUMPS  [LAMBDA (JL PROP FN)                                       (* lmm "19-JUL-80 10:00")    (PROG ((CU 0)	   Z NEW)          [for X in JL	     do (replace JSN of X with (fetch JMIN of X))		(COND		  [(fetch JPT of X)                          (* Jump)		    (SETQ Z (CAR (GETPROP (fetch OPNAME of (CAR (fetch JPT of X)))					  PROP)))		    (replace JML of X with (CAR Z))		    (add CU (replace JU of X with (IDIFFERENCE (CDR Z)							       (CAR Z]		  (T                                         (* Tag)		     (replace JU of X with CU]          (while (LISTP (SETQ NEW (OPT.JLENPASS JL PROP))) do (SETQ JL NEW))          (COND	    (NEW (OPT.JFIXPASS JL FN])(OPT.JLENPASS  [LAMBDA (JL PROP)                                          (* lmm "19-JUL-80 10:08")    (PROG ((INC 0)	   (DEC 0)	   (CU 0)	   X U U1 DEF MIN ML SMIN SMAX)          (* JPT is NIL (for tags) or a pointer into ACODE (for jumps). JMIN is the lowest possible location for the 	  instruction or tag. JU is the cumulative uncertainty (for tags) or the length uncertainty 	  (for jumps). JML is the minimum length (for jumps). JSN is a serial number (the original JMIN) used to decide 	  whether a jump goes forward or backward.)          (* In the loop, CU is the cumulative uncertainty, DEC is the cumulative decrease in uncertainty, and INC is the 	  cumulative increase in minimum location.)          [for J in JL	     do (SETQ X (CAR (fetch JPT of J)))		(add (fetch JMIN of J)		     INC)		(COND		  ((NULL X)		    (SETQ DEC (IDIFFERENCE CU (fetch JU of J)))		    (replace JU of J with CU))		  ((NEQ (SETQ U (fetch JU of J))			0)		    [SETQ DEF (fetch (TAG JD) of (CAR (fetch OPARG of X]		    (SETQ MIN (IDIFFERENCE (fetch JMIN of DEF)					   (fetch JMIN of J)))		    (SETQ SMAX (OPT.JSIZE X (IPLUS (IDIFFERENCE (fetch JU of DEF)								CU)						   (COND						     ((IGREATERP (fetch JSN of DEF)								 (fetch JSN of J))						       (IPLUS (SETQ MIN (IPLUS MIN INC))							      DEC))						     (T MIN)))					  PROP))		    (SETQ SMIN (OPT.JSIZE X MIN PROP))		    [COND		      ((NEQ SMIN (SETQ ML (fetch JML of J)))			(replace JML of J with SMIN)			(add INC (IDIFFERENCE SMIN ML]		    (COND		      ((NEQ (SETQ U1 (IDIFFERENCE SMAX SMIN))			    U)			[COND			  ((ILESSP U1 0)			    (OPT.COMPILERERROR (QUOTE (U1 negative]			(add DEC (IDIFFERENCE U1 U))			(replace JU of J with U1)))		    (add CU U1]          (RETURN (COND		    ((AND (NEQ DEC 0)			  (NEQ CU 0))		      JL)		    (T T])(OPT.JFIXPASS  [LAMBDA (JL FN)                                            (* lmm "19-JUL-80 10:23")    (PROG (X)          (for J in JL do (COND			    ([NULL (SETQ X (CAR (fetch JPT of J]			      (replace JU of J with 0))			    (T (APPLY* FN (fetch JPT of J)				       (IDIFFERENCE [fetch JMIN						       of (fetch (TAG JD)							     of (CAR (fetch OPARG of X]						    (fetch JMIN of J])(OPT.JSIZE  [LAMBDA (OP D FN)                                          (* lmm "27-OCT-81 20:28")    (PROG [(Z (CDR (GETPROP (fetch OPNAME of OP)			    FN]      LP  (COND	    ((NLISTP Z)	      (RETURN Z))	    (T [SETQ Z (COND		   ((ILESSP D (CAR Z))		     (CADR Z))		   (T (CDDR Z]	       (GO LP]))(* utilities used by all files)(DEFINEQ(OPT.CALLP  [LAMBDA (OP FN N)                                          (* lmm: "22-JUL-77 02:40")    (AND (EQ (fetch OPNAME of OP)	     (QUOTE FN))	 (OR (NULL N)	     (EQ (CAR (fetch OPARG of OP))		 N))	 (OR (NULL FN)	     (EQ (CDR (fetch OPARG of OP))		 FN)	     (AND (LISTP FN)		  (FMEMB (CDR (fetch OPARG of OP))			 FN])(OPT.JUMPCHECK  [LAMBDA (C)                                                (* lmm: "22-JUL-77 02:39")    (SELECTQ (fetch OPNAME of (CAR C))	     ((JUMP RETURN)	       T)	     NIL])(OPT.DREV  [LAMBDA (L Z)    (PROG (Y)      R1  (COND	    ((NLISTP (SETQ Y L))	      (RETURN Z)))          (SETQ L (CDR L))          (SETQ Z (FRPLACD Y Z))          (GO R1])(OPT.CHLEV  [LAMBDA (N)                                                (* lmm "14-MAR-81 09:54")    (COND      (LEVEL (PROG1 (add LEVEL N)		    (OPT.CCHECK (IGEQ LEVEL 0])(OPT.CHECKTAG  [LAMBDA (TAG TAGFLAG)                                      (* lmm "14-MAR-81 09:15")    (COND      ((NULL LEVEL)	(replace (TAG LEVEL) of TAG with NIL))      ((NULL (fetch (TAG LEVEL) of TAG))	(AND TAGFLAG (SETQ LEVEL NIL)))      (T (OPT.CCHECK (EQ LEVEL (fetch (TAG LEVEL) of TAG)))	 T])(OPT.NOTJUMP  [LAMBDA (X)                                                (* lmm: "22-JUL-77 03:39")    (PROG NIL          (RETURN (create OP			  OPNAME &larr;(OR (SELECTQ (fetch OPNAME of X)					       (FJUMP (QUOTE TJUMP))					       (TJUMP (QUOTE FJUMP))					       NIL)				      (RETURN))			  OPARG &larr;(fetch OPARG of X])(OPT.INITHASH  [NLAMBDA (X)                                               (* rmk: " 3-Jan-84 13:18")    (COND      ([OR (HARRAYP (EVALV X))	   (HARRAYP (CAR (LISTP (EVALV X]	(CLRHASH (EVALV X)))      (T (SET X (HASHARRAY 100])(OPT.COMPINIT  [LAMBDA NIL                                                (* lmm: "22-JUL-77 16:51")    [MAPC (QUOTE ((OPRETURN . RETURN)		   (OPPOP . POP)		   (OPCOPY . COPY)		   (OPNIL . CONST)))	  (FUNCTION (LAMBDA (X)	      (SET (CAR X)		   (create OP			   OPNAME &larr;(CDR X]    (SETQ DONOTHING (LIST (QUOTE AC]))(MOVD? (QUOTE NILL)       (QUOTE REFRAME))(AND (GETD (QUOTE OPT.COMPINIT))     (OPT.COMPINIT))(PUTPROPS LOADTIMECONSTANT BYTEMACRO (= . DEFERREDCONSTANT))(PUTPROPS FRPTQ BYTEMACRO OPT.CFRPTQ)(DEFINEQ(OPT.CFRPTQ  [LAMBDA (L)                                                (* lmm "29-Jun-84 08:25")    (COND      ((EQ COMPILE.CONTEXT (QUOTE EFFECT))	(PROG ((END (create TAG))	       (ST (create TAG)))	      (COMP.VAL (CAR L))                             (* counter)	      (COMP.STTAG ST)	      (COMP.STCOPY)	      (COMP.VAL 0)	      (COMP.STFN (QUOTE IGREATERP)			 2)	      (COMP.STJUMP (QUOTE FJUMP)			   END)	      (COMP.VALN (CDR L)			 (QUOTE EFFECT))	      (COMP.VAL 1)	      (COMP.STFN (QUOTE IDIFFERENCE)			 2)	      (COMP.STJUMP (QUOTE JUMP)			   ST)	      (COMP.STTAG END)))      (T (COMP.EXP1 (CONS (QUOTE RPTQ)			  L]))(DECLARE: EVAL@COMPILE DONTCOPY (DECLARE: DOEVAL@COMPILE DONTCOPY(SPECVARS AC ALAMS1 ALLVARS ARGS ARGVARS BLKDEFS BLKFLG CODE COMFN COMFNS COMTYPE CONSTS EMFLAG EXP 	  FRAME FREELST FREEVARS LAPFLG LBCNT LEVEL LOCALVARS LOCALVARS LSTFIL MACEXP NLAMS1 PIFN 	  COMPILE.CONTEXT PROGCONTEXT RETURNLABEL SPECVARS SPECVARS SUBFNFREEVARS TAGS TOPFN TOPFRAME 	  TOPLAB VARS INTERNALBLKFNS))(DECLARE: DOEVAL@COMPILE DONTCOPY(SPECVARS PLVLFILEFLG)))(PUTPROPS IMAX2 BYTEMACRO (OPENLAMBDA (X Y)				      (COND ((NOT (IGREATERP X Y))					     Y)					    (T X))))(PUTPROPS IMIN2 BYTEMACRO (OPENLAMBDA (X Y)				      (COND ((IGREATERP X Y)					     Y)					    (T X))))(PUTPROPS AREF BOGUSMACRO COMP.AREF)(PUTPROPS ASET BOGUSMACRO COMP.ASET)(PUTPROPS FLOAT BOX (\FLOATBOX . \FLOATUNBOX))(DEFINEQ(COMP.AREF  [LAMBDA (A)                                                (* raf "18-Jun-85 17:52")    (PROG (DECL)          [COND	    ([AND (LITATOM (CAR A))		  (EQ [CAR (SETQ DECL (CDR (FASSOC (COMP.LOOKUPVAR (CAR A))						   ALLDECLS]		      (QUOTE ARRAY))		  (EQ (LENGTH (MKLIST (CADDR DECL)))		      (LENGTH (CDR A]	      (COND		((EQUAL (CADR DECL)			(QUOTE (BYTE 16)))		  (RETURN (COMP.EXPR (CONS (QUOTE \16AREF)					   A)				     COMPILE.CONTEXT)))		((FMEMB (CADR DECL)			(QUOTE (FLOATP FLONUM)))		  (RETURN (COMP.EXPR (CONS (QUOTE \LAREF)					   A)				     COMPILE.CONTEXT)))		(T (HELP]          (MAPC A (FUNCTION COMP.VAL))          (COMP.STFN (SELECTQ (LENGTH A)			      (2 (QUOTE \AREF.1))			      (3 (QUOTE \AREF.2))			      (QUOTE AREF))		     (LENGTH A])(COMP.ASET  (LAMBDA (A)                                                (* kbr: "12-Mar-85 17:08")    (PROG (DECL)          (COND	    ((AND (LITATOM (CADR A))		  (EQ (CAR (SETQ DECL (CDR (FASSOC (COMP.LOOKUPVAR (CADR A))						   ALLDECLS))))		      (QUOTE ARRAY))		  (EQ (LENGTH (MKLIST (CADDR DECL)))		      (LENGTH (CDDR A))))	      (COND		((EQUAL (CADR DECL)			(QUOTE (BYTE 16)))		  (RETURN (COMP.EXPR (CONS (QUOTE \16ASET)					   A)				     COMPILE.CONTEXT)))		((FMEMB (CADR DECL)			(QUOTE (FLOATP FLONUM)))		  (RETURN (COMP.EXPR (CONS (QUOTE \LASET)					   A)				     COMPILE.CONTEXT)))		(T (HELP)))))          (MAPC A (FUNCTION COMP.VAL))          (COMP.STFN (SELECTQ (LENGTH A)			      (3 (QUOTE \ASET.1))			      (4 (QUOTE \ASET.2))			      (QUOTE ASET))		     (LENGTH A)))))(COMP.BOX  [LAMBDA (TYPE)                                             (* lmm " 1-Jul-84 17:45")    (PROG [(BOXER (AND (LITATOM TYPE)		       (GETPROP TYPE (QUOTE BOX]          (if BOXER	      then (if (OPT.CALLP (CAR CODE)				  (CDR BOXER)				  1)		       then                                  (* top of stack was (unbox value), just get rid of BOX)			    (COMP.DELFN)			    (COMP.STFIX TYPE)		     else (COMP.STFN (CAR BOXER)				     1])(COMP.LOOKFORDECLARE  [LAMBDA (EXPS)                                             (* lmm " 1-Jul-84 16:54")    (while (EQ (CAR (LISTP (CAR EXPS)))	       COMMENTFLG)       do (pop EXPS))    (if (EQ (CAR (LISTP (CAR EXPS)))	    (QUOTE DECLARE))	then (for Y in (CDAR EXPS) bind DECLS		do (SELECTQ (CAR Y)			    [TYPE (for Z in (CDDR Y) do (push DECLS (CONS Z (COMP.DECLARETYPE									    (CADR Y]			    NIL)		finally (RETURN DECLS])(COMP.DECLARETYPE  [LAMBDA (X)                                                (* lmm "13-Jul-84 22:19")                                                             (* returns a valid compile context, too)    (SELECTQ X	     ((FLOATING FLOATP FLOAT)                        (* if you declare a variable to be FLOAT, you are really							     saying to hold it "unboxed")	       (QUOTE (UNBOXED . FLOAT)))	     (if (LISTP X)		 then (SELECTQ (CAR X)			       (ARRAY X)			       NIL])(COMP.FLOATBOX  [LAMBDA NIL                                                (* lmm "28-Jun-84 15:09")    (COND      ((OPT.CALLP (CAR CODE)		  (QUOTE \FLOATUNBOX)		  1)	(COMP.DELFN))      (T (COMP.STFN (QUOTE \FLOATBOX)		    1])(COMP.FLOATUNBOX  [LAMBDA NIL                                                (* lmm "28-Jun-84 15:08")    (PROGN (COMP.DELFIX (QUOTE FLOAT))	   (COND	     ((OPT.CALLP (CAR CODE)			 (QUOTE \FLOATBOX)			 1)	       (COMP.DELFN))	     [[AND (EQ (fetch OPNAME of (CAR CODE))		       (QUOTE CONST))		   (NUMBERP (fetch OPARG of (CAR CODE]	       (PROG [(NUM (fetch OPARG of (CAR CODE]		     (COMP.DELPUSH)		     (if (EQUAL (SETQ NUM (FLOAT NUM))				0)			 then (COMP.STCONST NIL)		       else (COMP.EXPR (BQUOTE (\VAG2 , (fetch (FLOATP HIWORD) of NUM)						      ,						      (fetch (FLOATP LOWORD) of NUM]	     (T (COMP.STFN (QUOTE \FLOATUNBOX)			   1])(COMP.PREDP  [LAMBDA (CTX)                                              (* lmm "29-Jun-84 08:30")    (AND (LISTP CTX)	 (FMEMB (CAR CTX)		(QUOTE (TJUMP FJUMP NTJUMP NFJUMP])(COMP.UBFLOAT2  [LAMBDA (A OP)                                             (* lmm "29-Jun-84 09:07")    (PROG ((N 0))          [COND	    ((AND (EQ COMPILE.CONTEXT (QUOTE EFFECT))		  (NOT OPTIMIZATIONSOFF))	      (RETURN (COMP.PROGN A]          (while A	     do (COMP.VAL (pop A))		(COMP.FLOATUNBOX)		(SETQ N (ADD1 N)))          (FRPTQ (SUB1 N)		 (COMP.STFN (LIST (QUOTE OPCODES)				  (QUOTE UBFLOAT2)				  OP)			    1))          (COMP.FLOATBOX])(COMP.UNBOX  [LAMBDA (TYPE)                                             (* lmm "29-Dec-84 11:46")    (PROG [(BOXER (AND (LITATOM TYPE)		       (GETPROP TYPE (QUOTE BOX]          (if BOXER	      then (COND		     ((OPT.CALLP (CAR CODE)				 (CAR BOXER)				 1)                          (* top of stack was (box value), just get rid of BOX)		       (COMP.DELFN))		     ((EQ TYPE (QUOTE FLOAT))		       (COMP.FLOATUNBOX))		     (T (HELP)                               (* if top of stack is (convert-type value) then get rid							     of convert-type before putting in unbox)			(COMP.DELFIX TYPE)			(COMP.STFN (CDR BOXER)				   1)))	    else (HELP "CAN'T UNBOX" TYPE]))(ADDTOVAR COMPILETYPELST )(* POST OPTIMIZATION)(DEFINEQ(OPT.POSTOPT  [LAMBDA (CODE)                                             (* lmm "29-Dec-84 20:48")    (COND      [OPTIMIZATIONSOFF (while CODE bind C VAL			   do (SETQ TAGS NIL)			      (while (EQ (fetch OPNAME of (SETQ C (pop CODE)))					 (QUOTE TAG))				 do (push TAGS C))			      (while (AND (EQ (fetch OPNAME of C)					      (QUOTE JUMP))					  (FMEMB (fetch OPARG of C)						 TAGS))				 do (SETQ C (pop CODE)))			      (for TAG in TAGS do (push VAL TAG))			      (push VAL C)			   finally (RETURN (CDR VAL]      (T (PROG ((FRAME TOPFRAME)		LABELS ANY (FRAMES (LIST (LIST TOPFRAME)))		(PASS 1)		DELETEDBINDS)	       (SETQ CODE (CONS NIL (NCONC1 CODE NIL)))	       (OPT.SETUPOPT)	   OPTLP	       (SETQ ANY)                                    (* optimization pass)	       (AND (OPT.FRAMEOPT (EQ PASS 1))		    (SETQ ANY T))	       (OPT.SCANOPT)	       (OPT.JUMPOPT)	       (OPT.RETOPT)	       (OPT.CCHECK (OPT.OPTCHECK))	       [COND		 ((NOT ANY)		   (AND [NOT (OR (AND XVARFLG (PROGN (OPT.XVARSCAN)						     (OPT.FRAMEOPT T NIL T)))				 (AND MERGEFRAMEFLG (OPT.FRAMEOPT T T XVARFLG]			(RETURN (CDR (OPT.DREV (CDR CODE]	       (SETQ PASS (ADD1 PASS))	       (BLOCK)	       (GO OPTLP])(OPT.SETUPOPT  [LAMBDA NIL                                                (* lmm: "22-JUL-77 02:59")                                                             (* set up code list as doubly linked list, scan for 							     tags)    (PROG ((C CODE)	   P B)      LPC (COND	    ((NULL C)	      (RETURN)))          (SELECTQ (fetch OPNAME of (CAR C))		   [TAG (COND			  ((SETQ B (FASSOC (CAR C)					   LABELS))			    (FRPLACA (CDR B)				     C))			  (T (SETQ LABELS (CONS (LIST (CAR C)						      C)						LABELS]		   [(JUMP TJUMP FJUMP NTJUMP NFJUMP ERRORSET)		     (COND		       ((SETQ B (FASSOC (fetch (JUMP TAG) of (CAR C))					LABELS))			 (NCONC1 B C))		       (T (SETQ LABELS (CONS (LIST (fetch (JUMP TAG) of (CAR C))						   NIL C)					     LABELS]		   NIL)          (SELECTQ (fetch OPNAME of (CAR C))		   [(ERRORSET BIND)		     (COND		       ((SETQ B (FASSOC (CDR (fetch OPARG of (CAR C)))					FRAMES))			 (RPLACA (CDR B)				 C))		       (T (SETQ FRAMES (CONS (LIST (CDR (fetch OPARG of (CAR C)))						   C)					     FRAMES]		   [(UNBIND DUNBIND)		     (COND		       ((SETQ B (FASSOC (CDR (fetch OPARG of (CAR C)))					FRAMES))			 (NCONC1 B C))		       (T (SETQ FRAMES (CONS (LIST (CDR (fetch OPARG of (CAR C)))						   NIL C)					     FRAMES]		   NIL)          (SETQ B (CDR C))          (replace PREV of C with B)          (replace NXT of C with P)          (SETQ P C)          (SETQ C B)          (GO LPC])(OPT.SCANOPT  [LAMBDA NIL                                                (* lmm "29-Apr-85 19:26")    (PROG ((CD CODE)	   A B P X Y)      LP  (SETQ B (fetch PREV of CD))          [AND P (OPT.CCHECK (EQ CD (fetch PREV of P]          (SELECTQ (fetch OPNAME of (SETQ A (CAR CD)))		   (CONST (COND			    ((AND (OPT.CALLP (CAR P)					     NIL 1)				  (OR (FMEMB [SETQ X (CDR (fetch OPARG of (CAR P]					     CONSTFNS)				      (FMEMB X VCONDITIONALS)				      (FMEMB X CONDITIONALS)))                                                             (* CONST FN.1 -&gt; (FN CONST))			      [RPLACA CD (create OP						 OPNAME &larr;(QUOTE CONST)						 OPARG &larr;(APPLY* X (fetch OPARG of A]			      (OPT.PRDEL P)			      (GO BLP))			    ([AND (SETQ A (FASSOC (fetch OPARG of A)						  CONST.FNS))				  (SOME (CDR A)					(FUNCTION (LAMBDA (X)					    (OPT.CALLP (CAR P)						       (CAR (SETQ A (CDR X)))						       (CAR X]                                                             (* constant + fn -&gt; otherfn)			      (OPT.PRDEL CD)			      (OPT.PRDEL P)			      [MAPC (CDR A)				    (FUNCTION (LAMBDA (X)					(SETQ B (OPT.PRATTACH (create OP								      OPNAME &larr;(CAR X)								      OPARG &larr;(CDR X))							      B]			      (GO BLP)))			  (GO CHECKPUSH))		   (HVAR (GO CHECKPUSH))		   ((AVAR GVAR FVAR)		     (GO CHECKPUSH))		   [SETQ (COND			   ((EQ (fetch OPARG of A)				(CAR B))                     (* want OPT.EQVALUE B CD execept OPT.EQVALUE takes the 							     wrong kind of arg)                                                             (* var (setq var) =&gt; var)			     (OPT.PRDEL CD)			     (GO BLP))			   ((OPT.DEADSETQP (fetch OPARG of A)					   P)                (* delete dead SETQ)			     (OPT.PRDEL CD)			     (GO BLP]		   (POP (SELECTQ (fetch OPNAME of (CAR B))				 ((AVAR HVAR FVAR GVAR COPY CONST)                                                             (* push POP deleted)				   (OPT.PRDEL B)				   (OPT.PRDEL CD)				   (SETQ B P)				   (GO BLP))				 [FN (COND				       ((COMP.CLEANFNOP (CDR (fetch OPARG of (CAR B)))							(QUOTE NOSIDE))                                                             (* cleanfn POP deleted)					 (RPTQ (PROG1 (CAR (fetch OPARG of (CAR B)))						      (OPT.PRDEL B)						      (OPT.PRDEL CD)						      (SETQ B (fetch PREV of P)))					       (SETQ B (OPT.PRATTACH OPPOP B)))					 (GO BLP]				 [SETQ (COND					 ([EQUAL (CAR (fetch PREV of B))						 (CONSTANT (create OP								   OPNAME &larr;(QUOTE COPY]                                                             (* COPY SETQ POP -&gt; SETQ)					   (OPT.PRDEL (fetch PREV of B))					   (OPT.PRDEL CD)					   (SETQ B P)					   (GO BLP]				 NIL))		   [DUNBIND (COND			      ((AND COMPILE.DUNBIND.POP.MERGE.FLG (EQ (CAR B)								      OPPOP))                                                             (* merge pop with DUNBIND)				(OPT.PRDEL B)                (* (DUNBIND level . frame))				[RPLACA (fetch OPARG of (CAR CD))					(ADD1 (CAR (fetch OPARG of (CAR CD]				(GO ALP]		   [UNBIND (COND			     ((SELECTQ (fetch OPNAME of (CAR B))				       [CONST                (* CONST UNBIND)					      (replace OPNAME of A with (QUOTE DUNBIND))                                                             (* change to DUNBIND)                                                             (* level is 1 less)					      (RPLACA (fetch OPARG of A)						      (SUB1 (CAR (fetch OPARG of A]				       (FN (COND					     ((AND (EQ (CAR (fetch OPARG of (CAR B)))						       1)						   (COMP.CLEANFNOP (CDR (fetch OPARG									   of (CAR B)))								   (QUOTE FREEVARS)))                                                             (* clean FN UNBIND)					       T)))				       NIL)			       (RPLACA CD (CAR B))			       (RPLACA B A)                  (* switch CONST and DUNBIND)			       (RPLACA (MEMB CD (CDDR (FASSOC (CDR (fetch OPARG of A))							      FRAMES)))				       B)			       (GO BLP]		   NIL)      TAG2(COND	    ((NULL B)	      (RETURN)))          (SETQ P CD)          (SETQ CD B)          (GO LP)      BLP (SETQ CD B)      CLP (SETQ P (fetch NXT of CD))      ALP (SETQ ANY T)          (GO LP)      CHECKPUSH          (AND NEWOPTFLG (SELECTQ (fetch OPNAME of (CAR B))				  [POP (COND					 ((OPT.EQVALUE (fetch PREV of B)						       CD)   (* X POP X)					   (OPT.PRDEL CD)					   (OPT.PRDEL B)					   (SETQ CD (fetch PREV of P))					   (GO ALP]				  NIL))          [COND	    (NEWOPTFLG (COND			 ((SETQ X (OPT.JUMPCOPYTEST CD B))   (* can insert COPY at X and then delete CD)			   (SETQ X (OPT.DELCOPYFN P X))			   (SETQ P (fetch NXT of CD))			   [COND			     ((EQ X (fetch PREV of CD))			       (OPT.PRDEL CD))			     (T (FRPLACA CD (QUOTE (SWAP]			   (OPT.PRATTACH OPCOPY X)			   (SETQ CD (fetch PREV of P))			   (GO ALP)))		       (COND			 ((AND (SETQ X (OPT.SKIPPUSH B 1 CD T))			       (SETQ X (OPT.JUMPCOPYTEST CD X)))			   (SETQ X (OPT.DELCOPYFN P X))			   (OPT.PRATTACH OPCOPY X)			   (FRPLACA CD (QUOTE (SWAP)))			   (GO ALP)))		       (GO TAG2))	    (T (COND		 ((OPT.EQVALUE B CD)                         (* val val -&gt; val COPY)		   (FRPLACA CD OPCOPY))		 ((EQ (CAR B)		      OPPOP)		   (COND		     ((OPT.EQVALUE (fetch PREV of B)				   CD)                       (* SETQ POP PUSH)		       (OPT.PRDEL CD)		       [OPT.PRDEL (PROG1 B (SETQ CD (fetch PREV of B]		       (GO ALP]          (GO TAG2])(OPT.XVARSCAN  [LAMBDA NIL                                                (* rmk: " 2-Apr-85 12:44")    (PROG ((CD CODE)	   A)          [for X in FRAMES do (replace NOXVAR of (CAR X) with (NEQ NIL (OASSOC (QUOTE AVAR)									       (fetch VARS										  of (CAR X]      LP  (SELECTQ (fetch OPNAME of (SETQ A (CAR CD)))		   (HVAR (AND (NOT (FMEMB A (FETCH VARS OF TOPFRAME)))			      (OPT.XVARSCAN1 A CD)))		   [SETQ (SETQ A (fetch OPARG of A))			 (COND			   ((EQ (fetch OPNAME of A)				(QUOTE HVAR))			     (OPT.XVARSCAN1 A CD]		   ((UNBIND DUNBIND)		     (OR (OPT.CODELEV CD 0)			 (replace NOXVAR of (CDR (fetch OPARG of A)) with T)))		   NIL)          (COND	    ((NULL (SETQ CD (fetch PREV of CD)))	      (RETURN)))          (GO LP])(OPT.XVARSCAN1  [LAMBDA (A CD)                                             (* rmk: " 2-Apr-85 12:03")    (PROG ((FR (OPT.CODEFRAME CD)))          (OR FR (OPT.COMPILERERROR))          (COND	    ((FMEMB A (fetch VARS of FR))	      (RETURN)))      LP  (SETQ FR (fetch PARENT of FR))          (COND	    ((FMEMB A (fetch VARS of FR))	      (replace NOXVAR of FR with T)	      (RETURN)))          (COND	    ((EQ FR TOPFRAME)                                (* can't find A)	      (OPT.COMPILERERROR)))          (GO LP])(OPT.JUMPOPT  [LAMBDA NIL                                                (* lmm "11-NOV-81 21:17")    (MAPC LABELS (FUNCTION (LAMBDA (X)	      (COND		((CADR X)                                    (* Label defined)		  (COND		    ((OR (OPT.JUMPTHRU (CAR X)				       (CDR X))			 (OPT.JUMPREV (CAR X)				      (CDR X)))		      (SETQ ANY T])(OPT.JUMPTHRU  [LAMBDA (TAG OPT.DEFREFS)                                  (* lmm "13-Jul-84 21:18")    (PROG ((DR OPT.DEFREFS)	   P APD ALST ANY INFO Y REF BR END (DEF (CAR OPT.DEFREFS))	   PD B (FRAME (fetch (TAG FRAME) of TAG))	   (LEVEL (fetch (TAG LEVEL) of TAG)))      LQ  (while [OR [type? TAG (SETQ APD (CAR (fetch PREV of DEF]		     (type? TAG (SETQ APD (CAR (SETQ PD (fetch NXT of DEF]	     do                                              (* two adjacent tags -							     merge them)		(OPT.LBMERGE TAG APD))          [COND	    ((NULL (CDR DR))                                 (* tag which is not reference;							     delete it)	      (RETURN (OPT.LBDEL TAG]          [COND	    [(EQ APD OPNIL)                                  (* instruction after the tag is NIL)	      (SETQQ ALST ((FJUMP NFJUMP . OPNIL]	    (T (SETQ ALST (SELECTQ (fetch OPNAME of APD)				   [JUMP (QUOTE ((JUMP)						  (TJUMP)						  (FJUMP)						  (NTJUMP)						  (NFJUMP]				   [TJUMP (QUOTE ((NTJUMP TJUMP)						   (NFJUMP FJUMP . 1]				   [FJUMP (QUOTE ((NTJUMP TJUMP . 1)						   (NFJUMP FJUMP]				   [NTJUMP (QUOTE ((NTJUMP)						    (NFJUMP FJUMP . 1]				   [NFJUMP (QUOTE ((NTJUMP TJUMP . 1)						    (NFJUMP]				   [POP (QUOTE ((NTJUMP TJUMP . 1)						 (NFJUMP FJUMP . 1)						 (JUMP NIL . JP]				   [RETURN (QUOTE ((JUMP NIL . R]				   [(AVAR GVAR FVAR HVAR)				     (QUOTE ((FJUMP NFJUMP . L)					      (TJUMP NTJUMP . L)					      (JUMP NIL . LL]				   (RETURN]      LP  (COND	    ((NOT (SETQ INFO (FASSOC [fetch OPNAME of (CAR (SETQ REF (CADR DR]				     ALST)))	      (GO NX)))          (COND	    ((EQ REF PD)	      [COMPERRM (CONS COMFN (QUOTE (-- infinite loop]	      (GO NX)))          (SETQ BR (fetch PREV of REF))          (SETQ Y	    (SELECTQ (CDDR INFO)		     (NIL                                    (* JUMP to JUMP)			  (fetch (JUMP TAG) of APD))		     (R                                      (* JUMP to RETURN)			(FRPLACA REF OPRETURN)			NIL)		     [L                                      (* VARIABLE REFERENCE)			(COND			  ((OR (OPT.EQVALUE BR PD)			       (AND (EQ (fetch OPNAME of (CAR REF))					(QUOTE TJUMP))				    (OPT.CALLP (CAR BR)					       VCONDITIONALS 1)				    (OPT.EQVALUE (fetch PREV of BR)						 PD)))       (* VAR CJUMP to VAR)			    (OPT.LABELNTHPR DEF 1 LEVEL 1))			  [(SETQ Y (OPT.JUMPCOPYTEST PD BR))                                                             (* VAR CJUMP .. VAR -&gt; VAR COPY CJUMP POP ..							     VAR)			    (PROG ((N 1)				   PDN)			          [COND				    (NEWOPTFLG (SETQ PDN (fetch NXT of PD))					       (while (AND (OPT.CALLP (CAR (SETQ INFO									     (fetch NXT of Y)))								      NIL 1)							   (COMP.CLEANFNOP							     (CDR (fetch OPARG of (CAR INFO)))							     (QUOTE NOSIDE))							   (OPT.EQOP (CAR INFO)								     (CAR PDN)))						  do (SETQ Y INFO)						     (SETQ PDN (fetch NXT of PDN))						     (add N 1]			          (OPT.PRATTACH OPCOPY Y)			          (OPT.PRATTACH OPPOP REF)			          (SETQ INFO)			          (RETURN (OPT.LABELNTHPR DEF N LEVEL 1]			  (T (GO NX]		     [LL (COND			   ((AND (EQ (CAR BR)				     OPPOP)				 (OPT.EQVALUE (fetch PREV of BR)					      PD))           (* SETQ var POP JUMP to var)			     (OPT.PRDEL BR)			     (OPT.LABELNTHPR DEF 1 LEVEL 1))			   (T (GO NX]		     (1                                      (* NTJUMP to POP)			(OPT.LABELNTHPR DEF 1 LEVEL -1))		     (OPNIL                                  (* FJUMP to NIL)			    (OPT.LABELNTHPR DEF 1 LEVEL 1))		     [JP (COND			   ((SETQ B (OPT.SKIPPUSH BR 1 NIL T))                                                             (* JUMP to POP)			     [PROG NIL			       LPB (SETQ BR (PROG1 (fetch PREV of BR)						   (OPT.PRDEL BR)))			           (COND				     ((NEQ BR B)				       (GO LPB]			     (OPT.LABELNTHPR DEF 1 LEVEL -1))			   (T (GO NX]		     (OPT.COMPILERERROR)))          (COND	    (Y (replace (JUMP TAG) of (CAR REF) with Y)	       (NCONC1 (OPT.DEFREFS Y)		       REF)))          (SETQ ANY T)                                       (* Since the jump to this tag was redirected, delete the							     jump from the REFS for this tag)          (FRPLACD DR (CDDR DR))          [COND	    ((CADR INFO)	      (replace OPNAME of (CAR REF) with (CADR INFO]          (GO LX)      NX  (SETQ DR (CDR DR))      LX  (COND	    ((CDR DR)	      (GO LP)))          [COND	    ((NULL (CDR OPT.DEFREFS))	      (RETURN (OPT.LBDEL TAG]          (RETURN ANY])(OPT.LBMERGE  [LAMBDA (TO FROM)                                          (* lmm: "22-JUL-77 16:03")    (PROG [(REFS (CDR (OPT.DEFREFS FROM]          [MAPC REFS (FUNCTION (LAMBDA (X)		    (replace (JUMP TAG) of (CAR X) with TO]          (NCONC (OPT.DEFREFS TO)		 REFS)          [OR (fetch (TAG LEVEL) of FROM)	      (PROGN (replace (TAG LEVEL) of TO with NIL)		     (OR (fetch FRAME of FROM)			 (replace FRAME of TO with NIL]          (RETURN (OPT.LBDEL FROM])(OPT.PRDEL  [LAMBDA (X)                                                (* lmm: "22-JUL-77 02:59")    (PROG ((B (fetch PREV of X))	   (P (fetch NXT of X)))          (AND B (replace NXT of B with P))          (AND P (replace PREV of P with B))          (replace NXT of X with NIL])(OPT.UBDEL  [LAMBDA (CD)                                               (* lmm "14-MAR-81 09:16")    (DREMOVE CD (OR (FASSOC (CDR (fetch OPARG of (CAR CD)))			    FRAMES)		    (OPT.COMPILERERROR])(OPT.LBDEL  [LAMBDA (TAG)                                              (* lmm "13-Jul-84 21:18")    (PROG ((DEF (CAR (OPT.DEFREFS TAG)))	   B)          (SETQ B (fetch PREV of DEF))          (OPT.PRDEL DEF)          (OPT.SETDEFREFS TAG NIL)          [COND	    ((OPT.JUMPCHECK B)                               (* delete code before deleted tag)	      (OPT.DELCODE (fetch NXT of B]          (RETURN T])(OPT.LABELNTHPR  [LAMBDA (CODE CNT LEVEL DL)                                (* lmm: "22-JUL-77 16:12")    (PROG ((CD CODE)	   G)          (OPT.CHLEV DL)      LP  (SETQ CD (fetch NXT of CD))          (COND	    ((IGREATERP CNT 0)	      (OR (type? TAG (CAR CD))		  (SUB1VAR CNT))	      (GO LP))	    (T (RETURN (COND			 ((type? TAG (CAR CD))			   (OPT.CHECKTAG (CAR CD)					 T)			   (CAR CD))			 (T (PROG1 (SETQ G (create TAG))				   (replace (TAG FRAME) of G with FRAME)				   (SETQ CD (OPT.PRATTACH G (fetch PREV of CD)))				   (OPT.SETDEFREFS G (LIST CD))				   (replace (TAG LEVEL) of G with LEVEL])(OPT.JUMPREV  [LAMBDA (TAG OPT.DEFREFS)                                  (* lmm "13-Jul-84 21:18")                                                             (* OPT.JUMPREV checks the things that PRECEDE particular							     kinds of jumps)    (PROG ((DR OPT.DEFREFS)	   R	   (D (CAR OPT.DEFREFS))	   END ANY LB CD (LEVEL (fetch (TAG LEVEL) of TAG))	   (FRAME (fetch (TAG FRAME) of TAG))	   BD ABD FLG BR ABR OABR PR APD OAR TMP)      LP  (SETQ R (CADR DR))          (SETQ PR (fetch NXT of R))          (SETQ BD (fetch PREV of D))          (SETQ ABD (CAR BD))          (SETQ BR (fetch PREV of R))          (SETQ ABR (CAR BR))          (SETQ OABR (fetch OPNAME of ABR))          (SETQ OAR (fetch OPNAME of (CAR R)))          (* variable code: last letter is R for reference {i.e. place of jump}, D for definition {i.e.	  place where TAG is} -	  preceding letters: -	  A for CAR -	  O for COP {op code} -	  P for CPR {next byte} -	  B for CBR {previous byte})          (SELECTQ OAR		   [JUMP (COND			   ((EQ R BD)                        (* JUMP to next location deleted)			     (OPT.PRDEL R))			   [(AND (OPT.EQOP ABD ABR)				 (SETQ TMP (OPT.COMMONBACK BD R LEVEL)))          (* OPT.COMMONBACK returns NIL if does nothing; T if deleted safe code or SAME if it deleted some code that 	  contained a reference to the label that is now being worked on.)                                                             (* merge similar code before JUMP and TAG)                                                             (* IF SAME don't continue with this label! could have 							     deleted other references to it)			     (COND			       ((EQ TMP T)				 (SETQ ANY T)				 (GO LX))			       (T (RETURN T]			   [[AND (CAR PR)				 (NOT (type? TAG (CAR PR]    (* delete code after JUMP)			     (COND			       ((OPT.DELCODE PR)             (* returns T if it deleted any jumps 							     (may have deleted a jump for this tag))				 (RETURN))			       (T (GO NX]			   ([AND (SELECTQ (fetch OPNAME of ABD)					  (RETURN T)					  (JUMP (NOT (FMEMB BD DR)))					  NIL)				 (SETQ END (fetch NXT of (OPT.FINDEND D R]                                                             (* move jumped-to code in line)			     (PROGN (replace NXT of BD with END)				    (replace PREV of (PROG1 END (SETQ END (fetch PREV of END)))				       with BD))			     (PROGN (replace NXT of BR with D)				    (replace PREV of D with BR)				    (replace PREV of PR with END)				    (replace NXT of END with PR)))			   (T (SELECTQ OABR				       (CONST                (* CONST JUMP)					      (SELECTQ (fetch OPNAME of APD)						       ((TJUMP NTJUMP)							 (SETQ FLG (fetch OPARG of ABR)))						       [(FJUMP NFJUMP)							 (SETQ FLG (NULL (fetch OPARG of ABR]						       (GO NX))					      (NCONC1 [OPT.DEFREFS							(replace (JUMP TAG) of (CAR R)							   with (COND								  (FLG (SELECTQ (fetch OPNAME										   of APD)										((TJUMP FJUMP)                                                             (* T JUMP to TJUMP)										  (OPT.PRDEL BR))										                                                             (* T JUMP to NTJUMP))								       (fetch (JUMP TAG)									  of APD))								  (T                                                              (* T JUMP to NF/FJUMP)								     (OPT.PRDEL BR)								     (OPT.LABELNTHPR D 1 LEVEL -1]						      R))				       [(TJUMP FJUMP)					 (COND					   ((EQ (fetch (JUMP TAG) of (CAR R))						(fetch (JUMP TAG) of ABR))                                                             (* TJUMP-&gt;TAG JUMP-&gt;TAG =&gt; POP JUMP-&gt;TAG)					     (OPT.PRDEL R)					     (OPT.PRATTACH OPPOP (fetch PREV of BR))					     (replace OPNAME of ABR with (QUOTE JUMP)))					   (T (GO NX]				       (GO NX]		   [(FJUMP TJUMP)		     (COND		       ((EQ R BD)                            (* TJUMP to next location)			 (FRPLACA R OPPOP))		       [(EQ OABR (QUOTE CONST))			 (COND			   ((SELECTQ OAR				     (TJUMP (fetch OPARG of ABR))				     (NULL (fetch OPARG of ABR)))                                                             (* T TJUMP -&gt; JUMP)			     (replace OPNAME of (CAR R) with (QUOTE JUMP))			     (OPT.PRDEL BR)			     (SETQ ANY T)                    (* try again)			     (GO LP))			   (T                                (* T FJUMP -&gt; NOOP)			      (OPT.PRDEL R)			      (OPT.PRDEL BR]		       ((OPT.CALLP ABR (QUOTE (NOT NULL))				   1)                        (* NULL TJUMP)			 (FRPLACA R (OPT.NOTJUMP (CAR R)))			 (OPT.PRDEL BR)			 (GO REDO))		       ((AND (EQ ABR OPCOPY)			     (EQ (CAR PR)				 OPPOP))                     (* COPY TJUMP POP -&gt; NTJUMP)			 (OPT.PRDEL BR)			 (OPT.PRDEL PR)			 (replace OPNAME of (CAR R) with (SELECTQ OAR								  (TJUMP (QUOTE NTJUMP))								  (QUOTE NFJUMP)))			 (GO REDO))		       ((AND (EQ (fetch OPNAME of ABD)				 (QUOTE JUMP))			     (EQ (fetch PREV of BD)				 R))                         (* FJUMP.1 JUMP.2 1: =&gt; TJUMP.2)			 (replace OPNAME of ABD with (SELECTQ OAR							      (TJUMP (QUOTE FJUMP))							      (QUOTE TJUMP)))			 (OPT.PRDEL R))		       ((SETQ CD (OPT.JUMPCOPYTEST PR BR))   (* What is before the jump is also after -							     e.g. X TJUMP X)			 (COND			   ((EQ (CAR PR)				(CAR (fetch NXT of D)))      (* X TJUMP.1 X ... 1:X ... -&gt; X COPY TJUMP.2 ...							     1:X 2: ...)			     (OPT.PRATTACH OPCOPY CD)			     (SETQ LB (OPT.LABELNTHPR D 1 LEVEL 1)))			   ((AND (OPT.JUMPCHECK (fetch PREV of D))				 (OR (OPT.EQVALUE BR PR)				     (AND (EQ OAR (QUOTE FJUMP))					  (OPT.CALLP ABR VCONDITIONALS 1)					  (OPT.EQVALUE (fetch PREV of BR)						       PR)))				 (SETQ END (OPT.FINDEND D R)))                                                             (* X FJUMP.1 X .a. 1: .b. -&gt; X NTJUMP.2 1: .b.							     ... 2: .a.)			     (PROGN (replace NXT of (fetch PREV of D) with (fetch NXT of END))				    (replace PREV of (fetch NXT of END) with (fetch PREV										of D)))			     (PROGN (replace NXT of R with D)				    (replace PREV of D with R)				    (replace PREV of PR with END)				    (replace NXT of END with PR))			     (replace OPNAME of (CAR R) with (SELECTQ OAR								      (FJUMP (QUOTE NTJUMP))								      (QUOTE NFJUMP)))			     (SETQ LB (OPT.LABELNTHPR PR 0 LEVEL 1)))			   (T (GO NX)))			 (OPT.PRDEL PR)			 (replace (JUMP TAG) of (CAR R) with LB)			 (NCONC1 (OPT.DEFREFS LB)				 R))		       (T (GO NX]		   [(NFJUMP NTJUMP)		     (COND		       [(EQ OABR (QUOTE CONST))			 (COND			   ((SELECTQ OAR				     (NTJUMP (fetch OPARG of ABR))				     (NULL (fetch OPARG of ABR)))                                                             (* T NTJUMP -&gt; JUMP)			     (replace OPNAME of (CAR R) with (QUOTE JUMP))			     (GO REDO))			   (T                                (* T NFJUMP -&gt; NOOP)			      (OPT.PRDEL BR)			      (OPT.PRDEL R]		       ((OPT.EQVALUE BR PR)                  (* X NTJUMP X -&gt; X COPY TJUMP)			 (OPT.PRATTACH OPCOPY (fetch PREV of R))			 (OPT.PRDEL PR)			 (replace OPNAME of (CAR R) with (SELECTQ OAR								  (NTJUMP (QUOTE TJUMP))								  (QUOTE FJUMP)))			 (GO REDO))		       [(EQ OAR (QUOTE NTJUMP))			 (COND			   [(NOT (OR (OPT.CALLP ABR CONDITIONALS)				     (OPT.CALLP ABR VCONDITIONALS)))			     (COND			       ((EQ (CAR (fetch NXT of R))				    OPNIL)                   (* NTJUMP NIL -&gt; COPY TJUMP)				 (OPT.PRDEL (fetch NXT of R))				 (OPT.PRATTACH OPCOPY BR)				 (replace OPNAME of (CAR R) with (QUOTE TJUMP))				 (GO REDO))			       (T (GO NX]			   [(OPT.CALLP ABR VCONDITIONALS 1)			     (COND			       ((OPT.EQVALUE (fetch PREV of BR)					     PR)             (* X LISTP NTJUMP X -&gt; X COPY LISTP TJUMP)				 (OPT.PRATTACH OPCOPY (fetch PREV of BR))				 (OPT.PRDEL PR)				 (replace OPNAME of (CAR R) with (QUOTE TJUMP))				 (GO REDO))			       (T (GO NX]			   (T (GO NX]		       (T (GO NX]		   (GO NX))          (SETQ ANY T)          (FRPLACD DR (CDDR DR))          (GO LX)      NX  (SETQ DR (CDR DR))      LX  (COND	    ((CDR DR)	      (GO LP)))          (RETURN ANY)      REDO(SETQ ANY T)          (GO LP])(OPT.COMMONBACK  [LAMBDA (BDEF REF LEVEL)                                   (* lmm "13-Jul-84 21:18")          (* When the code preceding a jump is the same as the code preceding the label, can delete the code preceding the 	  jump and move the label back -	  BDEF is the code preceding the label and REF is the jump and the code that precedes it)    (PROG ((BREF (fetch PREV of REF))	   G FLG TMP (FRAME FRAME))      M   (COND	    ((EQ (fetch OPNAME of (CAR BDEF))		 (QUOTE TAG))	      (OPT.CHECKTAG (CAR BDEF)			    LEVEL)	      (SETQ BDEF (fetch PREV of BDEF))	      (GO M)))          (COND	    ((OPT.EQOP (CAR BDEF)		       (CAR BREF))	      [SELECTQ (fetch OPNAME of (CAR BREF))		       ((AVAR HVAR GVAR FVAR CONST COPY)			 (OPT.CHLEV -1))		       ((SETQ STORE SWAP))		       (POP (COND			      ((AND [NOT (OPT.EQOP (CAR (fetch PREV of BREF))						   (CAR (fetch PREV of BDEF]				    (EQ (fetch OPNAME of (CAR (fetch PREV of BREF)))					(QUOTE SETQ))				    (EQ (fetch OPNAME of (CAR (fetch PREV of BDEF)))					(QUOTE SETQ)))       (* no OPT.COMMONBACK for different SETQ pop.)				(GO EXIT)))			    (OPT.CHLEV 1))		       ((TJUMP FJUMP NTJUMP NFJUMP)			 (OPT.CHLEV 1)			 [COND			   ((EQ (fetch (JUMP TAG) of (CAR BREF))				(fetch (JUMP TAG) of (CAR REF)))			     (SETQ FLG (QUOTE SAME]			 (OPT.DELTAGREF BREF))		       [FN (OPT.CHLEV (SUB1 (CAR (fetch OPARG of (CAR BDEF]		       [(UNBIND DUNBIND)			 (OPT.UBDEL BREF)			 [SETQ LEVEL (CAR (fetch OPARG of (CAR BREF]			 (SETQ FRAME (CDR (fetch OPARG of (CAR BREF]		       (OPT.COMPILERERROR (QUOTE (OPT.COMMONBACK shouldn't get here]	      (OR FLG (SETQ FLG T))	      (SETQ BDEF (fetch PREV of BDEF))	      (SETQ BREF (PROG1 (fetch PREV of BREF)				(OPT.PRDEL BREF)))	      (GO M)))      EXIT(COND	    (FLG (SETQ G (OPT.LABELNTHPR BDEF 0 LEVEL 0))		 (OPT.DELTAGREF REF)		 (replace (JUMP TAG) of (CAR REF) with G)		 (NCONC1 (OPT.DEFREFS G)			 REF)		 (RETURN FLG])(OPT.DELTAGREF  [LAMBDA (REF)                                              (* edited: "21-DEC-79 15:57")    (for X on (OPT.DEFREFS (fetch (JUMP TAG) of (CAR REF))) when (EQ (CADR X)								     REF)       do (RETURN (RPLACD X (CDDR X))) finally (OPT.COMPILERERROR])(OPT.FINDEND  [LAMBDA (C STOP)                                           (* lmm: "22-JUL-77 03:38")    (PROG NIL      LP  (COND	    ((EQ C STOP)	      (RETURN)))          (COND	    ((OPT.JUMPCHECK C)	      (RETURN C)))          (COND	    ((SETQ C (fetch NXT of C))	      (GO LP])(OPT.RETOPT  [LAMBDA NIL                                                (* DD: "21-FEB-83 17:17")                                                             (* optimizations involving RETURN)    (PROG ((RL (OPT.RETFIND CODE))	   TESTL TARGL)          [MAPC RL (FUNCTION (LAMBDA (C)		    (COND		      ((OPT.RETPOP C)			(SETQ ANY T)))		    (COND		      ((OPT.RETTEST C C)                     (* Test if C is a possible test.)          (* Looking for the case where two identical sequences ending with RETURN one of which is preceded by a conditional	  jump; -	  TJUMP-&gt;x stuff RETURN x: ... stuff RETURN ... becomes -	  FJUMP-&gt;y x: ... y: stuff RETURN)			(SETQ TESTL (CONS C TESTL)))		      (T (SETQ TARGL (CONS C TARGL]          (OR TESTL (RETURN ANY))          [SETQ TESTL (SUBSET TESTL (FUNCTION (LAMBDA (X)				  (NOT (OPT.RETOPT1 X TARGL]          [MAP TESTL (FUNCTION (LAMBDA (Z)		   (AND (LISTP Z)			(OPT.RETOPT1 (CAR Z)				     (CDR Z]          (RETURN ANY])(OPT.RETFIND  [LAMBDA (C)                                                (* lmm: "18-AUG-76 02:12:31")                                                             (* returns the list of all RETURN's in the code)    (PROG ((L1 C)	   R)      LP  (COND	    ((SETQ L1 (FMEMB OPRETURN (CDR L1)))	      (SETQ R (CONS L1 R))	      (GO LP)))          (RETURN R])(OPT.RETPOP  [LAMBDA (RET)                                              (* rmk: " 2-Apr-85 12:46")                                                             (* can delete any UNBIND's preceding a RETURN -							     the RETURN does it automatically)    (PROG (ANY TAGS VAL)      LP  (SELECTQ [fetch OPNAME of (CAR (SETQ RET (fetch PREV of RET]		   [UNBIND (SELECTQ (fetch OPNAME of VAL)				    ((AVAR HVAR)             (* don't delete UNBIND when followed by VAR RETURN)				      )				    (PROGN                   (* delete UNBIND before RETURN)					   (OPT.UBDEL RET)					   (GO DEL]		   [POP (COND			  (VAL                               (* delete POP before VAR RETURN)			       (GO DEL]		   [DUNBIND (COND			      (VAL                           (* delete DUNBIND before VAR RETURN)				   (OPT.UBDEL RET)				   (GO DEL]		   [COPY (COND			   ((NOT (fetch OPARG of (CAR RET)))                                                             (* delete COPY before RETURN)			     (GO DEL]		   [(AVAR HVAR FVAR GVAR CONST)		     (COND		       ((NULL VAL)			 (SETQ VAL (CAR RET))			 (GO LP))		       (T                                    (* VAR VAR RETURN)			  (GO DEL]		   (TAG (if [AND XVARFLG (SELECTQ (fetch OPNAME of VAL)						  (CONST NIL)						  (NOT (FMEMB VAL (fetch VARS of TOPFRAME]			    then                             (* if have XVARs then TAGs can't be ambiguous)			  else (SETQ TAGS (CONS (CAR RET)						TAGS))			       (GO LP)))		   NIL)          (RETURN ANY)      DEL (OPT.PRDEL RET)      DOIT(SETQ ANY T)          [MAPC TAGS (FUNCTION (LAMBDA (X)		    (replace (TAG LEVEL) of X with NIL]          (SETQ TAGS)          (GO LP])(OPT.RETOPT1  [LAMBDA (X L)                                              (* lmm: "13-OCT-76 18:45:46")    (PROG (END Y1)          (RETURN (COND		    ([SETQ Y1 (SOME L (FUNCTION (LAMBDA (Y)					(SETQ END (OPT.RETTEST X Y]		      (OPT.RETMERGE X END (CAR Y1))		      (SETQ ANY T])(OPT.RETTEST  [LAMBDA (TEST TARGET)                                      (* jds "ANOTHER FAKE DATE")    (PROG ((L1 TEST)	   (L2 TARGET)	   F1 F2 ONLYIFSAMEFRAME)          [COND	    ((EQ L1 L2)	      (SETQ F1 (SETQ F2 T]      LP  (SETQ L1 (fetch PREV of L1))          (SETQ L2 (fetch PREV of L2))      L1  (COND	    ((type? TAG (CAR L1))	      [OR F1 (SETQ F1 (fetch (TAG FRAME) of (CAR L1]	      (SETQ L1 (fetch PREV of L1))	      (GO L1)))      L2  (COND	    ((type? TAG (CAR L2))	      [OR F2 (SETQ F2 (fetch (TAG FRAME) of (CAR L2]	      (SETQ L2 (fetch PREV of L2))	      (GO L2)))          (SELECTQ (fetch OPNAME of (CAR L1))		   (RETURN (GO RET))		   (JUMP (GO RETJ))		   [(FJUMP TJUMP)		     (COND		       ((EQ (fetch (JUMP TAG) of (CAR L1))			    (CAR (fetch NXT of TEST)))			 (GO RETJ]		   [AVAR (COND			   ((EQ (CAR L1)				(CAR L2))			     (SETQ ONLYIFSAMEFRAME T)			     (GO LP]		   [HVAR (COND			   ((EQ (CAR L1)				(CAR L2))			     (COND			       ((EQ (OPT.CODEFRAME L1)				    (OPT.CODEFRAME L2))				 (COND				   ((EQ (OPT.CODELEV L1 0)					(OPT.CODELEV L2 0))				     (GO LP)          (* if NOXVAR would work, we could do this. Unfortunately, NOXVAR is ignored at this point (replace 	  (FRAME NOXVAR) of (OPT.CODEFRAME L1) with T))				     ]		   [(UNBIND DUNBIND)		     (COND		       ([AND [EQ [CAR (LISTP (fetch OPARG of (LISTP (CAR L1]				 (CAR (LISTP (fetch OPARG of (LISTP (CAR L2]			     (EQ [CDR (fetch OPARG of (LISTP (CAR L1]				 (CDR (fetch OPARG of (LISTP (CAR L2]			 (SETQ F1 (SETQ F2 T))               (* same frame)			 (GO LP]		   [FN (COND			 ((OPT.EQOP (CAR L1)				    (CAR L2))			   (GO LP]		   (BIND                                     (* don't merge binds)			 NIL)		   [(POP CONST FVAR GVAR SWAP)		     (COND		       ((EQ (CAR L1)			    (CAR L2))			 (GO LP]		   [(STORE COPY)		     (COND		       ((EQUAL (CAR L1)			       (CAR L2))			 (GO LP]		   NIL)          (RETURN)      RETJ[OR F1 (SETQ F1 (fetch (TAG FRAME) of (fetch (JUMP TAG) of (CAR L1]      RET [COND	    (ONLYIFSAMEFRAME (COND			       ((NEQ (OR F1 (OPT.CODEFRAME L1))				     (OR F2 (OPT.CODEFRAME L2)))                                                             (* OPT.RETTEST fail because not same frame)				 (RETURN]          (RETURN L1])(OPT.RETMERGE  [LAMBDA (TEST END TARGET)                                  (* lmm "13-OCT-78 21:25")    (PROG ((L1 TEST)	   (L2 TARGET)	   G VEQ FEQ LEV)          [COND	    ([AND (SETQ LEV (OPT.CODEFRAME (fetch PREV of TEST)))		  (EQ LEV (OPT.CODEFRAME (fetch PREV of TARGET]	      (SETQ FEQ T)	      (COND		((AND (SETQ LEV (OPT.CODELEV (fetch PREV of TEST)					     0))		      (EQ LEV (OPT.CODELEV (fetch PREV of TARGET)					   0)))		  (SETQ VEQ T]      LP  (COND	    ((EQ L1 END)	      (SELECTQ (fetch OPNAME of (CAR L1))		       ((TJUMP FJUMP)			 [COND			   [[NOT (type? TAG (SETQ G (CAR L2]			     (SETQ G (create TAG))			     [COND			       (FEQ [replace (TAG FRAME) of G with (fetch (TAG FRAME)								      of (fetch (JUMP TAG)									    of (CAR L1]				    (COND				      (VEQ (replace (TAG LEVEL) of G					      with (fetch (TAG LEVEL) of (fetch (JUMP TAG)									    of (CAR L1]			     (OPT.SETDEFREFS G (LIST (OPT.PRATTACH G L2]			   (T (OR VEQ (replace (TAG LEVEL) of G with NIL))			      (OR FEQ (replace (TAG FRAME) of G with NIL]			 (FRPLACA L1 (OPT.NOTJUMP (CAR L1)))			 [DREMOVE L1 (OPT.DEFREFS (fetch (JUMP TAG) of (CAR L1]			 (replace (JUMP TAG) of (CAR L1) with G)			 (NCONC1 (OPT.DEFREFS G)				 L1))		       ((JUMP RETURN))		       (OPT.COMPILERERROR))	      (RETURN)))          (COND	    ((type? TAG (CAR L1))	      (OR VEQ (replace (TAG LEVEL) of (CAR L1) with NIL))	      (OR FEQ (replace (TAG FRAME) of (CAR L1) with NIL))	      (RPLACA (OPT.DEFREFS (CAR L1))		      (OPT.PRATTACH (CAR L1)				    L2))	      (SETQ L1 (PROG1 (fetch PREV of L1)			      (OPT.PRDEL L1)))	      (GO LP)))      L2  (COND	    ((type? TAG (CAR L2))	      (OR VEQ (replace (TAG LEVEL) of (CAR L2) with NIL))	      (OR FEQ (replace (TAG FRAME) of (CAR L2) with NIL))	      (SETQ L2 (fetch PREV of L2))	      (GO L2)))          (SELECTQ (fetch OPNAME of (CAR L1))		   ((UNBIND DUNBIND)		     (OPT.UBDEL L1))		   ((TJUMP NTJUMP FJUMP NFJUMP JUMP BIND ERRORSET)		     (OPT.COMPILERERROR))		   NIL)          (SETQ L1 (PROG1 (fetch PREV of L1)			  (OPT.PRDEL L1)))          (SETQ L2 (fetch PREV of L2))          (GO LP])(OPT.CODELEV  [LAMBDA (CD LEV)                                           (* jds "THIS IS A FAKE DATE")    (PROG NIL          (RETURN (IPLUS (SELECTQ (fetch OPNAME of (CAR CD))				  (TAG (OR (fetch (TAG LEVEL) of (CAR CD))					   (RETURN)))				  [(NTJUMP NFJUMP TJUMP FJUMP)				    (RETURN (OPT.CODELEV (fetch PREV of CD)							 (SUB1 LEV]				  [(AVAR HVAR COPY CONST FVAR GVAR)				    (RETURN (OPT.CODELEV (fetch PREV of CD)							 (ADD1 LEV]				  [FN (RETURN (OPT.CODELEV (fetch PREV of CD)							   (ADD1 (IDIFFERENCE								   LEV								   (CAR (fetch OPARG									   of (CAR CD]				  [POP (RETURN (OPT.CODELEV (fetch PREV of CD)							    (SUB1 LEV]				  ((BIND ERRORSET)				    0)				  [DUNBIND (fetch (FRAME LEVEL) of (CDR (fetch OPARG									   of (CAR CD]				  [UNBIND (ADD1 (OR [fetch (FRAME LEVEL)						       of (CDR (fetch OPARG of (CAR CD]						    (RETURN]				  ((SETQ STORE SWAP)				    (RETURN (OPT.CODELEV (fetch PREV of CD)							 LEV)))				  (NIL (OPT.CCHECK (NOT (CDR CD)))				       0)				  (OPT.COMPILERERROR (CAR CD)))			 LEV])(OPT.CODEFRAME  [LAMBDA (CD)                                               (* rmk: " 2-Apr-85 12:47")    (SELECTQ (fetch OPNAME of (CAR CD))	     [TAG (OR (fetch (TAG FRAME) of (CAR CD))		      (OPT.CODEFRAME (fetch PREV of CD]	     ((NTJUMP NFJUMP TJUMP FJUMP)                    (* can't assume that code of jumped-to is same, because							     return-merging might have messed it up)	       (OPT.CODEFRAME (fetch PREV of CD)))	     [(BIND ERRORSET)	       (CDR (fetch OPARG of (CAR CD]	     [(UNBIND DUNBIND)	       (fetch PARENT of (CDR (fetch OPARG of (CAR CD]	     (NIL TOPFRAME)	     ((JUMP RETURN)	       NIL)	     (OPT.CODEFRAME (fetch PREV of CD])(OPT.DEFREFS  [LAMBDA (D)                                                (* lmm: "22-JUL-77 15:58")    (CDR (FASSOC D LABELS])(OPT.SETDEFREFS  [LAMBDA (D V)                                              (* lmm: "22-JUL-77 15:58")    (FRPLACD [OR (FASSOC D LABELS)		 (CAR (SETQ LABELS (CONS (CONS D)					 LABELS]	     V]))(DEFINEQ(OPT.FRAMEOPT  [LAMBDA (TRYLOCAL TRYMERGE TRYXVAR)                        (* lmm "16-DEC-81 17:05")    (PROG (ANY)          [COND	    (TRYLOCAL (MAPC FRAMES (FUNCTION (LAMBDA (X)				(AND (OPT.FRAMELOCAL (CAR X))				     (SETQ ANY T]          [MAPC FRAMES (FUNCTION (LAMBDA (F)		    (AND (CADR F)			 (OPT.FRAMEVAR F)			 (SETQ ANY T]          [COND	    (TRYMERGE (MAPC FRAMES (FUNCTION (LAMBDA (F)				(AND (CADR F)				     (OPT.FRAMEMERGE F)				     (SETQ ANY T]          [SETQ FRAMES (SUBSET FRAMES (FUNCTION (LAMBDA (F)				   (NOT (AND (CADR F)					     (OPT.FRAMEDEL F TRYXVAR)					     (SETQ ANY T]          (RETURN ANY])(OPT.FRAMEMERGE  [LAMBDA (F)                                                (* lmm "29-Dec-84 10:35")    (AND MERGEFRAMEFLG (PROG ((FR (CAR F))			      VAR VARS P)			     (COND			       ((AND (SETQ VARS (fetch VARS of FR))				     (NULL (CDR (FNTH VARS MERGEFRAMEMAX)))				     (SETQ P (fetch PARENT of FR))				     (OPT.MERGEFRAMEP FR P VARS))				 [PROG ((N (fetch NVALS of FR))					(V VARS)					(CD (fetch PREV of (CADR F)))					P2)				   PLP (COND					 ((AND (SETQ P2 (fetch PARENT of P))					       (OPT.MERGEFRAMEP FR P2 VARS))					   (SETQ P P2)					   (GO PLP)))				       (replace VARS of P with (NCONC (fetch VARS of P)								      VARS))				       (replace VARS of FR with NIL)				       (replace NNILS of P with (IPLUS (fetch NNILS of P)								       (fetch NNILS of FR)								       (fetch NVALS of FR)))				       (replace NNILS of FR with (replace NVALS of FR with 0))				   LP  (COND					 (V (SETQ VAR (create OP							      OPNAME &larr;(QUOTE SETQ)							      OPARG &larr;(CAR V)))					    [COND					      ((IGREATERP N 0)						(OPT.PRATTACH OPPOP (OPT.PRATTACH VAR CD)))					      (T [COND						   ((ZEROP N)						     (SETQ CD (OPT.PRATTACH OPNIL CD]						 (OR (OPT.NONILVAR (CAR V)								   CD P)						     (SETQ CD (OPT.PRATTACH VAR CD]					    (SETQ N (SUB1 N))					    (SETQ V (CDR V))					    (GO LP)))				       (COND					 ((MINUSP N)					   (OPT.PRATTACH OPPOP CD]				 (RETURN T])(OPT.NONILVAR  [LAMBDA (V CD FR)                                          (* lmm " 8-JAN-82 09:06")                                                             (* used by OPT.FRAMEMERGE)    (PROG NIL          (RETURN (AND (SELECTQ (fetch OPNAME of (CAR CD))				((CONST POP COPY AVAR HVAR FVAR GVAR TJUMP FJUMP NTJUMP NFJUMP SETQ 					STORE SWAP)				  T)				(NIL NIL)				(FN (COMP.CLEANFNOP (CDR (fetch OPARG of (CAR CD)))						    (QUOTE FREEVARS)))				(BIND (COND					([EQ FR (CDR (fetch OPARG of (CAR CD]					  (RETURN T))					(T T)))				((TAG RETURN)				  NIL)				((UNBIND DUNBIND ERRORSET)				  T)				NIL)		       (OPT.NONILVAR V (CDR CD)				     FR])(OPT.MERGEFRAMEP  [LAMBDA (FR PARENT VARS)                                   (* lmm "29-Dec-84 10:31")    (AND (FMEMB (fetch FRAMETYPE of PARENT)		MERGEFRAMETYPES)	 (COND	   [(OASSOC (QUOTE AVAR)		    VARS)	     (AND (OPT.CLEANFRAME PARENT FR)		  (PROG NIL		        [for V in VARS			   do (if (FMEMB (fetch OPARG of V)					 SYSSPECVARS)				  then (GO BAD))			      [for F in FRAMES when (NEQ (CAR F)							 FR)				 do (for V2 in (fetch VARS of (CAR F))				       do (COND					    ((EQ (fetch OPARG of V2)						 (fetch OPARG of V))					      (GO BAD]			      (for V2 in FREEVARS do (COND						       ((EQ (fetch OPARG of V2)							    (fetch OPARG of V))							 (GO BAD]		        (RETURN T)		    BAD (RETURN]	   (T (EQ MERGEFRAMEFLG T])(OPT.FRAMELOCAL  [LAMBDA (F)                                                (* lmm "29-Dec-84 20:45")    (PROG (VARS ANY)          (COND	    ((AND (OASSOC (QUOTE AVAR)			  (SETQ VARS (fetch (FRAME VARS) of F)))		  (OPT.CLEANFRAME F))                        (* make vars local when no external calls)	      (for X in VARS when (AND (EQ (fetch OPNAME of X)					   (QUOTE AVAR))				       (NOT (FMEMB (fetch OPARG of X)						   SYSSPECVARS)))		 do (replace OPNAME of X with (QUOTE HVAR))		    (SETQ ANY T))	      (RETURN ANY])(OPT.CLEANFRAME  [LAMBDA (FRAME AVOIDING)                                   (* lmm: " 9-NOV-76 16:20:20")    (AND (NOT (fetch EXTCALL of FRAME))	 (for F in FRAMES when (AND (EQ (fetch PARENT of (CAR F))					FRAME)				    (NEQ (CAR F)					 AVOIDING))	    always (OPT.CLEANFRAME (CAR F)				   AVOIDING])(OPT.FRAMEDEL(LAMBDA (F TRYXVAR) (* lmm "13-Jul-84 21:18") (PROG (VARS (FRM (CAR F)) PARENT OP FLV TMP DOXVAR) (SELECTQ (fetch FRAMETYPE of FRM) ((NIL ERRORSET) (RETURN)) NIL) (SETQ VARS (fetch VARS of FRM)) (SETQ FLV (fetch (FRAME LEVEL) of FRM)) (SETQ DOXVAR NIL) (COND ((AND (NOT (SOME (CDDR F) (FUNCTION (LAMBDA (X) (AND (EQ (fetch OPNAME of (CAR X)) (QUOTE UNBIND)) (IGREATERP (CAR (fetch OPARG of (CAR X))) 1)))))) (OR (NULL VARS) (AND (NOT (OASSOC (QUOTE AVAR) VARS)) (OR (OPT.DELETEFRAMECHECK VARS F) (AND TRYXVAR (NOT (fetch NOXVAR of FRM)) (SETQ DOXVAR T)))))) (* frame with no specvars, no UNBIND's with LEVEL gt 1) (OR (SETQ PARENT (fetch PARENT of FRM)) (OPT.COMPILERERROR)) (COND (DOXVAR (add FLV (fetch NNILS of FRM) (fetch NVALS of FRM)))) (for VR on VARS do (for CD on CODE do (COND ((AND (EQ (fetch OPARG of (CAR CD)) (CAR VR)) (EQ (fetch OPNAME of (CAR CD)) (QUOTE SETQ))) (COND (DOXVAR (OPT.CCHECK (EQ FRM (OPT.CODEFRAME CD))) (RPLACA CD (create OP OPNAME &larr; (QUOTE STORE) OPARG &larr; (OR (OPT.CODELEV CD (LENGTH (CDR VR))) (OPT.COMPILERERROR))))) (T (OPT.PRDEL CD) (* delete SETQ in OPT.FRAMEDEL)))) ((AND DOXVAR (EQ (CAR CD) (CAR VR))) (OPT.CCHECK (EQ (OPT.CODEFRAME CD) FRM)) (RPLACA CD (COND ((ZEROP (SETQ TMP (OPT.CODELEV (fetch PREV of CD) (LENGTH (CDR VR))))) OPCOPY) (T (create OP OPNAME &larr; (QUOTE COPY) OPARG &larr; TMP)))))))) (MAPC LABELS (FUNCTION (LAMBDA (X) (COND ((EQ (fetch (TAG FRAME) of (CAR X)) FRM) (replace (TAG FRAME) of (CAR X) with PARENT) (AND (fetch (TAG LEVEL) of (CAR X)) FLV (replace (TAG LEVEL) of (CAR X) with (IPLUS (fetch (TAG LEVEL) of (CAR X)) FLV)))))))) (PROG ((CD (CADR F))) (* delete the bind and all of the var references after) (MAPC (CONS NIL (AND (NOT DOXVAR) VARS)) (FUNCTION (LAMBDA NIL (SETQ CD (PROG1 (fetch NXT of CD) (OPT.PRDEL CD)))))) (FRPTQ (fetch NNILS of FRM) (OPT.PRATTACH OPNIL (fetch PREV of CD)))) (COND ((fetch EXTCALL of FRM) (replace EXTCALL of PARENT with T))) (MAPC (CDDR F) (FUNCTION (LAMBDA (CD) (* change DUNBIND to POP of LEVEL) (SELECTQ (PROG1 (fetch OPNAME of (SETQ OP (CAR CD))) (SETQ CD (PROG1 (fetch PREV of CD) (OPT.PRDEL CD)))) (UNBIND (COND (DOXVAR (COND ((NOT (ZEROP (SETQ TMP (IPLUS (CAR (fetch OPARG of OP)) (LENGTH VARS) -1)))) (SETQ CD (OPT.PRATTACH (create OP OPNAME &larr; (QUOTE STORE) OPARG &larr; TMP) CD)) (FRPTQ TMP (OPT.PRATTACH OPPOP CD))))) (T (OPT.CCHECK (EQ (CAR (fetch OPARG of OP)) 1))))) (DUNBIND (FRPTQ (COND (DOXVAR (IPLUS (CAR (fetch OPARG of OP)) (fetch NVALS of FRM) (fetch NNILS of FRM))) (T (CAR (fetch OPARG of OP)))) (OPT.PRATTACH OPPOP CD))) (OPT.COMPILERERROR))))) (MAPC FRAMES (FUNCTION (LAMBDA (F2) (COND ((EQ (fetch PARENT of (CAR F2)) FRM) (replace PARENT of (CAR F2) with PARENT) (replace (FRAME LEVEL) of (CAR F2) with (AND FLV (SETQ TMP (fetch (FRAME LEVEL) of (CAR F2))) (IPLUS TMP FLV)))))))) (RETURN T))))))(OPT.FRAMEVAR  [LAMBDA (F)                                                (* lmm "13-Jul-84 21:18")    (PROG (VARS CD (FR (CAR F))		VAL ANY NNILS NVALS)          [SETQ VARS (REVERSE (OR (fetch VARS of FR)				  (RETURN]          (SETQ NNILS (fetch NNILS of FR))          (SETQ NVALS (fetch NVALS of FR))          [for V on VARS as I from NNILS to 0 by -1 when (NEQ (fetch OPNAME of (CAR V))							      (QUOTE AVAR))	     do (COND		  ((NOT (SETQ CD (FMEMB (CAR V)					CODE)))		    [COND		      ((ZEROP I)			(SETQ I 1)			(OPT.PRATTACH OPPOP (fetch PREV of (CADR F)))			(SETQ NVALS (SUB1 NVALS)))		      (T (SETQ NNILS (SUB1 NNILS]            (* local var bound but not used)		    (PROG ((CD CODE))		      LP  (COND			    ((NOT CD)			      (RETURN)))                     (* delete all SETQ's)		          (COND			    ((AND (EQ (fetch OPARG of (CAR CD))				      (CAR V))				  (EQ (fetch OPNAME of (CAR CD))				      (QUOTE SETQ)))         (* local var set but never used)			      (OPT.PRDEL CD)))		          (SETQ CD (fetch PREV of CD))		          (GO LP))		    (RPLACA V NIL)		    (SETQ ANY T))		  ([NOTANY CODE (FUNCTION (LAMBDA (X)			       (AND (EQ (fetch OPNAME of X)					(QUOTE SETQ))				    (EQ (fetch OPARG of X)					(CAR V]		    (COND		      ([SETQ VAL (COND			    ((NEQ I 0)                       (* NIL var never set)			      (SETQ NNILS (SUB1 NNILS))			      OPNIL)			    ((AND (EQ [fetch OPNAME of (SETQ VAL (CAR (fetch PREV									 of (CADR F]				      (QUOTE CONST))				  (APPLY* EQCONSTFN (fetch OPARG of VAL)))			      (SETQ I 1)			      (SETQ NVALS (SUB1 NVALS))      (* delete this var, can try next)                                                             (* var bound to CONST and never set)			      (PROG1 (CAR (fetch PREV of (CADR F)))				     (OPT.PRDEL (fetch PREV of (CADR F]			(do (FRPLACA CD VAL) repeatwhile (SETQ CD (FMEMB (CAR V)									 CD)))			(FRPLACA V NIL)			(SETQ ANY T]          (COND	    (ANY [replace VARS of FR with (OPT.DREV (SUBSET VARS (FUNCTION (LAMBDA (X)								X]		 (replace NNILS of FR with NNILS)		 (replace NVALS of FR with NVALS)))          (RETURN ANY])(OPT.DELETEFRAMECHECK  [LAMBDA (VARS F)                                           (* lmm: "22-JUL-77 02:58")    (PROG ((CD (OPT.ONLYMEMB (CAR VARS)			     CODE)))          (OR (AND CD (EQ (fetch PREV of CD)			  (CADR F)))	      (RETURN))      LP  (SETQ VARS (CDR VARS))          (SETQ CD (fetch NXT of CD))          (COND	    ((NULL VARS)	      (RETURN T)))          (COND	    ((EQ (OPT.ONLYMEMB (CAR VARS)			       CODE)		 CD)	      (GO LP])(OPT.ONLYMEMB  [LAMBDA (X Y)                                              (* lmm: " 6-OCT-76 15:06:48")    (AND (SETQ Y (FMEMB X Y))	 (NOT (FMEMB X (CDR Y)))	 Y]))(RPAQQ MERGEFRAMETYPES (PROG LAMBDA MAP))(RPAQQ OPTIMIZATIONSOFF NIL)(DEFINEQ(OPT.SKIPPUSH  [LAMBDA (CD N VL LEVOPFLG)                                 (* lmm "19-JAN-82 22:16")    (OR N (SETQ N 1))    (COND      ((ILESSP N 0)	NIL)      ((ZEROP N)	CD)      (T (SELECTQ (fetch OPNAME of (CAR CD))		  ((AVAR HVAR FVAR GVAR CONST)		    (OPT.SKIPPUSH (fetch PREV of CD)				  (SUB1 N)				  VL LEVOPFLG))		  (COPY (AND (NOT (fetch OPARG of (CAR CD)))			     (OPT.SKIPPUSH (fetch PREV of CD)					   (SUB1 N)					   VL LEVOPFLG)))		  (SWAP (AND (IGEQ N 2)			     (OPT.SKIPPUSH (fetch PREV of CD)					   N VL LEVOPFLG)))		  (POP (OPT.SKIPPUSH (fetch PREV of CD)				     (ADD1 N)				     VL LEVOPFLG))		  ((FJUMP TJUMP NFJUMP NTJUMP)		    (AND NEWOPTFLG (NOT LEVOPFLG)			 (OPT.SKIPPUSH (fetch PREV of CD)				       (ADD1 N)				       VL LEVOPFLG)))		  [FN (COND			((OR (COMP.CLEANFNOP (CDR (fetch OPARG of (CAR CD)))					     (QUOTE NOSIDE))			     (AND NEWOPTFLG (SELECTQ (fetch OPNAME of (CAR VL))						     ((CONST HVAR)						       T)						     ((FVAR AVAR GVAR)						       (COMP.CLEANFNOP (CDR (fetch OPARG									       of (CAR CD)))								       (QUOTE FREEVARS)))						     NIL)))			  (OPT.SKIPPUSH (fetch PREV of CD)					[SUB1 (IPLUS N (CAR (fetch OPARG of (CAR CD]					VL LEVOPFLG]		  [SETQ (COND			  ([AND NEWOPTFLG VL (NEQ (CAR VL)						  (fetch OPARG of (CAR CD]			    (OPT.SKIPPUSH (fetch PREV of CD)					  N VL LEVOPFLG]		  NIL])(OPT.DELCODE  [LAMBDA (CD)                                               (* lmm "13-Jul-84 21:18")    (PROG (X FLG)      LP  (SELECTQ (fetch OPNAME of (SETQ X (CAR CD)))		   (NIL (RETURN FLG))		   (TAG (RETURN FLG))		   [(BIND ERRORSET)		     (RPLACA (CDR (FASSOC (CDR (fetch OPARG of X))					  FRAMES))			     NIL)		     (for LB in LABELS when (EQ (fetch (TAG FRAME) of (CAR LB))						(CDR (fetch OPARG of X)))			do (MAPC (CDR LB)				 (FUNCTION OPT.PRDEL]		   ((UNBIND DUNBIND)		     (DREMOVE CD (FASSOC (CDR (fetch OPARG of X))					 FRAMES)))		   ((JUMP FJUMP TJUMP NFJUMP NTJUMP ERRORSET)                                                             (* delete unreachable jump)		     (DREMOVE CD (OPT.DEFREFS (fetch (JUMP TAG) of X)))		     (SETQ FLG T))		                                             (* delete unreachable code))          (SETQ ANY T)          (SETQ CD (PROG1 (fetch NXT of CD)			  (OPT.PRDEL CD)))          (GO LP])(OPT.PRATTACH  [LAMBDA (ITEM BEFORE)                                      (* lmm: "22-JUL-77 02:58")    (PROG ((AFTER (fetch NXT of BEFORE))	   (NEW (CONS)))          (replace NXT of NEW with AFTER)          (replace PREV of NEW with BEFORE)          (FRPLACA NEW ITEM)          (replace NXT of BEFORE with NEW)          (AND AFTER (replace PREV of AFTER with NEW))          (RETURN NEW])(OPT.JUMPCOPYTEST  [LAMBDA (VL CDFROM)                                        (* lmm "15-JAN-82 18:08")          (* Where can a COPY be inserted such that VL would be on the stack -	  either returns the code list or NIL -	  used by transformation -	  var TJUMP-&gt;l var ... l: var -	  =&gt; var COPY TJUMP-&gt;l2 ... l: var l2:)    (COND      ((OPT.EQVALUE CDFROM VL)	CDFROM)      ((AND (OPT.CALLP (CAR CDFROM))	    (OR (EQ (fetch OPNAME of (CAR VL))		    (QUOTE HVAR))		(COMP.CLEANFNP (CDR (fetch OPARG of (CAR CDFROM)))			       (QUOTE FREEVARS)))	    (SETQ CDFROM (OPT.SKIPPUSH (fetch PREV of CDFROM)				       [SUB1 (CAR (fetch OPARG of (CAR CDFROM]				       VL T)))	(OPT.JUMPCOPYTEST VL CDFROM])(OPT.EQOP  [LAMBDA (OP1 OP2)                                          (* lmm " 8-JAN-82 09:04")    (OR (EQ OP1 OP2)	(AND (EQ (fetch OPNAME of OP1)		 (fetch OPNAME of OP2))	     (SELECTQ (fetch OPNAME of OP1)		      ((FVAR GVAR CONST COPY STORE)			(EQ (fetch OPARG of OP1)			    (fetch OPARG of OP2)))		      ((POP RETURN SWAP)			[OPT.CCHECK (AND (NOT (fetch OPARG of OP1))					 (NOT (fetch OPARG of OP2]			T)		      (FN (EQUAL OP1 OP2))		      [(JUMP TJUMP NTJUMP FJUMP NFJUMP BIND ERRORSET UNBIND DUNBIND)			(AND (EQ (CAR (fetch OPARG of OP1))				 (CAR (fetch OPARG of OP2)))			     (EQ (CDR (fetch OPARG of OP1))				 (CDR (fetch OPARG of OP2]		      (SETQ (OPT.EQOP (fetch OPARG of OP1)				      (fetch OPARG of OP2)))		      NIL])(OPT.EQVALUE  [LAMBDA (CD V)                                             (* lmm "19-JAN-82 22:25")    (PROG NIL      LP  (RETURN (SELECTQ (fetch OPNAME of (CAR CD))			   [COPY (COND				   ((NULL (fetch OPARG of (CAR CD)))				     (SETQ CD (fetch PREV of CD))				     (GO LP]			   [SETQ (COND				   ((EQ (fetch OPARG of (CAR CD))					(CAR V)))				   (T (SETQ CD (fetch PREV of CD))				      (GO LP]			   ((HVAR AVAR FVAR GVAR CONST)			     (EQ (CAR CD)				 (CAR V)))			   [(POP FJUMP TJUMP NFJUMP NTJUMP SWAP)			     (COND			       ((SETQ CD (OPT.SKIPPUSH (fetch PREV of CD)						       1 V))				 (GO LP]			   NIL])(OPT.DELCOPYFN  [LAMBDA (P X)                                              (* lmm "18-JAN-82 13:17")    (while (AND (OPT.CALLP (CAR P)			   NIL 1)		(OPT.EQOP (CAR P)			  (CAR (fetch NXT of X)))		(COMP.CLEANFNOP (CDR (fetch OPARG of (CAR P)))				(QUOTE NOSIDE))		(for Z&larr;P by (fetch PREV of Z) while (AND Z (NEQ Z X))		   always (SELECTQ (fetch OPNAME of (CAR Z))				   (FN (COMP.CLEANFNOP (CDR (fetch OPARG of (CAR Z)))						       (QUOTE NOSIDE)))				   ((FVAR AVAR HVAR GVAR SETQ)                                                             (* SETQ is OK since we have already guaranteed that the 							     value skipped is not modified by intervening setqs)				     T)				   NIL)))       do [SETQ P (fetch NXT of (PROG1 (fetch PREV of P)				       (OPT.PRDEL P]	  (SETQ X (fetch NXT of X)))    X]))(DEFINEQ(OPT.DEADSETQP  [LAMBDA (VAR CD)                                           (* lmm "13-Jul-84 21:18")    (DECLARE (SPECVARS ICNT))    (SELECTQ (fetch OPNAME of VAR)	     [(AVAR HVAR)	       (PROG (TAGS (ICNT 50))                        (* ICNT is used to limit the nmber of instructions 							     looked at past the setq.)                                                             (* look for dead SETQ)		     (RETURN (OPT.DS1 VAR CD]	     NIL])(OPT.DS1  [LAMBDA (VAR CD)                                           (* lmm "13-Jul-84 21:18")                                                             (* test if VAR is used in CD -- TAGS is a list of tags 							     already visited)    (PROG (A)      LP  [SELECTQ (fetch OPNAME of (SETQ A (CAR CD)))		   (SETQ (AND (EQ (fetch OPARG of A)				  VAR)			      (RETURN T)))		   (FN (AND (EQ (fetch OPNAME of VAR)				(QUOTE AVAR))			    (NOT (COMP.CLEANFNOP (CDR (fetch OPARG of A))						 (QUOTE FREEVARS)))			    (RETURN)))		   [(UNBIND DUNBIND)		     (COND		       ([FMEMB VAR (fetch (FRAME VARS) of (CDR (fetch OPARG of A]			 (RETURN T]		   [RETURN (RETURN (AND (SETQ A (OPT.CODEFRAME (fetch PREV of CD)))					(never (EQ (fetch FRAMETYPE of A)						   (QUOTE ERRORSET))					   repeatwhile (SETQ A (fetch PARENT of A]		   (JUMP (OR [SETQ CD (CAR (OPT.DEFREFS (fetch (JUMP TAG) of A]			     (RETURN))			 (GO LP))		   ((TJUMP FJUMP NTJUMP NFJUMP ERRORSET)		     (OR [OPT.DS1 VAR (CAR (OPT.DEFREFS (fetch (JUMP TAG) of A]			 (RETURN)))		   [TAG (COND			  ((FMEMB A TAGS)			    (RETURN T))			  (T (SETQ TAGS (CONS A TAGS]		   (COND		     ((EQ A VAR)		       (RETURN]          (OR (SETQ CD (fetch NXT of CD))	      (OPT.COMPILERERROR))      NX  [COND	    ((ZEROP ICNT)                                    (* DEADSETP gives up)	      (RETURN))	    (T (SETQ ICNT (SUB1 ICNT]          (GO LP]))(DECLARE: EVAL@COMPILE DONTCOPY (DECLARE: DOEVAL@COMPILE DONTCOPY(SPECVARS CODE LEVEL))(DECLARE: DOEVAL@COMPILE DONTCOPY(SPECVARS LABELS PASS ANY CODE FRAME FRAMES))(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS MERGEFRAMEMAX MERGEFRAMEFLG MERGEFRAMETYPES))(DECLARE: DOEVAL@COMPILE DONTCOPY(SPECVARS VARS ANY FRAME))(DECLARE: DOEVAL@COMPILE DONTCOPY(SPECVARS ICNT TAG))(DECLARE: DOEVAL@COMPILE DONTCOPY(SPECVARS FRAME LEVEL ANY))(DECLARE: DOEVAL@COMPILE DONTCOPY(SPECVARS FRAME LEVEL ANY))(DECLARE: DOEVAL@COMPILE DONTCOPY(SPECVARS TAGS ANY)))(* CONSISTENCY CHECKS)(DECLARE: EVAL@COMPILE DONTCOPY (DECLARE: EVAL@COMPILE [PUTPROPS OPT.CCHECK MACRO (ARGS (COND (COMPILECOMPILERCHECKS (LIST (QUOTE AND)								    (LIST (QUOTE NOT)									  (CAR ARGS))								    (LIST (QUOTE OPT.COMPILERERROR)									  (CADR ARGS])(RPAQQ COMPILECOMPILERCHECKS NIL))(DEFINEQ(OPT.COMPILERERROR  [LAMBDA (MESS1 MESS2)                                      (* lmm " 1-MAR-78 02:55")    (LISPXPRIN1 "Compiler error" T)    (HELP MESS1 MESS2])(OPT.OPTCHECK  [LAMBDA NIL                                                (* lmm "14-MAR-81 11:03")                                                             (* set up code list as doubly linked list, scan for 							     tags)    (PROG ((CD CODE)	   P B)      LPC (COND	    ((NULL CD)	      [for X in LABELS do (COND				    ((CDR X)				      [OR (FMEMB (CAR X)						 CODE)					  (OPT.COMPILERERROR (CAR X)							     (QUOTE (not in code]				      [MAPC (CDR X)					    (FUNCTION (LAMBDA (Y)						(OR (TAILP Y CODE)						    (OPT.COMPILERERROR Y (QUOTE (NOT CODE TAIL]				      [OR (EQ (CAR (CADR X))					      (CAR X))					  (OPT.COMPILERERROR X (QUOTE (TAG wrong]				      (EVERY (CDDR X)					     (FUNCTION (LAMBDA (Y)						 (OR (EQ (fetch (JUMP TAG) of (CAR Y))							 (CAR X))						     (OPT.COMPILERERROR X (QUOTE (TAG wrong]	      [for X in FRAMES do (COND				    [(EQ (CAR X)					 TOPFRAME)				      (AND (CDR X)					   (OPT.COMPILERERROR (CONS (QUOTE TOPFRAME)								    X]				    (T [for Y in (CDR X)					  do (OR (TAILP Y CODE)						 (OPT.COMPILERERROR (LIST (QUOTE (NOT IN CODE))									  Y X)))					     (OR (EQ (CDR (fetch OPARG of (CAR Y)))						     (CAR X))						 (OPT.COMPILERERROR (LIST (QUOTE (WRONG FRAME))									  Y X]				       (OR (FASSOC (fetch PARENT of (CAR X))						   FRAMES)					   (OPT.COMPILERERROR (QUOTE (PARENT NOT FRAME))							      X]	      (RETURN T)))          (SELECTQ (fetch OPNAME of (CAR CD))		   (TAG (OR (SETQ B (FASSOC (CAR CD)					    LABELS))			    (OPT.COMPILERERROR))			(OR (EQ (CAR (CDR B))				CD)			    (OPT.COMPILERERROR))			(OR (OR (NULL (fetch (TAG FRAME) of (CAR CD)))				(FASSOC (fetch (TAG FRAME) of (CAR CD))					FRAMES))			    (OPT.COMPILERERROR)))		   ((BIND ERRORSET)		     (OR (EQ (CADR (FASSOC (CDR (fetch OPARG of (CAR CD)))					   FRAMES))			     CD)			 (OPT.COMPILERERROR)))		   ((UNBIND DUNBIND)		     (OR (FMEMB CD (CDDR (FASSOC (CDR (fetch OPARG of (CAR CD)))						 FRAMES)))			 (OPT.COMPILERERROR)))		   [(JUMP TJUMP FJUMP NTJUMP NFJUMP)		     (OR (SETQ B (FASSOC (fetch (JUMP TAG) of (CAR CD))					 LABELS))			 (OPT.COMPILERERROR))		     (OR (MEMB CD B)			 (OPT.COMPILERERROR CD (QUOTE (NOT IN JUMP LIST]		   NIL)          (SETQ B (CDR CD))          (OR (AND (EQ (fetch PREV of CD)		       B)		   (EQ (fetch NXT of CD)		       P))	      (OPT.COMPILERERROR))          (SETQ P CD)          (SETQ CD B)          (GO LPC])(OPT.CCHECK  [LAMBDA (X)                                                (* lmm "14-MAR-81 09:18")    (OR X (OPT.COMPILERERROR]))(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS ALAMS BLKLIBRARY BYTE.EXT BYTEASSEMFN BYTECOMPFLG COMPILERMACROPROPS CIA CLEANFNLIST 	    COMP.SCRATCH COMPILETYPELST COMPILEUSERFN COMPSTATLST COMPSTATS CONDITIONALS CONST.FNS 	    CONSTOPS DONOTHING FILERDTBL FNA FORSHALLOW FRA GLOBALVARS HEADERBYTES HOKEYDEFPROP 	    LAMBDANOBIND LAMS LBA LEVELARRAY LINKEDFNS LINKFNS LOADTIMECONSTANT MAXBNILS MAXBVALS 	    MCONSTOPS MERGEFRAMEFLG MERGEFRAMEMAX MERGEFRAMETYPES MOPARRAY MOPCODES NLAMA NLAML 	    NODARR NOLINKFNS NOSTATSFLG NUMBERFNS OPCOPY OPNIL OPPOP OPRETURN PRA SELECTQFMEMB 	    SELECTVARTYPES STATAR STATMAX STATN SYSSPECVARS UNIQUE#ARRAY VCA VCONDITIONALS VREFFRA 	    COUTFILE XVARFLG MERGEFRAMEFLG OPTIMIZATIONSOFF NOFREEVARSFNS EQCONSTFN NEWOPTFLG))(DECLARE: DONTCOPY EVAL@COMPILE [DECLARE: EVAL@COMPILE (RECORD CODELST (OP . PREV)		[ACCESSFNS CODELST ((NXT (GETHASH DATUM PRA)					 (PUTHASH DATUM NEWVALUE PRA])](PUTPROPS OASSOC MACRO ((X Y)			(FASSOC X Y)))[DECLARE: EVAL@COMPILE (RECORD OP (OPNAME . OPARG))(RECORD JUMP (OPNAME TAG . JT)                               (* kind of OP)	     )(TYPERECORD TAG (LBNO . LEVEL)                               (* kind of OP)		LBNO &larr;(SETQ LBCNT (ADD1 LBCNT))		[ACCESSFNS TAG ((FRAME (GETHASH DATUM FRA)				       (PUTHASH DATUM NEWVALUE FRA))			    (JD (GETHASH DATUM LBA)				(PUTHASH DATUM NEWVALUE LBA])(RECORD VAR (COMP.VARTYPE . VARNAME)                         (* A particular kind of OP)	    )][DECLARE: EVAL@COMPILE (RECORD FRAME (FRAMETYPE (NNILS VARS . DECLS)			 LEVEL			 (BINDLST NVALS EXTCALL . CPIOK) . PROGLABELS)          (* FRAMETYPE is one of PROG LAMBDA ERRORSET MAP NIL -	  VARS are variables bound, NNILS are # which are bound to NIL -	  LEVEL is # of things on stack between this and next higher frame)	      (ACCESSFNS FRAME ((PARENT (GETHASH DATUM FRA)					(PUTHASH DATUM NEWVALUE FRA))			  (VREFFROM (GETHASH DATUM VREFFRA)				    (PUTHASH DATUM NEWVALUE VREFFRA))			  (NODBIND (GETHASH DATUM NODARR)				   (PUTHASH DATUM NEWVALUE NODARR))			  (PRIMARYRETURN (GETHASH DATUM BCINFO)					 (PUTHASH DATUM NEWVALUE BCINFO)))                                                             (* PARENT is next higher enclosing frame -							     shares hash table with TAG.FRAME)			 )	      (RECORD CPIOK NOXVAR                           (* Share the CPIOK field used by the compiler pass 1 							     and the NOXVAR field used by the maxc assembler)		      )	      NNILS &larr; 0)(RECORD COMINFO (COMTYPE TOPFRAME CODE ARGS))(ACCESSFNS COMP (CLEAR (PROGN (OPT.INITHASH FRA)			      (OPT.INITHASH LBA)			      (OPT.INITHASH PRA)			      (OPT.INITHASH VREFFRA)			      (OPT.INITHASH NODARR)			      (OPT.INITHASH BCINFO))))(RECORD JD (JPT (JMIN . JSN)		JU . JML)          (* JPT is NIL (for tags) or a pointer into ACODE (for jumps). JMIN is the lowest possible location for the 	  instruction or tag. JU is the cumulative uncertainty (for tags) or the length uncertainty (for jumps). JML is the 	  minimum length (for jumps). JSN is a serial number (the original JMIN) used to decide whether a jump goes forward or	  backward.)	   )])(DECLARE: EVAL@COMPILE [PUTPROPS THETYPE MACRO ((THETYPE . FORMS)	   ([LAMBDA (THEVALUE)		    (DECLARE (LOCALVARS THEVALUE)			     (TYPE THETYPE THEVALUE))		    THEVALUE] . FORMS])(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML OPT.INITHASH)(ADDTOVAR LAMA ))(PUTPROPS BYTECOMPILER COPYRIGHT ("Xerox Corporation" 1981 1982 1983 1984 1985))(DECLARE: DONTCOPY  (FILEMAP (NIL (6855 11889 (BYTEBLOCKCOMPILE2 6865 . 8336) (BYTECOMPILE2 8338 . 8575) (COMP.ATTEMPT.COMPILE 8577 . 9561) (COMP.RETFROM.POINT 9563 . 10227) (COMPERROR 10229 . 10655) (COMPPRINT 10657 . 10908) (COMPERRM 10910 . 11887)) (11890 17278 (COMP.TOPLEVEL.COMPILE 11900 . 14662) (COMP.BINDLIST 14664 . 14922) (COMP.CHECK.VAR 14924 . 15371) (COMP.BIND.VARS 15373 . 16887) (COMP.UNBIND.VARS 16889 . 17276)) (17279 26630 (COMP.VALN 17289 . 17418) (COMP.PROGN 17420 . 17988) (COMP.PROGLST 17990 . 18721) (COMP.EXP1 18723 . 18867) (COMP.EXPR 18869 . 21235) (COMP.TRYUSERFN 21237 . 21464) (COMP.USERFN 21466 . 21926) (COMP.CONST 21928 . 22739) (COMP.CALL 22741 . 24221) (COMP.VAR 24223 . 24696) (COMP.VAL1 24698 . 24827) (COMP.PROG1 24829 . 25166) (COMP.EFFECT 25168 . 25606) (COMP.VAL 25608 . 26021) (COMP.MACRO 26023 . 26628)) (26631 28171 (COMP.VARTYPE 26641 . 26870) (COMP.LOOKUPVAR 26872 . 27804) (COMP.LOOKUPCONST 27806 . 28169)) (28172 34128 (COMP.ST 28182 . 28557) (COMP.STFN 28559 . 28853) (COMP.STCONST 28855 . 29015) (COMP.STVAR 29017 . 29149) (COMP.STPOP 29151 . 29303) (COMP.DELFN 29305 . 29524) (COMP.STRETURN 29526 . 29694) (COMP.STTAG 29696 . 30495) (COMP.STJUMP 30497 . 31891) (COMP.STSETQ 31893 . 32132) (COMP.STCOPY 32134 . 32310) (COMP.DELPUSH 32312 . 32471) (COMP.DELPOP 32473 . 32637) (COMP.STBIND 32639 . 33715) (COMP.STUNBIND 33717 . 34126)) (34129 36370 (COMP.ARGTYPE 34139 . 34802) (COMP.CLEANEXPP 34804 . 35071) (COMP.CLEANFNP 35073 . 35389) (COMP.CLEANFNOP 35391 . 35535) (COMP.GLOBALVARP 35537 . 35710) (COMP.LINKCALLP 35712 . 36105) (COMP.ANONP 36107 . 36368)) (36371 38743 (COMP.CPI 36381 . 37671) (COMP.CPI1 37673 . 38245) (COMP.PICOUNT 38247 . 38741)) (38783 38981 (COMP.EVQ 38793 . 38979)) (39085 40781 (COMP.BOOL 39095 . 40779)) (40782 41139 (COMP.APPLYFNP 40792 . 41137)) (41305 41813 (COMP.AC 41315 . 41492) (COMP.PUNT 41494 . 41811)) (41863 43278 (COMP.FUNCTION 41873 . 42218) (COMP.LAM1 42220 . 42797) (COMP.GENFN 42799 . 43276)) (43540 49575 (COMP.COND 43550 . 45897) (COMP.SELECTQ 45899 . 49573)) (49746 50268 (COMP.QUOTE 49756 . 49983) (COMP.COMMENT 49985 . 50266)) (50316 51916 (COMP.DECLARE 50326 . 51209) (COMP.DECLARE1 51211 . 51914)) (54571 55357 (COMP.CARCDR 54581 . 55169) (COMP.STCROP 55171 . 55355)) (55437 55776 (COMP.NOT 55447 . 55774)) (55859 56603 (COMP.SETQ 55869 . 56387) (COMP.SETN 56389 . 56601)) (56604 59261 (COMP.LAMBDA 56614 . 59259)) (59385 64203 (COMP.PROG 59395 . 61740) (COMP.GO 61742 . 62653) (COMP.RETURN 62655 . 64201)) (66474 74293 (COMP.NUMERIC 66484 . 70301) (COMP.NUMBERCALL 70303 . 73134) (COMP.FIX 73136 . 73284) (COMP.STFIX 73286 . 73820) (COMP.DELFIX 73822 . 74291)) (74409 75786 (COMP.EQ 74419 . 75784)) (75844 78062 (COMP.NUMBERTEST 75854 . 78060)) (79157 85035 (COMP.MAP 79167 . 85033)) (86486 88773 (COMP.MLLIST 86496 . 87027) (COMP.MLL 87029 . 88166) (COMP.MLLVAR 88168 . 88439) (COMP.MLLFN 88441 . 88771)) (89701 93389 (OPT.RESOLVEJUMPS 89711 . 90524) (OPT.JLENPASS 90526 . 92581) (OPT.JFIXPASS 92583 . 93062) (OPT.JSIZE 93064 . 93387)) (93430 95686 (OPT.CALLP 93440 . 93815) (OPT.JUMPCHECK 93817 . 94018) (OPT.DREV 94020 . 94204) (OPT.CHLEV 94206 . 94397) (OPT.CHECKTAG 94399 . 94749) (OPT.NOTJUMP 94751 . 95105) (OPT.INITHASH 95107 . 95347) (OPT.COMPINIT 95349 . 95684)) (95894 96629 (OPT.CFRPTQ 95904 . 96627)) (97451 103544 (COMP.AREF 97461 . 98441) (COMP.ASET 98443 . 99440) (COMP.BOX 99442 . 99940) (COMP.LOOKFORDECLARE 99942 . 100452) (COMP.DECLARETYPE 100454 . 100971) (COMP.FLOATBOX 100973 . 101227) (COMP.FLOATUNBOX 101229 . 102068) (COMP.PREDP 102070 . 102254) (COMP.UBFLOAT2 102256 . 102757) (COMP.UNBOX 102759 . 103542)) (103607 145894 (OPT.POSTOPT 103617 . 105133) (OPT.SETUPOPT 105135 . 106702) (OPT.SCANOPT 106704 . 113257) (OPT.XVARSCAN 113259 . 114222) (OPT.XVARSCAN1 114224 . 114859) (OPT.JUMPOPT 114861 . 115227) (OPT.JUMPTHRU 115229 . 120120) (OPT.LBMERGE 120122 . 120672) (OPT.PRDEL 120674 . 121019) (OPT.UBDEL 121021 . 121260) (OPT.LBDEL 121262 . 121719) (OPT.LABELNTHPR 121721 . 122416) (OPT.JUMPREV 122418 . 131498) (OPT.COMMONBACK 131500 . 133704) (OPT.DELTAGREF 133706 . 134019) (OPT.FINDEND 134021 . 134331) (OPT.RETOPT 134333 . 135376) (OPT.RETFIND 135378 . 135753) (OPT.RETPOP 135755 . 137711) (OPT.RETOPT1 137713 . 138014) (OPT.RETTEST 138016 . 140897) (OPT.RETMERGE 140899 . 143396) (OPT.CODELEV 143398 . 144743) (OPT.CODEFRAME 144745 . 145546) (OPT.DEFREFS 145548 . 145684) (OPT.SETDEFREFS 145686 . 145892)) (145895 157002 (OPT.FRAMEOPT 145905 . 146572) (OPT.FRAMEMERGE 146574 . 148351) (OPT.NONILVAR 148353 . 149073) (OPT.MERGEFRAMEP 149075 . 150044) (OPT.FRAMELOCAL 150046 . 150706) (OPT.CLEANFRAME 150708 . 151061) (OPT.FRAMEDEL 151063 . 153917) (OPT.FRAMEVAR 153919 . 156332) (OPT.DELETEFRAMECHECK 156334 . 156824) (OPT.ONLYMEMB 156826 . 157000)) (157084 163515 (OPT.SKIPPUSH 157094 . 158656) (OPT.DELCODE 158658 . 159718) (OPT.PRATTACH 159720 . 160181) (OPT.JUMPCOPYTEST 160183 . 160977) (OPT.EQOP 160979 . 161861) (OPT.EQVALUE 161863 . 162566) (OPT.DELCOPYFN 162568 . 163513)) (163516 165598 (OPT.DEADSETQP 163526 . 164019) (OPT.DS1 164021 . 165596)) (166513 169529 (OPT.COMPILERERROR 166523 . 166697) (OPT.OPTCHECK 166699 . 169384) (OPT.CCHECK 169386 . 169527)))))STOP</pre>
  </body>
</html>
