<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>JCAI>sources>LispDMC.DM!2>LGC.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">:Title[LGC.mc];<br>*<br>* Edit History<br>* March 13, 1985  9:46 AM, Masinter, remove call to SAVEUCODESTATE<br>* January 19, 1985  2:38 PM, Masinter, add nop before repNIL to break ring<br>* February 9, 1984  3:28 AM, JonL, added a "cancel BDispatch" at .htpunt<br>* February 9, 1984  12:20 AM, JonL, remove A&larr; Id from GCOPTAIL; <br>* January 26, 1984  10:31 PM, JonL, Globalize GCLOOKUP; change .htprobe<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DispTable size from 5 to 3.<br>* January 13, 1984  9:25 PM, JonL, moved in REPNIL from lstack<br>* January 3, 1984  9:00 PM, JonL, .gcscanfail tails to REPNIL<br>* December 27, 1983  5:55 PM, JonL, Replaced GCLOOKT1 with <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">GCADDREF and GCDELREF<br>* December 27, 1983  11:42 AM, JonL, changed A0 to (Case) - (Case), <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> re-arranged GCLOOKT1 exit code<br>* December 21, 1983  9:21 AM, JonL, removed one inst from RPLPTR<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">opGCSCAN from LOW<br>* December 20, 1983  9:02 AM, JonL, AT.GCMAPTABLE and AT.HANDLEOVERFLOW<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">given correct meanings, and tail GCREF into REPNIL<br>* December 6, 1982  1:44 PM, Masinter<br>*<br>   KnowRBase[LTEMP0];<br>TOP LEVEL;<br>   InsSet[LispInsSet, 1];<br><br><br><br>:if[Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[25];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[24];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* GCREF and RPLPTR<br>:else;<br><br>*--------------------------------------------------------------------<br>opGCREF:</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>*--------------------------------------------------------------------<br>* Modify refcnt of argument, according to Case (obtained from id)<br>* Returns argument iff resultant refcnt is 0<br>   Case&larr; (Id) + (100000c);<br>   T&larr; (fetch&larr; TSP) + 1, call[GCLOOKUP];<br>   pd&larr; T, memBase&larr; StackM2BR;<br>   Branch[.+2, alu#0], pd&larr; T and (htstkcnt);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Null entry means a<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[REPNIL];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  refcnt of 1<br>   Branch[.+2, alu#0];<br>   </span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">nop;<br><br>REPNIL:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">GLOBAL,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Smashes a NIL onto top of stack<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (AtomHiVal), Branch[TL.REPNIL2];<br><br>TL.REPNIL2:<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">  Assumes TSP is correct and StackM2BR is memBase<br>   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; AT.NIL, NextOpCode;<br><br>regOP2[25, StackM2BR, opGCREF, noNData];<br><br><br>*--------------------------------------------------------------------<br>opRPLPTR:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* takes (PTR VAL) on stack, alpha byte is offset<br>*--------------------------------------------------------------------<br>* Replace pointer at PTR+offset with VAL, doing two reference counts<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (TSP) - (4c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; T&larr; (fetch&larr; T) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* segno of PTR address<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, LEFT&larr; (LEFT) + 1, memBase&larr; LScratchBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Id) + (T);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, carry&rsquo;], BrLo&larr; T;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (LTEMP0) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Crossed a segment boundary<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrHi&larr; LTEMP0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Setup BR to point to cell<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; 0s) + 1, Branch[RPLPTR1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Start fetch of cell<br><br>regOP2[24, StackBR, opRPLPTR, noNData];<br><br><br>* Note that we are still under the influence of an :else "NotReduced"<br><br>*--------------------------------------------------------------------<br>RPLPTR1:<br>*--------------------------------------------------------------------<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Tail into here with LScratchBR pointing to cell to smash<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; 0s) + 1 just done<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP contains value to put into cell<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Case&larr; 1c, Call[GCLOOKUP];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* deleteref old pointer<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP &larr; (TSP) - (2c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR;<br><br>*--------------------------------------------------------------------<br>RPLPTRTAIL:<br>*--------------------------------------------------------------------<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Tail into here with LScratchBR pointing to cell to smash<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP contains value to put into cell<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Case&larr; T - T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1, Call[GCLOOKUP];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* addref new value<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; LScratchBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; 0s;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and (lhmask);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + (LTEMP0);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* put high bits back<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; 0s, dbuf&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* store new value<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; 1s, dbuf&larr; LTEMP1;<br><br>*--------------------------------------------------------------------<br>GCOPTAIL:<br>*--------------------------------------------------------------------<br>* Final check, after an instruction has munged around with GCREF stuff,<br>*    as to whether there are collision entries in the overflow table, <br>*    or some space&rsquo;s cons counter has exceeded its maximum.  Note that<br>*    the latter condition has priority, since its associated function<br>*    does both kinds of actions.<br>* A lot of instructions branch to here, but it needn&rsquo;t be global since<br>*    these instructions often can use a full branch<br><br>   pd&larr; (PSTATE) and (or[PS.HTCNTFULL!, PS.HTOVERFLOW!]c);<br>   Branch[.+2, alu#0], PSTATE&larr; (PSTATE) and not (PS.HTOVERFLOW);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Neither bit is set<br>   Branch[.+2, alu#0], PSTATE&larr; (PSTATE) and not (PS.HTCNTFULL);<br>       DEFLO&larr; AT.HANDLEOVERFLOW, Branch[.gcoptl1];* PS.HTOVERFLOW set<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; AT.GCMAPTABLE;   </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   *  else PS.HTCNTFULL<br>.gcoptl1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; (1c), Branch[DOCALLPUNT];<br><br><br><br>* Note that we are still under the influence of an :else "NotReduced"<br><br>SUBROUTINE;<br><br>*--------------------------------------------------------------------<br>GCADDREF:<br>*--------------------------------------------------------------------<br>* Enter with LTEMP0, LTEMP1 containing pointer to be "counted",<br>*   and with T&larr; LTEMP0. <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; tyBaseBR, Case&larr; T - T,</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Goto[.gclkup2];<br>*--------------------------------------------------------------------<br>GCDELREF:<br>*--------------------------------------------------------------------<br>* Enter with LTEMP0, LTEMP1 containing pointer to be "counted". <br>*   and with T&larr; LTEMP0. <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; tyBaseBR, Case&larr; T - T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Case&larr; (Case) + 1,</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Goto[.gclkup2];<br><br>*--------------------------------------------------------------------<br>GCLOOKUP: GLOBAL,<br>*--------------------------------------------------------------------<br>* Enter with Case =  0 =&gt; add 1 to refcnt<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">1 =&gt; sub 1 from refcnt<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">2 =&gt; turn on stkref bit<br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> T&larr; (fetch&larr; hi.word) + 1 done<br>* Do the refcnt operation on the contents of the cell whose lo.word <br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">is currently being pointed to by T (modulo memBase)<br>* Exit with LTEMP0, LTEMP1 containing pointer (which was "counted") <br>* </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T has entry in htable<br>   T&larr; MD, fetch&larr; T, Goto[.gclkup1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Could fault<br><br>*--------------------------------------------------------------------<br>GCLOOKUP1: <br>*--------------------------------------------------------------------<br>* Do the refcnt operation on the contents of the cell whose lo.word <br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">is currently being pointed to by TSP (modulo memBase); otherwise,<br>*  this is the same as GCLOOKUP<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Could fault, so callers<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; MD, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  should have set PSTATE<br>.gclkup1:<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and (rhmask), LTEMP1&larr; Md;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Lo.word of cell shouldn&rsquo;t<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; tyBaseBR, LTEMP0&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  fault, since hi.word won<br><br>.gclkup2:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Here, both T and LTEMP0 must contain the hiword of the ptr<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; rcy[T, LTEMP1, 11];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Each typetable entry is<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  for a double page<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PROBE&larr; Md, memBase&larr; htMainBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&gt;=0], pd&larr; (PROBE) and (TT.LISPREF);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, Return;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* TT.NOREF bit was set<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0], T&larr; (LTEMP1) rsh 1;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Punt, if type is such that datum must be refcnt&rsquo;d by Lisp code.<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; Link, Branch[.htpunt];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PROBE &larr; fetch &larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch GC main table entry<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ENTRY &larr; Md, T&larr; (LTEMP0) + (LTEMP0);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; (LTEMP0) lsh 1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R even], pd&larr; ENTRY;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Bit 15 is "linkp" bit<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; Link, Branch[.htpunt];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Punt when entry is chain <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DblBranch[.htempty, .htnotempty, alu=0],</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  link to collision table <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; Link;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Save Link before dispatch<br><br>TOP LEVEL;<br><br>.htempty:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BDispatch&larr; Case;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T or (ht1cnt), Branch[.htprobe];<br><br>.htnotempty:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ldf[ENTRY, 10, 1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* get hi addr bits of entry<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T xor (LTEMP0);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* compare hi bits of pointer<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0], pd&larr; (ENTRY) + (add[ht1cnt!, ht1cnt!]c);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.htpunt];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Punt when pointer in table <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, carry&rsquo;], BDispatch&larr; Case;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  is not same as argument<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.htpunt];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Also, punt if cnt field<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ENTRY, Branch[.htprobe]; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  size about to be exceeded<br><br>.htprobe:   DispTable[3],<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + (ht1cnt), Branch[.htstore];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* case 0: addref<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T - (ht1cnt), Branch[.htstore];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* case 1: delref<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T or (htstkbit), Branch[.htstore];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* case 2: stkref<br><br>.htstore:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; T and (htStkCnt);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (LTEMP3) xor (ht1cnt), Branch[.htxit];<br><br>* Grumble, the following DispTable is effectively a "Cancel BDispatch"<br>*   for the BDispatch generated in the conditional branch above.<br>.htpunt:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">DispTable[1,3,3],<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&gt;=0], Case, T&larr; A0, MemBase&larr; htOfloBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;<br>* When Case negative, do UFN immediately (this should only be used by<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> the GCREF opcode)<br>* Otherwise, enter the puntout address in the "overflow" table<br>*   for future processing by \GC.HANDLEOVERFLOW<br>.htpuntloop:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0], PSTATE&larr; (PSTATE) or (PS.HTOVERFLOW);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + 1, Branch[.htpuntloop];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; (store&larr; T) - 1, dbuf&larr; LTEMP1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[Case, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + (LTEMP0);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; LTEMP3, dbuf&larr; T;<br>SUBROUTINE;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Link&larr; LTEMP2;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Return;<br><br>.htxit:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu=0], Link&larr; LTEMP2;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; PROBE, dbuf&larr; T, Return;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Normal return -- table entry<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; PROBE, T&larr; (dbuf&larr; 0c), Return;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  but return 0 when count is 1<br><br>TOPLEVEL;<br><br>:endif;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Reduced<br><br>*--------------------------------------------------------------------<br>* scan GC tables<br>*--------------------------------------------------------------------<br><br>:if[Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[173];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[174];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* GCSCAN1 and GCSCAN2<br>:else;<br><br>*--------------------------------------------------------------------<br>opGCSCAN1:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (TSP) - 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T, LTEMP0&larr; (-2c), branch[.gcscan];<br><br>*--------------------------------------------------------------------<br>opGCSCAN2:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (TSP) - 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T, LTEMP0&larr; (HTSTKBIT), branch[.gcscan];<br><br>.gcscan:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, memBase&larr; htMainBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; (LTEMP1) - 1, Q&larr; LTEMP1;<br><br>.gcscanlp:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.gcscanfail, R&lt;0], LTEMP1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; (fetch&larr; LTEMP1) - 1, Q&larr; LTEMP1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; Md, T&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R even], pd&larr; (LTEMP2) and T;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR, TSP&larr; (TSP) - 1, branch[.gcfoundret];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.gcscanlp, alu=0], pd&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">dblbranch[.gcfound1, .gcfound2, alu&lt;0], pd&larr; (LTEMP2) and (HTSTKCNT);<br><br>.gcfound1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.gcfoundret, alu=0], memBase&larr; StackBR, TSP&larr; (TSP) - 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; htMainBR, TSP&larr; (TSP) + 1, branch[.gcscanlp];<br><br>.gcfound2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; (LTEMP2) and not T, memBase&larr;htMainBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Turn off stkbit<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP2) and (HTSTKCNT);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T - (HT1CNT);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; Q, dbuf&larr; T, branch[.gcscanlp];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Refcnt went to 1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; Q, dbuf&larr; LTEMP2, branch[.gcscanlp];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Restore word<br><br>.gcfoundret:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; Q, NextOpCode;<br><br>.gcscanfail:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackM2BR, branch[REPNIL];<br><br>regOP1[173, StackBR, opGCSCAN1, NoNData];<br>regOP1[174, StackBR, opGCSCAN2, NoNData];<br><br>:endif; * reduced<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
