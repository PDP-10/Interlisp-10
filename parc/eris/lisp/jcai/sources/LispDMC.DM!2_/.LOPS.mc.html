<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>JCAI>sources>LispDMC.DM!2>LOPS.mc</title>
  </head>
  <body>
    <pre>
   :Title[LOPS];* Edit history:* Masinter, August 7, 1985  8:25 PM, add EQL, EQUAL* March 29, 1985  2:01 PM, make MISC1 also turn on ether* March 29, 1985  11:00 AM, Masinter, make CREATECELL ufn if free list NIL* March 22, 1985, 12:04, Masinter, change TYPEMASK, reformat* January 21, 1985  12:00 PM,  Masinter, unglobal REPSMALLT* January 19, 1985  1:56 PM, Masinter, add TYPEMASK, assume TYPREV masks bits* March 5, 1984  7:30 PM, JonL, added opMISC1 (alpha 9) for opRWMufMan*	 (and retracted opRWMufMan as an opcode).  GLOBALized REPSMALLT* February 18, 1984  2:47 PM, JonL, added opRWMufMan* February 18, 1984  12:53 PM, JonL, fix parity of branch condition for*	opEVAL of litatom; tried BDispatch in opEVAL again* February 2, 1984  5:08 PM, JonL, opBIN checks bits[4:7] of BR for zero* January 26, 1984  7:40 PM, JonL, spawned LLISTP off from this file;*		opEVAL uses BDispatch.* January 26, 1984  6:59 PM, JonL, opNOP and NEXTOP to LJUMP* January 7, 1984  5:38 PM, JonL, added commentary on TYPEP* January 6, 1984, 8:18 AM, JonL, fixed TL.CREATECELL to take an arg in*	NARGS which is the number of words to "pull back" on TSP* December 29, 1983  6:59 PM, JonL, "bubbled" inst in CREATECELL *	{memBase&larr; StackM2BR, T&larr; TSP} into previous inst, and replaced *	a few "0c"'s with (atomHiVal)'s;  changed (MaxConsCount) test in*	CREATECELL to use carry'; TYPEP tails into REPSMT2; shortened BIN *	by saving CCOFF in T over DOGETBYTE, and tailing into REPSMALLT*	Put error checking into WRITEPRINTERPORT; CDR tails into*	TL.PUSHNIL etc* December 27, 1983  6:30 PM, JonL, changed calls to GCLOOKT1 into calls *	to GCADDREF or GCDELREF* December 26, 1983  6:53 PM, JonL, move in opEQ and opNOP from LOW,*	let opEQ call ABFETCH and tail-out into TL.PUSHTRUE (or NIL)* December 26, 1983  6:40 PM, JonL, fixed callers of TYPREV to watch out *	for non-zero TT.*** bits* December 21, 1983  5:15 AM, JonL, opRCLK from LOW, NEXTOP from from *	LSTACK, moved opPOP to LSTACK, tailed opNTYPX into REPSMALLT* December 19, 1983  1:01 PM, JonL, TL.CREATECELL. Args in CELLHINUM and*	CELLLONUM * December 15, 1983  3:42 PM, JonL, Put in labels REPSMALLT and TL.REPT* November 29, 1983  4:42 PM, Masinter, change carry to &lt; on createcell   KnowRBase[LTEMP0];   TOP LEVEL;   InsSet[LispInsSet, 1];*--------------------------------------------------------------------SUBROUTINE;	TYPREV:	* Get type of datum from cell being fetched from T*--------------------------------------------------------------------* Enter having done *  T&larr; (fetch&larr; &lt;someLoc&gt;) + 1,   call[TYPREV];* Exit with Ahi in LTEMP0*           Alo in LTEMP1*           typenumber in T   T&larr; LTEMP0&larr; Md, fetch&larr; T;   LTEMP1&larr; Md, memBase&larr; tybaseBR;   T&larr; RCY[T, LTEMP1, 11];   fetch&larr; T, T&larr; (rhmask);   T&larr; (T) and (Md), memBase&larr; StackM2BR, return;TOP LEVEL;*--------------------------------------------------------------------opEQ:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[ABFETCH];	T&larr; Md, TSP&larr; (fetch&larr; T) - 1;	T&larr; Md, pd&larr; T xor (LTEMP0);	branch[.+2, alu=0], pd&larr; (T) xor (LTEMP1);	  LEFT&larr; (LEFT) + 1, branch[.neq];	branch[.neq, alu#0], LEFT&larr; (LEFT) + 1;	  TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), branch[TL.PUSHTRUE];.neq:	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), branch[TL.PUSHNIL];regOP1[360, StackM2BR, opEQ, noNData];*--------------------------------------------------------------------opEQL:  *--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase, call[ABFETCH];	T&larr; Md, TSP&larr; (fetch&larr; T) - 1;	pd&larr; T xor (LTEMP0);	branch[.+2, alu=0], pd&larr; (Md) xor (LTEMP1);	  LEFT&larr; (LEFT) + 1, branch[.neql];	branch[.+2, alu#0], LEFT&larr; (LEFT) + 1;	  TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), branch[TL.PUSHTRUE];.NEQL:	PD &larr; LTEMP0;	branch[.+2, alu#0], pd &larr; T;		TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), branch[TL.PUSHNIL];	branch[.+2, alu#0];		TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), branch[TL.PUSHNIL];	TSP &larr; (TSP) + (4C);opEQUAL:	CallUFN;regOP1[72, StackM2BR, opEQL, NoNData];    * EQLregOP1[364, StackM2BR, opEQL, NoNData]; * EQUAL*--------------------------------------------------------------------opNTYPX:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1,   call[TYPREV];*--------------------------------------------------------------------REPSMALLT:  	*--------------------------------------------------------------------*    Store a smallp into the Top-of-Stack slot;*    Assumes TSP is correct and StackM2BR is memBase	PAGEFAULTNOTOK;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; smallHi;REPSMT2:	TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;regOP1[4, StackM2BR, opNTYPX, noNData];*--------------------------------------------------------------------opDTEST:		* test if type name of tos = arg, ufn if not*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1, call[TYPREV];	memBase&larr; dtdBR;				* fetch type name of DTD	T&larr; LSH[T, 4];PAGEFAULTOK;	FETCH&larr; T, T &larr; LTEMP0, RisID;		* This is like T&larr; (Id);	T&larr; LSH[T, 10];				* Get the litatom index	T&larr; (Id) + T;				* same ID	pd&larr; T - (MD);PAGEFAULTNOTOK;	branch[.+2, alu=0];		CallUFN;			* type disagree	NextOpCode;regOP3[6, StackM2BR, opDTEST, noNData]; * this one is "coerce"regOP3[56, StackM2BR, opDTEST, noNData]; * this one is "typecheck"*--------------------------------------------------------------------opTYPEP:		* TYPEP, LISTP same code*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1, call[TYPREV];	pd&larr; (Id) xor T;.typepTAIL:	branch[.+2, alu#0], T&larr; AT.NIL;		NextOpcode;			* Continue if type same	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), * Otherwise, return NIL		branch[TL.REPNIL2];regOP1[3, StackM2BR, opTYPEP, listType!];regOP2[5, StackM2BR, opTYPEP, noNData];*--------------------------------------------------------------------opTYPEMASK:		* used for NUMBERP, FIXP, etc.*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;   T&larr; Md, fetch&larr; T;   LTEMP1&larr; Md, memBase&larr; tybaseBR;   T&larr; RCY[T, LTEMP1, 11];   fetch&larr; T;   T&larr; Md, memBase&larr; StackM2BR;   T&larr; RSH[T,10];   pd&larr; (Id) and T;   branch[.+2, alu=0], T&larr; AT.NIL;      NextOpcode;			* Continue if type same   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), branch[TL.REPNIL2];regOP2[63, StackM2BR, opTYPEMASK, noNData];*--------------------------------------------------------------------opCREATECELL:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1;	T&larr; Md, CELLHINUM &larr; (fetch&larr; T) - T;	* TOS = typenumber	pd&larr; NARGS&larr; T - (SmallHi);		* NARGS&larr; 0 if normal 	branch[.+2, alu=0], T&larr; Md, memBase&larr; dtdBR, CELLLONUM &larr; T - T;		  CallUFN;				* non-small arg	T&larr; LSH[T, 4];				* 2&uarr;4 wds per entryTL.CREATECELL:* Enter with T has the datatype number multiplied by the number of *  words per DTD entry;* DEFHI has hiword value for first cell* DEFLO has loword value for first cell* NARGS has the number of words to "pull back" on TSP when done* memBase is dtdBR	T&larr; T + (DTD.FREE);		* fetch free list	LTEMP2&larr; T&larr; (fetch&larr; T) + 1;	* fetch head of free list	LTEMP0&larr; Md, T&larr; (fetch&larr; T) + (sub[DTD.SIZE!, add[DTD.FREE!, 1]]c); 	pd&larr; LTEMP0;			* LTEMP0, LTEMP1 &larr; freelist head	branch[.+2, alu#0], LTEMP1&larr; Md, fetch&larr; T;	  CallUFN;    			* free list is empty	LTEMP3&larr; Cnt&larr; Md;		* LTEMP3, Cnt &larr; size in wds	branch[.+2, Cnt#0&amp;-1], memBase&larr; ScratchLZBR;	  UCodeCheck[allocateZeroSizeCell];	BrHi&larr; LTEMP0;PAGEFAULTOK;	T&larr; (FETCH&larr; LTEMP1) + 1;		* fetch contents of free	branch[.+2, Cnt#0&amp;-1], LTEMP4&larr; MD, T&larr; (fetch&larr; T) - (2c);		UCodeCheck[allocateOneSizeCell];PAGEFAULTNOTOK;	LTEMP3&larr; Md, T&larr; T + (LTEMP3);				* loloc+size-1.clearnew:PAGEFAULTOK;	T&larr; (STORE&larr; T) - 1, dbuf&larr; 0c, branch[., Cnt#0&amp;-1];PAGEFAULTNOTOK;.cleardone:* All but first word has been cleared. Store args into 1st and 2nd word   T&larr; (store&larr; T) +1, dbuf&larr; CELLHINUM;   store&larr; T, dbuf&larr; CELLLONUM;	T&larr; LTEMP2, memBase&larr; dtdBR;		* store new free cell	T&larr; (store&larr; T) - 1, dbuf&larr; LTEMP3;	store&larr; T, pd&larr; dbuf&larr; LTEMP4;	branch[.+2, alu#0], LTEMP2&larr; (LTEMP2) +		 (sub[DTD.COUNTER!,add[1,DTD.FREE!]]c);	   PSTATE&larr; (PSTATE) or (PS.HTCNTFULL);	* freelist became empty ?   fetch&larr; LTEMP2;   T&larr; (Md) + 1;					* Add 1 to conscounter   store&larr; LTEMP2, dbuf&larr; T;   pd&larr; T - (MaxConsCount);	T&larr; NARGS, FreezeBC;   branch[.+2, carry'], T&larr; TSP&larr; (TSP) - T, memBase&larr; StackM2BR;				* Exceeded MaxConsCount allocations of this type ?	   PSTATE&larr; (PSTATE) or (PS.HTCNTFULL);	* Result is address of newly allocated cell, which is smashed onto TOS   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;   store&larr; T, dbuf&larr; LTEMP1;*		DELREF on new cell, so implicit refcnt of 1 goes to 0	Case&larr; 1c, Call[GCLOOKUP1];	   LTEMP4&larr; (4c), Branch[GCOPTAIL];regOP1[37, StackM2BR, opCREATECELL, noNData];*--------------------------------------------------------------------opBIN:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1, call[TYPREV];	* returns with type in T	PD&larr; (Id) xor T, memBase&larr; ScratchLZBR;	* Set ScratchLZR to base of	Branch[.+2, alu=0], BrHi&larr; LTEMP0;	*  segment containg STREAMP	   CallUFN;				* Arg not a STREAMP ?PAGEFAULTOK;	T&larr; (FETCH&larr; LTEMP1) + 1;	LTEMP0&larr; MD, T&larr; (fetch&larr; T) + 1;		* LTEMP0 &larr; CCOFFPAGEFAULTNOTOK;	T&larr; Md, LTEMP2&larr; (fetch&larr; T) + 1;		* T &larr; NCCHARS	LTEMP0&larr; Md, pd&larr; T - (Q&larr; LTEMP0) - 1;	* LTEMP0 &larr; HiBuf, Q  &larr; CCOFF															* also pd&larr; NCCHARS-CCOFF-1	Branch[.+2, carry], LTEMP2&larr; (fetch&larr; LTEMP2) - (3c);	   CallUFN;				* Punt -- end of bufload	Branch[.+2, R&lt;0], LTEMP0, memBase&larr; ScratchBR;	   CallUFN;				* Punt -- readable bit off	T&larr; Md, pd&larr; (LTEMP0) and (7400c);	Branch[.+2, alu=0], BrHi&larr; LTEMP0;	*setup BR to base of buffer	  uCodeCheck[ExtraBitsInBufferAddress];	BrLo&larr; T, T&larr; LTEMP1&larr; Q, Call[.getByte];	*  and actually fetch byte	memBase&larr; ScratchLZBR, T&larr; T + 1;		* Now increment CCOFF	store&larr; LTEMP2, dbuf&larr; T;	memBase&larr; StackM2BR, T&larr; LTEMP1, Branch[REPSMALLT];regOP1[40, StackM2BR, opBIN, streamType!];*--------------------------------------------------------------------opMISC1:*--------------------------------------------------------------------* One arg miscellaneous opcode	T&larr; ID;	pd&larr; (T) - (11c);	Branch[opRWMufMan, alu=0], pd&larr; (T) - (12c);	Branch[Reset10MBEther, alu=0];	   callUFN;regOP2[170, StackM2BR, opMISC1, noNData];*--------------------------------------------------------------------opRWMufMan:*--------------------------------------------------------------------* One arg, a PosSMALLP, whose low-order 11 bits are a Muffler/Manifold*	address.  If the high-order bit (i.e., 2&uarr;15) is off, then read the*	the addressed muffler and return it's bit as the high-order bit of*	a PosSMALLP; if it is on, then execute the corresponding Manifold*		operation and return NIL.	T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX1];	T&larr; 13s;	pd&larr; LTEMP0, Cnt&larr; T;	Branch[.+2, alu=0],TSP&larr; (TSP) + (2c);	* Restore TSP		CallUfn;	flipMemBase;	* Both exits expect memBase to be StackM2Br.rwmmlp:		MidasStrobe&larr; Q;		* 11. iterations of strobe	Q lsh 1;		* and shift	nop;	Branch[.rwmmlp, Cnt#0&amp;-1];	Branch[.+2, R&gt;=0], LTEMP1;	* Don't do flipMembase here, 	  UseDMD, Branch[REPNIL];	*  because that constrains 	T&larr; ALUFMEM, Branch[REPSMALLT];	*  too many locations*--------------------------------------------------------------------opRCLK:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;   LTEMP0&larr; Md, fetch&larr; T, T&larr; (30c);		* LTEMP0 &larr; HiAddr to clobber   LTEMP1&larr; Md, memBase&larr; MDS;			* LTEMP1 &larr; LoAddr to clobber   T&larr; T + (400c);   taskingOff;   fetch&larr; T;									* fetch word 430 for hi part of clock   LTEMP2&larr; Md, rbase&larr; rbase[RTClock];		* LTEMP2 &larr; hiword of clock   T&larr; RTClock;					* T &larr; loword of clock   taskingOn;	   rbase&larr; rbase[LTEMP0];   memBase&larr; ScratchLZBR;   BrHi&larr; LTEMP0;PAGEFAULTOK;   LTEMP1&larr; (store&larr; LTEMP1) + 1, dbuf&larr; Md;PAGEFAULTNOTOK;   store&larr; LTEMP1, dbuf&larr; T, nextOpCode;regOP1[167, StackM2BR, opRCLK, noNData];*--------------------------------------------------------------------opREADPRINTERPORT:*--------------------------------------------------------------------	T&larr; NOT(EventCntA'), branch[PUSHSMALLT];regOP1[164, StackM2BR, opREADPRINTERPORT, noNData];*--------------------------------------------------------------------opWRITEPRINTERPORT:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase; * Using .UNBOX1 here 	T&larr; Md, fetch&larr; T;		*  would only save 1	pd&larr; T - (SmallHi), T&larr; Md;	*  IM loc, but cost	Branch[.+2, alu=0];		*  an extra 3 cycles		CallUfn;   EventCntB&larr; T, NextOpCode;regOP1[165, StackM2BR, opWRITEPRINTERPORT, noNData];regOP1[54, StackM2BR, opEVAL, noNData];*--------------------------------------------------------------------opEVAL:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1, call[TYPREV];	pd&larr; T and (370c);			* Only the first 8 type codes 	Branch[.+2, alu=0], T&larr; T and (7c);	*  are handled by ucode		CallUFN;	BDispatch&larr; T;	Branch[.evdispatch];.evdispatch:	DispTable[10],	CallUfn;		* Type 0 is randomness	NextOpCode;		* Smallp	NextOpCode;		* Fixp	NextOpCode;		* Floatp	FVNAME&larr; pd&larr; (LTEMP1), Branch[.evatom];	* Litatom.  "xor (AT.NIL)"	NARGS&larr; (1c), Branch[.evListp];	* Listp	NextOpCode;		* Arrayp	NextOpCode;		* Stringp%	code use to read:	pd&larr; T - (atomType);	branch[.evalatom, alu=0], pd&larr; T;	branch[.evalother, alu=0], pd&larr; T - (add[FixpType!, 1]c);	branch[.evalret, alu&lt;0], pd&larr; T - (ListType);	branch[.evListp, alu=0], NARGS&larr; 1c;	CallUFN;		* not atom, fixp, listp.evalother:	CallUFN;		* let UFN decide.evalret: NextOpCode;		* return self.evalatom:	FVNAME&larr; pd&larr; (LTEMP1);	* "xor (AT.NIL)"%.evatom:	Branch[.+2, alu#0], pd&larr; (FVNAME) xor (AT.T);		NextOpCode;		* eval of NIL=NIL	Branch[.+2, alu#0], T&larr; (FX.PVAR);		NextOpCode;		* eval of T=T	nop;		* Call can be false target of conditional branch	FVEP&larr; (PVAR) - T, Call[DOLOOKUP];	memBase&larr; ScratchLZBR;	BrHi&larr; FVHI;PAGEFAULTOK;	T&larr; (FETCH&larr; FVLO) + 1;		* Might fault, since it 	T&larr; Md, fetch&larr; T;		*  may be global cellPAGEFAULTNOTOK;	pd&larr; (FVHI) - (StackHi);	Branch[.+2, alu#0], memBase&larr; StackM2BR;		Branch[REPTMD1];	* Stack-bound value is OK	pd&larr; (add[AT.NOBIND!]s) xor (Md);	Branch[REPTMD1, alu#0];		* Global binding ok	CallUFN;			* Hmmm, NOBIND in topcell.evListp:	DEFLO&larr; AT.EVALFORM, Branch[DOCALLPUNT];REPTMD:  * Replace value on top of stack with value in T,,MD	memBase&larr; StackM2BR;REPTMD1:	T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T;	TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpcode;</pre>
  </body>
</html>
