<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>JCAI>sources>LispDMC.DM!2>LFAULTS.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">:Title[LFaults]; <br>*<br>* Edit History<br>* February 2, 1984  5:40 PM, JonL, set RBase before uCodeCheck at Fault0<br>* January 4, 1984  7:48 PM, JonL, CHECKPCXSUBR and FIXLEFT from LSTACK;<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> Let .intsoff in LispReschedule Call[FIXLEFT]; added more comments<br>* December 6, 1982  1:28 PM, Masinter<br><br>%<br>Lisp fault handler.<br><br>If the fault was an emulator map fault or a stack error, and the<br>emulator running at the time was Lisp, then calls the appropriate<br>trap procedure.<br><br>For any other fault, halts at one of the following breakpoints:<br><br>(In fault task, not having reset FaultInfo)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ManyFaults</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">More than one fault<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NotEmuFault</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Fault in non-emulator task<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NotMapFault</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Memory system fault other than map fault<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UnknownFault</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Fault of unknown origin<br><br>(In emulator task, having reset FaultInfo)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">AEmuStackError</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack error from Alto emulator<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">AEmuMapFault</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Map fault from Alto emulator<br><br>(In emulator task, the fault task never having been awakened)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LispIFUMapFault</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Map fault caused by IFU reference<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LispIFUFGParity</span><span class="tab" val="24"></span><span style="font: 10pt monospace">FG parity error<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LispIFURamPE</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">IFU decoding Ram parity error<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BogusIFUMapFault</span><span class="tab" val="24"></span><span style="font: 10pt monospace">IFU gave a map fault, but the page referenced<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">by PCX is not vacant and shouldn&rsquo;t<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">have faulted.<br><br>In the case of faults passed to the emulator task, interesting information is left in R-registers, as follows:<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FltErrors</span><span class="tab" val="24"></span><span style="font: 10pt monospace">NOT (Errors&rsquo;)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FaultInfo</span><span class="tab" val="24"></span><span style="font: 10pt monospace">NOT (Pipe2&rsquo;)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FltEmuPC</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Emulator TPC at time of fault<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FaultVal</span><span class="tab" val="24"></span><span style="font: 10pt monospace">DBuf -- value being stored if faulted on Store&larr;<br><br>%<br><br>*-----------------------------------------------------------<br>* Fault Task<br>*-----------------------------------------------------------<br><br>Set[XTask, IP[FLT]];<br><br>SUBROUTINE;<br>FLTInitPC:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; FLT, CoReturn;<br>TOPLEVEL;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, RBase&larr; RBase[FaultInfo];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TIOA&larr; T, Block;<br><br>FaultTask:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FltErrors&larr; NOT (Errors&rsquo;);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Read this always<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FaultInfo&larr; NOT (Pipe2&rsquo;);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Doesn&rsquo;t clear FaultInfo<br><br>* Test for memory system fault<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FaultInfo) AND (fi.numfaults);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; T XOR (fi.numFaults);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* See if we have all bits set;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Pointers, Branch[CheckStackErr, ALU=0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* All ones =&gt; no fault<br><br>* Memory system fault, see what kind<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; (FaultInfo) AND (fi.numFaults);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* All zeroes =&gt; one fault<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; (FaultInfo) AND (fi.emuFault), Branch[ManyFaults, ALU#0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; (FltErrors) AND (pipe4.notMapTrouble),<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">       Branch[NotEmuFault, ALU=0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[NotMapFault, ALU#0];<br><br>* Emulator map fault.  Clear it and pass fault to emulator.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">B&larr; FaultInfo&rsquo;, Branch[EmuFault];<br><br>* Not memory system fault, check for stack overflow or underflow<br>CheckStackErr:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; T AND (300c);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 200 = stack overflow, 100 = stack underflow<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[UnknownFault, ALU=0];<br><br>* Emulator map fault or stack error.<br>* Save emulator&rsquo;s state and restart emulator at Fault0.<br><br>EmuFault:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FaultVal&larr; DBuf;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RdTPC&larr; EMU;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FltEmuPC&larr; NOT (Link);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* TPC data is complemented<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Call[GetEmuFaultPC];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LdTPC&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Block, Branch[FaultTask];<br><br>* Fault conditions that we can&rsquo;t handle:<br>ManyFaults:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.], Breakpoint;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* More than 1 fault<br>NotEmuFault:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.], Breakpoint;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Not Emulator fault<br>NotMapFault:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.], Breakpoint;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Not map fault<br>UnknownFault:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.], Breakpoint;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Don&rsquo;t know what fault occurred<br><br>*--------------------------------------------------------------------<br>* Emulator Task<br>* The emulator is restarted here by the fault task after an emulator<br>* map fault or stack error.<br>*-----------------------------------------------------------<br><br>Set[XTask, IP[EMU]];<br><br>SUBROUTINE;<br>GetEmuFaultPC:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* "Called" only because there is no way to know<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; EMU, CoReturn;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  the u-address of Fault0 at assembly time<br>TOPLEVEL;<br><br>Fault0: <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RBase&larr; RBase[FltPipe0], <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Call[RestoreALUFM];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* If interrupted from BITBLT ?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; (FaultInfo) AND (fi.numFaults);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Which kind of fault?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.faultluz, alu#0], FaultMapVal&larr; NOT (Map&rsquo;);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; VAHi;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; FltPipe0&larr; T AND (7777C);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Only want low bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FltPipe1&larr; Q&larr; VALo;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FaultMapVal&larr; not (Pipe4&rsquo;);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Ref bits in pipe<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FltTemp&larr; NOT (IFUMLH&rsquo;);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Which emulator was running?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; (FltTemp) AND (14000C);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Test InsSet (Alto=0)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], rbase&larr; rbase[spAC0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[PAGEFAULTPUNT];<br>* Page fault from alto emulator: continue in next instruction<br>* with faulting address in AC0, 1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP&larr; spAC0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&+1 &larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Stack&-1 &larr; Q, branch[EmuNext];<br><br>.faultluz:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">RBase&larr; RBase[LTEMP0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[HWStackError];<br><br>*--------------------------------------------------------------------<br>* IFU traps from lisp emulator<br>*--------------------------------------------------------------------<br><br><br>Set[LispTrapBase, Sub[300, LShift[LispInsSet, 6]]];<br>DontKnowRBase;<br>TOPLEVEL;<br><br>*--------------------------------------------------------------------<br>IFuNotReady:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">IFUJump[0],  </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">at[LispTrapBase, 34];<br>*--------------------------------------------------------------------<br>LispIFUFGparity:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.], Breakpoint,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">at[LispTrapBase,  4];<br>*--------------------------------------------------------------------<br>LispIFURamPE:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.], Breakpoint,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">at[LispTrapBase, 74];<br>*--------------------------------------------------------------------<br><br><br>*--------------------------------------------------------------------<br>LispIFUMapFault:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">MemBase&larr; ifuBR,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">at[LispTrapBase, 0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CHECKPCX;<br>PAGEFAULTOK;<br>   T&larr; not (PCX&rsquo;); <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T rsh 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PCX/2 = word address in code <br>   T&larr; (FETCH&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  segment addressed by ifuBR<br>   T&larr; MD, FETCH&larr; T;<br>   T&larr; MD;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Wait for fault to occur<br>BogusIFUMapFault:<br>   Branch[.], Breakpoint;<br><br><br></span><span style="font: 10pt monospace">:if[Debugging];<br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">CHECKPCXSUBR:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (PSTATE) and (PS.PCXBAD);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">return;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PSTATE&larr; Link;<br>TOP LEVEL;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UCodeCheck[PuntInCall];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">:endif;<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace"><br><br></span><span style="font: 10pt monospace">*--------------------------------------------------------------------<br></span><span style="font: 10pt monospace">LispReschedule:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">at[LispTrapBase, 14];<br></span><span style="font: 10pt monospace">*--------------------------------------------------------------------<br></span><span style="font: 10pt monospace">* cf AEmuReschedule in Start.mc</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rbase&larr; rbase[NWW];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PD&larr; NWW;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, ALU&gt;0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NoReschedule, branch[.intsoff];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NWW&larr; (NWW) and not (BcplKeyMask);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Always turn off BCPL bit. If<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (NWW) and not (LispKeyMask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  other bits on, do old NWW punt<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.checkWW, alu#0], pd&larr; NWW;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* If LispInterrupt on, do KeyPunt<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NoReschedule, dblbranch[KEYPUNT, .intsoff, alu#0];<br><br>.checkWW:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">MemBase&larr; MDS;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (R400)+(52C);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* WW (= 452B)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; MD, ETemp&larr; (Fetch&larr; T) - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* ACTIVE (= 453B)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NWW&larr; (NWW) OR T, T&larr; MD;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* WW OR NWW<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NWW&larr; T&larr; T AND (Q&larr; NWW);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* (WW OR NWW) AND ACTIVE<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, ALU=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[NWWPUNT];<br>* No pending channel is turned on.<br>* Save turned-off interrupts in WW, flush them from NWW, <br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">and resume execution.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Store&larr; ETemp, DBuf&larr; Q;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NoReschedule, branch[RestartIFU];<br><br>.intsoff:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* No interrupt enabled; check for  <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rbase&larr; rbase[LTEMP0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  other reschedule conditions.<br>:if[FNStats];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (FnStatsPtr) - (StatsBufferBoundary);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[STATSPUNT, alu&gt;=0];<br>:endif;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&lt;0], LEFT;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* is LEFT negative?<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[RestartIFU];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ESP&larr; (fetch&larr; ESP) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch flagword<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; Md, fetch&larr; ESP;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (LTEMP2) xor (FreeStackBlock);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* is it a free block?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[STKOVPUNT, alu#0], ESP&larr; (ESP) - 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ESP&larr; (ESP) + (Md), Call[FIXLEFT];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[RestartIFU];<br><br></span><span style="font: 10pt monospace">*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">FIXLEFT:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ESP;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; T - (TSP);<br>FIXLEFT1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; (LEFT) rsh 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; (LEFT) - (LEFTOffset), return;<br>TOPLEVEL;<br></span><span style="font: 10pt monospace"><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
