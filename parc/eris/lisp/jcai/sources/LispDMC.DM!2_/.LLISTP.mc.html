<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>JCAI>sources>LispDMC.DM!2>LLISTP.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">   :Title[LLISTP - CAR, CDR, CONS, RPLACA, RPLACD];<br>* Edit history:<br>* February 9, 1984  4:22 AM, JonL, fixed bug in .CARCDR where it was<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">punting on NIL rather than on non-NIL litatoms<br>* February 9, 1984  12:36 AM, JonL, squeezed out one inst from CONS,<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> near comment " LTEMP1&larr; new CAR"<br>* January 26, 1984  7:08 PM, JonL, spawned this file off LOPS;<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">opCDR goes directly to REPTMD1<br>* January 18, 1984  7:41 PM, JonL, added .rplc; modified opRPLACA<br>* January 18, 1984  6:05 PM, JonL, added subroutine .carcdr; moved<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">REPTMD1 to near opCDR<br>* January 6, 1984  4:56 AM, JonL, Changed CDR to exit thru TL.REPNIL2<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">rather than TL.PUSHNIL<br>* January 3, 1984  4:13 PM, JonL, Re-incorporated experimental changes <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">made 12/30/83 fixing a clobberage of T by some TT.*** code<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> affecting CAR, CDR, RPLACA, RPLACD<br>* December 27, 1983  6:30 PM, JonL, changed calls to GCLOOKT1 into calls <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">to GCADDREF or GCDELREF<br>* December 26, 1983  6:40 PM, JonL, fixed callers of TYPREV to watch out <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">for non-zero TT.*** bits<br><br>   KnowRBase[LTEMP0];<br>   TOP LEVEL;<br>   InsSet[LispInsSet, 1];<br><br><br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">.CARCDR: <br>*--------------------------------------------------------------------<br>* Call to here has done a TYPREV, so pointer is in LTEMP0,1<br>*   and typetable entry xor&rsquo;d with listpType is in T<br>* Exit with hi.word (of cell pointed to) in LTEMP0, and<br>*   with lo.word on Md.<br><br>   branch[.crnlist, alu#0], pd&larr; BrHi&larr; LTEMP0;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*(LTEMP0) xor (AtomHiVal)<br>.carcdr1:<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FETCH&larr; LTEMP1) + 1;<br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; MD, T&larr; (fetch&larr; T) and (lhmask);<br>PAGEFAULTNOTOK, Return;<br>:else;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; MD, T&larr; (fetch&larr; T) and (lhmask), Return;<br>:endif;<br><br>.crnlist:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.crnlist1, alu#0], pd&larr; (LTEMP1);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*(LTEMP1) xor (AT.NIL)<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Entering here on litatoms<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu#0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Both Car, Cdr of NIL = NIL<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Punt if arg is non-NIL litatom<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">SUBROUTINE;<br>.crnlist1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Pd&larr; T and (rhmask); <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0], T&larr; (LTEMP1);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Check for non-zero<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrHi&larr; LTEMP0, branch[.carcdr1];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  TT.*** bits<br>TOPLEVEL;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;<br><br><br><br>*--------------------------------------------------------------------<br>opCAR:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1, Call[TYPREV]; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* returns with type in T<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Id) xor T, memBase&larr; ScratchLZBR, Call[.CARCDR];<br>.car1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP0) and (lhmask);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], LTEMP0&larr; T&larr; (LTEMP0) xor T, memBase&larr; StackM2BR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, Branch[REPSMT2];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, pd&larr; A0, memBase&larr; ScratchLZBR, Call[.CARCDR]; <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.car1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Cell is an indirection<br><br><br>regOP1[1, StackM2BR, opCAR, listType!];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>*--------------------------------------------------------------------<br>opCDR:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1, call[TYPREV]; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* returns with type in T<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Call[.CARCDR], pd&larr; (Id) xor T, memBase&larr; ScratchLZBR;<br>.cdr1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP1&larr; page base addr<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.cdrind, R&gt;=0], LTEMP0, </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Hi order bit of cell is <br><br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ldf[LTEMP0, 7, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  "not indirect" flg<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Assuming non-0 cdrcode, this lsh&rsquo;s it by 1,<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  while properly setting the alu branch conditions<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0], T&larr; T + (LTEMP1), memBase&larr; StackM2BR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Ah, cdr code indicates CDR is NIL<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (atomHiVal), branch[TL.REPNIL2];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + 1, branch[REPSMT2];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* CDR is on same page<br><br>.cdrind:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Indirection <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.cdr2, alu#0], T&larr; (LTEMP1) + T;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Call[.CARCDR], LTEMP1&larr; Md, pd&larr; A0,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Ah, full indirection<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; ScratchLZBR; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  so go around again.<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.cdr1];<br>.cdr2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + 1;<br>* Only local indirect, so fetch from that cell<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T</span><span style="font: 10pt monospace">, </span><span style="font: 10pt monospace">Branch[</span><span style="font: 10pt monospace">REPTMD</span><span style="font: 10pt monospace">];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br><br>regOP1[2, StackM2BR, opCDR, listType!];<br></span><span style="font: 10pt monospace"><br></span><span style="font: 10pt monospace"><br><br>:if[Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[30];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[31];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[32];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* RPLACA, RPLACD, CONS<br>:else;<br><br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">.RPLFETCH:<br>*--------------------------------------------------------------------<br>* Enter with LTEMP0, 1 has address of cell to smash<br>*            typeCode xor listTYpe on pd<br>*            T has typeTable entry (needed only if # listpType)<br>* Exit with LScratchBR set up to point to cell to smash.<br>*           LTEMP2&larr; has contents of hi.word of that cell<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Q&larr; LTEMP1 (for benefit to opRPLACD)<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T contains 1 (for benefit to opRPLACA)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.rplc1, alu=0], LEFT&larr; (LEFT) + 1, memBase&larr; LScratchBR; <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Pd&larr; T and (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Maybe typetable entry has<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.rplc2, alu=0], BrHi&larr; LTEMP0, T&larr; A0;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* non-zero TT.*** bits<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOPLEVEL; CallUFN; SUBROUTINE;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Not a list, so punt out<br>.rplc1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrHi&larr; LTEMP0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP0,1 have address of <br>.rplc2:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  cell to smash<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrLo&larr; LTEMP1, T&larr; A0;<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FETCH&larr; T) + 1, Q&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Fetch first word of that<br>:if[Debugging];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  cell in to determine if<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; MD;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  it is an indirection<br>PAGEFAULTNOTOK, Return;<br>:else;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; MD, Return;<br>:endif;<br><br>*--------------------------------------------------------------------<br>.RPLCKVETCH:<br>*--------------------------------------------------------------------<br>* Similar to .rplfetch, except that LTEMP2 has hi.word of address of<br>*    cell to smash; used only by the indirection case.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrHi&larr; LTEMP2, Branch[.rplc2];<br><br>TOPLEVEL;<br><br><br><br>*--------------------------------------------------------------------<br>opRPLACA:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (TSP) - (4c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + 1, call[TYPREV];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>*  Returns with memBase set to StackM2BR<br>.rplaca1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Pd&larr; T xor (listType), Call[.RPLFETCH];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (LTEMP2) and (lhmask);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; (2c), Branch[RPLPTR1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Md still valid<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Full indirection cell<br>TL.RPLAC:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  so re-fetch and then<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, Call[.rplckvetch];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  carry on.<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; (2c), Branch[RPLPTR1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Md still valid<br><br>regOP1[30, StackBR, opRPLACA, NoNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* RPLACA<br><br><br>*--------------------------------------------------------------------<br>opRPLACD:<br>*--------------------------------------------------------------------<br>   T&larr; (TSP) - (4c);<br>   T&larr; (fetch&larr; T) + 1, call[TYPREV];<br>   Pd&larr; T xor (listType);<br>   branch[.rplacd1, alu=0], memBase&larr; LScratchBR,<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; (LEFT) + 1; <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Pd&larr; T and (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Maybe typetable entry has<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.rplacd2, alu=0], BrHi&larr; LTEMP0,</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* some non-zero TT.*** bits <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP0) - (LTEMP0);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Not a list, so punt out<br>.rplacd1:<br>   BrHi&larr; LTEMP0, T&larr; (LTEMP0) - (LTEMP0);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Zero T, and set LScratchBR <br>.rplacd2:<br>   BrLo&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  to list cell&rsquo;s segment<br>PAGEFAULTOK;<br>   LTEMP1&larr; (FETCH&larr; LTEMP1) + 1, Q&larr; LTEMP1;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Q saves lo.word of cell <br>   LTEMP2&larr; MD;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP2&larr; hi.word of cell<br>PAGEFAULTNOTOK;<br>   branch[.rplacdind, R&gt;=0], LTEMP2, </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Test hi bit of cell<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP2) and (77400c); <br>* local bit of cdrcode on; look at TSP to see if NIL, samepage<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackM2BR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (fetch&larr; TSP) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, TSP&larr; (fetch&larr; TSP) - (3c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; Md, pd&larr; T or (Md), memBase&larr; LScratchBR;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Setup NIL test<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.rplacdnil, alu=0], pd&larr; T - (LTEMP0);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Setup SameSegP<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.rplacdnewcell, alu#0], LTEMP1&larr; Md, T&larr; (Md) xor (LTEMP1);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T and not (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Setup SamePagep<br>   branch[.+2, alu=0];<br>   </span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.rplacdnewcell];<br>.rplacdonpage:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* AH! on same page<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0, call[GCADDREF];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Addref new cell<br>   memBase&larr; LScratchBR;<br>   LTEMP1&larr; (fetch&larr; Q) + 1;<br>   LTEMP4&larr; LSH[LTEMP4, 7];<br>   T&larr; Md, LTEMP4&larr; (LTEMP4) or (100000c);<br>   T&larr; T and (77400c);<br>.rplacdlocal:<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd has hibyte of former CDR pointer -- maybe Delref it?<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.rplacdl1, alu=0], T&larr; RSH[T, 7];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; (LTEMP1) and (lhmask);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; T + (LTEMP1);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0, Call[GCDELREF];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; LScratchBR;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>.rplacdl1:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* store new cdrcode<br>   fetch&larr; Q;<br>   T&larr; (rhmask);<br>   T&larr; T and (Md);<br>   T&larr; T + (LTEMP4);<br>   store&larr; Q, dbuf&larr; T, branch[GCOPTAIL];<br><br><br>.rplacdnil:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* RPLACD of NIL is <br>   LTEMP4&larr; 100000c;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  even easier than<br>   T&larr; (LTEMP2) and (77400c), Branch[.rplacdlocal];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  of samepage ptr<br><br>.rplacdnewcell:<br>   TSP&larr; (TSP) + (2c);<br>   CallUFN;<br><br>.rplacdind:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* "local" bit off<br>   branch[.rplacdlocalind, alu#0], T&larr; RSH[T, 7];<br> * </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Full indirect, so fetch new cell and go around again<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, fetch&larr; LTEMP1;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, branch[.rplacd1];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>.rplacdlocalind:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Use CDR code as  <br>   LTEMP1&larr; (LTEMP1) and (lhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  offset on page<br>   T&larr; T + (LTEMP1);<br>   BrLo&larr; T;<br>   LTEMP4&larr; T&larr; (fetch&larr; 0s) + 1, Branch[RPLPTR1];<br><br>regOP1[31, StackBR, opRPLACD, NoNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* RPLACD<br><br><br>msc[DTD.NEXTPAGEs, DTD.NEXTPAGE!];<br>msc[DTD.COUNTERs, DTD.COUNTER!];<br><br>*--------------------------------------------------------------------<br>opCONS:<br>*--------------------------------------------------------------------<br>* LTEMP0, 1 will hold CDR value<br>* LScratchBR, LTEMP3 will hold new cons cell address<br>* LTEMP4 has CDR code <br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1, call[TYPREV];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; (Id) xor T, memBase&larr; LScratchBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.consnlist, alu#0], T&larr; BrHi&larr; LTEMP0;<br>.conslist:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Assume new cell on CDR&rsquo;s page<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ldf[LTEMP1, 7, 1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* [src, size, pos];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; T + (200c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* new cdr code<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP1) and (lhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* base of CDR&rsquo;s page<br>.constail:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; BrLo&larr; T;<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FETCH&larr; 0s;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; MD;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* word 0 of page: [cnt, nxt]<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R even], T&larr; LTEMP3&larr; (LTEMP3) - (400c);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Sub 1 from cnt<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">.cnsod1: uCodeCheck[badcons];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu&gt;=0], T&larr; T and (rhmask);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; "next"<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.consfail];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* trap out if no cells left<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, alu#0], LTEMP1&larr; (fetch&larr; T) + (LTEMP1);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch next<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">.cnszer: uCodeCheck[badcons];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, LTEMP3&larr; RSH[LTEMP3, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; [nxt,x], LTEMP3&larr; cnt<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; RCY[LTEMP3, T, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* [cnt,nxt]<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R even], store&larr; 0s, </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Store back the frlist ptr<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">dbuf&larr; LTEMP3;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">.cnsod2: uCodeCheck[badcons];<br>   BRLo&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Br now points to new cell<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0, Call[GCDELREF];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Create 0 cnt for new cell<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; ListpDTDBR;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; DTD.COUNTERs;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Increment conscounter<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (MaxConsCount);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, pd&larr; T - (Md);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, carry], T&larr; T + 1;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PSTATE&larr; (PSTATE) or (PS.HTOVERFLOW);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; DTD.COUNTERs, dbuf&larr; T;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackM2BR, LEFT&larr; (LEFT) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) - (2c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; fetch&larr; TSP;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* "pulls back" 1 on TSP<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Save new cell on stack<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, store&larr; T, dbuf&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  and LTEMP1&larr; new CAR<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; lsh[LTEMP4, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* shift cdrcode, and<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP0) or T, memBase&larr; LScratchBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* merge with new CAR<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> BR has hiloc of new CDR when room available on that page<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; 0s, dbuf&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Smash the car/cdr value<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; 1s, dbuf&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  into the new cell  <br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0, Call[GCADDREF];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* addref on new CAR<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Case&larr; T - T, memBase&larr; StackBR</span><span class="tab" val="24"></span><span style="font: 10pt monospace">,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* addref on new CDR<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Call[GCLOOKUP1];<br>* Since TSP has already been "pulled back" one cell, the setting<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> of memBase to StackBR instead of StackM2BR causes us to read the<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> cell just beyond the current TOS -- which was the 2nd arg to CONS,<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> namely the CDR value.<br>   LTEMP4&larr; (3c), Branch[GCOPTAIL];<br><br>.consnlist:<br>* CDR is not a list -- test it first for being NIL<br>   pd&larr; T or (LTEMP1), memBase&larr; ListpDTDBR;<br>   branch[.consother, alu#0], LTEMP4&larr; (200c);</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>.consnil:<br>   fetch&larr; DTD.NEXTPAGEs;<br>   T&larr; Md, memBase&larr; LScratchBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; nxtpage, where the new<br>   LTEMP0&larr; RSH[T, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  cons cell will come from<br>   branch[.+2, alu#0], BRHi&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.consfail];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* nxtpage = 0 ?<br>   T&larr; LSH[T, 10], branch[.constail];<br><br>.consother:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Pd&larr; (LTEMP2) and (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Maybe some non-zero TT.*** bits <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  were in the type table?</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; LScratchBR,branch[.conslist];<br>.consfail:<br>   CallUFN;<br><br>regOP1[32, StackM2BR, opCONS, listType!];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* CONS<br><br><br>:endif;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
