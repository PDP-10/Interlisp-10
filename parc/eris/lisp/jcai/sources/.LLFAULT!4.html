<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>JCAI>sources>LLFAULT!4</title>
  </head>
  <body>
    <pre>
(FILECREATED "16-Aug-85 05:42:04" {ERIS}&lt;LISPCORE&gt;SOURCES&gt;LLFAULT.;55 350726Q      changes to:  (FNS \DOLOCKPAGES)      previous date: "14-Aug-85 13:54:11" {ERIS}&lt;LISPCORE&gt;SOURCES&gt;LLFAULT.;54)(* Copyright (c) 1982, 1983, 1984, 1985 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT LLFAULTCOMS)(RPAQQ LLFAULTCOMS [(FNS \FAULTHANDLER)	(VARS (FAULTTEST T))	(FNS \FAULTINIT \D01.FAULTINIT \D01.ASSIGNBUFFERS)	(FNS \DOVE.FAULTINIT \DL.FAULTINIT \DL.NEWFAULTINIT \DL.UNMAPPAGES \DL.MARK.PAGES.UNAVAILABLE 	     \DL.ASSIGNBUFFERS \CHAIN.UP.RPT)	(FNS \PAGEFAULT \INVALIDADDR \INVALIDVP \FLUSHPAGE \LOADVMEMPAGE \MOVEREALPAGE \LOOKUPPAGEMAP 	     \LOCKEDPAGEP \SELECTREALPAGE \SPECIALRP \TRANSFERPAGE \UPDATECHAIN)	(COMS (* Temporary for LOCALFILE)	      (FNS \ZEROPAGE))	(FNS \NEWPAGE \DONEWPAGE \ASSURE.FPTOVP.PAGE \MAKESPACEFORLOCKEDPAGE \MOVEVMEMFILEPAGE 	     \NEWEPHEMERALPAGE \DONEWEPHEMERALPAGE \LOCKPAGES \DOLOCKPAGES \TEMPLOCKPAGES 	     \DOTEMPLOCKPAGES \TEMPUNLOCKPAGES \UNLOCKPAGES \FLUSHVM \LOGOUT0 \DOFLUSHVM 	     \RELEASEWORKINGSET \WRITEDIRTYPAGE \WRITEDIRTYPAGE1 \COUNTREALPAGES)	(FNS \DOCOMPRESSVMEM VMEM.PURE.STATE)	(FNS 32MBADDRESSABLE \SET.VMEM.FULL.STATE \DOVMEMFULLINTERRUPT \FLUSHVMOK?)	(INITVARS (\UPDATECHAINFREQ 144Q)		  (\PAGEFAULTCOUNTER 0)		  (\DIRTYPAGECOUNTER 0)		  (\DIRTYPAGEHINT 0)		  (\LASTACCESSEDVMEMPAGE 0)		  (\MAXSHORTSEEK 1750Q)		  (\MINSHORTSEEK 24Q)		  (\MAXCLEANPROBES 24Q)		  (\VMEM.INHIBIT.WRITE)		  (\VMEM.PURE.LIMIT)		  (\VMEM.FULL.STATE)		  (\GUARDVMEMFULL 764Q)		  (VMEM.COMPRESS.FLG)		  (\DOFAULTINIT 0)		  (\VMEMACCESSFN)		  (\SYSTEMCACHEVARS)		  (\MAXSWAPBUFFERS 1)		  (\EXTENDINGVMEMFILE)		  (\MaxScreenPage 0)		  (\NEWVMEMPAGEADDED))	(INITVARS (\LASTDIRTYCNT)		  (\LASTDIRTYFOUND)		  (\LASTDIRTYSCANPTR)		  (\DIRTYSEEKMAX 62Q))	(COMS (* Errors)	      (FNS \MP.ERROR))	(COMS (* Debugging)	      (FNS \ACTONVMEMFILE \SHOWPAGETABLE CHECKPAGEMAP CHECKFPTOVP CHECKFPTOVP1 \PRINTFPTOVP 		   \PRINTVP))	(E (RESETSAVE (RADIX 10Q)))	(DECLARE: EVAL@COMPILE DONTCOPY (MACROS \ACTONVMEMFILE .VMEM.CONSISTENTP. .LOCKABLERP.)		  (COMS (* Virtual page flags)			(CONSTANTS \VMAP.DIRTY \VMAP.CLEAN \VMAP.REF \VMAP.VACANT \VMAP.FLAGS 				   \VMAP.NOTFLAGS)			(RECORDS VMEMFLAGS)			(MACROS LOGNOT16))		  (COMS (* RPT constants)			(CONSTANTS \RPT.EMPTY \RPT.UNAVAILABLE \PAGETABLESTOPFLG \RPTENTRYLENGTH)			(RECORDS RPT RPT1)			(MACROS RPFROMRPT RPTFROMRP NPAGESMACRO))		  (COMS (* Virtual to file pagemap)			(EXPORT (CONSTANTS \MAXFILEPAGE))			(CONSTANTS \EMPTYPMTENTRY)			(RECORDS VP)			(MACROS .PAGEMAPBASE.))		  (COMS (* FP to VP stuff)			(RECORDS FPTOVP)			(CONSTANTS \NO.VMEM.PAGE)			(MACROS DLRPFROMFP DLFPFROMRP))		  (PROP DOPVAL \TOUCHPAGE TIMES3)		  (COMS (* Locked page table)			(MACROS .LOCKEDVPBASE. .LOCKEDVPMASK.))		  (CONSTANTS \MAXDIRTYSCANCOUNT \MINVMEMSPAREPAGES \DLBUFFERPAGES)		  (CONSTANTS 2MBPAGES)		  (GLOBALVARS \UPDATECHAINFREQ \REALPAGETABLE \RPTLAST \RPOFFSET \RPTSIZE 			      \LOCKEDPAGETABLE \EMBUFBASE \EMBUFVP \EMBUFRP \PAGEFAULTCOUNTER 			      \LASTDIRTYCNT \LASTDIRTYFOUND \LASTDIRTYSCANPTR \MACHINETYPE 			      \LASTACCESSEDVMEMPAGE \MAXSHORTSEEK \MAXCLEANPROBES \MINSHORTSEEK 			      \DIRTYSEEKMAX \DIRTYPAGECOUNTER \DIRTYPAGEHINT \VMEM.INHIBIT.WRITE 			      \VMEM.PURE.LIMIT \VMEM.FULL.STATE \GUARDVMEMFULL VMEM.COMPRESS.FLG 			      \KBDSTACKBASE \MISCSTACKBASE \DOFAULTINIT \FPTOVP \VMEMACCESSFN 			      \SYSTEMCACHEVARS \LASTVMEMFILEPAGE \EXTENDINGVMEMFILE \MaxScreenPage 			      \NEWVMEMPAGEADDED)		  (GLOBALVARS \#SWAPBUFFERS \#EMUBUFFERS \#DISKBUFFERS \MAXSWAPBUFFERS 			      \EMUSWAPBUFFERS \EMUBUFFERS \TELERAIDBUFFER \EMUDISKBUFFERS 			      \EMUDISKBUFEND)		  (MACROS RWMufMan)		  (CONSTANTS (DOLOCKCHECKS T)))	[COMS (* * MAKEINIT stuff)	      (FNS ADDPME CHECKIFPAGE DUMPINITPAGES MAKEROOMFORPME MAPPAGES READPAGEMAP 		   READPAGEMAPBLOCK SETUPPAGEMAP)	      (DECLARE: DONTCOPY (MACROS CHECKIF)			(ADDVARS (INEWCOMS (FNS DUMPINITPAGES)					   (VARS INITCONSTANTS)					   (FNS SETUPPAGEMAP ADDPME MAKEROOMFORPME MAPPAGES))				 (RDCOMS (FNS READPAGEMAP READPAGEMAPBLOCK CHECKIFPAGE \LOCKEDPAGEP 					      \LOOKUPPAGEMAP CHECKPAGEMAP CHECKFPTOVP CHECKFPTOVP1 					      \SHOWPAGETABLE \PRINTFPTOVP))				 (EXPANDMACROFNS CHECKIF .LOCKEDVPBASE. .LOCKEDVPMASK. .PAGEMAPBASE.)				 (MKI.SUBFNS (\NEWPAGE . MKI.NEWPAGE)					     (\LOCKPAGES . MKI.LOCKPAGES))				 (RD.SUBFNS (\NEWPAGE . VNEWPAGE)					    (\LOCKPAGES . VLOCKPAGES))				 (RDPTRS (\REALPAGETABLE))				 (RDVALS (\RPTSIZE)))			EVAL@COMPILE			(ADDVARS (DONTCOMPILEFNS DUMPINITPAGES SETUPPAGEMAP ADDPME MAKEROOMFORPME 						 MAPPAGES READPAGEMAP READPAGEMAPBLOCK CHECKIFPAGE]	(FNS \LOCKFN \LOCKCODE \LOCKVAR \LOCKCELL \LOCKWORDS)	[DECLARE: DONTCOPY		  (ADDVARS (INEWCOMS (FNS \LOCKFN \LOCKVAR \LOCKCELL \LOCKWORDS \LOCKCODE)				     (ALLOCAL (ADDVARS (LOCKEDFNS \FAULTHANDLER \FAULTINIT 								  \DOVE.FAULTINIT \D01.FAULTINIT 								  \DL.FAULTINIT \CHAIN.UP.RPT 								  \MAKESPACEFORLOCKEDPAGE \PAGEFAULT 								  \WRITEMAP \LOOKUPPAGEMAP 								  \LOCKEDPAGEP \LOADVMEMPAGE 								  \MOVEREALPAGE \INVALIDADDR 								  \INVALIDVP \SELECTREALPAGE 								  \TRANSFERPAGE \SPECIALRP 								  \UPDATECHAIN \MARKPAGEVACANT 								  \FLUSHPAGE \CLEARWORDS \FLUSHVM 								  \DONEWPAGE \ASSURE.FPTOVP.PAGE 								  \DONEWEPHEMERALPAGE 								  \WRITEDIRTYPAGE1 \COPYSYS0 								  \COPYSYS0SUBR \RELEASEWORKINGSET 								  \DOFLUSHVM \DOLOCKPAGES 								  \DOTEMPLOCKPAGES \TEMPUNLOCKPAGES 								  \MP.ERROR RAID \DL.NEWFAULTINIT 								  \DL.MARK.PAGES.UNAVAILABLE 								  \DL.UNMAPPAGES \DL.ASSIGNBUFFERS 								  \D01.ASSIGNBUFFERS \DOCOMPRESSVMEM 								  \MOVEVMEMFILEPAGE 								  \SET.VMEM.FULL.STATE \HINUM \LONUM)						       (LOCKEDVARS \REALPAGETABLE \RPTLAST 								   \PAGEFAULTCOUNTER \UPDATECHAINFREQ 								   \RPOFFSET \RPTSIZE 								   \LOCKEDPAGETABLE \EMBUFBASE 								   \EMBUFVP \EMBUFRP 								   \LASTACCESSEDVMEMPAGE 								   \MAXSHORTSEEK \MAXCLEANPROBES 								   \MINSHORTSEEK \DIRTYPAGECOUNTER 								   \DIRTYPAGEHINT \VMEM.INHIBIT.WRITE 								   \VMEM.PURE.LIMIT \VMEM.FULL.STATE 								   \GUARDVMEMFULL VMEM.COMPRESS.FLG 								   \KBDSTACKBASE \MISCSTACKBASE 								   \DOFAULTINIT \FPTOVP \MACHINETYPE 								   \VMEMACCESSFN \TELERAIDBUFFER 								   \EMUDISKBUFFERS \EMUDISKBUFEND 								   \MAXSWAPBUFFERS \EMUBUFFERS 								   \#EMUBUFFERS \#SWAPBUFFERS 								   \#DISKBUFFERS \RCLKSECOND 								   \RCLKMILLISECOND \VALSPACE 								   \EMUSWAPBUFFERS \EM.CURSORBITMAP 								   \PAGEMAP \PageMapTBL \IOCBPAGE 								   \IOPAGE \MISCSTATS \DEFSPACE 								   \InterfacePage \LASTVMEMFILEPAGE 								   \DoveIORegion \MaxScreenPage 								   \NEWVMEMPAGEADDED]	(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)									      (NLAML)									      (LAMA VMEM.PURE.STATE])(DEFINEQ(\FAULTHANDLER  [LAMBDA NIL                                                (* bvm: "31-MAR-83 17:34")    (PROG NIL      LP  [OR (AND \DOFAULTINIT (\FAULTINIT))	      (\PAGEFAULT (\VAG2 (fetch (IFPAGE FAULTHI) of \InterfacePage)				 (fetch (IFPAGE FAULTLO) of \InterfacePage]          (\CONTEXTSWITCH \FAULTFXP)          (GO LP]))(RPAQQ FAULTTEST T)(DEFINEQ(\FAULTINIT  [LAMBDA NIL                                                (* mpl "20-Jun-85 11:27")          (* * retrieves some constants from Interface page for the swapper and performs other initialization that must happen	  immediately. Called when starting up, and also when \FAULTHANDLER context starts, in case init hasn't happened yet, 	  as e.g. from MAKEINIT)    (OR (NEQ (fetch FPTOVPStart of \InterfacePage)	     0)	(\MP.ERROR \MP.OBSOLETEVMEM "No FPTOVP"))    (SETQ \MACHINETYPE (fetch MachineType of \InterfacePage))    (COND      ((AND (NEQ 0 (fetch (IFPAGE FullSpaceUsed) of \InterfacePage))	    (SELECTC \MACHINETYPE		     (\DORADO NIL)		     (\DANDELION (EQ 0 (fetch (IFPAGE DL24BitAddressable) of \InterfacePage)))		     (\DAYBREAK NIL)		     T))	(\MP.ERROR \MP.32MBINUSE "Sysout contains virtual pages not addressable by machine")))    (SETQ \LASTDIRTYSCANPTR)    (SELECTC \MACHINETYPE	     (\DANDELION (\DL.FAULTINIT))	     (\DAYBREAK (\DOVE.FAULTINIT))	     (\D01.FAULTINIT))    (COND      ((IGREATERP (fetch (IFPAGE NActivePages) of \InterfacePage)		  (IDIFFERENCE \LASTVMEMFILEPAGE \GUARDVMEMFULL))                                                             (* Vmem getting full!)	(\SET.VMEM.FULL.STATE)))    (COND      ((EQ (PROG1 \DOFAULTINIT (SETQ \DOFAULTINIT NIL))	   T)                                                (* true after \FLUSHVM. Need to rebuild some contexts)	(replace (IFPAGE KbdFXP) of \InterfacePage with (\MAKEFRAME (COND								      ((fetch (LITATOM CCODEP)									  of (QUOTE \KEYHANDLER))									(FUNCTION \KEYHANDLER))								      (T (QUOTE \DUMMYKEYHANDLER)))								    \KBDSTACKBASE								    (IPLUS \KBDSTACKBASE 									   \StackAreaSize)								    0 0))	(replace (IFPAGE MiscFXP) of \InterfacePage with (\MAKEFRAME (FUNCTION \DOMISCAPPLY)								     \MISCSTACKBASE								     (IPLUS \MISCSTACKBASE 									    \StackAreaSize)								     0 0))	T])(\D01.FAULTINIT  [LAMBDA NIL                                                (* bvm: " 5-Feb-85 12:42")    (SETQ \VMEMACCESSFN (FUNCTION \M44ACTONVMEMFILE))    (SETQ \REALPAGETABLE (fetch (IFPAGE REALPAGETABLEPTR) of \InterfacePage))                                                             (* Note: these SETQ's do not reference count, since the							     values are all smallp's and emulator addresses 							     (in atom space))    (SETQ \RPOFFSET (SIGNED (fetch (IFPAGE RPOFFSET) of \InterfacePage)			    BITSPERWORD))    (SETQ \RPTSIZE (fetch (IFPAGE RPTSIZE) of \InterfacePage))                                                             (* Initialize the software clocks from alto emulator)    (\BLT (LOCF (fetch SECONDSCLOCK of \MISCSTATS))	  (EMADDRESS \RTCSECONDS)	  (UNFOLD 3 WORDSPERCELL))    [SETQ \RCLKMILLISECOND (CONSTANT (OR (SMALLP \ALTO.RCLKMILLISECOND)					 (ERROR \ALTO.RCLKMILLISECOND 						"\ALTO.RCLKMILLISECOND isn't a SMALLP???"]          (* * \ALTO.RCLKMILLISECOND must be a SMALLP here so as not to cause any refcnt or pagefault activity.	  \RCLKSECOND is large and has to live on \MISCSTATS, since there is no convenient way to lock a random cell.)    (SETQ.NOREF \RCLKSECOND (LOCF (fetch RCLKSECOND of \MISCSTATS)))          (* * Note the SETQ.NOREF for \RCLKSECOND in order to guarantee no refcnt'ing (which might pagefault) Note that these	  LOADBYTE expressions are compiled as constants)    (replace (FIXP HINUM) of \RCLKSECOND with (LOADBYTE \ALTO.RCLKSECOND 16 16))    (replace (FIXP LONUM) of \RCLKSECOND with (LOADBYTE \ALTO.RCLKSECOND 0 16))    [if (AND (EQ \MACHINETYPE \DORADO)	     (ILEQ 5124 (fetch RVersion of \InterfacePage)))	then (replace NSHost0 of \InterfacePage with 0)	     (replace NSHost1 of \InterfacePage with 21898)	     (replace NSHost2 of \InterfacePage		with (IPLUS (MASK.1'S 15 1)			    (for I (N &larr; 0) from 1168 to 1175			       do                            (* Mufflers "2220Q" thru "2227Q" hold the bits of the 							     basic serial number)				  (SETQ N (IPLUS (LLSH N 1)						 (if (BITTEST (RWMufMan I)							      (MASK.1'S 15 1))						     then 0						   else 1)))			       finally (RETURN N]    (\CHAIN.UP.RPT)    (\D01.ASSIGNBUFFERS])(\D01.ASSIGNBUFFERS  [LAMBDA NIL                                                (* bvm: "12-JUL-83 18:25")    (PROGN                                                   (* Assign swap buffer)	   (SETQ \EMBUFVP (fetch (IFPAGE EMBUFVP) of \InterfacePage))	   (SETQ \EMBUFBASE (EMPOINTER (UNFOLD \EMBUFVP WORDSPERPAGE)))	   (SETQ \EMBUFRP (\READRP \EMBUFVP)))    (PROG ((EMBUF (fetch (IFPAGE EMUBUFFERS) of \InterfacePage))	   (EMLEN (fetch (IFPAGE EMUBUFLENGTH) of \InterfacePage))	   EXTRALEN NPAGES)          [add EMLEN (IDIFFERENCE EMBUF (SETQ EMBUF (CEIL EMBUF WORDSPERPAGE]                                                             (* Round up to a page boundary and throw out the 							     excess)          (SETQ EXTRALEN (IMOD EMLEN WORDSPERPAGE))          (add EXTRALEN (COND		 ((ILESSP EXTRALEN 100)		   (TIMES 2 WORDSPERPAGE))		 (T WORDSPERPAGE)))          (SETQ NPAGES (FOLDLO (SETQ EMLEN (IDIFFERENCE EMLEN EXTRALEN))			       WORDSPERPAGE))          (OR (IGEQ NPAGES 4)	      (RAID "No swap buffer space"))          (SETQ \TELERAIDBUFFER (EMPOINTER EMBUF))          (SETQ \EMUBUFFERS (\ADDBASE \TELERAIDBUFFER WORDSPERPAGE))          (SETQ \#EMUBUFFERS (SETQ NPAGES (SUB1 NPAGES)))          (SETQ \#SWAPBUFFERS (IMIN \MAXSWAPBUFFERS (IQUOTIENT NPAGES 2)))          (SETQ \#DISKBUFFERS (IDIFFERENCE \#EMUBUFFERS \#SWAPBUFFERS))          (SETQ \EMUDISKBUFFERS \EMUBUFFERS)          (SETQ \EMUDISKBUFEND (\ADDBASE \EMUDISKBUFFERS (UNFOLD \#DISKBUFFERS WORDSPERPAGE)))          (SETQ \EMUSWAPBUFFERS \EMUDISKBUFEND)          (\INITBFS (\ADDBASE \EMUBUFFERS (UNFOLD NPAGES WORDSPERPAGE))		    EXTRALEN T]))(DEFINEQ(\DOVE.FAULTINIT  [LAMBDA NIL                                                (* bvm: "25-Jul-85 12:48")    (DECLARE (GLOBALVARS \RCLKMILLISECOND \RCLKSECOND))    (SETQ \VMEMACCESSFN (FUNCTION \DOVE.ACTONVMEMFILE))    (SETQ \IOCBPAGE (create POINTER			    PAGE# &larr; \VP.IOCBS))    (COND      ((NOT (.VMEM.CONSISTENTP.))	(\MP.ERROR \MP.INVALIDVMEM)))    (\DL.NEWFAULTINIT)    (SETQ \RCLKMILLISECOND \DOVE.RCLKMILLISECOND)    (SETQ.NOREF \RCLKSECOND (LOCF (fetch RCLKSECOND of \MISCSTATS)))                                                             (* Unfortunately, \DOVE.RCLKSECOND is not smallp)    (replace (FIXP HINUM) of \RCLKSECOND with (CONSTANT (\HINUM \DOVE.RCLKSECOND)))    (replace (FIXP LONUM) of \RCLKSECOND with (CONSTANT (\LONUM \DOVE.RCLKSECOND)))    (\RCLK (LOCF (fetch BASECLOCK of \MISCSTATS)))           (* Reset base clock)    (\DoveMisc.ReadGMT (LOCF (fetch SECONDSCLOCK of \MISCSTATS)))    (\PUTBASEPTR (LOCF (fetch MILLISECONDSCLOCK of \MISCSTATS))		 0 NIL)                                      (* Clear the milliseconds timer)    (\DoveMisc.ReadHostID (LOCF (fetch NSHost0 of \InterfacePage)))    (SETQ \LASTVMEMFILEPAGE (fetch (IFPAGE DLLastVmemPage) of \InterfacePage))    (\DoveDisk.Init)    (\DoveDisplay.TurnOn])(\DL.FAULTINIT  [LAMBDA NIL                                                (* mpl "20-Jun-85 11:37")    (SETQ \VMEMACCESSFN (FUNCTION \DL.ACTONVMEMFILE))    (SETQ \IOCBPAGE (create POINTER			    PAGE# &larr; \VP.IOCBS))    (COND      ((NOT (.VMEM.CONSISTENTP.))	(\MP.ERROR \MP.INVALIDVMEM)))    (\DL.NEWFAULTINIT)    (SETQ \RCLKMILLISECOND \DLION.RCLKMILLISECOND)           (* These are fortunately both small)    (SETQ \RCLKSECOND \DLION.RCLKSECOND)    (\RCLK (LOCF (fetch BASECLOCK of \MISCSTATS)))           (* Reset base clock)    [COND      ((EQ (fetch DLTODVALID of \IOPAGE)	   0)                                                (* Time not valid, so store zero in the clock)	(\PUTBASEPTR (LOCF (fetch SECONDSCLOCK of \MISCSTATS))		     0 NIL))      (T (bind TMP (BASE &larr;(LOCF (fetch SECONDSCLOCK of \MISCSTATS)))	    do                                               (* Loop until clock reads the same as we wrote, in case							     it was being updated)	       (\PUTBASE BASE 1 (SETQ TMP (fetch DLTODLO of \IOPAGE)))	       (\PUTBASE BASE 0 (fetch DLTODHI of \IOPAGE))	    repeatuntil (EQ (fetch DLTODLO of \IOPAGE)			    TMP]    (\PUTBASEPTR (LOCF (fetch MILLISECONDSCLOCK of \MISCSTATS))		 0 NIL)                                      (* Clear the milliseconds timer)    (repeatwhile (IGEQ (fetch DLPROCESSORCMD of \IOPAGE)		       \DL.PROCESSORBUSY))                   (* Wait for IOP readiness)    (replace DLPROCESSORCMD of \IOPAGE with \DL.READPID)     (* Ask it to give the processor ID 							     (3 words))    (repeatwhile (IGEQ (fetch DLPROCESSORCMD of \IOPAGE)		       \DL.PROCESSORBUSY))    (replace NSHost0 of \InterfacePage with (fetch DLPROCESSOR0 of \IOPAGE))    (replace NSHost1 of \InterfacePage with (fetch DLPROCESSOR1 of \IOPAGE))    (replace NSHost2 of \InterfacePage with (fetch DLPROCESSOR2 of \IOPAGE))    (SETQ \LASTVMEMFILEPAGE (fetch (IFPAGE DLLastVmemPage) of \InterfacePage))    (\DL.DISKINIT T])(\DL.NEWFAULTINIT  [LAMBDA NIL                                                (* bvm: "12-Aug-85 11:12")          (* We have just started up on a DLion or Daybreak. Boot code has loaded the first n pages of the sysout into pages 2	  thru n-3, except for the area covered by the map and IO page, and has built the map accordingly.	  Our principal task is to build \REALPAGETABLE)    (PROG ((NREALPAGES (fetch (IFPAGE NRealPages) of \InterfacePage))	   (FIRSTBUFFERRP \RP.STARTBUFFERS)	   (SCRATCHVP \VP.INITSCRATCH)	   (SCRATCHBASE (create POINTER				PAGE# &larr; \VP.INITSCRATCH))	   FIRSTUSEFULRP IFPAGERP IOCBRP RPTBASE VP RPTPAGES FIRSTRP NDISPLAYPAGES)          [do (COND		((for I from 0 to (SUB1 \DLBUFFERPAGES) as (FPBASE &larr;(\ADDBASE \FPTOVP (DLFPFROMRP										FIRSTBUFFERRP)))		    by (\ADDBASE FPBASE 1)		    do (COND			 ([OR (NOT (fetch FPOCCUPIED of FPBASE))			      (\LOCKEDPAGEP (SETQ VP (fetch FPVIRTUALPAGE of FPBASE]                                                             (* Can't use as buffer. This is just a check for 							     consistency; you should pick \RP.STARTBUFFERS so that 							     this isn't a problem)			   (RETURN T)))                      (* Unmap this page so we can use it for buffers)		       (\WRITEMAP VP 0 \VMAP.VACANT))        (* Bad starting place, try again)		  (add FIRSTBUFFERRP 1))		(T (RETURN]          (SETQ FIRSTUSEFULRP (IPLUS FIRSTBUFFERRP \DLBUFFERPAGES))          (PROGN                                             (* Copy vital info that booting left in page 1)		 [COND		   (NIL           (* Use first buffer page for IOCB page. Used to have to place this in a real page whose page-in-segment number was 	  the same as that of \VP.IOCBS, but that constraint is now lifted for Daybreak.)			(SETQ IOCBRP FIRSTBUFFERRP)			(add FIRSTBUFFERRP 1))		   (T (SETQ IOCBRP (IPLUS (LOGAND (SUB1 (IMIN NREALPAGES 3072))						  65280)					  \VP.IOCBS))          (* Put IOCB page near the end of memory, but in the first 1.5 mb so that Burdock can see it.	  Temporary until Steve fixes swap code to not care what RP contains IOCB's)		      [SETQ VP (fetch FPVIRTUALPAGE of (\ADDBASE \FPTOVP (DLFPFROMRP IOCBRP]		      (COND			((\LOCKEDPAGEP VP)			  (\MP.ERROR \MP.IOCBPAGE))			(T                                   (* Unmap whoever lived in our target page)			   (\WRITEMAP VP 0 \VMAP.VACANT]		 (\WRITEMAP \VP.IOCBS IOCBRP \VMAP.CLEAN)		 (\WRITEMAP SCRATCHVP 1 \VMAP.CLEAN)		 (\BLT \IOCBPAGE SCRATCHBASE WORDSPERPAGE))          (PROGN                                             (* Copy InterfacePage out of segment zero)		 (\WRITEMAP SCRATCHVP FIRSTBUFFERRP \VMAP.CLEAN)		 (\BLT SCRATCHBASE \InterfacePage WORDSPERPAGE)		 (\WRITEMAP \VP.IFPAGE (SETQ IFPAGERP FIRSTBUFFERRP)			    \VMAP.CLEAN)		 (add FIRSTBUFFERRP 1))          [PROGN                                             (* Unmap everything that fell somewhere we can't use)		 (\DL.UNMAPPAGES (ADD1 \FP.IFPAGE)				 (DLFPFROMRP \RP.IOPAGE))    (* real segment zero, map or IOPAGE)		 (COND		   ((EQ \MACHINETYPE \DANDELION)		     (for NEXTBANK0 from 2MBPAGES by 2MBPAGES until (IGREATERP NEXTBANK0 NREALPAGES)			do                                   (* All the "shadows of the display bank" in higher 							     memory have restricted use; take them out of commission							     for now)			   (\DL.UNMAPPAGES NEXTBANK0 (IPLUS NEXTBANK0 PAGESPERSEGMENT -1]          (PROGN                                             (* Copy Display into segment zero)		 (SETQ NDISPLAYPAGES (IMAX \NP.DISPLAY (ADD1 \MaxScreenPage)))                                                             (* Number of display pages in use in this image)		 (for I from 0 to (SUB1 NDISPLAYPAGES) do (\WRITEMAP (IPLUS SCRATCHVP I)								     (IPLUS \RP.DISPLAY I)								     \VMAP.CLEAN))                                                             (* Point scratch area at real segment zero)		 (\BLT SCRATCHBASE (create POINTER					   PAGE# &larr; \VP.DISPLAY)		       (UNFOLD NDISPLAYPAGES WORDSPERPAGE))                                                             (* Copy display from wherever boot put it)		 (for I from 0 to (SUB1 NDISPLAYPAGES)		    do (\WRITEMAP (IPLUS SCRATCHVP I)				  0 \VMAP.VACANT)		       (\WRITEMAP (IPLUS \VP.DISPLAY I)				  (IPLUS \RP.DISPLAY I)				  \VMAP.CLEAN))              (* Display is now where hardware wants it, so enable 							     display)		 (replace (IOPAGE DLDISPCONTROL) of \IOPAGE with 0))          [COND	    ((EQ \MACHINETYPE \DAYBREAK)                     (* If on a daybreak, map the I/O region.							     Have to do this before calling 							     \DoveDisplay.ScreenWidth)	      (for I from 0 to (SUB1 \DOVEIORGNSIZE) do (\WRITEMAP (IPLUS \VP.DOVEIORGN I)								   (IPLUS \RP.DOVEIORGN I)								   \VMAP.CLEAN]          [PROG ((RPSIZE (IDIFFERENCE NREALPAGES (SETQ \RPOFFSET -1)))		 (FIRSTVP \VP.RPT))	        (SETQ FIRSTRP (COND		    ((AND (EQ \MACHINETYPE \DAYBREAK)			  (EQ (\DoveDisplay.ScreenWidth)			      \WIDEDOVEDISPLAYWIDTH))		      \RP.AFTERDOVEDISPLAY)		    (T \RP.AFTERDISPLAY)))                   (* Construct real page table in segment zero after the 							     display)	        (SETQ RPTPAGES (FOLDHI (TIMES3 RPSIZE)				       WORDSPERPAGE))	        (COND		  ((IGREATERP (IPLUS RPTPAGES FIRSTRP)			      PAGESPERSEGMENT)          (* No space in bank zero, so put RPT in first segment after 2 megabytes, where the first "shadow" display bank 	  lives. No shadow bank on Daybreak, but this is as good a place as any)		    (SETQ FIRSTRP (IMIN 2MBPAGES (IDIFFERENCE NREALPAGES RPTPAGES)))                                                             (* IMIN because we could be on a wide-display Daybreak 							     with small memory)		    [COND		      ((IGREATERP (IPLUS FIRSTVP RPTPAGES)				  \VP.BUFFERS)               (* Move virtual assignment backwards if necessary)			(SETQ FIRSTVP (IDIFFERENCE \VP.BUFFERS RPTPAGES]		    (\DL.UNMAPPAGES (DLFPFROMRP FIRSTRP)				    (DLFPFROMRP (IPLUS FIRSTRP RPTPAGES -1)))                                                             (* Unmap the pages in which RPT lives.							     This was already done on DLion, but can't hurt to do it							     again)		    ))	        (for I from 0 to (SUB1 RPTPAGES)		   do                                        (* Assign pages to real page table now)		      (\WRITEMAP (IPLUS FIRSTVP I)				 (IPLUS FIRSTRP I)				 \VMAP.CLEAN))	        (SETQ \REALPAGETABLE (create POINTER					     PAGE# &larr; FIRSTVP))	        (\CLEARWORDS \REALPAGETABLE (TIMES3 RPSIZE))	        (SETQ \RPTSIZE RPSIZE)	        (COND		  [(EQ \MACHINETYPE \DANDELION)		    (for NEXTBANK0 from 2MBPAGES by 2MBPAGES until (IGREATERP NEXTBANK0 NREALPAGES)		       do                                    (* Mark the shadow display bank pages unavailable)			  (\DL.MARK.PAGES.UNAVAILABLE NEXTBANK0 (IPLUS NEXTBANK0 PAGESPERSEGMENT -1]		  (T                                         (* RPT itself occupies unavailable pages;							     on DLion these were marked unavailable either in 							     segment zero after display or as part of shadow bank)		     (\DL.MARK.PAGES.UNAVAILABLE FIRSTRP (IPLUS FIRSTRP RPTPAGES -1))                                                             (* Also, Dove IO region is unavailable)		     (\DL.MARK.PAGES.UNAVAILABLE \RP.DOVEIORGN (SUB1 (IPLUS \RP.DOVEIORGN 									    \DOVEIORGNSIZE]          (PROGN           (* Fill in special cases in RPT -- the display, which is not where FPTOVP says it is, and all the pages that are 	  unavailable for one reason or another. Note: any page marked unavailable here MUST be unmapped by now, either 	  because booting never put it where FPTOVP says it would be, there's no page there to begin with, or there's an 	  explicit call to \WRITEMAP or \DL.UNMAPPAGES to unmap it above)		 (SETQ RPTBASE \REALPAGETABLE)		 [for I from 0 to (SUB1 NDISPLAYPAGES)		    do (SETQ RPTBASE (\ADDBASE RPTBASE \RPTENTRYLENGTH))                                                              (* Fill in Display pages)		       (replace (RPT VP) of RPTBASE with (IPLUS \VP.DISPLAY I))		       (replace (RPT FILEPAGE) of RPTBASE with (DLFPFROMRP (IPLUS \RP.TEMPDISPLAY I]		 (\DL.MARK.PAGES.UNAVAILABLE NDISPLAYPAGES \RP.IOPAGE)                                                             (* Mark rest of segment zero plus Map and IOPAGE 							     unavailable)		 )          [PROGN                                             (* fill in main part of RPT by reading FPTOVP)		 (for I from (ADD1 \RP.IOPAGE) to (SUB1 NREALPAGES)		    as [FPBASE &larr;(\ADDBASE \FPTOVP (DLFPFROMRP (ADD1 \RP.IOPAGE]		    by (\ADDBASE FPBASE 1) as [RPTBASE &larr;(fetch RPTRBASE of (RPTFROMRP (ADD1 										       \RP.IOPAGE]		    by (\ADDBASE RPTBASE \RPTENTRYLENGTH) bind (LASTREALPAGE								 &larr;(DLRPFROMFP (fetch (IFPAGE 										     NActivePages)										 of \InterfacePage)))		    do           (* Fill in rest of RPT from \FPTOVP. Could optimize this a little by special casing the area occupied by the 	  display, but this is simpler)		       (COND			 ((fetch (RPT UNAVAILABLE) of RPTBASE))			 ((AND (ILEQ I LASTREALPAGE)			       (fetch FPOCCUPIED of FPBASE)			       [NOT (fetch (VMEMFLAGS VACANT) of (\READFLAGS (SETQ VP									       (fetch FPVIRTUALPAGE										  of FPBASE]			       (EQ I (\READRP VP)))          (* There is a VP assigned to this filepage, and it is still there. False for display that got moved and any real 	  pages that didn't get filled. LASTREALPAGE is in case the real memory is larger than the sysout -- FPTOVP does not 	  exist all the way)			   (replace (RPT VP) of RPTBASE with VP)			   (replace (RPT FILEPAGE) of RPTBASE with (DLFPFROMRP I)))			 (T (replace (RPT EMPTY) of RPTBASE with T]          (PROGN                                             (* Touch up RPT with the exceptions)		 (SETQ RPTBASE (fetch RPTRBASE of (RPTFROMRP IFPAGERP)))                                                             (* Interface Page)		 (replace (RPT VP) of RPTBASE with \VP.IFPAGE)		 (replace (RPT FILEPAGE) of RPTBASE with \FP.IFPAGE)		 (replace (RPT UNAVAILABLE) of (fetch RPTRBASE of (RPTFROMRP IOCBRP)) with T)                                                             (* \IOCBPAGE)		 (\DL.MARK.PAGES.UNAVAILABLE FIRSTBUFFERRP (SUB1 FIRSTUSEFULRP))                                                             (* buffer pages unavailable to swapper)		 )          (\CHAIN.UP.RPT)          (PROG ((NBUFFERS (IDIFFERENCE FIRSTUSEFULRP FIRSTBUFFERRP)))                                                             (* Allocate buffers)	        (for I from 0 to (SUB1 NBUFFERS) do (\WRITEMAP (IPLUS \VP.BUFFERS I)							       (IPLUS FIRSTBUFFERRP I)							       \VMAP.CLEAN))	        (\DL.ASSIGNBUFFERS (create POINTER					   PAGE# &larr; \VP.BUFFERS)				   NBUFFERS])(\DL.UNMAPPAGES  [LAMBDA (FIRSTFP LASTFP)                                   (* bvm: "14-Jan-84 14:20")          (* * At initialization time, unmap anything that originally lived in filepages FIRSTFP thru LASTFP)    (for FP from FIRSTFP to LASTFP as (FPBASE &larr;(\ADDBASE \FPTOVP FIRSTFP)) by (\ADDBASE FPBASE 1)       when (fetch FPOCCUPIED of FPBASE) do (\WRITEMAP (fetch FPVIRTUALPAGE of FPBASE)						       0 \VMAP.VACANT])(\DL.MARK.PAGES.UNAVAILABLE  [LAMBDA (FIRSTRP LASTRP)                                   (* bvm: "14-Jan-84 14:32")    (for I from FIRSTRP to LASTRP as (RPTBASE &larr;(fetch RPTRBASE of (RPTFROMRP FIRSTRP)))       by (\ADDBASE RPTBASE \RPTENTRYLENGTH) do (replace (RPT UNAVAILABLE) of RPTBASE with T])(\DL.ASSIGNBUFFERS  [LAMBDA (BASE NPAGES)                                      (* bvm: "29-Jan-85 19:05")    (PROGN                                                   (* Allocate a page to hold name and password, and 							     perhaps other ephemeral things)	   (\CLEARWORDS BASE WORDSPERPAGE)	   (replace (IFPAGE UserNameAddr) of \InterfacePage with (\LOLOC (\ADDBASE BASE 1)))	   (replace (IFPAGE UserPswdAddr) of \InterfacePage with (\LOLOC (\ADDBASE BASE 33)))	   (SETQ BASE (\ADDBASE BASE WORDSPERPAGE))	   (add NPAGES -1))    (PROGN                                                   (* Assign swap buffer)	   (SETQ \EMBUFBASE BASE)	   (SETQ \EMBUFVP (fetch (POINTER PAGE#) of BASE))	   (SETQ \EMBUFRP (\READRP \EMBUFVP))	   (SETQ BASE (\ADDBASE BASE WORDSPERPAGE))	   (add NPAGES -1))    (PROGN                                                   (* Assign ether buffers)	   (replace (IFPAGE MDSZoneLength) of \InterfacePage with (UNFOLD 2 WORDSPERPAGE))	   (replace (IFPAGE MDSZone) of \InterfacePage with (\LOLOC BASE))	   (SETQ BASE (\ADDBASE BASE (UNFOLD 2 WORDSPERPAGE)))	   (SETQ \TELERAIDBUFFER BASE)	   (SETQ BASE (\ADDBASE BASE WORDSPERPAGE))	   (add NPAGES -3))    (PROGN                                                   (* Divvy up buffer space)	   (SETQ \#SWAPBUFFERS (SETQ \#EMUBUFFERS NPAGES))	   (SETQ \#DISKBUFFERS 0)	   (SETQ \EMUSWAPBUFFERS (SETQ \EMUBUFFERS BASE])(\CHAIN.UP.RPT  [LAMBDA NIL                                                (* bvm: "18-Dec-84 16:07")          (* * Maps over the Real Page Table as constructed so far and fleshes it out. Assumes that the table is built, has 	  all its VP and FILEPAGE entries set, and that the empty and unavailable entries are so marked.	  Finishes the job by chaining together the available pages and setting the LOCKED bits)    (PROG ((RPTBASE \REALPAGETABLE)	   (LASTEMPTY \REALPAGETABLE)	   (LASTUSED (\ADDBASE \REALPAGETABLE 1))	   FIRSTUSED)          (SETQ FIRSTUSED LASTUSED)          (* The "entry" \REALPAGETABLE is a dummy that points to the least recently used entry. We use the second word of 	  that dummy as a temporary chain head for the used pages, so that we can put all the empty pages at the front of the 	  queue.)          [for I from 1 to (SUB1 \RPTSIZE)	     do (SETQ RPTBASE (\ADDBASE RPTBASE \RPTENTRYLENGTH))		(COND		  ((fetch (RPT UNAVAILABLE) of RPTBASE))		  ((fetch (RPT EMPTY) of RPTBASE)		    (replace (RPT NEXTRP) of LASTEMPTY with I)		    (replace (RPT LOCKED) of RPTBASE with NIL)		    (SETQ LASTEMPTY RPTBASE))		  (T (replace (RPT NEXTRP) of LASTUSED with I)		     (replace (RPT LOCKED) of RPTBASE with (\LOCKEDPAGEP (fetch (RPT VP)									    of RPTBASE)))		     (SETQ LASTUSED RPTBASE]                 (* Finally, link the end of empty chain to front of in 							     use chain)          (replace (RPT NEXTRP) of LASTEMPTY with (fetch (RPT NEXTRP) of FIRSTUSED))          (replace (RPT NEXTRP) of (SETQ \RPTLAST LASTUSED) with \PAGETABLESTOPFLG)          (replace (RPT UNAVAILABLE) of \REALPAGETABLE with T)                                                             (* Dummy first entry)      ]))(DEFINEQ(\PAGEFAULT  [LAMBDA (PTR)                                              (* bvm: "13-Aug-85 16:38")    (\CLOCK0 (LOCF (fetch SWAPTEMP0 of \MISCSTATS)))         (* Note time of start)    (PROG ((VP (fetch (POINTER PAGE#) of PTR))	   FLAGS FILEPAGE)          (COND	    ((fetch (VP INVALID) of VP)                      (* Map out of bounds on Dolphin always produces -1 as 							     the vp. Don't know about other machines)	      (\MP.ERROR \MP.MOB "Page Fault: Map out of bounds" (AND (NEQ VP 65535)								      PTR)			 T))	    ([NOT (fetch (VMEMFLAGS VACANT) of (SETQ FLAGS (\READFLAGS VP]	      (\MP.ERROR \MP.RESIDENT "Fault on resident page" PTR T))	    ((EQ (SETQ FILEPAGE (\LOOKUPPAGEMAP VP))		 0)	      (\INVALIDADDR PTR))	    (T (COND		 ((EQ (\HILOC PTR)		      \STACKHI)                              (* should never happen. For debugging)		   (\MP.ERROR \MP.STACKFAULT "Fault on stack" PTR T)))	       (\LOADVMEMPAGE VP FILEPAGE)))          (COND	    (\NEWVMEMPAGEADDED                               (* Only happens if VMEM.PURE.STATE on)			       (\ASSURE.FPTOVP.PAGE)))          [\BOXIPLUS (LOCF (fetch SWAPWAITTIME of \MISCSTATS))		     (\BOXIDIFFERENCE (\CLOCK0 (LOCF (fetch SWAPTEMP1 of \MISCSTATS)))				      (LOCF (fetch SWAPTEMP0 of \MISCSTATS]                                                             (* Count the time used.)          (RETURN PTR])(\INVALIDADDR  [LAMBDA (ADDR)                                             (* bvm: " 6-AUG-83 22:25")    (\MP.ERROR \MP.INVALIDADDR "Invalid address" ADDR T])(\INVALIDVP  [LAMBDA (VP)                                               (* bvm: " 6-AUG-83 22:25")    (\MP.ERROR \MP.INVALIDVP "Invalid VP" VP])(\FLUSHPAGE  [LAMBDA (RPTINDEX FROMFLUSHVM)                             (* bvm: "13-Aug-85 16:35")          (* * Write out real page RPTINDEX if it is dirty.)    (PROG ((RPTR (fetch RPTRBASE of RPTINDEX))	   VP FP NEWFP)          (COND	    ([AND (fetch (RPT OCCUPIED) of RPTR)		  (fetch (VMEMFLAGS DIRTY) of (\READFLAGS (SETQ VP (fetch (RPT VP) of RPTR]                                                             (* Yes, page is dirty)	      (SETQ FP (fetch (RPT FILEPAGE) of RPTR))	      [COND		[(AND \VMEM.PURE.LIMIT (NOT FROMFLUSHVM))    (* Don't sully vmem; write page out beyond the original							     end of vmem)		  (COND		    ((ILEQ FP \VMEM.PURE.LIMIT)		      (COND			((fetch (RPT LOCKED) of RPTR)			  (\MP.ERROR \MP.WRITING.LOCKED.PAGE)))		      (SETQ NEWFP (add (fetch NActivePages of \InterfacePage)				       1))		      (COND			((IGREATERP NEWFP (IDIFFERENCE \LASTVMEMFILEPAGE \GUARDVMEMFULL))			  (\SET.VMEM.FULL.STATE)))		      (SETQ \NEWVMEMPAGEADDED T)		      (\PUTBASE (.PAGEMAPBASE. VP)				0 NEWFP)		      (\PUTBASE \FPTOVP NEWFP VP)		      (\PUTBASE \FPTOVP FP \NO.VMEM.PAGE)		      (replace (RPT FILEPAGE) of RPTR with (SETQ FP NEWFP]		((.VMEM.CONSISTENTP.)		  (replace (IFPAGE Key) of \InterfacePage with (LOGNOT16 \IFPValidKey))                                                             (* Invalidate vmem and write out the Interface page)		  (SETQ \DIRTYPAGEHINT 0)                    (* So that the dirty page background writer wakes up)		  (PROG ((IFVP (fetch (POINTER PAGE#) of \InterfacePage)))		        (\TRANSFERPAGE IFVP \FirstVmemBlock (RPTFROMRP (\READRP IFVP))				       T NIL]                (* Write it out)	      (COND		((IGREATERP \DIRTYPAGEHINT 0)		  (add \DIRTYPAGEHINT -1)))	      (\TRANSFERPAGE VP FP RPTINDEX T NIL])(\LOADVMEMPAGE  [LAMBDA (VPAGE FILEPAGE NEWPAGEFLG LOCK? DONTMOVETOPFLG)   (* bvm: "10-Aug-85 18:08")          (* Fault in virtual page VPAGE known to live in FILEPAGE on the vmem. NEWPAGEFLG is true if the page is new, so 	  should just be cleared, not loaded from vmem file. If LOCK? is true, locks down the page as well.	  In this case, if on Dandelion, we also check for page wanting to live in a particular real page.	  If DONTMOVETOPFLG is true, the real page we put this page in is not promoted to the front of the LRU queue of pages)    (COND      ((IGREATERP \PAGEFAULTCOUNTER \UPDATECHAINFREQ)	(\UPDATECHAIN)))    (add \PAGEFAULTCOUNTER 1)    (PROG ((RPTINDEX (\SELECTREALPAGE FILEPAGE LOCK? DONTMOVETOPFLG))	   RPTBASE SPECIALRP)          (SETQ RPTBASE (fetch RPTRBASE of RPTINDEX))          [COND	    ((AND LOCK? (OR (EQ \MACHINETYPE \DANDELION)			    (EQ \MACHINETYPE \DAYBREAK))		  (SETQ SPECIALRP (\SPECIALRP VPAGE)))       (* Must actually put FILEPAGE into special RP, and thus							     move old contents of SPECIALRP into RPTINDEX)	      (LET* ((SRINDEX (RPTFROMRP SPECIALRP))		     (SRPTR (fetch RPTRBASE of SRINDEX)))		    (\MOVEREALPAGE SRINDEX SRPTR RPTINDEX RPTBASE)		    (SETQ RPTINDEX SRINDEX)		    (SETQ RPTBASE SRPTR]                     (* Fill in new RPTINDEX with appropriate data)          (replace (RPT VP) of RPTBASE with VPAGE)          (replace (RPT FILEPAGE) of RPTBASE with FILEPAGE)          (replace (RPT LOCKED) of RPTBASE with LOCK?)          (COND	    ([AND DOLOCKCHECKS (NOT LOCK?)		  (EQ (LRSH VPAGE 8)		      (CONSTANT (\HILOC \PAGEMAP]	      (\MP.ERROR \MP.MAPNOTLOCKED "Page of page map being loaded but not locked" VPAGE)))          (\TRANSFERPAGE VPAGE FILEPAGE RPTINDEX NIL NEWPAGEFLG])(\MOVEREALPAGE  [LAMBDA (SOURCEINDEX SOURCERPT DESTINDEX DESTRPT)          (* bvm: "14-Aug-85 13:53")          (* * Moves the page, if any, currently living in real page table SOURCEINDEX &amp; SOURCERPT into the page indicated by 	  DESTINDEX &amp; DESTRPT. The destination is assumed to have been vacated)    (CHECK (NOT (fetch (RPT LOCKED) of SOURCERPT)))    (replace (RPT LOCKED) of DESTRPT with NIL)    [COND      ((fetch (RPT OCCUPIED) of SOURCERPT)                   (* Page was not vacant to start with)	(LET* ((SOURCEVP (fetch (RPT VP) of SOURCERPT))	       (SOURCEFLAGS (\READFLAGS SOURCEVP)))	      (replace (RPT VP) of DESTRPT with SOURCEVP)	      (replace (RPT FILEPAGE) of DESTRPT with (fetch (RPT FILEPAGE) of SOURCERPT))	      (\WRITEMAP \EMBUFVP (RPFROMRPT DESTINDEX)			 0)                                  (* Map buffer to target page)	      (\BLT \EMBUFBASE (create POINTER				       PAGE# &larr; SOURCEVP)		    WORDSPERPAGE)                            (* move data to buffer page)	      (\WRITEMAP \EMBUFVP \EMBUFRP 0)                (* Restore buffer to its proper page)	      (\WRITEMAP SOURCEVP (RPFROMRPT DESTINDEX)			 SOURCEFLAGS)                        (* Set flags and new RP for page)	  ]    DESTINDEX])(\LOOKUPPAGEMAP  [LAMBDA (VP)                                               (* bvm: "13-OCT-82 15:21")          (* Returns the pagemap entry for VP, which is expected to be in bounds. High bit of result is the lock bit.	  Zero denotes absence)    (PROG [(PRIMENTRY (\GETBASE \PageMapTBL (fetch (VP PRIMARYKEY) of VP]          (RETURN (COND		    ((EQ PRIMENTRY \EMPTYPMTENTRY)		      0)		    (T (\GETBASE \PAGEMAP (IPLUS PRIMENTRY (fetch (VP SECONDARYKEY) of VP])(\LOCKEDPAGEP  [LAMBDA (VP TEMP)                                          (* bvm: "18-Feb-85 18:08")          (* * True if VP is locked. If TEMP is NIL consults only the locked page table; otherwise, also checks for "temporary" locked page)    (OR (NEQ 0 (LOGAND (.LOCKEDVPMASK. VP)		       (\GETBASE (.LOCKEDVPBASE. VP)				 0)))	(UNLESSRDSYS (AND TEMP (NOT (fetch (VMEMFLAGS VACANT) of (\READFLAGS VP)))			  (fetch (RPT LOCKED) of (fetch RPTRBASE of (RPTFROMRP (\READRP VP])(\SELECTREALPAGE  [LAMBDA (NEWFP LOCK? DONTMOVETOPFLG)                       (* bvm: "10-Aug-85 18:08")          (* Selects a real page, flushing it if necessary, and returns the RPT index of the page. NEWFP, if supplied, is the 	  filepage that will be read into here. This might influence page choice by minimizing seek time.	  LOCK? means caller intends to lock the page, which constrains which real pages it can fall into.	  The selected page is moved to the back of the LRU queue, so that it won't be selected again soon, unless 	  DONTMOVETOPFLG is true. If DONTMOVETOPFLG is REMOVE then the page is spliced out of the chain forever.)    (PROG ((TRIES 0)	   (CNTR \MAXCLEANPROBES)	   (DISTANCE \MINSHORTSEEK)	   PREVRPT PREVINDEX RPTINDEX RPTBASE FP FLAGS)      RETRY          (SETQ PREVRPT \REALPAGETABLE)          (until (EQ (SETQ RPTINDEX (fetch (RPT NEXTRP) of PREVRPT))		     \PAGETABLESTOPFLG)	     do (SETQ RPTBASE (fetch RPTRBASE of RPTINDEX))		[COND		  ((fetch (RPT EMPTY) of RPTBASE)		    (RETURN PREVRPT))		  ((NOT (fetch (RPT OCCUPIED) of RPTBASE))		    (\MP.ERROR \MP.CHAIN.UNAVAIL "UNAVAILABLE page on Chain"))		  ([AND (NOT (fetch (RPT LOCKED) of RPTBASE))			[NOT (fetch (VMEMFLAGS REFERENCED) of (SETQ FLAGS (\READFLAGS								  (fetch (RPT VP) of RPTBASE]			(OR (NOT LOCK?)			    (.LOCKABLERP. (RPFROMRPT RPTINDEX]          (* Page is unlocked and unreferenced, so is good candidate for flushing. LOCK? check is to avoid locking a page into	  a real page that might be desired by code that cares about real pages)		    (COND		      ([OR (NOT (fetch (VMEMFLAGS DIRTY) of FLAGS))			   (PROGN (SETQ FP (fetch (RPT FILEPAGE) of RPTBASE))				  (COND				    ((SELECTQ \VMEM.INHIBIT.WRITE					      [NIL (SELECTQ \VMEM.FULL.STATE							    (NIL                                                              (* Normal, can write anything)								 T)							    (T                                                              (* Vmem is full and clean, don't write anything)							       NIL)							    (PROGN                                                              (* Vmem is full, but sullied, so might as well write 							     anything for which there is space)								   (AND (ILEQ FP \LASTVMEMFILEPAGE)									(OR (NULL \VMEM.PURE.LIMIT)									    (IGREATERP FP 										 \VMEM.PURE.LIMIT]					      (NEW           (* Only allowed to write old pages, since new pages 							     might just have to get moved a second time)						   (ILEQ FP \VMEM.PURE.LIMIT))					      (PROGN         (* We are forbidden from writing any page)						     NIL))				      (COND					((OR (ILEQ CNTR 0)					     (NULL NEWFP)					     (ILESSP (IABS (IDIFFERENCE FP NEWFP))						     DISTANCE))                                                             (* Page is near replacement, or we have given up trying							     for closeness)					  T)					(T                   (* Page is too far away from replacement page)					   (SETQ CNTR (SUB1 CNTR))					   [COND					     ((ILESSP DISTANCE \MAXSHORTSEEK)                                                             (* Get more liberal)					       (SETQ DISTANCE (LLSH DISTANCE 1]					   NIL]			[COND			  (DOLOCKCHECKS (COND					  ((fetch (RPT LOCKED) of RPTBASE)					    (\MP.ERROR \MP.FLUSHLOCKED 						       "Attempt to displace locked page"						       RPTBASE))					  ((EQ (fetch (RPT VPSEG) of RPTBASE)					       (CONSTANT (\HILOC \PAGEMAP)))					    (\MP.ERROR \MP.MAPNOTLOCKED 						       "A page of the page map is not locked"						       RPTBASE]			(\FLUSHPAGE RPTINDEX)			(\WRITEMAP (fetch (RPT VP) of RPTBASE)				   0 \VMAP.VACANT)			(replace (RPT EMPTY) of RPTBASE with T)			(RETURN PREVRPT]		(SETQ PREVRPT RPTBASE)		(SETQ PREVINDEX RPTINDEX)	     finally                                         (* Couldn't find an unreffed page because all pages 							     were touched since last \UPDATECHAIN.							     Do another, which clears ref bits, and try again)		     (COND		       ((EQ TRIES 0)			 (SETQ TRIES 1)			 (\UPDATECHAIN))		       [(AND (EQ TRIES 1)			     \VMEM.INHIBIT.WRITE)			 (SETQ \VMEM.INHIBIT.WRITE)			 (COND			   ((AND (NEQ \MACHINETYPE \DANDELION)				 (NEQ \MACHINETYPE \DAYBREAK))                                                             (* Don't call RAID on a DLion, since the interface is 							     so bad. Dorado user might want to know that we're 							     smashing \VMEM.INHIBIT.WRITE)			     (RAID "No clean vmem pages to reuse, must write one.  &uarr;N to continue"]		       (T (\MP.ERROR \MP.SELECTLOOP "Loop in \SELECTREALPAGE")))		     (GO RETRY))          (SELECTQ DONTMOVETOPFLG		   (NIL                                      (* Move this page to head of chain, so that it won't be							     picked again soon)			(replace (RPT NEXTRP) of PREVRPT with (fetch (RPT NEXTRP) of RPTBASE))                                                             (* Splice RPTINDEX out of chain)			(replace (RPT NEXTRP) of \RPTLAST with RPTINDEX)                                                             (* Put new page at end of chain)			(replace (RPT NEXTRP) of (SETQ \RPTLAST RPTBASE) with \PAGETABLESTOPFLG))		   (REMOVE                                   (* Splice this page out of chain altogether)			   (replace (RPT NEXTRP) of PREVRPT with (fetch (RPT NEXTRP) of RPTBASE))			   (replace (RPT NEXTRP) of RPTBASE with \PAGETABLESTOPFLG))		   NIL)          (RETURN RPTINDEX])(\SPECIALRP  [LAMBDA (VP)                                               (* edited: " 9-Aug-85 17:14")                                                             (* for \DANDELION, some virtual pages must be mapped 							     into special real pages. This function returns the 							     corresponding real page)    (SELECTC (FOLDLO VP PAGESPERSEGMENT)	     ((FOLDLO \VP.STACK PAGESPERSEGMENT)	       (IPLUS VP (IDIFFERENCE \RP.STACK \VP.STACK)))	     ((FOLDLO \VP.DISPLAY PAGESPERSEGMENT)	       (IPLUS VP (IDIFFERENCE \RP.DISPLAY \VP.DISPLAY)))	     NIL])(\TRANSFERPAGE  [LAMBDA (VP FILEPAGE RPTINDEX WRITE? NEWPAGE?)             (* MPL "27-Jul-85 21:28")          (* Transfers virtual page VP between page FILEPAGE of the vmem and real page RPTINDEX. WRITE? indicates direction of	  transfer. If NEWPAGE?, then page does not exist on file, and is simply cleared)    (PROG (NEWFLAGS)          (COND	    (WRITE? (FLIPCURSORBAR 15))	    (T (FLIPCURSORBAR 0)))          (SETQ NEWFLAGS (COND	      (NEWPAGE? \VMAP.DIRTY)	      (WRITE? (LOGAND (\READFLAGS VP)			      (LOGNOT16 \VMAP.DIRTY)))	      (T 0)))          (COND	    ((AND WRITE? (fetch (RPT LOCKED) of (fetch RPTRBASE of RPTINDEX)))                                                             (* Writing a locked page: can't diddle map, because 							     others might die, so do this in the straightforward 							     way)	      (\BLT \EMBUFBASE (create POINTER				       PAGE# &larr; VP)		    WORDSPERPAGE)                            (* Copy page into buffer, then write the buffer out)	      (\ACTONVMEMFILE FILEPAGE \EMBUFBASE 1 T)	      (SETQ \LASTACCESSEDVMEMPAGE FILEPAGE))	    ((NOT NEWPAGE?)                                  (* Map the buffer page into the target real page, 							     read/write the page, then set the map back)	      (\WRITEMAP VP 0 \VMAP.VACANT)                  (* Unmap VP so that we don't have two virtual pages 							     pointing at same real page)	      (\WRITEMAP \EMBUFVP (RPFROMRPT RPTINDEX)			 0)                                  (* Map buffer to target page)	      (\ACTONVMEMFILE FILEPAGE \EMBUFBASE 1 WRITE?)                                                             (* Do the i/o)	      (\WRITEMAP \EMBUFVP \EMBUFRP 0)                (* Restore buffer to its proper page)	      (SETQ \LASTACCESSEDVMEMPAGE FILEPAGE)))          (\WRITEMAP VP (RPFROMRPT RPTINDEX)		     NEWFLAGS)                               (* Set flags for page)          (COND	    (NEWPAGE?                                        (* Not on file yet, so clear it.							     Couldn't do this sooner because the flags weren't set)		      (\CLEARWORDS (create POINTER					   PAGE# &larr; VP)				   WORDSPERPAGE)))          (COND	    (WRITE? (FLIPCURSORBAR 15)		    (\BOXIPLUS (LOCF (fetch SWAPWRITES of \MISCSTATS))			       1))	    (T (FLIPCURSORBAR 0)	       (\BOXIPLUS (LOCF (fetch PAGEFAULTS of \MISCSTATS))			  1])(\UPDATECHAIN  [LAMBDA NIL                                                (* bvm: "30-Jul-85 15:20")                                                             (* Sorts the page chain by reference bit)    (CHECK (NOT \INTERRUPTABLE))    (PROG ((RPTINDEX (fetch (RPT NEXTRP) of \REALPAGETABLE))	   (CHAIN0 \REALPAGETABLE)	   (CHAIN1 (\ADDBASE \REALPAGETABLE 2))	   RPTR VP FLAGS HEAD1)          (SETQ HEAD1 CHAIN1)          (* HEAD1 = CHAIN1 is just a holding cell for the second Chain we temporarily create inside here.	  Use the unused third word of the dummy header entry of \REALPAGETABLE)          (replace (RPT NEXTRP) of CHAIN0 with \PAGETABLESTOPFLG)          (replace (RPT NEXTRP) of CHAIN1 with \PAGETABLESTOPFLG)          (do (SETQ RPTR (fetch RPTRBASE of RPTINDEX))	      (SETQ VP (fetch (RPT VP) of RPTR))	      [SETQ FLAGS (COND		  ((fetch (RPT EMPTY) of RPTR)		    0)		  (T (\READFLAGS VP]	      (COND		((OR (fetch (RPT LOCKED) of RPTR)		     (PROGN (COND			      ([AND DOLOCKCHECKS (EQ (fetch (RPT VPSEG) of RPTR)						     (CONSTANT (\HILOC \PAGEMAP]				(\MP.ERROR \MP.MAPNOTLOCKED "A page of the page map is not locked" 					   RPTR)))			    (fetch (VMEMFLAGS REFERENCED) of FLAGS)))                                                             (* Page referenced or locked, put on CHAIN1)		  (\WRITEMAP VP (RPFROMRPT RPTINDEX)			     (LOGAND FLAGS (LOGNOT16 \VMAP.REF)))                                                             (* Turn off ref bit)		  (replace (RPT NEXTRP) of CHAIN1 with RPTINDEX)		  (SETQ CHAIN1 RPTR))		(T                                           (* Page was not referenced recently, put on CHAIN0)		   (replace (RPT NEXTRP) of CHAIN0 with RPTINDEX)		   (SETQ CHAIN0 RPTR)))	      (SETQ RPTINDEX (fetch (RPT NEXTRP) of RPTR))                                                              (* Look at next page in old chain)	     repeatuntil (EQ RPTINDEX \PAGETABLESTOPFLG))          (replace (RPT NEXTRP) of CHAIN1 with \PAGETABLESTOPFLG)                                                             (* End of the line)          (replace (RPT NEXTRP) of CHAIN0 with (fetch (RPT NEXTRP) of HEAD1))                                                             (* Link end of CHAIN0 to beginning of CHAIN1)          (SETQ \RPTLAST (COND	      ((EQ HEAD1 CHAIN1)                             (* Nothing on CHAIN1 ??!!)		CHAIN0)	      (T CHAIN1)))                                   (* Pointer to end of complete chain)          (SETQ \DIRTYPAGECOUNTER (SETQ \PAGEFAULTCOUNTER 0]))(* Temporary for LOCALFILE)(DEFINEQ(\ZEROPAGE  [LAMBDA (VP)                                               (* hts: " 8-Oct-84 15:56")    (PROG ((BASE (create POINTER			 PAGE# &larr; VP)))          (\PUTBASE BASE (SUB1 WORDSPERPAGE)		    0)          (\BLT BASE (\ADDBASE BASE 1)		(SUB1 WORDSPERPAGE]))(DEFINEQ(\NEWPAGE  [LAMBDA (BASE NOERROR LOCK?)                               (* bvm: "13-Feb-85 16:48")          (* * Creates and returns a new page located at virtual addr BASE)    (UNINTERRUPTABLY        (COND	  [(NOT (\MISCAPPLY* (FUNCTION \DONEWPAGE)			     BASE LOCK?))                    (* Failed, page exists)	    (COND	      ((NOT NOERROR)		(\MP.ERROR \MP.NEWPAGE "Attempt to allocate already existing page" BASE T)))	    (COND	      (LOCK? (\LOCKPAGES BASE 1]	  ((IGREATERP (fetch (IFPAGE NActivePages) of \InterfacePage)		      (IDIFFERENCE \LASTVMEMFILEPAGE \GUARDVMEMFULL))                                                             (* Vmem getting full!)	    (\SET.VMEM.FULL.STATE)))	BASE)])(\DONEWPAGE  [LAMBDA (BASE LOCK? INTERNALFLG)                           (* bvm: "13-Aug-85 16:32")          (* * Allocates new page at BASE, locking it if LOCK? is true. Returns vmemfile page# on success, NIL if page already	  exists. Must be run in safe context! because it can cause vmem activity)    (AND \DOFAULTINIT (\FAULTINIT))                          (* Only an issue when INIT.SYSOUT starts.							     Perhaps there is a better place to put this)    (PROG ((VP (fetch (POINTER PAGE#) of BASE))	   MAPBASE LOCKBASE FILEPAGE NEXTPM ERRCODE)          (RETURN (COND		    ((fetch (VP INVALID) of VP)		      (\INVALIDVP VP)		      NIL)		    (T (SETQ MAPBASE (\GETBASE \PageMapTBL (fetch (VP PRIMARYKEY) of VP)))		       (COND			 ((EQ MAPBASE \EMPTYPMTENTRY)        (* Need to create a new second-level block)			   (SETQ NEXTPM (fetch (IFPAGE NxtPMAddr) of \InterfacePage))			   [COND			     ((EVENP NEXTPM WORDSPERPAGE)          (* Need a new secondary pagemap page. This recursion is ok, because we know that SETUPPAGEMAP assures that the 	  pagemap pages for all the pages in secondary map space were created at MAKEINIT time)			       (OR (\DONEWPAGE (\ADDBASE \PAGEMAP NEXTPM)					       T T)				   (RETURN (\MP.ERROR \MP.NEWMAPPAGE 						     "\DONEWPAGE failed to allocate new map page"]			   (\PUTBASE \PageMapTBL (fetch (VP PRIMARYKEY) of VP)				     NEXTPM)			   (replace (IFPAGE NxtPMAddr) of \InterfacePage with (IPLUS NEXTPM 										     \PMblockSize))			   (SETQ MAPBASE NEXTPM)))		       [SETQ MAPBASE (\ADDBASE \PAGEMAP (IPLUS MAPBASE (fetch (VP SECONDARYKEY)									  of VP]		       (COND			 ((NEQ (\GETBASE MAPBASE 0)			       0)                            (* Page exists)			   (RETURN NIL)))		       (SETQ FILEPAGE (add (fetch (IFPAGE NActivePages) of \InterfacePage)					   1))		       (replace (IFPAGE NDirtyPages) of \InterfacePage with FILEPAGE)                                                             (* Currently a redundant field)		       [COND			 (LOCK? (SETQ FILEPAGE (\MAKESPACEFORLOCKEDPAGE VP FILEPAGE))				(\PUTBASE (SETQ LOCKBASE (.LOCKEDVPBASE. VP))					  0					  (LOGOR (.LOCKEDVPMASK. VP)						 (\GETBASE LOCKBASE 0]		       (\PUTBASE \FPTOVP FILEPAGE VP)		       (\PUTBASE MAPBASE 0 FILEPAGE)		       (\LOADVMEMPAGE VP FILEPAGE T LOCK?)		       (COND			 (INTERNALFLG (SETQ \NEWVMEMPAGEADDED T))			 (T                                  (* Make sure \FPTOVP extended if necessary)			    (\ASSURE.FPTOVP.PAGE)))		       FILEPAGE])(\ASSURE.FPTOVP.PAGE  [LAMBDA NIL                                                (* bvm: "13-Aug-85 16:29")          (* Called at the end of some swapping operation that added one or more pages to the vmem file, setting 	  \NEWVMEMPAGEADDED true. If we're going to need a new page of \FPTOVP soon, do it now while there's still maneuvering	  room. The allowance below is for the worst case, which can happen when VMEM.PURE.STATE is on and \NEWPAGE was called	  needing a new pagemap page as well, in which case we could have as many as the following new vmem pages before we're	  home safe -	  1: \NEWPAGE added a page -	  2: a page was displaced by the new page and written to the end of the vmem -	  3: a new pagemap page was needed -	  4: it displaced a page to end of vmem -	  5: the new \FPTOVP page below -	  6: a page displaced by same. -	  -	  Alternatively, it could have been the new \FPTOVP page that needed a new pagemap block. Will never have both needing	  a new pagemap block, since there are several pagemap blocks per page)    (LET ((FILEPAGE (fetch (IFPAGE NActivePages) of \InterfacePage)))         (COND	   ((IGREATERP (IMOD FILEPAGE WORDSPERPAGE)		       (IDIFFERENCE WORDSPERPAGE 7))         (* This is a no-op if the page has already been 							     allocated)	     (\DONEWPAGE (\ADDBASE \FPTOVP (CEIL FILEPAGE WORDSPERPAGE))			 T T)))         (SETQ \NEWVMEMPAGEADDED NIL])(\MAKESPACEFORLOCKEDPAGE  [LAMBDA (VP FILEPAGE)                                      (* bvm: "12-Aug-85 18:34")          (* VP is a page to be locked, FILEPAGE its home. Returns a possibly new file page where VP will now live, after 	  having kicked the former resident of the new file page into VP's old FILEPAGE)    (PROG (DESIREDFP OLDVP FPBASE)          [SETQ DESIREDFP (SELECTC (FOLDLO VP PAGESPERSEGMENT)				   ((FOLDLO \VP.STACK PAGESPERSEGMENT)				     (IPLUS VP (IDIFFERENCE (DLFPFROMRP \RP.STACK)							    \VP.STACK)))				   ((FOLDLO \VP.DISPLAY PAGESPERSEGMENT)                                                             (* Display lives in a fixed place in file, but does not							     land there initially)				     (IPLUS VP (IDIFFERENCE (DLFPFROMRP \RP.TEMPDISPLAY)							    \VP.DISPLAY)))				   ((FOLDLO \VP.FPTOVP PAGESPERSEGMENT)                                                             (* A new page of FPTOVP has to be continguous on file 							     with other such pages)				     (IPLUS VP (IDIFFERENCE (DLFPFROMRP \RP.FPTOVP)							    \VP.FPTOVP)))				   (COND				     ((AND (ILEQ FILEPAGE (fetch LastLockedFilePage of \InterfacePage)						 )					   (IGREATERP FILEPAGE (DLFPFROMRP \RP.TYPETABLE)))                                                             (* Page is in a good place already.							     It probably was once locked, then unlocked)				       (RETURN FILEPAGE))				     (T                      (* Put it after all the other locked pages)					(add (fetch LastLockedFilePage of \InterfacePage)					     1]          (COND	    ((AND (fetch FPOCCUPIED of (SETQ FPBASE (\ADDBASE \FPTOVP DESIREDFP)))		  (NEQ (SETQ OLDVP (fetch FPVIRTUALPAGE of FPBASE))		       VP))                                  (* Someone else lives here, so move it out)	      (\MOVEVMEMFILEPAGE OLDVP DESIREDFP FILEPAGE)))          (RETURN DESIREDFP])(\MOVEVMEMFILEPAGE  [LAMBDA (VP OLDFP NEWFP)                                   (* bvm: "18-Nov-84 14:14")    (PROG ((FLAGS (\READFLAGS VP))	   RP)          (COND	    ((fetch (VMEMFLAGS VACANT) of FLAGS)             (* Page not resident, so pull it in)	      (\LOADVMEMPAGE VP OLDFP)	      (SETQ FLAGS \VMAP.CLEAN))	    ((\LOCKEDPAGEP VP)	      (\MP.ERROR \MP.BADLOCKED "Locked page is in the way" VP)))          (\WRITEMAP VP (SETQ RP (\READRP VP))		     (LOGOR FLAGS \VMAP.DIRTY))              (* Mark page dirty, so that it will eventually be 							     written to its new home)          (replace (RPT FILEPAGE) of (fetch RPTRBASE of (RPTFROMRP RP)) with NEWFP)                                                             (* Tell RPT where VP now lives)          (\PUTBASE (.PAGEMAPBASE. VP)		    0 NEWFP)                                 (* Tell \PAGEMAP about it)          (\PUTBASE \FPTOVP NEWFP VP)                        (* ... and \FPTOVP)      ])(\NEWEPHEMERALPAGE  [LAMBDA (BASE NOERROR)                                     (* bvm: "26-NOV-82 15:40")          (* * Creates and returns a new page located at virtual addr BASE, mapping it permanently into some real page but 	  leaving it out of the vmem file)    (\MISCAPPLY* (FUNCTION \DONEWEPHEMERALPAGE)		 BASE NOERROR])(\DONEWEPHEMERALPAGE  [LAMBDA (BASE NOERROR)                                     (* bvm: "13-Aug-85 16:42")          (* * Creates and returns a new page located at virtual addr BASE, mapping it permanently into some real page but 	  leaving it out of the vmem file)    (PROG ((VP (fetch (POINTER PAGE#) of BASE))	   MAPBASE PREVRP RPTINDEX RPTR)          (RETURN (COND		    ((fetch (VP INVALID) of VP)		      (\INVALIDVP VP)		      NIL)		    (T (SETQ MAPBASE (\GETBASE \PageMapTBL (fetch (VP PRIMARYKEY) of VP)))                                                             (* First check that the page doesn't exist)		       (COND			 ([OR (AND (NEQ MAPBASE \EMPTYPMTENTRY)				   (NEQ (\GETBASE \PAGEMAP (IPLUS MAPBASE (fetch (VP SECONDARYKEY)									     of VP)))					0))			      (NOT (fetch (VMEMFLAGS VACANT) of (\READFLAGS VP]                                                             (* Page is in the vmem already, so no hope)			   (COND			     ((NOT NOERROR)			       (\MP.ERROR \MP.NEWPAGE "Page already exists " BASE T)))			   (RETURN BASE)))		       (COND			 ((IGREATERP \PAGEFAULTCOUNTER \UPDATECHAINFREQ)			   (\UPDATECHAIN)))		       (add \PAGEFAULTCOUNTER 1)		       (SETQ RPTINDEX (\SELECTREALPAGE NIL T (QUOTE REMOVE)))                                                             (* Find a page to put this in)		       (SETQ RPTR (fetch RPTRBASE of RPTINDEX))                                                             (* Fill in new RPTINDEX with appropriate data)		       (replace (RPT VP) of RPTR with \RPT.UNAVAILABLE)		       (replace (RPT FILEPAGE) of RPTR with VP)                                                             (* For debugging only)		       (FLIPCURSORBAR 0)		       (\WRITEMAP VP (RPFROMRPT RPTINDEX)				  \VMAP.DIRTY)               (* Set flags for page)		       (\CLEARWORDS (create POINTER					    PAGE# &larr; VP)				    WORDSPERPAGE)            (* Clear new page)		       (FLIPCURSORBAR 0)		       (\BOXIPLUS (LOCF (fetch PAGEFAULTS of \MISCSTATS))				  1)		       (COND			 (\NEWVMEMPAGEADDED (\ASSURE.FPTOVP.PAGE)))		       BASE])(\LOCKPAGES  [LAMBDA (BASE NPAGES)                                      (* bvm: "26-NOV-82 15:17")                                                             (* Needs to be done in safe stack context because might							     cause vmem transfer)    (\MISCAPPLY* (FUNCTION \DOLOCKPAGES)		 BASE NPAGES)    BASE])(\DOLOCKPAGES  [LAMBDA (BASE NPAGES)                                      (* bvm: "16-Aug-85 05:41")    (for I from 0 to (SUB1 NPAGES) bind (VP &larr;(fetch (POINTER PAGE#) of BASE))					FILEPAGE MAPBASE RPTBASE RPINDEX RP MASK LOCKBASE       do [COND	    ((fetch (VP INVALID) of VP)	      (\INVALIDVP VP))	    [(EQ (SETQ MAPBASE (\GETBASE \PageMapTBL (fetch (VP PRIMARYKEY) of VP)))		 \EMPTYPMTENTRY)	      (\INVALIDADDR (ADDBASE BASE (UNFOLD I WORDSPERPAGE]	    (T [SETQ MAPBASE (\ADDBASE \PAGEMAP (IPLUS MAPBASE (fetch (VP SECONDARYKEY) of VP]	       (SETQ FILEPAGE (\GETBASE MAPBASE 0))	       (COND		 ((EQ 0 (LOGAND (SETQ MASK (.LOCKEDVPMASK. VP))				(\GETBASE (SETQ LOCKBASE (.LOCKEDVPBASE. VP))					  0)))               (* Not locked yet)		   (COND		     ((fetch VACANT of (\READFLAGS VP))      (* Bring locked page into core so we can move it if 							     necessary)		       (\LOADVMEMPAGE VP FILEPAGE NIL T)))		   [SETQ RPTBASE (fetch RPTRBASE of (SETQ RPINDEX (RPTFROMRP (SETQ RP (\READRP VP]		   [COND		     ((AND (NOT (.LOCKABLERP. RP))			   (NOT (\SPECIALRP VP)))          (* Page already swapped in, but lives in a real page that might need to get bumped (e.g., for stack), so move it 	  now. If \SPECIALRP is true then we know that the page got swapped into the right place, so no need to move it.)		       (LET* ((NEWINDEX (\SELECTREALPAGE NIL T))			      (NEWRPT (fetch RPTRBASE of NEWINDEX)))			     (\MOVEREALPAGE RPINDEX RPTBASE NEWINDEX NEWRPT)			     (replace (RPT EMPTY) of RPTBASE with T)                                                             (* Mark vacated RPT entry empty)			     (SETQ RPTBASE NEWRPT)			     (SETQ RP (RPFROMRPT NEWINDEX]		   (COND		     ((NEQ FILEPAGE (SETQ FILEPAGE (\MAKESPACEFORLOCKEDPAGE VP FILEPAGE)))          (* Moving to a new page, so have to mark this locked page dirty so that it will eventually get written to its new 	  home)		       (\WRITEMAP VP RP (LOGOR \VMAP.DIRTY \VMAP.REF))		       (replace (RPT FILEPAGE) of RPTBASE with FILEPAGE)		       (\PUTBASE \FPTOVP FILEPAGE VP)		       (\PUTBASE MAPBASE 0 FILEPAGE)))		   (\PUTBASE LOCKBASE 0 (LOGOR MASK (\GETBASE LOCKBASE 0)))                                                             (* Set lock bit in page map)		   (replace (RPT LOCKED) of RPTBASE with T]	  (add VP 1)       finally (COND		 (\NEWVMEMPAGEADDED                          (* If we had to load or rearrange pages, vmem could 							     have gotten bigger if VMEM.PURE.STATE on)				    (\ASSURE.FPTOVP.PAGE])(\TEMPLOCKPAGES  [LAMBDA (BASE NPAGES)                                      (* bvm: "10-Aug-85 18:17")          (* * "Temporarily" locks BASE for NPAGES, i.e. ensures that the swapper will not move the pages.	  Information vanishes at logout etc.)    (\MISCAPPLY* (FUNCTION \DOTEMPLOCKPAGES)		 BASE NPAGES])(\DOTEMPLOCKPAGES  [LAMBDA (BASE NPAGES)                                      (* bvm: "10-Aug-85 18:26")          (* "Temporarily" locks BASE for NPAGES, i.e. ensures that the swapper will not move the pages.	  Information vanishes at logout etc. This function must be locked because it manipulates the page table table.	  Runs in MISC context)    (to NPAGES as VP from (fetch (POINTER PAGE#) of BASE) bind RPTBASE RPINDEX RP       do (\TOUCHPAGE BASE)                                  (* Touch page in case not resident)	  [SETQ RPTBASE (fetch RPTRBASE of (SETQ RPINDEX (RPTFROMRP (SETQ RP (\READRP VP]	  [COND	    ((NOT (.LOCKABLERP. RP))          (* Page already swapped in, but lives in a real page that might need to get bumped (e.g., for stack), so move it 	  now)	      (LET* ((NEWINDEX (\SELECTREALPAGE NIL T))		     (NEWRPT (fetch RPTRBASE of NEWINDEX)))		    (\MOVEREALPAGE RPINDEX RPTBASE NEWINDEX NEWRPT)		    (replace (RPT EMPTY) of RPTBASE with T)                                                             (* Mark vacated RPT entry empty)		    (SETQ RPTBASE NEWRPT]	  (replace (RPT LOCKED) of RPTBASE with T)	  (SETQ BASE (\ADDBASE BASE WORDSPERPAGE])(\TEMPUNLOCKPAGES  [LAMBDA (BASE NPAGES)                                      (* bvm: "30-Jul-85 16:58")                                                             (* Unlocks pages that were locked by \TEMPLOCKPAGES.							     This function must be locked because it manipulates the							     page table)    (while (IGREATERP NPAGES 0) bind (VP &larr;(fetch (POINTER PAGE#) of BASE))				     RPTR       do (UNINTERRUPTABLY              (\TOUCHPAGE BASE)                              (* Touch page in case not resident.							     Should only happen if page wasn't locked to begin with)	      (COND		((AND (NEQ (SETQ RPTR (\READRP VP))			   0)		      (EQ [fetch (RPT VP) of (SETQ RPTR (fetch RPTRBASE of (RPTFROMRP RPTR]			  VP))		  (COND		    ([AND DOLOCKCHECKS (EQ (LRSH VP 8)					   (CONSTANT (\HILOC \PAGEMAP]		      (\MP.ERROR \MP.UNLOCKINGMAP "Attempt to unlock map page" VP)))		  (replace (RPT LOCKED) of RPTR with NIL))		(T (HELP "Page table changed out from under me!" VP))))	  (add VP 1)	  (add NPAGES -1)	  (SETQ BASE (\ADDBASE BASE WORDSPERPAGE])(\UNLOCKPAGES  [LAMBDA (BASE NPAGES)                                      (* bvm: "30-Jul-85 16:58")          (* * Unlocks NPAGES virtual pages from BASE onward)    (UNINTERRUPTABLY        (for I from 0 to (SUB1 NPAGES) bind (VP &larr;(fetch (POINTER PAGE#) of BASE))					    MASK LOCKBASE	   do (COND		((fetch (VP INVALID) of VP)		  (\INVALIDVP VP))		((NEQ 0 (LOGAND (SETQ MASK (.LOCKEDVPMASK. VP))				(\GETBASE (SETQ LOCKBASE (.LOCKEDVPBASE. VP))					  0)))               (* Yes, page was locked, so turn the bit off now)		  (COND		    ([AND DOLOCKCHECKS (EQ (LRSH VP 8)					   (CONSTANT (\HILOC \PAGEMAP]		      (\MP.ERROR \MP.UNLOCKINGMAP "Attempt to unlock map page" VP)))		  (\PUTBASE LOCKBASE 0 (LOGXOR MASK (\GETBASE LOCKBASE 0)))                                                             (* Update pagemap, then update real page table)		  (replace (RPT LOCKED) of (fetch RPTRBASE of (RPTFROMRP (\READRP VP))) with NIL)))	      (add VP 1)))])(\FLUSHVM  [LAMBDA NIL                                                (* bvm: "13-Feb-85 19:55")                                                             (* Writes out all dirty pages to vmem, making it 							     consistent. Returns NIL now, T if Bcpl starts up the 							     vmem)    (COND      ((\FLUSHVMOK?)	(UNINTERRUPTABLY                                     (* Write stuff out from a safe place)	    (PROG1 (COND		     ((\MISCAPPLY* (FUNCTION \DOFLUSHVM))    (* Return from Bcpl startup.							     Need to rebuild the context, since it was not written 							     out consistently)		       (SETQ \DOFAULTINIT T)                 (* Tell pagefault handler to initialize itself.							     Want the initialization to happen in Fault context to 							     avoid stack overflow messiness)		       (\CONTEXTSWITCH \FAULTFXP)		       (for VAR in \SYSTEMCACHEVARS do (SET VAR NIL))		       T))		   (SETQ \DIRTYPAGEHINT 32767)))])(\LOGOUT0  (LAMBDA (FAST)                                             (* bvm: "13-Feb-85 20:11")    (COND      ((OR (EQ (fetch MachineType of \InterfacePage)	       \DORADO)	   (EQ (fetch MachineType of \InterfacePage)	       \DOLPHIN))          (* * If we're running on a Dolphin or Dorado, we update the alto's clock. Note that Dandelions and Daybreaks don't 	  have alto clocks, so this wouldn't work on them)	(\BLT (EMADDRESS \RTCSECONDS)	      (LOCF (fetch SECONDSCLOCK of \MISCSTATS))	      (UNFOLD 3 WORDSPERCELL))))    (UNINTERRUPTABLY        (OR (AND (OR (NOT FAST)		     (AND (EQ FAST (QUOTE ?))			  (NOT (.VMEM.CONSISTENTP.))))		 (\FLUSHVM))	    (SELECTC (fetch MachineType of \InterfacePage)		     (\DAYBREAK (\DoveMisc.BootButton))		     (\LISPFINISH))))))(\DOFLUSHVM  [LAMBDA NIL                                                (* bvm: " 8-Jul-85 20:52")          (* * Write everything out in a resumable way. Value is NIL if returned from directly, T if from saved state.	  Always invoked via \MISCAPPLY*)    (CHECK (NOT \INTERRUPTABLE))                             (* NOTE: need stats gathering off in here.							     Also avoid touching pages)    (PROG ((IFPVP (fetch (POINTER PAGE#) of \InterfacePage))	   (SCRATCHBUF \EMUSWAPBUFFERS)	   IFPRPT)          (replace (IFPAGE MISCSTACKRESULT) of \InterfacePage with T)                                                             (* This will make it look like we have returned from 							     BCPL if caller gets control from the saved state)          [COND	    ((OR (EQ \MACHINETYPE \DANDELION)		 (EQ \MACHINETYPE \DAYBREAK))                (* Mark all active stack pages dirty, since the 							     microcode doesn't)	      (for VP from \VP.STACK to (IPLUS \VP.STACK (fetch HIBYTE of (fetch EndOfStack									     of \InterfacePage)))		 as RP from \RP.STACK do (\WRITEMAP VP RP (LOGOR \VMAP.REF \VMAP.DIRTY)))                                                             (* Similarly, the GC table does not get marked dirty)	      (for VP from \VP.GCTABLE to (IPLUS \VP.GCTABLE (SUB1 \NP.GCTABLE)) as RP from 										      \RP.GCTABLE		 do (\WRITEMAP VP RP (LOGOR \VMAP.REF \VMAP.DIRTY]          [COND	    (\VMEM.PURE.LIMIT                                (* Maintaining file consistency: move high water mark 							     up)			      (COND				(VMEM.COMPRESS.FLG (\DOCOMPRESSVMEM)))			      (SETQ \VMEM.PURE.LIMIT (fetch (IFPAGE NActivePages) of \InterfacePage]          (COND	    ((.VMEM.CONSISTENTP.)	      (replace (IFPAGE Key) of \InterfacePage with (LOGNOT16 \IFPValidKey))                                                             (* Invalidate vmem and write out the Interface page)	      (\TRANSFERPAGE IFPVP \FirstVmemBlock (RPTFROMRP (\READRP IFPVP))			     T NIL)))          (SETQ IFPRPT (RPTFROMRP (\READRP IFPVP)))          (for RPTINDEX from 1 to (SUB1 \RPTSIZE) do (\FLUSHPAGE RPTINDEX T) unless (EQ RPTINDEX 											IFPRPT))          (replace (IFPAGE Key) of \InterfacePage with \IFPValidKey)          (\BLT SCRATCHBUF \InterfacePage WORDSPERPAGE)      (* Make its current fx point at user context, i.e. the 							     \FLUSHVM frame)          (replace (IFPAGE CurrentFXP) of SCRATCHBUF with (fetch (IFPAGE MiscFXP) of \InterfacePage))          (\ACTONVMEMFILE (\LOOKUPPAGEMAP IFPVP)			  SCRATCHBUF 1 T)                    (* Write the page out from a safe place)          (RETURN NIL])(\RELEASEWORKINGSET  [LAMBDA NIL                                                (* bvm: "29-Nov-84 10:56")    (COND      ((\FLUSHVM)                                            (* Returning from Lisp startup)	T)      (T                                                     (* Unmap any unlocked page)	 (for RPTINDEX from 1 to (SUB1 \RPTSIZE) bind RPTR	    when (AND (fetch (RPT OCCUPIED) of (SETQ RPTR (fetch RPTRBASE of RPTINDEX)))		      (NOT (fetch (RPT LOCKED) of RPTR)))	    do (\WRITEMAP (fetch (RPT VP) of RPTR)			  (RPFROMRPT RPTINDEX)			  \VMAP.VACANT)	       (replace (RPT EMPTY) of RPTR with T])(\WRITEDIRTYPAGE  [LAMBDA (MINDIRTY)                                         (* bvm: "13-Aug-85 17:51")    (COND      ((OR (NOT (.VMEM.CONSISTENTP.))	   (AND \VMEM.PURE.LIMIT (NEQ \VMEM.PURE.LIMIT -1)		(NOT \VMEM.FULL.STATE)))	(PROG ((RPTR (OR \LASTDIRTYSCANPTR \REALPAGETABLE))	       (NUMDIRTY (OR \LASTDIRTYCNT 0))	       (CNT \MAXDIRTYSCANCOUNT)	       RP FP FLAGS)	      [COND		((AND (NULL \LASTDIRTYSCANPTR)		      (IGREATERP (IPLUS (add \DIRTYPAGECOUNTER 1)					\PAGEFAULTCOUNTER)				 \UPDATECHAINFREQ))          (* Take this time to update the page chain instead)		  (RETURN (UNINTERRUPTABLY                              (\MISCAPPLY* (FUNCTION \UPDATECHAIN)))]	      (OR MINDIRTY (SETQ MINDIRTY 1))	  LP  [COND		[(EQ (SETQ RP (fetch (RPT NEXTRP) of RPTR))		     \PAGETABLESTOPFLG)                      (* Hit end of chain. Write out what we found if enough 							     were dirty)		  (COND		    ((AND (IGEQ NUMDIRTY MINDIRTY)			  (NEQ NUMDIRTY 0)			  (SETQ RP \LASTDIRTYFOUND))		      (GO GOTPAGE))		    (T (SETQ \LASTDIRTYSCANPTR (SETQ \LASTDIRTYCNT (SETQ \LASTDIRTYFOUND NIL)))		       [COND			 ((AND (NEQ NUMDIRTY 0)			       (ILESSP \DIRTYSEEKMAX (LRSH MAX.SMALL.INTEGER 1)))                                                             (* Failed because page not close enough, so widen the 							     tolerance)			   (SETQ \DIRTYSEEKMAX (LLSH \DIRTYSEEKMAX 1]		       (RETURN]		((fetch (RPT EMPTY) of (SETQ RPTR (fetch RPTRBASE of RP)))                                                             (* Page is empty. Should never happen if key is valid)		  (RETURN))		((NOT (fetch (RPT LOCKED) of RPTR))          (* Don't bother writing out locked pages, since they 							     don't help us in our swapping quest)		  (SETQ FLAGS (\READFLAGS (fetch (RPT VP) of RPTR)))		  (COND		    ((NOT (fetch (VMEMFLAGS DIRTY) of FLAGS))                                                             (* Page not dirty; skip)		      )		    [(PROGN (SETQ FP (fetch (RPT FILEPAGE) of RPTR))			    (IGREATERP (IABS (IDIFFERENCE (COND							    ((AND \VMEM.PURE.LIMIT (ILESSP FP 										 \VMEM.PURE.LIMIT))                                                             (* We'd have to write page to a new place, not here)							      (fetch (IFPAGE NActivePages)								 of \InterfacePage))							    (T FP))							  \LASTACCESSEDVMEMPAGE))				       \DIRTYSEEKMAX))       (* Page too far away, don't write it)		      (COND			((fetch (VMEMFLAGS REFERENCED) of FLAGS)                                                             (* but still count it)			  (add NUMDIRTY 1]		    ((IGREATERP FP \LASTVMEMFILEPAGE)        (* Can't write it)		      )		    ((fetch (VMEMFLAGS REFERENCED) of FLAGS)                                                             (* Page dirty but referenced.							     Note it, but keep looking for a better one)		      (COND			((EQ NUMDIRTY 0)			  (SETQ \LASTDIRTYFOUND RP)))		      (add NUMDIRTY 1))		    (T                                       (* Dirty, not referenced: do it)		       (GO GOTPAGE]	      (COND		((EQ (add CNT -1)		     0)                                      (* Scanned for long enough; don't lock user out)		  (SETQ \LASTDIRTYSCANPTR RPTR)		  (SETQ \LASTDIRTYCNT NUMDIRTY)		  (RETURN)))	      (GO LP)	  GOTPAGE	      (UNINTERRUPTABLY                  (SETQ \LASTDIRTYSCANPTR (SETQ RPTR (fetch RPTRBASE of RP)))                                                             (* Keep traveling pointer)		  (SETQ \LASTDIRTYCNT (SETQ \LASTDIRTYFOUND NIL))		  (COND		    ((ILEQ (IABS (IDIFFERENCE (fetch (RPT FILEPAGE) of RPTR)					      \LASTACCESSEDVMEMPAGE))			   \DIRTYSEEKMAX)                    (* Could fail if swapping since the selection has moved							     the disk arm too far)		      (\MISCAPPLY* (FUNCTION \WRITEDIRTYPAGE1)				   RP RPTR)))		  (SETQ \DIRTYSEEKMAX \MAXSHORTSEEK))	      (RETURN T])(\WRITEDIRTYPAGE1  [LAMBDA (RP RPTR)                                          (* bvm: "13-Aug-85 16:41")                                                             (* Write out buffer RP. This fn is locked and called in							     the misc context)    (COND      ([AND (NOT (fetch (RPT LOCKED) of RPTR))	    (fetch (VMEMFLAGS DIRTY) of (\READFLAGS (fetch (RPT VP) of RPTR]                                                             (* Verify that the page is still a candidate, so 							     previous loop could be interruptable)	(\FLUSHPAGE RP)	(COND	  (\NEWVMEMPAGEADDED (\ASSURE.FPTOVP.PAGE])(\COUNTREALPAGES  [LAMBDA (TYPE)                                             (* bvm: "18-Dec-84 15:31")    (SELECTQ TYPE	     [(DIRTY REF)	       (PROG [(FLAGBITS (COND				  ((EQ TYPE (QUOTE DIRTY))				    \VMAP.DIRTY)				  (T \VMAP.REF]		     (RETURN (NPAGESMACRO (NEQ (LOGAND (\READFLAGS VP)						       FLAGBITS)					       0]	     (LOCKED (NPAGESMACRO (fetch (RPT LOCKED) of RPTR)))	     (OCCUPIED (NPAGESMACRO T))	     (\ILLEGAL.ARG TYPE]))(DEFINEQ(\DOCOMPRESSVMEM  [LAMBDA NIL                                                (* bvm: " 7-Apr-84 17:53")          (* * Called underneath \DOFLUSHVM to write the pages above the high water mark back to the places vacated below that	  mark)    (PROG ((EMPTYFP (DLFPFROMRP \RP.GCTABLE))	   (LASTFP (fetch NActivePages of \InterfacePage))	   (OLDVIW \VMEM.INHIBIT.WRITE)	   VP)          [COND	    ((NULL OLDVIW)                                   (* Encourage \SELECTREALPAGE to select only "old" file 							     pages for displacement, so that we don't needlessly 							     write the same page twice)	      (SETQ \VMEM.INHIBIT.WRITE (QUOTE NEW]      LP  (COND	    ((IGEQ EMPTYFP LASTFP)	      (SETQ \VMEM.INHIBIT.WRITE OLDVIW)	      (RETURN)))          [COND	    ((EQ (\GETBASE \FPTOVP EMPTYFP)		 \NO.VMEM.PAGE)	      (while (EQ (SETQ VP (\GETBASE \FPTOVP LASTFP))			 \NO.VMEM.PAGE)		 do (SETQ LASTFP (SUB1 LASTFP)))	      (\MOVEVMEMFILEPAGE VP LASTFP EMPTYFP)	      (replace NActivePages of \InterfacePage with (SETQ LASTFP (SUB1 LASTFP]          (add EMPTYFP 1)          (GO LP])(VMEM.PURE.STATE  [LAMBDA FLG                                                (* bvm: " 7-Apr-84 16:59")    (PROG1 (NOT (NULL \VMEM.PURE.LIMIT))	   (COND	     ((IGREATERP FLG 0)          (* Set \VMEM.PURE.LIMIT appropriately. If turning on, and it wasn't on before, set it to -1 so that it takes effect 	  only at the next FLUSHVM)	       (SETQ \VMEM.PURE.LIMIT (AND (ARG FLG 1)					   (OR \VMEM.PURE.LIMIT (SETQ \VMEM.PURE.LIMIT -1]))(DEFINEQ(32MBADDRESSABLE  [LAMBDA NIL                                                (* mpl "20-Jun-85 11:08")    (SELECTC \MACHINETYPE	     (\DORADO T)	     (\DOLPHIN NIL)	     (\DAYBREAK T)	     (NEQ 0 (fetch (IFPAGE DL24BitAddressable) of \InterfacePage])(\SET.VMEM.FULL.STATE  [LAMBDA NIL                                                (* bvm: "13-Feb-85 20:12")                                                             (* We are running out of vmem, try to extend file.							     Do this at next convenient time)    (COND      ((NOT \VMEM.FULL.STATE)                                (* Get an interrupt to handle this)	(replace VMEMFULL of \INTERRUPTSTATE with T)	(SETQ \PENDINGINTERRUPT T)))    (SETQ \VMEM.FULL.STATE (COND	((ILESSP (fetch (IFPAGE NActivePages) of \InterfacePage)		 \LASTVMEMFILEPAGE)                          (* Not completely full, allow normal things to happen)	  0)	((.VMEM.CONSISTENTP.)	  T)	(T (QUOTE DIRTY])(\DOVMEMFULLINTERRUPT  [LAMBDA NIL                                                (* bvm: "15-Feb-85 00:08")          (* * Called while interruptable when vmem is full or nearly so. Tries to extend vmem file, or gives error if it 	  can't)    (COND      (\EXTENDINGVMEMFILE           (* Another interrupt happened while we are extending file. Don't try to do this one twice, but repost the interrupt 	  in the hopes that it will happen after vmem extension is finished)			  (SETQ \PENDINGINTERRUPT T))      (T (RESETVARS ((\EXTENDINGVMEMFILE T))		    (COND		      ((NULL (SELECTC \MACHINETYPE				      ((LIST \DOLPHIN \DORADO)					(\M44EXTENDVMEMFILE (IPLUS (IMAX \LASTVMEMFILEPAGE									 (fetch (IFPAGE NActivePages)									    of \InterfacePage))								   \GUARDVMEMFULL 1)))				      T))                    (* Disk declines to do it now, try later)			(SETQ \PENDINGINTERRUPT T))		      ((IGREATERP (IDIFFERENCE \LASTVMEMFILEPAGE \GUARDVMEMFULL)				  (fetch (IFPAGE NActivePages) of \InterfacePage))			(SETQ \VMEM.FULL.STATE NIL)          (* All is okay, dismiss alarm.							     Can't disable interrupt until now to assure consistent 							     value for \VMEM.FULL.STATE)			(replace VMEMFULL of \INTERRUPTSTATE with NIL))		      (T (PROG ((HELPFLAG (QUOTE BREAK!)))			       (replace VMEMFULL of \INTERRUPTSTATE with NIL)                                                             (* Very slight chance of losing the break if &uarr;E right 							     here. Don't know how to fix this)			       (ERROR (CONCAT "Your virtual memory backing file is "					      (COND						((IGEQ (fetch (IFPAGE NActivePages) of \InterfacePage)						       \LASTVMEMFILEPAGE)						  "complete")						(T "near"))					      "ly full.")				      "Save your work &amp; reload a.s.a.p."])(\FLUSHVMOK?  [LAMBDA (TYPE NOERROR)                                     (* bvm: "13-Aug-85 17:52")          (* * Called before any attempt to do a \FLUSHVM to make sure it's ok)    (LET [(MSG (COND		 ((SELECTQ \VMEM.FULL.STATE			   ((T DIRTY)			     T)			   NIL)		   "-- virtual memory backing file too small")		 ((AND \VMEM.PURE.LIMIT (NEQ \VMEM.PURE.LIMIT -1)		       (NOT VMEM.COMPRESS.FLG))		   " while VMEM.PURE.STATE is on."]         (COND	   ((NOT MSG)	     T)	   (T [COND		((NOT NOERROR)		  (ERROR [CONCAT "Can't " (OR TYPE (SETQ TYPE (QUOTE LOGOUT]			 "-- virtual memory backing file too small"			 (COND			   ((EQ TYPE (QUOTE LOGOUT))			     "You may (LOGOUT T), which quits without saving state.")			   (T ""]	      NIL]))(RPAQ? \UPDATECHAINFREQ 144Q)(RPAQ? \PAGEFAULTCOUNTER 0)(RPAQ? \DIRTYPAGECOUNTER 0)(RPAQ? \DIRTYPAGEHINT 0)(RPAQ? \LASTACCESSEDVMEMPAGE 0)(RPAQ? \MAXSHORTSEEK 1750Q)(RPAQ? \MINSHORTSEEK 24Q)(RPAQ? \MAXCLEANPROBES 24Q)(RPAQ? \VMEM.INHIBIT.WRITE )(RPAQ? \VMEM.PURE.LIMIT )(RPAQ? \VMEM.FULL.STATE )(RPAQ? \GUARDVMEMFULL 764Q)(RPAQ? VMEM.COMPRESS.FLG )(RPAQ? \DOFAULTINIT 0)(RPAQ? \VMEMACCESSFN )(RPAQ? \SYSTEMCACHEVARS )(RPAQ? \MAXSWAPBUFFERS 1)(RPAQ? \EXTENDINGVMEMFILE )(RPAQ? \MaxScreenPage 0)(RPAQ? \NEWVMEMPAGEADDED )(RPAQ? \LASTDIRTYCNT )(RPAQ? \LASTDIRTYFOUND )(RPAQ? \LASTDIRTYSCANPTR )(RPAQ? \DIRTYSEEKMAX 62Q)(* Errors)(DEFINEQ(\MP.ERROR  [LAMBDA (CODE STRING ARG1 ARG2)                            (* mpl "20-Jun-85 11:09")    (COND      ((OR (EQ \MACHINETYPE \DANDELION)	   (EQ \MACHINETYPE \DAYBREAK))	((OPCODES RAID)	 CODE))      (T (RAID STRING ARG1 ARG2]))(* Debugging)(DEFINEQ(\ACTONVMEMFILE  [LAMBDA (FILEPAGE BUFFER NPAGES WRITEFLAG)                 (* MPL "22-Jun-85 20:18")    (COND      ((EQ \MACHINETYPE \DANDELION)	(\DL.ACTONVMEMFILE FILEPAGE BUFFER NPAGES WRITEFLAG))      ((EQ \MACHINETYPE \DAYBREAK)	(\DOVE.ACTONVMEMFILE FILEPAGE BUFFER NPAGES WRITEFLAG))      (T (\M44ACTONVMEMFILE FILEPAGE BUFFER NPAGES WRITEFLAG])(\SHOWPAGETABLE  [LAMBDA (MODE FILE)                                        (* bvm: "19-Feb-85 14:47")    (RESETLST (RESETSAVE (OUTPUT FILE))	      (RESETSAVE (RADIX 8))	      (PROG ((RPTR \REALPAGETABLE)		     (RP 0)		     FLAGS VP STATE FIRSTONE LASTONE)		    (printout NIL "     RP      VP           FilePage  Status" T)		    (until (SELECTQ MODE				    (CHAIN (EQ (SETQ RP (fetch (RPT NEXTRP) of RPTR))					       \PAGETABLESTOPFLG))				    (NIL (add RP 1)					 (IGEQ RP \RPTSIZE))				    (\ILLEGAL.ARG MODE))		       do (SETQ RPTR (fetch RPTRBASE of RP))			  (SETQ VP (fetch (RPT VP) of RPTR))			  (COND			    ((AND (NULL MODE)				  (EQ VP STATE))			      (SETQ LASTONE RP))			    (T (COND				 (LASTONE (printout NIL "ditto thru " LASTONE T)					  (SETQ LASTONE NIL)))			       (SETQ FIRSTONE RP)			       (SETQ STATE VP)			       (printout NIL .I7.8 (RPFROMRPT RP))			       [COND				 ((fetch (RPT EMPTY) of RPTR)				   (PRIN1 " Empty"))				 ((NOT (fetch (RPT OCCUPIED) of RPTR))				   (PRIN1 " Unavailable"))				 (T (printout NIL .I8.8 VP , # (\PRINTVP VP)					      28 .I6.8 (fetch (RPT FILEPAGE) of RPTR)					      ,,)				    (COND				      ((fetch (RPT LOCKED) of RPTR)					(COND					  ((NOT (\LOCKEDPAGEP VP))                                                             (* not permanently locked)					    (PRIN1 "Temp")))					(PRIN1 "Locked ")))				    (UNLESSRDSYS (PROGN (COND							  ((fetch (VMEMFLAGS REFERENCED)							      of (SETQ FLAGS (\READFLAGS VP)))							    (PRIN1 "Ref ")))							(COND							  ((fetch (VMEMFLAGS DIRTY) of FLAGS)							    (PRIN1 "Dirty"]			       (TERPRI])(CHECKPAGEMAP  [LAMBDA NIL                                                (* bvm: "10-Dec-84 12:40")    (RESETFORM (RADIX 8)	       (PROG ((NUMOCCUPIED 0)		      (NUMLOCKED 0)		      (CHAINOCCUPIED 0)		      (CHAINLOCKED 0)		      RPTR FPBASE FP VP RP)		     (CHECKFPTOVP)		     [for RPTINDEX from 1 to (SUB1 \RPTSIZE) when (fetch (RPT OCCUPIED)								     of (SETQ RPTR									  (fetch RPTRBASE									     of RPTINDEX)))			do (add NUMOCCUPIED 1)			   (SETQ VP (fetch (RPT VP) of RPTR))			   (SETQ FP (fetch (RPT FILEPAGE) of RPTR))			   (COND			     ((CHECKFPTOVP1 FP VP RPTINDEX))			     ([NEQ VP (fetch FPVIRTUALPAGE of (SETQ FPBASE (\ADDBASE \FPTOVP FP]			       (printout T "RPT for RP " (RPFROMRPT RPTINDEX)					 " says VP ")			       (\PRINTVP VP T)			       (printout T " lives in FP " FP "; but FP Map says that FP contains ")			       (\PRINTVP (fetch FPVIRTUALPAGE of FPBASE)					 T)			       (printout T T))			     ((\LOCKEDPAGEP VP)			       (add NUMLOCKED 1)			       (COND				 ((NOT (fetch (RPT LOCKED) of RPTR))				   (printout T "VP " VP ", living in RP " (RPFROMRPT RPTINDEX)					     " should be locked but isn't." T))				 ((IGREATERP FP (DLRPFROMFP (fetch (IFPAGE LastLockedFilePage)							       of \InterfacePage)))				   (printout T "VP " VP " is locked, but living in FP " FP 					     ", which is not in the locked page area"					     T]		     (PROGN (SETQ RPTR \REALPAGETABLE)       (* Check pagetable chain)			    [while (NEQ (SETQ RP (fetch (RPT NEXTRP) of RPTR))					\PAGETABLESTOPFLG)			       when (fetch (RPT OCCUPIED) of (SETQ RPTR (fetch RPTRBASE of RP)))			       do (add CHAINOCCUPIED 1)				  (COND				    ((fetch (RPT LOCKED) of RPTR)				      (add CHAINLOCKED 1]			    (COND			      ((ILESSP CHAINOCCUPIED NUMOCCUPIED)				(printout T NUMOCCUPIED " occupied pages, but only " CHAINOCCUPIED 					  " are on page chain.  "					  NUMLOCKED " pages are permanently locked; " CHAINLOCKED 					  " pages on chain are locked somehow."					  T])(CHECKFPTOVP  [LAMBDA NIL                                                (* bvm: "10-Dec-84 12:39")    (for FP from 1 to (fetch NActivePages of \InterfacePage) as (FPBASE &larr;(\ADDBASE \FPTOVP 1))       by (\ADDBASE FPBASE 1) when (fetch FPOCCUPIED of FPBASE) do (CHECKFPTOVP1 FP										 (fetch FPVIRTUALPAGE										    of FPBASE])(CHECKFPTOVP1  [LAMBDA (FP VP RPTINDEX)                                   (* bvm: "10-Dec-84 12:36")    (PROG ((FP2 (\LOOKUPPAGEMAP VP)))          (RETURN (COND		    ((NEQ FP2 FP)		      (COND			((UNLESSRDSYS RPTINDEX)			  (printout T "RPT for RP " (RPFROMRPT RPTINDEX)))			(T (printout T "FP map")))		      (printout T " says FP " FP " contains VP ")		      (\PRINTVP VP T)		      (printout T "; but PageMap says that page is in FP " FP2 T)		      T])(\PRINTFPTOVP  [LAMBDA (BASE NWORDS STREAM)                               (* bvm: "19-Feb-85 13:10")    (SETQ STREAM (GETSTREAM STREAM (QUOTE OUTPUT)))    (OR BASE (SETQ BASE \FPTOVP))    (OR NWORDS (SETQ NWORDS (fetch (IFPAGE NActivePages) of \InterfacePage)))    (RESETFORM (RADIX 8)	       (PROG ((LASTVP -2)		      (NEXTFP 0)		      FIRSTFP FIRSTVP NEXTVP LOCKEDP NEXTLOCKED)		     (while (IGEQ NWORDS 0)			do (add NEXTFP 1)			   [COND			     ((EQ NWORDS 0)			       (SETQ NEXTVP -1))			     ((NEQ (SETQ NEXTVP (\GETBASE (SETQ BASE (\ADDBASE BASE 1))							  0))				   \NO.VMEM.PAGE)			       (SETQ NEXTLOCKED (\LOCKEDPAGEP NEXTVP]			   [COND			     ([COND				 ((EQ NEXTVP \NO.VMEM.PAGE)				   (NEQ LASTVP \NO.VMEM.PAGE))				 (T (OR (NEQ NEXTVP (ADD1 LASTVP))					(NEQ NEXTLOCKED LOCKEDP]			       [COND				 ((IGEQ LASTVP 0)				   (COND				     (FIRSTFP (printout STREAM FIRSTFP "-")))				   (printout STREAM (SUB1 NEXTFP)					     12)				   (COND				     ((EQ LASTVP \NO.VMEM.PAGE)				       (printout STREAM "empty"))				     (T (COND					  (FIRSTFP (\PRINTVP FIRSTVP STREAM)						   (PRIN1 "-" STREAM)))					(\PRINTVP LASTVP STREAM)					(COND					  (LOCKEDP (PRIN1 (QUOTE *)							  STREAM]			       (SETQ FIRSTFP)			       (TERPRI STREAM)			       (SETQ FIRSTVP NEXTVP))			     (T                              (* in a run)				(OR FIRSTFP (SETQ FIRSTFP (SUB1 NEXTFP]			   (SETQ LASTVP NEXTVP)			   (SETQ LOCKEDP NEXTLOCKED)			   (add NWORDS -1])(\PRINTVP  [LAMBDA (VP STREAM)                                        (* bvm: "28-MAR-83 12:40")    (printout STREAM "{" (LRSH VP 8)	      ","	      (LOGAND VP 255)	      "}"]))(DECLARE: EVAL@COMPILE DONTCOPY (DECLARE: EVAL@COMPILE (PUTPROPS \ACTONVMEMFILE MACRO ((X . Y)	   (SPREADAPPLY* \VMEMACCESSFN X . Y)))(PUTPROPS .VMEM.CONSISTENTP. MACRO (NIL (EQ (fetch (IFPAGE Key)						   of \InterfacePage)					    \IFPValidKey)))[PUTPROPS .LOCKABLERP. MACRO ((RP)	   (* It's okay to lock a vp into this RP)	   (OR (NEQ (FOLDLO RP PAGESPERSEGMENT)		    (FOLDLO \RP.STACK PAGESPERSEGMENT))	       (NOT (OR (EQ \MACHINETYPE \DANDELION)			(EQ \MACHINETYPE \DAYBREAK])(* Virtual page flags)(DECLARE: EVAL@COMPILE (RPAQQ \VMAP.DIRTY 10000Q)(RPAQQ \VMAP.CLEAN 0)(RPAQQ \VMAP.REF 100000Q)(RPAQQ \VMAP.VACANT 30000Q)(RPAQQ \VMAP.FLAGS 170000Q)(RPAQQ \VMAP.NOTFLAGS 7777Q)(CONSTANTS \VMAP.DIRTY \VMAP.CLEAN \VMAP.REF \VMAP.VACANT \VMAP.FLAGS \VMAP.NOTFLAGS))[DECLARE: EVAL@COMPILE (ACCESSFNS VMEMFLAGS ((VACANT (EQ (LOGAND DATUM \VMAP.VACANT)				  \VMAP.VACANT))		      (DIRTY (NEQ (LOGAND DATUM \VMAP.DIRTY)				  0))		      (REFERENCED (NEQ (LOGAND DATUM \VMAP.REF)				       0))))](DECLARE: EVAL@COMPILE (PUTPROPS LOGNOT16 MACRO ((X)	   (LOGXOR X 177777Q))))(* RPT constants)(DECLARE: EVAL@COMPILE (RPAQQ \RPT.EMPTY 177776Q)(RPAQQ \RPT.UNAVAILABLE 177777Q)(RPAQQ \PAGETABLESTOPFLG 0)(RPAQQ \RPTENTRYLENGTH 3)(CONSTANTS \RPT.EMPTY \RPT.UNAVAILABLE \PAGETABLESTOPFLG \RPTENTRYLENGTH))[DECLARE: EVAL@COMPILE (BLOCKRECORD RPT ((LOCKED FLAG)		  (NEXTRP BITS 17Q)                          (* rp of next entry in page chain)		  (VP WORD)                                  (* Virtual page number occupying this real page)		  (FILEPAGE WORD)                            (* Page in Lisp.VirtualMem)		  )		 (BLOCKRECORD RPT ((NIL BITS 20Q)			       (VPSEG BYTE)			       (VPPAGEINSEG BYTE)))		 [ACCESSFNS RPT ([EMPTY (EQ (fetch (RPT VP) of DATUM)					    \RPT.EMPTY)					(COND					  (NEWVALUE (replace (RPT VP) of DATUM with \RPT.EMPTY))					  (T (ERROR "Invalid replace of RPT.EMPTY" DATUM]			     [UNAVAILABLE (EQ (fetch (RPT VP) of DATUM)					      \RPT.UNAVAILABLE)					  (COND					    (NEWVALUE (replace (RPT VP) of DATUM with 										 \RPT.UNAVAILABLE))					    (T (ERROR "Invalid replace of RPT.UNAVAILABLE" DATUM]			     (OCCUPIED (ILESSP (fetch (RPT VP) of DATUM)					       \RPT.EMPTY])(ACCESSFNS RPT1 (RPTRBASE (\ADDBASE \REALPAGETABLE (TIMES3 DATUM)))                                                             (* Given a RP, RPTRBASE produces a pointer to its entry							     in the real page table)		)](DECLARE: EVAL@COMPILE (PUTPROPS RPFROMRPT MACRO ((RPTINDEX)	   (IPLUS RPTINDEX \RPOFFSET)))(PUTPROPS RPTFROMRP MACRO ((RP)	   (IDIFFERENCE RP \RPOFFSET)))[PUTPROPS NPAGESMACRO MACRO ((FORM)	   (PROG ((RESULT 0)		  (CNTR \RPTSIZE)		  (RPTR \REALPAGETABLE)		  VP)		 (* Note order of loop: \REALPAGETABLE is dummy entry, so don't look at it, start at 		    next entry)		 LP		 (COND ((NEQ (SETQ CNTR (SUB1 CNTR))			     0)			(SETQ RPTR (\ADDBASE RPTR \RPTENTRYLENGTH))			(COND ((AND (fetch (RPT OCCUPIED)					   of RPTR)				    (PROGN (SETQ VP (fetch (RPT VP)							   of RPTR))					   FORM))			       (add RESULT 1)))			(GO LP)))		 (RETURN RESULT])(* Virtual to file pagemap)(* FOLLOWING DEFINITIONS EXPORTED)(DECLARE: EVAL@COMPILE (RPAQQ \MAXFILEPAGE 177776Q)(CONSTANTS \MAXFILEPAGE))(* END EXPORTED DEFINITIONS)(DECLARE: EVAL@COMPILE (RPAQQ \EMPTYPMTENTRY 177777Q)(CONSTANTS \EMPTYPMTENTRY))[DECLARE: EVAL@COMPILE (ACCESSFNS VP ((PRIMARYKEY (LRSH DATUM 5))	       (SECONDARYKEY (LOGAND DATUM 37Q))	       (INVALID (PROGN NIL))))](DECLARE: EVAL@COMPILE [PUTPROPS .PAGEMAPBASE. MACRO (OPENLAMBDA (VPAGE)					  (\ADDBASE \PAGEMAP (IPLUS (\GETBASE \PageMapTBL									      (fetch (VP PRIMARYKEY)										     of VPAGE))								    (fetch (VP SECONDARYKEY)									   of VPAGE])(* FP to VP stuff)[DECLARE: EVAL@COMPILE (BLOCKRECORD FPTOVP ((FPVIRTUALPAGE WORD))		    [ACCESSFNS FPTOVP ((FPOCCUPIED (NEQ (\GETBASE DATUM 0)							\NO.VMEM.PAGE])](DECLARE: EVAL@COMPILE (RPAQQ \NO.VMEM.PAGE 177777Q)(CONSTANTS \NO.VMEM.PAGE))(DECLARE: EVAL@COMPILE (PUTPROPS DLRPFROMFP MACRO ((FP)	   (ADD1 FP)))(PUTPROPS DLFPFROMRP MACRO ((RP)	   (SUB1 RP))))(PUTPROPS \TOUCHPAGE DOPVAL (1 GETBASE.N 0))(PUTPROPS TIMES3 DOPVAL (1 COPY LLSH1 IPLUS2))(* Locked page table)(DECLARE: EVAL@COMPILE [PUTPROPS .LOCKEDVPBASE. MACRO ((VP)	   (\ADDBASE \LOCKEDPAGETABLE (FOLDLO VP BITSPERWORD][PUTPROPS .LOCKEDVPMASK. MACRO ((VP)	   (LLSH 1 (IMOD VP BITSPERWORD])(DECLARE: EVAL@COMPILE (RPAQQ \MAXDIRTYSCANCOUNT 144Q)(RPAQQ \MINVMEMSPAREPAGES 144Q)(RPAQQ \DLBUFFERPAGES 20Q)(CONSTANTS \MAXDIRTYSCANCOUNT \MINVMEMSPAREPAGES \DLBUFFERPAGES))(DECLARE: EVAL@COMPILE (RPAQQ 2MBPAGES 10000Q)(CONSTANTS 2MBPAGES))(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \UPDATECHAINFREQ \REALPAGETABLE \RPTLAST \RPOFFSET \RPTSIZE \LOCKEDPAGETABLE \EMBUFBASE 	    \EMBUFVP \EMBUFRP \PAGEFAULTCOUNTER \LASTDIRTYCNT \LASTDIRTYFOUND \LASTDIRTYSCANPTR 	    \MACHINETYPE \LASTACCESSEDVMEMPAGE \MAXSHORTSEEK \MAXCLEANPROBES \MINSHORTSEEK 	    \DIRTYSEEKMAX \DIRTYPAGECOUNTER \DIRTYPAGEHINT \VMEM.INHIBIT.WRITE \VMEM.PURE.LIMIT 	    \VMEM.FULL.STATE \GUARDVMEMFULL VMEM.COMPRESS.FLG \KBDSTACKBASE \MISCSTACKBASE 	    \DOFAULTINIT \FPTOVP \VMEMACCESSFN \SYSTEMCACHEVARS \LASTVMEMFILEPAGE \EXTENDINGVMEMFILE 	    \MaxScreenPage \NEWVMEMPAGEADDED))(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS \#SWAPBUFFERS \#EMUBUFFERS \#DISKBUFFERS \MAXSWAPBUFFERS \EMUSWAPBUFFERS \EMUBUFFERS 	    \TELERAIDBUFFER \EMUDISKBUFFERS \EMUDISKBUFEND))(DECLARE: EVAL@COMPILE (PUTPROPS RWMufMan DMACRO ((X)	   (* Note that this is the MISC1 opcode with 11Q as the alpha byte.)	   ((OPCODES 170Q 11Q)	    X))))(DECLARE: EVAL@COMPILE (RPAQQ DOLOCKCHECKS T)(CONSTANTS (DOLOCKCHECKS T))))(* * MAKEINIT stuff)(DEFINEQ(ADDPME  [LAMBDA (VP NEWPAGEOK)                                     (* bvm: " 6-Dec-84 14:07")                                                             (* add an entry for VP to the PAGEMAP.							     Called only under MAKEINIT)    (PROG (PX PMP LOCKBASE)          [COND	    ((IEQ (SETQ PMP (\GETBASE \PageMapTBL (fetch (VP PRIMARYKEY) of VP)))		  \EmptyPMTEntry)                            (* empty entries in the PageMapTBL have 177777q as 							     their value)	      (COND		((EVENP NEXTPM WORDSPERPAGE)                 (* must add a new page map page)		  (SETQ PX (\ADDBASE \PAGEMAP NEXTPM))		  (OR NEWPAGEOK (IGREATERP (PAGELOC PX)					   VP)		      (HELP "page map needs new page after page map written out"))		  (\NEWPAGE PX NIL T)))	      (\PUTBASE \PageMapTBL (fetch (VP PRIMARYKEY) of VP)			(SETQ PMP NEXTPM))	      (SETQ NEXTPM (IPLUS NEXTPM \PMblockSize]          (SETQ PX (IPLUS PMP (fetch (VP SECONDARYKEY) of VP)))          (COND	    ((NEQ (\GETBASE \PAGEMAP PX)		  0)	      (HELP "page already in pagemap" VP))	    (T (\PUTBASE \PAGEMAP PX NEXTVMEM)	       [COND		 ((LOCKEDPAGEP VP)                           (* Set lock bit in locked page table)		   (\PUTBASE (SETQ LOCKBASE (.LOCKEDVPBASE. VP))			     0			     (LOGOR (.LOCKEDVPMASK. VP)				    (\GETBASE LOCKBASE 0]	       (SETQ NEXTVMEM (ADD1 NEXTVMEM])(CHECKIFPAGE  [LAMBDA NIL                                                (* mjs "19-Jul-84 13:24")    (CHECKIF Key EQUAL \IFPValidKey "Interface page key"])(DUMPINITPAGES  [LAMBDA (CODEFIRSTPAGE CODENEXTPAGE VERSIONS)              (* bvm: "14-Jan-85 12:51")                                                             (* called only under MAKEINIT)    (ADDPME (PAGELOC \InterfacePage)	    T)                                               (* THE INTERFACE PAGE MUST BE THE FIRST PAGE)    (for I from CODEFIRSTPAGE to (SUB1 CODENEXTPAGE)       do                                                    (* add the pagemap entries for the pages which were 							     written directly to the file)	  (ADDPME I T))    (MAPPAGES 0 (ADD1 \MAXVMPAGE)	      (FUNCTION MAKEROOMFORPME))    (MAPPAGES 0 (ADD1 \MAXVMPAGE)	      (FUNCTION ADDPME))    (PROGN                                                   (* set interface page locations -							     stack pointers already set up IN SETUPSTACK)	   (replace (IFPAGE NxtPMAddr) of \InterfacePage with NEXTPM)	   (replace (IFPAGE NActivePages) of \InterfacePage with (SUB1 NEXTVMEM))	   (replace (IFPAGE NDirtyPages) of \InterfacePage with (SUB1 NEXTVMEM))	   (replace (IFPAGE filePnPMP0) of \InterfacePage with (\GETBASE \PAGEMAP 0))	   (replace (IFPAGE filePnPMT0) of \InterfacePage with (\GETBASE (.PAGEMAPBASE. (PAGELOC											  \PageMapTBL)											)									 0))	   [COND	     (VERSIONS (replace (IFPAGE LVersion) of \InterfacePage with (CAR VERSIONS))		       (replace (IFPAGE MinBVersion) of \InterfacePage with (CADDR VERSIONS))		       (replace (IFPAGE MinRVersion) of \InterfacePage with (CADR VERSIONS]	   (replace (IFPAGE Key) of \InterfacePage with \IFPValidKey))    (MAPPAGES 0 (ADD1 \MAXVMPAGE)	      (FUNCTION DUMPVP))    (ALLOCAL (PROG ((FILE (OUTPUT)))	           [COND		     ((NOT (RANDACCESSP FILE))               (* SYSOUT file is sequential;							     have to get it random access for this)		       (OUTPUT (SETQ FILE (OPENFILE (CLOSEF FILE)						    (QUOTE BOTH]	           (SETFILEPTR FILE MKI.Page0Byte)))    (DUMPVP (PAGELOC \InterfacePage])(MAKEROOMFORPME  [LAMBDA (VP)                                               (* bvm: "29-MAR-83 17:11")                                                             (* make sure that the pagemap-page for page VP exists;							     we later will want to add it to the pagemap)    (COND      ((IEQ (\GETBASE \PageMapTBL (fetch (VP PRIMARYKEY) of VP))	    \EmptyPMTEntry)                                  (* empty entries in the PageMapTBL have 177777q as 							     their value)	(COND	  ((EVENP NEXTPM WORDSPERPAGE)                       (* must add a new page map page)	    (\NEWPAGE (\ADDBASE \PAGEMAP NEXTPM)		      NIL T)))	(\PUTBASE \PageMapTBL (fetch (VP PRIMARYKEY) of VP)		  NEXTPM)	(SETQ NEXTPM (IPLUS NEXTPM \PMblockSize])(MAPPAGES  [LAMBDA (BOT TOP FN)                                       (* lmm "26-MAR-81 12:23")    (PROG ((VP BOT)	   (IVP (PAGELOC \InterfacePage)))      LP  (COND	    ((AND (SETQ VP (MKI.NEXTPAGE VP))		  (IGREATERP TOP VP))	      (COND		((NOT (IEQ VP IVP))		  (APPLY* FN VP)))	      (SETQ VP (ADD1 VP))	      (GO LP])(READPAGEMAP  [LAMBDA NIL                                                (* bvm: "10-Dec-84 21:54")                                                             (* called only under READSYS -- reads in pagemap so 							     that SETVMPTR can work)    (PROG (D)          (LOCAL (MAPVMPAGE (fetch (POINTER PAGE#) of \InterfacePage)			    1))                              (* Install interface page by magic)          (* PROGN (SETQ FPSTART (fetch (IFPAGE LastDominoFilePage) of \InterfacePage)) (SETQ NPAGES (fetch 	  (IFPAGE NActivePages) of \InterfacePage)) (* Note: have to do these fetches before the SETFILEPTR since they 	  indirectly do SETFILEPTR themselves) (SETFILEPTR VMEMFILE (IPLUS (UNFOLD (SUB1 (fetch (IFPAGE FPTOVPStart) of 	  \InterfacePage)) BYTESPERPAGE) (UNFOLD FPSTART BYTESPERWORD))) (for I from FPSTART to NPAGES bind VP when 	  (NEQ (SETQ VP (VBIN2)) \NO.VMEM.PAGE) do (* Read in all of FPTOVP) (MAPVMPAGE VP (SUB1 I))))          [LOCAL (MAPVMPAGE (PAGELOC \PAGEMAP)			    (SUB1 (fetch (IFPAGE filePnPMP0) of \InterfacePage]                                                             (* map in first page of secondary page map, which is 							     where all the secondary map pages themselves live)          (LOCAL (SETVMPTR \PAGEMAP))          (for I from 0 to (SUB1 (FOLDHI PAGESPERSEGMENT \PMblockSize)) as VP from (PAGELOC \PAGEMAP)	     by \PMblockSize	     do                                              (* Have to read all the addresses of secondary map 							     pages themselves before we can read their contents)		(READPAGEMAPBLOCK VP))          (for J from 0 to (SUB1 \NumPMTpages) as FP from (SUB1 (fetch (IFPAGE filePnPMT0)								   of \InterfacePage))	     do                                              (* read in all the primary map table pages)		(LOCAL (MAPVMPAGE (IPLUS (PAGELOC \PageMapTBL)					 J)				  FP)))          (for I from 0 to (SUB1 (UNFOLD \NumPMTpages WORDSPERPAGE))	     do (COND		  ((IEQ (SETQ D (GETBASE \PageMapTBL I))			\EmptyPMTEntry))		  (T (LOCAL (SETVMPTR (ADDBASE \PAGEMAP D)))		     (READPAGEMAPBLOCK (UNFOLD I \PMblockSize])(READPAGEMAPBLOCK  [LAMBDA (VP)                                               (* lmm " 4-MAY-82 21:12")    (PROG ((B VP)	   P)          (FRPTQ \PMblockSize [COND		   ((NEQ (SETQ P (VBIN2))			 0)		     (LOCAL (MAPVMPAGE B (SUB1 P]		 (SETQ B (ADD1 B])(SETUPPAGEMAP  [LAMBDA NIL                                                (* bvm: " 8-Dec-84 14:52")                                                             (* called only from MAKEINIT to initialize the page 							     map)    (PROG NIL                                                (* set up page map)          (\NEWPAGE \PAGEMAP NIL T)          (CREATEPAGES \PageMapTBL \NumPMTpages NIL T)       (* init PageMapTBL pages to 177777q)          (for I from 0 to (SUB1 (UNFOLD \NumPMTpages WORDSPERPAGE)) do (\PUTBASE \PageMapTBL I 										  \EmptyPMTEntry))          (SETQ NEXTPM 0)          (for I from 0 to (SUB1 (fetch (VP PRIMARYKEY) of \NumPageMapPages))	     bind (PAGEMAPKEY &larr;(fetch (VP PRIMARYKEY) of (PAGELOC \PAGEMAP)))	     do           (* Assign pagemap pages to cover all pagemap pages, so that \DONEWPAGE can guarantee that when it needs to allocate 	  a new pagemap page, that the pagemap page for the new page already exists)		(\PUTBASE \PageMapTBL (IPLUS PAGEMAPKEY I)			  NEXTPM)		(SETQ NEXTPM (IPLUS NEXTPM \PMblockSize)))          (SETQ NEXTVMEM \FirstVmemBlock)                    (* add entry for InterfacePage which must be on 							     FirstVMemBlock)          (CREATEPAGES \LOCKEDPAGETABLE \NumLPTPages NIL T]))(DECLARE: DONTCOPY (DECLARE: EVAL@COMPILE [PUTPROPS CHECKIF MACRO ((FLD COMPARISON VALUE STR)	   (COND ((NOT (COMPARISON VALUE (fetch (IFPAGE FLD)						of \InterfacePage)))		  (printout T "Warning: " STR "= " (PROGN VALUE)			    ", but \InterfacePage says "			    (fetch (IFPAGE FLD)				   of \InterfacePage)			    T])(ADDTOVAR INEWCOMS (FNS DUMPINITPAGES)		   (VARS INITCONSTANTS)		   (FNS SETUPPAGEMAP ADDPME MAKEROOMFORPME MAPPAGES))(ADDTOVAR RDCOMS (FNS READPAGEMAP READPAGEMAPBLOCK CHECKIFPAGE \LOCKEDPAGEP \LOOKUPPAGEMAP 		      CHECKPAGEMAP CHECKFPTOVP CHECKFPTOVP1 \SHOWPAGETABLE \PRINTFPTOVP))(ADDTOVAR EXPANDMACROFNS CHECKIF .LOCKEDVPBASE. .LOCKEDVPMASK. .PAGEMAPBASE.)(ADDTOVAR MKI.SUBFNS (\NEWPAGE . MKI.NEWPAGE)		     (\LOCKPAGES . MKI.LOCKPAGES))(ADDTOVAR RD.SUBFNS (\NEWPAGE . VNEWPAGE)		    (\LOCKPAGES . VLOCKPAGES))(ADDTOVAR RDPTRS (\REALPAGETABLE))(ADDTOVAR RDVALS (\RPTSIZE))EVAL@COMPILE (ADDTOVAR DONTCOMPILEFNS DUMPINITPAGES SETUPPAGEMAP ADDPME MAKEROOMFORPME MAPPAGES READPAGEMAP 				       READPAGEMAPBLOCK CHECKIFPAGE))(DEFINEQ(\LOCKFN  [LAMBDA (FN)                                               (* bvm: "22-NOV-82 17:39")    [\LOCKCELL (SETQ FN (fetch (LITATOM DEFINITIONCELL) of (EVQ FN]    (COND      ((fetch (DEFINITIONCELL CCODEP) of FN)	(\LOCKCODE (fetch (DEFINITIONCELL DEFPOINTER) of FN])(\LOCKCODE  [LAMBDA (CODEBLOCK)                                        (* rmk: "15-Aug-84 13:35")    (\LOCKWORDS CODEBLOCK (UNFOLD (\#BLOCKDATACELLS CODEBLOCK)				  WORDSPERCELL])(\LOCKVAR  [LAMBDA (VAR)                                              (* lmm " 5-APR-82 00:43")    (\LOCKCELL (fetch (LITATOM VCELL) of (EVQ VAR])(\LOCKCELL  [LAMBDA (X NPGS)                                           (* bvm: "22-NOV-82 17:54")    (\LOCKPAGES (PAGEBASE X)		(OR NPGS 1])(\LOCKWORDS  [LAMBDA (BASE NWORDS)                                      (* bvm: "22-NOV-82 17:35")    (\LOCKPAGES (PAGEBASE BASE)		(COND		  (NWORDS (FOLDHI (IPLUS (fetch (POINTER WORDINPAGE) of BASE)					 NWORDS)				  WORDSPERPAGE))		  (T 1]))(DECLARE: DONTCOPY (ADDTOVAR INEWCOMS (FNS \LOCKFN \LOCKVAR \LOCKCELL \LOCKWORDS \LOCKCODE)	  (ALLOCAL (ADDVARS (LOCKEDFNS \FAULTHANDLER \FAULTINIT \DOVE.FAULTINIT \D01.FAULTINIT 				       \DL.FAULTINIT \CHAIN.UP.RPT \MAKESPACEFORLOCKEDPAGE \PAGEFAULT 				       \WRITEMAP \LOOKUPPAGEMAP \LOCKEDPAGEP \LOADVMEMPAGE 				       \MOVEREALPAGE \INVALIDADDR \INVALIDVP \SELECTREALPAGE 				       \TRANSFERPAGE \SPECIALRP \UPDATECHAIN \MARKPAGEVACANT 				       \FLUSHPAGE \CLEARWORDS \FLUSHVM \DONEWPAGE \ASSURE.FPTOVP.PAGE 				       \DONEWEPHEMERALPAGE \WRITEDIRTYPAGE1 \COPYSYS0 \COPYSYS0SUBR 				       \RELEASEWORKINGSET \DOFLUSHVM \DOLOCKPAGES \DOTEMPLOCKPAGES 				       \TEMPUNLOCKPAGES \MP.ERROR RAID \DL.NEWFAULTINIT 				       \DL.MARK.PAGES.UNAVAILABLE \DL.UNMAPPAGES \DL.ASSIGNBUFFERS 				       \D01.ASSIGNBUFFERS \DOCOMPRESSVMEM \MOVEVMEMFILEPAGE 				       \SET.VMEM.FULL.STATE \HINUM \LONUM)			    (LOCKEDVARS \REALPAGETABLE \RPTLAST \PAGEFAULTCOUNTER \UPDATECHAINFREQ 					\RPOFFSET \RPTSIZE \LOCKEDPAGETABLE \EMBUFBASE \EMBUFVP 					\EMBUFRP \LASTACCESSEDVMEMPAGE \MAXSHORTSEEK \MAXCLEANPROBES 					\MINSHORTSEEK \DIRTYPAGECOUNTER \DIRTYPAGEHINT 					\VMEM.INHIBIT.WRITE \VMEM.PURE.LIMIT \VMEM.FULL.STATE 					\GUARDVMEMFULL VMEM.COMPRESS.FLG \KBDSTACKBASE \MISCSTACKBASE 					\DOFAULTINIT \FPTOVP \MACHINETYPE \VMEMACCESSFN 					\TELERAIDBUFFER \EMUDISKBUFFERS \EMUDISKBUFEND 					\MAXSWAPBUFFERS \EMUBUFFERS \#EMUBUFFERS \#SWAPBUFFERS 					\#DISKBUFFERS \RCLKSECOND \RCLKMILLISECOND \VALSPACE 					\EMUSWAPBUFFERS \EM.CURSORBITMAP \PAGEMAP \PageMapTBL 					\IOCBPAGE \IOPAGE \MISCSTATS \DEFSPACE \InterfacePage 					\LASTVMEMFILEPAGE \DoveIORegion \MaxScreenPage 					\NEWVMEMPAGEADDED)))))(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA VMEM.PURE.STATE))(PUTPROPS LLFAULT COPYRIGHT ("Xerox Corporation" 3676Q 3677Q 3700Q 3701Q))(DECLARE: DONTCOPY  (FILEMAP (NIL (15540Q 16363Q (\FAULTHANDLER 15552Q . 16361Q)) (16415Q 33316Q (\FAULTINIT 16427Q . 22646Q) (\D01.FAULTINIT 22650Q . 27637Q) (\D01.ASSIGNBUFFERS 27641Q . 33314Q)) (33317Q 103245Q (\DOVE.FAULTINIT 33331Q . 36177Q) (\DL.FAULTINIT 36201Q . 42544Q) (\DL.NEWFAULTINIT 42546Q . 72413Q) (\DL.UNMAPPAGES 72415Q . 73400Q) (\DL.MARK.PAGES.UNAVAILABLE 73402Q . 74150Q) (\DL.ASSIGNBUFFERS 74152Q . 77274Q) (\CHAIN.UP.RPT 77276Q . 103243Q)) (103246Q 153671Q (\PAGEFAULT 103260Q . 106335Q) (\INVALIDADDR 106337Q . 106612Q) (\INVALIDVP 106614Q . 107052Q) (\FLUSHPAGE 107054Q . 113101Q) (\LOADVMEMPAGE 113103Q . 116773Q) (\MOVEREALPAGE 116775Q . 121567Q) (\LOOKUPPAGEMAP 121571Q . 122616Q) (\LOCKEDPAGEP 122620Q . 123666Q) (\SELECTREALPAGE 123670Q . 137715Q) (\SPECIALRP 137717Q . 141060Q) (\TRANSFERPAGE 141062Q . 146104Q) (\UPDATECHAIN 146106Q . 153667Q)) (153736Q 154427Q (\ZEROPAGE 153750Q . 154425Q)) (154430Q 246451Q (\NEWPAGE 154442Q . 156070Q) (\DONEWPAGE 156072Q . 163512Q) (\ASSURE.FPTOVP.PAGE 163514Q . 166507Q) (\MAKESPACEFORLOCKEDPAGE 166511Q . 172543Q) (\MOVEVMEMFILEPAGE 172545Q . 174636Q) (\NEWEPHEMERALPAGE 174640Q . 175403Q) (\DONEWEPHEMERALPAGE 175405Q . 202122Q) (\LOCKPAGES 202124Q . 202645Q) (\DOLOCKPAGES 202647Q . 210402Q) (\TEMPLOCKPAGES 210404Q . 211123Q) (\DOTEMPLOCKPAGES 211125Q . 213625Q) (\TEMPUNLOCKPAGES 213627Q . 216155Q) (\UNLOCKPAGES 216157Q . 220324Q) (\FLUSHVM 220326Q . 222360Q) (\LOGOUT0 222362Q . 224175Q) (\DOFLUSHVM 224177Q . 232051Q) (\RELEASEWORKINGSET 232053Q . 233423Q) (\WRITEDIRTYPAGE 233425Q . 244161Q) (\WRITEDIRTYPAGE1 244163Q . 245444Q) (\COUNTREALPAGES 245446Q . 246447Q)) (246452Q 252020Q (\DOCOMPRESSVMEM 246464Q . 251030Q) (VMEM.PURE.STATE 251032Q . 252016Q)) (252021Q 261501Q (32MBADDRESSABLE 252033Q . 252463Q) (\SET.VMEM.FULL.STATE 252465Q . 254065Q) (\DOVMEMFULLINTERRUPT 254067Q . 257766Q) (\FLUSHVMOK? 257770Q . 261477Q)) (263115Q 263545Q (\MP.ERROR 263127Q . 263543Q)) (263574Q 302315Q (\ACTONVMEMFILE 263606Q . 264414Q) (\SHOWPAGETABLE 264416Q . 270227Q) (CHECKPAGEMAP 270231Q . 274652Q) (CHECKFPTOVP 274654Q . 275505Q) (CHECKFPTOVP1 275507Q . 276473Q) (\PRINTFPTOVP 276475Q . 302004Q) (\PRINTVP 302006Q . 302313Q)) (316376Q 340465Q (ADDPME 316410Q . 321410Q) (CHECKIFPAGE 321412Q . 321664Q) (DUMPINITPAGES 321666Q . 326235Q) (MAKEROOMFORPME 326237Q . 327726Q) (MAPPAGES 327730Q . 330526Q) (READPAGEMAP 330530Q . 335202Q) (READPAGEMAPBLOCK 335204Q . 335665Q) (SETUPPAGEMAP 335667Q . 340463Q)) (342616Q 345025Q (\LOCKFN 342630Q . 343342Q) (\LOCKCODE 343344Q . 343652Q) (\LOCKVAR 343654Q . 344134Q) (\LOCKCELL 344136Q . 344374Q) (\LOCKWORDS 344376Q . 345023Q)))))STOP</pre>
  </body>
</html>
