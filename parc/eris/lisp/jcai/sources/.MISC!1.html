<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>JCAI>sources>MISC!1</title>
  </head>
  <body>
    <pre>
(FILECREATED " 2-Jul-85 17:53:23" {ERIS}&lt;LISPCORE&gt;SOURCES&gt;MISC.;9 37385        changes to:  (FNS CONSTANTEXPRESSIONP)      previous date: "14-Apr-85 20:45:43" {ERIS}&lt;LISPCORE&gt;SOURCES&gt;MISC.;8)(* Copyright (c) 1982, 1983, 1984, 1985 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT MISCCOMS)(RPAQQ MISCCOMS [(FNS ADD1VAR ADDTOVAR APPENDTOVAR APPEND \APPEND2 ASSOC ATTACH CHANGEPROP CONCATLIST 		      CONSTANTS CONSTANTEXPRESSIONP COPY DEFINEQ DEFLIST DREMOVE DREVERSE DSUBST 		      EQLENGTH ERSETQ EVERY GENSYM GENSYM? \GS.INITBUF GETLIS INTERSECTION KWOTE LAST 		      LASTN LCONC LDIFF LDIFFERENCE LENGTH LISTGET LISTGET1 LISTPUT LISTPUT1 LSUBST 		      MAP MAP2C MAP2CAR MAPC MAPCAR MAPCON MAPCONC MAPLIST MEMBER NLEFT NLSETQ NOTANY 		      NOTEVERY NTH PUTASSOC RATOMS REMOVE REVERSE RPT RPTQ FRPTQ SASSOC SAVEDEF 		      SAVEDEF1 SELECT SELECT1 SELECTC SETQQ SOME STRMEMB SUB1VAR SUBSET SUBST TAILP 		      TCONC TIME UNION)	(INITVARS (COMPVARMACROHASH NIL))	(ADDVARS (CONSTANTFOLDFNS PLUS IPLUS TIMES ITIMES DIFFERENCE IDIFFERENCE QUOTIENT IQUOTIENT 				  IMIN IMAX IABS LLSH LRSH LOGOR LOGXOR LOGAND OR AND))	(GLOBALVARS COMPVARMACROHASH CONSTANTFOLDFNS)	(DECLARE: EVAL@COMPILE DONTCOPY (CONSTANTS (\GS.BUFSIZE 100)))	(INITVARS (GENNUM 0)		  (\GS.OGENNUM -1)		  (\GS.NUMLEN 0)		  (\GS.BUF NIL)		  (\GS.STR (ALLOCSTRING 0)))	(ALISTS (PRETTYEQUIVLST SELECTC)		(DWIMEQUIVLST SELECTC))	(GLOBALVARS GENNUM \GS.OGENNUM \GS.NUMLEN \GS.BUF \GS.STR)	(LOCALVARS . T)	(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS		  (ADDVARS (NLAMA SELECTC SELECT FRPTQ RPTQ DEFINEQ CONSTANTS APPENDTOVAR ADDTOVAR)			   (NLAML TIME SUB1VAR SETQQ NLSETQ ERSETQ ADD1VAR)			   (LAMA APPEND])(DEFINEQ(ADD1VAR  (NLAMBDA (ADD1X)    (SET ADD1X (ADD1 (EVAL ADD1X))))))(DEFINEQ(ADDTOVAR  (NLAMBDA X                                                 (* rmk: " 4-JAN-82 15:45")    (RESETVARS ((DFNFLG DFNFLG))	       (COND		 ((EQ DFNFLG (QUOTE ALLPROP))		   (SETQQ DFNFLG PROP)))	       (RETURN (PROG (VAR TEM)			     (SAVESET (SETQ VAR (CAR X))				      (COND					((OR (LISTP (SETQ TEM (GETTOPVAL VAR)))					     (CDR X))					  (UNION (CDR X)						 (LISTP TEM)))					((NEQ TEM (QUOTE NOBIND))					  TEM))				      T)			     (RETURN VAR)))))))(DEFINEQ(APPENDTOVAR  (NLAMBDA X                                                 (* rmk: " 4-JAN-82 15:46")    (RESETVARS ((DFNFLG DFNFLG))	       (COND		 ((EQ DFNFLG (QUOTE ALLPROP))		   (SETQQ DFNFLG PROP)))	       (RETURN (PROG (VAR TEM)			     (SAVESET (SETQ VAR (CAR X))				      (COND					((OR (LISTP (SETQ TEM (GETTOPVAL VAR)))					     (CDR X))					  (UNION (LISTP TEM)						 (CDR X)))					((NEQ TEM (QUOTE NOBIND))					  TEM))				      T)			     (RETURN VAR)))))))(DEFINEQ(APPEND  [LAMBDA L                                                  (* lmm "30-Jun-84 00:37")                                                             (* fixed bug so that (APPEND 							     (QUOTE (A B . C))) was (QUOTE 							     (A B . C)))    (COND      ((EQ L 0)	NIL)      ((EQ L 1)	(\APPEND2 (ARG L 1)		  NIL))      (T (bind (VAL &larr;(ARG L L))	       (N &larr; L) while (IGREATERP (add N -1)					0)	    do (SETQ VAL (\APPEND2 (ARG L N)				   VAL))	    finally (RETURN VAL]))(DEFINEQ(\APPEND2  [LAMBDA (L1 L2)                                            (* lmm "30-Jun-84 00:30")    (COND      ((LISTP L1)	(PROG ((VAL (CONS (CAR L1)			  L2))	       TAIL)	      (SETQ TAIL VAL)	  LP  [FRPLACD TAIL (SETQ TAIL (LIST (CAR (OR (LISTP (SETQ L1 (CDR L1)))						      (PROGN (FRPLACD TAIL (OR L2 L1))							     (RETURN VAL]	      (GO LP)))      ((NLISTP L2)	L1)      (T L2]))(DEFINEQ(ASSOC  (LAMBDA (KEY ALST)                                         (* bvm: "20-FEB-81 14:58")    (PROG NIL      LP  (COND	    ((NLISTP ALST)	      (RETURN))	    ((AND (LISTP (CAR ALST))		  (EQ (CAAR ALST)		      KEY))	      (RETURN (CAR ALST))))          (SETQ ALST (CDR ALST))          (GO LP)))))(DEFINEQ(ATTACH  (LAMBDA (X L)    (COND      ((LISTP L)	(FRPLACA (FRPLACD L (CONS (CAR L)				  (CDR L)))		 X))      ((NULL L)	(CONS X))      (T (ERRORX (LIST 4 L)))))))(DEFINEQ(CHANGEPROP  (LAMBDA (X PROP1 PROP2)                                    (* wt: "31-MAY-79 22:28")    (PROG ((Z (COND		((LITATOM X)		  (GETPROPLIST X))		(T (ERRORX (LIST 14 X))))))      LP  (RETURN (COND		    ((NLISTP Z)		      NIL)		    ((EQ (CAR Z)			 PROP1)		      (FRPLACA Z PROP2)		      X)		    (T (SETQ Z (CDR (LISTP (CDR Z))))		       (GO LP))))))))(DEFINEQ(CONCATLIST  [LAMBDA (L)                                                (* rmk: "27-Mar-85 17:23")    (PROG (STR FATP)                                         (* Try to pre-determine FATP, at least for strings and 							     litatoms, where it is easy to tell.)          (SETQ STR (ALLOCSTRING (for X in L				    sum (AND (EQ (SYSTEMTYPE)						 (QUOTE D))					     (OR FATP (SELECTC (NTYPX X)							       (\STRINGP (SETQ FATP									   (ffetch (STRINGP 										       FATSTRINGP)									      of X)))							       (\LITATOM (SETQ FATP									   (ffetch (LITATOM FATPNAMEP)									      of X)))							       NIL)))					(NCHARS X))				 NIL NIL FATP))          (for X in L as I from 1 by (NCHARS X) do (RPLSTRING STR I X))          (RETURN STR]))(DEFINEQ(CONSTANTS  [NLAMBDA VARS                                              (* rmk: " 3-Jan-84 13:20")    (OR COMPVARMACROHASH (SETQ COMPVARMACROHASH (HASHARRAY 100)))    [for X in VARS do (COND			((LISTP X)			  (PUTHASH (CAR X)				   (LIST (QUOTE CONSTANT)					 (CADR X))				   COMPVARMACROHASH))			(T (PUTHASH X (LIST (QUOTE CONSTANT)					    X)				    COMPVARMACROHASH]    VARS]))(DEFINEQ(CONSTANTEXPRESSIONP  [LAMBDA (FORM)                                             (* lmm " 2-Jul-85 17:52")    (COND      [(LITATOM FORM)	(COND	  ((OR (NULL FORM)	       (EQ FORM T))	    (LIST FORM))	  ((AND COMPVARMACROHASH (SETQ FORM (GETHASH FORM COMPVARMACROHASH)))	    (CONSTANTEXPRESSIONP FORM]      [(LISTP FORM)	(SELECTQ (CAR FORM)		 (QUOTE (CDR FORM))		 (FUNCTION (AND (LITATOM (CADR FORM))				(CDR FORM)))		 (COND		   [(FMEMB (CAR FORM)			   CONSTANTFOLDFNS)		     (for X in (CDR FORM) collect (CAR (OR (CONSTANTEXPRESSIONP X)							   (RETURN)))			finally (RETURN (LIST (APPLY (CAR FORM)						     $$VAL]		   (T (PROG ((MAC (GETMACROPROP (CAR FORM)						COMPILERMACROPROPS)))			    (RETURN (AND MAC [NOT (EQUAL FORM (SETQ FORM (MACROEXPANSION FORM MAC]					 (CONSTANTEXPRESSIONP FORM]      ((NUMBERP FORM)	(LIST FORM]))(DEFINEQ(COPY  (LAMBDA (X)                                                (* lmm "16-FEB-82 22:07")    (COND      ((NLISTP X)	X)      (T (PROG (TAIL (VAL (LIST (COPY (CAR X)))))	       (SETQ TAIL VAL)	   LP  (COND		 ((NLISTP (SETQ X (CDR X)))		   (AND X (FRPLACD TAIL X))		   (RETURN VAL)))	       (FRPLACD TAIL (SETQ TAIL (CONS (COPY (CAR X)))))	       (GO LP)))))))(DEFINEQ(DEFINEQ  (NLAMBDA X    (DEFINE X))))(DEFINEQ(DEFLIST  (LAMBDA (L PROP)    (PROG NIL      LOOP(COND	    ((NLISTP L)	      (RETURN)))          (PUTPROP (CAAR L)		   PROP		   (CADAR L))                                (* NOTE: this call to PUTPROP is changed to /PUTPROP 							     later in the loadup.)          (SETQ L (CDR L))          (GO LOOP)))))(DEFINEQ(DREMOVE  (LAMBDA (X L)    (COND      ((NLISTP L)	NIL)      ((EQ X (CAR L))	(COND	  ((CDR L)	    (FRPLACA L (CADR L))	    (FRPLACD L (CDDR L))	    (DREMOVE X L))))      (T (PROG (Z)	       (DECLARE (LOCALVARS Z))	       (SETQ Z L)	   LP  (COND		 ((NLISTP (CDR L))		   (RETURN Z))		 ((EQ X (CADR L))		   (FRPLACD L (CDDR L)))		 (T (SETQ L (CDR L))))	       (GO LP)))))))(DEFINEQ(DREVERSE  (LAMBDA (L)    (PROG (Y Z)          (DECLARE (LOCALVARS Y Z))      R1  (COND	    ((NLISTP (SETQ Y L))	      (RETURN Z)))          (SETQ L (CDR L))          (SETQ Z (FRPLACD Y Z))          (GO R1)))))(DEFINEQ(DSUBST  (LAMBDA (NEW OLD EXPR)                                     (* lmm "16-FEB-82 22:10")    (PROG (B)          (COND	    ((EQ OLD (SETQ B EXPR))	      (RETURN (COPY NEW))))      LP  (COND	    ((NLISTP EXPR)	      (RETURN B))	    ((EQUAL OLD (CAR EXPR))	      (FRPLACA EXPR (COPY NEW)))	    (T (DSUBST NEW OLD (CAR EXPR))))          (COND	    ((AND OLD (EQ OLD (CDR EXPR)))	      (FRPLACD EXPR (COPY NEW))	      (RETURN B)))          (SETQ EXPR (CDR EXPR))          (GO LP)))))(DEFINEQ(EQLENGTH  [LAMBDA (X N)                                              (* bvm: "14-Feb-85 00:34")          (* Generated by paatern match. INcluded so user can load code that has been dwimified and or compiled into a 	  nonclisp system and run it.)    (COND      ((ILESSP N 0)	NIL)      ((EQ N 0)	(NLISTP X))      (T (AND (LISTP (SETQ X (NTH X N)))	      (NLISTP (CDR X]))(DEFINEQ(ERSETQ  (NLAMBDA (ERSETX)    (ERRORSET ERSETX T))))(DEFINEQ(EVERY  (LAMBDA (EVERYX EVERYFN1 EVERYFN2)                         (* Note that EVERY does not compile open, although SOME 							     does.)    (PROG NIL      LOOP(COND	    ((NLISTP EVERYX)	      (RETURN T))	    ((NULL (APPLY* EVERYFN1 (CAR EVERYX)			   EVERYX))	      (RETURN NIL)))          (SETQ EVERYX (COND	      (EVERYFN2 (APPLY* EVERYFN2 EVERYX))	      (T (CDR EVERYX))))          (GO LOOP)))))(DEFINEQ(GENSYM  [LAMBDA (PREFIX NUMSUFFIX OSTRBUFFER NEW? CHARCODE)        (* lmm "14-Apr-85 20:39")    (OR (NULL PREFIX)	(STRINGP PREFIX)	(LITATOM PREFIX)	(ERRORX (LIST 27 PREFIX)))    (OR (NULL NUMSUFFIX)	(FIXP NUMSUFFIX)	(ERRORX (LIST 27 NUMSUFFIX)))    (OR (NULL OSTRBUFFER)	(STRINGP OSTRBUFFER)	(ERRORX (LIST 27 OSTRBUFFER)))    (OR (NULL CHARCODE)	(CHARCODEP CHARCODE)	(ERRORX (LIST 27 CHARCODE)))    (PROG ((BUFSIZE \GS.BUFSIZE)	   (NUMLEN \GS.NUMLEN)	   [BUF (OR (STRINGP \GS.BUF)		    (SETQ \GS.BUF (ALLOCSTRING \GS.BUFSIZE]	   (PREFIXLEN 0)	   BEG.I ATOM)          (if (OR (NULL PREFIX)		  (EQ (SETQ PREFIXLEN (NCHARS PREFIX))		      0))	      then (SETQ PREFIX)		   (if (NULL CHARCODE)		       then                                  (* Here's the default case)			    (SETQ CHARCODE (CHARCODE A)))	    elseif (IGREATERP PREFIXLEN (IDIFFERENCE BUFSIZE 10))	      then (ERROR PREFIX "Too long"))          (if (if OSTRBUFFER		  then (if (NULL NUMSUFFIX)			   then (HELP "OSTRBUFFER supplied without NUMSUFFIX")			 elseif (ILESSP (SETQ BUFSIZE (NCHARS OSTRBUFFER))					(IPLUS 12 PREFIXLEN))			   then (ERROR OSTRBUFFER "Too short"))		       T		elseif NUMSUFFIX		  then                                       (* Insulate the normal \GS.BUF from random intrustions)		       [SETQ OSTRBUFFER (ALLOCSTRING (SETQ BUFSIZE (IPLUS PREFIXLEN 12]		       T)	      then (SETQ BUF OSTRBUFFER))      A   (UNINTERRUPTABLY              (if (if OSTRBUFFER		      then                                   (* Use the user-supplied buffer, or a freshly cons'd 							     one if he supplied NUMSUFFIX without OSTRBUFFER)			   T		    elseif (NOT (FIXP GENNUM))		      then                                   (* Disaster recovery)			   (SETQ GENNUM 0)			   T)		  then (SETQ NUMLEN (\GS.INITBUF BUF BUFSIZE (OR NUMSUFFIX GENNUM)))		else           (* In this case, we have kept account of the contents of \GS.BUF so we don't have to call \GS.INITBUF afresh, but 	  rather merely "patch up" the effect of adding 1 to GENNUM)		     (if (if (NOT (IEQP GENNUM \GS.OGENNUM))			     then                            (* User perhaps has reset GENNUM)				  (if (ILESSP GENNUM 0)				      then (SETQ GENNUM 0))				  T			   elseif (IGEQ GENNUM MAX.FIXP)			     then                            (* Sigh, two's complement wrap-around)				  (SETQ GENNUM 0)				  T)			 then (SETQ NUMLEN (\GS.INITBUF BUF BUFSIZE GENNUM)))                                                             (* Increment the GENNUM counter and the string buffer 							     buffer.)		     (if (for CNT C to NUMLEN as I from BUFSIZE by -1			    do                               (* Simulates a BCD type add in the gensym string)			       (SETQ C (NTHCHARCODE \GS.BUF I))			       (if (ILEQ (add C 1)					 (CHARCODE 9))				   then                      (* ha, carry stops here)					(RPLCHARCODE BUF I C)					(RETURN)				 else (RPLCHARCODE BUF I (CHARCODE 0)))			    finally (RETURN T))			 then                                (* Sigh, we have to extend the numerical part)			      (RPLCHARCODE BUF (IDIFFERENCE BUFSIZE NUMLEN)					   (CHARCODE 1))			      (SETQ NUMLEN (add \GS.NUMLEN 1)))		     (SETQ \GS.OGENNUM (add GENNUM 1)))      (* BEG.I will be the beginning index, in the buffer, 							     for the atom)	      (SETQ BEG.I (ADD1 (IDIFFERENCE BUFSIZE NUMLEN)))	      (if CHARCODE		  then (RPLCHARCODE BUF (add BEG.I -1)				    CHARCODE))	      (if PREFIX		  then (RPLSTRING BUF (SETQ BEG.I (IDIFFERENCE BEG.I PREFIXLEN))				  PREFIX))	      (SETQ \GS.STR (SUBSTRING BUF BEG.I BUFSIZE \GS.STR))	      (SETQ ATOM (MKATOM \GS.STR)))          (if (NUMBERP ATOM)	      then (ERRORX (LIST 27 PREFIX)))          (RETURN ATOM]))(DEFINEQ(GENSYM?  (LAMBDA (X)                                                (* lmm " 1-JUN-81 08:30")    (AND (LITATOM X)	 (EQ (NTHCHARCODE X -5)	     (CHARCODE A))	 (FIXP (NTHCHAR X -4))	 (FIXP (NTHCHAR X -3))	 (FIXP (NTHCHAR X -2))	 (FIXP (NTHCHAR X -1))	 T))))(DEFINEQ(\GS.INITBUF  [LAMBDA (BUF BUFSIZE N)                                    (* lmm "14-Apr-85 20:36")          (* Initializes BUF (which must be a stringp of length BUFSIZE) with the digits of N right-justified and left-0 	  padded up to a minimum of 4 digits. Returns the decimal length of N)    (PROG (NUMLEN)          (RPLSTRING BUF [IDIFFERENCE BUFSIZE (if (ILESSP N 10000)						  then       (* Trick to get leading zeros)						       (SETQ N (IPLUS N 10000))						       (SETQ NUMLEN 4)						else (SUB1 (SETQ NUMLEN (NCHARS N]		     N)          (AND (EQ BUF \GS.BUF)	       (SETQ \GS.NUMLEN NUMLEN))          (RETURN NUMLEN]))(DEFINEQ(GETLIS  (LAMBDA (X PROPS)                                          (* wt: "31-MAY-79 22:25")    (PROG ((Z (COND		((LITATOM X)		  (GETPROPLIST X))		(T X))))      LP  (RETURN (COND		    ((NLISTP Z)		      NIL)		    ((FMEMB (CAR Z)			    PROPS)		      Z)		    (T (SETQ Z (CDR (LISTP (CDR Z))))		       (GO LP))))))))(DEFINEQ(INTERSECTION  (LAMBDA (X Y)    (PROG ((R (CONS))	   S)          (DECLARE (LOCALVARS R S))      LP  (COND	    ((NLISTP X)	      (RETURN (CAR R)))	    ((COND		((LITATOM (SETQ S (CAR X)))		  (AND (FMEMB S Y)		       (NULL (FMEMB S (CAR R)))))		(T (AND (MEMBER S Y)			(NULL (MEMBER S (CAR R))))))	      (TCONC R S)))          (SETQ X (CDR X))          (GO LP)))))(DEFINEQ(KWOTE  (LAMBDA (X)                                                (* dcl: 15 SEP 75 15:25)    (COND      ((OR (NULL X)	   (EQ X T)	   (NUMBERP X))	X)      (T (LIST (QUOTE QUOTE)	       X))))))(DEFINEQ(LAST  (LAMBDA (X)    (PROG (XX)          (DECLARE (LOCALVARS XX))      L   (COND	    ((NLISTP X)	      (RETURN XX)))          (SETQ XX X)          (SETQ X (CDR X))          (GO L)))))(DEFINEQ(LASTN  (LAMBDA (L N)    (PROG (X Y)          (DECLARE (LOCALVARS X Y))          (COND	    ((NLISTP L)	      (RETURN NIL))	    ((NULL (SETQ X (FNTH L N)))	      (RETURN)))      LP  (COND	    ((NULL (SETQ X (CDR X)))	      (RETURN (CONS Y L))))          (SETQ Y (NCONC1 Y (CAR L)))          (SETQ L (CDR L))          (GO LP)))))(DEFINEQ(LCONC  (LAMBDA (PTR X)    (PROG (XX)          (DECLARE (LOCALVARS XX))          (RETURN (COND		    ((NULL X)		      PTR)		    ((OR (NLISTP X)			 (CDR (SETQ XX (LAST X))))		      (SETQ XX X)		      (GO ERROR))		    ((NULL PTR)		      (CONS X XX))		    ((NLISTP PTR)		      (SETQ XX PTR)		      (GO ERROR))		    ((NULL (CAR PTR))		      (FRPLACA (FRPLACD PTR XX)			       X))		    (T (FRPLACD (CDR PTR)				X)		       (FRPLACD PTR XX))))      ERROR          (ERROR (QUOTE "bad argument - LCONC")		 XX)))))(DEFINEQ(LDIFF  (LAMBDA (X Y Z)    (COND      ((EQ X Y)	Z)      ((AND (NULL Y)	    (NULL Z))	X)      (T (PROG (V)	       (COND		 (Z (SETQ V (CDR (FRPLACD (SETQ V (FLAST Z))					  (FRPLACD (CONS (CAR X)							 V))))))		 (T (SETQ V (SETQ Z (CONS (CAR X))))))	   LOOP(SETQ X (CDR X))	       (COND		 ((EQ X Y)		   (RETURN Z))		 ((NULL X)		   (RETURN (ERROR (QUOTE "LDIFF: not a tail")				  Y))))	       (SETQ V (CDR (FRPLACD V (FRPLACD (CONS (CAR X)						      V)))))	       (GO LOOP)))))))(DEFINEQ(LDIFFERENCE  [LAMBDA (X Y)                                              (* lmm "27-Mar-84 16:26")    (for Z in X when (NOT (MEMBER Z Y)) collect Z]))(DEFINEQ(LENGTH  (LAMBDA (X)    (PROG ((N 0))          (DECLARE (LOCALVARS N))      LP  (COND	    ((NLISTP X)	      (RETURN N))	    (T (SETN N (ADD1 N))	       (SETQ X (CDR X))	       (GO LP)))))))(DEFINEQ(LISTGET  (LAMBDA (LST PROP)                                         (* like getp but works on lists, searching them two cdrs							     at a time.)    (PROG NIL      LP  (COND	    ((NLISTP LST)	      (RETURN))	    ((EQ (CAR LST)		 PROP)	      (RETURN (CADR LST))))          (SETQ LST (CDR (LISTP (CDR LST))))          (GO LP)))))(DEFINEQ(LISTGET1  (LAMBDA (LST PROP)                                         (* Used to be called GET. Like LISTGET but only searches							     one cdr at a time.)    (PROG NIL      LP  (COND	    ((NLISTP LST)	      (RETURN))	    ((EQ (CAR LST)		 PROP)	      (RETURN (CADR LST))))          (SETQ LST (CDR LST))          (GO LP)))))(DEFINEQ(LISTPUT  (LAMBDA (LST PROP VAL)                                     (* Like PUT but works on lists.							     Inverse of LISTGET)    (PROG ((X (OR (LISTP LST)		  (ERRORX (LIST 4 LST))))	   X0)      LOOP(COND	    ((NLISTP (CDR X))                                (* Odd parity; either (A B C) or 							     (A B C . D) -							     drop thru and add at beginning)	      )	    ((EQ (CAR X)		 PROP)                                       (* found it)	      (FRPLACA (CDR X)		       VAL)	      (RETURN VAL))	    ((LISTP (SETQ X (CDDR (SETQ X0 X))))	      (GO LOOP))	    ((NULL X)          (* Ran out without finding PROP on even parity. add at end If X is not NIL, means ended in a non-list following 	  even parity, e.g. (A B . C) so drop through and add at front.)	      (FRPLACD (CDR X0)		       (LIST PROP VAL))	      (RETURN VAL)))      ADDFRONT          (FRPLNODE LST PROP (CONS VAL (CONS (CAR LST)					     (CDR LST))))          (RETURN VAL)))))(DEFINEQ(LISTPUT1  (LAMBDA (LST PROP VAL)                                     (* Used to be called PUTL. Like LISTPUT but only 							     searches one cdr at a time. Inverse of LISTGET1)    (PROG ((X (OR (LISTP LST)		  (ERRORX (LIST 4 LST)))))      LP  (COND	    ((NLISTP X)                                      (* Note no checks for lists ending in dotted pairs.)	      (RETURN (NCONC LST (LIST PROP VAL))))	    ((EQ (CAR X)		 PROP)	      (COND		((CDR X)		  (FRPLACA (CDR X)			   VAL))		(T (FRPLACD X (LIST VAL))))	      (RETURN LST)))          (SETQ X (CDR X))          (GO LP)))))(DEFINEQ(LSUBST  (LAMBDA (NEW OLD EXPR)                                     (* lmm "16-FEB-82 22:11")          (* Substitutes X as a segment for Y in Z. E.g. LSUBST ((A B) Y (X Y Z)) is (X A B Z) not meaningful for Y an atom 	  and CDR of a list. if X is NIL, operation effectively deletes Y, i.e. produces a copy without Y in it.)    (COND      ((NULL EXPR)	NIL)      ((NLISTP EXPR)	(COND	  ((EQ OLD EXPR)	    NEW)	  (T EXPR)))      ((EQUAL OLD (CAR EXPR))	(NCONC (COPY NEW)	       (LSUBST NEW OLD (CDR EXPR))))      (T (CONS (LSUBST NEW OLD (CAR EXPR))	       (LSUBST NEW OLD (CDR EXPR))))))))(DEFINEQ(MAP  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG NIL      LP  (COND	    ((NLISTP MAPX)	      (RETURN)))          (APPLY* MAPFN1 MAPX)          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP)))))(DEFINEQ(MAP2C  (LAMBDA (MAPX MAPY MAPFN1 MAPFN2)    (PROG NIL      LP  (COND	    ((OR (NLISTP MAPX)		 (NLISTP MAPY))	      (RETURN)))          (APPLY* MAPFN1 (CAR MAPX)		  (CAR MAPY))          (COND	    (MAPFN2 (SETQ MAPX (APPLY* MAPFN2 MAPX))		    (SETQ MAPY (APPLY* MAPFN2 MAPY)))	    (T (SETQ MAPX (CDR MAPX))	       (SETQ MAPY (CDR MAPY))))          (GO LP)))))(DEFINEQ(MAP2CAR  (LAMBDA (MAPX MAPY MAPFN1 MAPFN2)    (PROG (MAPL MAPE)      LP  (COND	    ((OR (NLISTP MAPX)		 (NLISTP MAPY))	      (RETURN MAPL)))          (SETQ MAPE (CONS (APPLY* MAPFN1 (CAR MAPX)				   (CAR MAPY))			   MAPE))          (COND	    (MAPL (FRPLACD (CDR MAPE)			   (FRPLACD MAPE)))	    (T (SETQ MAPL MAPE)))          (COND	    (MAPFN2 (SETQ MAPY (APPLY* MAPFN2 MAPY))		    (SETQ MAPX (APPLY* MAPFN2 MAPX)))	    (T (SETQ MAPY (CDR MAPY))	       (SETQ MAPX (CDR MAPX))))          (GO LP)))))(DEFINEQ(MAPC  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG NIL      LP  (COND	    ((NLISTP MAPX)	      (RETURN)))          (APPLY* MAPFN1 (CAR MAPX))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP)))))(DEFINEQ(MAPCAR  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL)))          (SETQ MAPE (CONS (APPLY* MAPFN1 (CAR MAPX))			   MAPE))          (COND	    (MAPL (FRPLACD (CDR MAPE)			   (FRPLACD MAPE)))	    (T (SETQ MAPL MAPE)))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP)))))(DEFINEQ(MAPCON  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE MAPY)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL))	    ((LISTP (SETQ MAPY (APPLY* MAPFN1 MAPX)))	      (COND		(MAPE (FRPLACD MAPE MAPY))		(T (SETQ MAPL (SETQ MAPE MAPY))))	      (PROG NIL		LP  (COND		      ((SETQ MAPY (CDR MAPE))			(SETQ MAPE MAPY)			(GO LP))))))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP)))))(DEFINEQ(MAPCONC  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE MAPY)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL))	    ((LISTP (SETQ MAPY (APPLY* MAPFN1 (CAR MAPX))))	      (COND		(MAPE (FRPLACD MAPE MAPY))		(T (SETQ MAPL (SETQ MAPE MAPY))))	      (PROG NIL		LP  (COND		      ((SETQ MAPY (CDR MAPE))			(SETQ MAPE MAPY)			(GO LP))))))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP)))))(DEFINEQ(MAPLIST  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL)))          (SETQ MAPE (CONS (APPLY* MAPFN1 MAPX)			   MAPE))          (COND	    (MAPL (FRPLACD (CDR MAPE)			   (FRPLACD MAPE)))	    (T (SETQ MAPL MAPE)))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP)))))(DEFINEQ(MEMBER  (LAMBDA (X Y)    (PROG NIL      LP  (RETURN (COND		    ((NLISTP Y)		      NIL)		    ((COND			((LITATOM X)			  (EQ X (CAR Y)))			(T (EQUAL X (CAR Y))))		      Y)		    (T (SETQ Y (CDR Y))		       (GO LP))))))))(DEFINEQ(NLEFT  [LAMBDA (L N TAIL)                                         (* bvm: "14-Feb-85 00:35")          (* Returns TAIL of L containing N elements more than TAIL, e.g. if TAIL is NIL (the usual case) NLEFT 	  ((A B C D E) 2) is (D E). If FOO is (A B C D E) and FIE is (CDDDR FOO), (NLEFT FOO 1 FIE) is 	  (C D E).)    (PROG ((X L)	   (Y L))      LP  (COND	    ((EQ N 0)	      (GO LP1))	    ((OR (EQ X TAIL)		 (NLISTP X))	      (RETURN NIL)))          (SETQ X (CDR X))          (SUB1VAR N)          (GO LP)      LP1 (COND	    ((OR (EQ X TAIL)		 (NLISTP X))	      (RETURN Y)))          (SETQ X (CDR X))          (SETQ Y (CDR Y))          (GO LP1]))(DEFINEQ(NLSETQ  (NLAMBDA (NLSETX)    (ERRORSET NLSETX NIL))))(DEFINEQ(NOTANY  (LAMBDA (SOMEX SOMEFN1 SOMEFN2)    (NULL (SOME SOMEX SOMEFN1 SOMEFN2)))))(DEFINEQ(NOTEVERY  (LAMBDA (EVERYX EVERYFN1 EVERYFN2)    (NULL (EVERY EVERYX EVERYFN1 EVERYFN2)))))(DEFINEQ(NTH  (LAMBDA (X N)    (COND      ((IGREATERP 1 N)	(CONS NIL X))      (T (PROG NIL	   LP  (COND		 ((NOT (IGREATERP N 1))		   (RETURN X))		 ((NLISTP X)		   (RETURN NIL)))	       (SETQ X (CDR X))	       (SETQ N (SUB1 N))	       (GO LP)))))))(DEFINEQ(PUTASSOC  (LAMBDA (KEY VAL ALST)                                     (* lmm: 5 SEP 75 119)    (PROG ((X (OR (LISTP ALST)		  (ERRORX (LIST 4 ALST)))))          (DECLARE (LOCALVARS X))      LP  (COND	    ((EQ (CAR (OR (LISTP (CAR X))			  (GO NEXT)))		 KEY)	      (FRPLACD (CAR X)		       VAL)	      (RETURN VAL)))      NEXT(SETQ X (OR (LISTP (CDR X))		      (PROGN (FRPLACD X (LIST (CONS KEY VAL)))			     (RETURN VAL))))          (GO LP)))))(DEFINEQ(RATOMS  (LAMBDA (A FILE RDTBL)    (PROG (L X)      B   (COND	    ((EQ (SETQ X (RATOM FILE RDTBL))		 A)	      (RETURN (CAR L)))	    ((SETQ L (TCONC L X))	      (GO B)))))))(DEFINEQ(REMOVE  (LAMBDA (X L)    (COND      ((NLISTP L)	NIL)      ((EQUAL X (CAR L))	(REMOVE X (CDR L)))      (T (CONS (CAR L)	       (REMOVE X (CDR L))))))))(DEFINEQ(REVERSE  (LAMBDA (L)    (PROG (U)          (DECLARE (LOCALVARS U))      LOOP(COND	    ((NLISTP L)	      (RETURN U)))          (SETQ U (CONS (CAR L)			U))          (SETQ L (CDR L))          (GO LOOP)))))(DEFINEQ(RPT  (LAMBDA (RPTN RPTF)    (PROG (RPTV)          (DECLARE (LOCALVARS RPTV))      LP  (COND	    ((IGREATERP RPTN 0)	      (SETQ RPTV (EVAL RPTF (QUOTE INTERNAL)))	      (SETQ RPTN (SUB1 RPTN))	      (GO LP))	    (T (RETURN RPTV)))))))(DEFINEQ(RPTQ  (NLAMBDA RPTZ    (PROG ((RPTN (EVAL (CAR RPTZ)		       (QUOTE INTERNAL)))	   RPTV)          (DECLARE (SPECVARS RPTN))      RPTQLOOP          (COND	    ((IGREATERP RPTN 0)	      (SETQ RPTV (APPLY (FUNCTION PROGN)				(CDR RPTZ)				(QUOTE INTERNAL)))	      (SETQ RPTN (SUB1 RPTN))	      (GO RPTQLOOP)))          (RETURN RPTV)))))(DEFINEQ(FRPTQ  (NLAMBDA RPTZ    (DECLARE (LOCALVARS . T))    (PROG ((RPTN (EVAL (CAR RPTZ)		       (QUOTE INTERNAL)))	   RPTV)      RPTQLOOP          (COND	    ((IGREATERP RPTN 0)	      (SETQ RPTV (APPLY (FUNCTION PROGN)				(CDR RPTZ)				(QUOTE INTERNAL)))	      (SETQ RPTN (SUB1 RPTN))	      (GO RPTQLOOP)))          (RETURN RPTV)))))(DEFINEQ(SASSOC  (LAMBDA (KEY ALST)    (PROG NIL      LP  (COND	    ((NLISTP ALST)	      (RETURN NIL))	    ((EQUAL (CAAR ALST)		    KEY)	      (RETURN (CAR ALST))))          (SETQ ALST (CDR ALST))          (GO LP)))))(DEFINEQ(SAVEDEF  (LAMBDA (X)    (COND      ((ATOM X)	(SAVEDEF1 X))      (T (MAPCAR X (FUNCTION SAVEDEF1)))))))(DEFINEQ(SAVEDEF1  (LAMBDA (X)    (PROG ((DF (GETD X)))          (RETURN (COND		    (DF (PUTPROP X (SETQ X (SELECTQ (FNTYP X)						    ((SUBR SUBR* FSUBR FSUBR*)						      (QUOTE SUBR))						    ((EXPR EXPR* FEXPR FEXPR*)						      (QUOTE EXPR))						    ((CEXPR CEXPR* CFEXPR CFEXPR*)						      (QUOTE CODE))						    (COND						      ((EXPRP X)							(QUOTE EXPR))						      (T (QUOTE LIST)))))				 DF)                         (* NOTE: this call to PUTPROP is changed to /PUTPROP 							     later in the loadup.)			X)))))))(DEFINEQ(SELECT  (NLAMBDA .SELEC.    (DECLARE (LOCALVARS . T))                                (* dcl: 12 Dec 78 09:08)    (APPLY (QUOTE PROGN)	   (SELECT1 (EVAL (CAR .SELEC.)			  (QUOTE SELECTQ))		    (CDR .SELEC.))	   (QUOTE SELECTQ)))))(DEFINEQ(SELECT1  (LAMBDA (M L)    (DECLARE (LOCALVARS . T))                                (* edited: 8 Dec 78 13:53)    (PROG (C A)      LP  (SETQ C L)          (COND	    ((NULL (SETQ L (CDR L)))	      (RETURN C))	    ((NLISTP (CAR (SETQ C (CAR C))))	      (AND (EQ M (EVAL (CAR C)			       (QUOTE INTERNAL)))		   (RETURN (CDR C)))	      (GO LP)))          (SETQ A (CAR C))      L2  (COND	    ((EQ M (EVAL (CAR A)			 (QUOTE INTERNAL)))	      (RETURN (CDR C)))	    ((LISTP (SETQ A (CDR A)))	      (GO L2))	    (T (GO LP)))))))(DEFINEQ(SELECTC  (NLAMBDA SELCQ                                             (* lmm "28-FEB-82 16:07")    (DECLARE (LOCALVARS . T))    (APPLY (QUOTE PROGN)	   ((LAMBDA (M L)	       (PROG (C TL)		 LP  (SETQ C L)		     (COND		       ((NULL (SETQ L (CDR L)))			 (RETURN C))		       ((OR (EQ (SETQ TL (EVAL (CAR (SETQ C (CAR C)))					       (QUOTE INTERNAL)))				M)			    (AND (LISTP TL)				 (FMEMB M TL)))			 (RETURN (CDR C))))		     (GO LP)))	     (EVAL (CAR SELCQ)		   (QUOTE SELECTQ))	     (CDR SELCQ))	   (QUOTE SELECTQ)))))(DEFINEQ(SETQQ  (NLAMBDA (X Y)    (SET X Y))))(DEFINEQ(SOME  (LAMBDA (SOMEX SOMEFN1 SOMEFN2)                            (* SOME compiles open.)    (PROG NIL      LOOP(COND	    ((NLISTP SOMEX)	      (RETURN NIL))	    ((APPLY* SOMEFN1 (CAR SOMEX)		     SOMEX)	      (RETURN SOMEX)))          (SETQ SOMEX (COND	      (SOMEFN2 (APPLY* SOMEFN2 SOMEX))	      (T (CDR SOMEX))))          (GO LOOP)))))(DEFINEQ(STRMEMB  (LAMBDA (X Y)                                              (* rmk: " 6-JUN-82 15:08")    (PROG (C N)          (DECLARE (LOCALVARS C N))          (SETQ Y (SUBSTRING Y 1))      B   (SETQ N 1)      A   (COND	    ((NULL (SETQ C (NTHCHARCODE X N)))	      (RETURN Y)))          (COND	    ((EQ C (NTHCHARCODE Y N))	      (SETQ N (ADD1 N))	      (GO A)))          (COND	    ((NULL (GNC Y))	      (RETURN))	    (T (GO B)))))))(DEFINEQ(SUB1VAR  (NLAMBDA (SUB1X)    (SET SUB1X (SUB1 (EVAL SUB1X))))))(DEFINEQ(SUBSET  (LAMBDA (MAPX MAPFN1 MAPFN2)    (PROG (MAPL MAPE)      LP  (COND	    ((NLISTP MAPX)	      (RETURN MAPL))	    ((APPLY* MAPFN1 (CAR MAPX))	      (COND		((NULL MAPL)		  (SETQ MAPL (SETQ MAPE (CONS (CAR MAPX)))))		(T (SETQ MAPE (CDR (FRPLACD MAPE (FRPLACD (CONS (CAR MAPX)								MAPE)))))                                                             (* Eseentially an open TCONC.)		   ))))          (SETQ MAPX (COND	      (MAPFN2 (APPLY* MAPFN2 MAPX))	      (T (CDR MAPX))))          (GO LP)))))(DEFINEQ(SUBST  (LAMBDA (NEW OLD EXPR)                                     (* lmm "16-FEB-82 22:11")    (COND      ((NULL EXPR)	NIL)      ((NLISTP EXPR)	(COND	  ((EQ OLD EXPR)	    (COPY NEW))	  (T EXPR)))      (T (CONS (COND		 ((EQUAL OLD (CAR EXPR))		   (COPY NEW))		 (T (SUBST NEW OLD (CAR EXPR))))	       (SUBST NEW OLD (CDR EXPR))))))))(DEFINEQ(TAILP  (LAMBDA (X Y)                                              (* True if X is A tail of Y X and Y non-null.)                                                             (* Included with editor for block compilation purposes.)    (AND X (PROG NIL	     LP  (COND		   ((NLISTP Y)		     (RETURN NIL))		   ((EQ X Y)		     (RETURN X)))	         (SETQ Y (CDR Y))	         (GO LP))))))(DEFINEQ(TCONC  (LAMBDA (PTR X)    (PROG (XX)          (DECLARE (LOCALVARS XX))          (RETURN (COND		    ((NULL PTR)		      (CONS (SETQ XX (CONS X NIL))			    XX))		    ((NLISTP PTR)		      (ERROR (QUOTE "bad argument - TCONC")			     PTR))		    ((NULL (CDR PTR))		      (FRPLACA PTR (CONS X NIL))		      (FRPLACD PTR (CAR PTR)))		    (T (FRPLACD PTR (CDR (FRPLACD (CDR PTR)						  (FRPLACD (CONS X (CDR PTR)))))))))))))(DEFINEQ(TIME  (NLAMBDA (TIMEX TIMEN TIMETYP)          (* If TIMETYP is 0, also prints real time, i.e. (CLOCK 0) if timetype is 3, does garbage collection time.	  If timetype is T does PAGEFAULTS.)                                                             (* Calls to prin1, terpri, print, and spaces changed to 							     correspoding lispx printing functions later in loadup.)    (PROG (TIMEY TIMECNS TIMEM TIMECLK1 TIMECLK2 TIMEZ)          (COND	    ((NULL TIMEN)	      (SETQ TIMEN 1))	    ((MINUSP TIMEN)	      (RETURN (CONS TIMEN (QUOTE (- ?)))))	    ((NOT (SMALLP TIMEN))	      (RETURN (CONS TIMEN (QUOTE (is too large))))))          (SETQ TIMEM TIMEN)          (SETQ TIMECNS (CONSCOUNT))          (SETQ TIMEZ (SELECTQ TIMETYP			       (0 (CLOCK 0))			       (3 (CLOCK 3))			       (T (PAGEFAULTS))			       NIL))          (SETQ TIMECLK1 (CLOCK 2))      T1  (COND	    ((NEQ TIMEM 0)	      (SETQ TIMEY (EVAL TIMEX))	      (SUB1VAR TIMEM)	      (GO T1)))          (SETQ TIMECLK2 (CLOCK 2))          (AND TIMEZ (SETQ TIMEZ (IDIFFERENCE (SELECTQ TIMETYP						       (0 (CLOCK 0))						       (3 (CLOCK 3))						       (T (PAGEFAULTS))						       (ERROR TIMETYP))					      TIMEZ)))          (SETQ TIMECNS (IDIFFERENCE (CONSCOUNT)				     TIMECNS))          (COND	    ((NEQ TIMEN 1)	      (PRIN1 TIMECNS T)	      (PRIN1 (QUOTE /)		     T)	      (PRIN1 TIMEN T)	      (PRIN1 (QUOTE " = ")		     T)))          (PRIN1 (IQUOTIENT TIMECNS TIMEN)		 T)          (SPACES 1 T)          (PRINT (QUOTE conses)		 T)          (SETQ TIMEM (FQUOTIENT (IPLUS TIMECLK2 (IMINUS TIMECLK1))				 1000))          (COND	    ((NEQ TIMEN 1)	      (PRIN1 TIMEM T)	      (PRIN1 (QUOTE /)		     T)	      (PRIN1 TIMEN T)	      (PRIN1 (QUOTE " = ")		     T)))          (PRIN1 (FQUOTIENT TIMEM TIMEN)		 T)          (SPACES 1 T)          (PRINT (QUOTE seconds)		 T)          (SELECTQ TIMETYP		   (0 (PRIN1 (FQUOTIENT TIMEZ 1000)			     T)		      (PRIN1 (QUOTE " seconds, real time")			     T))		   (3 (PRIN1 (FQUOTIENT TIMEZ 1000)			     T)		      (PRIN1 (QUOTE " seconds, garbage collection time")			     T))		   (T (PRIN1 TIMEZ T)		      (PRIN1 (QUOTE " page faults")			     T))		   NIL)          (RETURN TIMEY)))))(DEFINEQ(UNION  (LAMBDA (X Y)    (DECLARE (LOCALVARS . T))                                (* lmm "31-DEC-78 14:47")    (PROG (VAL)      LP  (COND	    ((NLISTP X)	      (RETURN (ENDCOLLECT VAL Y)))	    ((COND		((LITATOM (CAR X))		  (NOT (FMEMB (CAR X)			      Y)))		(T (NOT (MEMBER (CAR X)				Y))))	      (SETQ VAL (DOCOLLECT (CAR X)				   VAL))))          (SETQ X (CDR X))          (GO LP)))))(RPAQ? COMPVARMACROHASH NIL)(ADDTOVAR CONSTANTFOLDFNS PLUS IPLUS TIMES ITIMES DIFFERENCE IDIFFERENCE QUOTIENT IQUOTIENT IMIN IMAX 			       IABS LLSH LRSH LOGOR LOGXOR LOGAND OR AND)(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS COMPVARMACROHASH CONSTANTFOLDFNS))(DECLARE: EVAL@COMPILE DONTCOPY (DECLARE: EVAL@COMPILE (RPAQQ \GS.BUFSIZE 100)(CONSTANTS (\GS.BUFSIZE 100))))(RPAQ? GENNUM 0)(RPAQ? \GS.OGENNUM -1)(RPAQ? \GS.NUMLEN 0)(RPAQ? \GS.BUF NIL)(RPAQ? \GS.STR (ALLOCSTRING 0))(ADDTOVAR PRETTYEQUIVLST (SELECTC . SELECTQ))(ADDTOVAR DWIMEQUIVLST (SELECTC . SELECTQ))(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS GENNUM \GS.OGENNUM \GS.NUMLEN \GS.BUF \GS.STR))(DECLARE: DOEVAL@COMPILE DONTCOPY(LOCALVARS . T))(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA SELECTC SELECT FRPTQ RPTQ DEFINEQ CONSTANTS APPENDTOVAR ADDTOVAR)(ADDTOVAR NLAML TIME SUB1VAR SETQQ NLSETQ ERSETQ ADD1VAR)(ADDTOVAR LAMA APPEND))(PUTPROPS MISC COPYRIGHT ("Xerox Corporation" 1982 1983 1984 1985))(DECLARE: DONTCOPY  (FILEMAP (NIL (1740 1821 (ADD1VAR 1750 . 1819)) (1822 2327 (ADDTOVAR 1832 . 2325)) (2328 2836 (APPENDTOVAR 2338 . 2834)) (2837 3390 (APPEND 2847 . 3388)) (3391 3809 (\APPEND2 3401 . 3807)) (3810 4138 (ASSOC 3820 . 4136)) (4139 4323 (ATTACH 4149 . 4321)) (4324 4713 (CHANGEPROP 4334 . 4711)) (4714 5635 (CONCATLIST 4724 . 5633)) (5636 6057 (CONSTANTS 5646 . 6055)) (6058 7129 (CONSTANTEXPRESSIONP 6068 . 7127)) (7130 7528 (COPY 7140 . 7526)) (7529 7583 (DEFINEQ 7539 . 7581)) (7584 7923 (DEFLIST 7594 . 7921)) (7924 8336 (DREMOVE 7934 . 8334)) (8337 8575 (DREVERSE 8347 . 8573)) (8576 9109 (DSUBST 8586 . 9107)) (9110 9560 (EQLENGTH 9120 . 9558)) (9561 9630 (ERSETQ 9571 . 9628)) (9631 10069 (EVERY 9641 . 10067)) (10070 14487 (GENSYM 10080 . 14485)) (14488 14772 (GENSYM? 14498 . 14770)) (14773 15516 (\GS.INITBUF 14783 . 15514)) (15517 15863 (GETLIS 15527 . 15861)) (15864 16271 (INTERSECTION 15874 . 16269)) (16272 16492 (KWOTE 16282 . 16490)) (16493 16705 (LAST 16503 . 16703)) (16706 17066 (LASTN 16716 . 17064)) (17067 17617 (LCONC 17077 . 17615)) (17618 18134 (LDIFF 17628 . 18132)) (18135 18326 (LDIFFERENCE 18145 . 18324)) (18327 18544 (LENGTH 18337 . 18542)) (18545 18909 (LISTGET 18555 . 18907)) (18910 19269 (LISTGET1 18920 . 19267)) (19270 20296 (LISTPUT 19280 . 20294)) (20297 20917 (LISTPUT1 20307 . 20915)) (20918 21567 (LSUBST 20928 . 21565)) (21568 21827 (MAP 21578 . 21825)) (21828 22215 (MAP2C 21838 . 22213)) (22216 22748 (MAP2CAR 22226 . 22746)) (22749 23015 (MAPC 22759 . 23013)) (23016 23424 (MAPCAR 23026 . 23422)) (23425 23895 (MAPCON 23435 . 23893)) (23896 24373 (MAPCONC 23906 . 24371)) (24374 24777 (MAPLIST 24384 . 24775)) (24778 25022 (MEMBER 24788 . 25020)) (25023 25812 (NLEFT 25033 . 25810)) (25813 25884 (NLSETQ 25823 . 25882)) (25885 25988 (NOTANY 25895 . 25986)) (25989 26101 (NOTEVERY 25999 . 26099)) (26102 26369 (NTH 26112 . 26367)) (26370 26849 (PUTASSOC 26380 . 26847)) (26850 27049 (RATOMS 26860 . 27047)) (27050 27232 (REMOVE 27060 . 27230)) (27233 27465 (REVERSE 27243 . 27463)) (27466 27729 (RPT 27476 . 27727)) (27730 28096 (RPTQ 27740 . 28094)) (28097 28458 (FRPTQ 28107 . 28456)) (28459 28693 (SASSOC 28469 . 28691)) (28694 28825 (SAVEDEF 28704 . 28823)) (28826 29388 (SAVEDEF1 28836 . 29386)) (29389 29653 (SELECT 29399 . 29651)) (29654 30216 (SELECT1 29664 . 30214)) (30217 30777 (SELECTC 30227 . 30775)) (30778 30833 (SETQQ 30788 . 30831)) (30834 31204 (SOME 30844 . 31202)) (31205 31671 (STRMEMB 31215 . 31669)) (31672 31753 (SUB1VAR 31682 . 31751)) (31754 32290 (SUBSET 31764 . 32288)) (32291 32672 (SUBST 32301 . 32670)) (32673 33088 (TAILP 32683 . 33086)) (33089 33538 (TCONC 33099 . 33536)) (33539 35838 (TIME 33549 . 35836)) (35839 36267 (UNION 35849 . 36265)))))STOP</pre>
  </body>
</html>
