(FILECREATED " 1-Apr-86 17:18:46" {QV}<DICT>TOOLS>ANALYZER.;62 46277        changes to:  (MACROS Stream.NextChar)      previous date: "19-Mar-86 11:13:31" {QV}<DICT>TOOLS>ANALYZER.;61)(* Copyright (c) 1985, 1986 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT ANALYZERCOMS)(RPAQQ ANALYZERCOMS [(COMS (* * THE ANALYZER CLASS)			     (* MACROS that call apply the methods of the analyzer class.)			     (RECORDS Analyzer)			     (MACROS Analyzer.Open Analyzer.Close Analyzer.Corrections 				     Analyzer.Proofread Analyzer.Analyze Analyzer.Lookup 				     Analyzer.FindWord Analyzer.AddEntry)			     (* Functions implementing the default case for various methods of the 				analyzer class.)			     (FNS Analyzer.DefaultCorrections Analyzer.DefaultNextWord 				  Analyzer.DefaultAddEntry Analyzer.DefaultAnalyze 				  Analyzer.DefaultProofread Analyzer.DefaultLoadWordList 				  Analyzer.DefaultStoreWordList)			     (FNS Analyzer.Prop Analyzer.PushProp)			     (* Service MACROS.)			     (MACROS Analyzer.AlphaCharP \Analyzer.TestCorruption 				     Analyzer.Capitalization Analyzer.UCaseP)			     (FNS STREAM.FETCHSTRING)			     (MACROS Stream.Init Stream.NextChar)			     (FNS Analyzer.CorruptWord \Analyzer.NewCorruption))		       [COMS (* * TEDIT interface.)			     (FNS Analyzer.Establish AnalyzerForStream Analyzer.QuitFn)			     (FNS TEdit.ProofreadMenu TEdit.Correct TEdit.SetAnalyzer 				  TEdit.LoadWordList TEdit.StoreWordList)			     (INITVARS Analyzer.List Proofreader.AutoCorrect Analyzer.TimeProofreader)			     (P (TEDIT.ADD.MENUITEM				  TEDIT.DEFAULT.MENU				  '(Proofread (FUNCTION TEdit.ProofreadMenu)					      "Looks for the next spelling error after the caret."					      (SUBITEMS (SetProofreader (FUNCTION TEdit.SetAnalyzer))							(LoadWordList (FUNCTION TEdit.LoadWordList)								      						    "Loads a file of words into the proofreader.")							(StoreWordList (FUNCTION TEdit.StoreWordList)								       			"Stores the words added to the proofreader by the user on a remote file.")							(AutoCorrect (FUNCTION [LAMBDA (stream)										       (SETQ 									  Proofreader.AutoCorrect T)										       (TEDIT.PROMPTPRINT stream "AutoCorrection is ON." T])								     		    "The proofreader automatically generates a menu of corrections for the user.")							(ManualCorrect (FUNCTION [LAMBDA										   (stream)										   (SETQ 									  Proofreader.AutoCorrect)										   (TEDIT.PROMPTPRINT										     stream 									 "AutoCorrection is OFF."										     T])								       	      "The user must ask for a menu of corrections from the proofreader if he wants one.")))]		       (COMS (* * some of Martin's functions for dealing with French.)			     (FNS Analyzer.GenerateForms OCR.Correct French.LCase)			     (FNS SimpleStem.AddEntry SimpleStem.Analyze SimpleStem.New)			     (RECORDS CanonicalForm Stem))		       (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS				 (ADDVARS (NLAMA)					  (NLAML)					  (LAMA Analyzer.Prop])(* * THE ANALYZER CLASS)(* MACROS that call apply the methods of the analyzer class.)[DECLARE: EVAL@COMPILE (DATATYPE Analyzer (name grammar index props openFn closeFn proofreadFn analyzeFn lookupFn 			   correctionsFn generateFn conjugateFn findWordFn addEntryFn)		     openFn _(FUNCTION NILL)		     closeFn _(FUNCTION NILL)		     proofreadFn _(FUNCTION Analyzer.DefaultProofread)		     analyzeFn _(FUNCTION Analyzer.DefaultAnalyze)		     lookupFn _(FUNCTION NILL)		     correctionsFn _(FUNCTION Analyzer.DefaultCorrections)		     generateFn _(FUNCTION NILL)		     conjugateFn _(FUNCTION NILL)		     findWordFn _(FUNCTION NILL)		     addEntryFn _(FUNCTION Analyzer.DefaultAddEntry))](/DECLAREDATATYPE 'Analyzer		  '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 			    POINTER POINTER POINTER POINTER)		  '((Analyzer 0 POINTER)		    (Analyzer 2 POINTER)		    (Analyzer 4 POINTER)		    (Analyzer 6 POINTER)		    (Analyzer 8 POINTER)		    (Analyzer 10 POINTER)		    (Analyzer 12 POINTER)		    (Analyzer 14 POINTER)		    (Analyzer 16 POINTER)		    (Analyzer 18 POINTER)		    (Analyzer 20 POINTER)		    (Analyzer 22 POINTER)		    (Analyzer 24 POINTER)		    (Analyzer 26 POINTER))		  '28)(DECLARE: EVAL@COMPILE (PUTPROPS Analyzer.Open MACRO ((analyzer)	   (APPLY* (fetch (Analyzer openFn)			  of analyzer)		   analyzer)))[PUTPROPS Analyzer.Close MACRO ((analyzer)	   (APPLY* (fetch (Analyzer closeFn)			  of analyzer](PUTPROPS Analyzer.Corrections MACRO ((analyzer stream loc len)	   (* * returns a list of possible corrections for the string starting at "loc" that is "len" 	      characters long.)	   (APPLY* (fetch (Analyzer correctionsFn)			  of analyzer)		   analyzer stream loc len)))(PUTPROPS Analyzer.Proofread MACRO ((analyzer stream start length prFn)	   (* * The user interface to Analyzer.Analyze.)	   (APPLY* (fetch (Analyzer proofreadFn)			  of analyzer)		   analyzer stream start length prFn)))(PUTPROPS Analyzer.Analyze MACRO ((analyzer stream fromLoc toLoc analFn)	   (* * break up the stream into legal lexical items. call analFn (analyzer stream start len 										    entries)	      on each item, where "entries" is the analysis of that item. If "entries" is NIL, then 	      the item could not be analyzed.)	   (APPLY* (fetch (Analyzer analyzeFn)			  of analyzer)		   analyzer stream fromLoc toLoc analFn)))(PUTPROPS Analyzer.Lookup MACRO ((analyzer stream fromLoc toLoc)	   (* * Look up the substring of stream between fromLoc and toLoc in dict. "stream" can be a 	      stream, a string, or a list of characters.)	   (APPLY* (fetch (Analyzer lookupFn)			  of analyzer)		   analyzer stream fromLoc toLoc)))(PUTPROPS Analyzer.FindWord MACRO ((analyzer word stream start length)	   (APPLY* (fetch (Analyzer findWordFn)			  of analyzer)		   analyzer word stream start length)))(PUTPROPS Analyzer.AddEntry MACRO ((analyzer lemma entry dontRecord errorStream)	   (* * add lemma to the dictionary with entry "entry" %. If dontRecord is non-NIL, don't 	      worry about keeping track of this word for the word list.)	   (APPLY* (fetch (Analyzer addEntryFn)			  of analyzer)		   analyzer lemma entry dontRecord errorStream))))(* Functions implementing the default case for various methods of the analyzer class.)(DEFINEQ(Analyzer.DefaultCorrections  [LAMBDA (analyzer stream start length)                     (* jtm: "19-Mar-86 11:09")          (* * returns a list of possible spelling corrections for the given word.)    (PROG (form word wordList caps periods)	    [COND	      [(STREAMP stream)		(SETFILEPTR stream start)		(SETQ word (for i from 1 to length collect (BIN stream]	      ((STRINGP stream)		(SETQ word (for i from 1 to (NCHARS stream) collect (NTHCHARCODE stream 											       i]	    (SETQ caps (Analyzer.Capitalization word))	    (SETQ periods (FMEMB (CHARCODE %.)				     word))          (* * first try transpositions)	    (for tail temp on word while (CDR tail)	       do (SETQ temp (CAR tail))		    (RPLACA tail (CADR tail))		    (RPLACA (CDR tail)			      temp)		    (COND		      ((AND (EQ caps 'FIRST)			      (EQ tail word))              (* don't transpose the first letters of a capitalized 							     word.)			NIL)		      (T (\Analyzer.TestCorruption analyzer word wordList)))		    (RPLACA (CDR tail)			      (CAR tail))		    (RPLACA tail temp))          (* * next try deletions)	    (COND	      ((CDR word)		(\Analyzer.TestCorruption analyzer (CDR word)					  wordList)))	    (for tail temp on word while (CDR tail)	       do (SETQ temp (CDR tail))		    (RPLACD tail (CDDR tail))		    (\Analyzer.TestCorruption analyzer word wordList)		    (RPLACD tail temp))          (* * prepend a character.)	    (SETQ word (CONS (CHARCODE A)				 word))	    (SELECTQ caps		       (FIRST                                (* don't prepend a character before a capitalized 							     word.)			      NIL)		       (ALL                                  (* prepend a capital letter.)			    (for c from (CHARCODE A) to (CHARCODE Z)			       do (RPLACA word c)				    (\Analyzer.TestCorruption analyzer word wordList)))		       (for c from (CHARCODE a) to (CHARCODE z)			  do (RPLACA word c)			       (\Analyzer.TestCorruption analyzer word wordList)))	    (SETQ word (CDR word))          (* * insert characters.)	    (for tail on word	       do (RPLACD tail (CONS (CHARCODE A)					   (CDR tail)))		    [COND		      ((EQ caps 'ALL)			(for c from (CHARCODE A) to (CHARCODE Z)			   do (RPLACA (CDR tail)					  c)				(\Analyzer.TestCorruption analyzer word wordList)))		      (T (for c from (CHARCODE a) to (CHARCODE z)			    do (RPLACA (CDR tail)					   c)				 (\Analyzer.TestCorruption analyzer word wordList]		    (COND		      (periods (RPLACA (CDR tail)					 (CHARCODE %.))			       (\Analyzer.TestCorruption analyzer word wordList)))		    (RPLACD tail (CDDR tail)))          (* * replace characters)	    (for tail temp on word	       do (SETQ temp (CAR tail))		    [COND		      ((OR (EQ caps 'ALL)			     (AND (EQ caps 'FIRST)				    (EQ tail word)))			(for c from (CHARCODE A) to (CHARCODE Z)			   do (COND				  ((NEQ temp c)				    (RPLACA tail c)				    (\Analyzer.TestCorruption analyzer word wordList]		    [COND		      ((OR (EQ caps NIL)			     (NOT (ALPHACHARP (CHCON1 temp)))			     (AND (EQ caps 'FIRST)				    (NEQ tail word)))			(for c from (CHARCODE a) to (CHARCODE z)			   do (COND				  ((NEQ temp c)				    (RPLACA tail c)				    (\Analyzer.TestCorruption analyzer word wordList]		    (COND		      (periods (RPLACA tail (CHARCODE %.))			       (\Analyzer.TestCorruption analyzer word wordList)))		    (RPLACA tail temp))	    (SETQ wordList (SORT wordList))	    [for i on wordList do (while (STREQUAL (CAR i)							     (CADR i))					   do (RPLACD i (CDDR i]	    (RETURN wordList])(Analyzer.DefaultNextWord  [LAMBDA (analyzer stream startPtr searchLength NWFn)       (* jtm: "29-Oct-85 15:23")          (* * Scans the stream looking for a word, i.e. a sequence of alphabetic charqacters. If the file ptr is already in 	  the middle of such a sequence, it backs up to the beginning of that sequence. The function applies NWFn to 	  (stream start stop) for each such word.)    (SETFILEPTR stream (OR startPtr (SETQ startPtr 0)))    (bind char end endPtr word length start value quote (filePtr _(GETFILEPTR stream))	  (EOFPtr _(GETEOFPTR stream))       first (SETQ endPtr (COND		 (searchLength (IPLUS startPtr searchLength))		 (T EOFPtr)))	     (OR (ILEQ endPtr EOFPtr)		 (SETQ endPtr EOFPtr))       do (SETQ char (AND (ILESSP (GETFILEPTR stream)				  endPtr)			  (BIN stream)))	  (COND	    [(AND char (AND (NUMBERP char)			    (ILESSP char 128)			    (Analyzer.AlphaCharP char)))	      (OR start (SETQ start (SUB1 (GETFILEPTR stream]	    (start (SETQ end (GETFILEPTR stream))		   (SETQ length (IDIFFERENCE end start))		   (AND char (add length -1))                (* back up to the last legal char.)		   [COND		     (NWFn (SETQ value (APPLY* NWFn analyzer stream start length]		   (COND		     ((OR (NULL NWFn)			  (EQ value T))		       (RETURN (CONS start length)))		     (value (RETURN value)))		   (SETFILEPTR stream end)		   (SETQ start NIL)))	  (OR char (RETURN])(Analyzer.DefaultAddEntry  [LAMBDA (analyzer lemma entry dontRecord errorStream)      (* jtm: "10-Jan-86 12:00")    (TEDIT.PROMPTPRINT errorStream "Insert not implemented for this proofreader." T])(Analyzer.DefaultAnalyze  [LAMBDA (analyzer stream startPtr searchLength NWFn)       (* jtm: "19-Mar-86 10:40")          (* * Scans the stream looking for a word, i.e. a sequence of alphabetic charqacters. If the file ptr is already in 	  the middle of such a sequence, it backs up to the beginning of that sequence. The function applies NWFn to 	  (stream start stop) for each such word.)    [COND      ((STRINGP stream)	(SETQ stream (OPENSTRINGSTREAM stream]    (SETFILEPTR stream (OR startPtr (SETQ startPtr 0)))    (bind char end endPtr length start lookup quote number period (word _(ALLOCSTRING 100 32))	    (i _ startPtr) first [SETQ endPtr (COND				       (searchLength (IMIN (GETEOFPTR stream)							     (IPLUS startPtr searchLength)))				       (T (GETEOFPTR stream]       do (SETQ char (AND (ILESSP i endPtr)				(add i 1)				(BIN stream)))	    (COND	      ((AND start char (ILESSP char 128))		(RPLCHARCODE word (IDIFFERENCE i start)			       char)))	    (COND	      ((AND char (AND (ILESSP char 128)				  (Analyzer.AlphaCharP char)))		(COND		  ((NULL start)		    [COND		      (number (SETQ start (IDIFFERENCE i 2))                                                             (* we have a number followed by some characters.							     (e.g. 7th, 21st, etc.) Take in the last digit of the 							     number.)			      (RPLCHARCODE word 1 number)			      (SETQ number NIL))		      (T (SETQ start (SUB1 i]		    (RPLCHARCODE word (IDIFFERENCE i start)				   char)))		(COND		  (quote (COND			   ((EQ quote T)                   (* don't make a list until you need to.)			     (SETQ quote NIL)))			 (push quote char)))		(SETQ period NIL))	      ((AND start char (EQ char (CHARCODE %')))                                                             (* if the quote is in the middle of a word, leave it 							     in.)		(SETQ quote T))	      ((AND start char (EQ char (CHARCODE %.)))                                                             (* periods are legal in a string of characters 							     (e.g., i.e. abbr.))		(SETQ period T))	      (start (SETQ end i)		     (SETQ length (IDIFFERENCE end start))		     (AND char (add length -1))          (* back up to the last legal char.)		     (COND		       ((EQ quote T)                       (* delete final quotes)			 (add length -1))		       ((AND (FMEMB (CAR quote)					'(115 83))			       (NULL (CDR quote)))       (* delete %'s)			 (add length -2)))		     (SETQ quote NIL)		     (COND		       ((AND (EQ length 1)			       (EQ char (CHARCODE %))))                                                             (* letters used for outlines.)			 (add length 1)))		     (COND		       (period (add length -1)))		     [COND		       [NWFn (SETQ lookup (Analyzer.Lookup analyzer word 0 length))			     (COND			       ([AND period (NULL lookup)				       (SETQ lookup (Analyzer.Lookup analyzer word 0 (ADD1 length]                                                             (* abbreviation?)				 (add length 1)))			     (SETQ lookup (APPLY* NWFn analyzer stream start length lookup))			     (COND			       (lookup (RETURN lookup]		       (T (RETURN (CONS start length]		     (SETFILEPTR stream end)		     (SETQ i end)		     (SETQ start NIL))	      ((AND char (NUMBERP char)		      (IGEQ char 48)		      (ILEQ char 57))                      (* a number)		(SETQ number char))	      (T (SETQ number NIL)))	    (OR char (RETURN])(Analyzer.DefaultProofread  [LAMBDA (analyzer stream begin length)                     (* jtm: "12-Feb-86 15:22")    (PROG (start.length correction startTime stopTime (n 0))	    (TEDIT.PROMPTPRINT stream "Proofreading . . . " T)          (* * initialize and back up to the beginning of a word.)	    (SETQ startTime (CLOCK 0))	    (Stream.Init stream begin length)	    [COND	      ((NEQ length 0)		(while (AND (NUMBERP (SETQ char (BIN stream)))				(ALPHACHARP char))		   do (COND			  ((EQUAL begin 0)			    (RETURN))			  (T (add begin -1)			     (add length 1)			     (SETFILEPTR stream begin]          (* * look for the next spelling error.)	    [while [SETQ start.length (Analyzer.Analyze analyzer stream begin length							    (FUNCTION (LAMBDA (analyzer stream 											  start 											  length 											  entries)								(add n 1)								(COND								  ((NULL entries)								    (CONS start length]	       do           (* * start.length is a CONS pair of locations delimiting an unrecognizable word. Set the selection to it and 	  display it.)		    (TEDIT.SETSEL stream (ADD1 (CAR start.length))				    (CDR start.length)				    'RIGHT				    T)		    (TEDIT.SHOWSEL stream NIL)		    (TEDIT.NORMALIZECARET stream)		    (TEDIT.SHOWSEL stream T)		    (COND		      [(AND start.length Proofreader.AutoCorrect (SETQ correction				(TEdit.Correct stream analyzer)))			(SETQ begin (COND			    ((EQ correction '*SKIP*)			      (IPLUS (CAR start.length)				       (CDR start.length)))			    (T (CAR start.length]		      (T (RETURN]	    (SETQ stopTime (CLOCK 0))	    (COND	      (Analyzer.TimeProofreader (TEDIT.PROMPTPRINT stream (CONCAT "Elapsed Time: "									      (QUOTIENT										(DIFFERENCE 											 stopTime 											startTime)										1000.0)									      " seconds.")))	      (start.length (TEDIT.PROMPTPRINT stream "Error found."))	      (T (TEDIT.SETSEL stream (ADD1 (GETEOFPTR stream))				 0				 'RIGHT)		 (TEDIT.SHOWSEL stream NIL)		 (TEDIT.NORMALIZECARET stream)		 (TEDIT.SHOWSEL stream T)		 (TEDIT.PROMPTPRINT stream (COND					((EQUAL n 0)					  "No Errors.")					(T (CONCAT n " words proofread."])(Analyzer.DefaultLoadWordList  [LAMBDA (analyzer file)                                    (* jtm: "16-Oct-85 13:06")          (* * adds a word list to the given analyzer.)    (PROG (wordList)          (SETQ wordList (READFILE file))          (for i in (CDR wordList) do (Analyzer.AddEntry analyzer i T T))          (Analyzer.PushProp analyzer 'WordListFile			     file])(Analyzer.DefaultStoreWordList  [LAMBDA (analyzer file)                                    (* jtm: " 9-Oct-85 10:55")          (* * adds the current word list to the remote file.)    (PROG (wordList)          (SETQ wordList (Analyzer.Prop analyzer 'WordList))          [COND	    ((DIRECTORY file)	      (SETQ wordList (APPEND wordList (CDR (READFILE file]          (WRITEFILE wordList file)          (Analyzer.PushProp analyzer 'WordListFile			     file)          (Analyzer.Prop analyzer 'WordList			 NIL]))(DEFINEQ(Analyzer.Prop  [LAMBDA a                                                  (* jtm: " 2-Oct-85 14:45")    (PROG (p (analyzer (ARG a 1))	     (prop (ARG a 2)))          (SETQ p (FASSOC prop (fetch (Analyzer props) of analyzer)))          (RETURN (COND		    ((ILEQ a 2)		      (CDR p))		    [p (PROG1 (CDR p)			      (RPLACD p (ARG a 3]		    (T (push (fetch (Analyzer props) of analyzer)			     (CONS prop (ARG a 3)))		       NIL])(Analyzer.PushProp  [LAMBDA (analyzer prop value)                              (* jtm: " 9-Oct-85 10:43")          (* * pushes value onto a list of values stored at prop.)    (PROG [(prop.values (FASSOC prop (fetch (Analyzer props) of analyzer]          (COND	    [(NULL prop.values)	      (push (fetch (Analyzer props) of analyzer)		    (CONS prop (LIST value]	    ((NOT (for i in (CDR prop.values) thereis (EQUAL i value)))	      (push (CDR prop.values)		    value]))(* Service MACROS.)(DECLARE: EVAL@COMPILE [PUTPROPS Analyzer.AlphaCharP MACRO ((CHAR)	   (OR (EQ (LRSH CHAR 8)		   241)	       ([LAMBDA (UCHAR)			(DECLARE (LOCALVARS UCHAR))			(OR (EQ (LRSH UCHAR 8)				241)			    (AND (IGEQ UCHAR (CHARCODE A))				 (ILEQ UCHAR (CHARCODE Z]		(LOGAND CHAR 95][PUTPROPS \Analyzer.TestCorruption MACRO ((analyzer word wordList)	   (COND ((Analyzer.Lookup analyzer word)		  (push wordList (CONCATCODES word][PUTPROPS Analyzer.Capitalization MACRO ((word)	   (* * returns NIL, ALL or FIRST)	   (COND ((AND word (Analyzer.UCaseP (CAR word)))		  (COND ((AND word (Analyzer.UCaseP (CADR word)))			 'ALL)			(T 'FIRST][PUTPROPS Analyzer.UCaseP MACRO ((UCHAR)	   (OR (AND (IGEQ UCHAR (CHARCODE 361,041))		    (ILEQ UCHAR (CHARCODE 361,160)))	       (AND (IGEQ UCHAR (CHARCODE A))		    (ILEQ UCHAR (CHARCODE Z])(DEFINEQ(STREAM.FETCHSTRING  [LAMBDA (stream start length buffer)                       (* jtm: "14-Feb-86 13:11")    [COND      ((OR (NULL buffer)	     (IGREATERP length (NCHARS buffer)))	(SETQ buffer (ALLOCSTRING length]    (SETFILEPTR stream start)    (for i from 1 to length do (RPLCHARCODE buffer i (BIN stream)))    (SUBSTRING buffer 1 length]))(DECLARE: EVAL@COMPILE [PUTPROPS Stream.Init MACRO ((stream start length)	   (COND ((STRINGP stream)		  NIL)		 ((NOT (LISTP stream))		  (COND ((NULL start)			 (SETQ start 0)))		  [COND ((NULL length)			 (SETQ length (IDIFFERENCE (GETEOFPTR stream)						   start]		  (SETFILEPTR stream start][PUTPROPS Stream.NextChar MACRO ((stream length index)	   (COND ((LISTP stream)		  (pop stream))		 ((OR (NULL stream)		      (ILEQ length 0))		  NIL)		 ((STRINGP stream)		  (add length -1)		  (add index 1)		  (NTHCHARCODE stream index))		 (T (add length -1)		    (BIN stream])(DEFINEQ(Analyzer.CorruptWord  [LAMBDA (analyzer stream start length)                     (* jtm: " 2-Oct-85 13:41")          (* * returns a list of possible spelling corrections for the given word.)    [COND      ((NOT (LISTP word))	(SETQ word (CHCON word]    (PROG (form word wordList caps)	    (SETQ word (for i from 1 to length collect (BIN stream)))	    (SETQ caps (Analyzer.Capitalization word))          (* * first try transpositions)	    (for tail temp on word while (CDR tail)	       do (SETQ temp (CAR tail))		    (RPLACA tail (CADR tail))		    (RPLACA (CDR tail)			      temp)		    (COND		      ((AND (EQ caps 'FIRST)			      (EQ tail word))              (* don't transpose the first letters of a capitalized 							     word.)			NIL)		      (T (\Analyzer.TestCorruption analyzer word wordList)))		    (RPLACA (CDR tail)			      (CAR tail))		    (RPLACA tail temp))          (* * next try deletions)	    (COND	      ((CDR word)		(\Analyzer.TestCorruption analyzer (CDR word)					  wordList)))	    (for tail temp on word while (CDR tail)	       do (SETQ temp (CDR tail))		    (RPLACD tail (CDDR tail))		    (\Analyzer.TestCorruption analyzer word wordList)		    (RPLACD tail temp))          (* * prepend a character.)	    (SETQ word (CONS 'A				 word))	    (SELECTQ caps		       (FIRST                                (* don't prepend a character before a capitalized 							     word.)			      NIL)		       [ALL                                  (* prepend a capital letter.)			    (for c from (CHARCODE A) to (CHARCODE Z)			       do (RPLACA word c)				    (COND				      ((Analyzer.Analyze analyzer word)					(\Analyzer.NewCorruption (\AnalyzerStringForm word]		       (for c from (CHARCODE a) to (CHARCODE z)			  do (RPLACA word c)			       (\Analyzer.TestCorruption analyzer word wordList)))	    (SETQ word (CDR word))          (* * insert characters.)	    (for tail on word	       do (RPLACD tail (CONS 'A					   (CDR tail)))		    [COND		      ((EQ caps 'ALL)			(for c from (CHARCODE A) to (CHARCODE Z)			   do (RPLACA (CDR tail)					  c)				(\Analyzer.TestCorruption analyzer word wordList)))		      (T (for c from (CHARCODE a) to (CHARCODE z)			    do (RPLACA (CDR tail)					   c)				 (\Analyzer.TestCorruption analyzer word wordList]		    (RPLACD tail (CDDR tail)))          (* * replace characters)	    (for tail temp on word	       do (SETQ temp (CAR tail))		    [COND		      ((OR (EQ caps 'ALL)			     (AND (EQ caps 'FIRST)				    (EQ tail word)))			(for c from (CHARCODE A) to (CHARCODE Z)			   do (RPLACA tail c)				(COND				  ((EQ temp c))				  (T (\Analyzer.TestCorruption analyzer word wordList]		    [COND		      ((OR (EQ caps NIL)			     (NOT (ALPHACHARP temp))			     (AND (EQ caps 'FIRST)				    (NEQ tail word)))			(for c from (CHARCODE a) to (CHARCODE z)			   do (RPLACA tail c)				(COND				  ((EQ temp (CHARACTER c)))				  (T (\Analyzer.TestCorruption analyzer word wordList]		    (RPLACA tail temp))	    (SETQ wordList (SORT wordList))	    [for i on wordList do (while (STREQUAL (CAR i)							     (CADR i))					   do (RPLACD i (CDR i]	    (RETURN wordList])(\Analyzer.NewCorruption  [LAMBDA (w)                                                (* mk: " 6-Sep-85 14:15")    (OR (for i in wordList thereis (STREQUAL i w))	(push wordList w]))(* * TEDIT interface.)(DEFINEQ(Analyzer.Establish  [LAMBDA (analyzer)                                         (* jtm: " 8-Jan-86 08:50")    (AND analyzer (OR (AND (BOUNDP 'Analyzer.List)				 (bind (name _(fetch (Analyzer name) of analyzer))				    for tail on Analyzer.List when (EQUAL									   name									   (fetch (Analyzer name)									      of (CAR tail)))				    do (RPLACA tail analyzer)					 (RETURN T)))			  (push Analyzer.List analyzer])(AnalyzerForStream  [LAMBDA (stream)                                           (* jtm: " 2-Oct-85 14:00")          (* * comment)    (COND      ((STREAMPROP stream 'analyzer))      (T (TEdit.SetAnalyzer stream])(Analyzer.QuitFn  [LAMBDA (window stream textObj)                            (* jtm: "14-Jan-86 15:58")          (* * ask the user if he wants to save the word list.)    (PROG ((analyzer (AnalyzerForStream stream)))	    (COND	      ((AND analyzer (Analyzer.Prop analyzer 'WordList)		      (STREQUAL "yes" (TEDIT.GETINPUT stream 							  "Do you want to save the word list? "							  "yes")))		(TEdit.StoreWordList stream]))(DEFINEQ(TEdit.ProofreadMenu  [LAMBDA (stream)                                           (* jtm: "14-Mar-86 12:25")          (* * TEDIT interface to the current analyzer.)    (PROG (menuWindow menu analyzer)                       (* COND ((WINDOWPROP W (QUOTE DEFWINDOW)) 							     (* so they don't interfere.) 							     (CLOSEW (WINDOWPROP W (QUOTE DEFWINDOW)))))	    (SETQ menuWindow (WINDOWPROP W 'Proofreader.Menu))	    (COND	      ((NULL menuWindow)		(SETQ menu (create MENU				       ITEMS _(LIST (LIST 'Proofread							      (LIST 'Analyzer.Proofread								      (LIST 'AnalyzerForStream									      stream)								      stream								      (LIST 'SUB1									      (LIST 'TEDIT.GETPOINT										      stream)))							      				     "looks for the next spelling error starting from the caret.")						      (LIST 'Correct							      (LIST 'TEdit.Correct								      stream								      (LIST 'AnalyzerForStream									      stream))							      			    "generates a list of possible corrections for the current selection.")						      (LIST 'Insert							      (LIST 'Analyzer.AddEntry								      (LIST 'AnalyzerForStream									      stream)								      (LIST 'TEDIT.SEL.AS.STRING									      stream)								      T NIL stream)							      				       "inserts the selected word into the analyzer's word list."))				       CENTERFLG _ T))		(SETQ menuWindow (CREATEW (CREATEREGION -100 -100 (IPLUS 8										 (fetch										   (MENU IMAGEWIDTH)										    of menu))							      (IPLUS 8 (fetch (MENU IMAGEHEIGHT)									    of menu)))					      NIL NIL T))    (* WINDOWPROP menuWindow (QUOTE RESHAPEFN) 							     (QUOTE DON'T))		(ADDMENU menu menuWindow)		(WINDOWPROP W 'Proofreader.Menu			      menuWindow)		(CLOSEW menuWindow)))	    (COND	      ((NOT (OPENWP menuWindow))		(ATTACHWINDOW menuWindow W 'LEFT				'TOP				'LOCALCLOSE)                 (* (CAR (WINDOWPROP W (QUOTE PROMPTWINDOW))))                                                             (* if you attach the menuWindow to W, then it gets 							     attached to the top-most TEdit menu.)		(OPENW menuWindow)))	    (COND	      ((SETQ analyzer (AnalyzerForStream stream))		(Analyzer.Proofread analyzer stream (SUB1 (TEDIT.GETPOINT stream])(TEdit.Correct  [LAMBDA (stream analyzer)                                  (* jtm: "14-Jan-86 15:36")    (PROG (selection correction start length)	    (SETQ selection (TEDIT.GETSEL stream))	    (SETQ start (fetch (SELECTION CH#) of selection))	    (SETQ length (IDIFFERENCE (fetch (SELECTION CHLIM) of selection)					  start))	    [SELECTQ (SETQ correction (MENU (create MENU							    ITEMS _(APPEND (Analyzer.Corrections									       analyzer stream									       (SUB1 start)									       length)									     '(*INSERT* *SKIP*))							    CENTERFLG _ T							    MENUOFFSET _(create POSITION										  XCOORD _ 6										  YCOORD _ 6)							    TITLE _ "corrections")))		       (*INSERT* (Analyzer.AddEntry analyzer (TEDIT.SEL.AS.STRING stream)						    T NIL stream))		       (*SKIP* NIL)		       (COND			 (correction (TEDIT.DELETE stream)				     (TEDIT.INSERT stream correction]	    (RETURN correction])(TEdit.SetAnalyzer  [LAMBDA (stream analyzer)                                  (* jtm: "14-Mar-86 13:44")          (* * sets the analyzer property for the window)    (PROG (quitFn menuItems subItems result)	    [COND	      ((NULL analyzer)		[SETQ menuItems		  (for i in Analyzer.List		     collect (COND				 [[AND (Analyzer.Prop i 'RemoteDict)					 (OR (fetch (Analyzer index) of i)					       (AND (Analyzer.Open i)						      (fetch (Analyzer index) of i]				   (LIST (fetch (Analyzer name) of i)					   (LIST 'QUOTE						   i)					   "Calls the remote dictionary server"					   (CONS 'SUBITEMS						   (for j						      in (DictTool.RPCCall							     (RemoteDict.Analyzers							       (FULLUSERNAME)							       (CDR (fetch (Analyzer index)									 of i)))							     (fetch (Analyzer index) of i)							     (DictTool.PromptStream stream))						      collect (push subItems (CONS i j))								(LIST j (LIST 'QUOTE										  (CONS i j]				 (T (LIST (fetch (Analyzer name) of i)					    (LIST 'QUOTE						    i]		[COND		  ((AND (EQUAL 1 (LENGTH menuItems))			  (NULL subItems))		    (SETQ result (CAR Analyzer.List)))		  ((AND (EQUAL 1 (LENGTH menuItems))			  (EQUAL 1 (LENGTH subItems)))		    (SETQ result (CAR subItems)))		  (T (SETQ result (MENU (create MENU						      ITEMS _ menuItems						      TITLE _ "analyzers"						      CENTERFLG _ T]		(COND		  ((NULL result)		    (SETQ analyzer (STREAMPROP stream 'analyzer))		    (TEDIT.PROMPTPRINT stream (CONCAT "Proofreader is "							  (AND analyzer (fetch (Analyzer name)									     of analyzer))							  ": "							  (AND analyzer (Analyzer.Prop								   analyzer								   'RemoteDict))							  ".")					 T)		    (RETURN))		  ((LISTP result)		    (SETQ analyzer (CAR result))		    (Analyzer.Prop analyzer 'RemoteDict				     (CDR result)))		  (T (SETQ analyzer result]	    (COND	      ((Analyzer.Prop analyzer 'RemoteDict)		(TEDIT.PROMPTPRINT stream (CONCAT "Setting proofreader to " (fetch							(Analyzer name) of analyzer)						      ": "						      (Analyzer.Prop analyzer 'RemoteDict)						      "...")				     T))	      (T (TEDIT.PROMPTPRINT stream (CONCAT "Setting proofreader to "						       (AND analyzer (fetch (Analyzer name)									  of analyzer))						       "...")				      T)))	    (COND	      (analyzer (Analyzer.Open analyzer)))	    (STREAMPROP stream 'analyzer			  analyzer)	    (SETQ quitFn (TEXTPROP stream 'QUITFN))	    [COND	      ((OR (EQ quitFn 'Analyzer.QuitFn)		     (FMEMB 'Analyzer.QuitFn			      quitFn))		NIL)	      ((NULL quitFn)		(TEXTPROP stream 'QUITFN			    'Analyzer.QuitFn))	      (T (TEXTPROP stream 'QUITFN			     (CONS 'Analyzer.QuitFn				     quitFn]                 (* push the function onto the list.)	    (TEDIT.PROMPTPRINT stream "done."))    analyzer])(TEdit.LoadWordList  [LAMBDA (stream)                                           (* jtm: " 9-Oct-85 10:39")          (* * reads a word list from a remote file and adds it to the given analyzer.)    (PROG (file (analyzer (AnalyzerForStream stream)))          (COND	    ((NULL analyzer)	      (TEDIT.PROMPTPRINT stream "Please select a proofreader." T))	    ((NULL (SETQ file (TEDIT.GETINPUT stream "Fetch word list on file: ")))	      (TEDIT.PROMPTPRINT stream "Aborted." T))	    (T (TEDIT.PROMPTPRINT stream (CONCAT "Reading " file "...")				  T)	       (Analyzer.DefaultLoadWordList analyzer file)	       (TEDIT.PROMPTPRINT stream "done."])(TEdit.StoreWordList  [LAMBDA (stream)                                           (* jtm: " 4-Dec-85 13:46")          (* * stores the word list for the given analyzer on a remote file.)    (PROG (file (analyzer (AnalyzerForStream stream)))	    (COND	      ((NULL analyzer)		(TEDIT.PROMPTPRINT stream "Please select a proofreader." T))	      ((NULL (Analyzer.Prop analyzer 'WordList))		(TEDIT.PROMPTPRINT stream "No words to be stored." T))	      ([NULL (SETQ file (TEDIT.GETINPUT stream "Store word list on file: "						      (CAR (Analyzer.Prop analyzer 'WordListFile]		(TEDIT.PROMPTPRINT stream "Aborted." T))	      (T (TEDIT.PROMPTPRINT stream (CONCAT "Storing word list on " file "...")				      T)		 (Analyzer.DefaultStoreWordList analyzer file)		 (TEDIT.PROMPTPRINT stream "done."]))(RPAQ? Analyzer.List NIL)(RPAQ? Proofreader.AutoCorrect NIL)(RPAQ? Analyzer.TimeProofreader NIL)[TEDIT.ADD.MENUITEM TEDIT.DEFAULT.MENU '(Proofread (FUNCTION TEdit.ProofreadMenu)						   					     "Looks for the next spelling error after the caret."						   (SUBITEMS (SetProofreader (FUNCTION 										TEdit.SetAnalyzer))							     (LoadWordList (FUNCTION 									       TEdit.LoadWordList)									   						    "Loads a file of words into the proofreader.")							     (StoreWordList (FUNCTION 									      TEdit.StoreWordList)									    			"Stores the words added to the proofreader by the user on a remote file.")							     (AutoCorrect (FUNCTION [LAMBDA										      (stream)										      (SETQ 									  Proofreader.AutoCorrect T)										      (TEDIT.PROMPTPRINT stream "AutoCorrection is ON." T])									  		    "The proofreader automatically generates a menu of corrections for the user.")							     (ManualCorrect (FUNCTION [LAMBDA											(stream)											(SETQ 									  Proofreader.AutoCorrect)											(TEDIT.PROMPTPRINT stream "AutoCorrection is OFF." T])									    	      "The user must ask for a menu of corrections from the proofreader if he wants one.")))](* * some of Martin's functions for dealing with French.)(DEFINEQ(Analyzer.GenerateForms  [LAMBDA (word GFFeatures genFn trace)                      (* mk: "17-Sep-85 16:10")    (bind entries usedTemplates first [PROGN           (* * Analyze the prototype whose paradigm is to be generated.)					     [Analyze DefaultDict (CONCAT "{" word "}")						      (QUOTE start)						      NIL						      (FUNCTION (LAMBDA (dict w fromLoc toLoc f)          (* * Find the first hitherto unused template that is compatible with this analysis of the prototype and with the 	  features specified for the generation as a whole, and list its features as a seed for generation.)							  (bind x for tpl in Templates							     when (AND (SimpleUnify (CAR tpl)										    f)								       (SETQ x (SimpleUnify									   (CAR tpl)									   GFFeatures)))							     do (COND								  ((NOT (FMEMB tpl usedTemplates))								    (push entries (CONS w x))								    (push usedTemplates tpl)))								(RETURN]					     (tracer trace NIL # (COND						       ((CDR entries)							 (printout NIL T 1 " stems."))						       (entries (printout NIL T (LENGTH entries)									  " stem."))						       (T (printout NIL T "No analyses of " word]       while (SETQ entry (pop entries)) do (Gen (CONCAT "{" (CAR entry)							"}")						(QUOTE start)						(CDR entry)						NIL NIL genFn (AND trace 0])(OCR.Correct  [LAMBDA (dict word)                                        (* mk: "25-Sep-85 17:47")    (DECLARE (USEDFREE prevSpec stream))    (PROG [correction item n string (menuItems (QUOTE (--> *CORRECT* *QUIT* *INSERT*]          (AND prevSpec (push menuItems (QUOTE <--)))          [COND	    ((OR (STREQUAL word "pE")		 (STREQUAL word "oE"))	      (push menuItems "of"))	    (T (for i from 1 to (NCHARS word)		  do (SELECTQ (MKATOM (SUBSTRING word i i))			      (I (SETQ string (CONCAT (OR (SUBSTRING word 1 (SUB1 i))							  "")						      "l"						      (OR (SUBSTRING word (ADD1 i)								     (NCHARS word))							  "")))				 (AND (Analyzer.Analyze dict string)				      (push menuItems string)))			      [~ (for j from (CHARCODE a) to (CHARCODE z)				    do (SETQ string (CONCAT (OR (SUBSTRING word 1 (SUB1 i))								"")							    (FCHARACTER j)							    (OR (SUBSTRING word (ADD1 i)									   (NCHARS word))								"")))				       (AND (Analyzer.Analyze dict string)					    (push menuItems string))				       (for k from (CHARCODE a) to (CHARCODE z)					  do (SETQ string (CONCAT (OR (SUBSTRING word 1 (SUB1 i))								      "")								  (FCHARACTER j)								  (FCHARACTER k)								  (OR (SUBSTRING word (ADD1 i)										 (NCHARS word))								      "")))					     (AND (Analyzer.Analyze dict string)						  (push menuItems string]			      NIL]          (SELECTQ (SETQ item (MENU (create MENU					    ITEMS _ menuItems)))		   (<-- (TEDIT.DELETE stream (IPLUS (SETQ n (IPLUS (CADR prevSpec)								   (CDDR prevSpec)))						    1)				      (IDIFFERENCE (CADR wordSpec)						   n))		     (RETURN (QUOTE *RETRY*)))		   (--> (TEDIT.DELETE stream (SETQ n (IPLUS (CADR wordSpec)							    (CDDR wordSpec)							    1))				      (ADD1 (IDIFFERENCE (CADR (Analyzer.NextWord dict stream n										  (GETEOFPTR stream)))							 n)))			(RETURN (QUOTE *RETRY*)))		   (*CORRECT*)		   (*QUIT* (RETURN (QUOTE *QUIT*)))		   (*INSERT* (Dict.Put dict word T)			     (RETURN))		   (PROGN (COND			    (item (TEDIT.DELETE STREAM)				  (TEDIT.INSERT STREAM item)))			  (RETURN)))          (SETQ correction (MENU (create MENU					 ITEMS _ [APPEND (CONSTANT (LIST (QUOTE *QUIT*)									 (QUOTE *INSERT*)))							 (Analyzer.CorruptWord							   word							   (FUNCTION (LAMBDA (w)							       (Analyzer.Analyze dict w]					 CENTERFLG _ T					 CHANGEOFFSETFLG _ T					 TITLE _ "corrections")))          (SELECTQ correction		   (*QUIT* (RETURN (QUOTE *QUIT*)))		   (*INSERT* (Dict.Put dict word T))		   (NIL)		   (PROGN (TEDIT.DELETE STREAM)			  (TEDIT.INSERT STREAM correction)			  (RETURN (NCHARS correction])(French.LCase  [LAMBDA (w)                                                (* mk: "13-Sep-85 17:53")    (PROG (tail (x (L-CASE w)))          (SETQ tail (OR (SUBSTRING x 2 -1)			 ""))          (RETURN (COND		    ((STREQUAL (SETQ w (SUBSTRING w 1 1))			       (SUBSTRING x 1 1))		      (LIST x))		    (T (SELECTQ (MKATOM w)				(A (for i in (QUOTE (a ÿñ£ÿ  ÿñ¡ÿ )) collect (CONCAT i tail)))				(E (for i in (QUOTE (e ÿñ²ÿ  ÿñµÿ  ÿñ±ÿ  ÿñ°ÿ )) collect (CONCAT i tail)))				(I (for i in (QUOTE (i ÿñÀÿ  ÿñÄÿ )) collect (CONCAT i tail)))				(O (for i in (QUOTE (o ÿñÑÿ )) collect (CONCAT i tail)))				(U (for i in (QUOTE (u ÿñáÿ  ÿñßÿ )) collect (CONCAT i tail)))				x]))(DEFINEQ(SimpleStem.AddEntry  [LAMBDA (dict expo canonicalForm stemForm)                 (* mk: "19-Sep-85 16:35")    (SimpleStem.Analyze dict [FUNCTION (LAMBDA (entry canonicalForm stemForm)			    (COND			      (stemForm (replace (Stem expo) of entry with expo]			T canonicalForm stemForm])(SimpleStem.Analyze  [LAMBDA (dict fn createEntry canonicalForm stem)           (* mk: "19-Sep-85 17:01")    (bind entry for cf in (fetch (Analyzer contents) of dict)       when (OR (NOT canonicalForm)		(EQUAL canonicalForm (fetch (CanonicalForm form) of cf)))       do [for s in (fetch (CanonicalForm stems) of cf) when (OR (NOT stem)								 (EQUAL stem (fetch (Stem form)										of s)))	     do (APPLY* fn s canonicalForm stem)		(AND stem (RETURN))	     finally (COND		       ((NOT createEntry))		       ((NOT stem)			 (ERROR "No stem form given for new entry in SimpleStemLookup"))		       (T (push (fetch (CanonicalForm stems) of cf)				(SETQ entry (create Stem						    form _ stem)))			  (APPLY* fn entry canonicalForm stem]	  (AND canonicalForm (RETURN))       finally           (* * This code can be executed only if no canonical form was found. It creates a new entry for the canoncal form 	  with a subentry for the stem.)	       (COND		 ((NOT createEntry))		 ((NOT canonicalForm)		   (ERROR "No canonical form given for new entry in SimpleStemLookup"))		 ((NOT stem)		   (ERROR "No stem form given for new entry in SimpleStemLookup"))		 (T [push (fetch (Analyzer contents) of dict)			  (create CanonicalForm				  form _ canonicalForm				  stems _ (LIST (SETQ entry (create Stem								    form _ stem]		    (APPLY* fn entry canonicalForm stem])(SimpleStem.New  [LAMBDA (name)                                             (* mk: "19-Sep-85 16:35")    (create Dict	    name _ name (SETQ lookupFn (FUNCTION SimpleStem.Analyze))	    (SETQ addEntryFn (FUNCTION SimpleStem.AddEntry]))[DECLARE: EVAL@COMPILE (RECORD CanonicalForm (form . stems))(RECORD Stem (form . expo))](DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA Analyzer.Prop))(PUTPROPS ANALYZER COPYRIGHT ("Xerox Corporation" 1985 1986))(DECLARE: DONTCOPY  (FILEMAP (NIL (6479 20078 (Analyzer.DefaultCorrections 6489 . 10780) (Analyzer.DefaultNextWord 10782 . 12418) (Analyzer.DefaultAddEntry 12420 . 12631) (Analyzer.DefaultAnalyze 12633 . 16591) (Analyzer.DefaultProofread 16593 . 19067) (Analyzer.DefaultLoadWordList 19069 . 19493) (Analyzer.DefaultStoreWordList 19495 . 20076)) (20079 21190 (Analyzer.Prop 20089 . 20617) (Analyzer.PushProp 20619 . 21188)) (22057 22487 (STREAM.FETCHSTRING 22067 . 22485)) (23079 27125 (Analyzer.CorruptWord 23089 . 26907) (\Analyzer.NewCorruption 26909 . 27123)) (27155 28402 (Analyzer.Establish 27165 . 27676) (AnalyzerForStream 27678 . 27920) (Analyzer.QuitFn 27922 . 28400)) (28403 36855 (TEdit.ProofreadMenu 28413 . 30920) (TEdit.Correct 30922 . 31959) (TEdit.SetAnalyzer 31961 . 35241) (TEdit.LoadWordList 35243 . 35962) (TEdit.StoreWordList 35964 . 36853)) (38166 43719 (Analyzer.GenerateForms 38176 . 39697) (OCR.Correct 39699 . 42869) (French.LCase 42871 . 43717)) (43720 45946 (SimpleStem.AddEntry 43730 . 44050) (SimpleStem.Analyze 44052 . 45678) (SimpleStem.New 45680 . 45944)))))STOP