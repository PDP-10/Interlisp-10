<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>SOURCES>LISPDMC.DM!1>LFLOAT.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">Title[LFloat.mc, February 23, 1983  2:54 PM, Masinter];<br>* Lisp floating point operations<br>*-----------------------------------------------------------<br>   InsSet[LispInsSet, 1];<br><br>:if[NOFLOATING];<br>ufnOPs[</span><span style="font: 10pt monospace">350</span><span style="font: 10pt serif">];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* FPLUS<br>ufnOPs[351];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* FDIFFERENCE<br>ufnOPs[</span><span style="font: 10pt monospace">352</span><span style="font: 10pt serif">];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* FTIMES<br>ufnOPs[</span><span style="font: 10pt monospace">353</span><span style="font: 10pt serif">];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* FQUOTIENT<br>ufnOPs[</span><span style="font: 10pt monospace">362</span><span style="font: 10pt serif">];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* FGREATERP<br></span><span style="font: 10pt monospace"><br>UfnOps[354];</span><span class="tab" val="67"></span><span style="font: 10pt monospace">* \UNBOXFPLUS<br>UfnOps[355];</span><span class="tab" val="67"></span><span style="font: 10pt monospace">* \UNBOXFDIFFERENCE<br>UfnOps[356];</span><span class="tab" val="67"></span><span style="font: 10pt monospace">* \UNBOXFTIMES<br>UfnOps[357];</span><span class="tab" val="67"></span><span style="font: 10pt monospace">* \UNBOXFQUOTIENT<br><br>UfnOps[364];</span><span class="tab" val="67"></span><span style="font: 10pt monospace">* \UNBOXFGREATERP<br></span><span style="font: 10pt serif"><br>:else;<br><br>* Local R-register usage:<br>SetRMRegion[BBRegs];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Overlay BitBlt registers<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[ExpSign1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Exponent and sign of argument 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[Frac1H];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fraction of argument 1 (high part)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[Frac1L];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* (low part)<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[ExpSign2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Argument 2 ...<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[Frac2H];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[Frac2L];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[FTemp0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Temporaries<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[FTemp1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RVN[FTemp2];<br><br><br>TOPLEVEL;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">KnowRBase[LTEMP0];<br><br>*-----------------------------------------------------------<br>regOP1[351, StackM2BR, opFDIFFERENCE, 0];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">KnowRBase[LTEMP0];<br><br>opFDIFFERENCE:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br>KnowRBase[FTemp0];<br>    ExpSign2&larr; (ExpSign2)+1, Branch[FAddZeroR]; * Flip sign of arg 2 and add<br>   ExpSign2&larr; (ExpSign2)+1, Branch[FAddNonZero];<br><br>*-----------------------------------------------------------<br>regOP1[355, StackM2BR, opUNBOXFDIFF, 1]; KnowRBase[LTEMP0];<br><br>opUNBOXFDIFF:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNPACK];<br>KnowRBase[FTemp0];<br>    ExpSign2&larr; (ExpSign2)+1, Branch[FAddZeroR]; * Flip sign of arg 2 and add<br>   ExpSign2&larr; (ExpSign2)+1, Branch[FAddNonZero];<br>*-----------------------------------------------------------<br>regOP1[</span><span style="font: 10pt monospace">350</span><span style="font: 10pt serif">, StackM2BR, opFPLUS2, 0]; KnowRBase[LTEMP0];<br><br>opFPLUS2:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br>KnowRBase[FTemp0];<br>FAddZeroR:<br>    PD&larr; (Stack&+2)+(Stack&+2), Branch[FAddZero];<br><br>%<br>Difference between exponents is the amount of unnormalization required. The low 7 bits of ExpSign1 contain either 4 or 5, whereas the low 7 bits of ExpSign2 contain 0, 1, or 2.  Thus subtracting ExpSign2 from ExpSign1 cannot cause a carry out of the low 7 bits. Furthermore, the low bit gets the xor of the two signs, useful later when determining whether to add or subtract the fractions.<br>%<br><br>FAddNonZero:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; ExpSign1;<br>FAddNZ2:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign2&larr; T&larr; T-(Q&larr; ExpSign2);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp1&larr; A0, Q RSH 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+T, DblBranch[UnNorm1, UnNorm2, Carry&rsquo;];<br><br><br>*-----------------------------------------------------------<br>regOP1[354, StackM2BR, opUNBOXFPLUS, 1]; KnowRBase[LTEMP0];<br>opUNBOXFPLUS:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNPACK];<br>KnowRBase[FTemp0];<br>    PD&larr; (Stack&+2)+(Stack&+2), Branch[FAddZero]; <br>    T&larr; ExpSign1, branch[FAddNZ2];<br><br>*-----------------------------------------------------------<br>* Un-normalize operand 1.  T[0:7] has negative of right-shift count.<br><br>UnNorm1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (B&larr; Q) LSH 1, Branch[.+2, R even]; * Result exponent is Exp2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)+1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* But preserve Sign1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(LShift[20, 10]C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(LShift[20, 10]C), Branch[UnNorm1le20, Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(LShift[20, 10]C), Branch[UnNorm1le40, Carry];<br><br>* Exponents differ by more than 40.<br>* Just zero operand 1, but be sure to set the sticky bit.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; 1C;<br>ZeroFrac1H:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; A0, Branch[UnNormDone];<br><br>* Exponent difference IN [1..20].  Let n = the difference.<br>* T[0:7] now has 40 - n, i.e., IN [20..37], so SHA=R, SHB=T.<br>* This is correct shift control for LCY[R, T, 20-n] = RCY[T, R, n]<br>UnNorm1le20:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac1L, ShC&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; ShiftNoMask[FTemp1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* PD&larr; RCY[Frac1L, 0, [1..20]]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac1H, FreezeBC;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; ShiftNoMask[Frac1L],</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Frac1L&larr; RCY[Frac1H, Frac1L, [1..20]]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.+2, ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Test bits shifted out of Frac1L<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L) OR (1C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Nonzero bits lost, set sticky bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; A0, Q&larr; Frac2L;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; ShiftNoMask[Frac1H],</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Frac1H&larr; RCY[0, Frac1H, [1..20]]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[UnNormDone1];<br><br>* FAdd/FSub (cont&rsquo;d)<br><br>* Exponent difference IN [21..40].  Let n = the difference.<br>* T[0:7] now has 60 - n, i.e., IN [20..37], so SHA=R, SHB=T.<br>* This is correct shift control for LCY[R, T, 40-n] = RCY[T, R, n-20]<br>UnNorm1le40:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac1H, ShC&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; ShiftNoMask[FTemp1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; RCY[Frac1H, 0, [1..20]]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; T OR (Frac1L);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Bits lost from Frac1H and Frac1L<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; A0, FreezeBC;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; ShiftNoMask[Frac1H],</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Frac1L&larr; RCY[0, Frac1H, [1..20]]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[ZeroFrac1H, ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L) OR (1C),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Nonzero bits lost, set sticky bit<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[ZeroFrac1H];<br><br><br>* Un-normalize operand 2.  T[0:7] has right-shift count, and T[8:15] is IN [0..12].<br>UnNorm2:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (12S)-T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Negate count; ensure no borrow by ALU[8:15]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(LShift[20, 10]C), Branch[UnNormDone, Carry]; * Branch if exponents equal<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(LShift[20, 10]C), Branch[UnNorm2le20, Carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(LShift[20, 10]C), Branch[UnNorm2le40, Carry];<br><br>* Exponents differ by more than 40.<br>* Just zero operand 2, but be sure to set the sticky bit.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; 1C, Branch[ZeroFrac2H];<br>UnNorm2gr40:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; 1C;<br>ZeroFrac2H:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H&larr; A0, Branch[UnNormDone];<br><br>* Exponent difference in [1..20].  Let n = the difference.<br>* T[0:7] now has 40 - n, i.e., in [20..37], so SHA=R, SHB=T.<br>* This is correct shift control for LCY[R, T, 20-n] = RCY[T, R, n]<br>UnNorm2le20:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac2L, ShC&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; ShiftNoMask[FTemp1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* PD&larr; RCY[Frac2L, 0, [1..20]]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac2H, FreezeBC;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; ShiftNoMask[Frac2L],</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Frac2L&larr; RCY[Frac2H, Frac2L, [1..20]]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.+2, ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Test bits shifted out of Frac2L<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; (Frac2L) OR (1C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Nonzero bits lost, set sticky bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; A0, Q&larr; Frac2L;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac2H&larr; ShiftNoMask[Frac2H],</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Frac2H&larr; RCY[0, Frac2H, [1..20]]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[UnNormDone2];<br><br>* Exponent difference IN [21..40].  Let n = the difference.<br>* T[0:7] now has 60 - n, i.e., IN [20..37], so SHA=R, SHB=T.<br>* This is correct shift control for LCY[R, T, 40-n] = RCY[T, R, n-20]<br>UnNorm2le40:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac2H, ShC&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; ShiftNoMask[FTemp1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; RCY[Frac2H, 0, [1..20]]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; T OR (Frac2L);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Bits lost from Frac2H and Frac2L<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; A0, FreezeBC;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; ShiftNoMask[Frac2H],</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Frac1L&larr; RCY[0, Frac1H, [1..20]]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[ZeroFrac2H, ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; (Frac2L) OR (1C),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Nonzero bits lost, set sticky bit<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[ZeroFrac2H];<br><br>* Now decide whether fractions are to be added or subtracted.<br>UnNormDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; Frac2L;<br>UnNormDone1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac2H;<br>UnNormDone2:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign2, DblBranch[SubFractions, AddFractions, R odd]; * Subtract if signs differ<br><br>* FAdd/FSub (cont&rsquo;d)<br><br>* Signs equal, add fractions.  T = Frac2H, Q = Frac2L.<br>AddFractions:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L)+Q;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; T&larr; (Frac1H)+T, XorSavedCarry;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (Frac1L) AND (377C), Branch[FRePackNZ1, Carry&rsquo;];<br><br><br>* If carry out of high result, must normalize right 1 position.<br>* Need not restore leading "1", since rounding cannot cause a carry into this<br>* position, and the leading bit is otherwise ignored during repacking.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; (Frac1H) RSH 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; RCY[T, Frac1L, 1], Branch[.+2, R even];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L) OR (1C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Preserve sticky bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)+(LShift[1, 7]C), Branch[FRePackNonzero];<br><br>* Signs differ, subtract fractions.  T = Frac2H, Q = Frac2L.<br>SubFractions:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L)-Q;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Frac1H)-T-1, XorSavedCarry;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; A0, FreezeBC, Branch[Normalize, Carry];<br><br>* If carry, Frac1 was &gt;= Frac2, so result sign is Sign1.<br>* If no carry, sign of the result changed.  Must negate fraction and<br>* complement sign to restore sign-magnitude representation.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)+1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (0S)-(Frac1L);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Frac1H)-T-1, XorSavedCarry, Branch[Normalize];<br><br><br>* Add/Subtract with zeroes:<br>* One or both of the operands is zero.  ALU = (high word of arg1) LSH 1.  This is<br>* zero iff arg1 is zero (note that we don&rsquo;t need to worry about denormalized numbers,<br>* since they have been filtered out already).<br>* StkP has been advanced to point to high word of arg2.<br>FAddZero:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Stack&-1)+(Q&larr; Stack&-1),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; (high word of arg2) LSH 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[FAddArg2Zero, ALU#0]; * arg1#0 =&gt; arg2=0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt&larr; Stack&-1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Cnt&larr; low word of arg2<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[FAddArg1Zero, ALU#0]; * arg2#0 =&gt; arg1=0<br><br>* Both args are zero: result is -0 if both args negative, else +0.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&larr; (Stack) AND Q, branch[.storefloat];<br><br>* Arg 1 is zero and arg 2 nonzero: result is arg 2.<br>* Note: must re-pack sign explicitly, since FSub might have flipped it.<br>FAddArg1Zero:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; RCY[ExpSign2, T, 1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Insert Sign2 into high result<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1&larr; Cnt, branch[.storefloat];<br><br>* Arg 2 is zero and arg 1 nonzero: result is arg 1.<br>FAddArg2Zero:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP-1, branch[.storefloat];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Result already on stack<br><br>*-----------------------------------------------------------<br>regOP1[</span><span style="font: 10pt monospace">352</span><span style="font: 10pt serif">, StackM2BR, opFTIMES2, 0]; KnowRBase[LTEMP0];<br><br>opUNBOXFTIMES:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNPACK];<br>KnowRBase[FTemp0];<br>    T&larr; ExpSign2, Branch[MulArgZero]; * +1: at least one arg is zero<br>    T&larr; (ExpSign2)-(LShift[200, 7]C), branch[MulNormal];<br><br>*-----------------------------------------------------------<br>regOP1[356, StackM2BR, opUNBOXFTIMES, 1]; KnowRBase[LTEMP0];<br><br>opFTIMES2:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br>KnowRBase[FTemp0];<br>    T&larr; ExpSign2, Branch[MulArgZero]; * +1: at least one arg is zero<br><br>* XOR signs and add exponents.  Subtract 200 from exponent to correct for doubling bias,<br>* and add 1 to correct for 1-bit right shift of binary point during multiply<br>* (binary point of product is between bits 1 and 2 rather than between 0 and 1).<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (ExpSign2)-(LShift[200, 7]C); * Subtract 200 from ExpSign2[0:8]<br>MulNormal:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(LShift[1, 7]C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* And add 1 (can&rsquo;t combine the constants, alas)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)+T;<br><br>* Now do the multiplications.  Initial registers:<br>*   Frac1H = F1H (high 16 bits of arg 1)<br>*   Frac1L = F1L,,0 (low 8 bits of arg 1)<br>*   Frac2H = F2H (high 16 bits of arg 2)<br>*   Frac2L = F2L,,0 (low 8 bits of arg 2)<br>* Intermediate register usage:<br>*   Frac1L and FTemp0 accumulate sticky bits<br>*   FTemp2 is the initial product register for the Multiply subroutines.<br><br>* Do 8-step multiply of F1L*F2L, with initial product of zero.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; T&larr; RSH[Frac1L, 10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Frac1L&larr; 0,,F1L<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; RSH[Frac2L, 10],</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Frac2L&larr; 0,,F2L<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[MultTx2L8I];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Force 8 iterations,initial product 0<br><br>* Low product is FTemp2[8:15],,Q[0:7].  FTemp2[0:7] = Q[8:15] = 0.<br>* Do 8-step multiply of F2H*F1L, using high 8 bits of previous result as initial product.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp0&larr; Q;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Save low 8 bits for later use as sticky bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac2H, Cnt&larr; 6S, Call[MultTx1L];<br><br>* Cross product is FTemp2[0:15]..Q[0:7].  Q[8:15] = 0.<br>* Do 8-step multiply of F1H*F2L, with initial product of zero.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; Q;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Frac1L&larr; low 8 bits of cross product<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac1H, ShC&larr; T,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* ShC&larr; high 16 bits of cross product<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[MultTx2L8I];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Force 8 iterations,initial product 0<br><br>* Cross product is FTemp2[0:15]..Q[0:7].  Q[8:15] = 0.<br>* Add cross products, propagate carries, and merge sticky bits.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Frac1L)+Q;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Add low 8 bits of cross products<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (FTemp0) OR T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Merge with sticky bits from low product<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; ShC, Branch[.+2, ALU=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Collapse to single sticky bit in Frac1L[15]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; 1C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp2&larr; (FTemp2)+T, XorSavedCarry; * Add high 16 bits of cross products<br><br>* Do 16-step multiply of F1H*F2H, using high 16 bits of previous result as initial product.<br>* Frac1H&larr; (-1)+(carry out of sum of low and cross products).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; B&larr; Frac1H, Cnt&larr; 16S;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; T-T-1, XorSavedCarry, Call[MultTx2H];<br><br>* Final result is T,,Q.  Merge in the sticky bit from low-order products and exit.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L) OR Q, DispTable[1, 2, 2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Frac1H)+T+1, Branch[Normalize], DispTable[1, 2, 2];<br><br>* One or both of the arguments is zero.  Return zero with appropriate sign.<br>* T = ExpSign2<br>MulArgZero:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1) XOR T, Branch[FRePackZero];<br><br>*-----------------------------------------------------------<br>* Unsigned multiply subroutines<br>* Entry conditions (except as noted):<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt = n-2, where n is the number of iterations<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T = multiplicand<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">FracXX = multiplier (register depends on entry point);<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">leftmost (16D-n) bits must be zero.<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp2 = initial product (to be added to low 16 bits of final product)<br>* Exit conditions:<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">Product right-justified in T[0:15],,Q[0:n-1]<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">Q[n:15] = 0<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp2 = copy of T<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">Carry = 1 iff T[0] = 1<br>* If n = 16D, caller must squash Multiply dispatches in the 2 instructions<br>* following the Call.<br>* Timing: n+2<br>*-----------------------------------------------------------<br>Subroutine;<br><br>* Entry point for multiplier = Frac1L<br>MultTx1L:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; Frac1L, DblBranch[MultiplierO, MultiplierE, R odd];<br><br>* Entry point for multiplier = Frac2L.<br>* This entry forces 8 iterations with an initial product of zero.<br>MultTx2L8I:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp2&larr; A0, Cnt&larr; 6S;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; Frac2L, DblBranch[MultiplierO, MultiplierE, R odd];<br><br>* Entry point for multiplier = Frac2H<br>MultTx2H:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; Frac2H, DblBranch[MultiplierO, MultiplierE, R odd];<br><br>* Execute first Multiply purely for its side-effects (dispatch and shift Q)<br>MultiplierE:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; A0, Multiply, Branch[FM0];<br>MultiplierO:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; A0, Multiply, Branch[FM1];<br><br>DispTable[4];<br><br>* here after Q[14] was 0 (no add) and continue<br>FM0:</span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp2&larr; A&larr; FTemp2, Multiply, DblBranch[FM0E, FM0, Cnt=0&-1];<br>* here after Q[14] was 0 (no add) and exit<br>FM0E:</span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp2&larr; T&larr; A&larr; FTemp2, Multiply, Return;<br><br>* here after Q[14] was 1 (add) and continue<br>FM1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp2&larr; (FTemp2)+T, Multiply, DblBranch[FM0E, FM0, Cnt=0&-1];<br>* here after Q[14] was 1 (add) and exit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FTemp2&larr; T&larr; (FTemp2)+T, Multiply, Return;<br><br>TopLevel;<br><br><br>*-----------------------------------------------------------<br>regOP1[</span><span style="font: 10pt monospace">357</span><span style="font: 10pt serif">, StackM2BR, opUNBOXFQUO, 1]; KnowRBase[LTEMP0];<br>opUNBOXFQUO:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNPACK];<br>KnowRBase[FTemp0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> T&larr; ExpSign2, Branch[DivArgZero]; <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (ExpSign2)-(LShift[200, 7]C), branch[FDivNormal]; <br><br>*-----------------------------------------------------------<br>regOP1[</span><span style="font: 10pt monospace">353</span><span style="font: 10pt serif">, StackM2BR, opFQUOTIENT, 0]; KnowRBase[LTEMP0];<br>opFQUOTIENT:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br>KnowRBase[FTemp0];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> T&larr; ExpSign2, Branch[DivArgZero]; * +1: at least one arg is zero<br><br>* XOR signs and subtract exponents.<br>* Add 200 to resulting exponent to correct for cancellation of bias.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (ExpSign2)-(LShift[200, 7]C); * Subtract 200 from ExpSign2[0:8]<br>FDivNormal:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)-T;<br><br>* First, transfer dividend to Frac2H ,, Frac2L and divisor to T ,, Q,<br>* and unnormalize both of them by one bit so that significant dividend bits<br>* aren&rsquo;t lost during the division.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; (Frac1H) RSH 1, Branch[.+2, R odd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Frac1L) RSH 1, Branch[.+2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; ((Frac1L)+1) RCY 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Know Frac1L is even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; T, Q&larr; Frac2L;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; A&larr; Frac2H, Multiply;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T,,Q &larr; (Frac2H ,, Frac2L) RSH 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Know Q[14]=0, so can&rsquo;t dispatch<br><br>* Now do the division.<br>* Must do total of 26 iterations: 24 for quotient bits, +1 more significant<br>* bit in case we need to normalize, +1 bit for rounding.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H&larr; Frac1H, Call[DivFrac];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Do 16 iterations<br>Subroutine;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; Frac1L, CoReturn;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Preserve high quotient; do 10 more iterations<br><br>* We may have subtracted too much (or not added enough) in the last iteration.<br>* If so, adjust the remainder by adding back the divisor.  Since the remainder<br>* got shifted left one bit, we must double the divisor first.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; A&larr; T, Divide, Frac1L, Branch[NoRemAdjust, R odd]; * T,,Q &larr; (T,,Q) LSH 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; (Frac2L)+Q;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H&larr; T&larr; (Frac2H)+T, XorSavedCarry, Branch[.+2];<br><br>* Left-justify low quotient bits and zero sticky bit.<br>* Then, if the remainder is nonzero, set the sticky bit.<br>* Then normalize if necessary.  We should have to left-shift at most once,<br>* since the original operands were normalized.<br>NoRemAdjust:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac2H;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (Frac2L) OR T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; LSH[Frac1L, 6], Branch[.+2, ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L)+1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Set sticky bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac1H, Branch[Normalize];<br><br>* One or both of the arguments is zero.<br>* Trap if divisor is zero; return zero with appropriate sign otherwise.<br>DivArgZero:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H, Branch[MulArgZero, R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.floatfail];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Division by zero<br><br>*-----------------------------------------------------------<br>DivFrac:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Divide fractions<br>* Enter: Frac2H ,, Frac2L = dividend (high-order bit must be zero)<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T ,, Q = divisor (high-order bit must be zero)<br>* Exit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H ,, Frac2L = remainder, left-justified<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L = quotient bits (see below)<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T and Q unchanged<br>* When first called, executes 16 iterations and returns 16 high-order quotient bits.<br>* When resumed with CoReturn, executes 10 more iterations and returns 10 low-order<br>* quotient bits right-justified (other bits garbage).<br>* Timing: first call: 66; resumption: 41<br>*-----------------------------------------------------------<br>Subroutine;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt&larr; 17S;<br><br>* Previous quotient bit was a 1, i.e., dividend was &gt;= divisor.<br>* Subtract divisor from dividend and left shift dividend.<br>DivSubStep:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; ((Frac2L)-Q) LSH 1;<br>DivSubStep1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H&larr; (Frac2H)-T-1, XorSavedCarry, DblBranch[DivSh1, DivSh0, ALU&lt;0];<br><br>* Previous quotient bit was a 0, i.e., dividend was &lt; divisor (subtracted<br>* too much).  Add divisor to dividend and left shift dividend.<br>DivAddStep:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; ((Frac2L)+Q) LSH 1;<br>DivAddStep1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H&larr; (Frac2H)+T, XorSavedCarry, DblBranch[DivSh1, DivSh0, ALU&lt;0];<br><br>* Shifted a zero out of low dividend (ALU&lt;0 tested unshifted result).<br>DivSh0:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H&larr; (Frac2H)+(Frac2H), DblBranch[DivQuot1, DivQuot0, Carry];<br><br>* Shifted a one out of low dividend (ALU&lt;0 tested unshifted result).<br>DivSh1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H&larr; (Frac2H)+(Frac2H)+1, DblBranch[DivQuot1, DivQuot0, Carry];<br><br>* If the operation generated no carry then we have subtracted too much.<br>* Shift a zero into the quotient and add the divisor next iteration.<br>DivQuot0:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L)+(Frac1L),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Shift zero into quotient<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[DivAddStep, Cnt#0&-1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt&larr; 11S, CoReturn;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; ((Frac2L)+Q) LSH 1, Branch[DivAddStep1];<br><br>* If the operation generated a carry then we have not subtracted too much.<br>* Shift a one into the quotient and subtract the divisor next iteration.<br>DivQuot1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L)+(Frac1L)+1,</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Shift one into quotient<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[DivSubStep, Cnt#0&-1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt&larr; 11S, CoReturn;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; ((Frac2L)-Q) LSH 1, Branch[DivSubStep1];<br><br>TopLevel;<br><br>*-----------------------------------------------------------<br>regOP1[</span><span style="font: 10pt monospace">364</span><span style="font: 10pt serif">, StackM2BR, opUNBOXFGTP, noNData]; KnowRBase[LTEMP0];<br>opUNBOXFGTP:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">KnowRBase[FTemp0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack&+2, Branch[FGT2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* +1: at least one arg is zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack&+2, Branch[FGT2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; high arg1<br>*-----------------------------------------------------------<br>regOP1[</span><span style="font: 10pt monospace">362</span><span style="font: 10pt serif">, StackM2BR, opFGREATERP, noNData]; KnowRBase[LTEMP0];<br>opFGREATERP:<br>*-----------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">KnowRBase[FTemp0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> T&larr; Stack&+2, Branch[FGT2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* +1: at least one arg is zero<br><br>* First compare the signs<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack&+2;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; high arg1<br>FGT2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; T XOR (Q&larr; Stack&-1);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Q&larr; high arg2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack&-1, FreezeBC, Branch[FCompSignsDiff, ALU&lt;0]; * T&larr; low arg2<br><br>* Signs equal, compare magnitudes.  Q = high arg2, T = low arg2, StkP -&gt; high arg1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (Stack&-1)-Q, Branch[.+2, ALU#0]; * Compute high (arg1 - arg2)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (Stack)-T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* High parts equal, compute low (arg1 - arg2)<br><br>* Carry = 1 if arg1 &gt;= arg2 when treated as unsigned numbers.<br>* The sense of this is inverted if the arguments are in fact negative, since<br>* the representation is sign-magnitude rather than twos-complement.<br>FCompTest:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)+1, XorSavedCarry, Branch[FCompE, ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1, DblBranch[FCompL, FCompG, R odd];<br><br>* Signs unequal.  Unless both arguments are zero, return "less" if arg1 is negative,<br>* else "greater".  Q = high arg2.<br>FCompSignsDiff:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; T-T, StkP-1, Q LSH 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Carry&larr; 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (Frac1H) OR Q, Branch[FCompTest]; * ALU=0 iff both args are zero<br><br>FCompL:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&larr; -1C, branch[.fgtpret];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* arg1 &lt; arg2<br>FCompE:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&larr; A0, branch[.fgtpret];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* arg1 = arg2<br>FCompG:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&larr; 1C, branch[.fgtpret];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* arg1 &gt; arg2<br><br>.fgtpret: branch[.floatfail];</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br><br><br>SUBROUTINE;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">KnowRBase[LTEMP0];<br>*-----------------------------------------------------------<br>.FUNBOX2: GLOBAL, <br>* Pop and unpack two floating-point arguments.<br>* Call:<br><br>*   memBase&larr; StackM2BR;<br>*   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNBOX2];<br><br>* Exit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign2, Frac2H, Frac2L set up with argument 2 (right); ExpSign2[13:14]=00<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1, Frac1H, Frac1L set up with argument 1 (left); ExpSign1[13:14]=10<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP addresses high word of arg 1 (i.e., =2 if minimal stack)<br><br><br>* Returns +1: at least one argument is zero<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">+2: both arguments are nonzero<br>* Returns only for normal numbers or true zero.<br>* Traps if denormalized, infinity, or Not-a-Number.<br>* Clobbers Q<br><br>   LTEMP2&larr; Md, T&larr; (fetch&larr; T) - (3c);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP2&larr; YHi<br>   LTEMP3&larr; Md, T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP3&larr; YLo<br>   T&larr; LTEMP0&larr; Md, fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T, LTEMP0&larr; XHi<br>   LTEMP1&larr; Md, memBase&larr; tyBaseBR; </span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP1&larr; XLo<br><br>   T&larr; rcy[T, LTEMP1, 11];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T &larr; type table pointer for X<br>   fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br>   T&larr; Md, memBase&larr; ScratchLZBR;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T &larr; ntypx(X)<br>   pd&larr; (T) - (floatptype);<br>   branch[.+2, alu=0], BrHi&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.FLOATFAIL];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* nope, not fixp<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (2c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP&larr; T;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (FETCH&larr; LTEMP1) + 1;<br>   Stack&-1&larr; MD, fetch&larr; T;<br>   Stack&+3&larr; Md;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* push unboxed X<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   T&larr; LTEMP2, memBase&larr; tyBaseBR;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; YHi<br>   T&larr; rcy[T, LTEMP3, 11];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T &larr; type table pointer for Y<br>   fetch&larr; T;<br>   T&larr; Md, memBase&larr; ScratchLZBR;<br>   pd&larr; (T) - (floatptype);<br>   branch[.+2, alu=0], BrHi&larr; LTEMP2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.FLOATFAIL];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* nope, not floatp<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (FETCH&larr; LTEMP3) + 1;<br>   T&larr; Stack&-1&larr; MD, fetch&larr; T;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   Stack&larr; Md, RBASE&larr; RBASE[FTEMP0], branch[FunPack2];<br><br><br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">KnowRBase[LTEMP0];<br><br>.FUNPACK:<br>* unpack two floating-point arguments.<br>* Call:<br>*   memBase&larr; StackM2BR;<br>*   T&larr; (fetch&larr; TSP) + 1; LEFT&larr; (LEFT) + 1, SCall[.FUNPACK];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; (2c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP&larr; LTEMP0;<br><br>    Stack&-1&larr; Md, T&larr; (fetch&larr; T) - (3c);<br>    Stack&+3&larr; Md, T&larr; (fetch&larr; T) + 1;<br>    T&larr; Stack&-1&larr; Md, fetch&larr; T;<br>    Stack&larr; Md, RBase&larr; RBase[FTEMP0], branch[FUnPack2];<br><br><br><br>FUnPack2:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign2&larr; T AND (177600C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; RCY[T, Stack, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Garbage bit and top 15 fraction bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign2&larr; (ExpSign2) AND (77777C), * Exponent in bits 1:8, all else zero<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.+2, R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Branch if negative<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign2&larr; (ExpSign2)+(200C),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Positive, add 1 to exponent, B15 &larr; 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">DblBranch[Exp2Zero, .+2, ALU=0]; * Branch if exponent zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign2&larr; (ExpSign2)+(201C),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Negative, add 1 to exponent, B15 &larr; 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[Exp2Zero, ALU=0]; * Branch if exponent zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H&larr; T OR (100000C),</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Prefix explicit "1." to fraction<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[Exp2NaN, ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Branch if exponent was 377<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LSH[Stack&-1, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Left-justify low 8 fraction bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack&-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Now do arg 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; T AND (177600C), Branch[FUnPack1a];<br><br>Exp2Zero:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2H&larr; (Stack&-1) OR T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* See if entire fraction is zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac2L&larr; A0, Branch[Arg2DeNorm, ALU#0]; * Branch if not true zero<br>TopLevel;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack&-1, Q&larr; Link, SCall[FUnPack1]; * Zero, unpack other arg<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Link&larr; Q, Branch[.+2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Return +1 regardless of what FUnpack1 did<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Link&larr; Q;<br>Subroutine;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign2&larr; (ExpSign2) AND (1C), Return;<br><br>TopLevel;<br><br>Arg2DeNorm:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.floatfail];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Denormalized number<br>Exp2NaN:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.floatfail];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Not-a-Number<br><br>*-----------------------------------------------------------<br>FUnPack1:<br>* Pop and unpack one floating-point argument.<br>* Enter: T = top-of-stack, StkP points to TOS-1<br>* Exit:</span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1, Frac1H, Frac1L set up with argument<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP addresses high word of arg 1 (i.e., =2 if minimal stack)<br>* Call by: SCall[FUnPack1]<br>* Returns +1: argument is zero<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">+2: argument is nonzero<br>* Returns only for normal numbers or true zero.<br>* Traps if denormalized, infinity, or Not-a-Number.<br>* Timing: 7 cycles normally.<br>*-----------------------------------------------------------<br>Subroutine;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; T AND (177600C), Global;<br>FUnPack1a:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; RCY[T, Stack, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Garbage bit and top 15 fraction bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1) AND (77777C), * Exponent in bits 1:8, all else zero<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.+2, R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Branch if negative<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)+(204C),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Positive, add 1 to exponent, [13:14]&larr;10, [15]&larr;0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">DblBranch[Exp1Zero, .+2, ALU=0]; * Branch if exponent zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)+(205C),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Negative, add 1 to exponent, [13:14]&larr;10, [15]&larr;1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[Exp1Zero, ALU=0]; * Branch if exponent zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; T OR (100000C),</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Prefix explicit "1" to fraction<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[Exp1NaN, ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Branch if exponent was 377<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LSH[Stack&+1, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Left-justify low 8 fraction bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; T, Return[Carry&rsquo;];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Always skip (carry is always zero here)<br><br>Exp1Zero:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; (Stack&+1) OR T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* See if entire fraction is zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; A0, Branch[Arg1DeNorm, ALU#0]; * Branch if not true zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1) AND (1C), Return; * Zero, return +1<br><br>TopLevel;<br><br>Arg1DeNorm:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.floatfail];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Denormalized number<br>Exp1NaN:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.floatfail];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Not-a-Number<br><br><br>*-----------------------------------------------------------<br>Normalize:<br>* Normalize and re-pack floating-point result.<br>* Enter: ExpSign1, T, Frac1L contain unpacked result<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T = ALU = high fraction.<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP addresses high word of result (i.e., =2 if minimal stack)<br>* Timing: for nonzero result: 11 cycles minimum, +3 if need to normalize at all,<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">+2*(n MOD 16) if n&gt;1, where n is the number of normalization steps,<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">+3 if n&gt;15, +5 if need to round, +2 if rounding causes a carry<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">out of Frac1L, +1 or 2 in extremely rare cases.<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">For zero result: 6 cycles<br>*-----------------------------------------------------------<br><br>* See if result is already normalized or entirely zero.<br>* Note that we want the cases of no normalization, one-step normalization,<br>* and result entirely zero to be the fastest, since they are by far the most common.<br>* Therefore, do the first left shift in-line while branching on the other conditions.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; T OR (Q&larr; Frac1L),</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* ALU&larr; 0 iff entire fraction is 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[NormAlready, ALU&lt;0]; * Branch if already normalized<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; A&larr; T, Divide,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* (Frac1H,,Q) &larr; (T,,Q) LSH 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[NormalizeZero, ALU=0]; * Branch if fraction is zero<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)-(LShift[1, 7]C), * Subtract one from exponent<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[NormBegin, ALU#0]; * Branch if high fraction was nonzero<br><br>* If the high word of the fraction was zero, we discover that after having left-shifted<br>* the fraction once.  Effectively, left-shift the fraction 16 bits and subtract<br>* 16D from the exponent.  Actually, undo the first left shift and subtract only 15D<br>* from the exponent, in case the first left shift moved a one into the high fraction.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)+(LShift[1, 7]C); * Can&rsquo;t encode the constant I really want!<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)-(LShift[20, 7]C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; Frac1L;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Left-shift original fraction 16 bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; T, Branch[NormLoop];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Q&larr; 0<br><br>* In this loop, the exponent is in ExpSign1[0:8] and the fraction in Frac1H ,, Q.<br>* Left shift the fraction and decrement the exponent until the high-order bit<br>* of the fraction is a one.<br>NormBegin:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; A0, Frac1H, Branch[NormDone1, R&lt;0]; * Branch if one shift was enough<br>NormLoop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; A&larr; Frac1H, Divide, Branch[NormDone, R&lt;0]; * (Frac1H,,Q) &larr; (Frac1H,,Q) LSH 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)-(LShift[1, 7]C), Branch[NormLoop];<br><br>* When we bail out of the loop, the exponent is correct, but we have left-shifted<br>* the fraction one too many times.  Right-shift the fraction and exit.<br>NormDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; (Frac1H)-T, Multiply;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* (Frac1H,,Q) &larr; 1,,((Frac1H,,Q) RSH 1)<br>NormDone1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; Q, Branch[FRePackNonzero]; * Multiply dispatch pending!!<br><br>NormAlready:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; T, Branch[FRePackNonzero]; * Placement (sigh)<br><br>* Result was exactly zero: push +0 as answer.<br>NormalizeZero:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; A0, Branch[FRePackZero];<br><br>*-----------------------------------------------------------<br>FRePackNonzero:<br>* Re-pack nonzero floating-point result.<br>* Enter: ExpSign1, Frac1H, Frac1L contain unpacked result, which must be normalized but<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">need not have its leading "1" so long as rounding can&rsquo;t carry into this bit.<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP addresses high word of result (i.e., =2 if minimal stack)<br>* Timing: 9 cycles minimum, +5 if need to round, +2 if rounding causes a carry<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">out of Frac1L, +1 or 2 in extremely rare cases.<br>*-----------------------------------------------------------<br><br>* Prepare to round according to Round-to-Nearest convention.  Frac1L[8:15] are fraction<br>* bits that will be rounded off; result is exact only if these bits are zero.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (Frac1L) AND (377C), DispTable[1, 2, 2];<br>FRePackNZ1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1) OR (176C),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Put ones in all unused bits of ExpSign1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[NoRounding, ALU=0];<br><br>* Inexact result.  Round up if result is greater than halfway between representable<br>* numbers, down if less than halfway.  If exactly halfway, round in direction that makes<br>* least significant bit of result zero. Adding 1 at the Frac1L[8] position causes<br>* a carry into bit 7 iff the result is &gt;= halfway between representable numbers.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (Frac1L) AND (177C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L)+(200C), Branch[.+2, ALU#0];<br><br>* Exactly halfway.  But we have already rounded up.<br>* If the least significant bit was 1, it is now 0 (correct).<br>* If it was 0, it is now 1 (incorrect).  But in the latter case, no carries<br>* have propagated beyond the least significant bit, so...<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1L&larr; (Frac1L) AND NOT (400C); * Just zero the bit to fix it<br><br>* Now set the sticky flag and trap if appropriate.<br>* Note we have not propagated the carry out of the low word yet, so we must<br>* perform only logical ALU operations that don&rsquo;t clobber the carry flag.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; B&larr; Frac1H;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+1, RBase&larr; RBase[FTemp0],</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Prepare to do carry if appropriate<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[DoneRounding, Carry&rsquo;];<br><br>* There was a carry out of Frac1L.  Propagate it to Frac1H.<br>* If this causes a carry out of Frac1H, the rounded fraction is exactly 2.0, which<br>* we must normalize to 1.0; i.e., set fraction to 1.0 and increment exponent.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Frac1H&larr; T, Branch[.+2, Carry&rsquo;];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)+(LShift[1, 7]C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)-(LShift[2, 7]C), DblBranch[ExpOverflow, .+3, R&lt;0];<br><br>* Done rounding.  Check for exponent over/underflow, and repack and push result.<br>DoneRounding:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)-(LShift[2, 7]C), DblBranch[ExpOverflow, .+2, R&lt;0];<br>NoRounding:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExpSign1&larr; (ExpSign1)-(LShift[2, 7]C), * Subtract 2 from exponent<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[ExpOverflow, R&lt;0]; * Branch if exponent &gt; 377B originally<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LDF[Frac1H, 7, 10],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Extract high 7 fraction bits, exclude leading 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[ExpUnderflow, ALU&lt;0]; * Branch if exponent &lt; 2 originally<br><br>* At this point, ExpSign1[1:8] = desired exponent -1, and [9:15] = 176 if the<br>* sign is positive, 177 if negative.  Thus adding 2 (if positive) or 1 (negative)<br>* will correctly adjust the exponent and clear out [9:15].<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (ExpSign1)+T+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Merge exponent with fraction and add 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.+2, R odd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Branch if negative<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1&larr; T+1, Branch[.+2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Positive, add 1 more to finish fixing exponent<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1&larr; T OR (100000C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Negative, set sign bit of result<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Frac1H;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Construct low fraction<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; RCY[T, Frac1L, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1&larr; T, branch[.storefloat];<br><br>ExpUnderflow:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.floatfail];<br>ExpOverflow:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.floatfail];<br><br>*-----------------------------------------------------------<br>FRePackZero:<br>* Push a result of zero with the correct sign<br>* Enter: ExpSign1 has correct sign<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP addresses high word of result (i.e., =2 if minimal stack)<br>*-----------------------------------------------------------<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LSH[ExpSign1, 17];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Slide sign to bit 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Push true zero with correct sign<br>FRePackZ2:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1&larr; A0, branch[.storefloat];<br><br><br>.storefloat:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; ID, memBase&larr; StackBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.storeflunbox, alu#0], RBase&larr; RBase[LTEMP0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (TSP) - (4c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (store&larr; T) + 1, dbuf&larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (store&larr; T) + 1, dbuf&larr; Stack;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NARGS&larr; 2c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DEFLO&larr; HighByte[AT.MAKEFLOAT];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DEFLO&larr; (DEFLO) + (LowByte[AT.MAKEFLOAT]), branch[DOCALLPUNT];<br><br>.storeflunbox:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (TSP) - (4c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (store&larr; T) + 1, dbuf&larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (store&larr; T) + 1, dbuf&larr; Stack, NextOpCode;<br><br>.FLOATFAIL:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RBASE&larr; RBASE[LTEMP0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br><br>:ENDIF; * NOFLOATING;<br><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
