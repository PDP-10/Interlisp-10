<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>SOURCES>LISPDMC.DM!1>LBITBLT.mc</title>
  </head>
  <body>
    <div style="width: 499pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">Title[lbitblt.mc, December 7, 1982  1:11 PM, Masinter];<br>   InsSet[LispInsSet, 1];<br><br>regOP1[166, StackBR, opBITBLT, noNData];<br>*  dummy definition for alto bitblt:<br><br>BitBltSub:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Entry point<br>Subroutine;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&larr; A0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RETURN[alu=0];<br><br><br>   KnowRBase[LTEMP0];<br>   TOP LEVEL;<br><br><br><br>* Refer to the PrincOps for primary documentation.<br>* All numbers are octal except timings, which are decimal.<br><br>* Data structures:<br><br>* BitBltArg: TYPE = MACHINE DEPENDENT RECORD [<br>MSC[BB.dstLo, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* dst: BitAddress,<br>MSC[BB.dstHi, 1];<br>MSC[BB.dstBit, 2];<br>MSC[BB.dstBpl, 3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* dstBpl: INTEGER,<br>MSC[BB.srcLo, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* src: BitAddress,<br>MSC[BB.srcHi, 5];<br>MSC[BB.srcBit, 6];<br>MSC[BB.srcBpl, 7];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* srcBpl: INTEGER,<br>MSC[BB.width, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* width: CARDINAL,<br>MSC[BB.height, 11];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* height: CARDINAL,<br>MSC[BB.flags, 12];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* flags: BitBltFlags ];<br><br>* BitAddress: TYPE = MACHINE DEPENDENT RECORD [<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">word: LONG POINTER,<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">reserved: [0..7777B],<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">bit: [0..17B] ];<br><br>* BitBltFlags: TYPE = MACHINE DEPENDENT RECORD [<br>MC[BBF.direction, 100000];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* direction: {forward, backward},<br>MC[BBF.disjoint, 40000];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* disjoint: BOOLEAN,<br>MC[BBF.disjointItems, 20000];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* disjointItems: BOOLEAN,<br>MC[BBF.gray, 10000];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* gray: BOOLEAN,<br>MC[BBF.srcFunc, 4000];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* srcFunc: {normal, complement},<br>MC[BBF.dstFunc, 3000];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* dstFunc: {null, and, or, xor},<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* reserved: [0..777B] &larr; 0 ];<br><br>* -- re-interpretation of srcBpl if gray = TRUE<br>* GrayParm: TYPE = MACHINE DEPENDENT RECORD [<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">reserved: [0..17B] &larr; 0,<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">yOffset: [0..17B],<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">widthMinusOne: [0..17B] &larr; 0,</span><span class="tab" val="67"></span><span style="font: 10pt serif">-- present spec requires 0<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">heightMinusOne: [0..17B] ];<br><br>%<br>The 20 BitBlt Functions (combinations of gray, srcFunc, and dstFunc) are<br>divided into 4 classes:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">A</span><span class="tab" val="67"></span><span style="font: 10pt serif">dest &larr; f(gray)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">B</span><span class="tab" val="67"></span><span style="font: 10pt serif">dest &larr; f(gray, dest)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">C</span><span class="tab" val="67"></span><span style="font: 10pt serif">dest &larr; f(source)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">D</span><span class="tab" val="67"></span><span style="font: 10pt serif">dest &larr; f(source, dest)<br><br>The distribution of functions into classes is:<br>    Function (class)</span><span class="tab" val="67"></span><span style="font: 10pt serif">gray</span><span class="tab" val="67"></span><span style="font: 10pt serif">srcFunc</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">dstFunc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 0 (C)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">null<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 1 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">and<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 2 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">or<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 3 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">xor<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 4 (C)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">null<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 5 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">and<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 6 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">or<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 7 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">xor<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">10 (A)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">null<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">11 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">and<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">12 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">or<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">13 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">xor<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">14 (A)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">null<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">15 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">and<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">16 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">or<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">17 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">xor<br><br><br>Terminology: when referring to words in a scan line, "left" and "right"<br>refer to the words with lower and higher addresses, respectively, independent<br>of the direction of processing the scan line;  "first" and "last" refer<br>to the first and last words encountered in the direction of processing.<br><br>Since the Dorado can do BitBlt in either direction at equal cost,<br>this implementation always uses the direction specified by the programmer.<br>The disjoint bit is ignored, and disjointItems is used only to determine<br>whether or not "touching" of the data is required in some cases (see below).<br><br>The destination item is considered to consist of a left partial word,<br>some number of full (body) words, and a right partial word.  If the item<br>begins or ends on a word boundary, the left or right word is still<br>considered to be a partial word.<br><br>The destination bits preserved in the left and right partial words<br>are determined by the SHC register&rsquo;s LMask and RMask, respectively,<br>where LMask = dst.bit, RMask = 17-((dst.bit+width-1) mod 20).<br><br>The destination width in words, including the first and last partial words,<br>is computed by DWidth = (width + dst.bit + 17)/20.  Similarly,<br>the source width in words, including the first and last partial words,<br>is computed by SWidth = (width + src.bit + 17)/20.<br>DWidth and SWidth differ by at most +/-1.<br><br>If DWidth &gt; 2 then the destination consists of a left partial word, DWidth-2<br>full body words, and a right partial word.<br>If DWidth = 2 then the item consists of a left partial word immediately<br>followed by a right partial word.<br>If DWidth = 1 then the entire destination item lies within a single word,<br>not crossing a word boundary.  Effectively, the left and right partial words<br>are one and the same.  This case (called the "thin" case) requires<br>special handling, as both LMask and RMask must be applied simultaneously.<br><br>Processing of the scan line is controlled by two counters: the Cnt register<br>(loaded from ICnt), which counts the inner loop (20 words or fewer), and<br>MCount, which counts the outer loop.  Roughly speaking,<br>Cnt is loaded initially with DWidth mod 20 and MCount with DWidth/20.<br>The inner loop is executed Cnt times; then, until MCount is exhausted,<br>Cnt is reloaded with 20 and the inner loop is executed 20 more times.<br>The reason for this arrangement is to permit a PreFetch to be executed<br>every 20 words.<br><br>More precisely: Before each horizontal loop, the Cnt register is loaded with<br>  if DWidth &lt; 23 then DWidth-1 else (DWidth-3) mod 20 +2, so:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt &gt; 1 if the body contains one or more words.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt = 1 if there are no body words.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt = 0 in the thin case.<br>Cnt is decremented twice before the main loop is reached, so upon entry<br>to the main loop it contains DWidth-3 (assuming DWidth&lt;23), which is precisely<br>the correct value for going around the loop DWidth-2 times.  (The extra 2<br>in DWidth are the first and last partial words, which are handled outside<br>the word loop.)<br><br>MCount is loaded with (DWidth-3)/20 -1, so:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MCount &lt; 0 if DWidth &lt; 23<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MCount = 0 if 23 &lt;= DWidth &lt; 42, etc.<br>Each time the inner loop terminates, if MCount&lt;0 the scan line is finished,<br>but if MCount&gt;=0, MCount is decremented, Cnt is loaded with 17, and the<br>main loop is reentered for another 20 iterations.<br><br>When working left-to-right, the source may be thought of as T,,SrcWd --<br>that is, with T on the left and SrcWd on the right.  In any given operation,<br>T contains the previous source word and SrcWd contains the current one, and<br>the shift operation consists of left-shifting T,,SrcWd by 0 to 17 bits<br>(to align it with the destination) and storing the leftmost 20 bits of the<br>result.  Since the shifter is actually a cycler and produces the rightmost<br>20 bits (rather than the leftmost) of the cycled result, the shifter must<br>be set up to left-cycle an additional 20 bits (by exchanging SHA and SHB).<br>Hence SHA=R and SHB=T.<br><br>When working right-to-left, the source may be thought of as SrcWd,,T,<br>where T contains the previous source word and SrcWd the current, as before.<br>This is exactly symmetric with the left-to-right case and requires only<br>that SHA and SHB be exchanged.  Hence SHA=T and SHB=R.<br><br>Regardless of the direction, if there are at least as many data bits in the<br>first word of the source item as in the first word of the destination item,<br>then all the destination bits come from SrcWd during the first shift and<br>T need not be loaded at all.  On the other hand, if there are fewer bits<br>in the first word of the source item, the destination bits come from<br>both SrcWd and T.  In this case, T must contain the first source word and<br>SrcWd the second.  These two situations must be distinguished, since one<br>requires fetching only a single word whereas the other requires fetching<br>two words before operating the shifter for the first time.<br><br>A similar situation arises at the end of an item; that is, all the bits<br>in the last partial destination item may come from the leftover source<br>word in T, or it may be necessary to fetch an additional word into SrcWd.<br>These situations must be distinguished also.  An earlier version of this<br>microcode omitted the test and simply fetched the "extra" word always;<br>unfortunately, this sometimes resulted in touching a word outside the bit map,<br>which caused problems in a paged environment when the bit map happened<br>to be page-aligned.<br><br>Two bits in BBCtrl control the fetching of the "extra" word in the above<br>two cases.<br><br>In the normal case in which both srcBpl and dstBpl are multiples of 16,<br>the ShC register and all horizontal loop control information can be computed<br>just once for all scan lines.  If either srcBpl or dstBpl is not a multiple<br>of 16, this doesn&rsquo;t work, and all this stuff has to be recomputed for<br>each scan line.  I consider this case to be anomalous -- the PrincOps<br>specification is overly general, or perhaps was motivated by clever hacks<br>such as being able to BitBlt parallelograms.  Therefore, this implementation<br>takes the easy way out in this case by doing just one scan line, saving state<br>as if an interrupt had occurred, and restarting BitBlt from the beginning.<br>This is slow as blazes, but the user gets what he deserves.......<br><br>All the horizontal loops work in both directions by use of a trick:<br>ALUF[15] is redefined to be A+1 if moving left-to-right but A-1 if<br>right-to-left.  This ALU function is invoked by the operation "A+/-1",<br>and is used to advance source and destination pointers along the scan line.<br>A consequence of this is that ALUF[15] (normally A AND NOT B) cannot be<br>used by I/O tasks.<br><br>BBDst and BBSrc are 16-bit displacements relative to base registers<br>BBDstBR and BBSrcBR.  If moving top-to-bottom they start near zero<br>and count up; if bottom-to-top they start at ~2&uarr;15 and count down.<br>If more than ~2&uarr;15 words of bit map are processed, one of these displacements<br>becomes negative.  This is detected and causes BitBlt to restart, recomputing<br>the base registers and displacements.  BR displacement overflow is handled<br>this way because it takes too much code to recompute the BRs and displacements<br>in mid-stream.  The cost of restarting BitBlt from scratch in this case is<br>unimportant, since such a large amount of data is involved.  (Indeed, in<br>normal programs an interrupt will occur before 2&uarr;15 words are processed,<br>so BitBlt will be restarted anyway.)<br><br>166      PILOTBITBLT 0        -1                 \PILOTBITBLT<br><br>Performs Pilot-style bitblt.<br>TOS-1 is a pointer to a bitblt table, which is 16-aligned.<br>TOS number of scan lines already done (initially 0)<br><br>when resuming from interrupt or fault, the TOS count will be incremented appropriately.<br><br>TOS: number of scan lines already done.<br><br>BitBlt exits in one of three ways:<br><br>1. Normal completion: BitBlt pops the stack<br><br>2. Interrupt request pending: BitBlt leaves at TOS the number of scan lines already processed and branches to the interrupt handler.  BitBlt is subsequently restarted with the value left in TOS.<br><br>3. Page fault: BitBlt is careful to ensure restartability in the face of page faults.  That is, any time a page fault can occur, TOS contains the number of scan lines already done, and restarting BitBlt with that argument will cause the correct thing to happen.<br><br>Approximate timing for initialization and cleanup (excluding main loops):<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 65 cycles<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+10 if direction=backward<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+29 if resuming from interrupt<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+ one of the following:<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">gray:</span><span class="tab" val="67"></span><span style="font: 10pt serif"> 13 cycles minimum<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> +6 if resuming from interrupt<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">+37 if resuming and (heightMinusOne+1) is not a power of 2<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">~gray:</span><span class="tab" val="67"></span><span style="font: 10pt serif"> 21 cycles minimum<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">+29 if resuming from interrupt<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> +2 if direction=backward<br><br>Totals:</span><span class="tab" val="67"></span><span style="font: 10pt serif">gray:</span><span class="tab" val="67"></span><span style="font: 10pt serif">78 cycles minimum, 160 maximum <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">~gray:</span><span class="tab" val="67"></span><span style="font: 10pt serif">86 cycles minimum, 156 maximum <br><br>Note: these overheads are incurred on every scan line if dst.bit or src.bit<br>is not a multiple of 16.<br><br>See comments above main loops for main loop times.<br>%<br><br>*-----------------------------------------------------------<br>* R-register assignments:<br>*-----------------------------------------------------------<br><br>SetRMRegion[BBRegs];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* The RMRegion itself is defined in RegisterDefs.mc<br><br>RVN[BBDst];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Address of next word to process<br>RVN[BBSrc];<br><br>RVN[DstInc];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Address increment between scan lines --<br>RVN[SrcInc];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  negative if direction = backward<br><br>RVN[DRast];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Raster length (bits, later words) --<br>RVN[SRast];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  negative if direction = backward<br><br>RVN[PrefDst];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Address of next munch to PreFetch<br>RVN[PrefSrc];<br><br>RVN[DPrefOffset];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Offset of leftmost word of next scan line relative<br>RVN[SPrefOffset];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*  to first word of current scan line<br><br>RVN[VCount];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Vertical line count<br>RVN[MCount];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Horizontal munch count<br>RVN[ICnt];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Initial value of Cnt register for word loops<br><br>RVN[BBDisp];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Control flags and horizontal loop dispatch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* B0=1 =&gt; direction = backward<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* B8:15 = dispatch value relative to HorizontalDisp<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* (see below for details)<br><br>RVN[BBCtrl];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Control flags:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* B0=1 =&gt; 2 source words required for first dest word<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* B15=1 =&gt; 2 source words required for last dest word<br><br>RVN[SrcWd];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Leftover source word -- must be RVREL 17<br><br>* Alias used when the source is gray:<br>RME[GrayBump, SRast];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Size of gray brick in words -1<br><br>* Aliases used during initialization:<br>RME[Width, DPrefOffset]; * Width of item in bits<br>RME[DWidth, ICnt];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Width of destination item in words<br>RME[SWidth, PrefSrc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Width of source item in words<br>RME[Skew, DstInc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Destination-source skew, mod 20<br>RME[BBMasks, PrefDst];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* LMask and RMask values to be loaded into SHC<br>RME[BBFlags, SrcInc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* BitBlt flags word<br>RME[DstX, BBDst];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Destination starting X in bits, later in words<br>RME[SrcX, BBSrc];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Source starting X in bits, later in words<br>RME[IBBSrc, SPrefOffset]; * Initial BBSrc (gray only)<br>RME[BBTemp, SrcWd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Must be RVRel 17 because it is an arg to MulSub.<br><br>*-----------------------------------------------------------<br>* Other definitions<br>*-----------------------------------------------------------<br><br>* Base-register assignments<br><br>% -- Actually defined in ADefs.mc.  First two must be an even-odd pair.<br>BR[BBDstBR, ?];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BitBlt destination base<br>BR[BBSrcBR, ?];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BitBlt source base<br>BR[BBTableBR, ?];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Scratch (emulator use only)<br>%<br>BR[BBTableBR, 13];<br><br>* ALU functions defined by BitBlt.<br>* The ALUF Ram is loaded by BitBlt with the desired operations.<br>XALUOP[,BBOp,,17,E];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* A BBOp B -- logical operation invoked with shifter<br><br>XAOP[,+/-1,15,E];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* A +/-1 -- A+1 or A-1 depending on horizontal<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* direction.  This value of ALUF is normally<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* A AND NOT B and is restored by BitBlt when done.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This means, however, that A AND NOT B cannot be used<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* by other tasks.<br><br><br>* Layout of BBDisp register:<br>* B0 = 0 if direction = forward, 1 if backward<br>* B8-15: BigBDispatch value for setup and body dispatches.<br>* The following addressing constraints apply:<br>* (1) B13 = 1 and B15 = 1 if a real source bit map is used (0 if gray block).<br>* (2) B14 = 0 if the item(s) must be touched before beginning a transfer.<br>* (3) B11 = 1 if the destination is an operand.<br>* (4) Certain targets are tied together by Call constraints.<br>* (5) Must not stomp on too many JCN conditional branch targets.<br>* These bits are rather carefully selected to permit the same BBDisp to be<br>* used in three different dispatches.<br><br>Set[SrcFlg, 5];<br>Set[NoTouchFlg, 2];<br>Set[DstFlg, 20];<br><br>* BBDispX defines the page used for dispatches on BBDisp.<br>Set[BBDispX, 3400];<br>M[BBAt, At[BBDispX, Add[#1, #2]]];<br><br>* Page-relative entry points for setup routines.<br>* All must have B11 = 1, to neutralize body dispatch (DstFlag).<br>Set[GrayDstSetup&TouchLoc, 70];<br>Set[GrayDstSetupLoc, 72];<br>Set[SrcDstSetup&TouchLoc, 75];<br>Set[SrcDstSetupLoc, 77];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Must be SrcDstSetup&TouchLoc + 2<br><br>Set[HorizontalDispLoc, 70];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Target of setup dispatch<br><br>* Page-relative entry points for body routines.<br>* Each pair must differ only in the value of DstFlag, and the addresses<br>* must neutralize any one bits that may have been present for setup dispatch.<br>Set[GrayBodyLoc, 12];<br>Set[GrayDstBodyLoc, 32];<br><br>Set[SrcBodyLoc, 17];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* These must be xxxx1111 because they contain<br>Set[SrcDstBodyLoc, 37];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  conditional Call instructions<br><br>*-----------------------------------------------------------<br>opBITBLT:<br>*-----------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (2c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkP&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* set up StkP for use internally<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (TSP) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; T) - (2c);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch NScanLines<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; MD, T&larr; (fetch&larr; T) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Md, fetch&larr; T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch bitblt table<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">memBase&larr; BBTableBR; <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BrLo&larr; T, T&larr; Md;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BrHi&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBTableBR now points to BitBltArg<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RBase&larr; RBase[BBRegs];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FETCH&larr; BB.flags;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* can fault<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBFlags&larr; MD, Fetch&larr; BB.height;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (PS.INBITBLT);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* flag for pagefault<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PSTATE&larr; T;<br><br>* Dispatch on gray, srcFunc, dstFunc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LDF[BBFlags, 4, 11];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BigBDispatch&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[BBFunctionTable];<br><br>*-----------------------------------------------------------<br>BBFunctionTable: DispTable[20];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* gray, srcFunc, dstFunc, ALU op<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 1C, Branch[BBFC];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0, 0, 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 21C, Branch[BBFD];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0, 0, 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A AND B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 5C, Branch[BBFD];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0, 0, 2</span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A OR B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 15C, Branch[BBFD&T];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0, 0, 3</span><span class="tab" val="67"></span><span style="font: 10pt serif">A EQV B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 37C, Branch[BBFC];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0, 1, 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">A<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 35C, Branch[BBFD];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0, 1, 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">A AND B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 27C, Branch[BBFD];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0, 1, 2</span><span class="tab" val="67"></span><span style="font: 10pt serif">A OR B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 23C, Branch[BBFD&T];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0, 1, 3</span><span class="tab" val="67"></span><span style="font: 10pt serif">A XOR B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 1C, Branch[BBFA];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1, 0, 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 21C, Branch[BBFB];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1, 0, 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A AND B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 5C, Branch[BBFB];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1, 0, 2</span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A OR B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 15C, Branch[BBFB&T];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1, 0, 3</span><span class="tab" val="67"></span><span style="font: 10pt serif">A EQV B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 37C, Branch[BBFA];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1, 1, 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">A<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 35C, Branch[BBFB];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1, 1, 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">A AND B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 27C, Branch[BBFB];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1, 1, 2</span><span class="tab" val="67"></span><span style="font: 10pt serif">A OR B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 23C, Branch[BBFB&T];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1, 1, 3</span><span class="tab" val="67"></span><span style="font: 10pt serif">A XOR B<br>*-----------------------------------------------------------<br><br>* Select the appropriate dispatch word for the function.<br>BBFA:</span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; Add[NoTouchFlg]C, Branch[SetBBF];<br>BBFB:</span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; Add[DstFlg, NoTouchFlg]C, Branch[SetBBF];<br>BBFB&T:</span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; Add[DstFlg]C, Branch[SetBBF];<br>BBFC:</span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; Add[SrcFlg, NoTouchFlg]C, Branch[SetBBF];<br>BBFD:</span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; Add[SrcFlg, DstFlg, NoTouchFlg]C, Branch[SetBBF];<br>BBFD&T:</span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; Add[SrcFlg, DstFlg]C, Branch[SetBBF];<br><br>SetBBF:</span><span class="tab" val="67"></span><span style="font: 10pt serif">ALUFMRW&larr; T, ALUF[17],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Set ALU function<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; MD;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; height in scan lines<br><br>* VCount&larr; (scan lines left to do)-1.  Stack has scan lines already done.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VCount&larr; T-(Stack)-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* height - (scan lines done) -1<br><br>*-----------------------------------------------------------<br>* Set up destination base address<br>*-----------------------------------------------------------<br><br>* Registers in use: (permanent) BBDisp, VCount; (temporary) BBFlags.<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Fetch&larr; BB.dstBpl)-1, Branch[BitBltDone1, ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; T, DRast&larr; MD;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* DRast&larr; bits per line<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (DRast) AND (17C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* See if integral words per line<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack, Branch[.+2, ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack, Reschedule;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* No, process only one scan line<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; T, Branch[DstMult];*###, ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Branch if resuming from interrupt<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Fetch&larr; BB.dstLo)+1, DstX&larr; MD; * DstX&larr; dst.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; MD, Fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; low base word address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; MD, Branch[DstSetupBR];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBTemp&larr; high base word address<br><br>* Following garbage is only executed when resuming BitBlt from an interrupt<br>* or fault.  We must compute the base address for the next scan line.<br>* n.b. our life is made very difficult by the presence of the BitAddress<br>* structure and the specification of bit map width in bits rather than words,<br>* to say nothing of features such as bits/line being negative if direction =<br>* backwards.  I assume these were intended to help the Dolphin implementation,<br>* but they are definitely not helpful!  Alto BitBlt both had a cleaner<br>* interface and was easier to implement.<br>DstMult:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DstX&larr; MD;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; DRast, Call[MulSub];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T,,Q &larr; Q*T, clobbers BBTemp<br><br>* Now have 32-bit bit offset in T,,Q.  Add it to bit map base address.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; BB.dstLo, DRast, Branch[.+2, R&gt;=0]; * DstX&larr; dst.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(Stack);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* DRast negative, adjust high result<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* to make it 32-bit 2&rsquo;s complement<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DstX&larr; (DstX)+Q;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Add low bit offset to dst.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; BBTemp&larr; A&larr; T, XorSavedCarry;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBTemp&larr; high bit offset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; RCY[T, DstX, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Convert to word offset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+MD;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Add to low base word address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DstX&larr; (DstX) AND (17C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Mask new BitAddress.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; BB.dstHi;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; RSH[BBTemp, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBTemp&larr; high word offset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)+MD, XorSavedCarry; * Add to high base word address<br><br>* Together again here.  Now BBTemp,,T = adjusted base value.<br>DstSetupBR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MemBase&larr; BBDstBR, DRast, Branch[DstReallySetupBR, R&gt;=0];<br><br>* Processing bottom-to-top.<br>* Decrease base by 2&uarr;15, and (later) increase initial displacement by 2&uarr;15.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(100000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)-1, XorSavedCarry;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; (BBDisp) OR (100000C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Set flag to remember direction<br><br>* Now finally ready to load the base register!<br>DstReallySetupBR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRLo&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRHi&larr; BBTemp;<br><br>*-----------------------------------------------------------<br>* Set up source base address<br>*-----------------------------------------------------------<br><br>* Registers in use: (permanent) BBDisp, VCount, DRast;<br>* (temporary) BBFlags, DstX.<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MemBase&larr; BBTableBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Fetch&larr; BB.srcBpl)-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; T, SRast&larr; MD, BBDisp,</span><span class="tab" val="67"></span><span style="font: 10pt serif">* SRast&larr; bits per line<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[SrcIsGray, R even]; * Branch if source bit map is gray<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (SRast) AND (17C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* See if integral words per line<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack, Branch[.+2, ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Stack, Reschedule;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* No, process only one scan line<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; T, Branch[SrcMult];*###, ALU#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Branch if resuming from interrupt<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcX&larr; MD, T&larr; (Fetch&larr; BB.srcLo)+1; * SrcX&larr; src.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; MD, Fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; low base word address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; MD, Branch[SrcSetupBR];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBTemp&larr; high base word address<br><br>* Following garbage is only executed when resuming BitBlt from an interrupt<br>* or fault.  We must compute the base address for the next scan line.<br>SrcMult:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcX&larr; MD;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; SRast, Call[MulSub];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T,,Q &larr; Q*T, clobbers BBTemp<br><br>* Now have 32-bit bit offset in T,,Q.  Add it to bit map base address.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; BB.srcLo, SRast, Branch[.+2, R&gt;=0]; * SrcX&larr; src.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(Stack);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* SRast negative, adjust high result<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* to make it 32-bit 2&rsquo;s complement<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcX&larr; (SrcX)+Q;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Add low bit offset to src.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; BBTemp&larr; A&larr; T, XorSavedCarry;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBTemp&larr; high bit offset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; RCY[T, SrcX, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Convert to word offset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+MD;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Add to low base word address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcX&larr; (SrcX) AND (17C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Mask new BitAddress.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; BB.srcHi;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; RSH[BBTemp, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBTemp&larr; high word offset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)+MD, XorSavedCarry; * Add to high base word address<br><br>* Together again here.  Now BBTemp,,T = adjusted base value.<br>SrcSetupBR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MemBase&larr; BBSrcBR, SRast, Branch[.+3, R&gt;=0];<br><br>* Processing bottom-to-top.<br>* Decrease base by 2&uarr;15, and (later) increase initial displacement by 2&uarr;15.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(100000C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)-1, XorSavedCarry;<br><br>* Now finally ready to load the base register!<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (BBFlags) AND (Or[BBF.disjoint!, BBF.disjointItems!]C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRLo&larr; T, Branch[.+2, ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; (BBDisp) AND (Not[NoTouchFlg]C); * Not disjoint, must touch<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRHi&larr; BBTemp, Branch[BBSetupX];<br><br>*-----------------------------------------------------------<br>* Set up gray source block<br>*-----------------------------------------------------------<br><br>* Registers in use: (permanent) BBDisp, VCount, DRast;<br>* (temporary) DstX.<br><br>* Re-interpret srcBpl as a GrayParm record.<br>* Note: assume direction = forward always (required by PrincOps).<br>* BBSrcBR will end up pointing one beyond the end of the gray brick MOD 2&uarr;16,<br>* and BBSrc will address it using the negative indexing trick.<br>SrcIsGray:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcX&larr; MD, T&larr; (Fetch&larr; BB.srcLo)+1; * SrcX&larr; src.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; MD, Fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBTemp&larr; low base address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LDF[SRast, 4, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Extract yOffset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GrayBump&larr; (SRast) AND (17C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* GrayBump&larr; heightMinusOne --<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* GrayBump and SRast are same register<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (GrayBump)-T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; heightMinusOne-yOffset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)+T+1, MemBase&larr; BBSrcBR; * End of brick +1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; MD, BRLo&larr; BBTemp;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Load up the base register<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)-1, XorSavedCarry; * high base-1 for negative indexing<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRHi&larr; BBTemp;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; Stack;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Resuming from interrupt?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (GrayBump)-T, </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Recover yOffset<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[NoGrayDiv, ALU=0]; * Branch if no division required<br><br>* Following garbage is only executed when resuming BitBlt from an interrupt<br>* or fault.  We must compute the grayIndex for the next scan line.<br>* In general this is (yOffset + scanLinesDone) MOD height.  I expect height<br>* usually to be a power of two, so optimize this case and only do the<br>* full-blown MOD operation when necessary.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Stack)+T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* scanLinesDone + yOffset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (GrayBump)+1, Q&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; height, Q&larr; scanLinesDone+yOffset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (GrayBump) AND T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* = 0 iff height is power of 2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (GrayBump) AND Q, Branch[.+2, ALU=0];<br>* DivSub performs [T: remainder, Q: quotient] &larr; (T,,Q)/BBTemp<br>* and clobbers BBCtrl -- beware!  The division cannot fail.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; A0, Call[DivSub];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br><br>* Together again here.  Now T = appropriate initial y coordinate.<br>NoGrayDiv:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IBBSrc&larr; T-(GrayBump)-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Init negative index for references<br><br>*-----------------------------------------------------------<br>* X-coordinate setup: widths, margins, skew, masks, etc.<br>*-----------------------------------------------------------<br><br>* Registers in use: (permanent) BBDisp, VCount, DRast, SRast (= GrayBump);<br>* (temporary) DstX, SrcX (= BBSrc).<br>BBSetupX:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MemBase&larr; BBTableBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; BB.width;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Width&larr; MD, T&larr; A0;<br><br>* Compute LMask and RMask.<br>* LMask = dst.bit.<br>* RMask = 17-((dst.bit+width-1) mod 20) = (-dst.bit-width) mod 20.<br>* For reference, SHC fields are:<br>*  B2: SHA=T, B3: SHB=T, B4-7: count, B8-11: RMask, B12-15: LMask<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(Width);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; -width<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(DstX),</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; -dst.bit-width<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[BitBltDone2, ALU&gt;=0]; * Stop here if width &lt;= 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; DPF[T, 4, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* B8-11&larr;((-dst.bit-width)mod 20) lsh 4<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBMasks&larr; T OR (DstX);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* B12-15&larr; dst.bit<br><br>* Compute destination width in words, including first and last partial words.<br>* DWidth&larr; (width + dst.bit +17) / 20.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Width)+(17C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(Q&larr; DstX);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DWidth&larr; RSH[T, 4];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBCtrl&larr; (BBDisp)-(BBDisp)-1,</span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBCtrl[0] &larr; 1 in case gray source<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[BBNoSetupSrcX, R even]; * Branch if gray<br><br>* Compute source width in words, including first and last partial words.<br>* SWidth&larr; (width + src.bit +17) / 20.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (SrcX)+(17C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Width)+T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SWidth&larr; T&larr; RSH[T, 4];<br><br>* Set flags to control fetching of "extra" first and last words.<br>* Except in the "thin" case (DWidth=1), the setup/finish routines for the<br>* horizontal loops nominally fetch 1 word and store 2 words; an extra fetch<br>* may be required at the beginning, the end, or both, depending on the number<br>* of words in the source and destination items (see introductory comments).<br>* DWidth and SWidth differ by at most +/-1.<br>* If SWidth = DWidth+1, an extra source word must be fetched at both ends.<br>* If SWidth = DWidth-1 or SWidth = 1, no extra source words need be fetched.<br>* If SWidth = DWidth # 1, an extra source word must be fetched at one end:<br>*   if src.bit mod 20 &gt; dst.bit mod 20 then left else right.<br>* Set BBCtrl[0]&larr; extraLeft, BBCtrl[1:15]&larr; extraRight.<br>* (these flags are exchanged later if working right-to-left.)<br>* T still has SWidth; Q still has dst.bit.<br>* The following 2 instructions set BBCtrl&larr; -1 if SWidth&gt;DWidth, 0 otherwise.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (DWidth)-T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBCtrl&larr; T-T-1, XorSavedCarry, Branch[SetupSkew, ALU#0];<br><br>* Set BBCtrl&larr; 100000 if src.bit &gt; dst.bit, 77777 otherwise.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (SrcX)-Q-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Q=DstX; carry iff src.bit &gt; dst.bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBCtrl&larr; 100000C;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBCtrl&larr; (BBCtrl)-1, XorSavedCarry, Branch[SetupSkew];<br><br>BBNoSetupSrcX:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br><br>* X-coordinate setup (cont&rsquo;d)<br><br>* Compute skew = (src.bit-dst.bit) mod 20, and determine horizontal direction.<br>* Still have Q = dst.bit.<br>SetupSkew:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (SrcX)-Q;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; BBDisp, Branch[.+2, R even];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Skew&larr; T AND (17C), DblBranch[SetupRtoL, SetupLtoR, ALU&lt;0];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBSrc&larr; IBBSrc;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Gray, init source ptr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Skew&larr; T AND (17C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 200C, Branch[NoSrcThinChk];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* ALUFM control for "A+1"<br><br>* direction = forward: work from left to right.<br>* Set SHA=R, SHB=T, ALUF[15]="A+1".<br>* Note: if skew = 0, set SHA=R, SHB=R.<br>SetupLtoR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 200C, Branch[NoSrcThinChk, ALU=0]; * ALUFM control for "A+1"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Skew&larr; (Skew) OR (20C), Branch[SetupALU&ShC]; * SHB=T<br><br>* direction = backward: work from right to left.<br>* Set SHA=T, SHB=R, ALUF[15]="A-1".<br>* Advance starting X coordinates to rightmost ends of items.<br>* Note: if skew = 0, set SHA=R, SHB=R, and do not exchange extra-word flags.<br>SetupRtoL:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; (BBDisp) OR (100000C), Branch[.+3, ALU=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Skew&larr; (Skew) OR (40C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* SHA=T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBCtrl&larr; (BBCtrl) LCY 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Exchange source extra-word flags<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Width)-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DstX&larr; (DstX)+T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Advance to rightmost X-coordinates<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcX&larr; (SrcX)+T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Advance non-gray source<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; 36C;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* ALUFM control for "A-1"<br><br>* Have ALUFM control in T for "A+/-1" operation.<br>SetupALU&ShC:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (SWidth)-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Thin source check (see below)<br>NoSrcThinChk:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ALUFMRW&larr; T, A+/-1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Set ALU function<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[SetupShC, ALU#0]; * <br><br>* If we would have fetched an extra source word, but there is only one source<br>* word to fetch, then reset source extra-word flags and set SHA=R, SHB=R.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBCtrl&larr; A0, Branch[.+2, R&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Skew&larr; (Skew) AND (17C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LSH[BBMasks, 10], Branch[.+2]; * Placement<br><br>* Merge skew with masks and load SHC.<br>SetupShC:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LSH[BBMasks, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Shift masks to B0-7<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LCY[T, Skew, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Concatenate SHA, SHB, count, masks<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; DWidth, ShC&larr; T;<br><br>*-----------------------------------------------------------<br>* Compute word addresses and increments<br>*-----------------------------------------------------------<br><br>* Registers in use: (permanent) BBDisp, VCount, DRast, SRast, Width, BBCtrl;<br>* (temporary) DstX, SrcX, DWidth, SWidth.<br>* Note: at this point DRast and SRast are still in units of bits.<br><br>* Convert DstX to X word displacement relative to leftmost word of<br>* first scan line.  Note: BBDst is the same register as DstX.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDst&larr; RSH[DstX, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBDst&larr; DstX/20<br><br>* Compute destination inter-scan-line word address increment.<br>* DstInc&larr; DRast + (if direction=forward then -DWidth else DWidth).<br>* Also compute first PreFetch offset (from BBDst).<br>* = leftmost word on next scan line, even if processing right-to-left.<br>* DPrefOffset&larr; if direction=forward then DRast else DRast-DWidth.<br>* Finally, if direction=backward then add 2&uarr;15 to the word address,<br>* which will be counted down toward the base register which was initialized<br>* to the leftmost word of the first scan line -2&uarr;15.<br>* Note: T = DWidth here.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DRast&larr; RSH[DRast, 4],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Convert DRast to words<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[DstIncRtoL, R&lt;0]; * Branch if direction=backward<br><br>DstIncLtoR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DstInc&larr; (DRast)-T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* L to R: DRast-DWidth<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DPrefOffset&larr; T&larr; DRast, Branch[DstIncDone];<br><br>DstIncRtoL:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DRast&larr; (DRast) OR (170000C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Extend sign<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DstInc&larr; (DRast)+T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* R to L: DRast+DWidth<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DPrefOffset&larr; T&larr; (DRast)-T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDst&larr; (BBDst)+(100000C);<br><br>DstIncDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefDst&larr; (BBDst)+T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Initial PreFetch address<br><br>* Is a source item required?  If not, skip source setup.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp, Branch[BBNoSource, R even];<br><br>* Convert SrcX to X word displacement relative to leftmost word of<br>* first scan line.  Note: BBSrc is the same register as SrcX.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBSrc&larr; RSH[SrcX, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* BBSrc&larr; SrcX/20<br><br>* Compute source inter-scan-line word address increment.<br>* SrcInc&larr; SRast + (if direction=forward then -SWidth else SWidth).<br>* Also compute first PreFetch offset (from BBSrc).<br>* = leftmost word on next scan line, even if processing right-to-left.<br>* SPrefOffset&larr; if direction=forward then SRast else SRast-SWidth.<br>* Finally, if direction=backward then add 2&uarr;15 to the word address,<br>* which will be counted down toward the base register which was initialized<br>* to the leftmost word of the first scan line -2&uarr;15.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; SWidth;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SRast&larr; RSH[SRast, 4],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Convert SRast to words<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[SrcIncRtoL, R&lt;0]; * Branch if direction=backward<br><br>SrcIncLtoR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcInc&larr; (SRast)-T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* L to R: SRast-SWidth<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SPrefOffset&larr; T&larr; SRast, Branch[SrcIncDone];<br><br>SrcIncRtoL:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SRast&larr; (SRast) OR (170000C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Extend sign<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcInc&larr; (SRast)+T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* R to L: SRast+SWidth<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SPrefOffset&larr; T&larr; (SRast)-T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBSrc&larr; (BBSrc)+(100000C);<br><br>SrcIncDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefSrc&larr; (BBSrc)+T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Initial PreFetch address<br><br>*-----------------------------------------------------------<br>* Final adjustments prior to entering vertical loop<br>*-----------------------------------------------------------<br><br>* Compute ICnt, the initial value of the Cnt register for each loop.<br>* ICnt&larr; if DWidth &lt;= 22B then DWidth-1 else NOT (DWidth-3) [= 2-DWidth].<br>BBNoSource:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; (DWidth)-(23C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ICnt&larr; T&larr; (DWidth)-1, Branch[.+2, ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ICnt&larr; (1S)-T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* = (2S)-(DWidth)<br><br>* Never need to "touch" data in the "thin" case.<br>* ALU=0 here iff the "thin" case applies (DWidth=1).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&larr; (Stack)-1, Branch[.+2, ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp&larr; (BBDisp) OR (Add[NoTouchFlg]C);<br><br>* Enter vertical loop with (scan lines done)-1 on TOS and ALU&gt;=0.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MCount&larr; T-T-1, MemBase&larr; BBSrcBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; A0, Branch[BBVerticalLoop];<br><br><br>*-----------------------------------------------------------<br>* BitBlt vertical loop (per-scan-line)<br>* At top of loop, the following invariants hold:<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">VCount = (number of scan lines remaining)-1<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack = (number of scan lines done)-1<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">MemBase = BBSrcBR<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">ALU&lt;0 iff destination BR displacement has overflowed<br>* Vertical loop overhead:<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif"> 6 cycles for loop control and destination pointer update<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">+4 cycles for source pointer update if source item is used<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">+4 cycles if item is greater than 20B words wide<br>*-----------------------------------------------------------<br><br>BBVerticalLoop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VCount&larr; (VCount)-1, T&larr; MD,</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Force faults from previous item<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[BBDoneOrOverflow, ALU&lt;0, R&lt;0];<br><br>* If positive, ICnt has the desired initial value of Cnt (DWidth-1).<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; NOT (Cnt&larr; ICnt), Branch[SmallBlock, R&gt;=0];<br><br>* Item greater than one munch wide.  Set up separate munch and word counts.<br>* T now has DWidth-3, where DWidth is the number of words in the destination<br>* item, including first and last partial words.<br>* MCount &larr; (DWidth-3)/20 -1, Cnt &larr; (DWidth-3) mod 20 +2.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MCount&larr; RSH[T, 4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T AND (17C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(2C);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MCount&larr; (MCount)-1, Cnt&larr; T;<br><br>* This dispatch goes to one of: GrayDstSetup, GrayDstSetup&Touch,<br>* SrcDstSetup, or SrcDstSetup&Touch.<br>SmallBlock:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BigBDispatch&larr; BBDisp;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&larr; (Stack)+1,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Advance scan lines done<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">BranchExternal[Add[BBDispX, HorizontalDispLoc]];<br><br>*-----------------------------------------------------------<br>AdvanceSrcDst:<br>* Control returns here at the end of individual horizontal loops that<br>* involve both source and destination items.<br>* BBSrc, BBDst point one beyond last word processed.<br>*-----------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; SrcInc;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBSrc&larr; T&larr; (BBSrc)+T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefSrc&larr; T+(SPrefOffset);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; BBDst, Branch[SrcBROverflow, ALU&lt;0];<br><br>*-----------------------------------------------------------<br>AdvanceDst:<br>* Control returns here at the end of individual horizontal loops that<br>* involve only a destination item (and gray, which is handled separately).<br>* BBDst and T point one beyond last word processed.<br>*-----------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDst&larr; T&larr; T+(DstInc);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefDst&larr; T&larr; T+(DPrefOffset),<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">DblBranch[BBReschedPending, BBVerticalLoop, Reschedule];<br><br>SrcBROverflow:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; MD, Branch[BBDoneOrOverflow];<br><br><br>*-----------------------------------------------------------<br>* Either VCount is exhausted or one of the BR displacements overflowed<br>* (or conceivably both events occurred at the same time).<br>* If VCount is exhausted then return normally; otherwise restart BitBlt.<br>* Note: scan line count at TOS is one behind.<br>*-----------------------------------------------------------<br>BBDoneOrOverflow:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VCount, Branch[.+2, R&gt;=0];<br><br>* We just processed the last scan line, so exit normally.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[BitBltDone];<br><br>* Not done yet.  Restore clobbered ALUFM locations before<br>* taking interrupt.  Note: scan line count at TOS is one behind, so fix it.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RBase&larr; RBase[TSP], Stack&larr; (Stack)+1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (TSP) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">store&larr; T, dbuf&larr; Stack, call[RestoreALUFM];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PSTATE&larr; A0, branch[LispReschedule];<br><br><br>*-----------------------------------------------------------<br>* Reschedule pending.  Branch to the reschedule trap handler.<br>* After handling the interrupt, it will restart the BitBlt with the state<br>* left on the stack.<br>*-----------------------------------------------------------<br>BBReschedPending:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; MD, Branch[BBDoneOrOverflow]; * Handle the same as overflow<br><br><br>*-----------------------------------------------------------<br>* Really done.  Restore clobbered ALUFM, flush stack, and exit.<br>* Must clear the low-order bit of BitBltArg so that if the caller does<br>* a PUSH to recover it, he will see the right thing.<br>*-----------------------------------------------------------<br>* Get here during initialization when only ALUFM[17] has been clobbered.<br>BitBltDone1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br>BitBltDone2:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Nop;<br><br>* Get here at end when both ALUFM[17] and ALUFM[15] have been clobbered.<br>BitBltDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rbase&larr; rbase[LTEMP0], call[RestoreALUFM];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PSTATE&larr; A0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LEFT &larr; (LEFT) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (TSP) - (2c), NextOpcode;<br><br>*-----------------------------------------------------------<br>* Horizontal loops<br>*-----------------------------------------------------------<br><br>%<br>Organization of horizontal (per-word) loops:<br><br>There are a number of variations, depending on the following:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">1. Whether the source is normal or gray;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">2. Whether or not the destination is an operand;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">3. Whether or not the destination is "thin" (one word per scan line);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">4. Whether or not data need be "touched" before doing the transfer.<br><br>There are fewer than 16 total cases because some of these combinations<br>cannot occur (for example, the thin case never requires touching).<br>Each case has a "setup" routine, a "body" routine, and a "finish" routine.<br>Many of these routines are shared among cases, and the flow of control<br>is determined by a complicated network of dispatches on BBDisp.<br>Finish routines exit to the vertical loop by a branch to AdvanceDst or<br>AdvanceSrcDst.<br><br>It is never necessary to "touch" if any of the following is true:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">a. The destination is "thin";<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">b. The destination is not an operand of the BitBlt function;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">c. The function can be performed multiple times with the same effect<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   as performing it only once (i.e., anything except XOR,<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   assuming the source and destination items don&rsquo;t overlap).<br>The "touch" and "no touch" cases are distinguished as part of the dispatch.<br><br>To reduce miss wait and increase performance, while processing each<br>scan line we fall out of the main loop once per munch and PreFetch<br>one munch for the next scan line.  This strategy depends on the<br>assumption that each scan line is less than 100 munches long (for a 100-row<br>cache, which is what the Dorado has at present).  Note that PreFetches<br>are done left-to-right even if transfers are done right-to-left.<br><br>Note that the current implementation is imperfect in that the last munch<br>of the next scan line may not be prefetched, or an extra munch prefetched<br>unnecessarily, because the main loop does not terminate at munch boundaries<br>but rather at multiples of 20 words from the end of the scan line.<br>Also, the first scan line is not prefetched, and a line past the end of<br>the last scan line is prefetched unnecessarily.  These defects should not<br>affect performance noticeably in normal use.<br>%<br><br>TopLevel;<br>KnowRBase[BBRegs];<br><br>%*-----------------------------------------------------------<br>Case A:  dest &larr; f(gray)<br><br>BBOp is taken from the following table:<br><br>    Function (class)</span><span class="tab" val="67"></span><span style="font: 10pt serif">gray</span><span class="tab" val="67"></span><span style="font: 10pt serif">srcFunc</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">dstFunc</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ALU operation<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">10 (A)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">null</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">14 (A)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">null</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A<br><br>Entry point to this code is at GrayDestSetup.<br>It dispatches here after setup.<br><br>Timing, per scan line, including vertical loop overhead:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">19 cycles minimum in the normal case<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+1 cycle per full word (excluding first and last partial words)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+4 + (2 * # of munches) cycles if item is wider than 20B words<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">12 cycles total in the "thin" case<br>%*-----------------------------------------------------------<br><br>* Entry point for srcFunc = normal.<br>* T has first partial word to be stored, and SrcWd has gray word.<br>GrayBody: BBAt[GrayBodyLoc],<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDst&larr; (Store&larr; BBDst)+/-1, DBuf&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; ShiftNoMask[SrcWd], Branch[GrayEnd, Cnt=0&-1];<br><br>* Just replicate the shifted gray word throughout the destination body.<br>GrayLoop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDst&larr; (Store&larr; BBDst)+/-1, DBuf&larr; T, Branch[GrayLoop, Cnt#0&-1];<br><br>GrayEnd:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MCount&larr; (MCount)-1, Cnt&larr; 17S, Branch[GrayLast, R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefDst&larr; (PreFetch&larr; PrefDst), Carry20, Branch[GrayLoop];<br><br>GrayLast:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; BBDst, Branch[DstFinish];<br><br>* Store last partial word.  This is the tail of cases A and B.<br>* Have already fetched the last word (at BBDst).<br>DstFinish:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp, Branch[.+2, R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDRMask[SrcWd], B&larr; MD, Branch[StoreLastDst];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDLMask[SrcWd], B&larr; MD, Branch[StoreLastDst];<br><br>* Thin destination slice, for cases A and B.<br>DstThin:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDBothMasks[SrcWd], B&larr; MD;<br>StoreLastDst:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDst&larr; T&larr; (Store&larr; BBDst)+/-1, DBuf&larr; T, FlipMemBase,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[AdvanceDst];<br><br>%*-----------------------------------------------------------<br>Case B:  dest &larr; f(gray, dest)<br><br>BBOp is taken from the following table:<br><br>    Function (class)</span><span class="tab" val="67"></span><span style="font: 10pt serif">gray</span><span class="tab" val="67"></span><span style="font: 10pt serif">srcFunc</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">dstFunc</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ALU operation<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">11 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">and</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A AND B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">12 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">or</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A OR B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">13 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">xor</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A EQV B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">15 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">and</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A AND B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">16 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">or</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A OR B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">17 (B)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TRUE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">xor</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A XOR B<br><br>The gray word is kept in SrcWd and put directly into the shifter.<br><br>Case A also dispatches to one of case B&rsquo;s entry points, GrayDstSetup.<br>The setup code dispatches to the correct body routine.<br><br>Timing, per scan line, including vertical loop overhead:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">18 cycles minimum in the normal case<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+3 cycles per full word (excluding first and last partial words)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+6 + (2 * # of pages) cycles if data needs to be "touched"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+4 + (2 * # of munches) cycles if item is wider than 20B words<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">13 cycles total in the "thin" case<br>%*-----------------------------------------------------------<br><br>GrayDstSetup&Touch: BBAt[GrayDstSetup&TouchLoc],<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; DRast, FlipMemBase, Call[TouchDst];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FlipMemBase;<br><br>GrayDstSetup: BBAt[GrayDstSetupLoc],<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; BBSrc&larr; (Fetch&larr; BBSrc)+1, FlipMemBase; * Fetch gray word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcWd&larr; MD, Fetch&larr; BBDst,</span><span class="tab" val="67"></span><span style="font: 10pt serif">* SrcWd&larr; gray word<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.+2, ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Exhausted gray block?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBSrc&larr; T-(GrayBump)-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Yes, reset for next scan line<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefDst&larr; (PreFetch&larr; PrefDst), Carry20, Branch[DstThin, Cnt=0&-1];<br>* The following dispatch may modify GrayBody to GrayDstBody.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BigBDispatch&larr; BBDisp, Branch[.+2, R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDLMask[SrcWd], B&larr; MD, Branch[GrayBody];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDRMask[SrcWd], B&larr; MD, Branch[GrayBody];<br><br>* Body routine for case B only.<br>GrayDstBody: BBAt[GrayDstBodyLoc],<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDst&larr; T&larr; (Store&larr; BBDst)+/-1, DBuf&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefSrc&larr; (Fetch&larr; T)+/-1, Branch[GrayDstEnd, Cnt=0&-1];<br><br>* Inner loop runs with one word fetched ahead (now in MD).<br>* PrefSrc is used as a temporary -- runs one word ahead of BBDst.<br>GrayDstLoop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefSrc&larr; (Fetch&larr; PrefSrc)+/-1, T&larr; MD;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShiftNoMask[SrcWd], B&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDst&larr; (Store&larr; BBDst)+/-1, DBuf&larr; T, Branch[GrayDstLoop, Cnt#0&-1];<br><br>GrayDstEnd:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MCount&larr; (MCount)-1, Cnt&larr; 17S, Branch[DstFinish, R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefDst&larr; (PreFetch&larr; PrefDst), Carry20, Branch[GrayDstLoop];<br><br>%*-----------------------------------------------------------<br>Case C:  dest &larr; f(source)<br><br>BBOp is taken from the following table:<br><br>    Function (class)</span><span class="tab" val="67"></span><span style="font: 10pt serif">gray</span><span class="tab" val="67"></span><span style="font: 10pt serif">srcFunc</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">dstFunc</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ALU operation<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 0 (C)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">null</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 4 (C)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">null</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A<br><br>Entry points to this code are at SrcDstSetup and SrcDstSetup&Touch.<br>They dispatch here after setup.<br><br>Timing, per scan line, including vertical loop overhead:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">25 cycles minimum in the normal case<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+4 cycles per full word (excluding first and last partial words)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+12 + (4 * # of pages) cycles if data needs to be "touched"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+1 cycle if 2 source words are required for the first destination word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+3 cycles if gray is required<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+4 + (5 * # of munches) cycles if item is wider than 20B words<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">17 cycles minimum in the "thin" case<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+1 cycle if 2 source words are required<br>%*-----------------------------------------------------------<br><br><br>* Body routine for case C only.<br>SrcBody: BBAt[SrcBodyLoc],<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; BBDst&larr; (Store&larr; BBDst)+/-1, DBuf&larr; T, FlipMemBase,<br>**** Program around MicroD problem.  Desired branch clause is:<br>****</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[SrcEnd, Cnt=0&-1];<br>**** but we must actually write:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRGO@[0] RETCL@[2] JCN[43];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBSrc&larr; (Fetch&larr; BBSrc)+/-1, FlipMemBase,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBAt[SrcBodyLoc, 1]; **** MicroD problem<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcWd&larr; MD, T&larr; SrcWd;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShiftNoMask[SrcWd], Branch[SrcBody];<br><br>* This is called as a subroutine at the end of each munch.<br>* It either exits the horizontal loop or returns to do another munch.<br>SrcEnd:<br>Subroutine;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MCount&larr; (MCount)-1, Cnt&larr; 17S,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">DblBranch[SrcDstFinish, SrcDstMore, R&lt;0],<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBAt[SrcBodyLoc, 2]; **** MicroD problem<br>SrcDstMore:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefSrc&larr; (PreFetch&larr; PrefSrc), Carry20;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FlipMemBase;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefDst&larr; (PreFetch&larr; PrefDst), Carry20;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FlipMemBase, Return;<br>TopLevel;<br><br>* Store last partial word, for cases C and D.<br>SrcDstFinish:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBCtrl, Branch[.+2, R even];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch extra word at end?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBSrc&larr; (Fetch&larr; BBSrc)+/-1, FlipMemBase, Branch[.+2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FlipMemBase;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcWd&larr; MD, T&larr; SrcWd, Fetch&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDisp, Branch[.+2, R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDRMask[SrcWd], B&larr; MD, Branch[StoreLastSrcDst];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDLMask[SrcWd], B&larr; MD, Branch[StoreLastSrcDst];<br><br>* Thin destination slice, for cases C and D.<br>SrcDstThin:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDBothMasks[SrcWd], B&larr; MD;<br>StoreLastSrcDst:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBDst&larr; (Store&larr; BBDst)+/-1, DBuf&larr; T, FlipMemBase,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[AdvanceSrcDst];<br><br>%*-----------------------------------------------------------<br>Case D:  dest &larr; f(source, dest)<br><br>BBOp is taken from the following table:<br><br>    Function (class)</span><span class="tab" val="67"></span><span style="font: 10pt serif">gray</span><span class="tab" val="67"></span><span style="font: 10pt serif">srcFunc</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">dstFunc</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ALU operation<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 1 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">and</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A AND B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 2 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">or</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">NOT A OR B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 3 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">normal</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">xor</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A EQV B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 5 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">and</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A AND B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 6 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">or</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A OR B<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 7 (D)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">FALSE</span><span class="tab" val="67"></span><span style="font: 10pt serif">complement</span><span class="tab" val="67"></span><span style="font: 10pt serif">xor</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">A XOR B<br><br>Case C also dispatches to these entry points.<br>The setup code dispatches to the correct body routines.<br><br>Timing, per scan line, including vertical loop overhead:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 25 cycles minimum in the normal case<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+ 5 cycles per full word (excluding first and last partial words)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+12 + (4 * # of pages) cycles if data needs to be "touched"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+ 1 cycle if 2 source words required for the first destination word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+ 3 cycles if gray is required<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+ 4 + (5 * # of munches) cycles if item is wider than 20B words<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> 17 cycles minimum in the "thin" case<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">+ 1 cycle if 2 source words are required<br>%*-----------------------------------------------------------<br><br>SrcDstSetup&Touch: BBAt[SrcDstSetup&TouchLoc],<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; DRast, FlipMemBase, Call[TouchDst];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; SRast, FlipMemBase, Call[TouchSrc];<br>SrcDstSetup: BBAt[SrcDstSetupLoc],<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBCtrl, DblBranch[SrcDstSetup2, SrcDstSetup1, R&lt;0];<br><br>SrcDstSetup2:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBSrc&larr; (Fetch&larr; BBSrc)+/-1;<br>SrcDstSetup1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefSrc&larr; (PreFetch&larr; PrefSrc), Carry20;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; MD, BBSrc&larr; (Fetch&larr; BBSrc)+/-1, FlipMemBase;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcWd&larr; MD, Fetch&larr; BBDst;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PrefDst&larr; (PreFetch&larr; PrefDst), Carry20, Branch[SrcDstThin, Cnt=0&-1];<br>* The following dispatch may modify SrcBody to SrcDstBody.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BigBDispatch&larr; BBDisp, Branch[.+2, R&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDLMask[SrcWd], B&larr; MD, Branch[SrcBody];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShMDRMask[SrcWd], B&larr; MD, Branch[SrcBody];<br><br>* Body routine for case D only.<br>SrcDstBody: BBAt[SrcDstBodyLoc],<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; BBDst&larr; (Store&larr; BBDst)+/-1, DBuf&larr; T, FlipMemBase,<br>**** Program around MicroD problem.  Desired branch clause is:<br>****</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Call[SrcDstEnd, Cnt=0&-1];<br>**** but we must actually write:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRGO@[0] RETCL@[2] JCN[103];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBSrc&larr; (Fetch&larr; BBSrc)+/-1, FlipMemBase,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBAt[SrcDstBodyLoc, 1]; **** MicroD problem<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcWd&larr; MD, T&larr; SrcWd, Fetch&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; XShiftNoMask[SrcWd], B&larr; MD, Branch[SrcDstBody];<br><br>* This is called as a subroutine at the end of each munch.<br>* It either exits the horizontal loop or returns to do another munch.<br>SrcDstEnd:<br>Subroutine;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MCount&larr; (MCount)-1, Cnt&larr; 17S,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">DblBranch[SrcDstFinish, SrcDstMore, R&lt;0],<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBAt[SrcDstBodyLoc, 2]; **** MicroD problem<br>TopLevel;<br><br>*-----------------------------------------------------------<br>TouchSrc:<br>* Touches every page of the source item for this scan line.<br>* Entry: BBSrc = address of first word of source item<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T = SRast = words per source scan line; negative =&gt; bottom-to-top<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">SrcInc = distance between last word of one scan line and<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">first word of the next; negative =&gt; bottom-to-top<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">MemBase = BBSrcBR<br>* Exit: T and BBTemp clobbered<br>* Method: touch the last words of the item.  If the item is &gt;401B<br>* words long, also touch intermediate words at multiples of 400B words from<br>* the last word of the item.<br>* Note: we don&rsquo;t also need to touch the first word of the item, since if a fault<br>* occurs on it during the BitBlt word loop, nothing will have changed yet.<br>* Note: |SRast-SrcInc| gives the number of words touched in the item;<br>* the value is positive if moving left-to-right, negative if right-to-left.<br>* Timing: 5 cycles for first page or less<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif"> +1 cycle if right-to-left<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif"> +2 cycles per additional page<br>*-----------------------------------------------------------<br>Subroutine;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(SrcInc)-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBSrc)+T, DblBranch[STouchRtoL, STouchLtoR, ALU&lt;0];<br><br>STouchLtoR:<br>* T has (# words in source item)-1, BBTemp points to last (rightmost) word.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(400C)-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (Fetch&larr; BBTemp)-(400C), Branch[.+2, ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(400C), Branch[.-1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br><br>STouchRtoL:<br>* T has -(# words in source item)-1, BBTemp points to last (leftmost) word -2.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)+(2C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fix the off-by-2 address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(400C)+1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Should be T+402, but no matter<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (Fetch&larr; BBTemp)+(400C), Branch[.+2, ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(400C), Branch[.-1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br><br>*-----------------------------------------------------------<br>TouchDst:<br>* Touches every page of the destination item for this scan line.<br>* Entry: BBDst = address of first word of destination item<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T = DRast = words per destination scan line; negative =&gt; bottom-to-top<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">DstInc = distance between last word of one scan line and<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">first word of the next; negative =&gt; bottom-to-top<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">MemBase = BBDstBR<br>* Exit: T and BBTemp clobbered<br>* Note: must dirty any words touched, to force write-protect fault.<br>* Timing: 6 cycles for first page or less<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif"> +1 cycle if right-to-left<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif"> +3 cycles per additional page<br>*-----------------------------------------------------------<br>Subroutine;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(DstInc)-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBDst)+T, DblBranch[DTouchRtoL, DTouchLtoR, ALU&lt;0];<br><br>DTouchLtoR:<br>* T has (# words in source item)-1, BBTemp points to last (rightmost) word.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(400C)-1;<br>DTouchLoopLtoR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; BBTemp, PD&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T-(400C), Branch[DTouchDoneLtoR, ALU&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Store&larr; BBTemp, DBuf&larr; MD;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)-(400C), Branch[DTouchLoopLtoR];<br><br>DTouchDoneLtoR:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Store&larr; BBTemp, DBuf&larr; MD, Return;<br><br>DTouchRtoL:<br>* T has -(# words in source item)-1, BBTemp points to last (leftmost) word -2.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)+(2C);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fix the off-by-2 address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(400C)+1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Should be T+402, but no matter<br>DTouchLoopRtoL:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Fetch&larr; BBTemp, PD&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T+(400C), Branch[DTouchDoneRtoL, ALU&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Store&larr; BBTemp, DBuf&larr; MD;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BBTemp&larr; (BBTemp)+(400C), Branch[DTouchLoopRtoL];<br><br>DTouchDoneRtoL:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Store&larr; BBTemp, DBuf&larr; MD, Return;<br></span></div>
<div style="width: 499pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
</div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
