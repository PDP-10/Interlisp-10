<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>SOURCES>LISPDMC.DM!1>LFAULTS.mc</title>
  </head>
  <body>
    <pre>
:Title[LFaults.dmc, December 6, 1982  1:28 PM, Masinter];%Lisp fault handler.If the fault was an emulator map fault or a stack error, and theemulator running at the time was Lisp, then calls the appropriatetrap procedure.For any other fault, halts at one of the following breakpoints:(In fault task, not having reset FaultInfo)	ManyFaults		More than one fault	NotEmuFault		Fault in non-emulator task	NotMapFault		Memory system fault other than map fault	UnknownFault		Fault of unknown origin(In emulator task, having reset FaultInfo)	AEmuStackError		Stack error from Alto emulator	AEmuMapFault		Map fault from Alto emulator(In emulator task, the fault task never having been awakened)	LispIFUMapFault	Map fault caused by IFU reference	LispIFUFGParity	FG parity error	LispIFURamPE		IFU decoding Ram parity error	BogusIFUMapFault	IFU gave a map fault, but the page referenced				by PCX is not vacant and shouldn't				have faulted.In the case of faults passed to the emulator task, interesting information is left in R-registers, as follows:	FltErrors	NOT (Errors')	FaultInfo	NOT (Pipe2')	FltEmuPC	Emulator TPC at time of fault	FaultVal	DBuf -- value being stored if faulted on Store&larr;%*-----------------------------------------------------------* Fault Task*-----------------------------------------------------------Set[XTask, IP[FLT]];Subroutine;FLTInitPC:   T&larr; FLT, CoReturn;TopLevel;   T&larr; A0, RBase&larr; RBase[FaultInfo];   TIOA&larr; T, Block;FaultTask:   FltErrors&larr; NOT (Errors');		* Read this always   FaultInfo&larr; NOT (Pipe2');		* Doesn't clear FaultInfo* Test for memory system fault   T&larr; (FaultInfo) AND (fi.numfaults);   PD&larr; T XOR (fi.numFaults);		* See if we have all bits set;   T&larr; Pointers, Branch[CheckStackErr, ALU=0];	* All ones =&gt; no fault* Memory system fault, see what kind   PD&larr; (FaultInfo) AND (fi.numFaults);	* All zeroes =&gt; one fault   PD&larr; (FaultInfo) AND (fi.emuFault), Branch[ManyFaults, ALU#0];   PD&larr; (FltErrors) AND (pipe4.notMapTrouble),				       Branch[NotEmuFault, ALU=0];   Branch[NotMapFault, ALU#0];* Emulator map fault.  Clear it and pass fault to emulator.   B&larr; FaultInfo', Branch[EmuFault];* Not memory system fault, check for stack overflow or underflowCheckStackErr:   PD&larr; T AND (300c);	* 200 = stack overflow, 100 = stack underflow   Branch[UnknownFault, ALU=0];* Emulator map fault or stack error.* Save emulator's state and restart emulator at Fault0.EmuFault:   FaultVal&larr; DBuf;   RdTPC&larr; EMU;   FltEmuPC&larr; NOT (Link);	* TPC data is complemented   Call[GetEmuFaultPC];   LdTPC&larr; T;   Block, Branch[FaultTask];* Fault conditions that we can't handle:ManyFaults:   Branch[.], Breakpoint;	* More than 1 faultNotEmuFault:   Branch[.], Breakpoint;	* Not Emulator faultNotMapFault:   Branch[.], Breakpoint;	* Not map faultUnknownFault:   Branch[.], Breakpoint;	* Don't know what fault occurred*--------------------------------------------------------------------* Emulator Task* The emulator is restarted here by the fault task after an emulator* map fault or stack error.*-----------------------------------------------------------Set[XTask, IP[EMU]];Subroutine;GetEmuFaultPC:   T&larr; EMU, CoReturn;TopLevel;Fault0: RBase&larr; RBase[FltPipe0],    Call[RestoreALUFM];	* In case interrupted from BITBLT   PD&larr; (FaultInfo) AND (fi.numFaults);	* Which kind of fault?   FaultMapVal&larr; NOT (Map'), Branch[StackError, ALU#0];   T&larr; VAHi;   T&larr; FltPipe0&larr; T AND (7777C);	* only want low bits   FltPipe1&larr; Q&larr; VALo;   FaultMapVal&larr; not (Pipe4');	* ref bits in pipe* Which emulator was running at the time?   FltTemp&larr; NOT (IFUMLH');   PD&larr; (FltTemp) AND (14000C);	* Test InsSet (Alto=0)   branch[.+2, alu=0], rbase&larr; rbase[spAC0];      branch[PAGEFAULTPUNT];* Page fault from alto emulator: continue in next instruction* with faulting address in AC0, 1   StkP&larr; spAC0;   Stack&amp;+1 &larr; T;   Stack&amp;-1 &larr; Q, branch[EmuNext];*--------------------------------------------------------------------* IFU traps from lisp emulatorSet[LispTrapBase, Sub[300, LShift[LispInsSet, 6]]];DontKnowRBase;TopLevel;*--------------------------------------------------------------------IFuNotReady: IFUJump[0],   at[LispTrapBase, 34];*--------------------------------------------------------------------LispReschedule:				* cf AEmuReschedule in Start.mc   rbase&larr; rbase[NWW],			at[LispTrapBase, 14];   PD&larr; NWW;   branch[.+2, ALU&gt;0];	NoReschedule, branch[.intsoff];   NWW&larr; (NWW) and not (BcplKeyMask);	* always turn off BCPL bit   pd&larr; (NWW) and not (LispKeyMask);	* if other bits on, do old NWW punt   branch[.checkWW, alu#0], pd&larr; NWW;	* if LispInterrupt on, do KeyPunt   dblbranch[KEYPUNT, .intsoff, alu#0], NoReschedule;  .checkWW:	MemBase&larr; MDS;	T&larr; (R400)+(52C);	T&larr; (fetch&larr; T) + 1;		* WW (= 452B)	T&larr; MD, ETemp&larr; (Fetch&larr; T) - 1;	* ACTIVE (= 453B)	NWW&larr; (NWW) OR T, T&larr; MD;		* WW OR NWW	NWW&larr; T&larr; T AND (Q&larr; NWW);		* (WW OR NWW) AND ACTIVE	branch[.+2, ALU=0];		branch[NWWPUNT];* no pending channel is turned on.* Save turned-off interrupts in WW, flush them from NWW, and resume execution.	Store&larr; ETemp, DBuf&larr; Q;	NoReschedule, branch[RestartIFU];.intsoff: * no interrupt enabled; check for other Reschedule conditions:   rbase&larr; rbase[LTEMP0];:if[FNStats];   pd&larr; (FnStatsPtr) - (StatsBufferBoundary);   branch[STATSPUNT, alu&gt;=0];:endif;   branch[.+2, R&lt;0], LEFT;		* is LEFT negative?   	branch[RestartIFU];   memBase&larr; StackBR;   ESP&larr; (fetch&larr; ESP) + 1;			* fetch flagword   LTEMP2&larr; Md, fetch&larr; ESP;   pd&larr; (LTEMP2) xor (FreeStackBlock);	* is it a free block?   branch[STKOVPUNT, alu#0], ESP&larr; (ESP) - 1;   T&larr; ESP&larr; (ESP) + (Md);   LEFT&larr; T - (TSP);				* recompute Left   LEFT&larr; (LEFT) rsh 1;   LEFT&larr; (LEFT) - (LeftOffset), branch[RestartIFU];*--------------------------------------------------------------------LispIFUFGparity:   At[LispTrapBase, 4], Branch[.], Breakpoint;*--------------------------------------------------------------------LispIFURamPE:   At[LispTrapBase, 74], Branch[.], Breakpoint;*--------------------------------------------------------------------LispIFUMapFault:   At[LispTrapBase, 0], MemBase&larr; ifuBR;	CHECKPCX;	PAGEFAULTOK;   T&larr; NOT (PCX');   T&larr; T RSH 1;		* PCX/2 = word address in code segment   T&larr; (FETCH&larr; T) + 1;   T&larr; MD, FETCH&larr; T;   T&larr; MD;		* Wait for fault to occurBogusIFUMapFault:   Branch[.], Breakpoint;*-----------------------------------------------------------StackError:   uCodeCheck[HWStackError];</pre>
  </body>
</html>
