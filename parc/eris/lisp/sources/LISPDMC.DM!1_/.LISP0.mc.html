<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>SOURCES>LISPDMC.DM!1>LISP0.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:Title[Lisp0.mc, January 4, 1983  2:48 PM, Masinter];<br>:insert[DisplayDefs.mc];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">mc[max.pvar.for.fault, 3000];<br>* Code for Interface with BCPL<br><br>   KnowRBase[LTEMP0];<br>   TOP LEVEL;<br>   InsSet[LispInsSet, 1];<br><br>   mc[UCODE.CHECK, 0];<br>   mc[STKOV.PUNT, sub[0,SubovFXP!]]; * says context switch to Subov<br>   mc[NWW.INTERRUPT, 2];<br>   mc[PAGE.FAULT, sub[0,FAULTFXP!]];<br>   mc[STATS.PUNT, 4];<br><br>*--------------------------------------------------------------------<br>opSUBR:   <br>*--------------------------------------------------------------------<br>   LTEMP0&larr; Id; <br>   T&larr; LTEMP2&larr; Id;<br>   T&larr; T + T;<br>   T&larr; TSP&larr; (TSP) - (Cnt&larr; T);<br>   LTEMP1&larr; SubrArgArea;<br><br><br>.subr1:<br>   memBase&larr; StackBR, branch[.subr2, Cnt=0&-1];<br>   T&larr; (fetch&larr; T) + 1;<br>   memBase&larr; MDS;<br>   LTEMP1&larr; (store&larr; LTEMP1)+ 1, dbuf&larr; Md, branch[.subr1];<br><br>.subr2:<br>   LTEMP1&larr; (Id) - (PCX&rsquo;) - 1, branch[.storepuntpc];<br><br>IFUpause[175, 3, StackBR, 0, opSUBR, noNData, 0, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*SUBRCALL<br><br>*--------------------------------------------------------------------<br>opCNTXTSWITCH:<br>*--------------------------------------------------------------------<br>   T&larr; (TSP) - 1;<br>   TSP&larr; (fetch&larr; T) - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch arg<br>   rbase&larr; rbase[NWW];<br>   T&larr; Md, NWW&larr; (NWW) and not (100000c);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* turn on interrupts<br>   pd&larr; NWW, rbase&larr; rbase[LTEMP0];<br>   branch[.+2, alu=0], LTEMP0&larr; (0s) - T; * LTEMP0&larr; - (context#)<br>   pd&larr; LTEMP0, RescheduleNow;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* reschedule if int pending...<br>   LTEMP1&larr; (Id) - (PCX&rsquo;) - 1, branch[.storepuntpc];<br><br>IFUpause[176, 1, StackBR, 0, opCNTXTSWITCH, noNData, 0, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*CNTXTSWITCH<br><br>*--------------------------------------------------------------------<br>UCODECHECKPUNT: GLOBAL, DontKnowRBase, <br>*--------------------------------------------------------------------<br><br>* call: gcall[uCodePunt];<br><br>   T&larr; Link;<br>   rbase&larr; rbase[LTEMP0];<br>   memBase&larr; MDS;<br>   LTEMP0&larr; SubrArgArea;<br>   LTEMP0&larr; (store&larr; LTEMP0) + 1, dbuf&larr; SmallHi;<br>   T&larr; (store&larr; LTEMP0) + 1, dbuf&larr; T;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rbase&larr;rbase[FLTEMUPC];<br><br>   T&larr;(store&larr; T) + 1, dbuf&larr; FLTEMUPC;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rbase&larr;rbase[PVAR];<br><br>   T&larr; (store&larr; T) + 1, dbuf&larr; PVAR;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; TSP;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; PSTATE;<br>   LTEMP2&larr; 1c;<br>   LTEMP0&larr; UCODE.CHECK, branch[BCPLEXIT];<br>*--------------------------------------------------------------------<br>RAIDPUNT:<br>*--------------------------------------------------------------------<br><br>* like UCODEPUNT, but registers are OK;<br><br>   rbase&larr; rbase[LTEMP0];<br>   memBase&larr; MDS;<br>   LTEMP0&larr; SubrArgArea;<br>   LTEMP0&larr; (store&larr; LTEMP0) + 1, dbuf&larr; SmallHi;<br>   store&larr; LTEMP0, dbuf&larr; 0c;<br>   LTEMP2&larr; 1c;<br>   LTEMP0&larr; UCODE.CHECK, branch[PUNT];<br>*--------------------------------------------------------------------<br>STKOVPUNT:<br>*--------------------------------------------------------------------<br>   LTEMP0&larr; STKOV.PUNT, branch[.puntz];<br><br>*--------------------------------------------------------------------<br>STATSPUNT:<br>*--------------------------------------------------------------------<br>   LTEMP0&larr; STATS.PUNT, branch[.puntz];<br><br>*--------------------------------------------------------------------<br>NWWPUNT:* old NWW: exit to BCPL w/reschedule still set<br>*--------------------------------------------------------------------<br>   rbase&larr; rbase[LTEMP0];<br>   LTEMP0&larr; NWW.INTERRUPT, branch[.puntz]; <br><br>*--------------------------------------------------------------------<br>KEYPUNT: KnowRBase[NWW]; * new NWW: context switch to KBD context<br>*--------------------------------------------------------------------<br>   NWW&larr; (100000c); * turn off interrupts<br>   rbase&larr; rbase[LTEMP0];<br>   LTEMP0&larr; sub[0, KbdFXP!]c, branch[.puntz];<br><br>.puntz:<br>   LTEMP2&larr; A0, branch[PUNT];<br><br>*--------------------------------------------------------------------<br>PAGEFAULTPUNT:<br>*--------------------------------------------------------------------<br>   rbase&larr; rbase[FltPipe0];<br>   memBase&larr; InterfaceBR;<br>   T&larr; IFPFAULTHI;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; FltPipe0;<br>   store&larr; T, dbuf&larr; FltPipe1;<br>   rbase&larr; rbase[LTEMP0];<br><br>* check for pagefault in BITBLT, save Stack if so<br><br>   pd&larr; (PSTATE) xor (PS.INBITBLT);<br>   branch[.+2, alu#0], memBase&larr; StackBR, T&larr; (TSP) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PSTATE&larr; A0, store&larr; T, dbuf&larr; Stack, branch[.PFOK];<br><br>:if[Debugging];<br>   branch[.PFOK, R&lt;0], PSTATE, pd&larr; (PSTATE) xor (PS.PFOK);<br>   branch[.+2, alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">uCodeCheck[IllegalFault];<br>   nop;<br>:endif;<br><br>** check for page fault in page fault context<br><br>.PFOK:<br>   pd&larr; (PVAR) - (max.pvar.for.fault);<br>   branch[.+2, carry], LTEMP0&larr; PAGE.FAULT;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">uCodeCheck[PAGEFAULTRECURSION];<br><br>:if[Debugging];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">rbase&larr; rbase[NWW];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, R&gt;=0], NWW, rbase&larr; rbase[LTEMP0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">uCodeCheck[];<br>:endif;<br><br>   LTEMP2 &larr; A0, branch[PUNT];<br>*--------------------------------------------------------------------<br>* common punt code<br>*--------------------------------------------------------------------<br>PUNT:<br>   T&larr; (PVAR) - (FXBACK[FLAGS]);<br>   memBase&larr; StackBR, PSTATE, branch[.normalpunt, R&gt;=0];<br><br>* punt in call<br><br>   fetch&larr; T, LTEMP1&larr; FXInCall;<br>   LTEMP1&larr; (LTEMP1) or Md;<br>   store&larr; T, dbuf&larr; LTEMP1;<br>   T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; NARGS;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; 0c;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* can&rsquo;t fault if DEFHI nonzero<br>   TSP&larr; (store&larr; T) + 1, dbuf&larr; DEFLO, branch[.puntfixstack];<br><br>.normalpunt:<br>   fetch&larr; T, LTEMP1&larr; FXNoPushReturn;<br>   LTEMP1&larr; (LTEMP1) or Md;<br>   store&larr; T, dbuf&larr; LTEMP1;<br>   LTEMP1&larr; not (PCX&rsquo;);<br><br>.storepuntpc: </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* from SUBR and context switch, too<br>   T&larr; (PVAR) - (FXBACK[PC]);<br>   store&larr; T, dbuf&larr; LTEMP1;<br><br>   <br>.puntfixstack:<br>   T&larr; (PVAR) - (FXBACK[NEXT]);<br>   store&larr; T, T&larr; dbuf&larr; TSP;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* store NEXT<br>   T&larr; (ESP) - T;<br>   branch[.+2, carry], TSP&larr; (store&larr; TSP) + 1, dbuf&larr; FreeStackBlock;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">uCodeCheck[NoStackAtPunt];<br>   store&larr; TSP, dbuf&larr; T;<br><br>* LTEMP0 = punt or subr#, or else (- context#)<br>* LTEMP2  = number of args<br>* PVAR ok<br><br>BCPLEXIT:<br>   memBase&larr; interfaceBR;<br>   PVAR&larr; (PVAR) - (FX.PVAR);<br>   branch[.ctxswitch, R&lt;0], Q&larr; LTEMP0;<br><br>:if[Debugging];<br>   PSTATE&larr; (PS.INBCPL);<br>:endif;<br><br>   store&larr; add[CurrentFXP!]s, dbuf&larr; PVAR;<br><br>:if[FNStats];<br>   branch[.+2, R&gt;=0], FnStatsPtr;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.bcplxend];<br>   nop;<br>   DEFLO&larr; Q, call[.subrstat];<br>   memBase&larr; MDS;<br>   T&larr; StatsBufferPtr;<br>   store&larr; T, dbuf&larr; FnStatsPtr;<br>:endif; * FNStats<br><br><br>.bcplxend:<br>   T&larr; LTEMP2, rbase&larr; rbase[spAC0];<br>   StkP&larr; spAC2;<br>   Stack&+1&larr; Q;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* value for AC2 Punt or subr #<br>   Stack&-1&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* # of args<br>   T&larr; AemuRestartLoc, branch[start];<br><br><br>   KNOWRBASE[LTEMP0];<br><br>.ctxswitch:<br>   T&larr; (0s) - (LTEMP0);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* context#<br>   fetch&larr; T;<br><br>:if[Debugging];<br>   PSTATE&larr; (PS.PCXBAD);<br>:else;<br>   PSTATE&larr; A0;<br>:endif;<br><br>   PVAR&larr; Md, store&larr; T, dbuf&larr; PVAR;<br>   PVAR&larr; (PVAR) + (FX.PVAR), branch[RTN2];<br><br><br>:if[FNStats];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SUBROUTINE;<br><br>*--------------------------------------------------------------------<br>* Stats writing<br>*--------------------------------------------------------------------<br><br>.subrstat:<br>   DEFHI&larr; A0;<br>   T&larr; LSH[LTEMP2, 10];<br>   T&larr; T or (CALL.EVENT), branch[.storestat];<br><br>FNSTAT: * fn in LTEMP0, 1, NARGS set.<br>   T&larr; LTEMP0, memBase&larr; MDS;<br>   T&larr; LCY[T, NARGS, 10];<br>   T&larr; T or (CALL.EVENT);<br>   T&larr; (store&larr; FnStatsPtr) + 1, dbuf&larr; T;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, branch[.stattail];<br><br>.storeretstat:<br>   T&larr; (RETURN.EVENT), branch[.storestat];<br><br>.storestat:<br>   T&larr; T or (DEFHI), memBase&larr; MDS;<br>   T&larr; (store&larr; FnStatsPtr) + 1, dbuf&larr; T;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; DEFLO;<br>.stattail:<br>   FnStatsPtr&larr; T;<br>   T&larr; 30c;<br>   T&larr; T + (400c);<br>   taskingoff;<br>   fetch&larr; T;<br>   T&larr; (store&larr; FnStatsPtr) + 1, dbuf&larr; Md;<br>   rbase&larr; rbase[RTClock];<br>   T&larr; (store&larr; T) + 1, dbuf&larr; RTClock;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TASKINGON;<br>   rbase&larr; rbase[FnStatsPtr];<br>   FnStatsPtr&larr; T;<br>   pd&larr; T - (StatsBufferBoundary);<br>   branch[.+2, alu&lt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ReSchedule;<br>   return;<br><br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TOP LEVEL;<br><br>:endif; * FNStats<br><br><br>*--------------------------------------------------------------------<br><br>   KnowRBase[AEmRegs];<br>   m[MBXI, KnowRBase[AEmRegs]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   Top level];<br><br>LTrap:<br>   ETEMP2&larr; Id, call[GetPC];<br>   pd&larr; (ETEMP2) - (20c);<br>   branch[.+2, alu&lt;0], ETEMP4&larr; T + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[NPTrap]; <br>   BigBdispatch&larr; ETEMP2;<br>   branch[LTrapDispatch], StkP&larr; spAC0;<br><br><br>EmuNext:<br>   rbase&larr; rbase[AEmRegs], global;<br>   T&larr; ETEMP4, branch[start];<br><br>EmuSkip:<br>   rbase&larr; rbase[AEmRegs];<br>   T&larr; (ETEMP4) + 1, branch[start];<br><br>*--------------------------------------------------------------------<br>* arrive at the Lisp dispatch locations with StkP&larr; spAC0 <br>*--------------------------------------------------------------------<br><br>LTrapDispatch:<br>   branch[MBIX], dispTable[20];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   00<br>   branch[ReadFlags];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   01<br>   branch[SetFlags];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   02<br>   branch[XferPage];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   03<br>   branch[BGetBase];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   04<br>   branch[BPutBase];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   05<br>   branch[BGetBase32];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   06<br>   branch[BGetBasePtr];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   07<br>   branch[BPutBase32];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   10<br>   branch[InitLispRegs];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   11<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&larr; A0, branch[EmuNext];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*   12   GetRamVersion<br>   branch[NPTrap];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   13   was GetFXP<br>   branch[NPTrap];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   14   was SetFXP<br>   branch[uPCTrace];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   15<br>   branch[XBitBlt];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   16<br>   branch[NPTrap];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   17 was CallFN<br><br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>MBIX:   rbase&larr; rbase[LTEMP1];<br>   LTEMP0&larr; Stack&+1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* AC0: hi part of return value<br>   LTEMP1&larr; Stack;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* AC1: lo part of return value<br><br>:if[Debugging];<br>   PSTATE&larr; (PS.PCXBAD);<br>:else;<br>   PSTATE&larr; A0;<br>:endif;<br><br>:if[FNStats];<br>   rbase&larr; rbase[PVAR];<br>   T&larr; StatsBufferPtr;<br>   memBase&larr; MDS;<br>   fetch&larr; T;<br>   FnStatsPtr&larr; Md;<br>   pd&larr; FnStatsPtr;<br>   branch[.+2, alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FnStatsPtr&larr; -1c;<br><br>:else;<br>   FnStatsPtr&larr; T-T-1;<br>   memBase&larr; MDS;<br>:endif;<br><br>* memBase=MDS<br>   rbase&larr; rbase[NWW];<br>   T&larr; (R400) + (52C);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* WW (= 452B)<br>   fetch&larr; T, T&larr; (100000C);<br>   T&larr; (Md) and not (T);<br>   NWW &larr; (NWW) or T;<br>   branch[.+2, alu=0], rbase&larr; rbase[LTEMP0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Reschedule;<br><br>   T&larr; add[100000, LShift[LispInsSet, 10]]c;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* set InsSet<br>   InsSetOrEvent&larr; T;<br><br>   MemBX&larr; 0s;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* SET MemBX<br><br>   T&larr; StackEmpty;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* set StkP<br>   StkP&larr; T;<br><br>   memBase&larr; interfaceBR;<br>   fetch&larr; add[CurrentFXP!]s;<br>   PVAR&larr; Md;<br>   PVAR&larr; (PVAR) + (FX.PVAR), branch[RTN2];</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>ReadFlags:<br>   call[flushVp], T&larr; Stack;<br>   RMap&larr; ETEMP3, call[waitforMapBuf];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* uses T only<br>   Stack&+1&larr; not (Map&rsquo;);<br>   T&larr; not (Pipe4&rsquo;);<br>   Stack&-1&larr; T and (m1pipe4.wpdref),</span><span class="tab" val="67"></span><span style="font: 10pt serif">* wp, d, & ref from pipe4<br>   branch[EmuNext];<br><br><br>   KnowRBase[LTEMP0];<br><br>*--------------------------------------------------------------<br>opREADFLAGS:<br>   T&larr; (TSP) - 1;<br>   fetch&larr; T;<br>   call[flushVp], T&larr; Md, rbase&larr;rbase[ETEMP3]; <br>   RMap&larr; ETEMP3, call[waitforMapBuf];<br><br>   pd&larr; Id, rbase&larr; rbase[TSP];<br>   branch[.+2, alu=0], LTEMP0&larr; not (Pipe4&rsquo;);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; not (Map&rsquo;), branch[.readtail];<br>   LTEMP0&larr; (LTEMP0) and (m1pipe4.wpdref), branch[.readtail];<br><br>.readtail:<br><br>   T&larr; (Id) - (PCX&rsquo;) - 1;<br>   PCF&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* restart IFU<br>   T&larr; (TSP) - 1, memBase&larr; StackBR;<br>   store&larr; T, dbuf&larr; LTEMP0, NextOpCode;<br><br>regOP1[161, StackBR, opREADFLAGS, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* readflags<br>regOP1[162, StackBR, opREADFLAGS, 1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* readrp<br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>SetFlags:<br>   StkP&larr; spAC2; <br>   T&larr; (Stack&-2) + (3c);<br>   fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch flags<br>   ETEMP2&larr; Md, T&larr; Stack&+1, call[flushVP];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*flush cache<br>   T&larr; lsh [ETEMP2, 2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* position the wp&dirty bits<br>   T&larr; T and (TIOAvacantMapEntry);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* mask out any extra bits<br>   T&larr; Stack&-1, TIOA&larr; T;<br>   B&larr; T, TASKINGOFF;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get bmux stable for Map&larr;<br>   Map&larr; ETEMP3, B&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* write the map<br>   TASKINGON;<br>   call[waitforMapBuf], TIOA&larr; ETEMP3;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* clear TIOA<br><br>* flushVp did one IFUReset, must do a second<br><br>   branch[.+2, R&gt;=0], ETEMP2, IFUReset;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* check for ref bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">fetch&larr; ETEMP3;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* reference it<br>   branch[EmuNext];<br><br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br>FlushVP:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* vp is in T, uses ETEMP3, sets memBase<br>   memBase&larr; LScratchBR, B&larr; Md;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* finish any stores<br>   IFUreset;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* stop IFU from making refs<br>   ETEMP3&larr; lsh[T, 10];<br>   T&larr; rsh[T, 10];<br>   BrHi&larr; T;<br>   BrLo&larr; ETEMP3;<br>   T&larr; 360C;<br><br> FlushVPLoop:   flush&larr; T;<br>   T&larr; T - (20C);<br>   branch[FlushVPLoop, alu&gt;=0];<br>   B&larr; Md, ETEMP3&larr; A0, return;<br><br>TOP LEVEL;<br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>XferPage: <br>   call[setXferBR], memBase&larr; BBDSTBR, T&larr; Stack&+1;<br>   call[setXferBR], memBase&larr; BBSRCBR, T&larr; Stack&-1;<br>   T&larr; rhmask;<br>   Cnt&larr; T;<br>   fetch&larr; T, flipMemBase;<br>   T&larr; (store&larr; T) - 1, dbuf&larr; Md, flipMemBase, branch[.-1, Cnt#0&-1];<br>   branch[EmuSkip];<br><br>SUBROUTINE;<br><br>setXferBR:<br>   ETEMP3&larr; RSH[T, 10];<br>   BrHi&larr; ETEMP3;<br>   ETEMP3&larr; LSH [T, 10];<br>   BrLo&larr; ETEMP3, return;<br>TOP LEVEL;<br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>BGetBase: <br>   call[BFetch];<br>   Stack&larr; Md, branch[EmuSkip];<br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>BGetBase32:<br>   call[BFetch];<br>   Stack&+1&larr; Md;<br>   fetch&larr; 1s;<br>   Stack&larr; Md, branch[EmuSkip];<br><br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>BGetBasePtr: T&larr; rhmask;<br>   call[BFetch];<br>   Stack&+1&larr; T and (Md);<br>   fetch&larr; 1s;<br>   Stack&larr; Md, branch[EmuSkip];<br><br>SUBROUTINE;<br>BFetch:<br>   memBase&larr; LScratchBR;<br>   BrHi&larr; Stack&+1;<br>   BrLo&larr; Stack&-1;<br>   fetch&larr; 0s, return;<br>TOP LEVEL;<br><br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>BPutBase: <br>   StkP&larr; spAC2;<br>   T&larr; (Stack&-2) + (3c);<br>   fetch&larr; T;<br>   T&larr; Md, call[BStore], memBase&larr; LScratchBR;<br>   B&larr; Md, branch[EmuSkip];<br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>BPutBase32: <br>   StkP&larr; spAC2;<br>   T&larr; (Stack&-2) + (3c);<br>   fetch&larr; T;   <br>   T&larr; Md;<br>   T&larr; (fetch&larr; T) + 1;<br>   T&larr; Md, fetch&larr; T;<br>   call[BStore], ETEMP2&larr; Md, memBase&larr; LScratchBR;<br>   T&larr; ETEMP2;<br>   store&larr; 1s, dbuf&larr; T, branch[EmuSkip];<br><br>*--------------------------------------------------------------------<br>SUBROUTINE;<br>BStore:<br>   BrHi&larr; Stack&+1;<br>   BrLo&larr; Stack&-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* restore to AC0<br>   store&larr; 0s, dbuf&larr; T, return;<br>TOP LEVEL;<br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>InitLispRegs:<br><br>   rbase&larr; rbase[RMForIFU];<br><br>   MemBX&larr; 0s;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* SET MemBX<br><br>   AllOnes&larr; T-T-1;<br><br>:if[Debugging];<br>   PSTATE&larr; (PS.INBCPL);<br>:endif;<br><br>   T&larr; DTDspace;<br>   LTEMP0&larr; DTDbase;<br>   memBase&larr; dtdBR, call[setBR];<br><br>   LTEMP0&larr; (LTEMP0) + (lshift[ListType!, 4]c);<br>   memBase&larr; ListpDTDBR, call[setBR];<br><br>   T&larr; STATSspace;<br>   LTEMP0 &larr; MDSTYPEbase;<br>   memBase&larr; tybaseBR, call[setBR];<br><br>   LTEMP0 &larr; UFNTablebase;<br>   memBase&larr; ufnBR, call[setBR];<br><br>   T&larr; stackHI;<br>   LTEMP0 &larr; A0,<br>   memBase&larr; StackBR, call[setBR];<br><br>   T&larr; T - 1;<br>   LTEMP0&larr; (LTEMP0) - (2c);<br>   memBase&larr; StackM2BR, call[setBR];<br><br>   T&larr; VALspace;<br>   LTEMP0&larr; A0,<br>   memBase&larr; ValSpaceBR, call[setBR];<br><br>   T&larr; A0;<br>   LTEMP0&larr; A0,<br>   memBase&larr; ZeroBR, call[setBR];<br><br>   LTEMP0&larr; A0,<br>   memBase&larr; ScratchLZBR, call[setBR];<br><br>   T&larr; DEFspace;<br>   LTEMP0&larr; A0,<br>   memBase&larr; DefBR, call[setBR];   <br><br>   T&larr; HTMAINspace;<br>   LTEMP0&larr; HTMAINbase;<br>   memBase&larr; htMainBR, call[setBR];<br><br>   LTEMP0&larr; HTOVERFLOWbase;<br>   memBase&larr; HTOfloBR, call[setBR];<br><br>   T&larr; INTERFACEspace;<br>   LTEMP0&larr; INTERFACEbase;<br>   memBase&larr; interfaceBR, call[setBR];<br><br>   memBase&larr; MDS;<br>   T&larr; and[RamVersion, 177400]c;<br>   T&larr; T + (and[RamVersion, 377]c);<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;<br><br>   T&larr; and[RamMinBcplVersion, 177400]c;<br>   T&larr; T + (and[RamMinBcplVersion, 377]c);<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;<br><br>   T&larr; and[RamMinLispVersion, 177400]c;<br>   T&larr; T + (and[RamMinLispVersion, 377]c);<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;<br><br>* now initialize/find out display width<br><br>   rbase&larr; rbase[DisplayConfig];<br>   T&larr; OR[177400, MaxWidthWordsAlto!]C, DisplayConfig,<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[ILRDisp, R even];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Branch if Alto monitor<br><br>* Switch to using the entire width of the LF monitor:<br><br>   DisplayConfig&larr; (DisplayConfig) OR (2C);<br>   T&larr; Or[177400, MaxWidthWordsLF!]C;<br><br>* T has the new words/scanline<br>* 377 in the LH to signal DHT to reinitialize.<br><br>   MaxWidthWords&larr; T;<br><br>ILRDisp:<br>   T&larr; T AND (377C);<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;<br><br>   rbase&larr; rbase[RealPages];<br>   T&larr; RealPages;<br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* # pages<br>   T&larr; 2000c;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* "dummy" #pages/module <br>   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T,</span><span class="tab" val="67"></span><span style="font: 10pt serif">* (doesn&rsquo;t matter)<br>   branch[EmuNext];<br><br>SUBROUTINE;<br><br>   KnowRBase[LTEMP0];<br>setBR:<br>   BrHi&larr; T;<br>   BrLo&larr; LTEMP0, return;<br>TOP LEVEL;<br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>uPCTrace:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* ignore<br>   branch[EmuNext];<br><br>MBXI;</span><span class="tab" val="67"></span><span style="font: 10pt serif">*--------------------------------------------------------------<br>XBitBlt:<br>   T&larr; (fetch&larr; Stack&+2) + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get pointer from Ac0<br>   T&larr; Md, fetch&larr; T;<br>   Stack&+1&larr; A0, memBase&larr; LScratchBR;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* TOS == AC3, BBTable (AC2) = 0<br>   BrHi&larr; T, T&larr; Md;<br>   BrLo&larr; T;<br>   ETEMP4&larr; (ETEMP4) + 1, SCall[BitBltSub];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* increment PC<br>   ETEMP4&larr; (ETEMP4) - 1, branch[EmuNext];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* interrupt, return .+1<br>   ETEMP4&larr; (ETEMP4) + 1, branch[EmuNext];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* normal exit, return .+3<br><br><br>*--------------------------------------------------------------<br>   TOP LEVEL;<br>   knowrbase[LTEMP0];<br>   InsSet[LispInsSet, 1];<br><br>opUPCTRACE:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Md, fetch&larr; T; rbase&larr; rbase[Events];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; Md, call[SetPCHistAddr];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NextOpCode;<br><br>regOP1[</span><span style="font: 10pt monospace">377</span><span style="font: 10pt serif">, StackM2BR, opUPCTRACE, noNData];<br><br><br>*--------------------------------------------------------------<br>* Memory system initialization stubs for lisp<br><br><br><br>InitMapWarm:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[ResumeEmulator]; * i.e., don&rsquo;t do anything<br><br>*-----------------------------------------------------------<br>WaitForMapBuf:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Wait for map operation to complete<br>* Clobbers nothing<br>*-----------------------------------------------------------<br>Subroutine;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; T-T-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PD&larr; PRef, Branch[., ALU&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* MapBufBusy is sign bit<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
