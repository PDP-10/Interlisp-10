<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>SOURCES>LISP0MC.DM!1>HtFind.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Htfind.0mc, March 23, 1983  10:21 AM, van Melle];RV[Probe, IP[lspNargs]];RV[Case, IP[lspDefx0]];RV[Entry, IP[lspDefx1]];@GcRef:	* TOS -&gt; TOS if cnt went to zero, NIL otherwise	Case &larr; 100000c, opcode[025];	* = explicit punt if collision	T &larr; NextData[IBuf];	Case &larr; (Case) + T;	T &larr; Stack&amp;-1;			* L0,1 &larr; TOS	lspL1 &larr; T;	T &larr; Stack&amp;+1, loadpage[pgHtFind];	lspL0 &larr; T, call[GcLookup];	lu &larr; (Entry) and (htStkCnt), goto[TOSGetsNILifNeq];			* Smash TOS with NIL unless Stackbit = refcnt = 0onpage[pgHtFind];* GcLookup subroutine L0,1 = Pointer, Case = operation; returns Entry, which* is guaranteed to be valid in collision bit and count field if no collision* Smashes lspLN, lspNargs, lspL5, AC2/Hi, and Case &amp; Entry (lspDefx0,1).GcLookup:	T &larr; rsh[lspL1, 1];	Probe &larr; T, UseCTask;		* Location to make probe in hash table	T &larr; APC&amp;APCTask, task;	lspL5 &larr; T;			* Save return address	lspL0 &larr; rhmask[lspL0];		* mask out any garbage in hi 8 bits	T &larr; lsh[lspL0, 7];	T &larr; (rsh[lspL1, 11]) or T;	PFetch1[MDSTypeBaseBr, lspLN];	* get Type table entry	AC2Hi &larr; (htMainSpace);		* Set up base register while waiting	AC2 &larr; (htMainBase), task;	T &larr; Probe;	lu &larr; (lspLN) and (40000c), goto[htAtom, R&lt;0];	* sign bit = no gcref*	skip[alu=0];			* test "no gcref in microcode" bit*	  goto[htPunt];			* Entry needs to be set	PFetch1[AC2, Entry];		* Get Hash table entry					* Cannot fault because table locked	lu &larr; Entry, skip[Reven];	* Pointer to collision entry if odd	  goto[htPunt];	T &larr; lsh[lspL0, 1], goto[htNotEmpty, alu#0];	* Is entry empty?	Entry &larr; T;			* Empty means Entry has count of 1	Entry &larr; (Entry) or (ht1cnt), goto[htDisp];htNotEmpty:	T &larr; ldf[Entry, 7, 10];		* get hi bits of hash table entry	lu &larr; (lspL0) xor T;		* compare with the pointer	lu &larr; (Entry) + (ht1cnt), skip[alu=0];	  Entry &larr; 1c, goto[htPunt];	* Not same, is a collision	goto[htDone, carry];		* overflow of Cnt field - just returnhtDisp:	dispatch[Case, 16, 2];	lspLN &larr; (htStkCnt), disp[htProbe];htProbe:	T &larr; Entry &larr; (Entry) + (ht1cnt), goto[htStore], disptable[3];	* case 0: addref	T &larr; Entry &larr; (Entry) - (ht1cnt), goto[htStore];	* case 1: delref	T &larr; Entry &larr; (Entry) or (htstkbit), goto[htStore];	* case 2: stkrefhtStore:				* store modified entry	lspLN &larr; (lspLN) and T;		* Mask out all but Stk &amp; Cnt fields	lu &larr; (lspLN) xor (ht1cnt);	lspLN &larr; T, skip[alu#0];	  lspLN &larr; 0c;			* Entry with cnt=1, stk=0 not stored	T &larr; Probe;	PStore1[AC2, lspLN], goto[htDone];					* Update entry in hash tablehtAtom:	Entry &larr; (ht1cnt), goto[htDone];	* atoms etc never in tablehtDone:	lspL0 &larr; rhmask[lspL0], call[retLBL];	* Mask out garbage from Punt					* And task, because next return won't	APC&amp;APCTask &larr; lspL5, goto[retLBL];htPunt:					* add case,,L0,1 to HT overflow table	T &larr; lsh[Case, 10], goto[htCallUfn, R&lt;0];	lspL0 &larr; (lspL0) + T;		* OR case into hi L0	T &larr; 100000c, call[.+1];		* Offset of overflow table	PFetch1[AC2, lspLN];		* fetch entry	lu &larr; lspLN;			* Zeros end the table	skip[alu=0], Case &larr; (Case) or (GcOverflowPunt);	* signal punt for end of op	  T &larr; (Form2[AllOnes]) + T, return;	* T &larr; T+2, return to PFetch1	PStore2[AC2, lspL0], goto[htDone];	* Store entryhtCallUfn:				* Can't defer this punt	lspUFN &larr; 025c, goto[ufnLBL];* RplPtr.n(base, ptr): store TOS at n off TOS-1, preserving the hi byte at TOS-1@RplPtr:	loadpage[pgHStack], call[CheckElt2P4], opcode[24];:IF[0];		*** old code	loadpage[pgRplPtr];	nop;onpage[pgRplPtr];	Stack&amp;-2, call[PopL2];		* Set L3,2 to ptr	T &larr; NextData[IBuf];		* get offset	lspL2 &larr; (lspL2) + T;	goto[RplPtrA1, no carry];	  lspL3 &larr; (lspL3) + (400c);	* crossed segment	goto[RplPtrA1];		* because just wrote hi base for next PFetchPopL2:				* put TOS in L3,2 for addressing				* leaves stack level alone	T &larr; Stack&amp;-1;	lspL2 &larr; T;	T &larr; rhmask[Stack&amp;+1];	lspL3 &larr; T;	lspL3 &larr; (lsh[lspL3, 10]) + T + 1, return;:ELSE;		**** new code	Stack&amp;-2;			* Point at base	T &larr; NextData[IBuf];		* word offset	T &larr; (Stack&amp;-1) + T, loadpage[pgRplPtr];	* form low base	lspL2 &larr; T, FreezeResult;onpage[pgRplPtr];	T &larr; lsh[Stack&amp;+1, 10], skip[Carry'];	* form hi base	  T &larr; (R400) + T;		* Segment cross	lspL3 &larr; T;	nop;				* wait for hi base to write:ENDIF;RplPtrA1:		* from Rplaca, Rplacd.			* Stack points at PTR, new item is above that			* L3,2 points at cell to replace in	PFetch2[lspL2, lspL0, 0];	* get old contents.  CAN FAULT	T &larr; lhmask[lspL0];RplPtrA2:				* from Rplaca	XBuf &larr; T, loadpage[pgHTFind];	Case &larr; 1c, callp[GcLookup];	* Deleteref old value	StkState &larr; rsh[StkState, 1];	Stack&amp;+2;			* point at new item	T &larr; Stack&amp;-1;	lspL1 &larr; T;	T &larr; XBuf;			* old hi byte,,0	T &larr; (rhmask[Stack&amp;-1]) or T;	lspL0 &larr; T;			* L0,1 &larr; old hi byte,,new item RplPtr1:			* From GVAR&larr;.  L0,1 = words to store at L3,2	PStore2[lspL2, lspL0, 0];	* Store new value, no fault	loadpage[pgHTFind];		* Case &larr; 0 in rh, punt flag remains	Case &larr; lhmask[Case], callp[GcLookup];	* Addref new value	GcExit:			* Come here at end of gcreffing instructions			* normal finish, unless htpunt was called for	lu &larr; (Case) and (GcPunts);	lu &larr; (Case) and (CreateCellPunt), skip[alu#0];	  NextOpCode;	lspDefx1 &larr; (atomGCOVERFLOW), skip[alu=0];	  lspDefx1 &larr; (atomGCGENPUNT);	* more general punt needed	loadpage[pgFrame];	lspNargs &larr; 1c, gotop[lspCallFn0];* Gvar&larr;, op 27: Set top value of atom alpha,beta to TOS@SetGvar:	loadpage[pgRplPtr], opcode[27];	lspL3 &larr; (VALspace);onpage[pgRplPtr];	T &larr; NextData[IBuf];	lspL2 &larr; T;	T &larr; NextData[IBuf];	lspL2 &larr; (lsh[lspL2, 10]) or T, task;	* L2 &larr; atom number to set	lspL2 &larr; lsh[lspL2, 1];		* Point at value cellSetGvar1:				* Here from SETF	PFetch2[lspL2, lspL0, 0];	* fetch old top value; CAN FAULT	loadpage[pgHTFind];	Case &larr; 1c, callp[GcLookup];	* Deleteref old value		T &larr; Stack&amp;-1;	lspL1 &larr; T;			* L0,1 &larr; TOS	T &larr; Stack&amp;+1;	lspL0 &larr; T, goto[RplPtr1];* Rplaca (LST ITEM)@Rplaca:	loadpage[pgHStack], call[CheckElt2P4], opcode[030];	Stack&amp;-2, call[lspTyp];		* check type of LST (below ITEM)	loadpage[pgRplPtr];	lu &larr; (lspType) - (listType);onpage[pgRplPtr];	skip[alu=0];			* ok if listp	  lspUFN&larr; 30c, goto[ufnLBL];					* LST is now in L3,2 from lspTyp	PFetch2[lspL2, lspL0, 0];	* look at old cdrcode,,car	T &larr; lhmask[lspL0];		* cdrcode	goto[RplPtrA2, alu#0];		* cdrcode#0 is normal, do Rplptr	T &larr; lsh[lspL0, 10];		* indirect: this is hiloc shifted	lspL3 &larr; T;	T &larr; lspL1;			* loloc indirect	lspl2 &larr; T, goto[RplPtrA1];	* go do RPLPTR with fetch@Rplacd:	lspUFN&larr; (031c), goto[lspUfnxP4], opcode[031];	* Rplacd%@Rplacd:		* (RPLACD LST NEWCDR) =&gt; LST	loadpage[pgHStack], call[CheckElt2P4], opcode[031];	Stack&amp;-2, call[lspTyp];		* get LST in L3,2, type in lspType	loadpage[pgRplacd];	lu &larr; (lspType) - (listtype);onpage[pgRplacd];	lspUFN &larr; 31c, skip[alu=0];	  goto[ufnLBL];RplacdFetch:	Pfetch2[lspL2, lspL0, 0];	* fetch contents of cell	T &larr; lhmask[lspL0];		* get cdrcode	XBuf1 &larr; T, goto[Rplacd1, alu#0];	T &larr; lspL0;	lspL3 &larr; T;			* follow indirect...	T &larr; lspL1;	lspL2 &larr; T, goto RplacdFetch;Rplacd1:				* contents of cell in 0,1	goto[RplacdIndirect, alu&gt;=0];	* indirect on page	Stack&amp;+2;			* Point Stack back at NEWCDR	T &larr; Stack&amp;-1;	lspL1 &larr; T;	T &larr; Stack&amp;-1;			* Stack points at LST now	lspL4 &larr; T, goto[RplacdNIL, alu=0];	* NEWCDR in 4,1	lu &larr; (lspL3) xor T;		* compare hi words of LST, NEWCDR	skip[alu=0];	  goto[ufnLBL];			* NEWCDR not on LST's page	T &larr; lhmask[lspL1];	T &larr; (lhmask[lspL2]) xor T;	* compare lo parts of page numbers	skip[alu=0];	  goto[ufnLBL];			* NEWCDR not on LST's page	T &larr; lsh[lspL1, 7];		* cell # of NEWCDR in left half	T &larr; (rhmask[lspL0]) or T;	* new contents of LST, minus 200 bit	XBuf2&larr; T;			* save it	T &larr; lspL4;	lspL0 &larr; T, loadpage[pgHtFind];	* NEWCDR now in 0,1	Case&larr; 0c, callp[GcLookup];	* Addref NEWCDRRplacdSmash:				* Old cdrcode in lh of XBuf1					* almost new cdr code word in XBuf2					* LST in L3,2	T &larr; XBuf1 &larr; ldf[XBuf1, 1, 10];	* 2 * old cdrcode	T &larr; (lhmask[lspL2]) + 2;	* point at old cdr	lspL1 &larr; T;	T &larr; lspL3;	lspL0 &larr; T, loadpage[pgHtFind];	* old cdr now in 0,1	Case &larr; (lhmask[Case]) + 1, callp[GcLookup]; 	* deleteref old cdr	XBuf2 &larr; (XBuf2) or (100000c);	* set cdr on page bit	PStore1[lspL2, XBuf2, 0];	* update LST's cdr code	loadpage[pgRplPtr];	StkState&larr;rsh[StkState,1], gotop[GcExit];				* done, having popped once, check for puntRplacdNIL:				* Hiloc(NEWCDR) = 0	lu &larr; lspL1;			* Loloc(NEWCDR)	XBuf2 &larr; 0c, goto[RplacdSmash, alu=0];	  goto[ufnLBL];			* NEWCDR not NIL, so punt	RplacdIndirect:				* indirect on page, cdrcode in XBuf1	T &larr; ldf[XBuf1, 1, 10], loadpage[pgRplptr];	* 2 * old cdrcode	lspL2 &larr;(lhmask[lspL2]) + T, gotop[RplptrA1];				* point 3,2 at loc of cdr, go do RplPtr on it	%	* GcScan1, op 173@GcScan1:	T &larr; 0c, goto[GcScanx], opcode[173];* GcScan2, op 174@GcScan2:	T &larr; 100c, opcode[174];	lspL0 &larr; (htStkBit);		* Pattern = Collision bit or Stack bit 	lspL0 &larr; (lspL0) + 1, goto[GcScanx];GcScanx:	Saluf &larr; T, T &larr; Stack&amp;-1;	* MB &larr; 0 for GcScan1, 1 for GcScan2	lspGenBrHi &larr; (htMainSpace);	lspGenBr &larr; (htMainBase);	lspLN &larr; T, loadpage[pgGcScan];	PFetch4[lspGenBr, XBuf];onpage[pgGcScan];GcScanRestart:	Dispatch[lspLN, 16, 2];	T &larr; lspLN &larr; (lspLN) and not (3c), disp[.+1];	lu &larr; 0c, goto[GcSa0], disptable[4];	* == instr at GcSa0+1	lu &larr; 0c, goto[GcSa1];			* == T &larr; XBuf, goto[GcSa0];	lu &larr; 0c, goto[GcSa2];			* == T &larr; XBuf1, goto[GcSa1];	lu &larr; 0c, goto[GcSa3];			* == T &larr; XBuf2, goto[GcSa2];GcScanLoop:	PFetch4[lspGenBr, XBuf], call[retLBL];	* get 4 words, task	T &larr; XBuf3;GcSa3:	T &larr; XBuf2, goto[GcSc3, alu#0];GcSa2:	T &larr; XBuf1, goto[GcSc2, alu#0];GcSa1:	T &larr; XBuf, goto[GcSc1, alu#0];GcSa0:	lu &larr; lspLN, goto[GcSc0, alu#0];	T &larr; lspLN &larr; (lspLN) - (4c), dblgoto[GcScanLoop, GcScanDone, alu#0];GcSc3:	lspLN &larr; (lspLN) + (3c);	T &larr; XBuf3, dblgoto[GcCheck2, GcCheck1, MB];	GcSc2:	lspLN &larr; (lspLN) + (2c);	T &larr; XBuf2, dblgoto[GcCheck2, GcCheck1, MB];	GcSc1:	lspLN &larr; (lspLN) + (1c);	T &larr; XBuf1, dblgoto[GcCheck2, GcCheck1, MB];	GcSc0:	T &larr; XBuf, dblgoto[GcCheck2, GcCheck1, MB];GcCheck1:			* In GcScan1: Check for collision or stk=cnt=0	lspL1 &larr; T;	lu &larr; (lspL1) and (htStkCnt), skip[Reven];	  T &larr; lspLN, goto[GcScanFound];		* Collision bit on	skip[alu#0];	  T &larr; lspLN, goto[GcScanFound];		* Stk=cnt=0	goto[GcScanRestart];		* combine with GcCheck2+1? (senses are reversed)GcCheck2:			* In GcScan2: Check for collision or stk	lu &larr; (lspL0) and T;	* L0 set up the desired pattern at init	T &larr; lspLN, dblgoto[GcScanFound, GcScanRestart, alu#0];GcScanDone:	T &larr; Stack &larr; 0c;		* TOS &larr; NIL when doneGcScanFound:	Stack&amp;+1 &larr; T, goto[nxiLBL];	* TOS &larr; offset of find@ReclaimCell:	* (PTR) =&gt; newptr or NIL*	lspUFN &larr; (172c), goto[lspUfnxP5], opcode[172];	* ReclaimCell	loadpage[pgReclaim], opcode[172];	nop;onpage[pgReclaim];	loadpage[pgTyp];	callp[lspTyp];	lu &larr; (lspType) - (listtype);	lspUFN &larr; 172c, skip[alu=0];	  goto[ufnLBL];			* punt if nlistp	PFetch2[lspL2, lspL0, 0];	* contents of cell -&gt; L0,1	T &larr; lhmask[lspL0];		* get cdrcode	skip[alu#0];	  goto[ufnLBL];			* punt on full indirect (cdrcode=0)%---------	T &larr; lhmask[lspL0], skip[R&lt;0];	* get cdrcode, skip if 200 bit on	  goto[ufnLBL];			* punt on indirect cases---------%	XBuf &larr; T, call[FreeListCell];	* save cdr code, free cell L2,3	loadpage[pgHtFind];	Case &larr; 1c, call[GcLookup];	* deleteref car	Stack&amp;-1 &larr; 0c;			* TOS &larr; NIL	Stack&amp;+1 &larr; 0c, call[ReclaimCheck];  * Put car on stack if cnt is zero	T &larr; ldf[XBuf, 1, 10];		* cdrcode lsh 1	goto[ReclaimDone, alu=0], T &larr; lspL2&larr; (lhmask[lspL2]) + T;				* point at cdr cell, or finished if cdr nil	lu &larr; XBuf, goto[ReclaimCdr1, R&lt;0];	* Case 1 is cdr on page, easy	PFetch2[lspL2, lspL0, 0];		* Get contents of cdr's cell	call[FreeListCell];			* Free the cell itself	T &larr; rhmask[lspL0], goto[ReclaimCdr2];	* cdr = contents of cellReclaimCdr1:	lspL1 &larr; T;			* lo half of cdr	T &larr; rsh[lspL3, 10];ReclaimCdr2:	lspL0 &larr; T, loadpage[pgHtFind];	* hi half	call[GcLookup];			* deleteref cdr	call[ReclaimCheck];		* put cdr on stack if cnt is zeroReclaimDone:	loadpage[pgRplPtr];	gotop[GcExit];			* check for htpuntReclaimCheck:	* Replace TOS with L0,1 if Entry is a zero-count ht entry	lu &larr; (Entry) and (htstkcnt), skip [REven];	  return;			* Collision entry, so unknown	T &larr; lspL0, skip[alu=0];	  return;			* Stkbit,,cnt nonzero	Stack&amp;-1 &larr; T;	T &larr; lspL1;	Stack&amp;+1 &larr; T, return;FreeListCell:	* L3,2 points at cell to free.  L0 is contents of its first word.	* Smashes L3,2 to point at pagebase.  Smashes L4, lh[L0], XBuf2,3	T &larr; rhmask[lspL2];		* offset in page	lspL2 &larr; lhmask[lspL2];		* point to page base	Pfetch2[lspL2, XBuf2, 0];	* get count,,nextcell, nextpage	lspL4 &larr; T;			* save offset	lu &larr; XBuf3, skip[R&gt;=0];		* nextpage = -1 is punt case.		* NOTE: Assumes &lt; 24-bit addrs, or no lists on negative pages	  goto[ufnLBL];			* punt if this page not in free chain	T &larr; lsh[XBuf2, 10];		* next cell, shifted to high byte	lspL0 &larr; (rhmask[lspL0]) or T;	* make it cdr code at cell	T &larr; lspL4;	Pstore1[lspL2, lspL0];		* store it back in cell	XBuf2 &larr; (XBuf2) + (400c);	* increment count	XBuf2 &larr; (lhmask[XBuf2]) or T;	* make it count,,celloffset:IF[BreakPoints];	lu &larr; XBuf2, skip[REven];	  breakpoint;:ENDIF;	Pstore1[lspL2, XBuf2, 0];	* store it back on page	return;				* allow XBuf2 write	:END[Htfind];</pre>
  </body>
</html>
