<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>SOURCES>LISP0MC.DM!1>Ops.0mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:TITLE[Ops.0mc, June 29, 1983  3:42 PM, vanMelle];<br><br>* Swap, op 375, Swap TOS and TOS-2<br>@Swap:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack], call[checkElt2P7], opcode[375];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-3, call[Swap1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+2 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1, call[Swap1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+2 &larr; T, goto[nxiLBL];<br><br>Swap1:</span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&+2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-2 &larr; Stack&-2, return;<br><br><br>* Eq, op 360, Compare TOS and TOS-2, push T or Nil if eq or not, resp<br>@Eq:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack], call[checkElt2P7], opcode[360];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rsh[StkState, 1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (Stack&+1) xor T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-2, FreezeResult, skip[alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lu &larr; (Stack) xor T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* If lolocs were eq, test hi&rsquo;s<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; 0c, skip[alu#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* about to push T or NIL...<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Stack&+1 &larr; (KtVal), goto[nxiLBL];<br>PushTP7:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T, goto[nxiLBL];<br><br><br>* Nop , op 376, Nop<br>@Nop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NextOpCode, opcode[376];<br><br><br>* Pop ,  op 277, Pop stack, ignore the item<br>@Pop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-2, goto[PopChk6], opcode[277];<br><br><br>* Listp, op 003, Replace TOS with Nil if TOS is not a list<br>@Listp:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[lspTyp], opcode[003];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspType) - (listType);<br>TOSGetsNILifNeq:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Replace TOS with NIL if alu#0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  NextOpCode;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; 0c;<br>PushTP4:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T, goto[nxiLBL];<br><br><br>* Ntypx, op 004, Replace TOS with type of TOS<br>@Ntypx:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[lspTyp], opcode[004];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* pop stack, get type in T and Type<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; (smallpl), goto[PushTP4];<br><br><br>* Typep, op 005, Replace TOS with Nil if TOS is not type number of alpha byte<br>@Typep:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[lspTyp], opcode[005];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* pop stack, get type in T and Type<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspType) - T, goto[TOSGetsNILifNeq];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* could be just lu &larr; NextData[IBuf] - T, goto[TOSGetsNILifNeq];<br><br>* Dtest, op 006, test if type name of TOS = arg, ufn if not<br>@Dtest:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[lspTyp], opcode[006];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* get type of TOS into Type<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspGenBrHi &larr; (DTDSpace);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* point at DataTypeDescriptor table<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspGenBr &larr; (DTDBase);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[lspType, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* table is indexed by type<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspGenBr, lspType];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Type &larr; typename(TOS)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (lsh[lspL1, 10]) or T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* T &larr; alpha,,beta<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspType) - T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* is T same as typename?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspNargs &larr; 2c, skip[alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  NextOpCode;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Yes, return tos as is<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* do ufn call inline here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; lsh[StkState, 1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* account for push<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; (smallpl);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* push typename atom as smallp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T, loadpage[pgFrame];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspDefx1 &larr; (atomDTESTFAIL), goto[lspCallFn0];<br><br><br>onpage[pgTyp];<br>* Subroutine to get data type of TOS, returns it in T and lspType;<br>* transfers TOS into L3,2 in form suitable for use as a base reg pair<br>lspTyp:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[Stack&+1, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL3 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rsh[lspL2, 11];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (rsh[lspL3, 1]) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[</span><span style="font: 10pt serif">MDSTypeBaseBr</span><span style="font: 10pt serif">, lspType];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspType &larr; rhmask[lspType], return;<br><br>* CAR, op 001, replace TOS with car[TOS]<br>@Car:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[lspTyp], opcode[001];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* TOS in L2, 3, type in lspType<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspType) - (listtype);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 001c, skip[alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[CarCdrNilP];<br>lspCar1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[lspL2, lspL0, 0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; lhmask[lspL0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[lspL0], goto[CdrTail, alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[lspL0, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* indirect cell: L3,2 &larr; L0,1, retry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL3 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; T, goto[lspCar1];<br><br>* CDR, op 002, replace TOS with cdr[TOS]<br>@Cdr:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[lspTyp], opcode[002];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspType) - (listtype);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 002c, skip[alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[CarCdrNilP];<br>lspCdr3:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[lspL2, lspL0, 0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; ldf[lspL0, 1, 7], skip[R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* T &larr; cdr code<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lspL2 &larr; (lhmask[lspL2]) + T, dblgoto[lspCdr1, lspCdr2, alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; (lhmask[lspL2]) + T, goto[lspCdrNil, alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (lspL2) + T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* cdr is on page at offset 2*T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rsh[lspL3, 10];<br>CdrTail:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Here with Hiloc[cell] in T, lo in L1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL1, goto[PushTP4];<br><br>lspCdr1:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* cdr full indirect<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[lspL0, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* L3,2 &larr; L0,1, retry<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL3 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; T, goto[lspCdr3];<br><br>lspCdrNil:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1 &larr; 0c, goto[PushTP4];<br><br>lspCdr2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* cdr indirect on page: cdr is contained in cell at page + 2*cdrcode<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[lspL2, lspL0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[lspL0], goto[CdrTail];<br><br>CarCdrNilP:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Car/cdr of non-list<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (Stack&+1) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  NextOpCode;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">goto[ufnLBL];<br><br>* Bin, op 40.  Takes TOS = Stream, returns byte as smallp<br>:IF[WithBin];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* new Bin (5 mi shorter)<br>@Bin:</span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL6 &larr; (StreamType), call[lspTyp], opcode[40];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspL6) - T, loadpage[pgBin];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Is it a STREAM?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 040c, skip[alu=0];<br>onpage[pgBin];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[lspL2, XBuf, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch first 4 words of Stream<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* = Offset, NChars, Flags,,Buffer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[XBuf2], skip[R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Is Buffer Binable?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* lspL1 &larr; bufHi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; (lsh[lspL1, 10]) + T + 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* convert to baseregHi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; XBuf1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* nbr Chars in buffer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (XBuf) - T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Current Offset - NChars<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; XBuf3, skip[alu&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Past end of buffer?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; T, loadpage[opPage3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* L0 &larr; baseregLo<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rsh[XBuf, 1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Get Current pos as word ptr<br>onpage[opPage3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspL0, lspL1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch data word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XBuf &larr; (XBuf) + 1, dblgoto[.+2,.+1, R odd];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Increment position, check which byte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> T &larr; rsh[lspL1, 10], skip;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* even byte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  T &larr; rhmask[lspL1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* odd byte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspL2, XBuf, 0], goto[TOSGetsTSmall];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store back modified OFD, push byte on stack<br>:ELSE;<br>@Bin:</span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 40c, goto[lspUfnxP4], opcode[40];<br>:ENDIF;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br>:IF[0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* old Bin<br>@Bin:</span><span class="tab" val="67"></span><span style="font: 10pt serif">call[lspTyp], opcode[40];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgBin];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspType) - (StreamType);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Is it a STREAM?<br>onpage[pgBin];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 040c, skip[alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[lspL2, XBuf, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch first 4 words of Stream<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* = Offset, NChars, Flags,,Buffer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; XBuf1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* nbr Chars in buffer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (XBuf) - T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Current Position - NChars<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu&lt;0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Past end of buffer?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[XBuf2], skip[R&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Is Buffer Readable?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; (lsh[lspL1, 10]) + T + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; XBuf3, task;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rsh[XBuf, 1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Get Current pos as word ptr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspL0, lspL1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch data word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XBuf &larr; (XBuf) + 1, skip[R odd];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Increment position, check which byte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> lspL1 &larr; rsh[lspL1, 10], skip;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">nop;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Wait for XBuf to get written<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[lspL2, XBuf, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store back modified OFD<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; (smallpl);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Push byte as small int<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[lspL1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T, goto[nxiLBL];<br>:ENDIF;<br><br>RV[Case, IP[lspDefx0]];<br><br>* (RPLCONS LST ITEM) does (CDR (RPLACD LST (CONS ITEM NIL)))<br><br>:IF[WithCons];<br>@RplCons:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack], call[CheckElt2P4], opcode[046];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-2, call[lspTyp];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get LST in 3,2, type in Type<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgCons];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspType) - (listType);<br>onpage[pgCons];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 46c, skip[alu=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* set UFN for punt, skip if listp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* punt if LST not list<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Pfetch1[lspL2, lspL4, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* L4 &larr; hiword of LST (can fault)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 200c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (rsh[lspL4, 10]) xor T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* compare cdr code against cdr.nil<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL4, skip[alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* punt if (CDR LST) not NIL<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XBuf &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Save old contents for later so we can update cdr code<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; lhmask[lspL2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* point L3,2 at LST&rsquo;s page<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Case &larr; 0c, call[MakeConsCell];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* get back CONS = L3,2 </span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* we are committed to finishing now<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[GetListpDTD];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* stack points at LST now<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+2, call[IncrementConsCount];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* now points at ITEM<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[Stack&-1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; T, loadpage[pgHtFind];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* ITEM in 0,1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Case &larr; lhmask[Case], call[GcLookup];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Addref ITEM.  Preserves 2,3<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* loloc(LST)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL5 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* save for below<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL2;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* loloc(CONS)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Smash LST on stack (hiloc&rsquo;s are same)<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; (lspL0) or (100000c);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Put cdr.nil code in ITEM<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore2[lspL2, lspL0, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store cdr.nil,,ITEM in CONS<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[lspL2, 7];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 2*Offset of CONS, shifted to cdr code<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XBuf &larr; (XBuf) or T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* insert in hi word of old LST<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* (200 bit already known to be on)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL5;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* loloc(LST)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 2,3 now points at LST<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[lspL2, XBuf, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store cdr code back to LST<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgRplptr];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rsh[StkState, 1], goto [GcExit];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Account for stack decrement, go check for htpunt<br><br><br>@Cons:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack], call[CheckElt2P4], opcode[032];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[lspTyp];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get CDR in 3,2, type in Type<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgCons];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspType) - (listType);<br>onpage[pgCons];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 32c, goto[ConsList, alu=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* set UFN for punt, do listp case<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL3, call[GetListpDTD];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspL2) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">goto[ConsNil, alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">goto[ufnLBL];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* cdr non-NIL non-list<br><br>ConsNil:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">nop;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Even<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-2, call[GetNextConsPage];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* pop off cdr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Case &larr; 0c, call[MakeConsCell];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[IncrementConsCount];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XBuf&larr; 200c, goto[ConsTail];<br><br>ConsList:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; lhmask[lspL2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Point at cdr&rsquo;s page<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Case &larr; 0c, call[MakeConsCell];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* L2 returns pointer to Cons cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">call[GetListpDTD];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Pop CDR into 0,1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T, call[IncrementConsCount];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* cdr is in 0, 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHtFind];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Case &larr; 0c, callp[GcLookup];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Addref Cdr pointer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; 200c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (ldf[lspL1, 10, 7]) + T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">XBuf &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* cdr code<br><br>ConsTail:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&+1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; T, loadpage[pgHtFind];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Case &larr; lhmask[Case], callp[GcLookup];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Addref car pointer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[XBuf, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; (rhmask[lspL0]) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore2[lspL2, lspL0, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store cons cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rsh[lspL3, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Shift hiword to normal place<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Put ptr on stack<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T, loadpage[pgHtFind];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Case &larr; (lhmask[Case]) + 1, callp[GcLookup];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Deleteref cons cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgRplPtr];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rsh[StkState, 1], gotop[GcExit];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Check for htoverflow<br><br>GetListpDTD:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Set lspGenBr, BrHi to point at DTD for type LISTP<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspGenBrHi &larr; (DTDSpace);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspGenBr &larr; (DTDBase);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspGenBr &larr; (lspGenBr)+(120c), return;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 120 = Listtype lsh 4<br><br>IncrementConsCount:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* assumes lspGenBrHi,Br points at LISTPDTD<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1 [lspGenBr, lspL0, 14];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* old cons count from LISTPdtd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; (lspL0)+1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* increment count<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspL0) - (MaxNewCellCount);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* has count gotten too high?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[lspGenBr, lspL0, 14], skip[alu&lt;0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* store updated count<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Case &larr; (Case) or (40000c);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* cause punt later<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">return;<br><br>GetNextConsPage:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* set L2,3 pointing at a cons page, or punt.<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* smashes L0<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspGenBr, lspL0, 15];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get LISTPDTD:NextPage<br> </span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; lspL0;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* No page if 0<br> </span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu#0];<br> </span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lhmask[lspL0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* form address from page#<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL3 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* hiloc of page address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[lspL0, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; T, return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* loloc of page address<br><br>MakeConsCell:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* enter with L2,3 addressing desired cons page<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* lspUFN = opcode that called it (for punt)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* returns L2,3 pointing at new cons cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">* smashes L0,4,5<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspL2, lspL0, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get count, next cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[lspL0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL5 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Save offset of cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspL2, lspL4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* L4 &larr; hiword of new cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0&larr; (lspL0) - (400c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* subtract 1 from count<br> </span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* call UFN if no cells left<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rsh[lspL4, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* offset of next free cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0&larr; (lhmask[lspL0]) or T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[lspL2, lspL0, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store count, next cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL5;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* word# in page of new cell<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; (lspL2) or T, return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Create ptr to new cell<br><br>:ELSE;<br>@RplCons:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 46c, goto[lspUfnxP4], opcode[46];<br>@Cons:</span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 32c, goto[lspUfnxP4], opcode[32];<br>:ENDIF;<br><br><br>* CreateCell[type] -&gt; Cell.  No change to stack state<br><br>:IF[WithCreateCell];<br>@CreateCell:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[Stack&-1, 4], call[XCreateCell], opcode[37];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgRplPtr];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">gotop[GcExit];<br><br>XCreateCell:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (Stack&+1) xor (smallpl);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Punt if type not smallp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">qBuf &larr; T, UseCTask, goto[DoCreateCella, alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lspUFN &larr; 37c, goto[ufnLBL];<br><br>* CreateCell subroutine.  Enter with qBuf = lsh[type#,4].<br>* Returns with TOS replaced by new cell, whose base address is in lspGenBr.<br>* Caller must finish by going to GcExit.<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">onpage[opPage0];<br><br>DoCreateCell:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UseCTask;<br>DoCreateCella:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; APC&APCTask;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL6 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Save return address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">qBuf1 &larr; (DTDSpace);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* form basereg for DTD<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">qBuf &larr; (qBuf) + (DTDBase);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* finish forming basereg<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch4[qBuf, uBuf, 0], call[retLBL];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch out of DTD for this type:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* uBuf = name (not used)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* uBuf1 = Size in words<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* uBuf2,3 = FREE<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* cannot fault?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[qBuf, lspL4, 14];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* L4 &larr; DTD:COUNTER<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[uBuf2];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* FreeHi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (uBuf3) or T, loadpage[pgCreateCell];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* test that free # nil<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; T, goto[CreateNIL, alu=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* need Hi here for Gcref<br>onpage[pgCreateCell];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (lsh[uBuf2, 10]) + T + 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* form basereghi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspGenBrHi &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; uBuf3;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* FreeLo<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspGenBr &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* here for addressing<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* here for Gc<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[lspGenBr, uBuf2, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* get old contents of FREE = new FREE<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* can fault<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf &larr; 0c;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">xBuf1 &larr; 0c;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Prepare for clearing...<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; uBuf1, call[CreateDec];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* point at end of region for clearing, top down<br><br>CreateLp:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore2[lspGenBr, xBuf];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Clear two words; can fault<br>CreateDec:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (Form-2[AllOnes]) + T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* T &larr; T-2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* to CreateLp<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* no more faults possible now<br>:IF[IFE[pgHtFind, pgCreateCell, 0, 1]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHtFind];<br>:ENDIF;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Case &larr; 1c, callp[GcLookup];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Deleteref new cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore4[qBuf, uBuf, 0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store back new FREE and old friends<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL4 &larr; (lspL4) + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* increment counter<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[uBuf2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (uBuf3) or T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Check new FREE = NIL<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspL4) - (MaxNewCellCount), skip[alu#0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* increment counter<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Case &larr; (Case) or (CreateCellPunt);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Punt later if freelist empty<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL0, skip[alu&lt;0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  Case &larr; (Case) or (CreateCellPunt);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Punt later if counter too high<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* TOS &larr; new cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[qBuf, lspL4, 14];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store counter back<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APC&APCTask &larr; lspL6, goto[retLBL];<br><br>CreateNIL:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Freelist is empty, so need to punt,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* but lspUFN is not set.  Assume only<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* one-byte opcodes call us<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (PCXReg) - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* back up PCF<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PCF &larr; lspUFN, call[retLBL];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* wait for it to write<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* reread current instruction<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; T, goto[ufnLBL];<br><br>:ELSE;<br>@CreateCell:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUfn &larr; 37c, goto[lspUfnxP4], opcode[37];<br>:ENDIF;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">:END[Ops];<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
