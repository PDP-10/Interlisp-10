<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>SOURCES>LISPBCPLFILES.DM!1>MainInit.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">// MainInit.bcpl.  Bulk of the initialization code.<br>// Last change July 20, 1983  2:23 PM by Bill van Melle<br>// Last change May 25, 1983  11:22 AM by Bill van Melle<br>// Last change March 24, 1983  9:06 PM by Bill van Melle<br>// Last change December 21, 1982  5:18 PM by Bill van Melle<br>// reorganized dsk init June 8, 1982  9:57 PM by Bill van Melle<br>// Last change May 24, 1982  12:14 PM by Bill van Melle<br>// InitLispRegs change May 19, 1982  10:23 PM by Bill van Melle<br>// command parse change March 19, 1982  1:05 PM by Bill van Melle<br>// Last change March 18, 1982  1:42 PM by Bill van Melle<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "AltoFileSys.d"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "AltoDefs.d"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "LispBcpl.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Stats.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Streams.d"<br><br>external [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// defined here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocVec; MainInit; ShortStack; SavedUFP; SavedSCP; GiveUp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SwapCursors; RestoreCursor<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// O.S. procedures<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Resets; Closes; MoveBlock; ReadBlock; CreateDiskStream; FileLength<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">InitializeZone; Zero; Usc; Max; Min; CharWidth; SetFilePos<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Allocate; Wss; Endofs; Gets; OpenFile; ShowDisplayStream; PositionPage<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MyFrame; CallSwat; SysErr<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// OS statics <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dsp; sysZone; sysFont; fpSysDir; fpComCm; fpSysFont; sysDisk; fpRemCm<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UserName; lvSysZone; lvSysErr; lvUserFinishProc<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// other library procedures<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LookupEntries; SetupReadParam; ReadParam; EvalParam<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// LIsp procedures<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MachineType; Version; LispFinishProc; InitLispRegs<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Serial; IPutBase; LoadRam; LISPFINISH<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// SUBR base, some init code base<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">uCodeCheck; InitFmap<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// initialization only<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">GetRamVersion; SetupLispMem; KBDinit; RemoteInitVmem; LocalInitVmem<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics exported<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocPtr; AllocEnd; AllocInFirstBlock; lastStaticAllocation<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">statsFP; sysFontCharWidth<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ScreenWords; callRaid<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RamVersion; MinLispForRam<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">HostMagic0; HostMagic1; HostMagic2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VmemStream; SysinName<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">fillMemory; haveUcode; altoUcodeFp; uCodeLoaded<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">extraBuffers; extraBufLength<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@SubrBase; @lvNIL; @lvKT; @lvVPtr; @VPtr0; SubrArgsVector<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@Bcpl; @ContextQ <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@dspStartAddr; @dspArea; @dlispDsp; @DLispDCB<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EmulatorSpace<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LispStackLength; StartOfAllocBlock<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PupZoneLength<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LispStackStart<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PupZoneStart<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>static [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocPtr</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// set in InitLisp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocEnd</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// end of fixed alloc region<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocInFirstBlock</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// true when in fixed block<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lastStaticAllocation</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// last AllocPtr in fixed region<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SavedUFP = -1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SavedSCP = -1</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// used to save OS procs<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">statsFP = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// FP for Lisp.stats<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">sysFontCharWidth</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// width of a char, for Raid<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dontGiveUp = false</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// if true, call swat instead of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">//  quitting on startup errors<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ScreenWords</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// these 3 from InitLispRegs<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RamVersion<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MinLispForRam<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">HostMagic0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">HostMagic1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">HostMagic2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">VmemStream = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// nonzero while an OS vmem stream is open<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SysinName = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// for error msgs<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">fillMemory = false</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// T -&gt; fill up memory completely<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">haveUcode = false</span><span class="tab" val="67"></span><span style="font: 10pt serif">// true if started with Lisp microcode<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">uCodeLoaded = false</span><span class="tab" val="67"></span><span style="font: 10pt serif">// true after ucode loaded<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">altoUcodeFp = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// maybe the Fp for AltoD0Mc.eb<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">callRaid = false</span><span class="tab" val="67"></span><span style="font: 10pt serif">// if true, call Raid on startup<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">extraBuffers<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">extraBufLength</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// for Lisp&rsquo;s use<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ebCreationDate = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>manifest [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NILNum = #0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// atom # for NIL<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TNum = #114</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// atom # for T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SubrArgsPtr = #210</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// addr where ucode puts args<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MaxSubrArgs = 12</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// maximum nargs for any subr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lEDCB = 6</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// extended DCB length<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lFileName = 80</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// file name length in words<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MinPupZoneLength = 8000</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// space for pup zone<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DefaultLispStackLength = 2400</span><span class="tab" val="67"></span><span style="font: 10pt serif">// ~10 pages for bcpl/lisp stack <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">extraBufWanted = 12*WordsPerPage  // how much buffer to give to Lisp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EbCreationDateStart = 4</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// i.e. third word of file<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LispVersionStart = #200</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// bytepos in eb file of version #s<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ExtraZoneSize = 2*WordsPerPage</span><span class="tab" val="67"></span><span style="font: 10pt serif">// how much to allocate on /Z<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>structure Vers:<br>        [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Microcode Version word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">machType bit 4</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// machine type<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">emulType bit 4</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// emulators supported<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">blank byte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>structure String: [ length byte; char&uarr;1,255 byte ]<br><br>// The address of AllocVec is used as the base of the initialization code in<br>// InitLisp (which allocates run time storage starting here). Do not move<br>// within the file or change order of file load without being careful.<br><br>let AllocVec(n, align; numargs nargs) = valof<br><br>// AllocPtr is initialized to the first address that can be used to allocate<br>// permanent data structures (AllocVec). The first two allocations (the<br>// Pup zone and the Bcpl/Lisp run time stack) are made over the top of the<br>// initialization code and are not written into until the initialization is<br>// complete.<br><br>   [<br>// If align is specified, the allocation is align word aligned, for align a power of 2.<br>   if nargs eq 2 then [ let mask=align-1<br>                        AllocPtr=(AllocPtr+mask) & (not mask)<br>                      ]<br>   let addr=AllocPtr</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Save existing pointer for result<br>   AllocPtr=AllocPtr+n</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Move to after this allocation<br>   test AllocInFirstBlock<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifso if Usc(AllocPtr, AllocEnd) gr 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">then CallSwat ("Not enough initial allocation space")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ifnot if Usc (AllocPtr, @StackEnd) gr 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">then @StackEnd=AllocPtr</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Reset end of stack to after allocation<br>   resultis addr<br>   ]<br><br>and MainInit(EventualEndOfStack) be<br>   [<br>   let makeZone = false<br>   dsp = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// turn off any display<br>   AllocPtr = StartOfAllocBlock<br>   AllocEnd = AllocVec<br>   AllocInFirstBlock = true</span><span class="tab" val="67"></span><span style="font: 10pt serif">// do some initial alloc in fixed<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// block reserved by loader<br><br>// Initialize new keyboard driver.  Done quickly so typeahead is not lost<br>   KBDinit()<br><br>// We will need space for the single disk stream that can be open at<br>// once (either stats or initialization) plus some extra space for other<br>// diverse allocations. Here we create a SysZone of approx. the right size.<br><br>// This could later be merged into the PupZone by InitSystem<br>   [<br>   let szl=2*(lKS+WordsPerPage)+WordsPerPage</span><span class="tab" val="67"></span><span style="font: 10pt serif">// stream+buffer*2 plus 1 page<br>   sysZone = InitializeZone(AllocVec(szl),szl)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// for us<br>   @lvSysZone = sysZone</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// for Os<br>   ]<br><br>// don&rsquo;t do this until sysZone exists<br>   if Version()&lt;&lt;Vers.emulType eq 4</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Lisp emul = 4<br>     then haveUcode = true<br><br>   let RamV, MinBcplForRam, MLFR, sw, pnum, ppm, host0, host1, host2<br>       = 0, nil, nil, nil, nil, nil, 0, 0, 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// adjacent for InitLispRegs<br><br>   let origCursor = vec 16<br>   SwapCursors (origCursor, table[<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">#177777; #100001; #40002; #25544;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> #17770;   #7760;  #3740;  #1700;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  #1100;   #2440;  #4220; #10610;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> #21704; #47742; #177777; #177777 ])<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// set hour-glass cursor<br><br>// Set up ucoce/bcpl communication area in locations #200-#277<br>   @StatsPtr = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// no stats initially<br>   @#206 = #2000 % lv Bcpl</span><span class="tab" val="67"></span><span style="font: 10pt serif">// = JMP @Bcpl <br>   @#207 = #77400</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// CallSwat in case #206 gets clobbered<br><br>// Subr argument passing structures. SubrArgsPtr = #210<br>   SubrArgsVector = AllocVec(MaxSubrArgs)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Bcpl args vector<br>   for i = 0 to MaxSubrArgs-1 do SubrArgsVector!i=SubrArgsPtr+2*i<br><br>// Binding various atom pointers which go back to Lisp.<br>// The atom numbers of T and NIL used to come from the IPage, now constants<br>   lvNIL = MakeAtomPtr(NILNum)<br>   lvKT = MakeAtomPtr(TNum)<br><br>// Bind various statics<br>   lvVPtr = lv VPtr0<br>   SubrBase = lv uCodeCheck</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// First SUBR<br><br>// Set up context structures for Pup package<br>   ContextQ=AllocVec(2);  ContextQ!0=0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Allocate and empty ContextQ<br><br>// Open the sysfont file, get the file length and allocate space for the font<br>   [ let s = CreateDiskStream(fpSysFont, ksTypeReadOnly, wordItem)<br>     let sl = (FileLength(s) + 1) rshift 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">// in words<br>     if Usc(AllocPtr+sl, AllocEnd) gr 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">then [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// SysFont too big<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Closes(s)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// close it<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">let s = OpenFile ("Gacha10.al", ksTypeReadOnly, wordItem)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// try for a common smaller font<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if s eq 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then GiveUp ("Sorry, your SysFont.al is too big*N// ",<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  "Couldn&rsquo;t find {DSK}Gacha10.al (an acceptable alternative)")<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">let sl = (FileLength(s) + 1) rshift 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Gacha size<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>     let fontblk = AllocVec(sl)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// space for sysFont<br>     Resets(s)<br>     ReadBlock(s, fontblk, sl)<br>     Closes(s)<br>   // The sysFont static is set to the third word of the font, which is<br>   // what is wanted by the character display routines.<br>     sysFont=fontblk+2<br>     sysFontCharWidth = CharWidth (sysFont, $A)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// for Raid<br>   ]<br><br><br>// Read command line - decides whether sysin or resume<br><br>   let foo = vec lFileName<br>   SysinName = foo<br>   SysinName!0 = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// empty until one is specified<br>   let statsName = vec lFileName<br>   statsName!0 = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// empty until one is specified<br>   let LispUcodeName = vec lFileName<br>   test haveUcode<br>      ifso LispUcodeName!0 = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// don&rsquo;t need to load microcode<br>     ifnot test MachineType() eq Dolphin<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     ifso MoveBlock(LispUcodeName, "DolphinLispMc.eb", 9)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">    ifnot MoveBlock(LispUcodeName, "DoradoLispMc.eb", 8)<br>   let lispUcodeFp = 0<br>   let AltoUcodeName = vec lFileName<br>   MoveBlock(AltoUcodeName, (MachineType() eq Dolphin? "AltoD0Mc.eb", "AltoD1Mc.eb"), 6)<br>   let askedForAlto = false<br>   let quitEarly = false<br><br> [ComParse<br>   let body = vec lFileName<br>   let COMstream = CreateDiskStream(fpComCm, ksTypeReadOnly, charItem)<br>   let switch, bodylen, bodywords = 0, 0, 0<br>   let firstNameFound = 0<br> </span><span class="tab" val="67"></span><span style="font: 10pt serif">[</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// begin loop<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let ch = Endofs(COMstream)? $*N, Gets(COMstream)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">switchon ch into<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $*S: case $*N:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// end of token<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if firstNameFound eq 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if bodylen<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">body&gt;&gt;String.length = bodylen<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">bodywords = (bodylen rshift 1) + 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">switchon switch into<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   [<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 0: case -1:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// no switch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if bodylen eq 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then endcase</span><span class="tab" val="67"></span><span style="font: 10pt serif">// else fall thru for default /I<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $I: case $i:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// sysin name<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">test bodylen<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso MoveBlock(SysinName, body, bodywords)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot MoveBlock(SysinName, "Lisp.sysout", 6)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $N: case $n:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// set UserName<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless bodywords gr UserName!-1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   do MoveBlock(UserName, body, bodywords)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $S: case $s:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// open stats file<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">test bodylen<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso MoveBlock(statsName, body, bodywords)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot MoveBlock(statsName, "Lisp.stats", 6)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $M: case $m:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// load microcode file<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">test bodylen<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso MoveBlock(LispUcodeName, body, bodywords)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot test MachineType() eq Dolphin<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifso MoveBlock(LispUcodeName, "DolphinLispMc.eb", 9)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> ifnot MoveBlock(LispUcodeName, "DoradoLispMc.eb", 8)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">haveUcode = false</span><span class="tab" val="67"></span><span style="font: 10pt serif">// ignore loaded ucode<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $A: case $a:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// specify alto ucode file<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">test (bodylen ne 0) &<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> ((bodylen gr 1) % body&gt;&gt;String.char&uarr;1 ne $-)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// -/A means none<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">MoveBlock(AltoUcodeName, body, bodywords)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  </span><span class="tab" val="67"></span><span style="font: 10pt serif">askedForAlto = true<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot AltoUcodeName!0 = 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $F: case $f: fillMemory = true; endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $Z: case $z: makeZone = true; endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $R: case $r: callRaid = true; endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $Q: case $q: quitEarly = true; endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if Endofs(COMstream) then break<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">bodylen = 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">switch = 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">firstNameFound = -1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">endcase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case $/:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// maybe a switch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if switch eq 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [ switch = -1</span><span class="tab" val="67"></span><span style="font: 10pt serif">// signal a switch start<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  endcase ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// else fall thru<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   default:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// part of a body or switch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">test switch eq -1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso switch = ch</span><span class="tab" val="67"></span><span style="font: 10pt serif">// set one-char switch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot</span><span class="tab" val="67"></span><span style="font: 10pt serif">[</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// fill in body<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if firstNameFound ge 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [ firstNameFound = 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">  endcase  // ignore lisp.run<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if switch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// multi-char switch parsed as body<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">bodylen = bodylen+2<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">body&gt;&gt;String.char&uarr;(bodylen-1) = $/<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">body&gt;&gt;String.char&uarr;bodylen = switch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">switch = 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">bodylen = bodylen+1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">body&gt;&gt;String.char&uarr;bodylen = ch<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">] repeat</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// end until<br><br><br>   Closes(COMstream)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// close and discard COMstream<br> ]ComParse<br><br>   [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// look up the lisp system files<br>   let VMEMid, SYSINid = 0, 0<br>   let RemoteP = false<br>   let dev = vec 5*lDV</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// lDV = len dir entry<br>   let SysDir = CreateDiskStream(fpSysDir, ksTypeReadWrite, wordItem)<br>   let namev = vec 5<br>   namev!0 = "LISP.VIRTUALMEM."<br>   namev!1 = SysinName!0 ? SysinName, 0<br>   namev!2 = statsName!0 ? statsName, 0<br>   namev!3 = LispUcodeName!0 ? LispUcodeName, 0<br>   namev!4 = AltoUcodeName!0 ? AltoUcodeName, 0<br>   if SysinName!0 <br>      then [ let i = 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     [  let ch = nil<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">ch = SysinName&gt;&gt;String.char&uarr;i<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if ch eq ${ % ch eq $[</span><span class="tab" val="67"></span><span style="font: 10pt serif">// if remote name, don&rsquo;t lookup now]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then [ namev!1 = 0; RemoteP = true; break ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if ch ne $*S<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then break<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">i = i+1 ] repeatuntil i gr SysinName&gt;&gt;String.length<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>   LookupEntries(SysDir, namev, dev, 5, true)<br>   </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// +1 turns dir entries into fileptrs<br>   // dont create vmem file - it should exist (contiguously!) already<br>   for i = 0 to 4<br>     do [<br>   </span><span class="tab" val="67"></span><span style="font: 10pt serif">test @dev<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso [ switchon i into<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   [<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 0: VMEMid = dev+1; endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 1: SYSINid = dev+1; endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 2: statsFP = Allocate(sysZone, lFP)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   MoveBlock (statsFP, dev+1, lFP)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 3: lispUcodeFp = dev+1; endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   case 4: altoUcodeFp = Allocate(sysZone, lFP)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   MoveBlock (altoUcodeFp, dev+1, lFP)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   endcase<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot if (namev!i ne 0) & ((i ne 4) % askedForAlto)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then GiveUp ("Cant find ", namev!i)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dev = dev+lDV</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// move on to next file<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>   Closes(SysDir)<br><br>// we now know what kind of sysin, if any, to do<br>   test haveUcode</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// get versions for Ipage checking if possible<br>      ifso [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">InitLispRegs(lv RamV)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// fills in 9 words<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MinLispForRam = MLFR<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RamVersion = RamV<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>     ifnot [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// get versions from uCode file before loading<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let s = CreateDiskStream(lispUcodeFp, ksTypeReadOnly, wordItem)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless s do GiveUp("Can&rsquo;t open microcode file ", LispUcodeName)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// see StampVersions.bcpl<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ebCreationDate = AllocVec(2)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFilePos(s, 0, EbCreationDateStart)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ebCreationDate!0 = Gets(s)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ebCreationDate!1 = Gets(s)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">SetFilePos(s, 0, LispVersionStart)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RamVersion = Gets(s)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MinBcplForRam = Gets(s)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MinLispForRam = Gets(s)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Closes(s)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br><br>   unless RamVersion ge MinRamForBcpl<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">do GiveUp("Microcode too old for this lisp.run")<br>   unless BcplVersion ge MinBcplForRam<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">do GiveUp("Lisp.run too old for this microcode")<br><br>   test RemoteP<br>      ifso [ RemoteInitVmem (SysinName, VMEMid)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     SYSINid = -1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>     ifnot [ if SYSINid<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">then [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// SYSIN from disk<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">@StackEnd = RemoteInitVmem</span><span class="tab" val="67"></span><span style="font: 10pt serif">// flush useless code<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">LocalInitVmem (SYSINid, VMEMid)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">     ]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>   if quitEarly then finish<br>   @StackEnd = LocalInitVmem</span><span class="tab" val="67"></span><span style="font: 10pt serif">// free up some space<br>   AllocInFirstBlock = false<br>   lastStaticAllocation = AllocPtr<br>   AllocPtr=AllocVec</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// next alloc will be overlaid on init code<br><br>// We allocate at least MinPupZoneLength words for the Pup zone, but we<br>// make sure that it extends at least to the end of the initialization code.<br>// This is because the pup zone is not touched during main initialization,<br>// whereas subsequent allocations are.  The Pup initialization code hides<br>// under the LispStack allocation (after Maininit) so it doesn&rsquo;t zorch itself.<br>// Hence, LispStack must be long enough to cover the Pup init code.<br><br>   LispStackLength = Max(DefaultLispStackLength, InitFmap-AllocPtr)<br>   LispStackStart=AllocVec(LispStackLength)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// space for lisp stack<br>   PupZoneLength=Max(MinPupZoneLength, @StackEnd-AllocPtr)<br>   PupZoneStart=AllocVec(PupZoneLength)<br><br>   if lispUcodeFp<br>      then [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let s = CreateDiskStream(lispUcodeFp, ksTypeReadOnly, wordItem)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless s do GiveUp("Can&rsquo;t open microcode file ", LispUcodeName)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let sl = (FileLength(s) + 1) rshift 1 - WordsPerPage<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// length of LoadRam buffer we need<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let buffer = (@StackEnd + WordsPerPage-1) & not (WordsPerPage-1)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let newend = ShortStack(1000)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">if newend - buffer ls sl<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then CallSwat("Microcode file too large")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let oldend = @StackEnd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@StackEnd = newend</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// get lots of space for buffer<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PositionPage(s, 2)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ReadBlock(s, buffer, sl)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Closes(s)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LoadRam((MachineType() eq Dolphin? buffer-1, buffer), 1)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@StackEnd = oldend<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">haveUcode = true<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">InitLispRegs(lv RamV)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// fills in 9 words<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless RamV ge MinRamForBcpl</span><span class="tab" val="67"></span><span style="font: 10pt serif">// Check BEFORE using other ILR values<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   do GiveUp("Microcode too old for this lisp.run")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">unless BcplVersion ge MinBcplForRam<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   do GiveUp("Lisp.run too old for this microcode")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">MinLispForRam = MLFR<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RamVersion = RamV<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>   uCodeLoaded = true<br><br>// Rebind OS procedures for errors, swat and exit. Restored at finish<br>   SavedUFP = @lvUserFinishProc<br>   @lvUserFinishProc = LispFinishProc<br>//   SavedSCP = @lvSwatContextProc<br>//   @lvSwatContextProc = LispSwatContext<br><br>   ScreenWords = sw</span><span class="tab" val="67"></span><span style="font: 10pt serif">// copy InitLispRegs values into statics for others<br>   HostMagic0 = host0<br>   HostMagic1 = host1<br>   HostMagic2 = host2<br><br>   extraBufLength = ((AllocPtr+WordsPerPage) & (not (WordsPerPage-1))) -<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">AllocPtr + extraBufWanted<br>   extraBuffers = AllocVec(extraBufLength)<br><br>   SetupLispMem(SYSINid, VMEMid, pnum, ppm)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Inits VMem<br>   ]<br><br>// Allocate the display, but do not open the TTY stream yet<br>   dlispDsp = AllocVec(2)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// lisp display<br><br>// dlispDsp is a fake. All it has are pointers to a single display block<br>// which is manipulated from Lisp. We allocate that now.<br>   DLispDCB =  AllocVec(lEDCB, 2)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// single dcb; 2word aligned<br>   Zero(DLispDCB, lEDCB)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// must be empty<br>   dlispDsp&gt;&gt;DS.fdcb = DLispDCB<br>   dlispDsp&gt;&gt;DS.ldcb = DLispDCB<br><br>   test makeZone & (Serial() ls #377)<br>      ifso [</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// allocate an mds zone even so<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let length = EventualEndOfStack-AllocPtr</span><span class="tab" val="67"></span><span style="font: 10pt serif">// what&rsquo;s left<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">length = (length ls #10000) ? 0, Min(ExtraZoneSize, length-ExtraZoneSize)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IPutBase(IFPMDSZone, length? AllocVec(length), 0)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IPutBase(IFPMDSZoneLength, length)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>     ifnot [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IPutBase(IFPMDSZone, 0)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IPutBase(IFPMDSZoneLength, 0)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br><br>// Now set the display start address. We will eventually give all of<br>// memory from this point on to the display bitmap.<br>   dspStartAddr = AllocVec(0, WordsPerPage)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// page align display<br>   dspArea = EventualEndOfStack - dspStartAddr<br>   unless dspArea ge WordsPerPage then CallSwat("No space for dsp")<br><br>   @lvSysErr = SysErr</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Not the OS SysErr<br><br>   RestoreCursor (origCursor)<br><br>// The display will be given whatever space remains between the end of the<br>// last AllocVec (rounded up to a page boundary) and the bottom of the stack<br>// frame for InitSystem (plus a small amount needed for it to start the rest<br>// of the system). The latter quantity is EventualEndOfStack. We do this so<br>// the (substantial) stack frame for MainInit can be reclaimed.<br>// Display is actually turned on in InitLisp after we exit<br><br>   SysinName = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// dynamic var will disappear<br>   ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and MakeAtomPtr(atomNum) = valof<br>   [<br>   let ap = AllocVec(2, 2)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Dolphin wants these 2-word aligned<br>   ap!0 = ATOMspace;  ap!1 = atomNum<br>   resultis ap<br>   ]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">and ShortStack(n) = (MyFrame()-n) & not (WordsPerPage-1)<br><br>// Figures out where to end the stack a specified distance from here. Allows<br>// at least n words and rounds down (i.e. more stack) to the nearest page<br><br>and GiveUp(str1, str2; numargs na) be<br>   [<br>   if VmemStream<br>      then Closes(VmemStream)</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// regain some zone space<br>   let st = dontGiveUp? 0, CreateDiskStream(fpRemCm, ksTypeWriteOnly, charItem)<br>   test st<br>      ifso [ Resets(st)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     Wss(st, "// ")</span><span class="tab" val="67"></span><span style="font: 10pt serif">// write str on rem.cm for cleaner crash<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     Wss(st, str1)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     if (na gr 1) & str2 & (str2!0)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">then Wss(st, str2)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     Wss(st, "*N")<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     Closes(st)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     @displayListHead = 0</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// turn off any display<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">     LISPFINISH()<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ]<br>     ifnot CallSwat (str1, str2)<br>   ]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif"><br>and SwapCursors (oldcursor, newcursor) be<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// save cursor in oldcursor, set newcursor<br>  for i = 0 to 15<br>    do [ oldcursor!i = cursorBitMap!i<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> cursorBitMap!i = newcursor!i<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>and RestoreCursor (oldcursor) be<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// make cursor be oldcursor<br>  for i = 0 to 15<br>    do cursorBitMap!i = oldcursor!i<br><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
