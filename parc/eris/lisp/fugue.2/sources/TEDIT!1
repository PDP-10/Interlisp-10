(FILECREATED "17-AUG-83 18:04:00" {PHYLUM}<SYBALSKY>TEDIT.;399 389561       changes to:  (FNS TEDIT.PUT.OBJECT)      previous date: "17-AUG-83 16:22:59" {PHYLUM}<SYBALSKY>TEDIT.;398)(PRETTYCOMPRINT TEDITCOMS)(RPAQQ TEDITCOMS [(RECORDS CHARLOOKS FMTSPEC SELECTION TEDITOBJ TEDITOBJREF THISLINE LINEDESCRIPTOR)	(FNS * TEDITFNS)	(CURSORS BXCARET BXHICARET TEDIT.LINECURSOR)	(FILES TEXTOFD)	(CONSTANTS (\SCRATCHLEN 64)		   (SPACE (QUOTE % ))		   (CR (QUOTE %))		   (COPYSELSHADE 30583)		   (EDITMOVESHADE -1)		   (EDITGRAY 32800)		   (\PieceDescriptorLOOKS 0)		   (\PieceDescriptorOBJECT 1)		   (\PieceDescriptorPARA 2))	(INITVARS (TEditBluePendingDelete T)		  (TEDIT.DEFAULT.WINDOW NIL)		  (TEDIT.DEFAULT.FONT (FONTCREATE (QUOTE GACHA)						  10))		  (TEDIT.DEFAULT.CHARLOOKS (CHARLOOKS.FROM.FONT TEDIT.DEFAULT.FONT))		  (TEDIT.DEFAULT.FMTSPEC (create FMTSPEC QUAD _ (QUOTE LEFT)						 1STLEFTMAR _ 0 LEFTMAR _ 0 RIGHTMAR _ 0 LEADBEFORE _ 						 0 LEADAFTER _ 0 LINELEAD _ 0 TABSPEC _ NIL)))	(VARS (TEDIT.SELECTION (create SELECTION))	      (TEDIT.SHIFTEDSELECTION (create SELECTION HOW_COPYSELSHADE HASCARET_NIL))	      (TEDIT.MOVESELECTION (CREATE SELECTION HOW_EDITMOVESHADE HASCARET_NIL HOWHEIGHT_32767))	      (TEDIT.DELETESELECTION (CREATE SELECTION HOW_BLACKSHADE HASCARET_NIL HOWHEIGHT_32767))	      (TEDIT.COPY.PENDING NIL)	      (TEDIT.MOVE.PENDING NIL)	      (TEDIT.DEL.PENDING NIL)	      (TEDIT.SELPENDING NIL)	      (TEDIT.BLUEPENDINGDELETE NIL)	      [TEDIT.KNOWN.FONTS (QUOTE ((Times% Roman (QUOTE TIMESROMAN))					 (Helvetica (QUOTE HELVETICA))					 (Gacha (QUOTE GACHA))					 (Cream (QUOTE CREAM]	      (TEDIT.FACE.MENU (create MENU ITEMS _ (QUOTE (Bold Italic Bold% Italic Regular))				       CENTERFLG _ T TITLE_ "Face:"))	      (TEDIT.SIZE.MENU (create MENU ITEMS _				       (QUOTE (6 7 8 9 10 11 12 14 18 24 30 36))				       CENTERFLG _ T MENUROWS_4 TITLE_ "Type Size:")))	(GLOBALVARS TEDIT.DEFAULT.WINDOW TEDIT.SELECTION TEDIT.SCRATCHSELECTION TEDIT.MOVESELECTION 		    TEDIT.SHIFTEDSELECTION TEDIT.DELETESELECTION TEDIT.COPY.PENDING 		    TEDIT.MOVE.PENDING TEDIT.DEL.PENDING TEDIT.SELPENDING TEDIT.BLUEPENDINGDELETE 		    TEDIT.CURRENT.FONT TEDIT.CURRENT.CHARLOOKS TEDIT.CURRENT.PARALOOKS 		    TEDIT.KNOWN.FONTS TEDIT.FACE.MENU TEDIT.SIZE.MENU TEDIT.DEFAULT.FONT 		    TEDIT.DEFAULT.CHARLOOKS TEditBluePendingDelete)	(MACROS * TEDITMACROS)	(COMS (* Screen updating utilities)	      (FNS TEDIT.DEACTIVATE.WINDOW \EDITREPAINTFN \EDITRESHAPEFN TEDIT.WINDOW.TITLE 		   TEDIT.DELETELINE \DISPLAYLINE \EDITSCROLLFN \FILLWINDOW \FIXCHANGEDPART 		   \FORMATLINE \PULLTEXT \SHOWSEL \PUSHLINES \PUSHTEXT \BACKFORMAT))	(COMS (* Read-table Utilities)	      (FNS \TEDIT.READTABLE \TEDIT.WORDBOUND.READTABLE TEDIT.GETSYNTAX TEDIT.SETSYNTAX 		   TEDIT.GETFUNCTION TEDIT.SETFUNCTION TEDIT.WORDGET TEDIT.WORDSET)	      (CONSTANTS (NONE.TTC 0)			 (CHARDELETE.TTC 1)			 (WORDDELETE.TTC 2)			 (DELETE.TTC 3)			 (FUNCTIONCALL.TTC 4)			 (REDO.TTC 5)			 (UNDO.TTC 6)			 (CMD.TTC 7)			 (PUNCT.TTC 20)			 (TEXT.TTC 21)			 (WHITESPACE.TTC 22))	      (CONSTANTS (MSPACE 153)			 (NSPACE 152)			 (THINSPACE 159)			 (FIGSPACE 154))	      (INITVARS (TEDIT.READTABLE (\TEDIT.READTABLE))			(TEDIT.WORDBOUND.READTABLE (\TEDIT.WORDBOUND.READTABLE)))	      (GLOBALVARS TEDIT.READTABLE TEDIT.WORDBOUND.READTABLE)	      (DECLARE: EVAL@COMPILE DONTCOPY (RECORDS TEDITTERMCODE)))	(COMS (* Abbreviation expansion facility)	      (FNS \TEDIT.ABBREV.EXPAND)	      (VARS TEDIT.ABBREVS)	      (GLOBALVARS TEDIT.ABBREVS))	(COMS (* Process-world interfaces)	      (FNS \TEDIT.PROCIDLEFN \TEDIT.PROCENTRYFN \TEDIT.PROCEXITFN))	(COMS (* Debugging functions)	      (FNS PLCHAIN PRINTLINE))	(COMS (* Caret handler; stolen from CHAT.)	      (FNS \EDIT.DOWNCARET \EDIT.FLIPCARET TEDIT.FLASHCARET \EDIT.UPCARET 		   TEDIT.NORMALIZECARET \SETCARET)	      (DECLARE: EVAL@COMPILE DONTCOPY (RECORDS CARET)))	(COMS (* UNDO & History List stuff)	      (RECORDS TEDITHISTORYEVENT)	      (FNS \TEDIT.HISTORYADD TEDIT.UNDO TEDIT.UNDO.INSERTION TEDIT.UNDO.DELETION TEDIT.REDO 		   TEDIT.REDO.INSERTION TEDIT.REDO.LOOKS TEDIT.UNDO.LOOKS TEDIT.UNDO.MOVE)	      (INITVARS (TEDIT.HISTORYLST NIL))	      (GLOBALVARS TEDIT.HISTORYLST))	(COMS (* Menu interfacing)	      (FNS TEDIT.ADD.MENUITEM TEDIT.DEFAULT.MENUFN TEDIT.REMOVE.MENUITEM \TEDIT.CREATEMENU 		   \TEDIT.MENU.WHENHELDFN \TEDIT.MENU.WHENSELECTEDFN)	      (GLOBALVARS TEDIT.DEFAULT.MENU)	      [INITVARS (TEDIT.DEFAULT.MENU (\TEDIT.CREATEMENU (QUOTE (Put Get Include Find Looks 									   Substitute Quit]	      (P [OR (SASSOC (QUOTE TEdit)			     BackgroundMenuCommands)		     (NCONC1 BackgroundMenuCommands (QUOTE (TEdit (QUOTE (TEDIT))								  "Opens a TEdit window for use."]		 (SETQ BackgroundMenu NIL)))	(INITRECORDS CARET)	(FILES TEDITHCPY)	(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)									      (NLAML)									      (LAMA])[DECLARE: EVAL@COMPILE (DATATYPE CHARLOOKS (CLFONT                                  (* The font descriptor for these characters)			    CLPROTECTED                      (* T if chars can't be selected, else NIL)			    CLINVISIBLE                      (* T if TEDIT is to ignore these chars;							     else NIL)			    CLSELHERE          (* T if TEDIT can put selection after this char (for menu blanks) else NIL; anything typed after this char will 	  NOT BE PROTECTED.)			    CLCANCOPY                        (* T if this text can be selected for copying, even tho 							     protected (it will become unprotected after the copy;							     for Dribble/TTY interface))			    CLNAME                           (* Name of the font (e.g., HELVETICA))			    CLSIZE                           (* Font size, in points)			    CLITAL                           (* T if the characters are italic, else NIL)			    CLBOLD                           (* T if the characters are bold, else NIL)			    CLULINE                          (* T if the characters are to be underscored, else NIL)			    CLOLINE                          (* T if the characters are to be overscored, else NIL)			    CLSTRIKE                         (* T if the characters are to be struck thru, else nil.)			    CLSUPER                          (* A superscripting offset in points 							     (?) else NIL)			    CLSUB                            (* A subscripting distance in points 							     (?), else NIL)			    CLSMALLCAP                       (* T if small caps, else NIL)			    CLSTYLE                          (* The style to be used in marking these characters;							     overridden by the other fields)			    ))(DATATYPE FMTSPEC (1STLEFTMAR LEFTMAR RIGHTMAR LEADBEFORE LEADAFTER LINELEAD TABSPEC QUAD))(DATATYPE SELECTION (Y0                                      (* Y value of topmost line of selection)			X0                                   (* X value of left edge of selection)			DX                                   (* Width of the selection, if it's on one line.)			CH#                                  (* CH# of the first selected character)			XLIM                                 (* X value of right edge of last selected character)			CHLIM                                (* CH# of the last character in the selection)			DCH                                  (* # of characters selected (can be zero, for point 							     selection.))			L1                                   (* -> line descriptor for the line where the first 							     selected character is)			LN                                   (* -> line descriptor for the line which contains the 							     end of the selection)			YLIM                                 (* Y value of the bottom of the line that ends the 							     selection)			POINT                                (* Which end should the caret appear at? 							     (LEFT or RIGHT))			SET                                  (* T if this selection is real;							     NIL if not)			(\TEXTOBJ XPOINTER)                  (* TEXTOBJ that describes the selected text)			SELKIND                              (* What kind of selection? CHAR or WORD or LINE or PARA)			HOW                                  (* SHADE used to highlight this selection)			HOWHEIGHT                            (* Height of the highlight (1 usually, full line for 							     delete selection...))			HASCARET                             (* T if there should be a caret for this selection)			SELOBJ                               (* If this selection is inside an object, which object?)			ONFLG                                (* T if the selection is highlighted on the screen, else							     NIL)			SELOBJINFO                           (* A Place for the selected object to put info about 							     selection inside itself.)			)		    SET _ NIL HOW _ BLACKSHADE HOWHEIGHT _ 1 HASCARET _ T)(DATATYPE TEDITOBJ (                                         (* Template for any TEDIT object which can be displayed 							     and interacted with using TEdit's facilities.)		    SIZEFN          (* (SIZEFN OBJ MODE) called to set the XSIZE and YSIZE fields -- to tell how big the object's screen or print 	  image is.)		    XSIZE                                    (* Width of the object's screen image, in screen dots)		    YSIZE                                    (* Height of the object's screen image, in screen 							     points)		    YDESC                                    (* Object's descent below the base line, in screen 							     points)		    YASC                                     (* Object's ascent above the base line, in screen 							     points)		    SELFN          (* (SELFN object rel-X rel-Y) called when the mouse is selecting inside the object. This is BEFORE the selection 	  is finalized by releasing the mouse button.)		    SELSHOWFN          (* (SELSHOWFN OBJ ?? ?? ??) called to highlight a selection within the oject or sel of the object alone.	  May extend to intra object sels later.)		    EXTENDFN          (* (EXTENDFN oldsel newsel case?) Handles extending a selection which is either (1) All inside the object, or 	  (2) Starts inside the object but ends outside, or (3) Starts ourside the object and ends inside it.	  CASE may be used to distinguish these cases...)		    SELFINALFN                               (* (SELFINALFN object SEL) is used to finalize a 							     selection that intersects an object, so the object can 							     react to being selected.)		    DISPLAYFN                                (* (DISPLAYFN OBJECT DS MODE) called to display the 							     object on the screen or hardcopy, or other way, 							     depending on MODE)		    BITS                                     (* Bit map cache for stroing the object's screen image)		    INSERTFN                                 (* (INSERTFN OBJ ?? ??) (is it yet?) called when object 							     is inserted into a document.)		    DELETEFN                                 (* (DELETEFN OBJ ?? ??) called when the object is 							     deleted from the document.)		    COPYFN          (* (COPYFN OBJ PIECE oldch? newch?) (not yet) called when the object is copied elsewhere in the text.	  May return a fresh object which is used, or NIL to re-use the same object.)		    PUTFN                                    (* (PUTFN OBJ CHARSTREAM FMTSTREAM ?? ??) 							     (not yet) called to put the object onto a file in 							     reconstructable form.)		    GETFN          (* (GETFN PIECE?) called (not yet) to construct and return the object from a text representation which starts with	  PIECE, or some such)		    MOVEFN                                   (* (MOVEFN OBJ ?? ?? ??) called 							     (not yet) when the object is moved in the text)		    EDITFN          (* (EDITFN obj) Called to "Edit" the object. Must return T if the object changed and needs redisplay, or NIL if no	  changes happened.)		    ))(RECORD TEDITOBJREF (OBJREF . OBJREST))(DATATYPE THISLINE (                                         (* Cache for line-related character location info, for 							     selection code to use)		    DESC                                     (* Line descriptor for the line this describes now)		    LEN                                      (* Length of the line in characters)		    CHARS          (* Array of character codes (or objects) on the line (charcode of 400 => dummy entry for looks change--go get next	  entry in LOOKS))		    WIDTHS                                   (* Array of each character's width in points)		    LOOKS                                    (* Array of any looks changes within the line.							     LOOKS (0) = starting characterlooks for the line)		    ))(DATATYPE LINEDESCRIPTOR (YBOT                               (* Y value for the bottom of the line 							     (below the descent))			       YBASE                         (* Yvalue for the base line the characters sit on)			       LEFTMARGIN                    (* Left margin, in screen points)			       RIGHTMARGIN                   (* Right margin, in screen points)			       LXLIM                         (* X value of right edge of rightmost character on the 							     line (may exceed right margin, if char is a space.))			       SPACELEFT                     (* Space left on the line, ignoring trailing blanks & 							     CRs.)			       FIRSTSPACE                    (* X offset of left edge of first space on the line 							     (for line updating))			       LHEIGHT                       (* Total height of hte line, Ascent+Descent.)			       CHAR1                         (* CH# of the first character on the line.)			       CHARLIM                       (* CH# of the last character on the line)			       CHARTOP                       (* CH# of the character which forced the line break 							     (may exceed CHARLIM))			       DIRTY                         (* T if this line has changed since it was last 							     formatted.)			       NEW                           (* T if this line has not been displayed since being 							     formatted last)			       CR\END                        (* T if this line ends with a CR.)			       ASCENT                        (* Ascent of the line above YBASE)			       DESCENT                       (* How far line descends below YBASE)			       NEXTLINE                      (* Next line chain pointer)			       (PREVLINE XPOINTER)           (* Previous line chain pointer)			       DELETED          (* T if this line has been completely deleted since it was last formatted or displayed. (Used by deletion routines	  to detect garbage lines))			       CACHE                         (* Bitmap cache for the line's image.)			       LDOBJ                         (* The object which lies behind this line of text, for 							     updating, etc.)			       LHASPROT                      (* This line contains protected text.)			       LFMTSPEC                      (* The format spec for this line's paragraph 							     (eventually))			       )	  CHARLIM _ 1000000 NEXTLINE _ NIL PREVLINE _ NIL NEW _ T DIRTY _ NIL YBOT _ 0 YBASE _ 0 	  LEFTMARGIN _ 0 DELETED _ NIL)](/DECLAREDATATYPE (QUOTE CHARLOOKS)		  (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 				  POINTER POINTER POINTER POINTER POINTER POINTER POINTER)))(/DECLAREDATATYPE (QUOTE FMTSPEC)		  (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER)))(/DECLAREDATATYPE (QUOTE SELECTION)		  (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 				  POINTER POINTER POINTER XPOINTER POINTER POINTER POINTER POINTER 				  POINTER POINTER POINTER)))(/DECLAREDATATYPE (QUOTE TEDITOBJ)		  (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 				  POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 				  POINTER)))(/DECLAREDATATYPE (QUOTE THISLINE)		  (QUOTE (POINTER POINTER POINTER POINTER POINTER)))(/DECLAREDATATYPE (QUOTE LINEDESCRIPTOR)		  (QUOTE (POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 				  POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 				  XPOINTER POINTER POINTER POINTER POINTER POINTER)))(RPAQQ TEDITFNS (CHARLOOKS.FROM.FONT COERCETEXTOBJ EQCLOOKS SEEFILE TEDIT TEDIT.BUILD.PCTB 				     TEDIT.CHARWIDTH TEDIT.COPY TEDIT.CR.UPDATESCREEN TEDIT.CREATEW 				     TEDIT.CURSORMOVEDFN TEDIT.CURSOROUTFN TEDIT.DELETE 				     TEDIT.DO.BLUEPENDINGDELETE TEDIT.EXTEND.SEL TEDIT.FIND 				     TEDIT.FORMATTEDP TEDIT.GET TEDIT.GET.CHARLOOKS TEDIT.GET.OBJECT 				     TEDIT.GET.PARALOOKS TEDIT.GETINPUT TEDIT.GETSEL TEDIT.INCLUDE 				     TEDIT.INSERT TEDIT.INSERT.DISPLAYTEXT TEDIT.INSERT.OBJECT 				     TEDIT.INSERT.UPDATESCREEN TEDIT.LOOKS TEDIT.MAKESEL 				     TEDIT.MODIFYLOOKS TEDIT.MOVE TEDIT.NEW.FONT TEDIT.PARAPPLY 				     TEDIT.PUT TEDIT.PUT.CHARLOOKS TEDIT.PUT.OBJECT 				     TEDIT.PUT.PARALOOKS TEDIT.PUT.PCTB TEDIT.PUT.PIECE.DESCRIPTOR 				     TEDIT.QUIT TEDIT.REDO.REPLACE TEDIT.REPLACE TEDIT.SCAN.LINE 				     TEDIT.SCANSEL TEDIT.SEEPARA TEDIT.SEL.AS.STRING TEDIT.SELECT 				     TEDIT.SELECT.LINE.SCANNER TEDIT.SET.SEL.LOOKS TEDIT.SETSEL 				     TEDIT.SHOWSEL TEDIT.STRINGWIDTH TEDIT.UNDO.REPLACE TEDIT.\INSERT 				     \ATMIN \ATMOUT \COPYSEL \DOFORMATTING \DWIN \DWOUT 				     \TEDIT.BUTTONEVENTFN \TEDIT.GET.INSERT.CHARLOOKS 				     \TEDIT.HCPYFMTSPEC \TEDIT.INTERRUPT.SETUP \TEDIT.LOOKS 				     \TEDIT.LOOKS.UPDATE \FIXDLINES \FIXILINES \FIXSEL \PNC \SHOWTEXT 				     \STRINGIN \STRINGOUT \TEDIT.BLTCHAR \TEDIT.CHARDELETE 				     \TEDIT.CLOSEUPLINES \TEDIT.COMMAND.LOOP \TEDIT.DELETE 				     \TEDIT.FIND.FIRST.LINE \TEDIT.FIND.LAST.LINE \TEDIT.FIXDELSEL 				     \TEDIT.FIXSELS \TEDIT.FONTCOPY \TEDIT.FOREIGN.COPY? 				     \TEDIT.FORMATTEDP1 \TEDIT.NEWREGIONFN \TEDIT.QUIT \TEDIT.QUIT2 				     \TEDIT.SET.WINDOW.EXTENT \TEDIT.SHOWSELS \TEDIT.UPDATE.SHOWSEL 				     \TEDIT.WINDOW.SETUP \TEDIT.WORD.BOUND \TEDIT.WORDDELETE \TEDIT1 				     \WATOM \WSTRING))(DEFINEQ(CHARLOOKS.FROM.FONT  [LAMBDA (FONT)                                             (* jds " 7-JAN-83 11:51")    (PROG ((LOOKS (create CHARLOOKS			  CLFONT _ FONT)))          (SELECTQ (CAR (FONTPROP FONT (QUOTE FACE)))		   (BOLD (replace CLBOLD of LOOKS with T)			 (replace CLITAL of LOOKS with NIL))		   (replace CLBOLD of LOOKS with NIL))          (SELECTQ (CADR (FONTPROP FONT (QUOTE FACE)))		   (ITALIC (replace CLITAL of LOOKS with T))		   (replace CLITAL of LOOKS with NIL))          (with CHARLOOKS LOOKS (SETQ CLSIZE (FONTPROP FONT (QUOTE SIZE)))		(SETQ CLSUPER NIL)		(SETQ CLSUB NIL))          (RETURN LOOKS])(COERCETEXTOBJ  [LAMBDA (STREAM TYPE)                                      (* jds " 6-APR-83 15:25")                                                             (* Coerce the contents of the TEXOTBJ to be of the given							     type. This is for making a string from a textobj, e.g.)    (PROG [(TEXTOBJ (COND		      ((type? STREAM STREAM)			(fetch F3 of STREAM))		      (T STREAM]          (OR (type? TEXTOBJ TEXTOBJ)	      (\ILLEGAL.ARG TEXTOBJ))                        (* If we haven't got a TEXTOBJ, something is wrong.)          (RETURN (SELECTQ TYPE			   (STRINGP (PROG ((STR (ALLOCSTRING (fetch TEXTLEN of TEXTOBJ)))					   PC					   (CH# 1)					   (PCTB (fetch PCTB of TEXTOBJ))					   PFILE)				          [for I from (ADD1 \FirstPieceOffset)					     to (IDIFFERENCE (\EDITELT PCTB \PCTBLastPieceOffset)							     2)					     by \EltsPerPiece					     do (SETQ PC (\EDITELT PCTB I))						(COND						  ((ATOM PC)                                                             (* It's the lastpiece atom -- do nothing.)						    )						  [(fetch PSTR of PC)						    [OR (ZEROP (fetch PLEN of PC))							(RPLSTRING STR CH#								   (SUBSTRING (fetch PSTR										 of PC)									      1									      (fetch PLEN										 of PC]						    (SETQ CH# (IPLUS CH# (fetch PLEN of PC]						  [(SETQ PFILE (fetch PFILE of PC))						    [COND						      ((NOT (OPENP PFILE))							(OPENFILE (fetch FULLNAME of PFILE)								  (QUOTE INPUT))							(SETQ PFILE							  (\GETOFD (OPENFILE (fetch FULLNAME										of PFILE)									     (QUOTE INPUT))								   (QUOTE INPUT]						    (SETFILEPTR PFILE (fetch PFPOS of PC))						    (for C from CH# as I from 1						       to (fetch PLEN of PC)						       do (RPLCHARCODE STR C (BIN PFILE)))						    (SETQ CH# (IPLUS CH# (fetch PLEN of PC]						  [(fetch POBJ of PC)                                                             (* DO NOTHING FOR OBJECTS)						    (SETQ CH# (IPLUS CH# (fetch PLEN of PC]						  (T (ERROR "CANNOT GET TEXT FROM A 'PIECE.'" PC]				          (RETURN STR)))			   (STREAM (COND				     ((type? STREAM (fetch TXTFILE of TEXTOBJ))				       (OPENFILE (fetch FULLNAME of (fetch TXTFILE of TEXTOBJ))						 (QUOTE INPUT))				       (replace ACCESSBITS of (fetch TXTFILE of TEXTOBJ)					  with ReadBit)))				   (\SETUPGETCH 1 TEXTOBJ)				   STREAM)			   NIL])(EQCLOOKS  [LAMBDA (CLOOK1 CLOOK2)                                    (* jds "11-APR-83 15:46")                                                             (* Given two sets of CHARLOOKS, are they effectively the							     same?)    (OR (EQ CLOOK1 CLOOK2)	(AND (EQ (fetch CLFONT of CLOOK1)		 (fetch CLFONT of CLOOK2))	     (EQ (fetch CLPROTECTED of CLOOK1)		 (fetch CLPROTECTED of CLOOK2))	     (EQ (fetch CLINVISIBLE of CLOOK1)		 (fetch CLINVISIBLE of CLOOK2))	     (EQ (fetch CLSELHERE of CLOOK1)		 (fetch CLSELHERE of CLOOK2))	     (EQ (fetch CLCANCOPY of CLOOK1)		 (fetch CLCANCOPY of CLOOK2))	     (EQ (fetch CLULINE of CLOOK1)		 (fetch CLULINE of CLOOK2))	     (EQ (fetch CLOLINE of CLOOK1)		 (fetch CLOLINE of CLOOK2))	     (EQ (fetch CLSTRIKE of CLOOK1)		 (fetch CLSTRIKE of CLOOK2))	     (EQ (fetch CLSUPER of CLOOK1)		 (fetch CLSUPER of CLOOK2))	     (EQ (fetch CLSUB of CLOOK1)		 (fetch CLSUB of CLOOK2))	     (EQ (fetch CLSMALLCAP of CLOOK1)		 (fetch CLSMALLCAP of CLOOK2))	     (EQ (fetch CLSTYLE of CLOOK1)		 (fetch CLSTYLE of CLOOK2])(SEEFILE  [LAMBDA (FILE ST ND)                                       (* jds " 4-FEB-83 20:05")    (PROG ((OFP (GETFILEPTR FILE))	   CH)          (SETFILEPTR FILE ST)          (for I from ST to ND do (printout T I 5 (SETQ CH (BIN FILE))					    9					    (CHARACTER CH)					    T])(TEDIT  [LAMBDA (TEXT WINDOW DONTSPAWN PROPS)                      (* jds "17-AUG-83 09:59")                                                             (* User entry to the text editor.							     Takes an optional window to be used for editing)                                                             (* DONTSPAWN => Don't try to create a new process for 							     this edit.)    [COND      ((AND TEXT (ATOM TEXT))                                (* Make sure the file exists before trying to open the 							     window.)	(SETQ TEXT (OPENFILE TEXT (QUOTE INPUT)			     (QUOTE OLD]    [COND      [DONTSPAWN (OR WINDOW (SETQ WINDOW (OR TEDIT.DEFAULT.WINDOW (TEDIT.CREATEW 						"Please specify a REGION for the editing window."]      (T (OR WINDOW (SETQ WINDOW (TEDIT.CREATEW "Please specify a REGION for the editing window."]    (WINDOWPROP WINDOW (QUOTE TEDIT.PROPS)		PROPS)    (PROG (PROC)          (COND	    (DONTSPAWN                                       (* Either no processes running, or specifically not to 							     spawn one.)		       (RETURN (\TEDIT1 TEXT WINDOW T PROPS)))	    (T                                               (* Spawn a process to do the edit.)	       (SETQ PROC (ADD.PROCESS (LIST (QUOTE \TEDIT1)					     (KWOTE TEXT)					     WINDOW NIL (KWOTE PROPS))				       (QUOTE TEdit)				       (QUOTE NO)))	       (PROCESS.WINDOW PROC WINDOW)	       (TTY.PROCESS PROC])(TEDIT.BUILD.PCTB  [LAMBDA (TEXT TEXTOBJ START END)                           (* jds " 9-JUN-83 14:32")                                                             (* START = 1st char of file to read from, if specified)                                                             (* END = use this as eofptr of file.							     For use in reading files within files.)    (PROG [SEL LINES PCTB PC OLDPC NPC PROPS TYPECODE PCLEN (CURFILECH# (OR START 0))	       (CURCH# 1)	       (TEXTSTREAM (AND TEXTOBJ (fetch STREAMHINT of TEXTOBJ]          (SETQ NPC (\TEDIT.FORMATTEDP1 TEXT END))          [COND	    ((NOT NPC)                                       (* This is an unformatted file)	      [RETURN (\MAKEPCTB (create PIECE					 PFILE _ TEXT					 PFPOS _ CURFILECH#					 PLEN _(IDIFFERENCE (OR END (GETFILEINFO TEXT (QUOTE LENGTH)))							    CURFILECH#)					 PREVPIECE _ OLDPC					 PLOOKS _(CHARLOOKS.FROM.FONT TEDIT.DEFAULT.FONT]                                                             (* So create a single piece to describe its contents)	      )	    (T (SETQ PCTB (\MAKEPCTB NIL NPC))	       (AND TEXTOBJ (replace PCTB of TEXTOBJ with PCTB]          (bind (OLDPC _ NIL) for I from 1 to NPC as PCN from \FirstPieceOffset by \EltsPerPiece	     do (SETQ PC (create PIECE				 PFILE _ TEXT				 PFPOS _ CURFILECH#				 PLEN _(SETQ PCLEN (\DWIN TEXT))				 PREVPIECE _ OLDPC))		[COND		  (OLDPC (replace NEXTPIECE of OLDPC with PC)			 (replace PPARALOOKS of PC with (fetch PPARALOOKS of OLDPC]		(SELECTC (SETQ TYPECODE (\WIN TEXT))			 (\PieceDescriptorLOOKS (TEDIT.GET.CHARLOOKS PC TEXT)						(add CURFILECH# (fetch PLEN of PC)))			 (\PieceDescriptorOBJECT (TEDIT.GET.OBJECT TEXTSTREAM PC TEXT CURFILECH#)						 (add CURFILECH# (fetch PLEN of PC))						 (replace PLEN of PC with 1))			 (\PieceDescriptorPARA (AND OLDPC (replace PPARALAST of OLDPC with T))					       (TEDIT.GET.PARALOOKS PC TEXT)					       (replace PLEN of PC with (\DWIN TEXT))                                                             (* Set this piece's length from the character looks.)					       (\WIN TEXT)   (* Skip the piece-type code, since we know what's next)					       (TEDIT.GET.CHARLOOKS PC TEXT)					       (AND TEXTOBJ (replace FORMATTEDP of TEXTOBJ							       with T))                                                             (* This document is "formatted".)					       (add CURFILECH# (fetch PLEN of PC)))			 (SHOULDNT "Impossible piece-type code in BUILD.PCTB"))		(SETQ OLDPC PC)		(\EDITSETA PCTB PCN CURCH#)		(\EDITSETA PCTB (ADD1 PCN)			   PC)		(add CURCH# (fetch PLEN of PC))	     finally (\EDITSETA PCTB PCN CURCH#)		     (\EDITSETA PCTB (ADD1 PCN)				(QUOTE LASTPIECE))		     (\EDITSETA PCTB \PCTBLastPieceOffset (ADD1 PCN))		     (\EDITSETA PCTB \PCTBFreePieces 0))          (RETURN PCTB])(TEDIT.CHARWIDTH  [LAMBDA (CH FONT TERMSA)                                   (* jds "25-MAY-83 18:59")                                                             (* Displays the character and increments the Xposition.							     STREAM is guaranteed to be the stream corresponding to a							     display stream.)    (SELECTC (fetch CCECHO of (\SYNCODE TERMSA CH))	     (INDICATE.CCE (IPLUS (COND				    ((IGREATERP CH 127)      (* META character)				      (SETQ CH (LOGAND CH 127))				      (CHARWIDTH (CHARCODE #)						 FONT))				    (T 0))				  (COND				    ((ILESSP CH 32)          (* CONTROL character)				      (SETQ CH (LOGOR CH 64))				      (CHARWIDTH (CHARCODE ^)						 FONT))				    (T 0))				  (CHARWIDTH CH FONT)))	     [SIMULATE.CCE (SELCHARQ CH				     ((EOL CR LF)				       (IMAX 6 (CHARWIDTH CH FONT)))				     (ESCAPE (CHARWIDTH (CHARCODE $)							FONT))				     (BELL                   (* make switching of bits uninterruptable but allow 							     interrupts between flashes.)					   0)				     (TAB 36)				     (PROGN                  (* this case was copied from \DSCCOUT.)					    (CHARWIDTH CH FONT]	     (REAL.CCE (CHARWIDTH CH FONT))	     (IGNORE.CCE 0)	     (SHOULDNT])(TEDIT.COPY  [LAMBDA (FROM TO THISLINE)                                 (* jds " 3-AUG-83 13:02")    (SETQ TEDIT.COPY.PENDING NIL)                            (* First, Turn off the global flag that got us here.)    (COND      ((NOT (AND FROM (fetch SET of FROM)))                  (* There MUST be a source selected first.)	(printout PROMPTWINDOW "Copy source selection hasn't been set yet." T))      (T (\SHOWSEL FROM NIL NIL)                             (* Before all else, make sure the copy source selection 							     is turned off)	 (replace SET of FROM with NIL)	 (COND	   ((AND TO (fetch SET of TO))                       (* Can only do copy if there's a target selection)	     (PROG ((FROMCH1 (fetch CH# of FROM))		    (FROMCHLIM (fetch CHLIM of FROM))		    (TOPCTB (fetch PCTB of (fetch \TEXTOBJ of TO)))		    (FPCTB (fetch PCTB of (fetch \TEXTOBJ of FROM)))		    INSERTCH# PCLST INSPC (TOOBJ (fetch \TEXTOBJ of TO))		    (FROMOBJ (fetch \TEXTOBJ of FROM))		    (FROMLEN (fetch TEXTLEN of (fetch \TEXTOBJ of FROM)))		    (TOLEN (fetch TEXTLEN of (fetch \TEXTOBJ of TO)))		    LEN CHANGEDLINE)	           (\SHOWSEL TO NIL NIL)                     (* Turn off SELs before we go any further)                                                             (* Find the insertion point)	           [COND		     ((EQ (fetch POINT of TO)			  (QUOTE LEFT))		       (SETQ INSERTCH# (fetch CH# of TO)))		     (T (SETQ INSERTCH# (ADD1 (IMIN (fetch CHLIM of TO)						    TOLEN]   (* Figure out where to do the insertion.)	           (SETQ LEN (\COPYTEXT FROMOBJ TOOBJ FROMCH1 FROMCHLIM INSERTCH#))                                                             (* Do the actual copy)	           (\FIXILINES (fetch LINES of TOOBJ)			       TO INSERTCH# LEN TOLEN)       (* Fix LINES and SELs)	           (AND (SETQ CHANGEDLINE (\FIXCHANGEDPART TOOBJ THISLINE))			(\FILLWINDOW (fetch YBOT of CHANGEDLINE)				     CHANGEDLINE TOOBJ THISLINE))                                                             (* Refresh the display)	           (replace CH# of TO with INSERTCH#)        (* Correct the target selection)	           (replace CHLIM of TO with (IPLUS INSERTCH# LEN -1))	           (replace DCH of TO with LEN)	           (replace DX of TO with 0)	           (replace POINT of TO with (QUOTE RIGHT))	           (\FIXSEL TO TOOBJ)	           (\SHOWSEL TO NIL T)))	   (T                                                (* There is no target selection -- complain)	      (CLRPROMPT)	      (printout PROMPTWINDOW "Please select a destination for the copy first." T])(TEDIT.CR.UPDATESCREEN  [LAMBDA (CH# XPOINT TEXTOBJ SEL LINE THISLINE BLANKSEEN CRSEEN DS CHWIDTH)                                                             (* jds "26-JUL-83 11:56")          (* Update the edit window image after a CR is typed. Move any text after the CR to a new line, and push or pull 	  text as needed.)    (PROG ((NLINE1 (create LINEDESCRIPTOR using LINE))	   (LINES\DELETED NIL)	   (LINES (fetch LINES of TEXTOBJ))	   (DS (fetch DS of TEXTOBJ))	   (WINDOW (fetch \WINDOW of TEXTOBJ))	   (NEXTLINE (fetch NEXTLINE of LINE))	   (PREVLINE (fetch PREVLINE of LINE))	   (WWIDTH (fetch WRIGHT of TEXTOBJ))	   LEN NL OLINE DX OCHLIM OXLIM OCR\END NYBOT OFLOWFN)          (replace CACHE of NLINE1 with (BITMAPCREATE WWIDTH (fetch LHEIGHT of NLINE1)))                                                             (* Image cache for the new line.)          (replace NEXTLINE of LINE with NLINE1)          (SETQ CH# (IMIN CH# (fetch TEXTLEN of TEXTOBJ)))   (* Limit CH# to pre-existing text length)          (replace PREVLINE of NLINE1 with LINE)          (AND NEXTLINE (replace PREVLINE of NEXTLINE with NLINE1))          [SETQ NYBOT (replace YBOT of NLINE1 with (IDIFFERENCE (fetch YBOT of NLINE1)								(fetch LHEIGHT of NLINE1]                                                             (* New line's location)          (COND	    ((AND (ILEQ NYBOT (fetch WBOTTOM of TEXTOBJ))		  (SETQ OFLOWFN (WINDOWPROP WINDOW (QUOTE TEDIT.OVERFLOWFN)))		  (APPLY* OFLOWFN WINDOW TEXTOBJ))           (* This pushed a line off-screen, and there was an 							     overflow function, and it handled the problem.							     Just bail out of the update.)	      (RETURN)))          (replace YBASE of NLINE1 with (IDIFFERENCE (fetch YBASE of NLINE1)						     (fetch LHEIGHT of NLINE1)))          (replace SPACELEFT of LINE with (IPLUS (fetch SPACELEFT of LINE)						 (fetch LXLIM of LINE)						 (IMINUS XPOINT)))          (replace CHARLIM of LINE with CH#)          (replace CHARTOP of LINE with CH#)          (replace CR\END of LINE with T)          (replace LXLIM of LINE with (IPLUS XPOINT CHWIDTH))          (AND NEXTLINE (\PUSHLINES TEXTOBJ NEXTLINE (fetch LHEIGHT of NLINE1)				    DS				    (fetch WRIGHT of TEXTOBJ)))                                                             (* Move the rest of the text down, to make room for the 							     new line)          (BITBLT DS XPOINT (fetch YBOT of LINE)		  DS		  (fetch LEFTMARGIN of NLINE1)		  (fetch YBOT of NLINE1)		  (fetch SPACELEFT of LINE)		  (fetch LHEIGHT of NLINE1)		  (QUOTE INPUT)		  (QUOTE REPLACE))                           (* Copy text after the CR to the new line)          (BITBLT NIL 0 0 DS XPOINT (fetch YBOT of LINE)		  (fetch SPACELEFT of LINE)		  (fetch LHEIGHT of LINE)		  (QUOTE TEXTURE)		  (QUOTE REPLACE)		  WHITESHADE)                                (* Blank the pre-existing line from where the CR went 							     in)          (BITBLT NIL 0 0 DS [IDIFFERENCE WWIDTH (IPLUS (fetch SPACELEFT of NLINE1)							(IDIFFERENCE XPOINT (fetch LEFTMARGIN									       of NLINE1]		  (fetch YBOT of NLINE1)		  (fetch WRIGHT of TEXTOBJ)		  (fetch LHEIGHT of NLINE1)		  (QUOTE TEXTURE)		  (QUOTE REPLACE)		  WHITESHADE)                                (* Blank the newly-created line to the right of the new 							     text.)          (SETQ OXLIM (IPLUS (fetch LEFTMARGIN of NLINE1)			     (IDIFFERENCE (fetch LXLIM of NLINE1)					  XPOINT)))          (* XLIM of the new line, as just moved down -- not 							     counting any text which may move upward to fill it out.)          (SETQ OCHLIM (fetch CHARLIM of NLINE1))          (SETQ OCR\END (fetch CR\END of NLINE1))          (\FORMATLINE TEXTOBJ NIL (ADD1 CH#)		       THISLINE NLINE1)          [COND	    ([OR (NOT (IEQP OXLIM (fetch LXLIM of NLINE1)))		 (NOT (IEQP OCHLIM (fetch CHARLIM of NLINE1]	      (SETQ DX (IDIFFERENCE (fetch LXLIM of NLINE1)				    OXLIM))	      (COND		[(IGREATERP DX 0)		  (while (IGREATERP DX 0)		     do (COND			  [NEXTLINE (COND				      ((AND (IGREATERP (IDIFFERENCE (fetch LXLIM of NEXTLINE)								    (fetch LEFTMARGIN of NEXTLINE))						       DX)					    (IGREATERP (fetch YBOT of NEXTLINE)						       (fetch WBOTTOM of TEXTOBJ)))                                                             (* Text moved up to fill the line out.							     Make the change on-screen, too)					(BITBLT DS (fetch LEFTMARGIN of NEXTLINE)						(fetch YBOT of NEXTLINE)						DS OXLIM (fetch YBOT of NLINE1)						DX						(fetch LHEIGHT of NLINE1)						(QUOTE INPUT)						(QUOTE REPLACE))                                                             (* Move the text image up)					(BITBLT DS 0 (fetch YBOT of NLINE1)						(fetch CACHE of NLINE1)						0 0 WWIDTH (fetch LHEIGHT of NLINE1)						(QUOTE INPUT)						(QUOTE REPLACE))                                                             (* Now cache the new line image for later use.)					(SETQ LINES\DELETED					  (OR (\PULLTEXT NEXTLINE DX (ADD1 (fetch CHARLIM									      of NLINE1))							 THISLINE TEXTOBJ)					      LINES\DELETED))                                                             (* Then propogate the text movement)					(SETQ DX 0))				      ((ILEQ (fetch YBOT of NEXTLINE)					     (fetch WBOTTOM of TEXTOBJ))                                                             (* The next line lies below bottom of window--just 							     Displayline, and blast the next line to hell.)					(\DISPLAYLINE TEXTOBJ NLINE1)					(replace NEXTLINE of NLINE1 with NIL)					(replace PREVLINE of NEXTLINE with NIL)					(HELP)					(SETQ DX 0))				      (T                     (* NEXT NLINE1 WON'T FILL THIS ONE: GRAB IT, DECREMENT 							     DX, BUMP LXLIM, MOVE ANY LOWER LINES UP OVER IT, AND TRY							     AGAIN.)					 (BITBLT DS (fetch LEFTMARGIN of NEXTLINE)						 (fetch YBOT of NEXTLINE)						 DS OXLIM (fetch YBOT of NLINE1)						 (fetch LXLIM of NEXTLINE)						 (fetch LHEIGHT of NEXTLINE)						 (QUOTE INPUT)						 (QUOTE REPLACE))					 [SETQ DX (IDIFFERENCE DX (IDIFFERENCE (fetch LXLIM										  of NEXTLINE)									       (fetch LEFTMARGIN										  of NEXTLINE]					 [SETQ OXLIM (IPLUS OXLIM (IDIFFERENCE (fetch LXLIM										  of NEXTLINE)									       (fetch LEFTMARGIN										  of NEXTLINE]					 (SETQ NL (fetch NEXTLINE of NEXTLINE))					 (TEDIT.DELETELINE NEXTLINE TEXTOBJ)					 (SETQ NEXTLINE NL)					 (SETQ LINES\DELETED T]			  (T (\DISPLAYLINE TEXTOBJ NLINE1)			     (SETQ DX 0]		((ILESSP DX 0)                               (* Not a problem if the CR overflew the line length 							     limits)		  ]          (COND	    (LINES\DELETED                                   (* A complete text line was deleted.							     Fill the screen with more lines, to fit.)			   (SETQ OLINE (\TEDIT.FIND.LAST.LINE TEXTOBJ LINES))                                                             (* OLINE is now the last line displayed on the screen.)			   (\FILLWINDOW (fetch YBOT of OLINE)					OLINE TEXTOBJ THISLINE)))          (TEDIT.SET.SEL.LOOKS SEL (QUOTE NORMAL))          (replace CHLIM of SEL with (fetch CH# of SEL))          (replace L1 of SEL with NLINE1)          (replace LN of SEL with NLINE1)          (replace DCH of SEL with 0)          (replace DX of SEL with 0)          (replace POINT of SEL with (QUOTE LEFT))          (replace SELKIND of SEL with (QUOTE CHAR))          (replace X0 of SEL with (replace XLIM of SEL with (fetch LEFTMARGIN of NLINE1)))          [SETQ NYBOT (replace Y0 of SEL with (replace YLIM of SEL with (fetch YBOT of NLINE1]          (\SHOWSEL SEL NIL T)          (COND	    ((ILEQ NYBOT (fetch WBOTTOM of TEXTOBJ))         (* This pushed the caret off-screen.							     Move it up.)	      (SCROLLW WINDOW 0 (LLSH (fetch LHEIGHT of NLINE1)				      1])(TEDIT.CREATEW  [LAMBDA (PROMPT)                                           (* jds "15-MAR-83 10:42")    (CLRPROMPT)    (printout PROMPTWINDOW PROMPT T)    (SETQ TEDIT.DEFAULT.WINDOW (CREATEW (GETREGION)					"Text Editor Window"))    (CLRPROMPT)    (DSPFONT TEDIT.DEFAULT.FONT TEDIT.DEFAULT.WINDOW)    TEDIT.DEFAULT.WINDOW])(TEDIT.CURSORMOVEDFN  [LAMBDA (W)                                                (* jds "14-JUL-83 15:00")                                                             (* Watch the mouse and change the cursor to reflect the 							     region of the window it's in 							     (line select, window split eventually?))    (PROG [(X (LASTMOUSEX W))	   (TEXTOBJ (WINDOWPROP W (QUOTE TEXTOBJ]          (SELECTQ (fetch MOUSEREGION of TEXTOBJ)		   [TEXT (COND			   ((ILESSP X (IPLUS (fetch WLEFT of TEXTOBJ)					     8))             (* In left margin; switch to the line-select cursor)			     (CURSOR TEDIT.LINECURSOR)			     (replace MOUSEREGION of TEXTOBJ with (QUOTE LINE]		   [LINE (COND			   ((IGEQ X (IPLUS (fetch WLEFT of TEXTOBJ)					   8))			     (CURSOR T)			     (replace MOUSEREGION of TEXTOBJ with (QUOTE TEXT]		   NIL])(TEDIT.CURSOROUTFN  [LAMBDA (W)                                                (* jds "30-JUL-82 10:10")                                                             (* Cursor leaves edit window;							     make sure we think we're in the text region.)    (PROG [(TEXTOBJ (WINDOWPROP W (QUOTE TEXTOBJ]          (COND	    ((EQ (fetch MOUSEREGION of TEXTOBJ)		 (QUOTE LINE))	      (CURSOR T)	      (replace MOUSEREGION of TEXTOBJ with (QUOTE TEXT])(TEDIT.DELETE  [LAMBDA (STREAM SEL LEN)                                   (* jds "21-FEB-83 15:31")                                                             (* DELETE THE CHARACTERS SPECIFIED FROM THE MAIN TEXT.)    (PROG [(TEXTOBJ (COND		      ((type? STREAM STREAM)			(fetch F3 of STREAM))		      (T STREAM]          [COND	    ((FIXP SEL)	      (TEDIT.SETSEL STREAM SEL LEN)	      (SETQ SEL (fetch SEL of TEXTOBJ]          (OR SEL (SETQ SEL (fetch SEL of TEXTOBJ)))          (\TEDIT.DELETE SEL TEXTOBJ (fetch THISLINE of TEXTOBJ])(TEDIT.DO.BLUEPENDINGDELETE  [LAMBDA (SEL TEXTOBJ THISLINE)                             (* jds "21-MAR-83 16:44")                                                             (* Check for blue-pending-delete, and do it if it's 							     there.)    (COND      (TEDIT.BLUEPENDINGDELETE                               (* If he's in a Blue-pending-delete state, delete the 							     selection.)			       (\TEDIT.DELETE SEL (fetch \TEXTOBJ of SEL)					      THISLINE)			       (\SHOWSEL SEL NIL NIL)			       (SETQ TEDIT.PENDINGDEL NIL)			       (SETQ TEDIT.BLUEPENDINGDELETE NIL)			       (TEDIT.SET.SEL.LOOKS SEL (QUOTE NORMAL))			       (\SHOWSEL SEL NIL T])(TEDIT.EXTEND.SEL  [LAMBDA (X Y OSEL THISLINE TEXTOBJ SELOPERATION)           (* jds "25-JUL-83 15:04")                                                             (* Gather a new selected character, and extend OSEL to 							     include it. Return the extended selection.)    (PROG ([NSEL (TEDIT.SELECT X Y TEXTOBJ THISLINE (SELECTQ (fetch SELKIND of OSEL)							     ((LINE PARA)							       (QUOTE LINE))							     ((WORD CHAR)							       (QUOTE TEXT))							     (QUOTE TEXT))			       (OR (EQ (fetch SELKIND of OSEL)				       (QUOTE WORD))				   (EQ (fetch SELKIND of OSEL)				       (QUOTE PARA]	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   (NPOINT NIL)	   (SETOSELFLG NIL))                                 (* Assume They're on the same line of text;							     the easy case.)          (COND	    ((AND NSEL (fetch SET of NSEL))                  (* If there's no second selection, don't bother trying)	      (TEDIT.SET.SEL.LOOKS NSEL SELOPERATION)        (* Make the new selection be the same kind as the 							     original, as to what it's for -- regular, copy-source, 							     etc.)	      [SETQ NPOINT (COND		  ((ILESSP (fetch CH# of NSEL)			   (fetch CH# of OSEL))              (* If the new selection starts to left of old one, caret							     goes at the LEFT)		    (QUOTE LEFT))		  ((ILEQ (fetch CHLIM of NSEL)			 (fetch CHLIM of OSEL))              (* If the selections overlap, leave it alone.)		    (SETQ SETOSELFLG T)		    NIL)		  (T                                         (* Otherwise, it's to the RIGHT)		     (QUOTE RIGHT]	      [SELECTQ NPOINT		       (LEFT                                 (* Caret's to the left. Keep the same right end)			     (replace CHLIM of NSEL with (fetch CHLIM of OSEL))			     (replace XLIM of NSEL with (fetch XLIM of OSEL))			     (replace YLIM of NSEL with (fetch YLIM of OSEL))			     (replace LN of NSEL with (fetch LN of OSEL)))		       (RIGHT                                (* Point's to the right; keep the same left end.)			      (replace CH# of NSEL with (fetch CH# of OSEL))			      (replace X0 of NSEL with (fetch X0 of OSEL))			      (replace Y0 of NSEL with (fetch Y0 of OSEL))			      (replace L1 of NSEL with (fetch L1 of OSEL)))		       (PROGN (replace CHLIM of NSEL with (fetch CHLIM of OSEL))			      (replace XLIM of NSEL with (fetch XLIM of OSEL))			      (replace YLIM of NSEL with (fetch YLIM of OSEL))			      (replace LN of NSEL with (fetch LN of OSEL))			      (replace CH# of NSEL with (fetch CH# of OSEL))			      (replace X0 of NSEL with (fetch X0 of OSEL))			      (replace Y0 of NSEL with (fetch Y0 of OSEL))			      (replace L1 of NSEL with (fetch L1 of OSEL))			      (SETQ NPOINT (fetch POINT of OSEL]	      [replace DCH of NSEL with (ADD1 (IDIFFERENCE (IMIN TEXTLEN (fetch CHLIM of NSEL))							   (fetch CH# of NSEL]                                                             (* The selection's length cannot exceed that of the 							     whole text.)	      [replace CHLIM of NSEL with (IPLUS (fetch CH# of NSEL)						 (SUB1 (fetch DCH of NSEL]                                                             (* This assures that the CHLIM corresponds to the DCH.)	      (replace POINT of NSEL with NPOINT)	      (replace DX of NSEL with (IDIFFERENCE (fetch XLIM of NSEL)						    (fetch X0 of NSEL)))	      (COND		(SETOSELFLG                                  (* For whatever reason, it is wise to copy the new sel 							     into the old one.)			    (\COPYSEL NSEL OSEL))		(T                                           (* Otherwise, set the POINT of the old sel to correspond							     to the new sel's.)		   (replace POINT of OSEL with NPOINT)))	      (RETURN NSEL))	    (T                                               (* No new selection was made;							     just return the old one.)	       (RETURN OSEL])(TEDIT.FIND  [LAMBDA (TEXTOBJ STRING CH#)                               (* jds "21-JUL-83 13:36")          (* Search thru TEXTOBJ, starting where the caret is, for the string STRING, exact match only for now.	  (Optionally, start the search at character ch#.))    (COND      ((type? STREAM TEXTOBJ)	(SETQ TEXTOBJ (fetch F3 of TEXTOBJ)))      ((type? TEXTOBJ TEXTOBJ))      (T (SHOULDNT)))    (PROG ((SEL (fetch SEL of TEXTOBJ))	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   [TEXTLIM (ADD1 (IDIFFERENCE (fetch TEXTLEN of TEXTOBJ)				       (NCHARS STRING]	   (FOUND NIL)	   (CH#1 (NTHCHARCODE STRING 1))	   CH1 ANCHOR PCH# OANCHOR CH)          (\TEDIT.HISTORYADD (create TEDITHISTORYEVENT				     THACTION _(QUOTE Find)				     THAUXINFO _ STRING				     THTEXTOBJ _ TEXTOBJ))          (replace \INSERTNEXTCH of TEXTOBJ with -1)          (COND	    ((OR CH# (fetch SET of SEL))                     (* There must be a well-defined starting point.)	      (RETURN (PROG NIL			    (SETQ CH1 (OR CH# (SELECTQ (fetch POINT of SEL)						       (LEFT (fetch CH# of SEL))						       (RIGHT (ADD1 (fetch CHLIM of SEL)))						       NIL)))                                                             (* Find the starting point for the search)                                                             (* DO THE SEARCH)			RETRY			    (SETQ ANCHOR CH1)			    (\SETUPGETCH CH1 TEXTOBJ)			    (SETQ CH (\GETCH TEXTOBJ))			    (for old ANCHOR from CH1 to TEXTLEN			       do (COND				    ((EQ CH CH#1)				      (RETURN)))				  (SETQ CH (\GETCH TEXTOBJ)))			    (COND			      ((IGREATERP ANCHOR TEXTLIM)				(RETURN NIL)))               (* No starting character found before end of string)			    (SETQ OANCHOR ANCHOR)			    (SETQ FOUND T)			    [for old CH1 from (ADD1 ANCHOR) to TEXTLEN as PCH# from 2			       to (NCHARS STRING)			       do (SETQ CH (\GETCH TEXTOBJ))				  (COND				    ((NEQ CH (NTHCHARCODE STRING PCH#))				      (SETQ FOUND NIL)				      (RETURN]			    (COND			      (FOUND (RETURN ANCHOR))			      (T (GO RETRY])(TEDIT.FORMATTEDP  [LAMBDA (FILE LEN)                                         (* jds "13-JAN-83 18:21")          (* Returns NIL if it isn't a formatted file, or the # of pieces needed if it is; leaves file at start of text or 	  of piece descriptions, resp.)    (SETQ LEN (OR LEN (GETEOFPTR FILE)))    (PROG (DESCPTR NPIECES PASSWORD)          (COND	    ((ILEQ LEN 8)                                    (* Too short to be formatted.)	      (RETURN NIL))	    (T (SETFILEPTR FILE (IDIFFERENCE LEN 8))         (* Move to start of FILEPTR to descriptions)	       (SETQ DESCPTR (\DWIN FILE))                   (* Read the file pos of the descripotions)	       (SETQ NPIECES (\WIN FILE))	       (SETQ PASSWORD (\WIN FILE))	       (COND		 ((IEQP PASSWORD 31415)		   (SETFILEPTR FILE DESCPTR)		   (RETURN NPIECES))		 (T (RETURN NIL])(TEDIT.GET  [LAMBDA (TEXTOBJ FILE)                                     (* jds "17-AUG-83 16:01")                                                             (* Get a new file (overwriting the one being edited.))    (PROG (OFILE OCURSOR LINES (PCTB (fetch PCTB of TEXTOBJ))		 (TEDIT.GET.FINISHEDFORMS NIL))          [SETQ OFILE (OR FILE (MKATOM (TEDIT.GETINPUT "Name of the file to load:  "]          (\SHOWSEL (fetch SEL of TEXTOBJ)		    NIL NIL)          (COND	    [OFILE (RESETLST (RESETSAVE (TTYDISPLAYSTREAM PROMPTWINDOW))			     (RESETSAVE (CURSOR WAITINGCURSOR))			     (SETQ OFILE (\GETOFD (OPENFILE OFILE (QUOTE INPUT))						  (QUOTE INPUT)))			     (COND			       [(\TEDIT.FORMATTEDP1 OFILE)   (* This file is formatted--build a compacted piece 							     table.)				 (SETQ PCTB (replace PCTB of TEXTOBJ with (TEDIT.BUILD.PCTB OFILE 											  TEXTOBJ]			       (T                            (* Unformatted file--build a single-piece piece table.)				  (\CLEARPCTB PCTB)				  (\INSERTPIECE (\CREATEPIECE OFILE)						(QUOTE LASTPIECE)						TEXTOBJ)))			     (for FORM in TEDIT.GET.FINISHEDFORMS do (EVAL FORM))                                                             (* Do any necessary cleanup for outside packages)			     (SETQ LINES (fetch LINES of TEXTOBJ))			     (replace TXTFILE of TEXTOBJ with (\GETOFD OFILE (QUOTE INPUT)))			     (replace \DIRTY of TEXTOBJ with NIL)			     (replace NEXTLINE of LINES with NIL)			     (replace \INSERTNEXTCH of TEXTOBJ with -1)			     [replace TEXTLEN of TEXTOBJ				with (SUB1 (\EDITELT PCTB (SUB1 (\EDITELT PCTB \PCTBLastPieceOffset]			     (replace SET of (fetch SEL of TEXTOBJ) with NIL)			     (replace SET of (fetch SCRATCHSEL of TEXTOBJ) with NIL)			     (replace SET of (fetch SHIFTEDSEL of TEXTOBJ) with NIL)			     (replace SET of (fetch MOVESEL of TEXTOBJ) with NIL)			     (replace SET of TEDIT.SELECTION with NIL)			     (replace SET of TEDIT.SHIFTEDSELECTION with NIL)			     (\FILLWINDOW (fetch YBOT of LINES)					  LINES TEXTOBJ (fetch THISLINE of TEXTOBJ))			     (WINDOWPROP (fetch \WINDOW of TEXTOBJ)					 (QUOTE TITLE)					 (TEDIT.WINDOW.TITLE TEXTOBJ))			     (\TEDIT.HISTORYADD (create TEDITHISTORYEVENT							THACTION _(QUOTE Get]	    (T (printout PROMPTWINDOW T "[Get aborted.]" T])(TEDIT.GET.CHARLOOKS  [LAMBDA (PC FILE)                                          (* jds "17-JAN-83 14:56")                                                             (* Put a description of LOOKS into FILE.							     LOOKS apply to characters CH1 thru CHLIM-1)    (PROG (FONT STR NAME NAMELEN SIZE SUPER SUB PROPS (LOOKS (create CHARLOOKS)))          (replace PLOOKS of PC with LOOKS)          (SETQ NAMELEN (\WIN FILE))                         (* The length of the description which follows)          [SETQ NAME (PACK (for I from 1 to NAMELEN collect (CHARACTER (\BIN FILE]                                                             (* The font name)          (SETQ SIZE (\WIN FILE))                            (* Size of the type, in points)          (SETQ SUPER (\WIN FILE))                           (* Superscripting distance)          (SETQ SUB (\WIN FILE))                             (* Subscripting distance)          (\WIN FILE)                                        (* Placeholder for the style designation)          (SETQ PROPS (\WIN FILE))          (with CHARLOOKS LOOKS [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]		[SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]		[SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]		[SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]		[SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]		[SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]		[SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]		[SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]		[SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]		[SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]		(SETQ CLSIZE SIZE))          (replace CLFONT of LOOKS with (FONTCREATE NAME SIZE (COND						      ((AND (fetch CLBOLD of LOOKS)							    (fetch CLITAL of LOOKS))							(QUOTE BOLDITALIC))						      ((fetch CLBOLD of LOOKS)							(QUOTE BOLD))						      ((fetch CLITAL of LOOKS)							(QUOTE ITALIC])(TEDIT.GET.OBJECT  [LAMBDA (STREAM PIECE FILE CURCH#)                         (* jds " 9-JUN-83 14:32")                                                             (* Get an object from the file)                                                             (* CURCH# = fileptr within the text section of the file 							     where the object's text starts.)    (PROG (FILEPTRSAVE NAMELEN NAME)          (SETQ NAMELEN (\WIN FILE))                         (* The length of the description which follows)          [SETQ NAME (PACK (for I from 1 to NAMELEN collect (CHARACTER (\BIN FILE]                                                             (* The re-load function name)          (SETQ FILEPTRSAVE (GETFILEPTR FILE))               (* Save our file location thru the building of the 							     object)          (APPLY* NAME STREAM PIECE FILE CURCH#)          (SETFILEPTR FILE FILEPTRSAVE)          (RETURN (fetch POBJ of PIECE])(TEDIT.GET.PARALOOKS  [LAMBDA (PC FILE)                                          (* jds "19-APR-83 11:07")                                                             (* Put a description of LOOKS into FILE.							     LOOKS apply to characters CH1 thru CHLIM-1)    (PROG ((LOOKS (create FMTSPEC)))          (replace PPARALOOKS of PC with LOOKS)          (replace 1STLEFTMAR of LOOKS with (\WIN FILE))     (* Left margin for the first line of the paragraph)          (replace LEFTMAR of LOOKS with (\WIN FILE))        (* Left margin for the rest of the paragraph)          (replace RIGHTMAR of LOOKS with (\WIN FILE))       (* Right margin for the paragraph)          (replace LEADBEFORE of LOOKS with (\WIN FILE))     (* Leading before the paragraph)          (replace LEADAFTER of LOOKS with (\WIN FILE))      (* Lead after the paragraph)          (replace LINELEAD of LOOKS with (\WIN FILE))       (* inter-line leading)          (replace TABSPEC of LOOKS with NIL)                (* Will be tab specs)          (replace QUAD of LOOKS with (SELECTC (\WIN FILE)					       (1 (QUOTE LEFT))					       (2 (QUOTE RIGHT))					       (3 (QUOTE CENTER))					       (4 (QUOTE JUST))					       (SHOULDNT])(TEDIT.GETINPUT  [LAMBDA (PROMPTSTRING DEFAULTSTRING DELIMITER.LIST)        (* jds "17-AUG-83 15:05")                                                             (* Ask for input (file names, &c) for TEdit, perhaps 							     with a default.)    (FRESHLINE PROMPTWINDOW)    (PROMPTFORWORD PROMPTSTRING DEFAULTSTRING NIL PROMPTWINDOW NIL NIL		   (OR DELIMITER.LIST (CHARCODE (EOL LF TAB ESCAPE)))		   NIL])(TEDIT.GETSEL  [LAMBDA (STREAM)                                           (* jds " 2-JUN-83 15:49")    (create SELECTION using (fetch SEL of (fetch F3 of STREAM])(TEDIT.INCLUDE  [LAMBDA (TEXTOBJ THISLINE)                                 (* jds "16-AUG-83 11:05")                                                             (* Obtain a file name, and include that file's contents 							     at the place where the caret is.)                                                             (* Returns T if the insertion happened, NIL if there was							     no place to put it.)    (PROG ((SEL (fetch SEL of TEXTOBJ))	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   (PCTB (fetch PCTB of TEXTOBJ))	   NFILE INSERTCH# INSPC LEN CHANGEDLINE INSPC# PCLST NPC)          (COND	    ((fetch SET of SEL)                              (* There is a place to do the include.)	      (SETQ NFILE (MKATOM (TEDIT.GETINPUT "Name of the file to load:  ")))	      (OR NFILE (RETURN))                            (* If no file was given, don't bother INCLUDEing.)	      (TEDIT.DO.BLUEPENDINGDELETE SEL TEXTOBJ THISLINE)                                                             (* Delete any text, if need be)	      (\SHOWSEL SEL NIL NIL)                         (* Turn off SELs before we go any further)	      [SETQ INSERTCH# (COND		  ((EQ (fetch POINT of SEL)		       (QUOTE LEFT))		    (fetch CH# of SEL))		  (T (ADD1 (fetch CHLIM of SEL]              (* Find the place to make the insertion.)	      (SETQ INSPC# (OR (\CHTOPCNO INSERTCH# PCTB)			       (\EDITELT PCTB \PCTBLastPieceOffset)))	      (SETQ INSPC (\EDITELT (fetch PCTB of TEXTOBJ)				    (ADD1 INSPC#)))          (* The piece to make the insertion in)	      [COND		((NEQ INSPC (QUOTE LASTPIECE))		  (COND		    ((IGREATERP INSERTCH# (\EDITELT PCTB INSPC#))                                                             (* Must split the piece.)		      (SETQ INSPC (\SPLITPIECE INSPC INSERTCH# TEXTOBJ INSPC#))		      (add INSPC# 1)		      (SETQ PCTB (fetch PCTB of TEXTOBJ))    (* Refresh the PCTB in case it grew.)		      ]	      (SETQ NFILE (\GETOFD (OPENFILE NFILE (QUOTE INPUT))				   (QUOTE INPUT)))	      [COND		[(SETQ NPC (\TEDIT.FORMATTEDP1 NFILE))       (* The INCLUDEd file is formatted: Copy all the pieces.)		  (SETQ PCLST (TEDIT.BUILD.PCTB NFILE NIL))		  [SETQ LEN (SUB1 (\EDITELT PCLST (SUB1 (\EDITELT PCLST \PCTBLastPieceOffset]		  (for I from 1 to NPC as PCN from (ADD1 \FirstPieceOffset) by \EltsPerPiece		     do (\INSERTPIECE (\EDITELT PCLST PCN)				      INSPC TEXTOBJ))		  (SETQ PCLST (\EDITELT PCLST (ADD1 \FirstPieceOffset]		(T                                           (* Not formatted, so the file will be a single piece.)		   (SETQ PCLST (\CREATEPIECE NFILE))		   (\INSERTPIECE PCLST INSPC TEXTOBJ)		   (SETQ LEN (fetch PLEN of PCLST]	      (replace \INSERTNEXTCH of TEXTOBJ with -1)	      (\TEDIT.HISTORYADD (create TEDITHISTORYEVENT					 THACTION _(QUOTE Include)					 THCH# _ INSERTCH#					 THLEN _ LEN					 THFIRSTPIECE _ PCLST					 THTEXTOBJ _ TEXTOBJ))	      (\FIXILINES (fetch LINES of TEXTOBJ)			  SEL INSERTCH# LEN TEXTLEN)	      (\TEXTSETEOF (fetch STREAMHINT of TEXTOBJ)			   (replace TEXTLEN of TEXTOBJ with (IPLUS TEXTLEN LEN)))	      (AND (SETQ CHANGEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))		   (\FILLWINDOW (fetch YBOT of CHANGEDLINE)				CHANGEDLINE TEXTOBJ THISLINE))	      (replace CHLIM of SEL with (IPLUS (replace CH# of SEL with INSERTCH#)						LEN -1))     (* Now fix up the selection to be the included text, 							     point_left, character selection grain.)	      (replace DCH of SEL with LEN)	      (replace DX of SEL with 0)	      (replace POINT of SEL with (QUOTE LEFT))	      (replace SELKIND of SEL with (QUOTE CHAR))	      (\FIXSEL SEL TEXTOBJ)	      (\SHOWSEL SEL NIL T)	      (replace \DIRTY of TEXTOBJ with T)             (* Mark the document changed)	      T)	    (T (CLRPROMPT)	       (printout PROMPTWINDOW "Please choose the place for the INCLUDE first." T)	       NIL])(TEDIT.INSERT  [LAMBDA (STREAM CH SELORCH#)                               (* jds "18-JUL-83 14:43")                                                             (* Insert the character CH at the appropriate spot in 							     the text.)    [COND      ((FIXP SELORCH#)                                       (* He gave us a ch# to insert before)	(TEDIT.SETSEL STREAM SELORCH# 1 (QUOTE LEFT]    [COND      ((LITATOM CH)	(SETQ CH (MKSTRING CH]    [OR (type? SELECTION SELORCH#)	(SETQ SELORCH# (fetch SEL of (fetch F3 of STREAM]    (COND      [(AND SELORCH# (fetch SET of SELORCH#))	(PROG ((TEXTOBJ (fetch F3 of STREAM)))	      (PROG ((CH# (IMAX 1 (SELECTQ (fetch POINT of SELORCH#)					   (LEFT (fetch CH# of SELORCH#))					   [RIGHT (ADD1 (IMIN (fetch TEXTLEN of TEXTOBJ)							      (fetch CHLIM of SELORCH#]					   NIL)))		     (LINE (SELECTQ (fetch POINT of SELORCH#)				    (LEFT (fetch L1 of SELORCH#))				    (RIGHT (fetch LN of SELORCH#))				    NIL))		     (XPOINT (SELECTQ (fetch POINT of SELORCH#)				      (LEFT (fetch X0 of SELORCH#))				      (RIGHT (fetch XLIM of SELORCH#))				      NIL))		     (OTEXTLEN (fetch TEXTLEN of TEXTOBJ))		     (DS (fetch DS of TEXTOBJ))		     (LINES (fetch LINES of TEXTOBJ))		     (CHARS (COND			      ((type? STRINGP CH)				(NCHARS CH))			      (T 1)))		     BLANKSEEN CRSEEN)		    (COND		      ((fetch \WINDOW of TEXTOBJ)            (* If this text is in a window, move it so the insertion							     point is on-screen, then turn off the selection 							     highlight)			(TEDIT.NORMALIZECARET TEXTOBJ SELORCH#)			(\SHOWSEL SELORCH# NIL NIL)))		    (for ACHAR instring CH		       do                                    (* Find out if there are blanks or CRs in the new text.)			  (SELCHARQ ACHAR				    (CR (SETQ CRSEEN T)					(RETURN))				    (SPACE (SETQ BLANKSEEN T))				    NIL))		    (\INSERTCH CH CH# TEXTOBJ)               (* Go do the actual insertion)		    (\FIXILINES LINES SELORCH# CH# CHARS OTEXTLEN)                                                             (* Fix up the line descriptors and the Selection.)		    (TEDIT.INSERT.UPDATESCREEN CH CH# CHARS XPOINT TEXTOBJ SELORCH# LINE OTEXTLEN 					       BLANKSEEN CRSEEN DS)                                                             (* Update the edit window.)		]      (T (printout PROMPTWINDOW "Please select a place for the insertion." T])(TEDIT.INSERT.DISPLAYTEXT  [LAMBDA (TEXTOBJ CH CHWIDTH LINE XPOINT DS SEL)            (* jds " 4-JUL-83 20:10")                                                             (* This function does the actual displaying of typed-in 							     text on the edit window.)    (PROG ((OFONT (DSPFONT (fetch CLFONT of (fetch INSERTFONT of TEXTOBJ))			   DS))	   (TERMSA (fetch TXTTERMSA of TEXTOBJ)))          (\EDIT.UPCARET (fetch CARET of TEXTOBJ))          (BITBLT DS XPOINT (fetch YBOT of LINE)		  DS		  (IPLUS XPOINT CHWIDTH)		  (fetch YBOT of LINE)		  (IDIFFERENCE (fetch RIGHTMARGIN of LINE)			       XPOINT)		  (fetch LHEIGHT of LINE)		  (QUOTE INPUT)		  (QUOTE REPLACE))          (MOVETO XPOINT (fetch YBASE of LINE)		  DS)          [COND	    [TERMSA                                          (* Special terminal table for controlling character 							     display. Use it.)		    (RESETLST (RESETSAVE \PRIMTERMSA TERMSA)			      (replace F1 of (fetch STREAMHINT of TEXTOBJ) with DS)			      (COND				[(STRINGP CH)				  (for CHAR instring CH				     do (SELCHARQ CHAR						  (TAB       (* Put down white)						       (BITBLT NIL 0 0 DS XPOINT							       (fetch YBOT of LINE)							       36							       (fetch LHEIGHT of LINE)							       (QUOTE TEXTURE)							       (QUOTE REPLACE)							       WHITESHADE)						       (RELMOVETO 36 0 DS))						  (CR (BITBLT NIL 0 0 DS XPOINT							      (fetch YBOT of LINE)							      (IMAX 6 (CHARWIDTH CHAR OFONT))							      (fetch LHEIGHT of LINE)							      (QUOTE TEXTURE)							      (QUOTE REPLACE)							      WHITESHADE))						  (\DSPPRINTCHAR (fetch STREAMHINT of TEXTOBJ)								 CHAR]				(T (SELCHARQ CH					     (TAB            (* Put down white)						  (BITBLT NIL 0 0 DS XPOINT (fetch YBOT of LINE)							  36							  (fetch LHEIGHT of LINE)							  (QUOTE TEXTURE)							  (QUOTE REPLACE)							  WHITESHADE)						  (RELMOVETO 36 0 DS))					     (CR (BITBLT NIL 0 0 DS XPOINT (fetch YBOT of LINE)							 (IMAX 6 (CHARWIDTH CH OFONT))							 (fetch LHEIGHT of LINE)							 (QUOTE TEXTURE)							 (QUOTE REPLACE)							 WHITESHADE))					     (\DSPPRINTCHAR (fetch STREAMHINT of TEXTOBJ)							    CH]	    (T                                               (* No special handling; just use native character codes)	       (COND		 [(STRINGP CH)		   (for CHAR instring CH do (SELCHARQ CHAR						      (TAB                                                              (* Put down white)							   (BITBLT NIL 0 0 DS XPOINT								   (fetch YBOT of LINE)								   36								   (fetch LHEIGHT of LINE)								   (QUOTE TEXTURE)								   (QUOTE REPLACE)								   WHITESHADE)							   (RELMOVETO 36 0 DS))						      (CR (BITBLT NIL 0 0 DS XPOINT								  (fetch YBOT of LINE)								  (IMAX 6 (CHARWIDTH CHAR OFONT))								  (fetch LHEIGHT of LINE)								  (QUOTE TEXTURE)								  (QUOTE REPLACE)								  WHITESHADE))						      (BLTCHAR CHAR DS]		 (T (SELCHARQ CH			      (TAB                           (* Put down white)				   (BITBLT NIL 0 0 DS XPOINT (fetch YBOT of LINE)					   36					   (fetch LHEIGHT of LINE)					   (QUOTE TEXTURE)					   (QUOTE REPLACE)					   WHITESHADE)				   (RELMOVETO 36 0 DS))			      (CR (BITBLT NIL 0 0 DS XPOINT (fetch YBOT of LINE)					  (IMAX 6 (CHARWIDTH CH OFONT))					  (fetch LHEIGHT of LINE)					  (QUOTE TEXTURE)					  (QUOTE REPLACE)					  WHITESHADE))			      (BLTCHAR CH DS]          (BITBLT NIL 0 0 DS (fetch LXLIM of LINE)		  (fetch YBOT of LINE)		  (fetch WRIGHT of TEXTOBJ)		  (fetch LHEIGHT of LINE)		  (QUOTE TEXTURE)		  (QUOTE REPLACE)		  WHITESHADE)          (TEDIT.MODIFYLOOKS LINE XPOINT DS (fetch INSERTFONT of TEXTOBJ))          (OR (fetch TXTREADONLY of TEXTOBJ)	      (\EDIT.DOWNCARET (fetch CARET of TEXTOBJ)))          (DSPFONT OFONT DS])(TEDIT.INSERT.OBJECT  [LAMBDA (OBJECT STREAM CH#)                                (* jds " 3-AUG-83 13:02")                                                             (* Inserts the annotation OBJECT into text STREAM in 							     front of character CH.)    (PROG [(TEXTOBJ (fetch F3 of STREAM))	   (SEL (fetch SEL of (fetch F3 of STREAM]          (PROG ([PC (COND		       ((ILEQ CH# (fetch TEXTLEN of TEXTOBJ))			 (\CHTOPC CH# (fetch PCTB of TEXTOBJ)))		       (T (QUOTE LASTPIECE]		 PCNO CHNO NEWPC PREVPC (PCTB (ffetch PCTB of TEXTOBJ))		 (TEXTLEN (fetch TEXTLEN of TEXTOBJ)))	        (\SHOWSEL SEL NIL NIL)                       (* Turn off the selection for now)	        (SETQ CH# (IMIN CH# (ADD1 TEXTLEN)))         (* CH# we're to insert these characters in front of)	        (freplace \INSERTFIRSTCH of TEXTOBJ with -1)	        (SETQ PCNO (\FINDPIECE PC PCTB))             (* Piece we're to insert in front of or inside)	        (SETQ NEWPC (create PIECE				    PSTR _ NIL				    PFILE _ NIL				    POBJ _ OBJECT				    PLEN _ 1))               (* The new piece we're inserting)	        (COND		  ((OR (IGREATERP CH# TEXTLEN)		       (IEQP CH# (\EDITELT PCTB PCNO)))      (* We're inserting on a piece boundary;							     do it, then remember the prior piece.)		    (\INSERTPIECE NEWPC PC TEXTOBJ))		  (T                                         (* Not on a piece boundary; split the piece we're inside							     of, then insert.)		     (\INSERTPIECE NEWPC (\SPLITPIECE PC CH# TEXTOBJ)				   TEXTOBJ)))	        (SETQ PCTB (fetch PCTB of TEXTOBJ))	        (SETQ PREVPC (OR (fetch PREVPIECE of NEWPC)				 PC))                        (* The piece we're to take the inserted characters' 							     looks from)	        [replace INSERTFONT of TEXTOBJ		   with (replace PLOOKS of NEWPC with (COND							((ZEROP TEXTLEN)							  (CHARLOOKS.FROM.FONT TEDIT.DEFAULT.FONT))							(T (COND							     ((fetch CLSELHERE								 of (fetch PLOOKS of PREVPC))							       (create CHARLOOKS								  copying (fetch PLOOKS of PREVPC)									  CLSELHERE _ NIL CLPROTECTED 									  _ NIL))							     (T (fetch PLOOKS of PREVPC]	        (\TEDIT.HISTORYADD (create TEDITHISTORYEVENT					   THACTION _(QUOTE Insert)					   THCH# _ CH#					   THLEN _(fetch PLEN of NEWPC)					   THFIRSTPIECE _ NEWPC					   THTEXTOBJ _ TEXTOBJ))	        [SETQ TEXTLEN (\TEXTSETEOF (fetch STREAMHINT of TEXTOBJ)					   (freplace TEXTLEN of TEXTOBJ with (IPLUS 1 TEXTLEN]	        (replace \INSERTNEXTCH of TEXTOBJ with -1)	        (replace \DIRTY of TEXTOBJ with T)	        (replace DESC of (fetch THISLINE of TEXTOBJ) with NIL)	        (\FIXILINES (fetch LINES of TEXTOBJ)			    SEL CH# 1 (SUB1 TEXTLEN))	        (\FIXCHANGEDPART TEXTOBJ (fetch THISLINE of TEXTOBJ))	        (replace CH# of SEL with (replace CHLIM of SEL with (ADD1 CH#)))	        (replace DCH of SEL with 0)	        (replace DX of SEL with 0)	        (replace POINT of SEL with (QUOTE LEFT))	        (replace SELKIND of SEL with (QUOTE CHAR))	        (replace DESC of (fetch THISLINE of TEXTOBJ) with NIL)	        (\FIXSEL SEL TEXTOBJ)	        (\SHOWSEL SEL NIL T)	        (\COPYSEL SEL TEDIT.SELECTION])(TEDIT.INSERT.UPDATESCREEN  [LAMBDA (CH CH# CHARS XPOINT TEXTOBJ SEL LINE OTEXTLEN BLANKSEEN CRSEEN DS)                                                             (* jds " 3-AUG-83 13:02")                                                             (* Update the edit window after an insertion)    (PROG ((THISLINE (fetch THISLINE of TEXTOBJ))	   EOLFLAG CHORIG CHWIDTH OXLIM OCHLIM OCR\END PREVSPACE FIXEDLINE HIDEOUSFLAG NEXTLINE LINES 	   NEWLINEFLG DX PREVLINE SAVEWIDTH OFLOWFN)          (OR (fetch \WINDOW of TEXTOBJ)	      (RETURN))                                      (* If this textobj has no window to update, don't 							     bother)          (COND	    (LINE                                            (* We're typing into a pre-existing line)		  [COND		    [(STRINGP CH)                            (* Width of the inserted text, if it's > 1 character 							     long)		      (SETQ CHWIDTH (TEDIT.STRINGWIDTH CH (fetch CLFONT of (fetch INSERTFONT									      of TEXTOBJ))						       (fetch TXTTERMSA of TEXTOBJ]		    (T                                       (* Width for a single character)		       (SETQ CHWIDTH (SELCHARQ CH					       (TAB          (* Make all tabs 1/2 inch for the time being.)						    36)					       (CHARWIDTH CH (fetch CLFONT								of (fetch INSERTFONT of TEXTOBJ]		  [SETQ EOLFLAG (OR (IGREATERP CH# OTEXTLEN)				    (IGREATERP CH# (fetch CHARLIM of LINE]                                                             (* We're inserting at the end of a line.)		  (replace CH# of SEL with (IPLUS CHARS CH#))		  (replace CHLIM of SEL with (fetch CH# of SEL))		  (replace POINT of SEL with (QUOTE LEFT))		  (replace DCH of SEL with 0)		  (replace DX of SEL with 0)		  (replace X0 of SEL with (IPLUS CHWIDTH XPOINT))		  (replace XLIM of SEL with (IPLUS CHWIDTH XPOINT))		  (replace L1 of SEL with LINE)		  (replace LN of SEL with LINE)		  (replace Y0 of SEL with (fetch YBOT of LINE))		  (replace YLIM of SEL with (fetch YBOT of LINE))		  (replace SELKIND of SEL with (QUOTE CHAR))		  (SETQ OXLIM (fetch LXLIM of LINE))         (* Where the line used to end.)		  (SETQ OCHLIM (fetch CHARLIM of LINE))		  (SETQ OCR\END (AND (fetch CR\END of LINE)				     (NOT EOLFLAG)))         (* Remember whether or not this line used to end with a 							     CR)		  [SETQ BLANKSEEN (AND BLANKSEEN (SETQ PREVLINE (fetch PREVLINE of LINE))				       (NOT (fetch CR\END of PREVLINE))				       (ILEQ CH# (fetch CHARTOP of PREVLINE]		  (COND		    ((NEQ (fetch QUAD of (fetch LFMTSPEC of LINE))			  (QUOTE LEFT))                      (* It's anything other than left-ragged formatting.							     Must do redisplay the hard way.)		      (SETQ FIXEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))		      (AND FIXEDLINE (\FILLWINDOW (fetch YBOT of FIXEDLINE)						  FIXEDLINE TEXTOBJ THISLINE))		      (\FIXSEL SEL TEXTOBJ))		    ((AND CRSEEN (NOT BLANKSEEN)			  (OR (NOT (STRINGP CH))			      (IEQP 1 CHARS)))               (* Only a CR in this stash.)		      (TEDIT.CR.UPDATESCREEN CH# XPOINT TEXTOBJ SEL LINE THISLINE BLANKSEEN CRSEEN DS 					     CHWIDTH))		    [[OR BLANKSEEN CRSEEN (AND EOLFLAG (OR (ILEQ CH# OTEXTLEN)							   (fetch CR\END of LINE)))			 (IGREATERP CHWIDTH (IMIN (IDIFFERENCE (fetch RIGHTMARGIN of LINE)							       XPOINT)						  (fetch SPACELEFT of LINE]                                                             (* MOVE SOME TEXT TO THE NEXT LINE, CREATING IT IF NEED 							     BE.)		      (COND			(BLANKSEEN                           (* BlankSeen => back up to previous line, and try a pull							     of text.)				   (SETQ FIXEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))				   (AND FIXEDLINE (\FILLWINDOW (fetch YBOT of FIXEDLINE)							       FIXEDLINE TEXTOBJ THISLINE))				   (SETQ BLANKSEEN T)				   (\FIXSEL SEL TEXTOBJ)				   (\SHOWSEL SEL NIL T))			(T (\FORMATLINE TEXTOBJ NIL (fetch CHAR1 of LINE)					THISLINE LINE)			   (COND			     ([AND (ILESSP (fetch CHARLIM of LINE)					   (fetch TEXTLEN of TEXTOBJ))				   (OR (NOT (IEQP (IPLUS CHWIDTH OXLIM)						  (fetch LXLIM of LINE)))				       (NOT (IEQP (IPLUS CHARS OCHLIM)						  (fetch CHARLIM of LINE]                                                             (* The length of the line changed;							     we have to move some text.)			       (COND				 ((IGREATERP XPOINT (fetch LXLIM of LINE))                                                             (* The insertion point moved to the next line.)                                                             (* This => (1) Do push of text from this line)                                                             (* (2) Recompute insertx on new line.)                                                             (* (3) Go back and redo the insertion business.)				   (SETQ HIDEOUSFLAG T)				   (replace DIRTY of LINE with T)				   (replace CHARLIM of LINE with OCHLIM)				   (SETQ FIXEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))				   (AND FIXEDLINE (\FILLWINDOW (fetch YBOT of FIXEDLINE)							       FIXEDLINE TEXTOBJ THISLINE))				   (SETQ BLANKSEEN T)				   (\FIXSEL SEL TEXTOBJ))				 ((IGREATERP (IPLUS XPOINT CHWIDTH)					     (fetch LXLIM of LINE))                                                             (* The inserted text spans a line boundary.)				   (SETQ HIDEOUSFLAG T)				   (replace DIRTY of LINE with T)				   (replace CHARLIM of LINE with OCHLIM)				   (SETQ FIXEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))				   (AND FIXEDLINE (\FILLWINDOW (fetch YBOT of FIXEDLINE)							       FIXEDLINE TEXTOBJ THISLINE))				   (SETQ BLANKSEEN T)				   (\FIXSEL SEL TEXTOBJ))				 (T (SETQ DX (IDIFFERENCE (IPLUS OXLIM CHWIDTH)							  (fetch LXLIM of LINE)))				    (replace DIRTY of LINE with NIL)))			       (COND				 ((NOT HIDEOUSFLAG)				   (COND				     ((fetch NEXTLINE of LINE)				       [SETQ SAVEWIDTH (IMIN DX (IMAX 0 (IDIFFERENCE (fetch 										      RIGHTMARGIN											of LINE)										     (IDIFFERENCE										       OXLIM DX]                                                             (* Remember how much was REALLY saved in the SAVEBM)				       [OR (fetch CACHE of LINE)					   (replace CACHE of LINE					      with (BITMAPCREATE (fetch WRIGHT of TEXTOBJ)								 (fetch LHEIGHT of LINE]				       (BITBLT (fetch \WINDOW of TEXTOBJ)					       (IDIFFERENCE OXLIM DX)					       (fetch YBOT of LINE)					       (fetch CACHE of LINE)					       0 0 DX (fetch LHEIGHT of LINE)					       (QUOTE INPUT)					       (QUOTE REPLACE))				       (TEDIT.INSERT.DISPLAYTEXT TEXTOBJ CH CHWIDTH LINE XPOINT DS 								 SEL)				       (\PUSHTEXT (fetch NEXTLINE of LINE)						  (IDIFFERENCE OXLIM DX)						  (fetch YBOT of LINE)						  DX						  (ADD1 (fetch CHARLIM of LINE))						  TEXTOBJ THISLINE OCR\END (fetch CACHE of LINE)						  SAVEWIDTH))				     (T (TEDIT.INSERT.DISPLAYTEXT TEXTOBJ CH CHWIDTH LINE XPOINT DS 								  SEL)					(replace NEXTLINE of LINE					   with (\FORMATLINE TEXTOBJ NIL							     (ADD1 (fetch CHARLIM of LINE))							     THISLINE))					(SETQ NEWLINEFLG T)					(replace PREVLINE of (fetch NEXTLINE of LINE) with LINE)					(COND					  ((IGREATERP (fetch YBOT of LINE)						      (IPLUS (fetch LHEIGHT								of (fetch NEXTLINE of LINE))							     (fetch WBOTTOM of TEXTOBJ)))					    [replace YBOT of (fetch NEXTLINE of LINE)					       with (IDIFFERENCE (fetch YBOT of LINE)								 (fetch LHEIGHT								    of (fetch NEXTLINE of LINE]					    [replace YBASE of (fetch NEXTLINE of LINE)					       with (IPLUS (fetch YBOT of (fetch NEXTLINE									     of LINE))							   (fetch DESCENT							      of (fetch NEXTLINE of LINE]					    (\DISPLAYLINE TEXTOBJ (fetch NEXTLINE of LINE)))					  (T                 (* A Line fell off the bottom.							     Remember for potential later handling)					     (AND (SETQ OFLOWFN (WINDOWPROP (fetch \WINDOW									       of TEXTOBJ)									    (QUOTE TEDIT.OVERFLOWFN)))						  (APPLY* OFLOWFN (fetch \WINDOW of TEXTOBJ)							  TEXTOBJ]		    (T (replace SPACELEFT of LINE with (IDIFFERENCE (fetch SPACELEFT of LINE)								    CHWIDTH))		       (replace LXLIM of LINE with (IPLUS (fetch LXLIM of LINE)							  CHWIDTH))		       (replace DESC of THISLINE with NIL)		       (TEDIT.INSERT.DISPLAYTEXT TEXTOBJ CH CHWIDTH LINE XPOINT DS SEL)))		  [OR (fetch CACHE of LINE)		      (replace CACHE of LINE with (BITMAPCREATE (fetch WRIGHT of TEXTOBJ)								(fetch LHEIGHT of LINE]		  (BITBLT (fetch \WINDOW of TEXTOBJ)			  0			  (fetch YBOT of LINE)			  (fetch CACHE of LINE)			  0 0 (fetch WRIGHT of TEXTOBJ)			  (fetch LHEIGHT of LINE)			  (QUOTE INPUT)			  (QUOTE REPLACE))		  (\SHOWSEL SEL NIL T))	    (T                                               (* There isn't really a line to type into yet.							     Let's create it.)	       (SETQ LINE LINES)	       (replace NEXTLINE of LINE with (SETQ NEXTLINE (\FORMATLINE TEXTOBJ NIL 1 THISLINE)))                                                             (* Create the new line)	       (replace PREVLINE of NEXTLINE with LINE)	       (replace YBOT of NEXTLINE with (IDIFFERENCE (fetch YBOT of LINE)							   (fetch LHEIGHT of NEXTLINE)))                                                             (* Find where it goes on the screen)	       (replace YBASE of NEXTLINE with (IPLUS (fetch YBOT of NEXTLINE)						      (fetch DESCENT of NEXTLINE)))	       (\DISPLAYLINE TEXTOBJ NEXTLINE)               (* Display it and cache the image)	       (replace L1 of SEL with (replace LN of SEL with NEXTLINE))	       (\FIXSEL SEL TEXTOBJ)	       (\SHOWSEL SEL NIL T)))          (\COPYSEL SEL TEDIT.SELECTION)          (COND	    ((ILEQ (SELECTQ (fetch POINT of SEL)			    (LEFT (fetch Y0 of SEL))			    (RIGHT (fetch YLIM of SEL))			    0)		   (fetch WBOTTOM of TEXTOBJ))               (* The caret just went off-screen.							     Move it up some.)	      (\EDITSCROLLFN (fetch \WINDOW of TEXTOBJ)			     0			     (LLSH (fetch LHEIGHT of (SELECTQ (fetch POINT of SEL)							      (LEFT (fetch L1 of SEL))							      (RIGHT (fetch LN of SEL))							      (SHOULDNT)))				   1])(TEDIT.LOOKS  [LAMBDA (TEXTOBJ NLOOKS SEL LEN)                           (* jds " 3-AUG-83 13:02")                                                             (* Programmatic interface for character looks in TEdit)    (PROG ([TSEL (COND		   ((type? SELECTION SEL)		     SEL)		   (T (TEDIT.SETSEL TEXTOBJ SEL LEN (QUOTE LEFT]	   (PCTB (fetch PCTB of TEXTOBJ))	   (THISLINE (fetch THISLINE of TEXTOBJ))	   PC1 PCNO1 PCNON PCN (FONT NIL)	   (FACE NIL)	   (SIZE NIL)	   (PROT NIL)	   (SELHERE NIL)	   (ULINE NIL)	   (OLINE NIL)	   (STRIKE NIL)	   (SUPER NIL)	   (SUB NIL)	   NEWLOOKS DY (\INPC (fetch \INSERTPC of TEXTOBJ))	   CH# CHLIM CHANGEDLINE (OLDLOOKSLIST NIL))         (* Construct the set of new looks to apply:)          (COND	    ((type? CHARLOOKS NLOOKS)                        (* We've already got a made-up set of looks;							     we'll just use it.)	      )	    (T                                               (* We got an AList -- prepare looks changes in that 							     form)	       (SETQ NEWLOOKS NLOOKS)	       (SETQ FONT (GETPROP NLOOKS (QUOTE FAMILY)))	       (SETQ FACE (GETPROP NLOOKS (QUOTE FACE)))	       (SETQ SIZE (GETPROP NLOOKS (QUOTE SIZE)))	       (SETQ PROT (GETPROP NLOOKS (QUOTE PROTECTED)))	       (SETQ SELHERE (GETPROP NLOOKS (QUOTE SELECTPOINT)))	       (SETQ ULINE (GETPROP NLOOKS (QUOTE UNDERLINE)))	       (SETQ OLINE (GETPROP NLOOKS (QUOTE OVERLINE)))	       (SETQ STRIKE (GETPROP NLOOKS (QUOTE STRIKEOUT)))	       (SETQ SUPER (GETPROP NLOOKS (QUOTE SUPERSCRIPT)))	       (SETQ SUB (GETPROP NLOOKS (QUOTE SUBSCRIPT)))	       (SETQ NLOOKS NIL)                             (* Tell later code to use NEWLOOKS.)	       ))          (replace \DIRTY of TEXTOBJ with T)                 (* Mark the document changed.)          (\SHOWSEL TSEL NIL NIL)          (SETQ CH# (fetch CH# of TSEL))                     (* 1st ch# of the text to change)          (SETQ CHLIM (IMIN (fetch TEXTLEN of TEXTOBJ)			    (fetch CHLIM of TSEL)))          (* last ch to change)          (SETQ PC1 (\CHTOPC CH# PCTB))                      (* Piece the first ch is in)          (SETQ PCNO1 (\FINDPIECE PC1 PCTB))                 (* Piece # of first piece)          (COND	    ((IGREATERP CH# (\EDITELT PCTB PCNO1))           (* If CH# is not first ch in piece, split it.)	      (SETQ PC1 (\SPLITPIECE PC1 CH# TEXTOBJ PCNO1))                                                             (* Take 2nd half of the split, which starts with CH#.)	      (SETQ PCTB (fetch PCTB of TEXTOBJ))            (* NB: \SplitPiece may make a new PCTB, so copy it 							     here.)	      ))          (SETQ PCNON (\CHTOPCNO (ADD1 CHLIM)				 PCTB))                      (* Last piece)          (SETQ PCN (\EDITELT PCTB (ADD1 PCNON)))          (COND	    [(IEQP (ADD1 CHLIM)		   (\EDITELT PCTB PCNON))                    (* CHLIM+1 is the start of a new piece.							     just use prevpiece as pcn)	      (SETQ PCN (\EDITELT PCTB (SUB1 PCNON]	    (T                                               (* If the last char isn't the last char in the piece, 							     then split it and take the first half.)	       (\SPLITPIECE PCN (ADD1 CHLIM)			    TEXTOBJ PCNON)))          (bind ((PC _ PC1)		 NEWPCLOOKS)	     while (AND PC (NEQ PC PCN))	     do (SETQ OLDLOOKSLIST (NCONC1 OLDLOOKSLIST (fetch PLOOKS of PC)))                                                              (* Save old looks for the Undo.)		[replace PLOOKS of PC with (SETQ NEWPCLOOKS					     (OR NLOOKS (create CHARLOOKS							   using (fetch PLOOKS of PC)								 CLFONT _(\TEDIT.FONTCOPY								   (fetch CLFONT								      of (fetch PLOOKS of PC))								   NEWLOOKS]                                                             (* Give this piece its new looks)		(SELECTQ FACE			 (BOLD (replace CLBOLD of NEWPCLOOKS with T)			       (replace CLITAL of NEWPCLOOKS with NIL))			 (ITALIC (replace CLITAL of NEWPCLOOKS with T)				 (replace CLBOLD of NEWPCLOOKS with NIL))			 (BOLDITALIC (replace CLBOLD of NEWPCLOOKS					with (replace CLITAL of NEWPCLOOKS with T)))			 (STANDARD (replace CLBOLD of NEWPCLOOKS				      with (replace CLITAL of NEWPCLOOKS with NIL)))			 NIL)		[AND PROT (replace CLPROTECTED of NEWPCLOOKS with (EQ PROT (QUOTE ON]		[AND SELHERE (replace CLSELHERE of NEWPCLOOKS with (EQ SELHERE (QUOTE ON]		[AND ULINE (replace CLULINE of NEWPCLOOKS with (EQ ULINE (QUOTE ON]		[AND OLINE (replace CLOLINE of NEWPCLOOKS with (EQ OLINE (QUOTE ON]		[AND STRIKE (replace CLSTRIKE of NEWPCLOOKS with (EQ STRIKE (QUOTE ON]		(AND SUPER (replace CLSUPER of NEWPCLOOKS with SUPER))		(AND SUB (replace CLSUB of NEWPCLOOKS with SUB))		(AND SIZE (replace CLSIZE of NEWPCLOOKS with SIZE))		[COND		  ((EQ PC \INPC)		    (replace INSERTFONT of TEXTOBJ with (fetch CLFONT of (fetch PLOOKS of PC]		(SETQ PC (fetch NEXTPIECE of PC))	     finally (OR PC (RETURN))		     (SETQ OLDLOOKSLIST (NCONC1 OLDLOOKSLIST (fetch PLOOKS of PC)))		     [replace PLOOKS of PC			with (SETQ NEWPCLOOKS (OR NLOOKS (create CHARLOOKS							    using (fetch PLOOKS of PC)								  CLFONT _(\TEDIT.FONTCOPY								    (fetch CLFONT								       of (fetch PLOOKS of PC))								    NEWLOOKS]		     (SELECTQ FACE			      (BOLD (replace CLBOLD of NEWPCLOOKS with T)				    (replace CLITAL of NEWPCLOOKS with NIL))			      (ITALIC (replace CLITAL of NEWPCLOOKS with T)				      (replace CLBOLD of NEWPCLOOKS with NIL))			      (BOLDITALIC (replace CLBOLD of NEWPCLOOKS					     with (replace CLITAL of NEWPCLOOKS with T)))			      (STANDARD (replace CLBOLD of NEWPCLOOKS					   with (replace CLITAL of NEWPCLOOKS with NIL)))			      NIL)		     [AND PROT (replace CLPROTECTED of NEWPCLOOKS with (EQ PROT (QUOTE ON]		     [AND SELHERE (replace CLSELHERE of NEWPCLOOKS with (EQ SELHERE (QUOTE ON]		     [AND ULINE (replace CLULINE of NEWPCLOOKS with (EQ ULINE (QUOTE ON]		     [AND OLINE (replace CLOLINE of NEWPCLOOKS with (EQ OLINE (QUOTE ON]		     [AND STRIKE (replace CLSTRIKE of NEWPCLOOKS with (EQ STRIKE (QUOTE ON]		     [AND SUPER (replace CLSUPER of NEWPCLOOKS with (EQ SUPER (QUOTE ON]		     [AND SUB (replace CLSUB of NEWPCLOOKS with (EQ SUB (QUOTE ON]		     (AND SIZE (replace CLSIZE of NEWPCLOOKS with SIZE)))          (bind (LL _(fetch LINES of TEXTOBJ)) while LL	     do                                              (* Mark changed lines as DIRTY.)		(COND		  ((AND (ILEQ (fetch CHAR1 of LL)			      CHLIM)			(IGEQ (fetch CHARLIM of LL)			      CH#))		    (replace DIRTY of LL with T)))		(SETQ LL (fetch NEXTLINE of LL)))          (\TEDIT.HISTORYADD (create TEDITHISTORYEVENT				     THACTION _(QUOTE Looks)				     THLEN _(ADD1 (IDIFFERENCE CHLIM CH#))				     THCH# _ CH#				     THFIRSTPIECE _ PC1				     THOLDINFO _ OLDLOOKSLIST				     THAUXINFO _ NEWLOOKS				     THTEXTOBJ _ TEXTOBJ))   (* Save this action for undo/redo)          (SETQ CHANGEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))                                                             (* Update the screen image)          (AND CHANGEDLINE (\FILLWINDOW (fetch YBOT of CHANGEDLINE)					CHANGEDLINE TEXTOBJ THISLINE))          (replace \INSERTNEXTCH of TEXTOBJ with -1)          (\FIXSEL TSEL TEXTOBJ)          (\SHOWSEL TSEL NIL T])(TEDIT.MAKESEL  [LAMBDA (STREAM CH# LEN POINT)                             (* jds " 3-AUG-83 13:03")    (PROG ((SEL (fetch SEL of (fetch F3 of STREAM)))	   (TEXTOBJ (fetch F3 of STREAM)))          (\SHOWSEL SEL NIL NIL)          (replace CH# of SEL with CH#)          (replace CHLIM of SEL with (IMAX CH# (IPLUS CH# LEN -1)))          (replace DCH of SEL with LEN)          (replace POINT of SEL with (OR POINT (QUOTE LEFT)))          (replace \TEXTOBJ of SEL with TEXTOBJ)          (replace SET of SEL with T)          (AND (fetch \WINDOW of TEXTOBJ)	       (\FIXSEL SEL TEXTOBJ))          (\SHOWSEL SEL NIL T])(TEDIT.MODIFYLOOKS  [LAMBDA (LINE STARTX DS LOOKS)                             (* jds " 7-JAN-83 09:40")                                                             (* Modify the screen to allow for underlining, etc. 							     Also, restore the vertical offset to the baseline.)    (PROG ((CURX (DSPXPOSITION NIL DS))	   (CURY (DSPYPOSITION NIL DS)))          (COND	    ((fetch CLULINE of LOOKS)                        (* It's underlined.)	      (MOVETO STARTX (ADD1 (fetch YBOT of LINE))		      DS)	      (RELDRAWTO (IDIFFERENCE CURX STARTX)			 0 1 (QUOTE PAINT)			 DS)))          (COND	    ((fetch CLOLINE of LOOKS)	      (MOVETO STARTX (IPLUS CURY (FONTPROP (fetch CLFONT of LOOKS)						   (QUOTE HEIGHT)))		      DS)	      (RELDRAWTO (IDIFFERENCE CURX STARTX)			 0 1 (QUOTE PAINT)			 DS)))          (COND	    ((fetch CLSTRIKE of LOOKS)	      (MOVETO STARTX (LRSH (IPLUS CURY (FONTPROP (fetch CLFONT of LOOKS)							 (QUOTE HEIGHT)))				   1)		      DS)	      (RELDRAWTO (IDIFFERENCE CURX STARTX)			 0 1 (QUOTE PAINT)			 DS)))          (MOVETO CURX (fetch YBASE of LINE)		  DS])(TEDIT.MOVE  [LAMBDA (FROMSEL TOSEL THISLINE)                           (* jds "21-JUL-83 13:44")    (SETQ TEDIT.MOVE.PENDING NIL)                            (* First, Turn off the global flag that got us here.)    (COND      ((NOT (AND FROMSEL (fetch SET of FROMSEL)))            (* There MUST be a source selected first.)	(printout PROMPTWINDOW "Move source selection isn't set yet." T))      (T (PROG (EVENT (LEN (fetch DCH of FROMSEL))		      CH# SOURCECH# FIRSTPIECE)	       (\SHOWSEL TOSEL NIL NIL)	       (\SHOWSEL FROMSEL NIL NIL)	       (\TEDIT.DELETE FROMSEL (fetch \TEXTOBJ of FROMSEL)			      THISLINE NIL)	       (SETQ EVENT (CAR TEDIT.HISTORYLST))	       (SETQ SOURCECH# (fetch CH# of FROMSEL))       (* Place to put the text back to if the move is undone.)	       (SETQ CH# (SELECTQ (fetch POINT of TOSEL)				  (LEFT (fetch CH# of TOSEL))				  (RIGHT (ADD1 (fetch CHLIM of TOSEL)))				  NIL))	       (\SHOWSEL TOSEL NIL NIL)	       (\SHOWSEL FROMSEL NIL NIL)	       (replace THPOINT of (CAR TEDIT.HISTORYLST) with (QUOTE RIGHT))	       (TEDIT.UNDO.DELETION (fetch \TEXTOBJ of TOSEL)				    EVENT LEN CH# (fetch THFIRSTPIECE of EVENT))	       (replace THACTION of EVENT with (QUOTE Move))	       (replace THAUXINFO of EVENT with (fetch \TEXTOBJ of FROMSEL))	       (replace THOLDINFO of EVENT with SOURCECH#)	       (replace THTEXTOBJ of EVENT with (fetch \TEXTOBJ of TOSEL))	       (replace THCH# of EVENT with CH#)	       (\SHOWSEL TOSEL NIL T])(TEDIT.NEW.FONT  [LAMBDA NIL                                                (* jds " 3-AUG-83 11:37")    (PROG [(NAME (MKATOM (TEDIT.GETINPUT "Name of font:  "]          (AND NAME [SETQ TEDIT.KNOWN.FONTS (NCONC1 TEDIT.KNOWN.FONTS (LIST NAME (KWOTE (U-CASE											  NAME]	       (RETURN (U-CASE NAME])(TEDIT.PARAPPLY  [LAMBDA (ITEM MENU BUTTON)                                 (* jds "23-MAY-83 11:16")                                                             (* APPLY GIVEN PARA LOOKS TO CURRENT PARA.)    (PROG ((W (WFROMMENU MENU))	   MAIN D TEXTOBJ PC NPC)          (SETQ MAIN (WINDOWPROP W (QUOTE MAINW)))          [SETQ D (create FMTSPEC copying (WINDOWPROP MAIN (QUOTE DATUM]          (SETQ TEXTOBJ (fetch \TEXTOBJ of TEDIT.SELECTION))          (SETQ PC (\CHTOPC (fetch CHAR1 of (fetch L1 of (fetch SEL of TEXTOBJ)))			    (fetch PCTB of TEXTOBJ)))          (bind (NPC _ PC) while NPC	     do (replace PPARALOOKS of NPC with D)		(AND (fetch PPARALAST of NPC)		     (RETURN))		(SETQ NPC (fetch NEXTPIECE of NPC)))          (bind (NPC _(fetch PREVPIECE of PC)) while (AND NPC (NOT (fetch PPARALAST of NPC)))	     do (replace PPARALOOKS of NPC with D)		(SETQ NPC (fetch PREVPIECE of NPC])(TEDIT.PUT  [LAMBDA (TEXTOBJ FILE FORCENEW)                            (* jds " 8-AUG-83 16:31")                                                             (* If the guy was editing a file, make a new updated 							     version; else, ask for a file name)                                                             (* If FILE is specd, it's used;							     else the user must give us one)    (PROG (OCURSOR OFILE FONTFILEUSED (TEDIT.PUT.FINISHEDFORMS NIL)		   (TEDIT.GET.FINISHEDFORMS NIL))          [COND	    [FILE                                            (* We were given a file to use.)		  (SETQ OFILE (\GETOFD (OPENFILE FILE (QUOTE OUTPUT)						 (QUOTE NEW))				       (QUOTE OUTPUT]	    [FORCENEW                                        (* He insists on a new file. 							     (without giving us one NIL))		      (SETQ OFILE (TEDIT.GETINPUT "Name of the file to save this text in:  "))		      (COND			(OFILE (SETQ OFILE (\GETOFD (OPENFILE (MKATOM OFILE)							      (QUOTE OUTPUT)							      (QUOTE NEW))						    (QUOTE OUTPUT)))			       (SETQ OCURSOR (CURSOR WAITINGCURSOR]	    [(type? STREAM (fetch TXTFILE of TEXTOBJ))       (* There was a file!)	      [SETQ OFILE (UNPACKFILENAME (fetch FULLFILENAME (fetch TXTFILE of TEXTOBJ]	      (LISTPUT OFILE (QUOTE VERSION)		       NIL)	      (SETQ OFILE (TEDIT.GETINPUT "Name of the file to save this text in:  " (PACKFILENAME					    OFILE)))	      (SETQ OFILE (\GETOFD (OPENFILE (MKATOM OFILE)					     (QUOTE BOTH)					     (QUOTE NEW))				   (QUOTE BOTH]	    (T (SETQ OFILE (TEDIT.GETINPUT "Name of the file to save this text in:  "))                                                             (* Get a file to put the text into)	       (COND		 (OFILE (SETQ OFILE (\GETOFD (OPENFILE (MKATOM OFILE)						       (QUOTE OUTPUT)						       (QUOTE NEW))					     (QUOTE OUTPUT)))			(SETQ OCURSOR (CURSOR WAITINGCURSOR]          (OR OFILE (RETURN))                                (* If there's no file given, don't even try saving the 							     file)          (SETQ OCURSOR (CURSOR WAITINGCURSOR))          [COND	    ((IGREATERP (fetch TEXTLEN of TEXTOBJ)			0)	      (SETQ FONTFILEUSED (TEDIT.PUT.PCTB TEXTOBJ OFILE]          (for FORM in TEDIT.PUT.FINISHEDFORMS do (EVAL FORM))          (COND	    ((OPENP OFILE)                                   (* We wrote a file. Remember the filename for next 							     time.)	      (CLOSEF OFILE)                                 (* Close the file, to free it up.)	      [SETQ OFILE (\GETOFD (OPENFILE (fetch FULLNAME of OFILE)					     (QUOTE INPUT]   (* And re-open it for INPUT only)	      (COND		(FONTFILEUSED                                (* This file is formatted--build a compacted piece 							     table.)			      (replace PCTB of TEXTOBJ with (TEDIT.BUILD.PCTB OFILE TEXTOBJ))			      (for FORM in TEDIT.GET.FINISHEDFORMS do (EVAL FORM))                                                             (* Finish up any left-over tasks caused by the 							     pseudo-Get.)			      )		(T                                           (* Unformatted file--build a single-piece piece table.)		   (\CLEARPCTB (fetch PCTB of TEXTOBJ))		   (\INSERTPIECE (\CREATEPIECE OFILE)				 (QUOTE LASTPIECE)				 TEXTOBJ)))	      (CLOSEF? (fetch TXTFILE of TEXTOBJ))	      (replace TXTFILE of TEXTOBJ with OFILE)	      (replace \DIRTY of TEXTOBJ with NIL)))          (CURSOR OCURSOR)          (WINDOWPROP (fetch \WINDOW of TEXTOBJ)		      (QUOTE TITLE)		      (TEDIT.WINDOW.TITLE TEXTOBJ))          (replace \INSERTNEXTCH of TEXTOBJ with -1)          (\TEDIT.HISTORYADD (create TEDITHISTORYEVENT				     THACTION _(QUOTE Put)				     THCH# _ 0				     THLEN _ 0				     THFIRSTPIECE _ NIL))    (* Set up a history entry for this.)      ])(TEDIT.PUT.CHARLOOKS  [LAMBDA (FILE CH1 CHLIM LOOKS)                             (* jds "14-JAN-83 14:23")                                                             (* Put a description of LOOKS into FILE.							     LOOKS apply to characters CH1 thru CHLIM-1)    (PROG ((FONT (fetch CLFONT of LOOKS))	   STR)          (\DWOUT FILE (IDIFFERENCE CHLIM CH1))              (* The length of this run of looks)          (\WOUT FILE \PieceDescriptorLOOKS)                 (* Mark this as setting the piece's looks)          [\WOUT FILE (NCHARS (FONTPROP FONT (QUOTE FAMILY]                                                             (* The length of the description which follows)          (for CH inatom (FONTPROP FONT (QUOTE FAMILY)) do (\BOUT FILE CH))                                                             (* Print the form which can EVAL to re-create the font 							     information)          (\WOUT FILE (fetch CLSIZE of LOOKS))               (* Size of the type, in points)          (\WOUT FILE (OR (fetch CLSUPER of LOOKS)			  0))                                (* Superscripting distance)          (\WOUT FILE (OR (fetch CLSUB of LOOKS)			  0))                                (* Subscripting distance)          (\WOUT FILE 0)                                     (* Placeholder for the style designation)          (\WOUT FILE (LOGOR (COND			       ((fetch CLBOLD of LOOKS)				 512)			       (T 0))			     (COND			       ((fetch CLITAL of LOOKS)				 256)			       (T 0))			     (COND			       ((fetch CLULINE of LOOKS)				 128)			       (T 0))			     (COND			       ((fetch CLOLINE of LOOKS)				 64)			       (T 0))			     (COND			       ((fetch CLSTRIKE of LOOKS)				 32)			       (T 0))			     (COND			       ((fetch CLSMALLCAP of LOOKS)				 16)			       (T 0))			     (COND			       ((fetch CLPROTECTED of LOOKS)				 8)			       (T 0))			     (COND			       ((fetch CLINVISIBLE of LOOKS)				 NIL 4)			       (T 0))			     (COND			       ((fetch CLSELHERE of LOOKS)				 2)			       (T 0))			     (COND			       ((fetch CLCANCOPY of LOOKS)				 1)			       (T 0])(TEDIT.PUT.OBJECT  [LAMBDA (PIECE OFILE FONTFILE CURCH#)                      (* jds "17-AUG-83 18:02")                                                             (* Given a piece which describes an object, put the 							     object out there.)    (PROG ((OBJECT (fetch POBJ of PIECE))	   (FONTCH# (GETFILEPTR FONTFILE))	   LEN)          (\DWOUT FONTFILE 0)                                (* Placeholder for length of the object's description)          (\WOUT FONTFILE \PieceDescriptorOBJECT)            (* Mark this as setting the piece's looks)          (\ATMOUT FONTFILE (fetch GETFN of (fetch OBJREF of OBJECT)))                                                             (* The FN to apply to reconstruct the object)          (APPLY* (fetch PUTFN of (fetch OBJREF of OBJECT))		  OBJECT OFILE)          (SETFILEPTR FONTFILE FONTCH#)                      (* Now go back and fill in the length of the text 							     description of the object.)          [\DWOUT FONTFILE (SETQ LEN (ADD1 (IDIFFERENCE (GETEOFPTR OFILE)							CURCH#]          (SETFILEPTR FONTFILE -1)                           (* Make sure we're at the end of the font file)          (SETFILEPTR OFILE -1)                              (* And the text part of the file)          (RETURN LEN])(TEDIT.PUT.PARALOOKS  [LAMBDA (FILE PC)                                          (* jds "20-APR-83 14:16")                                                             (* Put a description of LOOKS into FILE.							     LOOKS apply to characters CH1 thru CHLIM-1)    (PROG ((LOOKS (fetch PPARALOOKS of PC)))          (\DWOUT FILE 0)                                    (* Place holder for number of characters in the piece --							     really taken from the charlooks.)          (\WOUT FILE \PieceDescriptorPARA)                  (* Identify this as a paragraph looks piece)          (\WOUT FILE (fetch 1STLEFTMAR of LOOKS))           (* Left margin for the first line of the paragraph)          (\WOUT FILE (fetch LEFTMAR of LOOKS))              (* Left margin for the rest of the paragraph)          (\WOUT FILE (fetch RIGHTMAR of LOOKS))             (* Right margin for the paragraph)          (\WOUT FILE (fetch LEADBEFORE of LOOKS))           (* Leading before the paragraph)          (\WOUT FILE (fetch LEADAFTER of LOOKS))            (* Lead after the paragraph)          (\WOUT FILE (fetch LINELEAD of LOOKS))             (* inter-line leading)          (replace TABSPEC of LOOKS with NIL)                (* Will be tab specs)          (\WOUT FILE (SELECTQ (fetch QUAD of LOOKS)			       (LEFT 1)			       (RIGHT 2)			       (CENTER 3)			       (JUST 4)			       (SHOULDNT])(TEDIT.PUT.PCTB  [LAMBDA (TEXTOBJ OFILE)                                    (* jds " 9-MAY-83 15:59")                                                             (* Put a representation of the piece table onto OFILE, 							     preserving font changes and paragraph looks)    (PROG (OCURSOR CH PC PFILE PSTR POBJ OFILELEN OLDLOOKS (OLDPARALOOKS (fetch FMTSPEC of TEXTOBJ))		   OLDCH# CURCH# PREVPC (FONTFILE NIL)		   (PCCOUNT 0)		   (TEDIT.PUT.FINISHEDFORMS NIL))          (SETQ PC (\EDITELT (fetch PCTB of TEXTOBJ)			     (ADD1 \FirstPieceOffset)))      (* First piece in the document)          (SETQ OLDLOOKS TEDIT.DEFAULT.CHARLOOKS)          [SETQ CURCH# (SETQ OLDCH# (ADD1 (GETFILEPTR OFILE]          [while PC	     do [COND		  ((fetch POBJ of PC)                        (* It's an object -- go use its PUTFN)		    [OR FONTFILE (SETQ FONTFILE (OPENFILE (QUOTE {CORE}TEDIT.LOOKSTEMP)							  (QUOTE BOTH)							  (QUOTE NEW]		    (COND		      (OLDLOOKS (TEDIT.PUT.CHARLOOKS FONTFILE OLDCH# CURCH# OLDLOOKS)				(add PCCOUNT 1)))            (* If the prior thing was text, send along its 							     descriptor.)		    (add CURCH# (TEDIT.PUT.OBJECT PC OFILE FONTFILE CURCH#))                                                             (* Send out the object)		    (SETQ OLDLOOKS NIL)                      (* Make sure we note ANY looks on the next characters)		    (add PCCOUNT 1)                          (* Mark the prior item an OBJECT.)		    )		  (T (COND		       ([OR (NOT (EQCLOOKS OLDLOOKS (fetch PLOOKS of PC)))			    (AND (OR (NOT PREVPC)				     (fetch PPARALAST of PREVPC))				 (NOT (EQUALALL (fetch PPARALOOKS of PC)						(fetch FMTSPEC of TEXTOBJ]                                                             (* We have a piece with new looks.)			 [OR FONTFILE (SETQ FONTFILE (OPENFILE (QUOTE {CORE}TEDIT.LOOKSTEMP)							       (QUOTE BOTH)							       (QUOTE NEW]			 [COND			   ((NOT (IEQP OLDCH# CURCH#))			     (COND			       (OLDLOOKS                     (* If there were looks past, and if the run was not 							     empty, save a piece for its looks)					 (TEDIT.PUT.CHARLOOKS FONTFILE OLDCH# CURCH# OLDLOOKS)					 (add PCCOUNT 1]			 (SETQ OLDLOOKS (fetch PLOOKS of PC))			 (SETQ OLDCH# CURCH#)))		     (COND		       ([AND (OR (NOT PREVPC)				 (fetch PPARALAST of PREVPC))			     (NOT (EQUALALL (fetch PPARALOOKS of PC)					    (fetch FMTSPEC of TEXTOBJ]                                                             (* The last piece ended a paragraph, so send out new 							     para looks)			 (TEDIT.PUT.PARALOOKS FONTFILE PC)))		     [COND		       [(SETQ PFILE (fetch PFILE of PC))			 (COPYBYTES PFILE OFILE (fetch PFPOS of PC)				    (IPLUS (fetch PFPOS of PC)					   (fetch PLEN of PC]		       ((SETQ PSTR (fetch PSTR of PC))			 (for I from 1 to (fetch PLEN of PC) as CH instring PSTR			    do (\BOUT OFILE CH]		     (add CURCH# (fetch PLEN of PC]		(SETQ PREVPC PC)		(SETQ PC (fetch NEXTPIECE of PC))	     finally                                         (* Put out a piece describing the last characters in the							     file.)		     (COND		       ((AND FONTFILE OLDLOOKS)              (* Only if there WERE characters, and only if there's a 							     need for font information)			 (TEDIT.PUT.CHARLOOKS FONTFILE OLDCH# CURCH# OLDLOOKS)			 (add PCCOUNT 1]          (for FORM in TEDIT.PUT.FINISHEDFORMS do (EVAL FORM))                                                             (* Do any user-specific cleanup)          (COND	    ((AND (OPENP OFILE)		  FONTFILE)                                  (* We need to write format info.)	      (SETQ OFILELEN (GETFILEPTR OFILE))	      (COPYBYTES FONTFILE OFILE 0 (GETEOFPTR FONTFILE))                                                             (* Copy the font information to the file trailer)	      (\DWOUT OFILE OFILELEN)	      (\WOUT OFILE PCCOUNT)                          (* # OF PIECES WE'' NEED TO RECONSTRUCT THIS FILE)	      (\WOUT OFILE 31415)                            (* Now the "password": 31415)	      (CLOSEF FONTFILE)	      (DELFILE FONTFILE)))          (RETURN FONTFILE])(TEDIT.PUT.PIECE.DESCRIPTOR  [LAMBDA (FILE CH1 CHLIM LOOKS)                             (* jds " 4-JAN-83 15:01")                                                             (* Put a description of LOOKS into FILE.							     LOOKS apply to characters CH1 thru CHLIM-1)    (PROG ((FONT (fetch CLFONT of LOOKS))	   STR)          (SETQ STR (CONCAT "(FONTCREATE " (KWOTE (FONTPROP FONT (QUOTE FAMILY)))			    " "			    (FONTPROP FONT (QUOTE SIZE))			    " "			    (KWOTE (FONTPROP FONT (QUOTE FACE)))			    " )"))          (\DWOUT FILE (IDIFFERENCE CHLIM CH1))              (* The length of this run of looks)          (\WOUT FILE (NCHARS STR))                          (* The length of the description which follows)          (PRIN1 STR FILE)                                   (* Print the form which can EVAL to re-create the font 							     information)          (\BOUT FILE (LOGOR (COND			       ((fetch CLPROTECTED of LOOKS)				 8)			       (T 0))			     (COND			       ((fetch CLINVISIBLE of LOOKS)				 NIL 4)			       (T 0))			     (COND			       ((fetch CLSELHERE of LOOKS)				 2)			       (T 0))			     (COND			       ((fetch CLCANCOPY of LOOKS)				 1)			       (T 0])(TEDIT.QUIT  [LAMBDA (STREAM VALUE)                                     (* jds " 2-AUG-83 15:15")                                                             (* Force the edit session supported by STREAM to 							     terminate, and to return VALUE)    (COND      ((type? STREAM STREAM)                                 (* If he gave us a textofd, get the textobj)	(SETQ STREAM (fetch F3 of STREAM)))      ((type? TEXTOBJ STREAM)                                (* A Textobj is just fine)	)      (T                                                     (* Anything else is ungood, double-plus)	 (\ILLEGAL.ARG STREAM)))    (replace EDITFINISHEDFLG of STREAM with (OR VALUE T))    (AND (fetch \WINDOW of STREAM)	 (NEQ (fetch \WINDOW of STREAM)	      (PROCESS.WINDOW (TTY.PROCESS)))	 (TTY.PROCESS (WINDOWPROP (fetch \WINDOW of STREAM)				  (QUOTE PROCESS])(TEDIT.REDO.REPLACE  [LAMBDA (TEXTOBJ EVENT)                                    (* jds "13-JUL-83 14:05")    (PROG ((OLDEVENT (fetch THOLDINFO of EVENT))	   (CH# (fetch CH# of (fetch SEL of TEXTOBJ)))	   (SEL (fetch SEL of TEXTOBJ)))          (\SHOWSEL SEL NIL NIL)          (\TEDIT.DELETE SEL TEXTOBJ (fetch THISLINE of TEXTOBJ))          (\SHOWSEL SEL NIL NIL)          (TEDIT.REDO.INSERTION TEXTOBJ EVENT CH#)          (replace THOLDINFO of EVENT with (SETQ OLDEVENT (CAR TEDIT.HISTORYLST)))          (replace THACTION of OLDEVENT with (QUOTE Replace))          (replace THACTION of EVENT with (QUOTE Replace))          (replace THCH# of EVENT with CH#)          (\TEDIT.HISTORYADD EVENT])(TEDIT.REPLACE  [LAMBDA (TEXTSTREAM)                                       (* jds "17-AUG-83 15:00")    (PROG [SEARCHSTRING REPLACESTRING SEARCH.LEN REPLACE.LEN DELTA.LEN TEXTOBJ SELECTED.REGION 			STARTCHAR# ENDCHAR# ABORTFLG CONFIRMFLG (REPLACEDFLG 0)			(YESLIST (QUOTE ("Y" "YES" "T" "Yes" "y"]          [COND	    ((NULL (SETQ SEARCHSTRING (TEDIT.GETINPUT "Search string:")))	      (HELP)	      (PROGN (PROMPTPRINT "Null string - Abort.")		     (RETURN]          (SETQ REPLACESTRING (OR (TEDIT.GETINPUT "Replace string:")				  ""))          (SETQ CONFIRMFLG (MEMBER (TEDIT.GETINPUT "Confirm before each replace?" "No"						   (CHARCODE (EOL SPACE ESCAPE LF TAB)))				   YESLIST))          (SETQ SEARCH.LEN (NCHARS SEARCHSTRING))          (SETQ REPLACE.LEN (NCHARS REPLACESTRING))          (SETQ DELTA.LEN (IDIFFERENCE REPLACE.LEN SEARCH.LEN))          (SETQ TEXTOBJ (fetch F3 of TEXTSTREAM))          (SETQ SELECTED.REGION (fetch SEL of TEXTOBJ))          (SETQ STARTCHAR# (fetch CH# of SELECTED.REGION))          (SETQ ENDCHAR# (IPLUS STARTCHAR# (IMINUS SEARCH.LEN)				(fetch DCH of SELECTED.REGION)))          [until (OR (GREATERP (SETQ STARTCHAR# (OR (TEDIT.FIND TEXTOBJ SEARCHSTRING STARTCHAR#)						    (ADD1 ENDCHAR#)))			       ENDCHAR#)		     ABORTFLG)	     do (PROG (PENDING.SELECTION CHOICE)		      (SETQ PENDING.SELECTION (TEDIT.SETSEL TEXTSTREAM STARTCHAR# SEARCH.LEN))		      [COND			(CONFIRMFLG (TEDIT.SHOWSEL TEXTSTREAM T PENDING.SELECTION)				    (COND				      ((MEMBER [SETQ CHOICE (TEDIT.GETINPUT 								     "OK to replace? ['Q' quits]"									    "Yes"									    (CHARCODE (EOL SPACE 											   ESCAPE LF 											   TAB]					       (QUOTE ("Q" "q")))					(SETQ ABORTFLG T)					(GO L1))				      ((NOT (MEMBER CHOICE YESLIST))					(TEDIT.SHOWSEL TEXTSTREAM NIL PENDING.SELECTION)					(GO L1]		      (TEDIT.DELETE TEXTSTREAM PENDING.SELECTION)		      [COND			((NOT (EQUAL REPLACESTRING ""))			  (PROGN (TEDIT.INSERT TEXTSTREAM REPLACESTRING STARTCHAR#)				 (SETQ ENDCHAR# (IPLUS ENDCHAR# DELTA.LEN]		      (add REPLACEDFLG 1)		  L1  (SETQ STARTCHAR# (IPLUS STARTCHAR# REPLACE.LEN]          [COND	    ((ZEROP REPLACEDFLG)	      (PROMPTPRINT "No replacement."))	    (T (PROMPTPRINT (CONCAT (MKSTRING REPLACEDFLG)				    " Replacements made."]          (RETURN REPLACEDFLG])(TEDIT.SCAN.LINE  [LAMBDA (TEXTOBJ LINE THISLINE X Y WORDSELFLG SELOPERATION)                                                             (* jds "17-AUG-83 14:53")                                                             (* Given a line, find the character which straddles the 							     mouse.)    (DECLARE (LOCALVARS . T))    (PROG ((L NIL)	   (WLIST (fetch WIDTHS of THISLINE))	   (CHLIST (fetch CHARS of THISLINE))	   (LLIST (fetch LOOKS of THISLINE))	   (LOOKNO 1)	   (DX 0)	   OTX YBOT YBASE TX (CH (CHARCODE SPACE))	   PREVCH TXB (CHB 0)	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   CLOOKS PCLOOKS)          (COND	    ((NEQ (fetch DESC of THISLINE)		  LINE)                                      (* If the cache doesn't describe this line, call 							     \FORMATLINE so it will.)	      (\FORMATLINE TEXTOBJ NIL (fetch CHAR1 of LINE)			   THISLINE LINE)))          [SETQ OTX (SETQ TXB (SETQ TX (fetch LEFTMARGIN of LINE]          (SETQ CHB (SUB1 (fetch CHAR1 of LINE)))          (SETQ CLOOKS (\EDITELT LLIST 0))          (for I from 0 to (fetch LEN of THISLINE) as CHNO from (SUB1 (fetch CHAR1 of LINE))	     do (SETQ PREVCH CH)		(SETQ PCLOOKS CLOOKS)		(SETQ CH (\EDITELT CHLIST I))		[COND		  ((EQ CH 400)                               (* Change of CharLooks -- make the switch)		    (SETQ CLOOKS (\EDITELT LLIST LOOKNO))    (* New looks)		    (add LOOKNO 1)                           (* Move to next CLook for next transition)		    (add I 1)                                (* Don't count this toward the CHNO counter.)		    (SETQ CH (\EDITELT CHLIST I]		[COND		  ((AND (ILESSP X TX)			(OR (EQ SELOPERATION (QUOTE COPY))			    (fetch CLSELHERE of PCLOOKS)			    (NOT (fetch CLPROTECTED of PCLOOKS)))			(OR (NOT WORDSELFLG)			    (NOT (SMALLP PREVCH))			    (\TEDIT.WORD.BOUND PREVCH CH)))          (* If we're beyond the mouse's X, and the character is selectable, and we're in char select or this is a word 	  boundary then SELECT!!!)		    (SETQ L (fetch SCRATCHSEL of TEXTOBJ))		    (COND		      ((SMALLP PREVCH)			(replace SELOBJ of L with NIL))		      (T (SETQ WORDSELFLG NIL)			 (replace SELOBJ of L with PREVCH)			 (APPLY* (fetch SELFN of PREVCH)				 PREVCH				 (IDIFFERENCE X TXB)				 (IDIFFERENCE Y (fetch YBOT of LINE))				 L)))		    (replace SET of L with T)		    (replace Y0 of L with (fetch YBOT of LINE))		    (replace X0 of L with (COND					    ((fetch CLSELHERE of PCLOOKS)                                                             (* If CLSelHere, then select to RIGHT always.)					      TX)					    (WORDSELFLG TXB)					    (T OTX)))		    (replace DX of L with (COND					    ((fetch CLSELHERE of PCLOOKS)					      0)					    (WORDSELFLG (IDIFFERENCE TX TXB))					    (T DX)))		    [replace CH# of L with (IMAX 1 (COND						   ((fetch CLSELHERE of PCLOOKS)						     CHNO)						   (WORDSELFLG (ADD1 CHB))						   (T CHNO]		    (replace XLIM of L with (COND					      ((fetch CLSELHERE of PCLOOKS)						TX)					      (WORDSELFLG TX)					      (T TX)))		    (replace CHLIM of L with (COND					       ((fetch CLSELHERE of PCLOOKS)						 CHNO)					       (WORDSELFLG CHNO)					       (T CHNO)))		    (replace YLIM of L with (fetch YBOT of LINE))		    (replace L1 of L with LINE)		    (replace LN of L with LINE)		    [replace POINT of L with (COND					       ((fetch CLSELHERE of PCLOOKS)						 (QUOTE RIGHT))					       [WORDSELFLG (COND							     ((AND (NEQ PREVCH (CHARCODE CR))								   (IGEQ X (LRSH (IPLUS TX TXB)										 1)))							       (QUOTE RIGHT))							     (T (QUOTE LEFT]					       (T (COND						    ((AND (IGEQ DX 5)							  (NEQ PREVCH (CHARCODE CR))							  (IGEQ X (LRSH (IPLUS TX OTX)									1)))						      (QUOTE RIGHT))						    (T (QUOTE LEFT]		    (replace DCH of L with (COND					     ((fetch CLSELHERE of PCLOOKS)					       0)					     (WORDSELFLG (IDIFFERENCE CHNO CHB))					     (T 1)))		    (RETURN))		  (T                                         (* We're not past the mouse yet;							     just track the last word boundary 							     (or protected-text boundary) for word selection.)		     (COND		       ((OR (AND (NOT (fetch CLPROTECTED of CLOOKS))				 (\TEDIT.WORD.BOUND PREVCH CH))			    (NEQ (fetch CLPROTECTED of PCLOOKS)				 (fetch CLPROTECTED of CLOOKS))			    (fetch CLSELHERE of PCLOOKS))			 (SETQ TXB TX)			 (SETQ CHB CHNO]		(SETQ OTX TX)		(SETQ DX (\WORDELT WLIST I))		(SETQ TX (IPLUS TX DX)))          (COND	    ((AND (NOT L)		  (IGEQ (fetch LEN of THISLINE)			0)		  (fetch CLPROTECTED of CLOOKS))             (* He's pointing to the right of the line, but there's 							     protected text at the end. Select a point at the last 							     legal spot.)	      (SETQ L (fetch SCRATCHSEL of TEXTOBJ))	      (replace SET of L with T)	      (replace Y0 of L with (fetch YBOT of LINE))	      (replace X0 of L with TXB)	      (replace DX of L with 0)	      (replace CH# of L with (IMAX 1 (ADD1 CHB)))	      (replace XLIM of L with TXB)	      (replace CHLIM of L with (IMAX 1 (ADD1 CHB)))	      (replace YLIM of L with (fetch YBOT of LINE))	      (replace L1 of L with LINE)	      (replace LN of L with LINE)	      (replace POINT of L with (QUOTE LEFT))	      (replace DCH of L with 0)	      (replace SELOBJ of L with NIL)))          [COND	    [L                                               (* If we found the place he's pointing, set up the 							     inter-pointers so each can find the other)	       (replace \TEXTOBJ of L with TEXTOBJ)	       (replace SELKIND of L with (COND					    (WORDSELFLG (QUOTE WORD))					    (T (QUOTE CHAR]	    (T                                               (* We didn't find what he was pointing at.							     Point to the end of the line.)	       (SETQ L (fetch SCRATCHSEL of TEXTOBJ))	       (replace SET of L with T)	       (COND		 ((SMALLP CH)		   (replace SELOBJ of L with NIL))		 (T (SETQ WORDSELFLG NIL)		    (replace SELOBJ of L with CH)))	       (replace Y0 of L with (fetch YBOT of LINE))	       [replace X0 of L with (COND				       (WORDSELFLG TXB)				       (T (IDIFFERENCE TX DX]	       (replace XLIM of L with TX)	       (replace DX of L with (COND				       (WORDSELFLG (IDIFFERENCE TX TXB))				       (T DX)))	       [replace CH# of L with (COND					(WORDSELFLG (ADD1 CHB))					(T (IMIN (fetch CHARLIM of LINE)						 TEXTLEN]	       (replace YLIM of L with (fetch YBOT of LINE))	       (replace CHLIM of L with (IMIN (fetch CHARLIM of LINE)					      TEXTLEN))	       [replace POINT of L with (COND					  [(OR WORDSELFLG (NEQ CH (CHARCODE CR)))                                                             (* You can select only to the left of a CR;							     elsewhere, you can select to the right)					    (COND					      ((IGEQ X (LRSH (IPLUS TX TXB)							     1))						(QUOTE RIGHT))					      (T (QUOTE LEFT]					  (T (QUOTE LEFT]	       (replace L1 of L with LINE)	       (replace LN of L with LINE)	       (replace DCH of L with (COND					(WORDSELFLG (IDIFFERENCE (IMIN (fetch CHARLIM of LINE)								       TEXTLEN)								 CHB))					(T 1)))	       (replace \TEXTOBJ of L with TEXTOBJ)	       (replace SELKIND of L with (COND					    (WORDSELFLG (QUOTE WORD))					    (T (QUOTE CHAR]          (RETURN L])(TEDIT.SCANSEL  [LAMBDA (STREAM)                                           (* jds "15-SEP-82 11:14")                                                             (* Set up to read the selected text;							     return the sel's length or NIL if nothing selected.)    (PROG ((TEXTOBJ (fetch F3 of STREAM))	   SEL)          (SETQ SEL (fetch SEL of TEXTOBJ))          (COND	    ((fetch SET of SEL)	      (\SETUPGETCH (fetch CH# of SEL)			   TEXTOBJ)	      (RETURN (fetch DCH of SEL)))	    (T (RETURN NIL])(TEDIT.SEEPARA  [LAMBDA (STREAM)                                           (* jds "13-JUL-83 15:36")    (PROG ([INSPW (INSPECT (create FMTSPEC copying (fetch LFMTSPEC						      of (fetch L1							    of (fetch SEL								  of (fetch F3 of STREAM]	   INSPWREG TMENU MENUW)          (SETQ INSPWREG (WINDOWPROP INSPW (QUOTE REGION)))          (SETQ TMENU (create MENU			      ITEMS _(QUOTE (Apply))			      CENTERFLG _ T			      ITEMWIDTH _(IDIFFERENCE (fetch WIDTH of INSPWREG)						      4)			      WHENSELECTEDFN _(QUOTE TEDIT.PARAPPLY)))          [SETQ MENUW (ADDMENU TMENU NIL (create POSITION						 XCOORD _(fetch LEFT of INSPWREG)						 YCOORD _(fetch TOP of INSPWREG]          (WINDOWPROP MENUW (QUOTE MAINW)		      INSPW)          (WINDOWPROP INSPW (QUOTE TEXTOBJ)		      (fetch F3 of STREAM])(TEDIT.SEL.AS.STRING  [LAMBDA (STREAM SEL)                                       (* jds "29-APR-83 17:38")                                                             (* Given a text stream, go to the TEXTOBJ, get the 							     current selection, and return it as a string.)    [COND      ((type? TEXTOBJ STREAM)                                (* We actually got a textobj.							     fix it.)	(SETQ STREAM (fetch STREAMHINT of STREAM]    (PROG ((TEXTOBJ (fetch F3 of STREAM))	   LEN TSEL RESULT OFFST BASE)          (SETQ TSEL (OR SEL (fetch SEL of TEXTOBJ)))          (SETQ LEN (fetch DCH of TSEL))          (COND	    ((OR (ZEROP LEN)		 (NOT (fetch SET of TSEL)))                  (* There is no selection, or it's zero-width.							     Return "")	      (RETURN ""))	    (T (SETQ RESULT (ALLOCSTRING LEN (CHARCODE SPACE)))                                                             (* The resulting string)	       (SETQ OFFST (fetch (STRINGP OFFST) of RESULT))	       (SETQ BASE (\ADDBASE (fetch (STRINGP BASE) of RESULT)				    OFFST))	       (\SETUPGETCH (fetch CH# of TSEL)			    TEXTOBJ)                         (* Starting point for the string is start of selection.)	       (for I from 0 to (SUB1 LEN)		  do                                         (* Get chars from the stream, and put them in the 							     string.)		     (\PUTBASEBYTE BASE I (\GETCH TEXTOBJ)))	       (RETURN RESULT])(TEDIT.SELECT  [LAMBDA (X Y TEXTOBJ THISLINE REGION WORDSELFLG SELOPERATION)                                                             (* jds " 4-AUG-83 09:35")                                                             (* Select the character word, line, or paragraph the 							     mouse is pointing at.)    (DECLARE (LOCALVARS . T))    (PROG ((L NIL)	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   PREVLINE)          (SETQ L (TEDIT.SELECT.LINE.SCANNER X Y TEXTOBJ (fetch LINES of TEXTOBJ)					     REGION WORDSELFLG SELOPERATION))          (COND	    ((type? SELECTION L)                             (* He pointed at something real;							     return that.)	      (TEDIT.SET.SEL.LOOKS L SELOPERATION)	      (RETURN L))	    ((type? LINEDESCRIPTOR L)                        (* He pointed below the bottom of the text.							     Select to the right of the last character on the 							     screen.)	      (SETQ PREVLINE L)	      (SETQ L (fetch SCRATCHSEL of TEXTOBJ))	      (replace SET of L with T)	      (replace \TEXTOBJ of L with TEXTOBJ)	      [replace CH# of L with (IMAX 1 (IMIN TEXTLEN (fetch CHARLIM of PREVLINE]	      (replace CHLIM of L with (fetch CH# of L))	      (replace DCH of L with 0)	      [replace POINT of L with (COND					 ((IGREATERP (fetch CH# of L)						     (fetch TEXTLEN of TEXTOBJ))                                                             (* Can't select to the right of a character past EOF, 							     only to the left -- which is the right edge of the 							     text.)					   (QUOTE LEFT))					 (T (QUOTE RIGHT]	      (TEDIT.SET.SEL.LOOKS L SELOPERATION)	      (\FIXSEL L TEXTOBJ)	      (RETURN L))	    (T                                               (* Nothing selected, nothing gained.							     Return nothing.)	       (RETURN L])(TEDIT.SELECT.LINE.SCANNER  [LAMBDA (X Y TEXTOBJ LINE.LIST REGION WORDSELFLG SELOPERATION)                                                             (* jds "21-JUL-83 13:46")                                                             (* Select the character word, line, or paragraph the 							     mouse is pointing at.)    (DECLARE (LOCALVARS . T))    (PROG ((L NIL)	   (WWIDTH (fetch WRIGHT of TEXTOBJ))	   (THISLINE (fetch THISLINE of TEXTOBJ))	   (DS (fetch DS of TEXTOBJ))	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   PREVLINE)          [bind (LINE _ LINE.LIST) while (AND LINE (IGREATERP (fetch YBOT of LINE)							      (fetch WBOTTOM of TEXTOBJ)))	     do (          (* Search thru the list of displayed lines, looking for the first one whose bottom is below the mouse.	  That's the line we're pointing at.)		 (COND		   ((ILEQ (fetch YBOT of LINE)			  Y)                                 (* Found it.)		     (SELECTQ REGION			      (TEXT                          (* We're in the regular text area, so scan accross 							     looking for the character.)				    (SETQ L (TEDIT.SCAN.LINE TEXTOBJ LINE THISLINE X Y WORDSELFLG 							     SELOPERATION)))			      [LINE                          (* He is selecting an entire line, or a paragraph.)				    (COND				      ((AND (OR (fetch MENUFLG of TEXTOBJ)						(fetch LHASPROT of LINE))					    (NEQ SELOPERATION (QUOTE COPY)))                                                             (* In a TEDIT menu, you can't select a whole paragraph 							     or line.)					(RETURN NIL)))				    (SETQ L (fetch SCRATCHSEL of TEXTOBJ))                                                             (* The scratch selection)				    (replace \TEXTOBJ of L with TEXTOBJ)                                                             (* Make sure he knows what document the selection's in.)				    (replace SET of L with T)                                                             (* Mark it valid.)				    (replace SELOBJ of L with NIL)                                                             (* Not selecting an object just yet)				    (COND				      [WORDSELFLG            (* Select a paragraph.)						  (replace SELKIND of L with (QUOTE PARA))                                                             (* SEARCH FORWARD FROM THE CURRENT LINE TO A LIE WITH A 							     CR OR CHARLIM=EOTEXT)						  (bind (LL _ LINE)						     while (AND (NOT (fetch CR\END of LL))								(ILESSP (fetch CHARLIM of LL)									TEXTLEN))						     do [COND							  ((fetch NEXTLINE of LL)							    (SETQ LL (fetch NEXTLINE of LL)))							  (T (replace NEXTLINE of LL								with (\FORMATLINE								       TEXTOBJ NIL								       (ADD1 (fetch CHARLIM										of LL))								       THISLINE))							     (replace PREVLINE								of (fetch NEXTLINE of LL)								with LL)							     (SETQ LL (fetch NEXTLINE of LL]						     finally (replace LN of L with LL))                                                             (* SEARCH BACK TO A LINE WITH A CR OR BOTEXT)						  [bind (LL _(fetch PREVLINE of LINE))						     while (AND (IGEQ (fetch CHAR1 of LL)								      1)								(NOT (fetch CR\END of LL)))						     do (SETQ LL (fetch PREVLINE of LL))						     finally (replace L1 of L								with (COND								       ((IGEQ (fetch CHAR1										 of LL)									      1)									 (fetch NEXTLINE									    of LL))								       (T (\BACKFORMAT LINE.LIST 										       TEXTOBJ 										       THISLINE)									  (fetch NEXTLINE									     of LINE.LIST]						  (replace CH# of L						     with (fetch CHAR1 of (fetch L1 of L)))						  (replace CHLIM of L						     with (fetch CHARLIM							     of (fetch LN of L)))						  (replace Y0 of L						     with (fetch YBOT of (fetch L1 of L)))						  (replace YLIM of L						     with (fetch YBOT of (fetch LN of L)))						  (replace X0 of L						     with (fetch LEFTMARGIN							     of (fetch L1 of L)))						  (replace XLIM of L						     with (fetch LXLIM of (fetch LN of L)))						  (replace POINT of L with (QUOTE LEFT))						  [replace DCH of L						     with (ADD1 (IDIFFERENCE (fetch CHLIM										of L)									     (fetch CH# of L]						  (replace DX of L						     with (IPLUS 1 (IDIFFERENCE (fetch XLIM										   of L)										(fetch X0										   of L]				      (T                     (* Select the line we're pointing at.)					 (replace SELKIND of L with (QUOTE LINE))					 (replace L1 of L with (replace LN of L with LINE))					 (replace CH# of L with (fetch CHAR1 of LINE))					 (replace CHLIM of L with (fetch CHARLIM of LINE))					 (replace DX of L with (IDIFFERENCE (fetch LXLIM									       of LINE)									    (fetch LEFTMARGIN									       of LINE)))					 (replace X0 of L with (fetch LEFTMARGIN of LINE))					 (replace XLIM of L with (fetch LXLIM of LINE))					 (replace Y0 of L with (replace YLIM of L								  with (fetch YBOT of LINE)))					 [replace DCH of L					    with (ADD1 (IDIFFERENCE (fetch CHLIM of L)								    (fetch CH# of L]					 (replace POINT of L with (QUOTE LEFT))					 (replace SET of L with T]			      (SHOULDNT "Unknown text/line-bar region?"))		     (RETURN)))		 (SETQ PREVLINE LINE)		 (SETQ LINE (fetch NEXTLINE of LINE]          (RETURN (OR L PREVLINE])(TEDIT.SET.SEL.LOOKS  [LAMBDA (SEL OPERATION)                                    (* edited: "14-MAR-83 18:39")                                                             (* Set what the selection should be displayed like, 							     given what it's for (NORMAL, COPY, MOVE, etc.))    (SELECTQ OPERATION	     (NORMAL                                         (* Regular selection)		     (replace HOW of SEL with BLACKSHADE)		     (replace HOWHEIGHT of SEL with 1)		     (replace HASCARET of SEL with T))	     (COPY                                           (* Copy source)		   (replace HOW of SEL with COPYSELSHADE)		   (replace HOWHEIGHT of SEL with 1)		   (replace HASCARET of SEL with NIL))	     (MOVE                                           (* Copy source)		   (replace HOW of SEL with EDITMOVESHADE)		   (replace HOWHEIGHT of SEL with 16384)		   (replace HASCARET of SEL with NIL))	     (DELETE                                         (* To be deleted instantly)		     (replace HOW of SEL with BLACKSHADE)		     (replace HOWHEIGHT of SEL with 16384)		     (replace HASCARET of SEL with NIL)		     NIL)	     (PENDINGDEL                                     (* Delete at next type-in)			 (replace HOW of SEL with BLACKSHADE)			 (replace HOWHEIGHT of SEL with 16384)			 (replace HASCARET of SEL with T)			 NIL)	     NIL])(TEDIT.SETSEL  [LAMBDA (STREAM CH# LEN POINT)                             (* jds " 3-AUG-83 13:03")                                                             (* Given a text stream or textobj, and a piece of text 							     to select, set the internal selection, and return it.)    (COND      ((type? TEXTOBJ STREAM)                                (* He gave us a TEXTOBJ, so run it back to the stream 							     below.)	(SETQ STREAM (fetch STREAMHINT of STREAM)))      ((type? STREAM STREAM)                                 (* OK, it's a stream)	)      (T                                                     (* Not a stream or a TEXTOBJ, so complain)	 (\ILLEGAL.ARG STREAM)))    (PROG ((SEL (fetch SEL of (fetch F3 of STREAM)))	   (TEXTOBJ (fetch F3 of STREAM)))          (\SHOWSEL SEL NIL NIL)          (COND	    ((type? SELECTION CH#)                           (* He gave use a selection; just plug it in)	      (\COPYSEL CH# SEL)	      (replace ONFLG of SEL with NIL)                (* And make sure it can be turned on.)	      )	    (T                                               (* He fed us numbers; use them)	       (replace CH# of SEL with CH#)                 (* Starting character)	       (replace CHLIM of SEL with (IMAX CH# (IPLUS CH# LEN -1)))                                                             (* Last selected character)	       (replace DCH of SEL with LEN)	       (replace POINT of SEL with (OR POINT (QUOTE LEFT)))                                                             (* Which side the caret should go on)	       ))          (replace \TEXTOBJ of SEL with TEXTOBJ)             (* Link it back to the associated textobj)          (replace SET of SEL with T)                        (* Mark the selection as valid for others to use)          (AND (fetch \WINDOW of TEXTOBJ)	       (\FIXSEL SEL TEXTOBJ))                        (* Update the selection's screen location)          (\SHOWSEL SEL NIL T)                               (* Highlight it on the screen)          (RETURN SEL])(TEDIT.SHOWSEL  [LAMBDA (STREAM ONFLG SEL)                                 (* jds " 3-AUG-83 13:03")    (PROG ((TEXTOBJ (fetch F3 of STREAM)))          (COND	    (SEL                                             (* He's giving us a selection to highlight.							     Connect it to this textobj.)		 (replace \TEXTOBJ of SEL with TEXTOBJ)		 (\FIXSEL SEL TEXTOBJ)))          (\SHOWSEL (OR SEL (fetch SEL of TEXTOBJ))		    NIL ONFLG])(TEDIT.STRINGWIDTH  [LAMBDA (STR FONT TERMSA)                                  (* jds "25-MAY-83 18:28")    (COND      (TERMSA                                                (* We have a terminal talbe to take account of.							     Do so.)	      (for CH instring STR sum (TEDIT.CHARWIDTH CH FONT TERMSA)))      (T                                                     (* Just use the native character widths)	 (for CH instring STR sum (SELCHARQ CH					    (TAB 36)					    (CHARWIDTH CH FONT])(TEDIT.UNDO.REPLACE  [LAMBDA (TEXTOBJ EVENT LEN CH# FIRSTPIECE)                 (* jds " 3-AUG-83 13:03")    (PROG ((OLDEVENT (fetch THOLDINFO of EVENT))	   (CH# (fetch THCH# of EVENT))	   (SEL (fetch SEL of TEXTOBJ)))          (\SHOWSEL SEL NIL NIL)          (TEDIT.UNDO.INSERTION TEXTOBJ EVENT LEN CH# FIRSTPIECE)          (\SHOWSEL SEL NIL NIL)          (TEDIT.UNDO.DELETION TEXTOBJ OLDEVENT (fetch THLEN of OLDEVENT)			       CH#			       (fetch THFIRSTPIECE of OLDEVENT))          (replace THOLDINFO of OLDEVENT with EVENT)          (replace THACTION of OLDEVENT with (QUOTE Replace))          (replace THOLDINFO of EVENT with NIL)          (\TEDIT.HISTORYADD OLDEVENT)          (replace CH# of SEL with CH#)          (replace CHLIM of SEL with (IPLUS CH# (fetch THLEN of OLDEVENT)					    -1))          (replace DCH of SEL with (fetch THLEN of OLDEVENT))          (replace POINT of SEL with (fetch THPOINT of EVENT))          (replace THPOINT of OLDEVENT with (fetch THPOINT of EVENT))          (\FIXSEL SEL TEXTOBJ)          (\SHOWSEL SEL NIL T])(TEDIT.\INSERT  [LAMBDA (CH SEL STREAM BLANKSEEN CRSEEN SKIPINSERT)        (* jds "21-JUL-83 13:47")                                                             (* Insert the character CH at the appropriate spot in 							     the text.)    (DECLARE (LOCALVARS . T))    (PROG [(TEXTOBJ (COND		      ((type? STREAM STREAM)                 (* If we got a STREAM, change it into a textobj)			(fetch F3 of STREAM))		      (T STREAM]          (COND	    ((NOT (AND SEL (fetch SET of SEL)))	      (printout PROMPTWINDOW "Please select a place for the insertion." T)	      (RETURN)))          (COND	    ((fetch \WINDOW of TEXTOBJ)                      (* There is a window; make sure the insert point is 							     on-screen, and turn off any highlighted selection)	      (TEDIT.NORMALIZECARET TEXTOBJ SEL)	      (\SHOWSEL SEL NIL NIL)))          (PROG [(CH# (IMAX 1 (SELECTQ (fetch POINT of SEL)				       (LEFT (fetch CH# of SEL))				       (RIGHT (ADD1 (fetch CHLIM of SEL)))				       NIL)))		 (LINE (SELECTQ (fetch POINT of SEL)				(LEFT (fetch L1 of SEL))				(RIGHT (fetch LN of SEL))				NIL))		 (XPOINT (SELECTQ (fetch POINT of SEL)				  (LEFT (fetch X0 of SEL))				  (RIGHT (fetch XLIM of SEL))				  NIL))		 (OTEXTLEN (fetch TEXTLEN of TEXTOBJ))		 (DS (fetch DS of TEXTOBJ))		 (CHARS (COND			  ((type? STRINGP CH)			    (NCHARS CH))			  (T 1]	        [OR SKIPINSERT (COND		      ((AND CRSEEN (fetch FORMATTEDP of TEXTOBJ))                                                             (* This was a CR. Go do the para breaking as needed)			(\INSERTCR CH CH# TEXTOBJ))		      (T                                     (* No para breaks. Just insert the character)			 (\INSERTCH CH CH# TEXTOBJ]	        (\FIXILINES (OR (fetch PREVLINE of LINE)				(fetch LINES of TEXTOBJ))			    SEL CH# CHARS OTEXTLEN)	        (TEDIT.INSERT.UPDATESCREEN CH CH# CHARS XPOINT TEXTOBJ SEL LINE OTEXTLEN BLANKSEEN 					   CRSEEN DS])(\ATMIN  [LAMBDA (STREAM)                                           (* jds " 3-FEB-83 14:35")    (PROG ((LEN (\WIN STREAM)))          (RETURN (COND		    ((ZEROP LEN)		      NIL)		    (T (PACK (for I from 1 to LEN collect (CHARACTER (\BIN STREAM])(\ATMOUT  [LAMBDA (STREAM ATOM)                                      (* jds " 3-FEB-83 14:34")                                                             (* Write an atom's characters in length-contents form.)    (\WOUT STREAM (NCHARS ATOM))    (OR (ZEROP (NCHARS ATOM))	(for CH inatom ATOM do (\BOUT STREAM CH])(\COPYSEL  [LAMBDA (FROM TO)                                          (* jds " 7-FEB-83 13:37")                                                             (* Copy a SELECTION record from FROM to TO, without 							     creating any new ones)    (replace Y0 of TO with (fetch Y0 of FROM))    (replace X0 of TO with (fetch X0 of FROM))    (replace DX of TO with (fetch DX of FROM))    (replace CH# of TO with (fetch CH# of FROM))    (replace XLIM of TO with (fetch XLIM of FROM))    (replace CHLIM of TO with (fetch CHLIM of FROM))    (replace DCH of TO with (fetch DCH of FROM))    (replace L1 of TO with (fetch L1 of FROM))    (replace LN of TO with (fetch LN of FROM))    (replace YLIM of TO with (fetch YLIM of FROM))    (replace POINT of TO with (fetch POINT of FROM))    (replace SET of TO with (fetch SET of FROM))    (replace \TEXTOBJ of TO with (fetch \TEXTOBJ of FROM))    (replace SELKIND of TO with (fetch SELKIND of FROM))    (replace HOW of TO with (fetch HOW of FROM))    (replace HOWHEIGHT of TO with (fetch HOWHEIGHT of FROM))    (replace HASCARET of TO with (fetch HASCARET of FROM))    (replace SELOBJ of TO with (fetch SELOBJ of FROM))    (replace ONFLG of TO with (fetch ONFLG of FROM])(\DOFORMATTING  [LAMBDA (TEXTOBJ LINE FMTSPEC THISLINE #BLANKS PREVSP 1STLN)                                                             (* jds "22-APR-83 11:36")                                                             (* Do the formatting work for justified, centered, etc. 							     lines)    (PROG ((QUAD (fetch QUAD of FMTSPEC))	   (SPACELEFT (LLSH (fetch SPACELEFT of LINE)			    5))	   (CHLIST (fetch CHARS of THISLINE))	   (WLIST (fetch WIDTHS of THISLINE))	   (SPACEOFLOW 0)	   EXTRASP OPREVSP)          [COND	    ((fetch LINELEAD of FMTSPEC)                     (* If line leading was specified, set it)	      (add (fetch LHEIGHT of LINE)		   (fetch LINELEAD of FMTSPEC))	      (add (fetch ASCENT of LINE)		   (fetch LINELEAD of FMTSPEC]          [COND	    ((AND 1STLN (fetch LEADBEFORE of FMTSPEC))       (* If line leading was specified, set it)	      (add (fetch LHEIGHT of LINE)		   (fetch LEADBEFORE of FMTSPEC))	      (add (fetch ASCENT of LINE)		   (fetch LEADBEFORE of FMTSPEC]          (COND	    ((OR (ZEROP (fetch LEN of THISLINE))		 (ZEROP #BLANKS)		 (ZEROP PREVSP))                             (* For empty lines, and lines with no spaces, don't 							     bother fixing blank widths.)	      (RETURN)))          (SELECTQ QUAD		   [LEFT                                     (* Do nothing for left-justified lines except replace 							     the character codes)			 (while (IGREATERP PREVSP 0)			    do (SETQ OPREVSP (SUB1 PREVSP))			       (SETQ PREVSP (\EDITELT CHLIST OPREVSP))			       (\EDITSETA CHLIST OPREVSP (CONSTANT (CHARCODE SPACE]		   [RIGHT                                    (* Just move the right margin over)			  (replace LEFTMARGIN of LINE with (IPLUS (fetch LEFTMARGIN of LINE)								  (fetch SPACELEFT of LINE)))			  (replace LXLIM of LINE with (fetch RIGHTMARGIN of LINE))			  (while (IGREATERP PREVSP 0)			     do                              (* And fix the character codes)				(SETQ OPREVSP (SUB1 PREVSP))				(SETQ PREVSP (\EDITELT CHLIST OPREVSP))				(\EDITSETA CHLIST OPREVSP (CONSTANT (CHARCODE SPACE]		   [CENTER                                   (* Split the difference for centering)			   (add (fetch LEFTMARGIN of LINE)				(LRSH SPACELEFT 6))			   (add (fetch LXLIM of LINE)				(LRSH SPACELEFT 6))			   (while (IGREATERP PREVSP 0)			      do (SETQ OPREVSP (SUB1 PREVSP))				 (SETQ PREVSP (\EDITELT CHLIST OPREVSP))				 (\EDITSETA CHLIST OPREVSP (CONSTANT (CHARCODE SPACE]		   [JUST                                     (* For justified lines, stretch each space so line 							     reaches the right margin)			 (COND			   ((OR (fetch CR\END of LINE)				(IGEQ (fetch CHARLIM of LINE)				      (fetch TEXTLEN of TEXTOBJ)))                                                             (* This is the last line in the paragraph;							     don't stretch it out.)			     (SETQ EXTRASP 0))			   (T (bind (OPREVSP _ PREVSP) while (ILEQ OPREVSP (IPLUS PREVSP 2))				 do                          (* Back up over all trailing white space on the line.)				    (SETQ OPREVSP (SUB1 PREVSP))				    (SETQ PREVSP (\EDITELT CHLIST OPREVSP))				    (\EDITSETA CHLIST OPREVSP (CONSTANT (CHARCODE SPACE)))				    (add #BLANKS -1)				    %%%%)			      (AND (ZEROP #BLANKS)				   (RETURN))                 (* If there aren't any blanks except at end-of-line, 							     don't bother going further.)			      (replace LXLIM of LINE with (fetch RIGHTMARGIN of LINE))                                                             (* Fix the right margin for showing selections &c)			      (SETQ EXTRASP (IQUOTIENT SPACELEFT #BLANKS))                                                             (* Now apportion the extra space evenly among blanks.)			      ))			 (while (IGREATERP PREVSP 0)			    do                               (* Fix up the widths of spaces in the line)			       (SETQ OPREVSP (SUB1 PREVSP))			       (SETQ PREVSP (\EDITELT CHLIST OPREVSP))			       (\EDITSETA CHLIST OPREVSP (CONSTANT (CHARCODE SPACE)))			       [OR (fetch CR\END of LINE)				   (\WORDSETA WLIST OPREVSP (IPLUS (LRSH (IPLUS EXTRASP SPACEOFLOW)									 5)								   (\WORDELT WLIST OPREVSP]			       (SETQ SPACEOFLOW (LOGAND 31 (IPLUS EXTRASP SPACEOFLOW]		   NIL])(\DWIN  [LAMBDA (FILE)                                             (* jds " 3-JAN-83 16:08")    (IPLUS (LLSH (\BIN FILE)		 24)	   (LLSH (\BIN FILE)		 16)	   (LLSH (\BIN FILE)		 8)	   (\BIN FILE])(\DWOUT  [LAMBDA (FILE NUMBER)                                      (* jds " 3-JAN-83 15:30")    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 24)))    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 16)))    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 8)))    (\BOUT FILE (LOGAND 255 NUMBER])(\TEDIT.BUTTONEVENTFN  [LAMBDA (W STREAM)                                         (* jds "17-AUG-83 13:36")                                                             (* Handle button events inside a BX-style editing 							     window.)    [COND      ((type? STREAM STREAM)                                 (* Get the TEXTOBJ from it.)	(SETQ STREAM (fetch F3 of STREAM]    (PROG ((OSEL NIL)	   (SEL NIL)	   [TEXTOBJ (OR STREAM (WINDOWPROP W (QUOTE TEXTOBJ]	   (DS (WINDOWPROP W (QUOTE DSP)))	   USERFN	   (GLOBALSEL TEDIT.SELECTION)	   (X (LASTMOUSEX W))	   (Y (LASTMOUSEY W))	   [CLIPREGION (DSPCLIPPINGREGION NIL (WINDOWPROP W (QUOTE DSP]	   (SELOPERATION (QUOTE NORMAL))	   (SELFN (WINDOWPROP W (QUOTE TEDIT.CMD.SELFN)))	   (EXTENDFLG NIL)	   THISLINE)          (COND	    [[OR (NOT TEXTOBJ)		 (fetch EDITFINISHEDFLG of TEXTOBJ)		 (AND (fetch TXTREADONLY of TEXTOBJ)		      (NOT (KEYDOWNP (QUOTE LSHIFT)))		      (NOT (KEYDOWNP (QUOTE RSHIFT]          (* It's not inside the window's REAL region, so call on 							     a menu.)	      (TOTOPW W)	      (COND		((\TEDIT.MOUSESTATE RIGHT)		  (DOWINDOWCOM W]	    [(NOT (INSIDE? CLIPREGION X Y))                  (* It's not inside the window's REAL region, so call on 							     a menu.)	      (TOTOPW W)	      (COND		((\TEDIT.MOUSESTATE RIGHT)		  (DOWINDOWCOM W))		(TEXTOBJ (AND (SETQ USERFN (WINDOWPROP W (QUOTE TEDIT.TITLEMENUFN)))			      (COND				([AND (SETQ PROC (WINDOWPROP W (QUOTE PROCESS]                                                             (* This window has a live process behind it;							     go evaluate the button fn there.)				  (PROCESS.APPLY PROC USERFN (LIST W)))				(T (ADD.PROCESS (LIST USERFN (KWOTE W]	    (TEXTOBJ                                         (* Usual case -- he's really selecting something.)		     (SETQ THISLINE (fetch THISLINE of TEXTOBJ))		     (SETQ TEDIT.SELPENDING T)               (* Tell all instances of TEDIT not to run -- we're doing							     a selection.)		     (OR (fetch UP of (fetch CARET of TEXTOBJ))			 (\EDIT.FLIPCARET (fetch CARET of TEXTOBJ)					  T))                (* Make sure the caret isn't being displayed.)		     (replace CURSORBM of (fetch CARET of TEXTOBJ) with BXHICARET)                                                             (* Then make the caret be the special, tall one so he 							     can see it.)		     (COND		       [(OR (fetch TXTREADONLY of TEXTOBJ)			    (KEYDOWNP (QUOTE LSHIFT))			    (KEYDOWNP (QUOTE RSHIFT)))       (* the SHIFT key is down; mark this selection for COPY 							     or MOVE.)			 (COND			   ((AND (KEYDOWNP (QUOTE CTRL))				 (NOT (fetch TXTREADONLY of TEXTOBJ)))                                                             (* CTRL-SHIFT select means MOVE.)			     (SETQ GLOBALSEL TEDIT.MOVESELECTION)			     (SETQ OSEL (fetch MOVESEL of TEXTOBJ))			     (SETQ SELOPERATION (QUOTE MOVE)))			   (T (SETQ GLOBALSEL TEDIT.SHIFTEDSELECTION)			      (SETQ OSEL (fetch SHIFTEDSEL of TEXTOBJ))			      (SETQ SELOPERATION (QUOTE COPY]		       ((KEYDOWNP (QUOTE CTRL))              (* He's holding the control key down;							     note the fact.)			 (SETQ GLOBALSEL TEDIT.DELETESELECTION)			 (SETQ OSEL (fetch DELETESEL of TEXTOBJ))			 (SETQ SELOPERATION (QUOTE DELETE))			 (SETQ TEDIT.BLUEPENDINGDELETE NIL))		       (T (SETQ OSEL (fetch SEL of TEXTOBJ))			  (SETQ TEDIT.BLUEPENDINGDELETE NIL)                                                             (* Reset the pending-delete flag.)			  ))		     (\COPYSEL OSEL GLOBALSEL)		     (bind (OSELOP _ SELOPERATION) while [NOT (AND (ZEROP (LOGAND LASTKEYBOARD 104))								   (ZEROP (LOGAND LASTMOUSEBUTTONS 7]			do                                   (* Poll the selection & display its current state)			   [OR (ZEROP (LOGAND LASTMOUSEBUTTONS 7))			       (COND				 ((fetch TXTREADONLY of TEXTOBJ)				   (SETQ SELOPERATION (QUOTE COPY)))				 [(OR (KEYDOWNP (QUOTE LSHIFT))				      (KEYDOWNP (QUOTE RSHIFT)))                                                             (* the SHIFT key is down; mark this selection for COPY 							     or MOVE.)				   (COND				     ((KEYDOWNP (QUOTE CTRL))				       (SETQ SELOPERATION (QUOTE MOVE)))				     (T (SETQ SELOPERATION (QUOTE COPY]				 ((KEYDOWNP (QUOTE CTRL))    (* He's holding the control key down;							     note the fact.)				   (SETQ SELOPERATION (QUOTE DELETE)))				 (T                          (* No key being held down; revert to normal selection.)				    (SETQ SELOPERATION (QUOTE NORMAL]			   [COND			     ((IN/SCROLL/BAR? W LASTMOUSEX LASTMOUSEY)                                                             (* If he moves to the scroll bar, let him scroll without							     trouble)			       (SCROLL.HANDLER W))			     ((INSIDEP CLIPREGION (SETQ X (LASTMOUSEX DS))				       (SETQ Y (LASTMOUSEY DS)))                                                             (* Only do selection if the mouse is inside the window 							     proper)			       (COND				 ((\TEDIT.MOUSESTATE LEFT)   (* Left button is character selection)				   (SETQ SEL (TEDIT.SELECT X Y TEXTOBJ THISLINE							   (fetch MOUSEREGION of TEXTOBJ)							   NIL SELOPERATION))				   (SETQ EXTENDFLG NIL))				 ((\TEDIT.MOUSESTATE MIDDLE)                                                             (* Middle button is word selection)				   (SETQ SEL (TEDIT.SELECT X Y TEXTOBJ THISLINE							   (fetch MOUSEREGION of TEXTOBJ)							   T SELOPERATION))				   (SETQ EXTENDFLG NIL))				 [(\TEDIT.MOUSESTATE RIGHT)                                                             (* RIght button extends selections)				   (COND				     ((fetch SET of GLOBALSEL)				       (AND TEditBluePendingDelete (EQ SELOPERATION (QUOTE NORMAL))					    (SETQ SELOPERATION (QUOTE PENDINGDEL))					    (SETQ TEDIT.BLUEPENDINGDELETE T))                                                             (* If TeditBluePendingDelete flag is set, then simulate 							     Laurel's blue-pending-delete feature.)				       (SETQ SEL (TEDIT.EXTEND.SEL X Y GLOBALSEL THISLINE TEXTOBJ 								   SELOPERATION))				       (SETQ EXTENDFLG T]				 (T                          (* The mouse buttons are up, leaving us with a pro-tem 							     "permanent" selection)				    (\COPYSEL OSEL GLOBALSEL)))			       (COND				 ([AND SEL (NOT (AND (fetch SET of OSEL)						     (EQUAL (fetch CH# of SEL)							    (fetch CH# of OSEL))						     (EQUAL (fetch CHLIM of SEL)							    (fetch CHLIM of OSEL))						     (EQ (fetch \TEXTOBJ of SEL)							 (fetch \TEXTOBJ of OSEL))						     (EQ (fetch POINT of SEL)							 (fetch POINT of OSEL))						     (EQ (fetch HOW of SEL)							 (fetch HOW of OSEL))						     (EQ (fetch HOWHEIGHT of SEL)							 (fetch HOWHEIGHT of OSEL))						     (EQ OSELOP SELOPERATION]				   (COND				     ((AND EXTENDFLG (EQ OSELOP SELOPERATION))				       (\TEDIT.UPDATE.SHOWSEL SEL OSEL)				       (\COPYSEL SEL OSEL)				       (replace ONFLG of OSEL with T))				     (T (\SHOWSEL OSEL NIL NIL)					(COND					  ((NEQ OSELOP SELOPERATION)                                                             (* He changed his mind about copying, deleting, or 							     whatever -- change the kind of selection it is.)					    (SELECTQ SELOPERATION						     (NORMAL (SETQ GLOBALSEL TEDIT.SELECTION)							     (SETQ OSEL (fetch SEL of TEXTOBJ)))						     (COPY (SETQ GLOBALSEL TEDIT.SHIFTEDSELECTION)							   (SETQ OSEL (fetch SHIFTEDSEL of TEXTOBJ)))						     (MOVE (SETQ GLOBALSEL TEDIT.MOVESELECTION)							   (SETQ OSEL (fetch MOVESEL of TEXTOBJ)))						     (DELETE (SETQ GLOBALSEL TEDIT.DELETESELECTION)							     (SETQ OSEL (fetch DELETESEL									   of TEXTOBJ)))						     NIL)					    (SETQ OSELOP SELOPERATION)                                                             (* Remember the new operation type.)					    ))					(\COPYSEL SEL OSEL)					(replace ONFLG of OSEL with NIL)					(\SHOWSEL OSEL NIL T]			   (BLOCK)			   (GETMOUSESTATE)			   (TEDIT.CURSORMOVEDFN W))		     (\COPYSEL OSEL GLOBALSEL)		     (SELECTQ SELOPERATION			      (COPY (SETQ TEDIT.COPY.PENDING T)				    (replace SET of OSEL with NIL)				    (\TEDIT.FOREIGN.COPY? GLOBALSEL)                                                             (* Maybe copy into the SYSBUF, if the recipient isn't a 							     TEdit window.)				    )			      (MOVE (SETQ TEDIT.MOVE.PENDING T)				    (replace SET of OSEL with NIL))			      (DELETE (SETQ TEDIT.DEL.PENDING T)				      (replace SET of OSEL with NIL))			      NIL)		     (AND SELFN (APPLY* SELFN TEXTOBJ GLOBALSEL SELOPERATION))                                                             (* Give a user exit routine control, perhaps for logging							     of selections.)		     (SETQ TEDIT.SELPENDING NIL)             (* Tell all TEDITs that we're done selecting.)		     (OR (fetch UP of (fetch CARET of TEXTOBJ))			 (\EDIT.FLIPCARET (fetch CARET of TEXTOBJ)					  T))		     (replace CURSORBM of (fetch CARET of TEXTOBJ) with BXCARET)		     (AND OSEL (fetch SET of OSEL)			  (fetch SELOBJ of OSEL)			  (APPLY* (fetch SELFINALFN of (fetch OBJREF of (fetch SELOBJ of OSEL)))				  (fetch SELOBJ of OSEL)				  OSEL W])(\TEDIT.GET.INSERT.CHARLOOKS  [LAMBDA (PIECE)                                            (* jds "22-APR-83 12:54")                                                             (* Given a default source of charlooks, set us up some 							     good ones. IN particular, reset CLPROTECTED if need be.)    (COND      [PIECE                                                 (* There IS a piece to take looks from)	     (COND	       ((fetch CLPROTECTED of (fetch PLOOKS of PIECE))                                                             (* His looks are protected; we have to copy to a new 							     CHARLOOKS.)		 (create CHARLOOKS using (fetch PLOOKS of PIECE)					 CLPROTECTED _ NIL CLSELHERE _ NIL))	       (T                                            (* No protection, just reuse his looks)		  (fetch PLOOKS of PIECE]      (T (CHARLOOKS.FROM.FONT TEDIT.DEFAULT.FONT])(\TEDIT.HCPYFMTSPEC  [LAMBDA (SPEC)                                             (* jds "20-APR-83 15:31")    (create FMTSPEC	    1STLEFTMAR _(ITIMES (fetch 1STLEFTMAR of SPEC)				35)	    LEFTMAR _(ITIMES (fetch LEFTMAR of SPEC)			     35)	    RIGHTMAR _(ITIMES (fetch RIGHTMAR of SPEC)			      35)	    LEADBEFORE _(ITIMES (fetch LEADBEFORE of SPEC)				35)	    LEADAFTER _(ITIMES (fetch LEADAFTER of SPEC)			       35)	    LINELEAD _(ITIMES (fetch LINELEAD of SPEC)			      35)	    QUAD _(fetch QUAD of SPEC])(\TEDIT.INTERRUPT.SETUP  [LAMBDA (WINDOW FORCEOFF)                                  (* jds " 3-AUG-83 11:23")                                                             (* Disarm any inconvenient interrupts, and save 							     re-arming info on the window.)    [COND      ((NOT WINDOW))      ((AND FORCEOFF (WINDOWPROP WINDOW (QUOTE TEDIT.INTERRUPTS)))                                                             (* There are disarmed interrupts;							     re-arm them.)	(for INTSPEC in (WINDOWPROP WINDOW (QUOTE TEDIT.INTERRUPTS)) do (INTERRUPTCHAR (CAR INTSPEC)										       (CADR INTSPEC))	     )	(WINDOWPROP WINDOW (QUOTE TEDIT.INTERRUPTS)		    NIL))      ([AND (NOT FORCEOFF)	    (NOT (WINDOWPROP WINDOW (QUOTE TEDIT.INTERRUPTS]                                                             (* There aren't any interrupts disarmed;							     go do it.)	(WINDOWPROP WINDOW (QUOTE TEDIT.INTERRUPTS)		    (for INT in (QUOTE (5 127)) collect (INTERRUPTCHAR INT NIL]    WINDOW])(\TEDIT.LOOKS  [LAMBDA (TEXTOBJ THISLINE)                                 (* jds " 4-AUG-83 09:56")    (PROG ((SEL (fetch SEL of TEXTOBJ))	   (PCTB (fetch PCTB of TEXTOBJ))	   PC1 PCNO1 PCNON PCN (FONT NIL)	   (FACE NIL)	   (SIZE NIL)	   NEWLOOKS DY (\INPC (fetch \INSERTPC of TEXTOBJ))	   [POS (create POSITION			XCOORD _(fetch LEFT of (WINDOWPROP (fetch \WINDOW of TEXTOBJ)							   (QUOTE REGION)))			YCOORD _(fetch TOP of (WINDOWPROP (fetch \WINDOW of TEXTOBJ)							  (QUOTE REGION]	   CH# CHLIM CHANGEDLINE (OLDLOOKSLIST NIL))          (COND	    [(fetch SET of SEL)                              (* He's got something selected.)	      (SETQ FONT (MENU (create MENU				       TITLE _ "Font:"				       ITEMS _[NCONC1 (COPY TEDIT.KNOWN.FONTS)						      (QUOTE (Other (TEDIT.NEW.FONT]				       CENTERFLG _ T)			       POS))                         (* Set the font for the new text.)	      (SETQ FACE (SELECTQ (MENU TEDIT.FACE.MENU POS)				  (Bold (QUOTE BOLD))				  (Italic (QUOTE ITALIC))				  (Bold% Italic (QUOTE BOLDITALIC))				  (Regular (QUOTE STANDARD))				  NIL))                      (* Set the face (bold, etc.))	      (SETQ SIZE (MENU TEDIT.SIZE.MENU POS))         (* Set the type size)                                                             (* Construct the set of new looks to apply:)	      (COND		(FONT (SETQ NEWLOOKS (LIST (QUOTE FAMILY)					   FONT)))		(T (SETQ NEWLOOKS NIL)))                     (* The font)	      [COND		(FACE (SETQ NEWLOOKS (CONS (QUOTE FACE)					   (CONS FACE NEWLOOKS]                                                             (* The face)	      [COND		(SIZE (SETQ NEWLOOKS (CONS (QUOTE SIZE)					   (CONS SIZE NEWLOOKS]                                                             (* The size)	      (COND		(NEWLOOKS                                    (* If there is a change to be made:)			  (replace \DIRTY of TEXTOBJ with T)                                                             (* Mark the document changed.)			  (\SHOWSEL SEL NIL NIL)			  (SETQ CH# (fetch CH# of SEL))      (* 1st ch# of the text to change)			  (SETQ CHLIM (fetch CHLIM of SEL))                                                             (* last ch to change)			  (SETQ PC1 (\CHTOPC CH# PCTB))      (* Piece the first ch is in)			  (SETQ PCNO1 (\FINDPIECE PC1 PCTB))                                                             (* Piece # of first piece)			  (COND			    ((IGREATERP CH# (\EDITELT PCTB PCNO1))                                                             (* If CH# is not first ch in piece, split it.)			      (SETQ PC1 (\SPLITPIECE PC1 CH# TEXTOBJ PCNO1))                                                             (* Take 2nd half of the split, which starts with CH#.)			      (SETQ PCTB (fetch PCTB of TEXTOBJ))                                                             (* NB: \SplitPiece may make a new PCTB, so copy it 							     here.)			      ))			  (SETQ PCNON (\CHTOPCNO (ADD1 CHLIM)						 PCTB))      (* Last piece)			  (SETQ PCN (\EDITELT PCTB (ADD1 PCNON)))			  (COND			    [(IEQP (ADD1 CHLIM)				   (\EDITELT PCTB PCNON))    (* CHLIM+1 is the start of a new piece.							     just use prevpiece as pcn)			      (SETQ PCN (\EDITELT PCTB (SUB1 PCNON]			    (T                               (* If the last char isn't the last char in the piece, 							     then split it and take the first half.)			       (\SPLITPIECE PCN (ADD1 CHLIM)					    TEXTOBJ PCNON)))			  (bind ((PC _ PC1)				 NEWPCLOOKS)			     while (NEQ PC PCN)			     do (SETQ OLDLOOKSLIST (NCONC1 OLDLOOKSLIST (fetch PLOOKS of PC)))                                                              (* Save old looks for the Undo.)				[replace PLOOKS of PC				   with (SETQ NEWPCLOOKS (create CHARLOOKS							    using (fetch PLOOKS of PC)								  CLFONT _(\TEDIT.FONTCOPY								    (fetch CLFONT								       of (fetch PLOOKS of PC))								    NEWLOOKS]                                                             (* Give this piece its new looks)				(SELECTQ FACE					 (BOLD (replace CLBOLD of NEWPCLOOKS with T)					       (replace CLITAL of NEWPCLOOKS with NIL))					 (ITALIC (replace CLITAL of NEWPCLOOKS with T)						 (replace CLBOLD of NEWPCLOOKS with NIL))					 (BOLDITALIC (replace CLBOLD of NEWPCLOOKS							with (replace CLITAL of NEWPCLOOKS								with T)))					 (STANDARD (replace CLBOLD of NEWPCLOOKS						      with (replace CLITAL of NEWPCLOOKS							      with NIL)))					 NIL)				(AND SIZE (replace CLSIZE of NEWPCLOOKS with SIZE))				[COND				  ((EQ PC \INPC)				    (replace INSERTFONT of TEXTOBJ				       with (fetch CLFONT of (fetch PLOOKS of PC]				(SETQ PC (fetch NEXTPIECE of PC))			     finally (SETQ OLDLOOKSLIST (NCONC1 OLDLOOKSLIST (fetch PLOOKS										of PC)))				     [replace PLOOKS of PC					with (SETQ NEWPCLOOKS					       (create CHARLOOKS						  using (fetch PLOOKS of PC)							CLFONT _(\TEDIT.FONTCOPY (fetch CLFONT										    of (fetch PLOOKS											  of PC))										 NEWLOOKS]				     (SELECTQ FACE					      (BOLD (replace CLBOLD of NEWPCLOOKS with T)						    (replace CLITAL of NEWPCLOOKS with NIL))					      (ITALIC (replace CLITAL of NEWPCLOOKS with T)						      (replace CLBOLD of NEWPCLOOKS with NIL))					      (BOLDITALIC (replace CLBOLD of NEWPCLOOKS							     with (replace CLITAL of NEWPCLOOKS								     with T)))					      (STANDARD (replace CLBOLD of NEWPCLOOKS							   with (replace CLITAL of NEWPCLOOKS								   with NIL)))					      NIL)				     (AND SIZE (replace CLSIZE of NEWPCLOOKS with SIZE)))			  (bind (LL _(fetch LINES of TEXTOBJ)) while LL			     do (COND				  ((AND (ILEQ (fetch CHAR1 of LL)					      CHLIM)					(IGEQ (fetch CHARLIM of LL)					      CH#))				    (replace DIRTY of LL with T)))				(SETQ LL (fetch NEXTLINE of LL)))			  (\TEDIT.HISTORYADD (create TEDITHISTORYEVENT						     THACTION _(QUOTE Looks)						     THLEN _(ADD1 (IDIFFERENCE CHLIM CH#))						     THCH# _ CH#						     THFIRSTPIECE _ PC1						     THOLDINFO _ OLDLOOKSLIST						     THAUXINFO _ NEWLOOKS						     THTEXTOBJ _ TEXTOBJ))                                                             (* Save this action for undo/redo)			  (SETQ CHANGEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))			  (AND CHANGEDLINE (\FILLWINDOW (fetch YBOT of CHANGEDLINE)							CHANGEDLINE TEXTOBJ THISLINE))			  (replace \INSERTNEXTCH of TEXTOBJ with -1)			  (TEDIT.SET.SEL.LOOKS SEL (QUOTE NORMAL))                                                             (* Restore the selection to normalcy)			  (SETQ TEDIT.PENDINGDEL NIL)        (* And turn off any pending deletion.)			  (\FIXSEL SEL TEXTOBJ)			  (\SHOWSEL SEL NIL T]	    (T (CLRPROMPT)	       (printout PROMPTWINDOW "Please select some text to modify first" T])(\TEDIT.LOOKS.UPDATE  [LAMBDA (STREAM PC)                                        (* jds "29-APR-83 16:26")                                                             (* At a piece boundary, update the line formatting 							     fields ASCENT, DESCENT, and FONTWIDTHS)    (PROG [(TLOOKS (fetch PLOOKS of PC))	   (FONT (fetch CLFONT of (fetch PLOOKS of PC]          (COND	    ((NOT (EQCLOOKS TLOOKS TEDIT.CURRENT.CHARLOOKS))	      [SETQ ASCENT (MAX ASCENT (FONTPROP FONT (QUOTE ASCENT]	      [SETQ DESCENT (MAX DESCENT (FONTPROP FONT (QUOTE DESCENT]	      (SETQ FONTWIDTHS (fetch \SFWidths of FONT))	      (add LOOKNO 1)                                 (* Fix the counter of charlooks changes)	      (\EDITSETA LOOKS LOOKNO TLOOKS)                (* Save the new looks for selection/display)	      (\EDITSETA CHLIST TLEN 400)                    (* Put a marker in the character list to denote a looks 							     change)	      (\WORDSETA WLIST TLEN 0)                       (* Font changes have no width)	      (add TLEN 1)                                   (* Account for the dummy marker/looks in TLEN)	      (AND (fetch CLPROTECTED of TLOOKS)		   (replace LHASPROT of LINE with T))        (* If this line contains protected text, mark the 							     linedescriptor accordingly)	      ])(\FIXDLINES  [LAMBDA (LINES SEL CH#1 CH#LIM TEXTOBJ)                    (* jds "21-JUL-83 13:48")                                                             (* Fix up the list LINES of line descriptors, given that							     characters CH#1 thru CH#LIM were deleted.)                                                             (* Change CHAR1 and CHARLIM entries in each descriptor, 							     and remove any descriptors for lines which disappeared 							     entirely.)    (PROG ((NLINES LINES)	   (DCH (ADD1 (IDIFFERENCE CH#LIM CH#1)))	   (CH#1L (SUB1 CH#1))	   PL NL CHARLIM)          (bind (LINE _(fetch NEXTLINE of LINES))		CHARLIM CHAR1 while LINE	     do (SETQ CHARLIM (fetch CHARLIM of LINE))		(SETQ CHAR1 (fetch CHAR1 of LINE))		(COND		  [(ILESSP CHARLIM CH#1)		    (COND		      ((AND (IGEQ CH#1 CHAR1)			    (ILEQ CH#1 (fetch CHARTOP of LINE)))                                                             (* This change happened in a place where it may affect 							     this line's break decision. Better reformat to be safe.)			(replace DIRTY of LINE with T))		      ((AND (fetch CR\END of LINE)			    (IEQP CHARLIM CH#1L))            (* This line ends in CR, and the deletion starts 							     immediately thereafter. Best to reformat, for safety.)			(replace DIRTY of LINE with T]		  ((IGREATERP CHAR1 CH#LIM)		    (replace CHAR1 of LINE with (IMAX 1 (IDIFFERENCE CHAR1 DCH)))		    (replace CHARLIM of LINE with (IDIFFERENCE CHARLIM DCH))		    (replace CHARTOP of LINE with (IDIFFERENCE (fetch CHARTOP of LINE)							       DCH)))		  [(OR (ILESSP CHAR1 CH#1)		       (IGREATERP CHARLIM CH#LIM))		    (replace DIRTY of LINE with T)		    (replace CHAR1 of LINE with (IMAX 1 (IMIN CHAR1 CH#1)))		    (COND		      [(IGREATERP CHARLIM CH#LIM)			(replace CHARLIM of LINE with (IDIFFERENCE CHARLIM								   (IMIN DCH (ADD1 (IDIFFERENCE										     CH#LIM CHAR1]		      (T (replace CHARLIM of LINE with CH#1L]		  (T (SETQ NL (fetch NEXTLINE of LINE))		     (SETQ PL (fetch PREVLINE of LINE))		     (COND		       (PL (replace NEXTLINE of PL with NL)))		     (COND		       (NL (replace PREVLINE of NL with PL)))		     (COND		       ((EQ NLINES LINE)			 (SETQ NLINES NL)))		     (replace DELETED of LINE with T)        (* Mark this line deleted, so DELETETEXTCHARS know to 							     ignore it.)		     ))		(SETQ LINE (fetch NEXTLINE of LINE)))          (\TEDIT.FIXDELSEL (fetch SEL of TEXTOBJ)			    TEXTOBJ CH#1 CH#LIM DCH)         (* Fix up the selections in this textobj)          (\TEDIT.FIXDELSEL (fetch SHIFTEDSEL of TEXTOBJ)			    TEXTOBJ CH#1 CH#LIM DCH)          (\TEDIT.FIXDELSEL (fetch MOVESEL of TEXTOBJ)			    TEXTOBJ CH#1 CH#LIM DCH)          (\TEDIT.FIXDELSEL (fetch DELETESEL of TEXTOBJ)			    TEXTOBJ CH#1 CH#LIM DCH)          (RETURN NLINES])(\FIXILINES  [LAMBDA (LINES SEL CH#1 DCH OTEXTLEN)                      (* jds "25-JUL-83 14:57")                                                             (* Fix the list LINES of line descriptors to account for							     DCH characters inserted before CH#1)    (SETQ CH#1 (IMAX CH#1 1))    [AND LINES (bind [LINE _(COND			     ((IGEQ (fetch CHARTOP of LINES)				    0)                       (* Make sure to skip the initial dummy line)			       LINES)			     (T (fetch NEXTLINE of LINES]		  while LINE		  do (COND		       ((IGREATERP (fetch CHAR1 of LINE)				   CH#1)                     (* This line starts after the insertion point.							     Update it's CHAR1)			 (replace CHAR1 of LINE with (IPLUS (fetch CHAR1 of LINE)							    DCH)))		       ((AND (IEQP CH#1 (fetch CHAR1 of LINE))			     (NEQ LINE (fetch L1 of SEL)))   (* The insertion is at the end of the PRIOR line--so go 							     ahead and update this CHAR1)			 (replace CHAR1 of LINE with (IPLUS (fetch CHAR1 of LINE)							    DCH))			 (COND			   ((fetch PREVLINE of LINE)			     (replace DIRTY of (fetch PREVLINE of LINE) with T)))			 (replace DIRTY of LINE with T))		       ((IGEQ (fetch CHARTOP of LINE)			      CH#1)                          (* This line spans the insert point.							     Mark it DIRTY.)			 (replace DIRTY of LINE with T))		       ((AND (IGEQ (fetch CHARLIM of LINE)				   OTEXTLEN)			     (NOT (fetch CR\END of LINE)))          (* This line is the last in the file, and its CHAR1 is <= the insert point, and it doesn't end in a CR.	  Therefore, move the line's end upward to accomodate the insertion.)			 (replace DIRTY of LINE with T)))		     [COND		       ([OR (IGEQ (fetch CHARLIM of LINE)				  CH#1)			    (AND (IGEQ (fetch CHARLIM of LINE)				       OTEXTLEN)				 (NOT (fetch CR\END of LINE]			 (replace CHARLIM of LINE with (IPLUS (fetch CHARLIM of LINE)							      DCH))			 (COND			   ((IGEQ (fetch CHARTOP of LINE)				  CH#1)			     (replace CHARTOP of LINE with (IPLUS (fetch CHARTOP of LINE)								  DCH]		     (SETQ LINE (fetch NEXTLINE of LINE]    [COND      ((IGEQ (fetch CH# of SEL)	     CH#1)                                           (* Fix up the selection; if we're beyond the insert 							     point, move the whole sel forward)	(replace CH# of SEL with (IPLUS (fetch CH# of SEL)					DCH]    (COND      ((IGEQ (fetch CHLIM of SEL)	     CH#1)                                           (* And the tail end of the sel, too.)	(replace CHLIM of SEL with (IPLUS (fetch CHLIM of SEL)					  DCH])(\FIXSEL  [LAMBDA (SEL TEXTOBJ)                                      (* jds " 2-AUG-83 14:18")                                                             (* Given that the selection SEL contains the correct CH#							     and CHLIM, reset the YBOT, X0, DX, and XLIM values.)    (PROG ((CH# (fetch CH# of SEL))	   (CHLIM (fetch CHLIM of SEL))	   (THISLINE (fetch THISLINE of TEXTOBJ))	   (STARTFOUND NIL)	   WLIST CHLIST LINE PREVLINE)          (COND	    ((fetch SET of SEL)	      (replace X0 of SEL with -1)	      (SETQ WLIST (fetch WIDTHS of THISLINE))	      (SETQ CHLIST (fetch CHARS of THISLINE))	      (replace XLIM of SEL with -1)	      (replace Y0 of SEL with (fetch WTOP of TEXTOBJ))	      (replace YLIM of SEL with -1)	      (replace L1 of SEL with (replace LN of SEL with NIL))	      (bind (LINE _(fetch NEXTLINE of (fetch LINES of TEXTOBJ)))		    TX DX while LINE		 do (COND		      [(AND (IGEQ CH# (fetch CHAR1 of LINE))			    (ILEQ CH# (fetch CHARLIM of LINE)))                                                             (* The selection starts in this line.							     Fix L1, X0, and Y0.)			(SETQ STARTFOUND T)			(replace Y0 of SEL with (fetch YBOT of LINE))			(replace L1 of SEL with LINE)			(SETQ TX (fetch LEFTMARGIN of LINE))                                                             (* Temp. X value for scanning the line from left margin 							     to the right)			(replace X0 of SEL with (fetch LEFTMARGIN of LINE))			(COND			  [(AND (IEQP CH# (fetch CHARLIM of LINE))				(EQ (fetch POINT of SEL)				    (QUOTE RIGHT))				(IEQP (fetch DCH of SEL)				      0)				(fetch CR\END of LINE)				(fetch NEXTLINE of LINE))    (* This selection starts AFTER the CR on a line, and 							     doesn't include it.)			    (replace L1 of SEL with (fetch NEXTLINE of LINE))                                                             (* Change the selection to start on the next line, at 							     the margin, instead.)			    (replace X0 of SEL with (fetch LEFTMARGIN of (fetch L1 of SEL)))			    (replace Y0 of SEL with (fetch YBOT of (fetch L1 of SEL]			  ((IGREATERP CH# (fetch CHAR1 of LINE))                                                             (* Only bother formatting the line if the selection 							     doesn't include the first character.)			    (COND			      ((NEQ (fetch DESC of THISLINE)				    LINE)                    (* If this line isn't cached in THISLINE, reformat it.)				(\FORMATLINE TEXTOBJ NIL (fetch CHAR1 of LINE)					     THISLINE LINE)))			    (COND			      ((IGEQ (fetch LEN of THISLINE)				     0)                      (* As long as there's something there on the line...)				(for I from 0 to (fetch LEN of THISLINE) as CHNO				   from (fetch CHAR1 of LINE)				   do (SETQ DX (\WORDELT WLIST I))				      (SETQ TX (IPLUS TX DX))				      (COND					((EQ 400 (\EDITELT CHLIST I))                                                             (* This is a format effector--reduce CHNO to ignore it)					  (SETQ CHNO (SUB1 CHNO)))					((ILESSP CHNO CH#)					  (replace X0 of SEL with TX))					(T (RETURN]		      ((IEQP CH# (ADD1 (fetch CHARLIM of LINE)))                                                             (* The selection starts either here or at the start of 							     the next line.)			(replace Y0 of SEL with (fetch YBOT of LINE))			(replace L1 of SEL with LINE)			(replace X0 of SEL with (fetch LXLIM of LINE)))		      ((AND (NOT STARTFOUND)			    (IGREATERP (fetch CHAR1 of LINE)				       CH#)			    (ILEQ (fetch CHAR1 of LINE)				  CHLIM))                    (* The selection starts before this line, so play 							     catch-up)			(replace Y0 of SEL with (fetch YBOT of LINE))			(replace L1 of SEL with LINE)			(replace X0 of SEL with (fetch LEFTMARGIN of LINE))			(SETQ STARTFOUND T)))		    [COND		      [(AND (IGEQ CHLIM (fetch CHAR1 of LINE))			    (ILEQ CHLIM (fetch CHARLIM of LINE)))                                                             (* The selection ends in this line.							     Fix LN, XLIM, and YLIM.)			(replace YLIM of SEL with (fetch YBOT of LINE))			(replace LN of SEL with LINE)			(SETQ TX (fetch LEFTMARGIN of LINE))                                                             (* Temp X position)			(replace XLIM of SEL with (fetch LXLIM of LINE))			(COND			  [(AND (IEQP CHLIM (fetch CHARLIM of LINE))				(EQ (fetch POINT of SEL)				    (QUOTE RIGHT))				(IEQP (fetch DCH of SEL)				      0)				(fetch NEXTLINE of LINE)				(fetch CR\END of LINE))      (* This selection starts AFTER the CR on a line, and 							     doesn't include it.)			    (replace LN of SEL with (fetch NEXTLINE of LINE))                                                             (* Change the selection to start on the next line, at 							     the margin, instead.)			    (replace XLIM of SEL with (fetch LEFTMARGIN of (fetch LN of SEL)))			    (replace YLIM of SEL with (fetch YBOT of (fetch LN of SEL]			  ((ILESSP CHLIM (IMIN (fetch CHARLIM of LINE)					       (fetch TEXTLEN of TEXTOBJ)))                                                             (* Only bother formatting if the selection doesn't 							     include the last char on the line)			    (COND			      ((NEQ (fetch DESC of THISLINE)				    LINE)                    (* If this line isn't cached in THISLINE, then reformat 							     it.)				(\FORMATLINE TEXTOBJ NIL (fetch CHAR1 of LINE)					     THISLINE LINE)))			    (COND			      ((IGEQ (fetch LEN of THISLINE)				     0)				(for I from 0 to (fetch LEN of THISLINE) as CHNO				   from (fetch CHAR1 of LINE)				   do (SETQ DX (\WORDELT WLIST I))				      (SETQ TX (IPLUS TX DX))				      (COND					((EQ 400 (\EDITELT CHLIST I))                                                             (* This is a format effector--reduce CHNO to ignore it)					  (SETQ CHNO (SUB1 CHNO)))					((ILEQ CHNO CHLIM)					  (replace XLIM of SEL with TX))					(T (RETURN]		      ((IEQP CHLIM (ADD1 (fetch CHARLIM of LINE)))                                                             (* The selection ends either here or at the start of the							     next line.)			(replace YLIM of SEL with (fetch YBOT of LINE))			(replace LN of SEL with LINE)			(replace XLIM of SEL with (fetch LXLIM of LINE]		    (SETQ PREVLINE LINE)		    (SETQ LINE (fetch NEXTLINE of LINE)))	      (COND		[(IEQP 0 (fetch DCH of SEL))                 (* If this is a point selection, put it on the correct 							     side of the character we selected.)		  (replace DX of SEL with 0)		  (COND		    ((EQ (fetch POINT of SEL)			 (QUOTE LEFT))		      (replace XLIM of SEL with (fetch X0 of SEL)))		    (T (replace X0 of SEL with (fetch XLIM of SEL]		(T                                           (* Otherwise, fix DX for the selection)		   (replace DX of SEL with (IDIFFERENCE (fetch XLIM of SEL)							(fetch X0 of SEL])(\PNC  [LAMBDA (CH STR)                                           (* jds " 7-JUN-82 14:03")    (PROG ((LEN (fetch (STRINGP LENGTH) of STR))	   (OFFST (fetch (STRINGP OFFST) of STR)))          (COND	    ((ZEROP LEN)	      (ERROR "NO ROOM LEFT IN STRING TO PUT CHARACTER"))	    (T (UNINTERRUPTABLY                   (\PUTBASEBYTE (fetch (STRINGP BASE) of STR)				 OFFST CH)		   (replace (STRINGP OFFST) of STR with (ADD1 OFFST))		   (replace (STRINGP LENGTH) of STR with (SUB1 LEN)))])(\SHOWTEXT  [LAMBDA (TEXTOBJ THISLINE LINES)                           (* jds "10-MAY-83 13:25")                                                             (* Fill the editor window with text, starting from the 							     top of the file.)    (COND      ((fetch \WINDOW of TEXTOBJ)                            (* If there is no edit window, just return.)	(DSPRESET (ffetch DS of TEXTOBJ))                    (* Clear the window.)	(RESETLST (RESETSAVE (CURSOR WAITINGCURSOR))         (* Display the hourglass cursor as we work)		  (OR LINES (SETQ LINES (create LINEDESCRIPTOR						YBOT _(fetch WTOP of TEXTOBJ)						CHAR1 _ 0						CHARLIM _ 0						SPACELEFT _ -1						RIGHTMARGIN _(SUB1 (fetch WRIGHT of TEXTOBJ))						NEXTLINE _ NIL						CHARTOP _ -1						LHEIGHT _ 0						FIRSTSPACE _ 0						LXLIM _(fetch WRIGHT of TEXTOBJ)						CR\END _ T						ASCENT _ 0						DESCENT _ 0)))                                                             (* Make sure we have the anchor pseudo-line)		  (\FILLWINDOW (fetch WTOP of TEXTOBJ)			       LINES TEXTOBJ THISLINE)       (* Fill the window as usual)		  LINES])(\STRINGIN  [LAMBDA (STREAM)                                           (* jds " 3-FEB-83 15:01")                                                             (* Write a string on a file in length-contents form;							     one word for the length, and one byte per character 							     contained.)    (PROG ((LEN (\WIN STREAM))	   STR)          (SETQ STR (ALLOCSTRING LEN))          [OR (ZEROP LEN)	      (for I from 1 to LEN do (RPLCHARCODE STR I (\BIN STREAM]          (RETURN STR])(\STRINGOUT  [LAMBDA (STREAM STRING LEN)                                (* jds " 3-FEB-83 14:59")                                                             (* Write a string on a file in length-contents form;							     one word for the length, and one byte per character 							     contained.)    (SETQ LEN (OR LEN (NCHARS STRING)))    (\WOUT STREAM LEN)    (OR (ZEROP LEN)	(for CH instring STRING as I from 1 to LEN do (\BOUT STREAM CH])(\TEDIT.BLTCHAR  [LAMBDA (CHARCODE DISPLAYSTREAM WIDTH CURX)                (* jds "11-FEB-83 19:13")                                                             (* Version of BLTCHAR peculiar to TEdit -- relies on 							     \DISPLAYLINE to make sure things keep working right.)          (* puts a character on a display stream. Much of the information needed by the BitBlt microcode is prestored by 	  the routines that change it. This is kept in the BitBltTable.)                                                             (* knows about the representation of a DisplayStream.)    (DECLARE (LOCALVARS . T))    (PROG (NEWX LEFT RIGHT DEST)          (SETQ NEWX (IPLUS CURX WIDTH))          (SETQ LEFT (IMAX (ffetch \SFClippingLeft of DISPLAYSTREAM)			   CURX))          (SETQ RIGHT (IMIN (ffetch \SFClippingRight of DISPLAYSTREAM)			    NEWX))          (SETQ NEWX (ffetch \SFPILOTBBT of DISPLAYSTREAM))          (COND	    ((ILESSP LEFT RIGHT)	      (UNINTERRUPTABLY                  (\INSURETOPWDS DISPLAYSTREAM)		  (freplace PBTDESTBIT of NEWX with LEFT)		  (freplace PBTWIDTH of NEWX with (IMIN (\GETBASE (ffetch \SFWIDTHSCACHE								     of DISPLAYSTREAM)								  CHARCODE)							(IDIFFERENCE RIGHT LEFT)))		  (freplace PBTSOURCEBIT of NEWX with (IDIFFERENCE (IPLUS (\DSPGETCHAROFFSET CHARCODE 										    DISPLAYSTREAM)									  LEFT)								   CURX))		  (\PILOTBITBLT NEWX 0))	      T])(\TEDIT.CHARDELETE  [LAMBDA (TEXTOBJ SCRATCHSTRING SEL)                        (* jds " 3-AUG-83 13:03")                                                             (* Do character-backspace deletion for TEDIT)    [COND      ((type? STREAM TEXTOBJ)                                (* If, perchance, we got a STREAM, change it to the 							     equivalent TEXTOBJ.)	(SETQ TEXTOBJ (fetch F3 of TEXTOBJ]    (PROG ((THISLINE (fetch THISLINE of TEXTOBJ))	   TLEN INSCH#)          (COND	    [[NOT (ZEROP (SETQ TLEN (fetch (STRINGP OFFST) of SCRATCHSTRING]	      (replace (STRINGP OFFST) of SCRATCHSTRING with (SUB1 TLEN))	      (replace (STRINGP LENGTH) of SCRATCHSTRING with (ADD1 (fetch (STRINGP LENGTH)								       of SCRATCHSTRING]	    (T                                               (* Delete the character just before the current 							     insertpoint.)	       (SELECTQ (fetch POINT of SEL)			[LEFT (SETQ INSCH# (SUB1 (fetch CH# of SEL]			(RIGHT (SETQ INSCH# (fetch CHLIM of SEL)))			NIL)	       (COND		 ((ILEQ INSCH# 0)		   NIL)		 (T (replace CH# of SEL with (replace CHLIM of SEL with INSCH#))		    (replace DCH of SEL with 1)		    (\SHOWSEL SEL NIL NIL)		    (\FIXSEL SEL TEXTOBJ)		    (\TEDIT.DELETE SEL TEXTOBJ THISLINE T])(\TEDIT.CLOSEUPLINES  [LAMBDA (TEXTOBJ PREVLINE NEXTLINE DONTFILLFLG)            (* jds "25-JUL-83 15:09")          (* Given a gap between PREVLINE and NEXTLINE, move NEXTLINE et seq up to cover the gap, and adjust the YBOTs.	  If FILLFLG, then fill in as needed?)    (PROG (DY (DS (fetch DS of TEXTOBJ))	      (WWIDTH (fetch WRIGHT of TEXTOBJ))	      [LOWESTY (COND			 (PREVLINE (fetch YBOT of PREVLINE))			 (T (fetch WTOP of TEXTOBJ]	      (THISLINE (fetch THISLINE of TEXTOBJ)))          [COND	    (NEXTLINE                                        (* If the gap isn't at the end, move whatever else up 							     over it.)		      [SETQ DY (IDIFFERENCE LOWESTY (IPLUS (fetch YBOT of NEXTLINE)							   (fetch LHEIGHT of NEXTLINE]		      (AND (ILEQ DY 0)			   (RETURN))                         (* If there's no gap, don't bother with anything else.)		      (BITBLT DS 0 0 DS 0 DY WWIDTH (IPLUS (fetch YBOT of NEXTLINE)							   (fetch LHEIGHT of NEXTLINE))			      (QUOTE INPUT)			      (QUOTE REPLACE))               (* Move the remaining lines upward.)		      (bind ((LINE _ NEXTLINE)			     (NYBOT _ LOWESTY))			 while LINE			 do                                  (* Scan the remaining lines, fixing up the vertical 							     spacing information)			    (SETQ NYBOT (IDIFFERENCE NYBOT (fetch LHEIGHT of LINE)))			    [COND			      [(ILEQ (fetch YBOT of LINE)				     (fetch WBOTTOM of TEXTOBJ))                                                             (* Line is off screen. Display it at the right spot.)				(AND DONTFILLFLG (RETURN))   (* If we're not filling the screen, then stop here.)				(replace YBOT of LINE with NYBOT)				(replace YBASE of LINE with (IPLUS NYBOT (fetch DESCENT of LINE)))				(\DISPLAYLINE TEXTOBJ LINE)				(OR (fetch NEXTLINE of LINE)				    (IGEQ (fetch CHARLIM of LINE)					  (fetch TEXTLEN of TEXTOBJ))				    (PROGN (replace NEXTLINE of LINE					      with (\FORMATLINE TEXTOBJ NIL								(ADD1 (fetch CHARLIM of LINE))								THISLINE))					   (replace PREVLINE of (fetch NEXTLINE of LINE)					      with LINE]			      (T                             (* Line is visible; just update YBOT/YBASE)				 (replace YBOT of LINE with NYBOT)				 (replace YBASE of LINE with (IPLUS (fetch YBOT of LINE)								    (fetch DESCENT of LINE]			    (SETQ LOWESTY NYBOT)			    (SETQ LINE (fetch NEXTLINE of LINE))			 until (ILEQ NYBOT (fetch WBOTTOM of TEXTOBJ]          (BITBLT NIL 0 0 DS 0 0 WWIDTH (SUB1 LOWESTY)		  (QUOTE TEXTURE)		  (QUOTE REPLACE)		  WHITESHADE)                                (* Clear the part of the screen below the lowest line 							     now displayed)          (RETURN T])(\TEDIT.COMMAND.LOOP  [LAMBDA (STREAM RTBL)                                      (* jds "17-AUG-83 13:54")                                                             (* Main command loop for the TEDIT editor.							     Includes keyboard polling and command dispatch)    (PROG ((TEXTOBJ (COND		      ((type? STREAM STREAM)			(fetch F3 of STREAM))		      (T STREAM)))	   (ISCRSTRING (ALLOCSTRING \SCRATCHLEN " "))	   SEL WINDOW LINES THISLINE IPASSSTRING)          (SETQ SEL (fetch SEL of TEXTOBJ))          (SETQ WINDOW (fetch \WINDOW of TEXTOBJ))          (SETQ LINES (fetch LINES of TEXTOBJ))          (SETQ THISLINE (fetch THISLINE of TEXTOBJ))          (SETQ IPASSSTRING (SUBSTRING ISCRSTRING 1))        (* Used inside \INSERT\TTY\BUFFER)          (SETQ RTBL (OR RTBL TEDIT.READTABLE))              (* Used to derive command characters from type-in)          (RESETLST [RESETSAVE (PROGN (\TEDIT.INTERRUPT.SETUP WINDOW))			       (QUOTE (AND (\TEDIT.INTERRUPT.SETUP OLDVALUE T]		    [RESETSAVE (PROGN TEXTOBJ)			       (QUOTE (AND (TXTFILE OLDVALUE)					   (CLOSEF? (TXTFILE OLDVALUE]		    (PROG (CH FN (DIRTY NIL)			      (BLANKSEEN NIL)			      INSCH#			      (CRSEEN NIL)			      TLEN CHNO (READSA (fetch READSA of #CURRENTRDTBL#))			      (TERMSA \PRIMTERMSA)			      (TEDITSA (fetch READSA of RTBL))			      (TEDITFNHASH (fetch READMACRODEFS of RTBL))			      (LOOPFN (WINDOWPROP WINDOW (QUOTE TEDIT.CMD.LOOPFN)))			      (CHARFN (WINDOWPROP WINDOW (QUOTE TEDIT.CMD.CHARFN)))			      COMMANDFN)		          (while (NOT (fetch EDITFINISHEDFLG of TEXTOBJ))			     do (\WAITFORSYSBUFP 25)				(while (OR TEDIT.SELPENDING (fetch EDITOPACTIVE of TEXTOBJ))				   do                        (* Don't do anything while he's selecting or one of the 							     lock-out ops is active.)				      (TEDIT.FLASHCARET (fetch CARET of TEXTOBJ))				      (BLOCK))               (* Await type-in or mouse action)				(TEDIT.FLASHCARET (fetch CARET of TEXTOBJ))				(AND LOOPFN (APPLY* LOOPFN STREAM))                                                              (* If the guy wants control during the loop, give it to 							     him.)				[COND				  (TEDIT.COPY.PENDING        (* Have to copy the shifted SEL to caret.)						      (\COPYSEL TEDIT.SHIFTEDSELECTION								(fetch SHIFTEDSEL of TEXTOBJ))						      (TEDIT.DO.BLUEPENDINGDELETE SEL TEXTOBJ 										  THISLINE)						      (TEDIT.COPY (fetch SHIFTEDSEL of TEXTOBJ)								  (fetch SEL of TEXTOBJ)								  THISLINE)						      (replace SET of (fetch SHIFTEDSEL of TEXTOBJ)							 with NIL))				  (TEDIT.MOVE.PENDING        (* Have to copy the shifted SEL to caret.)						      (\COPYSEL TEDIT.MOVESELECTION								(fetch MOVESEL of TEXTOBJ))						      (TEDIT.DO.BLUEPENDINGDELETE SEL TEXTOBJ 										  THISLINE)						      (TEDIT.MOVE (fetch MOVESEL of TEXTOBJ)								  (fetch SEL of TEXTOBJ)								  THISLINE)						      (replace SET of (fetch MOVESEL of TEXTOBJ)							 with NIL))				  (TEDIT.DEL.PENDING         (* Delete the current selection.)						     (SETQ TEDIT.DEL.PENDING NIL)                                                             (* Above all, reset the demand flag first)						     (COND						       ((fetch SET of TEDIT.DELETESELECTION)                                                             (* Only try the deletion if he really set the 							     selection.)							 (\SHOWSEL (fetch DELETESEL of TEXTOBJ)								   NIL NIL)                                                             (* Turn off the selection highlights)							 (\SHOWSEL (fetch SEL of TEXTOBJ)								   NIL NIL)							 (replace SET of (fetch DELETESEL									    of TEXTOBJ)							    with NIL)							 (\COPYSEL TEDIT.DELETESELECTION								   (fetch SEL of TEXTOBJ))							 (TEDIT.SET.SEL.LOOKS (fetch SEL										 of TEXTOBJ)									      (QUOTE NORMAL))                                                             (* Grab the selection we're to use)							 (\TEDIT.DELETE (fetch SEL of TEXTOBJ)									(fetch \TEXTOBJ									   of (fetch SEL										 of TEXTOBJ))									THISLINE NIL]				(UNINTERRUPTABLY                                    (replace (STRINGP OFFST) of ISCRSTRING with 0)				    (replace (STRINGP LENGTH) of ISCRSTRING with \SCRATCHLEN))				[while (\SYSBUFP)				   do                        (* Handle user type-in)				      (SETQ CH (\GETKEY))				      (AND CHARFN (APPLY* STREAM CH))                                                              (* Give the OEM user control for each character typed.)				      (SELECTC (fetch TERMCLASS of (\SYNCODE TERMSA CH))					       (CHARDELETE.TC                                                              (* Backspace handler: Remove the character just before 							     SEL:CH#.)							      (\TEDIT.CHARDELETE TEXTOBJ ISCRSTRING 										 SEL THISLINE)							      (SETQ TEDIT.BLUEPENDINGDELETE NIL))					       (WORDDELETE.TC (\INSERT\TTY\BUFFER)                                                             (* Insert any cached characters before doing the 							     delete.)							      (\TEDIT.WORDDELETE TEXTOBJ READSA)							      (SETQ TEDIT.BLUEPENDINGDELETE NIL))					       (LINEDELETE.TC                                                              (* DEL Key handler: Delete the selected characters)							      (\INSERT\TTY\BUFFER)							      (\TEDIT.DELETE SEL TEXTOBJ THISLINE)							      (SETQ TEDIT.BLUEPENDINGDELETE NIL))					       (SELECTC (\SYNCODE TEDITSA CH)							(CHARDELETE.TTC                                                              (* Backspace handler: Remove the character just before 							     SEL:CH#.)									(\TEDIT.CHARDELETE TEXTOBJ 										       ISCRSTRING SEL 											 THISLINE)									(SETQ TEDIT.BLUEPENDINGDELETE 									  NIL))							(WORDDELETE.TTC (\INSERT\TTY\BUFFER)                                                             (* Insert any cached characters before doing the 							     delete.)									(\TEDIT.WORDDELETE TEXTOBJ 											   READSA)									(SETQ TEDIT.BLUEPENDINGDELETE 									  NIL))							(DELETE.TTC                                                              (* DEL Key handler: Delete the selected characters)								    (\INSERT\TTY\BUFFER)								    (\TEDIT.DELETE SEL TEXTOBJ 										   THISLINE)								    (SETQ TEDIT.BLUEPENDINGDELETE NIL)								    )							(UNDO.TTC                                                              (* He hit the CANCEL key, so go UNDO something)								  (TEDIT.UNDO TEXTOBJ THISLINE)								  (SETQ TEDIT.BLUEPENDINGDELETE NIL))							(REDO.TTC                                                              (* He hit the CANCEL key, so go UNDO something)								  (TEDIT.REDO TEXTOBJ THISLINE)								  (SETQ TEDIT.BLUEPENDINGDELETE NIL))							(CMD.TTC                                                              (* The 'command' key was hit;							     call the user's function.)								 (SETQ TEDIT.BLUEPENDINGDELETE NIL)								 (AND (SETQ COMMANDFN									(WINDOWPROP WINDOW										    (QUOTE 										  TEDIT.COMMANDFN)))								      (APPLY* COMMANDFN									      (fetch STREAMHINT										 of TEXTOBJ)									      TEXTOBJ SEL)))							(FUNCTIONCALL.TTC                                                              (* This is a special character -- it calls a function)									  (SETQ 									  TEDIT.BLUEPENDINGDELETE NIL)									  (AND (SETQ FN										 (GETHASH CH 										      TEDITFNHASH))									       (APPLY* FN										       (fetch 										       STREAMHINT											  of TEXTOBJ)										       TEXTOBJ)))							(PROGN                                                              (* Any other key was hit: Just insert the character.)							       (TEDIT.DO.BLUEPENDINGDELETE SEL 											  TEXTOBJ 											 THISLINE)                                                             (* Handle blue pending delete, if there is one.)							       (COND								 ((ZEROP (fetch (STRINGP LENGTH)									    of ISCRSTRING))								   (replace (STRINGP OFFST)								      of ISCRSTRING with 0)								   (replace (STRINGP LENGTH)								      of ISCRSTRING with \SCRATCHLEN)								   (TEDIT.\INSERT ISCRSTRING SEL 										  TEXTOBJ BLANKSEEN 										  CRSEEN)								   (SETQ BLANKSEEN NIL)								   (SETQ CRSEEN NIL)))							       (SELCHARQ CH									 (SPACE (\INSERT\TTY\BUFFER)										(TEDIT.\INSERT CH SEL 											  TEXTOBJ T 											      NIL))									 (CR (\INSERT\TTY\BUFFER)									     (TEDIT.\INSERT CH SEL 											  TEXTOBJ NIL 											    T))									 (\PNC CH ISCRSTRING]				(\INSERT\TTY\BUFFER])(\TEDIT.DELETE  [LAMBDA (SEL STREAM THISLINE SELOFF)                       (* jds "15-AUG-83 20:08")                                                             (* DELETE THE CHARACTERS SPECIFIED FROM THE MAIN TEXT.)                                                             (* SELOFF => The selection is already turned off.)    (PROG [(TEXTOBJ (COND		      ((type? STREAM STREAM)                 (* If we got a STREAM, change it into a textobj)			(fetch F3 of STREAM))		      (T STREAM]          (PROG ((CH# (fetch CH# of SEL))		 (CHLIM (fetch CHLIM of SEL))		 OLINE1 OLINEN (NLINE1 NIL)		 LEN NEXTLINE NL (CRFLAG NIL)		 (LINES\DELETED NIL)		 (LINES (fetch LINES of TEXTOBJ))		 OLINE DX OCHLIM OXLIM (DS (fetch DS of TEXTOBJ))		 (WINDOW (fetch \WINDOW of TEXTOBJ))		 PREVLINE TEXTLEN OCR\END SAVEWIDTH CHANGEDLINE)	        [SETQ LEN (COND		    ((IGREATERP CH# (fetch TEXTLEN of TEXTOBJ))                                                             (* Past end of text, so don't delete any)		      0)		    ((IGREATERP CH# CHLIM)                   (* Start is past end, so don't delete any.)		      0)		    ((ZEROP (fetch DCH of SEL))              (* Just a caret--no text really selected--so don't 							     delete any)		      0)		    ((ZEROP CHLIM)                           (* CHLIM is before start of text, so don't delete any)		      0)		    (T                                       (* The normal case.)		       (ADD1 (IDIFFERENCE CHLIM CH#]         (* # of characters to be deleted)	        (COND		  ((OR (NOT (fetch SET of SEL))		       (ZEROP LEN))                          (* If the selection isn't set, don't do anything.)		    (RETURN)))	        (AND (fetch \WINDOW of TEXTOBJ)		     (TEDIT.NORMALIZECARET TEXTOBJ SEL))     (* If the text appears in a window, move the deletion 							     point on-screen)	        (SETQ OLINE1 (fetch L1 of SEL))	        (SETQ OLINEN (fetch LN of SEL))	        (\TEDIT.SHOWSELS TEXTOBJ NIL NIL)            (* Turn off the selection's highlighting)	        (SETQ LINES (\FIXDLINES LINES SEL CH# CHLIM TEXTOBJ))                                                             (* Update the line descriptors to account for the 							     deletion)	        (\DELETECH CH# CHLIM LEN TEXTOBJ)            (* Do the actual deletion of characters)	        (replace THPOINT of (CAR TEDIT.HISTORYLST) with (fetch POINT of SEL))                                                             (* Remember which side of the selection we were on, in 							     case it gets undone.)	        (SETQ TEXTLEN (fetch TEXTLEN of TEXTOBJ))    (* The new text length)	        [SETQ LINES\DELETED (\TEDIT.CLOSEUPLINES TEXTOBJ (COND							   ((fetch DELETED of OLINE1)							     (fetch PREVLINE of OLINE1))							   (T OLINE1))							 (COND							   ((fetch DELETED of OLINEN)							     (fetch NEXTLINE of OLINEN))							   (T OLINEN]                                                             (* Remove any lines which were completely deleted.)	        (COND		  ([OR (NOT OLINE1)		       (NOT OLINEN)		       (AND (fetch FORMATTEDP of TEXTOBJ)			    (OR (NEQ (fetch QUAD of (fetch LFMTSPEC of OLINE1))				     (QUOTE LEFT))				(IGREATERP (fetch RIGHTMAR of (fetch LFMTSPEC of OLINE1))					   (fetch WRIGHT of TEXTOBJ]                                                             (* This line must needs be reformatted the hard way--it 							     isn't a left ragged line or one of the lines is 							     off-screen.)		    (SETQ CHANGEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))                                                             (* Correct the text that's displayed already)		    (AND CHANGEDLINE (\FILLWINDOW (fetch YBOT of CHANGEDLINE)						  CHANGEDLINE TEXTOBJ THISLINE))                                                             (* And fill out the window.)		    (replace CH# of SEL with (IMAX 1 CH#))   (* Then fix up the selection as needed.)		    (replace CHLIM of SEL with (fetch CH# of SEL))		    (replace POINT of SEL with (QUOTE LEFT))		    (replace DX of SEL with 0)		    (replace DCH of SEL with 0)		    (\FIXSEL SEL TEXTOBJ)		    (\TEDIT.SHOWSELS TEXTOBJ NIL T)		    (RETURN)))                               (* Close up any gap in the screen)	        [COND		  [(EQ OLINE1 OLINEN)                        (* The deletion was within a single line.)		    (COND		      ((NOT (fetch DELETED of OLINE1))       (* Remove the deleted text, closing up the gap.							     Fix LXLIM & Spaceleft)			(replace SPACELEFT of OLINE1			   with (IPLUS (IMIN (fetch SPACELEFT of OLINE1)					     (IDIFFERENCE (fetch RIGHTMARGIN of OLINE1)							  (fetch XLIM of SEL)))				       (fetch DX of SEL)))   (* This handles the case where you delete a trailing 							     space on the line (not counted in SPACELEFT).)			(replace LXLIM of OLINE1 with (IDIFFERENCE (fetch LXLIM of OLINE1)								   (fetch DX of SEL)))			(BITBLT DS (fetch XLIM of SEL)				(fetch YBOT of OLINE1)				DS				(fetch X0 of SEL)				(fetch YBOT of OLINE1)				(IDIFFERENCE (fetch RIGHTMARGIN of OLINE1)					     (fetch XLIM of SEL))				(fetch LHEIGHT of OLINE1)				(QUOTE INPUT)				(QUOTE REPLACE))             (* Move the rest of the line to the left over the 							     deleted part)			(BITBLT NIL 0 0 DS (IDIFFERENCE (fetch RIGHTMARGIN of OLINE1)							(fetch SPACELEFT of OLINE1))				(fetch YBOT of OLINE1)				(fetch SPACELEFT of OLINE1)				(fetch LHEIGHT of OLINE1)				(QUOTE TEXTURE)				(QUOTE REPLACE)				WHITESHADE)                  (* And blank out to the right margin)			(SETQ NLINE1 OLINE1)			(COND			  ((IGEQ CHLIM (IPLUS (fetch CHARLIM of OLINE1)					      LEN))			    (SETQ CRFLAG T)))			(replace DESC of THISLINE with NIL)			(replace FIRSTSPACE of OLINE1 with (fetch LEFTMARGIN of OLINE1))                                                             (* Force it to try bringing text up from this line in 							     the future)			)		      (T (SETQ NLINE1 (fetch PREVLINE of OLINE1))			 (COND			   ((IGREATERP (fetch CHARLIM of NLINE1)				       0)                    (* We'll only re-format this line if it isn't the dummy 							     header line.)			     (replace DIRTY of NLINE1 with T]		  (T                                         (* The deletion spans a line boundary.)		     (SETQ LINES\DELETED T)                  (* Remember that fact.)		     (freplace LEN of THISLINE with -1)          (* We can't tell whether there are any spaces to the left of us on the line; Hence, in the future, we must assume 	  the worst and try to move text upward)		     (COND		       ((NOT (fetch DELETED of OLINE1))      (* WIPE OUT TAIL WHICH WAS DELETED, CHANGE LXLIM, SAVE 							     PTR TO IT.)			 (replace SPACELEFT of OLINE1 with (IDIFFERENCE (fetch RIGHTMARGIN									   of OLINE1)									(fetch X0 of SEL)))			 (replace LXLIM of OLINE1 with (fetch X0 of SEL))                                                             (* New limit of line's length is same as start of del.)			 (BITBLT NIL 0 0 DS (IDIFFERENCE (fetch RIGHTMARGIN of OLINE1)							 (fetch SPACELEFT of OLINE1))				 (fetch YBOT of OLINE1)				 (fetch SPACELEFT of OLINE1)				 (fetch LHEIGHT of OLINE1)				 (QUOTE TEXTURE)				 (QUOTE REPLACE)				 WHITESHADE)                 (* Blank out the deleted part)			 (SETQ NLINE1 OLINE1)))		     [COND		       ((NOT (fetch DELETED of OLINEN))          (* Wipe out the front part of the line, and move the rest over. Then fix its LXLIM, SPACELEFT, and FIRSTSPACE.	  Then save a pointer to it if none was saved for the first line of the deletion.)			 (replace FIRSTSPACE of OLINEN with 0)			 (BITBLT DS (fetch XLIM of SEL)				 (fetch YBOT of OLINEN)				 DS				 (fetch LEFTMARGIN of OLINEN)				 (fetch YBOT of OLINEN)				 (IDIFFERENCE (fetch RIGHTMARGIN of OLINEN)					      (fetch XLIM of SEL))				 (fetch LHEIGHT of OLINEN)				 (QUOTE INPUT)				 (QUOTE REPLACE))            (* Wipe out the deleted part)			 [replace LXLIM of OLINEN with (IDIFFERENCE (fetch LXLIM of OLINEN)								    (IDIFFERENCE (fetch XLIM										    of SEL)										 (fetch LEFTMARGIN										    of OLINEN]                                                             (* Fix the right limit of the line's extent)			 [replace SPACELEFT of OLINEN with (IPLUS (fetch SPACELEFT of OLINEN)								  (IDIFFERENCE (fetch XLIM										  of SEL)									       (fetch LEFTMARGIN										  of OLINEN]                                                             (* And SPACELEFT on the line)			 (BITBLT NIL 0 0 DS (IDIFFERENCE (fetch RIGHTMARGIN of OLINEN)							 (fetch SPACELEFT of OLINEN))				 (fetch YBOT of OLINEN)				 (fetch SPACELEFT of OLINEN)				 (fetch LHEIGHT of OLINEN)				 (QUOTE TEXTURE)				 (QUOTE REPLACE)				 WHITESHADE)                 (* Clear to the right margin)			 (OR NLINE1 (SETQ NLINE1 OLINEN]		     (COND		       ((NOT NLINE1)			 (SETQ NLINE1 (fetch PREVLINE of OLINE1))			 (COND			   ((IGREATERP (fetch CHARLIM of NLINE1)				       0)                    (* We'll only re-format this line if it isn't the dummy 							     header line.)			     (replace DIRTY of NLINE1 with T]	        [COND		  (NLINE1                                    (* If it looks like we may need to look at the previous 							     line to do this right, move back and look at it.)			  (AND (SETQ PREVLINE (fetch PREVLINE of NLINE1))			       (IGREATERP (fetch CHAR1 of PREVLINE)					  0)			       (NOT (fetch CR\END of PREVLINE))			       (ILEQ CH# (fetch CHARTOP of PREVLINE))			       (SETQ NLINE1 PREVLINE)			       (replace DIRTY of NLINE1 with T))			  (while NLINE1			     do                              (* Propagate the changes downward...)				(COND				  [(AND (fetch DIRTY of NLINE1)					(SETQ NEXTLINE (fetch NEXTLINE of NLINE1))					(OR (IGEQ (IDIFFERENCE (fetch RIGHTMARGIN of NLINE1)							       (fetch LXLIM of NLINE1))						  (IDIFFERENCE (fetch FIRSTSPACE of NEXTLINE)							       (fetch LEFTMARGIN of NEXTLINE)))					    (ZEROP (IDIFFERENCE (fetch FIRSTSPACE of NEXTLINE)								(fetch LEFTMARGIN of NEXTLINE)))					    (AND (fetch CR\END of NLINE1)						 CRFLAG)))   (* The known fast cases)          (* This line needs to be checked AND there's a line after it to steal text from AND we think we can snatch a word 	  or more from that next line)				    (SETQ OXLIM (fetch LXLIM of NLINE1))                                                             (* Old values for checking after re-format)				    (SETQ OCHLIM (fetch CHARLIM of NLINE1))				    (SETQ OCR\END (fetch CR\END of NLINE1))				    (\FORMATLINE TEXTOBJ NIL (fetch CHAR1 of NLINE1)						 THISLINE NLINE1)                                                             (* Compute the new line break)				    [COND				      ([OR (NOT (IEQP OXLIM (fetch LXLIM of NLINE1)))					   (NOT (IEQP OCHLIM (fetch CHARLIM of NLINE1]                                                             (* We got some text from the next line.							     Go move the screen images as needed)					(SETQ DX (IDIFFERENCE (fetch LXLIM of NLINE1)							      OXLIM))                                                             (* Width of the text to be moved up)					(COND					  [                  (* We're only interested if there IS text to move.)					    (IGREATERP DX 0)					    (while (IGREATERP DX 0)					       do            (* Keep grabbing text until we've got it all)						  (COND						    [NEXTLINE                                                             (* There IS another line to grab text from.)						      (COND							((AND (IGREATERP (fetch YBOT of NEXTLINE)									 (fetch WBOTTOM of TEXTOBJ))							      (IGREATERP (IDIFFERENCE (fetch LXLIM											 of NEXTLINE)										      (fetch 										       LEFTMARGIN											 of NEXTLINE))									 DX))                                                             (* The next line is on-screen, and has enough text to 							     fill our needs.)							  (BITBLT DS (fetch LEFTMARGIN of NEXTLINE)								  (fetch YBOT of NEXTLINE)								  DS OXLIM (fetch YBOT of NLINE1)								  DX								  (fetch LHEIGHT of NLINE1)								  (QUOTE INPUT)								  (QUOTE REPLACE))                                                             (* Move the front of the next line up to the end of this							     line, satisfying our need.)							  (SETQ LINES\DELETED							    (OR (\PULLTEXT NEXTLINE DX									   (ADD1 (fetch CHARLIM										    of NLINE1))									   THISLINE TEXTOBJ)								LINES\DELETED))                                                             (* Now propogate the text grabbing on downward.)							  (SETQ DX 0)                                                             (* We've satisfied the need; tell the main loop so.)							  )							((IGREATERP (IDIFFERENCE (fetch LXLIM										    of NEXTLINE)										 (fetch LEFTMARGIN										    of NEXTLINE))								    DX)                                                             (* The next line lies below bottom of window--just 							     Displayline, and blast the next line to hell.)							  (\DISPLAYLINE TEXTOBJ NLINE1)							  (replace NEXTLINE of NLINE1 with NIL)							  (replace PREVLINE of NEXTLINE with NIL)							  (SETQ DX 0))							(T                                                              (* NEXT NLINE1 WON'T FILL THIS ONE: GRAB IT, DECREMENT 							     DX, BUMP LXLIM, MOVE ANY LOWER LINES UP OVER IT, AND TRY							     AGAIN.)							   (BITBLT DS (fetch LEFTMARGIN of NEXTLINE)								   (fetch YBOT of NEXTLINE)								   DS OXLIM (fetch YBOT of NLINE1)								   (fetch LXLIM of NEXTLINE)								   (fetch LHEIGHT of NEXTLINE)								   (QUOTE INPUT)								   (QUOTE REPLACE))							   [SETQ DX							     (IDIFFERENCE DX									  (IDIFFERENCE (fetch LXLIM											  of NEXTLINE)										       (fetch 										       LEFTMARGIN											  of NEXTLINE]                                                             (* Find out how much more text we need.)							   [SETQ OXLIM							     (IPLUS OXLIM								    (IDIFFERENCE (fetch LXLIM										    of NEXTLINE)										 (fetch LEFTMARGIN										    of NEXTLINE]                                                             (* And fix the "old" values for the next shor thru the 							     loop)							   (SETQ NL (fetch NEXTLINE of NEXTLINE))							   (TEDIT.DELETELINE NEXTLINE TEXTOBJ)                                                             (* Really delete the line we used up, and move lower 							     lines up to fill.)							   (SETQ NEXTLINE NL)							   (SETQ LINES\DELETED T]						    (T       (* There is no succeeding line to take text from.							     Resort to the slow way, then stop the process bu setting							     DX to 0)						       (\DISPLAYLINE TEXTOBJ NLINE1)						       (SETQ DX 0]					  ((ILESSP DX 0)     (* For whatever reason, we have to push text downward 							     (deleting a blank at EOL can do this).)					    (SETQ DX (IMINUS DX))					    [COND					      ((fetch NEXTLINE of NLINE1)                                                             (* There's a next line to push onto)						[SETQ SAVEWIDTH						  (IMIN DX							(IMAX 0 (IDIFFERENCE (fetch RIGHTMARGIN										of NLINE1)									     (IDIFFERENCE									       (fetch LXLIM										  of NLINE1)									       DX]                                                             (* Save the text to be pushed down)						[OR (fetch CACHE of NLINE1)						    (replace CACHE of NLINE1						       with (BITMAPCREATE (fetch WRIGHT of TEXTOBJ)									  (fetch LHEIGHT									     of NLINE1]						(BITBLT (fetch \WINDOW of TEXTOBJ)							(IDIFFERENCE OXLIM DX)							(fetch YBOT of NLINE1)							(fetch CACHE of NLINE1)							0 0 DX (fetch LHEIGHT of NLINE1)							(QUOTE INPUT)							(QUOTE REPLACE))						(\PUSHTEXT (fetch NEXTLINE of NLINE1)							   (IDIFFERENCE OXLIM DX)							   (fetch YBOT of NLINE1)							   DX							   (ADD1 (fetch CHARLIM of NLINE1))							   TEXTOBJ THISLINE OCR\END							   (fetch CACHE of NLINE1)							   SAVEWIDTH)                                                             (* And push the next guy along.)						)					      (T             (* No next line to push text onto.							     Make a new one.)						 (replace NEXTLINE of NLINE1						    with (\FORMATLINE TEXTOBJ NIL								      (ADD1 (fetch CHARLIM									       of NLINE1))								      THISLINE))                                                             (* Create the new line)						 (replace PREVLINE of (fetch NEXTLINE of NLINE1)						    with NLINE1)                                                             (* Plug it into the chain of lines)						 (COND						   ((IGREATERP (fetch YBOT of NLINE1)							       (IPLUS (fetch LHEIGHT									 of (fetch NEXTLINE									       of NLINE1))								      (fetch WBOTTOM of TEXTOBJ)))                                                             (* There's room for this new line.							     Go ahead and display it)						     [replace YBOT of (fetch NEXTLINE of NLINE1)							with (IDIFFERENCE (fetch YBOT of NLINE1)									  (fetch LHEIGHT									     of (fetch NEXTLINE										   of NLINE1]						     [replace YBASE of (fetch NEXTLINE of NLINE1)							with (IPLUS (fetch YBOT								       of (fetch NEXTLINE									     of NLINE1))								    (fetch DESCENT								       of (fetch NEXTLINE									     of NLINE1]						     (\DISPLAYLINE TEXTOBJ (fetch NEXTLINE									      of NLINE1]					    (BITBLT NIL 0 0 DS (fetch LXLIM of NLINE1)						    (fetch YBOT of NLINE1)						    (fetch WRIGHT of TEXTOBJ)						    (fetch LHEIGHT of NLINE1)						    (QUOTE TEXTURE)						    (QUOTE REPLACE)						    WHITESHADE)                                                             (* Blank out the line beyond its new end)					    ]				    (COND				      ((AND (IGEQ (fetch CHARLIM of NLINE1)						  TEXTLEN)					    (NOT (fetch CR\END of NLINE1)))                                                             (* If this line is at end of text, and it has no 							     trailing CR, make sure there's no dummy line below it.)					(replace NEXTLINE of NLINE1 with NIL]				  ((AND (IEQP (fetch LXLIM of NLINE1)					      (IDIFFERENCE (fetch RIGHTMARGIN of NLINE1)							   (fetch SPACELEFT of NLINE1)))					(ILESSP (fetch CHARLIM of NLINE1)						TEXTLEN))    (* The general case)				    (\FIXCHANGEDPART TEXTOBJ THISLINE)				    (RETURN)))				(SETQ NLINE1 (fetch NEXTLINE of NLINE1]	        (COND		  (LINES\DELETED                             (* Lines were deleted; fill the bottom of the window as 							     possible)				 (SETQ OLINE (\TEDIT.FIND.LAST.LINE TEXTOBJ LINES))                                                             (* OLINE is now the last line displayed on the screen.)				 (\FILLWINDOW (fetch YBOT of OLINE)					      OLINE TEXTOBJ THISLINE)))	        (replace CH# of SEL with (IMAX 1 CH#))	        (replace CHLIM of SEL with (fetch CH# of SEL))	        (replace POINT of SEL with (QUOTE LEFT))	        (replace DX of SEL with 0)	        (replace DCH of SEL with 0)	        (TEDIT.SET.SEL.LOOKS SEL (QUOTE NORMAL))	        (COND		  ((ZEROP TEXTLEN)                           (* There are no characters; set the SEL to be at top of 							     screen, left edge.)		    (replace NEXTLINE of LINES with (\FORMATLINE TEXTOBJ NIL 1 THISLINE NIL))		    (replace PREVLINE of (fetch NEXTLINE of LINES) with LINES)		    [replace YBOT of (fetch NEXTLINE of LINES)		       with (IDIFFERENCE (fetch WTOP of TEXTOBJ)					 (FONTPROP (FONTCREATE (QUOTE GACHA)							       10)						   (QUOTE HEIGHT]		    (replace DESCENT of (fetch NEXTLINE of LINES) with (FONTPROP (FONTCREATE										   (QUOTE GACHA)										   10)										 (QUOTE DESCENT)))		    [replace YBASE of (fetch NEXTLINE of LINES)		       with (IPLUS (fetch YBOT of (fetch NEXTLINE of LINES))				   (fetch DESCENT of (fetch NEXTLINE of LINES]		    [replace YBASE of (fetch NEXTLINE of LINES)		       with (IPLUS (fetch YBOT of (fetch NEXTLINE of LINES))				   (fetch DESCENT of (fetch NEXTLINE of LINES]		    [replace Y0 of SEL with (IDIFFERENCE (fetch WTOP of TEXTOBJ)							 (COND							   ((fetch L1 of SEL)							     (fetch LHEIGHT								of (fetch L1 of SEL)))							   (T 12]		    (replace YLIM of SEL with (fetch Y0 of SEL))		    (replace POINT of SEL with (QUOTE LEFT))		    (replace DX of SEL with 0)		    [replace X0 of SEL with (replace XLIM of SEL					       with (COND						      ((fetch L1 of SEL)							(fetch LEFTMARGIN							   of (fetch L1 of SEL)))						      (T 8]		    (replace DCH of SEL with 0)		    (replace L1 of SEL with (fetch NEXTLINE of LINES))		    (replace LN of SEL with (fetch NEXTLINE of LINES)))		  (T (replace DESC of THISLINE with NIL)		     (\FIXSEL SEL TEXTOBJ)		     (\TEDIT.FIXSELS TEXTOBJ SEL)))	        (\SHOWSEL SEL NIL T)	        (\TEDIT.SHOWSELS TEXTOBJ NIL T])(\TEDIT.FIND.FIRST.LINE  [LAMBDA (TEXTOBJ WHEIGHT CH#)                              (* jds "26-JUL-83 10:53")                                                             (* Find the first line to be displayed, given that it 							     must include character CH#)    (PROG ((LINES (fetch LINES of TEXTOBJ))	   (WWIDTH (fetch WRIGHT of TEXTOBJ))	   (THISLINE (fetch THISLINE of TEXTOBJ))	   (TEXTSTREAM (fetch STREAMHINT of TEXTOBJ))	   LINE CHNO CH)          [COND	    ((ZEROP (fetch TEXTLEN of TEXTOBJ))              (* If there's no text, force an empty line)	      (SETQ CHNO 1)	      (replace NEXTLINE of LINES with NIL)	      (RETURN LINES))	    ((IGEQ CH# (fetch TEXTLEN of TEXTOBJ))           (* If there's no text on the screen, just return nil)	      (RETURN NIL))	    (T                                               (* Otherwise, move back thru the text until we find a 							     for-sure line break)	       (\SETUPGETCH CH# TEXTOBJ)	       (SETQ CH (\GETCH TEXTOBJ))	       (for old CHNO from CH# to 2 by -1 while (NOT (EQ CH (CHARCODE CR)))		  do (SETQ CH (\BACKBIN TEXTSTREAM)))	       (SETQ CHNO (COND		   ((ILEQ CHNO 1)                            (* If we moved back to start-of-file, move forward from 							     there;)		     1)		   ((IEQP CHNO CH)                           (* If we landed on a CR first shot, let's try moving 							     forward from there.)		     CH)		   (T                                        (* Else, skip the CR we passed over)		      (IPLUS CHNO 2]          (SETQ CH# (IMIN CH# (fetch TEXTLEN of TEXTOBJ)))          [repeatwhile (ILEQ CHNO CH#)	     do                                              (* Starting from the known line break, move forward 							     until we find the line which has the right CH# in it)		(SETQ LINE (\FORMATLINE TEXTOBJ NIL CHNO THISLINE))		(replace YBOT of LINE with WHEIGHT)		(replace NEXTLINE of LINES with LINE)		(replace PREVLINE of LINE with LINES)		(SETQ LINES LINE)		(SETQ CHNO (ADD1 (fetch CHARLIM of LINE]          (RETURN LINE])(\TEDIT.FIND.LAST.LINE  [LAMBDA (TEXTOBJ LINES)                                    (* jds "10-MAY-83 13:47")                                                             (* Among the line descriptors in LINES, find the last 							     one on the screen; then return it.)    (OR LINES (SETQ LINES (fetch LINES of TEXTOBJ)))         (* Make sure a list of line descriptors is specified.)    (COND      ((fetch \WINDOW of TEXTOBJ)                            (* If there's no window, return NIL.)	(bind (OLINE _ LINES)	      (LINE _ LINES)	      (CURY _(fetch YBOT of LINES)) while (AND LINE (IGREATERP (fetch YBOT of LINE)								       (fetch WBOTTOM of TEXTOBJ)))	   do                                                (* Find the lowest line above screen bottom, and put it 							     in OLINE.)	      (SETQ OLINE LINE)	      (SETQ LINE (fetch NEXTLINE of LINE))	   finally (RETURN OLINE)))      (T NIL])(\TEDIT.FIXDELSEL  [LAMBDA (SELTOFIX TEXTOBJ CH#1 CH#LIM DCH)                 (* jds "12-JUL-83 13:55")                                                             (* Fix up a SELTOFIX after deletion inside that textobj)                                                             (* Only if the Selection is set, and is in THIS textobj)    (COND      ((AND (fetch SET of SELTOFIX)	    (EQ TEXTOBJ (fetch \TEXTOBJ of SELTOFIX)))	(COND	  ((IGREATERP (fetch CH# of SELTOFIX)		      CH#LIM)                                (* The selection is after the deleted text.							     Just move it forward)	    (replace CH# of SELTOFIX with (IDIFFERENCE (fetch CH# of SELTOFIX)						       DCH))	    (replace CHLIM of SELTOFIX with (IDIFFERENCE (fetch CHLIM of SELTOFIX)							 DCH)))	  ((IGEQ (fetch CHLIM of SELTOFIX)		 CH#1)                                       (* It overlaps, at least partially.)	    (COND	      ((IGEQ (fetch CH# of SELTOFIX)		     CH#1)                                   (* If the start of the selection was inside the deleted 							     area, it now starts where the deletion left off.)		(replace CH# of SELTOFIX with CH#1)))	    (replace CHLIM of SELTOFIX with (IMAX CH#1 (IDIFFERENCE (fetch CHLIM of SELTOFIX)								    DCH)))	    (replace DCH of SELTOFIX with (COND					    ((IEQP (fetch CHLIM of SELTOFIX)						   CH#1)					      0)					    (T (ADD1 (IDIFFERENCE (fetch CHLIM of SELTOFIX)								  (fetch CH# of SELTOFIX])(\TEDIT.FIXSELS  [LAMBDA (TEXTOBJ EXCEPT)                                   (* jds " 3-AUG-83 13:05")                                                             (* Fixes all the sels for a given textobj.)    (for SELN in (LIST (fetch SEL of TEXTOBJ)		       (fetch SHIFTEDSEL of TEXTOBJ)		       (fetch MOVESEL of TEXTOBJ)		       (fetch DELETESEL of TEXTOBJ))       when (NEQ SELN EXCEPT) do (AND (fetch SET of SELN)				      (\FIXSEL SELN TEXTOBJ])(\TEDIT.FONTCOPY  [LAMBDA (FONT NEWSPECS)                                    (* jds " 5-JUN-83 16:25")                                                             (* Cloak FONTCOPY in protection for the user from an 							     unavailable font.)    (COND      [(CAR (NLSETQ (FONTCOPY FONT NEWSPECS]      (T (printout PROMPTWINDOW "Can't find font." T)	 FONT])(\TEDIT.FOREIGN.COPY?  [LAMBDA (SEL)                                              (* jds "17-AUG-83 14:00")          (* IF the current process's window isn't a TEdit window, do a "Copy" by BKSYSBUFing the selected text.	  Then turn off all the various indicators.)    (PROG (PROCW TEXTOBJ)          (COND	    ([OR [NOT (AND (SETQ PROCW (PROCESS.WINDOW (TTY.PROCESS)))			   (SETQ TEXTOBJ (WINDOWPROP PROCW (QUOTE TEXTOBJ]		 (AND PROCW TEXTOBJ (OR (fetch TXTREADONLY of TEXTOBJ)					(fetch EDITOPACTIVE of TEXTOBJ]                                                             (* OK -- receiver isn't TEdit.							     Do it the hard way.)	      (\SETUPGETCH (fetch CH# of SEL)			   (fetch \TEXTOBJ of SEL))	      [for I from 1 to (fetch DCH of SEL)		 do (BKSYSBUF (CHARACTER (\BIN (fetch STREAMHINT of (fetch \TEXTOBJ of SEL]	      (\SHOWSEL SEL NIL NIL)	      (SETQ TEDIT.COPY.PENDING NIL])(\TEDIT.FORMATTEDP1  [LAMBDA (FILE LEN)                                         (* jds "13-JUL-83 15:05")                                                             (* Checks for a version-1 formatted file)          (* Returns NIL if it isn't a formatted file, or the # of pieces needed if it is; leaves file at start of text or 	  of piece descriptions, resp.)    (SETQ LEN (OR LEN (GETEOFPTR FILE)))    (PROG (DESCPTR NPIECES PASSWORD)          (COND	    ((ILEQ LEN 8)                                    (* Too short to be formatted.)	      (RETURN NIL))	    (T (SETFILEPTR FILE (IDIFFERENCE LEN 8))         (* Move to start of FILEPTR to descriptions)	       (SETQ DESCPTR (\DWIN FILE))                   (* Read the file pos of the descriptions)	       (SETQ NPIECES (\WIN FILE))	       (SETQ PASSWORD (\WIN FILE))	       (COND		 ((IEQP PASSWORD 31415)		   (SETFILEPTR FILE DESCPTR)		   (RETURN NPIECES))		 (T (SETFILEPTR FILE 0)		    (RETURN NIL])(\TEDIT.NEWREGIONFN  [LAMBDA (FIXEDPOINT MOVINGPOINT WINDOW)                    (* jds "24-FEB-83 17:43")          (* This function is called whenever a new region for the window is needed. It constrains the size of the window so	  that the menu and/or titles will fit)    (COND      ((NULL MOVINGPOINT)                                    (* This is true only the first time the function is 							     called)	FIXEDPOINT)      (T (PROG (#OFMENUITEMS MENUWIDTH XDELTA YDELTA)          (* The NEWREGIONFNARG can be either a window or a list consisting of the number of items in the menu and the 	  minimum width of the window neede to hold the menu an titles)	       (SETQ XDELTA (IDIFFERENCE (fetch (POSITION XCOORD) of MOVINGPOINT)					 (fetch (POSITION XCOORD) of FIXEDPOINT)))	       (SETQ YDELTA (IDIFFERENCE (fetch (POSITION YCOORD) of MOVINGPOINT)					 (fetch (POSITION YCOORD) of FIXEDPOINT)))	       [COND		 [(IGEQ XDELTA 0)		   (replace (POSITION XCOORD) of MOVINGPOINT with (IPLUS (fetch (POSITION XCOORD)									    of FIXEDPOINT)									 (IMAX 32 XDELTA]		 (T (replace (POSITION XCOORD) of MOVINGPOINT with (IPLUS (fetch (POSITION XCOORD)									     of FIXEDPOINT)									  (IMIN -32 XDELTA]	       [COND		 [(IGEQ YDELTA 0)		   (replace (POSITION YCOORD) of MOVINGPOINT with (IPLUS (fetch (POSITION YCOORD)									    of FIXEDPOINT)									 (IMAX 32 YDELTA]		 (T (replace (POSITION YCOORD) of MOVINGPOINT with (IPLUS (fetch (POSITION YCOORD)									     of FIXEDPOINT)									  (IMIN -32 YDELTA]	       (RETURN MOVINGPOINT])(\TEDIT.QUIT  [LAMBDA (W)                                                (* jds " 2-AUG-83 15:04")                                                             (* Called by the default TEDIT.DEFAULT.MENUFN to perform							     the QUIT command.)    (PROG ((TEXTOBJ (WINDOWPROP W (QUOTE TEXTOBJ)))	   (QUITFN (WINDOWPROP W (QUOTE TEDIT.QUITFN)))	   QUITFLG)          (COND	    ((AND QUITFN (NEQ QUITFN T)		  (EQ (SETQ QUITFLG (APPLY* QUITFN W (fetch STREAMHINT of TEXTOBJ)					    TEXTOBJ))		      (QUOTE DON'T)))                        (* The user supplied a QUITFN, and it returned "DON'T", 							     so just ignore all this fooferaw and keep editing.)	      (RETURN))	    ([AND (fetch \DIRTY of TEXTOBJ)		  (NEQ QUITFN T)		  (NEQ QUITFLG T)		  (OPENP (fetch TXTFILE of TEXTOBJ))		  (NOT (STRINGP (fetch TXTFILE of TEXTOBJ]   (* If this document has changed, and it's from a file, 							     check with the user to make sure he really wants to do 							     it.)	      (replace EDITFINISHEDFLG of TEXTOBJ with (EVAL.IN.TTY.PROCESS (LIST (QUOTE \TEDIT.QUIT2)										  )									    T)))	    (T                                               (* Go ahead and quit the next time we see the main 							     command loop.)	       (replace EDITFINISHEDFLG of TEXTOBJ with T])(\TEDIT.QUIT2  [LAMBDA (TEXTOBJ)                                          (* jds "22-APR-83 11:10")    (RESETLST (RESETSAVE (TTYDISPLAYSTREAM PROMPTWINDOW))	      (RESETSAVE (CARET T))	      (CLRPROMPT)	      (SELECTQ (ASKUSER NIL NIL 				"This has not been saved since the last change.  Really QUIT?  ")		       (Y T)		       (N NIL)		       (SHOULDNT])(\TEDIT.SET.WINDOW.EXTENT  [LAMBDA (TEXTOBJ)                                          (* jds "10-MAY-83 13:48")                                                             (* Set the window's EXTENT property according to 1st and							     last char on screen.)    (PROG ((WHEIGHT (fetch WTOP of TEXTOBJ))	   (WINDOW (fetch \WINDOW of TEXTOBJ))	   (LINES (fetch LINES of TEXTOBJ))	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   TOPCHAR BOTCHAR PREVLINE EXTHEIGHT EXTBOT)          (OR WINDOW (RETURN))                               (* Do nothing if there's no window to do it in.)          (while (AND LINES (IGEQ (fetch YBOT of LINES)				  WHEIGHT))	     do (SETQ LINES (fetch NEXTLINE of LINES)))          (OR LINES (RETURN))          (SETQ TOPCHAR (fetch CHAR1 of LINES))          (while (AND LINES (IGREATERP (fetch YBOT of LINES)				       (fetch WBOTTOM of TEXTOBJ)))	     do (SETQ PREVLINE LINES)		(SETQ LINES (fetch NEXTLINE of LINES)))          (OR PREVLINE (RETURN))          (SETQ BOTCHAR (IMIN TEXTLEN (fetch CHARLIM of PREVLINE)))          (AND (IEQP BOTCHAR TOPCHAR)	       (RETURN))          (SETQ EXTHEIGHT (IQUOTIENT (ITIMES (IDIFFERENCE WHEIGHT (fetch YBOT of PREVLINE))					     TEXTLEN)				     (IDIFFERENCE BOTCHAR TOPCHAR)))          [SETQ EXTBOT (IDIFFERENCE (fetch YBOT of PREVLINE)				    (IQUOTIENT (ITIMES (IDIFFERENCE WHEIGHT (fetch YBOT of PREVLINE))						       (IDIFFERENCE TEXTLEN BOTCHAR))					       (IDIFFERENCE BOTCHAR TOPCHAR]          (WINDOWPROP WINDOW (QUOTE EXTENT)		      (create REGION			      BOTTOM _ EXTBOT			      HEIGHT _ EXTHEIGHT			      WIDTH _(fetch WRIGHT of TEXTOBJ)			      LEFT _ 0])(\TEDIT.SHOWSELS  [LAMBDA (TEXTOBJ HOW ON)                                   (* jds "22-MAR-83 14:47")                                                             (* Turns all the selections for a given Textobj on or 							     off)    (for SELN in (LIST (fetch SEL of TEXTOBJ)		       (fetch SHIFTEDSEL of TEXTOBJ)		       (fetch MOVESEL of TEXTOBJ)		       (fetch DELETESEL of TEXTOBJ))       do (AND (fetch SET of SELN)	       (\SHOWSEL SELN HOW ON])(\TEDIT.UPDATE.SHOWSEL  [LAMBDA (NSEL OSEL TSTFLG)                                 (* jds " 2-JUN-83 15:43")                                                             (* Update the selection highlighting to reflect the 							     differences between NSEL and OSEL)    (PROG ((TEXTOBJ (fetch \TEXTOBJ of OSEL)))          (PROG ((DS (ffetch DS of TEXTOBJ))		 (SHADE (OR (fetch HOW of OSEL)			    BLACKSHADE))		 (SHADEHEIGHT (OR (fetch HOWHEIGHT of OSEL)				  1))		 (EXCHFLG NIL)		 TSEL LL)	        (replace ONFLG of NSEL with T)               (* Make the new selection think that we've really 							     displayed all its new aspects.)	        [COND		  ((fetch HASCARET of OSEL)                  (* Turn off the caret, if need be)		    (\EDIT.UPCARET (fetch CARET of TEXTOBJ]	        [COND		  ((NEQ (fetch CH# of NSEL)			(fetch CH# of OSEL))                 (* The new selection starts earlier;							     add hilight at the front)		    (COND		      ((ILESSP (fetch CH# of OSEL)			       (fetch CH# of NSEL))          (* Actually, it starts later;							     just exchange the selections)			(SETQ TSEL OSEL)			(SETQ OSEL NSEL)			(SETQ NSEL TSEL)			(SETQ EXCHFLG T)))		    (COND		      ((EQ (fetch L1 of OSEL)			   (fetch L1 of NSEL))               (* The left ends are on the same line.							     Just blacken the space between them)			(BITBLT NIL 0 0 DS (fetch X0 of NSEL)				(fetch Y0 of NSEL)				(IDIFFERENCE (fetch X0 of OSEL)					     (fetch X0 of NSEL))				(IMIN SHADEHEIGHT (fetch LHEIGHT of (fetch L1 of OSEL)))				(QUOTE TEXTURE)				(QUOTE INVERT)				SHADE))		      (T                                     (* They start on different lines;							     blacken the intervening lines.)			 (AND (fetch L1 of NSEL)			      (BITBLT NIL 0 0 DS (fetch X0 of NSEL)				      (fetch Y0 of NSEL)				      (IDIFFERENCE (fetch LXLIM of (fetch L1 of NSEL))						   (fetch X0 of NSEL))				      (IMIN SHADEHEIGHT (fetch LHEIGHT of (fetch L1 of NSEL)))				      (QUOTE TEXTURE)				      (QUOTE INVERT)				      SHADE))			 (SETQ LL (OR (fetch L1 of NSEL)				      (fetch LINES of TEXTOBJ)))			 (AND LL (SETQ LL (fetch NEXTLINE of LL)))			 (while LL until (OR (EQ LL (fetch L1 of OSEL))					     (ILEQ (fetch YBOT of LL)						   (fetch WBOTTOM of TEXTOBJ)))			    do (BITBLT NIL 0 0 DS (fetch LEFTMARGIN of LL)				       (fetch YBOT of LL)				       (IDIFFERENCE (fetch LXLIM of LL)						    (fetch LEFTMARGIN of LL))				       (IMIN SHADEHEIGHT (fetch LHEIGHT of LL))				       (QUOTE TEXTURE)				       (QUOTE INVERT)				       SHADE)			       (SETQ LL (fetch NEXTLINE of LL)))			 (AND LL (IGREATERP (fetch YBOT of LL)					    (fetch WBOTTOM of TEXTOBJ))			      (BITBLT NIL 0 0 DS (fetch LEFTMARGIN of LL)				      (fetch YBOT of LL)				      (IDIFFERENCE (fetch X0 of OSEL)						   (fetch LEFTMARGIN of LL))				      (IMIN SHADEHEIGHT (fetch LHEIGHT of LL))				      (QUOTE TEXTURE)				      (QUOTE INVERT)				      SHADE]	        (COND		  (EXCHFLG                                   (* Put the selections back as they were.)			   (SETQ TSEL OSEL)			   (SETQ OSEL NSEL)			   (SETQ NSEL TSEL)			   (SETQ EXCHFLG NIL)))	        [COND		  ((NEQ (fetch CHLIM of OSEL)			(fetch CHLIM of NSEL))               (* NSEL ends later -- go add hilite at the end)		    (COND		      ((ILESSP (fetch CHLIM of NSEL)			       (fetch CHLIM of OSEL))        (* NO it ends earlier; just switch the selections and go							     ahead as usual)			(SETQ TSEL OSEL)			(SETQ OSEL NSEL)			(SETQ NSEL TSEL)			(SETQ EXCHFLG T)))		    (COND		      ((EQ (fetch LN of OSEL)			   (fetch LN of NSEL))               (* They end on the same line;							     blacken the DX space between them)			(BITBLT NIL 0 0 DS (fetch XLIM of OSEL)				(fetch YLIM of OSEL)				(IDIFFERENCE (fetch XLIM of NSEL)					     (fetch XLIM of OSEL))				(IMIN SHADEHEIGHT (fetch LHEIGHT of (fetch LN of OSEL)))				(QUOTE TEXTURE)				(QUOTE INVERT)				SHADE))		      (T                                     (* They end on different lines;							     blacken intervening lines)			 (AND (fetch L1 of OSEL)			      (BITBLT NIL 0 0 DS (fetch XLIM of OSEL)				      (fetch YLIM of OSEL)				      (IDIFFERENCE (fetch LXLIM of (fetch LN of OSEL))						   (fetch XLIM of OSEL))				      (IMIN SHADEHEIGHT (fetch LHEIGHT of (fetch LN of OSEL)))				      (QUOTE TEXTURE)				      (QUOTE INVERT)				      SHADE))			 (SETQ LL (OR (fetch LN of OSEL)				      (fetch LINES of TEXTOBJ)))			 (AND LL (SETQ LL (fetch NEXTLINE of LL)))			 (while LL until (OR (EQ LL (fetch LN of NSEL))					     (ILEQ (fetch YBOT of LL)						   (fetch WBOTTOM of TEXTOBJ)))			    do (BITBLT NIL 0 0 DS (fetch LEFTMARGIN of LL)				       (fetch YBOT of LL)				       (IDIFFERENCE (fetch LXLIM of LL)						    (fetch LEFTMARGIN of LL))				       (IMIN SHADEHEIGHT (fetch LHEIGHT of LL))				       (QUOTE TEXTURE)				       (QUOTE INVERT)				       SHADE)			       (SETQ LL (fetch NEXTLINE of LL)))			 (AND LL (IGREATERP (fetch YBOT of LL)					    (fetch WBOTTOM of TEXTOBJ))			      (BITBLT NIL 0 0 DS (fetch LEFTMARGIN of LL)				      (fetch YBOT of (fetch LN of NSEL))				      (IDIFFERENCE (fetch XLIM of NSEL)						   (fetch LEFTMARGIN of LL))				      (IMIN SHADEHEIGHT (fetch LHEIGHT of LL))				      (QUOTE TEXTURE)				      (QUOTE INVERT)				      SHADE]	        (COND		  (EXCHFLG                                   (* Put the selections back as they were.)			   (SETQ TSEL OSEL)			   (SETQ OSEL NSEL)			   (SETQ NSEL TSEL)))	        (COND		  ((fetch HASCARET of NSEL)                  (* Now put the caret back up.)		    (COND		      ((EQ (fetch POINT of NSEL)			   (QUOTE LEFT))                     (* Left end of the selection)			(\SETCARET (fetch X0 of NSEL)				   (fetch Y0 of NSEL)				   DS TEXTOBJ))		      (T                                     (* Right end of the selection)			 (\SETCARET (fetch XLIM of NSEL)				    (fetch YLIM of NSEL)				    DS TEXTOBJ])(\TEDIT.WINDOW.SETUP  [LAMBDA (WINDOW TEXTOBJ TEXTSTREAM THISLINE PROPS)         (* jds "16-AUG-83 12:13")                                                             (* Set up the window and TEXTOBJ so they correspond, and							     the window is a TEDIT window.)    (PROG ((SEL (fetch SEL of TEXTOBJ))	   DS PROP)          (OR WINDOW (\ILLEGAL.ARG WINDOW))          (WINDOWPROP WINDOW (QUOTE BUTTONEVENTFN)		      (QUOTE \TEDIT.BUTTONEVENTFN))          (* Set the window up with the right mouse interfaces for							     TEDIT.)          (WINDOWPROP WINDOW (QUOTE RIGHTBUTTONFN)		      (QUOTE \TEDIT.BUTTONEVENTFN))          (WINDOWADDPROP WINDOW (QUOTE RESHAPEFN)			 (QUOTE \EDITRESHAPEFN))          (WINDOWADDPROP WINDOW (QUOTE NEWREGIONFN)			 (QUOTE \TEDIT.NEWREGIONFN))          (WINDOWPROP WINDOW (QUOTE SCROLLFN)		      (QUOTE \EDITSCROLLFN))          (WINDOWPROP WINDOW (QUOTE REPAINTFN)		      (QUOTE \EDITREPAINTFN))          [OR (WINDOWPROP WINDOW (QUOTE TEDIT.TITLEMENUFN))	      (WINDOWPROP WINDOW (QUOTE TEDIT.TITLEMENUFN)			  (OR (LISTGET1 PROPS (QUOTE TITLEMENUFN))			      (QUOTE TEDIT.DEFAULT.MENUFN]          (WINDOWADDPROP WINDOW (QUOTE CLOSEFN)			 (QUOTE TEDIT.DEACTIVATE.WINDOW))          (WINDOWPROP WINDOW (QUOTE WINDOWENTRYFN)		      (QUOTE \TEDIT.PROCIDLEFN))          (PROCESSPROP (THIS.PROCESS)		       (QUOTE TTYEXITFN)		       (QUOTE \TEDIT.PROCEXITFN))          (PROCESSPROP (THIS.PROCESS)		       (QUOTE TTYENTRYFN)		       (QUOTE \TEDIT.PROCENTRYFN))          (WINDOWPROP WINDOW (QUOTE TEXTSTREAM)		      TEXTSTREAM)                            (* Save the text stream for the user to get at via the 							     window.)          (WINDOWPROP WINDOW (QUOTE TEXTOBJ)		      TEXTOBJ)                               (* Give a handle on the TEXTOBJ for the text being 							     edited.)          (WINDOWPROP WINDOW (QUOTE CURSORMOVEDFN)		      (QUOTE TEDIT.CURSORMOVEDFN))          (WINDOWPROP WINDOW (QUOTE CURSOROUTFN)		      (QUOTE TEDIT.CURSOROUTFN))          [replace WINDOWTITLE of TEXTOBJ with (COND						 ((EQUAL (WINDOWPROP WINDOW (QUOTE TITLE))							 "Edit Window [Inactive]")                                                             (* No user title; use ours)						   NIL)						 ((EQUAL (WINDOWPROP WINDOW (QUOTE TITLE))							 "")                                                             (* The window's title is empty, so we can provide one.)						   NIL)						 ((EQUAL (WINDOWPROP WINDOW (QUOTE TITLE))							 "Text Editor Window")						   NIL)						 (T (WINDOWPROP WINDOW (QUOTE TITLE]          (WINDOWPROP WINDOW (QUOTE TITLE)		      (TEDIT.WINDOW.TITLE TEXTOBJ))          [SETQ DS (replace DS of TEXTOBJ with (WINDOWPROP WINDOW (QUOTE DSP]          (replace \SFRightMargin of DS with 32767)          (* So we don't get spurious RETURNs printed out by the 							     system)          (replace \WINDOW of TEXTOBJ with WINDOW)          [COND	    ((SETQ PROP (LISTGET1 PROPS (QUOTE REGION)))     (* The caller wants to set a region.							     Use his)	      (replace WTOP of TEXTOBJ with (fetch TOP of PROP))	      (replace WRIGHT of TEXTOBJ with (fetch RIGHT of PROP))	      (replace WBOTTOM of TEXTOBJ with (fetch BOTTOM of PROP))	      (replace WLEFT of TEXTOBJ with (fetch LEFT of PROP)))	    (T                                               (* Otherwise, default to the whole window)	       (replace WLEFT of TEXTOBJ with 0)	       (replace WBOTTOM of TEXTOBJ with 0)	       (replace WTOP of TEXTOBJ with (fetch HEIGHT of (DSPCLIPPINGREGION NIL DS)))	       (replace WRIGHT of TEXTOBJ with (fetch WIDTH of (DSPCLIPPINGREGION NIL DS]          (WINDOWPROP WINDOW (QUOTE LINES)		      (replace LINES of TEXTOBJ with (\SHOWTEXT TEXTOBJ THISLINE)))                                                             (* Display the text in the window, for later use.)          (AND (SETQ PROP (LISTGET1 PROPS (QUOTE QUITFN)))	       (WINDOWPROP WINDOW (QUOTE TEDIT.QUITFN)			   PROP))                            (* What to do when user QUITs)          (AND (SETQ PROP (LISTGET1 PROPS (QUOTE AFTERQUITFN)))	       (WINDOWPROP WINDOW (QUOTE TEDIT.AFTERQUITFN)			   PROP))                            (* What to do after the QUIT takes effect)          (AND (SETQ PROP (LISTGET1 PROPS (QUOTE LOOPFN)))	       (WINDOWPROP WINDOW (QUOTE TEDIT.LOOPFN)			   PROP))                            (* FN to execute each time thru command loop)          (AND (SETQ PROP (LISTGET1 PROPS (QUOTE CHARFN)))	       (WINDOWPROP WINDOW (QUOTE TEDIT.CHARFN)			   PROP))                            (* FN to execute per character typed.)          (SETQ PROP (LISTGET1 PROPS (QUOTE MENU)))          (* The Command menu, or list of items for it)          (COND	    ((type? MENU PROP)                               (* It's a menu. just use it.)	      (WINDOWPROP WINDOW (QUOTE TEDIT.MENU)			  PROP))	    (PROP                                            (* It's a list of menu items.							     Force a new menu on next middle button.)		  (WINDOWPROP WINDOW (QUOTE TEDIT.MENU.COMMANDS)			      PROP)		  (WINDOWPROP WINDOW (QUOTE TEDIT.MENU)			      NIL)))          (SETQ PROP (LISTGET1 PROPS (QUOTE SEL)))           (* Initial Selection, if any.)          (COND	    ((type? SELECTION PROP)                          (* We came in with an explicit initial sel.							     Set it up.)	      (\COPYSEL PROP SEL)	      (replace SET of SEL with T)	      (replace \TEXTOBJ of SEL with TEXTOBJ)	      (\FIXSEL SEL TEXTOBJ)	      (\SHOWSEL SEL NIL T))	    ((AND (fetch SET of SEL)		  (NOT PROP))                                (* If we came into this with a valid selection, 							     highlight it.)	      (\FIXSEL SEL TEXTOBJ)	      (\SHOWSEL SEL NIL T))	    (T                                               (* Starting without a selection;							     let's start with a point selection before the first 							     character.)	       (replace CH# of SEL with (COND					  ((FIXP PROP))					  (PROP (CAR PROP))					  (1)))	       (replace CHLIM of SEL with (COND					    ((FIXP PROP))					    [PROP (SUB1 (IPLUS (CAR PROP)							       (CADR PROP]					    (1)))	       (replace DCH of SEL with (COND					  ((FIXP PROP)					    0)					  (PROP (CADR PROP))					  (0)))	       (replace DX of SEL with 0)	       (replace POINT of SEL with (QUOTE LEFT))	       (replace SELKIND of SEL with (QUOTE CHAR))	       (replace SET of SEL with T)	       (replace \TEXTOBJ of SEL with TEXTOBJ)	       (\FIXSEL SEL TEXTOBJ)	       (\SHOWSEL SEL NIL T)))          (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ)          (\COPYSEL SEL TEDIT.SELECTION])(\TEDIT.WORD.BOUND  [LAMBDA (PREVCH CH)                                        (* jds "28-APR-83 17:21")    (PROG ((READSA (fetch READSA of TEDIT.WORDBOUND.READTABLE))	   SYN1 SYN2)          (COND	    ((NOT (AND (FIXP PREVCH)		       (FIXP CH)))	      (RETURN T)))          (SETQ SYN1 (\SYNCODE READSA PREVCH))          (SETQ SYN2 (\SYNCODE READSA CH))          (RETURN (NEQ SYN1 SYN2])(\TEDIT.WORDDELETE  [LAMBDA (TEXTOBJ)                                          (* jds " 3-AUG-83 13:04")                                                             (* Delete the word to the left of the caret.)    (PROG ((THISLINE (fetch THISLINE of TEXTOBJ))	   (SEL (fetch SEL of TEXTOBJ))	   (STREAM (fetch STREAMHINT of TEXTOBJ))	   (READSA (fetch READSA of TEDIT.WORDBOUND.READTABLE))	   INSCH# CH CHNO)                                   (* Back word.)          (SETQ INSCH# (SELECTQ (fetch POINT of SEL)				(LEFT (SUB1 (fetch CH# of SEL)))				(RIGHT (fetch CHLIM of SEL))				NIL))                        (* Find the place to delete backward from)          (COND	    ((IGREATERP INSCH# 0)                            (* Don't try to back up past start of file.)	      (\SETUPGETCH INSCH# TEXTOBJ)	      (SETQ CH (\BIN STREAM))	      (for old CHNO from INSCH# to 1 by -1 while (SELECTC (\SYNCODE READSA CH)								  (TEXT.TTC NIL)								  T)		 do (SETQ CH (\GETCHB TEXTOBJ)))             (* Skip over any initial separator characters)	      (for old CHNO from CHNO to 1 by -1 while (SELECTC (\SYNCODE READSA CH)								(TEXT.TTC T)								NIL)		 do (SETQ CH (\GETCHB TEXTOBJ)))             (* Skip over the next group of non-separators 							     (= a "word"))	      (\SHOWSEL SEL NIL NIL)	      [replace CH# of SEL with (COND					 ((ILEQ CHNO 1)					   1)					 (T (IPLUS 2 CHNO]   (* First character to delete)	      (replace CHLIM of SEL with INSCH#)	      (replace DCH of SEL with (IDIFFERENCE INSCH# CHNO))	      (\FIXSEL SEL TEXTOBJ)	      (\SHOWSEL SEL NIL T)	      (\TEDIT.DELETE SEL TEXTOBJ THISLINE])(\TEDIT1  [LAMBDA (TEXT WINDOW UNSPAWNED PROPS)                      (* jds "17-AUG-83 09:52")                                                             (* Does the actual editing work, and re-coercion or 							     process kill when done. Called by TEDIT directly, or 							     ADD.PROCESSed by it.)    (SETQ TEXT (OPENTEXTSTREAM TEXT WINDOW NIL NIL PROPS))   (* Open the text for editing)    (\TEDIT.COMMAND.LOOP (fetch F3 of TEXT))                 (* Run the editing engine)    (CLOSEW WINDOW)    (AND (WINDOWPROP WINDOW (QUOTE TEDIT.AFTERQUITFN))	 (APPLY* (WINDOWPROP WINDOW (QUOTE TEDIT.AFTERQUITFN))		 WINDOW TEXT))                               (* Apply any post-window-close 							     (and post-QUIT) function)    (COND      (UNSPAWNED                                             (* We're not a distinct process: Send back the edited 							     text in some suitable form)		 (COND		   ((NEQ (fetch EDITFINISHEDFLG of (fetch F3 of TEXT))			 T)		     (PROG1 (fetch EDITFINISHEDFLG of (fetch F3 of TEXT))			    (replace EDITFINISHEDFLG of (fetch F3 of TEXT) with NIL)))		   ((STRINGP (fetch TXTFILE of (fetch F3 of TEXT)))		     (COERCETEXTOBJ (fetch F3 of TEXT)				    (QUOTE STRINGP)))		   (T TEXT)))      (T                                                     (* We're a distinct process. Just die)	 (KILL.ME])(\WATOM  [LAMBDA (STREAM ATOM)                                      (* jds "14-JAN-83 15:27")                                                             (* Write an atom's characters in length-contents form.)    (\WOUT STREAM (NCHARS ATOM))    (for CH inatom ATOM do (\BOUT STREAM CH])(\WSTRING  [LAMBDA (STREAM STRING LEN)                                (* jds "14-JAN-83 15:23")                                                             (* Write a string on a file in length-contents form;							     one word for the length, and one byte per character 							     contained.)    (SETQ LEN (OR LEN (NCHARS STRING)))    (\WOUT STREAM LEN)    (for CH instring STRING as I from 1 to LEN do (\BOUT STREAM CH]))(RPAQ BXCARET (CURSORCREATE (READBITMAP) 4 7))(16 16"@@@@""@@@@""@@@@""@@@@""@@@@""@@@@""@@@@""A@@@""CH@@""GL@@""GL@@""LF@@""HB@@""@@@@""@@@@""@@@@")(RPAQ BXHICARET (CURSORCREATE (READBITMAP) 4 7))(16 16"A@@@""A@@@""A@@@""A@@@""A@@@""A@@@""A@@@""A@@@""CH@@""GL@@""FL@@""LF@@""HB@@""@@@@""@@@@""@@@@")(RPAQ TEDIT.LINECURSOR (CURSORCREATE (READBITMAP) 15 15))(16 16"@@@A""@@@C""@@@G""@@@O""@@AO""@@CO""@@GO""@@@O""@@AK""@@AI""@@C@""@@C@""@@F@""@@F@""@@L@""@@L@")(FILESLOAD TEXTOFD)(DECLARE: EVAL@COMPILE (RPAQQ \SCRATCHLEN 64)(RPAQQ SPACE % )(RPAQQ CR %)(RPAQQ COPYSELSHADE 30583)(RPAQQ EDITMOVESHADE -1)(RPAQQ EDITGRAY 32800)(RPAQQ \PieceDescriptorLOOKS 0)(RPAQQ \PieceDescriptorOBJECT 1)(RPAQQ \PieceDescriptorPARA 2)(CONSTANTS (\SCRATCHLEN 64)	   (SPACE (QUOTE % ))	   (CR (QUOTE %))	   (COPYSELSHADE 30583)	   (EDITMOVESHADE -1)	   (EDITGRAY 32800)	   (\PieceDescriptorLOOKS 0)	   (\PieceDescriptorOBJECT 1)	   (\PieceDescriptorPARA 2)))(RPAQ? TEditBluePendingDelete T)(RPAQ? TEDIT.DEFAULT.WINDOW NIL)(RPAQ? TEDIT.DEFAULT.FONT (FONTCREATE (QUOTE GACHA)				      10))(RPAQ? TEDIT.DEFAULT.CHARLOOKS (CHARLOOKS.FROM.FONT TEDIT.DEFAULT.FONT))(RPAQ? TEDIT.DEFAULT.FMTSPEC (create FMTSPEC QUAD _ (QUOTE LEFT)				     1STLEFTMAR _ 0 LEFTMAR _ 0 RIGHTMAR _ 0 LEADBEFORE _ 0 LEADAFTER 				     _ 0 LINELEAD _ 0 TABSPEC _ NIL))(RPAQ TEDIT.SELECTION (create SELECTION))(RPAQ TEDIT.SHIFTEDSELECTION (create SELECTION HOW_COPYSELSHADE HASCARET_NIL))(RPAQ TEDIT.MOVESELECTION (CREATE SELECTION HOW_EDITMOVESHADE HASCARET_NIL HOWHEIGHT_32767))(RPAQ TEDIT.DELETESELECTION (CREATE SELECTION HOW_BLACKSHADE HASCARET_NIL HOWHEIGHT_32767))(RPAQQ TEDIT.COPY.PENDING NIL)(RPAQQ TEDIT.MOVE.PENDING NIL)(RPAQQ TEDIT.DEL.PENDING NIL)(RPAQQ TEDIT.SELPENDING NIL)(RPAQQ TEDIT.BLUEPENDINGDELETE NIL)(RPAQQ TEDIT.KNOWN.FONTS ((Times% Roman (QUOTE TIMESROMAN))			  (Helvetica (QUOTE HELVETICA))			  (Gacha (QUOTE GACHA))			  (Cream (QUOTE CREAM))))(RPAQ TEDIT.FACE.MENU (create MENU ITEMS _ (QUOTE (Bold Italic Bold% Italic Regular))			      CENTERFLG _ T TITLE_ "Face:"))(RPAQ TEDIT.SIZE.MENU (create MENU ITEMS _			      (QUOTE (6 7 8 9 10 11 12 14 18 24 30 36))			      CENTERFLG _ T MENUROWS_4 TITLE_ "Type Size:"))(DECLARE: DOEVAL@COMPILE DONTCOPY(ADDTOVAR GLOBALVARS TEDIT.DEFAULT.WINDOW TEDIT.SELECTION TEDIT.SCRATCHSELECTION TEDIT.MOVESELECTION 	  TEDIT.SHIFTEDSELECTION TEDIT.DELETESELECTION TEDIT.COPY.PENDING TEDIT.MOVE.PENDING 	  TEDIT.DEL.PENDING TEDIT.SELPENDING TEDIT.BLUEPENDINGDELETE TEDIT.CURRENT.FONT 	  TEDIT.CURRENT.CHARLOOKS TEDIT.CURRENT.PARALOOKS TEDIT.KNOWN.FONTS TEDIT.FACE.MENU 	  TEDIT.SIZE.MENU TEDIT.DEFAULT.FONT TEDIT.DEFAULT.CHARLOOKS TEditBluePendingDelete))(RPAQQ TEDITMACROS (\INSERT\TTY\BUFFER \TEDIT.MOUSESTATE))(DECLARE: EVAL@COMPILE (PUTPROPS \INSERT\TTY\BUFFER MACRO [NIL (COND					  ([NOT (ZEROP (SETQ TLEN (fetch (STRINGP OFFST)								     of ISCRSTRING]                                                             (* If there are typed-ahead characters cached, insert 							     them in the text object and clear the cache.)					    (replace (STRINGP OFFST) of ISCRSTRING with 0)					    (replace (STRINGP LENGTH) of ISCRSTRING with \SCRATCHLEN)					    (replace (STRINGP LENGTH) of IPASSSTRING with TLEN)					    (TEDIT.\INSERT IPASSSTRING SEL TEXTOBJ BLANKSEEN CRSEEN)					    (SETQ BLANKSEEN NIL)					    (SETQ CRSEEN NIL])(PUTPROPS \TEDIT.MOUSESTATE MACRO (BUTTON           (* Test to see if only the specified mouse button is down. DOES NOT call GETMOUSESTATE, so the mouse-button info 	  is the same as the last time it WAS called.)					  (SELECTQ (CAR BUTTON)						   (LEFT (QUOTE (IEQP LASTMOUSEBUTTONS 4)))						   (MIDDLE (QUOTE (IEQP LASTMOUSEBUTTONS 1)))						   (RIGHT (QUOTE (IEQP LASTMOUSEBUTTONS 2)))						   (SHOULDNT)))))(* Screen updating utilities)(DEFINEQ(TEDIT.DEACTIVATE.WINDOW  [LAMBDA (W)                                                (* jds "25-APR-83 14:11")                                                             (* Deactivate the various button fns for this window)    (PROG [(TEXTOBJ (WINDOWPROP W (QUOTE TEXTOBJ]          (COND	    ((AND TEXTOBJ (fetch EDITFINISHEDFLG of TEXTOBJ))                                                             (* Only do this if it's a TEdit window, and has been 							     QUIT out of.)	      (OR (fetch WINDOWTITLE of TEXTOBJ)		  (WINDOWPROP W (QUOTE TITLE)			      "Edit Window [Inactive]"))     (* Reset the window's title to a known "inactive" value)	      (WINDOWPROP W (QUOTE TEXTOBJ)			  NIL)                               (* Detach the edit data structures from the window)	      (WINDOWPROP W (QUOTE TEXTSTREAM)			  NIL)	      (WINDOWPROP W (QUOTE LINES)			  NIL)	      (WINDOWPROP W (QUOTE THISLINE)			  NIL)	      (WINDOWPROP W (QUOTE PROCESS.EXITFN)			  NIL)	      (WINDOWPROP W (QUOTE PROCESS.IDLEFN)			  NIL)	      (WINDOWPROP W (QUOTE CURSOROUTFN)			  NIL)	      (WINDOWPROP W (QUOTE CURSORMOVEDFN)			  NIL)	      (WINDOWPROP W (QUOTE BUTTONEVENTFN)			  (QUOTE TOTOPW))                    (* And the button functions)	      (WINDOWPROP W (QUOTE RIGHTBUTTONFN)			  (QUOTE DOWINDOWCOM))	      (WINDOWPROP W (QUOTE SCROLLFN)			  NIL)	      (WINDOWDELPROP W (QUOTE RESHAPEFN)			     (QUOTE \EDITRESHAPEFN))	      (\TEDIT.INTERRUPT.SETUP W T)                   (* Make sure any disarmed interrupts are restored.)	      (replace \WINDOW of TEXTOBJ with NIL)          (* Disconnect the window from the edit data structures 							     as well.)	      ])(\EDITREPAINTFN  [LAMBDA (W)                                                (* jds " 1-JUN-83 10:36")                                                             (* Redisplay the proper text in the window.)    (PROG ((LINES (WINDOWPROP W (QUOTE LINES)))	   (TEXTOBJ (WINDOWPROP W (QUOTE TEXTOBJ)))	   THISLINE LINE WHEIGHT YBOT WWIDTH SEL)          (SETQ WHEIGHT (fetch WTOP of TEXTOBJ))          (SETQ THISLINE (fetch THISLINE of TEXTOBJ))          (SETQ SEL (fetch SEL of TEXTOBJ))          (AND (fetch SET of SEL)	       (\SHOWSEL SEL NIL NIL))                       (* Turn off the selection, ifn there was one.)          (CLEARW W)          (bind (LINE _ LINES) while (AND LINE (IGREATERP (fetch YBOT of LINE)							  (fetch WBOTTOM of TEXTOBJ)))	     do (COND		  ((ILESSP (fetch YBOT of LINE)			   WHEIGHT)		    (\DISPLAYLINE TEXTOBJ LINE)))		(SETQ LINE (fetch NEXTLINE of LINE)))          (AND (fetch SET of SEL)	       (\SHOWSEL SEL NIL T])(\EDITRESHAPEFN  [LAMBDA (W BITS NEWREGION LEFT BOTTOM WIDTH HEIGHT)        (* jds " 3-AUG-83 13:04")                                                             (* Will eventually do the right thing w/r/t text 							     margins. For now, it's a place holder.)    (PROG ((TEXTOBJ (WINDOWPROP W (QUOTE TEXTOBJ)))	   (TEXTSTREAM (WINDOWPROP W (QUOTE TEXTSTREAM)))	   [NEWWHEIGHT (OR HEIGHT (fetch HEIGHT of (DSPCLIPPINGREGION NIL W]	   [NEWWWIDTH (OR WIDTH (fetch WIDTH of (DSPCLIPPINGREGION NIL W]	   (NEWLEFT (OR LEFT 0))	   (NEWBOTTOM (OR BOTTOM 0))	   (CH# 0)	   WHEIGHT FIRSTCH# LINES LINE WWIDTH THISLINE)          (OR TEXTOBJ (RETURN))                              (* If this window has no TEXTOBJ on it yet, just leave.)          (SETQ THISLINE (fetch THISLINE of TEXTOBJ))          (\SHOWSEL (fetch SEL of TEXTOBJ)		    NIL NIL)                                 (* Turn off the selection while we make changes)          (SETQ WHEIGHT (fetch WTOP of TEXTOBJ))             (* Old window height)          (replace WTOP of TEXTOBJ with NEWWHEIGHT)          (* Save new height/width for later use)          (replace WRIGHT of TEXTOBJ with NEWWWIDTH)          (replace WBOTTOM of TEXTOBJ with NEWBOTTOM)          (replace WLEFT of TEXTOBJ with NEWLEFT)          (OR (SETQ LINES (fetch LINES of TEXTOBJ))	      (RETURN))                                      (* If no text has been displayed yet, just leave)          (SETQ LINE LINES)          (while LINE	     do           (* Now hunt for the first line that had been visible, so we can find the CH# that has to appear at the top of the 	  window.)		(COND		  ((ILESSP (fetch YBOT of LINE)			   WHEIGHT)                          (* This line was visible)		    (SETQ FIRSTCH# (fetch CHAR1 of LINE))    (* Note its first character #)		    (RETURN))		  (T (replace YBOT of LINE with NEWWHEIGHT)))		(SETQ LINE (fetch NEXTLINE of LINE)))          (SETQ LINE (\TEDIT.FIND.FIRST.LINE TEXTOBJ NEWWHEIGHT FIRSTCH#))          (COND	    ((NEQ LINE LINES)	      (replace NEXTLINE of LINES with LINE)))        (* Forget the old chain of line descriptors)          (COND	    (LINE                                            (* You can only do this if there IS text on the screen 							     to start with.)		  (replace YBOT of LINE with (IDIFFERENCE NEWWHEIGHT (fetch LHEIGHT of LINE)))                                                             (* Fix the line to appear at the top of the window)		  (replace YBASE of LINE with (IPLUS (fetch YBOT of LINE)						     (fetch DESCENT of LINE)))		  (\DISPLAYLINE TEXTOBJ LINE)                (* Actually display it)		  (\FILLWINDOW (fetch YBOT of LINE)			       LINE TEXTOBJ THISLINE)        (* Fill out the window with more lines, to fill or to 							     EOF)		  ))          (\FIXSEL (fetch SEL of TEXTOBJ)		   TEXTOBJ)                                  (* Fix up the selection to account for the line 							     shuffling)          (\SHOWSEL (fetch SEL of TEXTOBJ)		    NIL T)                                   (* And highlight it)      ])(TEDIT.WINDOW.TITLE  [LAMBDA (TEXTOBJ)                                          (* jds " 5-OCT-82 14:04")                                                             (* Given a text obj, create a title for the window in 							     it.)    (OR (fetch WINDOWTITLE of TEXTOBJ)	(CONCAT "Edit Window for:  " (SELECTQ (TYPENAME (fetch TXTFILE of TEXTOBJ))					      (STRINGP (fetch TXTFILE of TEXTOBJ))					      (STREAM (fetch FULLNAME of (fetch TXTFILE of TEXTOBJ)))					      (ATOMP (fetch TXTFILE of TEXTOBJ))					      (fetch TXTFILE of TEXTOBJ])(TEDIT.DELETELINE  [LAMBDA (LINE TEXTOBJ)                                     (* jds "18-MAR-83 15:53")                                                             (* Remove a complete text line descriptor from the edit 							     window, then move lower lines up over it.)    (PROG ((PREV (fetch PREVLINE of LINE))	   (NEXT (fetch NEXTLINE of LINE)))                  (* Fix up the line-descriptor chain to dis-include line)          (COND	    (PREV (replace NEXTLINE of PREV with NEXT)))          (COND	    (NEXT (replace PREVLINE of NEXT with PREV)))          (\TEDIT.CLOSEUPLINES TEXTOBJ PREV NEXT)            (* And fix up the screen to cover the blank space.)      ])(\DISPLAYLINE  [LAMBDA (TEXTOBJ LINE)                                     (* jds "17-AUG-83 15:47")                                                             (* Display the line of text LINE in the edit window 							     where it belongs.)    (PROG ((CH 0)	   (CHLIST (fetch CHARS of (fetch THISLINE of TEXTOBJ)))	   (WLIST (fetch WIDTHS of (fetch THISLINE of TEXTOBJ)))	   (LOOKS (fetch LOOKS of (fetch THISLINE of TEXTOBJ)))	   (DS (fetch DS of TEXTOBJ))	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   (THISLINE (fetch THISLINE of TEXTOBJ))	   (TERMSA (fetch TXTTERMSA of TEXTOBJ))	   (STREAM (fetch STREAMHINT of TEXTOBJ))	   LOOKSTARTX \PCHARSLEFT \PSTRING \PFILE FONT OFONT OLOOKS XOFFSET CLIPLEFT CLIPRIGHT)          (MOVETO (fetch LEFTMARGIN of LINE)		  (fetch YBASE of LINE)		  DS)          (SETQ XOFFSET (fetch \SFXOFFSET of DS))          (SETQ CLIPLEFT (fetch \SFClippingLeft of DS))          (SETQ CLIPRIGHT (fetch \SFClippingRight of DS))          (BITBLT NIL 0 0 DS 0 (fetch YBOT of LINE)		  (IDIFFERENCE CLIPRIGHT CLIPLEFT)		  (fetch LHEIGHT of LINE)		  (QUOTE TEXTURE)		  (QUOTE REPLACE)		  WHITESHADE)                                (* Clear the space the line will occupy)          (COND	    ((AND (ILEQ (fetch CHAR1 of LINE)			TEXTLEN)		  (IGREATERP (fetch YBOT of LINE)			     (fetch WBOTTOM of TEXTOBJ)))    (* Only display the line if it appears before the end of							     the text!)	      (COND		((AND (NOT (fetch NEW of LINE))		      (fetch CACHE of LINE)		      (IGEQ (fetch BITMAPHEIGHT of (fetch CACHE of LINE))			    (fetch LHEIGHT of LINE))		      (IGEQ (fetch BITMAPWIDTH of (fetch CACHE of LINE))			    (fetch WRIGHT of TEXTOBJ)))      (* There's an image cache -- use it)		  (BITBLT (fetch CACHE of LINE)			  0 0 DS 0 (fetch YBOT of LINE)			  (fetch WRIGHT of TEXTOBJ)			  (fetch LHEIGHT of LINE)			  (QUOTE INPUT)			  (QUOTE REPLACE))		  (RETURN))		((NEQ (fetch DESC of THISLINE)		      LINE)                                  (* No image cache -- re-format and display)		  (\FORMATLINE TEXTOBJ NIL (fetch CHAR1 of LINE)			       THISLINE LINE)))	      (replace NEW of LINE with NIL)	      (replace F1 of STREAM with DS)	      (SETQ OFONT (DSPFONT (fetch CLFONT of (SETQ OLOOKS (\EDITELT LOOKS 0)))				   DS))	      (SETQ LOOKSTARTX (fetch LEFTMARGIN of LINE))	      (bind (LOOKNO _ 1)		    DX		    (TX _(IPLUS XOFFSET (fetch LEFTMARGIN of LINE))) for I from 0		 to (fetch LEN of THISLINE)		 do (SETQ CH (\EDITELT CHLIST I))		    (SETQ DX (\WORDELT WLIST I))		    [SELECTC CH			     (400 (replace \SFXPOSITION of DS with (IDIFFERENCE TX XOFFSET))				  (TEDIT.MODIFYLOOKS LINE LOOKSTARTX DS OLOOKS)				  (DSPFONT (fetch CLFONT of (SETQ OLOOKS (\EDITELT LOOKS LOOKNO)))					   DS)				  (add LOOKNO 1)				  (AND (fetch CLSUB of OLOOKS)				       (RELMOVETO 0 (IMINUS (fetch CLSUB of OLOOKS))						  DS))				  (AND (fetch CLSUPER of OLOOKS)				       (RELMOVETO 0 (fetch CLSUPER of OLOOKS)						  DS))				  (SETQ LOOKSTARTX (IDIFFERENCE TX XOFFSET)))			     (9                              (* TAB: use the width from the cache to decide the right							     formatting.))			     (13                             (* It's a CR)				 NIL)			     (COND			       [(SMALLP CH)				 (COND				   (TERMSA (\DSPPRINTCHAR STREAM CH))				   (T (\TEDIT.BLTCHAR CH DS DX TX]			       (T                            (* CH is an object.)				  (MOVETO (IDIFFERENCE TX XOFFSET)					  (DSPYPOSITION NIL DS)					  DS)				  (APPLY* (fetch DISPLAYFN of (fetch OBJREF of CH))					  CH DS (QUOTE DISPLAY)					  (fetch STREAMHINT of TEXTOBJ]		    (add TX DX)		 finally (replace \SFXPOSITION of DS with (IDIFFERENCE TX XOFFSET)))	      [COND		([NOT (AND (fetch CACHE of LINE)			   (IGEQ (fetch BITMAPHEIGHT of (fetch CACHE of LINE))				 (fetch LHEIGHT of LINE))			   (IGEQ (fetch BITMAPWIDTH of (fetch CACHE of LINE))				 (fetch WRIGHT of TEXTOBJ]		  (replace CACHE of LINE with (BITMAPCREATE (fetch WRIGHT of TEXTOBJ)							    (fetch LHEIGHT of LINE]	      (BITBLT DS 0 (fetch YBOT of LINE)		      (fetch CACHE of LINE)		      0 0 (fetch WRIGHT of TEXTOBJ)		      (fetch LHEIGHT of LINE)		      (QUOTE INPUT)		      (QUOTE REPLACE))	      (DSPFONT OFONT DS])(\EDITSCROLLFN  [LAMBDA (W DX DY)                                          (* jds " 3-AUG-83 13:04")                                                             (* Handle scrolling of the edit window)    (PROG (WHEIGHT (TEXTOBJ (WINDOWPROP W (QUOTE TEXTOBJ)))		   (PRIORCR 0)		   (SELWASON NIL)		   LINES TRUEY TRUEX DS WWIDTH SEL THISLINE (PREVLINE NIL)		   (PRESCROLLFN (WINDOWPROP W (QUOTE TEDIT.PRESCROLLFN)))		   (POSTSCROLLFN (WINDOWPROP W (QUOTE TEDIT.POSTSCROLLFN)))		   THEIGHT TOPLINE RHEIGHT LOWESTY YBOT LINE CH# CHNO CH)          (SETQ THISLINE (fetch THISLINE of TEXTOBJ))          (COND	    ((ZEROP (fetch TEXTLEN of TEXTOBJ))              (* Don't scroll a zero-length file)	      (RETURN)))          (SETQ DS (fetch DS of TEXTOBJ))                    (* Displaystream for the window)          (SETQ WHEIGHT (fetch WTOP of TEXTOBJ))             (* Height of the window)          (SETQ LOWESTY WHEIGHT)                             (* Lowest Y of a line-bottom yet seet)          (SETQ WWIDTH (fetch WRIGHT of TEXTOBJ))            (* Width of the window)          (SETQ LINES (fetch LINES of TEXTOBJ))              (* List of formatted lines)          (AND PRESCROLLFN (DOUSERFNS PRESCROLLFN W))        (* If there's a pre-scroll fn, execute it now.)          (COND	    ((fetch SET of (SETQ SEL (fetch SEL of TEXTOBJ)))                                                             (* Turn off the selection during the scroll.)	      (SETQ SELWASON (fetch ONFLG of SEL))	      (\SHOWSEL SEL NIL NIL)))          (COND	    [(AND (FIXP DY)		  (NOT (ZEROP DY)))                          (* Regular up/down scrolling)	      (SETQ TRUEY (IDIFFERENCE WHEIGHT (IABS DY)))	      (COND		[(ILESSP 0 DY)                               (* Scroll text up)		  (SETQ LINE LINES)		  (while LINE		     do                                      (* Find the line whose top is to move to the top of the 							     window)			[COND			  ((ILESSP (fetch YBOT of LINE)				   TRUEY)			    (RETURN))			  (T (replace YBASE of LINE with (IPLUS (fetch DESCENT of LINE)								(replace YBOT of LINE with WHEIGHT]			(SETQ PREVLINE LINE)			(SETQ LINE (fetch NEXTLINE of LINE)))		  [COND		    (LINE                                    (* There is a line to go to the top)			  (SETQ RHEIGHT (IPLUS (fetch YBASE of LINE)					       (fetch ASCENT of LINE)))                                                             (* Find the Ypos of the top of the line's image)			  (BITBLT DS 0 0 DS 0 (IDIFFERENCE WHEIGHT RHEIGHT)				  WWIDTH RHEIGHT (QUOTE INPUT)				  (QUOTE REPLACE))			  (while (AND LINE (IGREATERP (fetch YBOT of LINE)						      (fetch WBOTTOM of TEXTOBJ)))			     do (replace YBOT of LINE with (IPLUS (fetch YBOT of LINE)								  (IDIFFERENCE WHEIGHT RHEIGHT)))				(replace YBASE of LINE with (IPLUS (fetch YBOT of LINE)								   (fetch DESCENT of LINE)))				(SETQ PREVLINE LINE)				(SETQ LINE (fetch NEXTLINE of LINE]		  (COND		    ((AND LINE (IGREATERP (fetch YBOT of LINE)					  (fetch WBOTTOM of TEXTOBJ)))		      (\FILLWINDOW (fetch YBOT of LINE)				   LINE TEXTOBJ THISLINE))		    (PREVLINE (\FILLWINDOW (fetch YBOT of PREVLINE)					   PREVLINE TEXTOBJ THISLINE]		(T                                           (* Scroll text down in window, adding lines at top to 							     fill.)		   (SETQ PREVLINE (SETQ TOPLINE LINES))      (* Find the top line on the screen:)		   [while TOPLINE do (COND				       ((ILESSP (fetch YBOT of TOPLINE)						WHEIGHT)					 (RETURN))				       (T (SETQ PREVLINE TOPLINE)					  (SETQ TOPLINE (fetch NEXTLINE of TOPLINE]		   [COND		     ((EQ PREVLINE LINES)                    (* There's nothing between us and start of file that's 							     formatted; start by making some.)		       (SETQ PREVLINE (\BACKFORMAT LINES TEXTOBJ THISLINE]                                                             (* Starting with PREVLINE, accumulate LHEIGHTs until we 							     hit top of text or have accumulated enough lines to fill							     the screen)		   (SETQ THEIGHT 0)		   [while (AND (ILESSP THEIGHT (IABS DY))			       (IGEQ (fetch CHAR1 of PREVLINE)				     1))		      do                                     (* Make provision here later for FORMATBACKWARDSing 							     lines to fill in, if need be.)			 (add THEIGHT (fetch LHEIGHT of PREVLINE))			 (SETQ PREVLINE (fetch PREVLINE of PREVLINE))			 (COND			   ((ILESSP (fetch CHAR1 of PREVLINE)				    1)                       (* We need to format some lines above where we are -- go							     do it.)			     (SETQ PREVLINE (\BACKFORMAT LINES TEXTOBJ THISLINE]		   [COND		     ((IGEQ THEIGHT (IABS DY))               (* BACK UP ONE LINE TO GET TO THE ONE WHICH PUSHED US 							     OVER TOP)		       (SETQ PREVLINE (fetch NEXTLINE of PREVLINE))		       (SETQ THEIGHT (IDIFFERENCE THEIGHT (fetch LHEIGHT of PREVLINE]		   (SETQ PREVLINE (fetch NEXTLINE of PREVLINE))                                                             (* Move to the first line to be formatted.-)		   (BITBLT DS 0 THEIGHT DS 0 0 WWIDTH (IDIFFERENCE WHEIGHT THEIGHT)			   (QUOTE INPUT)			   (QUOTE REPLACE))		   (BITBLT NIL 0 0 DS 0 (IDIFFERENCE WHEIGHT THEIGHT)			   WWIDTH THEIGHT (QUOTE TEXTURE)			   (QUOTE REPLACE)			   WHITESHADE)		   (bind (LINE _ TOPLINE) while LINE		      do (COND			   ((IGREATERP (fetch YBOT of LINE)				       (IPLUS (fetch WBOTTOM of TEXTOBJ)					      THEIGHT))      (* This line will be on screen.							     Adjust its YBOT/YBASE)			     (replace YBOT of LINE with (IDIFFERENCE (fetch YBOT of LINE)								     THEIGHT))			     (replace YBASE of LINE with (IDIFFERENCE (fetch YBASE of LINE)								      THEIGHT))			     (SETQ LOWESTY (fetch YBOT of LINE)))			   (T (replace YBOT of LINE with 0)))			 (SETQ LINE (fetch NEXTLINE of LINE)))		   (BITBLT NIL 0 0 DS 0 0 WWIDTH LOWESTY (QUOTE TEXTURE)			   (QUOTE REPLACE)			   WHITESHADE)                       (* Now move the top window line 							     (& successors) down to let the new lines fit.							     Adjust YBOTs as needed.)		   (SETQ YBOT WHEIGHT)		   (while (NEQ PREVLINE TOPLINE)		      do [replace YBOT of PREVLINE with (SETQ YBOT (IDIFFERENCE YBOT										(fetch LHEIGHT										   of PREVLINE]			 (replace YBASE of PREVLINE with (IPLUS (fetch YBOT of PREVLINE)								(fetch DESCENT of PREVLINE)))			 (\DISPLAYLINE TEXTOBJ PREVLINE)			 (SETQ PREVLINE (fetch NEXTLINE of PREVLINE)))                                                             (* Move down lines to be added, adjusting YBOT/YBASE and							     DISPALYLINE-ing them, until the next line to do EQ 							     TOPLINE)		   ]	    ((FLOATP DY)                                     (* Do a thumbing-type scroll)	      (AND (fetch L1 of SEL)		   (replace YBOT of (fetch L1 of SEL) with 0))                                                             (* Make sure it thinks the old selection is off-screen 							     for now)	      (AND (fetch LN of SEL)		   (replace YBOT of (fetch LN of SEL) with 0))	      (SETQ CH# (IMAX (IMIN (SUB1 (fetch TEXTLEN of TEXTOBJ))				    (FIXR (FTIMES (fetch TEXTLEN of TEXTOBJ)						  DY)))			      1))	      (SETQ LINE (\TEDIT.FIND.FIRST.LINE TEXTOBJ WHEIGHT CH#))                                                             (* Find the first line to go in the window)	      (replace YBOT of LINE with (IDIFFERENCE WHEIGHT (fetch LHEIGHT of LINE)))                                                             (* Set it up as the top line.)	      (replace YBASE of LINE with (IPLUS (fetch YBOT of LINE)						 (fetch DESCENT of LINE)))	      (\DISPLAYLINE TEXTOBJ LINE)	      (\FILLWINDOW (fetch YBOT of LINE)			   LINE TEXTOBJ THISLINE)            (* And fill out the window from there.)	      ))          (AND POSTSCROLLFN (DOUSERFNS POSTSCROLLFN W))      (* For user subsystem cleanup)          [COND	    ((fetch SET of SEL)	      (\FIXSEL SEL TEXTOBJ)	      (AND SELWASON (\SHOWSEL SEL NIL T]          (COND	    ((fetch SET of (fetch SHIFTEDSEL of TEXTOBJ))	      (\FIXSEL (fetch SHIFTEDSEL of TEXTOBJ)		       TEXTOBJ)	      (\SHOWSEL (fetch SHIFTEDSEL of TEXTOBJ)			NIL T)))          (COND	    ((fetch SET of (fetch MOVESEL of TEXTOBJ))	      (\FIXSEL (fetch MOVESEL of TEXTOBJ)		       TEXTOBJ)	      (\SHOWSEL (fetch MOVESEL of TEXTOBJ)			NIL T)))          (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ])(\FILLWINDOW  [LAMBDA (YBOT CURLINE TEXTOBJ THISLINE DONTFILLFLG)        (* jds "26-JUL-83 11:03")                                                             (* Fill out TEXTOBJ's window, starting with the line 							     after CURLINE, whose ybottom is YBOT)                                                             (* Return T if any lines are moved up.)                                                             (* DONTFILLFLG => Don't bother printing any new lins at 							     the bottom of the screen.)    (PROG ((DS (fetch DS of TEXTOBJ))	   (LINE (fetch NEXTLINE of CURLINE))	   (CHARLIM (fetch CHARLIM of CURLINE))	   (PREVLINE CURLINE)	   (WHEIGHT (fetch WTOP of TEXTOBJ))	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   (LINES\DELETED NIL)	   (WINDOW (fetch \WINDOW of TEXTOBJ))	   OFLOWFN)          (while (AND LINE (IGEQ (fetch YBOT of LINE)				 WHEIGHT))	     do                                              (* Do not start with a line which is above the top of 							     the screen.)		(SETQ PREVLINE LINE)		(SETQ CHARLIM (fetch CHARLIM of LINE))		(SETQ LINE (fetch NEXTLINE of LINE)))          [repeatwhile (ILESSP CHARLIM TEXTLEN)	     do                                              (* Walk thru the lines below the starting line.)		[COND		  [(AND LINE (IGREATERP (SETQ YBOT (IDIFFERENCE YBOT (fetch LHEIGHT of LINE)))					(fetch WBOTTOM of TEXTOBJ)))                                                             (* If there is a line to display, and space to display 							     it, go ahead.)		    (COND		      [(AND (fetch CACHE of LINE)			    (NOT (fetch NEW of LINE)))       (* It was on the screen; just move it to its new home)			(BITBLT (fetch CACHE of LINE)				0 0 DS 0 YBOT (fetch RIGHTMARGIN of LINE)				(fetch LHEIGHT of LINE)				(QUOTE INPUT)				(QUOTE REPLACE))			(COND			  ((ILESSP (fetch YBOT of LINE)				   YBOT)                     (* IF THE LINE MOVED, THERE WERE DELETIONS.							     SAY SO WHEN WE RETURN.)			    (SETQ LINES\DELETED T)))			(replace YBOT of LINE with YBOT)			(replace YBASE of LINE with (IPLUS YBOT (fetch DESCENT of LINE]		      (T                                     (* The line wasn't on the screen;							     re-display it.)			 (replace YBOT of LINE with YBOT)			 (replace YBASE of LINE with (IPLUS YBOT (fetch DESCENT of LINE)))			 (\DISPLAYLINE TEXTOBJ LINE]		  (LINE                                      (* There is a line, but it won't fit.)			(SETQ YBOT (IPLUS YBOT (fetch LHEIGHT of LINE)))                                                             (* This existing line won't fit.							     Punt out of this, setting YBOT so the screen gets 							     cleared right.)			[COND			  ((SETQ OFLOWFN (WINDOWPROP WINDOW (QUOTE TEDIT.OVERFLOWFN)))                                                             (* Try calling any user-supplied overflow fn, to handle 							     the space overflow)			    (AND (APPLY* OFLOWFN WINDOW TEXTOBJ)				 (RETFROM (QUOTE \FILLWINDOW)					  NIL]			(RETURN))		  (DONTFILLFLG                               (* We are instructed NOT to try filling the screen, so 							     punt out.)			       (RETURN))		  ((OR (ILESSP CHARLIM TEXTLEN)		       (ZEROP TEXTLEN))                      (* No existing lines to display, but there's text left 							     (or the doc is empty and we need a dummy first line))		    (SETQ LINE (\FORMATLINE TEXTOBJ NIL (ADD1 CHARLIM)					    THISLINE))       (* Format the next line)		    (replace PREVLINE of LINE with PREVLINE)                                                             (* Hook it into the chain of line descriptors)		    (replace NEXTLINE of LINE with (fetch NEXTLINE of PREVLINE))		    (replace NEXTLINE of PREVLINE with LINE)		    (COND		      ((IGREATERP (SETQ YBOT (IDIFFERENCE YBOT (fetch LHEIGHT of LINE)))				  (fetch WBOTTOM of TEXTOBJ))                                                             (* If there's room, display the new line)			(replace YBOT of LINE with YBOT)			(replace YBASE of LINE with (IPLUS YBOT (fetch DESCENT of LINE)))			(\DISPLAYLINE TEXTOBJ LINE))		      (T                                     (* Otherwise, we've overflown the window again)			 (SETQ YBOT (IPLUS YBOT (fetch LHEIGHT of LINE)))			 [COND			   ((SETQ OFLOWFN (WINDOWPROP WINDOW (QUOTE TEDIT.OVERFLOWFN)))			     (AND (APPLY* OFLOWFN WINDOW TEXTOBJ)				  (RETFROM (QUOTE \FILLWINDOW)					   NIL]			 (RETURN]		(COND		  (LINE                                      (* Move forward to the next line in the chain, if any)			(SETQ CHARLIM (fetch CHARLIM of LINE))			(SETQ PREVLINE LINE)			(SETQ LINE (fetch NEXTLINE of LINE)))		  (T (SETQ CHARLIM (ADD1 TEXTLEN]          (while LINE	     do                                              (* If there are any existing lines which didn't fit, set							     their YBOTs to 0 so they don't show)		(AND (ILEQ (fetch CHAR1 of LINE)			   TEXTLEN)		     (replace YBOT of LINE with 0))		(SETQ LINE (fetch NEXTLINE of LINE)))          [COND	    ((IGREATERP YBOT (fetch WBOTTOM of TEXTOBJ))     (* If there is space left at the bottom of the window, 							     blank it out.)	      (BITBLT NIL 0 0 DS (fetch WBOTTOM of TEXTOBJ)		      0		      (fetch WRIGHT of TEXTOBJ)		      YBOT		      (QUOTE TEXTURE)		      (QUOTE REPLACE)		      WHITESHADE)	      [COND		((AND PREVLINE (fetch CR\END of PREVLINE)		      (OR (ILESSP (fetch YBOT of PREVLINE)				  WHEIGHT)			  (ILEQ (fetch CHARTOP of PREVLINE)				0))		      (IGEQ (fetch CHARLIM of PREVLINE)			    TEXTLEN)		      (IGEQ (fetch YBOT of PREVLINE)			    (fetch LHEIGHT of PREVLINE)))    (* If the last line ends in a CR, put a dummy line below							     it.)		  (SETQ PREVLINE (replace NEXTLINE of PREVLINE				    with (create LINEDESCRIPTOR						 CHAR1 _(ADD1 TEXTLEN)						 CHARLIM _(ADD1 TEXTLEN)						 RIGHTMARGIN _(fetch RIGHTMARGIN of PREVLINE)						 LEFTMARGIN _(IPLUS 8 (fetch WLEFT of TEXTOBJ))						 LXLIM _ 8						 SPACELEFT _(IDIFFERENCE (fetch RIGHTMARGIN									    of PREVLINE)									 8)						 FIRSTSPACE _ -1						 LHEIGHT _(fetch LHEIGHT of PREVLINE)						 ASCENT _(fetch ASCENT of PREVLINE)						 DESCENT _(fetch DESCENT of PREVLINE)						 YBOT _(IDIFFERENCE (fetch YBOT of PREVLINE)								    (fetch LHEIGHT of PREVLINE))						 YBASE _(IDIFFERENCE (fetch YBOT of PREVLINE)								     (fetch ASCENT of PREVLINE))						 PREVLINE _ PREVLINE						 NEXTLINE _(fetch NEXTLINE of PREVLINE)						 CHARTOP _(ADD1 TEXTLEN)						 LFMTSPEC _(fetch LFMTSPEC of PREVLINE]	      (COND		((IGEQ (fetch CHARLIM of PREVLINE)		       TEXTLEN)                              (* This line lies at end of text, so chop off any 							     following lines.)		  (replace NEXTLINE of PREVLINE with NIL]          (RETURN LINES\DELETED])(\FIXCHANGEDPART  [LAMBDA (TEXTOBJ THISLINE)                                 (* jds " 3-AUG-83 19:11")                                                             (* Reformat lines as needed after a change.							     Return the last line changed, or NIL if there's no need 							     for a \FILLWINDOW.)    (PROG ((DS (fetch DS of TEXTOBJ))	   (LINES (fetch LINES of TEXTOBJ))	   YBOT	   (FORMATDONE NIL)	   LIMITCHANGED WASDIRTY CHARLIM OCHLIM OLHEIGHT PREVLINE (FOUND NIL)	   (TEXTLEN (fetch TEXTLEN of TEXTOBJ))	   (WINDOW (fetch \WINDOW of TEXTOBJ))	   (WHEIGHT (fetch WTOP of TEXTOBJ))	   (WBOT (fetch WBOTTOM of TEXTOBJ))	   DY OFLOWFN)      MAINLOOP          [while LINES	     do                                              (* Find the first line descriptor of a DIRTY line.)		(SETQ YBOT (fetch YBOT of LINES))		(COND		  ((ILEQ YBOT WBOT)                          (* We've run off the bottom of the screen.)		    (replace NEXTLINE of (fetch PREVLINE of LINES) with NIL)                                                             (* There may be unfixed changes there, so chop off any 							     further lines.)		    (SETQ LINES NIL))		  ((fetch DIRTY of LINES)		    (RETURN))		  (T (SETQ LINES (fetch NEXTLINE of LINES]          [COND	    ((AND LINES (ILESSP (fetch CHARTOP of LINES)				0))                          (* If we hit on the dummy first line, skip over it -- 							     never try to reformat it.)	      (SETQ LINES (fetch NEXTLINE of LINES]          [COND	    ((NOT LINES)                                     (* No changed lines found -- clear below last line on 							     screen)	      (BITBLT NIL 0 0 DS (fetch WLEFT of TEXTOBJ)		      (fetch WBOTTOM of TEXTOBJ)		      (IDIFFERENCE (fetch WRIGHT of TEXTOBJ)				   (fetch WLEFT of TEXTOBJ))		      (IDIFFERENCE YBOT (fetch WBOTTOM of TEXTOBJ))		      (QUOTE TEXTURE)		      (QUOTE REPLACE)		      WHITESHADE)	      (RETURN (AND (ZEROP TEXTLEN)			   (fetch LINES of TEXTOBJ]          (* We found no changes; return a NIL last-line-changed)          (SETQ YBOT (fetch YBOT of (fetch PREVLINE of LINES)))                                                             (* Y bottom of the first line to reformat.)          (SETQ CHARLIM (SUB1 (fetch CHAR1 of LINES)))       (* SUB1 of char to start formatting with)          (while (AND LINES (IGREATERP YBOT (fetch WBOTTOM of TEXTOBJ)))	     do                                              (* Fix things up)		(SETQ OCHLIM (fetch CHARLIM of LINES))       (* This line's old CHLIM, for seeing if it changes)		(SETQ OLHEIGHT (fetch LHEIGHT of LINES))     (* This line's old height, for seeing if it changes.)		(\FORMATLINE TEXTOBJ NIL (ADD1 CHARLIM)			     THISLINE LINES)                 (* Format a line, starting 1 past the end of the prior 							     line)		[COND		  ((IGEQ (fetch YBOT of LINES)			 WHEIGHT)                            (* Do nothing until we see a change to a line which is 							     on-screen.)		    )		  ((IGREATERP (SETQ YBOT (IDIFFERENCE YBOT (fetch LHEIGHT of LINES)))			      (fetch WBOTTOM of TEXTOBJ))    (* If there's space left on the screen for this line,)		    [COND		      ([NOT (ZEROP (SETQ DY (IDIFFERENCE OLHEIGHT (fetch LHEIGHT of LINES]                                                             (* This line's total height changed -- must move the 							     rest of the window, and adjust YBOT/BASEs.)			(bind (LL _(fetch NEXTLINE of LINES))			   while (AND LL (IGREATERP (fetch YBOT of LL)						    (fetch WBOTTOM of TEXTOBJ)))			   do (COND				((ILEQ (replace YBOT of LL with (IPLUS (fetch YBOT of LL)								       DY))				       (fetch WBOTTOM of TEXTOBJ))                                                             (* This line moved below the bottom of the screen)				  (BITBLT NIL 0 0 WINDOW (fetch WLEFT of TEXTOBJ)					  (fetch YBOT of LL)					  (fetch WRIGHT of TEXTOBJ)					  (fetch LHEIGHT of LL)					  (QUOTE TEXTURE)					  (QUOTE REPLACE)					  WHITESHADE)))			      (replace YBASE of LL with (IPLUS (fetch YBASE of LL)							       DY))			      (SETQ LL (fetch NEXTLINE of LL)))			(COND			  ((IGREATERP DY 0)                  (* The line is shorter; move the rest up.)			    (BITBLT WINDOW 0 0 WINDOW 0 DY (fetch WRIGHT of TEXTOBJ)				    YBOT				    (QUOTE INPUT)				    (QUOTE REPLACE)))			  (T                                 (* The line is taller; move the rest down.)			     (BITBLT WINDOW 0 (IMINUS DY)				     WINDOW 0 0 (fetch WRIGHT of TEXTOBJ)				     YBOT				     (QUOTE INPUT)				     (QUOTE REPLACE]		    (replace YBOT of LINES with YBOT)        (* Display it where we are now)		    (replace YBASE of LINES with (IPLUS YBOT (fetch DESCENT of LINES)))                                                             (* Base line for the characters to sit on)		    (\DISPLAYLINE TEXTOBJ LINES)             (* Display it)		    )		  (T (AND (SETQ OFLOWFN (WINDOWPROP WINDOW (QUOTE TEDIT.OVERFLOWFN)))			  (APPLY* OFLOWFN WINDOW TEXTOBJ)			  (RETFROM (QUOTE \FIXCHANGEDPART)				   NIL]		(COND		  ((IGEQ (SETQ CHARLIM (fetch CHARLIM of LINES))			 TEXTLEN)                            (* We've run off the end of the text.)		    (SETQ PREVLINE LINES)		    (replace NEXTLINE of PREVLINE with NIL)		    (RETURN))		  ([AND (IEQP OCHLIM CHARLIM)			(IEQP OLHEIGHT (fetch LHEIGHT of LINES))			(NOT (AND (fetch NEXTLINE of LINES)				  (fetch DIRTY of (fetch NEXTLINE of LINES]                                                             (* There was no change in this line, so we're done.)		    (SETQ PREVLINE LINES)                    (* Show this line as the last one changed)		    (GO MAINLOOP)                            (* Go look for more changes to fix up)		    ))		(SETQ PREVLINE LINES)                        (* Move to the next line)		(SETQ LINES (fetch NEXTLINE of LINES)))          (COND	    ((ILEQ YBOT (fetch WBOTTOM of TEXTOBJ))          (* If we made changes all the way to the bottom of the 							     screen,)	      (AND PREVLINE (replace NEXTLINE of PREVLINE with NIL))                                                             (* Discard any remaining lines below that, to force 							     reformatting.)	      (RETURN)                                       (* This prevents loss of changes which go past end of 							     screen.)	      )	    (T (RETURN PREVLINE])(\FORMATLINE  [LAMBDA (TEXTOBJ FMTSPEC CH#1 THISLINE OLINE 1STLN)        (* jds "13-JUL-83 15:31")                                                             (* Given a starting place, format the next line of text.							     Return the LINEDESCRIPTOR; reusing OLINE if it's given.)    (PROG (TX [LINE (OR OLINE (create LINEDESCRIPTOR				      RIGHTMARGIN _(fetch WRIGHT of TEXTOBJ]	      DX	      (CH#B CH#1)	      TXB CH (FORCEEND NIL)	      (GATHERBLANK T)	      (T1SPACE NIL)	      TXB1 DXB WIDTH LOOK#B FONT (TLEN 0)	      (TEXTLEN (ffetch TEXTLEN of TEXTOBJ))	      (THISLINE (fetch THISLINE of TEXTOBJ))	      FONTWIDTHS	      (CHNO CH#1)	      (LOOKNO 0)	      (ASCENT 0)	      (DESCENT 0)	      (PREVSP 0)	      (#BLANKS 0)	      TERMSA CLOOKS TEXTSTREAM CHLIST WLIST LOOKS)          (SETQ CHLIST (fetch CHARS of THISLINE))          (SETQ WLIST (fetch WIDTHS of THISLINE))          (SETQ LOOKS (fetch LOOKS of THISLINE))          (SETQ TEXTSTREAM (fetch STREAMHINT of TEXTOBJ))          (SETQ TERMSA (fetch TXTTERMSA of TEXTOBJ))          (replace EXTRASTREAMOP of TEXTSTREAM with (QUOTE \TEDIT.LOOKS.UPDATE))          (freplace CHARLIM of LINE with TEXTLEN)            (* Force each new line to find its true CHARLIM.)          (freplace NEW of LINE with T)                      (* Mark this line as not yet displayed)          (freplace DIRTY of LINE with NIL)                  (* And as unchanged since the last formatting.)          (freplace CHAR1 of LINE with CH#1)          (freplace CR\END of LINE with NIL)                 (* Assume we won't see a CR.)          [COND	    [(AND (ILEQ CH#1 TEXTLEN)		  (NOT (ZEROP TEXTLEN)))                     (* Only continue if there's really text we can format.)	      (\SETUPGETCH CH#1 TEXTOBJ)                     (* Starting place)	      (SETQ FONT TEDIT.CURRENT.FONT)                 (* And starting character looks)	      (SETQ CLOOKS TEDIT.CURRENT.CHARLOOKS)	      (SETQ ASCENT (IMAX ASCENT (fetch \SFAscent of FONT)))	      (SETQ DESCENT (IMAX DESCENT (fetch \SFDescent of FONT)))	      (SETQ FONTWIDTHS (fetch \SFWidths of FONT))	      (\EDITSETA LOOKS 0 TEDIT.CURRENT.CHARLOOKS)    (* Save looks in the line cache)	      [OR FMTSPEC (SETQ FMTSPEC (OR (fetch PPARALOOKS of (fetch F5 of TEXTSTREAM))					    (fetch FMTSPEC of TEXTOBJ]                                                             (* Get the paragraph looks)	      [SETQ 1STLN (AND (fetch F5 of TEXTSTREAM)			       (fetch PREVPIECE of (fetch F5 of TEXTSTREAM))			       (fetch PPARALAST of (fetch PREVPIECE of (fetch F5 of TEXTSTREAM)))			       (IEQP (fetch FW7 of TEXTSTREAM)				     (fetch COFFSET of TEXTSTREAM))			       (IEQP (fetch FW6 of TEXTSTREAM)				     (fetch CPAGE of TEXTSTREAM]                                                             (* Are we on the first line of a paragraph?)	      [SETQ TX (SETQ TXB (replace LEFTMARGIN of LINE				    with (IPLUS (fetch WLEFT of TEXTOBJ)						8						(COND						  (1STLN (fetch 1STLEFTMAR of FMTSPEC))						  (T (fetch LEFTMAR of FMTSPEC]                                                             (* Set the left margin accordingly)	      [replace RIGHTMARGIN of LINE with (SETQ WIDTH						  (COND						    ([AND (fetch FORMATTEDP of TEXTOBJ)							  (NOT (ZEROP (fetch RIGHTMAR of FMTSPEC]						      (IPLUS (fetch WLEFT of TEXTOBJ)							     (fetch RIGHTMAR of FMTSPEC)))						    (T (IDIFFERENCE (fetch WRIGHT of TEXTOBJ)								    8]                                                             (* RIGHTMAR = 0 => follow the window's width.)	      (SETQ TXB1 WIDTH)	      [for old TLEN from 0 to 254 as old CHNO from CH#1 to TEXTLEN		 do                                          (* The character loop)		    (SETQ CH (\BIN TEXTSTREAM))              (* Get the next character for the line.)		    [SETQ DX (COND			[(SMALLP CH)                         (* CH is really a character)			  (COND			    (TERMSA (TEDIT.CHARWIDTH CH TEDIT.CURRENT.FONT TERMSA))			    (T (\GETWIDTH FONTWIDTHS CH]			(T                                   (* CH is an object)			   (PROG1 [OR (fetch XSIZE of (fetch OBJREF of CH))				      (PROGN (APPLY* (fetch SIZEFN of (fetch OBJREF of CH))						     CH)					     (fetch XSIZE of (fetch OBJREF of CH]				  [SETQ ASCENT (IMAX ASCENT (fetch YASC of (fetch OBJREF									      of CH]				  (SETQ DESCENT (IMAX DESCENT (fetch YDESC								 of (fetch OBJREF of CH]                                                             (* Get CH's X width.)		    (SELCHARQ CH			      (SPACE                         (* CH is a <Space>. Remember it, in case we need to 							     break the line.)				     (COND				       (GATHERBLANK (SETQ TXB1 TX)						    (SETQ GATHERBLANK NIL)))				     (SETQ CH#B CHNO)				     (\EDITSETA CHLIST TLEN PREVSP)				     (\WORDSETA WLIST TLEN DX)				     (SETQ PREVSP (ADD1 TLEN))				     (OR T1SPACE (SETQ T1SPACE TX))				     (SETQ TX (IPLUS TX DX))				     (SETQ TXB TX)				     (SETQ DXB DX)				     (SETQ LOOK#B LOOKNO)				     (add #BLANKS 1))			      (CR                            (* Ch is a <Return>. Force an end to the line.)				  (freplace CHARLIM of LINE with CHNO)				  (SETQ FORCEEND T)				  (\EDITSETA CHLIST TLEN 13)				  (\WORDSETA WLIST TLEN (SETQ DX (IMAX DX 6)))				  (SETQ TXB1 TX)				  (OR T1SPACE (SETQ T1SPACE TX))				  (replace CR\END of LINE with T)				  (SETQ TX (IPLUS TX DX))				  (RETURN))			      (TAB                           (* Try to be reasonable with tabs.							     This will create trouble when doing fast-case 							     insert/delete, but Pah! for now.)				   (COND				     (GATHERBLANK (SETQ TXB1 TX)						  (SETQ GATHERBLANK NIL)))				   (SETQ CH#B CHNO)				   (SETQ DX 36)              (* For now, make all TABs be 1/2in spaces.)				   (\EDITSETA CHLIST TLEN PREVSP)				   (\WORDSETA WLIST TLEN DX)				   (SETQ PREVSP (ADD1 TLEN))				   (OR T1SPACE (SETQ T1SPACE TX))				   (SETQ TX (IPLUS TX DX))				   (SETQ TXB TX)				   (SETQ DXB DX)				   (SETQ LOOK#B LOOKNO)				   (add #BLANKS 1))			      (PROGN (SETQ GATHERBLANK T)				     (COND				       ((AND (IGREATERP (SETQ TX (IPLUS TX DX))							WIDTH)					     T1SPACE)        (* We're past the right margin;							     stop formatting at the last blank.)					 (SETQ FORCEEND T)					 (freplace CHARLIM of LINE with CH#B)					 (SETQ TX TXB)					 (SETQ DX DXB)					 (SETQ LOOKNO LOOK#B)					 (RETURN))				       (T                    (* We're not past the right margin yet, or we haven't 							     yet seen a place to do the break.)					  (\EDITSETA CHLIST TLEN CH)					  (\WORDSETA WLIST TLEN DX]	      (COND		((AND (IEQP TLEN 255)		      (ILESSP CHNO TEXTLEN))                 (* This line is too long for us to format??)		  (CLRPROMPT)		  (printout PROMPTWINDOW "Line too long to format: " LINE)		  (printout PROMPTWINDOW T "First Ch#:  " (fetch CHAR1 of LINE)			    T "Text:  ")		  (for I from 0 to 15 do (PRIN1 (CHARACTER (\EDITELT CHLIST I))						PROMPTWINDOW))		  (printout PROMPTWINDOW "..." T]	    (T                                               (* No text to go in this line;							     set Ascent/Descent to the default font from the window.)	       (SETQ ASCENT (FONTPROP (DSPFONT NIL (fetch DS of TEXTOBJ))				      (QUOTE ASCENT))		 (SETQ DESCENT (FONTPROP (DSPFONT NIL (fetch DS of TEXTOBJ))					 (QUOTE DESCENT)))		 (SETQ FMTSPEC (OR FMTSPEC (fetch FMTSPEC of TEXTOBJ)))		 [SETQ 1STLN (AND (fetch F5 of TEXTSTREAM)				  (fetch PREVPIECE of (fetch F5 of TEXTSTREAM))				  (fetch PPARALAST of (fetch PREVPIECE of (fetch F5 of TEXTSTREAM)))				  (IEQP (fetch FW6 of TEXTSTREAM)					(fetch CPAGE of TEXTSTREAM))				  (IEQP (fetch FW7 of TEXTSTREAM)					(fetch COFFSET of TEXTSTREAM]		 [SETQ TX (SETQ TXB (replace LEFTMARGIN of LINE				       with (IPLUS (fetch WLEFT of TEXTOBJ)						   8						   (COND						     (1STLN (fetch 1STLEFTMAR of FMTSPEC))						     (T (fetch LEFTMAR of FMTSPEC]		 [replace RIGHTMARGIN of LINE with (SETQ WIDTH						     (COND						       ([AND (fetch FORMATTEDP of TEXTOBJ)							     (NOT (ZEROP (fetch RIGHTMAR									    of FMTSPEC]							 (fetch RIGHTMAR of FMTSPEC))						       (T (IDIFFERENCE (fetch WRIGHT of TEXTOBJ)								       8]		 (SETQ TXB1 WIDTH]          (COND	    ((ZEROP (freplace LHEIGHT of LINE with (IPLUS ASCENT DESCENT)))	      (replace LHEIGHT of LINE with 12)))            (* Line's height (or 12 for an empty line))          (replace ASCENT of LINE with ASCENT)          (replace DESCENT of LINE with DESCENT)          (freplace CHARTOP of LINE with CHNO)          (COND	    (FORCEEND NIL)	    (T (SETQ CHNO (SUB1 CHNO))	       (SETQ TLEN (SUB1 TLEN))	       (SETQ TXB1 TX)))                              (* If we ran off the end of the text, then keep true 							     space left on the line.)          (freplace LXLIM of LINE with TX)          (freplace SPACELEFT of LINE with (IDIFFERENCE WIDTH TXB1))          (freplace DESC of THISLINE with LINE)          [freplace LEN of THISLINE	     with (IMIN 254 (COND			  ((ILESSP TEXTLEN CH#1)			    -1)			  (T (IPLUS LOOKNO (IDIFFERENCE (IMIN (fetch CHARLIM of LINE)							      TEXTLEN)							(fetch CHAR1 of LINE]          (\DOFORMATTING TEXTOBJ LINE FMTSPEC THISLINE #BLANKS PREVSP 1STLN)          (replace LFMTSPEC of LINE with FMTSPEC)          (freplace FIRSTSPACE of LINE with (OR T1SPACE TX))          (replace EXTRASTREAMOP of TEXTSTREAM with NIL)          (RETURN LINE])(\PULLTEXT  [LAMBDA (LINE DX CH1 THISLINE TEXTOBJ)                     (* jds " 3-AUG-83 19:16")                                                             (* Reset start of line to ch1, and pull dx off the 							     front.)    (COND      ((ILESSP DX 0)	(ERROR "MOVING TEXT DOWN AFTER A DELETE??!" DX)))    (PROG ((OXLIM (fetch LXLIM of LINE))	   (OCHLIM (fetch CHARLIM of LINE))	   (OSPACE (IPLUS (fetch SPACELEFT of LINE)			  DX))	   NLINE NDX NL (DEL NIL)	   (DS (fetch DS of TEXTOBJ))	   (OCH1 (fetch CHAR1 of LINE)))          (replace DIRTY of LINE with NIL)          (replace SPACELEFT of LINE with OSPACE)            (* There's going to be more space on this line when 							     we're done.)          (replace CHAR1 of LINE with CH1)          (BITBLT DS (IPLUS (fetch LEFTMARGIN of LINE)			    DX)		  (fetch YBOT of LINE)		  DS		  (fetch LEFTMARGIN of LINE)		  (fetch YBOT of LINE)		  (fetch RIGHTMARGIN of LINE)		  (fetch LHEIGHT of LINE)		  (QUOTE INPUT)		  (QUOTE REPLACE))                           (* Move remaining text over)          (SETQ OXLIM (IDIFFERENCE OXLIM DX))                (* And shorten the line accordingly)          (BITBLT NIL 0 0 DS (IDIFFERENCE (fetch RIGHTMARGIN of LINE)					  OSPACE)		  (fetch YBOT of LINE)		  (fetch RIGHTMARGIN of LINE)		  (fetch LHEIGHT of LINE)		  (QUOTE TEXTURE)		  (QUOTE REPLACE)		  WHITESHADE)                                (* Blank the newly-cleared section of the line's image)          (COND	    ((IEQP OXLIM (fetch LEFTMARGIN of LINE))	      (TEDIT.DELETELINE LINE TEXTOBJ)                (* The call to \PULLTEXT emptied this line completely.							     Throw it away.)	      (SETQ DEL T))	    [T                                               (* Need to check for flow-in from the next line.)	       (\FORMATLINE TEXTOBJ NIL CH1 THISLINE LINE)	       (OR LINE:CACHE (LINE:CACHE_(BITMAPCREATE TEXTOBJ:WRIGHT LINE:LHEIGHT)))	       (COND		 ((IEQP OXLIM (fetch LXLIM of LINE))         (* No text moved; just update the line's cached image)		   (BITBLT DS 0 (fetch YBOT of LINE)			   (fetch CACHE of LINE)			   0 0 (fetch WRIGHT of TEXTOBJ)			   (fetch LHEIGHT of LINE)			   (QUOTE INPUT)			   (QUOTE REPLACE)))		 (T                                          (* The line length changed from what we'd expected.							     Some text got moved up from below.)		    (SETQ NDX (IDIFFERENCE (fetch LXLIM of LINE)					   OXLIM))		    (COND		      ((ILESSP NDX 0)			(ERROR "Moving Text down after DEL." NDX))		      (T (COND			   [(AND (SETQ NLINE (fetch NEXTLINE of LINE))				 (IGREATERP (fetch YBOT of NLINE)					    (fetch WBOTTOM of TEXTOBJ)))			     (COND			       [(IGEQ (IDIFFERENCE (fetch LXLIM of NLINE)						   (fetch LEFTMARGIN of NLINE))				      NDX)                   (* There's enough on the next line to grab)				 (BITBLT DS (fetch LEFTMARGIN of NLINE)					 (fetch YBOT of NLINE)					 DS OXLIM (fetch YBOT of LINE)					 NDX					 (fetch LHEIGHT of LINE)					 (QUOTE INPUT)					 (QUOTE REPLACE))    (* Move the text up from the next line)				 (BITBLT DS 0 (fetch YBOT of LINE)					 (fetch CACHE of LINE)					 0 0 (fetch WRIGHT of TEXTOBJ)					 (fetch LHEIGHT of LINE)					 (QUOTE INPUT)					 (QUOTE REPLACE))    (* And update the line's cached image)				 (COND				   ((ILESSP (fetch CHARLIM of LINE)					    (fetch TEXTLEN of TEXTOBJ))                                                             (* There are more characters to go on the next line.)				     (SETQ DEL (\PULLTEXT NLINE NDX (ADD1 (fetch CHARLIM									     of LINE))							  THISLINE TEXTOBJ)))				   (T                        (* This line is the last. Delete all the others)				      (SETQ DEL T)				      (replace NEXTLINE of LINE with NIL)				      (replace PREVLINE of NLINE with NIL)				      (BITBLT NIL 0 0 DS 0 0 (fetch WRIGHT of TEXTOBJ)					      (SUB1 (fetch YBOT of LINE))					      (QUOTE TEXTURE)					      (QUOTE REPLACE)					      WHITESHADE]			       (T                            (* Not enough on next line;; grab it and loop)				  (ERROR "PULLING TEXT FROM TOO SHORT A LINE"]			   (T (\DISPLAYLINE TEXTOBJ LINE)			      (replace NEXTLINE of LINE with NIL)			      (AND NLINE (replace PREVLINE of NLINE with NIL]	    (T (replace LXLIM of LINE with OXLIM)))          (RETURN DEL])(\SHOWSEL  [LAMBDA (SEL HOW ON)                                       (* jds "31-MAY-83 16:43")                                                             (* Highlight the selection SEL, according to HOW, 							     turning it on or off according to ON)    (COND      ((AND SEL (fetch SET of SEL)	    (fetch \WINDOW of (fetch \TEXTOBJ of SEL)))      (* This operation only makes sense if there is a 							     selection, it has been set, and there's a window to do 							     the highlighting in.)	(PROG ((TEXTOBJ (fetch \TEXTOBJ of SEL)))	      (PROG ((DS (ffetch DS of TEXTOBJ))		     (LINES (ffetch LINES of TEXTOBJ))		     (SHADE (OR (fetch HOW of SEL)				BLACKSHADE))		     (SHADEHEIGHT (OR (fetch HOWHEIGHT of SEL)				      1))		     LL)		    (COND		      ((fetch SELOBJ of SEL)			(APPLY* (fetch SELSHOWFN of (fetch OBJREF of (fetch SELOBJ of SEL)))				(fetch SELOBJ of SEL)				SEL ON DS)			(RETURN)))		    (COND		      [(AND ON (NOT (fetch ONFLG of SEL)))   (* It's off and we want to turn it on)			(replace ONFLG of SEL with T)        (* Mark the selection as highlighted)			[COND			  ((OR (fetch L1 of SEL)			       (fetch LN of SEL))			    (COND			      ((EQ (fetch L1 of SEL)				   (fetch LN of SEL))        (* It's all in a single line;							     just underline the right section and beat it)				(BITBLT NIL 0 0 DS (fetch X0 of SEL)					(fetch Y0 of SEL)					(fetch DX of SEL)					(IMIN SHADEHEIGHT (fetch LHEIGHT							     of (fetch L1 of SEL)))					(QUOTE TEXTURE)					(QUOTE INVERT)					SHADE))			      (T                             (* Different lines.)				 (AND (fetch L1 of SEL)				      (BITBLT NIL 0 0 DS (fetch X0 of SEL)					      (fetch Y0 of SEL)					      (IDIFFERENCE (fetch LXLIM of (fetch L1 of SEL))							   (fetch X0 of SEL))					      (IMIN SHADEHEIGHT (fetch LHEIGHT								   of (fetch L1 of SEL)))					      (QUOTE TEXTURE)					      (QUOTE INVERT)					      SHADE))        (* If the first line is known, underline the right 							     section of it.)				 (SETQ LL (OR (fetch L1 of SEL)					      LINES))				 (AND LL (SETQ LL (fetch NEXTLINE of LL)))                                                             (* The line after the first, or the top line on the 							     screen -- if we didn't have a first line)				 (while LL until (OR (EQ LL (fetch LN of SEL))						     (ILEQ (fetch YBOT of LL)							   (fetch WBOTTOM of TEXTOBJ)))				    do                       (* Highlight every line between first and last)				       (BITBLT NIL 0 0 DS (fetch LEFTMARGIN of LL)					       (fetch YBOT of LL)					       (IDIFFERENCE (fetch LXLIM of LL)							    (fetch LEFTMARGIN of LL))					       (IMIN SHADEHEIGHT (fetch LHEIGHT of LL))					       (QUOTE TEXTURE)					       (QUOTE INVERT)					       SHADE)				       (SETQ LL (fetch NEXTLINE of LL)))				 (AND LL (IGREATERP (fetch YBOT of LL)						    (fetch WBOTTOM of TEXTOBJ))				      (BITBLT NIL 0 0 DS (fetch LEFTMARGIN of LL)					      (fetch YBOT of (fetch LN of SEL))					      (IDIFFERENCE (fetch XLIM of SEL)							   (fetch LEFTMARGIN of LL))					      (IMIN SHADEHEIGHT (fetch LHEIGHT of LL))					      (QUOTE TEXTURE)					      (QUOTE INVERT)					      SHADE))        (* Highlight the final line of the selection)				 ]			(COND			  ((AND (fetch HASCARET of SEL)				(NOT (fetch TXTREADONLY of TEXTOBJ)))			    (COND			      ((EQ (fetch POINT of SEL)				   (QUOTE LEFT))				(\SETCARET (fetch X0 of SEL)					   (fetch Y0 of SEL)					   DS TEXTOBJ))			      (T (\SETCARET (fetch XLIM of SEL)					    (fetch YLIM of SEL)					    DS TEXTOBJ]		      ((AND (NOT ON)			    (fetch ONFLG of SEL))            (* The selection is highlighted and we want to turn it 							     off.)			(replace ONFLG of SEL with NIL)      (* Mark it as being turned off)			[COND			  ((AND (fetch HASCARET of SEL)				(NOT (fetch TXTREADONLY of TEXTOBJ)))			    (COND			      ((EQ (fetch POINT of SEL)				   (QUOTE LEFT))				(\EDIT.UPCARET (fetch CARET of TEXTOBJ)))			      (T (\EDIT.UPCARET (fetch CARET of TEXTOBJ]			(COND			  ((OR (fetch L1 of SEL)			       (fetch LN of SEL))			    (COND			      ((EQ (fetch L1 of SEL)				   (fetch LN of SEL))        (* It's a single line; just highlight the right section 							     of it.)				(BITBLT NIL 0 0 DS (fetch X0 of SEL)					(fetch Y0 of SEL)					(fetch DX of SEL)					(IMIN SHADEHEIGHT (fetch LHEIGHT							     of (fetch L1 of SEL)))					(QUOTE TEXTURE)					(QUOTE INVERT)					SHADE))			      (T                             (* The selection extends over 2 or more lines.)				 (AND (fetch L1 of SEL)				      (BITBLT NIL 0 0 DS (fetch X0 of SEL)					      (fetch Y0 of SEL)					      (IDIFFERENCE (fetch LXLIM of (fetch L1 of SEL))							   (fetch X0 of SEL))					      (IMIN SHADEHEIGHT (fetch LHEIGHT								   of (fetch L1 of SEL)))					      (QUOTE TEXTURE)					      (QUOTE INVERT)					      SHADE))        (* If we know the first line, de-highlight it.)				 (SETQ LL (OR (fetch L1 of SEL)					      LINES))				 (AND LL (SETQ LL (fetch NEXTLINE of LL)))                                                             (* Find the next line (either next after 1st in 							     selection, or top one on screen))				 (while LL until (OR (EQ LL (fetch LN of SEL))						     (ILEQ (fetch YBOT of LL)							   (fetch WBOTTOM of TEXTOBJ)))				    do (BITBLT NIL 0 0 DS (fetch LEFTMARGIN of LL)					       (fetch YBOT of LL)					       (IDIFFERENCE (fetch LXLIM of LL)							    (fetch LEFTMARGIN of LL))					       (IMIN SHADEHEIGHT (fetch LHEIGHT of LL))					       (QUOTE TEXTURE)					       (QUOTE INVERT)					       SHADE)				       (SETQ LL (fetch NEXTLINE of LL)))				 (AND LL (IGREATERP (fetch YBOT of LL)						    (fetch WBOTTOM of TEXTOBJ))				      (BITBLT NIL 0 0 DS (fetch LEFTMARGIN of LL)					      (fetch YBOT of (fetch LN of SEL))					      (IDIFFERENCE (fetch XLIM of SEL)							   (fetch LEFTMARGIN of LL))					      (IMIN SHADEHEIGHT (fetch LHEIGHT of LL))					      (QUOTE TEXTURE)					      (QUOTE INVERT)					      SHADE])(\PUSHLINES  [LAMBDA (TEXTOBJ LINE DY DS WWIDTH)                        (* jds "10-JUN-83 15:38")                                                             (* Move all lines in the editing window, starting with 							     FIRSTLINE, down by DY)    (PROG (OFLOWFN)          (COND	    ((IGREATERP (fetch YBOT of LINE)			(IPLUS (fetch WBOTTOM of TEXTOBJ)			       DY))                          (* This line will remain on screen.							     Push it down, then go push the others.)	      [COND		((fetch NEXTLINE of LINE)                    (* Push lower lines down. If that overflows 							     (and it's handled) don't bother completing the ripple)		  (OR (\PUSHLINES TEXTOBJ (fetch NEXTLINE of LINE)				  DY DS WWIDTH)		      (RETURN]	      (BITBLT DS 0 (fetch YBOT of LINE)		      DS 0 (IDIFFERENCE (fetch YBOT of LINE)					DY)		      WWIDTH		      (fetch LHEIGHT of LINE)		      (QUOTE INPUT)		      (QUOTE REPLACE))	      (replace YBOT of LINE with (IDIFFERENCE (fetch YBOT of LINE)						      DY))	      (replace YBASE of LINE with (IDIFFERENCE (fetch YBASE of LINE)						       DY)))	    ((AND (SETQ OFLOWFN (WINDOWPROP (fetch \WINDOW of TEXTOBJ)					    (QUOTE TEDIT.OVERFLOWFN)))		  (APPLY* OFLOWFN (fetch \WINDOW of TEXTOBJ)			  TEXTOBJ))                          (* This line overflows the screen.							     If the handler takes care of it, punt further rippling.)	      (RETURN NIL))	    ((IGREATERP (fetch YBOT of LINE)			(fetch WBOTTOM of TEXTOBJ))          (* Otherwise, just drop the line off-screen.)	      (BITBLT NIL 0 0 DS 0 0 WWIDTH (IPLUS (fetch YBOT of LINE)						   (fetch LHEIGHT of LINE))		      (QUOTE TEXTURE)		      (QUOTE REPLACE)		      WHITESHADE)	      (replace YBOT of LINE with 0)))          (RETURN T])(\PUSHTEXT  [LAMBDA (LINE X Y DX CH TEXTOBJ THISLINE FORCEFORMAT SAVEBM SAVEWIDTH)                                                             (* jds " 4-JUL-83 12:46")                                                             (* MOVE TEXT FROM THE LINE ABOVE ONTO THIS LINE)    (TEDIT.FLASHCARET (fetch CARET of TEXTOBJ))              (* Let the caret keep flashing in the right spot while 							     we work)    (PROG ((NDX 0)	   (OXLIM (fetch LXLIM of LINE))	   (OCHLIM (fetch CHARLIM of LINE))	   (OSPACE (fetch SPACELEFT of LINE))	   NEXTLINE OCR\END (DS (ffetch DS of TEXTOBJ))	   NEWLINE NSAVEWIDTH OFLOWFN)          (replace CHAR1 of LINE with CH)                    (* Fix up this line to start just after old line ends)          (SETQ OXLIM (fetch LXLIM of LINE))                 (* Old line-end point, for checking for changes)          (SETQ OCR\END (fetch CR\END of LINE))          (\FORMATLINE TEXTOBJ NIL CH THISLINE LINE)          [COND	    [(OR FORCEFORMAT (IGREATERP DX OSPACE))          (* May need to move some text to yet another line...)	      (SETQ NDX (IDIFFERENCE (IPLUS OXLIM DX)				     (fetch LXLIM of LINE)))                                                             (* NDX _ Amount of text to be moved to the next line)	      (COND		((IGREATERP NDX 0)                           (* There is excess on this line--move it to the next 							     line)		  (COND		    (OCR\END                                 (* This line ends in a CR -- just create a new line with							     the overflow on it)			     (SETQ NEWLINE (\FORMATLINE TEXTOBJ NIL (ADD1 (fetch CHARLIM									     of LINE))							THISLINE))			     (replace YBOT of NEWLINE with (IDIFFERENCE (fetch YBOT of LINE)									(fetch LHEIGHT of NEWLINE)))			     (replace YBASE of NEWLINE with (IPLUS (fetch YBOT of NEWLINE)								   (fetch DESCENT of NEWLINE)))			     (COND			       ((AND (SETQ OFLOWFN (WINDOWPROP DS (QUOTE TEDIT.OVERFLOWFN)))				     (APPLY* OFLOWFN DS TEXTOBJ))				 (RETURN NIL))			       ((SETQ NEXTLINE (fetch NEXTLINE of LINE))                                                             (* There's another line to push onto.)				 (OR (\PUSHLINES TEXTOBJ NEXTLINE (fetch LHEIGHT of NEWLINE)						 (fetch DS of TEXTOBJ)						 (fetch WRIGHT of TEXTOBJ))				     (RETURN NIL))           (* If pushing overflowed the window, punt here and now.)				 (BITBLT NIL 0 0 DS 0 (IDIFFERENCE (fetch YBOT of LINE)								   (fetch LHEIGHT of NEWLINE))					 (fetch WRIGHT of TEXTOBJ)					 (fetch LHEIGHT of NEWLINE)					 (QUOTE TEXTURE)					 (QUOTE REPLACE)					 WHITESHADE)				 (replace PREVLINE of NEXTLINE with NEWLINE)))			     (replace NEXTLINE of NEWLINE with NEXTLINE)			     (replace PREVLINE of NEWLINE with LINE)			     (replace NEXTLINE of LINE with NEWLINE)			     (OR (fetch TXTREADONLY of TEXTOBJ)				 (\EDIT.UPCARET (fetch CARET of TEXTOBJ)))                                                             (* Move the caret out of the way while we move text)			     (BITBLT DS (IDIFFERENCE OXLIM NDX)				     (fetch YBOT of LINE)				     DS				     (fetch LEFTMARGIN of NEWLINE)				     (fetch YBOT of NEWLINE)				     NDX				     (fetch LHEIGHT of NEWLINE)				     (QUOTE INPUT)				     (QUOTE REPLACE))        (* Move the text onto the newly-built line)			     (OR (fetch TXTREADONLY of TEXTOBJ)				 (\EDIT.DOWNCARET (fetch CARET of TEXTOBJ)))			     (SETQ NDX 0))		    ((fetch NEXTLINE of LINE)                (* There is a line after this one;							     save text for it)		      [SETQ NSAVEWIDTH (IMIN NDX (IMAX 0 (IDIFFERENCE (fetch RIGHTMARGIN									 of LINE)								      (IDIFFERENCE OXLIM NDX]		      (BITBLT DS (IDIFFERENCE OXLIM NDX)			      (fetch YBOT of LINE)			      (fetch CACHE of LINE)			      0 0 NDX (fetch LHEIGHT of LINE)			      (QUOTE INPUT)			      (QUOTE REPLACE)))		    (T                                       (* No succeeding line, so create one.)		       (SETQ NEXTLINE (\FORMATLINE TEXTOBJ NIL (ADD1 (fetch CHARLIM of LINE))						   THISLINE))		       (COND			 ((IGREATERP (fetch YBOT of LINE)				     (IPLUS (fetch LHEIGHT of NEXTLINE)					    (fetch WBOTTOM of TEXTOBJ)))			   (replace YBOT of NEXTLINE with (IDIFFERENCE (fetch YBOT of LINE)								       (fetch LHEIGHT of NEXTLINE)))			   (replace YBASE of NEXTLINE with (IPLUS (fetch YBOT of NEXTLINE)								  (fetch DESCENT of NEXTLINE)))			   (\DISPLAYLINE TEXTOBJ NEXTLINE))			 ((AND (SETQ OFLOWFN (WINDOWPROP DS (QUOTE TEDIT.OVERFLOWFN)))			       (APPLY* OFLOWFN DS TEXTOBJ))                                                             (* This line overflowed the window.							     If it gets handled by user handler, just punt out.)			   (RETURN NIL)))		       (replace NEXTLINE of LINE with NEXTLINE)		       (replace PREVLINE of NEXTLINE with LINE)		       (SETQ NDX 0]	    (T                                               (* There is enough room on this line, so not to worry 							     about moving text down.)	       (replace SPACELEFT of LINE with (IDIFFERENCE (fetch SPACELEFT of LINE)							    DX))	       (replace LXLIM of LINE with (IPLUS OXLIM DX]          (COND	    ((IGREATERP (fetch YBOT of LINE)			(fetch WBOTTOM of TEXTOBJ))          (* This line is fully on-screen.							     Move it over to make room for text, then move the text 							     in from above.)	      (\EDIT.UPCARET (fetch CARET of TEXTOBJ))       (* Caret out of the way)	      (BITBLT DS (fetch LEFTMARGIN of LINE)		      (fetch YBOT of LINE)		      DS		      (IPLUS (fetch LEFTMARGIN of LINE)			     DX)		      (fetch YBOT of LINE)		      OXLIM		      (fetch LHEIGHT of LINE)		      (QUOTE INPUT)		      (QUOTE REPLACE))                       (* Move this line over to make room.)	      (BITBLT NIL 0 0 DS (fetch LEFTMARGIN of LINE)		      (fetch YBOT of LINE)		      DX		      (fetch LHEIGHT of LINE)		      (QUOTE TEXTURE)		      (QUOTE REPLACE)		      WHITESHADE)                            (* Blank out the space just cleared.)	      (BITBLT SAVEBM 0 0 DS (fetch LEFTMARGIN of LINE)		      (fetch YBOT of LINE)		      SAVEWIDTH		      (fetch LHEIGHT of LINE)		      (QUOTE INPUT)		      (QUOTE REPLACE))                       (* Move the text in from above.)	      (BITBLT NIL 0 0 DS (fetch LXLIM of LINE)		      (fetch YBOT of LINE)		      (fetch WRIGHT of TEXTOBJ)		      (fetch LHEIGHT of LINE)		      (QUOTE TEXTURE)		      (QUOTE REPLACE)		      WHITESHADE)                            (* Blank out the area beyond the end of this line)                                                             (* Cache the new image)	      (OR (fetch TXTREADONLY of TEXTOBJ)		  (\EDIT.DOWNCARET (fetch CARET of TEXTOBJ)))	      (OR (ILEQ NDX 0)		  (\PUSHTEXT (fetch NEXTLINE of LINE)			     (IDIFFERENCE OXLIM NDX)			     (fetch YBOT of LINE)			     NDX			     (ADD1 (fetch CHARLIM of LINE))			     TEXTOBJ THISLINE OCR\END (fetch CACHE of LINE)			     NSAVEWIDTH))                    (* Now propogate the change to the next line.)	      ))          [OR (fetch CACHE of LINE)	      (replace CACHE of LINE with (BITMAPCREATE (fetch WRIGHT of TEXTOBJ)							(fetch LHEIGHT of LINE]          (BITBLT DS 0 (fetch YBOT of LINE)		  (fetch CACHE of LINE)		  0 0 (fetch WRIGHT of TEXTOBJ)		  (fetch LHEIGHT of LINE)		  (QUOTE INPUT)		  (QUOTE REPLACE))          (replace DIRTY of LINE with NIL)          (RETURN T])(\BACKFORMAT  [LAMBDA (LINES TEXTOBJ THISLINE)                           (* jds " 5-JUN-83 16:43")                                                             (* Move back to the next preceding CR 							     (to guarantee a line break), then format lines to reach 							     where we are now.)    (PROG ((LINE1 (fetch NEXTLINE of LINES))	   (WHEIGHT (fetch WTOP of TEXTOBJ))	   CH1 CHNO CH NLINE)          [SETQ CH1 (COND	      (LINE1 (fetch CHAR1 of LINE1))	      (T (fetch TEXTLEN of TEXTOBJ]          (COND	    ((ILEQ CH1 1)                                    (* No more lines can be formatted -- we're at the front 							     of the file.)	      (RETURN LINES))	    (T                                               (* There is more to do.)	       (\SETUPGETCH (IDIFFERENCE CH1 1)			    TEXTOBJ)	       [for old CHNO from (IDIFFERENCE CH1 2) to 1 by -1		  do (SETQ CH (\GETCHB TEXTOBJ))		     (COND		       ((EQ CH (CHARCODE CR))			 (RETURN]	       (SETQ CHNO (IMAX (ADD1 CHNO)				1))	       [while (ILEQ CHNO (SUB1 CH1))		  do (SETQ NLINE (\FORMATLINE TEXTOBJ NIL CHNO THISLINE))		     (replace YBOT of NLINE with WHEIGHT)		     (replace YBASE of NLINE with WHEIGHT)		     (replace PREVLINE of NLINE with LINES)		     (replace NEXTLINE of LINES with NLINE)		     (SETQ LINES NLINE)		     (SETQ CHNO (ADD1 (fetch CHARLIM of NLINE]	       (replace NEXTLINE of NLINE with LINE1)	       (AND LINE1 (replace PREVLINE of LINE1 with NLINE))	       (RETURN NLINE]))(* Read-table Utilities)(DEFINEQ(\TEDIT.READTABLE  [LAMBDA NIL                                                (* jds "15-DEC-82 20:15")                                                             (* Create a TEdit read-table, to control which 							     characters have what functions and call which commands.)    (PROG [(RTBL (create READTABLEP			 READMACRODEFS _(HARRAY 50]          (for CH in (CHARCODE (BS ^A ^W DEL #A #C ESC)) as CL	     in (LIST CHARDELETE.TTC CHARDELETE.TTC WORDDELETE.TTC DELETE.TTC UNDO.TTC CMD.TTC 		      REDO.TTC)	     do                                              (* Set up the default syntax classes for command 							     characters)		(\SETSYNCODE (fetch READSA of RTBL)			     CH CL))          (for CH in (CHARCODE (^X)) as FN in (QUOTE (\TEDIT.ABBREV.EXPAND))	     do                                              (* Set up the default function-calling characters 							     (^X to expand abbrevs for now))		(\SETSYNCODE (fetch READSA of RTBL)			     CH FUNCTIONCALL.TTC)		(PUTHASH CH FN (fetch READMACRODEFS of RTBL)))          (RETURN RTBL])(\TEDIT.WORDBOUND.READTABLE  [LAMBDA NIL                                                (* jds "28-APR-83 17:28")          (* Create a readtable which will let TEdit find word boundaries. A word boundary is any point where the SYNCODE of	  the adjacent characters is different)    (PROG [(RTBL (create READTABLEP			 READMACRODEFS _(HARRAY 50]          (for CH from 0 to 255 do (\SETSYNCODE (fetch READSA of RTBL)						CH PUNCT.TTC))                                                             (* By default, every character except those noted below 							     is a punctuation character)          (for CH from (CHARCODE A) to (CHARCODE Z) do (\SETSYNCODE (fetch READSA of RTBL)								    CH TEXT.TTC))                                                             (* Upper case alpha)          (for CH from (CHARCODE a) to (CHARCODE z) do (\SETSYNCODE (fetch READSA of RTBL)								    CH TEXT.TTC))                                                             (* Lower case alpha)          (for CH from (CHARCODE 0) to (CHARCODE 9) do (\SETSYNCODE (fetch READSA of RTBL)								    CH TEXT.TTC))                                                             (* And digits are text characters)          (for CH in (CHARCODE (CR SPACE TAB ^L)) do (\SETSYNCODE (fetch READSA of RTBL)								  CH WHITESPACE.TTC))                                                             (* And these are white space)          (for CH in (LIST MSPACE NSPACE THINSPACE FIGSPACE) do (\SETSYNCODE (fetch READSA										of RTBL)									     CH TEXT.TTC))          (RETURN RTBL])(TEDIT.GETSYNTAX  [LAMBDA (CH TABLE)                                         (* jds "31-JAN-83 10:50")    (SELECTC (\SYNCODE (fetch READSA of TABLE)		       CH)	     (WORDDELETE.TTC (QUOTE WORDDELETE))	     (CHARDELETE.TTC (QUOTE CHARDELETE))	     (DELETE.TTC (QUOTE DELETE))	     (UNDO.TTC (QUOTE UNDO))	     (REDO.TTC (QUOTE REDO))	     (FUNCTIONCALL.TTC (QUOTE FN))	     (CMD.TTC (QUOTE CMD))	     NIL])(TEDIT.SETSYNTAX  [LAMBDA (CHAR CLASS TABLE)                                 (* jds "15-DEC-82 10:18")                                                             (* SETS TEDIT-STYLE SYNTAX BITS IN A TERMTABLE)    (\SETSYNCODE (fetch READSA of TABLE)		 CHAR		 (SELECTQ CLASS			  (CHARDELETE CHARDELETE.TTC)			  (WORDDELETE WORDDELETE.TTC)			  ((DELETE LINEDELETE)			    DELETE.TTC)			  (UNDO UNDO.TTC)			  (REDO REDO.TTC)			  (CMD CMD.TTC)			  (FN FUNCTIONCALL.TTC)			  NONE.TTC])(TEDIT.GETFUNCTION  [LAMBDA (CH TABLE)                                         (* jds "31-JAN-83 10:51")                                                             (* Gets the FN that is called when CH is hit inside 							     TEDIT.)    (AND TABLE (type? READTABLEP TABLE)	 (fetch READMACRODEFS of TABLE)	 (IEQP FUNCTIONCALL.TTC (\SYNCODE (fetch READSA of TABLE)					  CH))	 (GETHASH CH (fetch READMACRODEFS of TABLE])(TEDIT.SETFUNCTION  [LAMBDA (C FN RTBL)                                        (* jds "15-DEC-82 10:19")                                                             (* Set TEDITs (read) table so that FN is called whenever							     C is typed.)    (\SETSYNCODE (fetch READSA of RTBL)		 C FUNCTIONCALL.TTC)                         (* Mark the character as invoking a function)    (OR (fetch READMACRODEFS of RTBL)	(replace READMACRODEFS of RTBL with (HARRAY 50)))    (* Make sure there's a hash table to store the function 							     in.)    (PUTHASH C FN (fetch READMACRODEFS of RTBL])(TEDIT.WORDGET  [LAMBDA (CH TABLE)                                         (* jds "27-MAY-83 13:24")    (\SYNCODE (fetch READSA of (OR TABLE TEDIT.WORDBOUND.READTABLE))	      (COND		((SMALLP CH))		(T (CHCON1 CH])(TEDIT.WORDSET  [LAMBDA (CHARCODE CLASS TABLE)                             (* jds " 1-JUN-83 12:23")                                                             (* SETS TEDIT-STYLE SYNTAX BITS IN A TERMTABLE)    (\SETSYNCODE (fetch READSA of (OR TABLE TEDIT.WORDBOUND.READTABLE))		 (COND		   ((SMALLP CHARCODE))		   (T (CHCON1 CHARCODE)))		 (COND		   ((FIXP CLASS))		   (T (SELECTQ CLASS			       (PUNCTUATION PUNCT.TTC)			       (WHITESPACE WHITESPACE.TTC)			       (TEXT TEXT.TTC)			       TEXT.TTC]))(DECLARE: EVAL@COMPILE (RPAQQ NONE.TTC 0)(RPAQQ CHARDELETE.TTC 1)(RPAQQ WORDDELETE.TTC 2)(RPAQQ DELETE.TTC 3)(RPAQQ FUNCTIONCALL.TTC 4)(RPAQQ REDO.TTC 5)(RPAQQ UNDO.TTC 6)(RPAQQ CMD.TTC 7)(RPAQQ PUNCT.TTC 20)(RPAQQ TEXT.TTC 21)(RPAQQ WHITESPACE.TTC 22)(CONSTANTS (NONE.TTC 0)	   (CHARDELETE.TTC 1)	   (WORDDELETE.TTC 2)	   (DELETE.TTC 3)	   (FUNCTIONCALL.TTC 4)	   (REDO.TTC 5)	   (UNDO.TTC 6)	   (CMD.TTC 7)	   (PUNCT.TTC 20)	   (TEXT.TTC 21)	   (WHITESPACE.TTC 22)))(DECLARE: EVAL@COMPILE (RPAQQ MSPACE 153)(RPAQQ NSPACE 152)(RPAQQ THINSPACE 159)(RPAQQ FIGSPACE 154)(CONSTANTS (MSPACE 153)	   (NSPACE 152)	   (THINSPACE 159)	   (FIGSPACE 154)))(RPAQ? TEDIT.READTABLE (\TEDIT.READTABLE))(RPAQ? TEDIT.WORDBOUND.READTABLE (\TEDIT.WORDBOUND.READTABLE))(DECLARE: DOEVAL@COMPILE DONTCOPY(ADDTOVAR GLOBALVARS TEDIT.READTABLE TEDIT.WORDBOUND.READTABLE))(DECLARE: EVAL@COMPILE DONTCOPY [DECLARE: EVAL@COMPILE (ACCESSFNS TEDITTERMCODE ((TTCLASS (LOGAND DATUM 224))			  (TTDECODE (LOGAND DATUM 31))))])(* Abbreviation expansion facility)(DEFINEQ(\TEDIT.ABBREV.EXPAND  [LAMBDA (STREAM)                                           (* jds "21-JUL-83 14:01")                                                             (* Expand an abbvreviation)    (PROG ((TEXTOBJ (fetch F3 of STREAM))	   SEL CH# (CH NIL)	   EXPANSION)          (SETQ SEL (fetch SEL of TEXTOBJ))          (SETQ CH# (SELECTQ (fetch POINT of SEL)			     (LEFT (SUB1 (fetch CH# of SEL)))			     (RIGHT (fetch CHLIM of SEL))			     0))          [COND	    ((ZEROP CH#)                                     (* If we're off the front of the document, don't bother 							     trying.)	      (RETURN))	    ((ZEROP (fetch DCH of SEL))                      (* Point Selection, so use the character to the left)	      (\SETUPGETCH CH# TEXTOBJ)	      [SETQ CH (MKSTRING (CHARACTER (\BIN STREAM]	      (TEDIT.SETSEL STREAM CH# 1 (QUOTE LEFT)))	    (T                                               (* We have a selection that isn't just a caret.							     Use it.)	       (SETQ CH (TEDIT.SEL.AS.STRING STREAM]          (SETQ EXPANSION (SASSOC CH TEDIT.ABBREVS))         (* Find the abbreviation's expansion)          (COND	    (EXPANSION                                       (* It exists, so insert it where the abbrev used to be)		       (TEDIT.DELETE TEXTOBJ SEL)		       (TEDIT.INSERT STREAM (CDR EXPANSION)				     SEL]))(RPAQQ TEDIT.ABBREVS (("b" . "")		      ("n" . "")		      ("m" . "")		      ("%"" . "``")))(DECLARE: DOEVAL@COMPILE DONTCOPY(ADDTOVAR GLOBALVARS TEDIT.ABBREVS))(* Process-world interfaces)(DEFINEQ(\TEDIT.PROCIDLEFN  [LAMBDA (WINDOW)                                           (* jds " 2-AUG-83 15:13")                                                             (* TEDIT's PROC.IDLEFN for regaining control.							     If the shift key is down, we're not trying to restart 							     this window, just to copy from it.)    (GETMOUSESTATE)    [COND      ([AND (INSIDE? (DSPCLIPPINGREGION NIL WINDOW)		     (LASTMOUSEX WINDOW)		     (LASTMOUSEY WINDOW))	    (NOT (OR (KEYDOWNP (QUOTE LSHIFT))		     (KEYDOWNP (QUOTE RSHIFT))		     (KEYDOWNP (QUOTE COPY))		     (KEYDOWNP (QUOTE MOVE]                  (* No SHIFT key down; let's regain control.)	(TTY.PROCESS (WINDOWPROP WINDOW (QUOTE PROCESS]    (\TEDIT.BUTTONEVENTFN WINDOW])(\TEDIT.PROCENTRYFN  [LAMBDA (NEWPROCESS OLDPROCESS)                            (* jds " 2-AUG-83 15:32")                                                             (* TEDIT's PROCESS.ENTRYFN, which disarms any dangerous 							     interrupts within the editing world)    (\TEDIT.INTERRUPT.SETUP (PROCESS.WINDOW NEWPROCESS])(\TEDIT.PROCEXITFN  [LAMBDA (THISP NEWP)                                       (* jds " 2-AUG-83 15:32")                                                             (* Re-arm any interrupts that TEdit turned off, so the 							     poor user has them available in other parts of the 							     system.)    (\TEDIT.INTERRUPT.SETUP (PROCESS.WINDOW THISP)			    T]))(* Debugging functions)(DEFINEQ(PLCHAIN  [LAMBDA (LN)                                               (* jds "21-JAN-82 09:57")    (PRINTLINE LN)    (COND      ((fetch NEXTLINE of LN)	(PLCHAIN (fetch NEXTLINE of LN])(PRINTLINE  [LAMBDA (LN)                                               (* jds "28-FEB-83 15:30")    (printout T "-----" T LN "  Bot: " (fetch YBOT of LN)	      "  Base: "	      (fetch YBASE of LN)	      "  Height: "	      (fetch LHEIGHT of LN)	      "  Ascent: "	      (fetch ASCENT of LN)	      "  Descent: "	      (fetch DESCENT of LN)	      T "Char1: " (fetch CHAR1 of LN)	      "  Lim: "	      (fetch CHARLIM of LN)	      "  Top: "	      (fetch CHARTOP of LN))    (COND      ((fetch DIRTY of LN)	(PRIN1 "  DIRTY")))    (COND      ((fetch NEW of LN)	(PRIN1 "  NEW")))    (COND      ((fetch CR\END of LN)	(PRIN1 "  CR-at-end")))    (COND      ((fetch DELETED of LN)	(PRIN1 "  DELETED")))    (COND      ((fetch CACHE of LN)	(PRIN1 "  CACHED")))    (PRIN1 ".")    (printout T "RMar: " (fetch RIGHTMARGIN of LN)	      "  1stSp: "	      (fetch FIRSTSPACE of LN)	      "  XLim: "	      (fetch LXLIM of LN)	      "  Left: "	      (fetch SPACELEFT of LN)	      T "Prev:  " (fetch PREVLINE of LN)	      T "Next:  " (fetch NEXTLINE of LN)	      T)    (COND      ((AND (IGEQ (fetch CHAR1 of LN)		  1)	    (ILEQ (fetch CHAR1 of LN)		  (fetch TEXTLEN of TEXTOBJ)))               (* The line is real -- print it.)	(\SETUPGETCH (fetch CHAR1 of LN)		     TEXTOBJ)	(PRIN1 "|")	[bind CH for CHNO from (fetch CHAR1 of LN) to (IMIN (fetch TEXTLEN of TEXTOBJ)							    (fetch CHARLIM of LN))	   do (SETQ CH (\GETCH TEXTOBJ))	      (COND		((SMALLP CH)		  (PRIN1 (CHARACTER CH)))		(T (PRINT CH]	(PRIN1 "|"]))(* Caret handler; stolen from CHAT.)(DEFINEQ(\EDIT.DOWNCARET  [LAMBDA (CARET)                                            (* jds "24-JUN-82 17:27")    (AND (fetch UP of CARET)	 (\EDIT.FLIPCARET CARET T))                          (* CARET:FORCEDDOWN is set so that caret will come up 							     quickly.)    (replace FORCEDDOWN of CARET with T])(\EDIT.FLIPCARET  [LAMBDA (CARET FORCE)                                      (* jds "21-OCT-82 11:31")                                                             (* changes the caret from on to off or off to on.)    (COND      ([OR FORCE (fetch FORCEDDOWN of CARET)	   (AND (IGREATERP (CLOCK0 (fetch NOWTIME of CARET))			   (fetch THENTIME of CARET))		(NOT (fetch FORCEUP of CARET]	(UNINTERRUPTABLY                                     (* note the time of the next change.)                                                             (* must be done without creating boxes because happens 							     during keyboard wait.)	    (\BOXIPLUS (CLOCK0 (fetch THENTIME of CARET))		       (fetch CARETRATE of CARET))	    (replace UP of CARET with (NOT (fetch UP of CARET)))                                                             (* CARET:DOWN indicates whether caret is on or off.							     necessary so it can be turned off before the character 							     is echoed)                                                             (* CARET:FORCEDDOWN indicates that the caret was taken 							     down so that it will go back up quickly.)	    (replace FORCEDDOWN of CARET with NIL)	    (replace FORCEUP of CARET with NIL)	    (PROG ((DS (fetch CARETDS of CARET))		   (CURS (fetch CURSORBM of CARET)))	          [COND		    ((fetch UP of CARET))		    (T (replace CARETX of CARET with (DSPXPOSITION NIL DS))		       (replace CARETY of CARET with (DSPYPOSITION NIL DS]	          (BITBLT (fetch CURSORBITMAP of CURS)			  0 0 DS (IDIFFERENCE (fetch CARETX of CARET)					      (fetch CURSORHOTSPOTX of CURS))			  (IDIFFERENCE (fetch CARETY of CARET)				       (fetch CURSORHOTSPOTY of CURS))			  CURSORWIDTH CURSORHEIGHT (QUOTE INPUT)			  (QUOTE INVERT))))])(TEDIT.FLASHCARET  [LAMBDA (CARET)                                            (* jds "25-JUN-82 12:44")    (OR (fetch FORCEUP of CARET)	(\EDIT.FLIPCARET CARET])(\EDIT.UPCARET  [LAMBDA (CARET)                                            (* jds "24-JUN-82 17:32")    (OR (fetch UP of CARET)	(\EDIT.FLIPCARET CARET T))                           (* CARET:FORCEUP is set so that caret will stay up.)    (replace FORCEUP of CARET with T])(TEDIT.NORMALIZECARET  [LAMBDA (TEXTOBJ SEL)                                      (* jds "18-JUL-83 14:30")                                                             (* Scroll the text window so that the caret is visible 							     in it.)    [COND      ((type? STREAM TEXTOBJ)                                (* We were given a text STREAM.							     Get the TEXTOBJ from it.)	(SETQ TEXTOBJ (fetch F3 of TEXTOBJ]    (PROG ((SEL (OR SEL (fetch SEL of TEXTOBJ)))	   CH# Y)                                            (* First, find where the caret is)          (SELECTQ (fetch POINT of SEL)		   (LEFT (SETQ CH# (fetch CH# of SEL))			 (SETQ Y (fetch Y0 of SEL)))		   (RIGHT (SETQ CH# (SUB1 (fetch CHLIM of SEL)))			  (SETQ Y (fetch YLIM of SEL)))		   NIL)          (COND	    ((OR (IGEQ Y (fetch WTOP of TEXTOBJ))		 (ILEQ Y (fetch WBOTTOM of TEXTOBJ)))        (* The caret is off-screen. Scroll to get it on)	      (\EDITSCROLLFN (fetch \WINDOW of TEXTOBJ)			     0			     (FQUOTIENT CH# (fetch TEXTLEN of TEXTOBJ])(\SETCARET  [LAMBDA (X Y DS TEXTOBJ)                                   (* jds "27-MAY-83 13:36")    (PROG NIL          [COND	    ((AND (ILESSP Y (fetch WTOP of TEXTOBJ))		  (IGREATERP Y 0)		  (NOT (fetch TXTREADONLY of TEXTOBJ)))	      (MOVETO X Y DS)	      (\EDIT.DOWNCARET (fetch CARET of TEXTOBJ]      (* Only put down the caret the line it points to is 							     on-screen)      ]))(DECLARE: EVAL@COMPILE DONTCOPY [DECLARE: EVAL@COMPILE (RECORD CARET (NOWTIME THENTIME FORCEDDOWN UP CARETDS CURSORBM CARETRATE FORCEUP CARETX CARETY)	      NOWTIME _(CREATECELL \FIXP)	      THENTIME _(CREATECELL \FIXP)	      CURSORBM _ BXCARET CARETRATE _ \CARETRATE UP _ T)])(* UNDO & History List stuff)[DECLARE: EVAL@COMPILE (RECORD TEDITHISTORYEVENT (THACTION THPOINT THLEN THCH# THFIRSTPIECE THOLDINFO THAUXINFO THTEXTOBJ)			  THPOINT _(QUOTE LEFT))](DEFINEQ(\TEDIT.HISTORYADD  [LAMBDA (EVENT)                                            (* jds "24-FEB-83 14:33")                                                             (* Add a new event to the history list.							     For now, this just re-sets the whole list to be the one 							     event...)    (SETQ TEDIT.HISTORYLST (LIST EVENT])(TEDIT.UNDO  [LAMBDA (TEXTOBJ THISLINE)                                 (* jds "13-JUL-83 13:28")                                                             (* Undo the last thing this guy did.)                                                             (* Format of the history list: 							     (Selector-kind-of-last-op --info--))    (PROG ((SEL (fetch SEL of TEXTOBJ))	   EVENT CH# LEN FIRSTPIECE CHANGEDLINE)          (COND	    ((AND TEDIT.HISTORYLST (SETQ EVENT (CAR TEDIT.HISTORYLST)))                                                             (* There really is something to UNDO.							     Decide what, & fix it.)	      (SETQ LEN (fetch THLEN of EVENT))              (* Length of the text that was inserted/deleted/changed)	      (SETQ CH# (fetch THCH# of EVENT))              (* Starting CH# of the change)	      (SETQ FIRSTPIECE (fetch THFIRSTPIECE of EVENT))                                                             (* First piece affected by the change)	      (RESETLST (RESETSAVE (CURSOR WAITINGCURSOR))			(\SHOWSEL SEL NIL NIL)			(SELECTQ (fetch THACTION of EVENT)				 ((Insert Copy Include)      (* It was an insertion)				   (TEDIT.UNDO.INSERTION TEXTOBJ EVENT LEN CH# FIRSTPIECE))				 (Delete                     (* It was a deletion)					 (TEDIT.UNDO.DELETION TEXTOBJ EVENT LEN CH# FIRSTPIECE))				 (Looks                      (* It was a deletion)					(TEDIT.UNDO.LOOKS TEXTOBJ EVENT LEN CH# FIRSTPIECE))				 (Move (TEDIT.UNDO.MOVE TEXTOBJ EVENT LEN CH# FIRSTPIECE)                                                             (* He moved some text)				       )				 (Replace (TEDIT.UNDO.REPLACE TEXTOBJ EVENT LEN CH# FIRSTPIECE)                                                             (* He replaced one piece of text with another.)					  )				 (Get                        (* He did a GET -- not undoable.)				      (CLRPROMPT)				      (printout PROMPTWINDOW "You can't UNDO a GET." T))				 (Put                        (* He did a PUT -- not undoable.)				      (CLRPROMPT)				      (printout PROMPTWINDOW "You can't undo a Put." T))				 (printout PROMPTWINDOW 					   "Trying to UNDO an action that isn't implemented:  "					   (fetch THACTION of EVENT)					   T))			(\SHOWSEL SEL NIL T)))	    (T (CLRPROMPT)	       (printout PROMPTWINDOW "Nothing to UNDO." T])(TEDIT.UNDO.INSERTION  [LAMBDA (TEXTOBJ EVENT LEN CH# FIRSTPIECE)                 (* jds " 3-AUG-83 13:04")                                                             (* UNDO a prior Insert, Copy, or Include.)    (PROG (CHANGEDLINE (THISLINE (fetch THISLINE of TEXTOBJ)))          (replace \INSERTFIRSTCH of TEXTOBJ with -1)          (replace \INSERTNEXTCH of TEXTOBJ with -1)          (bind (TL _ 0) while (ILESSP TL LEN)	     do                                              (* Delete enough inserted pieces to cover the insertion 							     we're undoing.)		(\DELETEPIECE FIRSTPIECE (fetch PCTB of TEXTOBJ))                                                              (* Delete the piece)		(SETQ TL (IPLUS TL (fetch PLEN of FIRSTPIECE)))                                                              (* Track the length of what we've deleted)		(SETQ FIRSTPIECE (fetch NEXTPIECE of FIRSTPIECE))                                                              (* Move to the next piece))          (\TEXTSETEOF (fetch STREAMHINT of TEXTOBJ)		       (replace TEXTLEN of TEXTOBJ with (IDIFFERENCE (fetch TEXTLEN of TEXTOBJ)								     LEN)))                                                             (* Reset the text length and EOF ptr of the text 							     stream.)          (\FIXDLINES (fetch LINES of TEXTOBJ)		      (fetch SEL of TEXTOBJ)		      CH#		      (IPLUS CH# LEN -1)		      TEXTOBJ)                               (* Fix the line descriptors & selection)          (AND (SETQ CHANGEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))	       (\FILLWINDOW (fetch YBOT of CHANGEDLINE)			    CHANGEDLINE TEXTOBJ THISLINE))   (* Fix up the display for all this foofaraw)          (replace POINT of (fetch SEL of TEXTOBJ) with (QUOTE LEFT))          (\FIXSEL (fetch SEL of TEXTOBJ)		   TEXTOBJ)                                  (* Really fix the selection)          (replace THACTION of EVENT with (QUOTE Delete))    (* Make the UNDO be UNDOable, by changing the event to a							     deletion.)      ])(TEDIT.UNDO.DELETION  [LAMBDA (TEXTOBJ EVENT LEN CH# FIRSTPIECE)                 (* jds " 3-AUG-83 13:04")                                                             (* UNDO a prior Deletion of text.)    (PROG ((INSPC# (\CHTOPCNO CH# (fetch PCTB of TEXTOBJ)))	   (NPC (fetch NEXTPIECE of FIRSTPIECE))	   (THISLINE (fetch THISLINE of TEXTOBJ))	   (PCTB (fetch PCTB of TEXTOBJ))	   (SEL (fetch SEL of TEXTOBJ))	   (OTEXTLEN (fetch TEXTLEN of TEXTOBJ))	   CHANGEDLINE NEWPIECE INSPC)          (replace \INSERTFIRSTCH of TEXTOBJ with -1)        (* Force a recomputation of piece lengths, etc.)          (replace \INSERTNEXTCH of TEXTOBJ with -1)          [COND	    ((IGREATERP CH# (\EDITELT PCTB INSPC#))	      (SETQ INSPC (\SPLITPIECE (\EDITELT PCTB (ADD1 INSPC#))				       CH# TEXTOBJ INSPC#))	      (add INSPC# 1))	    (T (SETQ INSPC (\EDITELT PCTB (ADD1 INSPC#]          (SETQ NEWPIECE (create PIECE using FIRSTPIECE))          (replace THFIRSTPIECE of EVENT with NEWPIECE)          (bind (TL _ 0) while (ILESSP TL LEN)	     do (\INSERTPIECE NEWPIECE INSPC TEXTOBJ)        (* Insert the piece back in)		(SETQ TL (IPLUS TL (fetch PLEN of FIRSTPIECE)))                                                              (* Keep track of how much we've re-inserted)		(SETQ FIRSTPIECE NPC)                        (* Move to the next piece to insert)		(AND NPC (SETQ NPC (fetch NEXTPIECE of NPC)))		(SETQ NEWPIECE (create PIECE using FIRSTPIECE)))                                                             (* Done here because \INSERTPIECE creams the NEXTPIECE 							     field.)          (\TEXTSETEOF (fetch STREAMHINT of TEXTOBJ)		       (replace TEXTLEN of TEXTOBJ with (IPLUS (fetch TEXTLEN of TEXTOBJ)							       LEN)))                                                             (* Reset the text length and EOF ptr of the text 							     stream.)          (\FIXILINES (fetch LINES of TEXTOBJ)		      SEL CH# LEN OTEXTLEN)                  (* Fix the line descriptors & selection)          (AND (SETQ CHANGEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))	       (\FILLWINDOW (fetch YBOT of CHANGEDLINE)			    CHANGEDLINE TEXTOBJ THISLINE))   (* Fix up the display for all this foofaraw)          (replace CH# of SEL with CH#)                      (* Make the selection point at the re-inserted text)          (replace CHLIM of SEL with (IPLUS CH# LEN -1))          (replace DCH of SEL with LEN)          (replace POINT of SEL with (fetch THPOINT of EVENT))          (TEDIT.SET.SEL.LOOKS SEL (QUOTE NORMAL))          (\FIXSEL SEL TEXTOBJ)                              (* Really fix the selection)          (replace THACTION of EVENT with (QUOTE Insert))    (* Make the UNDO be UNDOable, by changing the event to a							     insertion.)      ])(TEDIT.REDO  [LAMBDA (TEXTOBJ THISLINE)                                 (* jds " 3-AUG-83 13:04")                                                             (* REDO the last thing this guy did.)                                                             (* Format of the history list: 							     (Selector-kind-of-last-op --info--))    (PROG ((SEL (fetch SEL of TEXTOBJ))	   EVENT CH)          (COND	    ((AND TEDIT.HISTORYLST (SETQ EVENT (CAR TEDIT.HISTORYLST)))                                                             (* There really is something to REDO Decide what, & do 							     it.)	      (RESETLST (RESETSAVE (CURSOR WAITINGCURSOR))			(\SHOWSEL SEL NIL NIL)			(SELECTQ (fetch THACTION of EVENT)				 [(Insert Copy Include)      (* It was an insertion)				   (TEDIT.REDO.INSERTION TEXTOBJ EVENT							 (IMAX 1							       (SELECTQ (fetch POINT of SEL)									(LEFT (fetch CH#										 of SEL))									(RIGHT (ADD1 (fetch CHLIM											of SEL)))									NIL]				 (Delete                     (* It was a deletion)					 (\TEDIT.DELETE SEL TEXTOBJ THISLINE))				 (Replace (TEDIT.REDO.REPLACE TEXTOBJ EVENT))				 [Looks                      (* It was a looks change)					(TEDIT.REDO.LOOKS TEXTOBJ EVENT							  (IMAX 1								(SELECTQ (fetch POINT of SEL)									 (LEFT (fetch CH#										  of SEL))									 (RIGHT (ADD1 (fetch CHLIM											 of SEL)))									 NIL]				 (Find                       (* EXACT-MATCH SEARCH COMMAND)				       [RESETLST (RESETSAVE (CURSOR WAITINGCURSOR))						 (SETQ SEL (fetch SEL of TEXTOBJ))						 (\SHOWSEL SEL NIL NIL)						 (SETQ CH (TEDIT.FIND TEXTOBJ (fetch THAUXINFO										 of EVENT)))						 (COND						   (CH (replace CH# of SEL with CH)						       [replace CHLIM of SEL							  with (SUB1 (IPLUS CH									    (NCHARS (fetch THAUXINFO										       of EVENT]						       (replace DCH of SEL							  with (NCHARS (fetch THAUXINFO of EVENT)))						       (replace POINT of SEL with (QUOTE RIGHT))						       (\FIXSEL SEL TEXTOBJ)						       (\SHOWSEL SEL NIL T)						       (TEDIT.NORMALIZECARET TEXTOBJ))						   (T (printout PROMPTWINDOW "String '"								(fetch THAUXINFO of EVENT)								"' not found." T]				       (replace \INSERTNEXTCH of TEXTOBJ with -1))				 (Move                       (* He moved some text))				 (Get                        (* He did a GET -- not undoable.)				      (CLRPROMPT)				      (printout PROMPTWINDOW "You can't REDO a GET." T))				 (Put                        (* He did a PUT -- not undoable.)				      (CLRPROMPT)				      (printout PROMPTWINDOW "You can't REDO a PUT." T))				 (printout PROMPTWINDOW "REDO of the action " (fetch THACTION										 of EVENT)					   " isn't implemented." T))			(\SHOWSEL SEL NIL T)))	    (T (CLRPROMPT)	       (printout PROMPTWINDOW "Nothing to REDO." T])(TEDIT.REDO.INSERTION  [LAMBDA (TEXTOBJ EVENT CH#)                                (* jds " 3-AUG-83 13:04")                                                             (* REDO a prior Insert/Copy/Include of text.)    (PROG (INSPC INSPC# NPC (THISLINE (fetch THISLINE of TEXTOBJ))		 (SEL (fetch SEL of TEXTOBJ))		 (PCTB (fetch PCTB of TEXTOBJ))		 (LEN (fetch THLEN of EVENT))		 (FIRSTPIECE (create PIECE using (fetch THFIRSTPIECE of EVENT)))		 (OTEXTLEN (fetch TEXTLEN of TEXTOBJ))		 CHANGEDLINE)          (replace THFIRSTPIECE of EVENT with FIRSTPIECE)    (* So we can UNDO this, and remove the right set of 							     pieces.)          (replace \INSERTNEXTCH of TEXTOBJ with -1)         (* Force any further insertions to make new pieces.)          (SETQ NPC (fetch NEXTPIECE of FIRSTPIECE))          (SETQ INSPC# (\CHTOPCNO CH# PCTB))                 (* Piece # of the piece we're to insert inside or in 							     front of)          (SETQ INSPC (\EDITELT PCTB (ADD1 INSPC#)))          [SETQ INSPC (COND	      ((IEQP CH# (\EDITELT PCTB INSPC#))             (* We're inserting just before an existing piece)		INSPC)	      (T                                             (* We must split this piece, and insert before the 							     second part.)		 (PROG1 (\SPLITPIECE INSPC CH# TEXTOBJ INSPC#)			(add INSPC# \EltsPerPiece]          (bind (TL _ 0) while (ILESSP TL LEN)	     do                                              (* Loop thru the pieces of the prior insertion, 							     inserting copies of enough of them to cover the length 							     of the insertion.)		(\INSERTPIECE FIRSTPIECE INSPC TEXTOBJ)      (* Insert the piece back in)		(SETQ TL (IPLUS TL (fetch PLEN of FIRSTPIECE)))                                                              (* Keep track of how much we've re-inserted)		(SETQ FIRSTPIECE (create PIECE using NPC))                                                              (* Move to the next piece to insert)		(AND NPC (SETQ NPC (fetch NEXTPIECE of NPC)))                                                              (* Done here because \INSERTPIECE creams the NEXTPIECE 							     field.))          (\TEXTSETEOF (fetch STREAMHINT of TEXTOBJ)		       (replace TEXTLEN of TEXTOBJ with (IPLUS (fetch TEXTLEN of TEXTOBJ)							       LEN)))                                                             (* Reset the text length and EOF ptr of the text 							     stream.)          (\FIXILINES (fetch LINES of TEXTOBJ)		      SEL CH# LEN OTEXTLEN)                  (* Fix the line descriptors & selection)          (AND (SETQ CHANGEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))	       (\FILLWINDOW (fetch YBOT of CHANGEDLINE)			    CHANGEDLINE TEXTOBJ THISLINE))   (* Fix up the display for all this foofaraw)          (replace CH# of SEL with CH#)                      (* Make the selection point at the re-inserted text)          (replace CHLIM of SEL with (IPLUS CH# LEN -1))          (replace DCH of SEL with LEN)          (TEDIT.SET.SEL.LOOKS SEL (QUOTE NORMAL))          (\FIXSEL SEL TEXTOBJ)                              (* Really fix the selection)          (replace THACTION of EVENT with (QUOTE Insert))    (* Make the UNDO be UNDOable, by changing the event to a							     insertion.)      ])(TEDIT.REDO.LOOKS  [LAMBDA (TEXTOBJ EVENT CH#)                                (* jds " 4-AUG-83 09:57")                                                             (* Set looks on the current selection from the 							     TEDIT.CHARLOOKS.WINDOW)    (PROG ((SEL (fetch SEL of TEXTOBJ))	   (PCTB (fetch PCTB of TEXTOBJ))	   PC1 PCNO1 PCNON PCN (FONT NIL)	   FACE SIZE (NEWLOOKS (fetch THAUXINFO of EVENT))	   (\INPC (fetch \INSERTPC of TEXTOBJ))	   (THISLINE (fetch THISLINE of TEXTOBJ))	   CH# CHLIM CHANGEDLINE (OLDLOOKSLIST NIL))          (SETQ FACE (LISTGET NEWLOOKS (QUOTE FACE)))        (* Get the face and size for later use in setting fields							     of the CHARLOOKS)          (SETQ SIZE (LISTGET NEWLOOKS (QUOTE SIZE)))          (COND	    ((fetch SET of SEL)                              (* He's got something selected.)	      (\SHOWSEL SEL NIL NIL)	      (SETQ CH# (fetch CH# of SEL))                  (* 1st ch# of the text to change)	      (SETQ CHLIM (fetch CHLIM of SEL))              (* last ch to change)	      (SETQ PC1 (\CHTOPC CH# PCTB))                  (* Piece the first ch is in)	      (SETQ PCNO1 (\FINDPIECE PC1 PCTB))             (* Piece # of first piece)	      (COND		((IGREATERP CH# (\EDITELT PCTB PCNO1))       (* If CH# is not first ch in piece, split it.)		  (SETQ PC1 (\SPLITPIECE PC1 CH# TEXTOBJ))   (* Take 2nd half of the split, which starts with CH#.)		  (SETQ PCTB (fetch PCTB of TEXTOBJ))        (* NB: \SplitPiece may make a new PCTB, so copy it 							     here.)		  (replace \INSERTNEXTCH of TEXTOBJ with -1)))	      (SETQ PCN (OR (\CHTOPC (ADD1 CHLIM)				     PCTB)			    (QUOTE LASTPIECE)))              (* Last piece)	      (SETQ PCNON (\FINDPIECE PCN PCTB))	      (COND		((IEQP (ADD1 CHLIM)		       (\EDITELT PCTB PCNON))                (* CHLIM+1 is the start of a new piece.							     just use prevpiece as pcn)		  (SETQ PCN (fetch PREVPIECE of PCN)))		(T                                           (* If the last char isn't the last char in the piece, 							     then split it and take the first half.)		   (\SPLITPIECE PCN (ADD1 CHLIM)				TEXTOBJ)		   (replace \INSERTNEXTCH of TEXTOBJ with -1)))	      (bind ((PC _ PC1)		     NEWPCLOOKS)		 while (NEQ PC PCN)		 do (SETQ OLDLOOKSLIST (NCONC1 OLDLOOKSLIST (fetch PLOOKS of PC)))                                                              (* Save old looks for the Undo.)		    [replace PLOOKS of PC with (SETQ NEWPCLOOKS						 (create CHARLOOKS						    using (fetch PLOOKS of PC)							  CLFONT _(FONTCOPY (fetch CLFONT									       of (fetch PLOOKS										     of PC))									    NEWLOOKS]                                                             (* Give this piece its new looks)		    (SELECTQ FACE			     (BOLD (replace CLBOLD of NEWPCLOOKS with T)				   (replace CLITAL of NEWPCLOOKS with NIL))			     (ITALIC (replace CLITAL of NEWPCLOOKS with T)				     (replace CLBOLD of NEWPCLOOKS with NIL))			     (BOLDITALIC (replace CLBOLD of NEWPCLOOKS					    with (replace CLITAL of NEWPCLOOKS with T)))			     (STANDARD (replace CLBOLD of NEWPCLOOKS					  with (replace CLITAL of NEWPCLOOKS with NIL)))			     NIL)		    (AND SIZE (replace CLSIZE of NEWPCLOOKS with SIZE))		    [COND		      ((EQ PC \INPC)			(replace INSERTFONT of TEXTOBJ with (fetch CLFONT							       of (fetch PLOOKS of PC]		    (SETQ PC (fetch NEXTPIECE of PC))		 finally [replace PLOOKS of PC with (SETQ NEWPCLOOKS						      (create CHARLOOKS							 using (fetch PLOOKS of PC)							       CLFONT _(FONTCOPY (fetch CLFONT										    of (fetch PLOOKS											  of PC))										 NEWLOOKS]			 (SELECTQ FACE				  (BOLD (replace CLBOLD of NEWPCLOOKS with T)					(replace CLITAL of NEWPCLOOKS with NIL))				  (ITALIC (replace CLITAL of NEWPCLOOKS with T)					  (replace CLBOLD of NEWPCLOOKS with NIL))				  (BOLDITALIC (replace CLBOLD of NEWPCLOOKS						 with (replace CLITAL of NEWPCLOOKS with T)))				  (STANDARD (replace CLBOLD of NEWPCLOOKS					       with (replace CLITAL of NEWPCLOOKS with NIL)))				  NIL)			 (AND SIZE (replace CLSIZE of NEWPCLOOKS with SIZE)))	      (bind (LL _(fetch LINES of TEXTOBJ)) while LL		 do (COND		      ((AND (ILEQ (fetch CHAR1 of LL)				  CHLIM)			    (IGEQ (fetch CHARLIM of LL)				  CH#))			(replace DIRTY of LL with T)))		    (SETQ LL (fetch NEXTLINE of LL)))	      (\TEDIT.HISTORYADD (create TEDITHISTORYEVENT reusing EVENT THLEN _(ADD1 (IDIFFERENCE											CHLIM CH#))								   THCH# _ CH# THFIRSTPIECE _ PC1 								   THOLDINFO _ OLDLOOKSLIST THTEXTOBJ 								   _ TEXTOBJ))                                                             (* Save this action for undo/redo)	      (SETQ CHANGEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))	      (AND CHANGEDLINE (\FILLWINDOW (fetch YBOT of CHANGEDLINE)					    CHANGEDLINE TEXTOBJ THISLINE))	      (TEDIT.SET.SEL.LOOKS SEL (QUOTE NORMAL))	      (SETQ TEDIT.PENDINGDEL NIL)	      (\FIXSEL SEL TEXTOBJ)	      (\SHOWSEL SEL NIL T))	    (T (CLRPROMPT)	       (printout PROMPTWINDOW "Please select some text to modify first" T])(TEDIT.UNDO.LOOKS  [LAMBDA (TEXTOBJ EVENT LEN CH# FIRSTPIECE)                 (* jds " 4-AUG-83 09:57")                                                             (* Set looks on the current selection from the 							     TEDIT.CHARLOOKS.WINDOW)    (PROG ((SEL (fetch SEL of TEXTOBJ))	   (PCTB (fetch PCTB of TEXTOBJ))	   CHLIM CHANGEDLINE (OLDLOOKSLIST (fetch THOLDINFO of EVENT))	   (NEWLOOKSLIST NIL)	   (\INPC (fetch \INSERTPC of TEXTOBJ))	   (THISLINE (fetch THISLINE of TEXTOBJ)))          (bind ((PC _(fetch THFIRSTPIECE of EVENT))) for OLDLOOKS in OLDLOOKSLIST	     do (SETQ NEWLOOKSLIST (NCONC1 NEWLOOKSLIST (fetch PLOOKS of PC)))                                                              (* Remember this for the undo.)		(replace PLOOKS of PC with OLDLOOKS)         (* Give this piece its old looks)		[COND		  ((EQ PC \INPC)		    (replace INSERTFONT of TEXTOBJ with (fetch CLFONT of (fetch PLOOKS of PC]		(SETQ PC (fetch NEXTPIECE of PC)))          (replace THOLDINFO of EVENT with NEWLOOKSLIST)     (* Remember the other looks in case we UNDO the UNDO.)          (bind (LL _(fetch LINES of TEXTOBJ))		(CHLIM _(IPLUS (fetch THCH# of EVENT)			       (fetch THLEN of EVENT)			       -1))	     while LL	     do (COND		  ((AND (ILEQ (fetch CHAR1 of LL)			      CHLIM)			(IGEQ (fetch CHARLIM of LL)			      CH#))		    (replace DIRTY of LL with T)))		(SETQ LL (fetch NEXTLINE of LL)))          (SETQ CHANGEDLINE (\FIXCHANGEDPART TEXTOBJ THISLINE))          (AND CHANGEDLINE (\FILLWINDOW (fetch YBOT of CHANGEDLINE)					CHANGEDLINE TEXTOBJ THISLINE))          (TEDIT.SET.SEL.LOOKS SEL (QUOTE NORMAL))          (SETQ TEDIT.PENDINGDEL NIL)          (\FIXSEL SEL TEXTOBJ)          (\SHOWSEL SEL NIL T])(TEDIT.UNDO.MOVE  [LAMBDA (TEXTOBJ EVENT LEN CH# FIRSTPIECE)                 (* jds "20-JUL-83 12:16")    (SETQ TEDIT.MOVE.PENDING NIL)                            (* First, Turn off the global flag that got us here.)    (PROG ((TOOBJ (fetch THAUXINFO of EVENT))	   (FROMOBJ (fetch THTEXTOBJ of EVENT))	   (SOURCECH# (fetch THOLDINFO of EVENT))	   (CH# (fetch THCH# of EVENT))	   SOURCECH#)          (\SHOWSEL (fetch SEL of TOOBJ)		    NIL NIL)          (\SHOWSEL (fetch SEL of FROMOBJ)		    NIL NIL)          (TEDIT.UNDO.INSERTION FROMOBJ EVENT LEN CH# FIRSTPIECE)          (\SHOWSEL (fetch SEL of TOOBJ)		    NIL NIL)          (\COPYSEL (fetch SEL of TOOBJ)		    TEDIT.SELECTION)          (\SHOWSEL (fetch SEL of FROMOBJ)		    NIL NIL)          (TEDIT.UNDO.DELETION TOOBJ EVENT LEN SOURCECH# (fetch THFIRSTPIECE of EVENT))          (replace THACTION of EVENT with (QUOTE Move))          (replace THTEXTOBJ of EVENT with TOOBJ)          (replace THAUXINFO of EVENT with FROMOBJ)          (replace THOLDINFO of EVENT with CH#)          (replace THCH# of EVENT with SOURCECH#)          (\SHOWSEL (fetch SEL of FROMOBJ)		    NIL NIL)          (\COPYSEL TEDIT.SELECTION (fetch SEL of TOOBJ))          (TEDIT.SET.SEL.LOOKS (fetch SEL of TOOBJ)			       (QUOTE NORMAL))          (\SHOWSEL (fetch SEL of TOOBJ)		    NIL T]))(RPAQ? TEDIT.HISTORYLST NIL)(DECLARE: DOEVAL@COMPILE DONTCOPY(ADDTOVAR GLOBALVARS TEDIT.HISTORYLST))(* Menu interfacing)(DEFINEQ(TEDIT.ADD.MENUITEM  [LAMBDA (MENU ITEM)                                        (* jds " 9-AUG-83 09:55")                                                             (* Adds ITEM to the MENU, and updates all the stuff.)    (PROG (OLDITM)          (COND	    ((MEMBER ITEM (fetch ITEMS of MENU))             (* Do nothing--it's already in the menu)	      )	    ([AND (LISTP ITEM)		  (SETQ OLDITM (SASSOC (CAR ITEM)				       (fetch ITEMS of MENU]                                                             (* The menu item exists. Make sure the thing behind it 							     is right.)	      (RPLACD OLDITM (CDR ITEM)))	    (T                                               (* It isn't in the menu, so go ahead and add it.)	       (replace ITEMS of MENU with (NCONC1 (fetch ITEMS of MENU)						   ITEM))	       (COND		 ((EQ (fetch MENUCOLUMNS of MENU)		      1)                                     (* If there is only one column, force a re-figuring of 							     the number of rows)		   (replace MENUROWS of MENU with NIL))		 ((EQ (fetch MENUROWS of MENU)		      1)                                     (* There's only one row, so recompute # of columns.)		   (replace MENUCOLUMNS of MENU with NIL)))	       (replace ITEMWIDTH of MENU with 10000)	       (replace ITEMHEIGHT of MENU with 10000)	       (replace IMAGE of MENU with NIL)              (* Force it to create a new menu image.)	       (UPDATE/MENU/IMAGE MENU])(TEDIT.DEFAULT.MENUFN  [LAMBDA (W)                                                (* jds "17-AUG-83 15:15")                                                             (* Default User Fn for editor windows--displays a menu 							     of items & acts on the commands received.)    (PROG ((TEXTOBJ (WINDOWPROP W (QUOTE TEXTOBJ)))	   (THISLINE (WINDOWPROP W (QUOTE THISLINE)))	   (WMENU (WINDOWPROP W (QUOTE TEDIT.MENU)))	   THISMENU CH OFILE OCURSOR PCTB LINES SEL ITEM)          (COND	    ((fetch EDITOPACTIVE of TEXTOBJ)	      (FRESHLINE PROMPTWINDOW)	      (printout PROMPTWINDOW "Edit operation in progress; please wait.")	      (RETURN)))          (SETQ PCTB (fetch PCTB of TEXTOBJ))          (SETQ THISMENU (COND	      (WMENU)	      ((SETQ WMENU (WINDOWPROP W (QUOTE TEDIT.MENU.COMMANDS)))		(PROG1 (SETQ WMENU (\TEDIT.CREATEMENU WMENU))		       (WINDOWPROP W WMENU)))	      (TEDIT.DEFAULT.MENU)))          (RESETLST [RESETSAVE (PROGN (replace EDITOPACTIVE of TEXTOBJ with T)				      TEXTOBJ)			       (QUOTE (AND (replace EDITOPACTIVE of OLDVALUE with NIL]		    (SELECTQ (CAR (SETQ ITEM (MENU THISMENU)))			     (Put                            (* If the guy was editing a file, make a new updated 							     version; else, ask for a file name)				  (TEDIT.PUT TEXTOBJ NIL (EQ (CDR ITEM)							     (QUOTE LEFT)))                                                             (* If he selected this with left button, force a new 							     file name.)				  )			     (Get                            (* Get a new file (overwriting the one being edited.))				  (TEDIT.GET TEXTOBJ))			     (Include                        (* Insert a file where the caret is)				      (TEDIT.INCLUDE TEXTOBJ THISLINE))			     (Quit                           (* Stop this session.)				   (\TEDIT.QUIT W))			     (Substitute                     (* Search-and-replace)					 (TEDIT.REPLACE (fetch STREAMHINT of TEXTOBJ)))			     (Find                           (* EXACT-MATCH SEARCH COMMAND)				   (FRESHLINE PROMPTWINDOW)				   [SETQ OFILE (PROMPTFORWORD "Text to find: " (WINDOWPROP								W								(QUOTE TEDIT.LAST.FIND.STRING))							      NIL PROMPTWINDOW NIL NIL							      (CHARCODE (EOL LF ESC]				   [COND				     ([EQ OFILE (CONSTANT (CHARACTER (CHARCODE DEL]                                                             (* NOTHING--HE HIT DEL.)				       )				     (OFILE (SETQ SEL (fetch SEL of TEXTOBJ))					    (\SHOWSEL SEL NIL NIL)					    (SETQ CH (TEDIT.FIND TEXTOBJ (MKSTRING OFILE)))					    (COND					      (CH            (* We found the target text.)						  (replace CH# of SEL with CH)                                                             (* Set up SELECTION to be the found text)						  [replace CHLIM of SEL						     with (SUB1 (IPLUS CH (NCHARS OFILE]						  (replace DCH of SEL with (NCHARS OFILE))						  (replace POINT of SEL with (QUOTE RIGHT))						  (TEDIT.SET.SEL.LOOKS SEL (QUOTE NORMAL))                                                             (* Always selected normally)						  (SETQ TEDIT.PENDINGDEL NIL)                                                             (* And never pending a deletion.)						  (\FIXSEL SEL TEXTOBJ)						  (\SHOWSEL SEL NIL T)						  (TEDIT.NORMALIZECARET TEXTOBJ)						  (WINDOWPROP W (QUOTE TEDIT.LAST.FIND.STRING)							      OFILE)                                                             (* And get it into the window)						  )					      (T (printout PROMPTWINDOW "String '" OFILE 							   "' not found."							   T)						 (\SHOWSEL SEL NIL T]				   (replace \INSERTNEXTCH of TEXTOBJ with -1))			     (Looks                          (* He wants to set the font for the current selection)				    (\TEDIT.LOOKS TEXTOBJ THISLINE))			     (AND (CAR ITEM)				  (APPLY* (CAR ITEM)					  (fetch STREAMHINT of TEXTOBJ])(TEDIT.REMOVE.MENUITEM  [LAMBDA (MENU ITEM)                                        (* edited: "15-JUL-83 17:21")    (PROG (ITEMLIST)          [COND	    ((LITATOM ITEM)	      (for X in (fetch ITEMS of MENU) do (COND						   ((AND (LISTP X)							 (EQUAL (CAR X)								ITEM))						     (RETURN (SETQ ITEM X]          (RETURN (COND		    ((MEMBER ITEM (SETQ ITEMLIST (fetch ITEMS of MENU)))		      (replace ITEMS of MENU with (REMOVE ITEM ITEMLIST))		      (replace MENUCOLUMNS of MENU with NIL)		      (replace MENUROWS of MENU with NIL)		      (UPDATE/MENU/IMAGE MENU))		    (T NIL])(\TEDIT.CREATEMENU  [LAMBDA (ITEMS)                                            (* jds " 3-AUG-83 10:23")                                                             (* Create a TEdit command menu, given a list of menu 							     items.)    (create MENU	    ITEMS _ ITEMS	    CENTERFLG _ T	    MENUFONT _(FONTCREATE (QUOTE HELVETICA)				  10				  (QUOTE BOLD))	    WHENHELDFN _(QUOTE \TEDIT.MENU.WHENHELDFN)	    WHENSELECTEDFN _(QUOTE \TEDIT.MENU.WHENSELECTEDFN])(\TEDIT.MENU.WHENHELDFN  [LAMBDA (ITEM MENU BUTTON)                                 (* jds "24-FEB-83 19:23")    (COND      ((ATOM ITEM)	(CLRPROMPT)	(PROMPTPRINT (SELECTQ ITEM			      (Put "Sends the document to a file")			      (Get "Gets a new file as the document to edit.")			      (Looks "Changes the font/size/etc. of characters")			      (Find "Searches for a string")			      (Quit "Ends the edit session")			      "")))      (T (DEFAULTMENUHELDFN ITEM MENU BUTTON])(\TEDIT.MENU.WHENSELECTEDFN  [LAMBDA (ITEM MENU BUTTON)                                 (* jds "28-APR-83 18:09")                                                             (* A Selection fn for preserving the button pressed, for							     special handling in PUT, e.g.)    (CONS (DEFAULTWHENSELECTEDFN ITEM MENU BUTTON)	  BUTTON]))(DECLARE: DOEVAL@COMPILE DONTCOPY(ADDTOVAR GLOBALVARS TEDIT.DEFAULT.MENU))(RPAQ? TEDIT.DEFAULT.MENU (\TEDIT.CREATEMENU (QUOTE (Put Get Include Find Looks Substitute Quit))))[OR (SASSOC (QUOTE TEdit)	    BackgroundMenuCommands)    (NCONC1 BackgroundMenuCommands (QUOTE (TEdit (QUOTE (TEDIT))						 "Opens a TEdit window for use."](SETQ BackgroundMenu NIL)(FILESLOAD TEDITHCPY)(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA ))(DECLARE: DONTCOPY  (FILEMAP (NIL (18754 264046 (CHARLOOKS.FROM.FONT 18764 . 19469) (COERCETEXTOBJ 19471 . 22117) (EQCLOOKS 22119 . 23405) (SEEFILE 23407 . 23723) (TEDIT 23725 . 25212) (TEDIT.BUILD.PCTB 25214 . 28324) (TEDIT.CHARWIDTH 28326 . 29605) (TEDIT.COPY 29607 . 32534) (TEDIT.CR.UPDATESCREEN 32536 . 41443) (TEDIT.CREATEW 41445 . 41788) (TEDIT.CURSORMOVEDFN 41790 . 42706) (TEDIT.CURSOROUTFN 42708 . 43198) (TEDIT.DELETE 43200 . 43803) (TEDIT.DO.BLUEPENDINGDELETE 43805 . 44524) (TEDIT.EXTEND.SEL 44526 . 49023) (TEDIT.FIND 49025 . 51271) (TEDIT.FORMATTEDP 51273 . 52150) (TEDIT.GET 52152 . 54760) (TEDIT.GET.CHARLOOKS 54762 . 56767) (TEDIT.GET.OBJECT 56769 . 57772) (TEDIT.GET.PARALOOKS 57774 . 59149) (TEDIT.GETINPUT 59151 . 59580) (TEDIT.GETSEL 59582 . 59778) (TEDIT.INCLUDE 59780 . 64037) (TEDIT.INSERT 64039 . 66684) (TEDIT.INSERT.DISPLAYTEXT 66686 . 70923) (TEDIT.INSERT.OBJECT 70925 . 74561) (TEDIT.INSERT.UPDATESCREEN 74563 . 86112) (TEDIT.LOOKS 86114 . 94238) (TEDIT.MAKESEL 94240 . 94989) (TEDIT.MODIFYLOOKS 94991 . 96181) (TEDIT.MOVE 96183 . 97884) (TEDIT.NEW.FONT 97886 . 98206) (TEDIT.PARAPPLY 98208 . 99267) (TEDIT.PUT 99269 . 103334) (TEDIT.PUT.CHARLOOKS 103336 . 105648) (TEDIT.PUT.OBJECT 105650 . 107027) (TEDIT.PUT.PARALOOKS 107029 . 108566) (TEDIT.PUT.PCTB 108568 . 113067) (TEDIT.PUT.PIECE.DESCRIPTOR 113069 . 114351) (TEDIT.QUIT 114353 . 115299) (TEDIT.REDO.REPLACE 115301 . 116122) (TEDIT.REPLACE 116124 . 118575) (TEDIT.SCAN.LINE 118577 . 126916) (TEDIT.SCANSEL 126918 . 127486) (TEDIT.SEEPARA 127488 . 128396) (TEDIT.SEL.AS.STRING 128398 . 129958) (TEDIT.SELECT 129960 . 131985) (TEDIT.SELECT.LINE.SCANNER 131987 . 138230) (TEDIT.SET.SEL.LOOKS 138232 . 139798) (TEDIT.SETSEL 139800 . 142076) (TEDIT.SHOWSEL 142078 . 142568) (TEDIT.STRINGWIDTH 142570 . 143119) (TEDIT.UNDO.REPLACE 143121 . 144400) (TEDIT.\INSERT 144402 . 146559) (\ATMIN 146561 . 146837) (\ATMOUT 146839 . 147181) (\COPYSEL 147183 . 148815) (\DOFORMATTING 148817 . 153488) (\DWIN 153490 . 153701) (\DWOUT 153703 . 153982) (\TEDIT.BUTTONEVENTFN 153984 . 163946) (\TEDIT.GET.INSERT.CHARLOOKS 163948 . 164909) (\TEDIT.HCPYFMTSPEC 164911 . 165502) (\TEDIT.INTERRUPT.SETUP 165504 . 166564) (\TEDIT.LOOKS 166566 . 174128) (\TEDIT.LOOKS.UPDATE 174130 . 175552) (\FIXDLINES 175554 . 178722) (\FIXILINES 178724 . 181674) (\FIXSEL 181676 . 189753) (\PNC 189755 . 190305) (\SHOWTEXT 190307 . 191526) (\STRINGIN 191528 . 192057) (\STRINGOUT 192059 . 192553) (\TEDIT.BLTCHAR 192555 . 194085) (\TEDIT.CHARDELETE 194087 . 195507) (\TEDIT.CLOSEUPLINES 195509 . 198522) (\TEDIT.COMMAND.LOOP 198524 . 207890) (\TEDIT.DELETE 207892 . 231608) (\TEDIT.FIND.FIRST.LINE 231610 . 233879) (\TEDIT.FIND.LAST.LINE 233881 . 234896) (\TEDIT.FIXDELSEL 234898 . 236554) (\TEDIT.FIXSELS 236556 . 237087) (\TEDIT.FONTCOPY 237089 . 237476) (\TEDIT.FOREIGN.COPY? 237478 . 238486) (\TEDIT.FORMATTEDP1 238488 . 239499) (\TEDIT.NEWREGIONFN 239501 . 241227) (\TEDIT.QUIT 241229 . 242634) (\TEDIT.QUIT2 242636 . 243007) (\TEDIT.SET.WINDOW.EXTENT 243009 . 244838) (\TEDIT.SHOWSELS 244840 . 245375) (\TEDIT.UPDATE.SHOWSEL 245377 . 252288) (\TEDIT.WINDOW.SETUP 252290 . 259490) (\TEDIT.WORD.BOUND 259492 . 259904) (\TEDIT.WORDDELETE 259906 . 261758) (\TEDIT1 261760 . 263251) (\WATOM 263253 . 263567) (\WSTRING 263569 . 264044)) (268180 339401 (TEDIT.DEACTIVATE.WINDOW 268190 . 269960) (\EDITREPAINTFN 269962 . 271042) (\EDITRESHAPEFN 271044 . 274471) (TEDIT.WINDOW.TITLE 274473 . 275100) (TEDIT.DELETELINE 275102 . 275855) (\DISPLAYLINE 275857 . 280757) (\EDITSCROLLFN 280759 . 290134) (\FILLWINDOW 290136 . 297700) (\FIXCHANGEDPART 297702 . 304780) (\FORMATLINE 304782 . 315373) (\PULLTEXT 315375 . 320230) (\SHOWSEL 320232 . 327320) (\PUSHLINES 327322 . 329306) (\PUSHTEXT 329308 . 337719) (\BACKFORMAT 337721 . 339399)) (339435 345245 (\TEDIT.READTABLE 339445 . 340617) (\TEDIT.WORDBOUND.READTABLE 340619 . 342383) (TEDIT.GETSYNTAX 342385 . 342818) (TEDIT.SETSYNTAX 342820 . 343334) (TEDIT.GETFUNCTION 343336 . 343809) (TEDIT.SETFUNCTION 343811 . 344471) (TEDIT.WORDGET 344473 . 344706) (TEDIT.WORDSET 344708 . 345243)) (346421 347893 (\TEDIT.ABBREV.EXPAND 346431 . 347891)) (348107 349638 (\TEDIT.PROCIDLEFN 348117 . 348889) (\TEDIT.PROCENTRYFN 348891 . 349241) (\TEDIT.PROCEXITFN 349243 . 349636)) (349671 351700 (PLCHAIN 349681 . 349901) (PRINTLINE 349903 . 351698)) (351746 356217 (\EDIT.DOWNCARET 351756 . 352101) (\EDIT.FLIPCARET 352103 . 354109) (TEDIT.FLASHCARET 354111 . 354294) (\EDIT.UPCARET 354296 . 354607) (TEDIT.NORMALIZECARET 354609 . 355772) (\SETCARET 355774 . 356215)) (356705 381113 (\TEDIT.HISTORYADD 356715 . 357073) (TEDIT.UNDO 357075 . 359571) (TEDIT.UNDO.INSERTION 359573 . 361842) (TEDIT.UNDO.DELETION 361844 . 364963) (TEDIT.REDO 364965 . 368123) (TEDIT.REDO.INSERTION 368125 . 371757) (TEDIT.REDO.LOOKS 371759 . 377529) (TEDIT.UNDO.LOOKS 377531 . 379534) (TEDIT.UNDO.MOVE 379536 . 381111)) (381253 389016 (TEDIT.ADD.MENUITEM 381263 . 382863) (TEDIT.DEFAULT.MENUFN 382865 . 386994) (TEDIT.REMOVE.MENUITEM 386996 . 387666) (\TEDIT.CREATEMENU 387668 . 388162) (\TEDIT.MENU.WHENHELDFN 388164 . 388658) (\TEDIT.MENU.WHENSELECTEDFN 388660 . 389014)))))STOP