<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Carol>SOURCES>LISPDMC.DM!1>LGC.mc</title>
  </head>
  <body>
    <pre>
   :Title[LGC.mc, December 6, 1982  1:44 PM, Masinter];   KnowRBase[LTEMP0];   TOP LEVEL;   InsSet[LispInsSet, 1];:if[Reduced];	UfnOps[25];	UfnOps[24];:else;*--------------------------------------------------------------------opGCREF:	* modify reference count of DATUM according to CASE*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1;   CASE&larr; (Id) + (100000c), call[GCLOOKUP];   pd&larr; T, memBase&larr; StackM2BR;   branch[.+2, alu#0], pd&larr; T and (htstkcnt);	branch[.htnil];   branch[.+2, alu#0];	NextOpCode;* new entry created, return NIL.htnil:   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; AT.NIL, NextOpCode;   regOP2[25, StackM2BR, opGCREF, noNData];*--------------------------------------------------------------------opRPLPTR:	* takes (PTR VAL) on stack, alpha byte is offset		* replace pointer at PTR+offset with VAL, doing		* two reference counts*--------------------------------------------------------------------   T&larr; (TSP) - (4c);   T&larr; (fetch&larr; T) + 1;   T&larr; Md, fetch&larr; T;   LTEMP1&larr; (Id) + (Md);   branch[.rplptr1, carry'], memBase&larr; LScratchBR, LEFT&larr; (LEFT) + 1;	T&larr; T + 1, branch[.rplptr1];.rplptr1:   BrLo&larr; LTEMP1;   BrHi&larr; T;	PAGEFAULTOK;   T&larr; (fetch&larr; 0s) + 1;* RPLPTR1: * call with LScratchBR pointing to cell containing old value* T&larr; (fetch&larr; 0s) + 1 just done* TSP contains new valueRPLPTR1:   Case&larr; 1c, call[GCLOOKUP];	* deleteref old pointer   TSP &larr; (TSP) - (2c);   memBase&larr; StackBR;RPLPTRTAIL:   T&larr; (fetch&larr; TSP) + 1;   Case&larr; 0c, call[GCLOOKUP];	* addref new value   memBase&larr; LScratchBR;   fetch&larr; 0s;   T&larr; Md;   T&larr; T and (lhmask);   T&larr; T + (LTEMP0);		* put high bits back   store&larr; 0s, dbuf&larr; T;		* store new value   store&larr; 1s, dbuf&larr; LTEMP1;GCOPTAIL:   pd&larr; (PSTATE) and (or[PS.HTCNTFULL!, PS.HTOVERFLOW!]c);   branch[.+2, alu#0], PSTATE&larr; (PSTATE) and not (PS.HTOVERFLOW);	 NextOpCode;   branch[.+2, alu#0], A&larr; Id, NARGS&larr; 1c;      DEFLO&larr; AT.GCSCAN, branch[DOCALLPUNT];   PSTATE&larr; (PSTATE) and not (PS.HTCNTFULL);   DEFLO&larr; AT.GCOVERFLOW, branch[DOCALLPUNT];regOP2[24, StackBR, opRPLPTR, noNData];*--------------------------------------------------------------------   SUBROUTINE;*--------------------------------------------------------------------* called with CASE * T&larr; (fetch&larr; hi word) + 1 done* return pointer counted in LTEMP0,,LTEMP1, with T = entry in htableGCLOOKUP:   T&larr; MD, fetch&larr; T;				* could fault	PAGEFAULTNOTOK;   T&larr; T and (rhmask), LTEMP1&larr; Md;   memBase&larr; tyBaseBR, LTEMP0&larr; T, branch[.+2];GCLOOKT1:	* called with CASE 	* pointer to reference in in T, LTEMP1	* return pointer counted in LTEMP0,,LTEMP1, with T = entry in htable   memBase&larr; tyBaseBR, LTEMP0&larr; T;   T&larr; rcy[T, LTEMP1, 11];   fetch&larr; T;   PROBE&larr; Md, memBase&larr; htMainBR;   branch[.+2, R&gt;=0], pd&larr; (PROBE) and (TT.LISPREF);	T&larr; A0, return;				* no reference   branch[.+2, alu=0], T&larr; (LTEMP1) rsh 1;	LTEMP2&larr; Link, branch[.htpunt];		* always do in lisp   PROBE &larr; fetch &larr; T;				* fetch main table entry   ENTRY &larr; Md, T&larr; (LTEMP0) + (LTEMP0);   branch[.+2, R even], pd&larr; ENTRY;	LTEMP2&larr; Link, branch[.htpunt];		* collision   branch[.htnotempty, alu#0], LTEMP2&larr; Link;TOP LEVEL;   bdispatch&larr; CASE;   T&larr; T or (ht1cnt), branch[.htprobe];.htnotempty:   T&larr; ldf[ENTRY, 10, 1];			* get hi bits of entry   pd&larr; T xor (LTEMP0);				* compare hi bits of pointer   branch[.+2, alu=0], pd&larr; (ENTRY) + (ht1cnt);	branch[.htpunt];			* collision   goto[.htoverflow, carry], Link&larr; LTEMP2;   bdispatch&larr; CASE;   T&larr; ENTRY, branch[.htprobe];.htprobe:   DISPTABLE[5],   T&larr; T + (ht1cnt), branch[.htstore];		* case 0: addref   T&larr; T - (ht1cnt), branch[.htstore];		* case 1: delref   T&larr; T or (htstkbit), branch[.htstore];	* case 2: stkref.htstore:   LTEMP3&larr; T and (htStkCnt);   pd&larr; (LTEMP3) xor (ht1cnt);SUBROUTINE;   branch[.+2, alu=0], Link&larr; LTEMP2;   store&larr; PROBE, dbuf&larr; T, return;   store&larr; PROBE, T&larr; (dbuf&larr; 0c), return;.htoverflow:   T&larr; ENTRY, return;TOP LEVEL;.htpunt:   MemBase&larr; htOfloBR, T&larr; A0, branch[.+2, R&gt;=0], CASE;	CallUFN;	* if CASE negative, do UFN if not fit.htpuntloop:   T&larr; (fetch&larr; T) + 1;   pd&larr; Md;   branch[.+2, alu=0], PSTATE&larr; (PSTATE) or (PS.HTOVERFLOW);	T&larr; T + 1, branch[.htpuntloop];   LTEMP3&larr; (store&larr; T) - 1, dbuf&larr; LTEMP1;   T&larr; LSH[CASE, 10];   T&larr; T + (LTEMP0);   store&larr; LTEMP3, dbuf&larr; T; SUBROUTINE;   Link&larr; LTEMP2;   return;:endif;	* Reduced</pre>
  </body>
</html>
