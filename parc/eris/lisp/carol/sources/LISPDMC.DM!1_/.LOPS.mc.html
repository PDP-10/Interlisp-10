<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Carol>SOURCES>LISPDMC.DM!1>LOPS.mc</title>
  </head>
  <body>
    <div style="width: 472pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">   :Title[LOPS.mc, January 18, 1983  5:15 PM, Masinter];<br><br>   KnowRBase[LTEMP0];<br>   TOP LEVEL;<br>   InsSet[LispInsSet, 1];<br><br>*--------------------------------------------------------------------<br>opPOP:<br>*--------------------------------------------------------------------<br>   TSP&larr; (TSP) - (2c);<br>   Left&larr; (Left) + 1, NextOpcode;<br><br>regOP1[277, StackBR, opPOP, noNData];<br><br>*--------------------------------------------------------------------<br>opTYPEP:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* TYPEP, LISTP same code<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1, call[TYPREV];<br>   T&larr; T and (rhmask);<br>   pd&larr; (Id) - T;<br>   branch[.+2, alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NextOpcode;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* continue if type same<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* return NIL<br>   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; 0c, NextOpCode;<br><br>regOP1[3, StackM2BR, opTYPEP, listType!];<br>regOP2[5, StackM2BR, opTYPEP, noNData];<br><br>*--------------------------------------------------------------------<br>opNTYPX:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1,   call[TYPREV];<br>   T&larr; T and (rhmask);<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;   <br>   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;<br><br>regOP1[4, StackM2BR, opNTYPX, noNData];<br>*--------------------------------------------------------------------<br>opDTEST:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* test if type name of tos = arg, ufn if not<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1, call[TYPREV];<br>   memBase&larr; dtdBR;<br>   T&larr; lsh[T, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch type name of DTD<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   FETCH&larr; T, T &larr; LTEMP0, RisID;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* This is really T&larr; (Id);<br>   T&larr; lsh[T, 10];<br>   T&larr; (Id) + T;<br>   pd&larr; T - (MD);<br>   branch[.dtestfail, alu#0], Q&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br>   NextOpCode;<br><br><br>.dtestfail:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br>   CallUFN;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* type disagree<br><br>regOP3[6, StackM2BR, opDTEST, noNData];<br><br><br>:if[NOCREATECELL];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* NO CREATECELL AT ALL NOW<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UFNOPS[37];<br>:else;<br>*--------------------------------------------------------------------<br>opCREATECELL:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1;<br>   T&larr; Md, fetch&larr; T;<br>   pd&larr; T - (SmallHi);<br>   branch[.+2, alu=0], T&larr; Md, memBase&larr; dtdBR;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* TOS = typenumber<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br>   T&larr; lsh[T, 4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get DTD<br>   T&larr; T + (DTD.FREE);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch free list<br>   LTEMP2&larr; T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch head of free list<br>   LTEMP0&larr; Md, T&larr; (fetch&larr; T) + (sub[DTD.SIZE!, add[DTD.FREE!, 1]]c); <br>   LTEMP1&larr; Md, fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP0, 1&larr; free list head<br>   LTEMP3&larr; Cnt&larr; Md;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP3 & Cnt &larr; Size<br><br>:if[Debugging];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (LTEMP1) and (777c);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* word # in MDSpage of new cell<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T + (LTEMP3);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* plus count<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pd&larr; T - (1000c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, alu&lt;=0];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">UCodeCheck[CreateCrossesPageBoundary];<br>:endif;<br><br>   branch[.+2, Cnt#0&-1], memBase&larr; ScratchLZBR;<br>   </span><span class="tab" val="67"></span><span style="font: 10pt serif">UCodeCheck[allocateZeroSizeCell];<br>   BrHi&larr; LTEMP0;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (FETCH&larr; LTEMP1) + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch contents of free<br>   LTEMP4&larr; MD, T&larr; (fetch&larr; T) - (2c);<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   LTEMP3&larr; Md, T&larr; T + (LTEMP3);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* loloc + size - 1<br><br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (STORE&larr; T) - 1, branch[.+2, Cnt=0&-1];<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.clearnew];<br>*</span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK, branch[.cleardone];<br><br><br>.clearnew:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (STORE&larr; T) - 1, dbuf&larr; 0c, branch[., Cnt#0&-1];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>:if[Debugging];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pd&larr; (LTEMP1) - T - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UCodeCheck[];<br>:endif;<br><br>.cleardone:<br>   memBase&larr; dtdBR, T&larr; LTEMP2;<br>   T&larr; (store&larr; T) - 1, dbuf&larr; LTEMP3;<br>   store&larr; T, pd&larr; dbuf&larr; LTEMP4;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* store back new free cell<br><br>   branch[.+2, alu#0],<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; (LTEMP2)+(sub[DTD.COUNTER!,add[1,DTD.FREE!]]c);<br>     PSTATE&larr; (PSTATE) or (PS.HTCNTFULL);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* free list became empty<br><br>   fetch&larr; LTEMP2;<br>   T&larr; (Md) + 1;<br>   store&larr; LTEMP2, dbuf&larr; T;<br>   pd&larr; T - (MaxConsCount);<br>   branch[.+2, carry];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PSTATE&larr; (PSTATE) or (PS.HTCNTFULL);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* too many createcells<br><br>* save return value<br><br>   memBase&larr; StackM2BR, T&larr; TSP;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;<br>   store&larr; T, dbuf&larr; LTEMP1;<br><br>   T&larr; (fetch&larr; TSP) + 1;<br>   Case&larr; 1c, call[GCLOOKUP];<br>   branch[GCOPTAIL];<br><br>regOP1[37, StackM2BR, opCREATECELL, noNData];<br>:endif;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* NOCREATECELL<br><br><br><br>*--------------------------------------------------------------------<br>* subroutine to get type of datum<br>*--------------------------------------------------------------------<br>* leaves rbase alone, returns with membase&larr; StackBR<br>* ptr in LTEMP0,,LTEMP1, rbase[LTEMP0], T&larr; type<br>   SUBROUTINE;   <br><br>TYPREV:<br>   T&larr; LTEMP0&larr; Md, fetch&larr; T;<br>   LTEMP1&larr; Md, memBase&larr; tybaseBR;<br>   T&larr; rcy[T, LTEMP1, 11];<br>   fetch&larr; T;<br>   T&larr; Md, memBase&larr; StackM2BR, return;<br><br>   TOP LEVEL;<br><br><br>:if[NOBIN];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UfnOps[40];<br>:else;<br><br>*--------------------------------------------------------------------<br>opBIN:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1, call[TYPREV];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* returns with type in T<br>   PD&larr; (Id) - T, memBase&larr; ScratchLZBR;<br>   branch[.+2, alu=0], BrHi&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (FETCH&larr; LTEMP1) + 1;<br>   LTEMP0&larr; MD, T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP0= CCOFF<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   T&larr; Md, LTEMP1&larr; (fetch&larr; T) + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T=NCCHARS<br>   LTEMP0&larr; Md, pd&larr; T - (Q&larr; LTEMP0) - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; HiBuf, pd&larr; NCCHARS-CCOFF<br>   branch[.+2, carry], LTEMP1&larr; (fetch&larr; LTEMP1) - (3c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br>   branch[.+2, R&lt;0], LTEMP0, memBase&larr; ScratchBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* readable bit is off<br>   T&larr; Md, BrHi&larr; LTEMP0;<br>   BrLo&larr; T, LTEMP0&larr; Q, call[DOGETBYTE];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* actually fetch byte<br>   memBase&larr; StackM2BR, T&larr; LTEMP0;<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;<br>   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T;<br>   memBase&larr; ScratchLZBR;<br>   T&larr; (Q) + 1;<br>   store&larr; LTEMP1, dbuf&larr; T, NextOpCode;<br><br><br><br>regOP1[40, StackM2BR, opBIN, streamType!];<br>:endif; *NOBIN<br><br>*--------------------------------------------------------------------<br>opREADPRINTERPORT:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; NOT(EventCntA&rsquo;), branch[</span><span style="font: 10pt monospace">PUSHSMALLT</span><span style="font: 10pt serif">];<br>regOP1[164, StackM2BR, opREADPRINTERPORT, noNData];<br>*--------------------------------------------------------------------<br>opWRITEPRINTERPORT:<br>*--------------------------------------------------------------------<br>   T&larr; (TSP) - 1;<br>   fetch&larr; T;<br>   EventCntB&larr; Md, NextOpCode;<br><br>regOP1[165, StackBR, opWRITEPRINTERPORT, noNData];<br><br><br>*--------------------------------------------------------------------<br>opCAR:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1, call[TYPREV]; * returns with type in T<br>   PD&larr; (Id) - T, memBase&larr; ScratchLZBR;<br>.car1:<br>   branch[.carnlist, alu#0], BrHi&larr; LTEMP0;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (FETCH&larr; LTEMP1) + 1;<br>   LTEMP0&larr; MD, fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* CAN FAULT<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   T&larr; (LTEMP0) and (lhmask);<br>   branch[.+2, alu#0], LTEMP0&larr; T&larr; (LTEMP0) - T, memBase&larr; StackM2BR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP1&larr; Md, memBase&larr; ScratchLZBR, pd&larr; A0, branch[.car1];<br><br><br>   T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T;<br>   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;<br><br>.carnlist:<br>   T&larr; (LTEMP1);<br>.crnlist:<br>   pd&larr; (LTEMP0) or T;<br>   branch[.+2, alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">NextOpCode;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br><br>regOP1[1, StackM2BR, opCAR, listType!];<br>*--------------------------------------------------------------------<br>opCDR:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1, call[TYPREV]; * returns with type in T<br>   pd&larr; (Id) - T, memBase&larr; ScratchLZBR;<br>.cdr1:<br>   branch[.cdrnlist, alu#0], BrHi&larr; LTEMP0;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (FETCH&larr; LTEMP1) + 1;<br>   LTEMP0&larr; MD, T&larr; (fetch&larr; T) and (lhmask);<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   LTEMP1&larr; T;<br><br>   branch[.cdrind, R&gt;=0], LTEMP0, T&larr; ldf[LTEMP0, 7, 10];<br>   T&larr; T + T;<br>   branch[.cdrnil, alu=0], T&larr; T + (LTEMP1), memBase&larr; StackM2BR;<br><br>.cdronpage:<br>   TSP&larr; (TSP) + 1;<br>   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;<br><br>.cdrnil:<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;<br>   TSP&larr; (store&larr; TSP) - 1, dbuf&larr; 0c, NextOpCode;<br><br>.cdrind:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* indirect or local indirect<br>   T&larr; T + T;<br>   branch[.+2, alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP1&larr; Md, memBase&larr; ScratchLZBR, pd&larr; A0, branch[.cdr1];<br><br>.cdrlocalind:<br>   T&larr; (LTEMP1) + T;<br>   T&larr; (fetch&larr; T) + 1;<br>   T&larr; Md, fetch&larr; T, branch[REPTMD];<br><br>.cdrnlist:<br>   T&larr; (LTEMP1), branch[.crnlist];<br><br>regOP1[2, StackM2BR, opCDR, listType!];<br><br>:if[NORPLACS];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UfnOps[30];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UfnOps[31];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">UfnOps[</span><span style="font: 10pt monospace">32</span><span style="font: 10pt serif">];<br>:else;<br>*--------------------------------------------------------------------<br>opRPLACA:<br>*--------------------------------------------------------------------<br>   T&larr; (TSP) - (4c);<br>   T&larr; (fetch&larr; T) + 1, call[TYPREV];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* returns with type in T,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* pointer in LTEMP0, LTEMP1<br>   PD&larr; T - (listType);<br>   branch[.+2, alu=0], LEFT&larr; (LEFT) + 1, memBase&larr; LScratchBR; <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* not a list<br><br>.rplaca1:<br>   BrHi&larr; LTEMP0;<br>   BrLo&larr; LTEMP1;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   T&larr; (FETCH&larr; 0s) + 1;<br>   LTEMP0&larr; MD;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   PD&larr; (LTEMP0) and (lhmask);<br>   branch[.rplacaind, alu=0];<br>   branch[RPLPTR1];<br><br><br>.rplacaind:<br>   fetch&larr; T;<br>   LTEMP1&larr; Md, branch[.rplaca1];<br><br>regOP1[30, StackBR, opRPLACA, NoNData];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* RPLACA<br><br><br>*--------------------------------------------------------------------<br>opRPLACD:<br>*--------------------------------------------------------------------<br>   T&larr; (TSP) - (4c);<br>   T&larr; (fetch&larr; T) + 1, call[TYPREV];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* returns with type in T,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* pointer in LTEMP0, LTEMP1<br>   PD&larr; T - (listType);<br>   branch[.+2, alu=0], LEFT&larr; (LEFT) + 1, memBase&larr; LScratchBR; <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* not a list<br><br>.rplacd1:<br>   BrHi&larr; LTEMP0, T&larr; A0;<br>   BrLo&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* set LScratchBR to point to list cell&rsquo;s segment<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   LTEMP1&larr; (FETCH&larr; LTEMP1) + 1, Q&larr; LTEMP1;</span><span class="tab" val="67"></span><span style="font: 10pt serif"> <br>   LTEMP2&larr; MD;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP2 now has high word of cell<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   branch[.rplacdind, R&gt;=0], T&larr; (LTEMP2) and (77400c); * test hi bit of cell<br><br>* local bit of cdrcode on; look at TSP to see if NIL, samepage<br>   memBase&larr; StackM2BR;<br>   TSP&larr; (fetch&larr; TSP) + 1;<br>   T&larr; Md, TSP&larr; (fetch&larr; TSP) - (3c);<br>   LTEMP4&larr; Md, pd&larr; T or (Md), memBase&larr; LScratchBR;<br>   branch[.rplacdnil, alu=0], pd&larr; T - (LTEMP0);<br>   branch[.rplacdnewcell, alu#0], LTEMP1&larr; Md, T&larr; (Md) xor (LTEMP1);<br>   pd&larr; T and not (rhmask);<br>   branch[.rplacdonpage, alu=0], T&larr; LTEMP0;<br>   </span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.rplacdnewcell];<br><br>.rplacdonpage:<br>* must addref new cell<br>   CASE&larr; 0c, call[GCLOOKT1];<br>   memBase&larr; LScratchBR;<br>   LTEMP1&larr; (fetch&larr; Q) + 1;<br>   LTEMP4&larr; LSH[LTEMP4, 7];<br>   T&larr; Md, LTEMP4&larr; (LTEMP4) or (100000c);<br>   T&larr; T and (77400c), branch[.rplacdlocal];<br><br>.rplacdnil:<br>   LTEMP4&larr; 100000c;<br>   T&larr; (LTEMP2) and (77400c);<br><br>.rplacdlocal:<br>   branch[.rplacdnoref, alu=0], T&larr; RSH[T, 7]; * potentially deleteref old ptr<br>   LTEMP1&larr; (LTEMP1) and (lhmask);<br>   LTEMP1&larr; T + (LTEMP1);<br>   T&larr; LTEMP0;<br>   CASE&larr; 1c, call[GCLOOKT1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* deleteref T,,LTEMP1<br>   memBase&larr; LScratchBR;</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br><br>.rplacdnoref:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* store new cdrcode<br>   fetch&larr; Q;<br>   T&larr; (rhmask);<br>   T&larr; T and (Md);<br>   T&larr; T + (LTEMP4);<br>   store&larr; Q, dbuf&larr; T, branch[GCOPTAIL];<br><br><br>   <br>.rplacdnewcell:<br>   TSP&larr; (TSP) + (2c);<br>   CallUFN;<br><br>.rplacdind:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* "local" bit was off<br>   branch[.rplacdlocalind, alu#0], T&larr; RSH[T, 7];<br>   LTEMP0&larr; Md, fetch&larr; LTEMP1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* full indirect, fetch new cell<br>   LTEMP1&larr; Md, branch[.rplacd1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* use new pointer<br><br>.rplacdlocalind:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* use CDR code as offset <br>   LTEMP1&larr; (LTEMP1) and (lhmask);<br>   T&larr; T + (LTEMP1);<br>   BrLo&larr; T;<br>   T&larr; (fetch&larr; 0s) + 1, branch[RPLPTR1];<br><br>regOP1[31, StackBR, opRPLACD, NoNData];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* RPLACD<br><br><br>msc[DTD.NEXTPAGEs, DTD.NEXTPAGE!];<br>msc[DTD.COUNTERs, DTD.COUNTER!];<br><br>*--------------------------------------------------------------------<br>opCONS:<br>*--------------------------------------------------------------------<br>* LTEMP0, 1 have CDR<br>* LTEMP2, 3 hold new cons (and LScratchBR)<br>* LTEMP4 has CDR code (also used by .makeconscell subroutine)<br><br>   T&larr; (fetch&larr; TSP) + 1, call[TYPREV];<br>   pd&larr; (Id) - T, memBase&larr; LScratchBR;<br>   branch[.conslist, alu=0], T&larr; BRHi&larr; LTEMP0;<br>   pd&larr; T or (LTEMP1), memBase&larr; ListpDTDBR;<br>   dblbranch[.consnil, .consother, alu=0], LTEMP4&larr; (200c);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* cdrcode<br><br>.conslist:<br>   T&larr; ldf[LTEMP1, 7, 1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* [src, size, pos];<br>   LTEMP4&larr; T + (200c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* new cdr code<br>   T&larr; (LTEMP1) and (lhmask), branch[.constail];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* base of CDR&rsquo;s page<br><br>.consnil:<br>   fetch&larr; DTD.NEXTPAGEs;<br>   T&larr; Md, memBase&larr; LScratchBR;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; nxtpage<br>   LTEMP0&larr; RSH[T, 10];<br>   branch[.+2, alu#0], BRHi&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.consfail];<br>   T&larr; LSH[T, 10];<br><br>.constail:<br>   LTEMP1&larr; BrLo&larr; T;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   FETCH&larr; 0s;<br>   LTEMP3&larr; MD;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* word 0 of page: [cnt, nxt]<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   branch[.cnsod1, R odd], LTEMP3,<br>      T&larr; LTEMP3&larr; (LTEMP3) - (400c);<br>   branch[.+2, alu&gt;=0], T&larr; T and (rhmask);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* "next"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.consfail];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* no cells left<br>   branch[.cnszer, alu=0],<br>     LTEMP1&larr; (fetch&larr; T) + (LTEMP1);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch next<br>   T&larr; Md, LTEMP3&larr; RSH[LTEMP3, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; [nxt,x], LTEMP3&larr; cnt<br>   LTEMP3&larr; RCY[LTEMP3, T, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* [cnt,nxt]<br>   branch[.cnsod2, R odd], store&larr; 0s, dbuf&larr; LTEMP3;<br><br>   BRLo&larr; LTEMP1;<br><br>   T&larr; LTEMP0;<br>   Case&larr; 1c, call[GCLOOKT1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* deleteref new cell<br><br><br>   memBase&larr; ListpDTDBR;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* increment conscount<br>   fetch&larr; DTD.COUNTERs;<br>   T&larr; (MaxConsCount);<br>   T&larr; Md, pd&larr; T - (Md);<br>   branch[.+2, carry], T&larr; T + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PSTATE&larr; (PSTATE) or (PS.HTOVERFLOW);<br>   store&larr; DTD.COUNTERs, dbuf&larr; T;<br><br>   memBase&larr; StackM2BR, LEFT&larr; (LEFT) + 1;<br>   TSP&larr; (TSP) - (2c);<br>   T&larr; fetch&larr; TSP;<br>   LTEMP0&larr; Md, T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;<br>   fetch&larr; T;<br>   LTEMP1&larr; Md, store&larr; T, dbuf&larr; LTEMP1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"> * save new cell on stack<br><br><br>   T&larr; lsh[LTEMP4, 10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* shift cdrcode<br>   T&larr; (LTEMP0) or T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* merge with new CAR<br>   LTEMP1&larr; Md, memBase&larr; LScratchBR;<br>   store&larr; 0s, dbuf&larr; T;<br>   store&larr; 1s, dbuf&larr; LTEMP1;<br><br>   T&larr; LTEMP0;<br>   Case&larr; A0, call[GCLOOKT1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* addref new CDR<br><br>   Case&larr; A0, memBase&larr; StackBR;<br>   T&larr; (fetch&larr; TSP) + 1, call[GCLOOKUP];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* addref new CDR<br>   branch[GCOPTAIL];<br><br>.consother:<br>   CallUFN;<br><br>regOP1[</span><span style="font: 10pt monospace">32</span><span style="font: 10pt serif">, StackM2BR, op</span><span style="font: 10pt monospace">CONS</span><span style="font: 10pt serif">, listType!];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* </span><span style="font: 10pt monospace">CONS</span><span style="font: 10pt serif"><br><br>.cnsod1:<br>   uCodeCheck[badcons];<br><br>.cnsod2:<br>   uCodeCheck[badcons];<br><br>.cnszer:<br>   uCodeCheck[badcons];<br><br>.consfail:<br>   CallUFN;<br><br>:endif;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* NORPLACS<br><br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
