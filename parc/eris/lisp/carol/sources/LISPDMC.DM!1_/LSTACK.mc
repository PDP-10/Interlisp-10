:Title[LSTACK.mc, December 7, 1982  3:42 PM, Masinter];* STACK MANAGEMENT ROUTINES, COMMON INSTRUCTION TAILS	KnowRBase[LTEMP0];	TOP LEVEL;	InsSet[LispInsSet, 1];*--------------------------------------------------------------------opMYALINK:*--------------------------------------------------------------------	T_ (PVAR) - (FXBACK[ALINK]);	fetch_ T, T_ (177776c);	T_ T and Md;	T_ T - (FX.PVAR), branch[PUSHSMALLT];regOP1[146, StackBR, opMYALINK, noNData];*--------------------------------------------------------------------TL.ST0TMD:   T_ Md, LTEMP0_ (store_ LTEMP0) + 1, dbuf_ T, branch[TL.ST0];*--------------------------------------------------------------------TL.ST0:   store_ LTEMP0, dbuf_ T, NextOpCode;*--------------------------------------------------------------------TL.PUSHNIL:	TSP_ (store_ TSP) + 1, dbuf_ AT.NIL, NextOpCode;z37568(1792)\f8 542f0 75f8 70f0 48f8 70f0*--------------------------------------------------------------------TL.PUSHTRUE:	TSP_ (store_ TSP) + 1, dbuf_ AT.T, NextOpCode;*--------------------------------------------------------------------TL.PUSHT:	TSP_ (store_ TSP) + 1, dbuf_ T, NextOpCode;z37568\1f8 70f0 62f8 70f0*--------------------------------------------------------------------TL.NOP:	nop;	NextOpCode;*--------------------------------------------------------------------TL.DECTSP2: * after PCF_, normally	TSP_ (TSP) - (2c);	NextOpCode;*--------------------------------------------------------------------SUBROUTINE;SUB.PUSHT:	TSP_ (store_ TSP) + 1, dbuf_ T, return;*--------------------------------------------------------------------TOP LEVEL;PUSHT0:	branch[.+2, R>=0], LEFT_ (LEFT) - 1, memBase_ StackBR;		StackCheck;:if[Debugging];	pd_ T and not (77c);	branch[.+2, alu=0];		uCodeCheck[badpushval];:endif;	T_ (store_ TSP) + 1, dbuf_ T;	TSP_ (store_ T) + 1, dbuf_ LTEMP0, NextOpCode;*--------------------------------------------------------------------PUSHSMALLT:	branch[.+2, R>=0], LEFT_ (LEFT) - 1, memBase_ StackBR;		StackCheck;	TSP_ (store_ TSP) + 1, dbuf_ SmallHi, branch[TL.PUSHT];*--------------------------------------------------------------------PUSHTMD: 	PAGEFAULTNOTOK;	branch[.+2, R>=0], LEFT_ (LEFT) - 1, memBase_ StackBR;		StackCheck;:if[Debugging];	pd_ T and not (77c);	branch[.+2, alu=0];		uCodeCheck[badpushval];:endif;   T_ Md, TSP_ (store_ TSP) + 1, dbuf_ T, branch[TL.PUSHT];*--------------------------------------------------------------------:if[Debugging];PUSHTQ: 	pd_ T and not (77c);	branch[.+2, alu=0];		uCodeCheck[badpushval];PUSHTQOK: 	branch[.+2, R>=0], LEFT_ (LEFT) - 1, memBase_ StackBR;		StackCheck;:else;PUSHTQ: PUSHTQOK: 	branch[.+2, R>=0], LEFT_ (LEFT) - 1, memBase_ StackBR;		StackCheck;:endif;	TSP_ (store_ TSP) + 1, dbuf_ T;	TSP_ (store_ TSP) + 1, dbuf_ Q, NextOpCode;PUSHQT: PUSHQTOK: 	branch[.+2, R>=0], LEFT_ (LEFT) - 1, memBase_ StackBR;		StackCheck;:if[Debugging];	LTEMP0_ Q;	pd_ (LTEMP0) and not (77c);	branch[.+2, alu=0];		uCodeCheck[badpushval];:endif;	TSP_ (store_ TSP) + 1, dbuf_ Q, branch[TL.PUSHT];*--------------------------------------------------------------------SUBROUTINE;ADDSTK:		* called by FNCALL and MYFRAME when not enough stack	T_ (fetch_ ESP) + 1;					* next stack word	T_ Md, fetch_ T;	pd_ T xor (FreeStackBlock);	 branch[.addstkFail, alu#0];	ESP_ (ESP) + (Md), branch[.mergefree];FIXSTACKREGS:	memBase_ StackBR;	PVAR_ (PVAR) - (sub[FX.PVAR!, FX.NEXT!]c);	PVAR_ (fetch_ PVAR) + (sub[FX.PVAR!, FX.NEXT!]c);	T_ ESP_ Md;	TSP_ T, branch[.mergefree];FIXLEFT:	T_ ESP, branch[.fixleft1];.mergefree:	T_ (fetch_ ESP) + 1;	T_ Md, fetch_ T;	pd_ T xor (FreeStackBlock);	branch[.fixleft1, alu#0], T_ ESP;	ESP_ (ESP) + (Md), branch[.mergefree];.fixleft1:	LEFT_ T - (TSP);	LEFT_ (LEFT) rsh 1;	LEFT_ (LEFT) - (LEFTOffset), return;TOP LEVEL;.addstkFail:	branch[STKOVPUNT];*--------------------------------------------------------------------* REPTMD - replace value on top of stack with value in T,,MD*--------------------------------------------------------------------REPTMD:	memBase_ StackM2BR;:if[Debugging];	pd_ T and not (77c);	branch[.+2, alu=0];		uCodeCheck[badpushval];:endif;	T_ Md, TSP_ (store_ TSP) + 1, dbuf_ T;	TSP_ (store_ TSP) - 1, dbuf_ T, NextOpcode;* ---- debugging subroutines:if[Debugging];SUBROUTINE;CHECKPCXSUBR:   pd_ (PSTATE) and (PS.PCXBAD);   branch[.+2, alu#0];   return;   PSTATE_ Link;TOP LEVEL;	UCodeCheck[PuntInCall];:endif;:if[DebugEachInst];SUBROUTINE;DontKnowRBase;*--------------------------------------------------------------------NEXTOP: GLOBAL, * debug code that gets executed at the end of each instruction*--------------------------------------------------------------------	RBASE_RBASE[PSTATE];	PSTATE_ (PSTATE) and (not[PS.PCXBAD!]C);	branch[.+2, alu#0], LTEMP1_ Link;	ifuJump[0];TOP LEVEL;	UcodeCheck[];:endif;z37568\1f8 70f0 28f8 70f0 69f8 70f0 66f8 70f0 12f8 28f0 4f8g3f0G4f8g112f0G10f8g91G70g32f0G4f8g3f0G4f8g96G117f0 4f8 3f0 4f8 39g73f0G10f8g12G157g56f0G10f8g3G31f0 4f8 3f0 4f8 39g2G47f0 4f8 3f0 4f8 47g1G83f0 2f8 7f0 2f8 25f0 4f8 3f0 4f8 39g92f0G10f8g12G738f0 4f8 14f0 4f8 3f0 4f8 10f0 4f8 3f0 4f8 5f0 4f8 52f0g9f8G234g73f0G10f8g11G165f0 67f8 29f0 25f8