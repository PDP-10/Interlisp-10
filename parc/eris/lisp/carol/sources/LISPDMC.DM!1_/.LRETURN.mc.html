<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Carol>SOURCES>LISPDMC.DM!1>LRETURN.mc</title>
  </head>
  <body>
    <pre>
   :Title[LRETURN.mc, December 7, 1982  12:44 PM, Masinter];*--------------------------------------------------------------------* RETURN*--------------------------------------------------------------------   KnowRBase[LTEMP0];   top level;   InsSet[LispInsSet, 1];opRETURN:   T&larr; (fetch&larr; TSP) - 1, FlipMemBase;   LTEMP0&larr; Md, fetch&larr; T, T&larr; (FXBACK[ALINK]);   LTEMP1&larr; Md, T&larr; (PVAR) - T;   fetch&larr; T, LTEMP3&larr; (rhmask);				* get alink field   LTEMP2&larr; Md;   branch[.nquick, R odd], LTEMP2, T&larr; (LTEMP2) - (FXBACK[IVAR]);   T&larr; (fetch&larr; T) + (FXDIF[DEFLO, IVAR]);   Q&larr; IVAR, IVAR&larr; Md, T&larr; (fetch&larr; T) + 1;		* new IVAR   DEFLO&larr; Md, T&larr; (fetch&larr; T) + (FXDIF[PC, DEFHI]);   T&larr; Md, PVAR&larr; (fetch&larr; T) + (FXDIF[PVAR, PC]);   T&larr; T and (LTEMP3), memBase&larr; ifuBR;			* new PVAR:if[FNStats];   BrHi&larr; T, branch[.+2, R&lt;0], FnStatsPtr;	branch[.retstat], BrLo&larr; DEFLO;:else;   BrHi&larr; T;   BrLo&larr; DEFLO;:endif;   BrLo&larr; DEFLO;   T&larr; ESP, PCF&larr; Md;.finishret:   LEFT&larr; T - Q, memBase&larr; StackBR;   T&larr; (store&larr; Q) + 1, dbuf&larr; LTEMP0;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;   LEFT&larr; (LEFT) rsh 1;   LEFT&larr; (LEFT) - (add[LeftOffset!, 1]c), NextOpCode;:if[FNStats];.retstat:   DEFHI&larr; T; PCF&larr; Md, call[.storeretstat];	* finish this operation   T&larr; ESP, branch[.finishret];:endif;IFUpause[20,1,StackM2BR,0,opReturn,noNData, 0, 0];*--------------------------------------------------------------------* NQUICK cases of return*--------------------------------------------------------------------	m[HardReturn, CallUFN];.nquick:   T&larr; (PVAR) - (FXBACK[ALINK]);   T&larr; (fetch&larr; T) + (FXDIF[CLINK, ALINK]);   LTEMP2&larr; Md, T&larr; (fetch&larr; T) + (FXDIF[BLINK, CLINK]);   pd&larr; (LTEMP2) - (Md) - 1, branch[.+2, R odd];	UCodeCheck[BadFrame];   branch[.+2, alu=0], LTEMP2&larr; (LTEMP2) - 1;	HardReturn;			* alink#clink* LTEMP2 is returnee   T&larr; (LTEMP2) - (FXBACK[FLAGS]);      fetch&larr; T;					* flagword   T&larr; Md;:if[Debugging];   LTEMP3&larr; T and (StackMask);   pd&larr; (LTEMP3) xor (FxtnBlock);   branch[.+2, alu=0];	uCodeCheck[BadFrame];:endif;   pd&larr; T and (rhmask);   branch[.+2, alu=0], T&larr; (LTEMP2) - (FXBACK[NEXT]);	HardReturn;			* usecnt of returnee # 0   fetch&larr; T, T&larr; FreeStackBlock;   LTEMP3&larr; fetch&larr; Md;			* LTEMP3 points to returnee's next   pd&larr; T xor (Md);			* T &larr; flags   branch[.+2, alu#0], T&larr; IVAR;	branch[DORETURN];* check for contiguous BF   pd&larr; T xor (LTEMP3);			* is IVAR=returnee's next?   branch[.+2, alu=0], T&larr; (PVAR) - (FXBACK[BLINK]);	HardReturn;   fetch&larr; T;   T&larr; Md;   fetch&larr; T;   T&larr; Md;   pd&larr; T and (rhmask);   branch[DORETURN, alu=0];     HardReturn;DORETURN:	* do return to LTEMP2   T&larr; (PVAR) - (FXBACK[BFLAGS]);   fetch&larr; T, T&larr; add[BfResidual!, rhmask!]c;   pd&larr; T and Md;   branch[.freefx, alu=0], T&larr; IVAR;:if[Debugging];.checkfreebf:   T&larr; (PVAR) - (FXBACK[ALINK]);   fetch&larr; T;   LTEMP3&larr; Md;   branch[.+2, R odd], LTEMP3;	UCodeCheck[ShouldBeSlowFrame];   T&larr; (PVAR) - (FXBACK[BLINK]);:else;.checkfreebf:   T&larr; (PVAR) - (FXBACK[BLINK]);:endif;   fetch&larr; T, T&larr; (rhmask);   LTEMP3&larr; fetch&larr; Md;					* get bf flags   LTEMP4&larr; Md, pd&larr; T and Md;   branch[.nqnz, alu#0], T&larr; (LTEMP3) + (2c);:if[Debugging];   T&larr; (LTEMP3) + 1;   T&larr; (fetch&larr; T) + 1;   pd&larr; (IVAR) - (Md);   branch[.+2, alu=0];	uCodeCheck[IVARWRONG];:endif;   T&larr; T - (IVAR);   IVAR&larr; (store&larr; IVAR) + 1, dbuf&larr; FreeStackBlock;   store&larr; IVAR, dbuf&larr; T, branch[.clresid];.nqnz:	* leave BF alone, just decrement use count   T&larr; (LTEMP4) - 1;   store&larr; LTEMP3, dbuf&larr; T, branch[.clresid];.clresid:   T&larr; (PVAR) - (FXBACK[BFLAGS]);:if[Debugging];   fetch&larr; T;   LTEMP3&larr; Md;   pd&larr;(LTEMP3) and (BFResidual);   branch[.+2, alu#0];	uCodeCheck[StackBad];   nop;:endif;.freefx:				* make from T to ESP into a free block   ESP&larr; (ESP) - T;   T&larr; (store&larr; T) + 1, dbuf&larr; FreeStackBlock;   store&larr; T, dbuf&larr; ESP;   PVAR&larr; LTEMP2;*--------------------------------------------------------------------RTN2:	* return to frame at PVAR with LTEMP0,,LTEMP1*--------------------------------------------------------------------   memBase&larr; StackBR;:if[Debugging];   T&larr; (PVAR) - (FXBACK[FLAGS]);   fetch&larr; T;   T&larr; Md;   T&larr; T and (StackMask);   pd&larr; T xor (FxtnBlock);   branch[.+2, alu=0];	uCodeCheck[BadFrame];:endif;   T&larr; (PVAR) - (FXBACK[IVAR]);   T&larr; (fetch&larr; T) + (FXDIF[NEXT,IVAR]);   IVAR&larr; Md, fetch&larr; T;   ESP&larr; Md;   TSP&larr; Md, fetch&larr; Md;.extend:   ESP&larr; (fetch&larr; ESP) + 1;   T&larr; Md;   pd&larr; T xor (FreeStackBlock);   branch[.+2, alu#0], T&larr; ESP&larr; (fetch&larr; ESP) - 1;	ESP&larr; (ESP) + (Md), branch[.extend];   T&larr; (T - (TSP)) rsh 1;   branch[.+2, carry], LEFT&larr; T - (LeftOffset);	uCodeCheck[noStackAtPunt];   T&larr; (PVAR) - (FXBACK[FLAGS]);   fetch&larr; T;   LTEMP2&larr; Md;   pd&larr; (LTEMP2) and (FXInCall);   branch[.retcall, alu#0], pd&larr; (LTEMP2) and (FXNoPushReturn);   branch[.nopush, alu#0], Q&larr; TSP;   T&larr; (store&larr; Q) + 1, dbuf&larr; LTEMP0;   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;   branch[.retfe2, R&gt;=0], Left&larr; (Left) - 1;	uCodeCheck[NoStackAtPunt];.nopush:   LTEMP2&larr; (LTEMP2) and not (FXNoPushReturn);   store&larr; T, dbuf&larr; LTEMP2;			* turn off no pushbit   .retfe2:   T&larr; (PVAR) - (FXBACK[IVAR]);   T&larr; (fetch&larr; T) + (FXDIF[DEFLO, IVAR]);   IVAR&larr; Md, T&larr; (fetch&larr; T) + 1;   DEFLO&larr; Md, T&larr; (fetch&larr; T) + (FXDIF[PC, DEFHI]);   DEFHI&larr; Md, fetch&larr; T, T&larr; (rhmask);   DEFHI&larr; (DEFHI) and T, memBase&larr; ifuBR;   BrHi&larr; DEFHI;   BrLo&larr; DEFLO;   PCF&larr; Md;:if[FNStats];   branch[.+2, R&lt;0], FnStatsPtr;   call[.storeretstat];   NextOpCode;:else;   nop;   NextOpCode;:endif;.retcall:   LTEMP2&larr; (LTEMP2) and not (FXInCall);   store&larr; T, dbuf&larr; LTEMP2;   T&larr; (TSP) - 1;   T&larr; (fetch&larr; T) - 1;   DEFLO&larr; Md, T&larr; (fetch&larr; T) - 1;   DEFHI&larr; Md, T&larr; (fetch&larr; T) - 1;   NARGS&larr; Md; fetch&larr; T;:if[Debugging];   pd&larr; DEFHI;   branch[.+2, alu=0], LTEMP0&larr; Md;	uCodeCheck[BadRetCall];   pd&larr; (LTEMP0) xor (SmallHi);   branch[.+2, alu=0];	uCodeCheck[BadRetCall];:endif;   TSP&larr; T, branch[RESTARTCALL0];</pre>
  </body>
</html>
