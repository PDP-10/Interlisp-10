<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Carol>SOURCES>LISPDMC.DM!1>LFV.mc</title>
  </head>
  <body>
    <pre>
:TITLE[LFV.mc, December 6, 1982  1:31 PM, Masinter];   knowrbase[LTEMP0];   TOP LEVEL;   InsSet[LispInsSet, 1];RME[FVEP, LTEMP1];RME[FVNAME, LTEMP2];RME[FVTMP, LTEMP3];RME[FVCHAIN, LTEMP4];RME[FVINDEX, NARGS];RME[FVHI, DEFHI];RME[FVLO, DEFLO];:if[Reduced];	UfnOps[54];	UfnOps[57];:else;*--------------------------------------------------------------------opEVAL:*--------------------------------------------------------------------   T&larr; (fetch&larr; TSP) + 1, call[TYPREV];   T&larr; T and (rhmask);   pd&larr; T - (atomType);   branch[.evalatom, alu=0], pd&larr; T;   branch[.evalother, alu=0], pd&larr; T - (add[FixpType!, 1]c);   branch[.evalret, alu&lt;0], pd&larr; T - (ListType);   branch[.+2, alu=0], NARGS&larr; 1c;	CallUFN;	* not atom, fixp, listp.evalListp:   DEFLO&larr; AT.EVALFORM, branch[DOCALLPUNT];.evalother:   CallUFN;	* let UFN decide.evalret: NextOpCode;	* return self.evalatom:   FVNAME&larr; pd&larr; LTEMP1;	* note FVNAME= LTEMP2 really   branch[.+2, alu#0], pd&larr; (FVNAME) - (AT.T);	NextOpCode;	* eval of NIL=NIL   branch[.+2, alu#0], T&larr; (FX.PVAR);	NextOpCode;	* eval of T=T   nop;	* funny placement constraint   FVEP&larr; (PVAR) - T, call[DOLOOKUP];   memBase&larr; ScratchLZBR;   BrHi&larr; FVHI;	PAGEFAULTOK;   T&larr; (FETCH&larr; FVLO) + 1;   T&larr; Md, fetch&larr; T;	PAGEFAULTNOTOK;   pd&larr; (FVHI) - (StackHi);   branch[.+2, alu#0], pd&larr; T, memBase&larr; StackM2BR;	branch[REPTMD];   pd&larr; (1s) - (Md);   branch[.+2, alu=0];	branch[REPTMD];   callUFN;	* value is NOBINDregOP1[54, StackM2BR, opEVAL, noNData];*--------------------------------------------------------------------opSTKSCAN:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1;	FVNAME&larr; Md, fetch&larr; T, T&larr; (FX.PVAR);	FVNAME&larr; Md, pd&larr; FVNAME;	branch[.+2, alu=0], pd&larr; FVNAME;		CallUFN;	* not LITATOM	branch[.+2, alu#0];		CallUFN;	* NIL	nop;	FVEP&larr; (PVAR) - T, call[DOLOOKUP];	memBase&larr; StackM2BR, T&larr; TSP;	T&larr; (store&larr; T) + 1, dbuf&larr; FVHI;	store&larr; T, dbuf&larr; FVLO, NextOpCode;REGOP1[57, StackM2BR, opSTKSCAN, noNData];:endif[Reduced];*--------------------------------------------------------------------SUBROUTINE;  FVLOOKUP:*--------------------------------------------------------------------* look up free variable # T/2 in current frame* fill in location where value is bound* preserve LTEMP0   memBase&larr; ifuBR;	PAGEFAULTOK;   FETCH&larr; add[FNH.NLFV!]s;   FVNAME&larr; T rsh 1;		* free variable index   FVCHAIN&larr; (PVAR) + T + 1;	* where to fill in the indirection   FVTMP&larr; MD;			* nlocals, fvoffset	PAGEFAULTNOTOK;   T&larr; rsh[FVTMP, 10];		* T&larr; NLOCALS   FVTMP&larr; (FVTMP) and (rhmask);   T&larr; (FVTMP) - T;   T&larr; T + (FVNAME);   fetch&larr; T;   FVNAME&larr; Md, T&larr; (FX.PVAR);   FVEP&larr; (PVAR) - T;   memBase&larr; StackBR;   store&larr; FVCHAIN, dbuf&larr; 0c, branch[.newframe];*--------------------------------------------------------------------DOLOOKUP:*--------------------------------------------------------------------* Scan for free variable FVNAME starting at FVEP, return* in FVHI,FVLO the pointer to where it is bound* if FVCHAIN is odd, store indirection pointer at stackspace* should check for reschedule!!!   FVCHAIN&larr; A0;.newframe:   T&larr; (FVEP) + 1, memBase&larr; StackBR;   fetch&larr; T;   FVEP&larr; Md;   FVEP&larr; (FVEP) and not (1c);   FVEP&larr; (FVEP) - (FX.PVAR);   branch[.endofstack, alu=0], fetch&larr; FVEP;   FVTMP&larr; Md;   pd&larr; (FVTMP) and (FXNTValid);   T&larr; (FVEP) + (FX.DEFLO), branch[.+2, alu=0];	T&larr; (FVEP) + (FX.NTLO);   T&larr; (fetch&larr; T) + 1;   FVTMP&larr; Md, fetch&larr; T, T&larr; (rhmask);   T&larr; T and (Md), memBase&larr; LScratchBR;   BrHi&larr; T;   BrLo&larr; FVTMP;   FVINDEX&larr; FNH.FIRSTNAME;.lookforvar:	PAGEFAULTOK;   FETCH&larr; add[FNH.NTSIZE!]s;	* can fault   FVTMP&larr; Cnt&larr; MD;	* FVTMP = NTSIZE	PAGEFAULTNOTOK;.fvloop:	* this can really be done in a 2 inst loop   branch[.newframe, Cnt=0&amp;-1];   FVINDEX&larr; (fetch&larr; FVINDEX) + 1;   T&larr; Md;   pd&larr; (FVNAME) xor T;   branch[.fvloop, alu#0];% this is what a 2 instruction loop would look like   T&larr; A0;					* # FVNAME   branch[.+2, Cnt#0], pd&larr; T-T-1;	* pd #0	branch[.newframe];   FVINDEX&larr; (fetch&larr; FVINDEX) + 1, branch[.fvfound, alu=0];   T&larr; Md, pd&larr; (FVNAME) xor T, dblbranch[.notfound, .-1, Cnt=0&amp;-1].fvfound:   FVINDEX&larr; (FVINDEX) - (2c);%.fvfound:				* found a match   T&larr; (FVTMP) - 1;      T&larr; T + (FVINDEX);		* add NTSIZE, note FVINDEX already incremented   fetch&larr; T;   FVHI&larr; Md, T&larr; (rhmask);   T&larr; (T and (FVHI)) lsh 1, branch[.fvpfvar, R&lt;0];.fvivar:   FVEP&larr; (FVEP) - 1, memBase&larr; StackBR;   FVEP&larr; (fetch&larr; FVEP) + 1;   FVLO&larr; T + Md;   FVHI&larr; StackHi, branch[.donefvlookup];.fvpfvar:   T&larr; T + (FVEP), memBase&larr; StackBR;   T&larr; T + (FX.PVAR);				* T is stack relative location   T&larr; (fetch&larr; T) + 1;   FVLO&larr; Md, fetch&larr; T;   FVHI&larr; Md, pd&larr; (FVHI) and (40000c);	* check FVAR bit	FVHI&larr; (FVHI) and (rhmask), branch[.fvfvar, alu#0];.fvpvar:   branch[.+2, R&gt;=0], FVLO, FVLO&larr; T - 1, memBase&larr; LScratchBR;	branch[.fvloop];	* unbound PVAR   FVHI&larr; StackHi, branch[.donefvlookup];.fvfvar:   branch[.+2, R odd], FVLO;	branch[.donefvlookup];* should create chain here      branch[.newframe];.endofstack:   FVLO&larr; (FVNAME) + (FVNAME);   FVHI&larr; ValSpace, branch[.donefvlookup];.donefvlookup:   branch[.+2, R odd], FVCHAIN, memBase&larr; StackBR;	return;* kludge!!!	* STORE FVHI in both halves   T&larr; LSH[FVHI, 10];   T&larr; T + (FVHI);   T&larr; (store&larr; FVCHAIN) - 1, dbuf&larr; T;   store&larr; T, dbuf&larr; FVLO, return;</pre>
  </body>
</html>
