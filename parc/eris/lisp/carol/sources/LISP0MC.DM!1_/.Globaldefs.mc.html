<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Carol>SOURCES>LISP0MC.DM!1>Globaldefs.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 6pt; text-align: left">
<span style="font: 10pt serif">INSERT[MPCodes];<br>:TITLE[GlobalDefs];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ed Fiala 3 June 1982<br><br></span><span style="font: 12pt serif">* January 5, 1983  12:02 PM van Melle<br></span><span style="font: 10pt serif">* added PNIPLoc October 15, 1982  5:52 PM<br>* added With3MB and With10MB switch June 30, 1982  9:54 PM<br>* added NotDpyOverlay switch June 21, 1982  12:28 PM van Melle<br><br>*ASSEMBLY SWITCHES<br><br>Set[WithMidas,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 assembles extra code for debugging with Midas:<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 33b mi in Fault on MidasPage<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span class="tab" val="67"></span><span style="font: 10pt serif">(+2 mi if MidasPage # 17b)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  7b mi in Fault on FaultPage<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  3b mi in Timer on TimerPage<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*120b IMReserve on page 17 for Midas Kernel<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 14b IMReserve on page 16 for Kernel timer task in<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*     AMesa, but no IMReserve in MicOverlay.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*NOTE: Include LoadRAM.Dib and KernelOccupied.Dib and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*omit OverlayOccupied.Dib in the MicroD loadup if no<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Initial.<br>Set[CSLOverlay,IFE[WithMidas,0,1,0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* if not WithMidas<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 assembles DisplayInit to read the CSLKeyboard<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*overlay if the attached keyboard is a CSL keyboard<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*and also enables the code for adjusting the TOD<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*clock to 40, 44.5, or 50 mhz crystals.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*DisplayInitPage has an extra 57b mi in this case.<br>Set[FinalOverlay,IFE[WithMidas,0,1,0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* if not WithMidas<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 assembles Initialize.Mc to read in a final<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*overlay before transferring control to StartNova.<br>  Set[NoOverlays,IFE[Or[CSLOverlay,FinalOverlay],0,1,0]];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">*NOTE: if NoOverlays is 0, map and storage init code in Initialize<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">*on pg. 16b is replaced by code which delays before and after the<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">*display of some MP codes; this results in 51b fewer mi on page 16b.<br>Set[SmallTalkMode,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 for SmallTalk instead of Mesa.<br>Set[LispMode,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 for Lisp instead of Mesa.<br>Set[ButteMode,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 for Butte instead of Mesa.<br>Set[AltoXMMode,Or[SmallTalkMode,ButteMode,0]];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Assembles Alto XMLDA and XMSTA opcodes and enables<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*the emulator bank register for BitBlt and the Display<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*task&rsquo;s bank register; adds 10b mi on xoPage, 11b mi<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*on bbXMPage, 3b mi on DisplayPage2, and 1b mi on<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*DisplayPage3.<br>Set[With3MB, 1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">***** assembles 3MB ether microcode<br>Set[With10MB, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">***** assembles 10MB ether microcode<br>Set[WithAltoBitBlt, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">***** assembles Alto BitBlt microcode<br>set[WithPilotBitBlt, IFE[WithAltoBitBlt, 0, 1, 0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* not with AltoBitBlt<br>Set[WithColor, IFE[Or[WithMidas, And[With3MB, With10MB]], 0, 1, 0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">***** assembles color ucode<br><br>MC[cEtherBoot,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Etherboot control constant--10 for Net Exec,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*100 for Mesa Net Exec<br>MC[MaxStack,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Largest referenceable stack address (when StkP<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*points at MaxStack+1 to 17, trap occurs).<br>MC[MinPageCount,1000];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Minimum number of pages at which to allow Initialize<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*to continue with system initialization (if less than<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*this, shows error code on MP).<br><br>%The following integers control assembly of speed improvements in the Alto<br>emulator that consume microstore for additional speed.  Values should be<br>1 to assemble faster version, 0 to use slower but smaller version.<br>%<br>Set[neFastBltBlks,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 expends 53b mi to assemble faster versions of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*BLT and BLKS for a 4% to 9% speed improvement.<br>Set[neFastAGroup,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 expends 41b mi to assemble faster A-group<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*for a 5% to 10% speed improvement.<br>Set[neBCPLI360,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 assembles BCPL runtime for JSR @360 to 370.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Expends 65b mi on nePage, 26b mi on brGarbPage1,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*6b mi on brGarbPage2, and 2b mi on brGarbPage0 for<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*a 25% speed improvement.<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Most storage is on nePage and cannot easily be moved.<br>Set[neBCPLI340,And[neBCPLI360,1]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 assembles BCPL runtime for<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*JSR @340 to 357.  Expends 66b mi on br340Page and<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*3b mi on nePage for a 3% to 8% speed improvement.<br>Set[neBCPL300,And[neBCPLI360,0]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 assembles BCPL runtime for<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*JSR 300 to 332.  Expends 47b mi for a 0% to 2%<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*speed improvement.<br><br>Set[neAltoTraps,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 assembles 30b mi on nePage that cause a breakpoint<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*for illegal opcodes in the range 62000 - 67777.<br>Set[xoTraps,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*1 assembles 6b mi on xoPage for illegal opcodes<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*in the range 61000b to 61037b.<br><br>Set[WithCDC,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Enable color display controller microcode<br><br>IMReserve[17,377,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Reserve location 7777b, which LoadRAM can&rsquo;t handle.<br><br>%MICROCODE ORGANIZATION<br><br>Two debugging systems can be built from the sources: one to drive the LF<br>keyboard and one for the CSL keyboard (with either CSL or LF monitor); these<br>systems can be run directly from Midas because initialization does full map<br>and storage init and there are no microcode overlays.  These systems are<br>built with the NewAMesa.Cm and LFAMesa.Cm command files after assembling<br>the sources with WithMidas=1, CSLOverlay=0, and FinalOverlay=0.  The debugging<br>systems have their own version of LoadRAM and do not include Mesa floating<br>point, audio, Jasmine, or halftone microcode.<br><br>For system releases, an LF keyboard system is assembled in which extra code<br>for the LF keyboard and other overflow are on page 15.  Initial initializes<br>the map and storage, loads AMesa and its overlays in storage starting at<br>VM 1400, and exits via LoadRAM, which loads AMesa into the microstore and<br>transfers control into Initialize.Mc at EGO or KGO.  If the terminal has a<br>CSL keyboard (with either an LF or CSL monitor), then DisplayInit calls<br>LoadRAM to roll in the first overlay; otherwise, it skips this overlay.<br>NOTE: the LF keyboard driver is 74b mi larger than the CSL keyboard driver.<br>A final overlay overwrites the initialization.  The release system makes no<br>provision for debugging with Midas.<br><br>Pages 16 and 17 contain only initialization and Midas communication ucode,<br>and page 15 is sparsely populated with code that wouldn&rsquo;t quite fit elsewhere.<br>For the release system, just before jumping to StartNova, a final overlay<br>overwrites pp 16, 17, and unused locations in page 15; the overlay includes<br>MesaFP, Audio, Jasmine, and JasmineHalftone modules.  Jasmine and halftone<br>microcode is a natural overlay because:<br>(a) it almost fills one page, which is an easy unit of management;<br>(b) nothing in the resident calls it (it is invoked by Mesa JRAM); and<br>(c) it uses the Printer interface, so it could not be debugged from Midas in<br>any case.<br>MesaFP is also a convenient overlay because it is optional--FP opcodes trap<br>to software when no microcode is present.<br><br>If the distribution of resident and overlay code on page 15 changes, both<br>MicOverlayOccupied.Mc and OverlayOccupied.Mc must be edited.  Note that<br>Audio and Jasmine overwrite unused locations in TimerTable; these were<br>initialized in AMesa to crash.  MesaFP overwrites two Misc dispatch<br>locations in MesaX.<br><br>Any combination of WithMidas, CSLOverlay, and FinalOverlay values works, IFF<br>enough storage exists on pages 15b to 17b to accommodate WithMidas=1.<br>On October 16 1981, the final overlay was too large to allow the IMReserve<br>for the Midas kernel, and there were not quite enough free locations on page<br>15b for the 33b mi in Fault.Mc that are conditional upon WithMidas=1.<br>OverlayAll.Cm reassembles all files affected by these switches.  If<br>CSLOverlay=1 or FinalOverlay=1, map and storage init code in Initialize.Mc<br>will not be assembled, so the system will only be startable from Midas<br>indirectly, by running Initial first.  Also IMReserve for Kernel in<br>OverlayOccupied.Mc is not conditional upon WithMidas=1 because there is no<br>alternate use for the locations.<br>%<br><br>*TASK DEFINITIONS<br>Set[BootTask,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Task whose T-register used for booting<br>  IFG[BootTask,3,ER[Initialize.requires.BootTask.be.0.to.3]];<br><br>:IF[WithColor]; ****<br>Set[cdcTask,5];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Color Display<br>:ENDIF;****<br><br>:IF[With3MB];****<br>Set[eoTask,6];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ethernet Output<br>Set[eiTask,Add[eoTask,1]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Ethernet Input<br>  IFE[And[eoTask,14],And[eiTask,14],,ER[eoTask.and.eiTask.inconsistent]];<br>:ENDIF;****<br><br>:IF[With10MB];****<br>Set[</span><span style="font: 12pt serif">enxTask</span><span style="font: 10pt serif">,IFE[With3MB, 0, 7, 5]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*10MB Ethernet Input/Output<br>Set[</span><span style="font: 12pt serif">enxTask</span><span style="font: 10pt serif">2,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*2nd 10MB Ethernet Input/Output<br>Set[</span><span style="font: 12pt serif">enxTask</span><span style="font: 10pt serif">3,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*3rd 10MB Ethernet Input/Output<br>:ENDIF;****<br><br>Set[rdcTask,10];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Disk<br>Set[DpTask,12];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Display<br>Set[TTask,16];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Timer--wired-in, don&rsquo;t change this one<br><br>*Other switch initialization--DON&rsquo;T CHANGE THIS (init only)<br>Set[LFKeyBoard,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Default left alone for CSL keyboard assembly,<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*overruled for LF keyboard assembly<br><br><br>Set[NotDpyOverlay, 0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 0 for overlay assembly, 1 with InitDisplay<br><br>*INITIALIZATION PAGE ASSIGNMENTS<br>Set[InitPage,16];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*356b mi if NoOverlays=1 else 305b mi<br><br>Set[altoExtras, 13];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* was 3, but need space for enxTask *******<br><br>Loca[InitBase,InitPage,200];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*InitBase to InitBase+6 are used<br>**Constants unused here--possibly needed by Lisp<br>  MC[InitLocH,And[InitBase,7400]];<br>    MC[InitLocL,And[InitBase,377]];<br>    MC[K2InitLocL,InitLocL,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*7200 not presently in any .MLF files<br>    MC[KInitLocL,InitLocL,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*7203 known to MakeLoaderFile .MLF files<br>    MC[EInitLocL,InitLocL,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*7204 known to MakeLoaderFile .MLF files<br>Loca[DTabBase,16,240];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 11b mi in Initialize.Mc (allow for growth)<br><br>*NOTE: Page 17 addresses should be larger than 120b to allow the Midas Kernel.<br>*DisplayInitLoc value known to MakeLoaderFile .Mlf files<br>*DisplayInitLoc must be odd; DisplayInitLoc to DisplayInitLoc+6 are used<br>Loca[DisplayInitLoc,17,207];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*161b mi if CSLOverlay = 1, else 102b mi<br>Loca[TimerInitLoc,17,223];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 14b mi<br>Loca[rdcInitLoc,17,203];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 12b mi<br>Set[rdcInitPage2,altoExtras];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 16b mi rest of disk init (MUST NOT OVERWRITE<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*with final overlay).<br>:IF[With3MB];****<br>Loca[EtherInitLoc,17,221];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 24b mi<br>:ENDIF;****<br><br>:IF[With10MB];****<br></span><span style="font: 12pt serif">Set[enxInitPage,17];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Loca[enxInitLoc,enxInitPage,240]; <br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Loca[enxInitLoc2,enxInitPage,242];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Loca[enxInitLoc3,enxInitPage,244]; <br></span><span style="font: 10pt serif">:ENDIF;****<br><br><br>Set[TimerPage,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*36b mi if WithMidas=0 else 41b mi (not pages 4 to 7)<br>  Loca[TimerTable,TimerPage,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*0 to 25b used in this table<br><br><br>*FINAL OVERLAY PAGE ASSIGNMENTS<br></span><span style="font: 12pt serif">***Should move the starting addresses above the Midas Kernel.<br>* Loca[audGoLoc,17,2];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*11b mi on page of this starting address<br>* Set[audPage,17];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*36b mi<br>*   Loca[audGoLoc, audPage, 300];<br>IMRESERVE[TimerPage, 320, 3];</span><span class="tab" val="67"></span><span style="font: 12pt serif">* reserve for overlay<br><br></span><span style="font: 10pt serif">Set[JasPage,17];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*165b mi (not on 4 to 7) for Jasmine scanner<br>  Loca[JasmineOn,JasPage,10];<br>  Loca[JasmineOff,JasPage,11];<br>  Loca[JasminePulse,JasPage,12];<br>Set[HalftonePage,17];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*123b mi (not on 4 to 7) for Jasmine halftone ucode<br>  Loca[PrintLine,HalftonePage,0];<br><br><br>*IO DRIVER PAGE ASSIGNMENTS<br><br>*33b mi in Fault.Mc if WithMidas=1 (35b mi if CSLOverlay is 1)<br>*Set[MidasPage,IFE[CSLOverlay,1,IFE[FinalOverlay,1,15,16],17]];<br>Set[MidasPage,13];<br>  Loca[MidasFaultLoc,112];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*In Midas Kernel (used with GoToExternal)<br>  Loca[MidasBreakLoc,110];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*In Midas Kernel (used with GoToExternal)<br><br>Set[DisplayPage,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*UTVFC--whole page reserved for display<br>  Loca[FldDoneLoc,DisplayPage,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Must be odd<br>  Loca[dpWidthLoc,DisplayPage,2];<br>  Loca[BootSV,DisplayPage,362];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*2b mi in Display.Mc if LFKeyBoard=0<br><br>Loca[KeyTable,15,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*40b mi keyboard translation table if LFKeyBoard=1<br>Set[lfKBPage,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*34b mi for LF keyboard posting code if LFKeyBoard=1<br>*NOTE: Display.Mc sets DisplayPage2/3 equal to DisplayPage if LFKeyboard=0.<br>Set[DisplayPage2,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 3b mi (AltoXMMode only)<br>Set[DisplayPage3,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 1b mi (AltoXMMode only)<br><br><br>:IF[With3MB];*******<br>Set[eePage,IFE[With10MB, 0, 3, 11]];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*15b mi (not pages 4 to 7) Ether.Mc StartIO (task 0)<br>  Loca[eeLocA,eePage,110];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Overwritten location<br>  Loca[eeLocB,eePage,111];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Target of overwritten mi (JA must have<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*odd parity)<br></span><span style="font: 8pt serif"><br>*These four must be on the same page<br></span><span style="font: 10pt serif">Loca</span><span style="font: 8pt serif">[eoStartLoc,</span><span style="font: 10pt serif">eePage</span><span style="font: 8pt serif">,120];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">*Output notify<br></span><span style="font: 10pt serif">Loca[</span><span style="font: 8pt serif">eoTimerDoneLoc,</span><span style="font: 10pt serif">eePage</span><span style="font: 8pt serif">,130];</span><span class="tab" val="67"></span><span style="font: 8pt serif">*Output TimerDone notify<br></span><span style="font: 10pt serif">Loca</span><span style="font: 8pt serif">[eiStartLoc,</span><span style="font: 10pt serif">eePage</span><span style="font: 8pt serif">,140];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">*Input notify<br></span><span style="font: 10pt serif">Loca</span><span style="font: 8pt serif">[eiAbortLoc,</span><span style="font: 10pt serif">eePage</span><span style="font: 8pt serif">,150];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 8pt serif">*SIO abort notify<br></span><span style="font: 10pt serif">:ENDIF;*******<br><br>:IF[With10MB];*******<br></span><span style="font: 12pt serif">Set[enxPage,</span><span style="font: 10pt serif">3</span><span style="font: 12pt serif">];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*10 mb Ethernet microcode<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Loca[enxStartLoc,enxPage,110];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Input notify location<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Loca[enxOTimerDoneLoc,enxPage,114];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Output notify location<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Loca[enxDispTableLoc,enxPage,120];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*TimerDone notify loc<br></span><span style="font: 10pt serif">Set[StartIOPage, 1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* 10b mi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Loca[StartIOLoc, StartIOPage, 340];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* StartIO jumps here<br>:ENDIF;*******<br><br><br>Set[rdcPage,14];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Disk microcode<br><br>Set[DoIntPage,altoExtras];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*13b mi<br>  Loca[DoIntLoc,DoIntPage,364];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*For CSLKeyboard overlay GoToExternal<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*54b mi Color display controller<br>Loca[cdcInitLoc,13,222];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*(Mesa JRAM 56622 turns on)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Output with 0 argument to device cdcTask,,0 turns<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*it off.<br><br>*TASK 0 PAGE ASSIGNMENTS<br><br>*Page 0 allocation is extremely tricky because different code uses it.<br>*Old LoadRAM uses 300-337, 370-371 (new LoadRAM uses 300-331);<br>*Fault uses 0-1 (emulator buffer refill trap and fault entry),<br>*  140-157 for MC12 fault dispatch table.<br>*  200, 202, 204, 206 for notifies (could be moved);<br>*  340-357 (FixDisp in Fault.Mc).<br>Loca[MesaRefillLoc,0,2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Location of MesaRefill subroutine in MesaJ.Mc<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(for overlays with buffer refill code)<br>Set[FaultPage,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Body of fault handler (Not pages 4 to 7).<br>  Loca[FixDisp,FaultPage,340];<br>  Loca[MC12,FaultPage,140];<br>  Loca[EmuNotifyLoc,0,200];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Must be page 0<br>  Loca[NonEmuNotifyLoc,0,202];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Must be page 0<br>  Loca[ContNonEmuLoc,FaultPage,204];<br>  Loca[NonEmuPFLoc,0,206];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*205b to 210b are used; must be page 0<br>Set[PNIPPage,FaultPage];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*12b mi (must be FaultPage--branch to PFExit)<br>  Loca[PNIPLoc,PNIPPage,220];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* for PNIP subroutine<br>Set[LRJPage,0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">**Don&rsquo;t change without coordinating all emulators<br>  Loca[LRJStart,LRJpage,300];<br>  Loca[LRJContinue,LRJpage,301];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Old LoadRAM<br>*  Set[LRJContinue,Add[LRJStart,0]];<br>*  Set[ExchStkPLoc,Add[LRJStart,30]];<br>*  Set[SetStkPLoc,Add[LRJStart,31]];<br><br>Set[QLoc,230];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*02b mi in Initialize for BadWakeup crash code<br><br><br>*TASK 0 PAGE ASSIGNMENTS<br>Set[opPage0,4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*These cannot move since hardware forces the first mi<br>Set[opPage1,5];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*of each bytecode to start at 2001 + (4 * opcode)<br>Set[opPage2,6];<br>Set[opPage3,7];<br>  Loca[KFCRLoc,opPage3,76];<br>  Loca[P7TailLoc,opPage3,27];</span><span class="tab" val="67"></span><span style="font: 10pt serif">**Don&rsquo;t move--used by LRJ<br><br><br>*Pages shared by both Alto and Mesa emulators<br>Set[XMiscPage,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* 6b mi in Timer.Mc<br>  Loca[mxRClkLoc,XMiscPage,250];</span><span class="tab" val="67"></span><span style="font: 10pt serif">******** For Lisp calls to MXRClk<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*13b mi in Disk.Mc<br>:UNLESS[WithPilotBitBlt];<br>Set[bbPage,12];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*BitBlt<br>  Loca[bbIE,bbPage,200];<br>  Loca[bbIF,bbPage,220];<br>  Loca[bbI,bbPage,240];<br>Set[bbXMPage,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*11b mi (not pages 4 to 7) (AltoXMMode only)<br>IFE[And[bbXMPage,14],4,ER[bbXMPage.illegal.page.4.to.7]];<br><br>:ENDIF;<br><br>*Alto emulator page assignments<br>Set[nePage,1];<br>  Loca[neBase,nePage,0];<br>  Loca[JmpFinLoc,nePage,3];</span><span class="tab" val="67"></span><span style="font: 10pt serif">**Don&rsquo;t move--reentry location for Alto LRJ<br>  Loca[OpTab,nePage,20];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Dispatch tables<br>  Loca[IO0Tab,nePage,40];<br>  Loca[IO1Tab,nePage,60];<br><br>*Pieces of the Alto emulator that can be placed on any page<br>Set[neStartPage,13];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*07b mi</span><span class="tab" val="67"></span><span style="font: 10pt serif">--not pg1 (JmpFin) or 3 (TimerTable+3)<br>  Loca[neStartLoc,neStartPage,3]; **5403 known to D0Ram.bcpl<br>Set[neStartPage1,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*04b mi<br>Set[neStartPage2,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*06b mi<br>Set[neFixBPage,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*06b mi<br>Set[ConvertPage1,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*17b mi<br>Set[ConvertPage2,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*27b mi<br>Set[ConvertPage3,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*03b mi<br>Set[neBlksPage0,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*06b mi if neFastBltBlks=1<br>Set[neIntPage1,altoExtras];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*15b mi (not on pages 4 to 7)<br>Set[neMulPage,altoExtras];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*14b mi<br>Set[neDivPage,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*21b mi<br>Set[neLRJPage,0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*10b mi<br>Set[neCSPage,1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*24b mi (not on pages 4 to 7)<br>Set[neIntPage0,altoExtras];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*60b mi if neFastBltBlks=1 (not on pages 4 to 7)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* else 14b mi (pages 4 to 7 ok)<br><br>Set[aoPage,13];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alto A-group (not on pages 4 to 7); 140b mi if<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*neFastAGroup=1 else 77b<br>Set[xoPage,13];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alto extended ops (not on pages 4 to 7)<br>  Loca[xoBase,xoPage,0];<br>  Loca[xoTab0,xoPage,260];<br>  Loca[xoTab1,xoPage,300];<br>:IF[neBCPLI360]; ******************************<br>Set[brGarbPage0,6];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*02b mi<br>Set[brGarbPage1,15];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*26b mi (not on pages 4 to 7)<br>IFE[And[brGarbPage1,14],4,ER[brGarbPage1.illegal.page.4.to.7]];<br>Set[brGarbPage2,13];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*06b mi<br>  :IF[neBCPLI340]; ****************************<br>  Set[br340Page,13];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*66b mi; must = xoPage (uses xoWRTRAM, xoRFAC0)<br>  IFE[br340Page,xoPage,,ER[br340Page.ne.xoPage]];<br>  :ENDIF; *************************************<br>:ENDIF; ***************************************<br>:IF[neBCPL300]; *******************************<br>Set[brJsrPage,13];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*42b mi; can be moved without complications<br>:ENDIF; ***************************************<br><br>:IF[With3MB];*******<br>IFE[And[eePage,14],4,ER[eePage.illegal.page.4.to.7]];<br>:ENDIF;*******<br><br>IFE[And[TimerPage,14],4,ER[TimerPage.illegal.page.4.to.7]];<br>IFE[And[JasPage,14],4,ER[JasPage.illegal.page.4.to.7]];<br>IFE[And[HalftonePage,14],4,ER[HalftonePage.illegal.page.4.to.7]];<br>IFE[And[neIntPage1,14],4,ER[neIntPage1.illegal.page.4.to.7]];<br>IFE[And[neCSPage,14],4,ER[neCSPage.illegal.page.4.to.7]];<br>IFE[neFastBltBlks,1,<br>  IFE[And[neIntPage0,14],4,ER[neIntPage0.illegal.page.4.to.7]]];<br>IFE[And[aoPage,14],4,ER[aoPage.illegal.page.4.to.7]];<br>IFE[And[xoPage,14],4,ER[xoPage.illegal.page.4.to.7]];<br><br>%Addresses for memory error display in RM 100-107 when Midas is connected<br>(These are smashed only on a crash, not on simple breakpoints, so it should<br>be ok for these to overlap useful registers.).<br>%<br>SetTask[4];<br><br>RV4[MapEntry,TaskNumber,RefType,CrashCode,0];<br>RV4[CardNumber,MapFlags,QuadAddr,Syndrome,4];<br><br><br>SetTask[TTask];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Registers for timer task.<br><br>:IF[With10MB];*******<br></span><span style="font: 12pt serif">RV[enxNotify,51];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Notify value for 10 mb Ethernet<br>*RV[enxNotify2,52];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Notify value for 10 mb Ethernet<br>*RV[enxNotify3,53];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Notify value for 10 mb Ethernet<br></span><span style="font: 10pt serif">:ENDIF;*******<br><br>*Storage testing results from Initial--**DON&rsquo;T MOVE**.<br>RV4[xPageCount,xStorageFaults,xHardBadPages,xSoftBadPages,44];<br>*For backward compatibility, initialization copies xPageCount into<br>*StoragePages RM 326) also--eventually remove this after Lisp and Smalltalk<br>*are converted.<br>RV[StoragePages,26];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Copy of xPageCount (counts number of 400b-word pages<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*in which the storage diagnostic found no errors).<br><br>*Although only the top ~7 bits of RTCLow are accurate (i.e., the clock counts<br>*every 2560 cycles), ~35d lower-order bits reduce long-term clock drift to<br>*about crystal quality (1 part in 10&uarr;6? or less than 3 seconds/month).<br>RV[RTCLowLow,22];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Sublow word of Alto RealTime clock<br>RV[RTCLow,23];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Low half of Alto RealTime clock<br>*RConstantLo/Hi and StoragePages must be consecutive for DisplayInit.Mc<br>*(which fixes up RConstantLo/Hi for variable processor clock periods) and<br>*for Initialize.Mc.<br>RV2[RConstantLo,RConstantHi,24];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Addend for RTCLowLow,,RTCLow<br>RV2[TimerBase,TimerBasehi,40];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Base register containing 400b<br>RV[RSImage,42];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*RS232 Image Register<br>RV[TimerTemp,43];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Temporary<br>RM[PNIPSmash0,352];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Register smashed by PNIP calls in Fault.Mc<br>RM[PNIPSmash1,353];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Register smashed by PNIP calls in Fault.Mc (because<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*PNIP defined for task 0 but called by task 17).<br>RV[RTimer,57];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Constant for memory refresh timer<br>RV[Refr,77];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Refresh Address (Don&rsquo;t move--used in Kernel, Fault)<br><br>*Kernel/Initial/Fault registers<br>SetTask[17];<br><br>RV4[PipeReg,PipeReg1,PipeReg2,PipeReg3,60];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Pipe Ram Entry goes here<br>RV2[PipeReg4,PipeReg5,64];<br>RV[FFault,66];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Flags for faults (Also used by LoadRam)<br>RV[FaultParm,67];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*For passing page fault info from task 17 to emu<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">***Have to fix assignment conflict with Jasmine.Mc<br>RV[RTMP,71];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*temporary<br>RV[RXSTK,72];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Stackpointer<br>RV[RXPPB,73];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Page,Parity,BootReason<br>RV[RXCTASK,74];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*CTASK.NCIA<br>RV[RXAPC,75];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*APCTask&APC<br>RV[RXALU,76];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*ALU result and SALUF<br><br>*The following Kernel registers should not be smashed by any code which<br>*might be debugged with Midas, but OK to reuse them by Printer interface<br>*devices such as Jasmine scanner and Audio board.<br>RV[RW1,62];</span><span class="tab" val="67"></span><span style="font: 10pt serif">RV[RW0,63];</span><span class="tab" val="67"></span><span style="font: 10pt serif">RV[RCNT,64];</span><span class="tab" val="67"></span><span style="font: 10pt serif">RV[RADDR,65];<br>RV[RDATA,67];</span><span class="tab" val="67"></span><span style="font: 10pt serif">RV[RWSTAT,70];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Kernel only<br><br><br>SetTask[0];<br><br>*Task 0 registers used during initialization only<br>RV[xCNT,35];<br><br>%Alto emulator registers:<br><br>Each AC is a base register (ACnhi, PCBhi, and DMAhi are initialized by<br>FixNBases called from StartNova).  The stack predecessor to each AC must be<br>smashable by the A-group opcodes (since the StkP counter is 4 bits,<br>predecessor to 60, for example, is 77--watch out).  rpACn registers point at<br>the StkP predecessor to ACn (for PFetch1&rsquo;s, which do a push) and rwpACn<br>points at ACn.<br><br>For Alto, RM 3, 6-7, 21, 25, 40-53, 56-57, 64, 66-67, and 72-73 are temps;<br>RM 0, 12-13, 20, 62-63 are unused; all other RM locations have values that<br>must survive across opcodes; RM 6, 40-42, 51, 66, 70-71 used only by BitBlt.<br>**Note: although RM 63 is unused by Alto (xfWDC for Mesa), it seems necessary<br>to preserve it for Mesa traps to the Alto emulator.<br><br>If more registers are needed, modify BitBlt to use some of the Alto emulator&rsquo;s<br>constants and restore them before exit (R177400-R177402 are good choices since<br>these are Mesa temporaries); using these for BitBlt instead of any of the<br>registers named above as used only by BitBlt would free these registers for<br>the Alto emulator.<br>%<br>*R177400 to R177403 must be in a quadword since PCF[R177400] is used as<br>*the equivalent to PCF.word + 177400; similarly for SkipPCF0 to SkipPCF3.<br>RV4[R177400,R177401,R177402,R177403,14];<br>RV4[SkipPCF0,SkipPCF1,SkipPCF2,SkipPCF3,74];<br><br>RV[CARRY,1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alto carry bit in bit 0<br><br>*Also, the values are chosen so that the low 3 bits of the four will enumerate<br>*0, 2, 4, and 6, which allows the rwpACx pointers to be coincident with the<br>*four SkipPCFx registers.<br>RV2[AC2,AC2hi,4];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*3 smashed by A-group opcodes (used by Mesa BitBlt)<br>RV2[AC0,AC0hi,10];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*7 smashed by A-group (used by Mesa BitBlt, StartIO)<br>RV2[AC1,AC1hi,26];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*25 smashed by A-group<br>RV2[AC3,AC3hi,22];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*21 smashed by A-group<br><br>RV[rpAC0,54];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Pointer to AC0-1<br>RV[rpAC1,2];<br>RV[rpAC2,IP[R177403]];<br>RV[rpAC3,55];<br>RV[rwpAC0,IP[SkipPCF2]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Pointer to AC0 in bits 8:15<br>RV[rwpAC1,IP[SkipPCF1]];<br>RV[rwpAC2,IP[SkipPCF0]];<br>RV[rwpAC3,IP[SkipPCF3]];<br><br>RV[NWW,24];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Both Alto and Mesa<br>RV2[PCB,PCBhi,30];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alto and Mesa<br>RV2[MDS,MDShi,32];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Alto and Mesa<br><br>RV4[IBuf,IBuf1,IBuf2,IBuf3,34];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*4 word bytecode buffer for both Alto & Mesa<br><br>RV4[wBuf,wBuf1,wBuf2,wBuf3,40];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*wBuf temporary buffer<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(wBuf3 must be at xBuf-1 for Alto BLT)<br>RV4[xBuf,xBuf1,xBuf2,xBuf3,44];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Temporary buf (used by old LRJ--cannot move)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Also used as temporaries by Fault.Mc<br>RV4[yBuf,yBuf1,yBuf2,yBuf3,50];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Temporary buf (used by new LRJ--don&rsquo;t move)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(yBuf must be at xBuf3+1 for Alto BLT)<br><br>RV[SMA,7];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Temporary for CONVERT<br>RV[xnXH,56];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Temporary for CONVERT<br>RV[XBI,57];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Temporary for CONVERT<br><br>*WW, ACTIVE, and DMA must not coincide with any registers that must survive<br>*across interrupt checks for BLT or BLKS.<br>RV2[WW,ACTIVE,56];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*WW also used by Mesa<br><br>*Constants<br>RM[RMZero,IP[MDS]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Contains 0 for both Mesa and Alto<br>RM[RZero,IP[MDS]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Contains 0 for both Mesa and Alto<br>RV[R400,60];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*400 for both Alto and Mesa<br>RV[AllOnes,61];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*-1 for both Alto and Mesa (Only BitBlt uses AllOnes<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*for Alto, so could eliminate)<br><br>RV[MemStat,62];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Directs page fault handling by Fault.Mc<br><br>RV2[DMA,DMAhi,64];<br><br>RV2[LP,LPhi,66];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Long pointer base pair. (used by LRJ--cannot move)<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(Used for Alto XMLDA & XMSTA)<br><br>RV4[zBuf,zBuf1,zBuf2,zBuf3,70];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Quadword used by MesaFP<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*(Don&rsquo;t move unless xfTemp def changed--see below)<br><br>*RTemp and RTemp1 are used by PNIP, which might be called by any task,<br>*so these registers must not overlay any Kernel registers (x62-x77).  PNIP<br>*is most commonly called by task 17, so no conflicts on task 14-17 assignments<br>*is most important.<br>RV[RTemp,IP[yBuf2]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Both Alto and Mesa<br>RV[RTemp1,IP[yBuf3]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*Both Alto and Mesa (used by LRJ--cannot move)<br>RV2[xfTemp,xfTemp1,IP[zBuf2]];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*(used by LRJ--cannot move)<br><br>Macro[StkPCheck,IFG[IP[#1],MaxStack!,<br>  IFG[20,IP[#1],ER[#1.not.referenceable.by.StkP]]]];<br>StkPCheck[AC0]; StkPCheck[AC1]; StkPCheck[AC2]; StkPCheck[AC3];<br>*See the code at StartNova in Alto.Mc if any of these errors occurs<br>IFE[IP[AC2],4,,ER[rpAC2.and.rwpAC2.became.no.good]];<br>IFE[IP[AC0],10,,ER[rwpAC0.became.non-coincident.with SkipPCF2]];<br>IFE[IP[AC1],26,,ER[rwpAC1.became.non-coincident.with SkipPCF1]];<br>IFE[IP[AC3],22,,ER[rwpAC3.became.non-coincident.with SkipPCF3]];<br><br>:UNLESS[WithPilotBitBlt];<br>%BitBlt registers--these must not conflict with any inter-opcode storage<br>used by either Alto or Mesa emulators.  Uses AC0, AC2, and AC2hi, which<br>must not conflict with Mesa; must not smash Stack0-1 which are holding Mesa<br>arguments, but may smash Stack2 up; may smash AC3; restores IBuf-IBuf3 before<br>exit; LocalCache0-3 restored for Mesa exit.<br><br>RM 0, 12-13, 20, and, 62 are available; bbDty is available after init;<br>RM 22 is available for the Alto emulator but not for Mesa;<br>RM 11, 14-16 are available for the Mesa emulator but not for Alto.<br>%<br>RV[bbDest,IP[xBuf]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Quadword buffer<br><br>RV2[bbSlx,bbSty,IP[IBuf]];<br>RV[bbSLast,IP[IBuf1]];<br><br>RV2[bbDlx,bbDty,IP[IBuf2]];<br>*bbDty available after init<br><br>RV[bbSrc,IP[yBuf]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Quadword buffer<br>RV[bbYHi,IP[yBuf]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Init temporary<br><br>RV2[bbSrcQLo,bbSrcQHi,56];<br>RV2[bbDestQLo,bbDestQHi,IP[zBuf]];<br><br>RV[bbGray,IP[wBuf]];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*Quadword buffer<br>RV[bbGray1,IP[wBuf1]];<br>RV[bbGray2,IP[wBuf2]];<br><br>RV[bbDLast,6];<br>RV2[bbItemWid,bbItemsLeft,6];</span><span class="tab" val="67"></span><span style="font: 10pt serif">*bbItemWid only needed during early init<br><br>*Registers which need not be paired<br>RV[bbNegBitsLeft,3];<br>RV[bbDBMR,21];<br>RV[bbFunction,25];<br>RV[bbNegItemWid,64];<br>RV[bbSrcWLo,66];<br>RV[bbSBMR,67];<br>RV[bbNegSDNonOverlap,IP[zBuf2]];<br>RV[bbDestWLo,IP[zBuf3]];<br><br>:ENDIF;<br><br><br><br>*Constants<br><br>MC[IntPendingBit,10];<br><br><br>INSERT[MesaDefs];<br><br>:END[GlobalDefs];</span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
