:TITLE[Bindings.0mc...June 9, 1982  2:51 PM, van Melle];********* BIND   byte 1 (lspLN) = n,v   Byte2 (lspL2) = N*   n = number of PVARS bound to NIL*   v = number of PVARS bound to values popped off stack*   N => last PVAR is stored into slot NlspBind:	loadpage[pgBind], opcode[021];	gotop[.+1];onpage[pgBind];	T _ NextData[IBuf];	lspLN _ T;	T _ NextData[IBuf];	lspL2 _ T;					* LN = 0,0,n,v	T _ (ldf[lspLN, 10, 4]) - 1;	* T _ n-1	lspL4 _ T;	T _ (ldf[lspLN, 14, 4]) - 1;	* T _ v-1	lspL3 _ T;	T _ lspL2 _ lsh[lspL2, 1], task;	* N*2	lspL0 _ 0C;			* T0_NIL	lspL1 _ 0C, call[.+1];		* T0_NILlspBNil:	lspL4 _ (lspL4) - 1, goto[lspBNilFin, R<0];	PStore2[lspEp, lspL0];		* Push NIL	T _ (Form-2[AllOnes]) + T, return;	* T _ T-2, return to lspBNillspBNilFin:				* Odd placementlspBVal:			*** this loop may need tasking	lspL3 _ (lspL3) - 1, goto[lspBValFin, R<0];	PStore2[lspEp, Stack];		* Pop Stack into next pvar	StkState _ rcy[StkState, 1], goto[lspBVal1, Reven];	loadpage[pgHStack];	callp[HStkUndFlw];		* Assumes T undisturbed!!!lspBVal1:	T _ (Form-2[AllOnes]) + T, goto[lspBVal];	* T _ T-2lspBValFin:	T _ (ldf[lspLN, 10, 4]);	T _ (ldf[lspLN, 14, 4]) + T, task;	* T _ n+v	Stack&+1 _ (zero) - T - 1;		* push -(n+v) -1	T _ lspL2;	Stack&+1 _ T, goto[PushLBL];		* push 2*N******* UNBIND, DUNBINDlspDUnBind:					* unbind, discard value	loadpage[pgBind], opcode[023];	lspL0 _ (unboundPvar), gotop[lspUnbPop0];lspUnBind:					* unbind, preserve TOS	loadpage[pgBind],opcode[022];	T _ Stack&-1;onpage[pgBind];	lspL1 _ T;				* Pop TOS into L0,1	T _ Stack&-1;	lspL0 _ T, goto[lspUnbPop];lspUnbPop:					* Pop check	StkState _ rcy[StkState, 1], goto[lspUnbPop0, R Even];	loadpage[pgHStack];	callp[HStkUndFlw];lspUnbPop0:	MNBR _ Stack&-1;			* offset of last var to unbind	T _ (Stack&-1) + 1, goto[lspUnbPop, R>=0];			* T _ #vars to unbind; if non-negative, this was not a			* binding mark, so keep popping until it is	lspL2 _ T;	T _ MNBR;	lspLN _ (unboundPvar), call[.+1];lspUnbPop2:	lspL2 _ (lspL2) + 1, goto[lspUnbPop3, R>=0];	PStore1[lspEp, lspLN];	T _ (Form-2[AllOnes]) + T, return;      * T _ T-2, return to lspUnbPop2lspUnbPop3:	T _ lspL0, skip[R>=0];	  goto[PopLBL];	Stack&+1 _ T;				* Push L0,1 back on	T _ lspL1;	Stack&+1 _ T, goto[nxiLBL];		* no overflow possible, since we popped at least one thing:END[Bindings];