<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Carol>SOURCES>LISP0MC.DM!1>Inst.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Inst.0mc...March 23, 1983  10:19 AM, van Melle];* IvarsIvars:	T &larr; (lspIbasex), goto[lspPushT1], opcode[100];	T &larr; (lspIbasex) + (02c), goto[lspPushT1], opcode[101];	T &larr; (lspIbasex) + (04c), goto[lspPushT1], opcode[102];	T &larr; (lspIbasex) + (06c), goto[lspPushT1], opcode[103];	T &larr; (lspIbasex) + (10c), goto[lspPushT1], opcode[104];	T &larr; (lspIbasex) + (12c), goto[lspPushT1], opcode[105];	T &larr; (lspIbasex) + (14c), goto[lspPushT1], opcode[106];@IvarX:	T &larr; lspIbasex, opcode[107];Ivarx1:	T &larr; (NextData[IBuf]) + T;lspPushT1:	PFetch2[lspStkBr, Stack], goto[PushChkP5];* PvarsPvars:	PFetch2[lspEp, Stack, 0], goto[PushChkP5], opcode[110];	PFetch2[lspEp, Stack, 2], goto[PushChkP5], opcode[111];	PFetch2[lspEp, Stack, 4], goto[PushChkP5], opcode[112];	PFetch2[lspEp, Stack, 6], goto[PushChkP5], opcode[113];	PFetch2[lspEp, Stack, 10], goto[PushChkP5], opcode[114];	PFetch2[lspEp, Stack, 12], goto[PushChkP5], opcode[115];	PFetch2[lspEp, Stack, 14], goto[PushChkP5], opcode[116];@PvarX:	T &larr; lspEp, goto[Ivarx1], opcode[117];Fvars:	T &larr; (lspEp) + (00c), goto[lspFvar], opcode[120];	T &larr; (lspEp) + (02c), goto[lspFvar], opcode[121];	T &larr; (lspEp) + (04c), goto[lspFvar], opcode[122];	T &larr; (lspEp) + (06c), goto[lspFvar], opcode[123];	T &larr; (lspEp) + (10c), goto[lspFvar], opcode[124];	T &larr; (lspEp) + (12c), goto[lspFvar], opcode[125];	T &larr; (lspEp) + (14c), goto[lspFvar], opcode[126];	T &larr; lspEp, opcode[127];	T &larr; (NextData[IBuf]) + T;lspFvar:	PFetch2[lspStkBr, lspGenBr], call[retLBL];					* fetch contents of binding slot	lu &larr; lspGenBr, goto[lspFvarub, R Odd];	PFetch2[lspGenBr, Stack, 0];	* Fetch value in slot.  This can page faultWaitForStackFaultPush:	lu &larr; Stack, goto[PushChkP5];lspFvarub:				* not looked up yet	loadpage[pgFvar];	* T = offset of binding slot at this point	callp[Lookup];	PStore2[lspStkBr, lspL0], goto[lspFvar];					* store binding ptr, try again* GVAR -- access value cell of atom whose index is in next two bytes@Gvar:	lspGenBrHi &larr; (VALspace), opcode[140];	lspGenBr &larr; (VALbase);	T &larr; NextData[IBuf];	lspL0 &larr; T;	T &larr; NextData[IBuf];	lspL0 &larr; (lsh[lspL0, 10]) or T;	T &larr; lsh[lspL0, 1];	PFetch2[lspGenBr, Stack], goto[WaitForStackFaultPush];SetPvars:	PStore2[lspEp, Stack, 0], goto[UnPopStack], opcode[130];	PStore2[lspEp, Stack, 2], goto[UnPopStack], opcode[131];	PStore2[lspEp, Stack, 4], goto[UnPopStack], opcode[132];	PStore2[lspEp, Stack, 6], goto[UnPopStack], opcode[133];	PStore2[lspEp, Stack, 10], goto[UnPopStack], opcode[134];	PStore2[lspEp, Stack, 12], goto[UnPopStack], opcode[135];	PStore2[lspEp, Stack, 14], goto[UnPopStack], opcode[136];UnPopStack:	Stack&amp;+2, goto[nxiLBL];SetPvarPops:	PStore2[lspEp, Stack, 0], goto[PopChk6], opcode[270];	PStore2[lspEp, Stack, 2], goto[PopChk6], opcode[271];	PStore2[lspEp, Stack, 4], goto[PopChk6], opcode[272];	PStore2[lspEp, Stack, 6], goto[PopChk6], opcode[273];	PStore2[lspEp, Stack, 10], goto[PopChk6], opcode[274];	PStore2[lspEp, Stack, 12], goto[PopChk6], opcode[275];	PStore2[lspEp, Stack, 14], goto[PopChk6], opcode[276];* SetI, op 142, Set IVar N to TOS where N=following byte, dont pop stack@SetI:	T &larr; lspIbasex, goto[Svrx0], opcode[142];* SetP, op 137, Set PVar N to TOS where N=following byte, dont pop stack@SetP:	T &larr; lspEp, goto[Svrx0], opcode[137];Svrx0:	T &larr; (NextData[IBuf]) + T;	PStore2[lspStkBr, Stack], goto[UnPopStack];* SetF, op 143, Set Free var N to TOS, dont pop stack@SetF:	T &larr; lspEp, opcode[143];	T &larr; (NextData[IBuf]) + T;SetF1:	PFetch2[lspStkBr, lspGenBr], call[retLBL];	* fetch contents of binding slot	lu &larr; lspGenBr, goto[SetFfound, R Even];SetFub:				* not looked up yet	loadpage[pgFvar];	* T = offset of binding slot	callp[Lookup];	PStore2[lspStkBr, lspL0], goto[SetF1];					* store ptr in slot and try againSetFfound:	T &larr; (StackSpaceR);	lu &larr; (rsh[lspGenBrHi, 10]) xor T;	* is binding slot on stack?	T &larr; lspGenBrHi, goto[SetFtop, alu#0];	PStore2[lspGenBr, Stack, 0], goto[UnPopStack];SetFtop:		* binding slot not on stack, need to refcnt			* Move base to L2,3.  Should fix RplPtr instead	lspL3 &larr; T;	T &larr; lspGenBr, loadpage[pgRplPtr];	lspL2 &larr; T, gotop[SetGvar1];	* do gvar&larr; on this atom* Nil, op 150, Push Nil onto stack@Nil:	T &larr; Stack&amp;+1 &larr; 0c, goto[PushTChkP5], opcode[150];* Kt, op 151, Push T onto stack@Kt:	Stack&amp;+1 &larr; 0c, opcode[151];	Stack&amp;+1 &larr; (KtVal), goto[PushChkP5];* Zero, op 152, Push zero onto stack@Zero:	Stack&amp;+1 &larr; (smallpl), opcode[152];	Stack&amp;+1 &larr; 0c, goto[PushChkP5];* One, op 153, Push small int one onto stack@One:	Stack&amp;+1 &larr; (smallpl), opcode[153];	Stack&amp;+1 &larr; 1c, goto[PushChkP5];* Sic, op 154, Push 2nd byte onto stack as small integer@SIC:	Stack&amp;+1 &larr; (smallpl), opcode[154];	T &larr; NextData[IBuf], CallX[PushTChkP5];* Snic, op 155, Push 2nd byte onto stack as small negative integer@SNIC:	Stack&amp;+1 &larr; (smallneg), opcode[155];	T &larr; 177400c;	T &larr; (NextData[IBuf]) or T, CallX[PushTChkP5];* Sicx, op 154, Push next two bytes onto stack as small integer@SICX:	Stack&amp;+1 &larr; (smallpl), opcode[156];Sicx1:				* push word formed from next two bytes	lu &larr; CycleControl &larr; NextData[IBuf];	* Load from ALUA[10:17],...	T &larr; lhmask[Cycle&amp;PCXF];		* CycleControl is read to R[0:7]	T &larr; (NextData[IBuf]) or T, CallX[PushTChkP5];* AtomNumber, op 160, Same as SICX, except for its use@AtomNumber:	Stack&amp;+1 &larr; (smallpl), goto[Sicx1], opcode[160];* AConst, op 147, Push the following 2 bytes onto stack as an atom@AConst:	Stack&amp;+1 &larr; 0c, goto[Sicx1], opcode[147];* GConst, op 157, Push the 3 following bytes onto stack as a constant@GConst:	T &larr; NextData[IBuf], opcode[157];	Stack&amp;+1 &larr; T, goto[Sicx1];* Copy, op 144, Copy top of stack onto stack again@Copy:	Stack&amp;-1, opcode[144];	Stack&amp;+2 &larr; Stack;	Stack&amp;-1;	Stack&amp;+2 &larr; Stack, goto[PushChkP5];	:END[inst];</pre>
  </body>
</html>
