<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Carol>SOURCES>LISP0MC.DM!1>Low.0mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:TITLE[Low.0mc...October 25, 1982  12:38 PM, van Melle];<br><br>* GetBase.n, op 310<br>* {base} =&gt; {val(int)}<br>@GetBase:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 310c, call[lspSetBase], opcode[310];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspGenBr, lspL1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This can page fault<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Wait for fault<br><br>TOSGetsTSmall:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* TOS &larr; MakeSmallPos(T)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; (smallpl), goto[PushTP7];<br><br>* GetBasePtr.n, op 311<br>* {base} =&gt; {val(ptr)}<br>@GetBasePtr:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 311c, call[lspSetBase], opcode[311];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-2;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch to stack will push<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch2[lspGenBr, Stack];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This can page fault<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Redundant but saves 1 inst<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; rhmask[Stack], goto[PushTP7];<br><br>* GetBits.n.fd, op 312<br>* {base} =&gt; {val(int)}<br>@GetBits:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 312c, call[lspSetBase], opcode[312];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspGenBr, lspL1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This can page fault<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; CycleControl &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; RF[lspL1], goto[TOSGetsTSmall];<br><br>* PutBase.n, op 315<br>* {base, val(int)} =&gt; {val(int)}<br>@PutBase:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHstack], call[CheckElt2P7], opcode[315];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 315c, call[GetVal&Base];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* val in L1, base in lspGenBr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[lspGenBr, lspL1], goto[pb1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* This can page fault<br><br>* PutBasePtr.n, op 316<br>* {base, val(ptr)} =&gt; {val(ptr)}<br>@PutBasePtr:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHstack], call[CheckElt2P7], opcode[316];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get val in L0,1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; T, call[lspSetBase];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* base in lspGenBr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore2[lspGenBr, lspL0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This can page fault<br>pb1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; lspL1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Wait for fault<br>PopState1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rsh[StkState, 1], goto[nxiLBL];<br><br>* PutBits.n.fd, op 317<br>* {base, val(int)} =&gt; {val(ptr)}<br>@PutBits:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHstack], call[CheckElt2P7], opcode[317];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 317c, call[GetVal&Base];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* val in L1, base in lspGenBr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspGenBr, lspL4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Get old word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; CycleControl &larr; NextData[IBuf];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspLN &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; WFA[lspL1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* mask new value<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL4 &larr; (WFB[lspL4]) or T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* insert it into old word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspLN;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[lspGenBr, lspL4], goto[PopState1];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store it back<br><br>* GetBaseByte, op 302<br>* {base, disp} =&gt; {val(int-byte)}<br>@GetBaseByte:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHstack], call[CheckElt2P7], opcode[302];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 302c, call[GetVal&Base];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* val in L1, base in lspGenBr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rsh[lspL1, 1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* word offset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspGenBr, lspL4];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This can page fault<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1, skip[R odd];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* which byte?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> T &larr; rsh[lspL4, 10], goto[Gbb1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[lspL4], goto[Gbb1];<br>Gbb1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rsh[StkState, 1], goto[TOSGetsTSmall];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* -&gt; GetBase exit<br><br>* PutBaseByte, op 307<br>* {base, disp, val} =&gt; {val(int-byte)}<br>@PutBaseByte:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack], call[CheckElt3P7], opcode[307];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN &larr; 307c, call[CheckSmallp];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-2;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* L3 &larr; val<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL3 &larr; T, call[GetVal&Base];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* disp in L1, base in lspGenBr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL1 &larr; rsh[lspL1, 1], goto[PBBodd, Rodd];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspGenBr, lspL4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[lspL3, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL4 &larr; (rhmask[lspL4]) or T, goto[PBBDone];<br>PBBodd:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspGenBr, lspL4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; rhmask[lspL3];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL4 &larr; (lhmask[lspL4]) or T;<br>PBBDone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pstore1[lspGenBr, lspL4];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL3;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState&larr; rsh[StkState, 2], goto[TOSGetsTSmall];<br><br><br><br><br><br>GetVal&Base:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Pop small integer TOS into L1, punting if not<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Then put new TOS into lspGenBr/Hi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (Stack&-1) xor (smallpl);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T, goto[lspSetBase, alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  goto[ufnLBL];<br><br>lspSetBase:</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Turn TOS into LspGenBr,Hi as basereg<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Gotcha: don&rsquo;t do mem op in next inst<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspGenBr &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[Stack, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (rhmask[Stack&+1]) + T + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspGenBrHi &larr; T, return;<br><br><br><br><br>* AddBase, op 320<br>* {ptr, nbr} =&gt; {ptr}<br>@AddBase:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack], call[CheckElt2P7], opcode[320];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* lo addend<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (Stack) xor (smallpl);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* smallpos?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (Stack&-1) xor (smallneg), skip[alu#0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lspL0 &larr; Zero, goto[.adb2];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* hi = 0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL0 &larr; (Zero) - 1, goto[.adb2, alu=0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* hi = -1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lspUFN &larr; 320c, goto[ufnLBL];<br>.adb2:</span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) + T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* add lo base and lo addend<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1, FreezeResult;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lspL0, FreezeResult;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) + T, UseCOutAsCIn;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* add hi&rsquo;s<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1, goto[PopState1];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* lo result<br><br><br>* Vag2, op 321<br>* {nbr, nbr} =&gt; {ptr}<br>@Vag2:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack], call[CheckElt2P7], opcode[321];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T &larr; b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (Stack&-2) - (smallpl);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* test b small<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (Stack&+1) - (smallpl), skip[alu=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* test a small<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lspUFN &larr; 321c, goto[ufnLBL];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">skip[alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lspUFN &larr; 321c, goto[ufnLBL];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; Stack&-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* hiloc(TOS) &larr; a<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* then loloc(TOS) &larr; b (= T)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">StkState &larr; rsh[StkState, 1], goto[PushTP7];<br><br>* Hiloc, op 322, Push the high order word of the TOS onto the stack as an integer<br>@HiLoc:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1, opcode[322];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&+1, goto[TOSGetsTSmall];<br><br>* LoLoc, op 323, Replace TOS with the low order word of TOS as an integer<br>@LoLoc:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-1 &larr; (smallpl), opcode[323];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+1, goto[nxiLBL];<br><br>* (BLT destaddr sourceaddr nwords)<br>* moves TOS words from @TOS-1 to @TOS-2, right to left<br>*<br><br>@BLT:</span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[pgHStack], call[CheckElt3P7], opcode[304];<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* ensure 3 cells on stack<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (Stack&-1) xor (smallpl);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Is tos small?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL1 &larr; T, skip[alu=0];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Save count for int check<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  lspUfn &larr; 304c, goto[ufnLBL];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* no, punt<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack&-1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get source address<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL2 &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; lsh[Stack, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; (rhmask[Stack&-1]) + T + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* make L2,3 a basereg<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspL3 &larr; T, loadpage[opPage3];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* get dest in lspGenBr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspInstFlag &larr; (InBltState), callp[lspSetBase];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* pagefault flag<br><br>* Now have lspLN = nwords, lspGenBr = dest, lspL2,3 = source<br>* Stack is pointing at dest.  Our strategy is to use Stack as<br>* the offset in memory operations.  Stack is updated on each iteration,<br>* but only once we are sure there is no fault from the previous iteration.<br>* Stack is thus completely correct for Interrupts, needs only slight<br>* adjustment (incrementing nwords) on Pagefault.  When Stack reaches<br>* zero we are finished.<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&+2, call[BLTLp];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Point Stkp at nwords<br><br>BLTLp:</span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; Stack;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* don&rsquo;t update Stack til after fault<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T &larr; Stack &larr; (Stack) - 1, goto[BltXit, alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PFetch1[lspL2, xBuf];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* xBuf &larr; datum<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">nop;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PStore1[lspGenBr, xBuf];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* store in dest<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">goto[BltInt, IntPending];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">return;<br><br>BltInt:<br>* Take interrupt unless count was less than critical amount<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lu &larr; (lspL1) - (BltInterruptableMinWords);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">loadpage[opPage0], skip[alu&gt;=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  return;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* don&rsquo;t take interrupt yet<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">gotop[TakeInterrupt];<br><br>BltXit: Stack&-2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack&-2, loadpage[5];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">lspInstFlag &larr; (NormalState), goto[Pop2P5];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* net 2 pop<br><br><br>BltFault:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* come here on pagefault<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* need to restore nwords so that the last attempt is retried<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Stack &larr; (Stack) + 1, goto[lspDoFault], at[FaultDisp, InBltState!];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">:END[Low];<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
