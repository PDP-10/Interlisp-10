<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Carol>SOURCES>LISP0MC.DM!1>Lisp0.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Lisp0.0mc, October 25, 1982  12:30 PM, van Melle];* Alto mode instructionsinsert[DisplayDefs];		* Get WordsPerLine definitionSetTask[0];IMRESERVE[pgLisp0, IntfaceBase, IntfaceCnt];LispInst:	dispatch[PCF[IBUF], 14, 4], at[LispInstLoc];	disp[@@Mbix], CSkipData;*	breakpoint, mbx[12];*	breakpoint, mbx[13];*	breakpoint, mbx[14];*	breakpoint, mbx[17];@@Mbix:			* Return to Lisp with value in Ac0,1	lspGenBrHi &larr; (INTERFACEspace), mbx[00];	lspGenBr &larr; (INTERFACEbase);	PFetch1[lspGenBr, lspEp, 0];	* retrieve FX from Intfacepg	T &larr; AC0;	* move value to L0,1 for return	lspL0 &larr; T;* need to get WW to see if a Lisp interrupt struck while we were in AltoLand (which would be masked out of ACTIVE):IF[WindFlg];	T &larr; (R400) or (52c);		* mds 452 = WW	PFetch2[MDS, WW];		* fetch WW, ACTIVE:ENDIF;	T &larr; AC1, task;	lspL1 &larr; T;:IF[StatsMode];	T &larr; (StatsPointerLocation);	PFetch1[MDS, lspStatsPtr];		* Get this fetch going, too:ENDIF;	lspInstFlag &larr; (NormalState);	MDSTypeBaseBrHi &larr; MDSTypeSpace;		* for type tests	MDSTypeBaseBr &larr; MDSTypeBase;:IF[WindFlg];	WW &larr; (WW) and not (100000c);		* maybe don't need this	T &larr; (ACTIVE) or (LispKeyMask);	T &larr; (WW) and T;				* Ignore masked-out interrupts	NWW &larr; (NWW) or T, goto[mbi2, R&lt;0];	* OR waiting interrupts into NWW, skip if ints off	   FreezeResult, call[CheckInterrupts];	* may need to set IntPending:ENDIF;mbi2:	lspEpHi &larr; (StackSpace);			* Setup constant registers	T &larr; lspEpHi &larr; (lspEpHi) or (300c);	* StackHi in left, error value	lspStkBrHi &larr; T;				* in right (for overflow case)	lspTspHi &larr; T, loadpage[pgReturn];	lspStkBr &larr; 0c;onpage[pgReturn];:IF[StatsMode];	lu &larr; lspStatsPtr;		* Are stats on (this loc nonzero)?	T &larr; lspEp, skip[alu#0];	  lspStatsPtr &larr; (Zero) - 1;					* set sign bit so we can test quickly:ELSE;	T &larr; lspEp;:ENDIF;	lspLN &larr; T, goto[lspRtn2];	* return to frame Ep@@InitLispRegs:	AC1 &larr; 2000c, mbx[11];	LoadPageExternal[PNIPPage];	T &larr; (AC1) or (114c), callExternal[PNIPLoc];	* MP &larr; 1100d	AC1 &larr; IP[FFault]c;	Stkp &larr; AC1;			* Address of Ffault	T &larr; lspInstFlag &larr; 0c;	Stack &larr; (Stack) or (1c);	* let emulator handle pagefault	Stack &larr; (Stack) and not (20000c);	* Ignore H4 parity errors	AC1 &larr; (RamRelease);	AC1 &larr; (AC1) or (DolphinMcVersion), call[InitStore];	AC1 &larr; (MinBcplVersion), call[InitStore];	AC1 &larr; (MinLispVersion), call[InitStore];	AC1 &larr; (WordsPerLine), call[InitStore];	AC1 &larr; IP[StoragePages]c;	Stkp &larr; AC1;	PStore1[AC0, Stack], call[IncTRet];	AC1 &larr; 400c;	AC1 &larr; (AC1) or (200c), call[InitStore];	* pages per module = 600* for most Dolphins, the 48-bit NS host number is hiding in the high 32 bits* of ram location 7777.  High word is constant zero.	AC1 &larr; Zero, call[InitStore];		* Store zero	T &larr; lspL0 &larr; 7400c;			* low bits of T &larr; 0	lspL0 &larr; (lspL0) or (377c), call[ReadRamInit];	* L0 &larr; 7777						* Read 7777[0:15]	PStore1[AC0, AC1, 7];	T &larr; 1c, call[ReadRamInit];		* Read 7777[16:31]	PStore1[AC0, AC1, 10], goto[NoSkipStart];InitStore:	PStore1[AC0, AC1];	* Store AC1 at offset T from init vectorIncTRet:	T &larr; (Zero) + T + 1, return;	* T &larr; T+1ReadRamInit:	* Return in AC0 the contents of location in LspL0, part by T	APCTask&amp;APC &larr; lspL0;	ReadCS;	T &larr; CSData, disptable[1,1,0];		* Even placement	AC1 &larr; T, return;lspuPCTrace:			* uPC trace, not on Dolphin	return, mbx[15];SkipStart:	LoadPageExternal[nePage], gotoExternal[lneTaskSkpLoc];NoSkipStart:	LoadPageExternal[nePage], gotoExternal[lneTask1stLoc], at[FaultDisp, InBcplState!];:IF[WithPilotBitBlt];@@XBitBlt:				* No alto bitblt	loadpageExternal[xoPage], gotoExternal[lTrapLoc], mbx[16];:ELSE;@@XBitBlt:				* AC0 points at a bitblt table					* AC3 holds 2*scanlines done	PFetch1[AC0, AC2hi, 0], mbx[16];	T &larr; (PCF.WORD);	PCB &larr; (PCB) + T;	PCF &larr; RZero;			* update PCB, PCF	PFetch1[AC0, AC2, 1];		* get low pointer out of bbt		* BitBlt needs Stkp pointing at 2*scanlines done, viz. AC3	lspL0 &larr; IP[AC3]c;	Stkp &larr; lspL0;	lspInstFlag &larr; (InAltoBitBltState);	T &larr; rhmask[AC2hi];		* adjust the high pointer	AC2hi &larr; (lsh[AC2hi, 10]) + T + 1;	T &larr; (Cycle&amp;PCXF) or (100000c), gotoExternal[lbbBitBltLoc];bbPageFault:	lspL1 &larr; 1c, goto[bbMExit], at[FaultDisp, InAltoBitBltState!];lbbMesaInt:	lspL1 &larr; 0c, goto[bbMExit], at[BBMesaIntLoc];lbbMDone:	lspL1 &larr; 2c, goto[bbMExit], at[BBMDoneLoc];bbMExit:	AC2hi &larr; 0c;			* restore normal AC2hi	lspInstFlag &larr; (NormalState);*****	T &larr; (ldf[Cycle&amp;PCXF, 15, 2]) + T;	T &larr; lspL1, gotoExternal[lBitBltDoneLoc];	* T &larr; skip distance:ENDIF;* XNOvaOps for accessing the virtual memory.  These return skipping* on success, or not skipping if pagefault@@BGetBase:		* AC0 &larr; GetBase(AC0,,AC1)	nop, mbx[04];				* alloc constraint	call[lspSetGBr];	PFetch1[lspGenBr, AC0, 0];	AC0 &larr; AC0, goto[SkipStart];		* wait for fault@@BGetBase32:		* AC0,,AC1 &larr; GetBase32Bits(AC0,,AC1)	nop, mbx[06];				* alloc constraint	call[lspSetGBr];	PFetch1[lspGenBr, AC0, 0];	PFetch1[lspGenBr, AC1, 1];	AC1 &larr; AC1, goto[SkipStart];@@BGetBasePtr:		* AC0,,AC1 &larr; GetBasePtr(AC0,,AC1)	nop, mbx[07];				* alloc constraint	call[lspSetGBr];	PFetch1[lspGenBr, AC1, 1];	PFetch1[lspGenBr, AC0, 0];	AC0 &larr; (AC0) and (377c), goto[SkipStart];@@BPutBase:		* PutBase(AC0,,AC1, @AC2)	PFetch1[AC2, lspL3, 3], mbx[05];	call[lspSetGBr];	PStore1[lspGenBr, lspL3, 0];	lspL3 &larr; lspL3, goto[SkipStart];@@BPutBase32:		* PutBase32Bits(AC0,,AC1, @@AC2)	PFetch1[AC2, lspL3, 3], mbx[10];	T &larr; lspL3;	PFetch1[MDS, lspL2], call[retLBL];	T &larr; (lspL3) + 1;	PFetch1[MDS, lspL3];	call[lspSetGBr];	PStore2[lspGenBr, lspL2, 0];	lspL3 &larr; lspL3, goto[SkipStart];lspSetGBr:			* Load base reg LispGenBr from AC0,1	T &larr; rhmask[AC0];	lspGenBrHi &larr; T;	lspGenBrHi &larr; (lsh[lspGenBrHi, 10]) + T + 1;	T &larr; AC1;	lspGenBr &larr; T, goto[retLBL];	* Wait for lspGenBr &larr; to finish* VMTransferPage(toVp, FromVp)** moves 400b words from virtual address in ac1 to that in ac0@@VMTransferPage:	T &larr; lhmask[AC0], mbx[03];	lspL3 &larr; T;	T &larr; lsh[AC0, 10];	lspL2 &larr; T;			* L2,3 is base for page AC0 (dest)	T &larr; lsh[AC1, 10];	lspGenBr &larr; T;	T &larr; lhmask[AC1];	lspGenBrHi &larr; T;			* lspGenBr is base for page AC1 (src)	T &larr; lspLN &larr; 374c;		* Counter/offsetxmm:	nop;				* alloc constraint	PFetch4[lspGenBr, XBuf], call[retLBL];	PStore4[lspL2, XBuf], call[retLBL];	T &larr; lspLN &larr; (lspLN) - (4c);	goto[xmm, alu&gt;=0];	goto[SkipStart];* ReadFlags(Vp) -&gt; Real Page, Flags (ref, -- , wp, dirty, ...)@@ReadFlags:	Loadpage[pgMapOps], mbx[01];		* alloc constraint	UseCTask, callp[xReadFlags];		* get Rp in AC0, Flags in T	AC1 &larr; T, goto[NoSkipStart];* Lisp instructions for the same thing@ReadFlags:	lspUFN &larr; 161c, call[lspReadFlags], opcode[161];PushTP5:					* Flags were left in T	Stack&amp;+1 &larr; T, goto[nxiLBL];@ReadRP:	lspUFN &larr; 162c, call[lspReadFlags], opcode[162];	T &larr; AC0, goto[PushTP5];			* get RP, stuff itlspReadFlags:		* Come here with lspUFN set appropriately			* Return with Flags in T, RP in AC0, or else ufn out	T &larr; Stack&amp;-1;	lu &larr; (Stack) - (smallpl);	AC0 &larr; T, UseCtask, goto[xReadFlags, alu=0];	  goto[ufnLBL];				* VP not smallpos?* Come here with VP in AC0, returns flags in T, RP in AC0*  UseCTask in calling instructionxReadFlags:	T &larr; APC&amp;APCTask;	lspL5 &larr; T, call[XMapAC0];	* Get info in XBuf1,2,3 complemented	T &larr; lsh[XBufFC, 10];		* flags	T &larr; (rhmask[XBufRow]) or T;	* Row address in RH	XBuf &larr; (Zero) - 1;	XBuf &larr; (XBuf) xor T;		* XBuf &larr; ~T = flags,,old real page#	nop;				* is this needed?	xmap[lspGenBr, XBuf, 0];	* Restore entry (XMap had changed it)	XBuf &larr; XBuf;			* is this needed?	T &larr; (XBuf) and not (170000c);	* Mask out flags to get	Ac0 &larr; T;				* AC0 &larr; real page#	lu &larr; (XBuf) and (10000c);	XBuf &larr; rsh[XBuf, 1], skip[alu=0];	* Rearrange flag bits:	 XBuf &larr; (XBuf) or (100000c);	* Dolphin gives LOGSE,WP,DIRTY,REF					* Lisp wants REF,--,WP,DIRTY	APC&amp;APCTask &larr; lspL5;	T &larr; (XBuf) and (130000c), return;	* T &larr; flags* SetFlags(Vp, RP, flags)@@SetFlags:	PFetch1[AC2, XBuf1, 3], mbx[02];	* flags in XBuf1	T &larr; AC1, loadpage[pgMapOps];		* RP in XBuf	XBuf &larr; T, callp[WriteMap2];	goto[NoSkipStart];@WriteMap:	loadpage[pgHStack], call[CheckElt3P5], opcode[163];	T &larr; Stack&amp;-1, call[WriteMap1];		* FlagsPop2P5:	StkState &larr; rsh[StkState, 2], goto[nxiLBL];	* Two popsWriteMap1:	lu &larr; (Stack&amp;-1) - (smallpl);	XBuf1 &larr; T, skip[alu=0];			* XBuf1 &larr; flags	  lspUFN &larr; 163c, goto[ufnLBL];			* not smallpos	T &larr; Stack&amp;-1;	lu &larr; (Stack&amp;-1) - (smallpl);	XBuf &larr; T, skip[alu=0];			* XBuf &larr; RP	  lspUFN &larr; 163c, goto[ufnLBL];			* not smallpos	T &larr; Stack&amp;-1;	lu &larr; (Stack&amp;+1) - (smallpl);	AC0 &larr; T, skip[alu=0];			* AC0 &larr; VP	  lspUFN &larr; 163c, goto[ufnLBL];			* not smallposWriteMap2:* Now have XBuf = RP, XBuf1 = Flags, AC0 = VP	XBuf1 &larr; lsh[XBuf1, 1], skip[R&gt;=0];	  XBuf1 &larr; (XBuf1) or (10000c);		* rearrange flags as needed	T &larr; (XBuf1) and (70000c);	XBuf &larr; (ldf[XBuf, 4, 14]) or T, goto[XMapAc0];XmapAc0:			* Call XMap for page in AC0 using XBuf	T &larr; lhmask[AC0];	lspGenBrHi &larr; T;	T &larr; lsh[AC0, 10];	lspGenBr &larr; T;	nop;			* is this needed?	xmap[lspGenBr, XBuf, 0];	XBuf &larr; XBuf, UseCTask, goto[retLBL];				* Don't task while map is screwy	:END[Lisp0];</pre>
  </body>
</html>
