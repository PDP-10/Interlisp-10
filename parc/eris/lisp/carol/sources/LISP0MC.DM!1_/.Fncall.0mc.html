<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Carol>SOURCES>LISP0MC.DM!1>Fncall.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Fncall.0mc...August 11, 1982  5:23 PM, van Melle];* Fn0, op 010, Call function of 0 args whose name is in first 2 bytes@Fn0:	lspNargs &larr; 0c, goto[FnxTail], opcode[010];* Fn1, op 011, Call function of 1 args whose name is in first 2 bytes@Fn1:	lspNargs &larr; 1c, goto[FnxTail], opcode[011];* Fn2, op 012, Call function of 2 args whose name is in first 2 bytes@Fn2:	lspNargs &larr; 2c, goto[FnxTail], opcode[012];* Fn3, op 013, Call function of 3 args whose name is in first 2 bytes@Fn3:	lspNargs &larr; 3c, goto[FnxTail], opcode[013];* Fn4, op 014, Call function of 4 args whose name is in first 2 bytes@Fn4:	lspNargs &larr; 4c, goto[FnxTail], opcode[014];* Fnx, op 015, Fully general function call, first byte is number of args, next 2 bytes are atom@Fnx:	T &larr; NextData[IBuf], opcode[015];	lspNargs &larr; T, goto[FnxTail];	* Get number of argsFnxTail:	T &larr; NextData[IBuf];	lspDefx1 &larr; T;	T &larr; NextData[IBuf];	loadpage[pgFrame];	lspDefx1 &larr; (lsh[lspDefx1, 10]) or T, gotop[lspCallFn0];* CheckApply*, op 017: Punt if TOS is not ccodep or is NLAMBDA*@CheckApply:	T &larr; lsh[Stack&amp;-1, 1], opcode[17];	lu &larr; Stack&amp;+1;	lspGenBrHi &larr; (DEFspace), skip[alu=0];	  lspUFN &larr; 17c, goto[ufnLBL];	lspGenBr &larr; (DEFbase);	nop;				* may not be needed	PFetch2[lspGenBr, lspL0];	* fetch function definition cell	lspL0 &larr; (lspL0) and (10000c), goto[ApplyStarUfn, R&gt;=0];					* Ufn if codep bit off	skip[alu#0];	  NextOpCode;	lspUFN &larr; 17c, goto[ufnLBL];ApplyStarUfn:	lspUFN &larr; 17c, goto[ufnLBL];* Applyfn, op 016:* apply function whose name is TOS and number of args is TOS-2* This checks for 3 elements on stack because StkState cannot*  indicate no elements on stack@Applyfn:	nop, opcode[016];ApplyFn:	loadpage[pgHStack], call[CheckElt3P4];	T &larr; Stack&amp;-1;	lspDefx1 &larr; T;	T &larr; Stack&amp;-1;	lspDefx0 &larr; T;	T &larr; Stack&amp;-2;	lspNargs &larr; T, loadpage[pgFrame];	StkState &larr; rsh[StkState, 2], gotop[lspCallfn];onpage[opPage0];lspUfnxP4:	T &larr; SStkp;	lspL4 &larr; T, loadpage[pgUfnxA];	T &larr; (PcxReg);onpage[pgUfnxA];	Stkp &larr; lspL4, lspL4 &larr; T, NoRegILockOk, task;				* Stkp backed up to as of start of opcode				* LspL4 = PCF as of start of opcode	T &larr; (PCFReg);	lu &larr; (lspL4) - T;	* has PCF changed (i.e. more bytes fetched)?	lspGenBrHi &larr; STATSspace, skip[alu=0];	  PCF &larr; lspL4;	* yes, restore it.  Can't be unconditional			* because only low 3 bits of PCF can be loaded	lspGenBr &larr; UFNTableBase;	T &larr; lsh[lspUFN, 1];		* index into double-word ufn table	PFetch2[lspGenBr, lspL2];		* fetch function definition	T &larr; rhmask[lspL3];			* get number of args	lspL3 &larr; rsh[lspL3, 10];			* number of extra bytes (0-2)	lspNargs &larr; T, goto[lspUfnx4a, alu=0];	* skip much if no extra bytes	T &larr; NextData[IBuf];	lu &larr; lspL3, goto[lspUfnx4b, R Odd];	lspL1 &larr; T;	T &larr; NextData[IBuf];	T &larr; (lsh[lspL1, 10]) or T;lspUfnx4b:	Stack&amp;+1 &larr; (smallpl);	Stack&amp;+1 &larr; T;				* Push extra byte(s) as smallp	StkState &larr; lsh[StkState, 1];lspUfnx4a:	T &larr; lspL2, loadpage[pgFrame];		* Ufn atom	lspDefx1 &larr; T, gotop[lspCallfn0];	* call the function	:END[Fncall];</pre>
  </body>
</html>
