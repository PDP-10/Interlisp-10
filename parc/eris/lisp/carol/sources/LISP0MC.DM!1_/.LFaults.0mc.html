<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>Carol>SOURCES>LISP0MC.DM!1>LFaults.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Faults.0mc, July 29, 1983  4:39 PM, van Melle];* Punt cases, going to Bcpl* SubrCall opcode:  AC2 = Subr Number, AC3 = Number of Args@SubrCall:	nop, opcode[175];	T &larr; NextData[IBuf];		* Get Subr #	AC2 &larr; T;	T &larr; NextData[IBuf];		* Get Nargs	AC3 &larr; T, loadpage[pgHStack];	callp[ClrHStk];	lspL2 &larr; SubrArgArea;		* Address the subr arg area	lspL3 &larr; (0c);	T &larr; lsh[AC3, 1];			* Nargs*2	lspTsp &larr; (lspTsp) - T;	lspTsp &larr; (lspTsp) + (2c);	* Point tsp at first argSubrLp:	T &larr; (Form-2[AllOnes]) + T;	* T &larr; T-2	goto[lspSubr1, alu&lt;0];		* (T = 0 for final iteration)	PFetch2[lspTsp, lspL0];		* L0,1 &larr; TOS	call[retLBL];			* (alloc constraint keeps out of prev)	PStore2[lspL2, lspL0], goto[SubrLp];	* Arg &larr; L0,1lspSubr1:	T &larr; PCFreg;	PCB &larr; (lsh[PCB, 1]) + T;	T &larr; lsh[lspIfuBr, 1];	T &larr; PCB &larr; (PCB) - T;		* PC = 2*(PCB - Fnheader) + PCF	lspPC &larr; T;			* prepare to store it	T &larr; lspTsp, loadpage[pgLisp0];	* was addr of first arg = FX:Next	lspNext &larr; T;			* this comes after lspIfuBrHionpage[pgLisp0];	lspEp &larr; (lspEp) - (12c);		* point at FX	PStore4[lspEp, lspIfuBr, 2], goto[SubrMkFree];					* Store fnheader, Next, PC:IF[WindFlg];* ContextSwitch op.  TOS = context # (smallp)@ContextSwitch:	T &larr; Stack&amp;-1, loadpage[pgLisp0], opcode[176];	* context #	lu &larr; (Stack&amp;+1) xor (smallpl);		* Verify that it is smallponpage[pgLisp0];	AC2 &larr; T, skip[alu=0];			* AC2 &larr; context#	  lspUfn &larr; 176c, goto[ufnLBL];* If we were switching from kbd context, need interrupts back onEnableInterrupts:	NWW &larr; (NWW) and not (100000c), goto[CxS1, R&gt;=0];	  FreezeResult, call[CheckInterrupts];			* interrupts were off, may need to set IntPending	  nop;					* Alloc constraintCxS1:	AC3 &larr; 177400c, goto[NoBackup];		* AC3&lt;0 signals contextswitch*  While in Lisp, all interrupt bits are in NWW; don't have to worry about WW.CheckInterrupts:	T &larr; (SStkP&amp;NStkP) xor (377c), skip[alu#0];	  return;				* no interrupts called for	lspLN &larr; IP[RSImage]c;	StkP &larr; lspLN, lspLN &larr; T, NoRegILockOK;	* =&gt; RS232 image register	T &larr; Stack &larr; (Stack) or (IntPendingBit);	* OR in the intpending bit	StkP &larr; lspLN, RS232 &larr; T, return;	* restore stkp, stow RS232:ELSE;	lspUFN &larr; 176c, goto[ufnLBL], opcode[176];	* punt contextswitch:ENDIF;* Assorted punt cases*** NWW Interrupt, between instructions:IF[WindFlg];onpage[opPage0];		* From Nww opcode (0)NWWPunt:				* -2- Fetch --No args, Never FN	AC3 &larr; 0c;	loadpage[pgLisp0];:ELSE;onpage[pgLisp0];lspNWWInt:	AC3 &larr; 0c;:ENDIF;	AC2 &larr; (LispExitCodex), goto[CheckforBackup];onpage[pgFrame3];*** Stack overflow in function call (Context switch)lspSubovPunt:		* -1- Frame --Ac1= # of additional words, Always FN	AC3 &larr; 177400c;					* =&gt; do context switch	loadpage[pgLisp0];	AC2 &larr; SubovFXP, goto[CheckforBackup];		* Ac2 = Context#onpage[pgLisp0];*** Stack overflow in push, end of instruction (Context switch)StackFullPunt:		* -1- Stack --Ac1= # words, Never FN	AC3 &larr; 177400c;	AC2 &larr; SubovFXP, goto[NoBackup];*** Stats overflow (Checked in Return, at end of inst):IF[StatsMode];	onpage[pgJump];StatsPunt:	AC3 &larr; 0c;		* No args	loadpage[pgLisp0];	AC2 &larr; (StatsOvflCodex), gotop[NoBackup];	onpage[pgLisp0];:ENDIF;*** Page Fault, anywherellspMapFaultPunt:	* -3- Lfaults --, Sometime FN			* Come here with AC0 = Fault page			* Bcpl wants Ac0,1 = virtual addr of read fault	T &larr; 374c, at[MapFaultPuntLoc];	T &larr; (lsh[Stack, 2]) xor T;			* StkP points at PipeReg4			* = main col address in low 6 bits, complemented	T &larr; (ldf[lspGenBr, 16, 2]) or T;				* insert a within-quad address from				* base reg (may be wrong, but it is right for				* Getbase et al and Bcpl fetches, and we can't				* do better)	AC1 &larr; T;	* AC1 now has within-page address in rh, normal	T &larr; lsh[AC0, 10];	* low half of page	AC1 &larr; (rhmask[AC1]) or T;	* AC1 now has low half of fault addr	AC0 &larr; rsh[AC0, 10];		* AC0 has high half	Dispatch[lspInstFlag, 14, 4];	StkP &larr; xBuf2, disp[FaultDisp0];:IF[FaultFlg];*****  Fault switch context ******FaultDisp0:lspDoFault:	AC3 &larr; 177400c, at[FaultDisp, NormalState!];	* Do context switch	AC2 &larr; FaultFXP, call[GetInterfaceBase];	lspGenBr &larr; (lspGenBr) + (IFPFAULTHI);	* Store fault addr in interface page	PStore1[lspGenBr, AC0, 0], call[retLBL];:IF[Debugging];	lu &larr; (lspEp) - (minFaultPvar);	PStore1[lspGenBr, AC1, 1], skip[Carry];	  lspL1 &larr; (FaultInFault), goto[RaidPunt];	NWW &larr; (NWW) and not (100000c), goto[CheckforBackup, R&gt;=0];					* Are interrupts on?:IF[BreakPoints];	breakpoint;:ELSE;	lspL1 &larr; (FaultWithoutInterrupts), goto[RaidPunt];:ENDIF;:ELSE;	* if not debugging...	PStore1[lspGenBr, AC1, 1], goto[CheckforBackup];:ENDIF;:ELSE;*****  Fault call Bcpl ******FaultDisp0:lspDoFault:	lspL3 &larr; 0c, at[FaultDisp, NormalState!];	lspL2 &larr; (subrArgArea), task;	* Point at subr arg area	AC3 &larr; 1c;			* One arg	AC2 &larr; (PageFaultCodex);	PStore1[lspL2, AC0, 0], call[retLBL];	* store fault addr as subr arg	PStore1[lspL2, AC1, 1], goto[CheckforBackup];:ENDIF;StorePuntArgs:	lspL0 &larr; (smallpl);	T &larr; (subrArgArea);	PStore2[MDS, lspL0];	* Store subr args	AC2 &larr; (UcodeCheckCodex), return;NoBackup:	T &larr; PCFreg, goto[lspPuntStore];*** Raid punt, disaster onlyRaidPunt:			* -0- Ucode Check  --Arg in L1 = Smallp code	AC3 &larr; 1c, call[StorePuntArgs];CheckforBackup:	T &larr; (Pcxreg) - 1;	* PC at start of inst - 1, so will be redone	lu &larr; (Pcfreg) - T;	goto[lspPuntStore, alu&gt;=0];	  PCB &larr; (PCB) - (4c), goto[lspPuntStore];			* If PCF &lt; PCX-1 then buffer refill occurred, so decrement PCBlspPuntStore:	PCB &larr; (lsh[PCB, 1]) + T;	T &larr; lsh[lspIfuBr, 1];	T &larr; PCB &larr; (PCB) - T;		* PC = 2*(PCB-Fnheader) + PCF	lspPC &larr; T, loadpage[pgHStack];	* prepare it for PStore4 below	callp[ClrHStk];	lspEp &larr; (lspEp) - (12c);	* Point at FX	PFetch1[lspEp, lspL4, 0];	* L4 &larr; flagword of current frame	lspL0 &larr; (smallpl);		* Note: this is set for SubrInCall branch below, and also		* to make sure that L0,1 is a valid pointer in case of		* contextswitch to a non-nopush context	lu &larr; lspInstFlag, goto[SubrInCall, R&lt;0];	* In a function call?*** Normal punt, just set No Push bit	T &larr; lspTsp &larr; (lspTsp) + (2c);	* Point at word after end of frame	lspNext &larr; T, call[retLBL];	* Wait for reg to get written	PStore4[lspEp, lspIfuBr, 2];	* Store fnheader, Next, PC	lspL4 &larr; (lspL4) or (FxNoPushReturn), goto[SubrStFlags];					* Set no push bit*** Here if we were in function call...:IF[StkDebug];				* Are there 6 words on stack?SubrInCall:						T &larr; (lspTsp) + (6c);		***** temp	T &larr; (lspEsp) - T;		***** temp (should check for wraparound)	skip[carry];			***** temp	 breakpoint, goto[.];		***** temp: die if &lt; 6 words on stk:ELSE;SubrInCall:	nop;:ENDIF;* Store on stack the number of args, as a smallp, and the function definition* Tsp currently points at TOS	PStore2[lspTsp, lspDefx0, 4];		* store fn name	T &larr; lspNargs;			* lspL0 already = smallpos	lspL1 &larr; T;	PStore2[lspTsp, lspL0, 2], call[retLBL]; * Store Nargs as a smallp	lspTsp &larr; (lspTsp) + (6c);		* Next	PStore1[lspEp, lspTsp, 4], call[retLBL];	* Store it	lspL4 &larr; (lspL4) or (FxInCall);		* Set call in progressSubrStFlags:	PStore1[lspEp, lspL4, 0], goto[SubrMkFree];SubrMkFree:	T &larr; lspTsp;	T &larr; (lspEsp) - T;		* Compute # words free after frame	lspL3 &larr; T, goto[SubrStkError, No Carry];	* error if Esp&lt;Tsp	lspL2 &larr; freeStackBlock, Skip[alu=0];	* don't store empty free block	PStore2[lspTsp, lspL2, 0];	* make a free block	lu &larr; AC3, goto[CxtSwitch, R&lt;0];:IF[StatsMode];	lspStatsPtr, goto[SubrStat, R&gt;=0];:ENDIF;SubrStatDone:ToBcpl:					* Store current FX in interface page	PCB &larr; (BcplStartAddress);	* allocation constraint	call[GetInterfaceBase];	PStore1[lspGenBr, lspEp, 0], gotoExternal[lStartNovaLoc];CxtSwitch:	lspInstFlag &larr; (NormalState), call[GetInterfaceBase];	T &larr; AC2;	PFetch1[lspGenBr, lspLN], call[retLBL];				* Swap FX with one in Interfacepage	loadpage[pgReturn];	PStore1[lspGenBr, lspEp], gotop[lspRtn2];GetInterfaceBase:			* Point GenBr pair at Interface page	lspGenBrHi &larr; (INTERFACEspace);	lspGenBr &larr; (INTERFACEbase), return;:IF[BreakPoints];SubrStkError:	breakpoint, goto[.];:ELSE;SubrStkError:				* turn this into raid punt instead	T &larr; lspEsp;	lspL1 &larr; T, call[StorePuntArgs];	AC3 &larr; 1c, goto[ToBcpl];		* 1 arg to ucodecheck:ENDIF;:IF[WithMidas];lStartNova:	gotoExternal[lStartNovaLoc];:ENDIF;</pre>
  </body>
</html>
