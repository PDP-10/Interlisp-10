<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>Carol>SOURCES>LISP0MC.DM!1>Float.0mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 6pt; text-align: left">
<span style="font: 12pt serif">:IF[WithFloatingPoint]; ********************************<br>TITLE[Float.0mc];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* single-precision floating point<br><br>Set[PackInLine, WithCreateCell];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* Do createcell inline<br><br>* Adapted from MesaFp.mc<br>* Last edited September 29, 1982  10:04 PM van Melle<br>%<br>edits by Fiala<br>Original version by Jim Boyce.<br><br>Floating point numbers are represented in two different formats.  Arguments<br>on the stack are IEEE single precision reals with the following format:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">bit 0</span><span class="tab" val="77"></span><span style="font: 12pt serif">sign (1 means negative)<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1:8</span><span class="tab" val="77"></span><span style="font: 12pt serif">exponent biased by 127d<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">(exponent of 177b with a fraction of 0 is the integer 1;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif"> exponent of 0 with a fraction of 0 is true 0;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif"> exponent of 0 with non-0 fraction is denormalized [i.e., the<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">   fraction does not have an implicit "1." in front of it];<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif"> exponent of 377b with a fraction of 0 is infinity;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif"> exponent of 377b with non-0 fraction is Not-A-Number)<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">9:31</span><span class="tab" val="77"></span><span style="font: 12pt serif">fraction<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">(implicitly preceded by &rsquo;1.&rsquo; if non-0 and normalized.)<br><br>These numbers appear on the stack with the word holding bits 0-15 nearer to<br>the top of stack.  Most operations unpack the operands into a format that is<br>easier to work with.  This format uses three words interpreted as follows:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">ExpSign</span><span class="tab" val="77"></span><span style="font: 12pt serif">bits 1:8 are the exponent (biased by 127d), bit 15d the sign.<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">NOTE: FAdd, FSub, FMp, FDiv, etc. must and do compensate for<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">the addition of 1 to the exponent which occurs in the Renorm<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">subroutine.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Frac</span><span class="tab" val="77"></span><span style="font: 12pt serif">The fraction.  When unpacked, the leading one appears in<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">Frac[1]; when about to be packed again, the leading bit is in<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">Frac[0],  Frac[31d] is a StickyBit (the inclusive or of all<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">remaining bits); Fix and Round handle rounding slightly<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">differently.  <br></span><span class="tab" val="77"></span><span style="font: 12pt serif">FracH</span><span class="tab" val="77"></span><span style="font: 12pt serif">16 high order bits of Frac.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">FracL</span><span class="tab" val="77"></span><span style="font: 12pt serif">16 low order bits of Frac.<br><br>Three registers for each of the two arguments hold a floating point number in<br>unpacked form.  These registers have names with 1&rsquo;s or 2&rsquo;s in them.  Numbers<br>are often referred to by index (SB or DB).  Arg1 has index 2 and Arg2 has<br>index 3.<br><br>The IEEE specification calls for four different rounding modes, two methods of<br>handling underflow/denormalized numbers (we have added a third), two kinds<br>of infinity.  We are in the process of converting to a Real package that<br>records all mode settings in the fpSticky register accessible to microcode.<br>When this conversion is complete, microcode will optionally implement as much<br>of the package as it wants to, but trap when an opcode cannot be completed in<br>microcode.  We fall short in that the fpSticky register is not saved in<br>the Mesa process state.  In all other situations, microcode either completes<br>the operation or traps to software, as indicated below.<br><br><br>POSSIBLE IMPROVEMENTS:<br><br>1) Get the 1st level Misc dispatches all on one page to save 4 cycles here.<br>2) Put call to RoundFrac in FDiv exit saving 6 cycles.<br>3) Faster Renorm called from Float and subtraction.<br>4) Eliminate 3 cycles in zero-arg testing for all two-arg opcodes.<br>5) Use 31b max shift rather than 40b for Unnorm entry from FAdd/FSub; possibly<br>do the Unnorm entry differently for negative fpTemp.<br>6) Implement variant rounding modes, infinities, gradual denormalization,<br>infinity on overflow, not-a-number on divide by zero, mod on fix/round<br>overflow.<br>7) Get the fpSticky register and ? software bits in the process state.<br>8) Speed FSc by directly adding scaling factor to exponent field.<br><br>FPSTICKY REGISTER<br><br>  0</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">OR 1 into fpSticky[15d] on every inexact result<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">Trap on any inexact result<br>1-2</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">Trap on any denormalized result (user may be interested in<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">the loss of precision)<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">Substitute 0 on underflow (non-IEEE; requested by Wilhelm)<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">2</span><span class="tab" val="77"></span><span style="font: 12pt serif">Gradually denormalize on underflow (not in microcode)<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">3</span><span class="tab" val="77"></span><span style="font: 12pt serif">--<br> 3</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">Projective infinity (only one unsigned infinity; compare of<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">anything with infinity traps; not sure what other operations<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">are supposed to do).<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">Affine infinity (+ infinity and - infinity both defined;<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">arithmetic and comparisons work as expected).<br>4-5</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">Round to nearest (unbiased; round to even if halfway)<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">Round toward 0 (truncate)--not in microcode<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">2</span><span class="tab" val="77"></span><span style="font: 12pt serif">Round toward plus infinity--not in microcode<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">3</span><span class="tab" val="77"></span><span style="font: 12pt serif">Round toward minus infinity--not in microcode<br>  6</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">Trap if denormalized args are supplied<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">Normalize the arguments and then use them (not in microcode)<br>  7</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">Trap on invalid operations (compare of projective infinity,<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">Not-a-number as an argument)<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">Result is the infinity or not-a-number (not in microcode)<br>  8</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">Trap on overflow of Fix or Round operation<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">Return low-order 16d bits of the result (not in microcode)<br>  9</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">Trap on divide-by-zero<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stuff in not-a-number on divide-by-zero and continue<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">(not in microcode)<br> 10d</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">Trap on arithmetic overflow<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stuff in infinity on arithmetic overflow and continue<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">(not in microcode)<br>11-14d</span><span class="tab" val="77"></span><span style="font: 12pt serif">--</span><span class="tab" val="77"></span><span style="font: 12pt serif">undefined<br> 15d</span><span class="tab" val="77"></span><span style="font: 12pt serif">0</span><span class="tab" val="77"></span><span style="font: 12pt serif">All results have been exact<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1</span><span class="tab" val="77"></span><span style="font: 12pt serif">One or more inexact results have occurred (i.e., rounding has<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">taken place).<br><br>Softare is expected to execute the FSticky opcode to exchange a new value on<br>the stack with the value currently in Sticky; then it executes floating point<br>opcodes in the new mode settings.  The fpSticky register should be saved with<br>the Mesa process state.  Also, the software state of the floating point<br>processor includes occurrence bits for all the events which have traps:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Inexact result occurred (temporarily kept in fpSticky),<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Denormalized arguments were supplied;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Invalid operations occurred;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Fix/Round overflow occurred;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Divide by zero occurred;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Arithmetic overflow occurred;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Underflow occurred.<br>The microcode need not keep these occurrence bits because the software can<br>originally cause the events to trap, remember the event in storage, and<br>turn off the microcode trap enable.<br>**What about keeping the events in the process state?<br><br>In the current microcode implementation, any argument with 377b or 0b<br>exponent and any result which overflows will trap to software.<br><br><br>ROUNDING MODES<br><br>Rounding occurs at SB[fpFracL] bit 7 for arithmetic or bit 15d for Fix and<br>Round.  The bit following the one rounded is the rounding bit, and all lower<br>bits are sticky bits.  If sticky bits are all 0, the result is exact, and no<br>rounding occurs.  Otherwise, if the InexactResult trap is enabled, trap.<br>Otherwise, round in the direction specified by the rounding mode.<br><br>"Round to nearest" goes in the obvious direction when the sticky bits are<br>.ne. 0; if rounding bit is 1 and sticky bits .eq. 0, the number is exactly<br>halfway between two possible results, so by convention round to the nearest<br>even number.<br>%<br><br>*NOTE that fpExpSign, fpFracH, and fpFracL are not used--these are displaced<br>*by SB[] or DB[] to select the 1/2 registers.<br><br>RV[fpExpSign,70];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[fpFracH,14];</span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[fpFracL,44];<br>RV[fpExpSign1,72];</span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[fpFrac1H,16];</span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[fpFrac1L,46];<br>RV[fpExpSign2,73];</span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[fpFrac2H,17];</span><span class="tab" val="77"></span><span style="font: 12pt serif">RV[fpFrac2L,47];<br>*</span><span class="tab" val="77"></span><span style="font: 12pt serif">lspL2,3</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">  uBuf2,3</span><span class="tab" val="77"></span><span style="font: 12pt serif">   xBuf2,3<br><br>*RV[fpSticky,75];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*See page 1 comment--NOT A TEMPORARY<br>*RV[fpCode,45];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Fix, Round (xBuf1)<br>RV[fpCCTemp,44];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Unnorm</span><span class="tab" val="77"></span><span style="font: 12pt serif">(xBuf)<br>RV[fpTemp,71];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Unnorm, FAdd, FSub (lspL1)<br>RV[fpCount,44];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*FMul -- same as fpCCTemp<br>RV[fpFrac2HLSh1,70];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*FMul (lspL0)<br>RV[fpFrac2HLSh1p1,45];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*FMul -- same as fpCode<br>RV[fpOne,71];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*FMul -- same as fpTemp<br>RM[fpFrac1LL,IP[fpFrac2L]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*FMul<br>RV[fpTFrac,70];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*FDiv -- same as fpFrac2HLSh1<br>RV[fpFrac2H&rsquo;,44];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*FDiv -- same as fpCCTemp<br>RV[fpFrac2H&rsquo;p1,71];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*FDiv -- same as fpTemp<br>RV[fpFrac2Hp1,45];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*FDiv -- same as fpCode<br>*RM[fpRhi,IP[fpFrac1L]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*FSqRt<br>*RM[fpRlo,IP[fpFrac1H]];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*FSqRt<br><br>*545b mi including two alpha-byte dispatch locations overwritten in MesaX.<br>Set[fpPage0,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*354b mi (not pages 4 to 7)<br>Set[fpPage1,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* 36b mi<br>Set[fpPage2,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* 40b mi<br>Set[fpPage3,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*  5b mi<br>Set[fpPage4,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* 12b mi<br>Set[fpPage5,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* 22b mi<br>Set[fpPage6,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*  2b mi<br>Set[fpPage7,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* 23b mi<br>Set[fpPage8,11];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*  3b mi<br><br>Loca[UnnormDisp,fpPage0,40];<br>Loca[UnpackRet,fpPage0,60];<br>Loca[RoundDisp,fpPage0,100];<br>Loca[FixDisp,fpPage0,120];<br><br></span><span style="font: 10pt serif">M@[FloatOp, Or[And[#1,37], LShift[#2, 5]]];</span><span class="tab" val="77"></span><span style="font: 10pt serif">* FloatOp[opcode, fn]<br>* lspUFN = &lt;3 bits of dispatch ,, low 5 bits of opcode&gt;<br><br>RV2[Result1Hi, Result1Lo, IP[AC0]];<br><br>@FPlus:</span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; FloatOp[350, 0]c, goto[FUnbox], opcode[350];</span><span class="tab" val="77"></span><span style="font: 10pt serif"><br>@FDifference:<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; FloatOp[351, 1]c, goto[FUnbox], opcode[351];<br>@FTimes:</span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; FloatOp[352, 2]c, goto[FUnbox], opcode[352];<br>@FQuotient:<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; FloatOp[353, 3]c, goto[FUnbox], opcode[353];<br>@FGreaterp:<br>*****</span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; 362c, goto[lspUfnxP7], opcode[362];</span><span class="tab" val="77"></span><span style="font: 10pt serif">* FGreaterp<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; FloatOp[362, 4]c, goto[FUnbox], opcode[362];<br></span><span style="font: 12pt serif"><br>* Common floating unbox routine.  To simplify interface to Mesa, which<br>* expects TOS to be lo2, hi2 and TOS-1 to be lo1, hi1, we unbox the top<br>* two elements of the stack into 4 contiguous regs, pointing stkp at the<br>* front end, and swap push and pop in the mesa code.  Thus we will have<br>* qBuf = hi2, lo2, hi1, lo1<br><br>FUnbox:</span><span class="tab" val="77"></span><span style="font: 12pt serif">loadpage[pgHStack], call[CheckElt2P7];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&-1, call[FUnboxSub];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">PFetch2[xBuf2, qBuf, 0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&-1, call[FUnboxSub];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">PFetch2[xBuf2, qBuf2, 0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">lspLN &larr; IP[qBuf]c;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (SStkP&NStkP) xor (377c);</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">* T &larr; StkP<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">StkP &larr; lspLN, lspLN &larr; T, NoRegILockOK;</span><span class="tab" val="77"></span><span style="font: 12pt serif">* Point stkp at qBuf<br><br>* T is loaded with 30b, stored in SALUF as the A + A + Cy0 ALU operation.<br><br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2H &larr; T &larr; 30C;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">loadpage[fpPage0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2H &larr; (fpFrac2H) + (SALUF &larr; T), GoToP[Unpack2];<br><br><br>FUnboxSub:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">xBuf2 &larr; T;<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">T &larr; lsh[Stack&-1, 10];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">xBuf3 &larr; T;<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">T &larr; rsh[xBuf2, 11];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">T &larr; (rsh[xBuf3, 1]) or T;<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">PFetch1[MDSTypeBaseBr, lspType];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">T &larr; (FloatpType);<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lu &larr; (rhmask[lspType]) xor T;<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">skip[alu#0];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">  return;<br></span><span style="font: 12pt serif">FloatUfn:<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; (lspUFN) or (340c), goto[ufnLBL];<br></span><span style="font: 12pt serif"><br><br>%Unpack2 unpacks the first Real on the stack into fpExpSign2, fpFrac2H, and<br>fpFrac2L and the 2nd into fpExpSign1, fpFrac1H, and fpFrac1L and returns<br>SB pointing at arg1 and fpFrac1H in T for FAdd, FSub, FMul, and FDiv.<br><br>Unpack1 unpacks one real on the stack into fpExpSign2, fpFrac2H, and<br>fpFrac2L and returns SB and DB pointing at arg2 for Fix and Round.<br><br>Unpack also filters out numbers which the microcode can&rsquo;t handle, traping on<br>unnormalized numbers, Infinities, and NotANumbers.<br><br>Timing = 29 cycles for Unpack1, 46 for 2 args (-3 per arg that is 0 and<br>+1 per arg that is negative).<br>%<br>OnPage[fpPage0];<br><br>*fpFrac2H contains 60b here, where the two leading ones (i.e., bits 10:11d)<br>*are loaded into the word-addressing part of SB and select word 3 of an<br>*addressed quadword.<br><br>Unpack2:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2H &larr; (SB &larr; fpFrac2H) - 1, Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LdF[Stack,11,7];<br>*BBFBX causes SBX&larr;SB; the SB&larr; here takes effect when BBFBX in the last mi of<br>*Unpack is executed.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB &larr; fpFrac2H, fpFrac2H &larr; T, BBFBX, NoRegILockOK, Call[Unpack2A];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2H &larr; (LSh[fpFrac2H,7]) or T, Call[Unpack];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">StkP &larr; lspLN;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">**** Restore Stkp<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Dispatch[lspUFN,10,3];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; fpFrac1H &larr; (LSh[fpFrac1H,7]) or T, Disp[@FAdd];<br><br>% not used yet ------<br>fpSetSB:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB &larr; fpFrac2H, Return;<br><br>Unpack1:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2H &larr; (fpFrac2H) + (SALUF &larr; T), Call[fpSetSB];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">DB &larr; fpFrac2H, BBFBX, Call[Unpack];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*BBFBX will cause SBX&larr;SB<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Dispatch[fpCode,14,4];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; fpFrac2H &larr; (LSh[fpFrac2H,7]) or T, Disp[@Fix];<br>----- %<br><br>*Position exponent in bits 1:8 and sign in bit 15d because:<br>*(a) XOR&rsquo;ing  signs and adding or subtracting exponents in FMul and FDiv can<br>*be accomplished in one operation;<br>*(b) Convenient overflow/underflow test in sign bit of word; and<br>*(c) Convenient for packing result.<br><br>Unpack:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LdF[Stack,11,7];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; T;<br>Unpack2A:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (LdF[Stack&+1,1,17]) and not T, GoTo[UnpNeg,R&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; T, DblGoTo[UnpNZ, UnpZ, ALU#0];<br>UnpNeg:</span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; (Zero) + T + 1, DblGoTo[UnpNZ, UnpZ, ALU#0];<br><br>*Zero exponent may represent true 0 or denormalized number.<br><br>UnpZ:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&+1;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpFracH] or T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; T, BBFBX, GoTo[DenormTrap,ALU#0];<br>CInexactOK:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Return;<br><br>UnpNZ:</span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpExpSign] + (200C);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; SB[fpFracH] or (200C), GoTo[NaNTrap,ALU&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LSh[Stack,7];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; T, BBFBX;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; RSh[Stack&+1,11], Return;<br><br>%Entries are PackA and Renorm; NormGo is entered by FAdd/FSub and FSc; Float<br>contains a copy of the mi at Renorm.<br><br>Renorm left-shifts the fraction SB[fpFracH/L] until SB[fpFracH][0] is 1 and<br>subtracts the number of positions shifted from the exponent.  Then it rounds<br>SB[fpFracH],,SB[fpFracL] at SB[fpFracL][7] using SB[fpFracL][8] for rounding and<br>SB[fpFracL][9:15d] as sticky bits.  Finally, it performs range checks, pushes<br>the number onto the stack, and exits.<br><br>NOTE: If an overflow occurs, the possible range of exponents is<br>377 to 376+376-200 or 377b to 574b (For FMul with 0 NormSteps).<br>For an underflow, the possible range is 0 or 777b down to 0-376b+177b-1; i.e.,<br>0 or 777b down to 600b (For FDiv).<br><br>Timing from Renorm to exit: 8 x nsteps + 30 + (if sticky bits .eq. 0 after<br>normalizing: 1 if odd or 3 if even) + (3 if fpFracL carries rounding up<br>(+5 if fpFracH also carries)).<br>The number of normalizing steps will be:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">0 for FDiv or FSqRt<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1 for FSc (starting at NormGo);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">0 or 1 for FMul;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">0 or 1 for FAdd/FSub if signs are the same;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">1 to 24d for FAdd/FSub if signs differ (starting at NormGo);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">0 to 15d steps for Float.<br>%<br><br>NormStep:</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Only Renorm and copy of Renorm in Float jump to NormStep.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; SB[fpExpSign] - (200C);<br>LongNormGo:</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Odd placement; paired with mi at SubNonNeg+1.<br>NormGo:</span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; SB[fpFracL] SALUFOP T, Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; SB[fpFracH] SALUFOP T, UseCOutAsCIn;<br>*Even placement; paired with mi at MulDone+2.<br>Renorm:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LSh[SB[fpFracH],10], GoTo[NormStep,R&gt;=0];<br>%-----<br>Pack:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Dispatch[fpSticky,4,2];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Dispatch on rounding mode<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpFracL] and (177C), Disp[.+1];<br>*Round to nearest:  Test sticky bits; begin assuming sticky bits .ne. 0<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; SB[fpFracL] + (200C), DblGoTo[RndEx,RndNr,ALU=0], DispTable[4];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Truncate (i.e., round toward 0)<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Round toward plus infinity<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Round toward minus infinity<br>-----%<br>Pack:</span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpFracL] and (177C);<br>*Round to nearest:  Test sticky bits; begin assuming sticky bits .ne. 0<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; SB[fpFracL] + (200C), DblGoTo[RndEx,RndNr,ALU=0]; <br><br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Assumption correct--continue rounding.<br>RndNr:</span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; SB[fpFracH] + 1, UseCOutAsCIn, DblGoTo[RndUp,Inexact,Carry];<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Assumption wrong--all sticky bits are 0--fixup result.<br>RndEx:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Dispatch[SB[fpFracL],7,3], Skip[Carry&rsquo;];<br>*If carry occurred, then the number was exactly halfway between an odd<br>*number and the next higher even number, and it is now correctly rounded.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  SB[fpFracH] &larr; SB[fpFracH] + 1, GoTo[RndUp];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Disp[.+1];<br>Inexact:</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">* [0] Was halfway and odd--now fixed up.<br>*</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpSticky &larr; (fpSticky) or (1C), DblGoTo[InexactTrap,InexactNoTrap,R&lt;0], At[RoundDisp,0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">goto[InexactNoTrap], At[RoundDisp,0];<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">* [2] Was exact and even--adding 200b didn&rsquo;t affect it.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpExpSign] + (400C), DblGoTo[OverUnderflow,Pack2,R&lt;0], At[RoundDisp,2];<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">* [4] Was halfway beteen even & next higher odd--undo +200b.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; SB[fpFracL] - (200C), GoTo[Inexact], At[RoundDisp,4];<br><br>RndUp:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LSh[SB[fpFracH],10], GoTo[.+3,Carry&rsquo;];<br>*Adding 400b to SB[fpExpSign] here while leaving SB[fpFracH] .eq. 0 works<br>*except when exponent is 376b--false overflow gets generated.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  SB[fpExpSign] &larr; SB[fpExpSign] + (200C);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  SB[fpFracH] &larr; 100000C;<br>****</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpSticky &larr; (fpSticky) or (1C), GoTo[InexactTrap,R&lt;0];<br>InexactNoTrap:</span><span class="tab" val="77"></span><span style="font: 12pt serif">* [6] Was exact and odd.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpExpSign] + (400C), DblGoTo[OverUnderflow,Pack2,R&lt;0], At[RoundDisp,6];<br><br>Pack2:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (RSh[SB[fpFracL],10]) or T, GoTo[Overflow,ALU&lt;0];<br>:IF[PackInLine];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">Result1</span><span style="font: 12pt serif">Lo &larr; T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SB[fpExpSign] and not (177C), Task;<br>*Simultaneously offset the exponent by 1 while OR&rsquo;ing in the fraction.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (LdF[SB[fpFracH],0,10]) + T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (LSh[SB[fpExpSign],17]) or T;<br>PackA:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+2;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">* Set stack correctly<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">Result1</span><span style="font: 12pt serif">Hi &larr; T, </span><span style="font: 10pt serif">loadpage[opPage0];</span><span class="tab" val="77"></span><span style="font: 10pt serif">* Create a new Floatp cell<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">qBuf &larr; lshift[FloatpType!, 4]c, callp[DoCreateCell];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">PStore2[lspGenBr, Result1Hi, 0];</span><span class="tab" val="77"></span><span style="font: 10pt serif">* Can&rsquo;t fault now<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">loadpage[pgRplPtr];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">StkState &larr; rsh[StkState, 1], gotop[GcExit];<br></span><span style="font: 12pt serif"><br>:ELSE;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+1 &larr; (smallpl);</span><span class="tab" val="77"></span><span style="font: 12pt serif">* Start pushing two smallps as result<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+3 &larr; T;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Push low-order result word<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SB[fpExpSign] and not (177C), Task;<br>*Simultaneously offset the exponent by 1 while OR&rsquo;ing in the fraction.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (LdF[SB[fpFracH],0,10]) + T;<br>*Push high-order result & exit<br>**PackA:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (LSh[SB[fpExpSign],17]) or T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (LSh[SB[fpExpSign],17]) or T;<br>PackA:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&-2 &larr; T;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">* hi-order result word<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+1 &larr; (smallpl);</span><span class="tab" val="77"></span><span style="font: 12pt serif">* Finish small boxing<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">lspDefx1 &larr; LoA[MakeFloatNumber!];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">lspNargs &larr; 2c;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+1, loadpage[pgFrame];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">lspDefx1 &larr; (lspDefx1) or (HiA[MakeFloatNumber!]), gotop[lspCallFn0];<br>:ENDIF;<br><br>%Improvement for Float and FAdd/FSub with different signs.<br>Timing: 12/tristep + (5, 10, or 14 for the exit 0, 1, or 2 step cases).<br>This is 2 slower for 0 steps, 1 faster for 1 step, and 5 faster for 2 steps;<br>much faster for longer normalizations.  Renorm goes 1 faster if all places<br>which might use more than 1 NormStep jump to LongNorm.<br><br>LongNorm:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Dispatch[SB[fpFracH],1,2], GoTo[PackL,R&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; SB[fpExpSign] - (200C), Disp[.+1];<br>Norm3:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; RSh[SB[fpFracL],15], At[x,0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; LSh[SB[fpFracL],3], Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; (LSh[SB[fpFracH],3]) or T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; SB[fpExpSign] - (400C), GoTo[LongNorm];<br>Norm2:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; RSh[SB[fpFracL],16], At[x,1];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; LSh[SB[fpFracL],2];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; (LSh[SB[fpFracH],2]) or T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; SB[fpExpSign] - (200C), GoTo[PackL];<br>NormGo:</span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; SB[fpFracL] SALUFOP T, Skip, At[x,2];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; SB[fpFracL] SALUFOP T, At[x,3];<br>PackL:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LSh[SB[fpFracH],10], GoTo[Pack];<br><br>NormStep:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; SB[fpExpSign] - (200C), GoTo[NormGo];<br>%<br><br><br>%NegFrac performs a 2&rsquo;s complement negation on SB[fpFracH],,SB[fpFracL] and<br>returns the new SB[fpFracL] in T.<br><br>Timing: 6 cycles if SB[fpFracL] is 0, else 7 cycles.<br>%<br>NegFrac:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SB[fpFracL];<br>NegFrac1:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; SB[fpFracH] xnor (0C), Skip[ALU=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; SB[fpFracL] &larr; (Zero) - T, Return;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; SB[fpFracH] + 1, Return;<br><br><br>%RoundCard rounds SB[fpFracH],,T using MNBR[0] as rounding bit and<br>MNBR[1:17b] as sticky bits; T is unchanged if no rounding occurs, or contains<br>the new SB[fpFracL] if rounding occurs.<br><br>Timing: 4 if exact, 12 if sticky bits .ne. 0, 13 if sticky bits .eq. 0.<br>%<br><br>:IF[0]; **********<br>RoundCard:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (MNBR) SALUFOP T, Skip[ALU#0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  Return;</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Exact<br>*Round up if halfway and sticky bits non-0.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (RZero) + T, UseCOutAsCIn, Skip[ALU=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  SB[fpFracH] &larr; SB[fpFracH] + 1, UseCOutAsCIn, GoTo[CInexact];<br>*Sticky bits all 0, rounding bit 1: round up if odd, down if even, but just<br>*added 1, so result is correct if SB[fpFracL] now even, else 1 too big.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; SB[fpFracH] + 1, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (Form-2[AllOnes]) and T;<br>CInexact:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">goto[CInexactOK];<br>*****</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpSticky &larr; (fpSticky) or (1C), DblGoTo[InexactTrapA,CInexactOK,R&lt;0];<br>:ENDIF; *********<br><br>%Unnorm right-shifts the fraction DB[fpFracH/L] by fpTemp[1:8] positions with<br>underflow going into MNBR.  MNBR[1:15] are sticky bits.<br><br>Unnorm is called on FAdd, FSub, Fix, FixI, FixC, Round, RoundI, and RoundC.<br>On FAdd and FSub, it right-shifts the fraction of the number with the smaller<br>exponent by an amount equal to the difference in the exponents, so that the<br>fractions can be added.  On Fix or Round, it shifts the fraction so that its<br>exponent can be made 235b, which positions the decimal point to the right<br>of fpFracL bit 15d.<br><br>Use of MNBR to capture underflow and the 37b maximum shift is needed for<br>Fix/Round, which use MNBR[0] for rounding and MNBR[1:15d] as sticky bits.<br>FAdd/FSub worst case is when signs differ and subtraction of fractions<br>necessitates two normalization steps afterwards; in this case DB[fpFracL] bit<br>10d will become the rounding bit, so a maximum shift of 31b suffices, MNBR is<br>not needed, and underflowing bits can result in OR&rsquo;ing into any of DB[fpFracL]<br>bits 11d to 15d.<br><br>Timing: 8 cycles if shift count .ge. 40b (i.e., the leading fraction bit in<br>DB[fpFracH] bit 1 is shifted further than bit 0 of MNBR); 14 if count is 0;<br>25 if count is 1 to 17b; 16 if count is 20b; or 27 if count is 21b to 37b.<br>%<br><br>Unnorm:</span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (fpTemp) - (10000C);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (LdF[fpTemp,5,4]) - 1, GoTo[.+3,ALU&lt;0];<br>*More than two words--any value .ls. 40000b ok here<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  MNBR &larr; R400, BBFBX;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; DB[fpFracH] &larr; 0C, Return;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpCCTemp &larr; T, BBFBX, GoTo[Unnorm0,ALU&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">CycleControl &larr; fpCCTemp;<br>*CycleControl &larr; RSCount - 1, so MWX &larr; RSCount - 1 and DBX &larr; 0.  For WFA, this<br>*will left-cycle by 17b - DBX - MWX (= 20b - RSCount) and mask with 1&rsquo;s in<br>*bits DBX to MWX (= 0..(RSCount - 1)).<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpCCTemp &larr; 16C;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Dispatch[fpTemp,4,1];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpCCTemp &larr; (fpCCTemp) - T, LoadPage[fpPage3], Disp[.+1];<br><br></span><span class="tab" val="77"></span><span style="font: 12pt serif">MNBR &larr; WFA[DB[fpFracL]], GoToP[.+1], At[UnnormDisp,0];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*1 to 17b<br>OnPage[fpPage3];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; WFA[DB[fpFracH]];<br>*CycleControl &larr; 16b - (RSCount mod 20b - 1), knowing RSCount is non-zero, or<br>*DBX &larr; 0 and MWX &larr; 17b - (RSCount mod 20b).  For RF, this left-cycles by<br>*MWX+DBX+1 (= 20b - RSCount) and masks with 1&rsquo;s in bits 17b-MWX to 17b<br>*(= RSCount mod 20b to 17b).<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">CycleControl &larr; fpCCTemp;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (RF[DB[fpFracL]]) or T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">DB[fpFracH] &larr; RF[DB[fpFracH]], Return;<br><br>*21b to 37b<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; DB[fpFracL] - 1, LoadPage[fpPage0], GoToP[.+1], At[UnnormDisp,1];<br>OnPage[fpPage3];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* +1 always .eq. or (1C) here<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (WFA[DB[fpFracH]]) + 1, UseCOutAsCIn, GoToP[.+1];<br>OnPage[fpPage0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">CycleControl &larr; fpCCTemp, fpCCTemp &larr; T, NoRegILockOK;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">MNBR &larr; fpCCTemp;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; RF[DB[fpFracH]];<br>Unnorm1:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">DB[fpFracH] &larr; 0C, Return;<br><br>Unnorm0:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Dispatch[fpTemp,4,1];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; MNBR &larr; DB[fpFracL], Disp[.+1];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">MNBR &larr; RZero, Return, DispTable[2];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*No shift<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; DB[fpFracH], GoTo[Unnorm1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Shift exactly 1 word<br><br>%For Alto Mesa, FloatTrap et al. store alpha in OTPReg, set T to<br>sFloatingPoint, and go to Kfcr which traps to MesaCode to try again<br>on this operation.  For Cedar Mesa, the parameter is 400 + alpha.<br><br>Arrive at OverUnderflow for exponents 401b to 777b with the exponent field<br>offset by -1.  Exponents of 0 or of 777b down to 577b represent underflow;<br>377b to 576b represent overflow.  Overflow always traps.<br><br>Gradual denormalization is not handled in microcode and traps.  A microcode<br>implementation should sensibly handle not only denormalized results but also<br>denormalized arguments.  For an underflowing result, microcode would first<br>right-shift the fraction one position because the implicit leading 1 isn&rsquo;t<br>there with a zero exponent.  Then it would right-shift the fraction while<br>counting the exponent up to zero.  Rounding would take place after shifting,<br>and the special case in which rounding normalizes the number would be dealt<br>with.  Unpacking would normalize the fraction while counting the exponent<br>to a negative value.<br>%<br>%-----<br>OverUnderflow:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpExpSign] - (137400C);</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Distinguish overflow and underflow<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (fpSticky) and (20000C), Skip[ALU&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  DblGoTo[Pack0,FloatTrap,ALU#0];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Underflow--check mode<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Overflow<br><br>Overflow:</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*For exponent .eq. 377b or 400b<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];<br><br>InexactTrap:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];<br>FixTrapA:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];<br>FixTrapB:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];<br>FixTrap:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];<br>NaNTrap:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];<br>InexactTrapA:<br>DenormTrap:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP, GoTo[FloatTrp1];<br>FloatTrap:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SStkP;</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Even placement; paired with mi at Pack0.<br>:IF[AltoMode]; ********************************************<br>FloatTrp1:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTemp &larr; T, Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">StkP &larr; fpTemp;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LoadPageExternal[opPage3];<br>fpTrapExit:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; sFloatingPoint, GoToExternal[kfcrLoc];<br>:ELSE; ****************************************************<br>FloatTrp1:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">TrapParm &larr; T, Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">TrapParm &larr; (StkP &larr; TrapParm) xor T;<br>fpTrapExit:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LoadPage[opPage0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">RTemp &larr; (RTemp) + (400C), GoToP[UndefTrap];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*400 + alpha<br>:ENDIF; ***************************************************<br>-----%<br>OverUnderflow:<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; (lspUFN) or (340c), goto[ufnLBL];<br></span><span style="font: 12pt serif">Overflow:</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*For exponent .eq. 377b or 400b<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; (lspUFN) or (340c), goto[ufnLBL];<br></span><span style="font: 12pt serif">NaNTrap:<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; (lspUFN) or (340c), goto[ufnLBL];<br></span><span style="font: 12pt serif">DenormTrap:<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; (lspUFN) or (340c), goto[ufnLBL];<br></span><span style="font: 12pt serif">FloatTrap:<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; (lspUFN) or (340c), goto[ufnLBL];<br></span><span style="font: 12pt serif"><br>%Addition and subtraction are almost the same.  <br> 1) Unpack the arguments, negate Arg2 if FSub, check for zeroes.<br> 2) Point DB at the argument with the smaller exponent, SB at the other, and<br>call Unnorm to right-shift the DB argument by the difference in the exponents.<br> 3) Add or subtract magnitudes, depending on the signs.<br> 5) Renormalize the result, round, and push it on the stack.<br><br>Get here after T &larr; fpFrac1H; SB selects arg1.<br><br>Timing @FAdd to Renorm: 24 + (2 if FSub) + (5 if Exp1 .ls. Exp2)<br>+ (7 if subtraction produces negative fraction)<br>+ (1 if Unnorm produces ones in MNBR).  Add Unnorm time to this.<br>For those cases which enter Renorm at NormGo, 4 cycles have been subtracted.<br>Subtraction can produce a negative result only when Exp1 .eq. Exp2;<br>Unnorm produces a sticky bit only for exponent differences larger than 7.<br><br>0 or 1 NormSteps will be performed after addition;<br>1 or 2 NormSteps will be performed after subtraction usually; but<br>up to 24d NormSteps might be performed if 0.5 &lt; arg1/arg2 &lt; 2.0.<br>%<br>@FSub:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign2 &larr; (fpExpSign2) xor (1C), At[UnpackRet,1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Complement sign<br>@FAdd:</span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (fpFrac2H) and T, At[UnpackRet,0];<br>*Simultaneously compute the exponent difference in bits 0:8 while XOR&rsquo;ing<br>*the signs in bit 15d and setting up a 3 in bits 10:11d for SB&larr; and DB&larr;.<br>*The "1" in "61C" here prevents sign subtraction from propagating higher.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr;  (fpExpSign2) - (61C), GoTo[Add0,ALU=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpExpSign1) - T, Call[FAddA];<br>*Return here after Unnorm.  Or the Sticky bit into DB[fpFracL] bit 15 and test<br>*cycle the (Sign1 xor Sign2) bit into the ALU sign for testing.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; MNBR;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; RCy[fpTemp,1], Skip[ALU=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; (RSh[AllOnes,17]) or T, DblGoTo[AddFrac,SubFrac,ALU&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">DblGoTo[AddFrac,SubFrac,ALU&lt;0];<br><br>*fpTemp &larr; [(Exp1-Exp2) lsh 7] + 61b + S1 - S2<br>FAddA:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTemp &larr; T, Skip[ALU&lt;0];<br>*Exp1 .ge. Exp2: Point SB at arg1 (it already does), DB at arg2.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  DB &larr; fpTemp, GoTo[Unnorm];<br>*Exp1 .ls. Exp2: Point SB at arg2, DB at arg1; negate the count.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; 157C;<br>*fpTemp &larr; [(Exp1-Exp2)&rsquo; lsh 7] + 41b + S1 - S2; SB &larr; 3.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTemp &larr; (SB &larr; fpTemp) xnor T;<br>*fpTemp &larr; [(Exp2-Exp1) lsh 7] + 21b + S1 - S2; DB &larr; 2.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTemp &larr; (DB &larr; fpTemp) + T + 1, GoTo[Unnorm];<br><br>*The signs are equal;  add the fractions.  DB[fpFracL] is in T.<br>AddFrac:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; SB[fpFracL] + T, Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; DB[fpFracH] + 1, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; SB[fpFracH] + T, GoTo[Renorm];<br><br>*The signs are different;  subtract the fractions.  DB[fpFracL] is in T.<br>SubFrac:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracL] &larr; SB[fpFracL] - T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; DB[fpFracH], FreezeResult;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpFracH] &larr; T &larr; (SB[fpFracH]) - T, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpFracL] or T, GoTo[SubNeg,ALU&lt;0];<br>SubNonNeg:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; SB[fpExpSign] - (200C), GoTo[LongNormGo,ALU#0];<br>*****</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&+1 &larr; 0C, GoTo[FlPush];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">goto[Pack0];<br><br>*Get here only when the exponents are equal and the DB fraction is larger<br>*than the SB fraction.  2 to 24d NormSteps will be performed.<br>SubNeg:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SB[fpFracL], Call[NegFrac1];<br>*Simultaneously complement the sign and subtract 1 from the exponent.<br>  </span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; SB[fpExpSign] - (177C), GoTo[LongNormGo];<br><br>%Multiply.<br> 1) Unpack arguments leaving normalized fractions in fpFracH[1:15],,fpFracL[0:8].<br> 2) Check for zero arguments.  GoTo Mul0 if either arg denormalized; since<br>Unpack has trapped for any non-0 denormalized arg, the "and" at @FMul is<br>always non-0 for both args non-0.<br> 3) Set sign and exponent of Frac1 to Exp1+Exp2-177b+1-1, where -177b<br>compensates for the excess in Exp1+Exp2, +1 for the NormStep normally<br>required, and -1 for the exponent offset in Renorm; altogether this is<br>Exp1+Exp2-177b.  Adding fpExpSign1 to fpExpSign2 also XOR&rsquo;s the sign bit<br>for the result.<br> 4) Shift fpFrac2 so non-0 bits are in fpFrac2H[8:15],,fpFrac2L[0:15];<br>then copy fpFrac2L into MNBR for the inner loops; fpFrac2L becomes<br>the low-order product word fpFrac1LL.<br> 5) Left-shift fpFrac1H/L 2 positions and add fpFrac2H to fpFrac1L; the<br>leading multiplier bit is known to be 1, so the inner loop is entered with<br>the multiplier lsh 1 in fpFrac1H/L/LL[0:25b] and the multiplicand in<br>fpFrac1H/L/LL[30:57b].<br> 6) Perform the shift and add loop 23d times, since the 1st of 24d steps was<br>done before starting the loop.  Initially, two 0 bits lie between the<br>low-order multiplier and high-order product bits.  Each step shifts the<br>multiplier and product in fpFrac1H/L/LL and conditionally adds the<br>multiplicand in fpFrac2H/MNBR.  Carries may make the 2nd of the two 0&rsquo;s<br>between the multiplier and product into a 1, but the 1st 0 will remain 0.<br> 7) Do 0 or 1 NormSteps at Renorm.<br><br>Timing @FMul to Renorm for non-0 args: (36 or 39) + 8*(10/zero or 19/one)<br>+ 15*(6/zero, [11 or 14]/one).  Total averages 293.75 cycles.<br>%<br>@FMul:</span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (fpFrac2H) and T, At[UnpackRet,2];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpExpSign2) - (37400C), GoTo[Mul0,ALU=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; (fpExpSign1) + T, LoadPage[fpPage4];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; RSh[fpFrac1L,16];<br>OnPage[fpPage4];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; (LSh[fpFrac1H,2]) or T, Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LSh[fpFrac2H,11];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1LL &larr; (RSh[fpFrac2L,7]) or T;</span><span class="tab" val="77"></span><span style="font: 12pt serif">*For that 1st multiplier 1<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; fpFrac2H &larr; RSh[fpFrac2H,7], Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; (LSh[fpFrac1L,2]) or T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpOne &larr; 1C;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (MNBR &larr; fpFrac2L) SALUFOP T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpFrac2H) SALUFOP T, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2HLSh1 &larr; T, LoadPage[fpPage2];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2HLSh1p1 &larr; (Zero) + T + 1;<br>OnPage[fpPage2];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpCount &larr; 6C, Call[FMNoA1];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Total of 5 + 3*fpCount iterations<br><br>%With this unrolled loop, the exterior step runs in 10 + 9/add cycles and<br>interior steps in 6 + (5 or 8)/add cycles; the interior step can be<br>replicated 0 to 4 times, trading space for speed.  Each replication costs<br>10d mi each (+5 mi for initializing the three registers needed).<br>fpCount and entry point have to be adjusted.  The 1st fast loop saves an<br>average of 2.625/cycles bit; the 2nd saves an additional .875 cycles/bit;<br>34d saves .4375 cycles/bit, etc.  I haven&rsquo;t found any way of making the<br>slow exterior loop look more like the fast one and still get in the<br>required tasking.<br>%<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpCount &larr; (fpCount) - 1, GoTo[MulDone,R&lt;0];<br><br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1LL &larr; (fpFrac1LL) SALUFOP T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; (fpFrac1L)  SALUFOP T, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; (fpFrac1H)  SALUFOP T, UseCOutAsCIn, GoTo[FMAd1,R&lt;0];<br><br>FMNoA1:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1LL &larr; (fpFrac1LL) SALUFOP T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; (fpFrac1L)  SALUFOP T, UseCOutAsCIn;<br>FMAdS2:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; (fpFrac1H) SALUFOP T, UseCOutAsCIn, GoTo[FMAd2,R&lt;0];<br><br>FMNoA2:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1LL &larr; (fpFrac1LL) SALUFOP T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; (fpFrac1L)  SALUFOP T, UseCOutAsCIn;<br>FMAdS3:</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Additional loop replications go here<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H  &larr; (fpFrac1H)  SALUFOP T, UseCOutAsCIn, DblGoTo[FMAd3,FMNoA3,R&lt;0];<br><br>FMAd1:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (MNBR) SALUFOP T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1LL &larr; (LSh[fpFrac1LL,1]) + T, Skip[R&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; (fpFrac2HLSh1) + 1, UseCOutAsCIn, Skip;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; (fpFrac2HLSh1p1) + 1, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; (LSh[fpFrac1L,1]) + T, GoTo[FMAdS2,R&gt;=0];<br>**Carry is impossible for the 1st 7 iterations of the loop.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpOne) + 1, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; (LSh[fpFrac1H,1]) + T, GoTo[FMNoA2,R&gt;=0];<br><br>FMAd2:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (MNBR) SALUFOP T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1LL &larr; (LSh[fpFrac1LL,1]) + T, Skip[R&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; (fpFrac2HLSh1) + 1, UseCOutAsCIn, Skip;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; (fpFrac2HLSh1p1) + 1, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; (LSh[fpFrac1L,1]) + T, GoTo[FMAdS3,R&gt;=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpOne) + 1, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; (LSh[fpFrac1H,1]) + T, GoTo[FMNoA3,R&gt;=0];<br><br>FMAd3:</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Additional loop replications go here<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; MNBR;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1LL &larr; (fpFrac1LL) + T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; fpFrac2H, FreezeResult;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; (fpFrac1L) + T, UseCOutAsCIn;<br>FMNoA3:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; (fpFrac1H) + 1, UseCOutAsCIn, Return;<br><br>*If fpFrac2L ne 0, set the fpFracL1[15d] to control rounding.<br>MulDone:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (fpFrac1LL) - 1, LoadPage[fpPage0];<br>*7 cycles from last task to Renorm.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; (fpExpSign1) - (200C), GoToP[Renorm,Carry&rsquo;];<br>OnPage[fpPage0];<br>*10 cycles from last task to Renorm.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; (fpFrac1L) or (1C), GoTo[Renorm];<br><br>%Division.  Arg1 is dividend, arg2 divisor; quotient in MNBR/fpTFrac.<br> 1) Unpack arguments.<br> 2) Trap if divisor is 0; else return 0 quotient if dividend is 0.<br> 3) Copy fpFrac1L into fpTFrac so that fpFrac1L can accumulate the quotient.<br> 4) Set sign and exponent of the result: Exp1-Exp2+177b-1 is the exponent<br>if the initial subtract succeeds, where 177b supplies the offset and -1<br>compensates for the +1 in Renorm; if the initial subtract fails, an<br>additional -1 compensates for the extra quotient bit generated. The<br>subtraction of the exponents also xor&rsquo;s the signs, but it is necessary to<br>offset fpExpSign1 by 2 to ensure that if arg1 is positive and arg2 negative,<br>the carry from subtracting the signs won&rsquo;t affect the exponent calculation.<br> 5) Compute the variations on fpFrac2H needed for the inner loop.<br> 6) Initialize fpFrac1L to 1.  On the 1st iteration, a 1 will be produced if<br>dividend fraction is larger than divisor fraction; if so, 25d iterations<br>produce a 24d bit result and an extra bit for rounding.  If the 1st iteration<br>produces a 0, a 26th iteration is required, and fpFrac1L is reinitialized to 1.<br>The 1st inner loop exit occurs when the leading 1 has migrated out of the<br>sign bit; the 16d bits in fpFrac1L are copied into MNBR, and fpFrac1L is<br>reinitialized to 200b; the inner loop is then repeated 9d more times.  After<br>the 2nd inner loop exit, 25d quotient bits are in MNBR/fpFrac1L; the remainder<br>serves as a sticky bit.  The 1st inner loop exit is distinguished from the<br>2nd by the sign of fpFrac1L.<br> 7) The shift and add-or-subtract loop is primed with an initial subtraction;<br>then each step combines shifting the dividend with adding or subtracting<br>the divisor according to the quotient bit produced by the previous step.<br> 8) Undo the last subtraction if the right-most result bit is a 1, so that the<br>remainder will correctly be 0 or non-0 for rounding.<br> 9) Copy MNBR into fpFrac1H and OR into fpFrac1L for rounding if remainder non-0.<br> 10) No normalization is required; round and push result.<br><br>Timing @FDiv to Renorm: (52 or 53) + 24*(10 to 12) + (12 or 13 if<br>dividend &lt; divisor) + (3 if 25th bit is 0) + (3 if final remainder .ne. 0).<br>%<br>@FDiv:</span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (fpFrac2H) and T, At[UnpackRet,3];<br>*Go if either arg denormalized, since denormalized implies 0 because Unpack<br>*will have trapped for any non-zero denormalized argument.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpFrac2H) xnor (0C), Skip[ALU#0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; fpExpSign2, GoTo[Div0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2H&rsquo; &larr; T, LoadPage[fpPage8];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2Hp1 &larr; (Zero) - T, GoToP[.+1];<br>OnPage[fpPage8];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac2H&rsquo;p1 &larr; (Zero) + T + 1;<br>*Have to open-code the first subtraction.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; fpFrac2L, LoadPage[fpPage1];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpFrac1L) - T;<br>OnPage[fpPage1];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTFrac &larr; T, FreezeResult, Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpFrac2H&rsquo;) + 1, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; (fpFrac1H) + T, Call[DivStart];<br>*Loop here 10 to 12 cycles<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; (LSh[fpFrac1H,1]) + T;<br>*Shift in quotient bit<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; (fpFrac1L) SALUFOP T, UseCOutAsCIn, GoTo[DivSub,Carry];<br>*Shift the remainder left 1 bit and add the divisor.<br>DivAdd:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; fpFrac2L, FreezeResult, GoTo[DivAddLast,Carry];<br>DivAdR:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTFrac &larr; (LSh[fpTFrac,1]) + T, Skip[R&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; (fpFrac2H) + 1, UseCOutAsCIn, Return;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpFrac2Hp1) + 1, UseCOutAsCIn, Return;<br><br>*Shift the remainder left 1 bit and subtract the divisor.<br>DivSub:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; fpFrac2L, FreezeResult, GoTo[DivSubLast,Carry];<br>DivSbR:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTFrac &larr; (LSh[fpTFrac,1]) - T, Skip[R&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; (fpFrac2H&rsquo;) + 1, UseCOutAsCIn, Return;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpFrac2H&rsquo;p1) + 1, UseCOutAsCIn, Return;<br><br>*Initialize fpFrac1L so the sign will become 1 on the final iteration;<br>*a 1 will then be shifted into the sign for a normalized result.<br>DivStart:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; fpExpSign2 &larr; (fpExpSign2) - (37400C), GoTo[DivExtraStep,Carry&rsquo;];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpExpSign1 &larr; (fpExpSign1) - T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpFrac1L &larr; 3C, GoTo[DivSub];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Initial subtract succeeded<br>*Initial subtract failed--extra iteration and exponent is one smaller.<br>DivExtraStep:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpExpSign2) + (200C);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; (fpExpSign1) - T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; 1C, GoTo[DivAdd];<br><br>*Get to DivAddLast or DivSubLast once after the result bits for the<br>*high quotient word are accumulated and again after the final iteration.<br>DivAddLast:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; (fpExpSign1) + 1, DblGoTo[FDivX,.+2,ALU&gt;=0];<br>DivSubLast:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; (fpExpSign1) + 1, GoTo[FDivX,ALU&gt;=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  MNBR &larr; fpFrac1L, Skip[R Odd];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">    fpFrac1L &larr; 200C, GoTo[DivAdR];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpFrac1L &larr; 200C, GoTo[DivSbR];<br>*Really done; position the fraction for normalization and rounding.<br>FDivX:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; LSh[fpFrac1L,7], Skip[R Even];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; fpFrac1H, LoadPage[fpPage0], GoTo[DivMore1];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTFrac &larr; (fpTFrac) + T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpFrac2H) + 1, UseCOutAsCIn;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (fpFrac1H) + T, LoadPage[fpPage0];<br>DivMore1:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (fpTFrac) or T;<br>OnPage[fpPage0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; MNBR, Skip[ALU=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpFrac1L &larr; (fpFrac1L) or (1C);<br>*20 to 27 cycles from last task to Renorm.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; T, GoTo[Renorm];<br><br><br>%Floating scale.  2OS,,3OS are a floating point number whose exponent is<br>scaled by TOS, an integer such that -202b &lt;= TOS &lt;= 200b.<br>(Larger values reverse overflow and underflow reporting, so overflow could<br>substitute 0 rather than trapping in some cases.).  The opcode specification<br>is for -200b &lt;= TOS &lt;= 177b.<br><br>**Could speed this up by ignoring the Unpack results and manually checking for<br>overflow and underflow (i.e., for 1 &lt;= Exp &lt;= 376b); if all is ok, then<br>directly add fpFrac1H to the exponent in 2OS.<br>%<br>%-----<br>OnPage[fpPage0];<br><br>FSc1:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LSh[fpFrac1H,7], Skip[ALU#0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; Stack&+1 &larr; 0C, GoTo[PackA];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign2 &larr; (fpExpSign2) + T, GoTo[NormGo];<br>-----%<br><br>*ZERO ARGUMENTS.<br><br>%FAdd/FSub:  Get to Add0 knowing that (fpFrac1H) and (fpFrac2H) .eq. 0; since both<br>args were either normalized or zero if passed by Unpack, passed by one/both<br>fractions must be zero.  If just one is 0, return the other.  If both are 0,<br>return 0 (negative 0 if both args are negative 0).  SB points at arg1.<br>%<br><br>OnPage[fpPage0];<br><br>Add0:</span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; fpFrac1H;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; fpFrac2H, Skip[ALU=0];<br>***</span><span class="tab" val="77"></span><span style="font: 12pt serif">  Stack&+2, GoTo[NormReturn];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*fpFrac1H .ne. 0, so fpFrac2H .eq. 0<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpTemp &larr; 40c, goto[SetSB0];<br><br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; fpExpSign2, Skip[ALU#0];<br>*fpFrac1H and fpFrac2H both 0.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpExpSign1 &larr; (fpExpSign1) and T, GoTo[Pack0];<br><br>*The following would work except that on FSub the sign must be complemented:<br>*</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+3;<br>*</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&-2 &larr; Stack&-2;<br>*</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+3;<br>*</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&-2 &larr; Stack&-2, GoTo[NormReturn];<br><br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTemp &larr; 60C;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*fpFrac2H .ne. 0<br>SetSB0:</span><span class="tab" val="77"></span><span style="font: 12pt serif">SB &larr; fpTemp;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">BBFBX, GoTo[Renorm];<br><br>%Divide.  Trap if divisor (fpFrac2) is 0; else dividend (Frac1) is 0, so return<br>0 with sign the xor of the dividend and divisor signs.<br>Since Unpack has already trapped for all denormalized args except zeroes,<br>the checks for 0 look at fpFracH bit 1.  T contains fpExpSign2.<br><br>Multiply.  Return 0 with sign equal to the xor of the multiplier and<br>multiplicand signs.  T contains fpExpSign2 - 40000b.<br>%<br>Div0:</span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (fpFrac2H) and (40000C);<br>Mul0:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; (fpExpSign1) xor T, GoTo[FloatTrap,ALU=0];<br>********Pack0:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&+1 &larr; 0C, GoTo[PackA];<br>:IF[PackInLine];<br>Pack0:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; </span><span style="font: 10pt serif">Result1</span><span style="font: 12pt serif">Lo &larr; 0C, GoTo[PackA];<br>:ELSE;<br>Pack0:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+1 &larr; (smallpl);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+2;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&+1 &larr; 0C, GoTo[PackA];<br>:ENDIF;<br><br>%Floating Comparison returns INTEGER -1 if arg1 .ls. arg2,<br>0 if arg1 .eq. arg2, or 1 if arg1 .gr. arg2.<br><br>Timing @FComp to completion: 15 or 16 cycles if .eq., 27 to 30 cycles if .ne.<br><br>**Unpacking apparently serves only to eliminate not-a-numbers and denormalized<br>**numbers from testing.<br>%<br>:IF[0]; **********<br>@FComp:</span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LSh[fpExpSign1,17], Task, At[UnpackRet,4];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+3;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (LSh[fpExpSign2,17]) xor T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&-2, GoTo[CompDiffSign,ALU&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (Stack&+3) - T;</span><span class="tab" val="77"></span><span style="font: 12pt serif">*LU &larr; arg1Lo - arg2Lo<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&-2, FreezeResult;<br>*T &larr; arg1Hi - arg2Hi<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; (Stack&-1) - T, UseCOutAsCIn, GoTo[CompNon0Test,ALU#0];<br>Comp0Test:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack &larr; T, FreezeResult, GoTo[NormReturn,ALU=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign2 &larr; (fpExpSign2) + 1, DblGoTo[.+3,.+2,Carry&rsquo;];<br>CompNon0Test:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign2 &larr; (fpExpSign2) + 1, Skip[Carry&rsquo;];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpExpSign1, DblGoTo[CompL,CompG,R Odd];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpExpSign2, DblGoTo[CompL,CompG,R Odd];<br><br>CompG:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack &larr; 1C, GoTo[NormReturn];<br>CompL:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack &larr; (Zero) - 1, GoTo[NormReturn];<br><br>NormReturn:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; NextInst[IBuf];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">NIRet;<br><br>*If the signs differ, it is nevertheless possible that both fractions are 0<br>*(positive and negative 0).  When the signs differ, we don&rsquo;t care which way<br>*the Carry branch condition goes at Comp0Test+1 (???).<br>CompDiffSign:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; fpFrac1H;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; (fpFrac2H) or T, GoTo[Comp0Test];<br>:ENDIF; **********<br><br>* Lisp version: FGreaterp.  No negative zero to worry about; only 2 outcomes<br>* True if arg1 &gt; arg2, i.e. arg2-arg1 does not carry (arg2&gt;0) etc.<br>* We could use more of the Igreaterp code here if regs were same<br><br>@FComp:</span><span class="tab" val="77"></span><span style="font: 10pt serif">Stack&+1 &larr; 0c</span><span style="font: 12pt serif">, Task, At[UnpackRet,4];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* prepare T or NIL<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; LSh[fpExpSign1,17];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">lu &larr; (LSh[fpExpSign2,17]) xor T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; </span><span style="font: 10pt serif">qBuf3, loadpage[pgArith]</span><span style="font: 12pt serif">, Skip[alu&gt;=0];</span><span class="tab" val="77"></span><span style="font: 12pt serif">* arg1Lo<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpExpSign1, dblgotop[Igt, Ilt, R Even];<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">* signs differ, so arg1&gt;arg2 if arg1 positive<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">lu &larr; (qBuf1) - T, gotop[.+1];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">* arg2Lo - arg1Lo</span><span style="font: 10pt serif"><br>onpage[pgArith];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">T &larr; qBuf2, FreezeResult;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 10pt serif">* arg1Hi<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lu &larr; (qBuf) - T, UseCOutAsCIn, goto[CompNonZero, alu#0];</span><span style="font: 12pt serif"><br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 10pt serif">* arg2Hi - arg1Hi<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 10pt serif">* Subtract may come out equal, in which case<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 10pt serif">* result is always false, so check for this.<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">FreezeResult, Skip[alu#0];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">  Stack&+1 &larr; 0c, goto[ArithExit];</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 10pt serif">* args equal, so false<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">fpExpSign1 &larr; (fpExpSign1) + 1, dblgoto[.+3, .+2, Carry];<br>CompNonZero:<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 10pt serif">* Signs are same, and we have just compared arg2-arg1<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 10pt serif">* as unsigned integers.  If numbers are positive,<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 10pt serif">* then Carry=&gt; false; else Carry=&gt; true.<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">fpExpSign1 &larr; (fpExpSign1) + 1, Skip[Carry];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">  fpExpSign2, dblgoto[Igt, Ilt, R Even];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">  fpExpSign1, dblgoto[Igt, Ilt, R Even];<br></span><span style="font: 12pt serif"><br>%Float LONG INTEGER to REAL<br> 1) Copy the argument into Frac1<br> 2) Check sign, and negate Frac1 if negative.<br> 3) Avoid 16d of NormSteps if 1st word is 0; special case entirely 0.<br> 4) Set exponent and Renormalize.<br><br>Timing Float to Renorm: 21 cycles if positive, 28 if negative; +4 if<br>1st word insignificant.<br>%<br>:IF[0]; **********<br><br>Float:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; 40C, Task;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB &larr; fpFrac1H, fpFrac1H &larr; T, NoRegILockOK;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; T, BBFBX;</span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">*Start building sign<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&-1, Call[FloatA];<br>*Have fpFrac1L in T from either FloatA or NegFrac.<br>FloatB:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; (fpExpSign1) - (200C);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU&larr; fpFrac1H;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; (fpExpSign1) + (43400C), Skip[ALU=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  fpExpSign1 &larr; (fpExpSign1) + (4000C), GoTo[LongRenorm];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1H &larr; T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; 0C, Skip[ALU=0];<br>LongRenorm:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">  T &larr; LSh[SB[fpFracH],10], DblGoTo[Pack,NormStep,R&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; Stack&+1 &larr; 0C, GoTo[FlPush];<br><br>FloatA:</span><span class="tab" val="77"></span><span style="font: 12pt serif">fpFrac1L &larr; T;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpExpSign1 &larr; RSh[fpExpSign1,17], DblGoTo[NegFrac,FloatB,R&lt;0];<br>:ENDIF; **********<br><br>%Fix or Round REAL to LONG INTEGER, INTEGER, or CARDINAL.<br> 1) Unpack the argument.<br> 2) Unnormalize Frac1 so that the decimal point is positioned to the right of<br>fpFrac1L bit 15d.<br> 3) Round, if appropriate (controlled by fpCode)<br> 4) Negate the fraction if sign is negative.<br> 5) Several things depending on the result type</span><span class="tab" val="77"></span><span style="font: 12pt serif">(controlled by fpCode)<br>LONG INTEGER:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Push double-precision result.<br>INTEGER:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Trap if positive or negative number is larger than 15d bits,<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">else push single-precision result.<br>CARDINAL:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Trap if fraction word 0 is non-zero, else push<br></span><span class="tab" val="77"></span><span class="tab" val="77"></span><span style="font: 12pt serif">single-precision result.<br><br>Timing from @Fix to exit (not including Unnorm):<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Fix</span><span class="tab" val="77"></span><span style="font: 12pt serif">21 if 0, 23 if .gr. 0, 29 if .ls 0;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">FixC</span><span class="tab" val="77"></span><span style="font: 12pt serif">19 if 0, 21 if .gr. 0, 27 if .ls 0;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">FixI</span><span class="tab" val="77"></span><span style="font: 12pt serif">24 if 0, 26 if .gr. 0, 33 if .ls. 0;<br>Add 2 + RoundCard time for the analogous Round operations.<br>%<br>:IF[0]; **********<br><br>*Computation is 236b - Exp1 (the low order +1 prevents sign subtraction<br>*from propagating into the exponent field and inverts the branch condition).<br>*GoTo FixTrap if exponent .gr. 235b; in this case the number is .ge. 2&uarr;31d<br>*(31d bits holds all numbers .ls. 2&uarr;31.<br>FixRA:</span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; T &larr; SB[fpExpSign] - (200C);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpFracH], GoTo[FixTrap,ALU&gt;=0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">fpTemp &larr; (Zero) - T, GoTo[Unnorm,ALU#0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SB[fpFracL], GoTo[FrPos];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Fraction is 0<br><br><br>@Fix:</span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; SB[fpExpSign] - (47000C) - 1, Call[FixRA], At[UnpackRet,6];<br>*SB[fpFracL] is in T here.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign], DblGoTo[FRPos,FRNeg,R Odd];<br><br>@Round:</span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign] &larr; SB[fpExpSign] - (47000C) - 1, Call[FixRA], At[UnpackRet,10];<br>*SB[fpFracL] is in T here.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; MNBR, Call[RoundCard];<br>*SB[fpFracL] is still in T.<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign], Skip[R Odd];<br>FRNeg:</span><span class="tab" val="77"></span><span style="font: 12pt serif">  LU &larr; T, Call[NegFrac1];<br>FRPos:</span><span class="tab" val="77"></span><span style="font: 12pt serif">Dispatch[fpCode,12,2];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpFracH], Disp[.+1];<br><br></span><span class="tab" val="77"></span><span style="font: 12pt serif">GoTo[FixTrapA,ALU#0], At[FixDisp,2];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Cardinal<br>FlPush:</span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; NextInst[IBuf];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+1 &larr; T, NIRet;<br><br></span><span class="tab" val="77"></span><span style="font: 12pt serif">SB[fpExpSign], FreezeResult, GoTo[.+3,R Even], At[FixDisp,1];*Integer<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; T, GoTo[FixTrapB,ALU#0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">DblGoTo[FixTrapA,FlPush,ALU&lt;0];<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; SB[fpFracH] xnor (0C);<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">LU &larr; (LSh[AllOnes,17]) xor T, DblGoTo[FixTrapB,.-2,ALU#0];<br><br></span><span class="tab" val="77"></span><span style="font: 12pt serif">Stack&+1 &larr; T, At[FixDisp,0];</span><span class="tab" val="77"></span><span style="font: 12pt serif">*Long integer<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; SB[fpFracH], GoTo[FlPush];<br><br><br>%FSticky reads and sets the InexactResultTrapEnable and InexactResult Bit.<br>It swaps Stack and fpSticky.<br>%<br>FSticky:<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">MNBR &larr; fpSticky, fpSticky &larr; T, NoRegILockOK;<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">T &larr; MNBR, GoTo[FlPush];<br>:ENDIF; **********<br><br>END[</span><span style="font: 10pt serif">Float.0mc</span><span style="font: 12pt serif">];<br><br>:ELSE; ************************************************<br></span><span class="tab" val="77"></span><span style="font: 12pt serif">TITLE[No.floating.point.microcode];<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; 350c, goto[lspUfnxP7], opcode[350];</span><span class="tab" val="77"></span><span style="font: 10pt serif">* Fplus<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; 351c, goto[lspUfnxP7], opcode[351];</span><span class="tab" val="77"></span><span style="font: 10pt serif">* Fdifference<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; 352c, goto[lspUfnxP7], opcode[352];</span><span class="tab" val="77"></span><span style="font: 10pt serif">* Ftimes<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; 353c, goto[lspUfnxP7], opcode[353];</span><span class="tab" val="77"></span><span style="font: 10pt serif">* Fquotient<br></span><span class="tab" val="77"></span><span style="font: 10pt serif">lspUFN &larr; 362c, goto[lspUfnxP7], opcode[362];</span><span class="tab" val="77"></span><span style="font: 10pt serif">* FGreaterp<br></span><span style="font: 12pt serif">:ENDIF; ***********************************************<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
