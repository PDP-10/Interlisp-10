<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>INTERMEZZO>SOURCES>LispDMC.DM!2>LVARCONST.mc</title>
  </head>
  <body>
    <div style="width: 979pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">:Title[LVARCONST];<br>*<br>* Edit History<br>* January 8, 1985  4:12 AM, JonL, GVAR&larr; and endofstack typos in constants<br>* January 6, 1985  2:50 AM, JonL, emmend GVAR, GVAR&larr; and the global case of<br>*    </span><span class="tab" val="24"></span><span style="font: 10pt monospace"> FVAR lookup to permit 16-bit litatom indices<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">February 18, 1984  3:14 PM, JonL, labels PUSHSMALLT1 & PUSHTRUE1 for opRWMufMan<br>* January 31, 1984  1:30 AM, JonL, Added subroutine .aconstfetch<br>* January 13, 1984  9:05 PM, JonL, linst and lfv merged into this file<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PUSHTMD and TL.ST0TMD in from LSTACK<br>* December 30, 1983  3:33 PM, JonL, merged two insts in call to GCLOOKUP<br>* December 27, 1983  11:28 AM, JonL, opCOPY to LSTACK<br>* December 6, 1982  1:43 PM, Masinter<br><br>* Variable opcodes, including free variable lookup<br>*  and Constants opcodes<br><br>   knowrbase[LTEMP0];<br>   TOP LEVEL;<br>   InsSet[LispInsSet, 1];<br></span><span style="font: 10pt monospace"><br><br>*--------------------------------------------------------------------<br>* Some common tails for this file<br>*--------------------------------------------------------------------<br><br>*--------------------------------------------------------------------<br>PUSHTMD: </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* pushes  T,,MD, bumps TSP, and decrements LEFT</span><span style="font: 10pt monospace"><br></span><span style="font: 10pt monospace">*--------------------------------------------------------------------<br></span><span style="font: 10pt monospace">PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br></span><span style="font: 10pt monospace">:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T and not (77c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[</span><span style="font: 10pt monospace">badpushval</span><span style="font: 10pt monospace">];<br>:endif;<br></span><span style="font: 10pt monospace">   T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, branch[TL.PUSHT];<br><br></span><span style="font: 10pt monospace">*--------------------------------------------------------------------<br>TL.ST0TMD:<br>   T&larr; Md, LTEMP0&larr; (store&larr; LTEMP0) + 1, dbuf&larr; T, branch[TL.ST0];<br>*--------------------------------------------------------------------<br>TL.ST0:<br>   store&larr; LTEMP0, dbuf&larr; T, NextOpCode;<br>*--------------------------------------------------------------------<br><br><br>*--------------------------------------------------------------------<br>opIVAR:<br>*--------------------------------------------------------------------<br>   T&larr; (ifetch&larr; IVAR) + 1;<br>   T&larr; Md, ifetch&larr; T, branch[PUSHTMD];<br><br>regOP1[100, StackBR, opIVAR, 0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* IVAR<br>regOP1[101, StackBR, opIVAR, 2];<br>regOP1[102, StackBR, opIVAR, 4];<br>regOP1[103, StackBR, opIVAR, 6];<br>regOP1[104, StackBR, opIVAR, 10];<br>regOP1[105, StackBR, opIVAR, 12];<br>regOP1[106, StackBR, opIVAR, 14];<br>regOP2[107, StackBR, opIVAR, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PVARX<br><br>*--------------------------------------------------------------------<br>opPVAR:<br>*--------------------------------------------------------------------<br>   T&larr; (ifetch&larr; PVAR) + 1;<br>   T&larr; Md, ifetch&larr; T, branch[PUSHTMD];<br><br>regOP1[110, StackBR, opPVAR, 0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PVAR<br>regOP1[111, StackBR, opPVAR, 2];<br>regOP1[112, StackBR, opPVAR, 4];<br>regOP1[113, StackBR, opPVAR, 6];<br>regOP1[114, StackBR, opPVAR, 10];<br>regOP1[115, StackBR, opPVAR, 12];<br>regOP1[116, StackBR, opPVAR, 14];<br>regOP2[117, StackBR, opPVAR, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PVARX<br><br><br><br>*--------------------------------------------------------------------<br>opFVAR:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (ifetch&larr; PVAR) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, ifetch&larr; T;<br>.retryfvar:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R even], LTEMP0, T&larr; Md, memBase&larr; ScratchLZBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Id, branch[.FVFAIL];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* KLUDGE: LH IS DUPLICATED!!!!<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BRHi&larr; T;<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (FETCH&larr; LTEMP0) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; MD, fetch&larr; LTEMP0, branch[PUSHTMD];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>.FVFAIL:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>* T = offset of free variable, fill in and continue<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; T, call[FVLOOKUP];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T passed and smashed by FVLOOKUP<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + (PVAR);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, fetch&larr; T, branch[.retryfvar];<br><br>regOP1[120, StackBR, opFVAR, 0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* FVAR<br>regOP1[121, StackBR, opFVAR, 2];<br>regOP1[122, StackBR, opFVAR, 4];<br>regOP1[123, StackBR, opFVAR, 6];<br>regOP1[124, StackBR, opFVAR, 10];<br>regOP1[125, StackBR, opFVAR, 12];<br>regOP1[126, StackBR, opFVAR, 14];<br><br>regOP2[127, StackBR, opFVAR, noNData];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* FVARX<br><br>*--------------------------------------------------------------------<br>opGVAR:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* alpha + beta form atom number of global to fetch<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Id;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* hi bits<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[T,10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* shift left<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; ((Id) + T);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu&gt;=0], LTEMP0 &larr; (LTEMP0) lsh 1;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">flipMemBase; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* use Val2BR instead<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (FETCH&larr; LTEMP0) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; MD, fetch&larr; LTEMP0, branch[PUSHTMD];<br><br>regOP3[140, ValSpaceBR, opGVAR, noNData];<br><br><br>*--------------------------------------------------------------------<br>opSETPVAR:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (Id) + (PVAR), branch[TL.ST0TMD];<br><br>regOP1[130, StackM2BR, opSETPVAR, 0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PVAR&larr;<br>regOP1[131, StackM2BR, opSETPVAR, 2];<br>regOP1[132, StackM2BR, opSETPVAR, 4];<br>regOP1[133, StackM2BR, opSETPVAR, 6];<br>regOP1[134, StackM2BR, opSETPVAR, 10];<br>regOP1[135, StackM2BR, opSETPVAR, 12];<br>regOP1[136, StackM2BR, opSETPVAR, 14];<br><br>regOP2[137, StackM2BR, opSETPVAR, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* PVARX&larr;<br><br>*--------------------------------------------------------------------<br>opSETPVARPOP:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch TSP-2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, TSP&larr; (fetch&larr; T) - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch TSP-1, TSP&larr; TSP-2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (Id) + (PVAR);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; (LEFT) + 1, BRANCH[TL.ST0TMD];<br><br>regOP1[270, StackM2BR, opSETPVARPOP, 0];<br>regOP1[271, StackM2BR, opSETPVARPOP, 2];<br>regOP1[272, StackM2BR, opSETPVARPOP, 4];<br>regOP1[273, StackM2BR, opSETPVARPOP, 6];<br>regOP1[274, StackM2BR, opSETPVARPOP, 10];<br>regOP1[275, StackM2BR, opSETPVARPOP, 12];<br>regOP1[276, StackM2BR, opSETPVARPOP, 14];<br><br>*--------------------------------------------------------------------<br>opSETIVAR:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (Id) + (IVAR), branch[TL.ST0TMD];<br><br>regOP2[142, StackM2BR, opSETIVAR, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* IVARX&larr;<br><br><br><br>*--------------------------------------------------------------------<br>opFVARgets: <br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (ifetch&larr; PVAR) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, ifetch&larr; T;<br>.retrysetfvar:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R even], LTEMP0, T&larr; Md, memBase&larr; StackM2BR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Id, branch[.setffail];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Fvar not looked up  yet<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* KLUDGE</span><span class="tab" val="24"></span><span style="font: 10pt monospace">- TOP BYTE IS FILLED IN TOO<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T xor (StackHi);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.setfglobal, alu#0], TSP&larr; (fetch&larr; TSP) - 1, flipMemBase;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, TSP&larr; (fetch&larr; TSP) + 1, branch[TL.ST0TMD];<br>:if[Reduced];<br>.setfglobal:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + 1, memBase&larr; StackBR, Call[SUB.PUSHT];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0, Call[SUB.PUSHT];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; AT.SETFVAR, Goto[2ARGPUNT];<br>2ARGPUNT:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; T, T&larr; Link, Call[SAVEUCODESTATE];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; 2c, Branch[DOCALLPUNT];<br>:else;<br>.setfglobal:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) + 1, memBase&larr; LScratchBR, Branch[.setglobal];<br>:endif;<br>   <br>.setffail:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; T, call[FVLOOKUP];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + (PVAR);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, fetch&larr; T, branch[.retrysetfvar];<br><br>regOP2[143, StackBR, opFVARgets, noNData];<br><br>*--------------------------------------------------------------------<br></span><span style="font: 10pt monospace">SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">SUB.PUSHT:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, return;<br></span><span style="font: 10pt monospace">TOP LEVEL;<br></span><span style="font: 10pt monospace"><br><br>*--------------------------------------------------------------------<br>*   GVAR&larr;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> alpha + beta form atom number of global to store TOS<br>*--------------------------------------------------------------------<br><br>:if[Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[27];<br>:else;<br><br>opGVARgets:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Id, memBase&larr; LScratchBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; LSH[LTEMP0, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; ((Id) + (LTEMP0));<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu&gt;=0], LTEMP0 &larr; (LTEMP0) lsh 1;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (add[VALspace!,1]c), branch[.setglobal]; </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* use Val2BR instead<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; VALspace, branch[.setglobal];<br><br>.setglobal:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrLo&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrHi&larr; T, LTEMP4&larr; A0;<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Case&larr; T&larr; (FETCH&larr; 0s) + 1, Call[GCLOOKUP];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* deleteref old pointer<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackM2BR, Branch[RPLPTRTAIL];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* addref for new pointer<br><br>regOP3[27, ifuBR, opGVARgets, noNData];<br>:endif;<br><br><br>*--------------------------------------------------------------------<br>opNIL:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (AtomHiVal), Branch[TL.PUSHNIL];<br>TL.PUSHNIL:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (AT.NIL), NextOpCode;</span></div>
<div style="width: 979pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace"><br>regOP1[150, StackBR, opNIL, noNData];<br><br>*--------------------------------------------------------------------<br>opKT:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br>PUSHTRUE1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (AtomHiVal), branch[TL.PUSHTRUE];<br>TL.PUSHTRUE:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; AT.T, NextOpCode;<br><br>regOP1[151, StackBR, opKT, noNData];<br><br>*--------------------------------------------------------------------<br>op01SIC:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, TisID, NextOpCode;<br><br>regOP1[152, StackBR, op01SIC, 0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* &rsquo;0<br>regOP1[153, StackBR, op01SIC, 1];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* &rsquo;1<br>regOP2[154, StackBR, op01SIC, noNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* SIC<br><br>*--------------------------------------------------------------------<br>opSNIC:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Id) - (400c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallNegHi, branch[TL.PUSHT];<br><br>regOP2[155, StackBR, opSNIC, noNData];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* SNIC<br><br>*--------------------------------------------------------------------<br>opSICX:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Id, Call[.aconstfetch];<br>PUSHSMALLT:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], </span><span style="font: 10pt monospace">LEFT</span><span style="font: 10pt monospace">&larr; (</span><span style="font: 10pt monospace">LEFT</span><span style="font: 10pt monospace">) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br>PUSHSMALLT1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[TL.PUSHT];<br>TL.PUSHT:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, NextOpCode;</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace"><br><br>regOP3[156, StackBR, opSICX, noNData];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* SICX<br>regOP3[160, StackBR, opSICX, noNData];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* ATOMNUMBER<br>*--------------------------------------------------------------------<br>opACONST: <br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Id, Call[.aconstfetch];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (AtomHiVal), branch[TL.PUSHT];<br><br>SUBROUTINE;<br>.aconstfetch:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[T,10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Id) + (T), Return;<br>TOPLEVEL;<br><br>regOP3[147, StackBR, opACONST, noNData];<br><br>*--------------------------------------------------------------------<br>opGCONST:<br>*--------------------------------------------------------------------<br>* push 24 bit inline constant<br>* coded as a one byte jump opcode which jumps to .+4<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; not (PCX&rsquo;);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* current pc<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (LTEMP0) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* byte# of hi byte<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP0) rsh 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* word# of hi byte<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FETCH&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch it & next word<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R even], LTEMP0, T&larr; MD, FETCH&larr; T;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and (rhmask), branch[PUSHTMD];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; MD;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* rh T,,lh Md has low word, lh T has hi word.<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; rcy[T, LTEMP0, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; rsh[T, 10];<br>PUSHT0:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* pushes  T,,LTEMP0, bumps TSP, and decrements LEFT<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], LEFT&larr; (</span><span style="font: 10pt monospace">LEFT</span><span style="font: 10pt monospace">) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T and not (77c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[</span><span style="font: 10pt monospace">badpushval</span><span style="font: 10pt monospace">];<br>:endif;<br></span><span style="font: 10pt monospace">PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0, NextOpCode;<br><br><br>IFUjmp[157, 1, ifuBR, 0, opGCONST, 4];<br><br><br>:if[Reduced];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[57];<br>:else;<br><br>*--------------------------------------------------------------------<br>opSTKSCAN:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FVNAME&larr; Md, fetch&larr; T, T&larr; (FX.PVAR);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FVNAME&larr; Md, pd&larr; FVNAME;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], pd&larr; FVNAME;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* not LITATOM<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* NIL<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">nop;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* placement constraints<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FVEP&larr; (PVAR) - T, call[DOLOOKUP];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackM2BR, T&larr; TSP;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; FVHI;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; FVLO, NextOpCode;<br><br>REGOP1[57, StackM2BR, opSTKSCAN, noNData];<br><br>:endif;<br><br>*--------------------------------------------------------------------<br>SUBROUTINE;  FVLOOKUP:<br>*--------------------------------------------------------------------<br><br><br>* look up free variable # T/2 in current frame<br>* fill in location where value is bound<br>* preserve LTEMP0<br><br>   memBase&larr; ifuBR;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PAGEFAULTOK;<br><br>   FETCH&larr; add[FNH.NLFV!]s;<br>   FVNAME&larr; T rsh 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* free variable index<br>   FVCHAIN&larr; (PVAR) + T + 1;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* where to fill in the indirection<br>   FVTMP&larr; MD;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* nlocals, fvoffset<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PAGEFAULTNOTOK;<br><br>   T&larr; rsh[FVTMP, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; NLOCALS<br>   FVTMP&larr; (FVTMP) and (rhmask);<br>   T&larr; (FVTMP) - T;<br>   T&larr; T + (FVNAME);<br>   fetch&larr; T;<br>   FVNAME&larr; Md, T&larr; (FX.PVAR);<br>   FVEP&larr; (PVAR) - T;<br>   memBase&larr; StackBR;<br>   store&larr; FVCHAIN, dbuf&larr; 0c, branch[.newframe];<br><br>*--------------------------------------------------------------------<br>DOLOOKUP:<br>*--------------------------------------------------------------------<br>* Scan for free variable FVNAME starting at FVEP, return<br>* in FVHI,FVLO the pointer to where it is bound<br>* if FVCHAIN is odd, store indirection pointer at stackspace<br>* should check for reschedule!!!<br><br>   FVCHAIN&larr; A0;<br><br>.newframe:<br>   T&larr; (FVEP) + 1, memBase&larr; StackBR;<br>   fetch&larr; T;<br>   FVEP&larr; Md;<br>   FVEP&larr; (FVEP) and not (1c);<br>   FVEP&larr; (FVEP) - (FX.PVAR);<br>   branch[.endofstack, alu=0], fetch&larr; FVEP;<br>   FVTMP&larr; Md;<br>   pd&larr; (FVTMP) and (FXNTValid);<br>   T&larr; (FVEP) + (FX.DEFLO), branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FVEP) + (FX.NTLO);<br>   T&larr; (fetch&larr; T) + 1;<br>   FVTMP&larr; Md, fetch&larr; T, T&larr; (rhmask);<br>   T&larr; T and (Md), memBase&larr; LScratchBR;<br>   BrHi&larr; T;<br>   BrLo&larr; FVTMP;<br>   FVINDEX&larr; FNH.FIRSTNAME;<br><br>.lookforvar:<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PAGEFAULTOK;<br><br>   FETCH&larr; add[FNH.NTSIZE!]s;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* can fault<br>   FVTMP&larr; Cnt&larr; MD;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* FVTMP = NTSIZE<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PAGEFAULTNOTOK;<br><br>.fvloop:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* this can really be done in a 2 inst loop<br>   branch[.newframe, Cnt=0&-1];<br>   FVINDEX&larr; (fetch&larr; FVINDEX) + 1;<br>   T&larr; Md;<br>   pd&larr; (FVNAME) xor T;<br>   branch[.fvloop, alu#0];<br><br>% this is what a 2 instruction loop would look like<br>   T&larr; A0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* # FVNAME<br>   branch[.+2, Cnt#0], pd&larr; T-T-1;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* pd #0<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.newframe];<br>   FVINDEX&larr; (fetch&larr; FVINDEX) + 1, branch[.fvfound, alu=0];<br>   T&larr; Md, pd&larr; (FVNAME) xor T, dblbranch[.notfound, .-1, Cnt=0&-1]<br>.fvfound:<br>   FVINDEX&larr; (FVINDEX) - (2c);<br>%<br><br>.fvfound:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* found a match<br>   T&larr; (FVTMP) - 1;   <br>   T&larr; T + (FVINDEX);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* add NTSIZE, note FVINDEX already incremented<br>   fetch&larr; T;<br>   FVHI&larr; Md, T&larr; (rhmask);<br>   T&larr; (T and (FVHI)) lsh 1, branch[.fvpfvar, R&lt;0];<br><br>.fvivar:<br>   FVEP&larr; (FVEP) - 1, memBase&larr; StackBR;<br>   FVEP&larr; (fetch&larr; FVEP) + 1;<br>   FVLO&larr; T + Md;<br>   FVHI&larr; StackHi, branch[.donefvlookup];<br><br>.fvpfvar:<br>   T&larr; T + (FVEP), memBase&larr; StackBR;<br>   T&larr; T + (FX.PVAR);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T is stack relative location<br>   T&larr; (fetch&larr; T) + 1;<br>   FVLO&larr; Md, fetch&larr; T;<br>   FVHI&larr; Md, pd&larr; (FVHI) and (40000c);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* check FVAR bit<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FVHI&larr; (FVHI) and (rhmask), branch[.fvfvar, alu#0];<br><br>.fvpvar:<br>   branch[.+2, R&gt;=0], FVLO, FVLO&larr; T - 1, memBase&larr; LScratchBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.fvloop];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* unbound PVAR<br>   FVHI&larr; StackHi, branch[.donefvlookup];<br>.fvfvar:<br>   branch[.+2, R odd], FVLO;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.donefvlookup];<br>* should create chain here<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.newframe];<br><br>.endofstack:<br>   FVLO&larr; (FVNAME) + (FVNAME);<br>   FVHI&larr; ValSpace, branch[.+2, carry&rsquo;];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FVHI&larr; (FVHI) xor (1c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* a bit like flipMembase<br><br>.donefvlookup:<br>   branch[.+2, R odd], FVCHAIN, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">return;<br>* kludge!!!</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* STORE FVHI in both halves<br>   T&larr; LSH[FVHI, 10];<br>   T&larr; T + (FVHI);<br>   T&larr; (store&larr; FVCHAIN) - 1, dbuf&larr; T;<br>   store&larr; T, dbuf&larr; FVLO, return;<br><br>TOPLEVEL;</span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
