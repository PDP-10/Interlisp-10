<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>INTERMEZZO>SOURCES>LispDMC.DM!2>LMEM.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">:Title[LMEM];<br>* Edit History<br>* March 11, 1985  6:17 PM, Masinter, fix bug where BLT<br>* </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">of number &gt; 2&uarr;15 would always exit<br></span><span style="font: 10pt monospace">* February 2, 1985  2:55 PM, Masinter, attempt to fix bug where BLT<br></span><span style="font: 10pt serif">* January 21, 1985  11:54 AM, Masinter, bum VAG2 a bit, clean up a <br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK or two<br>* January 17, 1984  4:02 AM, JonL, added .pbsFetch for PUTBASEN and<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">PUTBITS<br>* January 17, 1984  2:10 AM, JonL, added .gbsFetch for use by GETBASEN,<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">GETBASEPTRN, and GETBITS; also tailed them out thru REPSMT2<br>* January 17, 1984  1:25 AM, JonL, abstracted .addrNfetch, changed<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">DOGETBYTE to .getByte and let it use LTEMP1 instead of LTEMP0<br>* January 17, 1984  12:51 AM, JonL, squeezed one inst out of opADDBASE<br>* January 13, 1984  10:42 PM, JonL, spawned LMEM off LOW.mc<br>* January 4, 1984  7:08 PM, JonL, tailed opPUTBASEPTR and opPUTBITS<br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">into TL.POP1.  <br>* December 15, 1983  3:45 PM, JonL,  HILOC to tail into REPTMD1<br><br>*--------------------------------------------------------------------<br>* Low-Level Memory referencing<br>*--------------------------------------------------------------------<br><br>   TOP LEVEL;<br>   knowrbase[LTEMP0];<br>   InsSet[LispInsSet, 1];<br><br><br>*--------------------------------------------------------------------<br>opHILOC:<br>*--------------------------------------------------------------------<br>   fetch&larr; TSP, T&larr; (SmallHi), branch[REPTMD1];<br><br>regOP1[322, StackM2BR, opHILOC, noNData];<br><br>*--------------------------------------------------------------------<br>opLOLOC:<br>*--------------------------------------------------------------------<br>   store&larr; TSP, dbuf&larr; SmallHi, NextOpCode;<br><br>regOP1[323, StackM2BR, opLOLOC, noNData];<br><br>*--------------------------------------------------------------------<br>opADDBASE:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.addrNfetch];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.adbs1, alu#0], LTEMP1&larr; (LTEMP1) + (Md);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* + Lo.word of addr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, carry], LEFT&larr; (LEFT) + 1;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode; * Done - fast case<br>   T&larr; (store&larr; T) - 1, dbuf&larr; LTEMP1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Carry over into next<br>   TSP&larr; (fetch&larr; T) + (2c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  next segment<br>   LTEMP0&larr; (1s) + (Md);<br>   store&larr; T, dbuf&larr; LTEMP0, NextOpCode;<br><br>SUBROUTINE;<br>.addrNfetch:<br>* Enter and exit with StackBR<br>* Leaves 0 on pd iff TOS is a smallposp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (2c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP0&larr; Hi.word of n<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP1&larr; Md, (fetch&larr; T);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP1&larr; Lo.word of n<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pd&larr; (LTEMP0) xor (SmallHi), Return; </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Is n a smallP?<br>TOPLEVEL;<br><br>.adbs1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br>%</span><span class="tab" val="67"></span><span style="font: 10pt serif">*  This could continue something like . . .<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LEFT&larr; (LEFT) - 1, memBase&larr; StackM2BR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX1];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (TSP) + 1, flipMemBase;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Change back to StackM2BR<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; T) - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* TSP was "pulled back" <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">(fetch&larr; T), LTEMP1&larr; Md;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP1&larr; lo.word of addr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (LTEMP1) + Q, LTEMP1&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Lo.word sum<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; (LTEMP0) + (Md), XorSavedCarry;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Hi.word sum<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (store&larr; LTEMP1) + 1, dbuf&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store Lo.word<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">(store&larr; T), dbuf&larr; LTEMP0, NextOpCode;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Store Hi.word<br>%<br><br>regOP1[320, StackM2BR, opADDBASE, noNData];<br><br>*--------------------------------------------------------------------<br>opVAG2:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (store&larr; TSP) + 1, dbuf&larr; Q;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;<br><br>% <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* This old code does error checking<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pd&larr; (LTEMP0) or (T);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.+2, alu=0], T&larr; (store&larr; TSP) + 1, dbuf&larr; Q;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;<br><br>    </span><span class="tab" val="67"></span><span style="font: 10pt serif">*</span><span class="tab" val="67"></span><span style="font: 10pt serif">This old code is 6 instruction executions instead of 11, but it  <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*   consumes two more locations, and does no error checking.<br><br>   T&larr; (TSP) - 1;<br>   T&larr; (fetch&larr; T) - (2c);<br>   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1;<br>   LEFT&larr; (LEFT) + 1;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; Md;<br>   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;<br>%<br><br>regOP1[321, StackM2BR, opVAG2, noNData];<br><br>*--------------------------------------------------------------------<br>opBLT: * (destinationaddr sourceaddr #wds)<br>*--------------------------------------------------------------------<br>* Defined to move one word at a time, from the high end to the<br>*   low end, and be continuable after interrupts.<br>* These highly-bummed ideas are taken from Taft&rsquo;s implementation of <br>*  Mesa BLT and BLTL, found in DMesaRW.mc<br>* Enter with: <br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q set to 20b<br>*        T set to number of words to move minus one<br>*        stack has running count (minus 1)<br>* Branch back around the loop:  <br>*</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">stack updated to next value<br>*        T set up 17 for the next full munch<br>* Before starting the transfer, touch the last word of the source and<br>*  destination blocks, to force any page faults that would happen, to<br>*  happen now rather than in the inner loop.  Maybe need not touch the <br>*  first words, since a fault there will abort the loop before it has <br>*  done anything permanent.  Also, "pre-warm" the cache for the next <br>*  time around.<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.addrNfetch];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.+2, alu=0], T&larr; T - 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Punt: #wds not smallposp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Why 2 for StkP? &rsquo;Cause<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  BitBlt does it that way<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP3&larr; Md, (fetch&larr; T), T&larr; (2c);</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch on hi.word of Dest<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr;  pd&larr; LTEMP1, StkP&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP1 had #wds to move</span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.bltxit, alu=0],</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* zero words to transfer?<br></span><span class="tab" val="67"></span><span style="font: 10pt serif"> T&larr; Md, stack&larr; T - 1, memBase&larr; BBDSTBR;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Stack&larr; #wds-1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, alu&gt;=0], BRHi&larr; T;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* call UFN if &gt; 2&uarr;15 words<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (20c); <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; T, T&larr; T - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Q&larr; (20c), T&larr; (17c)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRLo&larr; LTEMP3;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (stack) and T, memBase&larr; BBSRCBR;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; #wds-1 mod 20b<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRHi&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRLo&larr; LTEMP2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PSTATE&larr; (add[PS.PFOK!, PS.INBLT!]c); <br><br>.bltloop:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; T&larr; (FETCH&larr; stack) - T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch on first src wd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; (FETCH&larr; T) - (Q);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch on last src wd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PreFetch&larr; LTEMP2, flipMemBase;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FETCH&larr; stack;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch on first dest wd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FETCH&larr; LTEMP0;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Fetch on last dest wd<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PreFetch&larr; LTEMP2, T&larr; MD, flipMemBase;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Synchronize PageFaults<br>***   Here&rsquo;s the tight inner loop to move a munch<br>.bltmm:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">fetch&larr; stack, flipMemBase;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">stack&larr; (STORE&larr; stack) - 1, dbuf&larr; Md, flipMembase, <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.bltmm, Cnt#0&-1];</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br>***</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pd&larr; stack, Branch[.+2, Reschedule&rsquo;];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Tails into BitBlt code if <br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[BBXitToContinue];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  need to xit for interrupt<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (17c), Branch[.bltloop, alu&gt;=0];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* Should be 17 or -1, not 0<br><br>.bltdone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PSTATE&larr; A0;<br>.bltxit:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LEFT&larr; (LEFT) + (2c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LEFT is re-computed if<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (TSP) - (4c), NextOpCode;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  there is a fault-out<br><br>%<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (2c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pd&larr; (LTEMP0) xor (SmallHi);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, alu=0], LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP3&larr; Md, fetch&larr; T, pd &larr; T&larr; (LTEMP2);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, alu#0], LTEMP2&larr; Md, memBase&larr; BBDSTBR, T&larr; T - 1;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.bltdone];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* no words to copy<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Cnt&larr; T;  </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* number of words to transfer - 1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRHi&larr; LTEMP2;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRLo&larr; LTEMP3;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">memBase&larr; BBSRCBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRHi&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BRLo&larr; LTEMP1;<br><br>* and now for the loop. This should really keep state in Stack a la BITBLT:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FETCH&larr; T, flipMemBase;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (store&larr; T) - 1, dbuf&larr; MD, flipMembase, branch[.-1, Cnt#0&-1];<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>.bltdone:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Left&larr; (Left) + (2c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (TSP) - (4c), NextOpCode;<br>%<br><br>regOP1[304, StackM2BR, opBLT, noNData];<br><br><br>*--------------------------------------------------------------------<br>opGETBASEN:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) + 1, Call[.gbsFetch];<br>PAGEFAULTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IFETCH&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; MD, memBase&larr; StackM2BR, Branch[REPSMALLT];<br><br>regOP2[310, StackM2BR, opGETBASEN, noNData];<br><br>SUBROUTINE;<br>.gbsFetch:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Md, fetch&larr; T, LTEMP1&larr; (rhmask);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; Md, memBase&larr; ScratchLZBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BrHi&larr; T, Return;<br>TOPLEVEL;<br><br>*--------------------------------------------------------------------<br>opGETBITS: <br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) + 1, Call[.gbsFetch];<br>PAGEFAULTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">IFETCH&larr; LTEMP0, TisID;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">memBase&larr; StackM2BR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; MD, RF&larr; Id;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; ShiftLMask[LTEMP0], memBase&larr; StackM2BR, Branch[REPSMALLT];<br><br>regOP3[312, StackM2BR, opGETBITS, noNData];<br><br>*--------------------------------------------------------------------<br>opGETBASEPTRN: <br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) + 1, Call[.gbsFetch];<br>PAGEFAULTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; (IFETCH&larr; LTEMP0) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; MD, ifetch&larr; LTEMP0;<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T and (LTEMP1), memBase&larr; StackM2BR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, Branch[REPSMT2];<br><br>regOP2[311, StackM2BR, opGETBASEPTRN, noNData];<br><br><br>*--------------------------------------------------------------------<br>opGETBASEBYTE:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.addrNfetch];</span><span class="tab" val="67"></span><span style="font: 10pt serif">* See opADDBASE<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, alu=0], T&larr; T - 1;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* Index not smallPosp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">fetch&larr; T, LTEMP0&larr; Md;<br>   memBase&larr; LScratchBR, LEFT&larr; (LEFT) + 1;<br>   LTEMP0&larr; Md, BrLo&larr; LTEMP0;<br>   BrHi&larr; LTEMP0, call[.getByte];<br>   T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;<br>   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;<br><br>regOP1[302, StackM2BR, opGETBASEBYTE, noNData];<br><br><br>SUBROUTINE;<br>.getByte:<br>* called by BIN, GETBASEBYTE;<br>* Assumes current memBase is pointer, LTEMP1 is byte offset<br>* Returns byte in LTEMP1<br>* Must not clobber T<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dblbranch[.dgbeven, .dgbodd, R even], LTEMP1&larr; (LTEMP1) rsh 1;<br>.dgbeven:<br>  PAGEFAULTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FETCH&larr; LTEMP1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP1&larr; MD, memBase&larr; StackBR;<br>  PAGEFAULTNOTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP1&larr; RSH[LTEMP1, 10], return;<br>.dgbodd:<br>  PAGEFAULTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FETCH&larr; LTEMP1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP1&larr; MD, memBase&larr; StackBR;<br>  PAGEFAULTNOTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP1&larr; (LTEMP1) and (rhmask), return;<br><br>TOP LEVEL;<br><br>*--------------------------------------------------------------------<br>opPUTBASEN:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) + 1, Call[.pbsFetch];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch val hi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">STORE&larr; T, dbuf&larr; LTEMP0;<br>:if[Debugging];<br>   T&larr; MD, TSP &larr; (TSP) - (2c);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK, NextOpCode;<br>:else;<br>   T&larr; MD, TSP &larr; (TSP) - (2c), NextOpCode;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* wait for faults<br>:endif;<br><br>SUBROUTINE;<br>.pbsFetch:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP0&larr; Hi.newByte<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pd&larr; (LTEMP0) xor (SmallHi);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* check for smallPosp<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, alu=0], LTEMP0&larr; Md, Q&larr; Md,</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP0&larr; newByte<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; T) + 1;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TOPLEVEL; CallUFN; SUBROUTINE;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; Md, fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP2&larr; Hi.addr<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LEFT&larr; (LEFT) + 1, memBase&larr; ScratchLZBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Id) + (Md);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* T&larr; Lo.addr + alpha<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, carry&rsquo;], BrHi&larr; LTEMP2;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; (LTEMP2) + 1, branch[.-1];<br>:if[Debugging];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK, Return;<br>:else;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Return;<br>:endif;<br>TOPLEVEL;<br><br>regOP2[315, StackM2BR, opPUTBASEN, noNData];<br><br>*--------------------------------------------------------------------<br>opPUTBITS:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) + 1, Call[.pbsFetch];</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch val hi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FETCH&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">WF&larr; Id, LTEMP1&larr; T;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; ShMdBothMasks[LTEMP0];<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">store&larr; LTEMP1, dbuf&larr; T, Branch[TL.POP1];<br><br>regOP3[317, StackM2BR, opPUTBITS, noNData];<br><br><br>*--------------------------------------------------------------------<br>opPUTBASEPTRN:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch val hi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch val lo<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Q&larr; Md, T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* fetch addrhi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; Md, fetch&larr; T;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP0, Q have newval<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">memBase&larr; ScratchLZBR, LEFT&larr; (LEFT) + 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (Id) + (Md);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.+2, carry&rsquo;], BrHi&larr; LTEMP2;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; (LTEMP2) + 1, branch[.-1];<br>:if[Debugging];<br>PAGEFAULTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (STORE&larr; T) + 1, dbuf&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">STORE&larr; T, dbuf&larr; Q;<br>PAGEFAULTNOTOK, Branch[TL.POP1];<br>:else;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (STORE&larr; T) + 1, dbuf&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">STORE&larr; T, dbuf&larr; Q, Branch[TL.POP1];<br>:endif;<br><br>regOP2[316, StackM2BR, opPUTBASEPTRN, noNData];<br><br><br>*--------------------------------------------------------------------<br>opPUTBASEBYTE:</span><span class="tab" val="67"></span><span style="font: 10pt serif">* PUTBASEBYTE(base, displacement, value)<br>*--------------------------------------------------------------------<br>   T&larr; (TSP) - 1;<br>   T&larr; (fetch&larr; T) - 1;<br>   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP0 has new byte<br>   pd&larr; (LTEMP0) and not (rhmask);<br>   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1, branch[.+2, alu=0];   <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br>   pd&larr; (LTEMP1) xor (SmallHi);<br>   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1, branch[.+2, alu=0];* LTEMP1&larr;offset<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br>   LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pd&larr; (LTEMP2) xor (SmallHi);<br>   LTEMP2&larr; Md, fetch&larr; T, branch[.+2, alu=0];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br>   LEFT&larr; (LEFT) + 1, memBase&larr; LScratchBR;<br>   LTEMP2&larr; Md, BrLo&larr; LTEMP2;<br>   BrHi&larr; LTEMP2;<br><br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTOK;<br><br>   branch[.putRight, R odd], LTEMP1&larr; (LTEMP1) rsh 1;<br>   FETCH&larr; LTEMP1;<br>   T&larr; Md, TSP&larr; T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* CAN FAULT<br>   T&larr; T and (rhmask);<br>   Q&larr; LTEMP0;<br>   LTEMP0&larr; LSH[LTEMP0, 10];<br>   T&larr; T + (LTEMP0), branch[.restoreByte];<br><br>.putRight:<br>   FETCH&larr; LTEMP1;<br>   T&larr; Md, TSP&larr; T;</span><span class="tab" val="67"></span><span style="font: 10pt serif">* CAN FAULT<br>   T&larr; T and (lhmask);<br>   T&larr; T + (LTEMP0), Q&larr; LTEMP0, branch[.restoreByte];<br><br>.restoreByte:<br>   store&larr; LTEMP1, dbuf&larr; T;<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">PAGEFAULTNOTOK;<br><br>   LEFT&larr; (LEFT) + 1, memBase&larr; StackBR;<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;<br>   TSP&larr; (store&larr; TSP) + 1, dbuf&larr; Q, NextOpCode;<br><br><br>%<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (fetch&larr; TSP) - 1, flipMemBase, Call[.UNBOX2];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; T or (LTEMP0);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* displacement and value <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (LTEMP1) and not (rhmask);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">*  must be smallPosp&rsquo;s</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">pd&larr; T or (LTEMP0);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* value at most 8 bits<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Branch[.pbb1, alu=0], T&larr; (TSP) - 1;<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (TSP) + (4c);<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">CallUFN;<br>.pbb1:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP3&larr; T&larr; (fetch&larr; T) - 1;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP1 has new byte value<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; Md, T&larr; (fetch&larr; T) + (6c);</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* (must restore TSP, fault!)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; T, memBase&larr; LScratchBR;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LScratchBR points to base<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP0&larr; Md, BrLo&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BrHi&larr; LTEMP0, LTEMP0&larr; Q;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">* LTEMP0&larr; displacement<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">branch[.putRight, R odd], LTEMP0&larr; (LTEMP0) rsh 1;<br>PAGEFAULTOK;<br>.putLeft:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FETCH&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; LTEMP1, T&larr; (MD);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; LSH[LTEMP2, 10];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (T) and (rhmask), branch[.restoreByte];<br>.putRight:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">FETCH&larr; LTEMP0;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LTEMP2&larr; LTEMP1, T&larr; (MD);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T and (lhmask), branch[.restoreByte];<br>.restoreByte:<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; T or (LTEMP2);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">store&larr; LTEMP0, dbuf&larr; T;<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">LEFT&larr; (LEFT) - (2c);</span><span class="tab" val="67"></span><span style="font: 10pt serif"><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; LTEMP3, memBase&larr; StackBR;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">T&larr; (store&larr; T) + 1, dbuf&larr; SmallHi;<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, NextOpCode;<br><br>%<br><br>regOP1[307, StackBR, opPUTBASEBYTE, noNData];<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
