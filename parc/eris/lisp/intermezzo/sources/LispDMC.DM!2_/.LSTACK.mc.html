<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>INTERMEZZO>SOURCES>LispDMC.DM!2>LSTACK.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">:Title[LSTACK.mc, StackFrame manipulations];<br>*<br>* Edit History<br>* January 17, 1985  11:32 PM, Masinter, add STORE.N, COPY.N<br>* January 13, 1984  9:25 PM, JonL, LBIND merged in here<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PUSHTMD, TL.ST0TMD, TL.PUSHNIL and TL.PUSHTRUE to LVARCONST,<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">removed PUSHQT (no users?)<br>* January 6, 1984  4:55 AM, JonL, Note that REPNIL appears here (when ?)<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">added TL.REPNIL2 for CDR&rsquo;s benefit<br>* January 3, 1984  8:32 PM, JonL, Removed FIXSTACKREGS (was  <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">nowhere else referenced) and added lots of commentary<br>* December 27, 1983  11:30 AM, JonL, moved opCOPY from LINST<br>* December 26, 1983  3:11 PM, JonL, added subroutine ABFETCH,<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">SWAP starts out StackM2BR, and to use ABFETCH<br>* December 21, 1983  7:48 AM, JonL, brought in opSWAP, opPOP,<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">and REPSMALLT; Moved NEXTOP to LOPS<br>* December 15, 1983  3:49 PM -- added label REPTMD1 - JonL<br>* December 9, 1983  1:14 PM -- Added ARG0 - JonL<br>* Prior dates -- Masinter<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">KnowRBase[LTEMP0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOP LEVEL;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">InsSet[LispInsSet, 1];<br><br><br>*--------------------------------------------------------------------<br>opCOPY:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase;<br>   T&larr; Md, fetch&larr; T, branch[PUSHTMD];<br><br>regOP1[144, StackM2BR, opCOPY, noNData];<br>*--------------------------------------------------------------------<br>opCOPYN:<br>*--------------------------------------------------------------------<br>   T&larr; (TSP) - (T), TisID;<br>   T&larr; (fetch&larr; T) - 1, flipMemBase;<br>   T&larr; Md, fetch&larr; T, branch[PUSHTMD];<br><br>regOP2[75, StackM2BR, opCOPYN, noNData];<br>*--------------------------------------------------------------------<br>opSTOREN:<br>*--------------------------------------------------------------------<br>   T&larr; (fetch&larr; TSP) - 1, flipMemBase;<br>   T&larr; Md, LTEMP0 &larr; (fetch&larr; T) - (3c);<br>   LTEMP0&larr; (LTEMP0) - (T), TisID, branch[TL.ST0TMD];<br><br>regOP2[74, StackM2BR, opSTOREN, noNData];<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">*--------------------------------------------------------------------<br>opPOP:<br>*--------------------------------------------------------------------<br>regOP1[277, StackBR, opPOP, noNData];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; (LEFT) + 1;<br>TL.POP1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) - (2c), NextOpcode;<br><br><br>*--------------------------------------------------------------------<br>opSWAP:<br>*-------------------------------------------------------------------<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMembase, call[ABFETCH];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Bhi in LTEMP0<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Blo in LTEMP1<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; Md, T&larr; (fetch&larr; T) - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Ahi in LTEMP2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; Md,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Alo in LTEMP3<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Ahi&larr; Bhi<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Alo&larr; Blo<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP2;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Bhi&larr; Ahi<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; LTEMP3, NextOpcode;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Blo&larr; Alo<br><br>%<br>   T&larr; (TSP) - 1;<br>   T&larr; (fetch&larr; T) - 1;<br>   LTEMP1&larr; Md, T&larr; (fetch&larr; T) - 1;<br>   LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1;<br>   LTEMP2&larr; Md, fetch&larr; T;<br>   LTEMP0&larr; Md, T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;<br>   store&larr; T, dbuf&larr; LTEMP2, NextOpcode;<br>%<br><br>regOP1[375, StackM2BR, opSWAP, noNData];<br><br><br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">ABFETCH:<br>*--------------------------------------------------------------------<br><br>* For two-arguments A and B on stack (B in TOS)<br>* Enter with fetch pending on Bhi,<br>*            T positioned over Blo,<br>*            membase is StackBr<br>*  typical entry starts membase at StackM2BR and does<br>*         T&larr; (fetch&larr; TSP) - 1, flipMembase, call[ABFETCH];<br>* Exit with Bhi in LTEMP0<br>*           Blo in LTEMP1<br>*           fetch pending on Ahi<br>*           T positioned over Alo<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, T&larr; (fetch&larr; T) - (3c);</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Hi.word in LTEMP0<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, T&larr; (fetch&larr; T) + 1, return;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Lo.word in LTEMP1<br>TOPLEVEL;<br><br><br>*--------------------------------------------------------------------<br>opMYALINK:<br>*--------------------------------------------------------------------<br>regOP1[146, StackBR, opMYALINK, noNData];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[ALINK]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T, T&larr; (177776c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T and Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T - (FX.PVAR), branch[PUSHSMALLT];<br><br><br>UfnOps[145];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* MYARGCOUNT<br>UfnOps[141];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* ARG0<br><br>% Someday, we&rsquo;d like to do these two <br><br>*--------------------------------------------------------------------<br>opMYARGCOUNT:<br>*--------------------------------------------------------------------<br>regOP1[145, StackBR, opMYARGCOUNT, noNData];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[ALINK]), call[.GETMYARGCOUNT];         * Get Alink wd to see if fastp <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], </span><span style="font: 10pt monospace">LEFT</span><span style="font: 10pt monospace">&larr; (</span><span style="font: 10pt monospace">LEFT</span><span style="font: 10pt monospace">) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[TL.PUSHT];<br><br>SUBROUTINE;<br><br>.GETMYARGCOUNT:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T)+(FXDIF[BFLAGS,ALINK]); * T points to BFLAGS in BF<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*LTEMP0 holds Alink,fetch Bflags contents<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R even], LTEMP0, LTEMP0 &larr; (BfPadded); <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">    TOP LEVEL; callUFN; </span><span class="tab" val="24"></span><span style="font: 10pt monospace">SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*Punt out if not fastp case<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd &larr; (LTEMP0) and (Md);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], T&larr; (T - (IVAR)) rsh 1; * and nargs &larr; # IVAR wds / 2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">    T&larr; T - 1, RETURN; </span><span class="tab" val="24"></span><span style="font: 10pt monospace">* when "padded", there is an extra cell. sub it off<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">return;<br>TOP LEVEL;<br><br>*--------------------------------------------------------------------<br>opARG0:<br>*--------------------------------------------------------------------<br>regOP1[141, StackM2BR, opARG0, noNData];<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* One arg, the index of IVAR <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*   wanted<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T-(SmallHi), LTEMP1&larr; Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], T&larr; (LTEMP1) + (LTEMP1), flipMemBase;*punt if ~SMALLPOSP<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   callUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  or if = 0<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0], LTEMP2&larr; T + (IVAR);</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* args are double wds<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   callUFN;<br><br>* BEGINNING OF TESTING <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">nop;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[ALINK]), call[.GETMYARGCOUNT]; <br>* at this point, T has MYARGCOUNT in it<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (LTEMP1) - T - 1, flipMemBase; <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch [.+2, carry&rsquo;];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   callUFN;* arg too large!<br>* end of test<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; LTEMP2) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, TSP &larr; (store&larr; TSP) + 1, dbuf&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP &larr; (store&larr; TSP) - 1, dbuf&larr; T, NextOpCode;<br><br>%<br><br><br>*--------------------------------------------------------------------<br>opBIND:<br>*--------------------------------------------------------------------<br>* Binds n1 pvars to NIL and <br>* n2 pvars to the n2 items on the stack<br>* Last pvar stored into is N<br>* pushes binding mark [-(n1+n2)-1,, 2*N]<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP0&larr; Id;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* n1 (first 4 bits) #NILs<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Id, Cnt&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* n2 (next 4 bits)  #values<br> </span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (Id) lsh 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 2*N<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) + (Q&larr; T);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.endBindNils, Cnt=0&-1], LTEMP2&larr; T + 1; <br><br>.BindVarToNil:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; (store&larr; LTEMP2) - 1, DBuf&larr; AT.NIL;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; (store&larr; LTEMP2) - 1, DBuf&larr; 0c,</span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.BindVarToNil,Cnt#0&-1];<br><br>.endBindNils:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Cnt&larr; LTEMP1, T&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* #values to bind<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; (LEFT) + T;<br><br>.BindVarToVal:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (TSP) - 1, branch[.EndBind, Cnt=0&-1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (fetch&larr; T) - 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, (fetch&larr; TSP);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, LTEMP2&larr; (store&larr; LTEMP2) - 1, dbuf&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; (store&larr; LTEMP2) - 1, DBuf&larr; T, branch[.BindVarToVal];<br><br>.EndBind:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (0s) - (LTEMP1);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* -N2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T - (LTEMP0) - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* -N1-N2-1<br></span><span style="font: 10pt monospace">PUSHTQ: <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StackCheck;<br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T and not (77c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[</span><span style="font: 10pt monospace">badpushval</span><span style="font: 10pt monospace">];<br></span><span style="font: 10pt monospace">:endif;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; Q, NextOpCode;<br><br></span><span style="font: 10pt monospace"><br>IFUreg[21, 3, StackBR, 0, opBIND, noNData, 0, 1];<br><br><br>*--------------------------------------------------------------------<br>opUNBIND:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) - 1, flipMemBase;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, T&larr; (fetch&larr; T) - 1, flipMemBase;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; T, Q&larr; Md, branch[opDUNBIND];<br><br>*--------------------------------------------------------------------<br>opDUNBIND:<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; TSP&larr; (fetch&larr; TSP) - (2c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; Md, T&larr; T + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[opDUNBIND, R&gt;=0], LTEMP1, LTEMP1&larr; not (LTEMP1);<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">T points (relative to StackM2BR) to the odd word<br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1 has (n1+n2)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">flipMemBase;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Cnt&larr; LTEMP1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) + (Md) + 1;<br><br>.unbindvar:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Loop here<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.unbindend, Cnt=0&-1], T&larr; T - 1;<br>:if[Debugging];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* check if slot was not bound<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch &larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd &larr; Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu&gt;=0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">   uCodeCheck[UnBindNotBound];<br>:endif;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) - 1, dbuf&larr; AllOnes, branch[.unbindvar];<br><br>.unbindend:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">call[FIXLEFT];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; Id;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[PUSHTQ, alu=0], T&larr; LTEMP0;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Id=0 for unbind<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;<br><br>regOP1[22, StackM2BR, opUNBIND, 0];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* UNBIND<br>regOP1[23, StackM2BR, opDUNBIND, 1];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* DUNBIND<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
