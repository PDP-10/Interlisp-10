<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>INTERMEZZO>SOURCES>LispDMC.DM!2>DisplayMain.MC</title>
  </head>
  <body>
    <pre>
*-----------------------------------------------------------Title[DisplayMain.mc.....January 22, 1985  12:52 AM...Masinter];* Main part of Dorado display microcode -- included with emulators,* but not included with Bootstrap/Initial microcode.*-----------------------------------------------------------*-----------------------------------------------------------* Terminal Word Task (TWT) and Display Word Task (DWT) microcode.* TWT runs as either DWT or AWT, depending on hardware configuration.* If TWT runs as AWT, then DWT may run independently on behalf of* a non-Alto display, using the same word task microcode.*-----------------------------------------------------------%This microcode is structured as if it used subtasks, because it may beshared by non-Alto terminal microcode using DWT.  However, whenrunning in Alto terminal emulation mode as AWT or DWT, it NEVER expectsto get a B channel command or to run as the B subtask.Note that this microcode can run on behalf of the DispM terminal controlleror of either A or B channel of the DispY controller.  DispY and DispMuse independent but parallel RBase, MemBase, and TIOA values, and theA and B channels are differentiated by SubTask.  Thus, for example,references to ACount (below) apply equally well to BCount or TCountin the appropriate circumstances.This code uses subtasks, and must ALWAYS Branch to the same place whenblocking, must never test Branch conditions across blocks,  and must usetask-specific RBase, RStk, and MemBase values correctly. Note that thecontroller is designed to prohibit wakeups while DWT is initiated (eitherrunning or preempted) and for at least n instructions after any BLOCK,where n is approximately 5.DWT microcode wakes up in response to flags set by the DHT microcode.DWT does not need to be specially awakened for initialization.DWT will initialize itself EXCEPT that AAddress, BAddress, ACount,and BCount must have been initialized explicitly by DHT, because you cannotguarantee which subtask will run first, and DWTInit is executed only once.Subtask.0 defines a block of 16 subtask specific registers, of which5 per subtask are used by DWT: AAddress, ACount, ANextCount, ANextAddrLo,and ANextAddrHi are the subtask-specific registers for Channel A.There is a similar set for channel B.%Set[XTask, IP[DWT]];*-----------------------------------------------------------TWTInitPC:* Terminal word task initialization: return appropriate task number.*-----------------------------------------------------------Subroutine;KnowRBase[THTRegion];	T&larr; AWT, DisplayConfig, Branch[.+2, R&lt;0];	T&larr; DWT;	CoReturn;TopLevel;* Terminal word task starts up here as either DWT or AWT.* Select TIOA that addresses the appropriate hardware.* All other initialization and main loop code is the same as DWT.	MemBase&larr; TChannelBR;	RBase&larr; RBase[THTRegion];	RBase&larr; RBase[TWTRegion], DisplayConfig, Branch[UseDWTFlag, R&gt;=0];	T&larr; AWTFlag, Branch[SetDWTFlag];*-----------------------------------------------------------DWTInitPC:* Display word task initialization, for non-standard displays.*-----------------------------------------------------------Subroutine;KnowRBase[TWTRegion];	T&larr; DWT, CoReturn;TopLevel;* Display word task starts up here iff it is not being used for* Alto terminal emulation.	RBase&larr; RBase[AChannelRegion];	MemBase&larr; AChannelBR;UseDWTFlag:	T&larr; DWTFlag;			*same for both subtasksSetDWTFlag:	TIOA&larr; T;	T&larr; 20C, Branch[DWTCheck];	*same for both subtasks*-----------------------------------------------------------* Display word task main loop -- shared by terminal word task.* ACount &gt;=0 here iff data remains to be output for the current scan line.*-----------------------------------------------------------DWTStart:	ACount&larr; (ACount)-T, Branch[DWTCheck,  R&lt;0];* Fetch the next munch.  Output&larr; 20 signals to the display controller* that a new munch is on its way.	AAddress&larr; (IOFetch&larr; AAddress)+(Output&larr; T), Block, Branch[DWTStart];* AAddress will be even if we just exhausted a scan line.* AAddress will be odd if we have been awakened to start a new scan line.* In either case, isolate flag in AAddress[15] for use in adjusting* the WCB flags (below).DWTCheck:	AAddress&larr; (AAddress) AND (1C), Branch[DWTAdjustWCBFlags, R even];* Starting new scan line.  Copy parameters left by DHT.DWTRefill:	BrHi&larr; ANextAddrHi, Branch[DWTSpuriousWakeup, R&lt;0];	BrLo&larr; ANextAddrLo;	ACount&larr; ANextCount;		* (# Munches to Fetch)-1 in [8..11]* Now adjust WCB flags, as follows:* If we just exhausted a scan line, AAddress = 0 now; execute Output&larr; 0* to clear the CurWCB flag, and set AAddress to -1 for the next wakeup.* If we are starting a new scan line, AAddress = 1 now; execute Output&larr; 1* to set the CurWCB flag and clear the NextWCB flag, and set AAddress to 0* for the first IOFetch.DWTAdjustWCBFlags:	AAddress&larr; (AAddress)-1, Output&larr; AAddress, Block, Branch[DWTStart];* A bug in the hardware causes occasional spurious wakeups; just ignore them.* Note that we do nothing to dismiss the spurious wakeups -- the ones caused by* the known hardware bug are transient.DWTSpuriousWakeup:	ACount&larr; T-T-1, Block, Branch[DWTStart];*-----------------------------------------------------------* Alto Terminal Horizontal Task (THT) microcode.* This microcode runs as DHT or AHT and does everything* for the display except IOFetches. *-----------------------------------------------------------*-----------------------------------------------------------DHTInitPC:* Dummy Display Horizontal Task initialization.* The label DHTInitPC is redefined if real DHT microcode is included.*-----------------------------------------------------------Subroutine;	T&larr; DHT, CoReturn;TopLevel;* DHT will be awakened once; just ignore the wakeup.	Block, Branch[.];*-----------------------------------------------------------THTInitPC:* Terminal Horizontal Task initialization: return appropriate task number.* Note: must awaken the appropriate task here, since the task number is* a variable.*-----------------------------------------------------------Subroutine;KnowRBase[THTRegion];	T&larr; AHT, DisplayConfig, Branch[THTInitAHT, R&lt;0];	T&larr; DHT;	Wakeup[DHT], CoReturn;TopLevel;* DHT starts here	T&larr; Statics, Branch[THTInit1];	* Use DispY TIOASubroutine;THTInitAHT:	Wakeup[AHT], CoReturn;TopLevel;* AHT starts here	T&larr; TStatics, Branch[THTInit1];	* Use DispM TIOATHTInit1:	TIOA&larr; T;:If[AltoMode];		********** Alto version **********	RBase&larr; RBase[EmuBRHiReg];	T&larr; EmuBRHiReg, RBase&larr; RBase[TWTRegion], Call[SetDisplayBRHi];	MaxWidthWords&larr; MaxWidthWordsAlto;:Else;			******** PrincOps version ********	T&larr; A0, RBase&larr; RBase[TWTRegion], Call[SetDisplayBRHi];:EndIf;			**********************************	T&larr; AllShutUp, Call[OutputGetsT]; * Disable WakeUps, Reset DDC	TCount&larr; T-T-1, MemBase&larr; IOBR;	TAddress&larr; T-T-1, TIOA[TNLCB];	* Set initial TWT WCB flag	TSetNextWCB&larr; ANextWCBFlag;* Initialize both channels to maximum left margins, so they never turn on.	TChannelReg&larr; A0, Call[SendMaxMarg];* Reset various NLCB registers	T&larr; AScan, Call[OutputGetsT];	T&larr; BScan, Call[OutputGetsT];	* Initialize B because polarity is ORed with A!	T&larr; Modes, Call[OutputGetsT];* THT initialization (cont'd)* Skip over HRam and MiniMixer initialization if DispM present.ResetDisplayConfig:	RBase&larr; RBase[THTRegion];	PD&larr; NOT (DisplayConfig);	TReg400C&larr; 400C, Branch[NoInitRams, ALU&gt;=0];* Initialize HRam and MiniMixer.	Call[InitHRam];	Call[JLoadMiniMixer];	Nop;				* Placement* Initialize vertical waveform and left margin constants according to* the appropriate hardware configuration and display mode, chosen from:*   {Alto, LF (Alto mode), LF (full screen)} X {DispY, DispM}.* These are selected by, respectively,*   (DisplayConfig[13:15] = {0, 1, 3}) X (DisplayConfig[0] = {0, 1})* except that in PrincOps mode, DisplayConfig[13:15] = 1 selects LF (full screen)* and the value 3 does not occur.NoInitRams:	T&larr; LCY[DisplayConfig, DisplayConfig, 1], Branch[.+3, R odd];* Initialize vertical waveforms for an Alto monitor:	VisibleLineConst&larr; LowByte[TopBorderCntAlto, VisibleLineCnt, BottomBorderCntAlto];	TopBorderConst&larr; TopBorderCntAlto, Branch[.+3];* Initialize vertical waveforms for an LF monitor:	VisibleLineConst&larr; LowByte[TopBorderCntLF, VisibleLineCnt, BottomBorderCntLF];	TopBorderConst&larr; TopBorderCntLF;	VisibleLineConst&larr; (VisibleLineConst)+(400C);	VSyncConst&larr; VSyncCnt;* Now compute the IM address of the margin constants.	BootState&larr; A0, TaskingOff, Call[AfterMarginConsts];* MargConst[LMarg, CursorX] assembles IM word with the LMarg NLCB constant in the* left half and the CursorX NLCB constant in the right half.M[MargConst,  Set[T1@, Or[ALMarg!, And[Sub[0, #1], NLCBDataMask!]]]  Set[T2@, Or[CursorX!, And[Sub[0, #2], NLCBDataMask!]]]  Data[(Byt0[RShift[T1@, 10]] Byt1[And[T1@, 377]]    Byt2[RShift[T2@, 10]] Byt3[And[T2@, 377]])]];DispTable[IfE[AltoMode, 0, 4, 10]];	* Indexed by DisplayConfig[14:15],,DisplayConfig[0]	MargConst[Dec[0,0,3,6], Dec[0,3,2,5]];	* Alto monitor, DispY board	MargConst[Dec[0,0,0,0], Dec[0,3,2,0]];	* Alto monitor, DispM board:If[AltoMode];		********** Alto version *********** These constants include extra left margin to center an Alto-style picture on* an LF monitor.	MargConst[Dec[0,5,3,0], Dec[0,8,1,9]];	* LF monitor, Alto width, DispY board	MargConst[Dec[0,4,9,5], Dec[0,8,1,5]];	* LF monitor, Alto width, DispM board	Nop;	Nop;:EndIf;			*********************************** These constants are for a picture that fills the LF monitor.	MargConst[Dec[0,3,2,2], Dec[0,6,1,1]];	* LF monitor, full width, DispY board	MargConst[Dec[0,2,6,2], Dec[0,5,8,2]];	* LF monitor, full width, DispM board* THT initialization (cont'd)* T = table index, Link = table base.  Read the table entry from IM.* Miscellaneous other initialization is interspersed with this.AfterMarginConsts:	TTemp0&larr; T OR (Link), Call[LinkGetsTTemp0];	TVCWShadowReg&larr; A0, TIOA[TStatics], ReadIM[0];	T&larr; Link, Call[LinkGetsTTemp0];	T&larr; LCY[T, T, 10], ReadIM[1];	T&larr; T XOR (Link);	LMargConst&larr; T, Call[LinkGetsTTemp0];	TerminalLo&larr; A0, ReadIM[2];	T&larr; Link, Call[LinkGetsTTemp0];	T&larr; LCY[T, T, 10], ReadIM[3];	CursorXConst&larr; T XOR (Link);	TerminalHi&larr; T&larr; A0, TaskingOn, Call[OutputGetsT]; * Statics&larr; 0 to enable wakeups	BootTimer&larr; T&larr; A0, Block, Branch[THTNewField];*-----------------------------------------------------------LinkGetsTTemp0:*-----------------------------------------------------------Subroutine;	Link&larr; TTemp0, Return;TopLevel;*-----------------------------------------------------------* Start of new field (defined to be beginning of VSync)*-----------------------------------------------------------KnowRBase[THTRegion];THTNewField:	TFieldAreaReg&larr; VSyncConst;	TIOA[TNLCB], Call[SendMaxMarg];*Initialize cursor to zero	T&larr; CursorLo, Call[OutputGetsT];	T&larr; CursorHi, Call[OutputGetsT];* Complement field type and set VSync=1, VBlank=1	TVCWShadowReg&larr; (TVCWShadowReg) XOR (Or[VSync!, VBlank!, 1]C);	T&larr; BootTimer, Output&larr; T;	* T for boot check below%*-----------------------------------------------------------Booting obeys the following protocol:  1.	Ignore button pushes that are very short (less than 8 ms).  2.	Wait 1.5 seconds after a single push to see if the the user is	performing a multiple-push boot.  3.	If the button is down more than 2.5 seconds, ignore the button push.The baseboard also sees the boot button, and will boot the machine itselfif a multiple-push boot occurs.The ReadTerminal subroutine, called once every scan line (38 us),watches the boot button, and reports results in these registers:	TerminalHi &lt; 0 iff boot button is presently down;	BootTimer = duration of most recent button push (units of 38 us);		0 =&gt; no boot has occurred;		177777B =&gt; push was &gt; 2.5 seconds long.Note: ReadTerminal filters out too-short pushes (&lt; 8 ms).Note: BootTimer is valid only if the boot button is now up (TerminalHi &gt;= 0).This logic runs once per field (60 times/second) and decides what to do.The BootState register reflects the current state, as follows:	BootState=0 if nothing is happening; otherwise:	BootState[0:14] = number of fields remaining until action should be		taken (if boot button stays up);	BootState[15] = action: 1 = boot, 0 = ignore.%*-----------------------------------------------------------BootCheck:		* T=BootTimer; TerminalHi[0]=1 if boot button now down%  * * * turn off bootcheck for LISP	PD&larr; T, TerminalHi, Branch[EndBootCheck, R&lt;0];	PD&larr; BootState, Branch[NewBoot, ALU#0];* Boot button is now up and has not been down recently.	BootState&larr; (BootState)-(2C), Branch[.+2, ALU#0];	BootState&larr; A0, Branch[EndBootCheck]; * Nothing is happening* Timing button-up interval.  Timer expired?	Branch[.+2, ALU&lt;0];	Branch[EndBootCheck];* Timer has expired.  Reset state and take appropriate action.	BootState, Branch[Boot, R odd];	BootState&larr; A0, Branch[EndBootCheck];* Boot button is now up but has been down recently.  Start button-up timer, and set* action = ignore if multiple pushes are in progress or the last push was too long.NewBoot:	BootState&larr; MinimumWait, Branch[.+3, ALU#0]; * Branch if multiple push	PD&larr; (BootTimer)+1;		* Action&larr; boot iff BootTimer # -1	BootState&larr; (BootState)+1, XorSavedCarry;	BootTimer&larr; A0, Branch[EndBootCheck];% * end end of no boot check*-----------------------------------------------------------* Vertical retrace activity*-----------------------------------------------------------KnowRBase[THTRegion];EndBootCheck:	T&larr; (TReg400C) OR (LowByte[CursorXCoord]);	TTemp0&larr; (Fetch&larr; T)+1;		* Fetch cursorX; TTemp0&larr; cursorY	TTemp1&larr; MD, T&larr; APointer, Call[OutputGetsT]; * reset NLCB[ReaderPtr] to zero !!	T&larr; BPointer;	Output&larr; T, Call[ReadTerminal];	* Kills wakeup; decrements TFieldAreaReg	T&larr; CursorXConst, Block;		* Block here so we don't overrun the scan line	T&larr; T-(TTemp1);			* Add cursor position to base constant	Fetch&larr; TTemp0, Output&larr; T;	* Send CursorX to NLCB; fetch cursorY	T&larr; (TVCWShadowReg) AND (1C);	* Isolate fieldtype	T&larr; T-(TopBorderConst);		* Bias cursor past top border	T&larr; T-(TopBorderConst);	TCursorYReg&larr; T-MD;		* Calculate CursorY count/index	T&larr; (TReg400C) OR (LowByte[DAStart]);	T&larr; (Fetch&larr; T)+1;	TDCBChainReg&larr; MD;* Issue the vertical field interrupt.* Must not do this until we have picked up all page 1 locations that the* software might change during the interrupt routine (particularly DAStart* and the cursor coordinates), else there is the possibility of a race.	Fetch&larr; T;			* 421B = vertical field interrupt mask	RBase&larr; RBase[NWW];	NWW&larr; (NWW) OR MD, Reschedule;	RBase&larr; RBase[THTRegion];* Loop here for remainder of vertical syncVSyncLoop:	Output&larr; TVCWShadowReg;		* Also kills wakeup	Call[ReadTerminal];	T&larr; TopBorderConst, Block, Branch[VSyncLoop, ALU#0]; * Tests TFieldAreaReg* End of vertical sync.* If odd field, generate one line of blank before beginning visible field.* This is because in odd fields vertical sync does not end until the middle* of the next scan line.	TVCWShadowReg&larr; (TVCWShadowReg) AND (Not[VSync!]C), * VSync&larr; 0, VBlank&larr; 1		Branch[EvenField, R even];	Output&larr; TVCWShadowReg,		* Also kills wakeup		Call[ReadTerminal];	T&larr; TopBorderConst, Block;EvenField:	TSLCReg&larr; T-1;			* Set top border count	T&larr; TVCWShadowReg&larr; (TVCWShadowReg) AND (Not[Or[VSync!, VBlank!]]C),		Call[OutputGetsT];	* VSync&larr; 0, VBlank&larr; 0	TFieldAreaReg&larr; VisibleLineConst;	RBase&larr; RBase[TWTRegion];	TReaderPtrReg&larr; A0,		* Init to 0, needed every new field		Branch[NoDCB];		* Skip top border before processing DCBs*-----------------------------------------------------------* Visible portion of field (including borders).  Begin processing next DCB.* Note: borders are considered part of the "visible" portion of the field so* that cursor processing will occur within the borders as well.*-----------------------------------------------------------KnowRBase[TWTRegion];NewDCB:	PD&larr; TDCBChainReg;		* Follow chain	Branch[NoDCB, ALU=0];	T&larr; (Fetch&larr; TDCBChainReg)+1;	* fetch word 0 = next DCB link	TDCBChainReg&larr; MD, T&larr; (Fetch&larr; T)+1; * fetch word 1 = htab and width	TScratch&larr; MD, T&larr; (Fetch&larr; T)+1;	* fetch word 2 = bit map address	TNextAddrLo&larr; MD, T&larr; (Fetch&larr; T)+1; * fetch word 3 = scan line count	TSLCReg&larr; MD;* Check for Dorado/D0 "Long DCB":* if bit 0 of word 3 = 1, ignore the normal (short) bit map address,* and instead interpret words 4 and 5 as a long pointer to the bit map.	TSLCReg&larr; (TSLCReg)-1, Branch[LongDCB, R&lt;0]; * TSLCReg&larr; count-1	TNextAddrHi&larr; TBRHiReg, Branch[GetScan]; * Short pointer (=MDS)* The regular (16-bit) address must contain a seal before we will believe long DCBLongDCB:	PD&larr; (TNextAddrLo) XOR (LongDCBSeal);	T&larr; (Fetch&larr; T)+1, Branch[InvalidLongDCB, ALU#0];	TNextAddrLo&larr; MD, Fetch&larr; T;	TNextAddrHi&larr; MD;	TSLCReg&larr; (TSLCReg) XOR (100000C), Branch[GetScan];InvalidLongDCB:	TDCBChainReg&larr; A0, Branch[NoDCB]; * Stop DCB processing for this field* Set up Scan control in NLCB based on Alto polarity bit.* Ignore Alto resolution bit -- always use full resolution.GetScan:	PD&larr; (TScratch) AND (AltoPolarityMask); *look at LCWord	T&larr; Or[FullRes!, Size1!]C, Branch[.+2, ALU=0];	T&larr; T OR (AltoPolarity);	T&larr; T OR (AScan), Call[OutputGetsT]; * Send scan control to NLCB* check for zero width DCB.	T&larr; (TScratch) AND (377C);	* Width in words	TNWrdsMinus1&larr; T-1, Branch[.+2, ALU#0]; 	Branch[NoDCB];* Set up width and left margin in NLCB	TScratch&larr; LDF[TScratch, 6, 10];	* TScratch&larr; HTAB	T&larr; LSH[TScratch, 4];		* Convert words to pixels	T&larr; (LMargConst)-T, Call[OutputGetsT]; * Offset from HWindow and negate:If[AltoMode];		********** Alto version *********** Ensure that HTAB+NWRDS does not extend beyond the right-hand margin.* There is a bug in DispY that causes the picture to tear if that is done.	T&larr; MaxWidthWords;	T&larr; T-(TScratch);		* T&larr; max allowable width	PD&larr; T-(TNWrdsMinus1)-1;		* Compare to actual width	T&larr; LSH[T, 4], Branch[.+2, Carry']; * Convert words to pixels	T&larr; (TNWrdsMinus1)+1, Branch[.-1]; * Use actual width:Else;			******** PrincOps version ********	T&larr; (TNWrdsMinus1)+1;		* Use actual width	T&larr; LSH[T, 4];			* Convert words to pixels:EndIf;			**********************************	T&larr; T+(Sub[WidthOffset!, 1]C);	* WidthOffset is positive const	T&larr; T XOR (AWidthDataMask),	* Negate and insert register select		Call[OutputGetsT];	* send width to NLCB* Compute initial bit map offset based on even vs odd field.	RBase&larr; RBase[THTRegion];	T&larr; A0, TVCWShadowReg, RBase&larr; RBase[TWTRegion], Branch[.+2, R odd];	T&larr; A&larr; T, Branch[MoreDCB];	* Even field	T&larr; (TNWrdsMinus1)+1, Branch[MoreDCB]; * Odd field*-----------------------------------------------------------* THT per-scan-line activity*-----------------------------------------------------------KnowRBase[TWTRegion];* Continue current DCB (from CheckSLC, below).  T = 2*NWrds.* ALU contains (TNWrdsMinus1)+1, i.e., Carry iff zero-width DCB.* Advance address to next scan line for this field.MoreDCB:	TNextAddrLo&larr; (TNextAddrLo)+T, Branch[DoCursor, Carry];	TNextAddrHi&larr; A&larr; TNextAddrHi, XorSavedCarry, Call[JamPtrAndNextCnt];* Enable TWT to run!!	TIOA[AHTFlag];	T&larr; A0, Output&larr; TSetNextWCB, Branch[DoCursor];* Here if no DCB or zero width -- do not start up TWT.NoDCB:	TNWrdsMinus1&larr; T-T-1, Call[SendMaxMarg]; * returns T=0* Cursor processing.  T must have zero on entry here.DoCursor:	T&larr; T+1, RBase&larr; RBase[THTRegion];	T&larr; TCursorYReg&larr; (TCursorYReg)+T+1, TIOA[TNLCB], Branch[NoCursor, R&lt;0];	PD&larr; T-(22C);			* T is &gt;= 2	T&larr; (TReg400C)+T, Branch[BeyondCursor, ALU&gt;=0];	T&larr; T+(LowByte[Sub[CursorBitMap!, 2]]);	Fetch&larr; T;			* T was in [2..21], now points to data	TTemp0&larr; MD, Branch[SendCursor];NoCursor:	T&larr; CursorLo, Branch[CheckSLC];BeyondCursor:	TCursorYReg&larr; 100000C;		* maximum negative value	TTemp0&larr; A0;			* Cursor data &larr; 0SendCursor:	T&larr; (TTemp0) AND (377C);		* Have cursor data in TTemp0 now	T&larr; T OR (CursorLo), Call[OutputGetsT];	T&larr; RSH[TTemp0, 10];	T&larr; T OR (CursorHi);CheckSLC:	Output&larr; T, Call[ReadTerminal];	* Returns with ALU = TFieldAreaReg* Notice: Code MUST have done at least one Output to NLCB before reaching here	T&larr; (TReg400C)-1, RBase&larr; RBase[TWTRegion], Branch[EndOfField, ALU=0];	TSLCReg&larr; (TSLCReg)-1;	T&larr; ((TNWrdsMinus1)+1) LSH 1, Block, DblBranch[NewDCB, MoreDCB, ALU&lt;0];:If[AltoMode];		********** Alto version **********EndOfField:	MaxWidthWords&larr; (MaxWidthWords) AND T, RBase&larr; RBase[THTRegion],		Block, Branch[THTNewField, R&gt;=0];	Branch[ResetDisplayConfig];	* Switching between narrow and wide modes:Else;			******** PrincOps version ********EndOfField:	RBase&larr; RBase[THTRegion], Block, Branch[THTNewField];:EndIf;			**********************************%Note: when the DCB chain is exhausted, TSLCReg will continue to decrementon every line and the Branch to NewDCB will be taken. NewDCB will find theTDCBChainReg = 0, so will go to NoDCB, then to DoCursor, and back toCheckSLC until FieldArea is exhausted.Note: TSLCReg maintains the remaining number of scan lines minus one.%*-----------------------------------------------------------SendMaxMarg:* Send maximum margins to NLCB -- for blank scan lines.* Entry: TIOA[NLCB] or TIOA[TNLCB]* Exit: T = 0*-----------------------------------------------------------Subroutine;DontKnowRBase;	T&larr; AMaxMarg;	Output&larr; T;	T&larr; BMaxMarg;			* Does nothing if talking to DispM	T&larr; A0, Output&larr; T, Return;*-----------------------------------------------------------JamPtrAndNextCnt:* First, calculates the number of munches to send to the hardware,* loading ANextCount. The hardware reader pointer is updated and sent* to the hardware. Finally, the shadow reader pointer is updated for the* next entry into this subroutine.  Runs on behalf of AChannelRegion,* BChannelRegion, or TChannelRegion, depending on RBase.* Sets AReaderPtrReg, ANextCount. Destroys T.* Invariant for entry: AReaderPtrReg contains munch pointer into the fifo* for the Next scan line, and nothing else!!*-----------------------------------------------------------Subroutine;KnowRBase[AChannelRegion]; * or BChannelRegion, or TChannelRegion* first calculate next munch count for transfer. Calculation is*  NEW Word Pointer  - 1 + NWRDS.* Result in [8..11] is number of munches to transfer -1.	T&larr; (ANextAddrLo) AND (17C);	* get NEW word pointer	ANextCount&larr; T+(ANWrdsMinus1);	* set by DCB processing* merge WORD offset into fifo pointer and send to hardware	T&larr; (AReaderPtrReg)+T;		* word offset into RP	T&larr; T OR (APointer);	T&larr; T OR (AChannelReg);		* Select channel for NLCB command	T&larr; ANextCount, Output&larr; T;	* send reader pointer* now calculate update for reader pointer register (shadows hardware RP)	AReaderPtrReg&larr; (AReaderPtrReg)+T, Carry20;	AReaderPtrReg&larr; (AReaderPtrReg) AND (360C), Return;*-----------------------------------------------------------SetDisplayBRHi:* Sets the high part of the display BR for Alto terminal emulation* Entry: T = new BRHi value*-----------------------------------------------------------Subroutine;DontKnowRBase;	TBRHiReg&larr; T, Return;*-----------------------------------------------------------JLoadMiniMixer:* Loads the mininmixer with the identity for Alto emulation.* This is done ONCE in the beginning of the world. Users must be friendly enough* to reload MiniMixer as they exit from user code to Alto emulation code.* Entry: RBase[THTRegion].* Exit:	TIOA[MiniMixer]*	Clobbers T, TTemp0, TTemp1*-----------------------------------------------------------Subroutine;KnowRBase[THTRegion];* MiniMixer inputs are:*   0  Cursor*   1  AItem.0*   2  AItem.1*   3  AItem.2 OR Polarity*   4  AItem.3*   5  BItem.0*   6  AOn*   7  BOn* Desired output function is:*   IF ((Cursor OR AItem.0) XOR Polarity) = 1 THEN black ELSE white* where black = 0, white = 17B.* Note that all AItem.i are zero when AOn = 0 or i &gt;= item size.* Therefore, for Alto emulation we don't need to look at AOn at all; and* AItem.2 OR Polarity = Polarity.	TTemp1&larr; A0, TIOA[MiniMixer];	* address in 0..7, start with 0JamMMLoop:	T&larr; (TTemp1) LSH 1;	TTemp0&larr; (TTemp1) OR T;		* TTemp0.0&larr; AItem.0 OR Cursor	T&larr; LSH[TTemp1, 3];		* T.0&larr; Polarity	PD&larr; (TTemp0) XOR T;	T&larr; TTemp1, Branch[.+2, ALU&lt;0];	* Branch if black	T&larr; T OR (17C);			* White = 17B	TTemp1&larr; (TTemp1)+(400C);	Output&larr; T, Branch[JamMMLoop, ALU#0]; 	Return;TopLevel;:If[AltoMode];		********** Alto version ***********-----------------------------------------------------------SetDisplayConfigA:	* Alto Opcode 61032B* Set display mode to Alto emulation (AC0=0) or full screen (AC0=-1), and* return the number of words per scan line in AC0.*-----------------------------------------------------------TopLevel;Set[XTask, IP[EMU]];	Nop, At[SD400, 32];	RBase&larr; RBase[DisplayConfig];	T&larr; OR[177400, MaxWidthWordsAlto!]C, DisplayConfig,		Branch[RetConfig, R even];	* Branch if Alto monitor	Stack, Branch[.+2, R&lt;0];		* LF monitor, decide what to do* Switch to emulating an Alto monitor:	DisplayConfig&larr; (DisplayConfig) AND NOT (2C), Branch[.+3];* Switch to using the entire width of the LF monitor:	DisplayConfig&larr; (DisplayConfig) OR (2C);	T&larr; Or[177400, MaxWidthWordsLF!]C;* T has the new words/scanline, with 377 in the LH to signal DHT to reinitialize.	MaxWidthWords&larr; T;RetConfig:	Stack&larr; T AND (377C), IFUJump[0];:EndIf;			***********************************-----------------------------------------------------------SetDisplayFieldRate:* Emulator operation to adjust the vertical field rate* Enter: Stack[StkP] = total visible line count, including top and bottom border*	Stack[StkP-1] = top border*	Stack[StkP-2] = vertical sync* All counts are number of scan lines in the even field.* Exit: StkP&larr; StkP-3*-----------------------------------------------------------TopLevel;Set[XTask, IP[EMU]];	T&larr; Stack&amp;-1, RBase&larr; RBase[VisibleLineConst];	VisibleLineConst&larr; T;	TopBorderConst&larr; Stack&amp;-1;	VSyncConst&larr; Stack&amp;-1, IFUJump[0];</pre>
  </body>
</html>
