(FILECREATED "10-Jan-85 15:48:35" {ERIS}<LISPCORE>SOURCES>LLARITH.;15 143331Q      changes to:  (FNS GCD)      previous date: " 6-Jan-85 00:57:32" {ERIS}<LISPCORE>SOURCES>LLARITH.;14)(* Copyright (c) 1982, 1983, 1984, 1985 by Xerox Corporation. All rights reserved. The following program was created in 1982  but has not been published within the meaning of the copyright law, is furnished under license, and may not be used, copied and/or disclosed except in accordance with the terms of said license.)(PRETTYCOMPRINT LLARITHCOMS)(RPAQQ LLARITHCOMS [(LOCALVARS . T)	(COMS (* "OPCODES")	      (FNS IDIFFERENCE IGREATERP IQUOTIENT)	      (FNS \SLOWIPLUS2 \SLOWPLUS2 \SLOWIDIFFERENCE \SLOWDIFFERENCE \SLOWIGREATERP \SLOWLLSH1 		   \SLOWLLSH8 \SLOWLOGAND2 \SLOWLOGOR2 \SLOWLOGXOR2 \SLOWLRSH1 \SLOWLRSH8 		   \SLOWITIMES2 \SLOWTIMES2 \SLOWIQUOTIENT \SLOWQUOTIENT))	(COMS (* "IPLUS and IDIFFERENCE that smash result into their first arg")	      (FNS \BOXIPLUS \BOXIDIFFERENCE))	(* "subfunctions")	(FNS \MAKENUMBER)	(FNS OVERFLOW)	(INITVARS (\OVERFLOW 0))	(E (RESETSAVE (RADIX 8)))	(CONSTANTS (MAX.SMALLP 65535)		   (MIN.SMALLP -65536)		   (MAX.FIXP 2147483647)		   (MIN.FIXP -2147483648)		   (\SIGNBIT 32768))	(COMS (* "For Compatibility. Someday these two names should be flushed -- JonL 7/25/83")	      (CONSTANTS (MAX.INTEGER 2147483647)			 (MIN.INTEGER -2147483648)))	(FNS \GETBASEFIXP \PUTBASEFIXP \PUTBASEFIXP.UFN)	(EXPORT (DECLARE: DONTCOPY (RECORDS FIXP)			  (CONSTANTS (MAX.SMALL.INTEGER 65535)				     (MAX.POS.HINUM 32767))			  (MACROS .UNBOX. .NEGATE. .LLSH1. .LRSH1. .BOXIPLUS.)))	(FNS EQP FIX IQUOTIENT IREMAINDER LLSH LRSH LSH RSH)	(DECLARE: EVAL@COMPILE DONTCOPY (MACROS NBITS.OR.LESS .SUBSMALL. \IQUOTREM))	(* "Machine independent arithmetic functions")	(FNS MINUSP ILESSP IMINUS IPLUS ITIMES LOGAND LOGOR LOGXOR SUB1 ZEROP ADD1 GCD IEQP 	     INTEGERLENGTH)	(FNS ABS DIFFERENCE GREATERP PLUS QUOTIENT REMAINDER LESSP MINUS TIMES)	(FNS FMINUS FREMAINDER)	(FNS RANDSET RAND EXPT)	(DECLARE: DONTEVAL@LOAD DOCOPY (VARS (RANDSTATE)					     (\TOL 9.999992E-6)))	(GLOBALVARS RANDSTATE \TOL)	[COMS (FNS PutUnboxed \PUTFIXP \PUTSWAPPEDFIXP \HINUM \LONUM TRUNCATEMULTIPLY)	      (EXPORT (DECLARE: DONTCOPY (MACROS PutUnboxed]	(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS		  (ADDVARS (NLAMA)			   (NLAML)			   (LAMA TIMES PLUS LOGXOR LOGOR LOGAND ITIMES IPLUS])(DECLARE: DOEVAL@COMPILE DONTCOPY(LOCALVARS))(* "OPCODES")(DEFINEQ(IDIFFERENCE  [LAMBDA (X Y)                                              (* lmm "11-FEB-82 14:02")    ((OPCODES IDIFFERENCE)     X Y])(IGREATERP  [LAMBDA (X Y)                                              (* lmm "11-FEB-82 14:02")    ((OPCODES IGREATERP)     X Y])(IQUOTIENT  [LAMBDA (X Y)                                              (* lmm "11-FEB-82 14:02")    ((OPCODES IQUOTIENT)     X Y]))(DEFINEQ(\SLOWIPLUS2  [LAMBDA (X Y)                                              (* lmm " 2-Jul-84 17:10")    (\CALLME (QUOTE IPLUS))    (PROG (HX LX HY LY SIGNX)          (.UNBOX. X HX LX)          (.UNBOX. Y HY LY)          (SETQ SIGNX (IGREATERP HX MAX.POS.HINUM))          [SETQ HX (COND	      [(IGREATERP HX (IDIFFERENCE MAX.SMALL.INTEGER HY))		(IDIFFERENCE HX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER HY]	      (T (IPLUS HX HY]                               (* Add high parts)          [SETQ LX (COND	      [(IGREATERP LX (IDIFFERENCE MAX.SMALL.INTEGER LY))                                                             (* Carry into high part.)		[SETQ HX (COND		    ((EQ HX MAX.SMALL.INTEGER)		      0)		    (T (ADD1 HX]		(IDIFFERENCE LX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER LY]	      (T (IPLUS LX LY]          (COND	    ((AND (EQ SIGNX (IGREATERP HY MAX.POS.HINUM))		  (NEQ SIGNX (IGREATERP HX MAX.POS.HINUM)))                                                             (* overflow occurs if X and Y are same sign, but result 							     is opposite sign)	      (SELECTQ \OVERFLOW		       (T (LISPERROR "OVERFLOW" (\MAKENUMBER HX LX)))		       [NIL                                  (* return max/min)			    (RETURN (COND				      (SIGNX MIN.INTEGER)				      (T MAX.INTEGER]		       NIL)))          (RETURN (\MAKENUMBER HX LX])(\SLOWPLUS2  [LAMBDA (X Y)                                              (* lmm "21-Aug-84 16:20")                                                             (* UFN for PLUS Microcode generally handles the case of 							     two args both FIXPs)    (\CALLME (QUOTE PLUS))    (PROG NIL      LP  (RETURN (COND		    ((OR (FLOATP X)			 (FLOATP Y))		      (FPLUS X Y))		    ((NOT (FIXP X))		      (SETQ X (LISPERROR "NON-NUMERIC ARG" X T))		      (GO LP))		    ((NOT (FIXP Y))		      (SETQ Y (LISPERROR "NON-NUMERIC ARG" Y T))		      (GO LP))		    (T (IPLUS X Y])(\SLOWIDIFFERENCE  (LAMBDA (X Y)                                              (* JonL "27-Sep-84 22:59")    (\CALLME (QUOTE IDIFFERENCE))    (PROG (HX LX HY LY SIGNX)          (.UNBOX. X HX LX)          (.UNBOX. Y HY LY)                                  (* Allow this unboxing before the following test so 							     that error checking will be performed on Y)          (COND	    ((EQ Y 0)	      (RETURN (\MAKENUMBER HX LX))))          (.NEGATE. HY LY)          (SETQ SIGNX (IGREATERP HX MAX.POS.HINUM))          (COND	    ((COND		((AND (EQ 0 LY)		      (EQ HY \SIGNBIT))                      (* Y = -Y = Min.integer. Overflow occurs if X is 							     positive)		  (SETQ HX (LOGXOR HX HY))		  (NOT SIGNX))		(T (SETQ HX (COND		       ((IGREATERP HX (IDIFFERENCE MAX.SMALL.INTEGER HY))			 (IDIFFERENCE HX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER HY))))		       (T (IPLUS HX HY))))                   (* Add high parts)		   (SETQ LX (COND		       ((IGREATERP LX (IDIFFERENCE MAX.SMALL.INTEGER LY))                                                             (* Carry into high part.)			 (SETQ HX (COND			     ((EQ HX MAX.SMALL.INTEGER)			       0)			     (T (ADD1 HX))))			 (IDIFFERENCE LX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER LY))))		       (T (IPLUS LX LY))))                   (* overflow occurs if X and Y are same sign, but result							     is opposite sign)		   (AND (EQ SIGNX (IGREATERP HY MAX.POS.HINUM))			(NEQ SIGNX (IGREATERP HX MAX.POS.HINUM)))))	      (SELECTQ \OVERFLOW		       (T (LISPERROR "OVERFLOW" (\MAKENUMBER HX LX)))		       (NIL                                  (* return max/min)			    (RETURN (COND				      (SIGNX MIN.INTEGER)				      (T MAX.INTEGER))))		       NIL)))          (RETURN (\MAKENUMBER HX LX)))))(\SLOWDIFFERENCE  [LAMBDA (X Y)                                              (* lmm "21-Aug-84 16:21")                                                             (* UFN for DIFFERENCE Microcode generally handles the 							     case of two args both FIXPs)    (\CALLME (QUOTE DIFFERENCE))    (PROG NIL      LP  (RETURN (COND		    ((OR (FLOATP X)			 (FLOATP Y))		      (FDIFFERENCE X Y))		    ((NOT (FIXP X))		      (SETQ X (LISPERROR "NON-NUMERIC ARG" X T))		      (GO LP))		    ((NOT (FIXP Y))		      (SETQ Y (LISPERROR "NON-NUMERIC ARG" Y T))		      (GO LP))		    (T (IDIFFERENCE X Y])(\SLOWIGREATERP  [LAMBDA (X Y)                                              (* lmm " 2-Jul-84 17:10")    (\CALLME (QUOTE IGREATERP))    (PROG (HX LX HY LY)          (.UNBOX. X HX LX)          (.UNBOX. Y HY LY)          (RETURN (COND		    ((EQ HX HY)		      (IGREATERP LX LY))		    (T (IGREATERP (LOGXOR HX \SIGNBIT)				  (LOGXOR HY \SIGNBIT])(\SLOWLLSH1  [LAMBDA (X)                                                (* lmm "13-OCT-82 15:27")    (PROG (LO HI)          (.UNBOX. X HI LO)          (RETURN (\MAKENUMBER (IPLUS (LLSH (LOGAND HI 77777Q)					    1)				      (COND					((IGREATERP LO 77777Q)					  1)					(T 0)))			       (LLSH (LOGAND LO 77777Q)				     1])(\SLOWLLSH8  [LAMBDA (X)                                                (* lmm "13-OCT-82 15:28")    (PROG (HI LO)          (.UNBOX. X HI LO)          (RETURN (\MAKENUMBER (IPLUS (LLSH (LOGAND HI 377Q)					    10Q)				      (LRSH LO 10Q))			       (LLSH (LOGAND LO 377Q)				     10Q])(\SLOWLOGAND2  [LAMBDA (A B)                                              (* lmm " 2-Jul-84 17:11")    (\CALLME (QUOTE LOGAND))    (PROG (AH AL BH BL)          (.UNBOX. A AH AL)          (.UNBOX. B BH BL)          (RETURN (\MAKENUMBER (LOGAND AH BH)			       (LOGAND AL BL])(\SLOWLOGOR2  [LAMBDA (A B)                                              (* lmm " 2-Jul-84 17:11")    (\CALLME (QUOTE LOGOR))    (PROG (AH AL BH BL)          (.UNBOX. A AH AL)          (.UNBOX. B BH BL)          (RETURN (\MAKENUMBER (LOGOR AH BH)			       (LOGOR AL BL])(\SLOWLOGXOR2  [LAMBDA (A B)                                              (* lmm " 2-Jul-84 17:11")    (\CALLME (QUOTE LOGXOR))    (PROG (AH AL BH BL)          (.UNBOX. A AH AL)          (.UNBOX. B BH BL)          (RETURN (\MAKENUMBER (LOGXOR AH BH)			       (LOGXOR AL BL])(\SLOWLRSH1  (LAMBDA (X)                                                (* JonL "27-Sep-84 22:59")    (PROG (HI LO)          (.UNBOX. X HI LO)          (RETURN (\MAKENUMBER (LRSH HI 1)			       (IPLUS (LRSH LO 1)				      (COND					((EQ 0 (LOGAND HI 1))					  0)					(T 32768))))))))(\SLOWLRSH8  [LAMBDA (X)                                                (* lmm "13-OCT-82 15:29")    (PROG (HI LO)          (.UNBOX. X HI LO)          (RETURN (\MAKENUMBER (LRSH HI 10Q)			       (IPLUS (LLSH (LOGAND HI 377Q)					    10Q)				      (LRSH LO 10Q])(\SLOWITIMES2  (LAMBDA (X Y)                                              (* JonL "27-Sep-84 22:59")    (\CALLME (QUOTE ITIMES))    (COND      ((OR (EQ X 0)	   (EQ Y 0))	0)      (T (PROG (HX HY LX LY SIGN (HR 0)		   (LR 0)		   CARRY)	       (.UNBOX. X HX LX)	       (.UNBOX. Y HY LY)	       (COND		 ((IGREATERP HX MAX.POS.HINUM)		   (.NEGATE. HX LX)		   (SETQ SIGN T)))	       (COND		 ((IGREATERP HY MAX.POS.HINUM)		   (.NEGATE. HY LY)		   (SETQ SIGN (NOT SIGN))))	       (COND		 ((NEQ HY 0)		   (COND		     ((NEQ HX 0)		       (GO OVER)))		   (swap LX LY)		   (swap HX HY)))	   MLP (COND		 ((ODDP (PROG1 LY (SETQ LY (LRSH LY 1))))		   (COND		     ((IGREATERP LR (IDIFFERENCE MAX.SMALL.INTEGER LX))                                                             (* low parts overflow)                                                             (* make the low word be the less significant bits and 							     return the carry.)		       (SETQ LR (IDIFFERENCE LR (IDIFFERENCE MAX.SMALL.INTEGER (SUB1 LX))))		       (SETQ CARRY 1))		     (T                                      (* no carry just add the low halves.)			(SETQ LR (IPLUS LR LX))			(SETQ CARRY 0)))          (* the low order part of the answer has been set and CARRY is the numeric value of the carry from the low part 	  either 0 or 1)		   (COND		     ((IGREATERP (SETQ HR (IPLUS HR HX CARRY))				 MAX.POS.HINUM)		       (COND			 ((AND (EQ LY 0)			       SIGN			       (EQ HR (ADD1 MAX.POS.HINUM))			       (EQ LR 0))			   (RETURN MIN.INTEGER)))		       (GO OVER)))))	       (COND		 ((EQ 0 LY)		   (GO RET)))	       (COND		 ((IGEQ HX (LRSH (ADD1 MAX.POS.HINUM)				 1))		   (GO OVERTEST)))	       (.LLSH1. HX LX)	       (GO MLP)	   OVERTEST	       (COND		 ((AND (EQ HX (LRSH (ADD1 MAX.POS.HINUM)				    1))		       (EQ 0 LX)		       SIGN		       (EQ LY 1)		       (EQ HR 0)		       (EQ LR 0))                            (* odd special case)		   (RETURN MIN.INTEGER)))	   OVER(SELECTQ \OVERFLOW			(T (LISPERROR "OVERFLOW" (\MAKENUMBER HR LR)))			(NIL (RETURN (COND				       ((NULL SIGN)					 MAX.INTEGER)				       (T MIN.INTEGER))))			(PROGN                               (* truncate -							     this is awful code, but it works)			       (RETURN (TRUNCATEMULTIPLY X Y))))	   RET (COND		 (SIGN (.NEGATE. HR LR)))	       (RETURN (\MAKENUMBER HR LR)))))))(\SLOWTIMES2  [LAMBDA (X Y)                                              (* lmm "21-Aug-84 16:22")                                                             (* UFN for TIMES Microcode generally handles the case of							     two args both FIXPs)    (\CALLME (QUOTE TIMES))    (PROG NIL      LP  (RETURN (COND		    ((OR (FLOATP X)			 (FLOATP Y))		      (FTIMES X Y))		    ((NOT (FIXP X))		      (SETQ X (LISPERROR "NON-NUMERIC ARG" X T))		      (GO LP))		    ((NOT (FIXP Y))		      (SETQ Y (LISPERROR "NON-NUMERIC ARG" Y T))		      (GO LP))		    (T (ITIMES X Y])(\SLOWIQUOTIENT  [LAMBDA (X Y)                                              (* lmm " 2-Jul-84 17:12")    (\CALLME (QUOTE IQUOTIENT))    (\IQUOTREM X Y X)    X])(\SLOWQUOTIENT  [LAMBDA (X Y)                                              (* lmm "21-Aug-84 16:22")                                                             (* UFN for QUOTIENT Microcode generally handles the case							     of two args both FIXPs)    (\CALLME (QUOTE QUOTIENT))    (PROG NIL      LP  (RETURN (COND		    ((OR (FLOATP X)			 (FLOATP Y))		      (FQUOTIENT X Y))		    ((NOT (FIXP X))		      (SETQ X (LISPERROR "NON-NUMERIC ARG" X T))		      (GO LP))		    ((NOT (FIXP Y))		      (SETQ Y (LISPERROR "NON-NUMERIC ARG" Y T))		      (GO LP))		    (T (IQUOTIENT X Y]))(* "IPLUS and IDIFFERENCE that smash result into their first arg")(DEFINEQ(\BOXIPLUS  [LAMBDA (X Y)                                              (* lmm " 8-Aug-84 11:49")                                                             (* UFN for BOXIPLUS ipcode)    (.BOXIPLUS. X Y])(\BOXIDIFFERENCE  [LAMBDA (X Y)                                              (* lmm " 8-Aug-84 11:49")    (PROG ((HX (\GETBASE X 0))	   (LX (\GETBASE X 1))	   HY LY)          (.UNBOX. Y HY LY)          (.NEGATE. HY LY)          [SETQ HX (COND	      [(IGREATERP HX (IDIFFERENCE MAX.SMALL.INTEGER HY))		(IDIFFERENCE HX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER HY]	      (T (IPLUS HX HY]                               (* Add high parts)          [\PUTBASE X 1 (COND		      [(IGREATERP LX (IDIFFERENCE MAX.SMALL.INTEGER LY))                                                             (* Carry into high part.)			[SETQ HX (COND			    ((EQ HX MAX.SMALL.INTEGER)			      0)			    (T (ADD1 HX]			(IDIFFERENCE LX (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER LY]		      (T (IPLUS LX LY]          (\PUTBASE X 0 HX)          (RETURN X]))(* "subfunctions")(DEFINEQ(\MAKENUMBER  (LAMBDA (N0 N1)                                            (* JonL " 1-Jan-84 00:11")                                                             (* used as punt case for arith opcodes which create 							     large numbers)    (SETQ N1 (.COERCE.TO.SMALLPOSP. N1))    (SELECTC (SETQ N0 (.COERCE.TO.SMALLPOSP. N0))	     (0 N1)	     (65535                                          (* This is a word's worth of 1 bits)		    (\VAG2 \SmallNegHi N1))	     (create FIXP		     HINUM _ N0		     LONUM _ N1)))))(DEFINEQ(OVERFLOW  [LAMBDA (FLG)                    (* lmm: 14-JAN-76 1 6)    (PROG1 \OVERFLOW (SETQ \OVERFLOW (SELECTQ FLG					      (NIL NIL)					      (T T)					      0]))(RPAQ? \OVERFLOW 0)(DECLARE: EVAL@COMPILE (RPAQQ MAX.SMALLP 177777Q)(RPAQQ MIN.SMALLP -200000Q)(RPAQQ MAX.FIXP 17777777777Q)(RPAQQ MIN.FIXP -20000000000Q)(RPAQQ \SIGNBIT 100000Q)(CONSTANTS (MAX.SMALLP 177777Q)	   (MIN.SMALLP -200000Q)	   (MAX.FIXP 17777777777Q)	   (MIN.FIXP -20000000000Q)	   (\SIGNBIT 100000Q)))(* "For Compatibility. Someday these two names should be flushed -- JonL 7/25/83")(DECLARE: EVAL@COMPILE (RPAQQ MAX.INTEGER 17777777777Q)(RPAQQ MIN.INTEGER -20000000000Q)(CONSTANTS (MAX.INTEGER 17777777777Q)	   (MIN.INTEGER -20000000000Q)))(DEFINEQ(\GETBASEFIXP  [LAMBDA (BASE OFFST)                                       (* lmm " 5-Jan-85 23:11")    ([LAMBDA (\NewBaseAddr)	(\MAKENUMBER (\GETBASE \NewBaseAddr 0)		     (\GETBASE \NewBaseAddr 1]      (\ADDBASE BASE OFFST])(\PUTBASEFIXP  [LAMBDA (BASE OFFST VAL)                                   (* lmm " 5-Jan-85 23:16")    (PROG (HI LO)          (.XUNBOX. VAL HI LO)          (\PUTBASE BASE OFFST HI)          (\PUTBASE BASE (ADD1 OFFST)		    LO)      VAL (RETURN VAL])(\PUTBASEFIXP.UFN  [LAMBDA (BASE VAL OFFST)                                   (* lmm " 5-Jan-85 23:25")    (PROG (HI LO)          (.XUNBOX. VAL HI LO)          (\PUTBASE BASE OFFST HI)          (\PUTBASE BASE (ADD1 OFFST)		    LO)      VAL (RETURN VAL]))(* FOLLOWING DEFINITIONS EXPORTED)(DECLARE: DONTCOPY [DECLARE: EVAL@COMPILE (BLOCKRECORD FIXP ((HINUM WORD)		   (LONUM WORD))		  (CREATE (CREATECELL \FIXP))		  (TYPE? (EQ (NTYPX DATUM)			     \FIXP)))](DECLARE: EVAL@COMPILE (RPAQQ MAX.SMALL.INTEGER 177777Q)(RPAQQ MAX.POS.HINUM 77777Q)(CONSTANTS (MAX.SMALL.INTEGER 177777Q)	   (MAX.POS.HINUM 77777Q)))(DECLARE: EVAL@COMPILE (PUTPROPS .UNBOX. MACRO [(V HV LV)			 (PROG NIL			   UBLP(SELECTC (NTYPX V)					(\FIXP (SETQ HV (fetch (FIXP HINUM) of V))					       (SETQ LV (fetch (FIXP LONUM) of V)))					[\SMALLP (COND						   ((IGEQ V 0)						     (SETQ HV 0)						     (SETQ LV V))						   (T (SETQ HV 177777Q)						      (SETQ LV (LOLOC V]					(\FLOATP (SETQ V (\FIXP.FROM.FLOATP V))						 (GO UBLP))					(PROGN (SETQ V (LISPERROR "NON-NUMERIC ARG" V))					       (GO UBLP])(PUTPROPS .NEGATE. MACRO [(HY LY)			  (COND			    [(EQ 0 LY)			      (AND (NEQ HY 0)				   (SETQ HY (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER HY]			    (T (SETQ HY (IDIFFERENCE MAX.SMALL.INTEGER HY))			       (SETQ LY (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER LY])(PUTPROPS .LLSH1. MACRO ((HI LO)                             (* shift the pair left one, assuming no overflow)			 (SETQ HI (LLSH HI 1))			 (SETQ LO (LLSH (COND					  ((IGREATERP LO MAX.POS.HINUM)					    (add HI 1)					    (LOGAND LO MAX.POS.HINUM))					  (T LO))					1))))(PUTPROPS .LRSH1. MACRO ((HI LO)			 (SETQ LO (LRSH LO 1))			 [COND			   ((NEQ (LOGAND HI 1)				 0)			     (SETQ LO (IPLUS LO \SIGNBIT]			 (SETQ HI (LRSH HI 1))))(PUTPROPS .BOXIPLUS. MACRO (OPENLAMBDA (X Y)				       (PROG ((HX (\GETBASE X 0))					      (LX (\GETBASE X 1))					      HY LY)					     (.UNBOX. Y HY LY)					     [SETQ HX (COND						 [(IGREATERP HX (IDIFFERENCE MAX.SMALL.INTEGER HY))						   (IDIFFERENCE HX (ADD1 (IDIFFERENCE 										MAX.SMALL.INTEGER HY]						 (T (IPLUS HX HY]                                                             (* Add high parts)					     [\PUTBASE X 1 (COND							 [(IGREATERP LX (IDIFFERENCE 										MAX.SMALL.INTEGER LY))                                                             (* Carry into high part.)							   [SETQ HX (COND							       ((EQ HX MAX.SMALL.INTEGER)								 0)							       (T (ADD1 HX]							   (IDIFFERENCE LX (ADD1 (IDIFFERENCE 										MAX.SMALL.INTEGER LY]							 (T (IPLUS LX LY]					     (\PUTBASE X 0 HX)					     (RETURN X))))))(* END EXPORTED DEFINITIONS)(DEFINEQ(EQP  [LAMBDA (X Y)                                              (* lmm "21-JAN-82 08:20")    (COND      ((EQ X Y))      [(AND (NUMBERP X)	    (NUMBERP Y))	(COND	  ((OR (FLOATP X)	       (FLOATP Y))	    (FEQP X Y))	  (T (IEQP X Y]      ((EQ (NTYPX X)	   (NTYPX Y))	(SELECTC (NTYPX X)		 (\STACKP (EQ (fetch (STACKP EDFXP) of X)			      (fetch (STACKP EDFXP) of Y)))		 (\ARRAYP (AND (EQ (fetch (ARRAYP TYP) of X)				   \ST.CODE)			       (EQDEFP X Y)))		 NIL))      (T NIL])(FIX  [LAMBDA (N)                      (* lmm "18-APR-80 18:08")                                   (* FIX compiles open)    (IPLUS N 0])(IQUOTIENT  [LAMBDA (X Y)                                              (* lmm "11-FEB-82 14:02")    ((OPCODES IQUOTIENT)     X Y])(IREMAINDER  [LAMBDA (X Y)                                              (* edited: "29-APR-82 05:01")    (\IQUOTREM X Y NIL Y)    Y])(LLSH  [LAMBDA (X N)                                              (* lmm "13-OCT-82 15:30")    (COND      ((IGREATERP 0 N)	(LRSH X (IMINUS N)))      (T (PROG (XHI XLO)	       (.UNBOX. X XHI XLO)	       (COND		 ((IGREATERP N 37Q)		   (RETURN 0)))	       [COND		 ((IGREATERP N 17Q)		   (SETQ XHI XLO)		   (SETQ XLO 0)		   (SETQ N (IDIFFERENCE N 20Q]	       [COND		 ((IGREATERP N 7)		   (SETQ XHI (IPLUS (LLSH (LOGAND XHI 377Q)					  10Q)				    (LRSH XLO 10Q)))		   (SETQ XLO (LLSH (LOGAND XLO 377Q)				   10Q))		   (SETQ N (IDIFFERENCE N 10Q]	       (FRPTQ N (SETQ XHI (LOGAND XHI MAX.POS.HINUM))		      (.LLSH1. XHI XLO))	       (RETURN (\MAKENUMBER XHI XLO])(LRSH  [LAMBDA (X N)                                              (* lmm "13-OCT-82 15:30")                                                             (* assumes case where n is constant and 10Q or 1 handled							     in microcode or by \SLOWLRSHn)    (COND      ((IGREATERP 0 N)	(LLSH X (IMINUS N)))      (T (PROG (XHI XLO)	       (.UNBOX. X XHI XLO)	       (COND		 ((IGREATERP N 37Q)		   (RETURN 0)))	       [COND		 ((IGREATERP N 17Q)		   (SETQ XLO XHI)		   (SETQ XHI 0)		   (SETQ N (IDIFFERENCE N 20Q]	       [COND		 ((IGREATERP N 7)		   (SETQ XLO (IPLUS (LRSH XLO 10Q)				    (LLSH (LOGAND XHI 377Q)					  10Q)))		   (SETQ XHI (LRSH XHI 10Q))		   (SETQ N (IDIFFERENCE N 10Q]	       (FRPTQ N (.LRSH1. XHI XLO))	       (RETURN (\MAKENUMBER XHI XLO])(LSH  (LAMBDA (X N)                                              (* JonL "27-Sep-84 23:00")    (COND      ((ILEQ N 0)	(COND	  ((EQ N 0)	    X)	  (T (RSH X (IMINUS N)))))      ((IGREATERP N (CONSTANT (DIFFERENCE (TIMES 2 BITSPERWORD)					  2)))               (* Shifting more than the non-sign bits just returns 							     the sign bit)	(COND	  ((MINUSP X)                                        (* X was negative)	    (AND (EQ \OVERFLOW T)		 (NEQ X -1)		 (LISPERROR "OVERFLOW" (CONSTANT MIN.INTEGER)))	    (CONSTANT MIN.INTEGER))	  (T (AND (EQ \OVERFLOW T)		  (NEQ X 0)		  (LISPERROR "OVERFLOW" 0))	     0)))      (T (PROG (XHI XLO (XSIGNBIT 0))	       (.UNBOX. X XHI XLO)	       (COND		 ((IGEQ XHI \SIGNBIT)		   (SETQ XSIGNBIT \SIGNBIT)))	       (COND		 ((IGEQ N (CONSTANT BITSPERWORD))		   (AND (EQ \OVERFLOW T)			(COND			  ((EQ XSIGNBIT 0)			    (OR (NEQ XHI 0)				(NEQ (LOGAND XLO \SIGNBIT)				     0)))			  (T (OR (NEQ XHI MAX.SMALL.INTEGER)				 (EQ (LOGAND XLO \SIGNBIT)				     0))))			(LISPERROR "OVERFLOW" X))		   (SETQ XHI XLO)		   (SETQ XLO 0)		   (SETQ N (IDIFFERENCE N (CONSTANT BITSPERWORD)))))                                                             (* N must be less than BITSPERWORD, i.e. 16, now)	       (COND		 ((IGREATERP N 7)		   (PROGN (AND (EQ \OVERFLOW T)			       (NEQ (LOGAND XHI 77400Q)				    (COND				      ((NEQ XSIGNBIT 0)					77400Q)				      (T 0)))			       (LISPERROR "OVERFLOW" X))			  (SETQ XHI (LOGOR (LLSH XHI 10Q)					   (LRSH XLO 10Q)))			  (SETQ XLO (LLSH (LOGAND XLO 377Q)					  10Q))			  (SETQ N (IDIFFERENCE N 10Q)))))	       (FRPTQ N (AND (EQ \OVERFLOW T)			     (COND			       ((EQ 0 (LOGAND XHI 40000Q))				 (NEQ XSIGNBIT 0))			       (T (EQ XSIGNBIT 0)))			     (LISPERROR "OVERFLOW" X))		      (SETQ XHI (COND			  ((EQ 0 (LOGAND XLO \SIGNBIT))			    (LLSH XHI 1))			  (T                                 (* Flush the high-order bit, so subsequent LSH of XLO 							     won't overflow the SMALLP range)			     (SETQ XLO (LOGXOR XLO \SIGNBIT))			     (LOGOR (LLSH XHI 1)				    1))))		      (SETQ XLO (LLSH XLO 1)))	       (SETQ XHI (LOGOR XSIGNBIT (LOGAND XHI MAX.POS.HINUM)))	       (RETURN (\MAKENUMBER XHI XLO)))))))(RSH  (LAMBDA (X N)                                              (* JonL "27-Sep-84 23:00")    (COND      ((IGREATERP 0 N)	(LSH X (IMINUS N)))      (T (PROG (XHI XLO)	       (.UNBOX. X XHI XLO)	       (COND		 ((IGREATERP N 37Q)		   (RETURN (COND			     ((IGREATERP XHI 77777Q)         (* X WAS NEGATIVE)			       -1)			     (T 0)))))	       (COND		 ((IGREATERP N 17Q)		   (SETQ XLO XHI)		   (SETQ XHI (COND		       ((IGREATERP XHI 77777Q)			 177777Q)		       (T 0)))		   (SETQ N (IDIFFERENCE N 20Q))))	       (COND		 ((IGREATERP N 7)		   (SETQ XLO (IPLUS (LRSH XLO 10Q)				    (LLSH (LOGAND XHI 377Q)					  10Q)))		   (SETQ XHI (IPLUS (LRSH XHI 10Q)				    (COND				      ((IGREATERP XHI 77777Q)					177400Q)				      (T 0))))		   (SETQ N (IDIFFERENCE N 10Q))))	       (FRPTQ N (SETQ XLO (IPLUS (LRSH XLO 1)					 (COND					   ((EQ 0 (LOGAND XHI 1))					     0)					   (T 100000Q))))		      (SETQ XHI (IPLUS (LRSH XHI 1)				       (LOGAND XHI 100000Q))))	       (RETURN (\MAKENUMBER XHI XLO))))))))(DECLARE: EVAL@COMPILE DONTCOPY (DECLARE: EVAL@COMPILE (PUTPROPS NBITS.OR.LESS MACRO [(X N)			       (ILESSP X (CONSTANT (LLSH 1 N])(PUTPROPS .SUBSMALL. MACRO ((X Y)                            (* Subtract Y from X, returning the borrow out of the 							     next word)			    (COND			      ((ILEQ Y X)				(SETQ X (IDIFFERENCE X Y))				0)			      (T [SETQ X (ADD1 (IDIFFERENCE MAX.SMALL.INTEGER (IDIFFERENCE Y X]				 1))))(PUTPROPS \IQUOTREM MACRO ((X Y QUO REM)			   (PROG (HX LX HY LY SIGNQUOTIENT SIGNREMAINDER (CNT 0)				     (HZ 0)				     (LZ 0))			         (.UNBOX. X HX LX)			         (.UNBOX. Y HY LY)			         [COND				   ((IGREATERP HX MAX.POS.HINUM)				     (.NEGATE. HX LX)				     (SETQ SIGNQUOTIENT (SETQ SIGNREMAINDER T]                                                             (* Remainder has sign of dividend)			         [COND				   ((IGREATERP HY MAX.POS.HINUM)				     (.NEGATE. HY LY)				     (SETQ SIGNQUOTIENT (NOT SIGNQUOTIENT]			         (COND				   ((NEQ HX 0)				     (GO BIGDIVIDEND))				   ((NEQ HY 0)               (* Y is big, X is small, so result is 0)				     (GO DONE))				   ((EQ 0 LX)				     (GO RET0))				   ((EQ 0 LY)				     (GO DIVZERO))				   ((EQ LY 1)				     (SETQ LZ LX)				     (SETQ LX 0)				     (GO DONE)))             (* here we are dividing small X by small Y, and we know							     Y gt 1)			     LP1                             (* shift Y left until it is as big as X, and count how 							     many times)			         (COND				   ((AND (ILESSP LY LX)					 (ILEQ LY MAX.POS.HINUM))				     (SETQ LY (LLSH LY 1))				     (SETQ CNT (ADD1 CNT))				     (GO LP1)))			     LP2                             (* now start dividing Y into X by subtracting and 							     shifting, ending up with Y shifted back where it 							     started)			         [COND				   ((ILEQ LY LX)				     (SETQ LX (IDIFFERENCE LX LY))                                                             (* Y divides X once, so add bit into quotient)				     (SETQ LZ (ADD1 LZ]			         (SETQ LY (LRSH LY 1))			         (SETQ CNT (SUB1 CNT))			         (COND				   ((IGEQ CNT 0)				     (SETQ LZ (LLSH LZ 1))				     (GO LP2)))			         (GO DONE)			     BIGDIVIDEND                     (* X is big, so result may be big.							     Algorithm is same as above, but everything is doubled 							     in length)			         [COND				   ((EQ 0 HY)				     [COND				       ((EQ 0 (SETQ HY LY))					 (GO DIVZERO))				       ((AND SIGNREMAINDER (NULL SIGNQUOTIENT)					     (EQ 1 LY)					     (EQ HX \SIGNBIT)					     (EQ 0 LX))      (* Means that X is MIN.FIXP and Y is -1)					 (SELECTQ \OVERFLOW						  (T (ERROR "DIVISION OVERFLOW" Y))						  (GO RET0]				     (SETQ LY 0)				     (SETQ CNT 20Q))				   ((AND SIGNREMAINDER (NULL SIGNQUOTIENT)					 (EQ 0 LX)					 (EQ HX \SIGNBIT)					 (EQ 0 HY)					 (EQ 1 LY))          (* Means that X is MIN.FIXP and Y is -1)				     (SELECTQ \OVERFLOW					      (T (ERROR "DIVISION OVERFLOW" Y))					      (GO RET0]			     BIGLP			         (COND				   ((AND (OR (AND (EQ HY HX)						  (ILESSP LY LX))					     (ILESSP HY HX))					 (ILESSP HY MAX.POS.HINUM))				     (.LLSH1. HY LY)				     (SETQ CNT (ADD1 CNT))				     (GO BIGLP)))			     BIGLP2			         (COND				   ((OR (ILESSP HY HX)					(AND (EQ HY HX)					     (ILEQ LY LX)))                                                             (* Y divides X, so subtract Y from X and put a bit in 							     quotient)				     (SETQ HX (IDIFFERENCE (IDIFFERENCE HX HY)							   (.SUBSMALL. LX LY)))				     (SETQ LZ (ADD1 LZ))     (* note that this never overflows, because of the 							     preceding left shift)				     ))			         (.LRSH1. HY LY)			         (SETQ CNT (SUB1 CNT))			         (COND				   ((IGEQ CNT 0)				     (.LLSH1. HZ LZ)				     (GO BIGLP2)))			     DONE[COND				   (REM                      (* remainder is left in X)					(COND					  (SIGNREMAINDER (.NEGATE. HX LX)))					(SETQ REM (\MAKENUMBER HX LX]			         [COND				   (QUO (COND					  (SIGNQUOTIENT (.NEGATE. HZ LZ)))					(SETQ QUO (\MAKENUMBER HZ LZ]			         (RETURN)			     DIVZERO			         (SELECTQ \OVERFLOW					  (T (ERROR "DIVIDE BY ZERO" Y))					  (GO RET0))			     RET0(COND				   (REM (SETQ REM 0)))			         (COND				   (QUO (SETQ QUO 0)))			         (RETURN))))))(* "Machine independent arithmetic functions")(DEFINEQ(MINUSP  [LAMBDA (X)                      (* lmm "17-DEC-80 20:56")    (COND      ((FLOATP X)	(FGREATERP 0.0 X))      (T (IGREATERP 0 X])(ILESSP  [LAMBDA (X Y)    (IGREATERP Y X])(IMINUS  [LAMBDA (X)    (IDIFFERENCE 0 X])(IPLUS  [LAMBDA N                                                  (* lmm " 2-MAR-82 10:05")                                                             (* called only by interpreted code -							     this defn relies on fact that compiler turns IPLUS calls							     into sequences of opcodes)    (SELECTQ N	     (2 (IPLUS (ARG N 1)		       (ARG N 2)))	     (1 (IPLUS (ARG N 1)))	     (0 (IPLUS))	     (PROG ((R (IPLUS (ARG N 1)			      (ARG N 2)			      (ARG N 3)))		    (J 4))	       LP  (COND		     ((ILEQ J N)		       (SETQ R (IPLUS R (ARG N J)))		       (SETQ J (ADD1 J))		       (GO LP)))	           (RETURN R])(ITIMES  [LAMBDA N                                                  (* lmm " 2-MAR-82 10:05")                                                             (* called only by interpreted code -							     this defn relies on fact that compiler turns ITIMES 							     calls into sequences of opcodes)    (SELECTQ N	     (2 (ITIMES (ARG N 1)			(ARG N 2)))	     (1 (ITIMES (ARG N 1)))	     (0 (ITIMES))	     (PROG ((R (ITIMES (ARG N 1)			       (ARG N 2)			       (ARG N 3)))		    (J 4))	       LP  (COND		     ((ILEQ J N)		       (SETQ R (ITIMES R (ARG N J)))		       (SETQ J (ADD1 J))		       (GO LP)))	           (RETURN R])(LOGAND  [LAMBDA N                                                  (* lmm " 2-MAR-82 10:05")                                                             (* called only by interpreted code -							     this defn relies on fact that compiler turns LOGAND 							     calls into sequences of opcodes)    (SELECTQ N	     (2 (LOGAND (ARG N 1)			(ARG N 2)))	     (1 (LOGAND (ARG N 1)))	     (0 (LOGAND))	     (PROG ((R (LOGAND (ARG N 1)			       (ARG N 2)			       (ARG N 3)))		    (J 4))	       LP  (COND		     ((ILEQ J N)		       (SETQ R (LOGAND R (ARG N J)))		       (SETQ J (ADD1 J))		       (GO LP)))	           (RETURN R])(LOGOR  [LAMBDA N                                                  (* lmm " 2-MAR-82 10:05")                                                             (* called only by interpreted code -							     this defn relies on fact that compiler turns LOGOR calls							     into sequences of opcodes)    (SELECTQ N	     (2 (LOGOR (ARG N 1)		       (ARG N 2)))	     (1 (LOGOR (ARG N 1)))	     (0 (LOGOR))	     (PROG ((R (LOGOR (ARG N 1)			      (ARG N 2)			      (ARG N 3)))		    (J 4))	       LP  (COND		     ((ILEQ J N)		       (SETQ R (LOGOR R (ARG N J)))		       (SETQ J (ADD1 J))		       (GO LP)))	           (RETURN R])(LOGXOR  [LAMBDA N                                                  (* lmm " 2-MAR-82 10:05")                                                             (* called only by interpreted code -							     this defn relies on fact that compiler turns LOGXOR 							     calls into sequences of opcodes)    (SELECTQ N	     (2 (LOGXOR (ARG N 1)			(ARG N 2)))	     (1 (LOGXOR (ARG N 1)))	     (0 (LOGXOR))	     (PROG ((R (LOGXOR (ARG N 1)			       (ARG N 2)			       (ARG N 3)))		    (J 4))	       LP  (COND		     ((ILEQ J N)		       (SETQ R (LOGXOR R (ARG N J)))		       (SETQ J (ADD1 J))		       (GO LP)))	           (RETURN R])(SUB1  [LAMBDA (X)                      (* lmm " 5-MAR-80 23:07")    (IDIFFERENCE X 1])(ZEROP  (LAMBDA (X)                                                (* JonL "27-Sep-84 22:54")    (\MACRO.MX (ZEROP X))))(ADD1  [LAMBDA (X)    (IPLUS X 1])(GCD  [LAMBDA (N1 N2)                                            (* jds "10-Jan-85 15:42")                                                             (* Greatest common divisor, using Euler's Method)    (COND      ((EQ 0 N2)	N1)      ((MINUSP N2)                                           (* GCD is always positive)	(GCD (MINUS N2)	     N1))      (T (GCD N2 (IREMAINDER N1 N2])(IEQP  (LAMBDA (X Y)                                              (* JonL " 1-May-84 22:23")    (EQ 0 (IDIFFERENCE X Y))))(INTEGERLENGTH  (LAMBDA (X)                                                (* JonL "18-OCT-82 21:51")    (SELECTQ (SYSTEMTYPE)	     (D                                              (* Foo, INTEGERLENGTH currently "boxes" on negative 							     arguments)		(SELECTC (NTYPX X)			 (\SMALLP (COND				    ((ILESSP X 0)				      (SETQ X (MINUS X))))				  (COND				    ((NBITS.OR.LESS X 20Q)				      (COND					((NBITS.OR.LESS X 10Q)					  (COND					    ((NBITS.OR.LESS X 4)					      (COND						((NBITS.OR.LESS X 2)						  (COND						    ((NBITS.OR.LESS X 1)						      (COND							((EQ X 0)							  0)							(T 1)))						    (T 2)))						((NBITS.OR.LESS X 3)						  3)						(T 4)))					    ((NBITS.OR.LESS X 6)					      (COND						((NBITS.OR.LESS X 5)						  5)						(T 6)))					    ((NBITS.OR.LESS X 7)					      7)					    (T 10Q)))					((NBITS.OR.LESS X 14Q)					  (COND					    ((NBITS.OR.LESS X 12Q)					      (COND						((NBITS.OR.LESS X 11Q)						  11Q)						(T 12Q)))					    ((NBITS.OR.LESS X 13Q)					      13Q)					    (T 14Q)))					((NBITS.OR.LESS X 16Q)					  (COND					    ((NBITS.OR.LESS X 15Q)					      15Q)					    (T 16Q)))					((NBITS.OR.LESS X 17Q)					  17Q)					(T 20Q)))				    (T (SHOULDNT))))			 (\FIXP (PROG ((HX (fetch (FIXP HINUM) of X)))				      (if (IGREATERP HX MAX.POS.HINUM)					  then               (* So X is negative)					       ((LAMBDA (LX)						   (if (AND (EQ HX \SIGNBIT)							    (EQ LX 0))						       then                                                              (* So X is EQP to the minimum FIXP integer)							    (RETURN (CONSTANT BITS.PER.FIXP))						     else (.NEGATE. HX LX)))						 (fetch (FIXP LONUM) of X)))				      (RETURN (if (EQ HX 0)						  then           (* This bizarre case shouldn't really happen, but I wouldn't like to rule it out -- a non-normalized FIXP that 	  realy should be a SMALLP)						       (INTEGERLENGTH (fetch (FIXP LONUM)									 of X))						else (IPLUS (INTEGERLENGTH HX)							    BITSPERWORD)))))			 (PROGN           (* Someday we'd like (COND ((OPEN-BIGNUMP X) (SETQ X (BNDS X)) (LET* ((N (SUB1 (BNDS-LENGTH X))) 	  (HIGH-DIGIT (BNDS-REF X N))) (IPLUS (INTEGERLENGTH HIGH-DIGIT) (ITIMES (CONSTANT BIGNUMDIGIT.LENGTH) N))))))				(INTEGERLENGTH (FIX X)))))	     (PROG ((LEN (CONSTANT (LRSH (SUB1 BITS.PER.FIXP)					 1)))		    (BIT (CONSTANT (LLSH 1 (LRSH (SUB1 BITS.PER.FIXP)						 1))))		    (SHIFTER (CONSTANT (LLSH 1 (SUB1 (LRSH (SUB1 BITS.PER.FIXP)							   1)))))		    (ONEUP 0))                               (* 'len' IS LENGTH OF FIRST TRIAL 'bit')                                                             (* 'shifter' IS amount by which to shift the 'bit' ON 							     this round)	           (IF (NOT (FIXP X))		       THEN (SETQ X (FIX X)))	       SCANBITS	           (if (IGEQ X BIT)		       then (if (ILESSP X (SETQ ONEUP (LSH BIT 1)))				then                         (* Here, we've boiled it down to between two powers of 							     2)				     (RETURN LEN)			      elseif (EQ ONEUP (CONSTANT (SUB1 BITS.PER.FIXP)))				then                         (* May be it was actually the higher bit)				     (RETURN (CONSTANT (SUB1 BITS.PER.FIXP))))			    (SETQ BIT (LLSH BIT SHIFTER))			    (SETQ LEN (IPLUS LEN SHIFTER))		     elseif (IGEQ X (LRSH BIT 1))		       then (RETURN (SUB1 LEN))		     else (SETQ BIT (LRSH BIT SHIFTER))			  (SETQ LEN (IDIFFERENCE LEN SHIFTER)))	           (OR (EQ SHIFTER 1)		       (SETQ SHIFTER (LRSH SHIFTER 1)))	           (GO SCANBITS))))))(DEFINEQ(ABS  (LAMBDA (X)                                                (* JonL "17-Mar-84 22:24")    (COND      ((FIXP X)	(COND	  ((ILESSP X 0)	    (IDIFFERENCE 0 X))	  (T X)))      ((FLOATP X)	(COND	  ((FLESSP X 0.0)	    (FDIFFERENCE 0.0 X))	  (T X)))      (T                                                     (* Note that there is no "contagion" for this function, 							     as there is for PLUS and TIMES)	 (LISPERROR "NON-NUMERIC ARG" X)))))(DIFFERENCE  [LAMBDA (X Y)                                              (* lmm "11-FEB-82 14:02")    ((OPCODES DIFFERENCE)     X Y])(GREATERP  [LAMBDA (X Y)                    (* lmm: 17-DEC-75 23Q 65Q)    (COND      ((AND (FIXP X)	    (FIXP Y))	(IGREATERP X Y))      (T (FGREATERP X Y])(PLUS  (LAMBDA N                                                  (* JonL "17-Mar-84 22:17")                                                             (* Microcode generally handles the case of two args both							     FIXPs)    (PROG (R (J 0))      LP  (COND	    ((NEQ J N)	      (SETQ J (ADD1 J))	      (SETQ R (COND		  ((AND (FIXP (ARG N J))			(NOT (FLOATP R)))		    (IPLUS (OR R 0)			   (ARG N J)))		  (T (FPLUS (OR R 0.0)			    (ARG N J)))))	      (GO LP)))          (RETURN R))))(QUOTIENT  [LAMBDA (X Y)                    (* lmm: 17-DEC-75 25Q 36Q)    (COND      ((AND (FIXP X)	    (FIXP Y))	(IQUOTIENT X Y))      (T (FQUOTIENT X Y])(REMAINDER  [LAMBDA (X Y)                    (* lmm: 17-DEC-75 25Q 36Q)    (COND      ((AND (FIXP X)	    (FIXP Y))	(IREMAINDER X Y))      (T (FREMAINDER X Y])(LESSP  [LAMBDA (X Y)                    (* lmm: 17-DEC-75 23Q 73Q)    (COND      ((AND (FIXP Y)	    (FIXP X))	(IGREATERP Y X))      (T (FGREATERP Y X])(MINUS  (LAMBDA (X)                                                (* JonL "17-Mar-84 22:21")    (COND      ((FIXP X)	(IDIFFERENCE 0 X))      (T (FDIFFERENCE 0.0 X)))))(TIMES  (LAMBDA N                                                  (* JonL "17-Mar-84 22:22")    (PROG (R (J 0))      LP  (COND	    ((NEQ J N)	      (SETQ J (ADD1 J))	      (SETQ R (COND		  ((AND (FIXP (ARG N J))			(NOT (FLOATP R)))		    (ITIMES (OR R 1)			    (ARG N J)))		  (T (FTIMES (OR R 1.0)			     (ARG N J)))))	      (GO LP)))          (RETURN R)))))(DEFINEQ(FMINUS  [LAMBDA (X)                      (* lmm " 5-MAR-80 23:12")    (FDIFFERENCE 0.0 X])(FREMAINDER  [LAMBDA (X Y)                    (* rrb "24-APR-80 10:37")    (FDIFFERENCE X (FTIMES (FLOAT (FIX (FQUOTIENT X Y)))			   Y]))(DEFINEQ(RANDSET  [LAMBDA (X)                                                (* lmm "21-Aug-84 14:42")    (PROG (RS RS1 RS2)          (COND	    ((NULL X)	      (GO OUT))	    ((EQ X T)                                        (* initialize with clock)	      (SETQ RS1 (CLOCK))	      (SETQ RS2 (IDATE)))	    ((AND (FIXP (CDR (LISTP X)))		  (FIXP (CAR X)))                            (* user supplies initialization, old-style)	      (SETQ RS1 (CAR X))	      (SETQ RS2 (CDR X)))	    ((AND (EQ (LENGTH X)		      67Q)		  (EVERY X (FUNCTION FIXP)))	      [SETQ RS (MAPCAR X (FUNCTION (LAMBDA (N)				   (IPLUS N]	      (GO XX))	    (T (ERROR (QUOTE "ARG NOT PREVIOUS VALUE OF RANDSET")		      X)))          [PROG ((\OVERFLOW 0))	        (DECLARE (SPECVARS \OVERFLOW))	        (SETQ RS		  (MAPCAR (QUOTE (150177Q 134506Q 2372Q 154626Q 170230Q 66113Q 25744Q 40670Q 105776Q 					  171521Q 26405Q 111676Q 103564Q 151Q 162576Q 66157Q 23404Q 					  10171Q 157167Q 73124Q 57746Q 2565Q 152474Q 151770Q 124444Q 					  7426Q 114136Q 26172Q 146043Q 2037Q 1673Q 37700Q 46706Q 					  162146Q 6277Q 176221Q 3250Q 41735Q 156764Q 41547Q 144665Q 					  135532Q 63240Q 10560Q 5504Q 145075Q 114776Q 176503Q 160605Q 					  104147Q 12303Q 27516Q 35414Q 23625Q 25100Q))			  (FUNCTION (LAMBDA (Z)			      (SETQ RS1 (LOGAND RS1 177777Q))			      (LOGXOR Z (SETQ RS2 (PROG1 (LOGAND (IPLUS (ITIMES RS1 46635Q)									RS1)								 177777Q)							 (SETQ RS1 RS2]      XX  (FRPLACD (LAST RS)		   RS)          (SETQ RANDSTATE (CONS RS (FNTH RS 37Q)))      OUT (RETURN (for X in (CAR RANDSTATE) as I from 1 to 67Q collect X])(RAND  [LAMBDA (LOWER UPPER)                                      (* edited: "29-Mar-84 15:49")          (* This function implements the XRAND subroutine described in Stanford memo STAN-CS-77-601, Analysis of Additive 	  Random Number Generators, by John F. Reiser, on p 28.0 Rather than storing the X values in an array and computing 	  indexes I and J, however, I have elected to retain state in a circular list of 63Q elements.	  RANDSTATE is (CONS X (NTH X 37Q)); each time RAND is called, both CAR and CDR of RANDSTATE are CDR'ed to 	  effectively increment the index. In addition, the numbers are stored as 20Q bit binary fractions 	  (i.e. the decimal point is on the left of the 16-bit quantity))    (PROG (I J)          (OR (LISTP RANDSTATE)	      (PROGN (RANDSET T)		     RANDSTATE))          (SETQ I (CDAR RANDSTATE))          (SETQ J (CDDR RANDSTATE))          (RPLNODE RANDSTATE I J)          (RPLACA I (LOGAND (IDIFFERENCE (CAR I)					 (CAR J))			    MAX.SMALLP)))    (COND      [(NOT UPPER)	(COND	  ((NULL LOWER)                                      (* both UPPER and LOWER nil. Return number 							     (0 .. MAX.SMALLP) -							     not documented)	    (CAAR RANDSTATE))	  ((FIXP LOWER)                                      (* (RAND n) = (RAND 0 n-1))	    (IREMAINDER (CAAR RANDSTATE)			LOWER))	  (T                                                 (* (RAND N) N floating. Return 							     (RAND 0 N))	     (FTIMES LOWER (FQUOTIENT (CAAR RANDSTATE)				      (CONSTANT (FLOAT (ADD1 MAX.SMALLP]      [(AND (FIXP LOWER)	    (FIXP UPPER))	(OR (IGREATERP UPPER LOWER)	    (swap UPPER LOWER))	(SETQ UPPER (IDIFFERENCE UPPER LOWER))	(COND	  ((IGREATERP UPPER MAX.SMALLP)	    (IPLUS (IMOD (\MAKENUMBER (CAAR RANDSTATE)				      (CADAR RANDSTATE))			 (ADD1 UPPER))		   LOWER))	  (T (IPLUS (IREMAINDER (CAAR RANDSTATE)				(ADD1 UPPER))		    LOWER]      (T (FPLUS [FTIMES (FDIFFERENCE UPPER LOWER)			(FQUOTIENT (CAAR RANDSTATE)				   (CONSTANT (FLOAT (ADD1 MAX.SMALLP]		LOWER])(EXPT  (LAMBDA (A N)                                              (* JonL " 2-Jul-84 16:08")    (if (FIXP N)	then (if (FIXP A)		 then (if (NOT (IGREATERP N 0))			  then (if (EQ 0 N)				   then 1				 else (FEXPT A N))			elseif (EQ 0 A)			  then 0			else                                 (* Integer EXPonentiation -- works by clever 							     bit-dissection method)			     (PROG ((V 1))			       LP  (if (ODDP N)				       then (SETQ V (TIMES A V)))			           (if (EQ 0 (SETQ N (LRSH N 1)))				       then (RETURN V))			           (SETQ A (TIMES A A))			           (GO LP)))	       elseif (FEQP 0.0 (SETQ A (FLOAT A)))		 then (if (EQ 0 N)			  then 1.0			else 0.0)	       else                                          (* Real EXPonentiation -- works by clever bit-dissection							     method)		    (PROG ((V 1.0))		          (if (ILESSP N 0)			      then (SETQ A (FQUOTIENT 1.0 A))				   (SETQ N (IMINUS N)))		      LP  (if (ODDP N)			      then (SETQ V (TIMES A V)))		          (if (EQ 0 (SETQ N (LRSH N 1)))			      then (RETURN V))		          (SETQ A (TIMES A A))		          (GO LP)))      else (FEXPT A N)))))(DECLARE: DONTEVAL@LOAD DOCOPY (RPAQQ RANDSTATE NIL)(RPAQQ \TOL 9.999992E-6))(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS RANDSTATE \TOL))(DEFINEQ(PutUnboxed  (LAMBDA (PTR NUM)                                          (* JonL "25-JUL-83 02:29")    (\PUTFIXP PTR NUM)))(\PUTFIXP  [LAMBDA (PTR NUM)                                          (* lmm "11-DEC-80 15:10")    (PROG (HI LO)          (.UNBOX. NUM HI LO)          (replace (FIXP HINUM) of PTR with HI)          (replace (FIXP LONUM) of PTR with LO)          (RETURN NUM])(\PUTSWAPPEDFIXP  [LAMBDA (PTR NUM)                                          (* edited: " 7-JUN-83 10:34")                                                             (* store in MESA order rather than LISP order)    (PROG (HI LO)          (.UNBOX. NUM HI LO)          (replace (FIXP LONUM) of PTR with HI)          (replace (FIXP HINUM) of PTR with LO)          (RETURN NUM])(\HINUM  [LAMBDA (NUM)                    (* lmm "12-APR-81 22:01")    (PROG (HI LO)          (.UNBOX. NUM HI LO)          (RETURN HI])(\LONUM  [LAMBDA (NUM)                    (* lmm "12-APR-81 22:02")    (PROG (HI LO)          (.UNBOX. NUM HI LO)          (RETURN LO])(TRUNCATEMULTIPLY  (LAMBDA (X Y)                                              (* JonL "27-Sep-84 23:01")                                                             (* this is a dreadful kludge.							     -							     do unsigned multiply mod 40Q)    (COND      ((EQ 0 Y)	0)      ((EQ (LOGAND Y 1)	   1)	(IPLUS X (TRUNCATEMULTIPLY (LLSH X 1)				   (LRSH Y 1))))      (T (TRUNCATEMULTIPLY (LLSH X 1)			   (LRSH Y 1)))))))(* FOLLOWING DEFINITIONS EXPORTED)(DECLARE: DONTCOPY (DECLARE: EVAL@COMPILE (PUTPROPS PutUnboxed DMACRO (= . \PUTFIXP))))(* END EXPORTED DEFINITIONS)(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA TIMES PLUS LOGXOR LOGOR LOGAND ITIMES IPLUS))(PUTPROPS LLARITH COPYRIGHT ("Xerox Corporation" T 3676Q 3677Q 3700Q 3701Q))(DECLARE: DONTCOPY  (FILEMAP (NIL (4726Q 5625Q (IDIFFERENCE 4740Q . 5161Q) (IGREATERP 5163Q . 5404Q) (IQUOTIENT 5406Q . 5623Q)) (5626Q 34155Q (\SLOWIPLUS2 5640Q . 10516Q) (\SLOWPLUS2 10520Q . 11643Q) (\SLOWIDIFFERENCE 11645Q . 15577Q) (\SLOWDIFFERENCE 15601Q . 16761Q) (\SLOWIGREATERP 16763Q . 17557Q) (\SLOWLLSH1 17561Q . 20343Q) (\SLOWLLSH8 20345Q . 21055Q) (\SLOWLOGAND2 21057Q . 21534Q) (\SLOWLOGOR2 21536Q . 22207Q) (\SLOWLOGXOR2 22211Q . 22666Q) (\SLOWLRSH1 22670Q . 23410Q) (\SLOWLRSH8 23412Q . 24066Q) (\SLOWITIMES2 24070Q . 31375Q) (\SLOWTIMES2 31377Q . 32526Q) (\SLOWIQUOTIENT 32530Q . 33004Q) (\SLOWQUOTIENT 33006Q . 34153Q)) (34271Q 36451Q (\BOXIPLUS 34303Q . 34637Q) (\BOXIDIFFERENCE 34641Q . 36447Q)) (36505Q 37566Q (\MAKENUMBER 36517Q . 37564Q)) (37567Q 40065Q (OVERFLOW 37601Q . 40063Q)) (41245Q 42757Q (\GETBASEFIXP 41257Q . 41655Q) (\PUTBASEFIXP 41657Q . 42313Q) (\PUTBASEFIXP.UFN 42315Q . 42755Q)) (50433Q 65137Q (EQP 50445Q . 51465Q) (FIX 51467Q . 51722Q) (IQUOTIENT 51724Q . 52141Q) (IREMAINDER 52143Q . 52363Q) (LLSH 52365Q . 53751Q) (LRSH 53753Q . 55475Q) (LSH 55477Q . 62620Q) (RSH 62622Q . 65135Q)) (77067Q 117443Q (MINUSP 77101Q . 77333Q) (ILESSP 77335Q . 77421Q) (IMINUS 77423Q . 77507Q) (IPLUS 77511Q . 100763Q) (ITIMES 100765Q . 102243Q) (LOGAND 102245Q . 103523Q) (LOGOR 103525Q . 104777Q) (LOGXOR 105001Q . 106257Q) (SUB1 106261Q . 106426Q) (ZEROP 106430Q . 106644Q) (ADD1 106646Q . 106722Q) (GCD 106724Q . 107603Q) (IEQP 107605Q . 110015Q) (INTEGERLENGTH 110017Q . 117441Q)) (117444Q 124264Q (ABS 117456Q . 120420Q) (DIFFERENCE 120422Q . 120641Q) (GREATERP 120643Q . 121120Q) (PLUS 121122Q . 122141Q) (QUOTIENT 122143Q . 122420Q) (REMAINDER 122422Q . 122706Q) (LESSP 122710Q . 123162Q) (MINUS 123164Q . 123455Q) (TIMES 123457Q . 124262Q)) (124265Q 124703Q (FMINUS 124277Q . 124444Q) (FREMAINDER 124446Q . 124701Q)) (124704Q 137004Q (RANDSET 124716Q . 130144Q) (RAND 130146Q . 134323Q) (EXPT 134325Q . 137002Q)) (137241Q 142441Q (PutUnboxed 137253Q . 137463Q) (\PUTFIXP 137465Q . 140135Q) (\PUTSWAPPEDFIXP 140137Q . 141002Q) (\HINUM 141004Q . 141227Q) (\LONUM 141231Q . 141454Q) (TRUNCATEMULTIPLY 141456Q . 142437Q)))))STOP