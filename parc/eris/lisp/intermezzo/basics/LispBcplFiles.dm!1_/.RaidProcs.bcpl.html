<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>INTERMEZZO>BASICS>LispBcplFiles.dm!1>RaidProcs.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">// RaidProcs.bcpl. Supplementary procedures for RAID<br>// Last modified March 20, 1985  10:42 AM by Bill van Melle<br>// Changed atom hash January 30, 1985  11:49 AM by Bill van Melle<br>// Last modified January 21, 1985  12:16 PM by Bill van Melle<br>// Flushed VMDisplay December 13, 1984  12:05 PM by Bill van Melle<br>// Flushed TeleRaid July 20, 1983  2:49 PM by Bill van Melle<br>// Last modified March 30, 1983  11:31 AM by Bill van Melle<br>// Last modified December 16, 1982  10:15 PM by Bill van Melle<br>// Last modified July 21, 1982  9:32 PM by Bill van Melle<br>// Last modified September 19, 1981  2:01 PM by Bill van Melle<br>// Last modified August 4, 1981  12:47 PM by Beau Sheil<br><br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "AltoDefs.d"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Raid.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Stats.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Vmem.decl"<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">get "Streams.d"<br><br>external [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures defined here<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">ReadNum; ReadAtom; ShowRealCore<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">DoYankDef; DoSetTopVal; FetchAtomComponent <br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>external [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// procedures used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">CRLF; Ws; Wo; Wc; Bytes2<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">RaidReset; RAIDCode; ReadStrng; PrintAddrs; Confirm<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@BGetBase; @BGetBasePtr; @BGetBase32; @BPutBase32<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">@XSetReadBR; @RRead; @RWrite<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BP; ReadFlags; EmAddr; MkSmallPos; IGetBase<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EqNIL; Lprint<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// OS procs used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">Zero; MoveBlock<br><br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// statics used<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">EmulatorSpace; LastRealPageNo; @lvVPtr; @lvNIL<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">dsp; @DisplayAddrHi<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>manifest [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">emptySegment = EMPTY rshift 8</span><span class="tab" val="67"></span><span style="font: 10pt serif">// EMPTY&lt;&lt;VP.segment<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">emptyPage = EMPTY & #377</span><span class="tab" val="67"></span><span style="font: 10pt serif">// EMPTY&lt;&lt;VP.page<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// grumble must be constants<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>static [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">firstChar; reprobe; nReprobes; hash<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br><br>structure String: [ length byte; char&uarr;1,255 byte ]<br><br><br>let AtomNum(S) = valof<br>// Finds atom number for BCPL string. pn char format is that of bcpl strings<br> [ <br>   let pnLength = S&gt;&gt;String.length<br>   let lastWord = pnLength rshift 1</span><span class="tab" val="67"></span><span style="font: 10pt serif">// offset of last word in pname<br>   firstChar = S&gt;&gt;String.char&uarr;1<br>   reprobe = 0<br>   nReprobes = 0<br><br>// Compute the hash code for the name. Mimic the behavior of LISP.<br>// This code looks simpler than Lisp&rsquo;s because we automatically do<br>// 16-bit arithmetic, while Lisp has to struggle.<br><br>   hash = firstChar lshift 8<br>   for i = 2 to pnLength do<br>     [ hash = ((hash & #7777) lshift 2) + hash<br>       hash = (hash lshift 8) + hash + S&gt;&gt;String.char&uarr;i<br>     ]<br><br>   [<br><br>   let P = BGetBase(AHTspace, hash)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// P is contents of hash table entry <br>   if P eq 0 then RaidReset("No such atom")<br><br>// since P was non zero, it is the virtual address of an atom+1<br>   P = P-1<br><br>// fetch atom and check its pname. Check its characters (word-by-word)<br>// with those in pname. Count is first byte, and pad byte (if any) is 0.<br><br>   XSetReadBR(FetchAtomComponent(PNPspace, P))<br>   for i = 0 to lastWord do if RRead(i) ne S!i goto doReprobe<br><br>   resultis P</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// pnames are the same; return virtual address<br><br>doReprobe:<br>   if reprobe eq 0<br>      then reprobe = ((firstChar xor hash) % 1) & #77<br>   hash = hash+reprobe<br>   nReprobes = nReprobes+1<br>   ] repeat</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// comparison failed so reprobe<br> ]<br><br>and FetchAtomComponent (space, atom) = <br>  BGetBasePtr (space+(atom rshift 15), atom lshift 1)<br><br>and ReadAtom() = valof</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// obtains atom number from typein<br>  [ let s = vec 50<br>    unless ReadStrng(s) do RaidReset(" XXX")<br>    let num=0<br>    for i=1 to s&gt;&gt;String.length do<br>        [ let c = (s&gt;&gt;String.char&uarr;i)-$0<br>          test (c ge 0) & (c le 7)<br>            ifso  num=num*8+c<br>            ifnot resultis AtomNum(s)<br>        ]<br>    resultis num<br>  ]<br><br>and ReadNum(radix) = valof</span><span class="tab" val="67"></span><span style="font: 10pt serif">// read number in given radix<br>  [<br>   let s = vec 50<br>   unless ReadStrng(s) do RaidReset(" XXX")<br>   let num=0<br>   for i=1 to s&gt;&gt;String.length do<br>        [ let c = (s&gt;&gt;String.char&uarr;i)-$0<br>          test (c ge 0) & (c ls radix)<br>            ifso  num=num*radix+c<br>            ifnot RaidReset(" XXX")<br>        ]<br>   resultis num<br>  ]<br><br>and ShowRealCore() be</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Displays a segment page usage map<br> [<br>   CRLF()<br>   Ws (" State of virtual memory file: ")<br>   Ws (IGetBase(IFPKey) eq IFPValidKey? "C", "Inc")<br>   Ws ("onsistent")<br>   CRLF(); CRLF()<br>   let base = vec LastVMSegment+2; Zero(base, LastVMSegment+3)<br>   let ndirty, nlocked, nempty, nunavail = 0, 0, 0, 0<br>   let bp = BP(0)<br>   for i = 2 to BptSize do<br>     [</span><span class="tab" val="67"></span><span style="font: 10pt serif">bp = bp+3</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// next one.  Skips the dummy header<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let vp = BGetBase(BptSegment, bp+1)</span><span class="tab" val="67"></span><span style="font: 10pt serif">// bp&gt;&gt;BPT.VP<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let bucket = vp&lt;&lt;VP.segment<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">test (bucket ne emptySegment) % (vp&lt;&lt;VP.page ls emptyPage)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso</span><span class="tab" val="67"></span><span style="font: 10pt serif">[<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if BGetBase(BptSegment, bp) ls 0</span><span class="tab" val="67"></span><span style="font: 10pt serif">// bp&gt;&gt;BPT.LOCK<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then nlocked = nlocked+1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">if (ReadFlags(vp) & DIRTYbit) ne 0<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">   then ndirty = ndirty+1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">base!bucket = base!bucket + 1<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot test vp eq EMPTY<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">   ifso nempty = nempty+1<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">  ifnot nunavail = nunavail+1<br>     ]<br>   base!EmulatorSpace = PagesPerSegment</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">// Emulator done specially<br>   Ws(" Segment   Pages Contents*N")<br>   let total = 0<br>   for i = 0 to LastVMSegment do unless base!i eq 0<br>       do [ Ws("  "); Wo(i); Ws("  "); Wo(base!i)<br>            // The following is not a SELECT as the choices are not exclusive<br>            if i eq PNPspace then Ws(" PName pointers")<br>            if i eq DEFspace then Ws(" Definitions")<br>            if i eq TOPVALspace then Ws(" TopVals")<br>            if i eq PLISTspace then Ws(" Property lists")<br>            if i eq AHTspace then Ws(" Atom Hash Table")<br>            if i eq PMTspace then Ws(" Primary Page Map (PMT)")<br>            if i eq PAGEMAPspace then Ws(" Secondary Page Map")<br>            if i eq INTERFACEspace then Ws(" Interface page")<br>            if i eq MDSTYPEspace then Ws(" MDS type table")<br>            if i eq STACKspace then Ws(" Stack")<br>            if i eq EmulatorSpace then Ws(" Alto emulator")<br>            if i eq DisplayAddrHi & DisplayAddrHi ne 0<br>               then Ws(" Lisp display bitmap")<br>            if i ge ArrayLo & i le ArrayHi then Ws(" Lisp data")<br>            if i eq GCMainspace then Ws(" GC main table")<br>            if i eq GCCollspace then Ws(" GC collision table")<br>            CRLF()<br>            total = total + base!i ]<br>   Ws("   Total  "); Wo(total); Ws(" pages in use"); CRLF() <br>   let sp = "          "<br>   Ws(sp); Wo(nempty); Ws(" Empty"); CRLF()<br>   Ws(sp); Wo(LastRealPageNo-nunavail); Ws(" Total available pages"); CRLF()<br>   Ws(sp); Wo(nlocked); Ws(" pages locked"); CRLF()<br>   Ws(sp); Wo(ndirty); Ws(" pages dirty"); CRLF()<br>  ]<br><br>and DoYankDef() be<br>  [<br>  Ws(" from atom ")<br>  let a = ReadAtom()<br>  FetchAtomComponent(DEFspace, a)<br>  test EqNIL(lvVPtr)<br>    ifso Ws ("[no definition")<br>    ifnot [ Wc($[); PrintAddrs(DEFspace+(a rshift 15), (a lshift 1), 2) ]<br>  Ws("] and smash it into definition cell of atom ")<br>  let b = ReadAtom()<br>  Ws("[was ")<br>  PrintAddrs(DEFspace+(b rshift 15), (b lshift 1), 2)<br>  Wc($])<br>  if Confirm()<br>    then [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// since lvVPtr has been smashed by now...<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BGetBase32(DEFspace+(a rshift 15), (a lshift 1))<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">BPutBase32(DEFspace+(b rshift 15), (b lshift 1), lvVPtr)<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>  ]<br><br>and DoSetTopVal() be<br>  [<br>  let a = ReadAtom()<br>  Ws (" currently ")<br>  Lprint (FetchAtomComponent(TOPVALspace, a))<br>  Ws (" to be (atom or small octal value): ")<br>  let s = vec 50<br>  MoveBlock (s, "NIL", 2)<br>  unless ReadStrng(s, 99, true) & (s&gt;&gt;String.length gr 0) do RaidReset(" XXX")<br>  lvVPtr&gt;&gt;VA.vahi = SMALLPOSspace<br>  let num=0<br>  for i=1 to s&gt;&gt;String.length<br>     do  [<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">let c = (s&gt;&gt;String.char&uarr;i)-$0<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">test (c ge 0) & (c le 7)<br>           ifso num=num*8+c<br>          ifnot [</span><span class="tab" val="67"></span><span style="font: 10pt serif">// not numeric<br>  </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">num = AtomNum(s)<br>  </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">lvVPtr&gt;&gt;VA.vahi = ATOMspace<br>  </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">break<br>  </span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 10pt serif">]<br>         ]<br>  lvVPtr&gt;&gt;VA.valo = num<br>  BPutBase32(TOPVALspace+(a rshift 15), a lshift 1, lvVPtr)<br>  ]<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
