<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>INTERMEZZO>BASICS>LISP0MC.DM!1>Fetch.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Fetch.0mc...January 12, 1983  10:50 AM, van Melle];Set[FetchDebug, 0];Set[NoInterrupts, 0];*	GOTO[REFILLY],LOADPAGE[0],at[0001];*	only required on pages that contain NextInst/NextData'sREFILLY:*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[0377] ;*page  0 alto*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[0777] ;*page  1 alto*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[1377] ;*page  2 alto*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[1777] ;*page  3 alto	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[2377] ;*page  4lspNextInstP4:	lu &larr; NextInst[IBuf];lnixP4:		NIRET;	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[2777] ;*page  5lspNextInstP5:	lu &larr; NextInst[IBuf];lnixP5:		NIRET;	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[3377] ;*page  6lspNextInstP6:	lu &larr; NextInst[IBuf];lnixP6:		NIRET;	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[3777] ;*page  7lspNextInstP7:	lu &larr; NextInst[IBuf], at[P7TailLoc];	* placed for overlayslnixP7:		NIRET;*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[4377] ;*page 10*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[4777] ;*page 11	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[5377] ;*page 12lspNextInstP12:	lu &larr; NextInst[IBuf];lnixP12: 	NIRET;*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[5777] ;*page 13 alto*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[6377] ;*page 14 alto	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[6777] ;*page 15lspNextInstP15:	lu &larr; NextInst[IBuf];lnixP15: 	NIRET;	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[7377] ;*page 16lspNextInstP16:	lu &larr; NextInst[IBuf];lnixP16: 	NIRET;*	PFetch4[PCB, IBuf, 4], gotop[RefillIBuf], at[7777] ;*page 17 - can't	onpage[17];lspNextInstP17:	loadpage[7];		gotop[lspNextInstP7];	OnPage[0];RefillIBuf:	PCB &larr; (PCB) + (4c), at[340];	PCF &larr; Rzero, at[341];	nop, at[342];	return, at[343];		* Wait for page faultonpage[pgJump];* If the PFETCH4 faults, the fault handler will set IBUF to -1s and* continue as if nothing happened.  The fault happens after the 3rd* instruction past the pfetch is executed.  The fault handler destroys* the return link.  The micro instruction being executed must be on* pgJump for this special action to occur.ReturnOp:	return, opcode[374];	* Used by Fault for first mi NextData casePFop:	PFETCH4[PCB, IBUF, 0], opcode[377];	* This will page fault	IBUF &larr; IBUF, goto[nxiLBL];* Come here when IntPending instead of to next opcode	onpage[opPage0];TakeInterrupt:	T &larr; (SStkP&amp;NStkP) xor (377c), skip;	* maybe these can be the sameNwwOp:	T &larr; (SStkP&amp;NStkP) xor (377c), opcode[000];	lspL1 &larr; IP[RSImage]c;			* RS232 Image Register	Stkp &larr; lspL1, lspL1 &larr; T, NoRegILockOK;	T &larr; Stack &larr; (Stack) and not (IntPendingBit);	Stkp &larr; lspL1, RS232 &larr; T;:IF[WindFlg];	lu &larr; (NWW) and not (BothKeyMasks), goto[NoInterrupt, R&lt;0];				* test for interrupts other than lisp/bcpl key	NWW &larr; (NWW) and not (BcplKeyMask), goto[NWWPunt, alu#0];				* yes, do them by punting to bcpl	AC2 &larr; KbdFXP, skip[alu#0];	* Skip if no interrupts: shouldn't happen?	  goto[NoInterrupt];			* spurious	NWW &larr; 100000c;			* turn off interrupts before switching	loadpage[pgLisp0];	AC3 &larr; 177400c, gotop[CheckForBackup];	* AC3&lt;0 signals contextswitchNoInterrupt:	T &larr; (PCXReg) - 1;	* need to back up the PC before resuming	lspL1 &larr; T;	PCF &larr; lspL1;			* wait for PCF to get written	goto[nxiLBL];:ELSE;				* pre-Wind, always do Nww	LoadPage[pgLisp0];	gotop[lspNWWInt];:ENDIF;%:IF[NoInterrupts];	T &larr; (PCXReg);	lspL1 &larr; T;	lspL1 &larr; (lspL1) - (1c);	nop;	PCF &larr; (lspL1);	nop;	lu &larr; NextInst[IBuf];	NIRET;:ELSE;	LoadPage[pgLisp0];	gotop[lspNWWInt];:ENDIF;%	onpage[4];lspRetP4: return;	onpage[5];lspRetP5: return;	onpage[6];lspRetP6: return;	onpage[10];lspRetP10: return;	onpage[11];lspRetP11: return;	onpage[15];lspRetP15: return;	onpage[16];lspRetP16: return;	onpage[17];lspRetP17: return;	onpage[5];lspUfnxP5:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[6];lspUfnxP6:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[7];lspUfnxP7:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[10];lspUfnxP10:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[11];lspUfnxP11:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[12];lspUfnxP12:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[15];lspUfnxP15:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[16];lspUfnxP16:	loadpage[pgUfnx];	gotop[lspUfnxP4];	onpage[17];lspUfnxP17:	loadpage[pgUfnx];	gotop[lspUfnxP4];	:END[Fetch];</pre>
  </body>
</html>
