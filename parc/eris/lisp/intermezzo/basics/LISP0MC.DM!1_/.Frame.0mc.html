<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>INTERMEZZO>BASICS>LISP0MC.DM!1>Frame.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Frame.0mc, January 21, 1985  5:29 PM, van Melle];*********** function call microcode- CallFn**  Callfn*  Nargs=number of args, Defx0/Defx1= Expression to be called**  Can page fault on the fetch of the function cell, or the fetch of the header*  Can cause a stack overflow if NIL arguments are being added, or if it needs room for FE** Regs to set up:*	lspIfuBr, BrHi contain current function header*	IBaseX contains address of first IVar*******	onpage[pgFrame];lspCallFn0:			* call atom lspDefx1	lspDefx0 &larr; 0c, goto[lspCallFn];lspCallFn:	T &larr; lsh[lspIfuBr, 1];	T &larr; (lsh[PCB, 1]) - T;	T &larr; (PCFreg) + T;	lspLN &larr; T;		* PC = PCF + 2*(lspIfuBr-PCB)	T &larr; (lspEp) - (10c);	PStore4[lspStkBr, lspIfuBr];				* store fn header, Next (garbage), PC	lu &larr; rhmask[lspDefx0];		* Undefined function if not an atom	lspGenBrHi &larr; (DEFspace), goto[Udf-expr', alu#0];IFE[DEFbase!,0,,ER[DEFbase.not.zero]];lspDof1:	T &larr; lspGenBr &larr; (DEFbase);	qBuf1 &larr; T, loadpage[opPage3];	* clear part of this buf for later	lspInstFlag &larr; (InCallState), callp[ReturnOp];			* opcode 374.  Does a return, but also latches SStkp			* and PCX so that we can resume from here (from			* DoApplyFn) if there is a fault	T &larr; lsh[lspDefx1,1], goto[fetchDefn, R&gt;=0];					* Get address of function cell	  lspGenBrHi &larr; (DEFspace2);	* atom in high segment	  nop;				* wait for hi base to be written	  nop;				* wait for hi base to be writtenfetchDefn:	PFetch2[lspGenBr, lspL0];	* Fetch function cell, this can fault					* Memory busy for 10. cycles now	XBuf2 &larr; (FxtnBlock);		* Start preparing new BF &amp; FX	T &larr; lspEp;	XBuf3 &larr; T;			* Alink for future FX	qBuf3 &larr; Zero;			* clear part of this buf for later*	L0,1 contains definition cell, which is*	ccodep[0], fast[1], ArgType[2:3], code address [10:37]	T &larr; rhmask[lspL0], goto[Udf-expr, R&gt;=0];	* punt if not ccodep	T &larr; (lsh[lspL0, 10]) or T;	* duplicate in left half	lspIfuBrHi &larr; T;	PCBhi &larr; T;			* Setup PCBhi	T &larr; lspL1, task;	lspIfuBr &larr; T;			* low half of base reg	PFetch4[lspIfuBr, IBuf, 0];	* This may fault				* This fetchs the function header words:				* #Stack words, #Args, NF+NP-1, Start PC				* Memory busy for 8 cycles now reading IBuf	lu &larr; (lspL0) and (40000c);	* test fast bit in fndef	T &larr; lspTsp, skip[alu=0];	  XBuf2 &larr; (XBuf2) or (10000c);	* set fast bit in FX	T &larr; (lspEsp) - T;		* Amount of space left on stack	IBuf &larr; (IBuf) + (40c);		* Add a little slop	lu &larr; (IBuf) - T, loadpage[pgFrame3];	* compare with what's needed	T &larr; lspNargs, dblgoto[lspSubovPunt, lspAdjust, Carry];				* proceed if negative, i.e. enough room				* punt (stack overflow) otherwiseUdf-expr': nop;				* allocation constraintUdf-expr:				* Call lisp fn to do the call					* extra arg is the def	T &larr; lspDefx0, loadpage[pgFrame2];	Stack&amp;+1 &larr; T;onpage[pgFrame2];	T &larr; lspDefx1, call[lspCallPushT];	lspDefx1 &larr; (ExprApplyAtom);	lspGenBrHi &larr; (DEFspace);	* restore possibly smashed hi base	lspNargs &larr; (lspNargs) + 1, loadpage[pgFrame];	lspDefx0 &larr; 0c, goto[lspDof1];lspCallPushT:	Stack&amp;+1 &larr; T;	StkState &larr; lsh[StkState, 1], return;* Adjust the number of arguments* No more faults are possible* T = Nargs = number of arguments supplied* IBuf1	= number of arguments expected* IBuf2	= NF+NP-1* IBuf3	= Start PC* IFUbr	= base register for FN Header	onpage[pgFrame3];lspAdjust:	IBuf1 &larr; (IBuf1) - T, skip[R&gt;=0];		* IBuf1&lt;0 =&gt; nospread	  IBuf1 &larr; 0c;IF[StatsMode];	lspStatsPtr, goto[FNStat, R&gt;=0];:ENDIF;FNStatDone:	lu &larr; ldf[SStkP&amp;NStkP, 16, 1];	XBuf &larr; (BFBlock), goto[lspDocall1, alu=0];		* Stkp-1 is quad aligned (stkp read complemented).		* If we just stuck the BF next, it would not be quad aligned,		* so pad with a NIL.		* After this we will push/pop only an even number of cells,		* and IBuf1 is odd iff BF is truly padded	  lspNargs &larr; (lspNargs) + 1, loadpage[pgFrame2];	  T &larr; Stack&amp;+1 &larr; 0c, call[lspCallPushT];	  IBuf1 &larr; (IBuf1) - 1;lspDocall1:	lspTsp &larr; (lspTsp) - (2c);	StkState &larr; rcy[StkState, 1], call[fClrHStk1];fClrHStk1:	dispatch[lspTsp, 14, 2];	lspTsp &larr; (lspTsp) + (4c), disp[fClrHStkDisp0];fClrHStkDisp0:	PStore4[lspTsp, Hstack4, 0], goto[fClrHStack1], disptable[4];	PStore4[lspTsp, Hstack10, 0], goto[fClrHStack1];	PStore4[lspTsp, Hstack14, 0], goto[fClrHStack1];	PStore4[lspTsp, Hstack0, 0], goto[fClrHStack1];fClrHStack1:	StkState &larr; rcy[StkState, 2], skip[R Odd];	  return;			* to fClrHStk1:IF[StkDebug];	loadpage[pgHStack];	callp[ChkStk];:ENDIF;* Stack is flushed out now.* Tsp points at last quad of frame (last two args)	T &larr; (lspTsp) + (4c);	T &larr; (lsh[lspNargs, 1]) - T, task;	T &larr; lspIBasex &larr; (Zero) - T;	* IVAR =&gt; First arg	XBuf1 &larr; T, loadpage[pgFrame4];* Now adjust args.  IBuf1 = number of missing args (maybe negative)	T &larr; IBuf1, goto[lspDocall3, R Even];onpage[pgFrame4];	  XBuf &larr; (BFBlockPad);	  T &larr; IBuf1 &larr; (IBuf1) + 1;lspDocall3:				* IBuf1 is now even	qBuf2 &larr; (Zero) - 1, goto[lspDocall, alu=0];	T &larr; IBuf1 &larr; lsh[IBuf1, 1], dblgoto[PopExargs, PadArgs, R&lt;0];					* IBuf1 now expressed in wordsPadArgs:		* not enough args supplied: push IBuf1 words of NIL	qBuf &larr; 0c;			* qBuf1,3 already 0	qBuf2 &larr; 0c;	IBuf1 &larr; (IBuf1) - (4c), call[.+1];	IBuf1 &larr; (IBuf1) - (4c), goto[EndAdjust, R&lt;0];	PStore4[lspTsp, qBuf, 4];	* Push 2 NIL's on stack	lspTsp &larr; (lspTsp) + (4c), return;PopExargs:				* too many args supplied	lspTsp &larr; (lspTsp) + T;		* Pop extra arguments					* Wait for lspTsp to writeEndAdjust:	qBuf2 &larr; (Zero) - 1;* Close old frame extension and create the new basic frame and new frame extension* XBuf is now completely filled in with new BF &amp; FXlspDocall:				* even	PStore4[lspTsp, XBuf, 4];				* Store BF flags, IVar, FX flags, Alink	T &larr; (lspEp) - (6c);	PStore1[lspStkBr, lspIBasex];	* Store "Next" field of old extension					* Same as new IVar					* MC1 busy for 13 cycles now	T &larr; lspTsp &larr; (lspTsp) + (20c);	* point tsp at Pvar region	lspEp &larr; T;* Clear pvar and fvar slots* IBuf2	= (NF+NP+1)/2 - 1* IBuf3	= Start PC* IFUbr = Base register for FN header* Tsp   = pointer to start of pvar area* IBasex = pointer to start of BFFinCall:	qBuf &larr; (Zero) - 1, call[lspClearP];	* qBuf &larr; all ones					* Will set them to unbound					* qBuf1,3 were cleared earlier,					* though probably not necessarylspClearP:	IBuf2 &larr; (IBuf2) - 1, goto[CallDone, R&lt;0];	PStore4[lspTsp, qBuf, 0];	lspTsp &larr; (lspTsp) + (4c), return;CallDone:				* Now figure out where StkP goes	T &larr; IP[HStack2]c;	T &larr; (ldf[lspTsp, 14, 4]) + T + 1;	lspL4 &larr; T, loadpage[pgJump];	T &larr; rsh[IBuf3, 1];onpage[pgJump];			* Must be on pgJump since pfetch4 can fault	PFetch4[lspIfuBr, IBuf];	PCB &larr; T;		* Bypasss kludge: PCB&larr; addr of start of code	PCF &larr; RZero;	lspInstFlag &larr; (NormalState);	Stkp &larr; lspL4;			* Set stack pointer	lspTsp &larr; (lspTsp) - (2c);	* =&gt; last cell in Pvar region	StkState &larr; 376c, goto[IFE[StatsMode, 1, CheckCallOvfl, CallDone1]];CallDone1:	lu &larr; NextInst[IBuf];	StkState &larr; (StkState) or (3400c), NIRET;	* StkState &larr; 3776:IF[StatsMode];CheckCallOvfl:	lu &larr; (lspStatsPtr) - (StatsBufferBoundary), goto[CallDone1, R&lt;0];	  StkState &larr; (StkState) or (3400c), skip[alu&gt;=0];	    goto[CallDone1];			* NextOpCode	goto[StatsPunt];:ENDIF;	:END[Frame];</pre>
  </body>
</html>
