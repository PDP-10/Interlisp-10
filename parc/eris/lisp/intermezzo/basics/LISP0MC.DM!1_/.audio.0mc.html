<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[eris]&lt;Lisp>INTERMEZZO>BASICS>LISP0MC.DM!1>audio.0mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 12pt; text-align: left">
<span style="font: 12pt serif">:TITLE[Audio];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Last edited: 4 November 1981 by Fiala<br></span><span style="font: 10pt serif"><br>* January 7, 1983  4:21 PM van Melle<br>* added WithAudio switch July 2, 1982  3:44 PM <br>* Modified for Lisp - May 19, 1981  4:45 PM<br></span><span style="font: 12pt serif"><br>%This code manages synchronous circular buffers for audio input and output,<br>using a full duplex connection to the printer interface with a timer for<br>scheduling.  Because both the Audio driver and Midas use the Printer<br>interface, it does not make sense to debug this driver with Midas--this means<br>that a good choice for placement is on page 17, overwriting the Midas Kernel.<br><br>Input and output buffers have an identical form:  They begin on a quadaligned<br>storage boundary where the header is used as follows:<br>  word 0</span><span class="tab" val="67"></span><span style="font: 12pt serif">unsigned offset to 1st output word (ge 4);<br>  word 1</span><span class="tab" val="67"></span><span style="font: 12pt serif">unsigned offset to last output word;<br>  word 2</span><span class="tab" val="67"></span><span style="font: 12pt serif">unsigned offset to next output word to be processed by<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">microcode;<br>  word 3</span><span class="tab" val="67"></span><span style="font: 12pt serif">displacement from 1st word of output buffer to 1st word of<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">input buffer (will be added to word 2 mod 64K; ordinarily<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">this requires (word 1 + word 3) &lt; 64K).<br>Note that combined length of input and output buffers must be &lt; 64K words,<br>or &lt; 64K samples each.  Also note that if the displacement from the 1st word<br>in the output buffer to the 1st word in the input buffer is 0, then the<br>buffers will be coincident and, since output is done before input, the input<br>will be played back after a time delay equal to .125*nsamples/buffer msec.<br><br>To start audio input/output, push a long pointer to the quadaligned buffer<br>onto the stack followed by the AudioGo constant, and do JRAM.  The microcode<br>will then process both input and output continuously until terminated by<br>another AudioGo JRAM with an odd long pointer as its argument (Termination<br>will not actually occur until the Timer wakeup following this).  Microcode<br>never waits for software, so software must keep ahead or nullify buffer<br>contents when it is about to get behind and must guarantee no page faults on<br>audio data structures.  Page or write protect faults on other kinds of pages<br>would worsen the timing analysis below by about 9.0 us, so they aren&rsquo;t<br>allowed either.<br><br>New samples are handled every 125 us with the "ready" condition of the audio<br>device determined by polling; for guaranteed results, the timer must expire<br>early enough for timer resolution (6.4 us), completion by one lower and all<br>higher priority tasks, all competing timers, and the audio ucode itself (from<br>the beginning to the last Printer&larr; or &larr;Printer); also, samples must not be<br>handled during the last 8 (10?) us window before the next sample period.<br><br>No tasks are higher priority.  For the Alto system, the worst lower priority<br>competitor is the UTVFC, which might require 200 to 250 cycles/wakeup;<br>refresh is the only competing timer, requiring up to 35 cycles/wakeup.<br>The audio microcode below uses 51 cycles through its final io operation, so a<br>timer interval of 125 - 8.0 - 6.4 - 25 - 5.1 - 3.5 = 77 us appears safe.<br><br>For the Pilot/Cedar system, the worst lower priority competitor again appears<br>to be the UTVFC (?Check this?), which might require 62 cycles/task; refresh<br>and ethernet timers are the only competitors, with refresh requiring 26<br>cycles/wakeup.  The audio microcode below uses 51 cycles through its final<br>io operation, so a timer interval of 125 - 8.0 - 6.4 - 6.2 - 5.1 - 2.6 = 96.7<br>us appears safe.<br><br>At each wakeup, if the device is ready, the next io samples are processed;<br>else, if no buffers are setup, add to the timer and block.<br><br>A LoadTimer/AddToTimer must follow its predecessor by at least 6 cycles and<br>precede its successor by 8 cycles; the hardware requires separation by 14<br>cycles, enforced by this convention.  Branch conditions are illegal with<br>LoadTimer and AddToTimer.<br>%<br><br><br>SetTask[TTask];<br><br>:IF[AltoMode]; ***********************************<br>Set[AudTimerC,50322];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Simple timer, 13d x 6.4 us, slot 2<br><br>*These registers may be any in the 20b-77b range addressable by TTask.<br>RV[audTimer,30];<br>RV[audCnt,31];<br>RV2[audBuf,audBufhi,32];<br>RV[audTemp,43];<br><br>*These registers must be in the group of 20b registers reserved for TTask<br>*because they are sources or destinations for memory references.<br>Set[tRB,LShift[And[TTask,3],4]];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Enforce RM allocation requirements<br>RV4[audO1st,audOLast,audOPtr,audInBufOffset,Add[tRB,10]];<br>RV[audIWord,Add[tRB,14]];<br>RV[audOWord,Add[tRB,15]];<br>:ELSE; *******************************************<br>Set[AudTimerC,50362];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Simple timer, 15d x 6.4 us, slot 2<br><br>Set[tRB,LShift[And[TTask,3],4]];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Enforce RM allocation requirements<br><br>*These registers may be any in the 20b-77b range addressable by TTask.<br>RV[audTimer,34];<br>RV[audCnt,35];<br>RV2[audBuf,audBufhi,36];<br>RV[audTemp,Add[tRB,6]];<br><br>*These registers must be in the group of 20b registers reserved for TTask<br>*because they are sources or destinations for memory references.<br>RV4[audO1st,audOLast,audOPtr,audInBufOffset,Add[tRB,0]];<br>RV[audIWord,Add[tRB,4]];<br>RV[audOWord,Add[tRB,5]];<br>:ENDIF; ******************************************<br><br></span><span style="font: 10pt serif">SETTASK[0];<br>:IF[WithAudio];<br></span><span style="font: 12pt serif">IFE[WithMidas,1,ER[WARNING.Audio.can&rsquo;t.be.used.with.Midas,3]];<br><br></span><span style="font: 10pt serif">@Audio:</span><span class="tab" val="67"></span><span style="font: 10pt serif">lspLN &larr; HiA[audGoLoc, TTask], call[AudA], opcode[177];<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">goto[nxiLBL];<br><br>AudA:</span><span class="tab" val="67"></span><span style="font: 10pt serif">lspLN &larr; (lspLN) or (LoA[audGoLoc]);<br></span><span class="tab" val="67"></span><span style="font: 10pt serif">APCTask&APC &larr; lspLN, goto[retLBL];<br><br>SETTASK[TTask];<br></span><span style="font: 12pt serif">**JRAM starting constant is 160000b + audGoLoc.<br>*Initialize base registers and busy bits here.<br>audGo:</span><span class="tab" val="67"></span><span style="font: 12pt serif">audTimer &larr; HiA[AudTimerC], At[audGoLoc];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audTimer &larr; (audTimer) or (LoA[AudTimerC]);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LoadTimer[audTimer];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; Stack&-1;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audBuf &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; rhmask[Stack&+1];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audBufhi &larr; T, LoadPage[audPage];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audBufhi &larr; (LSh[audBufhi,10]) + T + 1;<br>OnPage[audPage];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">nop;</span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">* Wait for Base Hi to get written!!!<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PFetch4[audBuf,audO1st,0];<br>audRet:</span><span class="tab" val="67"></span><span style="font: 12pt serif">audCnt &larr; 101400C, Return;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Return to emulator JRAM return<br><br><br>%Timer dispatch comes here.  Timing from timer wakeup = 20 cycles when<br>device isn&rsquo;t ready yet, else 55 cycles on even iterations, 44 on odd,<br>plus 3 cycles on buffer wraparound.<br>%<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audBuf, Skip[R Even], At[TimerTable,15]; *Slot 2<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  Return;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Termination<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; audOPtr, LoadPage[audPage];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*LoadPage must be no earlier<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">AddToTimer[audTimer], gotop[.+1];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*AddToTimer at 5th mi after wakeup<br>OnPage[audPage];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audCnt &larr; (Printer &larr; audCnt) + 1, GoTo[aud0,R Odd];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Enable status<br>*Allow 1 mi after Printer&larr; before &larr;Printer for signal propagation.<br>*** (1 mi = 200 ns seems marginal delay for this).<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PFetch1[audBuf,audOWord];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; Printer, Skip[R Even];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  audCnt &larr; (audCnt) - 1, Return;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Block til ready<br></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span class="tab" val="67"></span><span style="font: 12pt serif">*Return at 4th mi after AddToTimer<br><br>**First two samples stored after start up are garbage<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audOPtr &larr; (audOPtr) + 1;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audIWord &larr; (audIWord) xnor (0C);</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Invert<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; (audOLast) - T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (audInBufOffset) + T, FreezeResult;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PStore1[audBuf,audIWord], GoTo[.+3,ALU#0];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  T &larr; audO1st;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  audOPtr &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audOWord &larr; (audOWord) xnor (0C);</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Invert<br>*Output next sample<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; RSh[audOWord,10], GoTo[aud1];<br><br>*audCnt alternates between 101400b and 101401b.<br>aud0:</span><span class="tab" val="67"></span><span style="font: 12pt serif">audCnt &larr; (audCnt) - (2C);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">LU &larr; Printer, Skip[R Even];<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">  audCnt &larr; (audCnt) + 1, Return;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">PStore1[audBuf,audOPtr,2];</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Store position for software<br>*Output next sample<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; RHMask[audOWord];<br><br>*audTemp &larr; 100000b or sample<br>aud1:</span><span class="tab" val="67"></span><span style="font: 12pt serif">audTemp &larr; T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audTemp &larr; (audTemp) or (100000C);<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; 1000C;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audTemp &larr; (Printer &larr; audTemp) or T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audTemp &larr; (Printer &larr; audTemp) and not T;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">Printer &larr; audTemp;<br><br>*Input next sample<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audTemp &larr; 100400C;<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (Printer &larr; audTemp) - 1;</span><span class="tab" val="67"></span><span style="font: 12pt serif">*Enable data read<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; 377C;<br>*&larr;Printer appears to be always negative here<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">T &larr; (Printer) and T;<br>*LH=previous, RH=new sample<br></span><span class="tab" val="67"></span><span style="font: 12pt serif">audIWord &larr; (LSh[audIWord,10]) or T, Return;<br><br>:ELSE;<br></span><span style="font: 10pt serif">@Audio:</span><span class="tab" val="67"></span><span style="font: 10pt serif">lspUFN&larr; 177c, goto[lspUfnxP5], opcode[177];<br></span><span style="font: 12pt serif">:ENDIF;<br><br>:END[Audio];</span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
