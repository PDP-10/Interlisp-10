<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>INTERMEZZO>BASICS>LISP0MC.DM!1>FVarlookup.0mc</title>
  </head>
  <body>
    <pre>
:TITLE[Fvarlookup.0mc, October 23, 1983  4:48 PM, van Melle];onpage[pgFvar];RM[FVep, IP[lspDefx1]];RM[Cnt, IP[lspDefx0]];RM[NamePtr, IP[lspGenBr]];RM[NamePtrHi, IP[lspGenBrHi]];** Called with name (litatom) to lookup in FVarName* Returns in FVarBinding/Hi a binding pointer* Important that FVarName ne 0 !!*FVarLookupName:	T &larr; (lspEp) - (12c);	FVep &larr; T, UseCtask;			* FVep &larr; current FX	T &larr; APC&amp;APCTask;:IF[FvarStatsMode];	lspStatsPtr, goto[FvStartStat, R&gt;=0];:ENDIF;	FVarReturnAddress &larr; T;			* save return linkNewFrame:	T &larr; (FVep) + (1c);	PFetch1[lspStkBr, FVep], task;		* FVep &larr; FVep:#Alink	FVep &larr; (FVep) - (12c);	T &larr; FVep &larr; (FVep) and not (1c);		* FVep &larr; FX base	goto[EndOfStack, alu=0];	PFetch1[lspStkBr, Cnt];			* get frame flags,,usecount	lu &larr; (Cnt) and (10000c);		* Test F bit	lu &larr; (Cnt) and (1000c), skip[alu=0];	* test V = nametab valid bit	  goto[NewFrame];			* skip frame if binds no vars	T &larr; (FVep) + (2c), skip[alu=0];	* T &larr; offset of Fnheader (V=0)	  T &larr; (FVep) + (6c);		* T &larr; offset of name table (V=1)	PFetch2[lspStkBr, NamePtr];	* get one or the other	T &larr; rhmask[NamePtrHi];	NamePtrHi &larr; (lsh[NamePtrHi, 10]) or T;				* why bother putting it in both halves?	T &larr; Cnt &larr; 10c;		* Offset of names in nametableSearchLoop:	PFetch4[NamePtr, xBuf], call[retLBL];				* Fetch next 4 words of nametable	T &larr; FVarName;		* Name to compare against				* Now compare T against each item in xBuf				* DispTable arrangement is for Dispatch				* following PVar1, which dispatches to the				* odd locationsLook0:	lu &larr; (xBuf) xor T, disptable[10];			* [0]Look1:	lu &larr; (xBuf1) xor T, dblgoto[Look2, Found0, alu#0];	* [1]Found0:	T &larr; Cnt, goto[Found];					* [2]Look2:	lu &larr; (xBuf2) xor T, dblgoto[Look3, Found1, alu#0];	* [3]Found1:	T &larr; Cnt &larr; (Cnt) + (1c), goto[Found];			* [4]Look3:	lu &larr; (xBuf3) xor T, dblgoto[Look4, Found2, alu#0];	* [5]Found2:	T &larr; Cnt &larr; (Cnt) + (2c), goto[Found];			* [6]Look4:	lu &larr; xBuf3, dblgoto[EndTest, Found3, alu#0];		* [7]Found3:	T &larr; Cnt &larr; (Cnt) + (3c), goto[Found];EndTest:	T &larr; Cnt &larr; (Cnt) + (4c), dblgoto[SearchLoop, NewFrame, alu#0];					* Nametable ends in zeroesFound:	PFetch1[NamePtr, lspL4, 6], call[retLBL];	* L4 &larr; NTSIZE,						* avoiding passaround failure	T &larr; (lspL4) + T;			* offset of second NT slot	PFetch1[NamePtr, lspL4];		* L4 &larr; flag,,offset	T &larr; rhmask[lspL4];			* offset of var wherever	lspL4 &larr; (lspL4) + T, goto[FoundAsIVar, R&gt;=0];	* word offsetFPvar:						* L4[0:1] = 10 or 11	T &larr; (FVep) + (12c);			* Find start of Pvars	T &larr; (rhmask[lspL4]) + T;		* Look at Nth Pvar	PFetch2[lspStkBr, FVarBinding];	* Fetch pvar value or fvar binding	lu &larr; (lspL4) and (40000c);		* which are we looking at?	goto[FoundAsPVar, alu=0];	lu &larr; FVarBinding, goto[FoundVal, R Even];	* has been looked up						* May want to create chain	goto[NewFrame];FoundAsPVar:			* fetched FVarBinding out of a PVAR slot	lu &larr; FVarBinding, goto[FailedAsPVar, R&lt;0];	* unbound if high bit on	FVarBinding &larr; T, goto[LookStackPtr];	* return ptr to this bindingFailedAsPVar:	* unbound pvar--loop, since there may be a bound one in same frame	* Need to get back into the main loop where we left off.  Cnt is	* offset of this instance of FVarName.  We shift Cnt left one and	* dispatch to 1 + that value of Cnt; e.g., if Cnt mod 4 = 2, then	* go to Look3.	T &larr; (lsh[Cnt, 1]) + 1;	lspL4 &larr; T;	Cnt &larr; (Cnt) and not (3c);	* Restore Cnt mod 4	Dispatch[lspL4, 15, 3];		* Always odd	T &larr; FVarName, disp[Look0];			* Note that alu#0, so the first goto works rightFoundAsIVar:	T &larr; (FVep) - 1;	PFetch1[lspStkBr, FVarBinding];		* Fetch ptr to Ivar start	T &larr; rhmask[lspL4];			* Add in offset	FVarBinding &larr; (FVarBinding) + T;LookStackPtr:	T &larr; FVarBindingHi &larr; (StackSpaceR);LookPtrHi:	FVarBindingHi &larr; (lsh[FVarBindingHi, 10]) or T, goto[FoundVal];EndOfStack:				* stack exhausted, point at value cell	T &larr; lsh[FVarName, 1], goto[EOSBig, r&lt;0];	* atomnumber * 2	FVarBinding &larr; T;	T &larr; FVarBindingHi &larr; (VALspaceR), goto[LookPtrHi];EOSBig:	FVarBinding &larr; T;		* value cell in second segment	T &larr; FVarBindingHi &larr; (VALspace2R), goto[LookPtrHi];:IF[FvarStatsMode];FoundVal:	lspStatsPtr, goto[FVExitStat, R&gt;=0];	APC&amp;APCTask &larr; FVarReturnAddress;:ELSE;FoundVal:	APC&amp;APCTask &larr; FVarReturnAddress;:ENDIF;FVLookupExit:	T &larr; SavedFvarOffset, return;	* T for benefit of FVar and FVar&larr;* Eval, op 54Eval:	call[lspTyp], opcode[54];	* get type in LN, pop TOS into L3,2	loadpage[pgEval];	T &larr; (lspType) - (listType);	* is it Listp?onpage[pgEval];	FreezeResult, goto[EvalList, alu=0];	* yes, do evalform	skip[alu&lt;0], lu &larr; (lspType) - (atomType);	* is TOS atom or less?	  lspUFN &larr; 54c, goto[ufnLBL];	* types greater than listp punt	T &larr; lspL2, skip[alu=0];		* Skip if type atom	  NextOpCode;			* Smallp, fixp, floatp eval to self					* TOS is atom.  Thus L3=0, L2 = atom#	lu &larr; (lspL2) - (KtVal), skip[alu#0];	  NextOpCode;			* NIL evals to self	skip[alu#0];	  NextOpCode;			* so does T	loadpage[pgFvar];	FVarName &larr; T, callp[FVarLookupName];					* Returns FVarBinding = binding slot	PFetch2[FVarBinding, lspL2, 0];	T &larr; lspL2;			* test L2,3 = NOBIND	lu &larr; (lspL3) - (atomNOBIND), goto[EvalOk, alu#0];	skip[alu#0];	  lspUFN &larr; (54c), goto[ufnLBL];	* punt if var's value is NOBIND				* Note this is not right if var is				* actually BOUND to NOBIND, but who cares?	nop;			* allocation constraintEvalOk:	Stack&amp;-1 &larr; T;		* = L2, hi half of value	T &larr; lspL3;	Stack&amp;+1 &larr; T, goto[nxiLBL];EvalList:			* Eval a list.  Do this by calling a				* special fn, rather than normal ufn, thus				* saving a frame in the interpreter.				* T is conveniently zero from previous lu	lspDefx1 &larr; atomEVALFORM;	lspDefx0 &larr; T, loadpage[pgFrame];	* &larr; 0	lspNargs &larr; 1c, gotop[lspCallFn];* StkScan, op 57: TOS -&gt; binding pointer of TOSStkScan:	T &larr; Stack&amp;-1, opcode[057];	lu &larr; Stack&amp;-1, goto[StkScanNil, alu=0];	skip[alu=0];				* Is hiloc of TOS zero?	  lspUFN &larr; 57c, goto[ufnLBL];		* no, punt	loadpage[pgFvar];	FVarName &larr; T, callp[FVarLookupName];	T &larr; rsh[FVarBindingHi, 10];			* hiloc of binding ptr	Stack&amp;+1 &larr; T;	T &larr; FVarBinding;StkScanPush:	Stack&amp;+1 &larr; T, goto[nxiLBL];StkScanNil:	Stack&amp;+1 &larr; (ValSpaceR), goto[StkScanPush];	* Note that T = 0	:END[Fvarlookup];</pre>
  </body>
</html>
