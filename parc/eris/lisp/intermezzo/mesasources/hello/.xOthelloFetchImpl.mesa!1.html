<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;Lisp>INTERMEZZO>mesasources>hello>xOthelloFetchImpl.mesa!1</title>
  </head>
  <body>
    <pre>
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- OthelloFetchImpl.mesa--  Johnsson	26-Feb-84 15:24:23--  Davirro	 5-Nov-84 10:53:21--  Masinter	16-Dec-84 15:54:49DIRECTORY  Auth,  Environment USING [bytesPerPage, bytesPerWord],  File USING [    Create, Delete, File, MakePermanent, nullFile, PageNumber, PageCount, GetSize, SetSize, Unknown],  FileTypes USING [tUntypedFile],  Heap USING [systemZone],  NSName,  NSString,  OthelloDefs USING [    AbortingCommand, CommandProcessor, Confirm, FlipCursor, GetLvIDFromUser, GetName,    IndexTooLarge, LeaderPage, leaderPages, lpNoteLength, lpVersion,    MyNameIs, Question, RegisterCommandProc, WriteLine, WriteLongNumber, WriteString, Yes],  OthelloFetch USING [Destination, Handle, Object],  OthelloOps USING [    BootFileType, GetVolumeBootFile, GetPhysicalVolumeBootFile, MakeBootable, MakeUnbootable,    SetPhysicalVolumeBootFile, SetVolumeBootFile, VoidVolumeBootFile, VoidPhysicalVolumeBootFile],  PhysicalVolume USING [ID],  Process USING [Detach],  Profile ,  Space USING [Map, CopyIn, ScratchMap, Unmap, Window],  Stream,  String ,  TemporaryBooting USING [InvalidParameters],  Volume USING [Close, GetAttributes, ID, InsufficientSpace, nullID, Open];OthelloFetchImpl: PROGRAM  IMPORTS Auth, File, Heap, NSString, OthelloDefs, OthelloOps, Process, Space, Stream, String, TemporaryBooting, Volume  EXPORTS OthelloDefs, OthelloFetch, Profile =  BEGIN    Object: TYPE = OthelloFetch.Object;    Handle: TYPE = OthelloFetch.Handle;    list: Handle &larr; NIL;    current: Handle &larr; NIL;    cmFile: LONG STRING &larr; NIL;  fileName: LONG STRING &larr; NIL;  z: UNCOUNTED ZONE = Heap.systemZone;  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};      -- Fetcher registration    Register: PUBLIC PROC [h: Handle] =    BEGIN    h.next &larr; list;    list&larr; h;    END;    Select: PUBLIC PROC [h: Handle] =    BEGIN    IF current # NIL THEN current.Close[];    current&larr; h;    END;    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- String/Credentials Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  domain, org: LONG STRING &larr; NIL;    GetDefaultDomain: --Profile--PUBLIC PROC [proc: PROC [LONG STRING]] = {    proc[domain]};    GetDefaultOrganization: --Profile--PUBLIC PROC [proc: PROC [LONG STRING]] = {    proc[org]};    GetID: --Profile--PUBLIC PROC [    flavor: Auth.Flavor, proc: PROC [id: Auth.IdentityHandle]] =    BEGIN    SELECT flavor FROM      simple =&gt; proc[simple];      strong =&gt; proc[strong];      ENDCASE =&gt; ERROR;    END;  Qualify: --Profile--PUBLIC PROC [    token, newToken: LONG STRING,    qualification: Profile.Qualification &larr; clearinghouse] = {    namePart: CARDINAL &larr; String.Length[token];    currentQual: Profile.Qualification &larr; none;    octalAddress: BOOLEAN &larr; TRUE; -- only '0..'7 and '# allowed    ss: String.SubStringDescriptor;    chChar: CHARACTER = ':;    regChar: CHARACTER = '.;    IF String.Length[token] = 0 THEN RETURN;    FOR i: CARDINAL IN [0..token.length) DO       SELECT token[i] FROM         regChar =&gt; {namePart &larr; i; currentQual &larr; registry};  -- look for last dot	 chChar =&gt; {namePart &larr; i; currentQual &larr; clearinghouse; EXIT}; -- first :	 IN['0..'7], '# =&gt; NULL;	 ENDCASE =&gt; octalAddress &larr; FALSE;       ENDLOOP;    IF currentQual = qualification OR octalAddress THEN {      String.AppendString[newToken, token]; RETURN};    ss &larr; [base: token, offset: 0, length: namePart];    String.AppendSubString[newToken, @ss];    SELECT qualification FROM      none =&gt; NULL;    &lt;&lt;registry =&gt;        IF String.Length[defaultRegistry] &gt; 0 THEN {	  String.AppendChar[newToken, regChar];	  String.AppendString[newToken, defaultRegistry]};&gt;&gt;      clearinghouse =&gt;        IF String.Length[domain] &gt; 0 OR 	   String.Length[org] &gt; 0 THEN {	  String.AppendChar[newToken, chChar];	  String.AppendString[newToken, domain];	  String.AppendChar[newToken, chChar];	  String.AppendString[newToken, org]};      ENDCASE};        ClearinghouseCmd: PROC = {    OthelloDefs.MyNameIs[	  myNameIs: "Clearinghouse"L,	  myHelpIs: "Set defaults for Clearinghouse"L];    OthelloDefs.GetName["Domain: "L, @domain];    OthelloDefs.GetName["Organization: "L, @org]};    userName: PUBLIC LONG STRING &larr; NIL;  userPassword: PUBLIC LONG STRING &larr; NIL;  strong, simple: Auth.IdentityHandle &larr; NIL;    LoginCmd: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Login"L, myHelpIs: "Set user name &amp; password"L];    OthelloDefs.GetName["User: "L, @userName];    OthelloDefs.GetName["Password: "L, @userPassword, stars];    IF simple # NIL THEN Auth.FreeIdentity[@simple, z];    IF strong # NIL THEN Auth.FreeIdentity[@strong, z];    simple &larr; MakeID[flavor: simple];    strong &larr; MakeID[flavor: strong]};  MakeID: PROC [flavor: Auth.Flavor] RETURNS [id: Auth.IdentityHandle] = {    myName: NSName.NameRecord &larr; [      org: S[org], domain: S[domain], local: S[userName]];    id &larr; Auth.MakeIdentity[      myName: @myName,      password: S[userPassword],      z: z,      style: flavor,      dontCheck: TRUE]};      directory: PUBLIC LONG STRING &larr; NIL;  Directory: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Directory"L,      myHelpIs: "Set Default FTP directory"L];    OthelloDefs.GetName["Directory: "L, @directory]};    -- Simple Fetches  FetchBoot: PROC = {    Fetch[pilot, "Boot file name: "L, "Fetch Boot File"L, "Fetch Boot File"L, "boot"L]};  FetchGerm: PROC = {    Fetch[germ,  "Germ file name: "L, "Germ Fetch"L, "Fetch Germ"L, "germ"L]};  FetchPilotMicrocode: PROC = {    Fetch[      softMicrocode,      "Pilot microcode file name: "L,      "Pilot Microcode Fetch"L,      "Fetch and Install Pilot Microcode"L,      "db"L]};  FetchDiagnosticMicrocode: PROC = {    Fetch[      hardMicrocode,      "Diagnostic microcode file name: "L,      "Diagnostic Microcode Fetch"L,      "Fetch and Install Diagnostic Microcode"L,      "db"L]};    FetchLisp: PROC = {    Fetch[      hardMicrocode,      "Lisp sysout file name: "L,      "Lisp Sysout Fetch"L,      "Fetch and Install Interlisp Sysout"L,      "sysout"L]};  Fetch: PROC [    type: OthelloOps.BootFileType, prompt, name, helpMsg, extension: STRING] = {    created: BOOLEAN;    file: File.File;    firstPage: File.PageNumber;    lvID: Volume.ID;    OthelloDefs.MyNameIs[myNameIs: name, myHelpIs: helpMsg];    CheckOpen[];    lvID &larr; OthelloDefs.GetLvIDFromUser[].lvID;    OthelloDefs.GetName[prompt, @fileName];    Volume.Open[lvID];    [file, firstPage] &larr; OthelloOps.GetVolumeBootFile[lvID, type];    IF (created &larr; file = File.nullFile) THEN      file &larr; File.Create[lvID, 1, FileTypes.tUntypedFile]    ELSE OthelloOps.MakeUnbootable[file, type, firstPage !       File.Unknown =&gt; CONTINUE;      TemporaryBooting.InvalidParameters =&gt; {        OthelloDefs.WriteLine["Warning, trouble making unbootable"L];	CONTINUE}];    current.Retrieve[fileName, [pilotFileSystemWrite[file]]      ! UNWIND =&gt; {IF created THEN File.Delete[file]; Volume.Close[lvID]}];    OthelloDefs.WriteString["Installing..."L];    OthelloOps.SetVolumeBootFile[file, type, OthelloDefs.leaderPages];    IF created THEN File.MakePermanent[file];-- add for LISP    IF String.Equal[extension, "sysout"L] THEN {   	OthelloDefs.WriteString["Expanding to fill volume..."L];   	SetBootFileSize[file,lvID];    	OthelloDefs.WriteString["OK..."L];	};-- end    OthelloOps.MakeBootable[file, type, OthelloDefs.leaderPages    ! TemporaryBooting.InvalidParameters =&gt; {      OthelloDefs.WriteLine["Warning, trouble making bootable"L]; CONTINUE}];    OthelloDefs.WriteLine["done"L];    IF type IN [hardMicrocode..germ] AND       OthelloDefs.Yes["Shall I also use this for the Physical Volume? "L       ! UNWIND =&gt; Volume.Close[lvID]] THEN      OthelloOps.SetPhysicalVolumeBootFile[file, type, OthelloDefs.leaderPages];    Volume.Close[lvID]};      bufPages: CARDINAL = 8;  StartFeedback: PUBLIC SIGNAL = CODE;  GrabBitsFromStream: PUBLIC PROC [    rs: Stream.Handle, rsSizePages: LONG CARDINAL,    destination: OthelloFetch.Destination, note: LONG STRING &larr; NIL] = {    WITH destination SELECT FROM      pilotFileSystemWrite =&gt; {	buffer: LONG POINTER &larr; NIL;        base: File.PageNumber &larr; 0;	got: CARDINAL;        File.SetSize[localFile, rsSizePages + OthelloDefs.leaderPages	! Volume.InsufficientSpace =&gt; OthelloDefs.AbortingCommand["Volume Full"L]];	SetLeaderPage[localFile, note];	SIGNAL StartFeedback;	WHILE base &lt; rsSizePages DO          thisPages: CARDINAL = CARDINAL[MIN[rsSizePages-base, bufPages]];	  size:      CARDINAL = thisPages*Environment.bytesPerPage;	  start:     CARDINAL &larr; 0;	  buffer &larr; Space.Map[	    window:[localFile, base+OthelloDefs.leaderPages, thisPages],	    life: dead].pointer;          DO	    [bytesTransferred: got] &larr; rs.GetBlock[[	      blockPointer: buffer, startIndex: start, stopIndexPlusOne: size] !	        Stream.EndOfStream =&gt; {	          got &larr; 0; start &larr; start + nextIndex; CONTINUE};	        UNWIND =&gt; [] &larr; Space.Unmap[buffer]];	    IF got = 0 THEN {[] &larr; Space.Unmap[buffer]; RETURN};            IF (start &larr; start + got) = size THEN EXIT;            ENDLOOP;          --buffer &larr; Space.Unmap[buffer, return];	  Process.Detach[LOOPHOLE[FORK Space.Unmap[buffer]]]; buffer &larr; NIL;          OthelloDefs.FlipCursor[];	  base &larr; base + thisPages;          ENDLOOP;	buffer &larr; Space.ScratchMap[1]; -- check for any leftover stuff	[bytesTransferred: got] &larr; rs.GetBlock[[	  blockPointer: buffer, startIndex: 0,	  stopIndexPlusOne: Environment.bytesPerPage] !	    Stream.EndOfStream =&gt; {got &larr; nextIndex; CONTINUE};	    UNWIND =&gt; [] &larr; Space.Unmap[buffer]];	[] &larr; Space.Unmap[buffer];	IF got # 0 THEN OthelloDefs.AbortingCommand[	  "File longer than advertised length"L]};      string =&gt; {	SIGNAL StartFeedback;	DO          stringOverhead: CARDINAL = SIZE[StringBody]*Environment.bytesPerWord;          string: LONG STRING = Space.ScratchMap[bufPages];          string&uarr; &larr; [	    length: 0,	    maxlength: bufPages*Environment.bytesPerPage - stringOverhead,	    text: ];	  WHILE string.length &lt; string.maxlength DO            got: CARDINAL;	    [bytesTransferred: got] &larr; rs.get[	      rs,	      [blockPointer: LOOPHOLE[@string.text],	       startIndex: string.length, stopIndexPlusOne: string.maxlength],	      rs.options	      ! Stream.EndOfStream =&gt; {	          got &larr; 0; string.length &larr; string.length + nextIndex; CONTINUE};                UNWIND =&gt; [] &larr; Space.Unmap[string]];	    IF got = 0 THEN {	      stringProc[string! UNWIND =&gt; [] &larr; Space.Unmap[string]];	      [] &larr; Space.Unmap[string]; RETURN};            string.length &larr; string.length + got;            ENDLOOP;          [] &larr; Space.Unmap[string];          OthelloDefs.AbortingCommand["Command file too long!"L];          ENDLOOP};      rawWrite =&gt;{	buffer: LONG POINTER = Space.ScratchMap[1];        done:  BOOLEAN &larr; FALSE;        first: BOOLEAN &larr; TRUE;	options: Stream.InputOptions &larr; rs.options;	GetPage: PROC RETURNS [LONG POINTER] = {          got:   CARDINAL; index: CARDINAL &larr; 0;          IF first THEN {SIGNAL StartFeedback; first &larr; FALSE};	  WHILE ~done DO	    [bytesTransferred: got] &larr; rs.get[	      sH: rs,	      block: [blockPointer: buffer, startIndex: index,	       stopIndexPlusOne: Environment.bytesPerPage],	      options: options	      ! Stream.EndOfStream =&gt; {got &larr; nextIndex; done &larr; TRUE; CONTINUE}];            IF (index &larr; index + got) = Environment.bytesPerPage 	       OR done THEN {OthelloDefs.FlipCursor[]; EXIT}            ENDLOOP;          RETURN[IF done AND index = 0 THEN NIL ELSE buffer]};	options.signalEndOfStream &larr; TRUE;        linkProc[GetPage ! UNWIND =&gt; [] &larr; Space.Unmap[buffer]];        WHILE ~done DO [] &larr; GetPage[! UNWIND =&gt; [] &larr; Space.Unmap[buffer]] ENDLOOP;        [] &larr; Space.Unmap[buffer]};      ENDCASE =&gt; ERROR};     -- Initial Ucode Fetch Command  FetchInitialMicrocode: PUBLIC PROC [    InstallProc: PROC [getPage: PROC RETURNS [LONG POINTER]]] = {    CheckOpen[];    OthelloDefs.GetName["File name: "L, @fileName];    OthelloDefs.Confirm[];    current.Retrieve[fileName, [rawWrite[InstallProc]]]};      -- Command Files    AlternateGetCMFile: PUBLIC PROC [s: STRING] = {    z.FREE[@cmFile];    cmFile &larr; z.NEW[StringBody[s.length+8]];    FOR i: CARDINAL IN [1..s.length) DO      String.AppendChar[cmFile, s[i]] ENDLOOP;    DoIndirect[]};  Indirect: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "@", myHelpIs: "Run command file"L];    OthelloDefs.GetName["Command file: "L, @cmFile    ! OthelloDefs.Question =&gt; {      OthelloDefs.WriteLine["[Host]&lt;Dir&gt;Filename"L]; RESUME}];    DoIndirect[]};    DoIndirect: PROC = {    [] &larr; String.AppendExtensionIfNeeded[@cmFile, "othello"L, z];    FOR h: Handle &larr; list, h.next UNTIL h = NIL DO      IF h.DoIndirect[cmFile] THEN RETURN;      ENDLOOP;    OthelloDefs.AbortingCommand["Unrecognizable command file name"L]};      -- Misc. commands    CloseCmd: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Close"L, myHelpIs: "Close currently open connection"L];    CloseFetch[]};    CloseFetch: PUBLIC PROC = {    Select[NIL]};    ListCmd: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "List Files"L, myHelpIs: "Enumerate files matching pattern"L];    CheckOpen[];    OthelloDefs.GetName["Pattern: "L, @fileName    ! OthelloDefs.Question =&gt; {      OthelloDefs.WriteLine["pattern to match"L]; RESUME}];    current.List[fileName]};    CheckOpen: PROC = {    IF current = NIL THEN      OthelloDefs.AbortingCommand["You must execute an Open command first"L]};    SetLeaderPage: PUBLIC PROCEDURE [file: File.File, note: LONG STRING] =    BEGIN    lp: LONG POINTER TO OthelloDefs.LeaderPage &larr; Space.Map[[file, 0, OthelloDefs.leaderPages]].pointer;    lp.version &larr; OthelloDefs.lpVersion;    lp.length &larr; MIN[note.length, OthelloDefs.lpNoteLength];    FOR i: CARDINAL IN [0..lp.length) DO      lp.note[i] &larr; note[i];      ENDLOOP;    [] &larr; Space.Unmap[lp];    END;     -- Commands for Interlisp-D   CopyLisp: PROC = BEGIN    fromVolume, toVolume: Volume.ID;    fromFile, toFile: File.File;    pvID: PhysicalVolume.ID;    error: BOOLEAN &larr; FALSE;    currentBase: File.PageNumber;    nextCount: File.PageCount;    fromWindow,toWindow: Space.Window;    toPointer: LONG POINTER;    fromPage1: LONG POINTER TO ARRAY[0..20] OF WORD; -- Lisp Interface Page    fromFileSize: File.PageCount;    fromFileActive: CARDINAL;    tries: CARDINAL;    toFileSize: File.PageCount;    minFileSize: File.PageCount;    OthelloDefs.MyNameIs[      myNameIs: "Copy Lisp From Another Volume"L,      myHelpIs: "Copies lisp from one volume to another"L];      [pvID, fromVolume] &larr; OthelloDefs.GetLvIDFromUser[prompt:"Volume to copy from: "L];      IF fromVolume = Volume.nullID THEN OthelloDefs.AbortingCommand["Invalid volume."L];      toVolume &larr; OthelloDefs.GetLvIDFromUser[prompt:"Volume to copy to:  "L].lvID;      IF toVolume = Volume.nullID THEN OthelloDefs.AbortingCommand["Invalid volume."L];      -- Open up the volumes      Volume.Open[fromVolume];      Volume.Open[toVolume];      -- Is there a source file?      fromFile &larr; OthelloOps.GetVolumeBootFile[fromVolume,hardMicrocode].file;      IF fromFile = File.nullFile THEN {      		Volume.Close[fromVolume];      		Volume.Close[toVolume];      		OthelloDefs.AbortingCommand["No Lisp sysout on source volume"L];		};      -- Is there a dest file? Delete it if yes.      toFile &larr; OthelloOps.GetVolumeBootFile[toVolume,hardMicrocode].file;      IF toFile # File.nullFile THEN {      	   OthelloOps.VoidVolumeBootFile[toVolume,hardMicrocode];	   File.Delete[toFile];	   IF OthelloOps.GetPhysicalVolumeBootFile[pvID,hardMicrocode].file = toFile	   THEN OthelloOps.VoidPhysicalVolumeBootFile[pvID,hardMicrocode];	   };      -- Create the dest file      fromWindow &larr; [file: fromFile,             	    base: 1 + OthelloDefs.leaderPages,		    count: 1];      fromPage1 &larr; Space.Map[fromWindow].pointer;      fromFileSize &larr; File.GetSize[fromFile];      fromFileActive &larr; fromPage1[20];      fromPage1 &larr; Space.Unmap[fromPage1];      IF fromFileActive &lt; 1000 THEN {Volume.Close[fromVolume];      		     Volume.Close[toVolume];      		     OthelloDefs.AbortingCommand["Source volume doesn't contain a Lisp system!"L];};      IF fromFileActive &gt; fromFileSize THEN {Volume.Close[fromVolume];      		     Volume.Close[toVolume];      		     OthelloDefs.AbortingCommand["Can't copy a VMEM that has been already expanded by Lisp!"L];};      toFileSize &larr; fromFileActive;      tries &larr; 1;      toFile &larr; File.Create[toVolume, toFileSize, FileTypes.tUntypedFile      			! Volume.InsufficientSpace =&gt; 			    { tries &larr; tries - 1;			      toFileSize &larr; toFileSize - 100;			      OthelloDefs.WriteString["."L];			      IF tries = 0 OR toFileSize &lt; 0 THEN {error &larr; TRUE;			    		CONTINUE}			      ELSE RETRY;};];      IF error THEN {Volume.Close[fromVolume];      		     Volume.Close[toVolume];      		     OthelloDefs.AbortingCommand["Destination volume does not contain sufficient space!"L];};      File.MakePermanent[toFile];      -- Create windows onto the file      OthelloDefs.WriteString["Copying "L];      OthelloDefs.WriteLongNumber[toFileSize];      OthelloDefs.WriteString["pages... "L];      currentBase &larr; 0;      nextCount &larr; 100;      DO -- until file has been copied         nextCount &larr; MIN[100,fromFileActive-currentBase];	 IF nextCount=0 THEN EXIT;	 fromWindow &larr; [file: fromFile,      		       base: currentBase,		       count: nextCount];         toWindow &larr; [file: toFile,      		     base: currentBase,		     count: nextCount];         toPointer &larr; Space.Map[toWindow].pointer;	 nextCount &larr; Space.CopyIn[toPointer,fromWindow];	 toPointer &larr; Space.Unmap[toPointer];	 currentBase &larr; currentBase + nextCount;	 OthelloDefs.WriteString["."L];         IF currentBase &gt;= minFileSize THEN EXIT;       ENDLOOP;      OthelloDefs.WriteString["Installing..."L];      OthelloOps.MakeBootable[toFile, hardMicrocode, OthelloDefs.leaderPages           ! TemporaryBooting.InvalidParameters =&gt; {             OthelloDefs.WriteLine["Warning, trouble making bootable"L]; CONTINUE}];      OthelloOps.SetVolumeBootFile[toFile,hardMicrocode,OthelloDefs.leaderPages];      OthelloDefs.WriteLine["done"L];      Volume.Close[fromVolume];      Volume.Close[toVolume];      END;-- This kludge sets the file's size to be as big as Pilot will let it be, on 100 page increments.  SetBootFileSize: PRIVATE PROC[file: File.File, lvID: Volume.ID] = BEGIN    tries: CARDINAL;     oldSize: File.PageCount &larr; File.GetSize[file];    newSize: File.PageCount &larr; oldSize + Volume.GetAttributes[lvID].freePageCount;    tries &larr; 20;    OthelloOps.MakeUnbootable[file, hardMicrocode, OthelloDefs.leaderPages];    File.SetSize[file, newSize 	  ! File.Unknown =&gt; {OthelloDefs.WriteLine["Warning: Trouble making file fill volume - File.Unknown"L];	    CONTINUE};	    Volume.InsufficientSpace =&gt; {OthelloDefs.WriteString["."L]; newSize &larr; newSize - 100;	    tries &larr; tries - 1; 	    IF tries = 0 OR newSize &lt; oldSize THEN {OthelloDefs.WriteLine["Warning: Expanding volume failed!"]; CONTINUE;} ELSE RETRY};];    OthelloOps.MakeBootable[file,hardMicrocode, OthelloDefs.leaderPages];    END;        ExpandLisp: PROC = BEGIN      pvID: PhysicalVolume.ID;      exVolume: Volume.ID;      exFile: File.File;      OthelloDefs.MyNameIs[         myNameIs: "Expand Lisp Virtual Memory File"L,	 myHelpIs: "Expand the lisp virtual memory file on a volume"L];      [pvID, exVolume] &larr; OthelloDefs.GetLvIDFromUser[prompt:"Volume to expand: "L];      IF exVolume = Volume.nullID THEN OthelloDefs.AbortingCommand["Invalid volume."L];      Volume.Open[exVolume];      exFile &larr; OthelloOps.GetVolumeBootFile[exVolume, hardMicrocode].file;      IF exFile = File.nullFile THEN OthelloDefs.AbortingCommand["No sysout on volume."L];      OthelloDefs.WriteString["Expanding file..."L];      SetBootFileSize[exFile,exVolume];      OthelloDefs.WriteLine["Done."L];      Volume.Close[exVolume];      END;  -- command processor  commandProcessor: OthelloDefs.CommandProcessor &larr; [FetchCommands];  FetchCommands: PROC [index: CARDINAL] = {    SELECT index FROM      0 =&gt; Indirect[];      1 =&gt; ClearinghouseCmd[];      2 =&gt; CloseCmd[];      3 =&gt; Directory[];      4 =&gt; FetchBoot[];      5 =&gt; FetchDiagnosticMicrocode[];      6 =&gt; FetchGerm[];      7 =&gt; FetchPilotMicrocode[];      8 =&gt; ListCmd[];      9 =&gt; LoginCmd[];      10 =&gt; FetchLisp[];      11 =&gt; CopyLisp[];      12 =&gt; ExpandLisp[];      ENDCASE =&gt; OthelloDefs.IndexTooLarge};  -- init  OthelloDefs.RegisterCommandProc[@commandProcessor];  END.</pre>
  </body>
</html>
