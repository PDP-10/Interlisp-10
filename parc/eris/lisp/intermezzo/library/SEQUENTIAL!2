(FILECREATED " 1-Mar-85 14:24:27" {ERIS}<LISP>INTERMEZZO>LIBRARY>SEQUENTIAL.;2 18655        changes to:  (VARS SEQUENTIALCOMS)      previous date: " 3-Dec-84 22:56:30" {ERIS}<LISP>INTERMEZZO>LIBRARY>SEQUENTIAL.;1)(* Copyright (c) 1984, 1985 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT SEQUENTIALCOMS)(RPAQQ SEQUENTIALCOMS ((RECORDS SEQUENTIALRUNS)		       (FNS DO.SEQUENTIAL.RUNS \SEQ.PRIN4 \SEQ.DEFAULTFILENAME \SEQ.WORDOUT 			    \SEQ.HOSTHASDIRECTORYSTRUCTUREP \SEQ.RELOAD \SEQ.RUN \SEQ.RUN1)		       (DECLARE: EVAL@COMPILE DONTCOPY (RECORDS INDEXREGION)				 (MACROS INDEXREGION.MOVETO READDBFILEWORD)				 (CONSTANTS INDEXREGION.OFFST RUNSREGION.OFFST))		       (DECLARE: DONTEVAL@LOAD DOCOPY (FILES PAGEHOLD))))[DECLARE: EVAL@COMPILE (TYPERECORD SEQUENTIALRUNS (INITFORMS CLEANUPFORMS FINALREM.CM . RELOADINGFORMS))](DEFINEQ(DO.SEQUENTIAL.RUNS  [LAMBDA (SEQUENTIALRUNS LISP.SYSOUTFILE SEQUENTIAL.DCOMFILE LOGFILE SEQUENCING.DATAFILE)                                                             (* JonL " 3-Dec-84 22:56")          (* * Creates and returns an open stream to a database file, which has the following structure: Word 16 	  (0 origin) contains n the number of "runs" to make, word 17 contains the index of the currently running form, word 	  18 contains the file index of the LISP.SYSOUTFILE name, word 19 contains the index of the SEQUENTIAL.DCOMFILE name, 	  word 20 contains the name of the "logging" file, and word 21 contains the name of the database file.	  Word 32 contains the file index of the initialization form, and words 33 through n+33 contains the file indices of 	  the s-expressions for each form to be run, and word n+34 contains the fileindex of the cleanup form.)    (OR (type? SEQUENTIALRUNS SEQUENTIALRUNS)	(\ILLEGAL.ARG SEQUENTIALRUNS))    (if (AND LISP.SYSOUTFILE (LITATOM LISP.SYSOUTFILE)	     (FILENAMEFIELD LISP.SYSOUTFILE (QUOTE VERSION)))	then (ERROR LISP.SYSOUTFILE 		    "Not possible to use explicit version numbers in LISP.SYSOUT file"))    (SETQ LISP.SYSOUTFILE (OR (\SEQ.DEFAULTFILENAME LISP.SYSOUTFILE						    (if (AND (BOUNDP (QUOTE MAKESYSNAME))							     MAKESYSNAME)							then (PACK* (QUOTE <LISP>)								    MAKESYSNAME								    (QUOTE >LISP.SYSOUT))						      else (QUOTE <LISP>CURRENT>LISP.SYSOUT))						    T)			      (ERROR LISP.SYSOUTFILE "Can't find a LISP.SYSOUT file")))    (SETQ LISP.SYSOUTFILE (if (STRPOS "DSK" (FILENAMEFIELD LISP.SYSOUTFILE (QUOTE HOST))				      NIL NIL T NIL UPPERCASEARRAY)			      then                           (* Alto EXEC command parser can't accept 							     (DSK) as a host name -- rather it is the implicit 							     default.)				   (PACKFILENAME (QUOTE HOST)						 NIL						 (QUOTE VERSION)						 NIL						 (QUOTE BODY)						 LISP.SYSOUTFILE)			    else                             (* Strip off the version number, so that a random ";"							     won't appear in the REM.CM file.)				 (PACKFILENAME (QUOTE VERSION)					       NIL					       (QUOTE BODY)					       LISP.SYSOUTFILE)))    [SETQ SEQUENTIAL.DCOMFILE (OR (AND (NULL SEQUENTIAL.DCOMFILE)				       (FINDFILE (QUOTE {DSK}SEQUENTIAL.DCOM)))				  (RESETLST (RESETSAVE DIRECTORIES LISPUSERSDIRECTORIES)					    (\SEQ.DEFAULTFILENAME SEQUENTIAL.DCOMFILE (QUOTE 										  SEQUENTIAL.DCOM)								  T]    (SETQ LOGFILE (\SEQ.DEFAULTFILENAME LOGFILE (QUOTE SEQUENTIAL.LOG)					"Can't find a name for the LOG file"))    [if (NULL SEQUENCING.DATAFILE)	then                                                 (* Null case treated specially -- means use 							     {DSK}SEQUENCING.DATAFILE and don't bother saving 							     previous versions)	     [until (NULL (PROG2 (CLOSEF? (QUOTE {DSK}SEQUENCING.DATAFILE))				 (DELFILE (QUOTE {DSK}SEQUENCING.DATAFILE]      else (SETQ SEQUENCING.DATAFILE (\SEQ.DEFAULTFILENAME SEQUENCING.DATAFILE (QUOTE 									      SEQUENCING.DATAFILE)							   				       "Can't find a name for the temporary sequencing data file"))	   (PROG ((VERSIONP (FILENAMEFIELD SEQUENCING.DATAFILE (QUOTE VERSION)))		  (REALFILE (FINDFILE SEQUENCING.DATAFILE)))	         (if (STRPOS "DSK" (FILENAMEFIELD SEQUENCING.DATAFILE (QUOTE HOST))			     NIL NIL T NIL UPPERCASEARRAY)		     then                                    (* Sigh, no multiple versions of database files on 							     {DSK})			  [if VERSIONP			      then (ERROR SEQUENCING.DATAFILE 					  "Can't use version numbers on local disk.")			    elseif REALFILE			      then (until (NULL (PROG2 (CLOSEF? SEQUENCING.DATAFILE)						       (DELFILE SEQUENCING.DATAFILE]		   elseif (AND REALFILE VERSIONP)		     then (CLOSEF? REALFILE)			  (DELFILE REALFILE]    (PROG ((RELOADINGFORMS (fetch (SEQUENTIALRUNS RELOADINGFORMS) of SEQUENTIALRUNS))	   (DATAFILESTREAM (OPENSTREAM (OR SEQUENCING.DATAFILE (QUOTE {DSK}SEQUENCING.DATAFILE))				       (QUOTE OUTPUT)))	   [LOGFILESTREAM (\OUTSTREAMARG (SETQ LOGFILE (OPENFILE LOGFILE (QUOTE OUTPUT]	   N INDICESLST TEM)          (DECLARE (SPECVARS DATAFILESTREAM))          (PRIN3 "***SEQUENTIAL.RUNS.DATA.FILE*** " DATAFILESTREAM)                                                             (* A semi-unique header, to act like an identifying 							     password for this kind of file)          (SETQ N (LENGTH RELOADINGFORMS))          (SETFILEPTR DATAFILESTREAM (CEIL (IPLUS RUNSREGION.OFFST (UNFOLD (IPLUS N 1)									   BYTESPERWORD))					   BYTESPERPAGE))    (* Move to S-expression data region, and write out some							     data)          [SETQ INDICESLST (LIST N (MASK.1'S 0 BITSPERWORD)				 (\SEQ.PRIN4 LISP.SYSOUTFILE)				 (\SEQ.PRIN4 SEQUENTIAL.DCOMFILE)				 (\SEQ.PRIN4 LOGFILE)				 (\SEQ.PRIN4 SEQUENCING.DATAFILE)				 (\SEQ.PRIN4 (fetch (SEQUENTIALRUNS FINALREM.CM) of SEQUENTIALRUNS))				 (\SEQ.PRIN4 (fetch (SEQUENTIALRUNS INITFORMS) of SEQUENTIALRUNS]          [SETFILEPTR DATAFILESTREAM (PROG1 (GETFILEPTR DATAFILESTREAM)                                                             (* Remember where next printout is to go and ...)					    (SETFILEPTR DATAFILESTREAM INDEXREGION.OFFST)                                                             (* Move to the index region, and fill in the slots)					    (MAPC INDICESLST (FUNCTION \SEQ.WORDOUT]          [SETQ INDICESLST (NCONC1 (MAPCAR RELOADINGFORMS (FUNCTION \SEQ.PRIN4))				   (\SEQ.PRIN4 (fetch (SEQUENTIALRUNS CLEANUPFORMS) of SEQUENTIALRUNS]          (SETFILEPTR DATAFILESTREAM (PROG1 0 (SETFILEPTR DATAFILESTREAM RUNSREGION.OFFST)					    (MAPC INDICESLST (FUNCTION \SEQ.WORDOUT))                                                             (* Indices of initialization, reloading, and cleanup 							     forms)					    ))          (replace (STREAM ACCESS) of DATAFILESTREAM with (QUOTE BOTH))          (RESETFORM (RADIX 8)		     (printout LOGFILESTREAM T (GDATE)			       "  ****  Log file for SEQUENTIAL runs of " USERNAME .TAB 20 			       "Machine: "			       .TAB 40 (OR (ETHERHOSTNAME)					   (AND (type? NSADDRESS \MY.NSADDRESS)						(\PRINTNSADDRESS \MY.NSADDRESS LOGFILESTREAM))					   (ETHERHOSTNUMBER))			       " ("			       (L-CASE (MACHINETYPE)				       T)			       ")" .TAB 20 "Microcode Version: " .TAB 40 (QUOTE %[)			       (LOADBYTE (MICROCODEVERSION)					 8 8)			       ", "			       (LOADBYTE (MICROCODEVERSION)					 0 8)			       (QUOTE %])			       .TAB 20 "Lisp System Date: " .TAB 40 MAKESYSDATE .TAB 20 			       "Memory Size: "			       .TAB 40 (REALMEMORYSIZE)			       (QUOTE Q)			       T T))          (DRIBBLE LOGFILESTREAM)          (MAPC (fetch (SEQUENTIALRUNS INITFORMS) of SEQUENTIALRUNS)		(FUNCTION EVAL))                             (* Do the initilization forms)          (\SEQ.RELOAD 0 LOGFILESTREAM DATAFILESTREAM)       (* Begin at the beginning!)          (SHOULDNT "Not Supposed to return from \SEQ.RELOAD "])(\SEQ.PRIN4  (LAMBDA (X)                                                (* JonL "28-Apr-84 22:02")    (DECLARE (USEDFREE DATAFILESTREAM))    (PROG1 (GETFILEPTR DATAFILESTREAM)	   (PRIN4 X DATAFILESTREAM)	   (BOUT DATAFILESTREAM (CHARCODE SPACE)))))(\SEQ.DEFAULTFILENAME  [LAMBDA (FILE DEFAULTNAME ERRORMESS)                       (* JonL " 3-Dec-84 22:47")    (PROG ((THISHOST (OR (for X HOST in LISPUSERSDIRECTORIES when (SETQ HOST (FILENAMEFIELD								      X								      (QUOTE HOST)))			    do (RETURN HOST))			 (QUOTE {DSK})))	   [XFILE (SELECTQ FILE			   (NIL (QUOTE {DSK}))			   (T (FILENAMEFIELD (DIRECTORYNAME T)					     (QUOTE HOST)))			   (if (LITATOM FILE)			       then FILE			     elseif (STREAMP FILE)			       then (PROG [(FULL (FULLNAME FILE (QUOTE OLD]				          (if (LITATOM FULL)					      then (RETURN FULL]	   TEM)                                              (* Note hack below to dispense with the directory name 							     when the host doesn't support a directory structure.)          (if XFILE	      then (SETQ XFILE (PACKFILENAME (QUOTE HOST)					     (SETQ TEM (OR (FILENAMEFIELD XFILE (QUOTE HOST))							   THISHOST))					     (QUOTE DIRECTORY)					     [AND (\SEQ.HOSTHASDIRECTORYSTRUCTUREP TEM)						  (OR (FILENAMEFIELD XFILE (QUOTE DIRECTORY))						      (FILENAMEFIELD DEFAULTNAME (QUOTE DIRECTORY]					     (QUOTE BODY)					     (NAMEFIELD XFILE T)					     (QUOTE BODY)					     (NAMEFIELD DEFAULTNAME T)))	    else (ERROR ERRORMESS FILE))          [if (EQ T ERRORMESS)	      then (PROG ((TEM (FINDFILE XFILE)))		         (if (NULL TEM)			     then (LISPERROR "FILE NOT FOUND" (SELECTQ FILE								       ((NIL T)									 XFILE)								       FILE))			   else (SETQ XFILE TEM]          (RETURN XFILE])(\SEQ.WORDOUT  (LAMBDA (X)                                                (* JonL "30-Apr-84 20:48")    (\WOUT DATAFILESTREAM X)))(\SEQ.HOSTHASDIRECTORYSTRUCTUREP  (LAMBDA (HOST)                                             (* JonL "27-Apr-84 17:42")                                                             (* The HOST argument should be the name without curly 							     braces)    (OR (HOSTNAMEP HOST)	(\ILLEGAL.ARG HOST))                                 (* Currently, we just screen out DSK type hosts.)    (OR (NOT (STRPOS "DSK" HOST NIL NIL T NIL UPPERCASEARRAY))	(find I from 4 suchthat (NOT (DIGITCHARP (OR (NTHCHARCODE HOST I)						     (RETURN))))))))(\SEQ.RELOAD  (LAMBDA (K LOGFILESTREAM DATAFILESTREAM)                   (* JonL " 4-May-84 16:46")          (* * Cons up the appropriate command line for the Alto EXEC so that after logout, the form at index K will be in a	  "fresh" Lisp.)    (DRIBBLE)    (CLOSEF? LOGFILESTREAM)                                  (* DRIBBLE should close the LOGFILESTREAM but who knows 							     if the user mucked with it somehow)    (SETFILEPTR DATAFILESTREAM 0)    (OR (STREQUAL "***SEQUENTIAL.RUNS.DATA.FILE***" (RSTRING DATAFILESTREAM))	(SHOULDNT (QUOTE {DSK}SEQUENTIALDATA)))    (RESETFORM (SETREADTABLE FILERDTBL)	       (PROG (N REMS SYSOUTFILENAME DCOMFILENAME DATABASEFILENAME)		     (SETQ N (READDBFILEWORD DATAFILESTREAM NUMBER.OF.RUNS))		     (OR (AND (ILESSP K N)			      (IGEQ K 0))			 (SHOULDNT "FORM index not in valid range"))                                                             (* K is 0-origin indexing; N now includes the cleanup 							     forms count.)		     (SETQ REMS (SIGNED (READDBFILEWORD DATAFILESTREAM CURRENT.RUN)					BITSPERWORD))		     (OR (EQ K (ADD1 REMS))			 (SHOULDNT (CONCAT "FORM index out of sequence (by amount " (IDIFFERENCE					     K REMS)					   ").")))		     (SETQ SYSOUTFILENAME (READDBFILEWORD DATAFILESTREAM LISP.SYSOUTFILE))		     (SETQ DCOMFILENAME (READDBFILEWORD DATAFILESTREAM SEQUENTIAL.DCOMFILE))		     (SETQ DATABASEFILENAME (READDBFILEWORD DATAFILESTREAM DATABASEFILE))		     (SETQ SYSOUTFILENAME (RSTRING (PROG2 (SETFILEPTR DATAFILESTREAM SYSOUTFILENAME)							  DATAFILESTREAM)))		     (for I C from 1 to (NCHARS SYSOUTFILENAME)			do                                   (* Change {'s to %['s in the file name, since it is read							     by the alto EXEC)			   (SELCHARQ (SETQ C (NTHCHARCODE SYSOUTFILENAME I))				     (({ })				       (RPLCHARCODE SYSOUTFILENAME I (SELCHARQ C									       ({ (CHARCODE %[))									       (} (CHARCODE %]))									       (SHOULDNT))))				     NIL))		     (SETQ DCOMFILENAME (RSTRING (PROG2 (SETFILEPTR DATAFILESTREAM DCOMFILENAME)							DATAFILESTREAM)))		     (SETQ DATABASEFILENAME (RATOM (PROG2 (SETFILEPTR DATAFILESTREAM DATABASEFILENAME)							  DATAFILESTREAM)))		     (until (NULL (PROG2 (CLOSEF? (QUOTE {DSK}REM.CM))					 (DELFILE (QUOTE {DSK}REM.CM)))))		     (SETQ REMS (OPENSTREAM (QUOTE {DSK}REM.CM)					    (QUOTE OUTPUT)))		     (PROGN                                  (* printout just isn't quite good enough for this one)			    (PRIN3 "Lisp " REMS)			    (PRIN3 SYSOUTFILENAME REMS)			    (PRIN3 " ;(PROGN (FILESLOAD (SYSLOAD) " REMS)			    (PRIN3 DCOMFILENAME REMS)			    (PRIN3 ") (\SEQ.RUN " REMS)			    (PRIN3 K REMS)			    (if DATABASEFILENAME				then (PRIN3 " " REMS)				     (PRIN3 DATABASEFILENAME REMS))			    (PRIN3 "]" REMS))		     (TERPRI REMS)		     (CLOSEF REMS)		     (LOGOUT T)))))(\SEQ.RUN  (LAMBDA (K SEQUENCING.DATAFILE)                            (* JonL " 9-Oct-84 05:18")          (* * Run the form at index K (0 origin) and if there are more, then continue reloading)    (PROG ((HELPFLAG NIL)	   (DATAFILESTREAM (OPENSTREAM (OR SEQUENCING.DATAFILE (QUOTE {DSK}SEQUENCING.DATAFILE))				       (QUOTE BOTH)))	   N LOGFILESTREAM)          (DECLARE (SPECVARS HELPFLAG LOGFILESTREAM)		   (GLOBALVARS PAGE.WAIT.SECONDS))          (SETQ PAGE.WAIT.SECONDS 0)          (INDEXREGION.MOVETO DATAFILESTREAM NUMBER.OF.RUNS)          (SETQ N (\WIN DATAFILESTREAM))                     (* Haumany "runs" total)          (OR (ILESSP K N)	      (IGEQ K 0)	      (SHOULDNT "Non-existent FORM index"))          (INDEXREGION.MOVETO DATAFILESTREAM LOGFILE)          (SETFILEPTR DATAFILESTREAM (\WIN DATAFILESTREAM))          (DRIBBLE (SETQ LOGFILESTREAM (OPENSTREAM (READ DATAFILESTREAM FILERDTBL)						   (QUOTE APPEND)						   (QUOTE OLD))))                                                             (* Re-open the LOG/DRIBBLE file)          (\SEQ.RUN1 K DATAFILESTREAM)          (add K 1)          (if (ILESSP K N)	      then                                           (* Unless we just completed the last one, then reload.)		   (\SEQ.RELOAD K LOGFILESTREAM DATAFILESTREAM)	    else                                             (* But on the last K, which is the list of "cleanup" 							     forms, we map EVAL down it.)		 (\SEQ.RUN1 K DATAFILESTREAM T)		 (INDEXREGION.MOVETO DATAFILESTREAM CURRENT.RUN)		 (\WOUT DATAFILESTREAM (ADD1 K))             (* If "working" on the N+1'th form, then all done.)		 (DRIBBLE)		 (CLOSEF? LOGFILESTREAM)		 (INDEXREGION.MOVETO DATAFILESTREAM REM.CM)		 (SETFILEPTR DATAFILESTREAM (\WIN DATAFILESTREAM))                                                              (* Get the final REM.CM and stuff it into the {DSK} 							     file.)		 (until (NULL (PROG2 (CLOSEF? (QUOTE {DSK}REM.CM))				     (DELFILE (QUOTE {DSK}REM.CM)))))		 (PROG (FILE (REM.CM (READ DATAFILESTREAM FILERDTBL)))		       (if REM.CM			   then (SETQ FILE (OPENFILE (QUOTE {DSK}REM.CM)						     (QUOTE OUTPUT)))				(PRIN4 REM.CM FILE)				(CLOSEF FILE)))		 (LOGOUT)))))(\SEQ.RUN1  (LAMBDA (K DATAFILESTREAM EVLISP)                          (* JonL " 7-May-84 00:24")    (INDEXREGION.MOVETO DATAFILESTREAM CURRENT.RUN)    (\WOUT DATAFILESTREAM K)                                 (* Inform the database file of which one we are 							     beginning to evalueate.)    (SETFILEPTR DATAFILESTREAM (IPLUS RUNSREGION.OFFST (UNFOLD K BYTESPERWORD)))    (SETFILEPTR DATAFILESTREAM (\WIN DATAFILESTREAM))        (* So go to the place in the S-expression part of the 							     file)    (PROG ((FORM (LISTP (READ DATAFILESTREAM FILERDTBL)))	   (HELPFLAG NIL))          (DECLARE (SPECVARS HELPFLAG))          (if EVLISP	      then (ERSETQ (MAPC FORM (FUNCTION EVAL)))	    else (ERSETQ (EVAL FORM))))    NIL)))(DECLARE: EVAL@COMPILE DONTCOPY [DECLARE: EVAL@COMPILE (BLOCKRECORD INDEXREGION ((NUMBER.OF.RUNS WORD)			  (CURRENT.RUN WORD)			  (LISP.SYSOUTFILE WORD)			  (SEQUENTIAL.DCOMFILE WORD)			  (LOGFILE WORD)			  (DATABASEFILE WORD)			  (REM.CM WORD)			  (INITFORMSX WORD)			  (LASTFIELD WORD)))](DECLARE: EVAL@COMPILE (PUTPROPS INDEXREGION.MOVETO MACRO [(FILE FIELD)				    (SETFILEPTR FILE (IPLUS INDEXREGION.OFFST							    (UNFOLD (INDEXF (fetch (INDEXREGION										     FIELD)									       of T))								    BYTESPERWORD])(PUTPROPS READDBFILEWORD MACRO ((STRM FIELD)				(INDEXREGION.MOVETO STRM FIELD)				(\WIN STRM))))(DECLARE: EVAL@COMPILE (RPAQQ INDEXREGION.OFFST 32)(RPAQQ RUNSREGION.OFFST 64)(CONSTANTS INDEXREGION.OFFST RUNSREGION.OFFST)))(DECLARE: DONTEVAL@LOAD DOCOPY (FILESLOAD PAGEHOLD))(PUTPROPS SEQUENTIAL COPYRIGHT ("Xerox Corporation" 1984 1985))(DECLARE: DONTCOPY  (FILEMAP (NIL (871 17693 (DO.SEQUENTIAL.RUNS 881 . 8685) (\SEQ.PRIN4 8687 . 8952) (\SEQ.DEFAULTFILENAME 8954 . 10769) (\SEQ.WORDOUT 10771 . 10911) (\SEQ.HOSTHASDIRECTORYSTRUCTUREP 10913 . 11487) (\SEQ.RELOAD 11489 . 14428) (\SEQ.RUN 14430 . 16906) (\SEQ.RUN1 16908 . 17691)))))STOP