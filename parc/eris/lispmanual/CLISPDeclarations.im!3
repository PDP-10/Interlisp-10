{Begin SubSec Declarations}{Title Declarations}{Text{Tag CLISPDeclarations}{index *BEGIN* *PRIMARY* declarations in CLISP}CLISP declarations are used to affect the choice of Interlisp function used as the translation of a particular operator.  For example, {lisp A+B} can be translated as either {lisp (PLUS A B)}, {lisp (FPLUS A B)}, or {lisp (IPLUS A B)}, depending on the declaration in effect.  Similarly {lisp X:1_Y} can mean {lisp (RPLACA X Y)}, {lisp (FRPLACA X Y)}, or {lisp (/RPLACA X Y)}, and {lisp <!! A B>} either {lisp (NCONC1 A B)} or {lisp (/NCONC1 A B)}.  Note that the choice of function on all CLISP transformations are affected by the CLISP declaration in effect, i.e., iterative statements, pattern matches, record operations, as well as infix and prefix operators.{FnDef {FnName CLISPDEC} {FnArgs DECLST}{TextPuts into effect the declarations in {arg DECLST}.  {fn CLISPDEC} performs spelling corrections on words not recognized as declarations. {fn CLISPDEC} is undoable.}}The user can makes (changes) a global declaration by calling {fn CLISPDEC} with {arg DECLST} a list of declarations, e.g., {lisp (CLISPDEC '(FLOATING UNDOABLE))}.  Changing a global declaration does not affect the speed of subsequent CLISP transformations, since all CLISP transformation are table driven (i.e., property list), and global declarations are accomplished by making the appropriate internal changes to CLISP at the time of the declaration. If a function employs {it local} declarations (described below), there will be a slight loss in efficiency owing to the fact that for each CLISP transformation, the declaration list must be searched for possibly relevant declarations.Declarations are implemented in the order that they are given, so that later declarations override earlier ones.  For example, the declaration {lisp FAST} specifies that {fn FRPLACA}, {fn FRPLACD}, {fn FMEMB}, and {fn FLAST} be used in place of {fn RPLACA}, {fn RPLACD}, {fn MEMB}, and {fn LAST};  the declaration {lisp RPLACA} specifies that {fn RPLACA} be used.  Therefore, the declarations {lisp (FAST RPLACA RPLACD)} will cause {fn FMEMB}, {fn FLAST}, {fn RPLACA}, and {fn RPLACD} to be used.The initial global declaration is {lisp INTEGER} and {lisp STANDARD}.The table below gives the declarations available in CLISP, and the Interlisp functions they indicate:{Begin Table Table of Declarations:}{COLUMN 30percent} {COLUMN}{UnderLine}{First Declaration}{Next Interlisp Functions to be used}{First {lisp INTEGER} or {lisp FIXED}}{Next {fn IPLUS}, {fn IMINUS}, {fn IDIFFERENCE}, {fn ITIMES}, {fn IQUOTIENT}, {fn ILESSP}, {fn IGREATERP}}{First {lisp FLOATING}}{Next {fn FPLUS}, {fn FMINUS}, {fn FDIFFERENCE}, {fn FTIMES}, {fn FQUOTIENT}, {fn LESSP}, {fn FGREATERP}}{First {lisp MIXED}}{Next {fn PLUS}, {fn MINUS}, {fn DIFFERENCE}, {fn TIMES}, {fn QUOTIENT}, {fn LESSP}, {fn GREATERP}}{First {lisp FAST}}{Next {fn FRPLACA}, {fn FRPLACD}, {fn FMEMB}, {fn FLAST}, {fn FASSOC}}{First {lisp UNDOABLE}}{Next {fn /RPLACA}, {fn /RPLACD}, {fn /NCONC}, {fn /NCONC1}, {fn /MAPCONC}, {fn /MAPCON}}{First {lisp STANDARD}}{Next {fn RPLACA}, {fn RPLACD}, {fn MEMB}, {fn LAST}, {fn ASSOC}, {fn NCONC}, {fn NCONC1}, {fn MAPCONC}, {fn MAPCON}}{First {lisp RPLACA}, {lisp RPLACD}, {lisp /RPLACA}, etc.}{Next corresponding function}{End Table Table of Declarations:}{index FRPLACA Fn}{index FRPLACD Fn}{index FMEMB Fn}{index FLAST Fn}{index FASSOC Fn}{index /RPLACA Fn}{index /RPLACD Fn}{index /NCONC Fn}{index /NCONC1 Fn}{index /MAPCONC Fn}{index /MAPCON Fn}{Begin SubSec Local Declarations}{Title Local Declarations}{Text{Tag CLISPLocalDeclarations}{index local record declarations in CLISP}The user can also make local declarations affecting a selected function or functions by inserting an expression of the form {lisp (CLISP: . {arg DECLARATIONS})} immediately following the argument list, i.e., as {fn CADDR} of the definition.  Such local declarations take precedence over global declarations.  Declarations affecting selected variables can be indicated by lists, where the first element is the name of a variable, and the rest of the list the declarations for that variable.  For example, {lisp (CLISP: FLOATING (X INTEGER))} specifies that in this function integer arithmetic be used for computations involving {lisp X}, and floating arithmetic for all other computations.{foot "involving" means where the variable itself is an operand.For example, with the declaration {lisp (FLOATING (X INTEGER))} in effect, {lisp (FOO X)+(FIE X)} would translate to {lisp FPLUS}, i.e., use floating arithmetic, even though {lisp X} appears somewhere inside of the operands, whereas {lisp X+(FIE X)} would translate to {lisp IPLUS}.If there are declarations involving {it both} operands, e.g., {lisp X+Y}, with {lisp (X FLOATING) (Y INTEGER)}, whichever appears first in the declaration list will be used.}{comment endfootnote}The user can also make local record declarations{index record declarations in CLISP} by inserting a record declaration, e.g., {lisp (RECORD --)}, {lisp (ARRAYRECORD --)}, etc., in the local declaration list.  In addition, a local declaration of the form {lisp (RECORDS A B C)} is equivalent to having copies of the global declarations {lisp A}, {lisp B}, and {lisp C} in the local declaration.  Local record declarations override global record declarations for the function in which they appear.  Local declarations can also be used to override the global setting of certain DWIM/CLISP parameters effective only for transformations within that function, by including in the local declaration an expression of the form {lisp ({arg VARIABLE} = {arg VALUE})}, e.g.,{lisp (PATVARDEFAULT = QUOTE)}.The {lisp CLISP:} expression is converted to a comment of a special form recognized by CLISP.  Whenever a CLISP transformation that is affected by declarations is about to be performed in a function, this comment will be searched for a relevant declaration, and if one is found, the corresponding function will be used.Otherwise, if none are found, the global declaration(s) currently in effect will be used.Local declarations are effective in the order that they are given, so that later declarations can be used to override earlier ones, e.g., {lisp (CLISP: FAST RPLACA RPLACD)} specifies that {fn FMEMB}, {fn FLAST}, {fn RPLACA}, and {fn RPLACD} be used.  An exception to this is that declarations for specific variables take precedence of general, function-wide declarations, regardless of the order of appearance, as in {lisp (CLISP: (X INTEGER) FLOATING)}.{index CLISPIFY FN}{fn CLISPIFY} also checks the declarations in effect before selecting an infix operator to ensure that the corresponding CLISP construct would in fact translate back to this form.  For example, if a {lisp FLOATING} declaration is in effect, {fn CLISPIFY} will convert {lisp (FPLUS X Y)} to {lisp X+Y}, but leave {lisp (IPLUS X Y)} as is.  Note that if {lisp (FPLUS X Y)} is {fn CLISPIFY}ed while a {lisp FLOATING} declaration is under effect, and then the declaration is changed to {lisp INTEGER}, when {lisp X+Y} is translated back to Interlisp, it will become {lisp (IPLUS X Y)}.}{End SubSec Local Declarations}{index *END* declarations in CLISP}}{End SubSec Declarations}