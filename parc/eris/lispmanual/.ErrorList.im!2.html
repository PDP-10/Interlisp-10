<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [eris]&lt;LispManual>ErrorList.im!2</title>
  </head>
  <body>
    <pre>
{Begin SubSec Error List}{Title Error List}{Text{note grand idea for reorganization:  I want to move the error list into an appendix in the back of the manual.  I also want to list all of the errors in alphabetical order.  After all, how often does someone need to know the error corresponding to a given error NUMBER????  Perhaps, if this information is used, I might include a short error#-&gt;errortext table in the error appendix too.idea:  perhaps I could collect ALL of the error messages referenced in the manual (most of which are produced by calls to ERROR, I assume, and put them in the alphabetical error list too.  This would make the error list useful, for once....}There are currently fifty-plus types of errors in the Interlisp system.  Some of these errors are implementation dependent, i.e., appear in Interlisp-10 but may not appear in other Interlisp systems.  The error number is set internally by the code that detects the error before it calls the error handling functions.  It is also the value returned by {index ERRORN FN}{fn ERRORN} if called subsequent to that type of error, and is used by {index ERRORMESS FN}{fn ERRORMESS} for printing the error message.Most errors will print the offending expression following the message, e.g., {lisp NON-NUMERIC ARG NIL} is very common.  Error number 18 (control-B){index control-B} always causes a break (unless {index HELPFLAG Var}{var HELPFLAG} is {lisp NIL}).  All other errors cause breaks if {index BREAKCHECK FN}{fn BREAKCHECK} returns {lisp T} (see {PageRef Tag WhenToBreak}).{note Do most errors have a recognizable 'culprit' ??  Should the culprits of all errors be put in the table below ??  we should have a more consistant way of documenting the 'culprit's of various errors.   perhaps another column in the table  ---mjs}{Tag ErrorNumbers}The errors are listed below by error number:{index error number}{Begin LabeledList Error Types}{Label 0  - {lisp JSYS ERROR}{index *PRIMARY* JSYS ERROR Error}}{Text(Interlisp-10)  Occurs following a trap in a JSYS.  As described on {PageRef Fn JSYS}, {index *PRIMARY* TRAP AT LOCATION Error}{lisp TRAP AT LOCATION} is printed, followed by the {lisp JSYS} diagnostic, and control returns to the operating system executive.  The user can then safely {lisp CONTINUE}, and the Interlisp error, {lisp JSYS ERROR} is then generated.  A {lisp TRAP AT LOCATION} can also occur if an illegal instruction is executed.  In this case, the operating system also prints {index ILLEGAL INSTRUCTION Error}{lisp ILLEGAL INSTRUCTION}.  This can happen for example if the user is programming directly in {lisp ASSEMBLE} code, or if his system somehow got smashed.  In the latter case, it is quite possible that random programs or data structures might have already been smashed.  Unless he is sure he knows what the problem is, the user is best advised to abandon this system as soon as possible.  (If the user does elect to {lisp CONTINUE}, Interlisp will (try to) generate a {lisp JSYS ERROR} and unwind.  In some cases, however, the system may be so badly smashed that the error message won't even print.)  Note that in some cases, e.g. illegal instruction trap while in the garbage collector, Interlisp will print out {lisp CAN'T CONTINUE}, because traps under those conditions are fatal.  The user {it may} be able to reenter his sytem via the {lisp START} command, and, if lucky, dump some data or functions before the system totally collapses.In Interlisp-D, this error is named {lisp SYSTEM ERROR}.{index *PRIMARY* SYSTEM ERROR Error}}{Label 1}{Text No longer used.}{Label 2  - {lisp STACK OVERFLOW}{index *PRIMARY* STACK OVERFLOW Error}}{TextOccurs when computation is too deep, either with respect to number of function calls, or number of variable bindings.  Usually because of a non-terminating recursive computation, i.e., a bug.In Interlisp-10, the garbage collector uses the same stack as the rest of the system, so that if a garbage collection occurs when deep in a computation, the stack can overflow (particularly if there is a lot of list structure that is deep in the {fn CAR} direction). If this does happen, the garbage collector will flush the stack used by the computation in order that the garbage collection can complete. Afterwards, the error message {lisp STACK OVERFLOW IN GC - COMPUTATION LOST}{index STACK OVERFLOW IN GC - COMPUTATION LOST Error} is printed, followed by a {lisp (RESET)}, i.e., return to top level.}{Label 3  - {lisp ILLEGAL RETURN}{index *PRIMARY* ILLEGAL RETURN Error}}{TextCall to {fn RETURN} when not inside of an interpreted {fn PROG}.}{Label 4  - {lisp ARG NOT LIST}{index *PRIMARY* ARG NOT LIST Error}}{TextE.g., {fn RPLACA} called on a non-list.}{Label 5  - {lisp HARD DISK ERROR}{index *PRIMARY* HARD DISK ERROR Error}}{Text(Interlisp-D)  An error with the local disk drive.}{Label 6  - {lisp ATTEMPT TO SET NIL}{index *PRIMARY* ATTEMPT TO SET NIL Error}}{TextVia {fn SET} or {fn SETQ}}{Label 7  - {lisp ATTEMPT TO RPLAC NIL}{index *PRIMARY* ATTEMPT TO RPLAC NIL Error}}{TextAttempt either to {fn RPLACA} or to {fn RPLACD} {lisp NIL} withsomething other than {lisp NIL}.}{Label 8  - {lisp UNDEFINED OR ILLEGAL GO}{index *PRIMARY* UNDEFINED OR ILLEGAL GO Error}}{Text{fn GO} when not inside of a {fn PROG}, or {fn GO} to nonexistent label.}{Label 9  - {lisp FILE WON'T OPEN}{index *PRIMARY* FILE WON'T OPEN Error}}{TextFrom {fn INFILE} or {fn OUTFILE}, {PageRef Fn INFILE}.}{Label 10  - {lisp NON-NUMERIC ARG}{index *PRIMARY* NON-NUMERIC ARG Error}}{TextA numeric function e.g., {fn IPLUS}, {fn ITIMES}, {fn IGREATERP}, expected a number.}{Label 11  - {lisp ATOM TOO LONG}{index *PRIMARY* ATOM TOO LONG Error}}{TextAttempted to create a litatom (via {fn PACK}, or typing one in, or reading from a file) with too many characters.  In Interlisp-D, the maximum number of characters in a litatom is 255.  In Interlisp-10, the maximum is 127 characters.}{Label 12  - {lisp ATOM HASH TABLE FULL}{index *PRIMARY* ATOM HASH TABLE FULL Error}}{TextNo room for any more (new) atoms.In Interlisp-10, the atom hash table will automatically expand by a specified number of pages each time it fills up until an upper limit of 32K atoms is reached.}{Label 13  - {lisp FILE NOT OPEN}{index *PRIMARY* FILE NOT OPEN Error}}{TextFrom an I/O function, e.g., {fn READ}, {fn PRINT}, {fn CLOSEF}.}{Label 14  - {lisp ARG NOT LITATOM}{index *PRIMARY* ARG NOT LITATOM Error}}{TextE.g., {fn SETQ}, {fn PUTPROP}, {fn GETTOPVAL}, etc., given a non-atomic arg.}{Label 15  - {lisp TOO MANY FILES OPEN}{index *PRIMARY* TOO MANY FILES OPEN Error}}{Text{ge}30, excluding the terminal.}{Label 16  - {lisp END OF FILE}{index *END* *PRIMARY* OF FILE Error}}{TextFrom an input function, e.g., {fn READ}, {fn READC}, {fn RATOM}.After the error, the file will then be closed.Note:  The entries on {var ERRORTYPELST} ({PageRef Var ERRORTYPELST}) are processed before the file is closed, so that the user can intercept and process this error via an entry on {var ERRORTYPELST}, thereby preventing the file from being closed.  It is also possible to use an {var ERRORTYPELST} entry to return a character as the value of the call to {fn ERRORX}, and the program will continue, e.g. returning "{lisp ]}" may be used to complete a read operation.}{Label 17  - {lisp ERROR}{index *PRIMARY* ERROR Error}}{TextCall to {index ERROR FN}{fn ERROR} ({PageRef Fn ERROR}).}{Label 18  - {lisp BREAK}{index BREAK Error}}{TextControl-B{index control-B} was typed.}{Label 19  - {lisp ILLEGAL STACK ARG}{index *PRIMARY* ILLEGAL STACK ARG Error}}{TextA stack function expected a stack position and was given something else.  This might occur if the arguments to a stack function are reversed.  Also occurs if user specified a stack position with a function name, and that function was not found on the stack.  See {PageRef Tag STACK}.}{Label 20  - {lisp FAULT IN EVAL}{index *PRIMARY* FAULT IN EVAL Error}}{TextArtifact of bootstrap.  Never occurs after {index FAULTEVAL FN}{fn FAULTEVAL} has been defined as described earlier.}{Label 21  - {lisp ARRAYS FULL}{index *PRIMARY* ARRAYS FULL Error}}{TextSystem will first initiate a garbage collection of array space, and if no array space is reclaimed, will then generate this error.}{Label 22  - {lisp FILE SYSTEM RESOURCES EXCEEDED}{index *PRIMARY* FILE SYSTEM RESOURCES EXCEEDED Error}}{Text(Interlisp-10) Includes no more disk space, disk quota exceeded, directory full, too many jfbs, job full.{note jfbs?}}{Label 23  - {lisp FILE NOT FOUND}{index *PRIMARY* FILE NOT FOUND Error}}{TextFile name does not correspond to a file in the corresponding directory.  Can also occur if file name is ambiguous.Interlisp is initialized with an entry on {var ERRORTYPELST} ({PageRef Var ERRORTYPELST}) to call {fn SPELLFILE}{index SPELLFILE FN} for error 23.  {fn SPELLFILE} will search alternate directories or perform spelling correction on the connected directory.  If {fn SPELLFILE} fails, then the user will see this error.}{Label 24  - {lisp BAD SYSOUT FILE}{index *PRIMARY* BAD SYSOUT FILE Error}}{TextDate does not agree with date of {fn MAKESYS}, or file is not a sysout file at all (see {PageRef Fn SYSOUT}).}{Label 25  - {lisp UNUSUAL CDR ARG LIST}{index *PRIMARY* UNUSUAL CDR ARG LIST Error}}{TextA form ends in a non-list other than {lisp NIL}, e.g., {lisp (CONS T . 3)}.}{Label 26  - {lisp HASH TABLE FULL}{index *PRIMARY* HASH TABLE FULL Error}}{TextSee hash array functions, {PageRef Tag HashArrays}.}{Label 27  - {lisp ILLEGAL ARG}{index *PRIMARY* ILLEGAL ARG Error}}{TextCatch-all error.  Currently used by {fn PUTD}, {fn EVALA}, {fn ARG}, {lisp FUNARG}, {fn ALLOCATE}, {fn RPLSTRING}, etc.}{Label 28  - {lisp ARG NOT ARRAY}{index *PRIMARY* ARG NOT ARRAY Error}}{Text{fn ELT} or {fn SETA} given an argument that is not a pointer to the beginning of an array (see {PageRef Fn ELT}).}{Label 29  - {lisp ILLEGAL OR IMPOSSIBLE BLOCK}{index *PRIMARY* ILLEGAL OR IMPOSSIBLE BLOCK Error}}{Text(Interlisp-10) From {index GETBLK FN}{fn GETBLK} or {index RELBLK FN}{fn RELBLK} (see {PageRef Fn GETBLK}).}{Label 30  - {lisp STACK PTR HAS BEEN RELEASED}{index *PRIMARY* STACK PTR HAS BEEN RELEASED Error}}{TextA released stack pointer was supplied as a stack descriptor for a purpose other than as a stack pointer to be re-used (see {PageRef Tag STACK}).}{Label 31  - {lisp STORAGE FULL}{index *PRIMARY* STORAGE FULL Error}}{TextFollowing a garbage collection, if a sufficient amount of words has not been collected, and there is no un-allocated space left in the system, this error is generated.}{Label 32  - {lisp ATTEMPT TO USE ITEM OF INCORRECT TYPE}{index *PRIMARY* ATTEMPT TO USE ITEM OF INCORRECT TYPE Error}}{TextBefore a field of a user data type is changed, the type of the item is first checked to be sure that it is of the expected type.  If not, this error is generated (see {PageRef Tag UserDataTypes}).}{Label 33  - {lisp ILLEGAL DATA TYPE NUMBER}{index *PRIMARY* ILLEGAL DATA TYPE NUMBER Error}}{TextThe argument is not a valid user data type number (see {PageRef Tag UserDataTypes}).{note what is the error if you use an invalid user data type NAME ??}}{Label 34  - {lisp DATA TYPES FULL}{index *PRIMARY* DATA TYPES FULL Error}}{TextAll available user data types have been allocated. (see {PageRef Tag UserDataTypes}).}{Label 35  - {lisp ATTEMPT TO BIND NIL OR T}{index *PRIMARY* ATTEMPT TO BIND NIL OR T Error}}{TextIn a {fn PROG} or {lisp LAMBDA} expression.}{Label 36  - {lisp TOO MANY USER INTERRUPT CHARACTERS}{index *PRIMARY* TOO MANY USER INTERRUPT CHARACTERS Error}}{TextAttempt to enable a user interrupt character when all 9 user channels are currently enabled (see {PageRef Tag UserInterruptChars}).}{Label 37  - {lisp READ-MACRO CONTEXT ERROR}{index *PRIMARY* READ-MACRO CONTEXT ERROR Error}}{Text(Interlisp-10)  Occurs when a {fn READ} is executed from within a read-macro function and the next token is a {lisp )} or a {lisp ]} (see {PageRef Tag ReadMacros}).}{Label 38  - {lisp ILLEGAL READTABLE}{index *PRIMARY* ILLEGAL READTABLE Error}}{TextThe argument was expected to be a valid readtable (see {PageRef Tag ReadTables}).}{Label 39  - {lisp ILLEGAL TERMINAL TABLE}{index *PRIMARY* ILLEGAL TERMINAL TABLE Error}}{TextThe argument was expected to be a valid terminal table (see {PageRef Tag TerminalTables}).}{Label 40  - {lisp SWAPBLOCK TOO BIG FOR BUFFER}{index *PRIMARY* SWAPBLOCK TOO BIG FOR BUFFER Error}}{Text(Interlisp-10) An attempt was made to swap in a function/array which is too large for the swapping buffer.  See {fn SETSBSIZE}{index SETSBSIZE FN}, {PageRef Fn SETSBSIZE}.}{Label 41  - {lisp PROTECTION VIOLATION}{index *PRIMARY* PROTECTION VIOLATION Error}}{Text(Interlisp-10)  Attempt to open a file that user does not have access to.  Also reference to unassigned device.}{Label 42  - {lisp BAD FILE NAME}{index *PRIMARY* BAD FILE NAME Error}}{TextIllegal character in file specification, illegal syntax, e.g. in Interlisp-10, two {lisp ;}'s etc.}{Label 43  - {lisp USER BREAK}{index *PRIMARY* USER BREAK Error}}{TextError corresponding to "hard" user-interrupt character.  See {PageRef Tag UserInterruptChars}.}{Label 44  - {lisp UNBOUND ATOM}{index *PRIMARY* UNBOUND ATOM Error}}{TextUnbound atom error.  When this occurs, a variable (atom) was used which had neither a stack binding (wasn't an argument to a function nor a {lisp PROG} variable) nor a top level value.  The "culprit" ({lisp (CADR ERRORMESS)}) is the atom.  Note that if DWIM corrects the error, no error occurs and the error number is not set.  However, if an error is going to occur, whether or not it will cause a break, the error number will be set.}{Label 45  - {lisp UNDEFINED CAR OF FORM}{index *PRIMARY* UNDEFINED CAR OF FORM Error}}{TextUndefined function error.  When is occurs, a form was evaluated whose function position ({lisp CAR}) does not have a definition as a function.  Culprit is the form.}{Label 46  - {lisp UNDEFINED FUNCTION}{index *PRIMARY* UNDEFINED FUNCTION Error}}{TextThis error is generated if {fn APPLY} is given an undefined function.  Culprit is {lisp (LIST {arg FN} {arg ARGS})}}{Label 47  - {lisp CONTROL-E}{index *PRIMARY* CONTROL-E Error}}{TextThe user typed Control-E.}{Label 48  - {lisp FLOATING UNDERFLOW}{index *PRIMARY* FLOATING UNDERFLOW Error}}{Text(Interlisp-D)  Underflow during floating-point operation.}{Label 49  - {lisp FLOATING OVERFLOW}{index *PRIMARY* FLOATING OVERFLOW Error}}{Text(Interlisp-D)  Overflow during floating-point operation.}{Label 50  - {lisp OVERFLOW}{index *PRIMARY* OVERFLOW Error}}{Text(Interlisp-D)  Overflow during integer operation.}{Label 51  - {lisp ARG NOT HARRAY}{index *PRIMARY* ARG NOT HARRAY Error}}{Text(Interlisp-D)  Signaled by hash array operations when given an argument that is not a hash array.  (In Interlisp-10, this still triggers error 28, {lisp ARG NOT ARRAY}).}{Label 52  - {lisp TOO MANY ARGUMENTS}{index *PRIMARY* TOO MANY ARGUMENTS Error}}{Text(Interlisp-D)  Signaled when too many arguments are given to a lambda-spread, lambda-nospread, or nlambda-spread function.}{End LabeledList Error Types}In addition, many system functions, e.g., {fn DEFINE}, {fn ARGLIST}, {fn ADVISE}, {fn LOG}, {fn EXPT}, etc, also generate errors with appropriate messages by calling {index ERROR FN}{fn ERROR} (see {PageRef Fn ERROR})which causes error number 17.}{End SubSec Error List}</pre>
  </body>
</html>
