{Begin SubSec Interlisp-10 Arrays}{Title Interlisp-10 Arrays}{Text{Tag Interlisp10Arrays}Interlisp-10 has a more primitive array facility than the other implementations of Interlisp.  In Interlisp-10, arrays are partitioned into four sections: a header,{index *PRIMARY* array header (in Interlisp-10 arrays) Term} a section containing unboxed numbers,{index *PRIMARY* unboxed numbers (in Interlisp-10 arrays) Term} a section containing list cells (each with a {fn CAR} and {fn CDR}), and a section containing relocation information.{index *PRIMARY* relocation information (in Interlisp-10 arrays) Term}  The last three sections can each be of arbitrary length (including 0); the header is two words long and contains the length of the other sections.  The unboxed number region of an array is used to store 36 bit quantities that are not Interlisp pointers, and therefore are not to be chased during garbage collections, e.g. machine instructions.  The relocation informaion is used when the array contains the definition of a compiled function, and specifies which locations in the {it unboxed} region of the array must be changed if the array is moved during a garbage collection.{fn ARRAY} returns an "array pointer"{index *PRIMARY* array pointers (in Interlisp-10 arrays) Term} to the beginning of the array, but it is also possible to create a pointer into the middle of an array.  {fn ARRAYP} will accept a pointer into the middle of an array, but  {fn ELT}, {fn SETA}, {fn ELTD}, and {fn SETD} generate an error, {lisp ARG NOT ARRAY}{index ARG NOT ARRAY Error}, if {arg A} is not an array pointer to the beginning of an array.Array-pointers print as {lisp #n}, {index # (followed by a number)}where {lisp n} is the octal representation of the pointer.  Note that {lisp #n} will be read as a literal atom, and not an array pointer.  The following functions are used to manipulate Interlisp-10 arrays:	{FnDef {FnName ARRAY} {FnArgs N P V}{TextAllocates a block of {arg N}+2 words, of which the first two are header information.  The next {arg P} ({LE} {arg N}) words contain unboxed numbers, and are initialized to unboxed 0.  The last {arg N}-{arg P} ({GE} 0) words are list cells; both {fn CAR} and {fn CDR} are available for storing information, and each is initialized to {arg V}.  If {arg P} is {lisp NIL}, 0 is used (i.e., an array containing all Interlisp pointers).{fn ARRAY} returns an "array pointer"{index array pointers (in Interlisp-10 arrays) Term} to the array.If sufficient space is not available for the array, a garbage collection of array space is initiated.  If this is unsuccessful in obtaining sufficient space, an error is generated, {lisp ARRAYS FULL}.{index ARRAYS FULL Error}}}{FnDef {FnName ELT} {FnArgs A N}{TextReturns the {arg N}th element of the array {arg A}.  {lisp (ELT {arg A} 1)} is the first element of the array (actually corresponds to the 3rd cell because of the 2 word header).If {arg N} corresponds to the unboxed number region of {arg A}, {fn ELT} returns the full 36 bit word as a boxed integer.  If {arg N} corresponds to the list cell region of {arg A}, {fn ELT} returns the {fn CAR} of the corresponding element.}}{FnDef {FnName SETA} {FnArgs A N V}{TextSets the {arg N}th element of the array {arg A} to {arg V}.If {arg N} corresponds to the unboxed number region of {arg A}, {arg V} must be a number, and is unboxed and stored as a full 36 bit word into the {arg N}th element of {arg A}.  If {arg N} corresponds to the list cell region of {arg A}, {arg V} replaces the {fn CAR} of the {arg N}th element.  {fn SETA} returns {arg V}.}}{FnDef {FnName ELTD} {FnArgs A N}{TextSame as {fn ELT} for the unboxed number region of {arg A}, but returns the {fn CDR} of the {arg N}th element, if {arg N} corresponds to the list cell region of {arg A}.}}{FnDef {FnName SETD} {FnArgs A N V}{TextSame as {fn SETA} for the unboxed number region of {arg A}, but sets the {fn CDR} half of the {arg N}th element, if {arg N} corresponds to the list cellregion of {arg A}.  {fn SETD} returns {arg V}.}}{FnDef {FnName ARRAYTYP} {FnArgs A}{TextReturns the number of unboxed number words of array {arg A}.  This value corresponds to the second argument to {fn ARRAY}.}}{FnDef {FnName ARRAYP} {FnArgs X}{TextReturns {arg X} if {arg X} is an array pointer, otherwise {lisp NIL}.  No check is made to ensure that {arg X} actually addresses the {it beginning} of an array.}}{FnDef {FnName ARRAYBEG} {FnArgs A}{TextIf {arg A} is a pointer into the middle of an array, returns the pointer to its beginning.  Otherwise returns {lisp NIL}.{note will it return NIL if A is already a pointer to the beginning of the array??}}}{FnDef {FnName ARRAYORIG} {FnArgs A}{TextReturns 1.  A dummy function provided for compatibility with other Interlisp arrays.}}{Begin Note}Date: 4 June 1981 4:35 pm PDT (Thursday)From: Masinter.PASubject: (BBN meeting notes) ARRAYSInterlisp-D has some extensions to the Interlisp-10 style of arrays.Interlisp-Jericho has imported (or will) Interlisp-D's style of ARRAYs.BBN agreed to implement the extensions in Interlisp-10 in a way which is alsobackward compatible.(Note that Interlisp-Jericho has an interesting scheme for implementingDOUBLEPOINTER arrays where the ELTD/SETD portion of the array is storedoffline at first reference.)We are agreed that the specification for ARRAY[n, typ, init, orig] is that "typ"can be any element which is a valid DATATYPE field descriptor; includingPOINTER, BYTE, (BITS n), FLOATP, FIXP. Implementations are free to "coerce"arguments to "higher" level types, e.g. (BITS n) -> FIXP."Mixed" arrays with part pointers and part numbers need not be supported.Date: 4 Jun 1981 1951-EDTSender: GREENFELD at BBNDSubject: Re: (BBN meeting notes) ARRAYSon the ARRAY function, one point still not agreed is whetherto allow ORIGINs other than 1.  While Interlisp-D adds this feature,Interlisp-Jericho explicitly decided not to.the ELTD/SETD scheme is a simple package that is machine-independent,and is in our LISPUSERS.{End Note}}{End SubSec Interlisp-10 Arrays}