{Begin Note}SELECT de-documented.  Is inconsistant.  It doesn't seem to be used in system files (EXCEPT as a PROG tag).Ron says:  SELECTxx fns should be conceptually like (SEL FN X . CLAUSES), where FN is wrapped around each select key (one atom or one list) so(SELECTQ ...)  <==>  (SEL 'QUOTE ...)(SELECTC ...)   <==>  (SEL 'CONSTANT ...)(SELCHARQ ...)   <==>  (SEL 'CHARCODE ...)so far so good...but unfortunately SELECT has somewhat different semantics, so it doesn't fit into this model.  In particular, (SELECT X ... ( (A B C) ...) ...) evaluates A, B, and C individually, rather than doing something to (A B C).Also, compiled SELECT doesn't do the right thing if infix operators are in selection keys or rest of clauses.{End Note}{FnDef {FnName SELECT}{FnArgs X CLAUSE{SUB 1} CLAUSE{SUB 2} {ellipsis} CLAUSE{SUB K} DEFAULT}{Type NOSPREAD NLAMBDA}{Text{fn SELECT} is similar to {fn SELECTQ} except that the selection key ({arg S{sub i}}) is evaluated before the {fn EQ} test.That is, if {arg S{sub i}} is an atom, the value of {arg X} is tested to see if it is {fn EQ} to the value of {arg S{sub i}}.  If so, the expressions {arg C{sub i1}} {ellipsis} {arg C{sub iN}} are evaluated in sequence, and the value of the {fn SELECT} is the value of the last expression evaluated, i.e., {arg C{sub iN}}.If {arg S{sub i}} is a list, the value of {arg X} is compared with the value of each element of {arg S{sub i}}, and if {arg X} is {fn EQ} to any one of them, then {arg C{sub i1}} {ellipsis} {arg C{sub iN}} are evaluated in turn asabove.  Note that if {arg S{sub i}} is {lisp (FOO FIE)} the test is{lisp (OR (EQ {arg X} FOO) (EQ {arg X} FIE))}.To get the test {lisp (EQ {arg X} (FOO FIE))},{arg S{sub i}} should be {lisp ((FOO FIE))}.If {arg CLAUSE{sub i}} is not selected in one of the two ways described, {arg CLAUSE{sub i+1}} is tested, etc., until all the clause's have been tested.  If none is selected, the value of the {fn SELECT} is the value of {arg DEFAULT}.{arg DEFAULT} must be present.{fn SELECT} compiles open, and is therefore very fast; however, it will not work if the value of {arg X} is a large integer or floating point number, since {fn SELECT} uses {fn EQ} for all comparisons.}}