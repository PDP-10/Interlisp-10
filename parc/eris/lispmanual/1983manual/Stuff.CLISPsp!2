If {var CLISPARRAY} is {lisp NIL},{foot {var CLISPARRAY} is initially {lisp NIL}, and {var #CLISPARRAY} is its size.The first time a translation is performed, a hash array of this size is created.Therefore to disable {var CLISPARRAY}, both it and {var #CLISPARRAY} should be set to {lisp NIL}.}{comment endfootnote}translations are implemented instead by replacing the CLISP expression by an expression of the form{index *PRIMARY* CLISP%   Litatom}{lisp (CLISP%{sp} {arg TRANSLATION} . {arg CLISP-EXPRESSION})},{foot {lisp CLISP%{sp}} is an atom consisting of the six characters {lisp C}, {lisp L}, {lisp I}, {lisp S}, {lisp P}, and {it space}, which must be preceded by the escape character {lisp %} in order for it to be included as a part of an identifier.The intent was to deliberately make this atom hard to type so as to make it unlikely that it would otherwise appear in a user's program or data, since the editor and prettyprint treat it very specially, as described above.}{comment endfootnote}e.g., {lisp (FOR X IN Y COLLECT (CAR X))} would be replaced by{lisp (CLISP%{sp} (MAPCAR Y (FUNCTION CAR)) FOR X IN Y COLLECT (CAR X))}.Both the editor and prettyprint know about {lisp CLISP%{sp}} expressions andtreat them specially by suppressing the translations: {fn PRETTYPRINT}prints just the CLISP (unless {var PRETTYTRANFLG}={lisp T}, as described below), while the editor makes the translation completely invisible, e.g., if the current expression were the above {lisp CLISP%{sp}} expression, {lisp F MAPCAR} would fail to find the {lisp MAPCAR}, and {lisp (3 ON)} would replace {lisp IN} with {lisp ON}, i.e., the editor operates as though both the {lisp CLISP%{sp}} and the {lisp MAPCAR} were not there.As with translations implemented via {var CLISPARRAY}, if the CLISP expression is changed by editing it, the translation is automatically deleted.{lisp CLISP%{sp}} expressions will interpret and compile correctly:{lisp CLISP%{sp}} is defined as an nlambda nospread function with an appropriate compiler macro.  Note that if the user sets {var CLISPARRAY} to {lisp NIL}, he can then break, trace, or advise {lisp CLISP%{sp}} to monitor theevaluation of iterative statements, pattern matches, and record operations.  This technique will work even if {var CLISPARRAY} was not {lisp NIL} at thetime the expressions were originally translated, since setting {var CLISPARRAY} to {lisp NIL} will effectively delete the translations, thereby causing the CLISP expressions to be retranslated when they are first encountered.  Note that if the user only wishes to monitor the CLISP in a certain function, he can accomplish this by embedding its definition in {lisp (RESETVAR CLISPARRAY NIL *).{index CLISP%  Litatom}If a {lisp CLISP%{sp}}} expression is encountered and {var CLISPARRAY} is {it not} {lisp NIL}, the translation is transferred to the hash array, and the {lisp CLISP%{sp}} expression replaced by just the CLISP.Setting {var PRETTYTRANFLG}{index PRETTYTRANFLG Var} to {lisp CLISP%{sp}} causes {fn PRETTYPRINT} to print CLISP expressions that have been translated in the form of{lisp (CLISP%{sp} {arg TRANSLATION} . {arg CLISP-EXPRESSION})}, even if the translation is currently stored in {var CLISPARRAY}.  These two features together provide the user with a way of dumping CLISP expressions together with their translations so that when reloaded (and run or dwimified), the translations will automatically be transferred to {var CLISPARRAY}.In summary, if {var PRETTYTRANFLG}={lisp NIL}, only the CLISP is printed (used for producing listings).If {var PRETTYTRANFLG}={lisp T}, only the translation is printed (used for exporting programs to systems that do not provide CLISP, and to examine translations for debugging purposes).{foot Note that {fn MAKEFILE} will reset {var PRETTYTRANFLG} to {lisp T}, using {fn RESETVAR}, when called with the option {lisp NOCLISP}.{index NOCLISP (MAKEFILE option)}{index MAKEFILE and CLISP}}{comment endfootnote}If {var PRETTYTRANFLG}={lisp CLISP%{sp}}, an expression of the form{lisp (CLISP%{sp} {arg TRANSLATION} . {arg CLISP-EXPRESSION})} is printed, (used for dumping both CLISP and translations).The preferred method of storing translations is in {var CLISPARRAY}, so that ifany {lisp CLISP%{sp}} expressions are converted while {var CLISPARRAY} is not {lisp NIL}, they will automatically be converted so as to use {var CLISPARRAY}.If {var CLISPARRAY}={lisp NIL}, they will be left alone, and furthermore,new translations will be implemented using {lisp CLISP%{sp}} expressions.{FnDef {FnName CLISPTRAN} {FnArgs X TRAN}{TextGives {arg X} the translation {arg TRAN} by storing them in {var CLISPARRAY}.If {var CLISPARRAY}is not {lisp NIL}, uses hashing scheme, otherwise uses {lisp CLISP%{sp}}scheme.  See {PageRef Tag 501}.{fn CLISPTRAN} is called for all CLISP translations, via a non-linked, external function call, i.e. it can be advised.}{comment endfootnote}}}{VarDef {Name CLISPRETRANFLG}{Text{index *PRIMARY* CLISPRETRANFLG Var}If {lisp T}, informs {fn DWIMIFY} to (re)translate all expressions which have remote translations, either in hash array or using {lisp CLISP%{sp}}.  Initially {lisp NIL}.}}{VarDef {Name PRETTYTRANFLG}{TextIf {lisp T}, causes {fn PRETTYPRINT} to print translations instead of CLISP expressions.  This is useful for exporting to a LISP system that does not have CLISP.  {var PRETTYTRANFLG} is (temporarily) reset to {lisp T} when {fn MAKEFILE} is called with the option {lisp NOCLISP}.{index NOCLISP (MAKEFILE option)}If {var PRETTYTRANFLG} is {lisp CLISP%{sp}},{index CLISP%  Litatom} both the CLISP and translations are printed in appropriate form.For more details, see {PageRef Tag 58}.{var PRETTYTRANFLG} is initially {lisp NIL}.}}--- from record package ---When the user redeclares a global record, the translations of all expressions involving that record or any of its fields are automatically deleted from {var CLISPARRAY}, and thus will be recomputed using the new information.  If the user is not using this method for storing translations, i.e., is instead using the {lisp CLISP%{sp}} method (See {PageRef Tag CLISP%}), those expressions already translated will remain as they are.  (There is no practical way to locate them.)If the user changes a {it local} record declaration, or changes some other CLISP declaration, e.g., {lisp STANDARD} to {lisp FAST}, and wishes the new information to affect record expressions already translated, he must make sure the corresponding translations are removed, usually either by {fn CLISPIFY}ing or applying the {lisp !DW} edit macro.