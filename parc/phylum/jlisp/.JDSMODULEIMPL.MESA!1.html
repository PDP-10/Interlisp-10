<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [phylum]&lt;JLisp>JDSMODULEIMPL.MESA!1</title>
  </head>
  <body>
    <pre>
-- File: JDSmoduleImpl.mesa -- last edit by: --   Nagata, April 7, 1982; converted to Trinity --   Glenn, September 10, 1981  5:56 PM -- Changed the Kanji convert of GET to ignore JDSBOR char in that field 9/10/81-- Added PhonicToJDS procedure to this module 7/23/81-- Changed the CATcode default value from: 22B to: 26B (4 new Catcodes)DIRECTORY  CharDefs USING [Char],  Environment USING [Block],  Heap USING [FreeNode, MakeNode, systemZone],  JDSmoduleDefs,  JDSPosDefs USING [GetCatValue, GetPosValue],  JDStoOISDefs USING [JDStoOIS, lastJDSKanji, UNDF],  MStream USING [EndOf],  OISDictDataDefs USING [Entry],  Stream USING [Block, Byte, CompletionCode, defaultObject, GetByte, GetPosition,    GetWord, Handle, InputOptions, Object, PutBlock, PutByte, SendAttention,    SetPosition, SetSST, SubSequenceType, WaitForAttention, Word];JDSmoduleImpl: MONITOR IMPORTS Heap, JDSPosDefs, JDStoOISDefs, MStream, Stream                       EXPORTS JDSmoduleDefs =  BEGIN   -- TYPEs  streamZone: UNCOUNTED ZONE = Heap.systemZone;  Handle: TYPE = Stream.Handle;  BoxObject: TYPE = RECORD [base: LONG CARDINAL, bytecount: CARDINAL];  BoxPtr: TYPE = LONG POINTER TO ARRAY [0..0) OF BoxObject;  Box: BoxPtr &larr; NIL;  jdsStreamObject: TYPE = MACHINE DEPENDENT RECORD [    defaultObject: Stream.Object, clientSH: Stream.Handle, jdsPtr: jdsFileObject];  StreamJDSObject: TYPE = LONG POINTER TO jdsStreamObject;  jdsObject: TYPE = RECORD [    jdspage: ARRAY [0..30] OF CARDINAL,  --  page directory of JDS file    numofboxes: CARDINAL &larr; 0,  --  count of number of boxes in page    wordsperbox: CARDINAL &larr; 0,  --  count of words per box (+ tabsets)    wordcount: CARDINAL &larr; 0,  --  count of total text words in page    wordsread: CARDINAL &larr; 0,  --  count of total words read so far    textwordsread: CARDINAL &larr; 0,  --  count of total text chars read so far    pageno: CARDINAL &larr; 0,  --  index to JDS.jdspage array    boxno: CARDINAL &larr; 0,  --  index to BoxObjects    boxtextbytesread: CARDINAL &larr; 0,  --  count of text bytes read from box    recordsmade: CARDINAL &larr; 0,  --  count of records (16 words) built/read *    wurd: CARDINAL &larr; 0,  --  JDS text character (in sequence)    curpage: LONG CARDINAL &larr; 0,  --  current page index    curbyteindx: LONG CARDINAL &larr; 0,  --  current stream byte index    topoftext: LONG CARDINAL &larr; 0,  --  Starting index of JDS text in file    pagetextstart: LONG CARDINAL &larr; 0,  --  current page start of text index    startofpage: BOOLEAN &larr; TRUE,  --  flag page change    startofbox: BOOLEAN &larr; TRUE];  --  flag box change  jdsFileObject: TYPE = LONG POINTER TO jdsObject;  -- Constant declarations  maxjdspages: CARDINAL = 30;  jdspagesize: CARDINAL = 16;  boxOffset: LONG CARDINAL = 22;  jdsfilecheckword: CARDINAL = 12345B;  JDSEOR: CARDINAL = 10000B;  JDSBOR: CARDINAL = 46B;  JDSBLK: CARDINAL = 375B;  NULLCHAR: CharDefs.Char = [ 177B, 377B];  UNDFCHAR: CharDefs.Char = [0, 201B];  -- PUBLIC SIGNALS   endOfJDS: PUBLIC SIGNAL = CODE;  -- PUBLIC PROCEDURES    create: PUBLIC PROCEDURE [h: Handle] RETURNS [hJDS: Handle] =    BEGIN    i: CARDINAL;    sH: StreamJDSObject;    sH &larr; streamZone.NEW[      jdsStreamObject &larr; [      defaultObject: Stream.defaultObject, clientSH: h, jdsPtr: NIL]];    sH.defaultObject.options &larr; [TRUE, FALSE, FALSE, FALSE, FALSE, TRUE];    sH.defaultObject.getByte &larr; getByte;    sH.defaultObject.putByte &larr; putByte;    sH.defaultObject.getWord &larr; getWord;  --  plug in my own proc    sH.defaultObject.get &larr; get;  --  plug in my own proc    sH.defaultObject.put &larr; put;    sH.defaultObject.delete &larr; delete;    sH.defaultObject.setSST &larr; setSST;    sH.defaultObject.sendAttention &larr; sendAttention;    sH.defaultObject.waitAttention &larr; waitAttention;    sH.clientSH &larr; h;    sH.jdsPtr &larr; streamZone.NEW[jdsObject];    Stream.SetPosition[h, 0];    IF MStream.EndOf[h] THEN ERROR;    FOR i IN [0..256) DO      sH.jdsPtr.wurd &larr; Stream.GetWord[h];      IF i &lt;= maxjdspages THEN sH.jdsPtr.jdspage[i] &larr; sH.jdsPtr.wurd;      sH.jdsPtr.wordsread &larr; sH.jdsPtr.wordsread + 1;      ENDLOOP;    IF sH.jdsPtr.jdspage[0] # jdsfilecheckword THEN ERROR;  -- not graceful !    sH.jdsPtr.startofpage &larr; TRUE;    sH.jdsPtr.startofbox &larr; TRUE;    sH.jdsPtr.pageno &larr; 0;    sH.jdsPtr.curpage &larr; 0;    sH.jdsPtr.curbyteindx &larr; Stream.GetPosition[h];    sH.jdsPtr.topoftext &larr; sH.jdsPtr.curbyteindx;    sH.jdsPtr.recordsmade &larr; 0;    RETURN[LOOPHOLE[sH, Handle]];    END;  topOfJDS: PUBLIC PROCEDURE [sH: Stream.Handle] =    BEGIN    sh: StreamJDSObject &larr; LOOPHOLE[sH];    sh.jdsPtr.startofpage &larr; TRUE;    sh.jdsPtr.startofbox &larr; TRUE;    sh.jdsPtr.pageno &larr; 0;    sh.jdsPtr.curpage &larr; 0;    sh.jdsPtr.recordsmade &larr; 0;    sh.jdsPtr.curbyteindx &larr; sh.jdsPtr.topoftext;    Stream.SetPosition[sh.clientSH, sh.jdsPtr.topoftext];    END;  getByte: PROCEDURE [sH: Stream.Handle] RETURNS [byte: Stream.Byte] =    BEGIN    sh: StreamJDSObject &larr; LOOPHOLE[sH];    RETURN[Stream.GetByte[sh.clientSH]];    END;  putByte: PROCEDURE [sH: Stream.Handle, byte: Stream.Byte] =    BEGIN    sh: StreamJDSObject &larr; LOOPHOLE[sH];    Stream.PutByte[sh.clientSH, byte];    END;  put: PROCEDURE [    sH: Stream.Handle, block: Stream.Block, endRecord: BOOLEAN] =    BEGIN    sh: StreamJDSObject &larr; LOOPHOLE[sH];    Stream.PutBlock[sh.clientSH, block, endRecord];    END;  get: PROCEDURE [    sH: Stream.Handle, block: Stream.Block, options: Stream.InputOptions]    RETURNS [      bytesTransferred: CARDINAL, why: Stream.CompletionCode,       sst: Stream.SubSequenceType] =    BEGIN  -- Reads a JDS file and creates a formatted Master Entry/record.    wurd: CARDINAL;    i, oiscode: CARDINAL &larr; 0;    tempindex: LONG CARDINAL;    done: BOOLEAN &larr; FALSE;    newrec: BOOLEAN &larr; FALSE;    eor: BOOLEAN &larr; FALSE;    sh: StreamJDSObject &larr; LOOPHOLE[sH];    JDS: jdsFileObject &larr; sh.jdsPtr;    RP: LONG POINTER TO OISDictDataDefs.Entry &larr; LOOPHOLE[block.blockPointer];    BEGIN  -- Dummy Block to contain the Exit clause    ENABLE endOfJDS =&gt; BEGIN why &larr; endOfStream; GOTO fini; END;    IF (block.stopIndexPlusOne MOD 2) # 0 THEN ERROR;  -- using words NOT bytes    bytesTransferred &larr; 0;    -- Conditional needed for Show Top flag ...reset to JDS.topoftext     Stream.SetPosition[sh.clientSH, JDS.curbyteindx];    -- get Start of JDS record (".")    UNTIL JDS.wurd = JDSBOR DO JDS.wurd &larr; getWord[sH]; ENDLOOP;    -- Initialize record    RP&uarr;.notdel &larr; TRUE;    RP&uarr;.notMarked &larr; TRUE;    RP&uarr;.kanjiCodeSet &larr; OIS;    RP&uarr;.kanaCodeSet &larr; PhonicCodes;    RP&uarr;.logicalDict &larr; 0;    -- get KANA chars with 377B-fill (minus 1)     FOR i IN [0..13] DO      IF done THEN RP&uarr;.kana[i] &larr; 377B      ELSE        BEGIN        JDS.wurd &larr; getWord[sH];        IF JDS.wurd = JDSEOR THEN {          eor &larr; newrec &larr; done &larr; TRUE; RP&uarr;.kana[i] &larr; 377B; }        ELSE          -- IF JDS.wurd = JDSBOR THEN {newrec &larr; done &larr; TRUE; RP&uarr;.kana[i] &larr; 377B;} ELSE          IF JDS.wurd = JDSBLK THEN {done &larr; TRUE; RP&uarr;.kana[i] &larr; 377B; }          ELSE RP&uarr;.kana[i] &larr; JDSToPhonic[JDS.wurd];        END;      ENDLOOP;    done &larr; FALSE;    i &larr; 0;    IF newrec THEN GOTO dunatkanji;    -- get Kanji chars with 177777B-fill (minus 1)    UNTIL JDS.wurd # JDSBLK DO JDS.wurd &larr; getWord[sH]; ENDLOOP;    FOR i IN [0..6] DO      IF done THEN RP&uarr;.kanji[i] &larr; NULLCHAR      ELSE        BEGIN        IF JDS.wurd = JDSEOR THEN {          RP&uarr;.kanji[i] &larr; NULLCHAR; eor &larr; newrec &larr; done &larr; TRUE; }        ELSE          IF JDS.wurd = JDSBLK THEN {RP&uarr;.kanji[i] &larr; NULLCHAR; done &larr; TRUE; }          ELSE {	    IF JDS.wurd IN [1..JDStoOISDefs.lastJDSKanji] THEN	     { oiscode &larr; JDStoOISDefs.JDStoOIS[JDS.wurd];	     IF oiscode = JDStoOISDefs.UNDF THEN	        RP&uarr;.kanji[i] &larr; UNDFCHAR		ELSE RP&uarr;.kanji[i] &larr; LOOPHOLE[oiscode, CharDefs.Char];} 	    ELSE RP&uarr;.kanji[i] &larr; UNDFCHAR; };        IF NOT done THEN JDS.wurd &larr; getWord[sH];        END;      ENDLOOP;    done &larr; FALSE;    i &larr; 0;    IF newrec THEN GOTO dunatfreq;    -- get Frequency code value from character  (0 - 9, default = 0)     UNTIL JDS.wurd # JDSBLK DO wurd &larr; getWord[sH]; ENDLOOP;    IF JDS.wurd = JDSEOR THEN {eor &larr; TRUE; GOTO dunatfreq; }    ELSE      IF JDS.wurd = JDSBOR THEN GOTO dunatfreq      ELSE RP&uarr;.freq &larr; IF JDS.wurd IN [216B..227B] THEN JDS.wurd - 216B ELSE 0;    -- get Part Of Speech code value from characters (0 - 244, default = 0)    wurd &larr; getWord[sH];  -- get the next word(s)    UNTIL JDS.wurd # JDSBLK DO wurd &larr; getWord[sH]; ENDLOOP;    IF JDS.wurd = JDSEOR THEN {eor &larr; TRUE; GOTO dunatpos; }    ELSE      -- IF JDS.wurd = JDSBOR THEN GOTO dunatpos ELSE      RP&uarr;.pos &larr; JDSPosDefs.GetPosValue[wurd, getWord[sH]];    --  get Catagory code value from character (0 - 25B, default = 26B)    wurd &larr; getWord[sH];  -- get the next word(s)    UNTIL JDS.wurd # JDSBLK DO JDS.wurd &larr; getWord[sH]; ENDLOOP;    IF JDS.wurd = JDSEOR THEN {eor &larr; TRUE; GOTO dunatcat; }    ELSE      IF JDS.wurd = JDSBOR THEN GOTO dunatcat      ELSE RP&uarr;.cat &larr; JDSPosDefs.GetCatValue[JDS.wurd];    --  get End of JDS record (CR)    done &larr; FALSE;    i &larr; 0;    IF NOT eor THEN      UNTIL JDS.wurd = JDSEOR DO        BEGIN        JDS.wurd &larr; getWord[sH];        IF JDS.wurd = JDSBOR THEN  -- No CR for this record...reset;          BEGIN          tempindex &larr; Stream.GetPosition[sh.clientSH];          tempindex &larr; tempindex - 2;          Stream.SetPosition[sh.clientSH, tempindex];          GOTO fini;          END;        END;        ENDLOOP;    GOTO fini;    -- fills the rest of the incomplete record with default values    EXITS  -- flagging the last unused byte with a "?" (6)      dunatkanji =&gt;        BEGIN        IF eor THEN  -- No CR for this record...reset;          BEGIN          tempindex &larr; Stream.GetPosition[sh.clientSH];          tempindex &larr; tempindex - 2;          Stream.SetPosition[sh.clientSH, tempindex];          END;        FOR i IN [0..6] DO RP&uarr;.kanji[i] &larr; NULLCHAR; ENDLOOP;        RP&uarr;.freq &larr; RP&uarr;.pos &larr; 0;        RP&uarr;.cat &larr; 26B;        JDS.recordsmade &larr; JDS.recordsmade + 1;        bytesTransferred &larr; bytesTransferred + 32;        END;      dunatfreq =&gt;        BEGIN        IF eor THEN  -- No CR for this record...reset;          BEGIN          tempindex &larr; Stream.GetPosition[sh.clientSH];          tempindex &larr; tempindex - 2;          Stream.SetPosition[sh.clientSH, tempindex];          END;        RP&uarr;.freq &larr; RP&uarr;.pos &larr; 0;        RP&uarr;.cat &larr; 26B;        JDS.recordsmade &larr; JDS.recordsmade + 1;        bytesTransferred &larr; bytesTransferred + 32;        END;      dunatpos =&gt;        BEGIN        IF eor THEN  -- No CR for this record...reset;          BEGIN          tempindex &larr; Stream.GetPosition[sh.clientSH];          tempindex &larr; tempindex - 2;          Stream.SetPosition[sh.clientSH, tempindex];          END;        RP&uarr;.pos &larr; 0;        RP&uarr;.cat &larr; 26B;        JDS.recordsmade &larr; JDS.recordsmade + 1;        bytesTransferred &larr; bytesTransferred + 32;        END;      dunatcat =&gt;        BEGIN        RP&uarr;.cat &larr; 26B;        JDS.recordsmade &larr; JDS.recordsmade + 1;        bytesTransferred &larr; bytesTransferred + 32;        END;      fini =&gt;        BEGIN        JDS.recordsmade &larr; JDS.recordsmade + 1;        bytesTransferred &larr; bytesTransferred + 32;        END;    END;  -- Dummy Block to contain the EXITS clause    IF MStream.EndOf[sh.clientSH] THEN why &larr; endOfStream    ELSE JDS.curbyteindx &larr; Stream.GetPosition[sh.clientSH];    RETURN[bytesTransferred, why, sst];    END;  getWord: PRIVATE PROCEDURE [sH: Stream.Handle] RETURNS [word: Stream.Word] =    BEGIN    sh: StreamJDSObject &larr; LOOPHOLE[sH];    JDS: jdsFileObject &larr; sh.jdsPtr;    IF JDS.startofpage THEN      BEGIN      JDS.pageno &larr; JDS.pageno + 1;      IF JDS.pageno &gt; maxjdspages THEN SIGNAL endOfJDS      ELSE IF JDS.jdspage[JDS.pageno] = 0 THEN RETURN[getWord[sH]];      JDS.curpage &larr; LONG[512]*LONG[JDS.jdspage[JDS.pageno]];      IF JDS.textwordsread &gt; 0 THEN Heap.FreeNode[p: Box];  -- Flush old boxes      Stream.SetPosition[sh.clientSH, JDS.curpage];  -- Start of page      JDS.numofboxes &larr; Stream.GetWord[sh.clientSH];      JDS.wordsperbox &larr; Stream.GetWord[sh.clientSH];      JDS.wordsperbox &larr; JDS.wordsperbox + Stream.GetWord[sh.clientSH];      JDS.curbyteindx &larr; JDS.curpage + 6;  -- update byte stream indx      Box &larr; AllocateBoxes[JDS];      LoadBoxPtrs[sh.clientSH, JDS];      JDS.wordcount &larr; Stream.GetWord[sh.clientSH];  -- Total Text wordcount of Page      JDS.curbyteindx &larr; JDS.curbyteindx + 2;  -- set to start page text (bytes)      JDS.pagetextstart &larr; JDS.curbyteindx;  -- set to start page text (bytes)      JDS.wordsread &larr; 4 + (JDS.numofboxes*JDS.wordsperbox);      JDS.textwordsread &larr; 0;      JDS.boxno &larr; 0;      JDS.startofpage &larr; FALSE;      JDS.startofbox &larr; TRUE;      RETURN[getWord[sH]];      END    ELSE      IF JDS.startofbox THEN        BEGIN        IF JDS.boxno &gt;= JDS.numofboxes THEN          BEGIN JDS.startofpage &larr; TRUE; RETURN[getWord[sH]]; END;        JDS.curbyteindx &larr; JDS.pagetextstart + Box[JDS.boxno].base;        Stream.SetPosition[sh.clientSH, JDS.curbyteindx];        JDS.boxtextbytesread &larr; 0;        JDS.startofbox &larr; FALSE;        RETURN[getWord[sH]];        END      ELSE        BEGIN        DO          IF JDS.wordsread &gt;= 256*16 THEN  -- End of Page ?            BEGIN JDS.startofpage &larr; TRUE; RETURN[getWord[sH]]; END;          IF JDS.textwordsread &gt;= JDS.wordcount THEN  -- End of Page Text ?            BEGIN JDS.startofpage &larr; TRUE; RETURN[getWord[sH]]; END;          IF JDS.boxtextbytesread &gt;= Box[JDS.boxno].bytecount THEN  -- End of Box Text ?            BEGIN            JDS.startofbox &larr; TRUE;            JDS.boxno &larr; JDS.boxno + 1;            RETURN[getWord[sH]];            END;          JDS.wurd &larr; Stream.GetWord[sh.clientSH];  -- Get JDS word          JDS.wordsread &larr; JDS.wordsread + 1;          JDS.textwordsread &larr; JDS.textwordsread + 1;          JDS.boxtextbytesread &larr; JDS.boxtextbytesread + 2;          IF JDS.wurd IN [1..6624B] OR JDS.wurd = 10000B THEN RETURN[JDS.wurd]          ELSE RETURN[JDS.wurd &larr; 201B];          ENDLOOP;        END;    END;  delete: PROCEDURE [sH: Stream.Handle] =    BEGIN    sh: StreamJDSObject &larr; LOOPHOLE[sH];    streamZone.FREE[@sh.jdsPtr];    streamZone.FREE[@sh];    END;  setSST: PROCEDURE [sH: Stream.Handle, sst: Stream.SubSequenceType] =    BEGIN    sh: StreamJDSObject &larr; LOOPHOLE[sH];    Stream.SetSST[sh.clientSH, sst];    END;  sendAttention: PROCEDURE [sH: Stream.Handle, byte: Stream.Byte] =    BEGIN    sh: StreamJDSObject &larr; LOOPHOLE[sH];    Stream.SendAttention[sh.clientSH, byte];    END;  waitAttention: PROCEDURE [sH: Stream.Handle] RETURNS [byte: Stream.Byte] =    BEGIN    sh: StreamJDSObject &larr; LOOPHOLE[sH];    RETURN[Stream.WaitForAttention[sh.clientSH]];    END;  AllocateBoxes: PRIVATE PROCEDURE [JDS: jdsFileObject] RETURNS [p: BoxPtr] =    BEGIN  -- Allocates space for Box records and initiates     i: CARDINAL;    p &larr; Heap.MakeNode[n: SIZE[BoxObject]*JDS.numofboxes];    FOR i IN [0..JDS.numofboxes) DO p[i].base &larr; 0; p[i].bytecount &larr; 0; ENDLOOP;    RETURN[p];    END;  LoadBoxPtrs: PRIVATE PROCEDURE [sH: Stream.Handle, JDS: jdsFileObject] =    BEGIN  --  Reads in the Box Text pointers and counts     i: CARDINAL;    bytesperbox, indx: LONG CARDINAL;    bytesperbox &larr; JDS.wordsperbox*2;    IF MStream.EndOf[sH] THEN ERROR;    indx &larr; JDS.curbyteindx + boxOffset;    FOR i IN [0..JDS.numofboxes) DO      Stream.SetPosition[sH, indx];  -- 12th word of box        Box[i].base &larr; Stream.GetWord[sH];      Box[i].bytecount &larr; Stream.GetWord[sH];      indx &larr; indx + bytesperbox;      ENDLOOP;    JDS.curbyteindx &larr; JDS.curbyteindx + (bytesperbox*JDS.numofboxes);    Stream.SetPosition[sH, JDS.curbyteindx];  -- get total text wordcount    END;  JDSToPhonic: PROC [JDSCode: CARDINAL] RETURNS [Phonic: [0..377B]] =    BEGIN    Phonic &larr;      SELECT JDSCode FROM        IN [400B..523B] =&gt; JDSCode - 400B,  --  kana        IN [216B..227B] =&gt; JDSCode - 36B,  --  digits        IN [230B..261B] =&gt; JDSCode - 7B,  --  UpperCase Romaji        IN [262B..313B] =&gt; JDSCode - 21B,  --  lowercase Romaji        = 41B =&gt; 377B,  --  blank        = 42B, =44 =&gt; 131B,  --  comma        = 43B, =45B =&gt; 132B,  --  period        = 157B =&gt; 321B,  --  yen sign        = 160B =&gt; 144B,  --  dollar sign        ENDCASE =&gt; 152B;  --  asterix default    END;  END.  </pre>
  </body>
</html>
