(DEFINE-FILE-INFO §READTABLE "XCL" §PACKAGE "INTERLISP")(filecreated " 3-Nov-86 22:56:58" {eris}<lispcore>library>copyfiles.\;50 27275        |changes| |to:|  (fns copiedtospec)      |previous| |date:| "21-Jun-85 15:49:06" {eris}<lispcore>library>copyfiles.\;49); Copyright (c) 1984, 1985, 1986 by Xerox Corporation.  All rights reserved.(prettycomprint copyfilescoms)(rpaqq copyfilescoms ((fns copyfiles mapfiles copiedfilename copiedfilepattern copiedfilematch                            copiedtospec espattern nohost comparefiles)                      (vars copyfilesenumerate)                      (i.s.oprs infiles)))(defineq(copyfiles  (lambda (fromspec tospec options)                          (* |lmm| " 6-Jun-85 14:08")                    (* |Copies| |the| |files| |specified| |in| fromspec |to| |the| |destination|           |in| tospec. |Which| |versions| |get| |copied,| |whether| |to| |copy| |old|           |files,| |etc.| |is| |controlled| |by| options.)    (let ((copyfilesoutput t)          (copyfiles.whentoskip (function ileq))          (copyfilesalways t)          (copyfilesversions nil)          (copyfilesrename nil)          (copyfilesask nil)          (copyfilesaskdefault)          (copyfilesreplace nil)          (copyfilespurgesource nil)          (copyfilespurge nil)          (copyfilesterse)          (copyfilestospec (copiedtospec tospec)))         (declare (specvars . t))         (|for| x |inside| options |do|                     (* |Run| |thru| |the| |options,| |turning| |them| |into| |internal| |flag|           |settings| |and| |functional| |specifications.|)                                        (selectq x                                            (quiet                     (* |Don't| |want| |to| |hear| |about| |files| |as| |they're| |copied.|          |Set| |the| |output| |file| |to| nil |to| |suppress| |printing.|)                                                   (setq copyfilesoutput nil))                                            (terse                     (* |Only| |print| \a \. |per| |file| |copied.|          |Set| |the| terse |flag.|)                                                   (setq copyfilesoutput nil)                                                   (setq copyfilesterse t))                                            ((rename move)   (* h\e |wants| |the| |files| |moved,|                                                              |not| |copied.|)                                                 (setq copyfilesrename t))                                            (always          (* always |copy| |the| |files|                                                              |specified.|)                                                    (setq copyfilesalways t)                                                             (* |Tell| |it| |so|)                                                    (setq copyfiles.whentoskip (function nill))                                                             (* |And| |say| |never| |to| |skip| \a                                                              |potential| |file|)                                                    )                                            (>                     (* |Only| |copy| |if| |the| |source| |has| \a |newer| |version| |than| |the|           |destination.|)                                               (setq copyfiles.whentoskip (function ileq))                                               (setq copyfilesalways nil))                                            ((= =a)          (* = |without| always |doesn't| |make|                                                              \a |lot| |of| |sense|)                                                 (setq copyfiles.whentoskip (function true))                                                 (setq copyfilesalways t))                                            (\#              (* |Skip| |files| |that| |are| |the|                                                              |same| |on| |the| |destination|)                                                (setq copyfiles.whentoskip (function equal))                                                (setq copyfilesalways nil))                                            (allversions (setq copyfilesversions t))                                            (\#a (setq copyfiles.whentoskip (function equal))                                                 (setq copyfilesalways t))                                            (>a (setq copyfiles.whentoskip (function ileq))                                                (setq copyfilesalways t))                                            (ask (setq copyfilesask t))                                            (purge (setq copyfilespurge t))                                            (purgesource (setq copyfilespurgesource t)                                                         (setq copyfilesalways nil))                                            (replace (setq copyfilesreplace t))                                            (cond                                               ((and (listp x)                                                     (eq (car x)                                                         'output))                                                (setq copyfilesoutput (openstream (cadr x)                                                                             'output                                                                             'new)))                                               ((and (listp x)                                                     (eq (car x)                                                         'ask))                                                (setq copyfilesask t)                                                (setq copyfilesaskdefault (cadr x)))                                               (t (error x "unrecognized option")))))         (and copyfilesask (not copyfilesoutput)              (setq copyfilesoutput t))         (mapfiles fromspec                (function (lambda (filename crdate)                            (prog (newfilename nf cf dt1 dt2 helpflag)                                  (declare (specvars helpflag))                                  (and copyfilesoutput (|printout| copyfilesoutput .tab0 0 filename))                                                             (* |List| |the| |candidate| |file's|                                                              |name|)                                  (or (ersetq (setq newfilename (copiedfilename filename fromspec                                                                        copyfilestospec                                                                        copyfilesversions)))                                      (return (and copyfilesoutput (|printout| copyfilesoutput                                                                           " illegal file name "))))                    (* |Find| |out| |what| |the| |file's| |name| |would| |be| |at| |the|           |destination.|)                                  (setq dt1 (|if| crdate                                                |then| (idate crdate)                                              |else| (getfileinfo filename 'icreationdate)))                                  (|if| (or (not copyfilesalways)                                            (neq copyfiles.whentoskip 'nill))                                      |then|                     (* w\e |aren't| always |copying.| s\o |have| |to| |check| |this| |file| |to|           |see| |if| |it| |meets| |the| |copy| |criteria.|)                                            (cond                                               ((setq nf (infilep newfilename))                    (* |There| |is| \a |file| |of| |the| |same| |name| |at| |the| |destination.|          |CHeck| |it| |out.|)                                                (setq dt2 (getfileinfo nf 'icreationdate))                                                             (* |The| |destination| |file's|                                                              |create| |date|)                                                (and copyfilesoutput (|printout|                                                                      copyfilesoutput " ["                                                                      (gdate dt1)                                                                      "]" " vs. " nf "["                                                                      (|if| dt2                                                                          |then| (gdate dt2)                                                                        |else| "no date?")                                                                      "]"))                                                             (* |Tell| |the| |user| |we're|                                                              |comparing| |dates|)                                                (cond                                                   ((and dt2 (apply* copyfiles.whentoskip dt1 dt2))                    (* i\f |the| |file| |has| \a |create| |date,| |and| |it| |meets| |the| skip           |criteria,| |then| |skip| |over| |this| |file|)                                                    (and copyfilesoutput (|printout| copyfilesoutput                                                                                 " skipped."))                                                    (return))))                                               (copyfilespurgesource                                                             (* |We're| |to| |purge| |the| |source|                                                              |directory| |of| |non-corresponding|                                                              |files|)                                                (cond                                                   ((progn (and copyfilesoutput                                                                (|printout| copyfilesoutput                                                                        " (no corresponding "                                                                        newfilename "), "))                                                           (or (not copyfilesask)                                                               (eq 'y (askuser dwimwait                                                                              copyfilesaskdefault                                                                              "delete? " nil t))))                                                    ((lambda (str)                                                       (and copyfilesoutput (|printout|                                                                                    copyfilesoutput                                                                                    str)))                                                     (|if| (delfile filename)                                                         |then| " deleted."                                                       |else| " couldn't delete."))))                                                (return))                                               ((not copyfilesalways)                                                             (* |file| |doesn't| |exist| |on|                                                              |destination|)                                                (and copyfilesoutput (|printout| copyfilesoutput                                                           " does not exist on destination -- skipped"                                                                            ))                                                (return))))                                  (|if| (and copyfilesreplace nf)                                      |then| (setq newfilename nf))                                  (|if| copyfilesoutput                                      |then|                     (* |Write| |out| |the| |file's| |new| |name,| |and| |tell| |him| |we're|           |copying| |or| |moving| |it.|)                                            (|printout| copyfilesoutput                                                   (|if| copyfilesrename                                                       |then| " rename"                                                     |else| " copy"))                                            (|if| (not nf)                                                |then| (|printout| copyfilesoutput " to (new file) "                                                               newfilename)))                                  (cond                                     ((and copyfilesask (neq (askuser dwimwait copyfilesaskdefault                                                                     "? " nil t)                                                             'y))                                      (return)))                                  (or (ersetq (setq cf (cond                                                          (copyfilesrename (renamefile filename                                                                                   newfilename))                                                          (t (copyfile filename newfilename)))))                                      (return (and copyfilesoutput (|printout| copyfilesoutput                                                                           " failed."))))                                  (|if| copyfilesoutput                                      |then| (|if| (and (not copyfilesask)                                                        (not nf)                                                        (strpos newfilename cf 1 nil 1 nil (                                                                                       uppercasearray                                                                                            )))                                                 |then| (|printout| copyfilesoutput                                                               (or (substring cf (add1 (nchars                                                                                           newfilename                                                                                              )))                                                                   "."))                                               |else| (|printout| copyfilesoutput " => " cf))))                            (and copyfilesterse (prin1 "." copyfilesterse))))                "*"                (|if| copyfilesversions                    |then| "*"                  |else| ""))         (|if| copyfilespurge             |then|                                          (* |delete| |from| |source| |if|                                                              |doesn't| |exist| |on| |destination|)                   (and copyfilesoutput (|printout| copyfilesoutput t                                                "Deleting files on destination but not on source" t))                   (copyfiles tospec fromspec (append (|if| copyfilesoutput                                                          |then| (list (list 'output copyfilesoutput)                                                                       ))                                                     (|if| copyfilesask                                                         |then| (list (list 'ask copyfilesaskdefault)                                                                      ))                                                     '(= purgesource))))         (cond            (copyfilesoutput (tab 0 0 copyfilesoutput)                   (neq copyfilesoutput t)                   (closef copyfilesoutput))))))(mapfiles  (lambda (filespec fn defaultext defaultvers)               (* |jds| "27-Feb-85 11:46")                    (* |Run| |thru| |all| |the| |files| |that| |match| filespec\, |calling| fn |on|           |each| |such| |file| |name|)    (|if| (listp filespec)        |then| (|for| x |in| filespec |do| (mapfiles x fn defaultext defaultvers))      |elseif| (or (strpos "*" filespec)                   (fmemb (nthcharcode filespec -1)                          (charcode (> \) ] } \:))))        |then| (prog ((filegroup (\\generatefiles (directory.fill.pattern filespec defaultext                                                          defaultvers)                                        '(creationdate)                                        '(sort)))                      name)                     (|if| copyfilesenumerate                         |then| (|for| pair                                   |in| (|while| (setq name (\\generatenextfile filegroup))                                           |collect| (cons (|if| (listp name)                                                               |then| (concatcodes name)                                                             |else| name)                                                           (\\generatefileinfo filegroup '                                                                  creationdate)))                                   |do| (apply* fn (car pair)                                               (cdr pair)))                       |else| (|while| (setq name (\\generatenextfile filegroup))                                 |do| (apply* fn (|if| (listp name)                                                     |then| (concatcodes name)                                                   |else| name)                                             (\\generatefileinfo filegroup 'creationdate)))))      |elseif| (setq filespec (infilep filespec))        |then| (apply* fn filespec (getfileinfo filespec 'creationdate)))))(copiedfilename  (lambda (filename fromspec copiedspec preserveversion)     (* |lmm| "23-Nov-84 14:38")                    (* filename |is| |the| |file| |produced| |by| |the| |directory| |enumeration.|          fromspec |is| |the| |original| "FROM" |specification,| |and| copiedspec |is|           |either| \a |directory| |specification| (|string|) |or| |else| \a |list,| cdr           |of| |which| |is| \a |list| |of| |character| |atoms.|)    (setq filename (cond                      ((listp copiedspec)                    (* nohost |strips| |off| |the| host                                                              |ortion|)                       (concatlist (copiedfilepattern (nohost (espattern fromspec))                                          (cdr copiedspec)                                          (nohost (unpack (cond                                                             (preserveversion filename)                                                             (t (packfilename.string 'version nil                                                                       'body filename))))))))                      (t (packfilename.string 'directory tospec 'host nil 'device nil 'directory nil                                'body                                (|if| preserveversion                                    |then| filename                                  |else| (packfilename 'version nil 'body filename))))))    (|if| (eq (nthcharcode filename -1)              (charcode \.))        |then|                     (* |this| |is| \a |terrible| |kludge,| |to| |get| |around| |the| |problem|           |that| |for| |some| |devices,| (infilep "FOO.") |fails| |while|          (infilep "FOO") |doesn't.| |This| |stripping| |off| |of| \a |terminal| "."           |doesn't| |hurt,| |but| |doesn't| |belong| |here.|          |Necessary| |for| |getting| \a |working| |version| |for| |the| |harmony|           |release.|)              (substring filename 1 -2 filename)      |else| filename)))(copiedfilepattern  (lambda (frpat topat chars)                                (* |lmm| "23-Nov-84 17:49")    (prog nil          (|while| (and frpat (eq (u-case (car frpat))                                  (u-case (car chars)))) |do| (|pop| frpat)                                                              (|pop| chars))          (return (nconc (|on| |old| topat |while| (neq (car topat)                                                        '*) |collect| (car topat))                         (cond                            ((and frpat (neq (car frpat)                                             '*))                             (|if| (and (null chars)                                        (equal frpat '(\. *))                                        (or (null topat)                                            (equal topat '   (*))))                                 |then| nil                               |else| (error "FROMSPEC doesn't match generated file")))                            (topat                           (* |both| topat |and| frpat |start|                                                              |with| *)                                   (nconc (ldiff chars (setq chars (|for| x |on| chars                                                                      |when| (copiedfilematch                                                                              x                                                                              (cdr frpat))                                                                      |do| (setq $$val x))))                                          (copiedfilepattern (cdr frpat)                                                 (cdr topat)                                                 chars)))                            (t (or (copiedfilematch chars frpat)                                   (error "file pattern doesn't match"))                               nil)))))))(copiedfilematch  (lambda (chars frpat)                                      (* |lmm| "30-Oct-84 13:33")    (prog nil      lp  (|if| (null frpat)              |then| (return (null chars))            |elseif| (eq (car frpat)                         '*)              |then| (return (or (null (cdr frpat))                                 (|find| x |on| chars |suchthat| (copiedfilematch x (cdr frpat)))))            |elseif| (eq (u-case (pop frpat))                         (u-case (pop chars)))              |then| (go lp)            |else| (return)))))(copiedtospec  (lambda (spec)                                             (* |lmm| " 3-Nov-86 19:06")    (|if| (strpos "*" spec)        |then| (cons 'pattern (espattern spec))      |else| (or (directoryname spec nil t)                 (error spec "not a valid directory")))))(espattern  (lambda (x)                                                (* |lmm| "23-Nov-84 10:53")    (|for| y |on| (unpack x) |collect| (|if| (eq (car y)                                                 '*)                                           |then| (|if| (and (eq (cadr y)                                                                 '\.)                                                             (eq (caddr y)                                                                 '*)                                                             (fmemb (cadddr y)                                                                    '(nil \;)))                                                      |then| (rplacd y (cdddr y)))                                                 '*                                         |else| (car y)))))(nohost  (lambda (up)    (selectq (car up)        (({ \( [)              (|do| (|pop| up)                   (selectq (car up)                       (nil (return))                       ((} \) ])                             (return (|pop| up)))                       (\' (|pop| up))                       nil)))        nil)    up))(comparefiles  (lambda (oldfile newfile)                                  (* |lmm| " 7-Sep-84 11:57")                    (* |Compare| |two| |files| |to| |see| |if| |their| |contents| |are| |the|           |same.|)    (prog ((ostream (openstream oldfile 'input 'old '(sequential t)))           (nstream (openstream newfile 'input 'old '(sequential t)))           olen nlen)          (setq olen (getfileinfo ostream 'length))          (setq nlen (getfileinfo nstream 'length))          (cond             ((not (eqp olen nlen))                    (* i\f |they| |files| |are| |of| |different| |lengths,| |they| |aren't| |the|           |same.|)              (error "File lengths differ:  " (concat olen " vs " nlen))))          (cond             (olen                     (* ftp |returns| nil |for| |the| |length| |of| |an| |empty| |file!|)                   (|for| bytepos |from| 0 |to| (sub1 olen) |do| (cond                                                                    ((neq (bin ostream)                                                                          (bin nstream))                                                                     (error "Files differ at byte "                                                                             bytepos))))))          (closef? ostream)          (closef? nstream))    t)))(rpaqq copyfilesenumerate t)(declare\: eval@compile (i.s.opr 'infiles nil '(subst (gensym)                              'genvar                              '(bind genvar _ (\\generatefiles body nil '(sort))                                     eachtime                                     (progn (or (setq i.v. (\\generatenextfile genvar))                                                (go $$out))                                            (if (listp i.v.)                                                then                                                (setq i.v. (concatcodes i.v.)))))) t))(putprops copyfiles copyright ("Xerox Corporation" 1984 1985 1986))(declare\: dontcopy  (filemap (nil (648 26571 (copyfiles 658 . 16575) (mapfiles 16577 . 18731) (copiedfilename 18733 . 20879) (copiedfilepattern 20881 . 22957) (copiedfilematch 22959 . 23586) (copiedtospec 23588 . 23896) (espattern 23898 . 24793) (nohost 24795 . 25157) (comparefiles 25159 . 26569)))))stop