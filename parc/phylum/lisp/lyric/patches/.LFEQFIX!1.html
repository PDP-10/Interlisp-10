<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [phylum]&lt;LISP>Lyric>PATCHES>LFEQFIX!1</title>
  </head>
  <body>
    <pre>
(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "INTERLISP")(filecreated "22-Oct-87 17:19:13" {eris}&lt;lispcore&gt;temp&gt;lfeqfix.\;1 5174         |changes| |to:|  (vars lfeqfixcoms)); Copyright (c) 1987 by Xerox Corporation.  All rights reserved.(prettycomprint lfeqfixcoms)(rpaqq lfeqfixcoms ((fns |\\LFReadPages| |\\VFMCorrectBufferP| |\\VFMMarkBufferDirty|)))(defineq(|\\LFReadPages|  (lambda (|stream| |streamFirstPage| |buffers|)             (* \; "Edited 22-Oct-87 16:03 by amd")                    (* |;;|           "Reads a bunch of pages from stream, starting at firstPage.  Returns number of bytes read.")                    (* |;;| "Modified ' 4-Jul-85 04:47:22' by HTS to extend the backing file whenever it tries to read past the end of the backing file.  This generally ensures that data subsequently written on these buffer pages will not be lost if you run out of disk space")                    (* |;;| "If asked to read a page which is off the end of the stream, it will zero the page.  Odd though it may seem, reading off the end of the file is reasonable behavior for copybytes: buffer pages must come from somewhere, and copybytes may not have to write the whole page, and in general copybytes does not know whether a page is actually in a file or off the end of it.  Seems inefficient, but since reading past eof does not actually require disk access, its not that bad.")                    (* |;;| "Extend backing file if necessary to accomodate buffers.")    (|\\LFExtendFileIfNecessary| |stream| |streamFirstPage| |buffers|)                    (* |;;| "Write out the buffers to the backing file.")    (|for| |buffer| |inside| |buffers| |as| |streamPageNumber| |from| |streamFirstPage| |as|                                                                               |backingFilePageNumber|       |from| (add1 |streamFirstPage|) |bind| (|file| &larr; (|fetch| (dlionstream filedesc) |of| |stream|                                                               ))                                             |lastStreamPage| |offset|       |first| (\\updateof |stream|)             (setq |lastStreamPage| (plus (|fetch| (dlionstream epage) |of| |stream|)                                          (|if| (cl:zerop (|fetch| (dlionstream eoffset) |of|                                                                                              |stream|                                                                 ))                                              |then| -1                                            |else| 0)))       |sum| (|if| (ileq |streamPageNumber| |lastStreamPage|)                 |then|                     (* |;;| "If page inside stream, then it has presumably already been written;  read it in.")                       (|\\PFGetPage| |file| |backingFilePageNumber| (|\\PFFindPageAddr| |file|                                                                             |backingFilePageNumber|)                              |buffer|)                     (* |;;|           "If this was the last page in the file, then fill in the trailing bytes with nulls.")                       (|if| (eql |streamPageNumber| |lastStreamPage|)                           |then| (setq |offset| (|fetch| (dlionstream eoffset) |of| |stream|))                                 (|if| (cl:zerop |offset|)                                     |then| (setq |offset| bytesperpage)                                   |else| (\\clearbytes |buffer| |offset| (difference bytesperpage                                                                                  |offset|)))                                 |offset|                         |else| bytesperpage)               |else|                     (* |;;| "If this was outside the stream, clear the buffer.")                     (\\clearwords |buffer| wordsperpage)                     0))))(|\\VFMCorrectBufferP|  (lambda (buffer volpagenum)                                (* \; "Edited 22-Oct-87 16:54 by amd")                    (* |;;| "True iff BUFFER is the right buffer for VOLPAGENUM")    (and (eql (|fetch| (\\btreebuf volume) |of| buffer)              |\\VFMvolumeHandle|)         (eql (|fetch| (\\btreebuf volpagenum) |of| buffer)              volpagenum))))(|\\VFMMarkBufferDirty|  (lambda (bufferpage)                                       (* \; "Edited 22-Oct-87 15:13 by amd")                    (* |;;|       "Note that the specified buffer has been written into and will have to be flushed out to disk.")    (|replace| (\\btreebuf dirty) |of| (|for| buf |in| |\\VFMbufferPool|                                          |thereis| (eql bufferpage (|fetch| (\\btreebuf page)                                                                       |of| buf))) |with| t)    nil)))(putprops lfeqfix copyright ("Xerox Corporation" 1987))(declare\: dontcopy  (filemap (nil (373 5095 (|\\LFReadPages| 383 . 4091) (|\\VFMCorrectBufferP| 4093 . 4511) (|\\VFMMarkBufferDirty| 4513 . 5093)))))stop</pre>
  </body>
</html>
