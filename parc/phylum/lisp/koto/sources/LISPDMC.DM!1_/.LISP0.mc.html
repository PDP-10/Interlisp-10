<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [phylum]&lt;LISP>KOTO>Sources>LISPDMC.DM!1>LISP0.mc</title>
  </head>
  <body>
    <pre>
:Title[Lisp0];** Edit History* March 29, 1985  2:20 PM, Masinter, formatting* March 20, 1985, Masinter, move UPCTRACE to 374* March 15, 1985  10:59 AM, Masinter,  bum out unused cases*      (e.g., Alto display)* March 12, 1985  6:52 PM, Masinter, SAVEUCODESTATE was smashing color CSB*   got rid of it* February 2, 1985  10:34 PM, Masinter, Def2BR was set wrong!* January 22, 1985  12:24 AM, Masinter, remove Altomode instructions no*     longer used* January 5, 1985  11:39 PM, JonL, Flush ZeroBR; setup Val2BR and Def2BR*     for 64K Litatoms scheme* February 18, 1984  4:54 PM, JonL, SAVEUCODESTATE uses SubrArgArea*		instead of statsBuffer* January 31, 1984  7:31 PM, JonL, embellish SAVEUCODESTATE* January 31, 1984  5:05 PM, Masinter, add SAVEUCODESTATE as subroutine* January 23, 1984  6:51 PM, JonL, debugging previous change* January 20, 1984  6:26 AM, JonL, added check for BLT in pageFault* January 4, 1983  2:48 PM, Masinter:insert[DisplayDefs.mc];	mc[max.pvar.for.fault, 3000];* Code for Interface with BCPL   KnowRBase[LTEMP0];   TOP LEVEL;   InsSet[LispInsSet, 1];   mc[UCODE.CHECK, 0];   mc[STKOV.PUNT, sub[0,SubovFXP!]]; * says context switch to Subov   mc[NWW.INTERRUPT, 2];   mc[PAGE.FAULT, sub[0,FAULTFXP!]];   mc[STATS.PUNT, 4];*--------------------------------------------------------------------opSUBR:   *--------------------------------------------------------------------	LTEMP0&larr; Id; 	T&larr; LTEMP2&larr; Id;										* Beta byte is # args	T&larr; T + T;	T&larr; TSP&larr; (TSP) - (Cnt&larr; T);			* Move args from stack	LTEMP1&larr; SubrArgArea, Branch[.subr1];.subr0:	T&larr; (fetch&larr; T) + 1;		* Tight loop to move args 	memBase&larr; MDS;		*  from stackframe to the	LTEMP1&larr; (store&larr; LTEMP1)+ 1, dbuf&larr; Md;	*  BCPL subr arg area.subr1:	memBase&larr; StackBR, branch[.subr0, Cnt#0&amp;-1];	LTEMP1&larr; (Id) - (PCX') - 1, branch[.storepuntpc];IFUpause[175, 3, StackBR, 0, opSUBR, noNData, 0, 0];	*SUBRCALL*--------------------------------------------------------------------opCNTXTSWITCH:*--------------------------------------------------------------------   T&larr; (TSP) - 1;   TSP&larr; (fetch&larr; T) - 1;		* fetch arg   rbase&larr; rbase[NWW];   T&larr; Md, NWW&larr; (NWW) and not (100000c);	* turn on interrupts   pd&larr; NWW, rbase&larr; rbase[LTEMP0];   branch[.+2, alu=0], LTEMP0&larr; (0s) - T; * LTEMP0&larr; - (context#)   pd&larr; LTEMP0, RescheduleNow;		* reschedule if int pending...   LTEMP1&larr; (Id) - (PCX') - 1, branch[.storepuntpc];IFUpause[176, 1, StackBR, 0, opCNTXTSWITCH, noNData, 0, 0];	*CNTXTSWITCH*--------------------------------------------------------------------UCODECHECKPUNT: GLOBAL,  *--------------------------------------------------------------------* call: SaveLink&larr; Link, Branch[uCodeCheckPunt];	LTEMP4&larr; SubrArgArea;				* set up ucode	LTEMP4&larr; (store&larr; LTEMP4) + 1, dbuf&larr; SmallHi;	*  address of punter	LTEMP4&larr; (store&larr; LTEMP4) + 1, dbuf&larr; T;		*  as arg to BCPL subr   LTEMP2&larr; 1c;   LTEMP0&larr; UCODE.CHECK, branch[BCPLEXIT];% got rid of SAVEUCODESTATE -- it smashes the color Core Status Buffer*--------------------------------------------------------------------SUBROUTINE;	SAVEUCODESTATE: GLOBAL,*--------------------------------------------------------------------* Clobbers LTEMP4 and BR* Called by*		rbase&larr; rbase[LTEMP0];*	KnowRBase[LTEMP0];*		LTEMP3&larr; T, T&larr; Link, Call[SAVEUCODESTATE];		memBase&larr; MDS;												* Save some volatile	Q&larr; LTEMP4;				*  ucode regs in stats	LTEMP4&larr; (XXXX); 	LTEMP4&larr; (store&larr; LTEMP4) + 1, dbuf&larr; (125377c);* 0  PassWord	LTEMP4&larr; (store&larr; LTEMP4) + 1, dbuf&larr; T;	* 1  Link at call here	T&larr; Link;	T&larr; (store&larr; LTEMP4) + 1, dbuf&larr; T;	* 2  ucode.addr + 1 of	RBase&larr;rbase[FLTEMUPC];			*   of call to here	T&larr;(store&larr; T) + 1, dbuf&larr; FLTEMUPC;	* 3  PC at fault	RBase&larr;rbase[LTEMP0];	T&larr; (store&larr; T) + 1, dbuf&larr; SaveLink;	* 4  maybe saved link	T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP3;	* 5  T register	T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0;	* 6  LTEMP0	T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;	* 7  LTEMP1	T&larr; (store&larr; T) + 1, dbuf&larr; PVAR;		* 10 PVAR	T&larr; (store&larr; T) + 1, dbuf&larr; TSP;		* 11 TSP	T&larr; (store&larr; T) + 1, dbuf&larr; PSTATE;	* 12 PSTATE	T&larr; (store&larr; T) + 1, dbuf&larr; DEFLO;	* 13 DEFLO	T&larr; (store&larr; T) + 1, dbuf&larr; NARGS;	* 14 NARGS	T&larr; (store&larr; T) + 1, dbuf&larr; Q;		* 15 LTEMP4	LTEMP0&larr; TIOA&amp;StkP;	T&larr; (Store&larr; T) + 1, dbuf&larr; LTEMP0;	* 16 stackp	LTEMP0&larr; 1c;	StkP&larr; LTEMP0;	T&larr; (Store&larr; T) + 1, dbuf&larr; Stack&amp;+1;	T&larr; (Store&larr; T) + 1, dbuf&larr; Stack&amp;+1;	T&larr; (Store&larr; T) + 1, dbuf&larr; Stack&amp;+1;	T&larr; (Store&larr; T) + 1, dbuf&larr; Stack&amp;+1;	T&larr; (Store&larr; T) + 1, dbuf&larr; Stack&amp;+1;	T&larr; LTEMP3, Return;%TOP LEVEL;*--------------------------------------------------------------------RAIDPUNT:*--------------------------------------------------------------------* like UCODEPUNT, but registers are OK;	RBase&larr; rbase[LTEMP0];	memBase&larr; MDS;	LTEMP0&larr; SubrArgArea;	LTEMP0&larr; (store&larr; LTEMP0) + 1, dbuf&larr; SmallHi;	store&larr; LTEMP0, dbuf&larr; 0c;	LTEMP2&larr; 1c;	LTEMP0&larr; UCODE.CHECK, Branch[PUNT];*--------------------------------------------------------------------STKOVPUNT:*--------------------------------------------------------------------	LTEMP0&larr; STKOV.PUNT, branch[.puntz];*--------------------------------------------------------------------STATSPUNT:*--------------------------------------------------------------------	LTEMP0&larr; STATS.PUNT, branch[.puntz];*--------------------------------------------------------------------NWWPUNT:* old NWW: exit to BCPL w/reschedule still set*--------------------------------------------------------------------   rbase&larr; rbase[LTEMP0];   LTEMP0&larr; NWW.INTERRUPT, branch[.puntz]; *--------------------------------------------------------------------KEYPUNT: KnowRBase[NWW]; * new NWW: context switch to KBD context*--------------------------------------------------------------------   NWW&larr; (100000c); * turn off interrupts   rbase&larr; rbase[LTEMP0];   LTEMP0&larr; sub[0, KbdFXP!]c, branch[.puntz];.puntz:   LTEMP2&larr; A0, branch[PUNT];*--------------------------------------------------------------------PAGEFAULTPUNT:*--------------------------------------------------------------------   rbase&larr; rbase[FltPipe0];   memBase&larr; InterfaceBR;   T&larr; IFPFAULTHI;   T&larr; (store&larr; T) + 1, dbuf&larr; FltPipe0;   store&larr; T, dbuf&larr; FltPipe1;   rbase&larr; rbase[LTEMP0];* Check first for pagefault while "in function call" (which is OK).:if[Debugging];	Branch[.+2, R&gt;=0], pd&larr; (PSTATE) and (PS.PFOK);	 Branch[.pfp1];	* OK to fault in fn call. No constraint on .pfp1	Branch[.+2, alu#0], pd&larr; (PSTATE) and (add[PS.INBITBLT!, PS.INBLT!]c);		uCodeCheck[PageFaultWhenNotOK];:else;	pd&larr; (PSTATE) and (add[PS.INBITBLT!, PS.INBLT!]c), * PSTATE is -1	Branch[.+2, R&gt;=0];		*  in fn call		Branch[.pfp1];	* OK to fault in fn call. No constraint on .pfp1:endif;* Check also for fault in BLT or BITBLT (which need stack patchup).	Branch[.pfp1, alu=0], PSTATE, pd&larr; (PSTATE) and (PS.INBLT);		Branch[.+2, alu=0], memBase&larr; StackBR, T&larr; (TSP) - 1; 			stack&larr; (stack) + 1;		PSTATE&larr; A0, store&larr; T, dbuf&larr; Stack, Branch[.pfp1]; .pfp1:		** check for page fault in page fault context	pd&larr; (PVAR) - (max.pvar.for.fault);	Branch[.+2, carry], LTEMP0&larr; PAGE.FAULT;		uCodeCheck[PageFaultRecursion];:if[Debugging];	rbase&larr; rbase[NWW];	Branch[.+2, R&gt;=0], NWW, rbase&larr; rbase[LTEMP0];		uCodeCheck[NWW?];:endif;.pfp2:   LTEMP2&larr; A0, branch[PUNT];*--------------------------------------------------------------------* common punt code*--------------------------------------------------------------------PUNT:	T&larr; (PVAR) - (FXBACK[FLAGS]);	memBase&larr; StackBR, PSTATE, branch[.normalpunt, R&gt;=0];* punt in call	fetch&larr; T, LTEMP1&larr; FXInCall;	LTEMP1&larr; (LTEMP1) or Md;	store&larr; T, dbuf&larr; LTEMP1;	T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;	T&larr; (store&larr; T) + 1, dbuf&larr; NARGS;	T&larr; (store&larr; T) + 1, dbuf&larr; 0c;	* can't fault if DEFHI nonzero	TSP&larr; (store&larr; T) + 1, dbuf&larr; DEFLO, branch[.puntfixstack];.normalpunt:	fetch&larr; T, LTEMP1&larr; FXNoPushReturn;	LTEMP1&larr; (LTEMP1) or Md;	store&larr; T, dbuf&larr; LTEMP1;	LTEMP1&larr; not (PCX');.storepuntpc: 			* from SUBR and context switch, too	T&larr; (PVAR) - (FXBACK[PC]);	store&larr; T, dbuf&larr; LTEMP1;   .puntfixstack:	T&larr; (PVAR) - (FXBACK[NEXT]);	store&larr; T, T&larr; dbuf&larr; TSP;			* store NEXT	T&larr; (ESP) - T;	branch[.+2, carry], TSP&larr; (store&larr; TSP) + 1, dbuf&larr; FreeStackBlock;		uCodeCheck[NoStackAtPunt];	store&larr; TSP, dbuf&larr; T;* LTEMP0 = punt or subr#, or else (- context#)* LTEMP2  = number of args* PVAR okBCPLEXIT:	memBase&larr; interfaceBR;	PVAR&larr; (PVAR) - (FX.PVAR);	branch[.ctxswitch, R&lt;0], Q&larr; LTEMP0;:if[Debugging];	PSTATE&larr; (PS.INBCPL);:endif;	store&larr; add[CurrentFXP!]s, dbuf&larr; PVAR;:if[FNStats];	branch[.+2, R&gt;=0], FnStatsPtr;	branch[.bcplxend];	nop;		* Following Call constrains addresses	DEFLO&larr; Q, Call[.subrstat];	memBase&larr; MDS;	T&larr; StatsBufferPtr;	store&larr; T, dbuf&larr; FnStatsPtr, Branch[.bcplxend];:endif; * FNStats.bcplxend:	T&larr; LTEMP2, rbase&larr; rbase[spAC0];	StkP&larr; spAC2;	Stack&amp;+1&larr; Q;			* value for AC2 Punt or subr #	Stack&amp;-1&larr; T;			* # of args	T&larr; AemuRestartLoc, branch[start];KnowRBase[LTEMP0];.ctxswitch:	T&larr; (0s) - (LTEMP0);	* context#	fetch&larr; T;:if[Debugging];	PSTATE&larr; (PS.PCXBAD);:else;	PSTATE&larr; A0;:endif;	PVAR&larr; Md, store&larr; T, dbuf&larr; PVAR;	PVAR&larr; (PVAR) + (FX.PVAR), branch[RTN2];:if[FNStats];	SUBROUTINE;*--------------------------------------------------------------------* Stats writing*--------------------------------------------------------------------.subrstat:	DEFHI&larr; A0;	T&larr; LSH[LTEMP2, 10];	T&larr; T or (CALL.EVENT), branch[.storestat];FNSTAT: * fn in LTEMP0, 1, NARGS set.	T&larr; LTEMP0, memBase&larr; MDS;	T&larr; LCY[T, NARGS, 10];	T&larr; T or (CALL.EVENT);	T&larr; (store&larr; FnStatsPtr) + 1, dbuf&larr; T;	T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1, branch[.stattail];.storeretstat:	T&larr; (RETURN.EVENT), branch[.storestat];.storestat:	T&larr; T or (DEFHI), memBase&larr; MDS;	T&larr; (store&larr; FnStatsPtr) + 1, dbuf&larr; T;	T&larr; (store&larr; T) + 1, dbuf&larr; DEFLO;.stattail:	FnStatsPtr&larr; T;	T&larr; 30c;	T&larr; T + (400c);	TaskingOFF;	fetch&larr; T;	T&larr; (store&larr; FnStatsPtr) + 1, dbuf&larr; Md;	RBase&larr; RBase[RTClock];	T&larr; (store&larr; T) + 1, dbuf&larr; RTClock;	TaskingON;	RBase&larr; RBase[FnStatsPtr];	FnStatsPtr&larr; T;	pd&larr; T - (StatsBufferBoundary);	branch[.+2, alu&lt;=0];		ReSchedule;	Return;	TOP LEVEL;:endif; * FNStats*--------------------------------------------------------------------   KnowRBase[AEmRegs];   m[MBXI, KnowRBase[AEmRegs]	   Top level];LTrap:   ETEMP2&larr; Id, call[GetPC];   branch[.+2, alu&lt;0], ETEMP4&larr; T + 1;   BigBdispatch&larr; ETEMP2;   branch[LTrapDispatch], StkP&larr; spAC0;EmuNext:   rbase&larr; rbase[AEmRegs], global;   T&larr; ETEMP4, branch[start];EmuSkip:   rbase&larr; rbase[AEmRegs];   T&larr; (ETEMP4) + 1, branch[start];*--------------------------------------------------------------------* arrive at the Lisp dispatch locations with StkP&larr; spAC0 *--------------------------------------------------------------------* vanMelle claims 0,1,2,4,5,6,10,11 are usedLTrapDispatch:   branch[MBIX], dispTable[20];	*   00   branch[ReadFlags];		*   01   branch[SetFlags];			*   02   branch[NPTrap];			*   03	was XferPage   branch[BGetBase];			*   04   branch[BPutBase];			*   05   branch[BGetBase32];		*   06   branch[NPTrap];			*   07  was BGetBasePtr   branch[BPutBase32];		*   10   branch[InitLispRegs];		*   11MBXI;	*--------------------------------------------------------------MBIX:   rbase&larr; rbase[LTEMP1];   LTEMP0&larr; Stack&amp;+1;			* AC0: hi part of return value   LTEMP1&larr; Stack;			* AC1: lo part of return value:if[Debugging];   PSTATE&larr; (PS.PCXBAD);:else;   PSTATE&larr; A0;:endif;:if[FNStats];   rbase&larr; rbase[PVAR];   T&larr; StatsBufferPtr;   memBase&larr; MDS;   fetch&larr; T;   FnStatsPtr&larr; Md;   pd&larr; FnStatsPtr;   branch[.+2, alu#0];	FnStatsPtr&larr; -1c;:else;   FnStatsPtr&larr; T-T-1;   memBase&larr; MDS;:endif;* memBase=MDS   rbase&larr; rbase[NWW];   T&larr; (R400) + (52C);	* WW (= 452B)   fetch&larr; T, T&larr; (100000C);   T&larr; (Md) and not (T);   NWW &larr; (NWW) or T;   branch[.+2, alu=0], rbase&larr; rbase[LTEMP0];	Reschedule;   T&larr; add[100000, LShift[LispInsSet, 10]]c;	* set InsSet   InsSetOrEvent&larr; T;   MemBX&larr; 0s;				* SET MemBX   T&larr; StackEmpty;				* set StkP   StkP&larr; T;   memBase&larr; interfaceBR;   fetch&larr; add[CurrentFXP!]s;   PVAR&larr; Md;   PVAR&larr; (PVAR) + (FX.PVAR), branch[RTN2];	MBXI;	*--------------------------------------------------------------ReadFlags:   call[flushVp], T&larr; Stack;   RMap&larr; ETEMP3, call[waitforMapBuf];	* uses T only   Stack&amp;+1&larr; not (Map');   T&larr; not (Pipe4');   Stack&amp;-1&larr; T and (m1pipe4.wpdref),	* wp, d, &amp; ref from pipe4   branch[EmuNext];   KnowRBase[LTEMP0];*--------------------------------------------------------------opREADFLAGS:   T&larr; (TSP) - 1;   fetch&larr; T;   call[flushVp], T&larr; Md, rbase&larr;rbase[ETEMP3];    RMap&larr; ETEMP3, call[waitforMapBuf];   pd&larr; Id, rbase&larr; rbase[TSP];   branch[.+2, alu=0], LTEMP0&larr; not (Pipe4');	LTEMP0&larr; not (Map'), branch[.readtail];   LTEMP0&larr; (LTEMP0) and (m1pipe4.wpdref), branch[.readtail];.readtail:   T&larr; (Id) - (PCX') - 1;   PCF&larr; T;				* restart IFU   T&larr; (TSP) - 1, memBase&larr; StackBR;   store&larr; T, dbuf&larr; LTEMP0, NextOpCode;regOP1[161, StackBR, opREADFLAGS, 0];	* readflagsregOP1[162, StackBR, opREADFLAGS, 1];	* readrpMBXI;	*--------------------------------------------------------------SetFlags:   StkP&larr; spAC2;    T&larr; (Stack&amp;-2) + (3c);   fetch&larr; T;				* fetch flags   ETEMP2&larr; Md, T&larr; Stack&amp;+1, call[flushVP];	*flush cache   T&larr; lsh [ETEMP2, 2];			* position the wp&amp;dirty bits   T&larr; T and (TIOAvacantMapEntry);		* mask out any extra bits   T&larr; Stack&amp;-1, TIOA&larr; T;   B&larr; T, TASKINGOFF;				* get bmux stable for Map&larr;   Map&larr; ETEMP3, B&larr; T;			* write the map   TASKINGON;   call[waitforMapBuf], TIOA&larr; ETEMP3;		* clear TIOA* flushVp did one IFUReset, must do a second   branch[.+2, R&gt;=0], ETEMP2, IFUReset;		* check for ref bit	fetch&larr; ETEMP3;				* reference it   branch[EmuNext];*--------------------------------------------------------------------SUBROUTINE;	FlushVP:	* vp is in T, uses ETEMP3, sets memBase   memBase&larr; LScratchBR, B&larr; Md;			* finish any stores   IFUreset;				* stop IFU from making refs   ETEMP3&larr; lsh[T, 10];   T&larr; rsh[T, 10];   BrHi&larr; T;   BrLo&larr; ETEMP3;   T&larr; 360C; FlushVPLoop:   flush&larr; T;   T&larr; T - (20C);   branch[FlushVPLoop, alu&gt;=0];   B&larr; Md, ETEMP3&larr; A0, return;TOP LEVEL;MBXI;	*--------------------------------------------------------------BGetBase:    call[BFetch];   Stack&larr; Md, branch[EmuSkip];MBXI;	*--------------------------------------------------------------BGetBase32:   call[BFetch];   Stack&amp;+1&larr; Md;   fetch&larr; 1s;   Stack&larr; Md, branch[EmuSkip];SUBROUTINE;BFetch:   memBase&larr; LScratchBR;   BrHi&larr; Stack&amp;+1;   BrLo&larr; Stack&amp;-1;   fetch&larr; 0s, return;TOP LEVEL;MBXI;	*--------------------------------------------------------------BPutBase:    StkP&larr; spAC2;   T&larr; (Stack&amp;-2) + (3c);   fetch&larr; T;   T&larr; Md, call[BStore], memBase&larr; LScratchBR;   B&larr; Md, branch[EmuSkip];MBXI;	*--------------------------------------------------------------BPutBase32:    StkP&larr; spAC2;   T&larr; (Stack&amp;-2) + (3c);   fetch&larr; T;      T&larr; Md;   T&larr; (fetch&larr; T) + 1;   T&larr; Md, fetch&larr; T;   call[BStore], ETEMP2&larr; Md, memBase&larr; LScratchBR;   T&larr; ETEMP2;   store&larr; 1s, dbuf&larr; T, branch[EmuSkip];*--------------------------------------------------------------------SUBROUTINE;BStore:   BrHi&larr; Stack&amp;+1;   BrLo&larr; Stack&amp;-1;		* restore to AC0   store&larr; 0s, dbuf&larr; T, return;TOP LEVEL;MBXI;	*--------------------------------------------------------------InitLispRegs:   rbase&larr; rbase[RMForIFU];   MemBX&larr; 0s;					* SET MemBX   AllOnes&larr; T-T-1;:if[Debugging];   PSTATE&larr; (PS.INBCPL);:endif;   T&larr; stackHI;   LTEMP0 &larr; A0, memBase&larr; StackBR, call[setBR];   LTEMP0&larr; (LTEMP0) - (2c);   T&larr; T - 1, memBase&larr; StackM2BR, call[setBR];   T&larr; VALspace;   LTEMP0&larr; A0, memBase&larr; ValSpaceBR, call[setBR];   T&larr; T + 1, memBase&larr; Val2BR, call[setBR];   T&larr; LTEMP0&larr; A0, memBase&larr; ScratchLZBR, call[setBR];   T&larr; DEFspace;   LTEMP0&larr; A0, memBase&larr; DefBR, call[setBR];      T&larr; T + 1, memBase&larr; Def2Br, call[setBR];   T&larr; HTMAINspace;   LTEMP0&larr; HTMAINbase;   memBase&larr; htMainBR, call[setBR];   LTEMP0&larr; HTOVERFLOWbase;   memBase&larr; HTOfloBR, call[setBR];* Note that it is required that*  DTDspace = MDSTYPEspace = UFNspace = INTERFACEspace   T&larr; INTERFACEspace;   LTEMP0&larr; INTERFACEbase;   memBase&larr; interfaceBR, call[setBR];   LTEMP0&larr; DTDbase;   memBase&larr; dtdBR, call[setBR];   LTEMP0&larr; (LTEMP0) + (lshift[ListType!, 4]c);   memBase&larr; ListpDTDBR, call[setBR];   LTEMP0 &larr; MDSTYPEbase;   memBase&larr; tybaseBR, call[setBR];   LTEMP0 &larr; UFNTablebase;   memBase&larr; ufnBR, call[setBR];   memBase&larr; MDS;   T&larr; and[RamVersion, 177400]c;   T&larr; T + (and[RamVersion, 377]c);   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;   T&larr; and[RamMinBcplVersion, 177400]c;   T&larr; T + (and[RamMinBcplVersion, 377]c);   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;   T&larr; and[RamMinLispVersion, 177400]c;   T&larr; T + (and[RamMinLispVersion, 377]c);   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;* now initialize display width   rbase&larr; rbase[DisplayConfig];   DisplayConfig&larr; (DisplayConfig) OR (2C);   T&larr; Or[177400, MaxWidthWordsLF!]C;   MaxWidthWords&larr; T;   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; MaxWidthWordsLF;   rbase&larr; rbase[RealPages];   T&larr; RealPages;   Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T;	* # pages   T&larr; 2000c;						* "dummy" #pages/module    Stack&larr; (store&larr; Stack) + 1, dbuf&larr; T,	* (doesn't matter)   branch[EmuNext];SUBROUTINE;   KnowRBase[LTEMP0];setBR:   BrHi&larr; T;   BrLo&larr; LTEMP0, return;TOP LEVEL;*--------------------------------------------------------------   TOP LEVEL;   knowrbase[LTEMP0];   InsSet[LispInsSet, 1];opUPCTRACE:	T&larr; (fetch&larr; TSP) + 1;	T&larr; Md, fetch&larr; T; rbase&larr; rbase[Events];	Q&larr; Md, call[SetPCHistAddr];	NextOpCode;regOP1[374, StackM2BR, opUPCTRACE, noNData]; * op 374 reserved on Dolphin*--------------------------------------------------------------* Memory system initialization stubs for lispInitMapWarm:	Branch[ResumeEmulator]; * i.e., don't do anything*-----------------------------------------------------------WaitForMapBuf:	* Wait for map operation to complete* Clobbers nothing*-----------------------------------------------------------Subroutine;	PD&larr; T-T-1;	PD&larr; PRef, Branch[., ALU&lt;0];	* MapBufBusy is sign bit	Return;</pre>
  </body>
</html>
