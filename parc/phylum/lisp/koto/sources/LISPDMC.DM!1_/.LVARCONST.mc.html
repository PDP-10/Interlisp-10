<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [phylum]&lt;LISP>KOTO>Sources>LISPDMC.DM!1>LVARCONST.mc</title>
  </head>
  <body>
    <pre>
:Title[LVARCONST];** Edit History* March 22 11:12AM, Masinter, formatting* March 13, 1985  9:42 AM, Masinter, remove call to SAVEUCODESTATE* January 8, 1985  4:12 AM, JonL, GVAR&larr; and endofstack typos in constants* January 6, 1985  2:50 AM, JonL, emmend GVAR, GVAR&larr; and the global case of*  FVAR lookup to permit 16-bit litatom indices*February 18, 1984  3:14 PM, JonL, labels PUSHSMALLT1 &amp; PUSHTRUE1 for opRWMufMan* January 31, 1984  1:30 AM, JonL, Added subroutine .aconstfetch* January 13, 1984  9:05 PM, JonL, linst and lfv merged into this file*		PUSHTMD and TL.ST0TMD in from LSTACK* December 30, 1983  3:33 PM, JonL, merged two insts in call to GCLOOKUP* December 27, 1983  11:28 AM, JonL, opCOPY to LSTACK* December 6, 1982  1:43 PM, Masinter* Variable opcodes, including free variable lookup*  and Constants opcodes   knowrbase[LTEMP0];   TOP LEVEL;   InsSet[LispInsSet, 1];*--------------------------------------------------------------------* Some common tails for this file*--------------------------------------------------------------------*--------------------------------------------------------------------PUSHTMD: 		* pushes  T,,MD, bumps TSP, and decrements LEFT*--------------------------------------------------------------------PAGEFAULTNOTOK;	branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;     T&larr; Md, TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, branch[TL.PUSHT];*--------------------------------------------------------------------TL.ST0TMD:   T&larr; Md, LTEMP0&larr; (store&larr; LTEMP0) + 1, dbuf&larr; T, branch[TL.ST0];*--------------------------------------------------------------------TL.ST0:   store&larr; LTEMP0, dbuf&larr; T, NextOpCode;*--------------------------------------------------------------------*--------------------------------------------------------------------opIVAR:*--------------------------------------------------------------------   T&larr; (ifetch&larr; IVAR) + 1;   T&larr; Md, ifetch&larr; T, branch[PUSHTMD];regOP1[100, StackBR, opIVAR, 0];		* IVARregOP1[101, StackBR, opIVAR, 2];regOP1[102, StackBR, opIVAR, 4];regOP1[103, StackBR, opIVAR, 6];regOP1[104, StackBR, opIVAR, 10];regOP1[105, StackBR, opIVAR, 12];regOP1[106, StackBR, opIVAR, 14];regOP2[107, StackBR, opIVAR, noNData];	* PVARX*--------------------------------------------------------------------opPVAR:*--------------------------------------------------------------------   T&larr; (ifetch&larr; PVAR) + 1;   T&larr; Md, ifetch&larr; T, branch[PUSHTMD];regOP1[110, StackBR, opPVAR, 0];		* PVARregOP1[111, StackBR, opPVAR, 2];regOP1[112, StackBR, opPVAR, 4];regOP1[113, StackBR, opPVAR, 6];regOP1[114, StackBR, opPVAR, 10];regOP1[115, StackBR, opPVAR, 12];regOP1[116, StackBR, opPVAR, 14];regOP2[117, StackBR, opPVAR, noNData];	* PVARX*--------------------------------------------------------------------opFVAR:*--------------------------------------------------------------------	T&larr; (ifetch&larr; PVAR) + 1;	LTEMP0&larr; Md, ifetch&larr; T;.retryfvar:	branch[.+2, R even], LTEMP0, T&larr; Md, memBase&larr; ScratchLZBR;		T&larr; Id, branch[.FVFAIL];	T&larr; T and (rhmask);						* KLUDGE: LH IS DUPLICATED!!!!	BRHi&larr; T;PAGEFAULTOK;	LTEMP0&larr; (FETCH&larr; LTEMP0) + 1;	T&larr; MD, fetch&larr; LTEMP0, branch[PUSHTMD];	.FVFAIL:		* T = offset of free variable, fill in and continue	LTEMP0&larr; T, call[FVLOOKUP];				* T passed and smashed by FVLOOKUP	T&larr; LTEMP0;	T&larr; T + (PVAR);	T&larr; (fetch&larr; T) + 1;	LTEMP0&larr; Md, fetch&larr; T, branch[.retryfvar];regOP1[120, StackBR, opFVAR, 0];		* FVARregOP1[121, StackBR, opFVAR, 2];regOP1[122, StackBR, opFVAR, 4];regOP1[123, StackBR, opFVAR, 6];regOP1[124, StackBR, opFVAR, 10];regOP1[125, StackBR, opFVAR, 12];regOP1[126, StackBR, opFVAR, 14];regOP2[127, StackBR, opFVAR, noNData];		* FVARX*--------------------------------------------------------------------opGVAR:	* alpha + beta form atom number of global to fetch*--------------------------------------------------------------------	T&larr; Id;								* hi bits	T&larr; LSH[T,10];						* shift left	LTEMP0&larr; ((Id) + T);	branch[.+2, alu&gt;=0], LTEMP0 &larr; (LTEMP0) lsh 1;		flipMemBase; 					* use Val2BR insteadPAGEFAULTOK;	LTEMP0&larr; (FETCH&larr; LTEMP0) + 1;	T&larr; MD, fetch&larr; LTEMP0, branch[PUSHTMD];regOP3[140, ValSpaceBR, opGVAR, noNData];*--------------------------------------------------------------------opSETPVAR:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase;	T&larr; Md, fetch&larr; T;	LTEMP0&larr; (Id) + (PVAR), branch[TL.ST0TMD];regOP1[130, StackM2BR, opSETPVAR, 0];			* PVAR&larr;regOP1[131, StackM2BR, opSETPVAR, 2];regOP1[132, StackM2BR, opSETPVAR, 4];regOP1[133, StackM2BR, opSETPVAR, 6];regOP1[134, StackM2BR, opSETPVAR, 10];regOP1[135, StackM2BR, opSETPVAR, 12];regOP1[136, StackM2BR, opSETPVAR, 14];regOP2[137, StackM2BR, opSETPVAR, noNData];	* PVARX&larr;*--------------------------------------------------------------------opSETPVARPOP:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase;			* fetch TSP-2	T&larr; Md, TSP&larr; (fetch&larr; T) - 1;					* fetch TSP-1, TSP&larr; TSP-2	LTEMP0&larr; (Id) + (PVAR);	LEFT&larr; (LEFT) + 1, BRANCH[TL.ST0TMD];regOP1[270, StackM2BR, opSETPVARPOP, 0];regOP1[271, StackM2BR, opSETPVARPOP, 2];regOP1[272, StackM2BR, opSETPVARPOP, 4];regOP1[273, StackM2BR, opSETPVARPOP, 6];regOP1[274, StackM2BR, opSETPVARPOP, 10];regOP1[275, StackM2BR, opSETPVARPOP, 12];regOP1[276, StackM2BR, opSETPVARPOP, 14];*--------------------------------------------------------------------opSETIVAR:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) - 1, flipMemBase;	T&larr; Md, fetch&larr; T;	LTEMP0&larr; (Id) + (IVAR), branch[TL.ST0TMD];regOP2[142, StackM2BR, opSETIVAR, noNData];	* IVARX&larr;*--------------------------------------------------------------------opFVARgets: *--------------------------------------------------------------------	T&larr; (ifetch&larr; PVAR) + 1;	LTEMP0&larr; Md, ifetch&larr; T;.retrysetfvar:	branch[.+2, R even], LTEMP0, T&larr; Md, memBase&larr; StackM2BR;		T&larr; Id, branch[.setffail];		* Fvar not looked up  yet	T&larr; T and (rhmask);					* KLUDGE	- TOP BYTE IS FILLED IN TOO	pd&larr; T xor (StackHi);	branch[.setfglobal, alu#0], TSP&larr; (fetch&larr; TSP) - 1, flipMemBase;		T&larr; Md, TSP&larr; (fetch&larr; TSP) + 1, branch[TL.ST0TMD];.setfglobal:	TSP&larr; (TSP) + 1, memBase&larr; LScratchBR, Branch[.setglobal];   .setffail:	LTEMP0&larr; T, call[FVLOOKUP];	T&larr; LTEMP0;	T&larr; T + (PVAR);	T&larr; (fetch&larr; T) + 1;	LTEMP0&larr; Md, fetch&larr; T, branch[.retrysetfvar];regOP2[143, StackBR, opFVARgets, noNData];*--------------------------------------------------------------------SUBROUTINE;	SUB.PUSHT:*--------------------------------------------------------------------	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, return;TOP LEVEL;*--------------------------------------------------------------------*   GVAR&larr;	 alpha + beta form atom number of global to store TOS*--------------------------------------------------------------------:if[Reduced];	UfnOps[27];:else;opGVARgets:	LTEMP0&larr; Id, memBase&larr; LScratchBR;	LTEMP0&larr; LSH[LTEMP0, 10];	LTEMP0&larr; ((Id) + (LTEMP0));	branch[.+2, alu&gt;=0], LTEMP0 &larr; (LTEMP0) lsh 1;		T&larr; (add[VALspace!,1]c), branch[.setglobal]; 	* use Val2BR instead	T&larr; VALspace, branch[.setglobal];.setglobal:	BrLo&larr; LTEMP0;	BrHi&larr; T, LTEMP4&larr; A0;PAGEFAULTOK;	Case&larr; T&larr; (FETCH&larr; 0s) + 1, Call[GCLOOKUP];		* deleteref old pointer	memBase&larr; StackM2BR, Branch[RPLPTRTAIL];		* addref for new pointerregOP3[27, ifuBR, opGVARgets, noNData];:endif;*--------------------------------------------------------------------opNIL:*--------------------------------------------------------------------	Branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (AtomHiVal), Branch[TL.PUSHNIL];TL.PUSHNIL:	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (AT.NIL), NextOpCode;regOP1[150, StackBR, opNIL, noNData];*--------------------------------------------------------------------opKT:*--------------------------------------------------------------------	branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;PUSHTRUE1:	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (AtomHiVal), branch[TL.PUSHTRUE];TL.PUSHTRUE:	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; AT.T, NextOpCode;regOP1[151, StackBR, opKT, noNData];*--------------------------------------------------------------------op01SIC:*--------------------------------------------------------------------	branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, TisID, NextOpCode;regOP1[152, StackBR, op01SIC, 0];		* '0regOP1[153, StackBR, op01SIC, 1];		* '1regOP2[154, StackBR, op01SIC, noNData];	* SIC*--------------------------------------------------------------------opSNIC:*--------------------------------------------------------------------	T&larr; (Id) - (400c);	branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallNegHi, branch[TL.PUSHT];regOP2[155, StackBR, opSNIC, noNData];		* SNIC*--------------------------------------------------------------------opSICX:*--------------------------------------------------------------------	T&larr; Id, Call[.aconstfetch];PUSHSMALLT:	branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;PUSHSMALLT1:	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[TL.PUSHT];TL.PUSHT:	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; T, NextOpCode;regOP3[156, StackBR, opSICX, noNData];		* SICXregOP3[160, StackBR, opSICX, noNData];		* ATOMNUMBER*--------------------------------------------------------------------opACONST: *--------------------------------------------------------------------	T&larr; Id, Call[.aconstfetch];	branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;	TSP&larr; (store&larr; TSP) + 1, dbuf&larr; (AtomHiVal), branch[TL.PUSHT];SUBROUTINE;.aconstfetch:	T&larr; LSH[T,10];	T&larr; (Id) + (T), Return;TOPLEVEL;regOP3[147, StackBR, opACONST, noNData];*--------------------------------------------------------------------opGCONST:*--------------------------------------------------------------------* push 24 bit inline constant* coded as a one byte jump opcode which jumps to .+4	LTEMP0&larr; not (PCX');							* current pc	LTEMP0&larr; (LTEMP0) + 1;						* byte# of hi byte	T&larr; (LTEMP0) rsh 1;							* word# of hi bytePAGEFAULTOK;	T&larr; (FETCH&larr; T) + 1;							* fetch it &amp; next word	branch[.+2, R even], LTEMP0, T&larr; MD, FETCH&larr; T;		T&larr; T and (rhmask), branch[PUSHTMD];	LTEMP0&larr; MD;				* rh T,,lh Md has low word, lh T has hi word.PAGEFAULTNOTOK;	LTEMP0&larr; rcy[T, LTEMP0, 10];	T&larr; rsh[T, 10];PUSHT0:				* pushes  T,,LTEMP0, bumps TSP, and decrements LEFT	branch[.+2, R&gt;=0], LEFT&larr; (LEFT) - 1, memBase&larr; StackBR;		StackCheck;PAGEFAULTNOTOK;	T&larr; (store&larr; TSP) + 1, dbuf&larr; T;	TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP0, NextOpCode;IFUjmp[157, 1, ifuBR, 0, opGCONST, 4];:if[Reduced];	UfnOps[57];:else;*--------------------------------------------------------------------opSTKSCAN:*--------------------------------------------------------------------	T&larr; (fetch&larr; TSP) + 1;	FVNAME&larr; Md, fetch&larr; T, T&larr; (FX.PVAR);	FVNAME&larr; Md, pd&larr; FVNAME;	branch[.+2, alu=0], pd&larr; FVNAME;		CallUFN;									* not LITATOM	branch[.+2, alu#0];		CallUFN;									* NIL	nop;											* placement constraints	FVEP&larr; (PVAR) - T, call[DOLOOKUP];	memBase&larr; StackM2BR, T&larr; TSP;	T&larr; (store&larr; T) + 1, dbuf&larr; FVHI;	store&larr; T, dbuf&larr; FVLO, NextOpCode;REGOP1[57, StackM2BR, opSTKSCAN, noNData];:endif;*--------------------------------------------------------------------SUBROUTINE;  FVLOOKUP:*--------------------------------------------------------------------* look up free variable # T/2 in current frame* fill in location where value is bound* preserve LTEMP0   memBase&larr; ifuBR;	PAGEFAULTOK;   FETCH&larr; add[FNH.NLFV!]s;   FVNAME&larr; T rsh 1;		* free variable index   FVCHAIN&larr; (PVAR) + T + 1;	* where to fill in the indirection   FVTMP&larr; MD;			* nlocals, fvoffset	PAGEFAULTNOTOK;   T&larr; rsh[FVTMP, 10];		* T&larr; NLOCALS   FVTMP&larr; (FVTMP) and (rhmask);   T&larr; (FVTMP) - T;   T&larr; T + (FVNAME);   fetch&larr; T;   FVNAME&larr; Md, T&larr; (FX.PVAR);   FVEP&larr; (PVAR) - T;   memBase&larr; StackBR;   store&larr; FVCHAIN, dbuf&larr; 0c, branch[.newframe];*--------------------------------------------------------------------DOLOOKUP:*--------------------------------------------------------------------* Scan for free variable FVNAME starting at FVEP, return* in FVHI,FVLO the pointer to where it is bound* if FVCHAIN is odd, store indirection pointer at stackspace* should check for reschedule!!!   FVCHAIN&larr; A0;.newframe:   T&larr; (FVEP) + 1, memBase&larr; StackBR;   fetch&larr; T;   FVEP&larr; Md;   FVEP&larr; (FVEP) and not (1c);   FVEP&larr; (FVEP) - (FX.PVAR);   branch[.endofstack, alu=0], fetch&larr; FVEP;   FVTMP&larr; Md;   pd&larr; (FVTMP) and (FXNTValid);   T&larr; (FVEP) + (FX.DEFLO), branch[.+2, alu=0];	T&larr; (FVEP) + (FX.NTLO);   T&larr; (fetch&larr; T) + 1;   FVTMP&larr; Md, fetch&larr; T, T&larr; (rhmask);   T&larr; T and (Md), memBase&larr; LScratchBR;   BrHi&larr; T;   BrLo&larr; FVTMP;   FVINDEX&larr; FNH.FIRSTNAME;.lookforvar:	PAGEFAULTOK;   FETCH&larr; add[FNH.NTSIZE!]s;	* can fault   FVTMP&larr; Cnt&larr; MD;	* FVTMP = NTSIZE	PAGEFAULTNOTOK;.fvloop:	* this can really be done in a 2 inst loop   branch[.newframe, Cnt=0&amp;-1];   FVINDEX&larr; (fetch&larr; FVINDEX) + 1;   T&larr; Md;   pd&larr; (FVNAME) xor T;   branch[.fvloop, alu#0];% this is what a 2 instruction loop would look like   T&larr; A0;					* # FVNAME   branch[.+2, Cnt#0], pd&larr; T-T-1;	* pd #0		branch[.newframe];   FVINDEX&larr; (fetch&larr; FVINDEX) + 1, branch[.fvfound, alu=0];   T&larr; Md, pd&larr; (FVNAME) xor T, dblbranch[.notfound, .-1, Cnt=0&amp;-1].fvfound:   FVINDEX&larr; (FVINDEX) - (2c);%.fvfound:				* found a match   T&larr; (FVTMP) - 1;      T&larr; T + (FVINDEX);		* add NTSIZE, note FVINDEX already incremented   fetch&larr; T;   FVHI&larr; Md, T&larr; (rhmask);   T&larr; (T and (FVHI)) lsh 1, branch[.fvpfvar, R&lt;0];.fvivar:   FVEP&larr; (FVEP) - 1, memBase&larr; StackBR;   FVEP&larr; (fetch&larr; FVEP) + 1;   FVLO&larr; T + Md;   FVHI&larr; StackHi, branch[.donefvlookup];.fvpfvar:   T&larr; T + (FVEP), memBase&larr; StackBR;   T&larr; T + (FX.PVAR);				* T is stack relative location   T&larr; (fetch&larr; T) + 1;   FVLO&larr; Md, fetch&larr; T;   FVHI&larr; Md, pd&larr; (FVHI) and (40000c);	* check FVAR bit	FVHI&larr; (FVHI) and (rhmask), branch[.fvfvar, alu#0];.fvpvar:   branch[.+2, R&gt;=0], FVLO, FVLO&larr; T - 1, memBase&larr; LScratchBR;		branch[.fvloop];						* unbound PVAR   FVHI&larr; StackHi, branch[.donefvlookup];.fvfvar:   branch[.+2, R odd], FVLO;		branch[.donefvlookup];* should create chain here	branch[.newframe];.endofstack:   FVLO&larr; (FVNAME) + (FVNAME);   FVHI&larr; ValSpace, branch[.+2, carry'];		FVHI&larr; (FVHI) xor (1c);		* a bit like flipMembase.donefvlookup:   branch[.+2, R odd], FVCHAIN, memBase&larr; StackBR;		return;* kludge!!!	* STORE FVHI in both halves   T&larr; LSH[FVHI, 10];   T&larr; T + (FVHI);   T&larr; (store&larr; FVCHAIN) - 1, dbuf&larr; T;   store&larr; T, dbuf&larr; FVLO, return;TOPLEVEL;</pre>
  </body>
</html>
