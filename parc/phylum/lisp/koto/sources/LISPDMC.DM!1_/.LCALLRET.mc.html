<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[phylum]&lt;LISP>KOTO>Sources>LISPDMC.DM!1>LCALLRET.mc</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt monospace">:Title[LCALLRET];<br>*<br>* Edit History<br>* March 13, 1985  9:45 AM, Masinter, remove calls to SAVEUCODESTATE<br>* January 6, 1985  12:18 AM, JonL, let .ATOMICFN flipMembase when<br>*     litatom index number has the 2&uarr;15 bit on<br>* February 9, 1984  1:07 AM, JonL, fixed screwup in label ufnPC:<br>* February 2, 1984  11:04 AM, JonL, fixes to callers of SAVEUCODESTATE<br>* January 31, 1984  5:02 PM, temporarily add call to SAVEUCODESTATE<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">to opUFN, ufnPC, and callers of DOCALLPUNT<br>* January 24-27, 1984, JonL, Globalize DOCALLPUNT<br>* January 13, 1984  8:07 PM, JonL, call and return code into one file<br>* January 4, 1984  7:26 PM, JonL, moved in some subroutines from<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LSTACK.mc -- ADDSTK from LSTACK; ufnPC resets Hardware stack<br>* December 31, 1983  12:51 PM, JonL, set memBase at ufnPC so code can<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch directly to it; added some commentary<br>* November 29, 1983  2:42 PM, JonL, removed spurious BrLo&larr; DEFLO.<br>* December 7, 1982  4:38 PM, Masinter - - - <br><br><br>*--------------------------------------------------------------------<br>* Function call<br>*--------------------------------------------------------------------<br><br>KnowRBase[LTemp0];<br>TOPLEVEL;<br>InsSet[LispInsSet, 1];<br><br><br>*--------------------------------------------------------------------<br>opFN:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* FN0-4 operators<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; Id;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Id;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[T,10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; (Id) + T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* 16 bit atom index<br>*--------------------------------------------------------------------<br>.FNCALL1:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Entry for DOCALLPUNT<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Id - (PCX&rsquo;) - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Return PC, for a n-byte op<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CHECKPCX;<br>*--------------------------------------------------------------------<br>.FNCALL2:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Entry for FNx and opUFN<br>*--------------------------------------------------------------------<br>   T&larr; (PVAR) - (FXBACK[PC]);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Suspend the current frame<br>   store&larr; T, dbuf&larr; LTEMP0, Branch[.ATOMICFN];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  by saving the PC<br><br><br>.atfXtnd:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR, Call[ADDSTK];<br>*--------------------------------------------------------------------<br>.ATOMICFN:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Build a frame and start running the function whose <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">index is DEFLO; NARGS args are on stack already.<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (DEFLO) + (DEFLO), memBase&larr; DefBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; word index of defcell<br>   PSTATE&larr; T-T-1, branch[.+2, carry&rsquo;];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">flipMemBase;<br>* CAN FAULT!!!<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (FETCH&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Fetch contents of defcell<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; MD, fetch&larr; T, T&larr; (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP0&larr; hi def<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&lt;0], LTEMP0&larr; T and (LTEMP0),</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* SignBit of defcell is <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, memBase&larr; ifuBR; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  flag for compiled code<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFHI&larr; (atomHiVal), Branch[.notCCODE];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">BrHi&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; BrLo&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP1&larr; fnLo<br>* CAN FAULT!!!<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FETCH&larr; 0s;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Fetch first word of<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LSH[LTEMP0, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  function header<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (LTEMP0) + T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Recompute fnheader<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; MD, fetch&larr; 1s;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (ESP) - T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T - (TSP);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* ESP - #WORDS - TSP<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, carry], LTEMP2&larr; Md,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP2&larr; def.na <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; 2s) + 1;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFHI&larr; (atomHiVal), Branch[.atfXtnd];<br>:if[FNStats];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.nofnstat, R&lt;0], LTEMP3&larr; Md,<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FnStatsPtr, fetch&larr; T; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP3&larr; def.pv<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PCF&larr; Md, PSTATE&larr; A0; call[FNSTAT];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.afterfnstat];<br>:else;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP3&larr; def.pv<br>:endif;<br>.nofnstat:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">PCF&larr; Md, PSTATE&larr; A0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* start IFU early<br>.afterfnstat:<br>* No faults after here<br><br>* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *<br>*    KLUDGE FOR FINDING OUT WHO IS CALLED: SMASH DEF WITH BIT     *<br>*    FETCH&larr; (4S); IVAR&larr; MD;                                       *<br>*    BRANCH[.+2, R&lt;0], IVAR&larr; IVAR OR (100000C);                   *<br>*    STORE&larr; (4S), DBUF&larr; IVAR;                                     *<br>* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (NARGS) + (NARGS), memBase&larr; StackBR;<br>PCXBAD;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">IVAR&larr; (TSP) - T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[NEXT]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; IVAR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* store FX.next<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.NoAdj, R&lt;0], T&larr; LTEMP2;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (NARGS) - T;<br><br>.tryagain:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.NoAdj&rsquo;, alu=0], pd&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.TooMany, alu&gt;0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T+1, branch[.tryagain];<br><br>.TooMany:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (TSP) - (2c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T-1, branch[.tryagain];<br><br>.NoAdj&rsquo;:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.+2], pd&larr; (TSP) and (2c);<br>.NoAdj:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (TSP) and (2c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.QuadP,  alu=0], T&larr; (store&larr; TSP) + 1, dbuf&larr; BFBlock;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; 0c;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Smash in a cell of 0&rsquo;s if not<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; 0c;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  quadword aligned; new BF wd<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; (add[BFBlock!, BFPadded!]c);<br>.QuadP:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; IVAR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* new IVAR<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; FxtnBlock;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* default flags<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; PVAR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* old PVAR<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fn address hi<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; LTEMP0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fn address lo<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; PVAR&larr; T + (FXDIF[PVAR, DEFHI]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">dblbranch[.StorePVS, .endfn, R&gt;=0], Cnt&larr; LTEMP3;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">  .StorePVS:<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* "Pvars", in multiples<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">*  of 2 cells<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; AllOnes, <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">dblbranch[.StorePVS, .endfn, Cnt#0&-1];<br>.endfn:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; TSP&larr; T + (4c);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; ((ESP) - T) rsh 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; T - (LeftOffset), NextOpCode;<br><br>.notCCODE:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (TSP), memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; T) + 1, dbuf&larr; DEFHI;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; T) + 1, dbuf&larr; DEFLO;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; (NARGS) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; AT.INTERPRETER, branch[.ATOMICFN];<br><br><br><br>*--------------------------------------------------------------------<br>SUBROUTINE;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">ADDSTK:</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> * add space to stack frame for FNCALL etc<br>*--------------------------------------------------------------------<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; ESP) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* next stack word<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T xor (FreeStackBlock);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TOP LEVEL;</span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[STKOVPUNT];</span><span class="tab" val="24"></span><span style="font: 10pt monospace"> TOPLEVEL;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ESP&larr; (ESP) + (Md);<br>.mergefree:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; ESP) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T xor (FreeStackBlock);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], T&larr; ESP;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LEFT&larr; T - (TSP), Branch[FIXLEFT1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ESP&larr; (ESP) + (Md), branch[.mergefree];<br><br>TOPLEVEL;<br><br></span><span style="font: 10pt monospace"> <br>IFUpause[10, 3, StackBR, 0, opFN, 0, 0, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*FN0<br>IFUpause[11, 3, StackBR, 0, opFN, 1, 0, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*FN1<br>IFUpause[12, 3, StackBR, 0, opFN, 2, 0, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*FN2<br>IFUpause[13, 3, StackBR, 0, opFN, 3, 0, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*FN3<br>IFUpause[14, 3, StackBR, 0, opFN, 4, 0, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*FN4<br><br>*--------------------------------------------------------------------<br>opFNX:<br>*--------------------------------------------------------------------<br>* Takes 3 argument bytes; first is NARGS, 2nd and 3rd are fn #.<br>* since IFU won&rsquo;t handle 4 byte instructions, the first arg is<br>* gotten from the IFU, and the fn is fetched directly. Things are<br>* much simpler if the opcode happens to be word aligned. <br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; Id;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; T&larr; (Id)-(PCX&rsquo;)-1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Id is length- get byte# of 3rd byte<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; T rsh 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* word which contains hi byte of fn<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (FETCH&larr; LTEMP0) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R odd], DEFLO&larr; MD, <br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T + (2c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T has new PC<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; T, memBase&larr; StackBR, branch[.FNCALL2];<br>FNXsplit:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; T, FETCH&larr; LTEMP0;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* save PC, fetch lo byte<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR, T&larr; MD;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T has lo byte of fn in hi byte<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; Rcy[DEFLO, T, 10], branch[.FNCALL2];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* and fix up<br><br>IFUpause[15, 2, ifuBR, 0, opFNX, noNData, 0, 0];<br><br>*--------------------------------------------------------------------<br>opAPPLYFN:<br>*--------------------------------------------------------------------<br>* TOS = FN TO CALL, TOS-1 = NARGS, TOS-... = arguments to FN<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch defhi<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFHI&larr; Md, T&larr; (fetch&larr; T) - (3c);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch deflo<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; Md, T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch narghi<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; T, flipMemBase;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; Md, pd&larr; T xor (SmallHi);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], TSP&larr; (TSP) - (4c);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UCodeCheck[BadRetCall];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Id - (PCX&rsquo;) - 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Save return PC<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[PC]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; T, dbuf&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (DEFHI) xor (AtomHiVal);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Check for atomic fn<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.notCCODE];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.ATOMICFN];<br><br>IFUpause[16, 1, StackM2BR, 0, opAPPLYFN, NoNData, 0, 0];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*APPLYFN<br><br>:if[NotReduced];<br><br>*--------------------------------------------------------------------<br>opCKAPPLY:<br>*--------------------------------------------------------------------<br>* TOS = FN TO CALL<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; TSP) + 1;</span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; Md, fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* hiloc<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, memBase&larr; DefBR, pd&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], T&larr; T + T;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* not litatom<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">FETCH&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; MD;<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R&lt;0], pd&larr; (LTEMP0) and (20000c);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* not CCODEP<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CallUFN;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* not argtype=0, 2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NextOpCode;<br><br>regOP1[17, StackM2BR, opCKAPPLY, NoNData];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">*CKAPPLY<br><br>:else;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UfnOps[17];<br>:endif;<br><br><br><br>*--------------------------------------------------------------------<br>opUFN:<br>*--------------------------------------------------------------------<br>* All "undefined" entries in the IFU memory come here, with <br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">a call is manufactured to the function fetched <br>*  from the UFN table, according to byte at PC. <br>* Format of table:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">defindex[0:15]</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">left word;<br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">nargs[8:15]</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">right word<br><br>.ufn0:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; ifuBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; LTEMP1&larr; not(PCX&rsquo;);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T&larr; current PC (byte offset)<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; T rsh 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP0&larr; current PC word address<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">CHECKPCX;<br>PAGEFAULTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (fetch&larr; LTEMP0) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* fetch word containing current op<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md, fetch&larr; LTEMP0;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">Branch[.ufnPCR, R odd], LTEMP1, LTEMP1&larr; Md;<br>.ufnPCL:<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; RCY[T, LTEMP1, 10];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; RSH[T, 10], branch[.ufnPC2];<br>.ufnPCR:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (T) and (rhmask);<br>.ufnPC2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; ufnBR, T&larr; T + T;<br>PAGEFAULTNOTOK;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">DEFLO&larr; Md, fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; Md, memBase&larr; StackBR;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; RSH[NARGS, 10];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; BDispatch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">NARGS&larr; (NARGS) and (rhmask), branch[.ufns];<br>.ufns:   DISPTABLE[3],<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.ufnPC3];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[.ufnpsh1];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (store&larr; TSP) + 1, dbuf&larr; SmallHi, branch[.ufnpsh2];<br><br>.ufnpsh1:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP1&larr; RSH[LTEMP1, 10];</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Only an "alpha" byte<br>.ufnpsh2:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Push the opcode databytes<br>.ufnPC3:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP0&larr; (LTEMP0) - (PCX&rsquo;), call[FIXLEFT];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">memBase&larr; StackBR, branch[.FNCALL2];<br><br>*--------------------------------------------------------------------<br>*  ufnPC:   GLOBAL,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"><br>*--------------------------------------------------------------------<br>* CallUFN macro just turns into "SaveLink&larr; Link, Call[ufnPC]"<br>ufnPC:   GLOBAL,<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; A0, RBase&larr; RBase[LTEMP0];<br><br>*</span><span class="tab" val="24"></span><span style="font: 10pt monospace">May come here from totally random places, so do a little cleanup<br>:if[StackEmpty!];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; StackEmpty;<br>* otherwise, T&larr; A0 handled it<br>:endif;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">StkP&larr; T, Branch[opUFN]; </span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Resets the hardware stack<br><br>*--------------------------------------------------------------------<br>DOCALLPUNT:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">GLOBAL,</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* Called from unbox, etc. <br>*--------------------------------------------------------------------<br>* Enter with DEFLO the atom index of fnname to call <br>*</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace"> NARGS has number of arguments to pass<br>* Flush out Id, recompute up LEFT<br>   T&larr; Id, call[FIXLEFT];<br>   T&larr; Id, memBase&larr; StackBR, branch[.FNCALL1];<br><br><br><br>*--------------------------------------------------------------------<br>* RETURN<br>*--------------------------------------------------------------------<br><br>   KnowRBase[LTEMP0];<br>   top level;<br>   InsSet[LispInsSet, 1];<br><br>opRETURN:<br>   T&larr; (fetch&larr; TSP) - 1, FlipMemBase;<br>   LTEMP0&larr; Md, fetch&larr; T, T&larr; (FXBACK[ALINK]);<br>   LTEMP1&larr; Md, T&larr; (PVAR) - T;<br>   fetch&larr; T, LTEMP3&larr; (rhmask);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* get alink field<br>   LTEMP2&larr; Md;<br>   branch[.nquick, R odd], LTEMP2, T&larr; (LTEMP2) - (FXBACK[IVAR]);<br>   T&larr; (fetch&larr; T) + (FXDIF[DEFLO, IVAR]);<br>   Q&larr; IVAR, IVAR&larr; Md, T&larr; (fetch&larr; T) + 1;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* new IVAR<br>   DEFLO&larr; Md, T&larr; (fetch&larr; T) + (FXDIF[PC, DEFHI]);<br>   T&larr; Md, PVAR&larr; (fetch&larr; T) + (FXDIF[PVAR, PC]);<br>   T&larr; T and (LTEMP3), memBase&larr; ifuBR;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* new PVAR<br>   BrLo&larr; DEFLO;<br><br>:if[FNStats];<br>   BrHi&larr; T, branch[.retstat, R&gt;=0], FnStatsPtr;<br>:else;<br>   BrHi&larr; T;<br>:endif;<br><br>   T&larr; ESP, PCF&larr; Md;<br>.finishret:<br>   LEFT&larr; T - Q, memBase&larr; StackBR;<br>   T&larr; (store&larr; Q) + 1, dbuf&larr; LTEMP0;<br>   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;<br>   LEFT&larr; (LEFT) rsh 1;<br>   LEFT&larr; (LEFT) - (add[LeftOffset!, 1]c), NextOpCode;<br><br>:if[FNStats];<br>.retstat:<br>   DEFHI&larr; T; PCF&larr; Md, call[.storeretstat];</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* finish this operation<br>   T&larr; ESP, branch[.finishret];<br>:endif;<br><br>IFUpause[20,1,StackM2BR,0,opReturn,noNData, 0, 0];<br><br><br><br>*--------------------------------------------------------------------<br>* NQUICK cases of return<br>*--------------------------------------------------------------------<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">m[HardReturn, CallUFN];<br><br>.nquick:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[ALINK]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + (FXDIF[CLINK, ALINK]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP2&larr; Md, T&larr; (fetch&larr; T) + (FXDIF[BLINK, CLINK]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (LTEMP2) - (Md) - 1, branch[.+2, R odd];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UCodeCheck[BadFrame];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], LTEMP2&larr; (LTEMP2) - 1;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">HardReturn;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* alink#clink<br><br>* LTEMP2 is returnee<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP2) - (FXBACK[FLAGS]);   <br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* flagword<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; Md;<br><br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; T and (StackMask);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (LTEMP3) xor (FxtnBlock);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[BadFrame];<br>:endif;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T and (rhmask);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0], T&larr; (LTEMP2) - (FXBACK[NEXT]);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">HardReturn;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* usecnt of returnee # 0<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T, T&larr; FreeStackBlock;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; fetch&larr; Md;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* LTEMP3 points to returnee&rsquo;s next<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T xor (Md);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* T &larr; flags<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu#0], T&larr; IVAR;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[DORETURN];<br><br>* check for contiguous BF<br><br>   pd&larr; T xor (LTEMP3);</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* is IVAR=returnee&rsquo;s next?<br>   branch[.+2, alu=0], T&larr; (PVAR) - (FXBACK[BLINK]);<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">HardReturn;<br>   fetch&larr; T;<br>   T&larr; Md;<br>   fetch&larr; T;<br>   T&larr; Md;<br>   pd&larr; T and (rhmask);<br>   DblBranch[DORETURN, DOHARDRETURN, alu=0];<br><br>DOHARDRETURN:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">HardReturn;<br><br>DORETURN:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* do return to LTEMP2<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[BFLAGS]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T, T&larr; add[BfResidual!, rhmask!]c;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; T and Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.freefx, alu=0], T&larr; IVAR;<br><br>:if[Debugging];<br>.checkfreebf:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[ALINK]);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, R odd], LTEMP3;<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">UCodeCheck[ShouldBeSlowFrame];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[BLINK]);<br>:else;<br>.checkfreebf:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[BLINK]);<br>:endif;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">fetch&larr; T, T&larr; (rhmask);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP3&larr; fetch&larr; Md;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* get bf flags<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">LTEMP4&larr; Md, pd&larr; T and Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.nqnz, alu#0], T&larr; (LTEMP3) + (2c);<br><br>:if[Debugging];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP3) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (fetch&larr; T) + 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">pd&larr; (IVAR) - (Md);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[IVARWRONG];<br>:endif;<br><br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; T - (IVAR);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">IVAR&larr; (store&larr; IVAR) + 1, dbuf&larr; FreeStackBlock;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; IVAR, dbuf&larr; T, branch[.clresid];<br><br>.nqnz:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* leave BF alone, decrement use count<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (LTEMP4) - 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">store&larr; LTEMP3, dbuf&larr; T;<br>.clresid:<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">T&larr; (PVAR) - (FXBACK[BFLAGS]);<br><br>:if[Debugging];<br>   fetch&larr; T;<br>   LTEMP3&larr; Md;<br>   pd&larr;(LTEMP3) and (BFResidual);<br>   branch[.+2, alu#0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[StackBad];<br>   nop;<br>:endif;<br><br>.freefx:</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* make from T to ESP into a free block<br>   ESP&larr; (ESP) - T;<br>   T&larr; (store&larr; T) + 1, dbuf&larr; FreeStackBlock;<br>   store&larr; T, dbuf&larr; ESP;<br><br>   PVAR&larr; LTEMP2;<br><br>*--------------------------------------------------------------------<br>RTN2:</span><span class="tab" val="24"></span><span style="font: 10pt monospace">* return to frame at PVAR with LTEMP0,,LTEMP1<br>*--------------------------------------------------------------------<br><br>   memBase&larr; StackBR;<br>:if[Debugging];<br>   T&larr; (PVAR) - (FXBACK[FLAGS]);<br>   fetch&larr; T;<br>   T&larr; Md;<br>   T&larr; T and (StackMask);<br>   pd&larr; T xor (FxtnBlock);<br>   branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[BadFrame];<br>:endif;<br><br>   T&larr; (PVAR) - (FXBACK[IVAR]);<br>   T&larr; (fetch&larr; T) + (FXDIF[NEXT,IVAR]);<br>   IVAR&larr; Md, fetch&larr; T;<br>   ESP&larr; Md;<br>   TSP&larr; Md, fetch&larr; Md;<br><br>.extend:<br>   ESP&larr; (fetch&larr; ESP) + 1;<br>   T&larr; Md;<br>   pd&larr; T xor (FreeStackBlock);<br>   branch[.+2, alu#0], T&larr; ESP&larr; (fetch&larr; ESP) - 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">ESP&larr; (ESP) + (Md), branch[.extend];<br><br>   T&larr; (T - (TSP)) rsh 1;<br>   branch[.+2, carry], LEFT&larr; T - (LeftOffset);<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[noStackAtPunt];<br><br>   T&larr; (PVAR) - (FXBACK[FLAGS]);<br>   fetch&larr; T;<br>   LTEMP2&larr; Md;<br>   pd&larr; (LTEMP2) and (FXInCall);<br>   branch[.retcall, alu#0], pd&larr; (LTEMP2) and (FXNoPushReturn);<br>   branch[.nopush, alu#0], Q&larr; TSP;<br>   T&larr; (store&larr; Q) + 1, dbuf&larr; LTEMP0;<br>   TSP&larr; (store&larr; T) + 1, dbuf&larr; LTEMP1;<br>   branch[.retfe2, R&gt;=0], Left&larr; (Left) - 1;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[NoStackAtPunt];<br><br><br>.nopush:<br>   LTEMP2&larr; (LTEMP2) and not (FXNoPushReturn);<br>   store&larr; T, dbuf&larr; LTEMP2;</span><span class="tab" val="24"></span><span class="tab" val="24"></span><span class="tab" val="24"></span><span style="font: 10pt monospace">* turn off no pushbit<br>   <br>.retfe2:<br>   T&larr; (PVAR) - (FXBACK[IVAR]);<br>   T&larr; (fetch&larr; T) + (FXDIF[DEFLO, IVAR]);<br>   IVAR&larr; Md, T&larr; (fetch&larr; T) + 1;<br>   DEFLO&larr; Md, T&larr; (fetch&larr; T) + (FXDIF[PC, DEFHI]);<br>   DEFHI&larr; Md, fetch&larr; T, T&larr; (rhmask);<br>   DEFHI&larr; (DEFHI) and T, memBase&larr; ifuBR;<br>   BrHi&larr; DEFHI;<br>   BrLo&larr; DEFLO;<br>   PCF&larr; Md;<br><br>:if[FNStats];<br>   branch[.+2, R&lt;0], FnStatsPtr;<br>   call[.storeretstat];<br>   NextOpCode;<br><br>:else;<br>   nop;<br>   NextOpCode;<br>:endif;<br><br>.retcall:<br>   LTEMP2&larr; (LTEMP2) and not (FXInCall);<br>   store&larr; T, dbuf&larr; LTEMP2;<br>   T&larr; (TSP) - 1;<br>   T&larr; (fetch&larr; T) - 1;<br>   DEFLO&larr; Md, T&larr; (fetch&larr; T) - 1;<br>   DEFHI&larr; Md, T&larr; (fetch&larr; T) - 1;<br>   NARGS&larr; Md; fetch&larr; T;<br>:if[Debugging];<br>   pd&larr; DEFHI;<br>   branch[.+2, alu=0], LTEMP0&larr; Md;<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[BadRetCall];<br>   pd&larr; (LTEMP0) xor (SmallHi);<br>   branch[.+2, alu=0];<br></span><span class="tab" val="24"></span><span style="font: 10pt monospace">uCodeCheck[BadRetCall];<br>:endif;<br>   TSP&larr; T, branch[.ATOMICFN];<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
