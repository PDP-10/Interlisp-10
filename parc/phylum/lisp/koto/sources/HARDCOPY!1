(FILECREATED "10-Nov-85 15:54:14" {ERIS}<LISPCORE>KOTO>HARDCOPY.;3 105892       changes to:  (FNS PRINTFILETYPE)      previous date: " 7-Nov-85 21:23:22" {ERIS}<LISPCORE>KOTO>HARDCOPY.;2)(* Copyright (c) 1984, 1985 by Xerox Corporation. All rights reserved.)(PRETTYCOMPRINT HARDCOPYCOMS)(RPAQQ HARDCOPYCOMS [(COMS (* exported functionality)			     (FNS HARDCOPY.SOMEHOW HARDCOPYIMAGEW HARDCOPYIMAGEW.TOFILE 				  HARDCOPYIMAGEW.TOPRINTER HARDCOPYREGION.TOFILE 				  HARDCOPYREGION.TOPRINTER \STRINGWIDTH.HCPYDISPLAYAUX)			     (* user interface jazz)			     (INITVARS (ChangeDefaultPrinter))			     (FNS MakeMenuOfPrinters MakeMenuOfImageTypes GetNewPrinterFromUser 				  PopUpWindowAndGetAtom NewPrinter GetPrinterName GetImageFile 				  FetchDefaultPrinter)			     (* filename diddlers)			     (FNS ExtensionForPrintFileType PRINTFILETYPE.FROM.EXTENSION))	(COMS (* Interface for PRINTERS and IMAGEFILES)	      (FNS DEFAULTPRINTER CAN.PRINT.DIRECTLY CONVERT.FILE.TO.TYPE.FOR.PRINTER EMPRESS 		   HARDCOPYW LISTFILES1 PRINTER.BITMAPFILE PRINTER.BITMAPSCALE PRINTER.SCRATCH.FILE 		   PRINTERPROP PRINTERSTATUS PRINTERTYPE PRINTFILEPROP PRINTFILETYPE 		   SEND.FILE.TO.PRINTER)	      (FNS PRINTERDEVICE)	      [DECLARE: DONTEVAL@LOAD DOCOPY (P (PRINTERDEVICE (QUOTE LPT]	      (P (* for backward compatibility)		 (MOVD? (QUOTE NILL)			(QUOTE PRINTERMODE)))	      (INITVARS (DEFAULTPRINTINGHOST)			(DEFAULTPRINTERTYPE (QUOTE PRESS))			(EMPRESS.SCRATCH (QUOTE (30 {DSK}EMPRESS.SCRATCH)))			(EMPRESS#SIDES T))	      (GLOBALVARS DEFAULTPRINTINGHOST DEFAULTPRINTERTYPE EMPRESS.SCRATCH EMPRESS#SIDES 			  PRINTERTYPES PRINTFILETYPES))	(COMS (* Converting text files to imagestreams)	      (INITVARS (TEXTDEFAULTTABS (LIST 20320))			(TEXTDEFAULTPAGEREGION (CREATEREGION 2794 1905 18415 24765)))	      (* TEXTDEFAULTTABS Hack, mica equivalent of 8 inches)	      (GLOBALVARS TEXTDEFAULTTABS TEXTDEFAULTPAGEREGION)	      (FNS TEXTTOIMAGEFILE COPY.TEXT.TO.IMAGE))	(COMS (FNS \BLTSHADE.GENERICPRINTER)	      (* hack for printers that can't really BLTSHADE))	[COMS (* stuff to support hardcopy streams on the display.)	      (FNS MAKEHARDCOPYSTREAM UNMAKEHARDCOPYSTREAM HARDCOPYSTREAMTYPE \CHARWIDTH.HDCPYDISPLAY 		   \DSPFONT.HDCPYDISPLAY \DSPRIGHTMARGIN.HDCPYDISPLAY \DSPXPOSITION.HDCPYDISPLAY 		   \DSPYPOSITION.HDCPYDISPLAY \STRINGWIDTH.HDCPYDISPLAY \HDCPYBLTCHAR 		   \HDCPYDISPLAY.FIX.XPOS \HDCPYDISPLAY.FIX.YPOS \HDCPYDISPLAYINIT \HDCPYDSPPRINTCHAR 		   \SLOWHDCPYBLTCHAR \CHANGECHARSET.HDCPYDISPLAY)	      (DECLARE: DONTCOPY DOEVAL@COMPILE (CONSTANTS (MICASPERPT (FQUOTIENT 2540 72))							   (IHALFMICASPERPT 17)							   (IMICASPERPT 35)))	      (DECLARE: DONTEVAL@LOAD DOCOPY (P (\HDCPYDISPLAYINIT]	(COMS (* Stuff to support MICA-unit hardcopy streams on the display)	      (FNS MAKEHARDCOPYMODESTREAM UNMAKEHARDCOPYMODESTREAM \BLTSHADE.HCPYMODE 		   \BITBLT.HCPYMODE \BRUSHCONVERT.HCPYMODE \CHANGECHARSET.HCPYMODE 		   \DASHINGCONVERT.HCPYMODE \CHARWIDTH.HCPYMODE \DRAWLINE.HCPYMODE 		   \DRAWCURVE.HCPYMODE \DRAWCIRCLE.HCPYMODE \DRAWELLIPSE.HCPYMODE \DSPFONT.HCPYMODE 		   \DSPLEFTMARGIN.HCPYMODE \DSPLINEFEED.HCPYMODE \DSPRIGHTMARGIN.HCPYMODE 		   \DSPXPOSITION.HCPYMODE \DSPYPOSITION.HCPYMODE \MOVETO.HCPYMODE 		   \FONTCREATE.HCPYMODE.PRESS \FONTCREATE.HCPYMODE.INTERPRESS \STRINGWIDTH.HCPYMODE 		   \HCPYMODEBLTCHAR \HCPYMODEDISPLAYINIT \HCPYMODEDSPPRINTCHAR \SLOWHCPYMODEBLTCHAR 		   \SFFixY.HCPYMODE)	      [ADDVARS (IMAGESTREAMTYPES (PRESSDISPLAY (FONTCREATE \FONTCREATE.HCPYMODE.PRESS)						       (CREATECHARSET \FONTCREATE.HCPYMODE.PRESS))					 (INTERPRESSDISPLAY (FONTCREATE 								  \FONTCREATE.HCPYMODE.INTERPRESS)							    (CREATECHARSET 								  \FONTCREATE.HCPYMODE.INTERPRESS]	      (DECLARE: DONTEVAL@LOAD DOCOPY (P (\HCPYMODEDISPLAYINIT])(* exported functionality)(DEFINEQ(HARDCOPY.SOMEHOW  [LAMBDA (WINDOW FILE PRINTERTYPE IMAGETYPE)                (* bvm: "17-Sep-85 15:20")          (* * "either run window's HARDCOPYFN or run HARDCOPYW")    (LET [(HARDCOPYFN (WINDOWPROP WINDOW (QUOTE HARDCOPYFN]         (ALLOW.BUTTON.EVENTS)         (COND	   ((NULL HARDCOPYFN)	     (HARDCOPYW WINDOW FILE NIL NIL NIL PRINTERTYPE)                                                             (* knows how to default)	     )	   (T (LET [(IMAGESTR (OPENIMAGESTREAM FILE (OR IMAGETYPE PRINTERTYPE]	           (APPLY* HARDCOPYFN WINDOW IMAGESTR)	           (CLOSEF? IMAGESTR])(HARDCOPYIMAGEW  [LAMBDA (W)                                                (* hdj "14-Feb-85 16:21")          (* * "hardcopy this window to the DEFAULTPRINTINGHOST")    (HARDCOPY.SOMEHOW W])(HARDCOPYIMAGEW.TOFILE  [LAMBDA (W)                                                (* hdj "14-Feb-85 15:00")    (LET ((FILE&TYPE (GetImageFile)))      (if FILE&TYPE	  then (HARDCOPY.SOMEHOW W (CAR FILE&TYPE)				 (CDR FILE&TYPE])(HARDCOPYIMAGEW.TOPRINTER  [LAMBDA (W)                                                (* bvm: "17-Sep-85 15:21")    (LET ((PRINTERCHOICE (GetPrinterName)))         (COND	   (PRINTERCHOICE (HARDCOPY.SOMEHOW W (PACK* (QUOTE {LPT})						     PRINTERCHOICE)					    (CAR (PRINTERPROP (PRINTERTYPE PRINTERCHOICE)							      (QUOTE CANPRINT])(HARDCOPYREGION.TOFILE  [LAMBDA NIL                                                (* hdj " 9-Oct-85 15:33")    (LET ((FILE&TYPE (GetImageFile)))         (if FILE&TYPE	     then (PROG (REGION)			    (SPAWN.MOUSE)			    (PROMPTPRINT "Select a region")			    (SETQ REGION (GETREGION))			    (CLRPROMPT)			    (HARDCOPYW REGION (CAR FILE&TYPE)					 NIL NIL NIL (CDR FILE&TYPE])(HARDCOPYREGION.TOPRINTER  [LAMBDA NIL                                                (* hdj " 9-Oct-85 15:33")    (LET ((PRINTERCHOICE (GetPrinterName)))         (if PRINTERCHOICE	     then (PROG (REGION)			    (SPAWN.MOUSE)			    (PROMPTPRINT "Select a region")			    (SETQ REGION (GETREGION))			    (CLRPROMPT)			    (HARDCOPYW REGION (PACK* (QUOTE {LPT})							 PRINTERCHOICE)					 NIL NIL NIL (PRINTERTYPE PRINTERCHOICE])(\STRINGWIDTH.HCPYDISPLAYAUX  [LAMBDA (STR FONT RDTBL SPACEWIDTH)                        (* gbn " 3-Oct-85 18:39")                                                             (* Returns the width of STR with SPACEWIDTH for the 							     width of spaces. RDTBL has already been coerced, so no							     FLG is needed)          (* * this is a clone of \stringwidth.generic, and must track changes to it)    (DECLARE (SPECVARS FONT SPACEWIDTH))                 (* Used in \MAPCHARS)    (LET ((CSVECTOR (ffetch FONTCHARSETVECTOR of FONT)))         (DECLARE (SPECVARS CSVECTOR))         (SELECTC (NTYPX STR)		    [\LITATOM (COND				[RDTBL (for C inatom STR					  bind (SA _(fetch READSA of RDTBL))						 (FIRSTFLG _ T)						 (PCTWIDTH _(\FGETIMAGEWIDTH FONT (CHARCODE %%)									     CSVECTOR))						 SYN CSET WIDTHSBASE					  sum [COND						  ((NEQ CSET (\CHARSET C))						    (SETQ CSET (\CHARSET C))						    (SETQ WIDTHSBASE (ffetch (CHARSETINFO 										      IMAGEWIDTHS)									  of (\GETCHARSETINFO										 CSET FONT]						(PROG1 [IPLUS							   (COND							     ((AND (fetch (READCODE ESCQUOTE)									of (SETQ SYN									       (\SYNCODE SA C)))								     (OR FIRSTFLG									   (fetch (READCODE 										    INNERESCQUOTE)									      of SYN)))							       PCTWIDTH)							     (T 0))							   (COND							     ((EQ C (CHARCODE SPACE))							       SPACEWIDTH)							     (T (\FGETWIDTH WIDTHSBASE (\CHAR8CODE									      C]							 (SETQ FIRSTFLG NIL]				(T (for C WIDTHSBASE CSET inatom STR				      sum [COND					      ((NEQ CSET (\CHARSET C))						(SETQ CSET (\CHARSET C))						(SETQ WIDTHSBASE (ffetch (CHARSETINFO IMAGEWIDTHS)								      of (\GETCHARSETINFO CSET FONT]					    (COND					      ((EQ C (CHARCODE SPACE))						SPACEWIDTH)					      (T (\FGETIMAGEWIDTH WIDTHSBASE (\CHAR8CODE C]		    [\STRINGP (COND				[RDTBL (IPLUS (UNFOLD (\FGETCHARWIDTH FONT (CHARCODE %"))							2)						(for C instring STR						   bind (PCTWIDTH _(\FGETCHARIMAGEWIDTH								      FONT								      (CHARCODE %%)))							  WIDTHSBASE CSET						   sum [if (NEQ CSET (\CHARSET C))							     then (SETQ CSET (\CHARSET C))								    (SETQ WIDTHSBASE								      (ffetch (CHARSETINFO 										      IMAGEWIDTHS)									 of (\GETCHARSETINFO CSET 											     FONT]							 (SELCHARQ C								   (SPACE SPACEWIDTH)								   [(%" %%)								     (IPLUS PCTWIDTH									      (\FGETIMAGEWIDTH										WIDTHSBASE										(\CHAR8CODE C]								   (\FGETIMAGEWIDTH WIDTHSBASE										    (\CHAR8CODE										      C]				(T (for C WIDTHSBASE CSET instring STR				      sum [COND					      ((NEQ CSET (\CHARSET C))						(SETQ CSET (\CHARSET C))						(SETQ WIDTHSBASE (ffetch (CHARSETINFO IMAGEWIDTHS)								      of (\GETCHARSETINFO CSET FONT]					    (COND					      ((EQ C (CHARCODE SPACE))						SPACEWIDTH)					      (T (\FGETIMAGEWIDTH WIDTHSBASE (\CHAR8CODE C]		    (LET ((S 0)			  WIDTHSBASE CSET)		         (DECLARE (SPECVARS S CSET WIDTHSBASE))		         (\MAPCHARS [FUNCTION (LAMBDA (CC)					  (add S (COND						   ((EQ CC (CHARCODE SPACE))						     SPACEWIDTH)						   ((EQ CSET (\CHARSET CC))						     (\FGETWIDTH WIDTHSBASE (\CHAR8CODE CC)))						   (T (SETQ CSET (\CHARSET CC))						      (SETQ WIDTHSBASE (ffetch (CHARSETINFO										     IMAGEWIDTHS)									    of (\GETCHARSETINFO										   CSET FONT)))						      (\FGETIMAGEWIDTH WIDTHSBASE (\CHAR8CODE CC]				      STR RDTBL RDTBL)		     S]))(* user interface jazz)(RPAQ? ChangeDefaultPrinter )(DEFINEQ(MakeMenuOfPrinters  [LAMBDA (MENUTITLE)                                        (* bvm: "17-Sep-85 19:14")    (DECLARE (GLOBALVARS DEFAULTPRINTINGHOST))    (create MENU	    ITEMS _(APPEND (for P inside DEFAULTPRINTINGHOST collect (COND								       ((LISTP P)									 (CADR P))								       (T P)))			   (LIST (LIST "Other..." (KWOTE (QUOTE OTHER))				       "You will be prompted for a printer")))	    TITLE _ MENUTITLE])(MakeMenuOfImageTypes  [LAMBDA (MENUTITLE)                                        (* hdj "25-Apr-85 11:11")          (* * "type selection; DISPLAY is temporarily disallowed")    (DECLARE (GLOBALVARS IMAGESTREAMTYPES))    (create MENU	    ITEMS _[for IMAGETYPE in IMAGESTREAMTYPES bind IMAGETYPENAME		      collect (PROGN (SETQ IMAGETYPENAME (CAR IMAGETYPE))				     (LIST (L-CASE IMAGETYPENAME T)					   (KWOTE IMAGETYPENAME)))		      when (AND (ASSOC (QUOTE OPENSTREAM)				       (CDR IMAGETYPE))				(NEQ (CAR IMAGETYPE)				     (QUOTE DISPLAY]	    TITLE _ MENUTITLE])(GetNewPrinterFromUser  [LAMBDA (PROMPTSTRING)                                     (* hdj "13-Feb-85 22:22")    (PopUpWindowAndGetAtom PROMPTSTRING])(PopUpWindowAndGetAtom  [LAMBDA (PROMPTSTRING CANDIDATE)                           (* bvm: "17-Sep-85 15:04")    (RESETLST (LET* ((FONT (DEFAULTFONT))		     [WIDTH (WIDTHIFWINDOW (IPLUS (STRINGWIDTH PROMPTSTRING FONT)						  (ITIMES 40 (CHARWIDTH (CHARCODE A)									FONT]		     (PROMPTW (CREATEW [CREATEREGION (IMIN LASTMOUSEX (IDIFFERENCE SCREENWIDTH WIDTH))						     LASTMOUSEY WIDTH (HEIGHTIFWINDOW						       (FONTPROP FONT (QUOTE HEIGHT]				       NIL NIL T)))		    (RESETSAVE (OPENW PROMPTW)			       (LIST (FUNCTION CLOSEW)				     PROMPTW))		    (LET [(RESPONSE (PROMPTFORWORD PROMPTSTRING CANDIDATE NIL PROMPTW NIL NIL						   (CHARCODE (CR]		         (AND RESPONSE (PACK* RESPONSE])(NewPrinter  [LAMBDA (PRINTER PRIMARY?)    (DECLARE (GLOBALVARS DEFAULTPRINTINGHOST))               (* bvm: "17-Sep-85 15:41")          (* * Adds PRINTER to list of known printing hosts if it isn't there. In addition, if PRIMARY? is true, moves it to 	  front)    (for ENTRY in DEFAULTPRINTINGHOST when (STRING-EQUAL (COND							   ((LISTP ENTRY)							     (CADR ENTRY))							   (T ENTRY))							 PRINTER)       do                                                    (* Printer exists. Move to front if primary)	  [COND	    (PRIMARY? (SETQ DEFAULTPRINTINGHOST (CONS ENTRY (REMOVE ENTRY DEFAULTPRINTINGHOST]	  (RETURN)       finally                                               (* Not found)	       (SETQ DEFAULTPRINTINGHOST (COND		   (PRIMARY? (CONS PRINTER DEFAULTPRINTINGHOST))		   (T (APPEND DEFAULTPRINTINGHOST (LIST PRINTER])(GetPrinterName  [LAMBDA NIL                                                (* rrb "27-Sep-85 18:23")    (DECLARE (GLOBALVARS ChangeDefaultPrinter))    (PROG ((PRINTERCHOICE (MENU (MakeMenuOfPrinters "Which printer?")))	   DEFAULTPRINTER)          [COND	    ((EQ PRINTERCHOICE (QUOTE OTHER))	      (SETQ PRINTERCHOICE (GetNewPrinterFromUser "Printer (CR to abort): "]          [COND	    (PRINTERCHOICE (COND			     ((NEQ PRINTERCHOICE (SETQ DEFAULTPRINTER (FetchDefaultPrinter)))			       (NewPrinter PRINTERCHOICE					   (AND DEFAULTPRINTER						(MENU (OR ChangeDefaultPrinter							  (SETQ ChangeDefaultPrinter							    (create MENU								    TITLE _ 								    "Make this the new default?"								    ITEMS _(QUOTE (("Yes" T 							 "Yes, make this the new default printer")										    ("No" NIL 									    "No, don't change it")))								    MENUROWS _ 1								    CENTERFLG _ T]          (RETURN PRINTERCHOICE])(GetImageFile  [LAMBDA NIL                                                (* hdj "14-Feb-85 13:07")    (PROG ((FILE (PopUpWindowAndGetAtom "File name (CR to abort): "))	   PRINTFILETYPE FILETYPEMENU EXTENSIONSUPPLIED EXTENSIONFORTYPE)          (if (NULL FILE)	      then (RETURN))          (SETQ FILETYPEMENU (MakeMenuOfImageTypes "File type?"))          (if (SETQ PRINTFILETYPE (PRINTFILETYPE.FROM.EXTENSION FILE))	      then (RETURN (CONS FILE PRINTFILETYPE))	    else (SETQ PRINTFILETYPE (MENU FILETYPEMENU))		 (if (NULL PRINTFILETYPE)		     then (RETURN)		   else (RETURN (CONS FILE PRINTFILETYPE])(FetchDefaultPrinter  [LAMBDA NIL                                                (* bvm: "17-Sep-85 15:34")    (LET ((P (DEFAULTPRINTER)))         (COND	   ((LISTP P)	     (CADR P))	   (T P]))(* filename diddlers)(DEFINEQ(ExtensionForPrintFileType  [LAMBDA (TYPE)                                             (* hdj "13-Feb-85 23:15")    (DECLARE (GLOBALVARS PRINTFILETYPES))    (CAADR (ASSOC (QUOTE EXTENSION)		  (CDR (ASSOC TYPE PRINTFILETYPES])(PRINTFILETYPE.FROM.EXTENSION  [LAMBDA (FILE)                                             (* hdj "10-Oct-85 11:07")                                                             (* return the imagestream type corresponding to the 							     extension)    (bind [EXT _(U-CASE (FILENAMEFIELD FILE (QUOTE EXTENSION] for TYPE in PRINTFILETYPES       when [FMEMB EXT (CADR (ASSOC (QUOTE EXTENSION)					    (CDR TYPE]       do (RETURN (CAR TYPE]))(* Interface for PRINTERS and IMAGEFILES)(DEFINEQ(DEFAULTPRINTER  [LAMBDA NIL                                                (* bvm: "17-Sep-85 15:17")    (COND      ((LISTP DEFAULTPRINTINGHOST)	(CAR DEFAULTPRINTINGHOST))      (T DEFAULTPRINTINGHOST])(CAN.PRINT.DIRECTLY  [LAMBDA (PRINTERTYPE FILETYPE)                             (* lmm " 7-OCT-83 12:05")    (FMEMB FILETYPE (PRINTERPROP PRINTERTYPE (QUOTE CANPRINT])(CONVERT.FILE.TO.TYPE.FOR.PRINTER  [LAMBDA (FILE FILETYPE PRINTERTYPE HEADING PRINTOPTIONS)   (* jds "30-Aug-85 11:48")    (SETQ FILETYPE (OR FILETYPE (QUOTE TEXT)))    (PROG [(SCRATCH (CLOSEF (OPENFILE (PRINTER.SCRATCH.FILE FILE PRINTERTYPE)				      (QUOTE OUTPUT)				      (QUOTE NEW]            (* Doing the open & close gets us a guaranteed version 							     number, so that all files are truly unique.)          (APPLY* (OR (LISTGET (PRINTERPROP PRINTERTYPE (QUOTE CONVERSION))			       FILETYPE)		      (for CANPRINT in (PRINTERPROP PRINTERTYPE (QUOTE CANPRINT)) bind CONVERTER			 when (SETQ CONVERTER (LISTGET (PRINTFILEPROP CANPRINT (QUOTE CONVERSION))						       FILETYPE))			 do (RETURN CONVERTER))		      (ERROR (CONCAT "Can't convert a " FILETYPE " for a " PRINTERTYPE " printer")			     (FULLNAME FILE)))		  FILE SCRATCH NIL HEADING)          (RESETSAVE NIL (LIST (FUNCTION [LAMBDA (SCRATCH)				   (CLOSEF? SCRATCH)				   (DELFILE SCRATCH])			       SCRATCH))          (RETURN SCRATCH])(EMPRESS  [LAMBDA (FILE #COPIES HOST HEADING #SIDES PRINTOPTIONS)    (* lmm " 3-OCT-83 20:21")    (SEND.FILE.TO.PRINTER FILE HOST (NCONC (COND					     (HEADING (LIST (QUOTE HEADING)							    HEADING)))					   (COND					     (#COPIES (LIST (QUOTE #COPIES)							    #COPIES)))					   (COND					     (#SIDES (LIST (QUOTE #SIDES)							   #SIDES)))					   PRINTOPTIONS])(HARDCOPYW  [LAMBDA (WINDOW/BITMAP/REGION FILE HOST SCALEFACTOR ROTATION PRINTERTYPE)                                                             (* bvm: "17-Sep-85 16:04")                                                             (* makes a hard copy of a window)                                                             (* WINDOW/BITMAP/REGION can be a WINDOW, a REGION, a 							     BITMAP, or NIL = select region)                                                             (* If FILE supplied, output goes there.							     If HOST supplied, IT is printed.							     If neither FILE nor HOST supplied, default is to print)    (PROG ((BITMAP (SCREENBITMAP))	   (PRINTHOST HOST)	   REGION FULLFILE)          [SETQ REGION (COND	      ((WINDOWP WINDOW/BITMAP/REGION)		(COND		  ((OPENWP WINDOW/BITMAP/REGION)		    (TOTOPW WINDOW/BITMAP/REGION)		    (WINDOWPROP WINDOW/BITMAP/REGION (QUOTE REGION)))		  (T (SETQ BITMAP (WINDOWPROP WINDOW/BITMAP/REGION (QUOTE IMAGECOVERED)))		     NIL)))	      ((BITMAPP WINDOW/BITMAP/REGION)		(SETQ BITMAP WINDOW/BITMAP/REGION)		NIL)	      ((type? REGION WINDOW/BITMAP/REGION)		WINDOW/BITMAP/REGION)	      (T (GETREGION]      RETRY          (COND	    [PRINTERTYPE (COND			   [PRINTHOST (COND					((NEQ PRINTERTYPE (PRINTERTYPE PRINTHOST))					  (ERROR PRINTHOST (CONCAT "not of printer type " PRINTERTYPE)						 )					  (GO RETRY]			   (FILE                             (* don't need a PRINTHOST if you give a file)				 )			   [(SETQ PRINTHOST (find HOST inside DEFAULTPRINTINGHOST					       suchthat (EQ PRINTERTYPE (PRINTERTYPE HOST]			   (T (ERROR 			     "Can't find a printing host in DEFAULTPRINTINGHOST that is of type "				     PRINTERTYPE)			      (GO RETRY]	    (PRINTHOST (SETQ PRINTERTYPE (PRINTERTYPE PRINTHOST)))	    [DEFAULTPRINTINGHOST (for X inside DEFAULTPRINTINGHOST when (PRINTERPROP (SETQ 										      PRINTERTYPE										       (PRINTERTYPE											 X))										     (QUOTE 										      BITMAPSCALE))				    do (RETURN (SETQ PRINTHOST X)) finally (SETQ PRINTERTYPE									     (PRINTERTYPE									       (SETQ PRINTHOST										 (DEFAULTPRINTER]	    [FILE (COND		    ((NOT (SETQ PRINTERTYPE (PRINTFILETYPE FILE T)))		      (ERROR FILE "Can't tell what kind of print file to produce -- PRINTERTYPE, DEFAULTPRINTERTYPE, DEFAULTPRINTINGHOST all NIL"			     )		      (GO RETRY]	    (T (ERROR "Can't tell where to send window image -- HOST, DEFAULTPRINTINGHOST are NIL")	       (GO RETRY)))          [COND	    ((NOT SCALEFACTOR)	      [SETQ SCALEFACTOR (COND		  (REGION (PRINTER.BITMAPSCALE (fetch WIDTH of REGION)					       (fetch HEIGHT of REGION)					       PRINTERTYPE PRINTHOST))		  (T (PRINTER.BITMAPSCALE (fetch BITMAPWIDTH of BITMAP)					  (fetch BITMAPHEIGHT of BITMAP)					  PRINTERTYPE PRINTHOST]	      (COND		((LISTP SCALEFACTOR)		  (SETQ ROTATION (CDR SCALEFACTOR))		  (SETQ SCALEFACTOR (CAR SCALEFACTOR]          (SETQ FULLFILE (PRINTER.BITMAPFILE (OR FILE (PRINTER.SCRATCH.FILE))					     PRINTERTYPE BITMAP SCALEFACTOR REGION ROTATION 					     "Window Image"))          [COND	    ((OR HOST (NULL FILE))	      (ADD.PROCESS [BQUOTE (PROGN (, (PRINTERPROP PRINTERTYPE (QUOTE SEND))					     (QUOTE , (COND ((LISTP PRINTHOST)							      (CADR PRINTHOST))							    (T PRINTHOST)))					     (QUOTE , FULLFILE)					     (QUOTE (DOCUMENT.NAME "Window Image")))					  ,					  (AND (NULL FILE)					       (BQUOTE (DELFILE (QUOTE , FULLFILE]			   (QUOTE NAME)			   (QUOTE HARDCOPYW]          (RETURN (AND FILE FULLFILE])(LISTFILES1  [LAMBDA (FILE PRINTOPTIONS)                                (* rmk: "30-Nov-84 08:51")    (SEND.FILE.TO.PRINTER FILE NIL PRINTOPTIONS])(PRINTER.BITMAPFILE  [LAMBDA (FILE PRINTERTYPE BITMAP SCALEFACTOR REGION ROTATION TITLE)                                                             (* lmm " 3-OCT-83 21:40")                                                             (* convert a bitmap into a file)    (DECLARE (SPECVARS . T))    (EVAL (PRINTERPROP PRINTERTYPE (QUOTE BITMAPFILE])(PRINTER.BITMAPSCALE  [LAMBDA (WIDTH HEIGHT PRINTERTYPE HOST)                    (* lmm " 3-OCT-83 21:32")                                                             (* could ask the host what size paper it has)    (PROG NIL          (RETURN (APPLY* (OR (PRINTERPROP PRINTERTYPE (QUOTE BITMAPSCALE))			      (RETURN 1))			  WIDTH HEIGHT HOST])(PRINTER.SCRATCH.FILE  [LAMBDA (FULLFILE)                                         (* lmm "25-Jun-84 17:05")    (COND      [(AND FULLFILE (FIXP (CAR (LISTP EMPRESS.SCRATCH)))	    (IGREATERP (OR (GETFILEINFO FULLFILE (QUOTE SIZE))			   0)		       (CAR EMPRESS.SCRATCH)))	(CAR (LISTP (CDR EMPRESS.SCRATCH]      (T (QUOTE {CORE}EMPRESS.SCRATCH])(PRINTERPROP  [LAMBDA (PRINTERTYPE PROP)                                 (* lmm " 5-OCT-83 16:11")    (for X in PRINTERTYPES when (EQMEMB PRINTERTYPE (CAR X))       do (RETURN (CADR (ASSOC PROP (CDR X])(PRINTERSTATUS  [LAMBDA (PRINTER)                                          (* lmm " 5-OCT-83 15:19")    (PROG [(STATUSFN (PRINTERPROP (PRINTERTYPE PRINTER)				  (QUOTE STATUS]          (RETURN (AND STATUSFN (APPLY* STATUSFN PRINTER])(PRINTERTYPE  [LAMBDA (HOST)                                             (* bvm: "17-Sep-85 15:18")    (SELECTQ HOST	     ((NIL LPT)	       (SETQ HOST (DEFAULTPRINTER)))	     NIL)    (COND      [(LISTP HOST)                                          (* Is a pair (type hostname); check that type is one we							     know about)	(LET ((ACTUALHOST (CAR HOST)))	     (COND	       ((for X in PRINTERTYPES thereis (EQMEMB ACTUALHOST (CAR X)))		 ACTUALHOST)	       (T (ERROR "Unrecognized printer " ACTUALHOST]      ((NULL HOST)	DEFAULTPRINTERTYPE)      ((GETPROP HOST (QUOTE PRINTERTYPE)))      [(for TYPE in PRINTERTYPES bind FN when (AND (SETQ FN (CDR (ASSOC (QUOTE HOSTNAMEP)									TYPE)))						   (APPLY* (CAR FN)							   HOST))	  do                                                 (* Try the predicates for each printer type for 							     recognizing their own host names)	     (RETURN (CAAR TYPE]      [(for PRINTER in (DEFAULTPRINTER) do (COND					     ((AND (LISTP PRINTER)						   (STRING-EQUAL (CADR PRINTER)								 HOST))					       (RETURN (CAR PRINTER]      (T DEFAULTPRINTERTYPE])(PRINTFILEPROP  [LAMBDA (PRINTFILETYPE PROP)                               (* rmk: "11-OCT-83 13:00")    (for X in PRINTFILETYPES when (EQMEMB PRINTFILETYPE (CAR X))       do (RETURN (CADR (ASSOC PROP (CDR X])(PRINTFILETYPE  [LAMBDA (FILE DONTOPEN)                                    (* bvm: "20-Oct-85 17:14")    (COND      ((IMAGESTREAMP FILE)	(IMAGESTREAMTYPE FILE))      (T (LET [(TYPE (GETFILEINFO FILE (QUOTE TYPE]	      (COND		((OR (EQ TYPE (QUOTE TEXT))		       (AND TYPE (ASSOC TYPE PRINTFILETYPES)))		  TYPE)		((PRINTFILETYPE.FROM.EXTENSION FILE))		((NOT DONTOPEN)		  (RESETLST [COND				((STRINGP FILE)            (* Yecch, OPENP of a string interprets string as a 							     string stream!)				  (SETQ FILE (MKATOM FILE]			      [COND				((NOT (OPENP FILE (QUOTE INPUT)))                                                             (* Open file so testers don't have to repeatedly open 							     and close it)				  (SETQ FILE (OPENFILE FILE (QUOTE INPUT)))				  (RESETSAVE NIL (LIST (QUOTE CLOSEF)							   FILE]			      (COND				((OR (RANDACCESSP FILE)				       (EQ (GETFILEPTR FILE)					     0))				  (for TYPE in PRINTFILETYPES				     when (CAR (NLSETQ (APPLY* (CADR (ASSOC (QUOTE											  TEST)											(CDR TYPE)))								       FILE)))				     do (RETURN (CAR TYPE])(SEND.FILE.TO.PRINTER  [LAMBDA (FILE HOST PRINTOPTIONS)                           (* bvm: "17-Sep-85 15:28")                                                             (* Returns file name if successful, NIL if not.							     The RESETLST makes sure the scratch file, if any, is 							     deleted.)    (RESETLST (PROG (FULLFILE STRM FILETYPE PRINTERTYPE PFILE)          (* Don't re-open it if it was previously open, cause caller (PRINTERDEVICE) really wants us to use the same stream, 	  which has the BEINGPRINTED property.)		    [RESETSAVE NIL (LIST (COND					   [(LISTGET PRINTOPTIONS (QUOTE DELETE))					     (FUNCTION (LAMBDA (FL)						 (CLOSEF? FL)						 (DELFILE FL]					   (T (FUNCTION CLOSEF?)))					 (SETQ STRM (OPENSTREAM FILE (QUOTE INPUT)								(QUOTE OLD)								8]                                                             (* Do we need to convert the FILE ?)		    (SETQ PFILE (SETQ FULLFILE (FULLNAME FILE)))		    (SETQ FILETYPE (PRINTFILETYPE FULLFILE))		RETRY		    [COND		      [[OR HOST (SETQ HOST (for X on PRINTOPTIONS by (CDDR X)					      when (MEMB (U-CASE (CAR X))							 (QUOTE (HOST SERVER)))					      do (RETURN (CADR X]			(SETQ PRINTERTYPE (PRINTERTYPE HOST))			(COND			  ((CAN.PRINT.DIRECTLY PRINTERTYPE FILETYPE)                                                             (* IS OK, NO CONVERSION)			    )			  (T (SETQ PFILE (CONVERT.FILE.TO.TYPE.FOR.PRINTER STRM FILETYPE PRINTERTYPE									   (LISTGET PRINTOPTIONS										    (QUOTE HEADING))									   PRINTOPTIONS]		      ((NULL DEFAULTPRINTINGHOST)			(ERROR "DEFAULTPRINTINGHOST and HOST arg are NIL; don't know where to print " 			       FULLFILE)			(GO RETRY))		      ([AND FILETYPE (for X inside (OR DEFAULTPRINTINGHOST (QUOTE (NIL)))					when (CAN.PRINT.DIRECTLY (SETQ PRINTERTYPE (PRINTERTYPE								     X))								 FILETYPE)					do (RETURN (SETQ HOST X]                                                             (* no conversion necessary)			)		      (T (SETQ PFILE (CONVERT.FILE.TO.TYPE.FOR.PRINTER STRM FILETYPE								       [SETQ PRINTERTYPE									 (PRINTERTYPE (SETQ HOST											(DEFAULTPRINTER]								       (LISTGET PRINTOPTIONS										(QUOTE HEADING))								       PRINTOPTIONS]		    (COND		      ([NLISTP (SETQ PFILE (APPLY* (OR (PRINTERPROP PRINTERTYPE (QUOTE SEND))						       (ERROR (CONCAT "Don't know how to send to a " 								      PRINTERTYPE)							      HOST))						   (COND						     ((LISTP HOST)						       (CADR HOST))						     (T HOST))						   PFILE						   (APPEND PRINTOPTIONS (QUOTE (#COPIES 1))							   (LIST (QUOTE DOCUMENT.NAME)								 FULLFILE]			(RETURN FULLFILE))		      (T (LISPXPRIN1 (CDR PFILE)				     T)			 (LISPXTERPRI T)			 (RETURN NIL]))(DEFINEQ(PRINTERDEVICE  [LAMBDA (NAME)                                             (* rmk: " 3-Dec-84 10:22")          (* This defines an LPT device. An LPT file is a file that gets sent to printer and deleted when it is closed.	  This must be defined on a CORE device only because we have no way of inheriting the previous CLOSEFILE function that	  this function is replacing but needs to call internally. We have \CORE.CLOSEFILE explicit in this code.)    (PROG ((DEV (\CREATECOREDEVICE NAME)))          [replace CLOSEFILE of DEV	     with (FUNCTION (LAMBDA (STREAM)		      (PROG [(SDEV (fetch DEVICE of STREAM))			     (PRINTOPTIONS (STREAMPROP STREAM (QUOTE PRINTOPTIONS]                                                             (* Get PRINTOPTIONS property before closing the stream,							     in case the closing throws them away)          (* If we could save away and get at the previous CLOSEFILE method (e.g. by an FDEVPROP), this could be replaced by 	  the generic (FDEVOP (QUOTE CLOSEFILE) SDEV STREAM))			    (RETURN (COND				      [(AND (NOT RESETSTATE)					    (OPENP STREAM (QUOTE OUTPUT))					    (IGREATERP (GETEOFPTR STREAM)						       0))          (* Close and send to printer only if open for output. If open for input, then we must already have started printing.	  Don't close until after getting EOF ptr.)					(\CORE.CLOSEFILE STREAM)					(replace ACCESS of STREAM with NIL)                                                             (* Hack, cause this is usually done later in the 							     generic \CLOSEFILE.)                                                             (* Let SEND.FILE.TO.PRINTER choose the host if it is 							     the generic printer LPT, otherwise use the name in the 							     devicename field.)          (* EVAL.AS.PROCESS (BQUOTE (SEND.FILE.TO.PRINTER (QUOTE , (fetch FULLNAME of STREAM)) (QUOTE , 	  (COND ((NEQ (QUOTE LPT) (fetch DEVICENAME of SDEV)) (fetch DEVICENAME of SDEV)) (T (FILENAMEFIELD 	  (fetch FULLNAME of STREAM) (QUOTE NAME))))) (APPEND (QUOTE (DELETE T)) PRINTOPTIONS (QUOTE (HEADING T))))))					(SEND.FILE.TO.PRINTER					  STREAM					  [COND					    ((NEQ (QUOTE LPT)						  (fetch DEVICENAME of SDEV))					      (fetch DEVICENAME of SDEV))					    (T (PROG ((NAME (fetch FULLNAME of STREAM))						      POS POS2)						     (RETURN (AND (SETQ POS (STRPOS "}" NAME))								  (SETQ POS2 (STRPOS "." NAME										     (ADD1 POS)))								  (SUBATOM NAME (ADD1 POS)									   (SUB1 POS2]					  (APPEND (QUOTE (DELETE T))						  PRINTOPTIONS						  (QUOTE (HEADING T]				      (T                     (* Error while creating the file, if the user had 							     wrapped a RESETLST/CLOSEF around his code.							     Presumably, he doesn't want the file printed)					 (\CORE.CLOSEFILE STREAM)					 (FDEVOP (QUOTE DELETEFILE)						 SDEV STREAM SDEV T]          (\DEFINEDEVICE NAME DEV)          (RETURN NAME]))(DECLARE: DONTEVAL@LOAD DOCOPY (PRINTERDEVICE (QUOTE LPT)))(* for backward compatibility)(MOVD? (QUOTE NILL)       (QUOTE PRINTERMODE))(RPAQ? DEFAULTPRINTINGHOST )(RPAQ? DEFAULTPRINTERTYPE (QUOTE PRESS))(RPAQ? EMPRESS.SCRATCH (QUOTE (30 {DSK}EMPRESS.SCRATCH)))(RPAQ? EMPRESS#SIDES T)(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS DEFAULTPRINTINGHOST DEFAULTPRINTERTYPE EMPRESS.SCRATCH EMPRESS#SIDES PRINTERTYPES 	    PRINTFILETYPES))(* Converting text files to imagestreams)(RPAQ? TEXTDEFAULTTABS (LIST 20320))(RPAQ? TEXTDEFAULTPAGEREGION (CREATEREGION 2794 1905 18415 24765))(* TEXTDEFAULTTABS Hack, mica equivalent of 8 inches)(DECLARE: DOEVAL@COMPILE DONTCOPY(GLOBALVARS TEXTDEFAULTTABS TEXTDEFAULTPAGEREGION))(DEFINEQ(TEXTTOIMAGEFILE  [LAMBDA (FILE IMAGEFILE IMAGETYPE FONTS HEADING TABS OPTIONS)                                                             (* bvm: "14-Aug-85 19:59")                                                             (* Generic function for converting PSPOOL format text 							     files into image files)    (RESETLST (PROG (IMAGESTREAM INSTRM OUTCHARFN INFILE INEOLC MAXFONT FONTARRAY)                                                             (* FONTARRAY is an array of font-descriptors)		    [RESETSAVE [SETQ INFILE (OPENFILE FILE (QUOTE INPUT)						      (QUOTE OLD)						      8						      (QUOTE ((SEQUENTIAL T]			       (QUOTE (PROGN (CLOSEF? OLDVALUE]                                                             (* Strip off the extension if we are generating the 							     name from the INFILE, so that OPENIMAGESTREAM can pack 							     on the appropriate extension)		    [RESETSAVE [SETQ IMAGESTREAM				 (OPENIMAGESTREAM				   (OR IMAGEFILE (PACKFILENAME (QUOTE EXTENSION)							       NIL							       (QUOTE VERSION)							       NIL							       (QUOTE BODY)							       INFILE))				   IMAGETYPE				   (APPEND [AND (NEQ HEADING T)						(LIST (QUOTE HEADING)						      (OR HEADING (CONCAT INFILE "     "									  (GETFILEINFO INFILE										       (QUOTE 										     CREATIONDATE]					   (AND (NOT (LISTGET OPTIONS (QUOTE REGION)))						(LIST (QUOTE REGION)						      TEXTDEFAULTPAGEREGION))					   (APPEND (LIST (QUOTE DOCUMENT.NAME)							 INFILE							 (QUOTE TABS)							 TABS							 (QUOTE FONTS)							 FONTS)						   OPTIONS]			       (QUOTE (AND RESETSTATE (DELFILE (CLOSEF? OLDVALUE]                                                             (* Make \BIN return NIL on EOS)		    (COPY.TEXT.TO.IMAGE INFILE IMAGESTREAM FONTS)		    (RETURN (LIST (CLOSEF INFILE)				  (CLOSEF IMAGESTREAM])(COPY.TEXT.TO.IMAGE  [LAMBDA (INFILE IMAGESTREAM FONTS TABS)                    (* bvm: "17-Sep-85 16:02")                                                             (* Copy text to an image stream, obeying PSPOOL control							     characters)    (LET* ((IMAGESTREAM (GETSTREAM IMAGESTREAM (QUOTE OUTPUT)))	   C FC (FONTARRAY (FONTMAPARRAY FONTS))	   (MAXFONT (ARRAYSIZE FONTARRAY))	   (INSTRM (GETSTREAM INFILE (QUOTE INPUT)))	   (INEOLC (GETFILEINFO INSTRM (QUOTE EOL)))	   (RIGHTMAR (DSPRIGHTMARGIN NIL IMAGESTREAM)))          (replace (STREAM ENDOFSTREAMOP) of INSTRM with (FUNCTION ZERO))          (bind (SHIFTEDCHARSET _(UNFOLD (ffetch CHARSET of INSTRM)					 256))	     do (COND		  ((AND (EQ 0 (SETQ C (\NSIN INSTRM SHIFTEDCHARSET SHIFTEDCHARSET)))			(EOFP INSTRM))		    (RETURN))		  ((AND RIGHTMAR (IGREATERP (DSPXPOSITION NIL IMAGESTREAM)					    RIGHTMAR))       (* Not to walk off the right edge of the paper)		    (TERPRI IMAGESTREAM)))		(COND		  ([IGREATERP C (CONSTANT (APPLY (FUNCTION MAX)						 (CHARCODE (^F CR LF ^L TAB NULL]		    (\OUTCHAR IMAGESTREAM C))		  (T (SELCHARQ C			       [^F                           (* Font shift)				   (SELCHARQ (SETQ FC (\NSIN INSTRM SHIFTEDCHARSET SHIFTEDCHARSET))					     [^T             (* tab to absolute pos.)						 (COND						   ((EQ 0 (SETQ FC (\NSIN INSTRM SHIFTEDCHARSET 									  SHIFTEDCHARSET)))						     (\OUTCHAR IMAGESTREAM (CHARCODE ^F))						     (\OUTCHAR IMAGESTREAM (CHARCODE ^T))						     (AND (\EOFP INSTRM)							  (RETURN))						     (\OUTCHAR IMAGESTREAM FC))						   (T           (* TEXTDEFAULTTABS is a hack, since it depends on the units of the stream. Should really be a property of the stream	  or imagetype, or defined in terms of standard scale)						      (SETQ FC (OR (CAR (NTH (OR TABS TEXTDEFAULTTABS)									     FC))								   (ERROR 								  "Undefined absolute tab number"									  FC)))						      (DSPXPOSITION FC IMAGESTREAM]					     (NULL (\OUTCHAR IMAGESTREAM (CHARCODE ^F))						   (AND (\EOFP INSTRM)							(RETURN))						   (\OUTCHAR IMAGESTREAM FC)                                                             (* EOS after ^F)						   )					     (COND					       ((AND (IGEQ MAXFONT FC)						     (NEQ FC 0))						 (DSPFONT (ELT FONTARRAY FC)							  IMAGESTREAM))					       (T (\OUTCHAR IMAGESTREAM (CHARCODE ^F))						  (\OUTCHAR IMAGESTREAM C]			       (CR                           (* Don't call generic \CHECKEOLC macro, because we are 							     trying to disciminate the raw CR and raw LF cases for 							     printing)          (* Note: Assumes, as does \CHECKEOLC and \FILEOUTCHARFN that the LF character will be generated immediately after 	  the CR, independent of the encoding, perhaps by a file-transfer protocol)				   (SELECTQ INEOLC					    (CR (TERPRI IMAGESTREAM))					    [CRLF (COND						    ((EQ (CHARCODE LF)							 (\PEEKBIN INSTRM T))						      (BIN INSTRM)						      (TERPRI IMAGESTREAM))						    (T (DSPXPOSITION (DSPLEFTMARGIN NIL IMAGESTREAM)								     IMAGESTREAM)                                                             (* Move to left margin)						       ]					    (DSPXPOSITION (DSPLEFTMARGIN NIL IMAGESTREAM)							  IMAGESTREAM)))			       (TAB (OR (NLSETQ (RELMOVETO (TIMES (CHARWIDTH (CHARCODE SPACE)									     IMAGESTREAM)								  8)							   0 IMAGESTREAM))					(\OUTCHAR IMAGESTREAM C)))			       [LF (COND				     ((EQ INEOLC (QUOTE LF))				       (TERPRI IMAGESTREAM))				     (T (DSPXPOSITION (PROG1 (DSPXPOSITION NIL IMAGESTREAM)							     (TERPRI IMAGESTREAM))						      IMAGESTREAM]			       (NULL (AND (EOFP INSTRM)					  (RETURN))				     (\OUTCHAR IMAGESTREAM C))			       (\OUTCHAR IMAGESTREAM C]))(DEFINEQ(\BLTSHADE.GENERICPRINTER  [LAMBDA (TEXTURE STREAM DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT OPERATION CLIPPINGREGION 		   SHADESCALE)                               (* hdj "12-Mar-85 14:05")    (LET* [(SCALE (DSPSCALE NIL STREAM))       (SCRATCHBM (BITMAPCREATE (FIX (FTIMES (FQUOTIENT SCALE SHADESCALE)					     (FQUOTIENT WIDTH SCALE)))				(FIX (FTIMES (FQUOTIENT SCALE SHADESCALE)					     (FQUOTIENT HEIGHT SCALE]      (\BLTSHADE.BITMAP TEXTURE SCRATCHBM 0 0 NIL NIL (QUOTE REPLACE))      (BITBLT SCRATCHBM 0 0 STREAM DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT (QUOTE INPUT)	      OPERATION NIL CLIPPINGREGION]))(* hack for printers that can't really BLTSHADE)(* stuff to support hardcopy streams on the display.)(DEFINEQ(MAKEHARDCOPYSTREAM  [LAMBDA (DISPLAYSTREAM IMAGETYPE)                          (* gbn "11-Oct-85 04:01")          (* * creates a hardcopy stream from a display stream.)    (DECLARE (GLOBALVARS \HDCPYDISPLAYIMAGEOPS))    (PROG [(DS (COND		   ((DISPLAYSTREAMP DISPLAYSTREAM))		   ((WINDOWP DISPLAYSTREAM)		     (WINDOWPROP DISPLAYSTREAM (QUOTE DSP)))		   ((NULL DISPLAYSTREAM)		     (DSPCREATE))		   (T (\ILLEGAL.ARG DISPLAYSTREAM]	    (replace (STREAM IMAGEOPS) of DS with \HDCPYDISPLAYIMAGEOPS)	    [STREAMPROP DS (QUOTE HARDCOPYIMAGETYPE)			  (OR IMAGETYPE (CAR (PRINTERPROP (PRINTERTYPE)								(QUOTE CANPRINT]                                                             (* set the bout fn to one that updates the mica fields							     and sets the position from them.)	    (replace (STREAM STRMBOUTFN) of DS with (FUNCTION \HDCPYDSPPRINTCHAR))	    (replace (STREAM OUTCHARFN) of DS with (FUNCTION \HDCPYDSPPRINTCHAR))                                                             (* set the parameters that are different to initialize							     the mica defined fields.)	    (DSPFONT (DSPFONT NIL DS)		       DS)	    (DSPXPOSITION 0 DS)	    (DSPYPOSITION 0 DS)	    (DSPRIGHTMARGIN (DSPRIGHTMARGIN NIL DS)			      DS)	    (RETURN DS])(UNMAKEHARDCOPYSTREAM  [LAMBDA (DISPLAYSTREAM)                                    (* rrb "28-Sep-84 15:26")          (* * returns a hardcopy stream to a display stream.)    (DECLARE (GLOBALVARS \DISPLAYIMAGEOPS))    (PROG [(DS (COND		 ((DISPLAYSTREAMP DISPLAYSTREAM))		 ((WINDOWP DISPLAYSTREAM)		   (WINDOWPROP DISPLAYSTREAM (QUOTE DSP)))		 (T (\ILLEGAL.ARG DISPLAYSTREAM]          (COND	    ((FMEMB (QUOTE HARDCOPY)		    (IMAGESTREAMTYPE DS)))	    (T (RETURN DS)))          (replace (STREAM IMAGEOPS) of DS with \DISPLAYIMAGEOPS)          (STREAMPROP DS (QUOTE HARDCOPYIMAGETYPE)		      NIL)                                   (* restore the bout fn)          (replace (STREAM STRMBOUTFN) of DS with (FUNCTION \DSPPRINTCHAR))          (replace (STREAM OUTCHARFN) of DS with (FUNCTION \DSPPRINTCHAR))          (RETURN DS])(HARDCOPYSTREAMTYPE  [LAMBDA (IMAGESTREAM)                                      (* rrb "28-Sep-84 18:41")          (* * returns the type of a hard copy stream which is either PRESS or INTERPRESS.)    (PROG (STREAM)          (RETURN (AND (SETQ STREAM (\OUTSTREAMARG IMAGESTREAM T))		       (STREAMPROP STREAM (QUOTE HARDCOPYIMAGETYPE])(\CHARWIDTH.HDCPYDISPLAY  [LAMBDA (STREAM CHARCODE)                                  (* gbn "11-Oct-85 04:09")                                                             (* gets the width of a character code in a hardcopy 							     stream. Should be updated for spacefactor)    (IQUOTIENT (IPLUS (\FGETCHARIMAGEWIDTH (FONTCREATE (ffetch (\DISPLAYDATA DDFONT)								of (ffetch IMAGEDATA									of STREAM))							     NIL NIL NIL (STREAMPROP STREAM										       (QUOTE											 										HARDCOPYIMAGETYPE)))					       CHARCODE)			  (CONSTANT IHALFMICASPERPT))		 (CONSTANT IMICASPERPT])(\DSPFONT.HDCPYDISPLAY  [LAMBDA (HDCPYDSTREAM FONT)                                (* rrb "11-Oct-85 17:53")          (* changes the font of a hardcopy display stream. Does what the display does then puts the hardcopy widths where 	  they can be found {FOR NOW USE THE DDCHARIMAGEWIDTHS FIELD})    (PROG1 (\DSPFONT.DISPLAY HDCPYDSTREAM FONT)	     (AND FONT (PROG [(DD (fetch IMAGEDATA of HDCPYDSTREAM))				  (FD (FONTCREATE FONT NIL NIL NIL (STREAMPROP HDCPYDSTREAM										   (QUOTE 										HARDCOPYIMAGETYPE]                                                             (* For now, use a streamprop instead of a special 							     field in the dispay data)                                                             (* Scale widths to micas, so we don't have to fetch 							     the constants to scale by for every char we print)			         (replace DDCHARIMAGEWIDTHS of DD				    with (PROG (W OLDWIDTH (SCALE (FONTPROP FD (QUOTE SCALE)))						      (CSINFO (\GETCHARSETINFO (fetch (STREAM											  CHARSET)										  of HDCPYDSTREAM)									       FD)))					           [COND						     ((EQP SCALE (CONSTANT MICASPERPT))						       (RETURN (fetch (CHARSETINFO WIDTHS)								    of CSINFO]					           (SETQ W (\CREATECSINFOELEMENT))					           (SETQ OLDWIDTH (fetch (CHARSETINFO WIDTHS)								       of CSINFO))					           (SETQ SCALE (FQUOTIENT (CONSTANT MICASPERPT)									      SCALE))					           [for I from 0 to \MAXTHINCHAR						      do (\FSETWIDTH W I								       (FIXR (FTIMES										 (\FGETWIDTH OLDWIDTH 											     I)										 SCALE]					           (RETURN W])(\DSPRIGHTMARGIN.HDCPYDISPLAY  [LAMBDA (DISPLAYSTREAM XPOSITION)                          (* rrb "21-Aug-84 18:30")          (* * Sets the right margin that determines when a cr is inserted by print for the hardcopy display stream.)          (* mica right margin is kept accurately using 35.27778. Since the updating at each character is done with 35, this	  may lead to a small error.)    (PROG1 (\DSPRIGHTMARGIN.DISPLAY DISPLAYSTREAM XPOSITION)	   (AND XPOSITION (replace (\DISPLAYDATA DDMICARIGHTMARGIN) of (fetch IMAGEDATA of 										    DISPLAYSTREAM)			     with (FIX (FTIMES XPOSITION (CONSTANT MICASPERPT])(\DSPXPOSITION.HDCPYDISPLAY  [LAMBDA (HARDCOPYSTREAM XPOSITION)                         (* rrb "20-Aug-84 17:51")                                                             (* updates the mica xposition too.)    (PROG1 (\DSPXPOSITION.DISPLAY HARDCOPYSTREAM XPOSITION)	   (AND XPOSITION (\HDCPYDISPLAY.FIX.XPOS HARDCOPYSTREAM])(\DSPYPOSITION.HDCPYDISPLAY  [LAMBDA (HARDCOPYSTREAM YPOSITION)                         (* rrb "20-Aug-84 17:51")                                                             (* updates the mica xposition too.)    (PROG1 (\DSPYPOSITION.DISPLAY HARDCOPYSTREAM YPOSITION)	   (AND YPOSITION (\HDCPYDISPLAY.FIX.YPOS HARDCOPYSTREAM])(\STRINGWIDTH.HDCPYDISPLAY  [LAMBDA (STREAM STR RDTBL)                                 (* gbn " 7-Nov-85 20:47")                                                             (* Returns the width of for the current 							     font/spacefactor in hardcopy stream STREAM.)    (LET [(HARDCOPYFD (FONTCREATE (ffetch (\DISPLAYDATA DDFONT) of (ffetch IMAGEDATA									    of STREAM))				    NIL NIL NIL (STREAMPROP STREAM (QUOTE HARDCOPYIMAGETYPE]         (IQUOTIENT (IPLUS (\STRINGWIDTH.GENERIC STR HARDCOPYFD RDTBL (\FGETCHARWIDTH							 HARDCOPYFD							 (CHARCODE SPACE)))			       (CONSTANT IHALFMICASPERPT))		      (CONSTANT IMICASPERPT])(\HDCPYBLTCHAR  [LAMBDA (CHARCODE DISPLAYSTREAM DISPLAYDATA)             (* rrb "11-Oct-85 17:53")          (* puts a character on a hardcopy display stream. Much of the information needed by the BitBlt microcode is 	  prestored by the routines that change it. This is kept in the BitBltTable.)                                                             (* knows about the representation of a DisplayStream.)    (DECLARE (LOCALVARS . T))    (PROG (LOCAL1 RIGHT LEFT CURX (CHAR8CODE (\CHAR8CODE CHARCODE))		    MICARIGHT)	    (COND	      ((NEQ (ffetch DDCHARSET of DISPLAYDATA)		      (\CHARSET CHARCODE))		(\CHANGECHARSET.HDCPYDISPLAY DISPLAYDATA (\CHARSET CHARCODE)					       DISPLAYSTREAM)))	    [COND	      ((ffetch (\DISPLAYDATA DDSlowPrintingCase) of DISPLAYDATA)		(RETURN (\SLOWHDCPYBLTCHAR CHARCODE DISPLAYSTREAM]	CRLP(SETQ CURX (ffetch DDXPOSITION of DISPLAYDATA))	    [COND	      ((IGREATERP (SETQ MICARIGHT (IPLUS (ffetch (\DISPLAYDATA DDMICAXPOS)							  of DISPLAYDATA)						       (\FGETWIDTH (ffetch (\DISPLAYDATA 										DDCHARIMAGEWIDTHS)								      of DISPLAYDATA)								   CHAR8CODE)))			    (ffetch (\DISPLAYDATA DDMICARIGHTMARGIN) of DISPLAYDATA))                                                             (* would go past right margin, force a cr)		(COND		  ((IGREATERP CURX (ffetch DDLeftMargin of DISPLAYDATA))                                                             (* don't bother CR if position is at left margin 							     anyway. This also serves to break the loop.)		    (\DSPPRINTCR/LF (CHARCODE EOL)				      DISPLAYSTREAM)         (* reuse the code in the test of this conditional 							     rather than repeat it here.)		    (GO CRLP]	    (freplace (\DISPLAYDATA DDMICAXPOS) of DISPLAYDATA with MICARIGHT)                                                             (* update the display stream x position.							     Make sure that there is at least one point width for 							     each character.)	    [freplace DDXPOSITION of DISPLAYDATA with (IMAX (ADD1 CURX)								    (IQUOTIENT (IPLUS										   MICARIGHT										   (CONSTANT 										  IHALFMICASPERPT))										 (CONSTANT 										      IMICASPERPT]                                                             (* transforms an x coordinate into the destination 							     coordinate.)	    (SETQ CURX (IPLUS CURX (ffetch DDXOFFSET of DISPLAYDATA)))	    (SETQ RIGHT (IPLUS CURX (\DSPGETCHARWIDTH CHAR8CODE DISPLAYDATA)))	    (COND	      ((IGREATERP RIGHT (SETQ LOCAL1 (ffetch DDClippingRight of DISPLAYDATA)))                                                             (* character overlaps right edge of clipping region.)		(SETQ RIGHT LOCAL1)))	    (SETQ LEFT (COND		((IGREATERP CURX (SETQ LOCAL1 (ffetch DDClippingLeft of DISPLAYDATA)))		  CURX)		(T LOCAL1)))	    (RETURN (COND			((AND (ILESSP LEFT RIGHT)				(NEQ (fetch PBTHEIGHT of (SETQ LOCAL1 (ffetch DDPILOTBBT										 of DISPLAYDATA)))				       0))			  (.WHILE.TOP.DS. DISPLAYSTREAM (freplace PBTDESTBIT of LOCAL1							   with LEFT)					  (freplace PBTWIDTH of LOCAL1 with (IDIFFERENCE										    RIGHT LEFT))					  (freplace PBTSOURCEBIT of LOCAL1					     with (IDIFFERENCE (IPLUS (\DSPGETCHAROFFSET 											CHAR8CODE 										      DISPLAYDATA)									    LEFT)								   CURX))					  (\PILOTBITBLT LOCAL1 0))			  T])(\HDCPYDISPLAY.FIX.XPOS  [LAMBDA (HARDCOPYSTREAM)                                   (* rrb "20-Aug-84 17:47")          (* * updates the mica X position from the x position in the display stream. This is called whenever the X position	  changes in a hardcopy stream.)    (PROG ((DD (fetch IMAGEDATA of HARDCOPYSTREAM)))          (replace (\DISPLAYDATA DDMICAXPOS) of DD with (FIX (FTIMES (fetch (\DISPLAYDATA DDXPOSITION)									of DD)								     (CONSTANT MICASPERPT])(\HDCPYDISPLAY.FIX.YPOS  [LAMBDA (HARDCOPYSTREAM)                                   (* rrb "20-Aug-84 17:50")          (* * updates the mica Y position from the Y position in the display stream. This is called whenever the Y position	  changes in a hardcopy stream.)    (PROG ((DD (fetch IMAGEDATA of HARDCOPYSTREAM)))          (replace (\DISPLAYDATA DDMICAYPOS) of DD with (FIX (FTIMES (fetch (\DISPLAYDATA DDYPOSITION)									of DD)								     (CONSTANT MICASPERPT])(\HDCPYDISPLAYINIT  [LAMBDA NIL                                                (* rmk: "24-Sep-84 17:04")          (* * Initializes global variables for the hardcopy Display device. This device appears to the user as an INTERPRESS 	  or PRESS device meaning units in micas but outputs to the screen. Much of this code was borrowed from the display 	  case.)    (DECLARE (GLOBALVARS \HDCPYDISPLAYIMAGEOPS))    (SETQ \HDCPYDISPLAYIMAGEOPS (create IMAGEOPS using \DISPLAYIMAGEOPS IMAGETYPE _(QUOTE							 (HARDCOPY DISPLAY))						       IMFONT _(FUNCTION \DSPFONT.HDCPYDISPLAY)						       IMRIGHTMARGIN _(FUNCTION 							 \DSPRIGHTMARGIN.HDCPYDISPLAY)						       IMXPOSITION _(FUNCTION 							 \DSPXPOSITION.HDCPYDISPLAY)						       IMYPOSITION _(FUNCTION 							 \DSPYPOSITION.HDCPYDISPLAY)						       IMSTRINGWIDTH _(FUNCTION 							 \STRINGWIDTH.HDCPYDISPLAY)						       IMCHARWIDTH _(FUNCTION \CHARWIDTH.HDCPYDISPLAY])(\HDCPYDSPPRINTCHAR  [LAMBDA (STREAM CHARCODE)                                  (* rrb "21-Aug-84 10:17")          (* * displays a character on a hardcopy display stream. This uses a display font but updates the x position 	  according to hardcopy widths.)    (PROG ((DD (fetch IMAGEDATA of STREAM)))          (\CHECKCARET STREAM)          (RETURN	    (SELECTC	      (fetch CCECHO of (\SYNCODE \PRIMTERMSA CHARCODE))	      [INDICATE.CCE (PROG ((CC CHARCODE))			          (add (fetch CHARPOSITION of STREAM)				       (IPLUS (COND						((IGREATERP CC 127)                                                             (* META character)						  (\HDCPYBLTCHAR (CHARCODE #)								 STREAM DD)						  (SETQ CC (LOGAND CC 127))						  1)						(T 0))					      (COND						((ILESSP CC 32)                                                             (* CONTROL character)						  (\HDCPYBLTCHAR (CHARCODE ^)								 STREAM DD)						  (SETQ CC (LOGOR CC 64))						  1)						(T 0))					      (PROGN (\HDCPYBLTCHAR CC STREAM DD)						     1]	      [SIMULATE.CCE		(SELCHARQ CHARCODE			  ((EOL CR LF)			    (\DSPPRINTCR/LF CHARCODE STREAM)			    (replace CHARPOSITION of STREAM with 0))			  (ESCAPE (\HDCPYBLTCHAR (CHARCODE $)						 STREAM DD)				  (add (fetch CHARPOSITION of STREAM)				       1))			  [BELL                              (* make switching of bits uninterruptable but allow 							     interrupts between flashes.)				(SELECTQ (MACHINETYPE)					 [DANDELION (PLAYTUNE (QUOTE ((880 . 2500]					 (FLASHWINDOW (WFROMDS STREAM]			  [TAB (PROG (TABWIDTH (SPACEWIDTH (CHARWIDTH (CHARCODE SPACE)								      STREAM)))				     (SETQ TABWIDTH (UNFOLD SPACEWIDTH 8))				     (COND				       ((IGREATERP (\DISPLAYSTREAMINCRXPOSITION						     (SETQ TABWIDTH						       (IDIFFERENCE TABWIDTH								    (MOD (IDIFFERENCE (fetch 										      DDXPOSITION											 of DD)										      (ffetch 										     DDLeftMargin											 of DD))									 TABWIDTH)))						     DD)						   (ffetch DDRightMargin of DD))                                                             (* tab was past rightmargin, force cr.)					 (\DSPPRINTCR/LF (CHARCODE EOL)							 STREAM)))                                                             (* return the number of spaces taken.)				     (add (fetch CHARPOSITION of STREAM)					  (IQUOTIENT TABWIDTH SPACEWIDTH]			  (PROGN                             (* this case was copied from \DSCCOUT.)				 (\HDCPYBLTCHAR CHARCODE STREAM DD)				 (add (fetch CHARPOSITION of STREAM)				      1]	      [REAL.CCE (SELECTC CHARCODE				 ((CHARCODE (EOL CR LF))				   (\DSPPRINTCR/LF CHARCODE STREAM)				   (replace CHARPOSITION of STREAM with 0))				 (ERASECHARCODE (DSPBACKUP (CHARWIDTH (CHARCODE A)								      STREAM)							   STREAM)                                                             (* line buffering routines have already taken care of 							     backing up the position)						0)				 (PROGN (\HDCPYBLTCHAR CHARCODE STREAM DD)					(add (fetch CHARPOSITION of STREAM)					     1]	      (IGNORE.CCE)	      (SHOULDNT])(\SLOWHDCPYBLTCHAR  [LAMBDA (CHARCODE DISPLAYSTREAM)                           (* rrb "21-Aug-84 09:44")          (* * THIS HAS BEEN SEPARATED OUT BUT HASN'T BEEN EDITTED TO DO CORRECT THING WRT UPDATING MICA FIELDS.)                                                             (* case of BLTCHAR where either font is rotated or 							     destination is a color bitmap.							     DISPLAYSTREAM is known to be a hardcopy display stream.)    (PROG (ROTATION (DD (fetch IMAGEDATA of DISPLAYSTREAM)))          (SETQ ROTATION (fetch (FONTDESCRIPTOR ROTATION) of (fetch DDFONT of DD)))          (RETURN	    (COND	      [(EQ 0 ROTATION)		(PROG (NEWX LEFT RIGHT (CURX (ffetch DDXPOSITION of DD)))		      [COND			((IGREATERP (SETQ NEWX (IPLUS CURX (\DSPGETCHARWIDTH CHARCODE DD)))				    (ffetch DDRightMargin of DD))                                                             (* past RIGHT margin, force eol)			  (\DSPPRINTCR/LF (CHARCODE EOL)					  DISPLAYSTREAM)			  (SETQ CURX (ffetch DDXPOSITION of DD))			  (SETQ NEWX (IPLUS CURX (\DSPGETCHARWIDTH CHARCODE DD]                                                             (* update the x position.)		      (freplace DDXPOSITION of DD with NEWX)		      (SETQ CURX (\DSPTRANSFORMX CURX DD))		      (SETQ LEFT (IMAX (ffetch DDClippingLeft of DD)				       CURX))		      (SETQ RIGHT (IMIN (ffetch DDClippingRight of DD)					(\DSPTRANSFORMX NEWX DD)))		      (RETURN (COND				((AND (ILESSP LEFT RIGHT)				      (NEQ (fetch PBTHEIGHT of (SETQ NEWX (ffetch DDPILOTBBT									     of DD)))					   0))				  (SELECTQ (fetch (BITMAP BITMAPBITSPERPIXEL)					      of (ffetch (\DISPLAYDATA DDDestination) of DD))					   (1 (.WHILE.TOP.DS. DISPLAYSTREAM							      (freplace PBTDESTBIT of NEWX								 with LEFT)							      (freplace PBTWIDTH of NEWX								 with (IDIFFERENCE RIGHT LEFT))							      (freplace PBTSOURCEBIT of NEWX								 with (IDIFFERENCE									(IPLUS (\DSPGETCHAROFFSET										 CHARCODE DD)									       LEFT)									CURX))							      (\PILOTBITBLT NEWX 0)))					   (4 (OR (\DDHASFONT DD)						  (\DDSETCOLORFONT DISPLAYSTREAM))					      (.WHILE.TOP.DS.						DISPLAYSTREAM						(freplace PBTDESTBIT of NEWX						   with (SETQ LEFT (LLSH LEFT 2)))						(freplace PBTWIDTH of NEWX						   with (IDIFFERENCE (LLSH RIGHT 2)								     LEFT))						(freplace PBTSOURCEBIT of NEWX						   with (IDIFFERENCE (IPLUS (LLSH (\DSPGETCHAROFFSET										    CHARCODE DD)										  2)									    LEFT)								     (LLSH CURX 2)))						(\PILOTBITBLT NEWX 0)))					   (8 (OR (\DDHASFONT DD)						  (\DDSETCOLORFONT DISPLAYSTREAM))					      (.WHILE.TOP.DS.						DISPLAYSTREAM						(freplace PBTDESTBIT of NEWX						   with (SETQ LEFT (LLSH LEFT 3)))						(freplace PBTWIDTH of NEWX						   with (IDIFFERENCE (LLSH RIGHT 3)								     LEFT))						(freplace PBTSOURCEBIT of NEWX						   with (IDIFFERENCE (IPLUS (LLSH (\DSPGETCHAROFFSET										    CHARCODE DD)										  3)									    LEFT)								     (LLSH CURX 3)))						(\PILOTBITBLT NEWX 0)))					   (SHOULDNT))				  T]	      (T                                             (* handle rotated fonts)		 (PROG ((YPOS (ffetch DDYPOSITION of DD))			(HEIGHTMOVED (\DSPGETCHARWIDTH CHARCODE DD))			(FONT (ffetch DDFONT of DD)))		       (RETURN (COND				 ((EQ ROTATION 90)           (* don't force CR for rotated fonts.)				   (\DSPYPOSITION.DISPLAY DISPLAYSTREAM (IPLUS YPOS HEIGHTMOVED))                                                             (* update the display stream x position.)				   (BITBLT (fetch (FONTDESCRIPTOR CHARACTERBITMAP) of FONT)					   0					   (\DSPGETCHAROFFSET CHARCODE DD)					   DISPLAYSTREAM					   (ADD1 (IDIFFERENCE (ffetch DDXPOSITION of DD)							      (FONTASCENT FONT)))					   YPOS					   (FONTHEIGHT FONT)					   HEIGHTMOVED))				 ((EQ ROTATION 270)				   (\DSPYPOSITION.DISPLAY DISPLAYSTREAM (IDIFFERENCE YPOS HEIGHTMOVED)							  )				   (BITBLT (fetch (FONTDESCRIPTOR CHARACTERBITMAP) of FONT)					   0					   (\DSPGETCHAROFFSET CHARCODE DD)					   DISPLAYSTREAM					   (IDIFFERENCE (ffetch DDXPOSITION of DD)							(FONTDESCENT FONT))					   (ffetch DDYPOSITION of DISPLAYSTREAM)					   (FONTHEIGHT FONT)					   HEIGHTMOVED))				 (T (ERROR "Not implemented to rotate by other than 0, 90 or 270"])(\CHANGECHARSET.HDCPYDISPLAY  [LAMBDA (DISPLAYDATA CHARSET HDCPYDSTREAM)                 (* rrb "11-Oct-85 18:12")          (* Called when the character set information cached in a display stream doesn't correspond to CHARSET Only sets 	  those field that are different from the regular DISPLAY case and uses the regular display case to get the rest.)    (\CHANGECHARSET.DISPLAY DISPLAYDATA CHARSET)    (PROG [(FD (FONTCREATE (ffetch DDFONT of DISPLAYDATA)			       NIL NIL NIL (STREAMPROP HDCPYDSTREAM (QUOTE HARDCOPYIMAGETYPE]                                                             (* For now, use a streamprop instead of a special 							     field in the dispay data)                                                             (* Scale widths to micas, so we don't have to fetch 							     the constants to scale by for every char we print)	    (replace DDCHARIMAGEWIDTHS of DISPLAYDATA	       with (PROG (W OLDWIDTH (SCALE (FONTPROP FD (QUOTE SCALE)))				 (CSINFO (\GETCHARSETINFO CHARSET FD)))			      (SETQ OLDWIDTH (fetch (CHARSETINFO WIDTHS) of CSINFO))			      (COND				((EQP SCALE (CONSTANT MICASPERPT))				  (RETURN OLDWIDTH)))			      (SETQ W (\CREATECSINFOELEMENT))			      (SETQ SCALE (FQUOTIENT (CONSTANT MICASPERPT)							 SCALE))			      [for I from 0 to \MAXTHINCHAR				 do (\FSETWIDTH W I (FIXR (FTIMES (\FGETWIDTH OLDWIDTH I)									SCALE]			      (RETURN W]))(DECLARE: DONTCOPY DOEVAL@COMPILE (DECLARE: EVAL@COMPILE (RPAQ MICASPERPT (FQUOTIENT 2540 72))(RPAQQ IHALFMICASPERPT 17)(RPAQQ IMICASPERPT 35)(CONSTANTS (MICASPERPT (FQUOTIENT 2540 72))	   (IHALFMICASPERPT 17)	   (IMICASPERPT 35))))(DECLARE: DONTEVAL@LOAD DOCOPY (\HDCPYDISPLAYINIT))(* Stuff to support MICA-unit hardcopy streams on the display)(DEFINEQ(MAKEHARDCOPYMODESTREAM  [LAMBDA (DISPLAYSTREAM IMAGETYPE)                          (* bvm: "17-Sep-85 18:09")          (* * Creates a hardcopy-mode display stream from a normal one. That stream operates in units of micas, but displays 	  on the screen as usual.)    (DECLARE (GLOBALVARS \HCPYMODEDISPLAYIMAGEOPS.PRESS \HCPYMODEDISPLAYIMAGEOPS.INTERPRESS))    (PROG [(DS (COND		 ((DISPLAYSTREAMP DISPLAYSTREAM))		 ((WINDOWP DISPLAYSTREAM)		   (WINDOWPROP DISPLAYSTREAM (QUOTE DSP)))		 ((NULL DISPLAYSTREAM)		   (DSPCREATE))		 (T (\ILLEGAL.ARG DISPLAYSTREAM]          (SELECTQ [OR IMAGETYPE (SETQ IMAGETYPE (CAR (PRINTERPROP (PRINTERTYPE)								   (QUOTE CANPRINT]		   (PRESS                                    (* Give the stream PRESS-style imageops, so it will 							     deal with press fonts right.)			  (replace (STREAM IMAGEOPS) of DS with \HCPYMODEDISPLAYIMAGEOPS.PRESS))		   (INTERPRESS                               (* Give the stream INTERPRESS-style operations, so it 							     will deal with Interpress fonts right.)			       (replace (STREAM IMAGEOPS) of DS with 							      \HCPYMODEDISPLAYIMAGEOPS.INTERPRESS))		   NIL)          (STREAMPROP DS (QUOTE HARDCOPYIMAGETYPE)		      IMAGETYPE)                             (* set the bout fn to one that updates the mica fields 							     and sets the position from them.)          (replace (STREAM STRMBOUTFN) of DS with (FUNCTION \HCPYMODEDSPPRINTCHAR))                                                             (* Set the character-printing functions for the stream 							     to the hardcopy-mode ones.)          (replace (STREAM OUTCHARFN) of DS with (FUNCTION \HCPYMODEDSPPRINTCHAR))          (* * set the parameters that are different to initialize the mica defined fields.)          (DSPFONT (DSPFONT NIL DS)		   DS)                                       (* Hardcopy version of the current font...)          (DSPXPOSITION 0 DS)                                (* Reset the X and Y positions to 0)          (DSPYPOSITION 0 DS)          (DSPRIGHTMARGIN (FIXR (FTIMES (OR (DSPRIGHTMARGIN NIL DS)					    (fetch WIDTH of (DSPCLIPPINGREGION NIL DS)))					MICASPERPT))			  DS)                                (* And reuse the right margin)          (RETURN DS])(UNMAKEHARDCOPYMODESTREAM  [LAMBDA (DISPLAYSTREAM)                                    (* jds " 6-Jan-85 14:59")          (* * returns a hardcopy stream to a display stream.)    (DECLARE (GLOBALVARS \DISPLAYIMAGEOPS))    (PROG [(DS (COND		 ((DISPLAYSTREAMP DISPLAYSTREAM))		 ((WINDOWP DISPLAYSTREAM)		   (WINDOWPROP DISPLAYSTREAM (QUOTE DSP)))		 (T (\ILLEGAL.ARG DISPLAYSTREAM]          (COND	    ((FMEMB (QUOTE HARDCOPY)		    (IMAGESTREAMTYPE DS))                    (* Make sure the stream really WAS a hardcopy-mode 							     stream.)	      )	    (T                                               (* It wasn't a hardcopy-mode stream.							     Don't make any changes)	       (RETURN DS)))          (replace (STREAM IMAGEOPS) of DS with \DISPLAYIMAGEOPS)                                                             (* Give it back the usual operations)          (STREAMPROP DS (QUOTE HARDCOPYIMAGETYPE)		      NIL)                                   (* restore the bout fn)          (replace (STREAM STRMBOUTFN) of DS with (FUNCTION \DSPPRINTCHAR))          (replace (STREAM OUTCHARFN) of DS with (FUNCTION \DSPPRINTCHAR))          (DSPXPOSITION 0 DS)          (DSPYPOSITION 0 DS)          (DSPRIGHTMARGIN (FIXR (FQUOTIENT (DSPRIGHTMARGIN NIL DS)					   MICASPERPT))			  DS)                                (* Convert the right margin back into points.)          (RETURN DS])(\BLTSHADE.HCPYMODE  [LAMBDA (TEXTURE STREAM DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT OPERATION CLIPPINGREGION)                                                             (* jds " 6-Jan-85 14:59")                                                             (* BLTSHADE to a hardcopy-mode dispolay stream)                                                             (* Just convert the coordinates and do the normal 							     display thing.)    (\BLTSHADE.1BITDISPLAY TEXTURE STREAM (\MICASTOPTS DESTINATIONLEFT)			   (\MICASTOPTS DESTINATIONBOTTOM)			   WIDTH HEIGHT OPERATION (\DASHINGCONVERT.HCPYMODE CLIPPINGREGION])(\BITBLT.HCPYMODE  [LAMBDA (SOURCEBITMAP SOURCELEFT SOURCEBOTTOM DESTSTRM DESTINATIONLEFT DESTINATIONBOTTOM WIDTH 			HEIGHT SOURCETYPE OPERATION TEXTURE CLIPPINGREGION CLIPPEDSOURCELEFT 			CLIPPEDSOURCEBOTTOM)                 (* jds " 6-Jan-85 15:01")                                                             (* BITBLT to a hardcopy-mode display stream.							     Convert the destination coordinates to micas and do the							     normal operation.)    (\BITBLT.1BITDISPLAY SOURCEBITMAP SOURCELEFT SOURCEBOTTOM DESTSTRM (\MICASTOPTS DESTINATIONLEFT)			 (\MICASTOPTS DESTINATIONBOTTOM)			 WIDTH HEIGHT SOURCETYPE OPERATION TEXTURE (\DASHINGCONVERT.HCPYMODE 										   CLIPPINGREGION)			 CLIPPEDSOURCELEFT CLIPPEDSOURCEBOTTOM])(\BRUSHCONVERT.HCPYMODE  [LAMBDA (BRUSH)                                            (* jds " 6-Jan-85 15:02")                                                             (* Convert a brush description from points to micas)    (COND      ((LISTP BRUSH)	(FOR BB IN BRUSH COLLECT (COND				   ((NUMBERP BB)				     (\MICASTOPTS BB))				   (T BB])(\CHANGECHARSET.HCPYMODE  [LAMBDA (DISPLAYDATA CHARSET)                              (* jds " 7-Jun-85 10:04")                                                             (* Called when the character set information cached in 							     a display stream doesn't correspond to CHARSET)    (PROG [BM (PBT (ffetch DDPILOTBBT of DISPLAYDATA))	      (CSINFO (\GETCHARSETINFO CHARSET (ffetch DDFONT of DISPLAYDATA]          (UNINTERRUPTABLY              (freplace DDWIDTHSCACHE of DISPLAYDATA with (ffetch (CHARSETINFO WIDTHS) of CSINFO))	      (freplace DDOFFSETSCACHE of DISPLAYDATA with (ffetch (CHARSETINFO OFFSETS)							      of CSINFO))	      (freplace DDCHARIMAGEWIDTHS of DISPLAYDATA with (ffetch (CHARSETINFO IMAGEWIDTHS)								 of CSINFO))	      (freplace DDCHARSET of DISPLAYDATA with CHARSET)	      (SETQ BM (ffetch CHARSETBITMAP of CSINFO))	      (freplace PBTSOURCEBPL of PBT with (UNFOLD (ffetch BITMAPRASTERWIDTH of BM)							 BITSPERWORD))	      [COND		((OR (NEQ (ffetch DDCHARSETASCENT of DISPLAYDATA)			  (ffetch CHARSETASCENT of CSINFO))		     (NEQ (ffetch DDCHARSETDESCENT of DISPLAYDATA)			  (ffetch CHARSETDESCENT of CSINFO)))		  (\SFFixY.HCPYMODE DISPLAYDATA CSINFO))		(T (freplace PBTSOURCE of PBT with (\ADDBASE (ffetch BITMAPBASE of BM)							     (ITIMES (ffetch BITMAPRASTERWIDTH									of BM)								     (ffetch DDCHARHEIGHTDELTA									of DISPLAYDATA])])(\DASHINGCONVERT.HCPYMODE  [LAMBDA (DASHING)                                          (* jds " 6-Jan-85 15:02")          (* Convert a list of numbers from micas to points. Usually this will be a dashing spec, but it might be a REGION as 	  well.)    (FOR DD IN DASHING COLLECT (\MICASTOPTS DD])(\CHARWIDTH.HCPYMODE  [LAMBDA (STREAM CHARCODE)                                  (* jds " 3-Jan-85 12:55")                                                             (* gets the width of a character code in a hardcopy 							     stream. Should be updated for spacefactor)    (\FGETWIDTH (ffetch (\DISPLAYDATA DDCHARIMAGEWIDTHS) of (fetch IMAGEDATA of STREAM))		CHARCODE])(\DRAWLINE.HCPYMODE  [LAMBDA (STREAM X1 Y1 X2 Y2 WIDTH OPERATION COLOR)         (* jds " 6-Jan-85 15:03")                                                             (* Do DRAWLINE for a hardcopy-mode display stream.)    (\DRAWLINE.DISPLAY STREAM (\MICASTOPTS X1)		       (\MICASTOPTS Y1)		       (\MICASTOPTS X2)		       (\MICASTOPTS Y2)		       (IMAX 1 (\MICASTOPTS WIDTH))		       OPERATION COLOR])(\DRAWCURVE.HCPYMODE  [LAMBDA (STREAM KNOTS CLOSED BRUSH DASHING)                (* jds " 6-Jan-85 15:04")                                                             (* Do DRAWCURVE for a hardcopy-mode displaystream.							     Converts all the mica values to points and uses the 							     usual display version.)    (\DRAWCURVE.DISPLAY STREAM [FOR KNOT IN KNOTS COLLECT (CONS (\MICASTOPTS (CAR KNOT))								(\MICASTOPTS (CDR KNOT]			CLOSED			(\BRUSHCONVERT.HCPYMODE BRUSH)			(\DASHINGCONVERT.HCPYMODE DASHING])(\DRAWCIRCLE.HCPYMODE  [LAMBDA (STREAM CENTERX CENTERY RADIUS BRUSH DASHING)      (* jds " 6-Jan-85 15:04")                                                             (* DRAWCIRCLE for a hardcopy-mode display stream.							     Convert coordinates to points and use the display 							     driver)    (\DRAWCIRCLE.DISPLAY STREAM (\MICASTOPTS CENTERX)			 (\MICASTOPTS CENTERY)			 (\MICASTOPTS RADIUS)			 (\BRUSHCONVERT.HCPYMODE BRUSH)			 (\DASHINGCONVERT.HCPYMODE DASHING])(\DRAWELLIPSE.HCPYMODE  [LAMBDA (STREAM CENTERX CENTERY SEMIMINORRADIUS SEMIMAJORRADIUS ORIENTATION BRUSH DASHING)                                                             (* jds " 6-Jan-85 15:06")                                                             (* DRAWELLIPSE driver for hardcopy-mode displaystreams.							     Convert all the values to points from micas, and use 							     the display DRAWELLIPSE.)    (\DRAWELLIPSE.DISPLAY STREAM (\MICASTOPTS CENTERX)			  (\MICASTOPTS CENTERY)			  (\MICASTOPTS SEMIMINORRADIUS)			  (\MICASTOPTS SEMIMAJORRADIUS)			  ORIENTATION			  (\BRUSHCONVERT.HCPYMODE BRUSH)			  (\DASHINGCONVERT.HCPYMODE DASHING])(\DSPFONT.HCPYMODE  [LAMBDA (HDCPYDSTREAM FONT)                                (* jds " 7-Jun-85 13:13")          (* changes the font of a hardcopy display stream. Does what the display does then puts the hardcopy widths where 	  they can be found {FOR NOW USE THE DDCHARIMAGEWIDTHS FIELD})    (PROG (XFONT OLDFONT (DD (fetch IMAGEDATA of HDCPYDSTREAM)))                                                             (* save old value to return, smash new value and update							     the bitchar portion of the record.)          (RETURN (PROG1 (SETQ OLDFONT (fetch DDFONT of DD))			 (COND			   (FONT (SETQ XFONT (OR (\GETFONTDESC FONT (fetch IMFONTCREATE								       of (fetch IMAGEOPS									     of HDCPYDSTREAM))							       T)						 (FONTCOPY (ffetch DDFONT of DD)							   FONT)))                                                             (* updating font information is fairly expensive 							     operation. Don't bother unless font has changed.)				 (OR (EQ XFONT OLDFONT)				     (UNINTERRUPTABLY                                         (freplace DDFONT of DD with XFONT)					 (freplace DDLINEFEED of DD					    with (IMINUS (fetch \SFHeight of XFONT)))                                                             (* Each line moves down by the font height, by default)					 (freplace DDSPACEWIDTH of DD with (\FGETCHARWIDTH									     XFONT									     (CHARCODE SPACE)))					 (\SFFixFont HDCPYDSTREAM DD)                                                             (* Fix up the font-dependent fields of the 							     DISPLAYSTREAM)					 )])(\DSPLEFTMARGIN.HCPYMODE  [LAMBDA (DISPLAYSTREAM XPOSITION)                          (* jds " 6-Jan-85 15:09")          (* * Sets the left margin that determines when a cr is inserted by print for the hardcopy display stream.)          (* * Sets the left margin for a hardcopy-mode displaystream, to determine where CR returns you to.)    (PROG1 [\DSPRIGHTMARGIN.DISPLAY DISPLAYSTREAM (AND XPOSITION (FIXR (FQUOTIENT XPOSITION 										  MICASPERPT]                                                             (* LATER, WHEN DDLEFTMARGINMICA EXISTS...							     (AND XPOSITION (replace (\DISPLAYDATA 							     DDMICARIGHTMARGIN) of (fetch IMAGEDATA of 							     DISPLAYSTREAM) with XPOSITION)))	   ])(\DSPLINEFEED.HCPYMODE  [LAMBDA (DISPLAYSTREAM DELTAY)                             (* jds " 6-Jan-85 15:10")                                                             (* For a hardcopy-mode displaystream, sets the amount 							     that a line feed increases the y coordinate by.)    (PROG ((DD (fetch IMAGEDATA of DISPLAYSTREAM)))          (RETURN (PROG1 (ffetch DDLINEFEED of DD)           (* Return the old value.)			 (AND DELTAY (COND				((NUMBERP DELTAY)				  (freplace DDLINEFEED of DD with DELTAY))				(T (\ILLEGAL.ARG DELTAY])(\DSPRIGHTMARGIN.HCPYMODE  [LAMBDA (DISPLAYSTREAM XPOSITION)                          (* jds " 6-Jan-85 15:13")          (* * Sets the right margin that determines when a cr is inserted by print for the hardcopy display stream.)    (PROG1 (fetch (\DISPLAYDATA DDMICARIGHTMARGIN) of (fetch IMAGEDATA of DISPLAYSTREAM))                                                             (* Return the old mica value.)	   [\DSPRIGHTMARGIN.DISPLAY DISPLAYSTREAM (AND XPOSITION (FIXR (FQUOTIENT XPOSITION 										  MICASPERPT]                                                             (* Set the right margin in display units,)	   (AND XPOSITION (replace (\DISPLAYDATA DDMICARIGHTMARGIN) of (fetch IMAGEDATA of 										    DISPLAYSTREAM)			     with XPOSITION))                (* And set the new mica value)	   ])(\DSPXPOSITION.HCPYMODE  [LAMBDA (HARDCOPYSTREAM XPOSITION)                         (* jds " 6-Jan-85 15:12")                                                             (* Update the X position for a mica-unit hardcopy-mode 							     displaystream)    (PROG1 (fetch (\DISPLAYDATA DDXPOSITION) of (fetch IMAGEDATA of HARDCOPYSTREAM))                                                             (* Return the old value...)	   [\DSPXPOSITION.DISPLAY HARDCOPYSTREAM (AND XPOSITION (FIXR (FQUOTIENT XPOSITION MICASPERPT]                                                             (* Set up the display right for this mica value)	   (AND XPOSITION (replace (\DISPLAYDATA DDXPOSITION) of (fetch IMAGEDATA of HARDCOPYSTREAM)			     with XPOSITION))                (* And remember what it was.)	   ])(\DSPYPOSITION.HCPYMODE  [LAMBDA (HARDCOPYSTREAM YPOSITION)                         (* jds " 7-Jun-85 14:04")                                                             (* Move to a new mica Y position)    (PROG ((DD (fetch IMAGEDATA of HARDCOPYSTREAM)))          (RETURN (PROG1 (ffetch DDYPOSITION of DD)          (* Return the old value first.)			 (COND			   ((NULL YPOSITION))			   ((NUMBERP YPOSITION)			     (UNINTERRUPTABLY                                 (freplace DDYPOSITION of DD with YPOSITION))			     (\INVALIDATEDISPLAYCACHE DD))			   (T (\ILLEGAL.ARG YPOSITION])(\MOVETO.HCPYMODE  [LAMBDA (STREAM X Y)                                       (* jds " 3-Jan-85 13:18")    (\DSPXPOSITION.HCPYMODE STREAM X)    (\DSPYPOSITION.HCPYMODE STREAM Y])(\FONTCREATE.HCPYMODE.PRESS  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)                 (* jds " 7-Jun-85 13:29")                                                             (* Create a font descriptor for a display stream that 							     is mimicing a PRESS device)    (PROG* ((DFONT (FONTCREATE FAMILY SIZE FACE ROTATION (QUOTE DISPLAY)))	    [HFONT (create FONTDESCRIPTOR using (FONTCREATE FAMILY SIZE FACE ROTATION (QUOTE PRESS]	    (CS0INFO (\GETCHARSETINFO 0 HFONT)))           (replace OTHERDEVICEFONTPROPS of HFONT with (LIST (QUOTE WIDTHS)							     (fetch \SFWidths of DFONT)							     (QUOTE ASCENT)							     (fetch \SFAscent of DFONT)							     (QUOTE DESCENT)							     (fetch \SFDescent of DFONT)							     (QUOTE HEIGHT)							     (fetch \SFHeight of DFONT)))                                                             (* Cache the DISPLAY info, for the various X- and 							     Y-position updating tasks that affect the display 							     bitmap itself)           (replace \SFOffsets of HFONT with (fetch \SFOffsets of DFONT))                                                             (* Fill in the right offsets from the display 							     font--into the hcpy font, and its Charset-0 info block)           (replace (CHARSETINFO OFFSETS) of CS0INFO with (fetch (ARRAYP BASE)							     of (fetch \SFOffsets of DFONT)))           (replace CHARACTERBITMAP of HFONT with (fetch CHARACTERBITMAP of DFONT))                                                             (* Likewise the character rasters)           (replace (CHARSETINFO CHARSETBITMAP) of CS0INFO with (fetch CHARACTERBITMAP of DFONT))           (replace FONTIMAGEWIDTHS of HFONT with (fetch \SFWidths of DFONT))                                                             (* And the raster widths (as distinct from the nominal 							     mica widths))           (replace (CHARSETINFO IMAGEWIDTHS) of CS0INFO with (fetch (ARRAYP BASE)								 of (fetch \SFWidths of DFONT)))           (replace FONTDEVICE of HFONT with (QUOTE PRESSDISPLAY))           (RETURN HFONT])(\FONTCREATE.HCPYMODE.INTERPRESS  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)                 (* jds " 7-Jun-85 15:19")                                                             (* Create a font descriptor for a display stream that 							     is mimicing an INTERPRESS device)    (PROG* ((DFONT (FONTCREATE FAMILY SIZE FACE ROTATION (QUOTE DISPLAY)))	    [HFONT (create FONTDESCRIPTOR using (FONTCREATE FAMILY SIZE FACE ROTATION (QUOTE 										       INTERPRESS]	    (CS0INFO (\GETCHARSETINFO 0 HFONT)))           (replace OTHERDEVICEFONTPROPS of HFONT with (LIST (QUOTE WIDTHS)							     (fetch \SFWidths of DFONT)							     (QUOTE ASCENT)							     (fetch \SFAscent of DFONT)							     (QUOTE DESCENT)							     (fetch \SFDescent of DFONT)							     (QUOTE HEIGHT)							     (fetch \SFHeight of DFONT)))                                                             (* Cache the DISPLAY info, for the various X- and 							     Y-position updating tasks that affect the display 							     bitmap itself)           (replace \SFOffsets of HFONT with (fetch \SFOffsets of DFONT))                                                             (* Fill in the right offsets from the display 							     font--into the hcpy font, and its Charset-0 info block)           (replace (CHARSETINFO OFFSETS) of CS0INFO with (fetch (ARRAYP BASE)							     of (fetch \SFOffsets of DFONT)))           (replace CHARACTERBITMAP of HFONT with (fetch CHARACTERBITMAP of DFONT))                                                             (* Likewise the character rasters)           (replace (CHARSETINFO CHARSETBITMAP) of CS0INFO with (fetch CHARACTERBITMAP of DFONT))           (replace FONTIMAGEWIDTHS of HFONT with (fetch \SFWidths of DFONT))                                                             (* And the raster widths (as distinct from the nominal 							     mica widths))           (replace (CHARSETINFO IMAGEWIDTHS) of CS0INFO with (fetch (ARRAYP BASE)								 of (fetch \SFWidths of DFONT)))           (replace FONTDEVICE of HFONT with (QUOTE INTERPRESSDISPLAY))           (RETURN HFONT])(\STRINGWIDTH.HCPYMODE  [LAMBDA (STREAM STR RDTBL)                                 (* rmk: "12-Sep-84 11:11")                                                             (* Returns the width of for the current 							     font/spacefactor in hardcopy stream STREAM.)    (PROG (WIDTHSBASE)          (RETURN (IQUOTIENT (IPLUS (\STRINGWIDTH.GENERIC STR (SETQ WIDTHSBASE							    (ffetch (\DISPLAYDATA DDCHARIMAGEWIDTHS)							       of (ffetch IMAGEDATA of STREAM)))							  RDTBL							  (\FGETWIDTH WIDTHSBASE (CHARCODE SPACE)))				    (CONSTANT IHALFMICASPERPT))			     (CONSTANT IMICASPERPT])(\HCPYMODEBLTCHAR  [LAMBDA (CHARCODE DISPLAYSTREAM DISPLAYDATA)               (* jds " 7-Jun-85 14:43")          (* puts a character on a hardcopy display stream. Much of the information needed by the BitBlt microcode is 	  prestored by the routines that change it. This is kept in the BitBltTable.)                                                             (* knows about the representation of a DisplayStream.)    (DECLARE (LOCALVARS . T))    (PROG (LOCAL1 RIGHT LEFT CURX MICARIGHT (CHAR8CODE (\CHAR8CODE CHARCODE)))      CRLP[COND	    ((NEQ (ffetch DDCHARSET of DISPLAYDATA)		  (\CHARSET CHARCODE))	      (\CHANGECHARSET.HCPYMODE DISPLAYDATA (\CHARSET CHARCODE]          [COND	    ((ffetch (\DISPLAYDATA DDSlowPrintingCase) of DISPLAYDATA)	      (RETURN (\SLOWHCPYMODEBLTCHAR CHARCODE DISPLAYSTREAM]          (SETQ CURX (FIXR (FQUOTIENT (ffetch DDXPOSITION of DISPLAYDATA)				      MICASPERPT)))          (* Convert the mica-position value to points only at 							     the last minute.)          [COND	    ((IGREATERP (SETQ MICARIGHT (IPLUS (ffetch (\DISPLAYDATA DDXPOSITION) of DISPLAYDATA)					       (\DSPGETCHARWIDTH CHAR8CODE DISPLAYDATA)))			(ffetch (\DISPLAYDATA DDMICARIGHTMARGIN) of DISPLAYDATA))                                                             (* would go past right margin, force a cr)	      (COND		((IGREATERP CURX (ffetch DDLeftMargin of DISPLAYDATA))                                                             (* don't bother CR if position is at left margin 							     anyway. This also serves to break the loop.)		  (\DSPPRINTCR/LF (CHARCODE EOL)				  DISPLAYSTREAM)             (* reuse the code in the test of this conditional 							     rather than repeat it here.)		  (GO CRLP]          (freplace (\DISPLAYDATA DDXPOSITION) of DISPLAYDATA with MICARIGHT)                                                             (* update the display stream x position.							     Make sure that there is at least one point width for 							     each character.)          [SETQ CURX (IPLUS CURX (SETQ LOCAL1 (ffetch DDXOFFSET of DISPLAYDATA]                                                             (* Screen position of the window, generally.)          (SETQ RIGHT (IPLUS CURX (\FGETWIDTH (ffetch DDCHARIMAGEWIDTHS of DISPLAYDATA)					      CHARCODE)))    (* Right edge of the character's image.)          (COND	    ((IGREATERP RIGHT (SETQ LOCAL1 (ffetch DDClippingRight of DISPLAYDATA)))                                                             (* character overlaps right edge of clipping region.)	      (SETQ RIGHT LOCAL1)))          (SETQ LEFT (COND	      ((IGREATERP CURX (SETQ LOCAL1 (ffetch DDClippingLeft of DISPLAYDATA)))		CURX)	      (T LOCAL1)))                                   (* Left edge of the character, as displayed.)          (RETURN (COND		    ((AND (ILESSP LEFT RIGHT)			  (NEQ (fetch PBTHEIGHT of (SETQ LOCAL1 (ffetch DDPILOTBBT of DISPLAYDATA)))			       0))                           (* If the character will appear on screen at all, let's							     display it.)		      (.WHILE.TOP.DS. DISPLAYSTREAM (freplace PBTDESTBIT of LOCAL1 with LEFT)                                                             (* Set up the destination bit with the screen-relative 							     left edge)				      (freplace PBTWIDTH of LOCAL1 with (IDIFFERENCE RIGHT LEFT))                                                             (* The display width from the clipped left and right 							     edges)				      (freplace PBTSOURCEBIT of LOCAL1					 with (IDIFFERENCE (IPLUS (\DSPGETCHAROFFSET CHAR8CODE 										     DISPLAYDATA)								  LEFT)							   CURX))                                                             (* And the source bit-offset from the OFFSETs array)				      (\PILOTBITBLT LOCAL1 0)                                                             (* Do the BITBLT)				      )		      T])(\HCPYMODEDISPLAYINIT  [LAMBDA NIL                                                (* jds " 4-Jan-85 20:32")          (* * Initializes global variables for the hardcopy Display device. This device appears to the user as an INTERPRESS 	  or PRESS device meaning units in micas but outputs to the screen. Much of this code was borrowed from the display 	  case.)    (DECLARE (GLOBALVARS \HCPYMODEDISPLAYIMAGEOPS.PRESS \HCPYMODEDISPLAYIMAGEOPS.INTERPRESS))    [SETQ \HCPYMODEDISPLAYIMAGEOPS.PRESS (create IMAGEOPS using \DISPLAYIMAGEOPS IMAGETYPE _(QUOTE								  (HARDCOPY DISPLAY))								IMFONT _(FUNCTION \DSPFONT.HCPYMODE)								IMRIGHTMARGIN _(FUNCTION 								  \DSPRIGHTMARGIN.HCPYMODE)								IMLEFTMARGIN _(FUNCTION 								  \DSPLEFTMARGIN.HCPYMODE)								IMLINEFEED _(FUNCTION 								  \DSPLINEFEED.HCPYMODE)								IMDRAWLINE _(FUNCTION 								  \DRAWLINE.HCPYMODE)								IMDRAWCURVE _(FUNCTION 								  \DRAWCURVE.HCPYMODE)								IMDRAWCIRCLE _(FUNCTION 								  \DRAWCIRCLE.HCPYMODE)								IMDRAWELLIPSE _(FUNCTION 								  \DRAWELLIPSE.HCPYMODE)								IMFILLCIRCLE _(FUNCTION 								  \FILLCIRCLE.HCPYMODE)								IMBLTSHADE _(FUNCTION 								  \BLTSHADE.HCPYMODE)								IMBITBLT _(FUNCTION \BITBLT.HCPYMODE)								IMXPOSITION _(FUNCTION 								  \DSPXPOSITION.HCPYMODE)								IMYPOSITION _(FUNCTION 								  \DSPYPOSITION.HCPYMODE)								IMMOVETO _(FUNCTION \MOVETO.HCPYMODE)								IMSTRINGWIDTH _(FUNCTION 								  \STRINGWIDTH.HCPYMODE)								IMCHARWIDTH _(FUNCTION 								  \CHARWIDTH.HCPYMODE)								IMFONTCREATE _(FUNCTION PRESSDISPLAY)								IMSCALE _[FUNCTION (LAMBDA NIL								    (CONSTANT (FQUOTIENT MICASPERINCH 											 72]								IMNEWPAGE _(FUNCTION (LAMBDA (STREAM)								    (PAGEFULLFN STREAM)								    (CLEARW STREAM]    (SETQ \HCPYMODEDISPLAYIMAGEOPS.INTERPRESS (create IMAGEOPS using \DISPLAYIMAGEOPS IMAGETYPE _(								       QUOTE (HARDCOPY DISPLAY))								     IMFONT _(FUNCTION 								       \DSPFONT.HCPYMODE)								     IMRIGHTMARGIN _(FUNCTION 								       \DSPRIGHTMARGIN.HCPYMODE)								     IMLEFTMARGIN _(FUNCTION 								       \DSPLEFTMARGIN.HCPYMODE)								     IMLINEFEED _(FUNCTION 								       \DSPLINEFEED.HCPYMODE)								     IMDRAWLINE _(FUNCTION 								       \DRAWLINE.HCPYMODE)								     IMDRAWCURVE _(FUNCTION 								       \DRAWCURVE.HCPYMODE)								     IMDRAWCIRCLE _(FUNCTION 								       \DRAWCIRCLE.HCPYMODE)								     IMDRAWELLIPSE _(FUNCTION 								       \DRAWELLIPSE.HCPYMODE)								     IMFILLCIRCLE _(FUNCTION 								       \FILLCIRCLE.HCPYMODE)								     IMBLTSHADE _(FUNCTION 								       \BLTSHADE.HCPYMODE)								     IMBITBLT _(FUNCTION 								       \BITBLT.HCPYMODE)								     IMXPOSITION _(FUNCTION 								       \DSPXPOSITION.HCPYMODE)								     IMYPOSITION _(FUNCTION 								       \DSPYPOSITION.HCPYMODE)								     IMMOVETO _(FUNCTION 								       \MOVETO.HCPYMODE)								     IMSTRINGWIDTH _(FUNCTION 								       \STRINGWIDTH.HCPYMODE)								     IMCHARWIDTH _(FUNCTION 								       \CHARWIDTH.HCPYMODE)								     IMFONTCREATE _(FUNCTION 								       INTERPRESSDISPLAY)								     IMSCALE _[FUNCTION (LAMBDA NIL									 (CONSTANT (FQUOTIENT 										     MICASPERINCH 72]								     IMNEWPAGE _(FUNCTION (LAMBDA (									   STREAM)									 (PAGEFULLFN STREAM)									 (CLEARW STREAM])(\HCPYMODEDSPPRINTCHAR  [LAMBDA (STREAM CHARCODE)                                  (* jds " 3-Jan-85 12:53")          (* * displays a character on a hardcopy display stream. This uses a display font but updates the x position 	  according to hardcopy widths.)    (PROG ((DD (fetch IMAGEDATA of STREAM)))          (\CHECKCARET STREAM)          (RETURN	    (SELECTC	      (fetch CCECHO of (\SYNCODE \PRIMTERMSA CHARCODE))	      [INDICATE.CCE (PROG ((CC CHARCODE))			          (add (fetch CHARPOSITION of STREAM)				       (IPLUS (COND						((IGREATERP CC 127)                                                             (* META character)						  (\HCPYMODEBLTCHAR (CHARCODE #)								    STREAM DD)						  (SETQ CC (LOGAND CC 127))						  1)						(T 0))					      (COND						((ILESSP CC 32)                                                             (* CONTROL character)						  (\HCPYMODEBLTCHAR (CHARCODE ^)								    STREAM DD)						  (SETQ CC (LOGOR CC 64))						  1)						(T 0))					      (PROGN (\HCPYMODEBLTCHAR CC STREAM DD)						     1]	      [SIMULATE.CCE		(SELCHARQ CHARCODE			  ((EOL CR LF)			    (\DSPPRINTCR/LF CHARCODE STREAM)			    (replace CHARPOSITION of STREAM with 0))			  (ESCAPE (\HCPYMODEBLTCHAR (CHARCODE $)						    STREAM DD)				  (add (fetch CHARPOSITION of STREAM)				       1))			  [BELL                              (* make switching of bits uninterruptable but allow 							     interrupts between flashes.)				(SELECTQ (MACHINETYPE)					 [DANDELION (PLAYTUNE (QUOTE ((880 . 2500]					 (FLASHWINDOW (WFROMDS STREAM]			  [TAB (PROG (TABWIDTH (SPACEWIDTH (CHARWIDTH (CHARCODE SPACE)								      STREAM)))				     (SETQ TABWIDTH (UNFOLD SPACEWIDTH 8))				     (COND				       ((IGREATERP (\DISPLAYSTREAMINCRXPOSITION						     (SETQ TABWIDTH						       (IDIFFERENCE TABWIDTH								    (MOD (IDIFFERENCE (fetch 										      DDXPOSITION											 of DD)										      (ffetch 										     DDLeftMargin											 of DD))									 TABWIDTH)))						     DD)						   (ffetch DDRightMargin of DD))                                                             (* tab was past rightmargin, force cr.)					 (\DSPPRINTCR/LF (CHARCODE EOL)							 STREAM)))                                                             (* return the number of spaces taken.)				     (add (fetch CHARPOSITION of STREAM)					  (IQUOTIENT TABWIDTH SPACEWIDTH]			  (PROGN                             (* this case was copied from \DSCCOUT.)				 (\HCPYMODEBLTCHAR CHARCODE STREAM DD)				 (add (fetch CHARPOSITION of STREAM)				      1]	      [REAL.CCE (SELECTC CHARCODE				 ((CHARCODE (EOL CR LF))				   (\DSPPRINTCR/LF CHARCODE STREAM)				   (replace CHARPOSITION of STREAM with 0))				 (ERASECHARCODE (DSPBACKUP (CHARWIDTH (CHARCODE A)								      STREAM)							   STREAM)                                                             (* line buffering routines have already taken care of 							     backing up the position)						0)				 (PROGN (\HCPYMODEBLTCHAR CHARCODE STREAM DD)					(add (fetch CHARPOSITION of STREAM)					     1]	      (IGNORE.CCE)	      (SHOULDNT])(\SLOWHCPYMODEBLTCHAR  [LAMBDA (CHARCODE DISPLAYSTREAM)                           (* rrb "21-Aug-84 09:44")          (* * THIS HAS BEEN SEPARATED OUT BUT HASN'T BEEN EDITTED TO DO CORRECT THING WRT UPDATING MICA FIELDS.)                                                             (* case of BLTCHAR where either font is rotated or 							     destination is a color bitmap.							     DISPLAYSTREAM is known to be a hardcopy display 							     stream.)    (PROG (ROTATION (DD (fetch IMAGEDATA of DISPLAYSTREAM)))          (SETQ ROTATION (fetch (FONTDESCRIPTOR ROTATION) of (fetch DDFONT of DD)))          (RETURN	    (COND	      [(EQ 0 ROTATION)		(PROG (NEWX LEFT RIGHT (CURX (ffetch DDXPOSITION of DD)))		      [COND			((IGREATERP (SETQ NEWX (IPLUS CURX (\DSPGETCHARWIDTH CHARCODE DD)))				    (ffetch DDRightMargin of DD))                                                             (* past RIGHT margin, force eol)			  (\DSPPRINTCR/LF (CHARCODE EOL)					  DISPLAYSTREAM)			  (SETQ CURX (ffetch DDXPOSITION of DD))			  (SETQ NEWX (IPLUS CURX (\DSPGETCHARWIDTH CHARCODE DD]                                                             (* update the x position.)		      (freplace DDXPOSITION of DD with NEWX)		      (SETQ CURX (\DSPTRANSFORMX CURX DD))		      (SETQ LEFT (IMAX (ffetch DDClippingLeft of DD)				       CURX))		      (SETQ RIGHT (IMIN (ffetch DDClippingRight of DD)					(\DSPTRANSFORMX NEWX DD)))		      (RETURN (COND				((AND (ILESSP LEFT RIGHT)				      (NEQ (fetch PBTHEIGHT of (SETQ NEWX (ffetch DDPILOTBBT									     of DD)))					   0))				  (SELECTQ (fetch (BITMAP BITMAPBITSPERPIXEL)					      of (ffetch (\DISPLAYDATA DDDestination) of DD))					   (1 (.WHILE.TOP.DS. DISPLAYSTREAM							      (freplace PBTDESTBIT of NEWX								 with LEFT)							      (freplace PBTWIDTH of NEWX								 with (IDIFFERENCE RIGHT LEFT))							      (freplace PBTSOURCEBIT of NEWX								 with (IDIFFERENCE									(IPLUS (\DSPGETCHAROFFSET										 CHARCODE DD)									       LEFT)									CURX))							      (\PILOTBITBLT NEWX 0)))					   (4 (OR (\DDHASFONT DD)						  (\DDSETCOLORFONT DISPLAYSTREAM))					      (.WHILE.TOP.DS.						DISPLAYSTREAM						(freplace PBTDESTBIT of NEWX						   with (SETQ LEFT (LLSH LEFT 2)))						(freplace PBTWIDTH of NEWX						   with (IDIFFERENCE (LLSH RIGHT 2)								     LEFT))						(freplace PBTSOURCEBIT of NEWX						   with (IDIFFERENCE (IPLUS (LLSH (\DSPGETCHAROFFSET										    CHARCODE DD)										  2)									    LEFT)								     (LLSH CURX 2)))						(\PILOTBITBLT NEWX 0)))					   (8 (OR (\DDHASFONT DD)						  (\DDSETCOLORFONT DISPLAYSTREAM))					      (.WHILE.TOP.DS.						DISPLAYSTREAM						(freplace PBTDESTBIT of NEWX						   with (SETQ LEFT (LLSH LEFT 3)))						(freplace PBTWIDTH of NEWX						   with (IDIFFERENCE (LLSH RIGHT 3)								     LEFT))						(freplace PBTSOURCEBIT of NEWX						   with (IDIFFERENCE (IPLUS (LLSH (\DSPGETCHAROFFSET										    CHARCODE DD)										  3)									    LEFT)								     (LLSH CURX 3)))						(\PILOTBITBLT NEWX 0)))					   (SHOULDNT))				  T]	      (T                                             (* handle rotated fonts)		 (PROG ((YPOS (ffetch DDYPOSITION of DD))			(HEIGHTMOVED (\DSPGETCHARWIDTH CHARCODE DD))			(FONT (ffetch DDFONT of DD)))		       (RETURN (COND				 ((EQ ROTATION 90)           (* don't force CR for rotated fonts.)				   (\DSPYPOSITION.DISPLAY DISPLAYSTREAM (IPLUS YPOS HEIGHTMOVED))                                                             (* update the display stream x position.)				   (BITBLT (fetch (FONTDESCRIPTOR CHARACTERBITMAP) of FONT)					   0					   (\DSPGETCHAROFFSET CHARCODE DD)					   DISPLAYSTREAM					   (ADD1 (IDIFFERENCE (ffetch DDXPOSITION of DD)							      (FONTASCENT FONT)))					   YPOS					   (FONTHEIGHT FONT)					   HEIGHTMOVED))				 ((EQ ROTATION 270)				   (\DSPYPOSITION.DISPLAY DISPLAYSTREAM (IDIFFERENCE YPOS HEIGHTMOVED)							  )				   (BITBLT (fetch (FONTDESCRIPTOR CHARACTERBITMAP) of FONT)					   0					   (\DSPGETCHAROFFSET CHARCODE DD)					   DISPLAYSTREAM					   (IDIFFERENCE (ffetch DDXPOSITION of DD)							(FONTDESCENT FONT))					   (ffetch DDYPOSITION of DISPLAYSTREAM)					   (FONTHEIGHT FONT)					   HEIGHTMOVED))				 (T (ERROR "Not implemented to rotate by other than 0, 90 or 270"])(\SFFixY.HCPYMODE  [LAMBDA (DISPLAYDATA CSINFO)                               (* jds " 7-Jun-85 14:11")          (* makes that part of the bitblt table of a display stream which deals with the Y information consistent.	  This is called whenever any of the information which effects it changes by the DSPFn eg DSPPosition.	  If the change affected the clipping region, \SFFixClippingRegion should be called before \SFFixY.HCPYMODE)                                                             (* assumes DISPLAYDATA has already been type checked.)    (PROG ((PBT (ffetch DDPILOTBBT of DISPLAYDATA))	   (FONT (ffetch DDFONT of DISPLAYDATA))	   (Y (\DSPTRANSFORMY (\MICASTOPTS (ffetch DDYPOSITION of DISPLAYDATA))			      DISPLAYDATA))	   TOP CHARTOP BM)          [SETQ CHARTOP (IPLUS Y (LISTGET (fetch OTHERDEVICEFONTPROPS of FONT)					  (QUOTE ASCENT]          [freplace PBTDEST of PBT with (\ADDBASE (fetch BITMAPBASE of (SETQ BM									 (ffetch DDDestination									    of DISPLAYDATA)))						  (ITIMES (ffetch BITMAPRASTERWIDTH of BM)							  (\SFInvert BM								     (SETQ TOP								       (IMAX (IMIN (ffetch 										    DDClippingTop										      of DISPLAYDATA)										   CHARTOP)									     0]          [freplace PBTSOURCE of PBT with (\ADDBASE (ffetch BITMAPBASE of (SETQ BM									    (ffetch (CHARSETINFO										      CHARSETBITMAP)									       of CSINFO)))						    (ITIMES (ffetch BITMAPRASTERWIDTH of BM)							    (freplace DDCHARHEIGHTDELTA of 										      DISPLAYDATA							       with (IMIN (IMAX (IDIFFERENCE CHARTOP 											     TOP)										0)									  MAX.SMALL.INTEGER]          (freplace PBTHEIGHT of PBT	     with (IMAX (IDIFFERENCE TOP (IMAX [IDIFFERENCE Y (freplace DDCHARSETDESCENT								 of DISPLAYDATA								 with (LISTGET (fetch 									     OTHERDEVICEFONTPROPS										  of FONT)									       (QUOTE DESCENT]					       (ffetch DDClippingBottom of DISPLAYDATA)))			0]))(ADDTOVAR IMAGESTREAMTYPES (PRESSDISPLAY (FONTCREATE \FONTCREATE.HCPYMODE.PRESS)					   (CREATECHARSET \FONTCREATE.HCPYMODE.PRESS))			     (INTERPRESSDISPLAY (FONTCREATE \FONTCREATE.HCPYMODE.INTERPRESS)						(CREATECHARSET \FONTCREATE.HCPYMODE.INTERPRESS)))(DECLARE: DONTEVAL@LOAD DOCOPY (\HCPYMODEDISPLAYINIT))(PUTPROPS HARDCOPY COPYRIGHT ("Xerox Corporation" 1984 1985))(DECLARE: DONTCOPY  (FILEMAP (NIL (3876 10283 (HARDCOPY.SOMEHOW 3886 . 4545) (HARDCOPYIMAGEW 4547 . 4760) (HARDCOPYIMAGEW.TOFILE 4762 . 5027) (HARDCOPYIMAGEW.TOPRINTER 5029 . 5417) (HARDCOPYREGION.TOFILE 5419 . 5859) (HARDCOPYREGION.TOPRINTER 5861 . 6358) (\STRINGWIDTH.HCPYDISPLAYAUX 6360 . 10281)) (10351 15478 (MakeMenuOfPrinters 10361 . 10860) (MakeMenuOfImageTypes 10862 . 11543) (GetNewPrinterFromUser 11545 . 11708) (PopUpWindowAndGetAtom 11710 . 12521) (NewPrinter 12523 . 13483) (GetPrinterName 13485 . 14533) (GetImageFile 14535 . 15253) (FetchDefaultPrinter 15255 . 15476)) (15509 16310 (ExtensionForPrintFileType 15519 . 15784) (PRINTFILETYPE.FROM.EXTENSION 15786 . 16308)) (16361 30220 (DEFAULTPRINTER 16371 . 16598) (CAN.PRINT.DIRECTLY 16600 . 16785) (CONVERT.FILE.TO.TYPE.FOR.PRINTER 16787 . 17966) (EMPRESS 17968 . 18360) (HARDCOPYW 18362 . 22412) (LISTFILES1 22414 . 22579) (PRINTER.BITMAPFILE 22581 . 22955) (PRINTER.BITMAPSCALE 22957 . 23323) (PRINTER.SCRATCH.FILE 23325 . 23682) (PRINTERPROP 23684 . 23917) (PRINTERSTATUS 23919 . 24172) (PRINTERTYPE 24174 . 25486) (PRINTFILEPROP 25488 . 25728) (PRINTFILETYPE 25730 . 27054) (SEND.FILE.TO.PRINTER 27056 . 30218)) (30221 33469 (PRINTERDEVICE 30231 . 33467)) (34250 40619 (TEXTTOIMAGEFILE 34260 . 36369) (COPY.TEXT.TO.IMAGE 36371 . 40617)) (40620 41330 (\BLTSHADE.GENERICPRINTER 40630 . 41328)) (41450 64278 (MAKEHARDCOPYSTREAM 41460 . 42900) (UNMAKEHARDCOPYSTREAM 42902 . 43872) (HARDCOPYSTREAMTYPE 43874 . 44252) (\CHARWIDTH.HDCPYDISPLAY 44254 . 44922) (\DSPFONT.HDCPYDISPLAY 44924 . 46754) (\DSPRIGHTMARGIN.HDCPYDISPLAY 46756 . 47426) (\DSPXPOSITION.HDCPYDISPLAY 47428 . 47775) (\DSPYPOSITION.HDCPYDISPLAY 47777 . 48124) (\STRINGWIDTH.HDCPYDISPLAY 48126 . 48843) (\HDCPYBLTCHAR 48845 . 52631) (\HDCPYDISPLAY.FIX.XPOS 52633 . 53157) (\HDCPYDISPLAY.FIX.YPOS 53159 . 53683) (\HDCPYDISPLAYINIT 53685 . 54698) (\HDCPYDSPPRINTCHAR 54700 . 58029) (\SLOWHDCPYBLTCHAR 58031 . 62703) (\CHANGECHARSET.HDCPYDISPLAY 62705 . 64276)) (64662 105485 (MAKEHARDCOPYMODESTREAM 64672 . 67195) (UNMAKEHARDCOPYMODESTREAM 67197 . 68780) (\BLTSHADE.HCPYMODE 68782 . 69454) (\BITBLT.HCPYMODE 69456 . 70234) (\BRUSHCONVERT.HCPYMODE 70236 . 70630) (\CHANGECHARSET.HCPYMODE 70632 . 72279) (\DASHINGCONVERT.HCPYMODE 72281 . 72614) (\CHARWIDTH.HCPYMODE 72616 . 73026) (\DRAWLINE.HCPYMODE 73028 . 73477) (\DRAWCURVE.HCPYMODE 73479 . 74067) (\DRAWCIRCLE.HCPYMODE 74069 . 74595) (\DRAWELLIPSE.HCPYMODE 74597 . 75314) (\DSPFONT.HCPYMODE 75316 . 77094) (\DSPLEFTMARGIN.HCPYMODE 77096 . 77870) (\DSPLINEFEED.HCPYMODE 77872 . 78494) (\DSPRIGHTMARGIN.HCPYMODE 78496 . 79401) (\DSPXPOSITION.HCPYMODE 79403 . 80296) (\DSPYPOSITION.HCPYMODE 80298 . 80959) (\MOVETO.HCPYMODE 80961 . 81158) (\FONTCREATE.HCPYMODE.PRESS 81160 . 83550) (\FONTCREATE.HCPYMODE.INTERPRESS 83552 . 85981) (\STRINGWIDTH.HCPYMODE 85983 . 86656) (\HCPYMODEBLTCHAR 86658 . 91001) (\HCPYMODEDISPLAYINIT 91003 . 94694) (\HCPYMODEDSPPRINTCHAR 94696 . 98251) (\SLOWHCPYMODEBLTCHAR 98253 . 103221) (\SFFixY.HCPYMODE 103223 . 105483)))))STOP