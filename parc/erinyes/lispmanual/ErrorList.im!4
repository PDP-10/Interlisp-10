{Begin SubSec Error List}{Title Error List}{Text{note grand idea for reorganization:  I want to move the error list into an appendix in the back of the manual.  I also want to list all of the errors in alphabetical order.  After all, how often does someone need to know the error corresponding to a given error NUMBER????  Perhaps, if this information is used, I might include a short error#->errortext table in the error appendix too.idea:  perhaps I could collect ALL of the error messages referenced in the manual (most of which are produced by calls to ERROR, I assume, and put them in the alphabetical error list too.  This would make the error list useful, for once....}There are currently fifty-plus types of errors in the Interlisp system.  Some of these errors are implementation dependent, i.e., appear in Interlisp-D but may not appear in other Interlisp systems.  The error number is set internally by the code that detects the error before it calls the error handling functions.  It is also the value returned by {index ERRORN FN}{fn ERRORN} if called subsequent to that type of error, and is used by {index ERRORMESS FN}{fn ERRORMESS} for printing the error message.Most errors will print the offending expression following the message, e.g., {lisp NON-NUMERIC ARG NIL} is very common.  Error number 18 (control-B){index control-B (Interrupt Character)} always causes a break (unless {index HELPFLAG Var}{var HELPFLAG} is {lisp NIL}).  All other errors cause breaks if {index BREAKCHECK FN}{fn BREAKCHECK} returns {lisp T} (see {PageRef Tag WhenToBreak}).{note Do most errors have a recognizable 'culprit' ??  Should the culprits of all errors be put in the table below ??  we should have a more consistant way of documenting the 'culprit's of various errors.   perhaps another column in the table  ---mjs}{Tag ErrorNumbers}{index *PRIMARY* Error numbers}The errors are listed below by error number:{Begin LabeledList Error Types}{Label 0}{Text{lisp SYSTEM ERROR}{index *PRIMARY* SYSTEM ERROR Error}Low-level Interlisp system error.  It is quite possible that random programs or data structures might have already been smashed.  Unless he is sure he knows what the problem is, the user is best advised to save any important information, and reload the Interlisp system as soon as possible.{Begin Comment Interlisp-10 Specific}{lisp JSYS ERROR}{index *PRIMARY* JSYS ERROR Error} (Interlisp-10)  Occurs following a trap in a JSYS.  {lisp TRAP AT LOCATION}{index *PRIMARY* TRAP AT LOCATION Error} is printed, followed by the {lisp JSYS} diagnostic, and control returns to the operating system executive.  The user can then safely {lisp CONTINUE}, and the Interlisp error, {lisp JSYS ERROR} is then generated.  A {lisp TRAP AT LOCATION} can also occur if an illegal instruction is executed.  In this case, the operating system also prints {index ILLEGAL INSTRUCTION Error}{lisp ILLEGAL INSTRUCTION}.  This can happen for example if the user is programming directly in {lisp ASSEMBLE} code, or if his system   (If the user does elect to {lisp CONTINUE}, Interlisp will (try to) generate a {lisp JSYS ERROR} and unwind.  In some cases, however, the system may be so badly smashed that the error message won't even print.)  Note that in some cases, e.g. illegal instruction trap while in the garbage collector, Interlisp will print out {lisp CAN'T CONTINUE}, because traps under those conditions are fatal.  The user {it may} be able to reenter his sytem via the {lisp START} command, and, if lucky, dump some data or functions before the system totally collapses.{End Comment Interlisp-10 Specific}}{Label 1}{Text No longer used.}{Label 2}{Text{lisp STACK OVERFLOW}{index *PRIMARY* STACK OVERFLOW Error}Occurs when computation is too deep, either with respect to number of function calls, or number of variable bindings.  Usually because of a non-terminating recursive computation, i.e., a bug.{Begin Comment Interlisp-10 specific}In Interlisp-10, the garbage collector uses the same stack as the rest of the system, so that if a garbage collection occurs when deep in a computation, the stack can overflow (particularly if there is a lot of list structure that is deep in the {fn CAR} direction). If this does happen, the garbage collector will flush the stack used by the computation in order that the garbage collection can complete. Afterwards, the error message {lisp STACK OVERFLOW IN GC - COMPUTATION LOST}{index STACK OVERFLOW IN GC - COMPUTATION LOST Error} is printed, followed by a {lisp (RESET)}, i.e., return to top level.{End Comment Interlisp-10 specific}}{Label 3}{Text{lisp ILLEGAL RETURN}{index *PRIMARY* ILLEGAL RETURN Error}Call to {fn RETURN} when not inside of an interpreted {fn PROG}.}{Label 4}{Text{lisp ARG NOT LIST}{index *PRIMARY* ARG NOT LIST Error}{fn RPLACA} called on a non-list.}{Label 5}{Text{lisp HARD DISK ERROR}{index *PRIMARY* HARD DISK ERROR Error}An error with the local disk drive.}{Label 6}{Text{lisp ATTEMPT TO SET NIL}{index *PRIMARY* ATTEMPT TO SET NIL Error}Via {fn SET} or {fn SETQ}}{Label 7}{Text{lisp ATTEMPT TO RPLAC NIL}{index *PRIMARY* ATTEMPT TO RPLAC NIL Error}Attempt either to {fn RPLACA} or to {fn RPLACD} {lisp NIL} with something other than {lisp NIL}.}{Label 8}{Text{lisp UNDEFINED OR ILLEGAL GO}{index *PRIMARY* UNDEFINED OR ILLEGAL GO Error}{fn GO} when not inside of a {fn PROG}, or {fn GO} to nonexistent label.}{Label 9}{Text{lisp FILE WON'T OPEN}{index *PRIMARY* FILE WON'T OPEN Error}From {fn OPENSTREAM} ({PageRef Fn OPENSTREAM}).}{Label 10}{Text{lisp NON-NUMERIC ARG}{index *PRIMARY* NON-NUMERIC ARG Error}A numeric function e.g., {fn PLUS}, {fn TIMES}, {fn GREATERP}, expected a number.}{Label 11}{Text{lisp ATOM TOO LONG}{index *PRIMARY* ATOM TOO LONG Error}Attempted to create a litatom (via {fn PACK}, or typing one in, or reading from a file) with too many characters.  In Interlisp-D, the maximum number of characters in a litatom is 255.{comment Interlisp-10 specific: In Interlisp-10, the maximum is 127 characters.}}{Label 12}{Text{lisp ATOM HASH TABLE FULL}{index *PRIMARY* ATOM HASH TABLE FULL Error}No room for any more (new) atoms.}{Label 13}{Text{lisp FILE NOT OPEN}{index *PRIMARY* FILE NOT OPEN Error}From an I/O function, e.g., {fn READ}, {fn PRINT}, {fn CLOSEF}.}{Label 14}{Text{lisp ARG NOT LITATOM}{index *PRIMARY* ARG NOT LITATOM Error}{fn SETQ}, {fn PUTPROP}, {fn GETTOPVAL}, etc., given a non-atomic arg.}{Label 15}{Text{lisp TOO MANY FILES OPEN}{index *PRIMARY* TOO MANY FILES OPEN Error}}{Label 16}{Text{lisp END OF FILE}{index *END* *PRIMARY* OF FILE Error}From an input function, e.g., {fn READ}, {fn READC}, {fn RATOM}.  After the error occurs, the file will still be left open.Note:  It is possible to use an {var ERRORTYPELST} entry ({PageRef Var ERRORTYPELST}) to return a character as the value of the call to {fn ERRORX}, and the program will continue, e.g. returning "{lisp ]}" may be used to complete a read operation.}{Label 17}{Text{lisp ERROR}{index *PRIMARY* ERROR Error}Call to {index ERROR FN}{fn ERROR} ({PageRef Fn ERROR}).}{Label 18}{Text{lisp BREAK}{index BREAK Error}Control-B{index control-B (Interrupt Character)} was typed.}{Label 19}{Text{lisp ILLEGAL STACK ARG}{index *PRIMARY* ILLEGAL STACK ARG Error}A stack function expected a stack position and was given something else.  This might occur if the arguments to a stack function are reversed.  Also occurs if user specified a stack position with a function name, and that function was not found on the stack.  See {PageRef Tag STACK}.}{Label 20}{Text{lisp FAULT IN EVAL}{index *PRIMARY* FAULT IN EVAL Error}Artifact of bootstrap process.  Never occurs after {index FAULTEVAL FN}{fn FAULTEVAL} is defined.}{Label 21}{Text{lisp ARRAYS FULL}{index *PRIMARY* ARRAYS FULL Error}System will first initiate a garbage collection of array space, and if no array space is reclaimed, will then generate this error.}{Label 22}{Text{lisp FILE SYSTEM RESOURCES EXCEEDED}{index *PRIMARY* FILE SYSTEM RESOURCES EXCEEDED Error}Includes no more disk space, disk quota exceeded, directory full,etc.}{Label 23}{Text{lisp FILE NOT FOUND}{index *PRIMARY* FILE NOT FOUND Error}File name does not correspond to a file in the corresponding directory.  Can also occur if file name is ambiguous.Interlisp is initialized with an entry on {var ERRORTYPELST} ({PageRef Var ERRORTYPELST}) to call {fn SPELLFILE}{index SPELLFILE FN} for this error.  {fn SPELLFILE} will search alternate directories or perform spelling correction on the connected directory.  If {fn SPELLFILE} fails, then the user will see this error.}{Label 24}{Text{lisp BAD SYSOUT FILE}{index *PRIMARY* BAD SYSOUT FILE Error}Date does not agree with date of {fn MAKESYS}, or file is not a sysout file at all (see {PageRef Fn SYSOUT}).}{Label 25}{Text{lisp UNUSUAL CDR ARG LIST}{index *PRIMARY* UNUSUAL CDR ARG LIST Error}A form ends in a non-list other than {lisp NIL}, e.g., {lisp (CONS T . 3)}.}{Label 26}{Text{lisp HASH TABLE FULL}{index *PRIMARY* HASH TABLE FULL Error}See hash array functions, {PageRef Term Hash Arrays}.}{Label 27}{Text{lisp ILLEGAL ARG}{index *PRIMARY* ILLEGAL ARG Error}Catch-all error.  Currently used by {fn PUTD}, {fn EVALA}, {fn ARG}, {lisp FUNARG}, etc.}{Label 28}{Text{lisp ARG NOT ARRAY}{index *PRIMARY* ARG NOT ARRAY Error}{fn ELT} or {fn SETA} given an argument that is not a legal array (see {PageRef Fn ELT}).}{Label 29}{Text{lisp ILLEGAL OR IMPOSSIBLE BLOCK}{index *PRIMARY* ILLEGAL OR IMPOSSIBLE BLOCK Error}(Interlisp-10)  Not enough free blocks available (from {lisp GETBLK} or {lisp RELBLK}).}{Label 30}{Text{lisp STACK PTR HAS BEEN RELEASED}{index *PRIMARY* STACK PTR HAS BEEN RELEASED Error}A released stack pointer was supplied as a stack descriptor for a purpose other than as a stack pointer to be re-used (see {PageRef Term Reusing Stack Pointers}).}{Label 31}{Text{lisp STORAGE FULL}{index *PRIMARY* STORAGE FULL Error}Following a garbage collection, if not enough words have been collected, and there is no un-allocated space left in the system, this error is generated.}{Label 32}{Text{lisp ATTEMPT TO USE ITEM OF INCORRECT TYPE}{index *PRIMARY* ATTEMPT TO USE ITEM OF INCORRECT TYPE Error}Before a field of a user data type is changed, the type of the item is first checked to be sure that it is the expected type.  If not, this error is generated (see {PageRef Term User Data Types}).}{Label 33}{Text{lisp ILLEGAL DATA TYPE NUMBER}{index *PRIMARY* ILLEGAL DATA TYPE NUMBER Error}The argument is not a valid user data type number (see {PageRef Term User Data Types}).{note what is the error if you use an invalid user data type NAME ??}}{Label 34}{Text{lisp DATA TYPES FULL}{index *PRIMARY* DATA TYPES FULL Error}All available user data types have been allocated (see {PageRef Term User Data Types}).}{Label 35}{Text{lisp ATTEMPT TO BIND NIL OR T}{index *PRIMARY* ATTEMPT TO BIND NIL OR T Error}In a {fn PROG} or {lisp LAMBDA} expression.}{Label 36}{Text{lisp TOO MANY USER INTERRUPT CHARACTERS}{index *PRIMARY* TOO MANY USER INTERRUPT CHARACTERS Error}Attempt to enable a user interrupt character when all user channels are currently enabled (see {PageRef Term User Interrupt Characters}).}{Label 37}{Text{lisp READ-MACRO CONTEXT ERROR}{index *PRIMARY* READ-MACRO CONTEXT ERROR Error}(Interlisp-10 only)  Occurs when a {fn READ} is executed from within a read macro function and the next token is a {lisp )} or a {lisp ]} (see {PageRef Tag ReadMacros}).}{Label 38}{Text{lisp ILLEGAL READTABLE}{index *PRIMARY* ILLEGAL READTABLE Error}The argument was expected to be a valid read table (see {PageRef Tag ReadTables}).}{Label 39}{Text{lisp ILLEGAL TERMINAL TABLE}{index *PRIMARY* ILLEGAL TERMINAL TABLE Error}The argument was expected to be a valid terminal table (see {PageRef Tag TerminalTables}).}{Label 40}{Text{lisp SWAPBLOCK TOO BIG FOR BUFFER}{index *PRIMARY* SWAPBLOCK TOO BIG FOR BUFFER Error}(Interlisp-10) An attempt was made to swap in a function/array which is too large for the swapping buffer.}{Label 41}{Text{lisp PROTECTION VIOLATION}{index *PRIMARY* PROTECTION VIOLATION Error}Attempt to open a file that user does not have access to.  Also reference to unassigned device.}{Label 42}{Text{lisp BAD FILE NAME}{index *PRIMARY* BAD FILE NAME Error}Illegal character in file specification, illegal syntax, e.g. two {lisp ;}'s etc.}{Label 43}{Text{lisp USER BREAK}{index *PRIMARY* USER BREAK Error}Error corresponding to user interrupt character.  See {PageRef Term User Interrupt Characters}.}{Label 44}{Text{lisp UNBOUND ATOM}{index *PRIMARY* UNBOUND ATOM Error}This occurs when a variable (litatom) was used which had neither a stack binding (wasn't an argument to a function nor a {lisp PROG} variable) nor a top level value.  The "culprit" ({lisp (CADR ERRORMESS)}) is the litatom.  Note that if DWIM corrects the error, no error occurs and the error number is not set.  However, if an error is going to occur, whether or not it will cause a break, the error number will be set.}{Label 45}{Text{lisp UNDEFINED CAR OF FORM}{index *PRIMARY* UNDEFINED CAR OF FORM Error}Undefined function error.  This occurs when a form is evaluated whose function position ({lisp CAR}) does not have a definition as a function.  Culprit is the form.}{Label 46}{Text{lisp UNDEFINED FUNCTION}{index *PRIMARY* UNDEFINED FUNCTION Error}This error is generated if {fn APPLY} is given an undefined function.  Culprit is {lisp (LIST {arg FN} {arg ARGS})}}{Label 47}{Text{lisp CONTROL-E}{index *PRIMARY* CONTROL-E Error}The user typed control-E.{index control-E (Interrupt Character)}}{Label 48}{Text{lisp FLOATING UNDERFLOW}{index *PRIMARY* FLOATING UNDERFLOW Error}Underflow during floating-point operation.}{Label 49}{Text{lisp FLOATING OVERFLOW}{index *PRIMARY* FLOATING OVERFLOW Error}Overflow during floating-point operation.}{Label 50}{Text{lisp OVERFLOW}{index *PRIMARY* OVERFLOW Error}Overflow during integer operation.}{Label 51}{Text{lisp ARG NOT HARRAY}{index *PRIMARY* ARG NOT HARRAY Error}Hash array operations given an argument that is not a hash array.{comment Interlisp-10 specific: (In Interlisp-10, this still triggers error 28, {lisp ARG NOT ARRAY}).}}{Label 52}{Text{lisp TOO MANY ARGUMENTS}{index *PRIMARY* TOO MANY ARGUMENTS Error}Too many arguments given to a lambda-spread, lambda-nospread, or nlambda-spread function.Note that Interlisp-D does not cause an error if more arguments are passed to a function than it is defined with.  This argument occurs when more individual arguments are passed to a function than Interlisp-D can store on the stack at once.  The limit is currently 80 arguments.}{End LabeledList Error Types}In addition, many system functions, e.g., {fn DEFINE}, {fn ARGLIST}, {fn ADVISE}, {fn LOG}, {fn EXPT}, etc, also generate errors with appropriate messages by calling {index ERROR FN}{fn ERROR} (see {PageRef Fn ERROR}) which causes error number 17.}{End SubSec Error List}       ? 1(DEFAULTFONT 1 (GACHA 10) (GACHA 8) (TERMINAL 8)) 
         ? 1(DEFAULTFONT 1 (GACHA 10) (GACHA 8) (TERMINAL 8)) 
          ;ý      ;ý zº