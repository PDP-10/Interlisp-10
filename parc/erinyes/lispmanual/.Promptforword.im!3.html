<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Erinyes]&lt;LispManual>Promptforword.im!3</title>
  </head>
  <body>
    <pre>
{Begin SubSec PROMPTFORWORD}{Title PROMPTFORWORD}{Text{Begin Note}File:   &lt;LispManual&gt;PromptForWord.imRevised:  Feb 21, Jun 29, and Jul 12, 1983 by JonLtranslated to IM format: Wed, 20 Jul 83 17:53 PDT by SannellaRevised: Mon, 15 Aug 83 11:51 PDT by Sannella{End Note}{index *PRIMARY* PROMPTFORWORD Fn}{fn PROMPTFORWORD} is a function that reads in a sequence of characters, generally from the keyboard, without involving {fn READ}-like syntax.  A user can supply a prompting string, as well as a "candidate" string, which is printed and used if the user types only a word terminator character (or doesn't type anything before a given time limit).  As soon as any characters are typed the "candidate" string is erased and the new input takes its place.{fn PROMPTFORWORD} accepts user type-in until one of the "word terminator" characters is typed.  Normally, the word terminator characters are {lisp EOL}, {lisp ESCAPE}, {lisp LF}, {lisp SPACE}, or {lisp TAB}.  This list can be changed using the {arg TERMINCHAR.LST} argument to {fn PROMPTFORWORD}, for example if it is desirable to allow the user to input lines including spaces.{fn PROMPTFORWORD} also recognizes the following special characters:{Begin LabeledList PROMPTFORWORD Character}{Label Control-A, Backspace, or DELETE}{TextAny of these characters deletes the last character typed and appropriately erases it from the echo stream if it is a display stream.}{Label Control-Q}{TextErases all the type-in so far.}{Label Control-R}{TextReprints the accumulated string.}{Label Control-V}{Text"Quotes" the next character: after typing Control-V, the next character typed is added to the accumulated string, regardless of any special meaning it has.  Allows the user to include editing characters and word terminator characters in the accumulated string.}{Label Control-W}{TextErases the last word.}{Label ?}{TextCalls up a "help" facility.  The action taken is defined by the {arg GENERATE?LIST.FN} argument to {fn PROMPTFORWORD} (see below).  Normally, this prints a list of possible candidates.}{End LabeledList PROMPTFORWORD Character}{FnDef {Name PROMPTFORWORD} {Args PROMPT.STR CANDIDATE.STR GENERATE?LIST.FN ECHO.CHANNEL DONTECHOTYPEIN.FLG URGENCY.OPTION TERMINCHARS.LST KEYBD.CHANNEL}{Text{fn PROMPTFORWORD} has a multiplicity of features, which are specified through a rather large number of input arguments, but the default settings for them (i.e., when they aren't given, or are given as {lisp NIL}) is such to minimize the number needed in the average case, and an attempt has been made to order the more frequently non-defaulted arguments at the beginning of the argument list.  The default input and echo are both to the terminal; the terminal table in effect during input allows most control characters to be {lisp INDICATE}'d.  {fn PROMPTFORWORD} returns {lisp NIL} if a null string is typed; this would occur when no candidate is given and only a terminator is typed, or when the candidate is erased and a terminator is typed with no other input still un-erased.  In all other cases, {fn PROMPTFORWORD} returns a string. {fn PROMPTFORWORD} is controlled through the following arguments:{Begin LabeledList PROMPTFORWORD arguments}{Label {arg PROMPT.STR}}{TextIf non-{lisp NIL}, this is coerced to a string and used for prompting; an additional space is output after this string.}{Label {arg CANDIDATE.STR}}{TextIf non-{lisp NIL}, this is coerced to a string and offered as initial contents of the input buffer.}{Label {arg GENERATE?LIST.FN}}{TextIf non-{lisp NIL}, this is either a string to be printed out for help, or a function to be applied to {arg PROMPT.STR} and {arg CANDIDATE.STR} (after both have been coerced to strings), and which should return a list of potential candidates.  The help string or list of potential candidates will then be printed on a separate line, the prompt will be restarted, and any type-in will be re-echoed.Note:  If {arg GENERATE?LIST.FN} is a function, its value list will be cached so that it will be run at most once per call to {fn PROMPTFORWORD}.{note arg! I think that GENERATE?LIST.FN would be a lot more useful if it also took the current accumulated string, so you could offer alternatives based on what the user has already typed --- mjstrue, lets change it --- jonl}}{Label {arg ECHO.CHANNEL}}{TextCoerced to an output stream; {lisp NIL} defaults to {lisp T}, the "terminal output stream", normally {lisp (TTYDISPLAYSTREAM)}.{note misfeature --- jonl}  To achieve echoing to the "current output stream", use {lisp (GETSTREAM NIL 'OUTPUT)}.  If echo is to a display stream, it will have a flashing caret showing where the next input is to be echoed.}{Label {arg DONTECHOTYPEIN.FLG}}{TextIf {lisp T}, there is no echoing of the input characters.  If the value of {arg DONTECHOTYPEIN.FLG} is a single-character atom or string, that character is echoed instead of the actual input.  For example, {fn LOGIN} prompts for a password with {arg DONTECHOTYPEIN.FLG} being "*".}{Label {arg URGENCY.OPTION}}{TextIf {lisp NIL}, {fn PROMPTFORWORD} quietly wait for input, as {fn READ} does; if a number, this is the number of seconds to wait for the user to respond (if timeout is reached, then {arg CANDIDATE.WORD} is returned, regardless of any other type-in activity); if {lisp T}, this means to wait forever, but periodically flash the window to alert the user; if {lisp TTY}, then {fn PROMPTFORWORD} grabs the TTY immediately.  When {arg URGENCY.OPTION}={lisp TTY}, the cursor is temporarily changed to a different shape to indicate the urgent nature of the request.}{Label {arg TERMINCHARS.LST}}{TextThis is list of "word terminator" character codes; it defaults to {lisp (CHARCODE (EOL ESCAPE LF SPACE TAB))}.  This may also be a single character code. {note May someday accept a "bittable" such as given to STRPOSL.}}{Label {arg KEYBD.CHANNEL}}{TextIf non-{lisp NIL}, this is coerced to a stream, and the input bytes are taken from that stream.  {lisp NIL} defaults to the keyboard input stream.  Note that this is {it not} the same as the terminal input stream {lisp T} ({PageRef Term Terminal  Streams}), which is a {it buffered} keyboard input stream, not suitable for use with {fn PROMPTFORWORD}.}{End LabeledList PROMPTFORWORD arguments}}} {comment endfndef}Examples:{lispcode(PROMPTFORWORD   "What is your FOO word?" 'Mumble   (FUNCTION (LAMBDA () '(Grumble Bletch)))   PROMPTWINDOW NIL 30)}This first prompts the user for input by printing the first argument as a prompt into {var PROMPTWINDOW};  then the proffered default answer, "{lisp Mumble}", is printed out and the caret starts flashing just after it to indicate that the upcoming input will be echoed there.  If the user fails to complete a word within 30 seconds, then the result will be the string {lisp "Mumble"}.  {lispcode(FRESHLINE T)(LIST    (PROMPTFORWORD      (CONCAT "{lbracket}"  HOST  "{rbracket} Login:")      (USERNAME NIL NIL T))   (PROMPTFORWORD      " (password)" NIL NIL NIL '*))}This first prompts in whatever window is currently {lisp (TTYDISPLAYSTREAM)}, and then takes in a username;  the second call prompts with {lisp " (password)"} and takes in another word (the password) {it without} proffering a candidate,  echoing the typed-in characters as "*".{note Caution: because of the dynamics of multiple processes, and the above-mentioned input-buffer saving, a multiple use of PROMPTFORWORD is not quite as simple as this "motivating" example.  See discussion of KEYBD.CHANNEL above.Not sure this is true.  I ripped out the nonsense about \KEYBOARD.STREAM (whoever heard of making a user supply an internal object for what one might expect to be the default behavior!).  --bvm}}{End SubSec PROMPTFORWORD}</pre>
  </body>
</html>
