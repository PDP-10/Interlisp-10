<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Erinyes]&lt;LispManual>Fonts.im!6</title>
  </head>
  <body>
    <pre>
{Begin SubSec Fonts}{Title Fonts}{Text{index *PRIMARY* Fonts}A font is the collection of images that are printed or displayed when characters are output to a graphic output device.  Some simple displays and printers can only print characters using one font.  Bitmap displays and graphic printers can print characters using a large number of fonts.Fonts are identified by a distinctive style or family (such as Modern or Classic), a size (such as 10 points), and a face (such as bold or italic).  Fonts also have a rotation that indicates the orientation of characters on the screen or page.  A normal horizontal font (also called a portrait font) has a rotation of 0; the rotation of a vertical (landscape) font is 90 degrees.  While any combination can be specified, in practice the user will find that only certain combinations of families, sizes, faces, and rotations are available for any graphic output device.To specify a font to the functions described below, a {lisp FAMILY} is represented by a literal atom, a {lisp SIZE} by a positive integer, and a {lisp FACE} by a three-element list of the form {lisp (WEIGHT SLOPE EXPANSION)}.  {lisp WEIGHT}, which indicates the thickness of the characters, can be {lisp BOLD}, {lisp MEDIUM}, or {lisp LIGHT}; {lisp SLOPE} can be {lisp ITALIC} or {lisp REGULAR}; and {lisp EXPANSION} can be {lisp REGULAR}, {lisp COMPRESSED}, or {lisp EXPANDED}, indicating how spread out the characters are.  For convenience, faces may also be specified by three-character atoms, where each character is the first letter of the corresponding field.  Thus, {lisp MRR} is a synonym for {lisp (MEDIUM REGULAR REGULAR)}.  In addition, certain common face combinations may be indicated by special literal atoms:{index STANDARD (Font face)}{index MRR (Font face)}{index ITALIC (Font face)}{index MIR (Font face)}{index BOLDITALIC (Font face)}{index BIR (Font face)}{lisp STANDARD} = {lisp (MEDIUM REGULAR REGULAR)} = {lisp MRR}{lisp ITALIC} = {lisp (MEDIUM ITALIC REGULAR)} = {lisp MIR}{lisp BOLD} = {lisp (BOLD REGULAR REGULAR)} = {lisp BRR}{lisp BOLDITALIC} = {lisp (BOLD ITALIC REGULAR)} = {lisp BIR}{index *PRIMARY* Font descriptors}Interlisp represents all the information related to a font in an object called a font descriptor.  Font descriptors contain the family, size, etc. properties used to represent the font.  In addition, for each character in the font, the font descriptor contains width information for the character and (for display fonts) a bitmap containing the picture of the character.The font functions can take fonts specified in a variety of different ways.  {fn DSPFONT}, {fn FONTCREATE}, {fn FONTCOPY}, etc. can be applied to font descriptors, "font lists" such as {lisp '(MODERN 10)}, image streams (coerced to its current font), or windows (coerced to the current font of its display stream).  The printout command "{lisp .FONT}" ({PageRef (Printout Command) .FONT}) will also accept fonts specified in any of these forms.{FnDef {Name FONTCREATE} {Args FAMILY SIZE FACE ROTATION DEVICE NOERRORFLG CHARSET}{TextReturns a font descriptor for the specified font.  {arg FAMILY} is a litatom specifying the font family.  {arg SIZE} is an integer indicating the size of the font in points.  {arg FACE} specifies the face characteristics in one of the formats listed above; if {arg FACE} is {lisp NIL}, {lisp STANDARD} is used.  {arg ROTATION}, which specifies the orientation of the font, is 0 (or {lisp NIL}) for a portrait font and 90 for a landscape font.  {arg DEVICE} indicates the output device for the font, and can be any image stream type ({PageRef Term Image stream types}), such as {lisp DISPLAY}, {lisp INTERPRESS}, etc.  {arg DEVICE} may also be an image stream, in which case the type of the stream determines the font device.  {arg DEVICE} defaults to {lisp DISPLAY}.The {arg FAMILY} argument to {fn FONTCREATE} may also be a list, in which case it is interpreted as a font-specification quintuple, a list of the form {lisp ({arg FAMILY} {arg SIZE} {arg FACE} {arg ROTATION} {arg DEVICE})}.  Thus, {lisp (FONTCREATE '(GACHA 10 BOLD))} is equivalent to {lisp (FONTCREATE 'GACHA 10 'BOLD)}.  {arg FAMILY} may also be a font descriptor, in which case that descriptor is simply returned.If a font descriptor has already been created for the specified font, {fn FONTCREATE} simply returns it.  If it has not been created, {fn FONTCREATE} has to read the font information from a font file that contains the information for that font.  The name of an appropriate font file, and the algorithm for searching depends on the device that the font is for, and is described in more detail below.  If an appropriate font file is found, it is read into a font descriptor.  If no file is found, for {lisp DISPLAY} fonts {fn FONTCREATE} looks for fonts with less face information and fakes the remaining faces (such as by doubling the bit pattern of each character or slanting it).  For hardcopy printer fonts, there is no acceptable faking algorithm.If no acceptable font is found, the action of {fn FONTCREATE} is determined by {arg NOERRORFLG}.  If {arg NOERRORFLG} is {lisp NIL}, it generates a {lisp FONT NOT FOUND} error{index FONT NOT FOUND Error} with the offending font specification; otherwise, {fn FONTCREATE} returns {lisp NIL}.{arg CHARSET} is the character set which will be read to create the font.  Defaults to 0.  For more information on character sets, see {index NS Characters}NS Characters, {PageRef Term NS Characters}.}}{FnDef {Name FONTP} {Args X}{TextReturns {arg X} if {arg X} is a font descriptor; {lisp NIL} otherwise.}}{FnDef {Name FONTPROP} {Args FONT PROP}{TextReturns the value of the {arg PROP} property of font {arg FONT}.  The following font properties are recognized:{Begin LabeledList Font Properties}{Label {lisp FAMILY}{index FAMILY (Font property)}}{Text The style of the font, represented as a literal atom, such as {lisp CLASSIC} or {lisp MODERN}.}{Label {lisp SIZE}{index SIZE (Font property)}}{Text A positive integer giving the size of the font, in printer's points (1/72 of an inch).}{Label {lisp WEIGHT}{index WEIGHT (Font property)}}{Text The thickness of the characters; one of {lisp BOLD}, {lisp MEDIUM}, or {lisp LIGHT}.}{Label {lisp SLOPE}{index SLOPE (Font property)}}{Text The "slope" of the characters in the font; one of {lisp ITALIC} or {lisp REGULAR}.}{Label {lisp EXPANSION}{index EXPANSION (Font property)}}{Text The extent to which the characters in the font are spread out; one of {lisp REGULAR}, {lisp COMPRESSED}, or {lisp EXPANDED}.  Most available fonts have {lisp EXPANSION}={lisp REGULAR}.}{Label {lisp FACE}{index FACE (Font property)}}{Text A three-element list of the form {lisp ({arg WEIGHT} {arg SLOPE} {arg EXPANSION})}, giving all of the typeface parameters.}{Label {lisp ROTATION}{index ROTATION (Font property)}}{Text An integer that gives the orientation of the font characters on the screen or page, in degrees.  A normal horizontal font (also called a portrait font){index Portrait fonts} has a rotation of 0; the rotation of a vertical (landscape) font{index Landscape fonts} is 90.}{Label {lisp DEVICE}{index DEVICE (Font property)}}{Text The device that the font can be printed on; one of {lisp DISPLAY}, {lisp INTERPRESS}, etc.}{Label {lisp ASCENT}{index ASCENT (Font property)}}{Text An integer giving the maximum height of any character in the font from its base line (the printing position).  The top line will be at {arg BASELINE}+{arg ASCENT}-1.}{Label {lisp DESCENT}{index DESCENT (Font property)}}{Text An integer giving the maximum extent of any character below the base line, such as the lower part of a "p".  The bottom line of a character will be at {arg BASELINE}-{arg DESCENT}.}{Label {lisp HEIGHT}{index HEIGHT (Font property)}}{Text Equal to {lisp ASCENT} + {lisp DESCENT}.}{Label {lisp SPEC}{index SPEC (Font property)}}{Text The {lisp ({arg FAMILY} {arg SIZE} {arg FACE} {arg ROTATION} {arg DEVICE})} quintuple by which the font is known to Lisp.}{Label {lisp DEVICESPEC}{index DEVICESPEC (Font property)}}{Text The {lisp ({arg FAMILY} {arg SIZE} {arg FACE} {arg ROTATION} {arg DEVICE})} quintuple that identifies what will be used to represent the font on the display or printer.  It will differ from the {lisp SPEC} property only if an implicit coercion is done to approximate the specified font with one that actually exists on the device.}{Label {lisp SCALE}{index SCALE (Font property)}}{Text The units per printer's point (1/72 of an inch) in which the font is measured.  For example, this is 35.27778 (the number of micas per printer's point) for Interpress fonts, which are measured in terms of micas.}{End LabeledList Font Properties}}}{FnDef {Name FONTCOPY}{Args OLDFONT PROP{sub 1} VAL{sub 1} PROP{sub 2} VAL{sub 2} {ellipsis}}{Type nospread}{TextReturns a font descriptor that is a copy of the font {arg OLDFONT}, but which differs from {arg OLDFONT} in that {arg OLDFONT}'s properties are replaced by the specified properties and values.  Thus, {lisp (FONTCOPY {arg FONT} 'WEIGHT 'BOLD 'DEVICE 'INTERPRESS)} will return a bold Interpress font with all other properties the same as those of {arg FONT}.  {fn FONTCOPY} accepts the properties {lisp FAMILY}, {lisp SIZE}, {lisp WEIGHT}, {lisp SLOPE}, {lisp EXPANSION}, {lisp FACE}, {lisp ROTATION}, and {lisp DEVICE}.  If the first property is a list, it is taken to be the {arg PROP{sub 1}} {arg VAL{sub 1}} {arg PROP{sub 2}} {arg VAL{sub 2}} {ellipsis} sequence.  Thus, {lisp (FONTCOPY {arg FONT} '(WEIGHT BOLD DEVICE INTERPRESS))} is equivalent to the example above.If the property {lisp NOERROR} is specified with value non-{lisp NIL}, {fn FONTCOPY} will return {lisp NIL} rather than causing an error if the specified font cannot be created.}}{FnDef {Name FONTSAVAILABLE} {Args FAMILY SIZE FACE ROTATION DEVICE CHECKFILESTOO?}{TextReturns a list of available fonts that match the given specification.  {arg FAMILY}, {arg SIZE}, {arg FACE}, {arg ROTATION}, and {arg DEVICE} are the same as for {fn FONTCREATE}.  Additionally, any of them can be the atom {lisp *}, in which case all values of that field are matched.If {arg CHECKFILESTOO?} is {lisp NIL}, only fonts already loaded into virtual memory will be considered.  If {arg CHECKFILESTOO?} is non-{lisp NIL}, the font directories for the specified device will be searched. When checking font files, the {arg ROTATION} is ignored.Note: The search is conditional on the status of the server which holds the font.  Thus a file server crash may prevent {fn FONTCREATE} from finding a file that an earlier {fn FONTSAVAILABLE} returned. Each element of the list returned will be of the form {lisp ({arg FAMILY} {arg SIZE} {arg FACE} {arg ROTATION} {arg DEVICE})}.Examples:{lispcode(FONTSAVAILABLE 'MODERN 10 'MRR 0 'DISPLAY)}will return {lisp ((MODERN 10 (MEDIUM REGULAR REGULAR) 0 DISPLAY))} if the regular Modern 10 font for the display is in virtual memory; {lisp NIL} otherwise.{lispcode(FONTSAVAILABLE '* 14 '* '* 'INTERPRESS T)}will return a list of all the size 14 Interpress fonts, whether they are in virtual memory or in font files. Warning:  One must be careful when using the function {fn FONTSAVAILABLE} to determine what {index Press format}Press font files are available.  For Press font families/faces, the font widths for different sizes are consistently scaled versions of the smallest font in the family/face.  Therefore, instead of storing data about all of the sizes in the {index FONTS.WIDTHS (File name)}{lisp FONTS.WIDTHS} file, only the widths for the font of {arg SIZE}=1 are stored, and the other widths are calculated by scaling these widths up.  This is signified in the {lisp FONTS.WIDTHS} file by a font with {arg SIZE}=0.  Therefore, if {fn FONTSAVAILABLE} is called with {arg CHECKFILESTOO?}={lisp T}, and it finds such a "relative" font, it returns a font spec list with size of 0.  For example, {lispcode&larr;(FONTSAVAILABLE 'GACHA '* '* 0 'PRESS T)((GACHA 0 (BOLD ITALIC REGULAR) 0 PRESS) (GACHA 0 (BOLD REGULAR REGULAR) 0 PRESS) (GACHA 0 (MEDIUM ITALIC REGULAR) 0 PRESS) (GACHA 0 (MEDIUM REGULAR REGULAR) 0 PRESS))}This indicates that Press files can be created with {lisp GACHA} files of any size with faces {lisp BIR}, {lisp BRR}, {lisp MIR}, and {lisp MRR}.  Of course, this doesn't guarantee that these fonts are available in all sizes on your printer.}}{FnDef {Name SETFONTDESCRIPTOR} {Args FAMILY SIZE FACE ROTATION DEVICE FONT}{TextIndicates to the system that {arg FONT} is the font that should be associated with the {arg FAMILY} {arg SIZE} {arg FACE} {arg ROTATION} {arg DEVICE} characteristics.  If {arg FONT} is {lisp NIL}, the font associated with these characteristics is cleared and will be recreated the next time it is needed.  As with {fn FONTPROP} and {fn FONTCOPY}, {arg FONT} is coerced to a font descriptor if it is not one already.This functions is useful when it is desirable to simulate an unavailable font or to use a font with characteristics different from the interpretations provided by the system.}}{FnDef {Name DEFAULTFONT} {Args DEVICE FONT {anonarg}}{TextReturns the font that would be used as the default (if {lisp NIL} were specified as a font argument) for image stream type {arg DEVICE}.  If {arg FONT} is a font descriptor, it is set to be the default font for {arg DEVICE}.}}{FnDef {Name CHARWIDTH} {Args CHARCODE FONT}{Text{arg CHARCODE} is an integer that represents a valid character (as returned by {fn CHCON1}).  Returns the amount by which an image stream's X-position will be incremented when the character is printed.}}{FnDef {Name CHARWIDTHY} {Args CHARCODE FONT}{TextLike {fn CHARWIDTH}, but returns the Y component of the character's width, the amount by which an image stream's Y-position will be incremented when the character is printed.  This will be zero for most characters in normal portrait fonts, but may be non-zero for landscape fonts or for vector-drawing fonts.{note Currently, the printing operations do not look at the character's Y-width, for performance reasons. -- document??}}}{FnDef {Name STRINGWIDTH} {Args STR FONT FLG RDTBL}{TextReturns the amount by which a stream's X-position will be incremented if the printname for the Interlisp-D object {arg STR} is printed in font {arg FONT}.  If {arg FONT} is an image stream, its font is used.  If {arg FLG} is non-{lisp NIL}, the {lisp PRIN2}-pname of {arg STR} with respect to the readtable {arg RDTBL} is used.}}{FnDef {Name STRINGREGION} {Args STR STREAM PRIN2FLG RDTBL}{TextReturns the region occupied by {arg STR} if it were printed at the current location in the image stream {arg STREAM}.  This is useful, for example, for determining where text is in a window to allow the user to select it.  The arguments {arg PRIN2FLG} and {arg RDTBL} are passed to {fn STRINGWIDTH}.Note:  {fn STRINGREGION} does not take into account any carriage returns in the string, or carriage returns that may be automatically printed if {arg STR} is printed to {arg STREAM}.  Therefore, the value returned is meaningless for multi-line strings.}}The following functions allow the user to access and change the bitmaps for individual characters in a display font.  Note:  Character code 256 can be used to access the "dummy" character, used for characters in the font with no bitmap defined.{note still true with NS chars???}{FnDef {Name GETCHARBITMAP} {Args CHARCODE FONT}{TextReturns a bitmap containing a copy of the image of the character {arg CHARCODE} in the font {arg FONT}.}}{FnDef {Name PUTCHARBITMAP} {Args CHARCODE FONT NEWCHARBITMAP NEWCHARDESCENT}{TextChanges the bitmap image of the character {arg CHARCODE} in the font {arg FONT} to the bitmap {arg NEWCHARBITMAP}.  If {arg NEWCHARDESCENT} is non-{lisp NIL}, the descent of the character is changed to the value of {arg NEWCHARDESCENT}.}}{FnDef {Name EDITCHAR} {Args CHARCODE FONT}{TextCalls the bitmap editor ({fn EDITBM}, {PageRef Fn EDITBM}) on the bitmap image of the character {arg CHARCODE} in the font {arg FONT}.  {arg CHARCODE} can be a character code (as returned by {fn CHCON1}) or an atom or string, in which case the first character of {arg CHARCODE} is used.}}}{End SubSec Fonts}{Begin Subsec Font Files and Font Directories}{Title Font Files and Font Directories}{TextIf {fn FONTCREATE} is called to create a font that has not been loaded into Interlisp, {fn FONTCREATE} has to read the font information from a font file that contains the information for that font.  For printer devices, the font files have to contain width information for each character in the font.  For display fonts, the font files have to contain, in addition, bitmap images for each character in the fonts.  The font file names, formats, and searching algorithms are different for each device.  There are a set of variables for each device, that determine the directories that are searched for font files.  All of these variables must be set before Interlisp can auto-load font files.  These variables should be initialized in the site-specific INIT file.{VarDef {Name DISPLAYFONTDIRECTORIES}{TextValue is a list of directories searched to find font bitmap files for display fonts.}}{VarDef {Name DISPLAYFONTEXTENSIONS}{TextValue is a list of file extensions used when searching {var DISPLAYFONTDIRECTORIES} for display fonts.  Initially set to {lisp (DISPLAYFONT)}, but when using older font files it may be necessary to add {lisp STRIKE} and {lisp AC} to this list.}}{VarDef {Name INTERPRESSFONTDIRECTORIES}{TextValue is a list of directories searched to find font widths files for {index Interpress format}Interpress fonts.}}{VarDef {Name PRESSFONTWIDTHSFILES}{TextValue is a list of files (not directories) searched to find font widths files for Press fonts.  {index Press format}Press font widths are packed into large files (usually named {index FONTS.WIDTHS (File name)}{lisp FONTS.WIDTHS}).}}}{End SubSec Font Files and Font Directories}{Begin Comment Font Classes de-documented, because only hackers use them}{Begin SubSec Font Classes}{Title Font Classes}{Text{Index *PRIMARY* Font classes}A font class is an instance of the {lisp FONTCLASS} data type{index FONTCLASS (Data type)} which contains a set of related fonts for different devices.  The font functions accept font classes, from which they extract the appropriate font for their device.  The normal font class variables ({var DEFAULTFONT}, {var CLISPFONT}, etc.) are initialized to font class objects.  Font classes are created and manipulated with the following functions:{FnDef {Name FONTCLASS} {Args NAME FONTLIST CREATEFORDEVICES}{TextReturns a new font class object with the name {arg NAME} and the device font components specified by {arg FONTLIST}, which should be a list of the form {lisp ({arg FONT#} {arg DISPLAYFONT} {arg PRESSFONT} {arg INTERPRESSFONT} {arg OTHERFONT{sub 1}} {arg OTHERFONT{sub 2}} {ellipsis})}.  {arg FONT#} is the font number used by {fn PRETTYPRINT} ({PageRef Fn PRETTYPRINT}) to change to the font.  {arg OTHERFONT{sub N}} should be a list of the form {lisp ({arg DEVICENAME} {arg FONT})}.  Each of the fonts in {arg FONTLIST} may be either a font descriptor, or a "font specification list" that {fn FONTCREATE} would accept.  {arg CREATEFORDEVICES} is a list of the devices for which the fonts should be automatically created.  Otherwise, the fonts are not actually created until they are accessed.  Note: if a display font is specified in {arg FONTLIST}, it is always created.}}{FnDef {Name FONTCLASSCOMPONENT} {Args FONTCLASS DEVICE FONT NOERRORFLG}{TextReturns the font component of the font class for the device {arg DEVICE} ({lisp DISPLAY}, {lisp INTERPRESS}, etc.).  If {arg FONT} is non-{lisp NIL}, the specified component is replaced.  If {arg NOERRORFLG} is non-{lisp NIL}, {fn FONTCLASSCOMPONENT} return {lisp NIL} if the component is unspecified in the font class, rather than causing an error.}}}{End SubSec Font Classes}{End Comment Font Classes de-documented, because only hackers use them}{Begin SubSec Font Profiles}{Title Font Profiles}{Text{note this needs to be EXTENSIVELY revised.  This has been changed drastically in Interlisp-D. (First cut taken, 15 Feb 84, Beau Sheil - more needed.)}{fn PRETTYPRINT} contains a facility for printing different elements (user functions, system functions, clisp words, comments, etc.) in different fonts to emphasize (or deemphasize) their importance, and in general to provide for a more pleasing appearance.  Of course, in order to be useful, this facility requires that the user is printing on a device (such as a bitmapped display or a laser printer) which supports multiple fonts.{fn PRETTYPRINT} signals font changes by inserting into the file a user-defined escape sequence (the value of the variable {var FONTESCAPECHAR}) followed by the character {it code} which specifies, by number, which font to use, i.e. {lisp &uarr;A} for font number 1, etc. Thus, if {var FONTESCAPECHAR} were the character {lisp &uarr;F}, {lisp &uarr;F&uarr;C} would be output to change to font 3, {lisp &uarr;F&uarr;A} to change to font 1, etc.  If {var FONTESCAPECHAR} consists of characters which are separator charactors in {var FILERDTBL}, then a file with font changes in it can also be loaded back in.Currently, {fn PRETTYPRINT} uses the following font classes.  The user can specify separate fonts for each of these classes, or use the same font for several different classes.{note Are these 'font classes' actually variables?  Should they be specified with VarDef's rather than a 'labeledlist'? Ans:  They are, but only incidentally. This format is right.}{Begin LabeledList font classes}{Label {index LAMBDAFONT (Font class)}{lisp LAMBDAFONT}}{TextThe font for printing the name of the function being prettyprinted, before the actual definition (usually a large font).}{Label {index CLISPFONT (Font class)}{lisp CLISPFONT}}{TextIf {var CLISPFLG} is on, the font for printing any clisp words, i.e. atoms with property {prop CLISPWORD}.}{Label {index COMMENTFONT (Font class)}{lisp COMMENTFONT}}{TextThe font used for comments.}{Label {index USERFONT (Font class)}{lisp USERFONT}}{TextThe font for the name of any function in the file, or any member of the list {var FONTFNS}.{index FONTFNS Var}}{Label {index SYSTEMFONT (Font class)}{lisp SYSTEMFONT}}{TextThe font for any other (defined) function.}{Label {index CHANGEFONT (Font class)}{lisp CHANGEFONT}}{TextThe font for an expression marked by the editor as having been changed.}{Label {index PRETTYCOMFONT (Font class)}{lisp PRETTYCOMFONT}}{TextThe font for the operand of a file package command.}{Label {index DEFAULTFONT (Font class)}{lisp DEFAULTFONT}}{TextThe font for everything else.}{End LabeledList font classes}Note that not all combinations of fonts will be aesthetically pleasing (or even readable!) and the user may have to experiment to find a compatible set.Although in some implementations {lisp LAMBDAFONT} et al. may be defined as variables, one should not set them directly, but should indicate what font is to be used for each class by calling the function {fn FONTPROFILE}:{FnDef {Name FONTPROFILE} {Args PROFILE}{TextSets up the font classes as determined by {arg PROFILE}, a list of elements which defines the correspondence between font classes and specific fonts.  Each element of {arg PROFILE} is a list of the form:{lispcode({arg FONTCLASS} {arg FONT#} {arg DISPLAYFONT} {arg PRESSFONT} {arg INTERPRESSFONT})}{arg FONTCLASS} is the font class name and {arg FONT#} is the font number for that class.  For each font class name, the escape sequence will consist of {var FONTESCAPECHAR} followed by the character {it code} for the font number, e.g. {lisp &uarr;A} for font number 1, etc.If {arg FONT#} is {lisp NIL} for any font class, the font class named {lisp DEFAULTFONT} (which must always be specified) is used.  Alternatively, if {arg FONT#} is the name of a previously defined font class, this font class will be equivalenced to the previously defined one.{arg DISPLAYFONT}, {arg PRESSFONT}, and {arg INTERPRESSFONT} are font specifications (of the form accepted by {fn FONTCREATE}) for the fonts to use when printing to the display and to {index Press format}Press and {index Interpress format}Interpress printers respectively.}}{VarDef {Name FONTPROFILE}{TextThis is the {it variable} used to store the current font profile, in the form accepted by the {it function} {fn FONTPROFILE}.  Note that simply editing this value will not change the fonts used for the various font classes; it is necessary to execute {lisp (FONTPROFILE FONTPROFILE)} to install the value of this variable. }}{index *PRIMARY* Font configurations}The process of printing with multiple fonts is affected by a large number of variables: {var FONTPROFILE}, {var FILELINELENGTH}, {var PRETTYLCOM}, etc.  To facilitate switching back and forth between various sets of values for the font variables, Interlisp supports the idea of named "font configurations" encapsulating the values of all relevant variables.To create a new font configuration, set all "relevant" variables to the values you want, and then call {fn FONTNAME} to save them (on the variable {var FONTDEFS}) under a given name.  To install a particular font configuration, call {fn FONTSET} giving it your name.  To change the values in a saved font configuration, edit the value of the variable {var FONTDEFS}.Note:  The list of variables saved by {fn FONTNAME} is stored in the variable {var FONTDEFSVARS}.  This can be changed by the user.{FnDef {FnName FONTNAME} {FnArgs NAME}{TextCollects the names and values of the variables on {var FONTDEFSVARS}, and saves them on {var FONTDEFS}.}}{FnDef {FnName FONTSET} {FnArgs NAME}{TextInstalls font configuration for {arg NAME}.  Also evaluates {lisp (FONTPROFILE FONTPROFILE)} to install the font classes as specified in the new value of the variable {var FONTPROFILE}.  Generates an error if {arg NAME} not previously defined.}}{VarDef {Name FONTDEFSVARS}{TextThe list of variables to be packaged by a {fn FONTNAME}.  Initially {var FONTCHANGEFLG}, {var FILELINELENGTH}, {var COMMENTLINELENGTH}, {var FIRSTCOL}, {var PRETTYLCOM}, {var LISTFILESTR}, and {var FONTPROFILE}.}}{VarDef {Name FONTDEFS}{TextAn association list of font configurations.  {var FONTDEFS} is a list of elements of form {lisp ({arg NAME} . {arg PARAMETER-PAIRS})}.  To save a configuration on a file after performing a {fn FONTNAME} to define it, the user could either save the entire value of {var FONTDEFS}, or use the {filecom ALISTS} file package command ({PageRef FileCom ALISTS}) to dump out just the one configuration.}}{VarDef {Name FONTESCAPECHAR}{TextThe character or string used to signal the start of a font escape sequence.}}{VarDef {Name FONTCHANGEFLG}{TextIf {lisp T}, enables fonts when prettyprinting.  If {lisp NIL}, disables fonts.}}{VarDef {Name LISTFILESTR}{TextIn Interlisp-10, passed to the operating system by {fn LISTFILES} ({PageRef Fn LISTFILES}).  Can be used to specify subcommands to the {lisp LIST} command, e.g. to establish correspondance between font number and font name.}}{VarDef {Name COMMENTLINELENGTH}{TextSince comments are usually printed in a smaller font, {var COMMENTLINELENGTH} is provided to offset the fact that Interlisp does not know about font widths.  When {var FONTCHANGEFLG}={lisp T}, {fn CAR} of {var COMMENTLINELENGTH} is the linelength used to print short comments, i.e. those printed in the right margin, and {fn CDR} is the linelength used when printing full width comments.}}{FnDef {FnName CHANGEFONT} {FnArgs FONT STREAM}{TextExecutes the operations on {arg STREAM} to change to the font {arg FONT}.  For use in {var PRETTYPRINTMACROS}.}}{Begin Note}Date: 18 May 1982 12:09 pm PDT (Tuesday)From: JonL.PAPoints on the mail manual, not previously sent to MANUAL:  2) P14.51ff, for "fontsets" -- I think a fontset should be described as a conceptual object with components (more like a DATATYPE or RECORD).  That will make it more apparent that FONTESCAPECHAR is not a component of a fontset, whereas many of the other GLOBALVARS in this section are in fact to be viewed as components.  This touches on the sticky problem of using GLOBALVARS where one meant SPECIAL vars, as shown up by the multiprocessing problem; viewing a FONTSET as a compound object from the very beginning bypasses this problem.     Questions:        2a) Does FONTNAME really mean "create a FontSet"?       2b) Does FONTSET  mean "set the current (or default?) font configuration to be that of argument"?       2c) CHANGEFONT, then, only retrieves information from the profile of the current font configuration, right? and then outputs a font change character sequence?{End Note}}{End SubSec Font Profiles}</pre>
  </body>
</html>
