{Begin Subsec Opening Image Streams}{Title Opening Image Streams}{Text{Index *PRIMARY* Image streams}An image stream is an output stream which "knows" how to process graphic commands to a graphics output device.  Besides accepting the normal character-output functions ({fn PRINT}, etc.), an image stream can also be passed as an argument to functions to draw curves, to print characters in multiple fonts, and other graphics operations.{index *PRIMARY* Image stream types}{Index DISPLAY (Image stream type)}{Index *PRIMARY* INTERPRESS (Image stream type)}{Index *PRIMARY* PRESS (Image stream type)}Each image stream has an "image stream type," a litatom that specifies the type of graphic output device that the image stream is processing graphics commands for.  Currently, the built-in image stream types are {lisp DISPLAY} (for the display screen), {lisp INTERPRESS} (for {index Interpress format}Interpress format printers), and {lisp PRESS} (for {index Press format}Press format printers).  There are also library packages available that define image stream types for the IRIS display, 4045 printer, FX-80 printer, C150 printer, etc.Image streams to the display (display streams{Index Display streams}) interpret graphics commands by immediately executing the appropriate operations to cause the desired image to appear on the display screen.  Image streams for hardcopy devices such as Interpress printers interpret the graphic commands by saving information in a file, which can later be sent to the printer.Note:  Not all graphics operations can be properly executed for all image stream types.  For example, {fn BITBLT} may not be supported to all printers.  This functionality is still being developed, but even in the long run some operations may be beyond the physical or logical capabilities of some devices or image file formats.  In these cases, the stream will approximate the specified image as best it can.{FnDef {Name OPENIMAGESTREAM} {Args FILE IMAGETYPE OPTIONS}{TextOpens and returns an image stream of type {arg IMAGETYPE} on a destination specified by {arg FILE}.  If {arg FILE} is a file name on a normal file storage device, the image stream will store graphics commands on the specified file, which can be transmitted to a printer by explicit calls to {fn LISTFILES} and {fn SEND.FILE.TO.PRINTER}.  If {arg IMAGETYPE} is {lisp DISPLAY}, then the user is prompted for a window to open.  {arg FILE} in this case will be used as the title of the window.If {arg FILE} is a file name on the {lisp LPT} device, this indicates that the graphics commands should be stored in a temporary file, and automatically sent to the printer when the image stream is closed by {fn CLOSEF}.  {arg FILE} = {lisp NIL} is equivalent to {arg FILE} = {lisp {bracket LPT}}.  File names on the {lisp LPT} device are of the form {lisp {bracket LPT}{arg PRINTERNAME}.{arg TYPE}}, where {arg PRINTERNAME}, {arg TYPE}, or both may be omitted.  {arg PRINTERNAME} is the name of the particular printer to which the file will be transmitted on closing; it defaults to the first printer on {var DEFAULTPRINTINGHOST} that can print {arg IMAGETYPE} files.  The {arg TYPE} extension supplies the value of {arg IMAGETYPE} when it is defaulted (see below).  {fn OPENIMAGESTREAM} will generate an error if the specified printer does not accept the kind of file specified by {arg IMAGETYPE}.If {arg IMAGETYPE} is {lisp NIL}, the image type is inferred from the extension field of {arg FILE} and the {lisp EXTENSIONS} properties in the list {var PRINTFILETYPES}{index PRINTFILETYPES Var} (see {PageRef Var PRINTFILETYPES}).  Thus, the extensions {lisp IP}, {lisp IPR}, and {lisp INTERPRESS} indicate {index Interpress format}Interpress format, and the extension {lisp PRESS} indicates {index Press format}Press format.  If {arg FILE} is a printer file with no extension (of the form {lisp {bracket LPT}{arg PRINTERNAME}}), then {arg IMAGETYPE} will be the type that the indicated printer can print.  If {arg FILE} has no extension but is not on the printer device {lisp {bracket LPT}}, then {arg IMAGETYPE} will default to the type accepted by the first printer on {var DEFAULTPRINTINGHOST}.  {arg OPTIONS} is a list in property list format, {lisp ({arg PROP1} {arg VAL1} {arg PROP2} {arg VAL2} {anonarg})}, used to specify certain attributes of the image stream; not all attributes are meaningful or interpreted by all types of image streams.  Acceptable properties are:{Begin labeledlist OPENIMAGESTREAM options}{Label {lisp REGION}}{TextValue is the region on the page (in stream scale units, 0,0 being the lower-left corner of the page) that text will fill up.  It establishes the initial values for {fn DSPLEFTMARGIN}, {fn DSPRIGHTMARGIN}, {fn DSPBOTTOMMARGIN} (the point at which carriage returns cause page advancement) and {fn DSPTOPMARGIN} (where the stream is positioned at the beginning of a new page).If this property is not given, the value of the variable {var DEFAULTPAGEREGION},{index DEFAULTPAGEREGION Var} is used.}{Label {lisp FONTS}}{TextValue is a list of fonts that are expected to be used in the image stream.  Some image streams (e.g. Interpress) are more efficient if the expected fonts are specified in advance, but this is not necessary.  The first font in this list will be the initial font of the stream, otherwise the default font for that image stream type will be used.}{Label {lisp HEADING}}{TextValue is the heading to be placed automatically on each page.  {lisp NIL} means no heading.}{End labeledlist OPENIMAGESTREAM options}{Begin Note}This option should not be documented --- eventually, this will be done "right", using a DSPROTATE function:LANDSCAPE --- If the value is non-{lisp NIL}, printing onto the image stream is done in "landscape" mode, with the page rotated 90 degrees.{End Note}}}Examples:  Suppose that {lisp Tremor:} is an {index Interpress format}Interpress printer, {lisp Quake} is a {index Press format}Press printer, and {var DEFAULTPRINTINGHOST} is {lisp (Tremor: Quake)}:{lisp (OPENIMAGESTREAM)} returns an Interpress image stream on printer {lisp Tremor:}.{lisp (OPENIMAGESTREAM NIL 'PRESS)} returns a Press stream on {lisp Quake}.{lisp (OPENIMAGESTREAM '{bracket LPT}.INTERPRESS)} returns an Interpress stream on {lisp Tremor:}.{lisp (OPENIMAGESTREAM '{bracket CORE}FOO.PRESS)} returns a Press stream on the file {lisp {bracket CORE}FOO.PRESS}.{FnDef {Name IMAGESTREAMP} {Args X IMAGETYPE}{Type nospread}{TextReturns {arg X} (possibly coerced to a stream) if it is an output image stream of type {arg IMAGETYPE} (or of any type if {arg IMAGETYPE}={lisp NIL}), otherwise {lisp NIL}.}}{FnDef {Name IMAGESTREAMTYPE} {Args STREAM}{TextReturns the image stream type of {arg STREAM}.}}{FnDef {Name IMAGESTREAMTYPEP} {Args STREAM TYPE}{TextReturns {lisp T} if {arg STREAM} is an image stream of type {arg TYPE}.}}}{End Subsec Opening Image Streams}{Begin SubSec Accessing Image Stream Fields}{Title Accessing Image Stream Fields}{TextThe following functions manipulate the fields of an image stream.  These functions return the old value (the one being replaced).  A value of {lisp NIL} for the new value will return the current setting without changing it.  These functions do not change any of the bits drawn on the image stream; they just affect future operations done on the image stream.{FnDef {Name DSPCLIPPINGREGION} {Args REGION STREAM}{TextThe clipping region{index Clipping region} is a region that limits the extent of characters printed and lines drawn (in the image stream's coordinate system).  Initially set so that no clipping occurs.Warning:  For display streams, the window system maintains the clipping region during window operations.  Users should be very careful about changing this field.}}{FnDef {Name DSPFONT} {Args FONT STREAM}{TextThe font field specifies the font (see {PageRef Term Fonts}) used when printing characters to the image stream.{Index Fonts}Note:  {fn DSPFONT} determines its new font descriptor from {arg FONT} by the same coercion rules that {fn FONTPROP} and {fn FONTCREATE} use ({PageRef Fn FONTCREATE}), with one additional possibility: If {arg FONT} is a list of the form {lisp ({arg PROP{sub 1}} {arg VAL{sub 1}} {arg PROP{sub 2}} {arg VAL{sub 2}} {ellipsis})} where {arg PROP{sub 1}} is acceptable as a font-property to {fn FONTCOPY} ({PageRef Fn FONTCOPY}), then the new font is obtained by {lisp ({fn FONTCOPY} ({fn DSPFONT}  NIL {arg STREAM}) {arg  PROP{sub 1}} {arg VAL{sub 1}} {arg  PROP{sub 2}} {arg VAL{sub 2}} {ellipsis})}.  For example, {lisp (DSPFONT '(SIZE 12) {arg STREAM})} would change the font to the 12 point version of the current font, leaving all other font properties the same.}}{FnDef {Name DSPTOPMARGIN} {Args YPOSITION STREAM}{TextThe top margin{Index Top margin} is an integer that is the Y position after a new page (in the image stream's coordinate system).  This function has no effect on windows.}}{FnDef {Name DSPBOTTOMMARGIN} {Args YPOSITION STREAM}{TextThe bottom margin{Index Bottom margin} is an integer that is the minimum Y position that characters will be printed by {lisp PRIN1} (in the image stream's coordinate system).  This function has no effect on windows.}}{FnDef {Name DSPLEFTMARGIN} {Args XPOSITION STREAM}{TextThe left margin{Index Left margin} is an integer that is the X position after an end-of-line (in the image stream's coordinate system).  Initially the left edge of the clipping region.}}{FnDef {Name DSPRIGHTMARGIN} {Args XPOSITION STREAM}{TextThe right margin{Index Right margin} is an integer that is the maximum X position that characters will be printed by {lisp PRIN1} (in the image stream's coordinate system).  This is initially the position of the right edge of the window or page.}}The line length{Index Line length} of a window or image stream (as returned by {fn LINELENGTH},{Index LINELENGTH Fn} {PageRef Fn LINELENGTH}) is computed by dividing the distance between the left and right margins by the width of an uppercase "A" in the current font.  The line length is changed whenever the font, left margin, or right margin are changed or whenever the window is reshaped.{FnDef {Name DSPOPERATION} {Args OPERATION STREAM}{TextThe operation is the default {lisp BITBLT} operation (see {PageRef (BITBLT argument) OPERATION}) used when printing or drawing on the image stream.  One of {lisp REPLACE}, {lisp PAINT}, {lisp INVERT}, or {lisp ERASE}.  Initially {lisp REPLACE}.  This is a meaningless operation for most printers which support the model that once dots are deposited on a page they cannot be removed.}}{FnDef {Name DSPLINEFEED} {Args DELTAY STREAM}{TextThe linefeed is an integer that specifies the Y increment for each linefeed, normally negative.  Initially minus the height of the initial font.}}{FnDef {Name DSPSCALE} {Args SCALE STREAM} {TextReturns the scale of the image stream {arg STREAM}, a number indicating how many units in the streams coordinate system correspond to one printer's point (1/72 of an inch).  For example, {fn DSPSCALE} returns 1 for display streams, and 35.27778 for {index Interpress format}Interpress and {index Press format}Press streams (the number of micas per printer's point).  In order to be device-independent, user graphics programs must either not specify position values absolutely, or must multiply absolute point quantities by the {fn DSPSCALE} of the destination stream.  For example, to set the left margin of the Interpress stream {lisp XX} to one inch, do{lispcode(DSPLEFTMARGIN (TIMES 72 (DSPSCALE NIL XX)) XX)} The {arg SCALE} argument to {fn DSPSCALE} is currently ignored.  In a future release it will enable the scale of the stream to be changed under user control, so that the necessary multiplication will be done internal to the image stream interface.  In this case, it would be possible to set the left margin of the Interpress stream {lisp XX} to one inch by doing{lispcode(DSPSCALE 1 XX)(DSPLEFTMARGIN 72 XX)} }}{FnDef {Name DSPSPACEFACTOR} {Args FACTOR STREAM} {TextThe space factor{index Space factor} is the amount by which to multiply the natural width of all following space characters on {arg STREAM}; this can be used for the justification of text.  The default value is 1.  For example, if the natural width of a space in {arg STREAM}'s current font is 12 units, and the space factor is set to two, spaces appear 24 units wide.  The values returned by {fn STRINGWIDTH} and {fn CHARWIDTH} are also affected.}}The following two functions only have meaning for image streams that can display color:{FnDef {Name DSPCOLOR} {Args COLOR STREAM}{TextSets the default foreground color of {arg STREAM}.  Returns the previous foreground color.  If {arg COLOR} is {lisp NIL}, it returns the current foreground color without changing anything.  The default color is white}}{FnDef {Name DSPBACKCOLOR} {Args COLOR STREAM}{TextSets the background color of {arg STREAM}.  Returns the previous background color.  If {arg COLOR} is {lisp NIL}, it returns the current background color without changing anything.  The default background color is black.}}}{End SubSec Accessing Image Stream Fields}{Begin SubSec Current Position of an Image Stream}{Title Current Position of an Image Stream}{Text{index *PRIMARY* Current position of image stream}Each image stream has a "current position," which is a position (in the image stream's coordinate system) where the next printing operation will start from.  The functions which print characters or draw on an image stream update these values appropriately.  The following functions are used to explicitly access the current position of an image stream:{FnDef {Name DSPXPOSITION} {Args XPOSITION STREAM}{TextReturns the X coordinate of the current position of {arg STREAM}.  If {arg XPOSITION} is non-{lisp NIL}, the X coordinate is set to it (without changing the Y coordinate).}}{FnDef {Name DSPYPOSITION} {Args YPOSITION STREAM}{TextReturns the Y coordinate of the current position of {arg STREAM}.  If {arg YPOSITION} is non-{lisp NIL}, the Y coordinate is set to it (without changing the X coordinate).}}{FnDef {Name MOVETO} {Args X Y STREAM}{TextChanges the current position of {arg STREAM} to the point {lisp ({arg X},{arg Y})}.}}{FnDef {Name RELMOVETO} {Args DX DY STREAM}{TextChanges the current position to the point {lisp ({arg DX},{arg DY})}coordinates away from current position of {arg STREAM}.}}{FnDef {Name MOVETOUPPERLEFT} {Args STREAM REGION}{TextMoves the current position to the beginning position of the top line of text.  If {arg REGION} is non-{lisp NIL}, it must be a {lisp REGION} and the X position is changed to the left edge of {arg REGION} and the Y position changed to the top of {arg REGION} less the font ascent of {arg STREAM}.  If {arg REGION} is {lisp NIL}, the X coordinate is changed to the left margin of {arg STREAM} and the Y coordinate is changed to the top of the clipping region of {arg STREAM} less the font ascent of {arg STREAM}.}}}{End SubSec Current Position of an Image Stream}{Begin SubSec Moving Bits Between Bitmaps With BITBLT}{Title Moving Bits Between Bitmaps With BITBLT}{Text{fn BITBLT} is the primitive function for moving bits from one bitmap to another, or from a bitmap to an image stream.{FnDef {Name BITBLT} {Args SOURCE SOURCELEFT SOURCEBOTTOM DESTINATION DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT SOURCETYPE OPERATION TEXTURE CLIPPINGREGION}{TextTransfers a rectangular array of bits from {arg SOURCE} to {arg DESTINATION}.    {arg SOURCE} can be a bitmap, or a display stream or window, in which case its associated bitmap is used. {arg DESTINATION} can be a bitmap or an arbitrary image stream.{arg WIDTH} and {arg HEIGHT} define a pair of rectangles, one in each of the {arg SOURCE} and {arg DESTINATION} whose left, bottom corners are at, respectively, ({arg SOURCELEFT}, {arg SOURCEBOTTOM}) and ({arg DESTINATIONLEFT}, {arg DESTINATIONBOTTOM}).  If these rectangles overlap the boundaries of either source or destination they are both reduced in size (without translation) so that they fit within their respective boundaries.  If {arg CLIPPINGREGION} is non-{lisp NIL} it should be a {lisp REGION} and is interpreted as a clipping region within {arg DESTINATION}; clipping to this region may further reduce the defining rectangles.  These (possibly reduced) rectangles define the source and destination rectangles for {fn BITBLT}. The mode of transferring bits is defined by {arg SOURCETYPE} and {arg OPERATION}.  {arg SOURCETYPE} and {arg OPERATION} specify whether the source bits should come from {arg SOURCE} or {arg TEXTURE}, and how these bits are combined with those of {arg DESTINATION}.  {arg SOURCETYPE} and {arg OPERATION} are described further below.{arg TEXTURE} is a texture, as described on {PageRef Tag Textures}.  {fn BITBLT} aligns the texture so that the upper-left pixel of the texture coincides with the upper-left pixel of the destination bitmap.{arg SOURCELEFT}, {arg SOURCEBOTTOM}, {arg DESTINATIONLEFT}, and {arg DESTINATIONBOTTOM} default to 0.  {arg WIDTH} and {arg HEIGHT} default to the width and height of the {arg SOURCE}.  {arg TEXTURE} defaults to white.  {arg SOURCETYPE} defaults to {lisp INPUT}.  {arg OPERATION} defaults to {lisp REPLACE}.  If {arg CLIPPINGREGION} is not provided, no additional clipping is done.  {fn BITBLT} returns {lisp T} if any bits were moved; {lisp NIL} otherwise.Note:  If {arg SOURCE} or {arg DESTINATION} is a window or image stream, the remaining arguments are interpreted as values in the coordinate system of the window or image stream and the operation of {fn BITBLT} is translated and clipped accordingly.  Also, if a window or image stream is used as the destination to {fn BITBLT}, its clipping region further limits the region involved.}}{arg SOURCETYPE} specifies whether the source bits should come from the bitmap {arg SOURCE}, or from the texture {arg TEXTURE}.  {arg SOURCETYPE} is interpreted as follows:{index *PRIMARY* SOURCETYPE (BITBLT argument)}{Begin LabeledList Sourcetype specifies}{Label {lisp INPUT}}{Text The source bits come from {arg SOURCE}.  {arg TEXTURE} is ignored.}{Label {lisp INVERT}}{Text The source bits are the inverse of the bits from {arg SOURCE}.  {arg TEXTURE} is ignored.}{Label {lisp TEXTURE}}{Text The source bits come from {arg TEXTURE}.  {arg SOURCE}, {arg SOURCELEFT}, and {arg SOURCEBOTTOM} are ignored.}{End LabeledList Sourcetype specifies}{arg OPERATION} specifies how the source bits (as specified by {arg SOURCETYPE}) are combined with the bits in {arg DESTINATION} and stored back into {arg DESTINATION}.  {arg DESTINATION} is one of the following:{index *PRIMARY* OPERATION (BITBLT argument)}{Begin LabeledList Operation specifies}{Label {lisp REPLACE}}{Text All source bits (on or off) replace destination bits.}{Label {lisp PAINT}}{Text Any source bits that are on replace the corresponding destination bits.  Source bits that are off have no effect.  Does a logical OR between the source bits and the destination bits.}{Label {lisp INVERT}}{Text Any source bits that are on invert the corresponding destination bits.  Does a logical XOR between the source bits and the destination bits.}{Label {lisp ERASE}}{Text Any source bits that are on erase the corresponding destination bits.  Does a logical AND operation between the inverse of the source bits and the destination bits.}{End LabeledList Operation specifies}Different combinations of {arg SOURCETYPE} and {arg OPERATION} can be specified to achieve many different effects.  Given the following bitmaps as the values of {arg SOURCE}, {arg TEXTURE}, and {arg DESTINATION}:{lispcode    < F ÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğü     ğü     ğü     ğü     ğü     ğü     ğü     ğü     ğü  ?À ğü  ÿğ ğü ÿü ğü ÿş ğü ÿÿ ğü ÿÿ€ğü ?àÀğü €àğü ~ àğü ş ğğü ü ğğüü øğüø øğüø øğüø øğüø øğüø øğüø øğüü øğü ü ğğü ş ğğü ~ àğü €àğü ?àÀğü ÿÿ€ğü ÿÿ ğü ÿş ğü ÿü ğü  ÿğ ğü  ?À ğü     ğü     ğü     ğü     ğü     ğü     ğü     ğü     ğü     ğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğÿÿÿÿÿÿÿğ                        <û›Ç¾   a›l0   q›l0   9›Ì>   ›l0   ›l0   øøó'¾                      ; F DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""         DDDDDDD@fffffff`"""""""                                 ûìßæóà  3ÆfÛ   3†fÛ   3ãfóà  3†fÛ   3ÆfÛ   3ìÆ<Ëà                     P Z ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ          ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                              xùï¶bgÌÀ lÃ6gllÀ fÃƒ7glnÀ fùÃ7m†lnÀ fÀã6ï†lmÀ lÀc6ÿÆlmÀ xÿÃ6xÆgÌÀ }{fn BITBLT} would produce the results given below for the difference combinations of {arg SOURCETYPE} and {arg OPERATION} (assuming {arg CLIPPINGREGION}, {arg SOURCELEFT}, etc. are set correctly, of course):{biglispcode     P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿ      ü ÿÿ      ü ÿÿ      ü ÿÿ      ü ÿÿ      ü ÿÿ      ü ÿÿ      ü ÿÿ      ü ÿÿ  ğ  ü ÿÿ  ?ü  ü ÿÿ  ÿÿ  ü ÿÿ ÿÿ€ ü ÿÿ ÿÿÀ ü ÿÿ ÿÿà ü ÿÿ øğ ü ÿÿ àø ü ÿÿ €ø ü ÿÿ ?€ü ü ÿÿ ?  ü ü ÿÿ   ş ü ÿÿ ~  ~ ü ÿÿ ~  ~ ü ÿÿ ~  ~ ü  ? ~  ~ ÿÿ ? ~  ~ ÿÿ ? ~  ~ ÿÿ ?   ş ÿÿ ? ?  ü ÿÿ ? ?€ü ÿÿ ? €ø ÿÿ ? àø ÿÿ ? øğ ÿÿ ? ÿÿà ÿÿ ? ÿÿÀ ÿÿ ? ÿÿ€ ÿÿ ?  ÿÿ  ÿÿ ?  ?ü  ÿÿ ?  ğ  ÿÿ ?      ÿÿ ?      ÿÿ ?      ÿÿ ?      ÿÿ ?      ÿÿ ?      ÿÿ ?      ÿÿ ?      ÿÿ ?      ÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  7¹¾  `   6ÙŒ  öŞ8ü¶ÙŒ  fÛlü¶ÙŒ  g›| w™Œ  c›`üvŒ  3<ü6                                 y÷˜ ÷À    m†Øq†  9ãğm†Øq†  m³ğyöØÙ‡À m° m‡˜ù†  m³ğm†ı†  9ãğeöŒ÷À €        €                           P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿÿÿÿü ÿÿÿÿÿ   ü ÿÿÿÿÿ   ü ÿÿÿÿÿ   ü ÿÿÿÿÿ   ü ÿÿÿÿÿ   ü ÿÿÿÿÿ   ü ÿÿÿÿÿ   ü ÿÿÿÿÿ   ü ÿÿÿÿÿğ  ü ÿÿÿÿÿü  ü ÿÿÿÿÿÿ  ü ÿÿÿÿÿÿ€ ü ÿÿÿÿÿÿÀ ü ÿÿÿÿÿÿà ü ÿÿÿÿÿğ ü ÿÿÿÿÿø ü ÿÿÿÿÿø ü ÿÿÿÿÿü ü ÿÿÿÿÿ ü ü ÿÿÿÿÿ ş ü ÿÿÿÿÿ ~ ü ÿÿÿÿÿ ~ ü ÿÿÿÿÿ ~ ü  ? ~ ÿÿÿÿÿ ? ~ ÿÿÿÿÿ ? ~ ÿÿÿÿÿ ?  ÿÿÿÿÿ ? ? ÿÿÿÿÿ ? ?€ÿÿÿÿÿ ? €ÿÿÿÿÿ ? àÿÿÿÿÿ ? øÿÿÿÿÿ ? ÿÿÿÿÿÿ ? ÿÿÿÿÿÿ ? ÿÿÿÿÿÿ ?  ÿÿÿÿÿÿ ?  ?ÿÿÿÿÿ ?  ÿÿÿÿÿ ?   ÿÿÿÿÿ ?   ÿÿÿÿÿ ?   ÿÿÿÿÿ ?   ÿÿÿÿÿ ?   ÿÿÿÿÿ ?   ÿÿÿÿÿ ?   ÿÿÿÿÿ ?   ÿÿÿÿÿ ?   ÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ ?ÿÿÿÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  7¹¾  `   6ÙŒ  öŞ8ü¶ÙŒ  fÛlü¶ÙŒ  g›| w™Œ  c›`üvŒ  3<ü6                                 xCfø      lãf0   9ãğlãv0   m³ğm³v0   m° yón0   m³ğcûn0   9ãğcf0   €        €                           P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÀ   ÿÿÿü ÿÀ   ÿÿÿü ÿÀ   ÿÿÿü ÿÀ   ÿÿÿü ÿÀ   ÿÿÿü ÿÀ   ÿÿÿü ÿÀ   ÿÿÿü ÿÀÿÿÿ   ü ÿÀÿÿÿ   ü ÿÀÿÿÿ   ü ÿÀÿÿÿ   ü ÿÀÿÿÿ   ü ÿÀÿÿÿ   ü ÿÀÿÿÿ   ü ÿÀÿÿÿ   ü ÿÀÿÿğğ  ü ÿÀÿÿÀü  ü ÿÀÿÿ ÿ  ü ÿÀÿş ÿ€ ü ÿÀÿü ÿÀ ü ÿÀÿø ÿà ü ÿÀÿğğ ü ÿÀÿàø ü ÿÀÿàø ü ÿÀÿÀü ü ÿÀÿÀÿ ü ü ÿÀÿ€ÿ ş ü ÿÀÿÿ ~ ü ÿÀÿÿ ~ ü ÿÀÿÿ ~ ü  ? ~ ÿÿÿ ? ~ ÿÿÿ ? ~ ÿÿÿ ?  ÿÿÿ ? ? ÿÿÿ ? ?€şÿÿ ? €şÿÿ ? àøÿÿ ? øàÿÿ ? ÿ ÿÿ ? ÿ ?ÿÿ ? ÿ ÿÿ ?  ÿ ÿÿÿ ?  ?ÿÿÿ ?  ÿÿÿ ?   ÿÿÿÿ ?   ÿÿÿÿ ?   ÿÿÿÿ ?   ÿÿÿÿ ?   ÿÿÿÿ ?   ÿÿÿÿ ?   ÿÿÿÿ ?   ÿÿÿÿ ?   ÿÿÿÿ ?ÿÿÿ   ÿ ?ÿÿÿ   ÿ ?ÿÿÿ   ÿ ?ÿÿÿ   ÿ ?ÿÿÿ   ÿ ?ÿÿÿ   ÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  7¹¾  `   6ÙŒ  öŞ8ü¶ÙŒ  fÛlü¶ÙŒ  g›| w™Œ  c›`üvŒ  3<ü6                                 lñ¾óà     lñ°ØÀ  9ãğnÛ0ØÀ  m³ğnÛ>ğÀ  m° mÎ0ØÀ  m³ğmÎ0ØÀ  9ãğlÄ>ÈÀ  €        €                           P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÀ        ÿÀ        ÿÀ        ÿÀ        ÿÀ        ÿÀ        ÿÀ        ÿÀÿÿÿ     ÿÀÿÿÿ     ÿÀÿÿÿ     ÿÀÿÿÿ     ÿÀÿÿÿ     ÿÀÿÿÿ     ÿÀÿÿÿ     ÿÀÿÿÿ     ÿÀÿÿğ     ÿÀÿÿÀ     ÿÀÿÿ      ÿÀÿş      ÿÀÿü      ÿÀÿø      ÿÀÿğ     ÿÀÿà     ÿÀÿà     ÿÀÿÀ     ÿÀÿÀÿ     ÿÀÿ€ÿ     ÿÀÿÿ     ÿÀÿÿ     ÿÀÿÿ          ÿÿÿ     ÿÿÿ     ÿÿÿ     ÿÿÿ     ÿÿÿ     şÿÿ     şÿÿ     øÿÿ     àÿÿ      ÿÿ      ?ÿÿ      ÿÿ      ÿÿÿ     ÿÿÿ     ÿÿÿ     ÿÿÿÿ     ÿÿÿÿ     ÿÿÿÿ     ÿÿÿÿ     ÿÿÿÿ     ÿÿÿÿ     ÿÿÿÿ     ÿÿÿÿ     ÿÿÿÿ        ÿ        ÿ        ÿ        ÿ        ÿ        ÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  7¹¾  `   6ÙŒ  öŞ8ü¶ÙŒ  fÛlü¶ÙŒ  g›| w™Œ  c›`üvŒ  3<ü6                                 }á¾      a³Œ0   9ãğa³0   m³ğ}æÇ>   m° a·Ã°   m³ğa¿á°   9ãğ}œ>   €        €        }{biglispcode     P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÀ        ÿÀ        ÿÀ        ÿÀ        ÿÀ        ÿÀ        ÿÀ        ÿÀÿÿÿÿÿÿ  ÿÀÿÿÿÿÿÿ  ÿÀÿÿÿÿÿÿ  ÿÀÿÿÿÿÿÿ  ÿÀÿÿÿÿÿÿ  ÿÀÿÿÿÿÿÿ  ÿÀÿÿÿÿÿÿ  ÿÀÿÿÿÿÿÿ  ÿÀÿÿğÿÿ  ÿÀÿÿÀÿÿ  ÿÀÿÿ  ÿÿ  ÿÀÿş  ÿ  ÿÀÿü  ?ÿ  ÿÀÿø  ÿ  ÿÀÿğàÿ  ÿÀÿàøÿ  ÿÀÿàşÿ  ÿÀÿÀşÿ  ÿÀÿÀÿÿÿ  ÿÀÿ€ÿÿÿ  ÿÀÿÿÿÿ  ÿÀÿÿÿÿ  ÿÀÿÿÿÿ    ÿÿÿÿÿ  ÿÿÿÿÿ  ÿÿÿÿÿ  ÿ€ÿÿÿÿ  ÿÀÿÿÿÿ  ÿÀşÿÿ  ÿàşÿÿ  ÿàøÿÿ  ÿğàÿÿ  ÿø  ÿÿ  ÿü  ?ÿÿ  ÿş  ÿÿ  ÿÿ  ÿÿÿ  ÿÿÀÿÿÿ  ÿÿğÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ        ÿ        ÿ        ÿ        ÿ        ÿ        ÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  <o¼ø `   <l60 öŞ8ü¶Ì60 fÛlü¶Ï¼0 g›| sŒ60 c›`üsŒ60 3<ü1²0                                y÷˜ ÷À    m†Øq†  9ãğm†Øq†  m³ğyöØÙ‡À m° m‡˜ù†  m³ğm†ı†  9ãğeöŒ÷À €        €                           P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿ ÿÿ  ÿÿÿÿÿ ÿ  ÿÿÿÿÿ ?ÿ  ÿÿÿÿÿ ÿ  ÿÿÿÿÿàÿ  ÿÿÿÿÿøÿ  ÿÿÿÿÿşÿ  ÿÿÿÿÿşÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ    ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿ  ÿ€ÿÿÿÿÿÿ  ÿÀÿÿÿÿÿÿ  ÿÀÿÿÿÿÿ  ÿàÿÿÿÿÿ  ÿàÿÿÿÿÿ  ÿğÿÿÿÿÿ  ÿø ÿÿÿÿÿ  ÿü ÿÿÿÿÿ  ÿş ÿÿÿÿÿ  ÿÿ ÿÿÿÿÿ  ÿÿÀÿÿÿÿÿ  ÿÿğÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ  ÿÿÿÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  <o¼ø `   <l60 öŞ8ü¶Ì60 fÛlü¶Ï¼0 g›| sŒ60 c›`üsŒ60 3<ü1²0                                xCfø      lãf0   9ãğlãv0   m³ğm³v0   m° yón0   m³ğcûn0   9ãğcf0   €        €                           P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿ   ÿÿÿ  ÿÿ   ÿÿÿ  ÿÿ   ÿÿÿ  ÿÿ   ÿÿÿ  ÿÿ   ÿÿÿ  ÿÿ   ÿÿÿ  ÿÿ   ÿÿÿ  ÿÿ   ÿÿÿ  ÿÿ  ÿÿ  ÿÿ  ?ÿÿ  ÿÿ  ÿ ÿÿ  ÿÿ ÿ ÿ  ÿÿ ÿ ?ÿ  ÿÿ ÿ ÿ  ÿÿ øàÿ  ÿÿ àøÿ  ÿÿ €şÿ  ÿÿ ?€şÿ  ÿÿ ? ÿÿ  ÿÿ  ÿÿ  ÿÿ ~ ÿÿ  ÿÿ ~ ÿÿ  ÿÿ ~ ÿÿ    ÿÿ ~ ÿÿ  ÿÿ ~ ÿÿ  ÿÿ ~ ÿÿ  ÿ€ÿ ş ÿÿ  ÿÀÿ ü ÿÿ  ÿÀü ÿÿ  ÿàø ÿÿ  ÿàø ÿÿ  ÿğğ ÿÿ  ÿø ÿà ÿÿ  ÿü ÿÀ ÿÿ  ÿş ÿ€ ÿÿ  ÿÿ ÿ  ÿÿ  ÿÿÀü  ÿÿ  ÿÿğğ  ÿÿ  ÿÿÿ   ÿÿ  ÿÿÿ   ÿÿ  ÿÿÿ   ÿÿ  ÿÿÿ   ÿÿ  ÿÿÿ   ÿÿ  ÿÿÿ   ÿÿ  ÿÿÿ   ÿÿ  ÿÿÿ   ÿÿ  ÿÿÿ   ÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  <o¼ø `   <l60 öŞ8ü¶Ì60 fÛlü¶Ï¼0 g›| sŒ60 c›`üsŒ60 3<ü1²0                                lñ¾óà     lñ°ØÀ  9ãğnÛ0ØÀ  m³ğnÛ>ğÀ  m° mÎ0ØÀ  m³ğmÎ0ØÀ  9ãğlÄ>ÈÀ  €        €                           P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ       ÿÿ  ?     ÿÿ  ÿ     ÿÿ ÿ     ÿÿ ÿ     ÿÿ ÿ     ÿÿ ø     ÿÿ à     ÿÿ €     ÿÿ ?€     ÿÿ ?      ÿÿ       ÿÿ ~      ÿÿ ~      ÿÿ ~            ~ ÿÿ      ~ ÿÿ      ~ ÿÿ      ş ÿÿ      ü ÿÿ     ü ÿÿ     ø ÿÿ     ø ÿÿ     ğ ÿÿ     ÿà ÿÿ     ÿÀ ÿÿ     ÿ€ ÿÿ     ÿ  ÿÿ     ü  ÿÿ     ğ  ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ        ÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  <o¼ø `   <l60 öŞ8ü¶Ì60 fÛlü¶Ï¼0 g›| sŒ60 c›`üsŒ60 3<ü1²0                                }á¾      a³Œ0   9ãğa³0   m³ğ}æÇ>   m° a·Ã°   m³ğa¿á°   9ãğ}œ>   €        €        }{biglispcode     P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÄDDDDDDD ÿæffffffd ÿâ""""""  ÿÀ        ÿÄDDDDDDD ÿæffffffd ÿâ""""""  ÿÀ        ÿÄDDDDDDD ÿæffffffd ÿâ""""""  ÿÀ        ÿÄDDDDDDD ÿæffffffd ÿâ""""""  ÿÀ        ÿÄDDDDDDD ÿæffffffd ÿâ""""""  ÿÀ        ÿÄDDDDDDD ÿæffffffd ÿâ""""""  ÿÀ        ÿÄDDDDDDD ÿæffffffd ÿâ""""""  ÿÀ        ÿÄDDDDDDD ÿæffffffd  """""""#ÿ        ÿ DDDDDDGÿ &ffffffgÿ """""""#ÿ        ÿ DDDDDDGÿ &ffffffgÿ """""""#ÿ        ÿ DDDDDDGÿ &ffffffgÿ """""""#ÿ        ÿ DDDDDDGÿ &ffffffgÿ """""""#ÿ        ÿ DDDDDDGÿ &ffffffgÿ """""""#ÿ        ÿ DDDDDDGÿ &ffffffgÿ """""""#ÿ        ÿ DDDDDDGÿ &ffffffgÿ """""""#ÿ        ÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  }›üŞ|`   a˜ÌÛ`öŞ8ü`ğÌÛ`fÛlü|`ÌŞ|g›| `ğÌÛ`c›`üa˜ÌÛ`3<ü}˜Ç™|                               y÷˜ ÷À    m†Øq†  9ãğm†Øq†  m³ğyöØÙ‡À m° m‡˜ù†  m³ğm†ı†  9ãğeöŒ÷À €        €                           P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿDDDD ÿÿÿÿÿfffd ÿÿÿÿÿ"""  ÿÿÿÿÿ     ÿÿÿÿÿDDDD ÿÿÿÿÿfffd ÿÿÿÿÿ"""  ÿÿÿÿÿ     ÿÿÿÿÿDDDD ÿÿÿÿÿfffd ÿÿÿÿÿ"""  ÿÿÿÿÿ     ÿÿÿÿÿDDDD ÿÿÿÿÿfffd ÿÿÿÿÿ"""  ÿÿÿÿÿ     ÿÿÿÿÿDDDD ÿÿÿÿÿfffd ÿÿÿÿÿ"""  ÿÿÿÿÿ     ÿÿÿÿÿDDDD ÿÿÿÿÿfffd ÿÿÿÿÿ"""  ÿÿÿÿÿ     ÿÿÿÿÿDDDD ÿÿÿÿÿfffd ÿÿÿÿÿ"""  ÿÿÿÿÿ     ÿÿÿÿÿDDDD ÿÿÿÿÿfffd  """"ÿÿÿÿÿ     ÿÿÿÿÿ DDDÿÿÿÿÿ &fffÿÿÿÿÿ """"ÿÿÿÿÿ     ÿÿÿÿÿ DDDÿÿÿÿÿ &fffÿÿÿÿÿ """"ÿÿÿÿÿ     ÿÿÿÿÿ DDDÿÿÿÿÿ &fffÿÿÿÿÿ """"ÿÿÿÿÿ     ÿÿÿÿÿ DDDÿÿÿÿÿ &fffÿÿÿÿÿ """"ÿÿÿÿÿ     ÿÿÿÿÿ DDDÿÿÿÿÿ &fffÿÿÿÿÿ """"ÿÿÿÿÿ     ÿÿÿÿÿ DDDÿÿÿÿÿ &fffÿÿÿÿÿ """"ÿÿÿÿÿ     ÿÿÿÿÿ DDDÿÿÿÿÿ &fffÿÿÿÿÿ """"ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  }›üŞ|`   a˜ÌÛ`öŞ8ü`ğÌÛ`fÛlü|`ÌŞ|g›| `ğÌÛ`c›`üa˜ÌÛ`3<ü}˜Ç™|                               xCfø      lãf0   9ãğlãv0   m³ğm³v0   m° yón0   m³ğcûn0   9ãğcf0   €        €                           P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿû»»»DDDD ÿÙ™™™fffd ÿİİİİ"""  ÿÿÿÿÿ     ÿû»»»DDDD ÿÙ™™™fffd ÿİİİİ"""  ÿÿÿÿÿ     ÿû»»»DDDD ÿÙ™™™fffd ÿİİİİ"""  ÿÿÿÿÿ     ÿû»»»DDDD ÿÙ™™™fffd ÿİİİİ"""  ÿÿÿÿÿ     ÿû»»»DDDD ÿÙ™™™fffd ÿİİİİ"""  ÿÿÿÿÿ     ÿû»»»DDDD ÿÙ™™™fffd ÿİİİİ"""  ÿÿÿÿÿ     ÿû»»»DDDD ÿÙ™™™fffd ÿİİİİ"""  ÿÿÿÿÿ     ÿû»»»DDDD ÿÙ™™™fffd  """"İİİßÿ     ÿÿÿÿÿ DDD»»»»ÿ &fff™™™›ÿ """"İİİßÿ     ÿÿÿÿÿ DDD»»»»ÿ &fff™™™›ÿ """"İİİßÿ     ÿÿÿÿÿ DDD»»»»ÿ &fff™™™›ÿ """"İİİßÿ     ÿÿÿÿÿ DDD»»»»ÿ &fff™™™›ÿ """"İİİßÿ     ÿÿÿÿÿ DDD»»»»ÿ &fff™™™›ÿ """"İİİßÿ     ÿÿÿÿÿ DDD»»»»ÿ &fff™™™›ÿ """"İİİßÿ     ÿÿÿÿÿ DDD»»»»ÿ &fff™™™›ÿ """"İİİßÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  }›üŞ|`   a˜ÌÛ`öŞ8ü`ğÌÛ`fÛlü|`ÌŞ|g›| `ğÌÛ`c›`üa˜ÌÛ`3<ü}˜Ç™|                               lñ¾óà     lñ°ØÀ  9ãğnÛ0ØÀ  m³ğnÛ>ğÀ  m° mÎ0ØÀ  m³ğmÎ0ØÀ  9ãğlÄ>ÈÀ  €        €                           P f ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿû»»»     ÿÙ™™™     ÿİİİİ     ÿÿÿÿÿ     ÿû»»»     ÿÙ™™™     ÿİİİİ     ÿÿÿÿÿ     ÿû»»»     ÿÙ™™™     ÿİİİİ     ÿÿÿÿÿ     ÿû»»»     ÿÙ™™™     ÿİİİİ     ÿÿÿÿÿ     ÿû»»»     ÿÙ™™™     ÿİİİİ     ÿÿÿÿÿ     ÿû»»»     ÿÙ™™™     ÿİİİİ     ÿÿÿÿÿ     ÿû»»»     ÿÙ™™™     ÿİİİİ     ÿÿÿÿÿ     ÿû»»»     ÿÙ™™™          İİİßÿ     ÿÿÿÿÿ     »»»»ÿ     ™™™›ÿ     İİİßÿ     ÿÿÿÿÿ     »»»»ÿ     ™™™›ÿ     İİİßÿ     ÿÿÿÿÿ     »»»»ÿ     ™™™›ÿ     İİİßÿ     ÿÿÿÿÿ     »»»»ÿ     ™™™›ÿ     İİİßÿ     ÿÿÿÿÿ     »»»»ÿ     ™™™›ÿ     İİİßÿ     ÿÿÿÿÿ     »»»»ÿ     ™™™›ÿ     İİİßÿ     ÿÿÿÿÿ     »»»»ÿ     ™™™›ÿ     İİİßÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ     ÿÿÿÿÿ                                  }›üŞ|`   a˜ÌÛ`öŞ8ü`ğÌÛ`fÛlü|`ÌŞ|g›| `ğÌÛ`c›`üa˜ÌÛ`3<ü}˜Ç™|                               }á¾      a³Œ0   9ãğa³0   m³ğ}æÇ>   m° a·Ã°   m³ğa¿á°   9ãğ}œ>   €        €        }{FnDef {Name BLTSHADE} {Args TEXTURE DESTINATION DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT OPERATION CLIPPINGREGION}{Text{fn BLTSHADE} is the {arg SOURCETYPE} = {lisp TEXTURE} case of {fn BITBLT}.  It fills the specified region of the destination bitmap {arg DESTINATION} with the texture {arg TEXTURE}.  {arg DESTINATION} can be a bitmap or image stream.}}{FnDef {Name BITMAPIMAGESIZE} {Args BITMAP DIMENSION STREAM}{TextReturns the size that {arg BITMAP} will be when {fn BITBLT}ed to {arg STREAM}, in {arg STREAM}'s units.  {arg DIMENSION} can be one of {lisp WIDTH}, {lisp HEIGHT}, or {lisp NIL}, in which case the dotted pair {lisp ({arg WIDTH} . {arg HEIGHT})} will be returned.}}}{End SubSec Moving Bits Between Bitmaps With BITBLT}{Begin SubSec Drawing Lines}{Title Drawing Lines}{TextInterlisp-D provides several functions for drawing lines and curves on image streams.  The line drawing functions are intended for interactive applications where efficiency is important.  They do not allow the use of "brush" patterns, like the curve drawing functions, but (for display streams) they support drawing a line in {lisp INVERT} mode, so redrawing the line will erase it.  {fn DRAWCURVE} ({PageRef Fn DRAWCURVE}) can be used to draw lines using a brush.{FnDef {Name DRAWLINE} {Args X{sub 1} Y{sub 1} X{sub 2} Y{sub 2} WIDTH OPERATION STREAM COLOR DASHING}{TextDraws a straight line from the point {lisp ({arg X{sub 1}},{arg Y{sub 1}})} to the point {lisp ({arg X{sub 2}},{arg Y{sub 2}})} on the image stream {arg STREAM}.  The position of {arg STREAM} is set to {lisp ({arg X{sub 2}},{arg Y{sub 2}})}.  If {arg X{sub 1}} equals {arg X{sub 2}} and {arg Y{sub 1}} equals {arg Y{sub 2}}, a point is drawn at {lisp ({arg X{sub 1}},{arg Y{sub 1}})}.{arg WIDTH} is the width of the line, in the units of the device.  If {arg WIDTH} is {lisp NIL}, the default is 1.{arg OPERATION} is the {fn BITBLT} operation (see {PageRef (BITBLT argument) OPERATION}) used to draw the line.  If {arg OPERATION} is {lisp NIL}, the value of {fn DSPOPERATION} for the image stream is used.{arg COLOR} is a color specification that determines the color used to draw the line for image streams that support color.  If {arg COLOR} is {lisp NIL}, the {fn DSPCOLOR} of {arg STREAM} is used.{arg DASHING} is a list of positive integers that determines the dashing characteristics of the line.  The line is drawn for the number of points indicated by the first element of the dashing list, is not drawn for the number of points indicated by the second element.  The third element indicates how long it will be on again, and so forth.  The dashing sequence is repeated from the beginning when the list is exhausted.  If {arg DASHING} is {lisp NIL}, the line is not dashed.}}{FnDef {Name DRAWBETWEEN}{Args POSITION{sub 1} POSITION{sub 2} WIDTH OPERATION STREAM COLOR DASHING}{TextDraws a line from the point {arg POSITION{sub 1}} to the point {arg POSITION{sub 2}} onto the destination bitmap of {arg STREAM}.  The position of {arg STREAM} is set to {arg POSITION{sub 2}}.}}{FnDef {Name DRAWTO} {Args X Y WIDTH OPERATION STREAM COLOR DASHING}{TextDraws a line from the current position to the point {lisp ({arg X},{arg Y})} onto the destination bitmap of {arg STREAM}.  The position of {arg STREAM} is set to {lisp ({arg X},{arg Y})}.}}{FnDef {Name RELDRAWTO} {Args DX DY WIDTH OPERATION STREAM COLOR DASHING}{TextDraws a line from the current position to the point {lisp ({arg DX},{arg DY})} coordinates away onto the destination bitmap of {arg STREAM}.  The position of {arg STREAM} is set to the end of the line.  If {arg DX} and {arg DY} are both 0, nothing is drawn.}}}{End SubSec Drawing Lines}{Begin SubSec Drawing Curves}{Title Drawing Curves}{Text{index *PRIMARY* Brushes for drawing curves}A curve is drawn by placing a brush pattern centered at each point along the curve's trajectory.  A brush pattern is defined by its shape, size, and color.  The predefined brush shapes are {lisp ROUND}, {lisp SQUARE}, {lisp HORIZONTAL}, {lisp VERTICAL}, and {lisp DIAGONAL}; new brush shapes can be created using the {fn INSTALLBRUSH} function, described below.  A brush size is an integer specifying the width of the brush in the units of the device.  The color is a color specification, which is only used if the curve is drawn to an image stream that supports colors.A brush is specified to the various drawing functions as a list of the form {lisp ({arg SHAPE} {arg WIDTH} {arg COLOR})}, for example {lisp (SQUARE 2)} or {lisp (VERTICAL 4 RED)}.  A brush can also be specified as a positive integer, which is interpreted as a {lisp ROUND} brush of that width.  If a brush is a litatom, it is assumed to be a function which is called at each point of the curve's trajectory (with three arguments: the X-coordinate of the point, the Y-coordinate, and the image stream), and should do whatever image stream operations are necessary to draw each point.  Finally, if a brush is specified as {lisp NIL}, a {lisp (ROUND 1)} brush is used as default.{index *PRIMARY* Dashing of curves}The appearance of a curve is also determined by its dashing characteristics.  Dashing is specified by a list of positive integers.  If a curve is dashed, the brush is placed along the trajectory for the number of units indicated by the first element of the dashing list.  The brush is {it off}, not placed in the bitmap, for a number of units indicated by the second element.  The third element indicates how long it will be on again, and so forth.  The dashing sequence is repeated from the beginning when the list is exhausted.  The units used to measure dashing are the units of the brush.  For example, specifying the dashing as {lisp (1 1)} with a brush of {lisp (ROUND 16)} would put the brush on the trajectory, skip 16 points, and put down another brush.  A curve is not dashed if the dashing argument to the drawing function is {lisp NIL}.The curve functions use the image stream's clipping region and operation.  Most types of image streams only support the {lisp PAINT} operation when drawing curves.  When drawing to a display stream, the curve-drawing functions accept the operation {lisp INVERT} if the brush argument is 1.  For brushes larger than 1, these functions will use the {lisp ERASE} operation instead of {lisp INVERT}.  For display streams, the curve-drawing functions treat the {lisp REPLACE} operation the same as {lisp PAINT}.{FnDef {Name DRAWCURVE} {Args KNOTS CLOSED BRUSH DASHING STREAM}{TextDraws a "parametric cubic spline curve" on the image stream {arg STREAM}.  {arg KNOTS} is a list of positions to which the curve will be fitted.  If {arg CLOSED} is non-{lisp NIL}, the curve will be closed; otherwise it ends at the first and last positions in {arg KNOTS}.  {arg BRUSH} and {arg DASHING} are interpreted as described above.For example,{lispcode(DRAWCURVE '((10 . 10)(50 . 50)(100 . 10)(150 . 50))   NIL '(ROUND 5) '(1 1 1 2) XX)}would draw a curve like the following on the display stream {lisp XX}:     ; ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿüÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿüÀ                  À                  À                  À                  À                  À    à           À   ğ           >À   ğ           >À   ó€          >À    çÀ          À  À À           À  à À         ÀÀ  à €         àÀ  à            àÀ  À            àÀ                ÀÀ       à          À      ğ          À      ğ          À      ğ          À       à          À                À €    €      € À €    €      À À €    €      À À             À À               € À p                À ø             p  À ø             ø  À ø             ø  À p             ø  À        À     p  À        à        À        à        À        à        À        À        À                 À        €  À   À>        €  à   À>        €  à   À>           à   À            qÀ   À             ø    Àà          à ø    Áğ         ó€ø    Áğ         ÷Àp    Áğ         ÷À     Àà          çÀ     À           €     À                  À                  À                  À                  À                  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿüÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿü}}{FnDef {Name DRAWCIRCLE} {Args CENTERX CENTERY RADIUS BRUSH DASHING STREAM}{TextDraws a circle of radius {arg RADIUS} about the point {lisp ({arg CENTERX},{arg CENTERY})} onto the image stream {arg STREAM}.  {arg STREAM}'s position is left at {lisp ({arg CENTERX},{arg CENTERY})}.  The other arguments are interpreted as described above.}}{FnDef {Name DRAWELLIPSE} {Args CENTERX CENTERY SEMIMINORRADIUS SEMIMAJORRADIUS ORIENTATION BRUSH DASHING STREAM}{TextDraws an ellipse with a minor radius of {arg SEMIMINORRADIUS} and a major radius of {arg SEMIMAJORRADIUS} about the point {lisp ({arg CENTERX},{arg CENTERY})} onto the image stream {arg STREAM}.  {arg ORIENTATION} is the angle of the major axis in degrees, positive in the counterclockwise direction.  {arg STREAM}'s position is left at {lisp ({arg CENTERX},{arg CENTERY})}.  The other arguments are interpreted as described above.}}New brush shapes can be defined using the following function:{FnDef {Name INSTALLBRUSH} {Args BRUSHNAME BRUSHFN BRUSHARRAY}{TextInstalls a new brush called {arg BRUSHNAME} with creation-function {arg BRUSHFN} and optional array {arg BRUSHARRAY}.  {arg BRUSHFN} should be a function of one argument (a width), which returns a bitmap of the brush for that width.  {arg BRUSHFN} will be called to create new instances of {arg BRUSHNAME}-type brushes; the sixteen smallest instances will be pre-computed and cached.  "Hand-crafted" brushes can be supplied as the {arg BRUSHARRAY} argument.  Changing an existing brush can be done by calling {fn INSTALLBRUSH} with new {arg BRUSHFN} and/or {arg BRUSHARRAY}.}}{FnDef {Name DRAWPOINT} {Args X Y BRUSH STREAM OPERATION}{TextDraws {arg BRUSH} centered around point ({arg X}, {arg Y}) on {arg STREAM}, using the operation {arg OPERATION}.  {arg BRUSH} may be a bitmap or a brush.}}}{End SubSec Drawing Curves}{Begin SubSec Miscellaneous Drawing and Printing Operations}{Title Miscellaneous Drawing and Printing Operations}{Text{FnDef {Name DSPFILL} {Args REGION TEXTURE OPERATION STREAM}{TextFills {arg REGION} of the image stream {arg STREAM} (within the clipping region) with the texture {arg TEXTURE}.  If {arg REGION} is {lisp NIL}, the whole clipping region of {arg STREAM} is used.  If {arg TEXTURE} or {arg OPERATION} is {lisp NIL}, the values for {arg STREAM} are used.}}{index Polygons}{FnDef {Name FILLPOLYGON} {Args POINTS TEXTURE STREAM}{TextFills in the polygon outlined by {arg POINTS} on the image stream {arg STREAM}, using the texture {arg TEXTURE}.{arg POINTS} is a list of positions ({PageRef Term Positions}) determining the vertices of a closed polygon.  {fn FILLPOLYGON} fills in this polygon with the texture {arg TEXTURE}.  {arg POINTS} can also be a list whose elements are lists of positions, in which case each sublist describes a separate polygon to be filled.Note:  When filling a polygon, there is more than one way of dealing with the situation where two polygon sides intersect, or one polygon is fully inside the other.  Currently, {fn FILLPOLYGON} to a display stream uses the "odd" fill rule, which means that intersecting polygon sides define areas that are filled or not filled somewhat like a checkerboard.  For example, {lisp (FILLPOLYGON '((125 . 125)(150 . 200)(175 . 125)(125 . 175)(175 . 175)) GRAYSHADE {arg WINDOW})} would produce a display something like this:    / E             €    €         @    €    €    @    @    
     
     P    P    *¨    *¨    P    UT    *¨    *¨    UT    UT  ªª  ªªª¨  *ªUT  UTT  UP
¨  * 
¨  * P  @P       
     
  @                              (  (  *  ¨   P  U T  *€¨  * 
¨  UPT  UPT  ª¨*ª  ªªªª UTUU UPU ª 
ª€ª 
ª€U@U U U@ª  ª€ª  ª€T  U@P  @
   
 
   
 @  P   P*    ¨*    ¨    PP              @    This fill convention also takes into account all polygons in {arg POINTS}, if it specifies multiple polygons.  This can be used to put "holes" in filled polygons.  For example,{lispcode(FILLPOLYGON  '( ((110 . 110)(150 . 200)(190 . 110))     ((135 . 125)(160 . 125)(160 . 150)(135 . 150)) )   GRAYSHADE {arg WINDOW})}will put a square hole in a triangular region:    O X                       €        €        @        @        
         
         P        P        *¨        *¨        UT        UT        ªª        ªª        UT       UU        ªª       ªª€      UU       UU@      ªª€      
ªª       UU@      UU@      
ªª       
ªª       UUP      UUP      *ªª¨      *ªª¨      UUUT      UUUT      ªªªª      ªªªª     UUUU     UUUU     ªªªª€    ªªªª€    UUUU@    UUUU@    
ªªªª     
ªªªª     UUUUP    UUUUP    *ªªªª¨    *   *¨    U   T    U   T    ª   *ª    ª   *ª    U   T   U   U    ª   *ª   ª   *ª€  U   U   U   U@  ª   *ª€  
ª   *ª   U   U@  U   U@  
ª   *ª   
ª   *ª   U   UP  U   UP  *ª   *ª¨  *ª   *ª¨  UU   UT  UU   UT  ªª   *ªª  ªª   *ªª UU   UU UUUUUUUU ªªªªªªªª€ªªªªªªªª€UUUUUUUU@UUUUUUUU@
ªªªªªªªª 
ªªªªªªªª UUUUUUUUPUUUUUUUUP*ªªªªªªªª¨*ªªªªªªªª¨UUUUUUUUUTUUUUUUUUUTªªªªªªªªªªªªªªªªªªªªCurrently, {fn FILLPOLYGON} uses the "Replace" {fn BITBLT} operation (see {PageRef (BITBLT argument) OPERATION}) to fill areas with the texture.  However, any areas that are not filled are not changed.  If there are "holes" in the filled polygon, this can be used to produce a "window" effect.  For example, the following is the display produced by filling the star polygon (above) over a window full of text:    ` P ø      à       @ €  â'€Dğ ƒˆ!B "(@ „E!ğ‚ >@ ‡Â! ‚  @ „!B@*(H „E	 â!€D0 ƒˆ†                                      *      ø     à      @ €  â'€*Dğ ƒˆ!B *(@ „E!ğ‚ U@ ‡Â! ‚ U@ „!B@ª¨H „E	 â!€ªÄ0 ƒˆ†    U@         U@          ª€         ª      ø   U@ à     U@@ €  â'€ª¤ğ ƒˆ!B ª¨@ „E!ğ…UT>UP‡Â! …UD UP„!Bª¤"*ª „E	 â ª¤Fª€ƒˆ†   U@ U       U@ U       *€  ª       
€  ¨    ø    Pà      P €  â'‚D° ƒˆ!B "(  „E!ğ‚ >@ ‡Â! ‚  @ „!B@„"(È „E	 â!€„D° ƒˆ†   @ @       P @        ¨ 
€       ¨ 
     ø  U @à    U U@ €  â'‚ªœª  ƒˆ!Bª¢ª  „E!ğ‚U]UP ‡Â! ‚UUUP „!BJª¢ª¨ „E	 â!Šªœª¨ ƒˆ†   U UT       U UT       
ª *¨       *¨ 
ª    ø  W Tà    T T €  â'ª¤Fª ƒˆ!B*„"(ª „E!ğ‚U>U ‡Â! ‚U U „!Bª"(j€„E	 â!¨D*€ƒˆ†  P   @     P   @          €     €        ø     Cà       @@€  â#€Dğ ƒˆ!B "(@ „E!ğ‚ >@ ‡Â! ‚  @ „!B@"(H „E	 â!€D0 ƒˆ†}}{FnDef {Name FILLCIRCLE} {Args CENTERX CENTERY RADIUS TEXTURE STREAM}{TextFills in a circular area of radius {arg RADIUS} about the point ({arg CENTERX},{arg CENTERY}) in {arg STREAM} with {arg TEXTURE}.  {arg STREAM}'s position is left at ({arg CENTERX},{arg CENTERY}).{note can't specify OPERATION??}}}{FnDef {Name DSPRESET} {Args STREAM}{TextSets the X coordinate of {arg STREAM} to its left margin, sets its Y coordinate to the top of the clipping region minus the font ascent.  For a display stream, this also fills its destination bitmap with its background texture.}}{FnDef {Name DSPNEWPAGE} {Args STREAM}{TextStarts a new page.  The X coordinate is set to the left margin, and the Y coordinate is set to the top margin plus the linefeed.}}{FnDef {Name CENTERPRINTINREGION} {Args EXP REGION STREAM} {TextPrints {arg EXP} so that is it centered within {arg REGION} of the {arg STREAM}.  If {arg REGION} is {lisp NIL}, {arg EXP} will be centered in the clipping region of {arg STREAM}.}}}{End SubSec Miscellaneous Drawing and Printing Operations}{Begin SubSec Drawing and Shading Grids}{Title Drawing and Shading Grids}{Text{Index Grids}A grid is a partitioning of an arbitrary coordinate system (hereafter referred to as the "source system") into rectangles.  This section describes functions that operate on grids.  It includes functions to draw the outline of a grid, to translate between positions in a source system and grid coordinates (the coordinates of the rectangle which contains a given position), and to shade grid rectangles.  A grid is defined by its "unit grid," a region (called a grid specification){index Grid specification} which is the origin rectangle of the grid in terms of the source system.  Its {lisp LEFT} field is interpreted as the X-coordinate of the left edge of the origin rectangle, its {lisp BOTTOM} field is the Y-coordinate of the bottom edge of the origin rectangle, its {lisp WIDTH} is the width of the grid rectangles, and its {lisp HEIGHT} is the height of the grid rectangles.{FnDef {Name GRID} {Args GRIDSPEC WIDTH HEIGHT BORDER STREAM GRIDSHADE}{TextOutlines the grid defined by {arg GRIDSPEC} which is {arg WIDTH} rectangles wide and {arg HEIGHT} rectangles high on {arg STREAM}.  Each box in the grid has a border within it that is {arg BORDER} points on each side; so the resulting lines in the grid are 2*{arg BORDER} thick.  If {arg BORDER} is the atom {lisp POINT}, instead of a border the lower left point of each grid rectangle will be turned on.  If {arg GRIDSHADE} is non-{lisp NIL}, it should be a texture and the border lines will be drawn using that texture.}}{FnDef {Name SHADEGRIDBOX} {Args X Y SHADE OPERATION GRIDSPEC GRIDBORDER STREAM}{TextShades the grid rectangle ({arg X},{arg Y}) of {arg GRIDSPEC} with texture {arg SHADE} using {arg OPERATION} on {arg STREAM}.  {arg GRIDBORDER} is interpreted the same as for {fn GRID}.}}The following two functions map from the X,Y coordinates of the source system into the grid X,Y coordinates:{FnDef {Name GRIDXCOORD} {Args XCOORD GRIDSPEC}{TextReturns the grid X-coordinate (in the grid specified by {arg GRIDSPEC}) that contains the source system X-coordinate {arg XCOORD}.}}{FnDef {Name GRIDYCOORD} {Args YCOORD GRIDSPEC}{TextReturns the grid Y-coordinate (in the grid specified by {arg GRIDSPEC}) that contains the source system Y-coordinate {arg YCOORD}.}}The following two functions map from the grid X,Y coordinates into the X,Y coordinates of the source system:{FnDef {Name LEFTOFGRIDCOORD} {Args GRIDX GRIDSPEC}{TextReturns the source system X-coordinate of the left edge of a grid rectangle at grid X-coordinate {arg GRIDX} (in the grid specified by {arg GRIDSPEC}).}}{FnDef {Name BOTTOMOFGRIDCOORD} {Args GRIDY GRIDSPEC}{TextReturns the source system Y-coordinate of the bottom edge of a grid rectangle at grid Y-coordinate {arg GRIDY} (in the grid specified by {arg GRIDSPEC}).}}}{End SubSec Drawing and Shading Grids}{Begin SubSec Display Streams}{Title Display Streams}{Text{Index *PRIMARY* Display streams}{Index *PRIMARY* DISPLAY (Image stream type)}{index *PRIMARY* Destination bitmap}Display streams (image streams of type {lisp DISPLAY}) are used to control graphic output operations to a bitmap, known as the "destination" bitmap of the display stream.  For each window on the screen, there is an associated display stream which controls graphics operations to a specific part of the screen bitmap.  Any of the functions that take a display stream will also take a window, and use the associated display stream.  Display streams can also have a destination bitmap that is not connected to any window or display device.{FnDef {Name DSPCREATE} {Args DESTINATION}{TextCreates and returns a display stream.  If {arg DESTINATION} is specified, it is used as the destination bitmap, otherwise the screen bitmap is used.}}{FnDef {Name DSPDESTINATION} {Args DESTINATION DISPLAYSTREAM}{TextReturns the current destination bitmap for {arg DISPLAYSTREAM}, setting it to {arg DESTINATION} if non-{lisp NIL}.  {arg DESTINATION} can be either the screen bitmap, or an auxilliary bitmap in order to construct figures, possibly save them, and then display them in a single operation.Warning:  The window system maintains the destination of a window's display stream.  Users should be very careful about changing this field.}}{FnDef {Name DSPXOFFSET} {Args XOFFSET DISPLAYSTREAM}}{FnDef {Name DSPYOFFSET} {Args YOFFSET DISPLAYSTREAM}{TextEach display stream has its own coordinate system, separate from the coordinate system of its destination bitmap.  Having the coordinate system local to the display stream allows objects to be displayed at different places by translating the display stream's coordinate system relative to its destination bitmap.  This local coordinate system is defined by the X offset{index X offset} and Y offset{index Y offset}.{fn DSPXOFFSET} returns the current X offset for {arg DISPLAYSTREAM}, the X origin of the display stream's coordinate system in the destination bitmap's coordinate system.  It is set to {arg XOFFSET} if non-{lisp NIL}.{fn DSPYOFFSET} returns the current Y offset for {arg DISPLAYSTREAM}, the Y origin of the display stream's coordinate system in the destination bitmap's coordinate system.  It is set to {arg YOFFSET} if non-{lisp NIL}.The X offset and Y offset for a display stream are  both initially 0 (no X or Y-coordinate translation).Warning:  The window system maintains the X and Y offset of a window's display stream.  Users should be very careful about changing these fields.}}{FnDef {Name DSPTEXTURE} {Args TEXTURE DISPLAYSTREAM}{TextReturns the current texture used as the background pattern for {arg DISPLAYSTREAM}.  It is set to {arg TEXTURE} if non-{lisp NIL}.  Initially the value of {var WHITESHADE}.}}{FnDef {Name DSPSOURCETYPE} {Args SOURCETYPE DISPLAYSTREAM}{TextReturns the current {fn BITBLT} sourcetype used when printing characters to the display stream (see {PageRef (BITBLT argument) SOURCETYPE}).  It is set to {lisp SOURCETYPE}, if non-{lisp NIL}.  Must be either {lisp INPUT} or {lisp INVERT}.  Initially {lisp INPUT}.}}{FnDef {Name DSPSCROLL} {Args SWITCHSETTING DISPLAYSTREAM}{TextReturns the current value of the "scroll flag," a flag that determines the {index Scrolling}scrolling behavior of the display stream; either {lisp ON} or {lisp OFF}.  If {lisp ON}, the bits in the display streams's destination bitmap are moved after any linefeed that moves the current position out of the destination bitmap.  Any bits moved out of the current clipping region are lost.  Does not adjust the X offset, Y offset, or clipping region of the display stream.  Initially {lisp OFF}.  Sets the scroll flag to {arg SWITCHSETTING}, if non-{lisp NIL}.Note:  The word "scrolling" also describes the use of "scroll bars" on the left and bottom of a window to move an object displayed in a window.  This feature is described on {PageRef Term Scrolling}.}}Each window has an associated display stream.  To get the window of a particular display stream, use {fn WFROMDS}:{FnDef {Name WFROMDS} {Args DISPLAYSTREAM DONTCREATE} {TextReturns the window associated with {arg DISPLAYSTREAM}, creating a window if one does not exist (and {arg DONTCREATE} is {lisp NIL}).  Returns {lisp NIL} if the destination of {arg DISPLAYSTREAM} is not a screen bitmap that supports a window system.If {arg DONTCREATE} is non-{lisp NIL}, {fn WFROMDS} will never create a window, and returns {lisp NIL} if {arg DISPLAYSTREAM} does not have an associated window.{fn TTYDISPLAYSTREAM} calls {fn WFROMDS} with {arg DONTCREATE} = {lisp T}, so it will not create a window unnecessarily.  Also, if {fn WFROMDS} does create a window, it calls {fn CREATEW} with {arg NOOPENFLG} = {lisp T}.}}{FnDef {Name DSPBACKUP} {Args WIDTH DISPLAYSTREAM}{TextBacks up {arg DISPLAYSTREAM} over a character which is {arg WIDTH} screen points wide.  {fn DSPBACKUP} fills the backed over area with the display stream's background texture and decreases the X position by {arg WIDTH}.  If this would put the X position less than {arg DISPLAYSTREAM}'s left margin, its operation is stopped at the left margin.  It returns {lisp T} if any bits were written, {lisp NIL} otherwise.}}}{End SubSec Display Streams}{Begin Comment removed by Sybalsky until it is more consistant}{Begin Subsec Previewing Hardcopy on the Display}{Title Previewing Hardcopy on the Display}{TextThe fonts used in the printers are not exactly the same as the display fonts, because low-resolution screen fonts don't look good when printed on high-resolution printers.  In particular, the character widths are not the same (even when scaled to take account of the printer resolution).  Because of this, it is difficult to format text on the display so that it is exactly where you want it, since it will be slightly different when printed.  In order to allow users to "preview" hardcopy without actually printing it, the following functions are useful: {FnDef {Name MAKEHARDCOPYSTREAM} {Args DISPLAYSTREAM IMAGETYPE}{TextChanges the display stream {arg DISPLAYSTREAM} so that measurements of character widths are consistent with the hardcopy device {arg IMAGETYPE} ({lisp INTERPRESS}, etc.).  This is useful for seeing on the screen how an image will look when it is hardcopied.  Caveat: This doesn't work for TEdit windows.}}{FnDef {Name UNMAKEHARDCOPYSTREAM} {Args DISPLAYSTREAM}{TextChanges a "hardcopy display stream" back into a regular display stream.}}Note:  When printing to a "hardcopy display stream," the text will not look as good as it will when printed.  In particular, the characters may look crunched together.  However, it accurately displays the relative positions of the letters, for formatting purposes.}{End Subsec Previewing Hardcopy on the Display}{End Comment removed by Sybalsky until it is more consistant}       ? 1(DEFAULTFONT 1 (GACHA 10) (GACHA 8) (TERMINAL 8)) 
         ? 1(DEFAULTFONT 1 (GACHA 10) (GACHA 8) (TERMINAL 8)) 
          M´      :  BMOBJ.GETFN2          :  BMOBJ.GETFN2            BMOBJ.GETFN2    ä        BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2            BMOBJ.GETFN2   °      ¦  BMOBJ.GETFN2   C      ¨  BMOBJ.GETFN2   w      z  BMOBJ.GETFN2         Ê  BMOBJ.GETFN2   +      ìP 'zº