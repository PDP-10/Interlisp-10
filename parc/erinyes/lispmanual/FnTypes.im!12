{Begin SubSec Function Types}{Title Function Types}{Text{index *PRIMARY* Function types}{Tag FnTypes}{index *PRIMARY* Expr definitions}{index *PRIMARY* Argument lists of functions}{index *PRIMARY* Function definitions}{index *PRIMARY* Evaluating arguments to functions}Interlisp functions are defined using list expressions called "expr definitions."  An expr definition is a list of the form {lisp ({arg LAMBDA-WORD} {arg ARG-LIST} {arg FORM{sub 1}} {ellipsis} {arg FORM{sub N}})}.  {arg LAMBDA-WORD} determines whether the arguments to this function will be evaluated or not, {arg ARG-LIST} determines the number and names of arguments, and {arg FORM{sub 1}} {ellipsis} {arg FORM{sub N}} are a series of forms to be evaluated after the arguments are bound to the local variables in {arg ARG-LIST}.If {arg LAMBDA-WORD} is the litatom {atom LAMBDA},{index *PRIMARY* LAMBDA Litatom} then the arguments to the function are evaluated.  If {arg LAMBDA-WORD} is the litatom {atom NLAMBDA},{index *PRIMARY* NLAMBDA Litatom} then the arguments to the function are not evaluated.  Functions which evaluate or don't evaluate their arguments are therefore known as "lambda"{index *PRIMARY* Lambda functions} or "nlambda"{index *PRIMARY* Nlambda functions} functions, respectively.If {arg ARG-LIST} is {lisp NIL} or a list of litatoms, this indicates a function with a fixed number of arguments.  Each litatom is the name of an argument for the function defined by this expression.  The process of binding these litatoms to the individual arguments is called "spreading" the arguments, and the function is called a "spread" function.{index *PRIMARY* Spread functions}  If the argument list is any litatom other than {lisp NIL}, this indicates a function with a variable number of arguments, known as a "nospread" function.{index *PRIMARY* Nospread functions}If {arg ARG-LIST} is anything other than a litatom or a list of litatoms, such as {lisp (LAMBDA "FOO" {ellipsis})}, attempting to use this expr definition will generate an {lisp ARG NOT LITATOM} error.{index ARG NOT LITATOM Error}  In addition, if {lisp NIL} or {lisp T} is used as an argument name, the error {lisp ATTEMPT TO BIND NIL OR T} is generated.{index ATTEMPT TO BIND NIL OR T Error}These two parameters (lambda/nlambda and spread/nospread) may be specified independently, so there are four main function types, known as lambda-spread, nlambda-spread, lambda-nospread, and nlambda-nospread functions.  Each one has a different form, and is used for a different purpose.  These four function types are described more fully below.Note:  For lambda-spread, lambda-nospread, or nlambda-spread functions, there is an upper limit to the number of arguments that a function can have, based on the number of arguments that can be stored on the stack on any one function call.  Currently, the limit is 80 arguments.  If a function is called with more than that many arguments, the error {index TOO MANY ARGUMENTS Error}{lisp TOO MANY ARGUMENTS} occurs.  However, nlambda-nospread functions can be called with an arbitrary number of arguments, since the arguments are not individually saved on the stack (see {PageRef nlambda-nospread functions}).{Begin SubSec Lambda-Spread Functions}{Title Lambda-Spread Functions}{Text{index *PRIMARY* Lambda-spread functions}Lambda-spread functions take a fixed number of evaluated arguments.  This is the most common function type.  A lambda-spread expr definition has the form:{lispcode (LAMBDA ({arg ARG{sub 1}} {ellipsis} {arg ARG{sub M}}) {arg FORM{sub 1}} {ellipsis} {arg FORM{sub N}})}The argument list {lisp ({arg ARG{sub 1}} {ellipsis} {arg ARG{sub M}})} is a list of litatoms that gives the number and names of the formal arguments to the function.  If the argument list is {lisp ()} or {atom NIL}, this indicates that the function takes no arguments.  When a lambda-spread function is applied to some arguments, the arguments are evaluated, and bound to the local variables {arg ARG{sub 1}} {ellipsis} {arg ARG{sub M}}.  Then, {arg FORM{sub 1}} {ellipsis} {arg FORM{sub N}} are evaluated in order, and the value of the function is the value of {arg FORM{sub N}}.{lispcode_ (DEFINEQ (FOO (LAMBDA (X Y) (LIST X Y))))(FOO)_ (FOO 99 (PLUS 3 4))(99 7)}In the above example, the function {lisp FOO} defined by {lisp (LAMBDA (X Y) (LIST X Y))} is applied to the arguments {lisp 99} and {lisp (PLUS 3 4)}, these arguments are evaluated (giving 99 and 7), the local variable {lisp X} is bound to 99 and {lisp Y} to 7, {lisp (LIST X Y)} is evaluated, returning {lisp (99 7)}, and this is returned as the value of the function.A standard feature of the Interlisp system is that no error occurs if a spread function is called with too many or too few arguments.  If a function is called with too many arguments, the extra arguments are evaluated but ignored.  If a function is called with too few arguments, the unsupplied ones will be delivered as {lisp NIL}.  In fact, a spread function cannot distinguish between being given {lisp NIL} as an argument, and not being given that argument, e.g., {lisp (FOO)} and {lisp (FOO NIL)} are {it exactly} the same for spread functions.  If it is necessary to distinguish between these two cases, use an nlambda function and explicitly evaluate the arguments with the {fn EVAL} function ({PageRef Fn EVAL}).}{End SubSec Lambda-Spread Functions}{Begin SubSec Nlambda-Spread Functions}{Title Nlambda-Spread Functions}{Text{index *PRIMARY* Nlambda-spread functions}Nlambda-spread functions take a fixed number of unevaluated arguments.  An nlambda-spread expr definition has the form:{lispcode (NLAMBDA ({arg ARG{sub 1}} {ellipsis} {arg ARG{sub M}}) {arg FORM{sub 1}} {ellipsis} {arg FORM{sub N}})}Nlambda-spread functions are evaluated similarly to lambda-spread functions, except that the arguments are not evaluated before being bound to the variables {arg ARG{sub 1}} {ellipsis} {arg ARG{sub M}}.{lispcode_ (DEFINEQ (FOO (NLAMBDA (X Y) (LIST X Y))) )(FOO)_ (FOO 99 (PLUS 3 4))(99 (PLUS 3 4))}In the above example, the function {lisp FOO} defined by {lisp (NLAMBDA (X Y) (LIST X Y))} is applied to the arguments {lisp 99} and {lisp (PLUS 3 4)}, these arguments are bound unevaluated to {lisp X} and {lisp Y}, {lisp (LIST X Y)} is evaluated, returning {lisp (99 (PLUS 3 4))}, and this is returned as the value of the function.Note:  Functions can be defined so that all of their arguments are evaluated (lambda functions) or none are evaluated (nlambda functions).  If it is desirable to write a function which only evaluates {it some} of its arguments (e.g. {fn SETQ}), the function should be defined as an nlambda, with some arguments explicitly evaluated using the function {fn EVAL} ({PageRef Fn EVAL}).  If this is done, the user should put the litatom {lisp EVAL} on the property list of the function under the property {prop INFO}.{index INFO Prop}  This informs various system packages such as DWIM, CLISP, and Masterscope that this function in fact {it does} evaluate its arguments, even though it is an nlambda.{index *PRIMARY* Evaluating nlambda arguments}Warning:  A frequent problem that occurs when evaluating arguments to nlambda functions with {fn EVAL} ({PageRef Fn EVAL}) is that the form being evaluated may reference variables that are not accessable within the nlambda function.  This is usually not a problem when interpreting code, but when the code is compiled, the values of "local" variables may not be accessable on the stack (see {PageRef Term Localvars}).  The system nlambda functions that evaluate their arguments (such as {fn SETQ}) are expanded in-line by the compiler, so this is not a problem.  Using the macro facility ({PageRef Tag Macros}) is recommended in cases where it is necessary to evaluate some arguments to an nlambda function.}{End SubSec Nlambda-Spread Functions}{Begin SubSec Lambda-Nospread Functions}{Title Lambda-Nospread Functions}{Text{index *PRIMARY* Lambda-nospread functions}Lambda-nospread functions take a variable number of evaluated arguments.  A lambda-nospread expr definition has the form:{lispcode (LAMBDA {arg VAR} {arg FORM{sub 1}} {ellipsis} {arg FORM{sub N}})}{arg VAR} may be any litatom, except {atom NIL} and {atom T}.  When a lambda-nospread function is applied to some arguments, each of these arguments is evaluated and the values stored on the stack.  {arg VAR} is then bound to the {it number} of arguments which have been evaluated.  For example, if {lisp FOO} is defined by {lisp (LAMBDA X {ellipsis})}, when {lisp (FOO A B C)} is evaluated, {lisp A}, {lisp B}, and {lisp C} are evaluated and {lisp X} is bound to 3.  {arg VAR} should {it never} be reset.The following functions are used for accessing the arguments of lambda-nospread functions:{FnDef {FnName ARG} {FnArgs VAR M}{Type NLAMBDA}{TextReturns the {arg M}th argument for the lambda-nospread function whose argument list is {arg VAR}.  {arg VAR} is the {it name} of the atomic argument list to a lambda-nospread function, and is not evaluated; {arg M} is the number of the desired argument, and is evaluated.  The value of {index ARG FN}{fn ARG} is undefined for {arg M} less than or equal to 0 or greater than the {it value} of {arg VAR}.{note {fn ARG} compiles open if {arg VAR} is bound locally in the function in which the call to {fn ARG} appears.  Otherwise, {fn ARG} compiles closed and evaluates its first argument on each call.  Note that this means that the value of {arg VAR} must be a {lisp SPECVAR}.  <<<always? Or just when you want to use it from a function called from a lambda-nospread?>>>}}}{FnDef {FnName SETARG} {FnArgs VAR M X}{Type NLAMBDA}{TextSets the {arg M}th argument for the lambda-nospread function whose argument list is {arg VAR} to {arg X}.  {arg VAR} is not evaluated; {arg M} and {arg X} are evaluated.  {arg M} should be between 1 and the value of {arg VAR}.}}In the example below, the function {lisp FOO} is defined to collect and return a list of all of the evaluated arguments it is given (the value of the {lisp for} statement).{lispcode_ (DEFINEQ (FOO             (LAMBDA X                (for ARGNUM from 1 to X collect (ARG X ARGNUM)](FOO)_ (FOO 99 (PLUS 3 4))(99 7)_ (FOO 99 (PLUS 3 4) (TIMES 3 4))(99 7 12)}}{End SubSec Lambda-Nospread Functions}{Begin SubSec Nlambda-Nospread Functions}{Title Nlambda-Nospread Functions}{Text{index *PRIMARY* Nlambda-nospread functions}Nlambda-nospread functions take a variable number of unevaluated arguments.  An nlambda-nospread expr definition has the form:{lispcode (NLAMBDA {arg VAR} {arg FORM{sub 1}} {ellipsis} {arg FORM{sub N}})}{arg VAR} may be any litatom, except {atom NIL} and {atom T}.  Though similar in form to lambda-nospread expr definitions, an nlambda-nospread is evaluated quite differently.  When an nlambda-nospread function is applied to some arguments, {arg VAR} is simply bound to a list of the unevaluated arguments.  The user may pick apart this list, and evaluate different arguments.In the example below, {lisp FOO} is defined to return the reverse of the list of arguments it is given (unevaluated):{lispcode_ (DEFINEQ (FOO (NLAMBDA X (REVERSE X))))(FOO)_ (FOO 99 (PLUS 3 4))((PLUS 3 4) 99)_ (FOO 99 (PLUS 3 4) (TIMES 3 4))((TIMES 3 4) (PLUS 3 4) 99)}Note:  The warning about evaluating arguments to nlambda functions ({PageRef Term Evaluating nlambda arguments}) also applies to nlambda-nospread function.}{End SubSec Nlambda-Nospread Functions}{Begin SubSec Compiled Functions}{Title Compiled Functions}{Text{index *PRIMARY* Compiled function objects}Functions defined by expr definitions can be compiled by the Interlisp compiler ({PageRef Tag COMPILER}).  The compiler produces compiled code objects (of data type {index CCODEP (data type)}{lisp CCODEP}) which execute more quickly than the corresponding expr definition code.  Functions defined by compiled code objects may have the same four types as expr definitions (lambda/nolambda, spread/nospread).  Functions created by the compiler are referred to as compiled functions.}{End SubSec Compiled Functions}{Begin SubSec Function Type Functions}{Title Function Type Functions}{TextThere are a variety of functions used for examining the type, argument list, etc. of functions.  These functions may be given either a litatom, in which case they obtain the function definition from the litatom's definition cell, or a function definition itself.{FnDef {FnName FNTYP} {FnArgs FN}{TextReturns {lisp NIL} if {arg FN} is not a function definition or the name of a defined function.  Otherwise {fn FNTYP} returns one of the following litatoms, depending on the type of function definition:{Begin LabeledList FNTYP returns}{Label {lisp EXPR}{index *PRIMARY* EXPR Litatom}}{TextLambda-spread expr definition.}{Label {lisp CEXPR}{index *PRIMARY* CEXPR Litatom}}{TextLambda-spread compiled definition.}{Label {lisp FEXPR}{index *PRIMARY* FEXPR Litatom}}{TextNlambda-spread expr definition.}{Label {lisp CFEXPR}{index *PRIMARY* CFEXPR Litatom}}{TextNlambda-spread compiled definition.}{Label {lisp EXPR*}{index *PRIMARY* EXPR* Litatom}}{TextLambda-nospread expr definition.}{Label {lisp CEXPR*}{index *PRIMARY* CEXPR* Litatom}}{TextLambda-nospread compiled definition.}{Label {lisp FEXPR*}{index *PRIMARY* FEXPR* Litatom}}{TextNlambda-nospread expr definition.}{Label {lisp CFEXPR*}{index *PRIMARY* CFEXPR* Litatom}}{TextNlambda-nospread compiled definition.}{Label {lisp FUNARG}{index FUNARG Litatom}}{Text{fn FNTYP} returns the litatom {atom FUNARG}{index  FUNARG Litatom} if {arg FN} is a {lisp FUNARG} expression.  See {PageRef Fn FUNCTION}.}{End LabeledList FNTYP returns}{lisp EXPR}, {lisp FEXPR}, {lisp EXPR*}, and {lisp FEXPR*} indicate that {arg FN} is defined by an expr definition.  {lisp CEXPR}, {lisp CFEXPR}, {lisp CEXPR*}, and {lisp CFEXPR*} indicate that {arg FN} is defined by a compiled definition, as indicated by the prefix {lisp C}.  The suffix {lisp *} indicates that {arg FN} has an indefinite number of arguments, i.e., is a nospread functions.  The prefix {lisp F} indicates unevaluated arguments.  Thus, for example, a {lisp CFEXPR*} is a compiled nospread-nlambda function.}}{FnDef {FnName EXPRP} {FnArgs FN}{TextReturns {lisp T} if {lisp (FNTYP {arg FN})} is either {lisp EXPR}, {lisp FEXPR}, {lisp EXPR*}, or {lisp FEXPR*}; {lisp NIL} otherwise.{index EXPR Litatom}{index FEXPR Litatom}{index EXPR* Litatom}{index FEXPR* Litatom}However, {lisp (EXPRP {arg FN})} is also true if {arg FN} is (has) a list definition, even if it does not begin with {atom LAMBDA} or {atom NLAMBDA}.  In other words, {fn EXPRP} is not quite as selective as {fn FNTYP}.}}{FnDef {FnName CCODEP} {FnArgs FN}{TextReturns {lisp T} if {index FNTYP FN}{lisp (FNTYP {arg FN})} is either{lisp CEXPR}, {lisp CFEXPR}, {lisp CEXPR*}, or {lisp CFEXPR*}; {lisp NIL} otherwise.{index CEXPR Litatom}{index CFEXPR Litatom}{index CEXPR* Litatom}{index CFEXPR* Litatom}}}{FnDef {FnName ARGTYPE} {FnArgs FN}{Text{arg FN} is the name of a function or its definition.  {fn ARGTYPE} returns 0, 1, 2, or 3, or {lisp NIL} if {arg FN} is not a function.  The interpretation of this value is:{Begin LabeledList interpretation of ARGTYPE}{Name 0}{text Lambda-spread function ({lisp EXPR}, {lisp CEXPR}){index EXPR Litatom}{index CEXPR Litatom}}{Name 1}{text Nlambda-spread function ({lisp FEXPR}, {lisp CFEXPR}){index FEXPR Litatom}{index CFEXPR Litatom}}{Name 2}{text Lambda-nospread function ({lisp EXPR*}, {lisp CEXPR*}){index EXPR* Litatom}{index CEXPR* Litatom}}{Name 3}{text Nlambda-nospread function ({lisp FEXPR*}, {lisp CFEXPR*}){index FEXPR* Litatom}{index CFEXPR* Litatom}}{End LabeledList interpretation of ARGTYPE}i.e., {fn ARGTYPE} corresponds to the {it rows} of {fn FNTYP}'s.}}{FnDef {FnName NARGS} {FnArgs FN}{TextReturns the number of arguments of {arg FN}, or {lisp NIL} if {arg FN} is not a function.  If {arg FN} is a nospread function, the value of {fn NARGS} is 1.{note why doesn't NARGS check LAMBDASPLST, to be consistant with ARGLIST??}}}{FnDef {FnName ARGLIST} {FnArgs FN}{TextReturns the "argument list" for {arg FN}.  Note that the "argument list" is a litatom for nospread functions.  Since {lisp NIL} is a possible value for {fn ARGLIST}, an error is generated, {lisp ARGS NOT AVAILABLE},{index ARGS NOT AVAILABLE Error} if {arg FN} is not a function.If {arg FN} is a compiled function, the argument list is constructed, i.e., each call to {fn ARGLIST} requires making a new list.  For functions defined by expr definitions, lists beginning with {atom LAMBDA} or {atom NLAMBDA}, the argument list is simply {fn CADR} of {fn GETD}.  If {arg FN} has an expr definition, and {fn CAR} of the definition is not {lisp LAMBDA} or {lisp NLAMBDA}, {fn ARGLIST} will check to see if {fn CAR} of the definition is a member of {index LAMBDASPLST Var}{var LAMBDASPLST} ({PageRef Var LAMBDASPLST}).  If it is, {fn ARGLIST} presumes this is a function object the user is defining via {var DWIMUSERFORMS} ({PageRef Var DWIMUSERFORMS}), and simply returns {fn CADR} of the definition as its argument list.  Otherwise {fn ARGLIST} generates an error as described above.}}{FnDef {FnName SMARTARGLIST} {FnArgs FN EXPLAINFLG TAIL}{TextA "smart" version of {fn ARGLIST} that tries various strategies to get the arglist of {arg FN}.First, {fn SMARTARGLIST} checks the property list of {arg FN} under the property {lisp ARGNAMES}{index *PRIMARY* ARGNAMES Prop}.  For spread functions, the argument list itself is stored.  For nospread functions, the form is {lisp (NIL {arg ARGLIST{sub 1}} . {arg ARGLIST{sub 2}})}, where {arg ARGLIST{sub 1}} is the value {fn SMARTARGLIST} should return when {arg EXPLAINFLG}={lisp T}, and {arg ARGLIST{sub 2}} the value when {arg EXPLAINFLG}={lisp NIL}.  For example, {lisp (GETPROP 'DEFINEQ 'ARGNAMES)} = {lisp (NIL (X1 XI ... XN) . X)}.  This allows the user to specify special argument lists.Second, if {arg FN} is not defined as a function, {fn SMARTARGLIST} attempts spelling correction on {arg FN} by calling {fn FNCHECK}{index FNCHECK FN} ({PageRef Fn FNCHECK}), passing {arg TAIL} to be used for the call to {fn FIXSPELL}.  If unsuccessful, an error will be generated, {lisp {arg FN} NOT A FUNCTION}.{index NOT A FUNCTION Error}Third, if {arg FN} is known to the file package ({PageRef Term File Package}) but not loaded in, {fn SMARTARGLIST} will obtain the arglist information from the file.Otherwise, {fn SMARTARGLIST} simply returns {lisp (ARGLIST {arg FN})}.{fn SMARTARGLIST} is used by {fn BREAK} ({PageRef Fn BREAK}) and {fn ADVISE} ({PageRef Fn ADVISE}) with {arg EXPLAINFLG}={lisp NIL} for constructing equivalent expr definitions, and by the TTYIN in-line command {lisp ?=} ({PageRef (in TTYIN) ?=}), with {arg EXPLAINFLG}={lisp T}.}}}{End SubSec Function Type Functions}}{End SubSec Function Types}       ? 1(DEFAULTFONT 1 (GACHA 10) (GACHA 8) (TERMINAL 8)) 
         ? 1(DEFAULTFONT 1 (GACHA 10) (GACHA 8) (TERMINAL 8)) 
          GACHA 
           Â       '      	W       ;                    >ã      J– zº