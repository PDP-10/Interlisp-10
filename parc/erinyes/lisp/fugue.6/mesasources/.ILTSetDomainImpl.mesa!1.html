<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Erinyes]&lt;LISP>FUGUE.6>MesaSources>ILTSetDomainImpl.mesa!1</title>
  </head>
  <body>
    <pre>
--ILTSetProfileImpl.mesa--Created by--   JFung.PASA	  	15-Nov-83 15:44:26--last edited by--   JFung.PASA	   	23-Jan-84 11:10:41 DIRECTORY     Cursor,     Event,     EventTypes USING [deactivate],     Exec,     Format USING [StringProc],     FormSW USING [          AllocateItemDescriptor, ClientItemsProcType, CommandItem, Destroy,          Display, FindItem, FreeHintsProcType, ItemHandle, MenuProcType, newLine,          ProcType, SetTagPlaces, StringItem],     Heap USING [systemZone],     LispToolOps,     Process,     Put,     Runtime USING [GetBcdTime],     String,     Supervisor USING [          AddDependency, AgentProcedure, CreateSubsystem, EnumerationAborted,          RemoveDependency, SubsystemHandle],     Time USING [Append, Unpack],     Tool USING [          Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,          UnusedLogName],     ToolDriver USING [Address, NoteSWs, RemoveSWs],     ToolWindow USING [Activate, Deactivate, DisplayProcType, TransitionProcType],     UserInput,     Version USING [Append],     Window USING [GetDisplayProc, Handle];ILTSetProfileImpl: PROGRAM     IMPORTS          Cursor, Event, Exec, FormSW, Heap, LispToolOps, Process, Put, Runtime,          String, Supervisor, Time, Tool, ToolDriver, ToolWindow, UserInput,          Version, Window     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;     DataHandle: TYPE = LONG POINTER TO Data;     Data: TYPE = MACHINE DEPENDENT RECORD [          -- Message subwindow stuff          msgSW(0): Window.Handle &larr; NIL,          -- File subwindow stuff          fileSW(2): Window.Handle &larr; NIL,          -- Form subwindow stuff          -- Note: enumerateds and booleans must be word boundary          -- aligned as addresses for them must be generated          --formSW: Window.Handle &larr; NIL,          paramSW(4): Window.Handle &larr; NIL,          commandSW(6): Window.Handle &larr; NIL,          busy(8): BOOLEAN &larr; FALSE,  -- command is running          userName(9): LONG STRING &larr; NIL,          userPassword(11): LONG STRING &larr; NIL,          domainName(13): LONG STRING &larr; NIL,          organizationName(15): LONG STRING &larr; NIL,          filePathName(17): LONG STRING &larr; NIL,          volName(19): LONG STRING &larr; NIL,          volHints(21): LONG POINTER TO VolHints &larr; NIL,	  volPassword(23): LONG STRING &larr; NIL,          vMemSize(25): File.PageCount &larr; 0,          fileTable(27): LONG POINTER TO SizeHints &larr; NIL,          connection(29): FileTransfer.Connection &larr; NIL,          indicator(31): Indicator &larr; left,	  docType(32): DocType &larr; general,	  fileServer(33): ServerType &larr; NS];     debug: BOOLEAN &larr; FALSE;     toolData: DataHandle &larr; NIL;     windowHandle: Window.Handle &larr; NIL;     active: BOOLEAN &larr; FALSE;     agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[          CheckDeactivate];     formDisplay: ToolWindow.DisplayProcType &larr; NIL;     heraldName: STRING &larr; [50];     CheckDeactivate: Supervisor.AgentProcedure =          BEGIN          IF event = EventTypes.deactivate AND windowHandle # NIL               AND windowHandle = eventData AND toolData.busy THEN               BEGIN               Put.Line[toolData.msgSW,                    "The tool is busy:  aborting deactivation"L];               ERROR Supervisor.EnumerationAborted;               END;          END;  --CheckDeactivate     ClearCommandSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL &larr; 0, i + 1 UNTIL               (item &larr; FormSW.FindItem[ILT.toolData.commandSW, i]) = NIL DO               item.flags.invisible &larr; TRUE ENDLOOP;          FormSW.Display[toolData.commandSW];          END;     ClearFileSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL &larr; 0, i + 1 UNTIL               (item &larr; FormSW.FindItem[ILT.toolData.fileSW, i]) = NIL DO               item.flags.invisible &larr; TRUE ENDLOOP;          FormSW.Display[ILT.toolData.fileSW];          formDisplay &larr; Window.GetDisplayProc[ILT.toolData.fileSW];          END;     ClearMsgSubwindow: PROCEDURE =          BEGIN          item: FormSW.ItemHandle;          FOR i: CARDINAL &larr; 0, i + 1 UNTIL               (item &larr; FormSW.FindItem[toolData.msgSW, i]) = NIL DO               item.flags.invisible &larr; TRUE ENDLOOP;          FormSW.Display[toolData.msgSW];          formDisplay &larr; Window.GetDisplayProc[toolData.msgSW];          END;     ClearSubWindows: PROCEDURE =          BEGIN          --ClearFileSubwindow;          ClearMsgSubwindow;          END;     ClientTransition: ToolWindow.TransitionProcType =          -- This procedure is called whenever the system determines that this          -- Tool's state is undergoing a user invoked transition.          -- In this Example we demonstrate a technique that minimizes the memory          -- requirements for a Tool that is inactive.          BEGIN          SELECT TRUE FROM               old = inactive =&gt;                    BEGIN                    IF toolData = NIL THEN                         toolData &larr; Heap.systemZone.NEW[Data &larr; []];                    --ProcessUserDotCM[];                    active &larr; TRUE;                    END;               new = inactive =&gt;                    BEGIN                    Supervisor.RemoveDependency[                         client: agent, implementor: Event.toolWindow];                    IF toolData # NIL THEN                         BEGIN                         FormSW.Destroy[toolData.paramSW];                         FormSW.Destroy[toolData.commandSW];                         Heap.systemZone.FREE[@toolData];                         END;                    --ToolDriver.RemoveSWs[tool: "LispTool"L];                    active &larr; FALSE;                    END;               ENDCASE          END;     Confirm: PROCEDURE RETURNS [okay: BOOLEAN] =          BEGIN          Cursor.Set[mouseRed];          [, okay] &larr; UserInput.WaitForConfirmation[];          Cursor.Set[textPointer];          UserInput.WaitNoButtons[];          END;  --Confirm     FormSWMakeUserCM: FormSW.ProcType =          BEGIN          toolData.busy &larr; TRUE;          ClearSubWindows;          IF Confirm[] THEN MakeUserCM[];          toolData.busy &larr; FALSE;          END;  --FormSWMakeUserCM     FormSWQuitProc: FormSW.ProcType =          BEGIN          IF debug THEN {               Put.Line[toolData.fileSW, "Quit Proc..."L];               --Process.Pause[Process.SecondsToTicks[5]];               };          [] &larr; ToolWindow.Deactivate[windowHandle];          END;  --FormSWQuitProc     Init: PROCEDURE =          BEGIN          --h: Exec.Handle;          --execWrite: Format.StringProc &larr; Exec.OutputProc[h];          --execWrite["Creating tool window.."L];           --Process.Pause[Process.SecondsToTicks[5]];          Exec.AddCommand["SetDomain.~"L, SetDomainExec, Unload];          --IF (windowHandle # NIL) AND ~active THEN              -- ToolWindow.Activate[windowHandle]          --ELSE windowHandle &larr; MakeTool[];          END;     SetDomainExec: Exec.ExecProc =          BEGIN          execWrite: Format.StringProc &larr; Exec.OutputProc[h];          --execWrite["Creating tool window.."L];           --Process.Pause[Process.SecondsToTicks[5]];          IF (windowHandle # NIL) AND ~active THEN               ToolWindow.Activate[windowHandle]          ELSE windowHandle &larr; MakeTool[];          END;     MakeCommands: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..3) OF CARDINAL &larr; [0, 30, 60];          nItems: CARDINAL = 2;          items &larr; AllocateItemDescriptor[nItems];          items[0] &larr; CommandItem[               tag: "Set Domain/Organization"L, place: newLine,               proc: FormSWMakeUserCM];          -- newLine is required, else will get 915 trap          --items[1] &larr; CommandItem[tag: "Set Volume Password"L, proc: FormSWQuitProc];          items[1] &larr; CommandItem[tag: "Quit"L, proc: FormSWQuitProc];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE];          END;     MakeParams: FormSW.ClientItemsProcType =          BEGIN OPEN FormSW;          tabs: ARRAY [0..7) OF CARDINAL &larr; [0, 28, 52, 56, 60, 68, 75];          nItems: CARDINAL = 2;          items &larr; AllocateItemDescriptor[nItems];          items[0] &larr; StringItem[               tag: "Domain"L, string: @ILT.toolData.domainName, inHeap: TRUE,               place: newLine];          items[1] &larr; StringItem[               tag: "Organization"L, string: @ILT.toolData.organizationName,               inHeap: TRUE];&lt;&lt;          items[2] &larr; StringItem[               tag: "Volume"L, string: @ILT.toolData.volName, inHeap: TRUE,               place: newLine];          items[3] &larr; StringItem[               tag: "Volume Password"L, string: @ILT.toolData.volPassword,	       --feedback: password,               inHeap: TRUE];&gt;&gt;          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];          RETURN[items, TRUE]          END;     MakeSWs: Tool.MakeSWsProc =          BEGIN          logName: STRING &larr; [40];          addresses: ARRAY [0..4) OF ToolDriver.Address;          Tool.UnusedLogName[unused: logName, root: "SetProfile.log"L];          toolData.msgSW &larr; Tool.MakeMsgSW[window: window, lines: 1];          toolData.paramSW &larr; Tool.MakeFormSW[               window: window, formProc: MakeParams];          toolData.commandSW &larr; Tool.MakeFormSW[               window: window, formProc: MakeCommands];          toolData.fileSW &larr; Tool.MakeFileSW[window: window, name: logName];          Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];          -- do the ToolDriver stuff          addresses &larr; [               [name: "msgSW"L, sw: ILT.toolData.msgSW],               --[name: "formSW"L, sw: ILT.toolData.formSW],               [name: "ParamSW"L, sw: ILT.toolData.paramSW], [               name: "CmdSW"L, sw: ILT.toolData.commandSW], [               name: "fileSW"L, sw: ILT.toolData.fileSW]];          ToolDriver.NoteSWs[               tool: "MakeUserCMTool"L, subwindows: DESCRIPTOR[addresses]];          END;     MakeTool: PROCEDURE RETURNS [wh: Window.Handle] =          BEGIN          String.AppendString[heraldName, "XSIS:Xerox Profile Tool "L];	  String.AppendString[heraldName, " of "L];          Time.Append[heraldName, Time.Unpack[Runtime.GetBcdTime[]]];          heraldName.length &larr; heraldName.length - 3;	  String.AppendString[heraldName, " on Pilot Version "L];          Version.Append[heraldName];          RETURN[               Tool.Create[                    makeSWsProc: MakeSWs, initialState: default,                    clientTransition: ClientTransition, name: heraldName,                    tinyName1: "Profile"L, tinyName2: "Tool"L]]          END;     ProfileToolActivate: PUBLIC PROCEDURE =          BEGIN          IF windowHandle = NIL THEN windowHandle &larr; MakeTool[];          ToolWindow.Activate[windowHandle];          Window.Stack[               windowHandle, Window.GetChild[               Window.GetParent[windowHandle]]];  -- top me          Window.ValidateTree[];          END;  --ProfileToolActivate     Unload: Exec.ExecProc =          BEGIN          IF windowHandle # NIL THEN Tool.Destroy[windowHandle];          ILT.windowHandle &larr; NIL;          [] &larr; Exec.RemoveCommand[h, "SetProfile.~"L];          END;     -- Mainline code     Init[];     END...</pre>
  </body>
</html>
