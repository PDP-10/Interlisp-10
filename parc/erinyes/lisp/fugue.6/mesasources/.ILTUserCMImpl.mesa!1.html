<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Erinyes]&lt;LISP>FUGUE.6>MesaSources>ILTUserCMImpl.mesa!1</title>
  </head>
  <body>
    <pre>
--ILTUserCMImpl.mesa--Created by--   JFung.PASA	  	10-Nov-83 15:48:47--last edited by--   JFung.PASA	   	19-Dec-83 16:51:12DIRECTORY     Cursor USING [Set],     Heap,      LispToolOps,     MFile,     MStream,     Process,     Put,     Stream,     Volume;ILTUserCMImpl: PROGRAM     IMPORTS Cursor, Heap, LispToolOps, MFile, MStream, Process, Put, Stream, Volume     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;	     debug: BOOLEAN &larr; TRUE;     nVols: CARDINAL;&lt;&lt;     PasswordCM: PUBLIC PROCEDURE[] =          BEGIN	  i: CARDINAL;          s: STRING &larr; [80];          v: Volume.ID;          all: Volume.TypeSet = [               normal: TRUE, debugger: TRUE, debuggerDebugger: TRUE];          name: LONG STRING &larr; "VolumeFile"L;          myFile: MFile.Handle &larr; NIL;          --readS: MStream.Handle &larr; NIL;          writeS: MStream.Handle &larr; NIL;	            IF ~MFile.ValidFilename[name] THEN {               Put.Line[ILT.toolData.msgSW, "Invalid file name"L]; RETURN; };          myFile &larr; MFile.Acquire[               name, anchor, MFile.dontRelease !               MFile.Error =&gt; {myFile &larr; NIL; CONTINUE}];          BEGIN          ENABLE MFile.Error =&gt; GOTO problem;          IF myFile # NIL THEN               BEGIN               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "SetAccess..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               MFile.SetAccess[myFile, readWrite];               END          ELSE               BEGIN               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "ReadWrite..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               myFile &larr; MFile.ReadWrite[name, MFile.dontRelease, text];               END;          writeS &larr; MStream.Create[myFile, []];          MStream.SetLength[writeS, 0];          IF ILT.toolData.volName # NIL THEN RETURN;          -- First, count the logical volumes.          nVols &larr; 0;          FOR v &larr; Volume.GetNext[Volume.nullID, all], Volume.GetNext[v, all] WHILE               v ~= Volume.nullID DO nVols &larr; nVols + 1; ENDLOOP;          -- Now build up the table          ILT.toolData.volHints &larr; Heap.systemZone.NEW[ILT.VolHints[nVols]];          FOR i IN [0..nVols) DO               v &larr; Volume.GetNext[v, all];               Volume.GetLabelString[v, s];	       writeS.PutString[s];               ENDLOOP;          writeS.SendNow;          myFile &larr; MFile.CopyFileHandle[               MStream.GetFile[writeS], MFile.dontRelease, readWrite];          EXITS               problem =&gt; {                    Put.Line[ILT.toolData.fileSW, "problem in volume file.."L];                    IF myFile # NIL THEN                         BEGIN                         Put.Line[ILT.toolData.msgSW, "Error in auquiring file"L];                         MFile.Release[myFile];                         END;                    }          END;          writeS.Delete;          IF myFile # NIL THEN MFile.Release[myFile];                    END;  &gt;&gt;     MakeUserCM: PUBLIC PROCEDURE[] =          BEGIN          name: LONG STRING &larr; "User.cm"L;          myFile: MFile.Handle &larr; NIL;          --readS: MStream.Handle &larr; NIL;          writeS: MStream.Handle &larr; NIL;          IF debug THEN {               Put.Line[toolData.fileSW, "Enter MakeUserCM..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          IF ~MFile.ValidFilename[name] THEN {               Put.Line[toolData.msgSW, "Invalid file name"L]; RETURN; };          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "Acquire..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          myFile &larr; MFile.Acquire[               name, anchor, MFile.dontRelease !               MFile.Error =&gt; {myFile &larr; NIL; CONTINUE}];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "Set hourGlass..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Cursor.Set[hourGlass];          --IF myFile # NIL THEN MFile.Release[myFile];          BEGIN          ENABLE MFile.Error =&gt; GOTO problem;          --ENABLE MFile.Error  =&gt; {MFile.Release[myFile]; CONTINUE;};          IF myFile # NIL THEN               BEGIN               IF ILT.debug THEN {                    Put.Line[ILT.toolData.fileSW, "SetAccess..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               MFile.SetAccess[myFile, readWrite];               END          ELSE               BEGIN               IF ILT.debug THEN {                    Put.Line[ILT.toolData.fileSW, "ReadWrite..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               myFile &larr; MFile.ReadWrite[name, MFile.dontRelease, text];               END;          --myFile &larr; MFile.ReadWrite[name, MFile.dontRelease, text];          -- myFile is ReadWrite so can Copy handle with read later          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "Create..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS &larr; MStream.Create[myFile, []];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "SetLength..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          MStream.SetLength[writeS, 0];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "PutString..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS.PutString["[User.cm]\n"];          --writeS.PutString["[Executive]\n"];          --writeS.PutString["WindowBox: [x: 574, y: 100, w: 450, h: 315]\n"];          --writeS.PutString["InitialState: active\n"];          writeS.PutString["[System]\n"];          writeS.PutString["Domain: "];          writeS.PutString[ILT.toolData.domainName];          writeS.PutString["\n"];          writeS.PutString["Organization: "];          writeS.PutString[ILT.toolData.organizationName];          writeS.PutString["\n"];          writeS.PutString["Screen: White\n"];          writeS.PutString["Debug: No\n"];          writeS.PutString["[Diagnostics:System]\n"];          writeS.PutString["InitialCommand: InstallLispTool\n"];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "SendNow..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS.SendNow;          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "CopyFileHandle..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          myFile &larr; MFile.CopyFileHandle[               MStream.GetFile[writeS], MFile.dontRelease, readOnly];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "Delete..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          EXITS               problem =&gt; {                    IF ILT.debug THEN Put.Line[ILT.toolData.fileSW, "problem..."L];                    IF myFile # NIL THEN                         BEGIN                         Put.Line[ILT.toolData.msgSW, "Error in auquiring file"L];                         MFile.Release[myFile];                         END;                    }          END;          writeS.Delete;          IF myFile # NIL THEN MFile.Release[myFile];	  	  PasswordCM[];          Cursor.Set[textPointer];          Put.Line[ILT.toolData.fileSW, " Done"L];          END;     END...-- Program ILTUserCMImpl  </pre>
  </body>
</html>
