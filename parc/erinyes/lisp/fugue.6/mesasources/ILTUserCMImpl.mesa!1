--ILTUserCMImpl.mesa--Created by--   JFung.PASA	  	10-Nov-83 15:48:47--last edited by--   JFung.PASA	   	19-Dec-83 16:51:12DIRECTORY     Cursor USING [Set],     Heap,      LispToolOps,     MFile,     MStream,     Process,     Put,     Stream,     Volume;ILTUserCMImpl: PROGRAM     IMPORTS Cursor, Heap, LispToolOps, MFile, MStream, Process, Put, Stream, Volume     EXPORTS LispToolOps =     BEGIN OPEN ILT: LispToolOps;	     debug: BOOLEAN _ TRUE;     nVols: CARDINAL;<<     PasswordCM: PUBLIC PROCEDURE[] =          BEGIN	  i: CARDINAL;          s: STRING _ [80];          v: Volume.ID;          all: Volume.TypeSet = [               normal: TRUE, debugger: TRUE, debuggerDebugger: TRUE];          name: LONG STRING _ "VolumeFile"L;          myFile: MFile.Handle _ NIL;          --readS: MStream.Handle _ NIL;          writeS: MStream.Handle _ NIL;	            IF ~MFile.ValidFilename[name] THEN {               Put.Line[ILT.toolData.msgSW, "Invalid file name"L]; RETURN; };          myFile _ MFile.Acquire[               name, anchor, MFile.dontRelease !               MFile.Error => {myFile _ NIL; CONTINUE}];          BEGIN          ENABLE MFile.Error => GOTO problem;          IF myFile # NIL THEN               BEGIN               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "SetAccess..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               MFile.SetAccess[myFile, readWrite];               END          ELSE               BEGIN               IF debug THEN {                    Put.Line[ILT.toolData.fileSW, "ReadWrite..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               myFile _ MFile.ReadWrite[name, MFile.dontRelease, text];               END;          writeS _ MStream.Create[myFile, []];          MStream.SetLength[writeS, 0];          IF ILT.toolData.volName # NIL THEN RETURN;          -- First, count the logical volumes.          nVols _ 0;          FOR v _ Volume.GetNext[Volume.nullID, all], Volume.GetNext[v, all] WHILE               v ~= Volume.nullID DO nVols _ nVols + 1; ENDLOOP;          -- Now build up the table          ILT.toolData.volHints _ Heap.systemZone.NEW[ILT.VolHints[nVols]];          FOR i IN [0..nVols) DO               v _ Volume.GetNext[v, all];               Volume.GetLabelString[v, s];	       writeS.PutString[s];               ENDLOOP;          writeS.SendNow;          myFile _ MFile.CopyFileHandle[               MStream.GetFile[writeS], MFile.dontRelease, readWrite];          EXITS               problem => {                    Put.Line[ILT.toolData.fileSW, "problem in volume file.."L];                    IF myFile # NIL THEN                         BEGIN                         Put.Line[ILT.toolData.msgSW, "Error in auquiring file"L];                         MFile.Release[myFile];                         END;                    }          END;          writeS.Delete;          IF myFile # NIL THEN MFile.Release[myFile];                    END;  >>     MakeUserCM: PUBLIC PROCEDURE[] =          BEGIN          name: LONG STRING _ "User.cm"L;          myFile: MFile.Handle _ NIL;          --readS: MStream.Handle _ NIL;          writeS: MStream.Handle _ NIL;          IF debug THEN {               Put.Line[toolData.fileSW, "Enter MakeUserCM..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          IF ~MFile.ValidFilename[name] THEN {               Put.Line[toolData.msgSW, "Invalid file name"L]; RETURN; };          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "Acquire..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          myFile _ MFile.Acquire[               name, anchor, MFile.dontRelease !               MFile.Error => {myFile _ NIL; CONTINUE}];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "Set hourGlass..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          Cursor.Set[hourGlass];          --IF myFile # NIL THEN MFile.Release[myFile];          BEGIN          ENABLE MFile.Error => GOTO problem;          --ENABLE MFile.Error  => {MFile.Release[myFile]; CONTINUE;};          IF myFile # NIL THEN               BEGIN               IF ILT.debug THEN {                    Put.Line[ILT.toolData.fileSW, "SetAccess..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               MFile.SetAccess[myFile, readWrite];               END          ELSE               BEGIN               IF ILT.debug THEN {                    Put.Line[ILT.toolData.fileSW, "ReadWrite..."L];                    Process.Pause[Process.SecondsToTicks[5]];                    };               myFile _ MFile.ReadWrite[name, MFile.dontRelease, text];               END;          --myFile _ MFile.ReadWrite[name, MFile.dontRelease, text];          -- myFile is ReadWrite so can Copy handle with read later          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "Create..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS _ MStream.Create[myFile, []];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "SetLength..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          MStream.SetLength[writeS, 0];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "PutString..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS.PutString["[User.cm]\n"];          --writeS.PutString["[Executive]\n"];          --writeS.PutString["WindowBox: [x: 574, y: 100, w: 450, h: 315]\n"];          --writeS.PutString["InitialState: active\n"];          writeS.PutString["[System]\n"];          writeS.PutString["Domain: "];          writeS.PutString[ILT.toolData.domainName];          writeS.PutString["\n"];          writeS.PutString["Organization: "];          writeS.PutString[ILT.toolData.organizationName];          writeS.PutString["\n"];          writeS.PutString["Screen: White\n"];          writeS.PutString["Debug: No\n"];          writeS.PutString["[Diagnostics:System]\n"];          writeS.PutString["InitialCommand: InstallLispTool\n"];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "SendNow..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          writeS.SendNow;          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "CopyFileHandle..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          myFile _ MFile.CopyFileHandle[               MStream.GetFile[writeS], MFile.dontRelease, readOnly];          IF ILT.debug THEN {               Put.Line[ILT.toolData.fileSW, "Delete..."L];               Process.Pause[Process.SecondsToTicks[5]];               };          EXITS               problem => {                    IF ILT.debug THEN Put.Line[ILT.toolData.fileSW, "problem..."L];                    IF myFile # NIL THEN                         BEGIN                         Put.Line[ILT.toolData.msgSW, "Error in auquiring file"L];                         MFile.Release[myFile];                         END;                    }          END;          writeS.Delete;          IF myFile # NIL THEN MFile.Release[myFile];	  	  PasswordCM[];          Cursor.Set[textPointer];          Put.Line[ILT.toolData.fileSW, " Done"L];          END;     END...-- Program ILTUserCMImpl  