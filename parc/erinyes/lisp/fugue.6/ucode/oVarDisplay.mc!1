{File name:  oVarDisplay.mcLast Edit:  30-Jul-83 16:44:26Fixed bank 0 core smash bug Purcell 30-Jul-83 16:44:20Modified for variable display rate by don  1-Jul-83 14:54:22 Description: Dandelion Display Microcode: "Do not attempt to adjust your set.  We control the vertical, we control the horizontal." Author: R. Garner (based on previous version by R. Crane, Pitts Jarvis) Created: April 15 1980, Edited: R. Garner, May 19, 1980  6:20 PM}{Edited: Purcell, July 15, 1982  8:57 PM}{adapted for current use}{NOTE: There is a good chance this code can be written without register "Line"!!The number of refreshes per scan line required is	(128 Refreshes/2 mSec)(28.8 uSec/Line) = 1.8 Refreshes/LineThis code assumes a total of 897 (381'x) Lines per Frame:	 26	Top Border	808	Field	 28	Bottom border	   4	Blanking	 27	Vert Sync (14 even, 13 odd) 	   4	End Vert Sync}	SetTask[1];	StartAddress[DisplayStart];	Set[StartVSync, 63];	Set[EndVSync, 3];	Set[Blank, 43];	Set[Pic, 45];	Set[InvPic, 4D];	Set[NoPic, 41];	Set[NoInvPic, 49];	{set in dandelion.df	  Set[PicLenShifted, 0CA]; {PicLength = 328'x = 808'd. PicLenShifted = RShift2 PicLength}}{values relative to HibernateRet}	Set[VSyncTime, 13'd]; {odd frame is 14'd}	Set[BotBordTime, 14'd]; 	Set[BlankTime, 2];	Set[OffTime, 9];{values relative to FieldRet}	Set[L5.FieldStart, 1];  {control goes to "FieldStart" from RET[FieldRet]}	Set[L5.Field, 0];  {control goes to "Field" from RET[FieldRet]}{values relative to SleepRet & DCycleRet}	Set[L5.DCycle6, 0];	Set[L5.DCycleA, 1];	Set[L5.DCycle, 2];	Set[L5.evs2, 3];	Set[L5.tb1, 4];	Set[L5.tb2, 5];	Set[L5.tb5, 6];	Set[L5.Hibernate, 7];{Format of Display Control Block}	{  Set[IOPageHigh, 1];}	{  Set[IOPage, 40];}	{  Set[DCBLoc, 0EB];}	Set[WakeupLoc, 0];	Set[DBitsLoc, 1];	Set[BorderLoc, 2];	Set[cursorXLoc, 3];	Set[cursorYLoc, 4];	{  Set[cursorMapLoc, 5];}{	Initilization}{Note: u7FF, u1FFF, and u3FFF should be initialized by the Emulator task}DisplayStart:	dX _ LShift1 0FF, SE_1, CANCELBR[$, 0F]	,c1;	dX _ LShift1 dX, SE_1	,c2;	r9u3FF _ dX	,c3;	dX _ 14'd,	c1;	uBBTime _ dX,	c2;{initialize for standard display rate}	c3;		rhdY _ IOPageHigh, Refresh	,c1;	dX _ IOPage	,c2;	dX _ dX LRot8	,c3;	dX _ dX or DCBLoc	,c1;	uDCBLoc _ dX	,c2;	dX _ dX + cursorMapLoc	,c3;	uInitCurMapAddr _ dX	,c1;	Line _ PicLenShifted	,c2;	dX _ Line LRot8	,c3;	uInitCurBufAddr _ dX, Refresh	,c1;	Line _ LRot1 Line	,c2;	Line _ LRot1 Line, rhLine _ 0	,c3;	rBuInitPicLength _ Line {328'x}, ClrDPRq	,c1;	Noop	,c2;	uClockBits _ 0, GOTO[EndVSync]	,c3;{	End Vertical Sync}{1st line of "End Vertical Sync" (4 clicks): Init cursor copy loop count; fetch & load border register; fetch wakeup mask.}EndVSync:	dX _ 7, L5 _ L5.evs2, Refresh	,c1, at[VSyncTime,10,HibernateRet];	uCopyCount _ dX	,c2;	dY _ uDCBLoc	,c3;	MAR _ [rhdY, dY + cursorYLoc]	,c1;	DCtl _ EndVSync, CANCELBR[$, 0]	,c2;	dX _ MD{cursorY}	,c3;	MAR _ [rhdY, dY + WakeupLoc]	,c1;	uDoCursor _ dX, CANCELBR[$, 0]	,c2;	dX _ MD{WakeupMask}, CALL[Sleep]	,c3;{2nd line of "End Vertical Sync" (4 clicks): Fetch exit length value and invert and blank bits.  If the display is turned off, the microcode executes as usual except there is border pattern everywhere instead of picture. Format of control bits:  0: 1=> off,  4: 1=> Invert,  5: 1=> disconnect (presently ignored),  6-15: scan line wake count}	MAR _ [rhdY, dY + BorderLoc], L5 _ L5.tb1	,c1, at[L5.evs2,10,SleepRet];	uDWakeup _ dX, CANCELBR[$, 0]	,c2;	dX _ MD{BorderPattern}	,c3;	MAR _ [rhdY, dY + DBitsLoc]	,c1;	DBorder _ dX, dY _ ~1, CANCELBR[$, 0]	,c2;	dX _ MD and dY{ScanLineWakeup and ~1}, XHDisp	,c3;	uExitLength _ dX, Refresh, DISP2[NormOn]	,c1;NormOn:	dX _ Pic, GOTO[DisplayNorm]	,c2, at[0,4,NormOn];NormOff:	dX _ NoPic, GOTO[DisplayNorm]	,c2, at[1,4,NormOn];InvOn:	dX _ InvPic, GOTO[DisplayInv]	,c2, at[2,4,NormOn];InvOff:	dX _ NoInvPic, GOTO[DisplayInv]	,c2, at[3,4,NormOn];DisplayNorm:	dY _ NoPic, CALL[Sleep]	,c3;DisplayInv:	dY _ NoInvPic, CALL[Sleep]	,c3;{	Top Border}{Border work involves initializing cursor related registers and copying the lines of the visible area within which the cursor appears into the Cursor Buffer.  The following compuations are made:The Line number on which the visible region stops:	uPicLength _ rBuInitPicLength or oddFieldThe Line number on which a wakeup is caused.:	uExitLength _ MIN[(ScanLineWakeup AND ~1) + 2 OR oddField, uPicLength]The Line number on which the cursor begins (If CursorY is greater than uPicLength, then no cursor will be displayed):	uDoCursor _ CursorY + ((CursorY xor oddField) and 1)The Line number on which the cursor stops:	uCursorStop _ uDoCursor + 14'dThe word address of the first word of the cursor bit map in the DCB:	uCurMapAddr _ uInitCurMapAddr + ((CursorY xor oddField) and 1)The word address of the first location of cursor in the Visible Region:	uCurVisAddr _ uDoCursor*wordsPerLine + (CursorX RShift4)The word address of the first location of the cursor in the Cursor Buffer:	uCurBufAddr _ rBuInitPicLength*wordsPerLine + (CursorX RShift4)The Fifo entries for a cursor line where the cursor is in the middle:	uCursorFifo0 _ [(CursorX RShift4) - 1,,0]	uCursorFifo1 _ [(CursorX RShift4) + 1,,(rBuInitPicLength-uDoCursor)]	uCursorFifo2 _ [63,,0]The Fifo entries for a cursor line where the cursor is at an edge:	LeftEdge = (CursorX RShift4)=0,	RightEdge = (CursorX RShift4)=62 or 63	uCursorFifo0' _ IF LeftEdge THEN uCursorFifo1 ELSE [1,,0]	uCursorFifo1' _ IF RightEdge THEN uCursorFifo0 ELSE [62,,0]	uCursorFifo2' _ IF RightEdge THEN [63,,(rBuInitPicLength-uDoCursor)] ELSE uCursorFifo2The Fifo entry for a line without a cursor is [63,,0].The mask & shift required to OR the cursor into the visible region are also computed.}{1st line of "Top Border" (6 clicks): Set uExitLength to min of ScanLineWakeup & InitPicLength.}TopBorder:	uStartPic _ dX, Refresh, L5 _ L5.tb2	,c1, at[L5.tb1,10,SleepRet];	uNoPic _ dY	,c2;	dY _ Line and 1	,c3;	dX _ rBuInitPicLength or dY{oddField}	,c1;	dY _ uExitLength or dY{oddField}	,c2;	dY _ dY + 2	,c3;	dY _ dY and r9u3FF	,c1;	[] _ dX - dY, CarryBr	,c2;	uPicLength _ dX, BRANCH[BadExitLen, ExitLenOK]	,c3;BadExitLen:	uExitLength _ dX, GOTO[PicLen] 	,c1;ExitLenOK:	uExitLength _ dY 	,c1;PicLen:	dY _ uDoCursor {cursorY}	,c2;	dX _ dY xor uClockBits {cursorY xor oddField}	,c3;	dX _ dX and 1  {(cursorY xor oddField) and 1}	,c1;	dY _ dX + dY {((cursorY xor oddField) and 1)+cursorY}, DCtl _ uNoPic	,c2;	uDoCursor _ dY, CALL[Sleep]	,c3;{2nd line of "Top Border" (7 clicks): Compute uDoCursor, uCurMapAddr, init uCurVisAddr, uCursorStop,  rAuCursorMask, and the cursorShift in rhdX.}TopB2:	dX _ uInitCurMapAddr or dX, Refresh, L5 _ L5.DCycle6	,c1, at[L5.tb2,10,SleepRet];	uCurMapAddr _ dX	,c2;	dX _ rBuInitPicLength	,c3;	dX _ dX - dY {rBuInitPicLength - uDoCursor}	,c1;	uCursorDiff _ dX	,c2;	dX _ dY + 0E {uDoCursor +14'd}	,c3;	uCursorStop _ dX, CALL[DCycle6]	,c1;	{1 click of dX_dY LRot1; dX_dX LRot1; dX_dX LRot4}	uCurVisAddr _ dX  {uDoCursor,,000000}	,c2, at[L5.DCycle6,10,DCycleRet];	dY _ uDCBLoc	,c3;	MAR _ [rhdY, dY + cursorXLoc]	,c1;	dY _ ~0F, CANCELBR[$, 0]	,c2;	rhdX _ dX _ MD{cursorX} and dY, XDisp	,c3;	dY _ dX LRot12  {cursorX RShift4}, DISP4[DMask]	,c1;	{1 cycle of "dX_mask"	,c2;}DMaskRet:	rAuCursorMask _ dX, CALL[Sleep]	,c3;{3rd line of "Top Border" (6 clicks): Compute uCurVisAddr, uCurBufAddr, and preliminary uCursorFifo2.  Set uDoCursor to off screen if CursorX is off screen.}TopB3:	dX _ ~3F, L5 _ L5.DCycleA	,c1, at[L5.DCycle6,10,SleepRet];	[] _ dY and dX {cursorX xor ~3F}, ZeroBr	,c2;	dX _ uCurVisAddr {uDoCursor,,000000}, BRANCH[$, CursorOn]	,c3;	uDoCursor _ ~dY xor dY, GOTO[CurVisAddr]	,c1;CursorOn:	Noop	,c1;CurVisAddr:	uCurVisAddr _ dX or dY {uDoCursor,,cursorX}	,c2;	dX _ uInitCurBufAddr	,c3;CurBufAddr:	{30-Jul-83 16:43:25 BUG FIX: neg cursorX caused out of range store}	dY _ dY and 03F,	c1;	Noop,	c2;	Noop,	c3;		uCurBufAddr _ dX or dY {rBuInitPicLength,,cursorX}, Refresh, CALL[DCycleA]	,c1;	{1 click of dX_LRot1 dY; dX_LRot1 dX; dX_dX LRot8}	{dX = cursorX,,0000000000}	dY _ r9u3FF	,c2, at[L5.DCycleA,10,DCycleRet];	uCursorFifo2 _ ~dY {111111,,0000000000}, CALL[Sleep]	,c3;{4th line of "Top Border" (3 clicks cursor in middle, 4 clicks cursor on edge): Compute uCursorFifo0, uCursorFifo1, and uCursorFifo2.}	dX _ dX - dY - 1, Xbus _ uStartPic, XDisp, L5 _ L5.tb5	,c1, at[L5.DCycleA,10,SleepRet];	uCursorFifo0 _ dX {dX=cursorX-1,,0000000000}, BRANCH[SkipCopy, $, 0B]	,c2;	dX _ dX+dY+1 {dX=cursorX,,0000000000}, ZeroBr	,c3;	dX _ dX+dY+1 {dX=cursorX+1,,0000000000}, ZeroBr, Refresh, BRANCH[$, CurAtLeft]	,c1;	[] _ dX+dY+1 {dY=cursorX+2,,0000000000}, NZeroBr, BRANCH[$, CurAt3F0]	,c2;	dX _ dX or uCursorDiff {cursorX+1,,PicLength - uDoCursor}, BRANCH[CurAt3E0, Sleep]	,c3;{Cursor is on left or right edge.}CurAtLeft:	dX _ dX or uCursorDiff {[1,PicLength - uDoCursor]}, CANCELBR[$]	,c2;	dY _ LShift1 ~dY  {dX=[62,0]}, GOTO[CurEdgeFin]	,c3;CurAt3F0:	dX _ uCursorDiff {[0,PicLength - uDoCursor]}, CANCELBR[$]	,c3;	uCursorFifo2 _ ~dY xor dX {[63,PicLength - uDoCursor]}, GOTO[CurAtR]	,c1;CurAt3E0:	uCursorFifo2 _ dX {[63,PicLength - uDoCursor]}	,c1;CurAtR:	dX _ dY+1 {dX=[1,0]}	,c2;	dY _ uCursorFifo0 {cursorX-1,,0000000000}	,c3;CurEdgeFin:	uCursorFifo0 _ dX	,c1;	dX _ dY	,c2;	CALL[Sleep]	,c3;{5th-12th lines of "Top Border" (9 clicks/line): Copy 8 lines from the visible region into the cursor buffer while ORing the cursor bit map into the lines.}CopyInit:	uCursorFifo1 _ dX, Refresh	,c1, at[L5.tb5,10,SleepRet];CopyCursor:	dY _ uCurMapAddr	,c2;	Line _ uCurVisAddr	,c3;	MAR _ [rhdY, dY], dY _ dY + 2, L5 _ L5.DCycle	,c1;	uCurMapAddr _ dY, [] _ rhdX, XDisp, CANCELBR[$, 2]	,c2;	dY _ MD{cursor word}, DISP4[DCycle]	,c3;	{1 click of dX_LRot1 dY; dX_LRot1 dX; dX_dX LRotn}	MAR _ [rhLine, Line+0]	,c1, at[L5.DCycle,10,DCycleRet];	dY _ dX and rAuCursorMask	,c2;	dY _MD or dY {visible or Left cursor}	,c3;	MAR _ [rhLine, Line + 1]	,c1;	dX _ dX and ~rAuCursorMask, CANCELBR[$, 2]	,c2;	dX _MD or dX {visible or Right cursor}	,c3;	Line _ Line + 80	,c1;	uCurVisAddr _ Line	,c2;	Line _ uCurBufAddr	,c3;	MAR _ [rhLine, Line+0]	,c1;	MDR _ dY, dY _ uClockBits	,c2;	dY _dY + 2	,c3;	MAR _ [rhLine, Line + 1]	,c1;	MDR _ dX, WriteOK, CANCELBR[$, 2]	c2;	Line _ Line + 80 	,c3;	uClockBits _ dY, Refresh	,c1;	dX _ uCopyCount-1, NibCarryBr, SuppressTimingWarning,	c2;	uCurBufAddr _ Line, ClrDPRq, BRANCH[CopyDone, $] 	,c3;	uCopyCount _ dX, Refresh, GOTO[CopyCursor]	,c1;{13th Line of "Top Border" (3+Field clicks):  Update the clock, reset the line number, and preload the CtlFifo (It should be loaded 1 line in advance).  The clock registers must be updated in the same click.}CopyDone:	Noop	,c1;CDone:	Line _ RShift1 dY {uClockBits/2}	,c2;	dY _ dY and 1 {zero line count, preserve oddField}	,c3;	dX _ uClockLow	,c1;	dX _ dX+Line {uClockLow+uClockBits/2}, CarryBr	,c2;	Line _ uClockHigh, BRANCH[$, UpClkHigh]	,c3;	uClockLow _ dX, GOTO[CUC]	,c1;UpClkHigh:	uClockLow _ dX, Line _ Line + 1	,c1;CUC:	uClockHigh _ Line, L5 _ L5.FieldStart	,c2;	uClockBits _ dY, CALL[Field]	,c3;{If the display is off, do not write into low bank.}SkipCopy:	rhdX _ dX _ OffTime, CALL[Snore]	,c3;CopySkipped:	dY _ uClockBits, GOTO[CDone]	,c1, at[OffTime,10,HibernateRet];{	Visible Field}{Line without cursor is 2 clicks, cursor line is 4 clicks, interrupt line is 2 additional clicks.}FieldStart:	DCtl _ uStartPic, L5 _ L5.Field, BRANCH[FieldC, FieldExit]	,c1;Field:	dX _ ~r9u3FF{normal fifo entry}, Refresh, BRANCH[FieldC, FieldExit]	,c1;FieldC:	[] _ dY xor uDoCursor, ZeroBr	,c2;CursorDone:	uClockBits _ dY, BRANCH[$, Cursor]	,c3;	DCtlFifo _ dX + dY, Refresh	,c1;	dY _ dY + 2, ClrDPRq, pRet5	,c2;	[] _ dY xor uExitLength, ZeroBr, BRANCH[Field, FieldStart]	,c3;Cursor:	[] _ dY xor uCursorStop, ZeroBr	,c1;	dX _ dY + 2, BRANCH[$, CursorLast]	,c2;	uDoCursor _ dX, GOTO[Curse]	,c3;CursorLast:	uDoCursor _ ~dY xor dY	,c3;Curse:	dX _ uCursorFifo0	,c1;	DCtlFifo _ dX + dY	,c2;	dX _ uCursorFifo1	,c3;	DCtlFifo _ dX + dY	,c1;	dX _ uCursorFifo2, GOTO[CursorDone]	,c2;FieldExit:	dX _ uPicLength, CANCELBR[$]	,c2;	[] _ dY xor dX, ZeroBr	,c3;	uExitLength _ dX, BRANCH[$, FieldDone]	,c1;	Noop	,c2;	Noop	,c3;	dX _ uWP	,c1;	dX _ dX or uDWakeup, MesaIntRq	,c2;	uWP _ dX, GOTO[Field]	,c3;FieldDone:	dY _ dY + 2	,c2;	uClockBits _ dY, GOTO[BotBorder]	,c3;{	Bottom border}BotBorder:	dY _ uNoPic, Refresh	,c1;{alu ops in c1 and c2 swapped}	dX _ uBBTime, ClrDPRq	,c2;	rhdX _ BotBordTime,	c3;	c1;	CALL[Hibernate],	c2;{	Start Vertical Retrace}StartBlk:	dX _ rhdX _ BlankTime, Refresh	,c1, at[BotBordTime,10,HibernateRet];	dY _ Blank, CALL[Hibernate]	,c2;{	Vertical Sync}StartVSync:	uClockBits _ Line _ Line xor dY{1}, Refresh,	,c1, at[BlankTime,10,HibernateRet];	Line _ Line and 1	,c2;	dX _ Line LRot4	,c3;	dY _ dX or StartVSync	,c1;	dX _ VSyncTime + Line, rhdX _ VSyncTime, CALL[Hibernate]	,c2;j(0,4939)\f7{	Hibernate, Sleep}Hibernate:	DCtl _ dY LRot0	,c3;Snore:	dX _ dX - 1, NegBr, Refresh, L5 _ L5.Hibernate	,c1, at[L5.Hibernate,10,SleepRet];	Xbus _ rhdX, XDisp, BRANCH[Winter, Spring]	,c2;Winter:	CANCELBR[Sleep, 0F]	,c3;Spring:	dY _ 1, RET[HibernateRet]	,c3;Sleep:	Line _ uClockBits, Refresh	,c1;	Line _ Line + 2, pRet5	,c2;	uClockBits _ Line, ClrDPRq, RET[SleepRet]	,c3;{	DCycle}DCycle:	dX _ dY, Xbus _ 0, XDisp, GOTO[NoRot],	c*, at[0,10,DCycle];	dX _ LRot1 dY, Xbus _ 0, XDisp, GOTO[NoRot],	c*, at[0F,10,DCycle];	dX _ LRot1 dY, Xbus _ 0, XDisp, GOTO[DRot1],	c*, at[0E,10,DCycle];	dX _ RRot1 dY, Xbus _ 1, XDisp, GOTO[NoRot],	c*, at[0D,10,DCycle];	dX _ dY, Xbus _ 1, XDisp, GOTO[NoRot],	c*, at[0C,10,DCycle];	dX _ LRot1 dY, Xbus _ 1, XDisp, GOTO[NoRot],	c*, at[0B,10,DCycle];DCycle6:	dX _ LRot1 dY, Xbus _ 1, XDisp, GOTO[DRot1],	c*, at[0A,10,DCycle];	dX _ RRot1 dY, Xbus _ 2, XDisp, GOTO[NoRot],	c*, at[9,10,DCycle];	dX _ dY, Xbus _ 2, XDisp, GOTO[NoRot],	c*, at[8,10,DCycle];	dX _ LRot1 dY, Xbus _ 2, XDisp, GOTO[NoRot],	c*, at[7,10,DCycle];DCycleA:	dX _ LRot1 dY, Xbus _ 2, XDisp, GOTO[DRot1],	c*, at[6,10,DCycle];	dX _ RRot1 dY, Xbus _ 3, XDisp, GOTO[NoRot],	c*, at[5,10,DCycle];	dX _ dY, Xbus _ 3, XDisp, GOTO[NoRot],	c*, at[4,10,DCycle];	dX _ LRot1 dY, Xbus _ 3, XDisp, GOTO[NoRot],	c*, at[3,10,DCycle];	dX _ LRot1 dY, Xbus _ 3, XDisp, GOTO[DRot1],	c*, at[2,10,DCycle];	dX _ RRot1 dY, Xbus _ 0, XDisp, GOTO[NoRot],	c*, at[1,10,DCycle];NoRot:	pRet5, DISP2[DLRot]	,c*;DRot1:	dX _ LRot1 dX, pRet5, DISP2[DLRot]	,c*;DLRot:	RET[DCycleRet]	,c*, at[0,4,DLRot];	dX _ dX LRot4, RET[DCycleRet]	,c*, at[1,4,DLRot];	dX _ dX LRot8, RET[DCycleRet]	,c*, at[2,4,DLRot];	dX _ dX LRot12, RET[DCycleRet]	,c*, at[3,4,DLRot];{	DMask}k166(1764)\f7 2g54G1b6B1g54GDMask:	dX _ 1, GOTO[DMaskRet],	c2, at[0F,10,DMask];	dX _ 3, GOTO[DMaskRet],	c2, at[0E,10,DMask];	dX _ 7, GOTO[DMaskRet],	c2, at[0D,10,DMask];	dX _ 0F, GOTO[DMaskRet],	c2, at[0C,10,DMask];	dX _ 1F, GOTO[DMaskRet],	c2, at[0B,10,DMask];	dX _ 3F, GOTO[DMaskRet],	c2, at[0A,10,DMask];	dX _ 7F, GOTO[DMaskRet],	c2, at[9,10,DMask];	dX _ 0FF, GOTO[DMaskRet],	c2, at[8,10,DMask];	dX _ LShift1 0FF, SE_1, GOTO[DMaskRet] {dX _ 1FF},	c2, at[7,10,DMask];	dX _ RShift1 u7FF, GOTO[DMaskRet] {dX _ 3FF},	c2, at[6,10,DMask];	dX _ u7FF, GOTO[DMaskRet] {dX _ 7FF},	c2, at[5,10,DMask];	dX _ RShift1 u1FFF, GOTO[DMaskRet] {dX _ FFF},	c2, at[4,10,DMask];	dX _ u1FFF, GOTO[DMaskRet] {dX _ 1FFF},	c2, at[3,10,DMask];	dX _ u3FFF, GOTO[DMaskRet] {dX _ 3FFF},	c2, at[2,10,DMask];	dX _ RShift1 (~dX xor dX), GOTO[DMaskRet] {dX _ 7FFF},	c2, at[1,10,DMask];	dX _ ~dX xor dX, GOTO[DMaskRet] {dX _ FFFF},	c2, at[0,10,DMask];