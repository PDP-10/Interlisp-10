<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Erinyes]&lt;LISP>FUGUE.6>Ucode>nRplPtr.mc!1</title>
  </head>
  <body>
    <pre>
{File name nRplPtr.mcDescription:  part of DandeLion InterLisp EmulatorAuthor: CharnleyLast edited by Charnley:    2-Sep-83 11:30:42Created by Charnley: 17-Jun-83 12:12:27}SetTask[0];{*******************************************************************	RPLPTR	GVAR&larr;*******************************************************************}{	GVAR&larr;	store TOS at VALSPACE + 2 * (alpha,,beta), preserving hi byte of destination		delref value at VALSPACE + 2 * (alpha,,beta)		addref tos}ufn[27];{Set[LoVALspace, Rshift[VALspaceL, 8]];GVARufn:	Rx &larr; 27'b, GOTO[ufn2],	c1;GVARg:	opcode[27'b],{	Q &larr; uLispOptions,	c1;	Ybus &larr; Q and 4, ZeroBr,	c2;	BRANCH[$, GVARufn],	c3;}	Q &larr; VALspace, L3 &larr; 0,	c1;	TT &larr; LoVALspace,	c2;	TT &larr; TT LRot8,	c3;	Rx &larr; ib, L1 &larr; L1.NoFixes,	c1;	Rx &larr; Rx LRot8,	c2;	Rx &larr; Rx or ibNA,	c3;	Rx &larr; LShift1 Rx, SE &larr; 0,	c1;	TT &larr; TT + Rx,	c2;	rhTT &larr; Q LRot0, GOTO[RplMap],	c3;}{	RPLPTR	store TOS at alpha + [tos - 1], preserving hi byte of destination		delref value at [tos - 1] + alpha		addref tos		pop}RPLPTR:		opcode[24'b],		MAR &larr; [rhS, S + 0], L3 &larr; 1,	c1;	L1 &larr; L1.NoFixes,	c2;	Rx &larr; MD{TOS-1.Lo},	c3;	MAR &larr; [rhS, S - 1],	c1;	TT &larr; Rx + ibNA, CarryBr, CANCELBR[$, 0],	c2;	rhTT &larr; MD{TOS-1.Hi}, BRANCH[RplMap, RplFixVHi],	c3;RplFixVHi:	Q &larr; rhTT + 1, LOOPHOLE[byteTiming],	c1;	rhTT &larr; Q LRot0,	c2;	c3;RplMap:	{map the address}	Map &larr; Q &larr; [rhTT, TT], L0 &larr; L0.RedoRpl,	c1;	,	c2;	Rx &larr; rhRx &larr; MD, XDirtyDisp,	c3;RplGet:	{mapping this reference can fault}	{get contents of address}	MAR &larr; Q &larr; [rhRx, Q + 0], BRANCH[RplRemap, $, 1],	c1,at[L0.RedoRpl,10,WMapFixCaller];	uSavAddr &larr; Q,	c2;	TT{oldHi} &larr; MD, GOTO[Rpl2ndwd],	c3;RplRemap:	CALL[WLMapFix],	c2;	Rpl2ndwd:	MAR &larr; [rhRx, Q + 1],	c1;	uSavOldHi &larr; TT, CANCELBR[$, 2],	c2;	TT{oldLo} &larr; MD,	c3;	{no faults from here on}	{setup for GcLookup:	  Rx &larr; addrHi &amp; 0FF	  TT &larr; addrLo	  uGcLov &larr; 0 {before first call only}	  L2 &larr; subr #	  Q &larr; 0 if addref, 1 if delref, 2 if stkref	  Trashes rhTT and rhRx	  }	Rx &larr; uSavOldHi,	c1;	Rx &larr; Rx and 0FF,	c2;	uGcLov &larr; 0{init for GcLookup to mark}, L2 &larr; L2.RplDel,	c3;RplDel:	{del ref to gotten}	Q &larr; rhRx,	c1;{save rhRx cuz gets smashed}	uuRx &larr; Q,	c2;	Q &larr; Q.DelRef, c3;	TOSH &larr; TOSH and 0FF, CALL[GcLookup],	c1;	{GcLookup Subroutine here}	TT &larr; TOS, L2 &larr; L2.RplAdd,	c2,at[L2.RplDel,10,GcLookRet];	Rx &larr; TOSH,	c3;RplAdd:	{add ref to tos}	Q &larr; Q.AddRef, CALL[GcLookup],	c1;		{GcLookup Subroutine here}RplBuild:	{fix TOS high byte}	Rx &larr; uSavOldHi{old hi},	c2,at[L2.RplAdd,10,GcLookRet];	Rx &larr; Rx and ~0FF,	c3;	TOSH &larr; TOSH or Rx,	c1;	Rx &larr; uSavAddr{saved Addr},	c2;	rhRx &larr; uuRx,	c3;RplPut:	{put TOSH,,TOS to address}	MAR &larr; [rhRx, Rx + 0],	c1;	MDR &larr; TOSH,	c2;	TT &larr; uGcLov{set by GcLookup},	c3;	MAR &larr; [rhRx, Rx + 1], {L3Disp,}	c1;	MDR &larr; TOS, {BRANCH[GVAREnd, $, 2],}CANCELBR[$, 2], LOOPHOLE[wok],	c2;RplPop:	{POP}	,	c3;	MAR &larr; [rhS, S + 0],	c1;	Xbus &larr; ib,	c2;	TOS &larr; MD,	c3;	MAR &larr; [rhS, S - 1],	c1;	Ybus &larr; TT, NZeroBr, CANCELBR[$, 0],	c2;	TOSH &larr; MD, BRANCH[RplNoOvXit, RplOvXit],	c3;RplNoOvXit:	S &larr; S - 2,	c1;	PC &larr; PC + 1, IBDisp, L2 &larr; L2.0, GOTO[DNI.nop],	c2;	RplOvXit:	{if overflow entries, exit via GCTableScan ???}GCTableScanExit:	{the following works for two byte opcodes's only!}	Rx &larr; AtomGCSCAN {371'b}, L3{ib's}&larr;1, c1;	IB &larr; Rx LRot0, GOTO[RplFNXIT],	c2;RplFNXIT:	S &larr; S - 2,	c3;	MAR &larr; Q &larr; [rhS, S + 1], IBPtr &larr; 0, GOTO[FN1Ext],	c1;{GVAREnd:	Xbus &larr; ib, Ybus &larr; TT, NZeroBr, L3{ib's}&larr;2,	c3;	Rx &larr; AtomGCSCAN {371'b}, BRANCH[GVAROvXit, GVARNoOvXit],	c1;GVARNoOvXit:	PC &larr; PC + 1, IBDisp, L2 &larr; L2.0,	c2;	PC &larr; PC + PC16, L2 &larr; L2.0, DISPNI[OpTable],	c3;GVAROvXit:	IB &larr; Rx LRot0, GOTO[RplFNXIT], c2;}	{ E N D }</pre>
  </body>
</html>
