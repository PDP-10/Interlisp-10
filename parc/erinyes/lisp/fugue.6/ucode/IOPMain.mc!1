{File name:  IOPMain.mcLast edited by Jim August 20, 1981  2:20 PM: Fix for new assembler.  Last Edited by Jim Frandeen: March 23, 1981  2:07 PM: Fix bug in WriteSwapped that caused grief when transferring only one word. Last Edited by Sandman: January 22, 1981  11:32 AM Last Edited by Roy Ogus: July 8, 1980  12:04 AM Description: Microcode to implement the IOP-CPport functions. Author: Roy Ogus,}k20(0,4939)(1,5644)(2,6350)(3,7056)(4,14817)\f1{NOTES:-  Word counter is used.  Must be an even number of bytes.-  BYTE ORDER:	normal byte order is low byte, high byte.  -  			swapped byte order is high byte, low byte.-  Memory addresses are real.-  The inner loop uses a maximum buffer address as terminator.}k40\f1{Register usage:	IOP	-	Memory address	rhIOP	-	High memory address	rTmp	-	Temp accumulator	uBufMax	-	Maximum buffer address}k40\f1(1224)\f1Set[IOPTask, 5];{set in Dandelion.df  Set[IOPOutMode, 2];		{IOP port output mode}  Set[IOPAWMode, 3];		{IOP port alwaysWU mode}}\f1{  loaded into L7   COMMANDS:	0 - Write Memory Block	1 - Read Memory Block	2 - Do Naked Notify	3 - (unimplemented)	4 - (unimplemented)	5 - Write Swapped Block	6 - Read Swapped Block}k40(0,4939)\f1{IOP  Task code}k40\f1	SetTask[IOPTask], StartAddress[IOPIdle];{Top of the IOP code.  The code is started at this point for a new command.  IOP Control should be set to InMode.}jk40\f1IOPIdle:	CANCELBR[$,0F],	c1; {Dispatch}	Xbus _ IOPIData, XDisp,	c2;	L7 _ 0, DISP3[IOPCmd],	c3;k40\f1{**************************************************************************}k40\f1{COMMAND 0:  Write memory block.     Format of transfer (bytes):	command (2 bits), low addr (10:17), mid. addr (2:9), high addr (0:1), 	 low count-1 (8:15), high count-1 (0:7),	 low data, high data, .....    IOP Control is in InMode}k40\f1{return from IOPSub}	rTmp _ rTmp + rIOP,	c3, at[0,10,IOPRet];k40\f1WFirst:	uBufMax _ rTmp, GOTO[WLo2],	c1;WLo:	MAR _ [rhIOP, rIOP], rIOP_rIOP+1,	c1;WLo2:	MDR _ rTmp, rTmp _ IOPIData, LOOPHOLE[mdrok], CANCELBR[$, 0],	c2;	rTmp _ rTmp LRot8,	c3; k40(2,14817)(3,65535)(4,65535)\f1WHiByte:	[] _ rIOP xor uBufMax, ZeroBr,	c1;	rTmp _ rTmp or IOPIData, BRANCH[$,WLo3Last],	c2;	rTmp _ rTmp LRot8, GOTO[WLo],	c3; k40\f1{This byte is the last byte.  Since we have to do one more click, set AlwaysWakeMode.  Have to put in an extra click to get everything done.  **Try to fix**.  There will be no page crossing, so do the memory reference and then go back to top of the loop.}WLo3Last:	IOPCtl _ IOPAWMode,	c3;	rTmp _ rTmp LRot8,	c1;	Noop,	c2;	Noop,	c3;WLoLast:	MAR_ [rhIOP, rIOP+0],	c1;	MDR _ rTmp,	c2;IOPDone:	IOPCtl _ IOPInMode, GOTO [IOPIdle],	c3;jk40\f1{**************************************************************************}k40(2,6350)(3,7056)(4,14817)\f1{COMMAND 1:  Read memory block.     Format of transfer (bytes):	command (4 bits), low addr (10:17), mid. addr (2:9), high addr (0:1),	 low count-1 (8:15), high count (0:7)	 => returns:   low data, high data, .....    IOP Control is in InMode}k40\f1CReadMem:	rIOP _ IOPIData, CALL[IOPSubc2],	c1, at [1,4,IOPCmd];	rTmp _ rTmp + rIOP, IOPCtl _ IOPOutMode,	c3, at[1,10,IOPRet];k40\f1RLo:	MAR _ [rhIOP, rIOP+0], BRANCH[RFirst, RRest],	c1;RFirst:	uBufMax _ rTmp, GOTO[RFetch],	c2;RRest:	GOTO[RFetch],	c2;RFetch:	IOPOData _ rTmp _ MD,	c3;k40(2,14817)(3,65535)(4,65535)\f1RHigh:	IOPOData _ rTmp LRot8,	c1; 	[] _ rIOP xor uBufMax, ZeroBr,	c2;	rIOP _ rIOP+1, NZeroBr, BRANCH[RLo, RDone],	c3;k40\f1RDone:	CANCELBR[IOPDonec2,1],	c1;{**************************************************************************}k40(2,6350)(3,7056)(4,14817)\f1{COMMAND 2:  Do Naked Notify.     Format of command:	command (2 bits), low interrupt mask, high interrupt mask.    IOP Control is in InMode}{return from IOPSub with mask in rTmp; need to do another click}	IOPCtl _ IOPAWMode,	c3, at[2,10,IOPRet];k40\f1{OR into wakeup U-register.  This must be done in one click.}	rIOP _ uWP, MesaIntRq,	c1;	rTmp _ rTmp or rIOP, IOPCtl _ IOPInMode,	c2;	uWP _ rTmp, GOTO [IOPIdle],	c3;k40\f1{**************************************************************************}k40\f1{COMMAND 3:  (unimplemented)}k40\f1Command3:	Noop,		c1, at[3,10,IOPCmd];IOPDonec2:	CANCELBR [IOPDone, 2],			c2;k40\f1{**************************************************************************}k40\f1{COMMAND 4:  (unimplemented)}k40\f1Command4:IOPDonec1:	GOTO[IOPDonec2],		c1, at[4,10,IOPCmd];k40\f1{**************************************************************************}k40\f1{COMMAND 5:  Write Swapped Block}k40\f1WriteSwapped:	rIOP _ IOPIData, CALL[IOPSubc2],		c1, at[5,10,IOPCmd];	rTmp _ rTmp + rIOP,	c3, at[5,10,IOPRet];	uBufMax _ rTmp, GOTO[WSHighx],	c1;WSHigh:	rIOP _ rIOP+1, BRANCH[$,WSDone],	c1;WSHighx:	rTmp _ IOPIData, 	c2;	rTmp _ rTmp LRot8,	c3; k40(2,14817)(3,65535)(4,65535)\f1WSLo:	MAR _ [rhIOP, rIOP+0],	c1;	MDR _ rTmp or IOPIData, CANCELBR[$, 0],	c2;	[] _ rIOP xor uBufMax, ZeroBr, GOTO [WSHigh],	c3; k40\f1WSDone:	GOTO[IOPDone],	c2;{**************************************************************************}k40(2,6350)(3,7056)(4,14817)\f1{COMMAND 6:  Read Swapped Block}k40\f1ReadSwapped:	rIOP _ IOPIData, CALL[IOPSubc2],		c1, at[6,10,IOPCmd];	rTmp _ rTmp + rIOP, IOPCtl _ IOPOutMode,	c3, at[6,10,IOPRet];k40\f1RSLo:	MAR _ [rhIOP, rIOP+0], BRANCH[RSFirst, RSRest],	c1;RSFirst:	uBufMax _ rTmp, GOTO[RSFetch],	c2;RSRest:	IOPOData _ rTmp LRot0, GOTO[RSFetch],	c2;RSFetch:	rTmp _ MD,	c3;k40(2,14817)(3,65535)(4,65535)\f1RSHigh:	IOPOData _ rTmp LRot8,	c1; 	[] _ rIOP xor uBufMax, ZeroBr,	c2;	rIOP _ rIOP+1, NZeroBr, BRANCH[RSLo, RSDone],	c3;k40\f1RSDone:	IOPOData _ rTmp LRot0, CANCELBR[IOPDonec2,1],	c1;k40(2,6350)(3,7056)(4,14817)\f1k40(2,14817)(3,65535)(4,65535)\f1{**************************************************************************Address and count fetching subroutine**************************************************************************}k40(2,6350)(3,7056)(4,14817)\f1{Read the low address (10:17)}IOPCmd:IOPSubc1:	rIOP _ IOPIData,	c1, at [0,10,IOPCmd];IOPSubc2:	rIOP _ rIOP LRot8,	c2;	Noop,			c3;k40\f1{Read the middle address (2:9)}	rIOP _ rIOP or IOPIData,	c1;	rIOP _ rIOP LRot8,	c2;	Noop,			c3;k40\f1{Read the high address (0:1) into rhIOP}	rhIOP _ IOPIData,	c1;	Noop,			c2;	Noop,			c3;k40\f1{Next comes the next parameter.  It is count-1 for write and read and mask for naked notify.}jk40\f1IOPSub2:	rTmp _ IOPIData,	c1, at[2,10,IOPCmd];	rTmp _ rTmp LRot8,	c2;	Noop,			c3;k40\f1	rTmp _ rTmp or IOPIData, L7Disp,	c1;	rTmp _ rTmp LRot8, RET[IOPRet],	c2;{END}k40(2,14817)(3,65535)(4,65535)\f1