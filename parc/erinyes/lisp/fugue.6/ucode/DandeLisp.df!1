{File name:  DandeLisp.df Description: Definitions for Dandelion Lisp Microcode, Created: April 6, 1982 by Purcell Last Edited:   12-Aug-83 10:36:31 charnley Last Edited:   20-Jul-83 10:47:17 charnley {nStkLimOffset} Last Edited: April 6, 1983  6:11 PM FUGATO Last Edited: August 1, 1982  12:57 PM nStkLimOffset Last Edited: March 24, 1983  8:48 PM start merging with Mesa 10 Last Edited: March 24, 1983  9:26 PM DiskCSBOffsetIOCB}{for using old dandelion.df with new diskDlion}{DISK CSB (Trident/Shugart/Quantum) - from 14000 to 1400F hex}  Set[DiskCSBOffsetIOCB, 0];{Parameter Settings}Set[KTval, 114'b],    {lisp constant KT}Set[AtomEVALFORM, 370'b],Set[AtomGCSCAN, 371'b],Set[AtomMAKENUMBER, 374'b],Set[AtomSETFVAR, 376'b],Set[AtomINTERPRETER, 400'b],Set[nRhS, 2{??}],Set[nStkLimOffset, 7],{%}Set[UFNspace, STATSspace];Set[STATSspaceReal, 3{1}],Set[MDSTYPEspaceReal, 3{1}];Set[INTERFACEbasePage, Rshift[INTERFACEbase, 8]];Set[DTDbasePage, Rshift[DTDbase, 8]];Set[ListpDTD.Counter, 14'b],Set[ListpDTD.NextPage, 15'b],Set[ConsNxtPg,  Add[Lshift[ListType, 4], ListpDTD.NextPage]],Set[ConsCnt,  Add[Lshift[ListType, 4], ListpDTD.Counter]],Set[crhHashTable,3]; { Real Page = 1400'b = 300'x}Set[crhTypeTable,3],{Real Page = 1600'b = 380'x}Set[UFNTablePage, Rshift[UFNTablebase, 8]];{R AND RH REGISTER DEFINITIONSSince there are no task specific registers in the machine, task identifiers are not bound to the register numbers with which they are shown.Q is reserved for the Emulator Task.Also, the stackP, STK, ib, and pc16 registers are reserved for the Emulator task.}{REGISTERS 0 - 6: EMULATOR}  {RegDef[TOS, R,	0];} {Top item of Stack (low word)}RegDef[rhTOS, RH,	0];	{temporary}RegDef[TOSH, R,	1]; {Top item of Stack (high word)}RegDef[rhTOSH, RH,	1];	{temporary}  {RegDef[TT, R,	2];} {temporary}  {RegDef[rhTT, RH,	2];}{temporary}RegDef[PV, R,	3]; {base reg for prog vars}RegDef[rhPV, RH,	3];RegDef[S, R, 	4];    {Stack pointer points to full odd word {best for jump}}RegDef[rhS, RH,	4];  {RegDef[PC, R,	5];}  {real address of program counter (PC16 selects byte)}  {RegDef[rhPC, RH,	5];} {program counter high}  {RegDef[Rx, R,	6];}{temporary}  {RegDef[rhRx, RH,	6];}{temporary}  {RegDef[rCount, R,	7];}{instruction counter}{U REGISTER BLOCK 7,8 -- DISK(x000) & TRIDENT}  {RegDef[uLimit,	U,	80];{rA=8}}  {RegDef[uDelta,	U,	81];}  {RegDef[uLimitH,	U,	70];{rA=7}}{U REGISTER BLOCK C,D -- ETHER}RegDef[rCountL,  R, 0C];   {Ether - debugging count}RegDef[rhCountL,  RH, 0C];   {Ether - debugging count}RegDef[rCountH,  R, 0D];   {Ether - debugging count}RegDef[rhCountH,  RH, 0D];   {Ether - debugging count}RegDef[uLispBootMsg, U, 0DE];	{also in nLispSAx000Initial.mc}{The allocation of Link registers:#    task0    Emulator1    Emulator2    Emulator3    Emulator4    Disk5    Display/LSEP6    Ethernet7    IOP}{U REGISTER DEFINITIONSRegisters indicated by ** contain Emulator state and must not be modified.}{U REGISTER BLOCK 0 -- EMULATOR STACK  TOS}RegDef[uU0,	U,	0]:RegDef[uValHigh,	U,	1]:{*** rA=TOS}{val space high virtual==22'b}  {RegDef[UBitBltArg,	U,	2];	{BitBlt}}  {RegDef[UHeight,	U,	3];	{BitBlt}}  {RegDef[UDstVALo,	U,	4];	{BitBlt}}  {RegDef[UDstBit,	U,	5];	{BitBlt}}  {RegDef[USrcVALo,	U,	6];	{BitBlt}}  {RegDef[USrcBit,	U,	7];	{BitBlt}}  {RegDef[UGray,	U,	8];	{BitBlt -- shares with USrcBpl}}  {RegDef[UDstBpl,	U,	9];	{BitBlt}}  {RegDef[UrhVS,	U,	0A];	{BitBlt}}  {RegDef[UrhVD,	U,	0B];	{BitBlt}}  {RegDef[UFlags,	U,	0C];	{BitBlt}}  {RegDef[UWidth,	U,	0D];	{BitBlt}}RegDef[uTOS,	U,	0D];	{rA=TOS}{fZ=D=_ib}{BitBlt}RegDef[uFF00,	U,	0E]: {*** rA=TOS}{FF00 to not use fY field}  {RegDef[uValHigh,	U,	0F]:}{*** rA=TOS}{val space high virtual==22'b}{U REGISTER BLOCK 1 -- EMULATOR   TOSH}  {RegDef[uWP,	U,	10];}	{** wakeups pending}  {RegDef[UvC,	U,	11];}	{** {rA = T}? low half of code (VA, , UvChigh)}RegDef[uKeepTOS, U, 11],{Cons temp}RegDef[u12,	U,	12];	{}RegDef[u0FF,	U,	13];	{** rA = TOSH}RegDef[uKeepTOSH, U, 14],{Cons temp}  {RegDef[uWW,	U,	14];}  {RegDef[u3FFF,	U,	15];}	{** constant, rA = TOSH}  {RegDef[uPMask,	U,	16];}	{** rA = T; constant = 0FFC}RegDef[uName,	U,	17];	{rA=TOSH}{name used by free var lookup}  {RegDef[uWDC,	U,	18];}	{** wakeup disable counter}  {RegDef[UGsave,	U,	19];}	{}{BitBlt}  {RegDef[UtbCount,	U,	1A];}	{TextBlt Count parameter, rA = T fZ = ErrnIBnStkp}RegDef[uIVar,	U,	1B];	{*** rA = TOSH}{fZ= _RH}{stk addr IVARs}  {RegDef[uT,	U,	1C];}	{rA = T}RegDef[uTOSH,	U,	1D];	{rA = T, fZ = _ib{GCONST}}  {RegDef[UrhMDSsave,	U,	1E];} {BitBlt}RegDef[u7F,	U,	1F];{***}{U REGISTER BLOCK 2 -- EMULATOR   rA=TT}RegDef[uSTACKspace,	U,	20];	{** rA = TT}RegDef[u0FFF,	U,	21];	{** rA = TT}RegDef[UvPCpageL,	U,	22];	{** rA = TT, (PC page address)}RegDef[u1FF,	U,	23];	{** rA = TT}RegDef[uTT3FF,	U,	25];	{}{*** rA = TT}  {RegDef[uESP,	U,	25];}	{*** rA = TT}  {RegDef[uFaultParm0	,U,	26];	{** rA = TT; fault parameter}}RegDef[uPV,	U,	26];	{** rA #PV}{save PV}{BitBlt writes}RegDef[uTT,	U,	27];	{rA = TT}{** A,Z=TT,_ibNA code base low v}RegDef[u7FFF,	U,	28];	{** rA = TT}RegDef[u7FE,	U,	29];	{**}{rA=TT}RegDef[uTT3FFF	,U,	2A];	{** rA = TT;}  {RegDef[uChain,	U,	2A];}	{** rA = TT; }{chain;  free var lookup}RegDef[uPCCrossL,	U,	2B];	{** rA = TT; }{}  {RegDef[u200,	U,	2C];}	{** constant}RegDef[UvCL,	U,	2C];	{** A,Z=TT,_ibNA code base low v}RegDef[UvChighL, U, 2D];	{** A,Z=TT,_ib code base high v}  {RegDef[u1FFF,	U,	2E];}	{** constant}  {RegDef[u7FF,	U,	2F];}	{** constant}{U REGISTER BLOCK 3 -- EMULATOR  rA=PV}RegDef[uuPV,	U,	30];	{}	  {RegDef[UQSave,	U,	31];}	{BitBlt temp}	RegDef[uFxNoPushReturn,	U,	32];	{**==100}{%}RegDef[uU33,	U,	33]	{}  {RegDef[UWidthM1,	U,	34];}	{BitBlt temp}	  {RegDef[Umask1,	U,	35];}	{BitBlt temp}	RegDef[U36,	U,	36]	{}  {RegDef[uFaultParm1,	U,	37];}	{fault parameter}  {RegDef[Umask2,	U,	37];}	{BitBlt temp}	  {RegDef[UmaskL,	U,	38];}	{BitBlt temp}	RegDef[uFxInCall,	U,	39];	{**==400 }{%}  {RegDef[ULsave,	U,	3A];}	{BitBlt temp}  {RegDef[UrhLsave,	U,	3B];}	{BitBlt temp}  {RegDef[uLastLevelLOwritten,	U,	3C];}	{BandBLT -- rA = rLoop}RegDef[unboundPvar,	U,	3D];	{**}{==FFFFh}RegDef[unboundFvar,	U,	3E];	{**}{==FFFFh}  {RegDef[uTickCount,	U,	3F];}	{** process tick interval}{U REGISTER BLOCK 4 -- EMULATOR  rA=S}RegDef[uStkLimO,	U,	40];	{**}{==FFFFh}  {RegDef[UXsave,	U,	42];}	{BitBlt temp}  {RegDef[UVSsave,	U,	43];}	{BitBlt temp}  {RegDef[USrcVALoSav,	U,	44];}	{BitBlt temp}  {RegDef[UrhGsave,	U,	4B];}	{rA = G, fZ = _RH}{BitBLT}RegDef[uPageFault,	U,	4E];	{}{U REGISTER BLOCK 5 -- EMULATOR  rA=PC}RegDef[uU50	,U,	50];	{}RegDef[uSavOldHi,U,51],	{Lisp temp}{RplPtr}RegDef[uSaveTOS,U,51],	{BLT temp}RegDef[uSavOldLo,U,52],	{Lisp temp}{RplPtr}RegDef[uSaveTT,U,52],	{BLT temp}RegDef[uConsTemp,U,53],	{Lisp temp}{Cons}RegDef[uSaveTOSH,U,53],	{BLT temp}RegDef[uGcLlo,U,55],	{Lisp temp}{GcLookup}RegDef[uGcLhi,U,56],	{Lisp temp}{GcLookup}RegDef[uGcLTem,U,57],	{Lisp temp}{GcLookup}RegDef[uGcLov,U,58],	{Lisp temp}{GcLookup}RegDef[uSavAddr,U,59],	{Lisp temp}{RplPtr}  {RegDef[UrhPCsave	,U,	5B];	{rA = PC, fZ = _RH}{BitBlt temp} }RegDef[uPC	,U,	5B];	{rA = PC, fZ = _RH}  {RegDef[UDstVALoSav	,U,	5C];	{BitBlt temp} }  {RegDef[UWidthW	,U,	5D];	{BitBlt temp} }RegDef[uPCib	,U,	5D];	{rA = PC, fZ = _ib}{U REGISTER BLOCK 6 -- EMULATOR  rA=Rx} {lots of params for BandBLT & Xfer}  {RegDef[ULcntsav,	U,	60];}	{BitBlt temp rA = Lcount}  {RegDef[uRx,	U,	60];	{Lisp temp rA = Rx} }RegDef[uFXmark,	U,	61];	{** rA = Rx; Frame Extension mark C000h}RegDef[uBFmark,	U,	62];	{** Basic Frame mark==8001h}RegDef[uUFNTableBaseHalf,	U,	63];	{** rA = T/Rx; }RegDef[uFreeStackBlock,	U,	64];	{** rA = T/Rx; }{==0A000}  {RegDef[uRx,	U,	65];}	{** rA = T/Rx; }{}RegDef[uBfResidualRhmask,	U,	66];	{** rA = T/Rx; }{==2FFh}RegDef[uESP,	U,	67];	{***}RegDef[uFunDef,	U,	68];	{}{last fun'n called to debug}RegDef[uChain,	U,	69];	{**}{chain;  free var lookup}RegDef[uPcBreak,	U,	6A];	{**}RegDef[uNewCount,U,6B],{Cons temp}RegDef[uAddrNewCellLo,U,6C],{Cons temp}RegDef[uuRx,	U,	6D];	{rA=Rx}{fZ=D=_ib}RegDef[uLispOptions,	U,	6F];	{DO NOT DISTURB -- LISP ONLY}RegDef[uBBTime, U, 99];{var.display uses to hold number of blank lines at the bottom of the display} {initialized to be 14'd for normal screen, change to 142'd for videotaping}{new defs for GC things}Set[Q.AddRef,0],{setup for GcLookup}Set[Q.DelRef,1],{setup for GcLookup}{GcLookup links  return thru GcLookRet}Set[L2.gcref,1],{GcRef}Set[L2.RplDel,2],{RplPtr}Set[L2.RplAdd,3],{RplPtr}Set[L2.ConsAdd,4],{Cons}Set[L2.ConsDel,5],{Cons}Set[L2.ConsListAdd,6],{Cons}Set[L3.TTFGcL,1],{Link Codes for Common Subroutines}Set[qPageFault, 2'b];    {page fault}Set[qWriteProtect, 3'b];    {}Set[NWWInterrupt, 4'b];    {}Set[L2.0, 0 ];{L0  MaskRet}Set[L2.WFRet, 2];{must be 2 for WF}{MaskRet}Set[L2.WFRetOdd, 3];{must be 3 for WF}{MaskRet}Set[L2.WFRetMap, 0];{must be 0 for WF}Set[L2.WFRetMapOdd, 1];{must be 1 for WF}{conflict with TextBlt}Set[L2.GFRet, 04];{L0  RxMapFixCaller}Set[L0.xRedoGF, 1 ];Set[L0.xRedoFV, 2 ];Set[L0.xRedoFV0, 3 ];Set[L0.xRedoCdr, 4 ];  {Set[L0.xRedo, 5 ];{reserved for pair with RedoCdr}}Set[L0.xRedoFVN, 6 ];  {Set[L0.xRedoGC, 7 ];}Set[L0.xRedoSClk, 9 ];{Set[L0.RedoBLT, 0D];{BLT} defd at WMapFix}{L0  MapFixCaller}Set[L0.RefillFNX, 0 ];Set[L0.RetRedo, 1 ];{}Set[L0.RedoGV, 4 ];{}Set[L0.RedoGBN, 5 ];{}Set[L0.RedoBP, 6 ];{}Set[L0.RedoGC, 7 ];{}Set[L0.ERefill,8];  {must be even}{Set[L0.RedoPBP, 9 ];}Set[L0.NERefill,0A];  {must end with 01}	Set[L0.NERefill.Set,8];  {must end with 00}	Set[WhichFixType,0B];  {used to distinquish between Refill & JRemap}Set[L0.FCRedo, 0B ];{must be even}Set[L0.BYRedoE, 0C ];{must be even}Set[L0.BYRedoO, 0D ];{must be odd}Set[L0.FCHRedo, 0E ];{2 or 3 mod 4}Set[L0.JRemap,0F]; {must be 0F}  {Set[L0.ji,7];}{L3  FixForTrap}Set[L3.rhTT.Q, 1 ];Set[L3.rhTT.TT, 2 ];Set[L3.rhMDS.Q, 3 ];{L2  typ returns thru typRet}{  1 used by CAR}{  2 used by CDR}{  3 used by LISTP}{  4 used by NTYPX}{  5 used by TYPEP}{  6 used by DTEST}Set[L2.ConsList, 7 ];{Cons}{L2  jn}Set[L2.ok, 0 ];Set[L2.STK, 1 ];Set[L2.TOS, 2 ];{L1  FixForTrap}{Fix routine to preserve Rx{context}}Set[L1.NoFixes, 0 ];{*GCONST}Set[L1.TrapGC, 1 ]; {**GCONST}Set[L1.FCH, 2 ]; {**even}Set[L1.FC, 3 ]; {**funct call}Set[L1.DecOnly, 4]; {*Cadr}{RCLK}  {Set[L1.PushDec, 4 ]; {*GETBASEBYTE}}Set[L1.Ret, 5 ]; {*Return}  {{Set[L1.fixPBY, 5 ]; {**PUTBASEBYTE}}}Set[L1.PushOnly, 6 ]; {*PUTBASEPTRN (PUTBASEBYTE)}Set[L1.PopOnly, 7]; {=7 FVAR}{*GVAR FVAR}Set[L1.Dec3, 8]; {*GBITS}{Clock}Set[L1.fixWF, 9 ]; {*PUTBITS}Set[L1.PushDec2,0A]; {*PUTBASEN}Set[L1.DecDec,0B]; {*GETBASE.N}Set[L1.Push2OK, 0C ]; {*PUTBASEBYTE}Set[L1.Refill, 0D ];	{**1-Refill}Set[L1.FNX, 0E ]; {must = 0E}{**FNX}Set[L1.fixFV, 0F]; {*fvLookup}{WMapFixCaller}Set[L0.RedoW, 1 ];  {Set[L0.WBYRedo, 2 ];}Set[L0.RedoWF, 3 ];Set[L0.WBYRedoE, 4 ];{must be even}Set[L0.WBYRedoO, 5 ];{}  {Set[L0.RedoWBLT, 6 ],}Set[L0.RedoClk, 8 ],Set[L0.RedoPBP, 9 ],Set[L0.RedoRpl, 0A ],{RplPtr}Set[L0.RedoCons1, 0B ],{Cons}Set[L0.RedoCons2, 0C ],{Cons}Set[L0.RedoBLT, 0D];{BLT}{L3  fvLookUp}Set[L3.FVAR, 2 ];{2 or 3 mod 4}Set[L3.FVARg, 0 ]; {must be even}{L1  fvLookUp 2 bit on for XLDisp}Set[L1.fvStack, 2];Set[L1.fvUnbound, 3];Set[L1.fvGlobal, 6];{stack push ops}Set[L3.atm1, 0];Set[L3.atm3, Add[08,0]];Set[L3.pls1, 2];Set[L3.pls3, Add[08,2]];Set[L3.pls2, 4];Set[L3.neg2, 6];  {Set[OpcodeBase, 500];}  {MacroDef[WriteOK, LOOPHOLE[wok]];}  {MacroDef[opcode, at[Add[#1, OpcodeBase]]];}  {MacroDef[AlwaysIBDisp, (IBDisp, IBPtr_1)];}MacroDef[ufn,  (  Rx _ #1'b, GOTO[ufn2], c1, at[Add[#1'b, OpcodeBase]])];MacroDef[ZeroBranch, ZeroBr]; {NZeroBR would force stack overflows}