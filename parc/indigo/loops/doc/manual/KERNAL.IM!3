{Begin SubSec The LOOPS Kernel}{Title The LOOPS Kernel}{Text{Tag LOOPSKernal}{Begin SubSec The Golden Braid (Object, Class, MetaClass)}{Title The Golden Braid (Object, Class, MetaClass)}{TextAll objects are directly or indirectly a subclass of the object called {lisp Object}.{index Object (Class)}  {lisp Object} holds all the methods for the defualt behavior of objects.   Heuristics for using these classes.{note ??}  This is the only object with no super classes.{lisp Class}{index Class (MetaClass)} is the class which holds the default behavior for all classes as objects.  {lisp Class} is the default MetaClass for all classes.  If {lisp Class} is not the MetaClass for a class, it must be on the supers of that metaClass.  There are messages fielded by {lisp Class} that know how to create and initialize instances.{lisp MetaClass}{index MetaClass (MetaClass)} is the class which holds the default behavior for classes which create classes.  {lisp MetaClass} is the metaclass for {lisp Class}, and is the only class which is its own metaClass. In accordance with the paragraph above {lisp Class} is a super of {lisp MetaClass}.  {Begin Note}<section to be completed!!!>Need to distinguish two purposes for metaClasses:(1) fielding msgs for a class (e.g., controlling instance creation)(2) creating classses -- ala description languages.{End Note}}{End SubSec The Golden Braid (Object, Class, MetaClass)}{Begin SubSec Perspectives and Nodes}{Title Perspectives and Nodes}{TextIn many cases it is useful to organize information in terms of multiple points of view.  For example, information about a man might be organized in terms of his role as a father, as an employee, and as a traveler.  Each point of view, called a perspective, contains information for a different purpose.  The perspecitives are related to each other in the sense that they collectively provide information about the same object.  Loops supports this organizational metaphor by providing special mixin classes called {lisp Perspective} and {lisp Node}.{Def {Type (Class)} {Name Perspective} {Text} }IVs:{Def {Type (IV of Perspective)} {Name perspectiveNode}{TextIndirect pointer to onode containing all perspectives of this object.}}Methods:{Def {Type (Method of Perspective)} {Name AddPersp} {Args self viewName view}{PrintName {lisp (_ {arg self} AddPersp {arg viewName} {arg view})}}{TextAdds a perspective to my node.}}{Def {Type (Method of Perspective)} {Name DeleteMeAsPersp} {Args self}{PrintName {lisp (_ {arg self} DeleteMeAsPersp)}}{TextDelete this object as a perspective of node.}}{Def {Type (Method of Perspective)} {Name DeletePersp} {Args self viewName view dontCauseError}{PrintName {lisp (_ {arg self} DeletePersp {arg viewName} {arg view} {arg dontCauseError})}}{TextDeletes a perspective from node.}}{Def {Type (Method of Perspective)} {Name Destroy} {Args self}{PrintName {lisp (_ {arg self} Destroy)}}{TextDestroy self but leave other perspectives on Node.}}{Def {Type (Method of Perspective)} {Name Destroy!} {Args self}{PrintName {lisp (_ {arg self} Destroy!)}}{TextDestroy self, Node and all other perspectives on Node.}}{Def {Type (Method of Perspective)} {Name GetPersp} {Args self perspName causeError}{PrintName {lisp (_ {arg self} GetPersp {arg perspName} {arg causeError})}}{TextReturns the perspective of this instance with viewName perspName.}}{Def {Type (Method of Perspective)} {Name MakePersp} {Args self viewName nodeType}{PrintName {lisp (_ {arg self} MakePersp {arg viewName} {arg nodeType})}}{TextIf no current perspectiveNode exists, then a node will be created of class {arg nodeType} (or {lisp Node} if {arg nodeType}={lisp NIL}).  {arg nodeType} should be a subclass of {lisp Node}.  {arg self} will be made the value of the property {arg viewName} on {lisp IV} perspectives of node.  If {arg self} already has a node, then it is used.}}{Def {Type (Class)} {Name Node} {Text} }IVs:{Def {Type (IV of Node)} {Name perspectives}{TextAssociated objects are stored on the property list of {lisp perspectives} under their perspective names.  The value of this IV is irrelevant.}}Methods:{Def {Type (Method of Node)} {Name AddPersp} {Args self viewName view dontCauseError}{PrintName {lisp (_ {arg self} AddPersp {arg viewName} {arg view} {arg dontCauseError})}}{TextAdds a perspective to a node on the IV {lisp perspectives} as value of property {arg viewName}.}}{Def {Type (Method of Node)} {Name DeletePersp} {Args self viewName view dontCauseError}{PrintName {lisp (_ {arg self} DeletePersp {arg viewName} {arg view} {arg dontCauseError})}}{TextDeletes a perspective of a node on the IV {lisp perspectives} on property {arg viewName}.  Checks for consistency.  Removes from IV {lisp pespectiveNode} of {arg view}, {arg self} as value, and {arg viewName} from property {lisp myViewName}.  If {arg view} is not that perspective, then causes an error, unless surpressed.}}{Def {Type (Method of Node)} {Name Destroy} {Args self}{PrintName {lisp (_ {arg self} Destroy)}}{TextDestroy the node after detaching all its perspectives.}}{Def {Type (Method of Node)} {Name Destroy!} {Args self}{PrintName {lisp (_ {arg self} Destroy!)}}{TextDestroy the node and all its perspectives.}}{Def {Type (Method of Node)} {Name GetPersp} {Args self perspName causeError}{PrintName {lisp (_ {arg self} GetPersp {arg perspName} {arg causeError})}}{TextReturns the perspective of this node with viewName of {arg perspName}.}}}{End SubSec Perspectives and Nodes}{Begin SubSec Useful Mixins}{Title Useful Mixins}{Text{lisp NamedObject} and {lisp GlobalNamedObject} contain only one instance variable, {lisp name}{index name (IV of NamedObject)}{index name (IV of GlobalNamedObject)} which holds the name of this object.  Any Loops object can be named, but {lisp NamedObject} and {lisp GlobalNamedObject} both have their names as part of their structure, and if the structure is changed they update their name.  As indicated by its name, instances of {lisp GlobalNamedObject} are named in the global name table and will be known independent of the environment they are in.  Instances of {lisp NamedObject} may only be known in a single environment, and the name may be reused in another environment.{Def {Type (Class)} {Name NamedObject}{Text}}{Def {Type (Class)} {Name GlobalNamedObject}{Text}}{Def {Type (Class)} {Name DatedObject}{Text{lisp DatedObject} has appropriate initial active values on its two instance variables so that they are filled in at creation with the right values.}}IVs:{Def {Type (IV of DatedObject)} {Name created}{TextDate and time of creation of object.}}{Def {Type (IV of DatedObject)} {Name creator}{TextUSERNAME of creator of object.}}{Def {Type (Class)} {Name Varlength}{Text{lisp VarLength} is a mixin class which allows a class to have indexed instance variables, from 1 to {lisp (_ {arg obj} Length)}.  These have not yet been extensively used.}}IVs:{Def {Type (IV of Varlength)} {Name indexedVars}{TextPlace where indexed variables are stored for {lisp VarLength} classes.}}Methods:{Def {Type (Method of Varlength)} {Name Length} {Args self}{PrintName {lisp (_ {arg self} Length)}}{TextReturns number of indexed variables allocated in this instance.}}{note discuss printing & editing of these.}}{End SubSec Useful Mixins}{Begin SubSec The MetaClass Named "Class"}{Title The MetaClass Named "Class"}{Text{index *PRIMARY* Class (MetaClass)}This sections describes the methods defined in the metaClass {lisp Class}.  Any of these methods can be augmented or superceeded in a particular class.  The complete list of methods associated with a class can be determined by using the browser.The {lisp Add}, {lisp Delete}, {lisp List} and {lisp List!} methods have an argument {arg type} which specifies the type of element to be added, deleted, or listed.  For specifying single items, {arg type} should be one of {lisp IV}, {lisp CV}, {lisp IVProp}, {lisp CVProp}, {lisp Method}, {lisp Super}, or {lisp Meta}.  For specifying sets of items, {arg type} should be {lisp IVs}, {lisp CVs}, {lisp IVProps}, {lisp CVProps}, {lisp Methods}, {lisp Supers}, {lisp Selectors}, or {lisp Functions}.In the following methods, adding or deleting instance variables and instance variable properties affects the class, and and therefore affects only instances created after the change.  Already existing instances are not changed. {Begin Note}Eventually they will be organized as follows:(1) Printing and Examining(2) Changing Class structure(3) OtherFacilitiesHowever right now they are an alphabetical list.{End Note}{Def {Type (Method of Class)} {Name Add} {Args self type name value propertyName}{PrintName {lisp (_ {arg self} Add {arg type} {arg name} {arg value} {arg propertyName})}}{TextAdd an instance specified by {arg type} to the class.  E.g. if {arg type}={lisp IV} then add an instance variable with the given name using the given value as default.  If {arg propertyName} is given, use {arg value} instead as the property value on {arg type} created or found.  The type must be one of the item types specified above: {lisp IV}, {lisp CV}, {lisp IVProp}, {lisp CVProp}, {lisp Method}, {lisp Super}, or {lisp Meta}.}}{Def {Type (Method of Class)} {Name CommentMethods} {Args self}{PrintName {lisp (_ {arg self} CommentMethods)}}{TextFor each method in the class, obtain its argument list, and insert this in the class definition under the method property {lisp args}.{index args (Method Property)}  If the source code of a method is in core, extract the comment which should be the fourth item in the source code, and insert in the class definition under the method property {lisp doc}.{index doc (Method Property)}  If no comment is found in the source code, put the user into the editor looking at that function.  When editing is finished, retrieve the comment from the method.}}{Def {Type (Method of Class)} {Name CopyMethod} {Args self mySelector newClass newSelector}{PrintName {lisp (_ {arg self} CopyMethod {arg mySelector} {arg newClass} {arg newSelector})}}{TextCopy the method associated with the selector {arg mySelector} from {arg self} to {arg newClass} (under the new selector {arg newSelector}).  {arg newSelector} defaults to {arg mySelector}.}}{Def {Type (Method of Class)} {Name DefMethod} {Args self selector args exp}{PrintName {lisp (_ {arg self} DefMethod {arg selector} {arg args} {arg exp})}}{TextAdds a method for {arg selector} to class.  If {arg args} and {arg expr} are {lisp NIL}, puts the user into the editor)}}{Def {Type (Method of Class)} {Name Delete} {Args self type name prop}{PrintName {lisp (_ {arg self} Delete {arg type} {arg name} {arg prop})}}{TextDeletes the specified element from class.  {arg type} must be one of {lisp IV}, {lisp CV}, {lisp IVProp}, {lisp CVProp}, {lisp Method}, {lisp Super}, or {lisp Meta}.}}{Def {Type (Method of Class)} {Name Destroy} {Args self}{PrintName {lisp (_ {arg self} Destroy)}}{TextDestroys (deletes) a class.}}{Def {Type (Method of Class)} {Name Destroy!} {Args self}{PrintName {lisp (_ {arg self} Destroy!)}}{TextRecursive version of Destroy. Destroys class and its subclasses.}}{Def {Type (Method of Class)} {Name Edit} {Args self commands}{PrintName {lisp (_ {arg self} Edit {arg commands})}}{TextCalls the Interlisp Editor on the source for class.}}{Def {Type (Method of Class)} {Name EditMethod} {Args self selector commands}{PrintName {lisp (_ {arg self} EditMethod {arg selector} {arg commands})}}{TextFinds the function associated with {arg selector} in class, and calls the Interlisp Editor on it.}}{Def {Type (Method of Class)} {Name FetchMethod} {Args self selector}{PrintName {lisp (_ {arg self} FetchMethod {arg selector})}}{TextReturns the name of the function which implements this method in this class.}}{Def {Type (Method of Class)} {Name HasCV} {Args self CVName prop}{PrintName {lisp (_ {arg self} HasCV {arg CVName} {arg prop})}}{TextTests if class has the specified class variable/property.}}{Def {Type (Method of Class)} {Name HasIV} {Args self IVName prop}{PrintName {lisp (_ {arg self} HasIV {arg IVName} {arg prop})}}{TextTests if class has the specified instance variable/property.}}{Def {Type (Method of Class)} {Name List} {Args self componentType componentName propName}{PrintName {lisp (_ {arg self} List {arg componentType} {arg componentName} {arg propName})}}{TextList the immediate components of a class.  {arg componentType} is one of the item or set specifiers described above.  If {arg componentType} is one of the item specifiers, then {arg componentName} should be specified;  {lisp List} will show that item.  If {arg componentType} is {lisp IVProps} or {lisp CVProps}, then {lisp List} will show just the property names of the named item.  Otherwise, for all set descriptors, it will list all relevant items.  {arg propName} must be specified only if component is {lisp IVProps} or {lisp CVProps}.  {lisp Selectors} and {lisp Methods} are synonyms, returning the list of selectors for the class; {lisp Functions} returns the list of names of functions called for methods in this class.}}{Def {Type (Method of Class)} {Name List! } {Args self type name verboseFlg}{PrintName {lisp (_ {arg self} List! {arg type} {arg name} {arg verboseFlg})}}{TextRecursive version of {lisp List}.  Omits things inherited from {lisp Object} and {lisp Class} unless {arg verboseFlg}={lisp T}.}}{Def {Type (Method of Class)} {Name MethodDoc} {Args self selector}{PrintName {lisp (_ {arg self} MethodDoc {arg selector})}}{TextPrint documentation for the method associated with {arg selector} in TTY window.}}{Def {Type (Method of Class)} {Name MoveMethod} {Args self newClass selector}{PrintName {lisp (_ {arg self} MoveMethod {arg newClass} {arg selector})}}{TextMoves the method specified by {arg selector} from this class to the specified class, changing the name of the function if it is of form {lisp {arg className}.{arg selector}}.}}{Def {Type (Method of Class)} {Name New} {Args self name supers}{PrintName {lisp (_ {arg self} New {arg name} {arg supers})}}{Text{lisp New} method for {lisp MetaClass}.  Since {lisp MetaClass} is its own metaClass, this needs to work correctly whether {arg self} is {lisp Class} or {lisp MetaClass} or a subClass of {lisp MetaClass}.  Work is done by {fn DefineClass}{index DefineClass Fn} in LOOPS.}}{Def {Type (Method of Class)} {Name NewTemp} {Args self selector superFlg}{PrintName {lisp (_ {arg self} NewTemp {arg selector} {arg superFlg})}}{TextMake a new temporary instance of this class which will not get saved on a database unless referred to by another saved object.}}{Def {Type (Method of Class)} {Name OnFile} {Args self file}{PrintName {lisp (_ {arg self} OnFile {arg file})}}{TextReturns {lisp T} if {arg self} is defined on the file {arg file}.}}{Def {Type (Method of Class)} {Name PP} {Args self file}{PrintName {lisp (_ {arg self} PP {arg file})}}{TextPrettyprints the class on the file {arg file}.}}{Def {Type (Method of Class)} {Name PP!} {Args self file}{PrintName {lisp (_ {arg self} PP! {arg file})}}{TextPrettyPrints the class at all levels.}}{Def {Type (Method of Class)} {Name PPM} {Args self selector}{PrintName {lisp (_ {arg self} PPM {arg selector})}}{TextPrettyprints the function which implements {arg selector} in this class.}}{Def {Type (Method of Class)} {Name PPMethod} {Args self selector}{PrintName {lisp (_ {arg self} PPMethod {arg selector})}}{TextPrettyprints the function which implements {arg selector} in this class.{note how different from PPM?}}}{Def {Type (Method of Class)} {Name Put} {Args self type name value prop}{PrintName {lisp (_ {arg self} Put {arg type} {arg name} {arg value} {arg prop})}}{Text{arg type} must be one of {lisp IV}, {lisp CV}, {lisp IVProp}, {lisp CVProp}, {lisp Method}, {lisp Super}, or {lisp Meta}.  Adds the specified type to the class.}}{Def {Type (Method of Class)} {Name Rename} {Args self newName environment}{PrintName {lisp (_ {arg self} Rename {arg newName} {arg environment})}}{TextGive a class a new name, renaming those methods of the form {lisp {arg className}.{arg selector}}.}}{Def {Type (Method of Class)} {Name ReplaceSupers} {Args self supers}{PrintName {lisp (_ {arg self} ReplaceSupers {arg supers})}}{TextReplace the entire supers list for this class.}}{Def {Type (Method of Class)} {Name SetName} {Args self newName environment}{PrintName {lisp (_ {arg self} SetName {arg newName} {arg environment})}}{TextChange the name of the class, forgetting old name.  Change the names of all methods which are of the form {lisp {arg className}.{arg selector}}.  Same as {lisp Rename}.}}{Def {Type (Method of Class)} {Name SubClasses} {Args self}{PrintName {lisp (_ {arg self} SubClasses)}}{TextReturns a list of immediate subclasses currently known for this class.}}}{End SubSec The MetaClass Named "Class"}{Begin SubSec The Class Named "Object"}{Title The Class Named "Object"}{Text{index *PRIMARY* Object (Class)}All classes have {lisp Object} as one of their supers, directly or indirectly.  Therefore, all instances know how to respond to the messages defined in {lisp Object}.  These can of course be overridden in any class, but {lisp Object} provides a set of default behaviors, and generally available subroutines.  {Def {Type (Method of Object)} {Name AddIV} {Args self name value prop}{PrintName {lisp (_ {arg self} AddIV {arg name} {arg value} {arg prop})}}{TextAdds an IV to instance.  If it is not in regular set, puts it in assoc List on otherIVs.}}{Def {Type (Method of Object)} {Name AssocKB} {Args self newKBName}{PrintName {lisp (_ {arg self} AssocKB {arg newKBName})}}{TextChange assocKB of this object to {arg newKBName}.}}{Def {Type (Method of Object)} {Name At} {Args self varName prop index}{PrintName {lisp (_ {arg self} At {arg varName} {arg prop} {arg index})}}{TextReturns the value of an "instance variable" for an object.  For an instance object, instance variables hold local state.  For an object that is a class, we use "instance variable" to refer to the variables that are private to instances of the class.{note ?}  If the value is an active value, {fn GetValue} activates its {arg getFn}. }}{Def {Type (Method of Object)} {Name BreakIt} {Args self varName propName type brkOnGetAlsoFlg}{PrintName {lisp (_ {arg self} BreakIt {arg varName} {arg propName} {arg type} {arg brkOnGetAlsoFlg})}}{TextCreates an active value which will cause a break when this value is changed.  If {arg brkOnGetAlsoFlg}={lisp T}, this will also break when the value is fetched.}}{Def {Type (Method of Object)} {Name Class} {Args self}{PrintName {lisp (_ {arg self} Class)}}{TextReturns the class of this object.}}{Def {Type (Method of Object)} {Name ClassName} {Args self}{PrintName {lisp (_ {arg self} ClassName)}}{TextReturns the className of the class of the object.}}{Def {Type (Method of Object)} {Name CopyDeep} {Args self KBC}{PrintName {lisp (_ {arg self} CopyDeep {arg KBC})}}{TextCopies the unit, sharing the iName list, copying instances, activeValues and lists.{note ?} }}{Def {Type (Method of Object)} {Name CopyShallow} {Args self}{PrintName {lisp (_ {arg self} CopyShallow)}}{TextMakes a new instance (a copy of this instance, not copying the values of the instance variables), with the same contents as {arg self}.{note ?}}}{Def {Type (Method of Object)} {Name DeleteIV} {Args self varName propName}{PrintName {lisp (_ {arg self} DeleteIV {arg varName} {arg propName})}}{TextRemoves an IV from an instance.  No longer shares IVName List with class.  Some programs which depend on IV may not work.}}{Def {Type (Method of Object)} {Name DeleteIVProp} {Args self ivName ivProp}{PrintName {lisp (_ {arg self} DeleteIVProp {arg ivName} {arg ivProp})}}{TextDeletes a property of an instance variable.}}{Def {Type (Method of Object)} {Name Destroy} {Args self}{PrintName {lisp (_ {arg self} Destroy)}}{TextDestroy an object in an environment.  Removes all IVs, class pointers, etc.  For garbage collection by user.}}{Def {Type (Method of Object)} {Name DoMethod}{Args self selector class arg{sub 1} arg{sub 2} arg{sub 3} arg{sub 4} arg{sub 5} arg{sub 6} arg{sub 7} arg{sub 8} arg{sub 9} arg{sub 10}}{PrintName {lisp (_ {arg self} DoMethod {arg selector} {arg class} {arg arg{sub 1}} {arg arg{sub 2}} {arg arg{sub 3}} {arg arg{sub 4}} {arg arg{sub 5}} {arg arg{sub 6}} {arg arg{sub 7}} {arg arg{sub 8}} {arg arg{sub 9}} {arg arg{sub 10}})}}{TextMessage form of the function {fn DoMethod}.}}{Def {Type (Method of Object)} {Name Edit} {Args self commands}{PrintName {lisp (_ {arg self} Edit {arg commands})}}{TextCalls the Interlisp editor on the source of the object.}}{Def {Type (Method of Object)} {Name HasIV} {Args self ivName prop}{PrintName {lisp (_ {arg self} HasIV {arg ivName} {arg prop})}}{TextReturns {lisp T} if {arg self} contains the specified IV.}}{Def {Type (Method of Object)} {Name Inspect} {Args self ASTYPE}{PrintName {lisp (_ {arg self} Inspect {arg ASTYPE})}}{TextCalls the Interlisp inspector to examine {arg self} (as an object of type {arg ASTYPE}).}}{note check these next two (do they return T or non-NIL?}{Def {Type (Method of Object)} {Name InstOf} {Args self className}{PrintName {lisp (_ {arg self} InstOf {arg className})}}{TextReturns {lisp T} if {arg self} is an immediate instance of the class with name {arg className}.}}{Def {Type (Method of Object)} {Name InstOf!} {Args self className}{PrintName {lisp (_ {arg self} InstOf! {arg className})}}{TextReturns {lisp T} if {arg self} is an instance of the class with name {arg className} either directly or through the supers chain of its class.}}{Def {Type (Method of Object)} {Name IVMissing} {Args self varName}{PrintName {lisp (_ {arg self} IVMissing {arg varName})}}{TextCalled from macro FetchIVDescr when there is no IV {arg varName}.  If {arg varName} is an IV of the class, then it adds IV to the instance and returns the IVDescr as requested.  Will also do this if user returns with {lisp OK} from {fn HELPCHECK}.}}{Def {Type (Method of Object)} {Name List} {Args self typeName}{PrintName {lisp (_ {arg self} List {arg typeName})}}{TextList IV properties, IVS of object, or other properties inherited from class.}}{Def {Type (Method of Object)} {Name List!} {Args self type name verboseFlg}{PrintName {lisp (_ {arg self} List! {arg type} {arg name} {arg verboseFlg})}}{TextRecursive form of {lisp List} for objects.  Omits things inherited from {lisp Object} unless {arg verboseFlg} is {lisp T}.}}{Def {Type (Method of Object)} {Name MessageNotUnderstood} {Args self selector superFlg}{PrintName {lisp (_ {arg self} MessageNotUnderstood {arg selector} {arg superFlg})}}{TextInvoked when a selector is not found for an object during a message sending operation.  Attempts to do spelling correction on the selector.  Causes an error if this fails.}}{Def {Type (Method of Object)} {Name NoObjectForMsg} {Args self selector}{PrintName {lisp (_ {arg self} NoObjectForMsg {arg selector})}}{TextCalled from {fn FetchMethodOrHelp}{index FetchMethodOrHelp Fn} when {arg self} is not a Loops object with a defined class.  A specialized response to this can be tailored in a given Loops application by first reseting the global Interlisp variable {var DefaultObject}{index DefaultObject Var} to point to an object.  This default object will field {lisp NoObjectForMsg} messages from {fn FetchMethodOrHelp}.  The method for {lisp NoObjectForMsg} on {var DefaultObject} should return a default value, usually dependent on the selector.  This version of {lisp NoObjectForMsg} just causes an error break.  A user can return from the error by typing {lisp RETURN {arg value}}, where {arg value} is the value that should have been returned as the result of sending {arg selector} to {arg self}.}}{Def {Type (Method of Object)} {Name PP} {Args self file}{PrintName {lisp (_ {arg self} PP)}}{TextPrettyPrints an instance definition on {arg file}.}}{Def {Type (Method of Object)} {Name PP!} {Args self file}{PrintName {lisp (_ {arg self} PP! {arg file})}}{TextPrettyPrints an instance to all levels.}}{Def {Type (Method of Object)} {Name PrintOn} {Args self file}{PrintName {lisp (_ {arg self} PrintOn {arg file})}}{TextThis is the default printing function for {lisp Object}.  It distinguishes between temporary objects, named objects, and others.}}{Def {Type (Method of Object)} {Name Put} {Args self varName newValue propName index}{PrintName {lisp (_ {arg self} Put {arg varName} {arg newValue} {arg propName} {arg index})}}{TextPuts {arg newValue} in an instance variable (see {fn GetValue}, {PageRef Fn GetValue}).  If the value/property of the variable contains an active value, the {arg putFn} is activated.}}{Def {Type (Method of Object)} {Name Rename} {Args self newName environment}{PrintName {lisp (_ {arg self} Rename {arg newName} {arg environment})}}{TextRemoves an old name, and gives it new name.}}{Def {Type (Method of Object)} {Name SetName} {Args self name environment noBitchFlg}{PrintName {lisp (_ {arg self} SetName {arg name} {arg environment} {arg noBitchFlg})}}{TextAssociates a name with an object in an environment.  This works for instances and classes.  An object can have more than one name.}}{Def {Type (Method of Object)} {Name TraceIt} {Args self varName propName type traceGetAlsoFlg}{PrintName {lisp (_ {arg self} TraceIt {arg varName} {arg propName} {arg type} {arg traceGetAlsoFlg})}}{TextCreates an active value which will cause tracing when this variable is changed.  Will also trace on fetches if {arg traceGetAlsoFlg}={lisp T}.}}{Def {Type (Method of Object)} {Name UnSetName} {Args self name environment}{PrintName {lisp (_ {arg self} UnSetName {arg name} {arg environment})}}{TextIf {arg name} actually names {arg self} in {arg environment}, then delete the association between {arg self} and {arg name}.}}{Def {Type (Method of Object)} {Name Understands} {Args self selector}{PrintName {lisp (_ {arg self} Understands {arg selector})}}{TextTests if {arg self} will respond to {arg selector}.}}{Def {Type (Method of Object)} {Name WhereIs} {Args self name type propName}{PrintName {lisp (_ {arg self} WhereIs {arg name} {arg type} {arg propName})}}{TextSearches the supers hierarchy until it finds the class from which {arg type} is inherited.  {arg type}={lisp NIL} defaults to {lisp METHODS}.}}}{End SubSec The Class Named "Object"}{Begin SubSec Functions for changing Loops Structure}{Title Functions for changing Loops Structure}{Text{Begin SubSec Moving and Renaming Methods}{Title Moving and Renaming Methods}{TextThere are a number of Interlisp functions available to help in the process of reorganizing class structures.  It is often the case in the development of a set of classes for some job that one finds some common super class of a set of classes, and wants to move a method up to the super, or copy it down from the super.  Also renaming both the selector and the function of a method is sometimes useful.{FnDef {Name RenameMethod} {Args className oldSelector newSelector}{TextChanges the selector {arg oldSelector} to {arg newSelector} in {arg className} and if the function name is {lisp {arg className}.{arg oldSelector}} does a {lisp RENAME} to {lisp {arg className}.{arg newSelector}}.}}{FnDef {Name RenameMethodFunction} {Args class oldName newName}{TextRenames a function used as a method in {arg class}.  Does not change the selector.  Complains if {arg oldName} is not found.}}{FnDef {Name MoveMethod} {Args oldClassname newClassName selector}{TextMoves the method from {arg oldClassname} to {arg newClassName}, and renames the function if it is of the form {lisp {arg oldClassname}.{arg selector}} to {lisp {arg newClassName}.{arg selector}}.}}{FnDef {Name CalledFns} {Args classes definedFlg}{TextGiven a list of classes, this function computes the list of all functions called by those classes.  If {arg definedFlg}={lisp T}, only returns the list of those functions which are defined.}}}{End SubSec Moving and Renaming Methods}{Begin SubSec Moving and Renaming Variables}{Title Moving and Renaming Variables}{TextIt is sometimes convenient to be able to move methods and variables when reconfiguring classes in an inheritance lattice.  The following functions are provided for this.:{FnDef {Name RenameVariable} {Args className oldVarName newVarName classFlg}{TextChanges the name of the variable from {arg oldVarName} to {arg newVarName}.  Changes any references to these variables in methods of the class. }}{FnDef {Name MoveVariable} {Args oldClassName newClassname variableName}{TextMoves the entire description of an instance variable into the new class.}}{FnDef {Name MoveClassVariable} {Args oldClassName newClassname variableName}{TextMoves the entire description of a class variable into the new class.}}}{End SubSec Moving and Renaming Variables}}{End SubSec Functions for changing Loops Structure}}{End SubSec The LOOPS Kernel}