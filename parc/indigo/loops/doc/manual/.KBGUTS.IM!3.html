<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Loops>DOC>MANUAL>KBGUTS.IM!3</title>
  </head>
  <body>
    <pre>
{Begin SubSec The Class KBState}{Title The Class KBState}{Text{Def {Type (Class)} {Name KBState}{Text}}IVs:{Def {Type (IV of KBState)} {Name name}{TextName of file associated with this KBState.  {lisp NIL} as value here overrides active value in named object.}}{Def {Type (IV of KBState)} {Name contents}{TextEither {lisp CURRENT}, meaning the current state of the KB with name or a list of layers and KBStates specifying layerset)}}Methods:{Def {Type (Method of KBState)} {Name AddEntities} {Args entityList}{PrintName (&larr; {arg self} AddEntities {arg entityList})}{TextAdd all items on {lisp contents} and {arg self} to {arg entityList}. Called by functions which write out the boot layer to make sure that all layers are added to the list of items to be dumped.}}{Def {Type (Method of KBState)} {Name AddToContents} {Args newAddition}{PrintName (&larr; {arg self} AddToContents {arg newAddition})}{TextAdds a new item to {lisp contents} of KB.}}{Def {Type (Method of KBState)} {Name Connect} {Args nameTable}{PrintName (&larr; {arg self} Connect {arg nameTable})}{TextRead in object file indices from all, possibly implicit, layers in order. These are being opened for input only.}}{Def {Type (Method of KBState)} {Name CurrentState} {Args}{PrintName (&larr; {arg self} CurrentState)}{TextCreate a KB state which reflects the current state of this KB.}}{Def {Type (Method of KBState)} {Name DescribeLayers} {Args dateOrDays assocKB}{PrintName (&larr; {arg self} DescribeLayers {arg dateOrDays} {arg assocKB})}{TextReturn a KBState whose contents are just those layers which occur after {arg dateOrDays} and have KB {arg assocKB}, or {lisp NIL} if none.}}{Def {Type (Method of KBState)} {Name Files} {Args fileList}{PrintName (&larr; {arg self} Files {arg fileList})}{Text{arg fileList} is a {fn TCONC} list of files already found.  Add any new ones found.  Very similar in structure to {lisp KBState.Connect}.}}{Def {Type (Method of KBState)} {Name MyKB} {Args}{PrintName (&larr; {arg self} MyKB)}{TextReturn the KB object corresponding to this KBState.}}{Def {Type (Method of KBState)} {Name ReadBoot} {Args}{PrintName (&larr; {arg self} ReadBoot)}{TextRead the boot file for this KB.}}{Def {Type (Method of KBState)} {Name SetContents} {Args lst}{PrintName (&larr; {arg self} SetContents {arg lst})}{TextMake KB have new contents.  Check types of elements.}}}{End SubSec The Class KBState}{Begin SubSec The Class KB}{Title The Class KB}{Text{Def {Type (Class)} {Name KB}{Text}}IVs:{Def {Type (IV of KB)} {Name connectedEnvs}{TextList of Envs which have read in contents of this KB.}}{Def {Type (IV of KB)} {Name contents}{TextKBs start out with an empty list of contents.}}{Def {Type (IV of KB)} {Name currentWriter}{TextEnvironment which is currently writing on this KB.}}{Def {Type (IV of KB)} {Name fileName}{TextFull name of file where this KB is stored.  Computed the first time it is needed.  Never stored.}}{Def {Type (IV of KB)} {Name owners}{TextList of owners of this KB.}}{Def {Type (IV of KB)} {Name status}{TextOne of {lisp Disconnected}, {lisp Connected}, or {lisp BootNeeded}.}}Methods:{Def {Type (Method of KB)} {Name AddToContents} {Args newAddition}{PrintName (&larr; {arg self} AddToContents {arg newAddition})}{TextAdds a new item to contents of KB.}}{Def {Type (Method of KB)} {Name ConnectForOutput} {Args nameTable}{PrintName (&larr; {arg self} ConnectForOutput {arg nameTable})}{TextRead in object file indices from all, possibly implicit, layers in order.  This is being opened for output.}}{Def {Type (Method of KB)} {Name CopyFileLayer} {Args layer}{PrintName (&larr; {arg self} CopyFileLayer {arg layer})}{TextCopies the FileLayer referred to by {arg layer} onto {arg self}, and adds a new Layer describing copied fileLayer onto contents of {arg self}.}}{Def {Type (Method of KB)} {Name CopyFileLayers} {Args layerDescription}{PrintName (&larr; {arg self} CopyFileLayers {arg layerDescription})}{TextCopy all the layers in {arg layerDescription} which should be a KBState into {arg self}.}}{Def {Type (Method of KB)} {Name Disconnect} {Args}{PrintName (&larr; {arg self} Disconnect)}{TextDisconnect this KB and close its file if open.}}{Def {Type (Method of KB)} {Name FreezeKB} {Args name}{PrintName (&larr; {arg self} FreezeKB {arg name})}{TextFind a KBState with {lisp %@name}={arg name} and {lisp contents}={lisp CURRENT}.  Replace it by a new KBState with {lisp contents} = currentState of myKB.  Return new KBState or {lisp NIL} if failure.}}{Def {Type (Method of KB)} {Name PrintContents} {Args file}{PrintName (&larr; {arg self} PrintContents {arg file})}{TextFn to Print out a formatted description of the contents of a knowledge base.}}{Def {Type (Method of KB)} {Name SetContents} {Args lst}{PrintName (&larr; {arg self} SetContents {arg lst})}{TextMake KB have new contents.  Check types of elements.}}{Def {Type (Method of KB)} {Name ThawKB} {Args name}{PrintName (&larr; {arg self} ThawKB {arg name})}{TextFind a KBState with {lisp (GetValue {arg self} (QUOTE name))}={arg name} and {lisp contents} not equal {lisp CURRENT}.  Replace it by a new KBState with {lisp contents} = {lisp CURRENT}.  Return new KBState or {lisp NIL} if failure.}}{Def {Type (Method of KB)} {Name WriteBoot} {Args}{PrintName (&larr; {arg self} WriteBoot)}{TextWrite out boot file containing KB and all layers and KBStates it contains implicitly or explicitly.}}{Def {Type (Method of KB)} {Name WriteEntityFile} {Args changedEntities namedEntities assockbName}{PrintName (&larr; {arg self} WriteEntityFile {arg changedEntities} {arg namedEntities} {arg assockbName})}{TextWrites the entities (objects) out to a layer in a given kb.}}{Def {Type (Method of KB)} {Name WriteFileLayer} {Args kbName nameTable}{PrintName (&larr; {arg self} WriteFileLayer {arg kbName} {arg nameTable})}{TextWrites the facts on the file, appending to file.  Format of layer is: - indexFilePosition (up to 7 characters) - entityCount (up to 7 characters) - nameCount (up to 7 characters) - entity records - indexRecords (UID followed by file position,) - nameRecords (name followed by UID) - initialFilePosition.}}}{End SubSec The Class KB}{Begin SubSec The Class Environment}{Title The Class Environment}{Text{Def {Type (Class)} {Name Environment}{Text}}IVs:{Def {Type (IV of Environment)} {Name status}{TextOne of {lisp NotOpen} or {lisp Open}.  {lisp Open} when indexes of KBs have been read in, {lisp NotOpen} after {lisp ClearObjectMemory}.}}{Def {Type (IV of Environment)} {Name nameTable}{TextnameTable for looking up UIDs and names.}}{Def {Type (IV of Environment)} {Name outputKB}{TextKB to which changes will be filed, and which specifies contents.}}{Def {Type (IV of Environment)} {Name assocKB}{TextName of the KB associated with new objects created.}}Methods:{Def {Type (Method of Environment)} {Name AssocKB} {Args akb}{PrintName (&larr; {arg self} AssocKB {arg akb})}{TextMake {arg akb} be the assocKB of this KB.}}{Def {Type (Method of Environment)} {Name Cancel} {Args}{PrintName (&larr; {arg self} Cancel)}{TextErase an environment without cleaning up so that environment is empty, as if it were not open, but it is still connected to the same KB.  Make it not current.}}{Def {Type (Method of Environment)} {Name ChangedKBs} {Args}{PrintName (&larr; {arg self} ChangedKBs)}{TextFinds the names of all KBs that have any modified entities associated with them.}}{Def {Type (Method of Environment)} {Name Cleanup} {Args KBNames noBootLayerFlg}{PrintName (&larr; {arg self} Cleanup {arg KBNames} {arg noBootLayerFlg})}{TextWrite FileLayers for KBs named in {arg KBNames}.  If {arg KBNames}={lisp NIL} then write a layer for each changed KB.  If {arg KBNames}={lisp T} then write one layer for all changes.  If {arg KBNames} is a single atom, then the update is written for that single assocKB.  Finish by writing new boot layer for outputKB unless {arg noBootLayerFlg} is {lisp T}.}}{Def {Type (Method of Environment)} {Name ClearObjectMemory} {Args}{PrintName (&larr; {arg self} ClearObjectMemory)}{TextWrite out boot layer if needed and clear nameTable.}}{Def {Type (Method of Environment)} {Name Close} {Args assocKBs}{PrintName (&larr; {arg self} Close {arg assocKBs})}{TextCleanup an environment so that all files are closed, and environment is empty, as if it were just created.}}{Def {Type (Method of Environment)} {Name ConnectOutput} {Args KB}{PrintName (&larr; {arg self} ConnectOutput {arg KB})}{TextMake {arg KB} be the file onto which changes in this Environment will be written.}}{Def {Type (Method of Environment)} {Name CopyObjects} {Args objList}{PrintName (&larr; {arg self} CopyObjects {arg objList})}{TextCopies objects on {arg objList} using the object structure of the object in Environment {arg self} with same UID, if found.}}{Def {Type (Method of Environment)} {Name DumpToKB} {Args kbName assocKBNames}{PrintName (&larr; {arg self} DumpToKB {arg kbName} {arg assocKBNames})}{Text???}}{Def {Type (Method of Environment)} {Name Files} {Args fileLst}{PrintName (&larr; {arg self} Files {arg fileLst})}{TextGet a list of all files associated with this environment.  Argument to {lisp KBState.Files} is a {fn TCONC} list.}}{Def {Type (Method of Environment)} {Name IsCurrent} {Args}{PrintName (&larr; {arg self} IsCurrent)}{TextTest if current.}}{Def {Type (Method of Environment)} {Name MakeCurrent} {Args}{PrintName (&larr; {arg self} MakeCurrent)}{TextSet values of {var CurrentNameTable} and {var CurrentEnvironment} from {arg self} and make {var DefaultKBName} be my assocKB.}}{Def {Type (Method of Environment)} {Name MakeNotCurrent} {Args bitchIfNotCurrent}{PrintName (&larr; {arg self} MakeNotCurrent {arg bitchIfNotCurrent})}{TextMakes no Environment Current if this is current, elses causes Error if not Current and {arg bitchIfNotCurrent}={lisp T}.}}{Def {Type (Method of Environment)} {Name MapObjectNames} {Args mapFn assocKBs noUIDs}{PrintName (&larr; {arg self} MapObjectNames {arg mapFn} {arg assocKBs} {arg noUIDs})}{Text{fn APPLY} {arg mapFn} to the name of each object stored in the environment.  If {arg assocKBs} given, select only those which are in the list.  If {arg noUIDs}={lisp T} then apply only to names which are not UIDs.  If {arg mapFn}={lisp NIL} then just list all names and UIDs; if {arg mapFn}={lisp T} then just the names.}}{Def {Type (Method of Environment)} {Name MarkDeleted} {Args objToBeDeleted}{PrintName (&larr; {arg self} MarkDeleted {arg objToBeDeleted})}{TextMark object as deleted in KB when new layer is written out.  Done by smashing localRecord field of entity, but NOT storedIn field.  See {lisp SelectChangedEntity}.}}{Def {Type (Method of Environment)} {Name Open} {Args}{PrintName (&larr; {arg self} Open)}{TextRead in the index of all the layers referred to by contents of outputKB.}}{Def {Type (Method of Environment)} {Name WriteBoot} {Args}{PrintName (&larr; {arg self} WriteBoot)}{TextMake outputKB write it's boot file.}}{Def {Type (Method of Environment)} {Name WriteUpdate} {Args kbName}{PrintName (&larr; {arg self} WriteUpdate {arg kbName})}{TextWrite layer for {arg kbName}, or all changes if {arg kbName}={lisp T}.}}}{End SubSec The Class Environment}{Begin SubSec The Class Layer}{Title The Class Layer}{Text{Def {Type (Class)} {Name Layer}{Text}}IVs:{Def {Type (IV of Layer)} {Name file}{TextName of the file where FileLayer is found.  Compute it on firstFetch from the kbName by searching directory path.  Don't save full name on file.}}{Def {Type (IV of Layer)} {Name kbName}{TextName of kb where this layer was stored e.g. BRIDGE.}}{Def {Type (IV of Layer)} {Name position}{TextIndex on file where FileLayer is found.}}{Def {Type (IV of Layer)} {Name assocKB}{TextName of KB with which this Layer is associated conceptually.}}Methods:{Def {Type (Method of Layer)} {Name AddEntities} {Args entityList}{PrintName (&larr; {arg self} AddEntities {arg entityList})}{TextAdd {arg self} to entity list for dumping on boot layer.}}{Def {Type (Method of Layer)} {Name Connect} {Args nameTable}{PrintName (&larr; {arg self} Connect {arg nameTable})}{TextOpen layer file and read in index.}}{Def {Type (Method of Layer)} {Name Files} {Args fileLst}{PrintName (&larr; {arg self} Files {arg fileLst})}{TextAdd my file to list if it is not already there.}}{Def {Type (Method of Layer)} {Name MapObjectNames} {Args mapFn noUIDs}{PrintName (&larr; {arg self} MapObjectNames {arg mapFn} {arg noUIDs})}{TextApply {arg mapFn} to objectnames in layer, or make a list of them if {arg mapFn}={lisp NIL}.}}}{End SubSec The Class Layer}{Begin SubSec The Class KBMeta}{Title The Class KBMeta}{Text{Def {Type (Class)} {Name KBMeta}{Text}}Methods:{Def {Type (Method of KBMeta)} {Name New} {Args kbName envName newVersionFlg}{PrintName (&larr; {arg self} New {arg kbName} {arg envName} {arg newVersionFlg})}{TextCreate a new KnowledgeBase file, and an environment if {arg kbName} is given, and make environment current.}}{Def {Type (Method of KBMeta)} {Name Old} {Args kbName envName}{PrintName (&larr; {arg self} Old {arg kbName} {arg envName})}{TextGet KB for this kbName.  (Causes boot layer to be read unless KB is already in the global table.)  If {arg envName} is given, creates an Environment of that name and connects the environment to the KB.}}{Def {Type (Method of KBMeta)} {Name ReadBoot} {Args}{PrintName (&larr; {arg self} ReadBoot)}{TextRead in index of existing KB given kbName.}}{Def {Type (Method of KBMeta)} {Name ReadOldBootLayer} {Args kbName numBack}{PrintName (&larr; {arg self} ReadOldBootLayer {arg kbName} {arg numBack})}{TextRead in index of already existing KB.}}{Def {Type (Method of KBMeta)} {Name Summarize} {Args fromKBName toKBName assocKBNames namedObjectsOnly}{PrintName (&larr; {arg self} Summarize {arg fromKBName} {arg toKBName} {arg assocKBNames} {arg namedObjectsOnly})}{TextIncorporate all objects of {arg fromKBName} with assocKB in {arg assocKBNames} (or all if {arg assocKBNames}={lisp NIL}) into new KB {arg toKBName}.  If {arg namedObjectsOnly}={lisp T}, then only copies over all those entities referred to by a name or by a named object directly or indirectly.  This latter feature provides a mechanism for garbage collection.}}}{End SubSec The Class KBMeta}{Begin SubSec The Class EnvironmentMeta}{Title The Class EnvironmentMeta}{Text{Def {Type (Class)} {Name EnvironmentMeta}{Text}}Methods:{Def {Type (Method of EnvironmentMeta)} {Name Cleanup} {Args}{PrintName (&larr; {arg self} Cleanup)}{TextWrite updates for all open environments.}}{Def {Type (Method of EnvironmentMeta)} {Name Close} {Args leaveKBattachedFlg}{PrintName (&larr; {arg self} Close {arg leaveKBattachedFlg})}{TextClose all the open environments.}}{Def {Type (Method of EnvironmentMeta)} {Name OpenFiles} {Args}{PrintName (&larr; {arg self} OpenFiles)}{TextReturns a list of the open files for all open Environments.}}}{End SubSec The Class EnvironmentMeta}</pre>
  </body>
</html>
