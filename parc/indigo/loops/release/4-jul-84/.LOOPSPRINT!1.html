<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Loops>RELEASE>4-JUL-84>LOOPSPRINT!1</title>
  </head>
  <body>
    <pre>
(FILECREATED "26-Jun-84 14:01:35" {INDIGO}&lt;LOOPS&gt;SOURCES&gt;LOOPSPRINT.;13 34836        changes to:  (FNS PrttyInstances)      previous date: "19-Jun-84 15:33:13" {INDIGO}&lt;LOOPS&gt;SOURCES&gt;LOOPSPRINT.;12)(* Copyright (c) 1983, 1984 by Xerox Corporation)(PRETTYCOMPRINT LOOPSPRINTCOMS)(RPAQQ LOOPSPRINTCOMS [(* Copyright (c)			  1983 by Xerox Corporation)		       (* Set up Printing of classes and instances)		       (P (DEFPRINT 'activeValue 'PrintActiveValue)			  (DEFPRINT 'class 'PrintClass)			  (DEFPRINT 'instance 'PrintInstance))		       (ALISTS (PRETTYPRINTYPEMACROS instance))		       (* PPObj is Called by the PreetyPrinter on instances ObjectAlwaysPPFlag and 			  ObjectDontPPFlag are used to determine if the PrettyPrint macro should be 			  applied recursively within the scope of a pretty printing operation. 			  ObjectDontPPFlag is bound to NIL in Object.PP and around MAKEFILE to 			  supress recursive prettyprinting on files and if objects don't have special 			  PP Methods of there own. ObjectAlways PPFlag is bound to NIL in the advice 			  to MAKEFILE so that recursion won't take place there unless the user 			  explicitly sets the value)		       (FNS PPObj)		       (VARS (ObjectAlwaysPPFlag)			     (ObjectDontPPFlag))		       (ADVICE MAKEFILE)		       (* * Functions for handling READ macros)		       (FNS * INFNS)		       (* * Prettyprinting functions)		       (FNS * PPFNS)		       (* This defines what is to happen when the command (CLASSES * CLASSNAMES)			  appears in a coms list.)		       (FILEPKGCOMS INSTANCES METHODS CLASSES)		       (* The following defines class, classes, and CLASS as synonyms for CLASSES 			  with respect to the file package type. Set up macros so that references to 			  classes and instances seen by HPRINT don't recur into their structure.)		       (ADDVARS (FILEPKGTYPES (class . CLASSES)					      (classes . CLASSES)					      (CLASS . CLASSES)					      (INSTANCE INSTANCES)					      (instance INSTANCES))				(HPRINTMACROS (class . HPRINTCLASS)					      (instance . HPRINTINSTANCE)))		       (* Set Up Loops Read Macros for ,@, and $)		       (P (SETALLSYNTAX %# (MACRO FIRST HashMacro)))		       (ADVICE * LOOPSPRINTADVICE)		       (ADDVARS (DWIMUSERFORMS (TRANS@$)))		       (DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS				 (ADDVARS (NLAMA DEFINSTANCES DEFINST DEFCLASSES DEFCLASS)					  (NLAML SETALLSYNTAX)					  (LAMA])(* Copyright (c) 1983 by Xerox Corporation)(* Set up Printing of classes and instances)(DEFPRINT 'activeValue 'PrintActiveValue)(DEFPRINT 'class 'PrintClass)(DEFPRINT 'instance 'PrintInstance)(ADDTOVAR PRETTYPRINTYPEMACROS (instance . PPObj))(* PPObj is Called by the PreetyPrinter on instances ObjectAlwaysPPFlag and ObjectDontPPFlag are used to determine if the PrettyPrint macro should be applied recursively within the scope of a pretty printing operation. ObjectDontPPFlag is bound to NIL in Object.PP and around MAKEFILE to supress recursive prettyprinting on files and if objects don't have special PP Methods of there own. ObjectAlways PPFlag is bound to NIL in the advice to MAKEFILE so that recursion won't take place there unless the user explicitly sets the value)(DEFINEQ(PPObj  [LAMBDA (instance)                                         (* dgb: "15-Jun-84 22:39")                                                             (* Called by the PreetyPrinter on instances)    (COND      ([AND (NOT ObjectAlwaysPPFlag)	    (OR ObjectDontPPFlag (AND (NEQ (OUTPUT)					   T)				      (NOT (DISPLAYSTREAMP (OUTPUT]	(PRIN2 instance))      (T (&larr; instance PP)))    NIL]))(RPAQQ ObjectAlwaysPPFlag NIL)(RPAQQ ObjectDontPPFlag NIL)(PUTPROPS MAKEFILE READVICE (NIL (AROUND NIL (PROG ((ObjectAlwaysPPFlag))						   *))))(* * Functions for handling READ macros)(RPAQQ INFNS (AtMacro AtMacroConstruct DataType DollarMacro GetLispClass HPRINTCLASS HPRINTINSTANCE 		      HREADCLASS HREADINSTANCE HashMacro InitializeLOOPS LoopsSyntax 		      PrettyPrintInstance SETALLSYNTAX TRANS@$))(DEFINEQ(AtMacro  [LAMBDA (fileHandle readTable)                             (* dgb: "17-SEP-82 02:28")          (* Causes the following transformations by a read-in macro. -	  %@FOO -&gt; (GetValue self (QUOTE FOO)) or (%@ FOO) -	  %@%@FOO -&gt; (GetClassValue self (QUOTE FOO)) or (%@%@ FOO) -	  %@FOO&larr;exp -&gt; (PutValue self exp) or (&larr;%@ FOO exp) -	  %@FOO&larr;+exp -&gt; (PushValue self exp) -	  %@%@FOO&larr; exp -&gt; (PutClassValue self exp) -	  %@%@FOO&larr;+ exp -&gt; (PushClassValue self exp) -	  %@ (X foo) -&gt; (GetValue X (QUOTE foo)) or (%@ X foo) -	  %@ (X foo prop) -&gt; (GetValue X (QUOTE foo) (QUOTE prop)) or (%@ X foo prop) -	  %@%@ (x foo) -&gt; (GetClassValue x (QUOTE foo)) or (%@%@ X foo prop) -	  %@%@ (x foo prop) -&gt; (GetClassValue x (QUOTE foo) (QUOTE prop)) -	  or (%@%@ X foo prop) -	  ... and similarly for the puts using &larr;%@ and &larr;%@%@ with the newValue always last)                                                             (* Also performs transformations for getting and putting							     properties of class variables and instance variables.)    (PROG (classVarFlg varName propName storeFlg newValueForm temp (objName (QUOTE self)))          (COND	    ((EQ (QUOTE %@)		 (PEEKC fileHandle))                         (* If next character is an "@" then this is a reference 							     to a class variable)	      (SETQ classVarFlg T)	      (READC fileHandle)))          (COND	    ((EQ (PEEKC fileHandle readTable)		 (QUOTE %())	      (SETQ temp (READ fileHandle readTable))	      (SETQ objName (CAR temp))	      (SETQ varName (CADR temp))	      (SETQ propName (CADDR temp)))	    [(NEQ (QUOTE OTHER)		  (GETSYNTAX (PEEKC fileHandle)			     readTable))                     (* Quit if character after the At looks like LISP 							     usage.)	      (RETURN (COND			(classVarFlg (QUOTE %@%@))			(T (QUOTE %@]	    (T                                               (* Here unless varName already ready with propName.)                                                             (* Temporarily make LeftArrow a BREAK character before 							     reading expression.)	       (RESETSAVE (SETSYNTAX (QUOTE &larr;)				     (QUOTE BREAKCHAR)				     readTable)			  (LIST (QUOTE SETBRK)				(GETBRK readTable)))	       (SETQ varName (RATOM fileHandle readTable))	       (SETSYNTAX (QUOTE &larr;)			  (QUOTE OTHER)			  readTable)))          [COND	    ((EQ (QUOTE &larr;)		 (PEEKC fileHandle readTable))	      (READC fileHandle readTable)	      (COND		((EQ (PEEKC fileHandle readTable)		     (QUOTE +))                              (* This means to push value on front)		  (READC fileHandle)		  (SETQ storeFlg 1))		(T (SETQ storeFlg T)))	      (SETQ newValueForm (READ fileHandle readTable]          (RETURN (AtMacroConstruct objName varName propName newValueForm classVarFlg storeFlg])(AtMacroConstruct  [LAMBDA (objName varName propName newValue classVarFlg storeFlg)                                                             (* dgb: "17-SEP-82 02:37")                                                             (* Constructs the form needed for atMacro.							     See translation table in AtMacro)    (COND      [(NULL storeFlg)	(NCONC [LIST (COND		       (classVarFlg (QUOTE %@%@))		       (T (QUOTE %@]	       (COND		 ((OR propName (NEQ (QUOTE self)				    objName))		   (LIST objName)))	       (LIST varName)	       (COND		 (propName (LIST propName]      [(EQ storeFlg 1)	(NCONC (LIST (COND		       (classVarFlg (QUOTE PushClassValue))		       (T (QUOTE PushValue)))		     objName		     (KWOTE varName))	       (LIST newValue)	       (COND		 (propName (LIST (KWOTE propName]      (T (NCONC [LIST (COND			(classVarFlg (QUOTE &larr;%@%@))			(T (QUOTE &larr;%@]		(COND		  ((OR propName (NEQ (QUOTE self)				     objName))		    (LIST objName)))		(LIST varName)		(COND		  (propName (LIST propName)))		(LIST newValue])(DataType  [LAMBDA (self varName localSt propName activeVal type)     (* dgb: "13-DEC-82 16:24")                                                             (* Dummy to cause dumping of noncircular datatype in 							     instances)    localSt])(DollarMacro  [LAMBDA (fileHandle readTable)                             (* dgb: "23-NOV-81 14:42")          (* Causes %$FOO to be translated at READ time into (GetObjectRec (QUOTE FOO)). The localState of this expression 	  is the objectRec itself)    (COND      [(EQ (GETSYNTAX (PEEKC fileHandle readTable))	   (QUOTE OTHER))	(LIST (QUOTE %$)	      (MKNAME (READ fileHandle readTable]      (T (QUOTE %$])(GetLispClass  [LAMBDA (obj)                                              (* dgb: "30-NOV-81 21:24")          (* * Gets the class corresponding to the Lisp object as specified in LispClassTable)    (COND      ((AND (LISTP obj)	    (type? class (CAR obj)))	(CAR obj))      (T (GETHASH (TYPENAME obj)		  LispClassTable])(HPRINTCLASS  [LAMBDA (EXPR FILE)                                        (* dgb: "18-MAR-83 16:35")                                                             (* Used by HPRINT to print out an expression which will 							     be read back in as a class)    (PRIN1 (QUOTE (HREADCLASS))	   FILE)    (PRIN2 (ClassName EXPR])(HPRINTINSTANCE  [LAMBDA (EXPR FILE)                                        (* dgb: "18-MAR-83 16:36")                                                             (* Used by HPRINT to print out an expression referring 							     to an instance, provided instance is dumped eleewhere)    (PRIN1 (QUOTE (HREADINSTANCE))	   FILE)    (PRIN2 (UID EXPR])(HREADCLASS  [LAMBDA (FILE)                                             (* dgb: "13-DEC-82 15:13")    (GetObjectRec (HREAD FILE])(HREADINSTANCE  [LAMBDA (FILE)                                             (* dgb: "13-DEC-82 17:41")    (GetObjectRec (MKNAME (HREAD FILE])(HashMacro  [LAMBDA (fileHandle readTable)                             (* dgb: "19-JAN-83 12:03")    (PROG (val name filePosition)          (RETURN (SELECTQ (SETQ val (PEEKC fileHandle))			   (%$                               (* %#%$FOO causes the unit named FOO to be read in right							     now, and a pointer to it inserted in the list being 							     read)			       (READC fileHandle)			       (SETQ name (READ fileHandle readTable))			       (OR (EQ T fileHandle)				   (SETQ filePosition (GETFILEPTR fileHandle)))                                                             (* Don't worry about the file position if reading from 							     the terminal)			       (SETQ val (GetObjectRec (MKNAME name)))			       [COND				 ((AND (NULL val)				       (STRINGP name))				   (SETQ val (NewObject OBJECT (MKNAME name]			       (OR (EQ T fileHandle)				   (SETFILEPTR fileHandle filePosition))			       val)			   [&amp;                                (* reads in an unnamed instance of type class, or 							     fetches old value. may change values)			      (READC fileHandle)			      (SETQ val (READ fileHandle readTable))			      (COND				[[FIXP (CDR (LISTP (CADR val]				  (RETURN (VAG (CADR val]				(T (RETURN (ModifyInstance val]			   [- (READC fileHandle)             (* a datatype dumped)			      (RETURN (create activeValue					      getFn &larr;(QUOTE DataType)					      localState &larr;(HREAD fileHandle]			   (SELECTQ (GETSYNTAX val readTable)				    (LEFTPAREN (SETQ val (READ fileHandle readTable))                                                             (* %# (val getFn putFn) is how ordinary active values 							     are printed out, and are to be read back in)					       (create activeValue						       localState &larr;(CAR val)						       getFn &larr;(CADR val)						       putFn &larr;(CADDR val)))				    ((LEFTBRACKET RIGHTPAREN RIGHTBRACKET STRINGDELIM BREAKCHAR 						  SEPRCHAR)				      (QUOTE %#))				    (PACK* (QUOTE %#)					   (RATOM fileHandle readTable])(InitializeLOOPS  [LAMBDA NIL                                                (* dgb: "26-DEC-83 15:30")                                                             (* Fn to initialize LOOPS package.)                                                             (* Set break characters for read macros.)    (LoopsSyntax T)                                          (* Initialize interaction with file system)    [COND      ((NLISTP (GETTOPVAL (QUOTE LispClassTable)))	(SETQ LispClassTable (CONS (HARRAY 16]    (SETQ DefaultKBName NIL)    (SETQ CurrentNameTable NIL)    (SETQ AllObjectNames NIL)    (DB-InitUI])(LoopsSyntax  [LAMBDA (offFlg)                                           (* dgb: " 3-JUN-83 10:23")    (COND      (offFlg (SETALLSYNTAX @ OTHER)	      (SETALLSYNTAX $ OTHER))      (T                                                     (* Set break characters for read macros.)	 (SETALLSYNTAX @(MACRO FIRST AtMacro))	 (SETALLSYNTAX $ (MACRO FIRST DollarMacro])(PrettyPrintInstance  [LAMBDA (self file)                                        (* dgb: " 4-OCT-83 11:38")                                                             (* PrettyPrint an self definition on file.)    (AND self (&larr; self FileOut file))    self])(SETALLSYNTAX  [NLAMBDA (CHAR FORM)                                       (* dgb: "23-DEC-83 13:51")    (SETSYNTAX CHAR FORM)    (SETSYNTAX CHAR FORM T)    (SETSYNTAX CHAR FORM FILERDTBL)    (SETSYNTAX CHAR FORM EDITRDTBL)    (SETSYNTAX CHAR FORM DEDITRDTBL])(TRANS@$  [LAMBDA NIL                                                (* dgb: " 4-JUN-83 17:05")                                                             (* Fix atoms which start with @ and $ to be list form)    (AND (LITATOM FAULTX)	 (Fix@$ FAULTX TAIL]))(* * Prettyprinting functions)(RPAQQ PPFNS (DEFCLASS DEFCLASSES DEFINST DEFINSTANCES DollarPrintOut EntityAddress 		       GetClassValuePrintOut GetValuePrintOut LoopsPPMacros PCVPrintOut PInstance 		       PVPrintOut PrettyPrintClass PrintActiveValue PrintClass PrintDefInstances 		       PrintInstance PrintOut@ PrintOut@@ PrintOut&larr;@ PrintOut&larr;@@ PrttyClasses 		       PrttyInstances PushClassValuePrintOut PushValuePrintOut PutClassValuePrintOut 		       PutValuePrintOut SplitAtom VarPrintOut))(DEFINEQ(DEFCLASS  [NLAMBDA FORM                                              (* dgb: " 7-OCT-82 16:50")          (* * Used by file package to define a class. DEFCLASS is CAR of defining form)    (PROG ((className (CAR FORM))	   (source (CDR FORM)))          (COND	    ((OR (NULL source)		 (NULL className))                           (* Ignore empty class definitions)	      (RETURN NIL))	    ((NOT (LITATOM className))	      (HELPCHECK className " cannot be a class name.Type OK to ignore.")	      (RETURN NIL)))          (COND	    ((NULL (GetClassRec className))                  (* Usually an error. class record should have previously							     been created.)	      (HELPCHECK "No exisiting class of with name: " className 			 "Type OK to define one and go on")	      (NewClass className)))          (COND	    [(CheckClassSource source className)             (* Dont't install the class if there are errors.)	      (COND		((STKPOS (QUOTE EditClassSource))            (* Bounce back to editor)		  (ERROR className " not defined  -- bad form " T))		(T (WRITE className "not installed because of error in source"]	    (T (InstallClassSource className source])(DEFCLASSES  [NLAMBDA CLASSES                                           (* dgb: "21-JUN-82 13:09")          (* * Used by the file package. When a form (DEFCLASSES c1 c2 --) is read in, class records for c1, c2, -- are 	  created. This allows the real class definitions to be read in in any order.)    (MAPC CLASSES (FUNCTION (LAMBDA (className)	      (OR (GetClassRec className)		  (NewEntity (create class				     className &larr; className				     classChangedFlg &larr; T)			     className])(DEFINST  [NLAMBDA DEFINST% FORM                                     (* dgb: " 4-OCT-83 10:07")                                                             (* Defining form for instances on a file)    (&larr; [OR (GetClassRec (CAR DEFINST% FORM))	   (PROGN (printout T (CAR DEFINST% FORM)			    " has no class defined for it" T "Defining one now:" T)		  (&larr; ($ Class)		     New		     (CAR DEFINST% FORM]       FileIn       (CDR DEFINST% FORM])(DEFINSTANCES  [NLAMBDA Instances                                         (* dgb: "19-NOV-82 16:57")          (* Read In the list of named instances, creating a new object with the named UID. Make sure it has other names as 	  given in the list. This insures that other later references point to this same instance.)    (MAPC Instances (FUNCTION (LAMBDA (classNameInstNames)	      (PROG (instNames className UID obj)		    [COND		      [(NLISTP (SETQ className (CDR classNameInstNames)))                                                             (* Old format input. UID passed as NIL to NewObject)			(SETQ instNames (LIST (CAR classNameInstNames]		      (T (SETQ className (CAR classNameInstNames))			 (SETQ instNames (REVERSE (CDR classNameInstNames)))			 (SETQ UID (MKNAME (pop instNames]		    (COND		      ((NULL className)			(RETURN)))		    (NameObject (NewObject (GetObjectRec className)					   UID)				instNames])(DollarPrintOut  [LAMBDA (X)                                                (* dgb: "19-NOV-81 23:27")          (* * This is called by PRETTYPRINT when it sees a form X starting with the atom GetClassRec.	  It causes this form to be printed out as "$name" in just those cases where the form is (GetObjectRec 	  (QUOTE name)))    (COND      ((AND (LISTP (CDR X))	    (NULL (CDDR X)))	(PRIN1 "$")	(PRIN1 (CADR X))	NIL)      (T X])(EntityAddress  [LAMBDA (E)                                                (* dgb: "11-NOV-82 02:29")    (LOC E])(GetClassValuePrintOut  [LAMBDA (X)                                                (* DECLARATIONS: (RECORD GCV 							     (GV obj var prop)))                                                             (* mjs: " 2-AUG-82 17:28")          (* * This is called by PRETTYPRINT when it sees a form X starting with the atom GetClassValue.	  It causes this form to be printed out as "@@varName" in just those cases where the form is 	  (GetClassValue self (QUOTE varName)) and as "@@(exp varName prop)" in those cases where the form is 	  (GetClassValue exp (QUOTE varName) (QUOTE prop)) where prop is optional)    (PROG ((obj (fetch obj of X))	   (var (fetch var of X))	   (prop (fetch prop of X)))          (COND	    ([OR (NEQ (CAR var)		      (QUOTE QUOTE))		 (AND prop (NEQ (CAR prop)				(QUOTE QUOTE]	      (RETURN X)))          (VarPrintOut "@@" obj (CADR var)		       (CADR prop))          (RETURN NIL])(GetValuePrintOut  [LAMBDA (X)                                                (* DECLARATIONS: (RECORD GV (GetValue obj var prop)))                                                             (* dgb: "27-JAN-82 17:21")          (* * This is called by PRETTYPRINT when it sees a form X starting with the atom GetValue. It causes this form to 	  be printed out as "@varName" in just those cases where the form is (GetValue self (QUOTE varName.)) and as 	  "@(exp varName prop)" in those cases where the form is (GetValue exp (QUOTE varName) (QUOTE prop)) where prop is 	  optional)    (PROG ((obj (fetch obj of X))	   (var (fetch var of X))	   (prop (fetch prop of X)))          (COND	    ([OR (NEQ (CAR var)		      (QUOTE QUOTE))		 (AND prop (NEQ (CAR prop)				(QUOTE QUOTE]	      (RETURN X)))          (VarPrintOut "@" obj (CADR var)		       (CADR prop))          (RETURN NIL])(LoopsPPMacros  [LAMBDA (onFlg)                                            (* dgb: "11-FEB-83 01:15")                                                             (* Turns on the prettypprint macros in 							     PRETTYPRINTMACROS)    (COND      (onFlg (ADDTOVAR PRETTYPRINTMACROS (PushValue . PushValuePrintOut)		       (PushClassValue . PushClassValuePrintOut)		       (%@ . PrintOut%@)		       (%@%@ . PrintOut%@%@)		       (&larr;%@ . PrintOut&larr;%@)		       (&larr;%@%@ . PrintOut&larr;%@%@)		       (%$ . DollarPrintOut)))      (T (for x in (QUOTE (PushValue PushClassValue %@ %@%@ &larr;%@ &larr;%@%@ %$)) do (SETQ PRETTYPRINTMACROS										(DELASSOC x 										PRETTYPRINTMACROS])(PCVPrintOut  [LAMBDA (X infix)                                          (* DECLARATIONS: (RECORD PCV 							     (PV obj var newV prop)))                                                             (* mjs: " 2-AUG-82 17:21")          (* * This is called by PRETTYPRINT when it sees a form X starting with the atom PutClassValue.	  Prints out forms as in GetClassValue forllowed by &larr; or &larr;+ and new expression)    (PROG ((obj (fetch obj of X))	   (var (fetch var of X))	   (newV (fetch newV of X))	   (prop (fetch prop of X)))          (COND	    ([OR (NEQ (CAR var)		      (QUOTE QUOTE))		 (AND prop (NEQ (CAR prop)				(QUOTE QUOTE]	      (RETURN X)))          (VarPrintOut "@@" obj (CADR var)		       (CADR prop))          (PRIN1 infix)          (PRINTDEF newV)          (RETURN NIL])(PInstance  [LAMBDA (inst file)                                        (* dgb: "19-JAN-83 10:56")          (* * Called to print an instance when doing the INSTANCES file pkg command.)    (PROG [(name (GetObjectName inst))	   [uid (COND		  ((type? instance inst)		    (UID inst T))		  (T (ERROR inst "does not have a uid"]	   (source (CDR (GetInstanceSource inst]          (RETURN (COND		    ((OR name (FMEMB uid UnnamedInstances)			 (NULL file))                        (* All object should simply be referred to by uid, 							     except if they are unnamed instances, and printing is 							     going to a real file.)		      (CONS "#$" (MKSTRING uid)))		    (T (SETQ UnnamedInstances (CONS uid UnnamedInstances))		       (printout file "#&amp;" .PPV source T T)		       T])(PVPrintOut  [LAMBDA (X infix)                                          (* DECLARATIONS: (RECORD PV (PutValue obj var newV prop)))                                                           (* dgb: "21-JAN-82 10:07")          (* * This is called by PRETTYPRINT when it sees a form X starting with the atom PutValue. Prints out forms as in 	  GetValue followed by &larr; or &larr;+ and new expression)    (PROG ((obj (fetch obj of X))	   (var (fetch var of X))	   (newV (fetch newV of X))	   (prop (fetch prop of X)))          (COND	    ([OR (NEQ (CAR var)		      (QUOTE QUOTE))		 (AND prop (NEQ (CAR prop)				(QUOTE QUOTE]	      (RETURN X)))          (VarPrintOut "@" obj (CADR var)		       (CADR prop))          (PRIN1 infix)          (PRINTDEF newV)          (RETURN NIL])(PrettyPrintClass  [LAMBDA (className file)                                   (* dgb: " 4-OCT-83 17:16")          (* * Called to prettyPrint a class definition on a file by the FILEPKGTYPE CLASSES and by the PP: method in Class)    (PROG (class)          (COND	    ((NULL (SETQ class (GetClassRec className)))	      (RETURN (HELPCHECK className 			    " is not defined as a class.Type OK to ignore this class and go on.")))	    (T (&larr; class FileOut file)))          (RETURN className])(PrintActiveValue  [LAMBDA (self file)                                        (* dgb: "19-Jun-84 15:04")                                                             (* This is called by the LISP PRINT function when it 							     sees an instance of the data type activeValue)    (PROG ((ls (fetch localState of self))	   (gf (fetch getFn of self))	   (pf (fetch putFn of self)))          (COND	    ([AND (OR (EQ pf (QUOTE StoreUnmarked))		      (EQ pf (QUOTE Temporary)))		  (NOT (OR (EQ T (OUTPUT))			   (DISPLAYSTREAMP file]             (* changing anything Temporary should not count as 							     changing the object Dont show the contents)	      (SETQ ls NIL)))          (RETURN (COND		    ((NULL file)          (* This is the case in which this function is being called to do internal printing for NCHARS, etc. We are faking 	  it out, perhaps wisely)		      (LIST "#(" ")"))		    ([AND (EQ gf (QUOTE DataType))			  (NOT (OR (EQ T (OUTPUT))				   (DISPLAYSTREAMP file]		      (PRIN1 "#-" file)		      (HPRINT ls file T T)		      T)		    (T                                       (* This is the usual case in which PrintActiveValue is 							     called. It prints "#(" then the prettyprinted list of 							     its parts)		       (printout file "#(" .PPVTL (LIST ls gf pf)				 ")"])(PrintClass  [LAMBDA (classRec file)                                    (* dgb: "17-MAR-82 11:39")          (* * This is called by the LISP PRINT function when it sees an instance of the data type class)    (CONS "#$" (fetch className of classRec])(PrintDefInstances  [LAMBDA (instances file)                                   (* dgb: " 5-OCT-82 10:50")          (* * Does the INSTANCES command for the LISP file pkg.)    (TERPRI file)    (PRIN1 "[DEFINSTANCES " file)    (for inst instRec in instances do (SETQ instRec (GetObjectRec inst))				      (PRIN2 (CONS (ClassName instRec)						   (GetObjectNames instRec))					     file)				      (SPACES 1 file))    (PRIN1 "]" file)    (TERPRI file)    (TERPRI file)    instances])(PrintInstance  [LAMBDA (instanceRec file)                                 (* dgb: "15-Jun-84 22:47")          (* * This is called by the LISP PRINT function when it sees an instance of the data type instance)    (DECLARE (SPECVARS FileEntities OutInstances WritingSummaryFlg WritingLayerFlg))    (PROG (entity uid uidString)          [COND	    ((OR (EQ file T)		 (DISPLAYSTREAMP file))                      (* for local human consumption)	      (&larr; instanceRec PrintOn file)	      (RETURN instanceRec))	    ((OR file OutInstances WritingSummaryFlg WritingLayerFlg)                                                             (* Force items being saved to have a uid)	      (SETQ uid (UID instanceRec]          (RETURN (COND		    (OutInstances                            (* This case when dumping instances to a file with 							     INSTANCES)				  (OR (MEMBER uid (CAR OutInstances))				      (TCONC OutInstances uid))                                                             (* REcursive dump of instances referred to)				  (CONS "#&amp;" (LIST (ClassName instanceRec)						   uid)))		    (WritingSummaryFlg                       (* Here if writing a summary layer)				       (OR (MEMBER (SETQ entity (GetEntityFromUID uid))						   (CAR FileEntities))					   (TCONC FileEntities entity))				       (CONS "#$" uid))		    (WritingLayerFlg                         (* Here if currently writing out on layerFile)				     (CONS "#$" uid))		    (T                                       (* Internal printing)		       (CONS "#&amp;" (LIST (ClassName instanceRec)					uid])(PrintOut%@  [LAMBDA (X)                                                (* dgb: "20-SEP-82 15:35")    (COND      ((NLISTP (CDR X))                                      (* Prettyprint macro form)	X)      (T [COND	   ((NULL (CDDR X))	     (VarPrintOut "@" (QUOTE self)			  (CADR X)))	   (T (VarPrintOut "@" (CADR X)			   (CADDR X)			   (CADDDR X]	 NIL])(PrintOut%@%@  [LAMBDA (X)                                                (* dgb: "20-SEP-82 15:36")    (COND      ((NLISTP (CDR X))	X)      (T [COND	   ((NULL (CDDR X))	     (VarPrintOut "@@" (QUOTE self)			  (CADR X)))	   (T (VarPrintOut "@@" (CADR X)			   (CADDR X)			   (CADDDR X]	 NIL])(PrintOut&larr;%@  [LAMBDA (X)                                                (* dgb: "20-SEP-82 15:40")          (* * This is called by PRETTYPRINT when it sees a form X starting with the atom &larr;%@. Prints out forms as in %@ 	  followed by &larr; and new expression)    (COND      ((NLISTP (CDR X))                                      (* Prettyprint macro form)	X)      (T (PROG [(newV (CAR (LAST X]	       (SELECTQ (LENGTH (SETQ X (CDR X)))			(2 (VarPrintOut "@" (QUOTE self)					(CAR X)))			(3 (VarPrintOut "@" (CAR X)					(CADR X)))			(VarPrintOut "@" (CAR X)				     (CADR X)				     (CADDR X)))	       (PRIN1 "&larr;")	       (PRINTDEF newV)	       (RETURN NIL])(PrintOut&larr;%@%@  [LAMBDA (X)                                                (* dgb: "20-SEP-82 15:45")          (* * This is called by PRETTYPRINT when it sees a form X starting with the atom &larr;%@%@. Prints out forms as in %@%@	  followed by &larr; and new expression)    (COND      ((NLISTP (CDR X))                                      (* Prettyprint Macro)	X)      (T (PROG [(newV (CAR (LAST X]	       (SELECTQ (LENGTH (SETQ X (CDR X)))			(2 (VarPrintOut "@@" (QUOTE self)					(CAR X)))			(3 (VarPrintOut "@@" (CAR X)					(CADR X)))			(VarPrintOut "@@" (CAR X)				     (CADR X)				     (CADDR X)))	       (PRIN1 "&larr;")	       (PRINTDEF newV)	       (RETURN NIL])(PrttyClasses  [LAMBDA (classes)                                          (* dgb: "22-MAR-82 15:02")          (* * Used by CLASSES command to print out rereadable versions of class definitions on files)    (PRINT (CONS (QUOTE DEFCLASSES)		 classes)	   PRTTYFILE)    (TERPRI PRTTYFILE)    (for className in classes do (PrettyPrintClass className PRTTYFILE])(PrttyInstances  [LAMBDA (instances)                                        (* dgb: "25-Jun-84 14:24")          (* * Prettyprint a list of named instances to a file. OutInstances is bound here, although usually a free variable	  when printing an instance)    (PROG [(OutInstances (LCONC NIL (for name obj in instances collect (UID obj)				       when (SETQ obj (OR (GetObjectRec name)							  (NULL (HELPCHECK name 				      " not defined as an instance.Type OK to ignore and go on."]          (DECLARE (SPECVARS OutInstances))          (for nm in (CAR OutInstances) bind obj	     do (PrettyPrintInstance (GetObjectRec nm)				     PRTTYFILE)		(TERPRI PRTTYFILE)		(TERPRI PRTTYFILE])(PushClassValuePrintOut  [LAMBDA (X)                                                (* dgb: "30-NOV-81 11:05")    (PCVPrintOut X "&larr;+"])(PushValuePrintOut  [LAMBDA (X)                                                (* dgb: "30-NOV-81 11:05")    (PVPrintOut X "&larr;+"])(PutClassValuePrintOut  [LAMBDA (X)                                                (* dgb: "11-DEC-81 23:01")    (PCVPrintOut X "&larr;"])(PutValuePrintOut  [LAMBDA (X)                                                (* mjs: " 4-JAN-82 10:52")    (PVPrintOut X "&larr;"])(SplitAtom  [LAMBDA (atom splitChar)                                   (* dgb: "22-JUN-82 11:14")          (* * Used to split method names etc at splitChar. Takes an atom and a char and returns a list of two atoms.	  e.g. SplitAtom (A.B %.) -&gt; (A B) Returns NIL if splitChar is not in atom)    (PROG ((pos (STRPOS splitChar atom)))          (RETURN (COND		    ((NULL pos)		      NIL)		    (T (CONS (SUBATOM atom 1 (SUB1 pos))			     (SUBATOM atom (ADD1 pos])(VarPrintOut  [LAMBDA (prefix obj var prop)                              (* dgb: "31-MAR-82 16:45")                                                             (* Prints out form for variable)    (SPACES 1)                                               (* This space is to protect against butting up against 							     another atom, and making the prefix read macro lose)    (COND      ((AND (NULL prop)	    (EQ obj (QUOTE self)))	(PRIN1 (CONCAT prefix var)))      (T (PRIN1 (CONCAT prefix "("))	 (PRINTDEF obj)	 (SPACES 1)	 (PRIN1 var)	 (COND	   (prop (SPACES 1)		 (PRIN1 prop)))	 (PRIN1 ")"]))(* This defines what is to happen when the command (CLASSES * CLASSNAMES) appears in a coms list.)(PUTDEF (QUOTE INSTANCES) (QUOTE FILEPKGCOMS) (QUOTE ([COM MACRO (INSTANCES							     (E (PrttyInstances (QUOTE INSTANCES]						      (TYPE DESCRIPTION "instances" GETDEF 							    GetInstanceSource))))(PUTDEF (QUOTE METHODS) (QUOTE FILEPKGCOMS) (QUOTE ((COM MACRO (X (COMS * (METHCOM . X)))							 CONTENTS TypeInMethods)						    (TYPE DESCRIPTION "methods" GETDEF 							  GetInstanceSource))))(PUTDEF (QUOTE CLASSES) (QUOTE FILEPKGCOMS) (QUOTE					      ([COM MACRO						    (CLASSLIST (P (DEFCLASSES . CLASSLIST))							       (E (MAPC (QUOTE CLASSLIST)									(FUNCTION PrettyPrintClass]					       (TYPE DESCRIPTION "class definitions" GETDEF 						     GetClassSource DELDEF RemoveClassDef))))(* The following defines class, classes, and CLASS as synonyms for CLASSES with respect to the file package type. Set up macros so that references to classes and instances seen by HPRINT don't recur into their structure.)(ADDTOVAR FILEPKGTYPES (class . CLASSES)		       (classes . CLASSES)		       (CLASS . CLASSES)		       (INSTANCE INSTANCES)		       (instance INSTANCES))(ADDTOVAR HPRINTMACROS (class . HPRINTCLASS)		       (instance . HPRINTINSTANCE))(* Set Up Loops Read Macros for ,@, and $)(SETALLSYNTAX %# (MACRO FIRST HashMacro))(RPAQQ LOOPSPRINTADVICE (HPINITRDTBL))(PUTPROPS HPINITRDTBL READVICE (NIL (AFTER NIL (SETSYNTAX 35 ' (MACRO FIRST HashMacro)							  HPRINTRDTBL))))(ADDTOVAR DWIMUSERFORMS (TRANS@$))(DECLARE: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA DEFINSTANCES DEFINST DEFCLASSES DEFCLASS)(ADDTOVAR NLAML SETALLSYNTAX)(ADDTOVAR LAMA ))(PUTPROPS LOOPSPRINT COPYRIGHT ("Xerox Corporation" 1983 1984))(DECLARE: DONTCOPY  (FILEMAP (NIL (3281 3704 (PPObj 3291 . 3702)) (4145 14157 (AtMacro 4155 . 7065) (AtMacroConstruct 7067 . 8145) (DataType 8147 . 8412) (DollarMacro 8414 . 8848) (GetLispClass 8850 . 9195) (HPRINTCLASS 9197 . 9546) (HPRINTINSTANCE 9548 . 9923) (HREADCLASS 9925 . 10064) (HREADINSTANCE 10066 . 10216) (HashMacro 10218 . 12290) (InitializeLOOPS 12292 . 12934) (LoopsSyntax 12936 . 13330) (PrettyPrintInstance 13332 . 13605) (SETALLSYNTAX 13607 . 13880) (TRANS@$ 13882 . 14155)) (14673 32962 (DEFCLASS 14683 . 15897) (DEFCLASSES 15899 . 16415) (DEFINST 16417 . 16880) (DEFINSTANCES 16882 . 17848) (DollarPrintOut 17850 . 18312) (EntityAddress 18314 . 18437) (GetClassValuePrintOut 18439 . 19426) (GetValuePrintOut 19428 . 20382) (LoopsPPMacros 20384 . 21088) (PCVPrintOut 21090 . 21957) (PInstance 21959 . 22783) (PVPrintOut 22785 . 23626) (PrettyPrintClass 23628 . 24137) (PrintActiveValue 24139 . 25533) (PrintClass 25535 . 25809) (PrintDefInstances 25811 . 26329) (PrintInstance 26331 . 27973) (PrintOut@ 27975 . 28358) (PrintOut@@ 28360 . 28679) (PrintOut&larr;@ 28681 . 29387) (PrintOut&larr;@@ 29389 . 30098) (PrttyClasses 30100 . 30494) (PrttyInstances 30496 . 31251) (PushClassValuePrintOut 31253 . 31402) (PushValuePrintOut 31404 . 31547) (PutClassValuePrintOut 31549 . 31696) (PutValuePrintOut 31698 . 31839) (SplitAtom 31841 . 32327) (VarPrintOut 32329 . 32960)))))STOP</pre>
  </body>
</html>
